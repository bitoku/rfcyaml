- title: __initial_text__
  contents:
  - '        RTP Payload Format for Generic Forward Error Correction

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a payload format for generic Forward Error\n\
    \   Correction (FEC) for media data encapsulated in RTP.  It is based on\n   the\
    \ exclusive-or (parity) operation.  The payload format described in\n   this document\
    \ allows end systems to apply protection using various\n   protection lengths\
    \ and levels, in addition to using various\n   protection group sizes to adapt\
    \ to different media and channel\n   characteristics.  It enables complete recovery\
    \ of the protected\n   packets or partial recovery of the critical parts of the\
    \ payload\n   depending on the packet loss situation.  This scheme is completely\n\
    \   compatible with non-FEC-capable hosts, so the receivers in a\n   multicast\
    \ group that do not implement FEC can still work by simply\n   ignoring the protection\
    \ data.  This specification obsoletes RFC 2733\n   and RFC 3009.  The FEC specified\
    \ in this document is not backward\n   compatible with RFC 2733 and RFC 3009.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \   2. Terminology .....................................................5\n  \
    \ 3. Basic Operation .................................................6\n   4.\
    \ Parity Codes ....................................................7\n   5. Uneven\
    \ Level Protection (ULP) ...................................7\n   6. RTP Media\
    \ Packet Structure ......................................9\n   7. FEC Packet Structure\
    \ ............................................9\n      7.1. Packet Structure ...........................................9\n\
    \      7.2. RTP Header for FEC Packets ................................10\n  \
    \    7.3. FEC Header for FEC Packets ................................11\n    \
    \  7.4. FEC Level Header for FEC Packets ..........................12\n   8. Protection\
    \ Operation ...........................................15\n      8.1. Generation\
    \ of the FEC Header ..............................15\n      8.2. Generation of\
    \ the FEC Payload .............................16\n   9. Recovery Procedures ............................................16\n\
    \      9.1. Reconstruction of the RTP Header ..........................16\n  \
    \    9.2. Reconstruction of the RTP Payload .........................18\n   10.\
    \ Examples ......................................................19\n      10.1.\
    \ An Example Offers Similar Protection as RFC 2733 .........19\n      10.2. An\
    \ Example with Two Protection Levels ....................21\n      10.3. An Example\
    \ with FEC as Redundant Coding ..................26\n   11. Security Considerations\
    \ .......................................29\n   12. Congestion Considerations\
    \ .....................................30\n   13. IANA Considerations ...........................................31\n\
    \      13.1. Registration of audio/ulpfec .............................31\n  \
    \    13.2. Registration of video/ulpfec .............................32\n    \
    \  13.3. Registration of text/ulpfec ..............................34\n      13.4.\
    \ Registration of application/ulpfec .......................35\n   14. Multiplexing\
    \ of FEC ...........................................36\n      14.1. FEC as a Separate\
    \ Stream .................................36\n      14.2. FEC as Redundant Encoding\
    \ ................................38\n      14.3. Offer / Answer Consideration\
    \ .............................39\n   15. Application Statement .........................................40\n\
    \   16. Acknowledgments ...............................................42\n  \
    \ 17. References ....................................................42\n    \
    \  17.1. Normative References .....................................42\n      17.2.\
    \ Informative References ...................................43\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The nature of real-time applications implies that they usually\
    \ have\n   more stringent delay requirements than normal data transmissions. \
    \ As\n   a result, retransmission of the lost packets is generally not a valid\n\
    \   option for such applications.  In these cases, a better method to\n   attempt\
    \ recovery of information from packet loss is through Forward\n   Error Correction\
    \ (FEC).  FEC is one of the main methods used to\n   protect against packet loss\
    \ over packet-switched networks\n   [9, 10].  In particular, the use of traditional\
    \ error correcting\n   codes, such as parity, Reed-Solomon, and Hamming codes,\
    \ has seen much\n   application.  To apply these mechanisms, protocol support\
    \ is\n   required.  RFC 2733 [9] and RFC 3009 [11] defined one of such FEC\n \
    \  protocols.  However, in these two RFCs a few fields (the P, X, and CC\n   fields)\
    \ in the RTP header are specified in ways that are not\n   consistent as they\
    \ are designed in RTP [1].  This prevents the\n   payload-independent validity\
    \ check of the RTP packets.\n   This document extends the FEC defined in RFC 2733\
    \ and RFC 3009 to\n   include unequal error protection on the payload data.  It\
    \ specifies a\n   general algorithm with the two previous RFCs as its special\
    \ cases.\n   This specification also fixes the above-mentioned inconsistency with\n\
    \   RFC 2733 and RFC 3009, and will obsolete those two previous RFCs.\n   Please\
    \ note that the payload specified in this document is not\n   backward compatible\
    \ with RFC 2733 and RFC 3009.  Because the payload\n   specified in this document\
    \ is signaled by different MIMEs from those\n   of RFC 3009, there is no concern\
    \ of misidentification of different\n   parity FEC versions in capacity exchange.\
    \  For parity FECs specified\n   here and in RFC 2733 and RFC 3009, the payload\
    \ data are unaltered and\n   additional FEC data are sent along to protect the\
    \ payload data.\n   Hence, the communication of the payload data would flow without\n\
    \   problem between hosts of different parity FEC versions and hosts that\n  \
    \ did not implement parity FEC.  The receiving hosts with incompatible\n   FEC\
    \ from the sending host would not be able to benefit from the\n   additional FEC\
    \ data, so it is recommended that existing host\n   implementing RFC 2733 and\
    \ RFC 3009 should be updated to follow this\n   specification when possible.\n\
    \   This document defines a payload format for RTP [1] that allows for\n   generic\
    \ forward error correction of real-time media.  In this\n   context, generic means\
    \ that the FEC protocol is (1) independent of\n   the nature of the media being\
    \ protected, be it audio, video, or\n   otherwise; (2) flexible enough to support\
    \ a wide variety of FEC\n   configurations; (3) designed for adaptivity so that\
    \ the FEC technique\n   can be modified easily without out-of-band signaling;\
    \ and (4)\n   supportive of a number of different mechanisms for transporting\
    \ the\n   FEC packets.\n   Furthermore, in many scenarios the bandwidth of the\
    \ network\n   connections is a very limited resource.  On the other hand, most\
    \ of\n   the traditional FEC schemes are not designed for optimal utilization\n\
    \   of the limited bandwidth resource.  An often used improvement is\n   unequal\
    \ error protection that provides different levels of protection\n   for different\
    \ parts of the data stream, which vary in importance.\n   The unequal error protection\
    \ schemes can usually make more efficient\n   use of bandwidth to provide better\
    \ overall protection of the data\n   stream against the loss.  Proper protocol\
    \ support is essential for\n   realizing these unequal error protection mechanisms.\
    \  The application\n   of most of the unequal error protection schemes requires\
    \ having the\n   knowledge of the importance for different parts of the data stream.\n\
    \   For that reason, most of such schemes are designed for particular\n   types\
    \ of media according to the structure of the media protected, and\n   as a result,\
    \ are not generic.\n   The FEC algorithm and protocol are defined in this document\
    \ for\n   generic forward error correction with unequal error protection for\n\
    \   real-time media.  The particular algorithm defined here is called the\n  \
    \ Uneven Level Protection (ULP).  The payload data are protected by one\n   or\
    \ more protection levels.  Lower protection levels can provide\n   greater protection\
    \ by using smaller group sizes (compared to higher\n   protection levels) for\
    \ generating the FEC packet.  As we will discuss\n   below, audio/video applications\
    \ would generally benefit from unequal\n   error protection schemes that give\
    \ more protection to the beginning\n   part of each packet such as ULP.  The data\
    \ that are closer to the\n   beginning of the packet are in general more important\
    \ and tend to\n   carry more information than the data farther behind in the packet.\n\
    \   It is well known that in many multimedia streams the more important\n   parts\
    \ of the data are always at the beginning of the data packet.\n   This is the\
    \ common practice in codec design since the beginning of\n   the packet is closer\
    \ to the re-synchronization marker at the header\n   and thus is more likely to\
    \ be correctly decoded.  In addition, almost\n   all media formats have the frame\
    \ headers at the beginning of the\n   packet, which is the most vital part of\
    \ the packet.\n   For video streams, most modern formats have optional data\n\
    \   partitioning modes to improve error resilience in which the video\n   macroblock\
    \ header data, motion vector data, and Discrete Cosine\n   Transform (DCT) coefficient\
    \ data are separated into their individual\n   partitions.  For example, in ITU-T\
    \ H.263 version 3, there is the\n   optional data partitioned syntax of Annex\
    \ V.  In MPEG-4 Visual Simple\n   Profile, there is the optional data partitioning\
    \ mode.  When these\n   modes are enabled, the video macroblock (MB) header and\
    \ motion vector\n   partitions (which are much more important to the quality of\
    \ the video\n   reconstruction) are transmitted in the partition(s) at the beginning\n\
    \   of the video packet while residue DCT coefficient partitions (which\n   are\
    \ less important) are transmitted in the partition close to the end\n   of the\
    \ packet.  Because the data is arranged in descending order of\n   importance,\
    \ it would be beneficial to provide more protection to the\n   beginning part\
    \ of the packet in transmission.\n   For audio streams, the bitstreams generated\
    \ by many of the new audio\n   codecs also contain data with different classes\
    \ of importance.  These\n   different classes are then transmitted in order of\
    \ descending\n   importance.  Applying more protection to the beginning of the\
    \ packet\n   would also be beneficial in these cases.  Even for uniform-\n   significance\
    \ audio streams, various time shifting and stretching\n   techniques can be applied\
    \ to the partially recovered audio data\n   packets.\n   Audio/video applications\
    \ would generally benefit from the FEC\n   algorithms specified in this document.\
    \  With ULP, the efficiency of\n   the protection of the media payload can potentially\
    \ be further\n   improved.  This document specifies the protocol and algorithm\
    \ for\n   applying the generic FEC to the RTP media payloads.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The following terms are used throughout this document:\n\
    \   Media Payload: The raw, unprotected user data that are transmitted\n   from\
    \ the sender.  The media payload is placed inside of an RTP\n   packet.\n   Media\
    \ Header: The RTP header for the packet containing the media\n   payload.\n  \
    \ Media Packet: The combination of a media payload and media header is\n   called\
    \ a media packet.\n   FEC Packet: The FEC algorithms at the transmitter take the\
    \ media\n   packets as an input.  They output both the media packets that they\n\
    \   are passed, and newly generated packets called FEC packets, which\n   contain\
    \ redundant media data used for error correction.  The FEC\n   packets are formatted\
    \ according to the rules specified in this\n   document.\n   FEC Header: The header\
    \ information contained in an FEC packet.\n   FEC Level Header: The header information\
    \ contained in an FEC packet\n   for each level.\n   FEC Payload: The payload\
    \ of an FEC packet.  It may be divided into\n   multiple levels.\n   Associated:\
    \ A FEC packet is said to be \"associated\" with one or more\n   media packets\
    \ (or vice versa) when those media packets are used to\n   generate the FEC packet\
    \ (by use of the exclusive-or operation).  It\n   refers to only those packets\
    \ used to generate the level 0 FEC\n   payload, if not explicitly stated otherwise.\n\
    \   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\"\
    ,\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in\
    \ this\n   document are to be interpreted as described in RFC 2119 [2].\n"
- title: 3.  Basic Operation
  contents:
  - "3.  Basic Operation\n   The payload format described here is used when the sender\
    \ in an RTP\n   session would like to protect the media stream it is sending with\n\
    \   generic parity FEC.  The FEC supported by this format is based on\n   simple\
    \ exclusive-or (XOR) parities operation.  The sender takes the\n   packets from\
    \ the media stream requiring protection and determines the\n   protection levels\
    \ for these packets and the protection length for\n   each level.  The data are\
    \ grouped together as described below in\n   Section 7.  The XOR operation is\
    \ applied across the payload to\n   generate the FEC information.  The results\
    \ following the procedures\n   defined here are RTP packets containing FEC information.\
    \  These\n   packets can be used at the receiver to recover the packets or parts\n\
    \   of the packets used to generate the FEC information.\n   The payload format\
    \ for FEC contains information that allows the\n   sender to tell the receiver\
    \ exactly which media packets are protected\n   by the FEC packet, and the protection\
    \ levels and lengths for each of\n   the levels.  Specifically, each FEC packet\
    \ contains an offset mask\n   m(k) for each protection level k.  If the bit i\
    \ in the mask m(k) is\n   set to 1, then media packet number N + i is protected\
    \ by this FEC\n   packet at level k.  N is called the sequence number base, and\
    \ is sent\n   in the FEC packet as well.  The amount of data that is protected\
    \ at\n   level k is indicated by L(k), which is also sent in the FEC packet.\n\
    \   The protection length, offset mask, payload type, and sequence number\n  \
    \ base fully identify the parity code applied to generate the FEC\n   packet with\
    \ little overhead.  A set of rules is described in Section\n   7.4 that defines\
    \ how the mask should be set for different protection\n   levels, with examples\
    \ in Section 10.\n   This document also describes procedures on transmitting all\
    \ the\n   protection operation parameters in-band.  This allows the sender\n \
    \  great flexibility; the sender can adapt the protection to current\n   network\
    \ conditions and be certain the receivers can still make use of\n   the FEC for\
    \ recovery.\n   At the receiver, both the FEC and original media are received.\
    \  If no\n   media packets are lost, the FEC packets can be ignored.  In the event\n\
    \   of a loss, the FEC packets can be combined with other received media\n   to\
    \ recover all or part of the missing media packets.\n"
- title: 4.  Parity Codes
  contents:
  - "4.  Parity Codes\n   For brevity, we define the function f(x,y,..) to be the\
    \ XOR (parity)\n   operator applied to the data blocks x,y,...  The output of\
    \ this\n   function is another block, called the parity block.  For simplicity,\n\
    \   we assume here that the parity block is computed as the bitwise XOR\n   of\
    \ the input blocks.  The exact procedure is specified in Section 8.\n   Protection\
    \ of data blocks using parity codes is accomplished by\n   generating one or more\
    \ parity blocks over a group of data blocks.  To\n   be most effective, the parity\
    \ blocks must be generated by linearly\n   independent combinations of data blocks.\
    \  The particular combination\n   is called a parity code.  The payload format\
    \ uses XOR parity codes.\n   For example, consider a parity code that generates\
    \ a single parity\n   block over two data blocks.  If the original media packets\
    \ are\n   a,b,c,d, the packets generated by the sender are:\n      a        b\
    \        c        d               <-- media stream\n                 f(a,b)  \
    \          f(c,d)        <-- FEC stream\n   where time increases to the right.\
    \  In this example, the error\n   correction scheme (we use the terms scheme and\
    \ code interchangeably)\n   introduces a 50% overhead.  But if b is lost, a and\
    \ f(a,b) can be\n   used to recover b.\n   It may be useful to point out that\
    \ there are many other types of\n   forward error correction codes that can also\
    \ be used to protect the\n   payload besides the XOR parity code.  One notable\
    \ example is Reed-\n   Solomon code, and there are many others [12].  However,\
    \ XOR parity\n   code is used here because of its effectiveness and simplicity\
    \ in both\n   protocol design and implementation.  This is particularly important\n\
    \   for implementation in nodes with limited resources.\n"
- title: 5.  Uneven Level Protection (ULP)
  contents:
  - "5.  Uneven Level Protection (ULP)\n   As we can see from the simple example above,\
    \ the protection on the\n   data depends on the size of the group.  In the above\
    \ example, the\n   group size is 2.  So if any one of the three packets (two payload\n\
    \   packets and one FEC packet) is lost, the original payload data can\n   still\
    \ be recovered.\n   In general, the FEC protection operation is a trade-off between\
    \ the\n   bandwidth and the protection strength.  The more FEC packets that are\n\
    \   generated as a fraction of the source media packets, the stronger the\n  \
    \ protection against loss but the greater the bandwidth consumed by the\n   combined\
    \ stream.\n   As is the common case in most of the media payload, not all the\
    \ parts\n   of the packets are of the same importance.  Using this property, one\n\
    \   can potentially achieve more efficient use of the channel bandwidth\n   using\
    \ unequal error protection, i.e., applying different protection\n   for different\
    \ parts of the packet.  More bandwidth is spent on\n   protecting the more important\
    \ parts, while less bandwidth on the less\n   important parts.\n   The packets\
    \ are separated into sections of decreasing importance, and\n   protection of\
    \ different strength is applied to each portion - the\n   sections are known as\
    \ \"levels\".  The protection operation is applied\n   independently at each level.\
    \  A single FEC packet can carry parity\n   data for multiple levels.  This algorithm\
    \ is called uneven level\n   protection, or ULP.\n   The protection of ULP is\
    \ illustrated in Figure 1 below.  In this\n   example, two ULP FEC packets are\
    \ protecting four payload packets.\n   ULP FEC packet #1 has only one level, which\
    \ protects packets A and B.\n   Instead of applying parity operation to the entire\
    \ packets of A and\n   B, it only protects a length of data of both packets. \
    \ The length,\n   which can be chosen and changed dynamically during a session,\
    \ is\n   called the protection length.\n   ULP FEC packet #2 has two protection\
    \ levels.  The level 0 protection\n   is the same as for ULP FEC packet #1 except\
    \ that it is operating on\n   packets C and D.  The level 1 protection is using\
    \ parity operation\n   applied on data from packets A, B, C, and D.  Note that\
    \ level 1\n   protection operates on a different set of packets from level 0 and\n\
    \   has a different protection length from level 0, so are any other\n   levels.\
    \  Information is all conveyed in-band through the protocols\n   specified in\
    \ this document.\n         Packet A          #####################\n         \
    \                         :        :\n         Packet B          ###############\
    \ :\n                                  :        :\n         ULP FEC Packet #1\
    \ @@@@@@@@        :\n                                  :        :\n         Packet\
    \ C          ###########     :\n                                  :        :\n\
    \         Packet D          ###################################\n            \
    \                      :        :\n         ULP FEC Packet #2 @@@@@@@@@@@@@@@@@\n\
    \                           :      :        :\n                           :<-L0->:<--L1-->:\n\
    \               Figure 1: Unequal Level Protection\n   As we have discussed in\
    \ the introduction, media streams usually have\n   the more important parts at\
    \ the beginning of the packet.  It is\n   usually useful to have the stronger\
    \ protection in the levels closer\n   to the beginning of the packet, and weaker\
    \ protection in the levels\n   farther back.  ULP algorithm provides such FEC\
    \ protection.\n   ULP FEC not only provides more protection to the beginning of\
    \ the\n   packet (which is more important), it also avoids as much as possible\n\
    \   the less efficient scenarios that an earlier section of a packet is\n   unrecoverable\
    \ while a later section can be recovered (and often has\n   to be discarded).\n"
- title: 6.  RTP Media Packet Structure
  contents:
  - "6.  RTP Media Packet Structure\n   The formatting of the media packets is unaffected\
    \ by FEC.  If the FEC\n   is sent as a separate stream, the media packets are\
    \ sent as if there\n   was no FEC.\n   This approach has the advantage that media\
    \ packets can be interpreted\n   by receivers that do not support FEC.  This compatibility\
    \ with\n   non-FEC capable receivers is particularly useful in the multicast\n\
    \   scenarios.  The overhead for using the FEC scheme is only present in\n   FEC\
    \ packets, and can be easily monitored and adjusted by tracking the\n   amount\
    \ of FEC in use.\n"
- title: 7.  FEC Packet Structure
  contents:
  - '7.  FEC Packet Structure

    '
- title: 7.1.  Packet Structure
  contents:
  - "7.1.  Packet Structure\n   A FEC packet is constructed by placing an FEC header\
    \ and one or more\n   levels of FEC header and payload into the RTP payload, as\
    \ shown in\n   Figure 2:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                RTP Header (12 octets or more)                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    FEC Header (10 octets)                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      FEC Level 0 Header                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     FEC Level 0 Payload                       |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      FEC Level 1 Header                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     FEC Level 1 Payload                       |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            Cont.                              |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 2: FEC Packet Structure\n"
- title: 7.2.  RTP Header for FEC Packets
  contents:
  - "7.2.  RTP Header for FEC Packets\n   The RTP header for FEC packets is only used\
    \ when the FEC are sent in\n   a separate stream from the protected payload stream\
    \ (as defined in\n   Section 14).  Hence, much of the discussion below applies\
    \ only to\n   that scenario.  All the fields in the RTP header of FEC packets\
    \ are\n   used according to RFC 3550 [1], with some of them further clarified\n\
    \   below.\n   Marker: This field is not used for this payload type, and SHALL\
    \ be\n   set to 0.\n   Synchronization Source (SSRC): The SSRC value SHALL be\
    \ the same as\n   the SSRC value of the media stream it protects.\n   Sequence\
    \ Number (SN): The sequence number has the standard definition\n   - it MUST be\
    \ one higher than the sequence number in the previously\n   transmitted FEC packet.\n\
    \   Timestamp (TS): The timestamp MUST be set to the value of the media\n   RTP\
    \ clock at the instant the FEC packet is transmitted.  Thus, the TS\n   value\
    \ in FEC packets is always monotonically increasing.\n   Payload type: The payload\
    \ type for the FEC packets is determined\n   through dynamic, out-of-band means.\
    \  According to RFC 3550 [1], RTP\n   participants that cannot recognize a payload\
    \ type must discard it.\n   This provides backward compatibility.  The FEC mechanisms\
    \ can then be\n   used in a multicast group with mixed FEC-capable and FEC-incapable\n\
    \   receivers, particularly when the FEC protection is sent as redundant\n   encoding\
    \ (see Section 14).  In such cases, the FEC protection will\n   have a payload\
    \ type that is not recognized by the FEC-incapable\n   receivers, and will thus\
    \ be disregarded.\n"
- title: 7.3.  FEC Header for FEC Packets
  contents:
  - "7.3.  FEC Header for FEC Packets\n   The FEC header is 10 octets.  The format\
    \ of the header is shown in\n   Figure 3 and consists of extension flag (E bit),\
    \ long-mask flag (L\n   bit), P recovery field, X recovery field, CC recovery\
    \ field, M\n   recovery field, PT recovery field, SN base field, TS recovery field,\n\
    \   and length recovery field.\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E|L|P|X|  CC   |M| PT recovery |            SN base            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          TS recovery                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        length recovery        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 3: FEC Header Format\n   The E bit is the extension\
    \ flag reserved to indicate any future\n   extension to this specification.  It\
    \ SHALL be set to 0, and SHOULD be\n   ignored by the receiver.\n   The L bit\
    \ indicates whether the long mask is used.  When the L bit is\n   not set, the\
    \ mask is 16 bits long.  When the L bit is set, the mask\n   is then 48 bits long.\n\
    \   The P recovery field, the X recovery field, the CC recovery field,\n   the\
    \ M recovery field, and the PT recovery field are obtained via the\n   protection\
    \ operation applied to the corresponding P, X, CC, M, and PT\n   values from the\
    \ RTP header of the media packets associated with the\n   FEC packet.\n   The\
    \ SN base field MUST be set to the lowest sequence number, taking\n   wrap around\
    \ into account, of those media packets protected by FEC (at\n   all levels). \
    \ This allows for the FEC operation to extend over any\n   string of at most 16\
    \ packets when the L field is set to 0, or 48\n   packets when the L field is\
    \ set to 1, and so on.\n   The TS recovery field is computed via the protection\
    \ operation\n   applied to the timestamps of the media packets associated with\
    \ this\n   FEC packet.  This allows the timestamp to be completely recovered.\n\
    \   The length recovery field is used to determine the length of any\n   recovered\
    \ packets.  It is computed via the protection operation\n   applied to the unsigned\
    \ network-ordered 16-bit representation of the\n   sums of the lengths (in bytes)\
    \ of the media payload, CSRC list,\n   extension and padding of each of the media\
    \ packets associated with\n   this FEC packet (in other words, the CSRC list,\
    \ RTP extension, and\n   padding of the media payload packets, if present, are\
    \ \"counted\" as\n   part of the payload).  This allows the FEC procedure to be\
    \ applied\n   even when the lengths of the protected media packets are not\n \
    \  identical.  For example, assume that an FEC packet is being generated\n   by\
    \ xor'ing two media packets together.  The length of the payload of\n   two media\
    \ packets is 3 (0b011) and 5 (0b101) bytes, respectively.\n   The length recovery\
    \ field is then encoded as 0b011 xor 0b101 = 0b110.\n"
- title: 7.4.  FEC Level Header for FEC Packets
  contents:
  - "7.4.  FEC Level Header for FEC Packets\n   The FEC level header is 4 or 8 octets\
    \ (depending on the L bit in the\n   FEC header).  The formats of the headers\
    \ are shown in Figure 4.\n   The FEC level headers consist of a protection length\
    \ field and a mask\n   field.  The protection length field is 16 bits long.  The\
    \ mask field\n   is 16 bits long (when the L bit is not set) or 48 bits long (when\
    \ the\n   L bit is set).\n   The mask field in the FEC level header indicates\
    \ which packets are\n   associated with the FEC packet at the current level. \
    \ It is either 16\n   or 48 bits depending on the value of the L bit.  If bit\
    \ i in the mask\n   is set to 1, then the media packet with sequence number N\
    \ + i is\n   associated with this FEC packet, where N is the SN Base field in\
    \ the\n   FEC packet header.  The most significant bit of the mask corresponds\n\
    \   to i=0, and the least significant to i=15 when the L bit is set to 0,\n  \
    \ or i=47 when the L bit is set to 1.\n    0                   1             \
    \      2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Protection Length       |             mask              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              mask cont. (present only when L = 1)             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 4: ULP Level Header Format\n   The setting of the mask\
    \ field shall follow the following rules:\n   a. A media packet SHALL be protected\
    \ only once at each protection\n      level higher than level 0.  A media packet\
    \ MAY be protected more\n      than once at level 0 by different packets, providing\
    \ the\n      protection lengths of level 0 of these packets are equal.\n   b.\
    \ For a media packet to be protected at level p, it MUST also be\n      protected\
    \ at level p-1 in any FEC packets.  Please note that the\n      protection level\
    \ p for a media packet can be in an FEC packet that\n      is different from the\
    \ one that contains protection level p-1 for\n      the same media packet.\n \
    \  c. If a ULP FEC packet contains protection at level p, it MUST also\n     \
    \ contain protection at level p-1.  Note that the combination of\n      payload\
    \ packets that are protected in level p may be different\n      from those of\
    \ level p-1.\n   The rationale for rule (a) is that multiple protection increases\
    \ the\n   complexity of the recovery implementation.  At higher levels, the\n\
    \   multiple protection offers diminishing benefit, so its application is\n  \
    \ restricted to level 0 for simpler implementation.  The rationale for\n   rule\
    \ (b) is that the protection offset (for each associated packet)\n   is not explicitly\
    \ signaled in the protocol.  With this restriction,\n   the offset can be easily\
    \ deducted from protection lengths of the\n   levels.  The rationale of rule (c)\
    \ is that the level of protection is\n   not explicitly indicated.  This rule\
    \ is set to implicitly specify the\n   levels.\n   One example of the protection\
    \ combinations is illustrated in Figure 5\n   below.  It is the same example as\
    \ shown in Figure 1.  This same\n   example is also shown in more detail in Section\
    \ 10.2 to illustrate\n   how the fields in the headers are set.\n         Packet\
    \ A          #####################\n                                  :      \
    \  :\n         Packet B          ############### :\n                         \
    \         :        :\n         ULP FEC Packet #1 @@@@@@@@        :\n         \
    \                         :        :\n         Packet C          ########### \
    \    :\n                                  :        :\n         Packet D      \
    \    ###################################\n                                  :\
    \        :\n         ULP FEC Packet #2 @@@@@@@@@@@@@@@@@\n                   \
    \        :      :        :\n                           :<-L0->:<--L1-->:\n   \
    \      Payload packet #  |  ULP FEC packet that protects at level\n          \
    \                 |          L0             L1\n      ---------------------+---------------------------------------\n\
    \                A          |          #1             #2\n                B  \
    \        |          #1             #2\n                C          |          #2\
    \             #2\n                D          |          #2             #2\n  \
    \         Figure 5: An Example of Protection Combination\n   In this example,\
    \ ULP FEC packet #1 only has protection level 0.  ULP\n   FEC packet #2 has protection\
    \ levels 0 and 1.  Read across the table,\n   it is shown that payload packet\
    \ A is protected by ULP FEC packet #1\n   at level 0, by ULP FEC packet #2 at\
    \ level 1, and so on.  Also, it can\n   be easily seen from the table that ULP\
    \ FEC packet #2 protects at\n   level 0 payload packets C and D, at level 1 payload\
    \ packets A-D, and\n   so on.  For additional examples with more details, please\
    \ refer to\n   Section 10, \"Examples\".\n   The payload of the ULP FEC packets\
    \ of each level is the protection\n   operation (XOR) applied to the media payload\
    \ and padding of the media\n   packets associated with the ULP FEC packet at that\
    \ level.  Details\n   are described in Section 8 on the protection operation.\n\
    \   The size of the ULP FEC packets is determined by the protection\n   lengths\
    \ chosen for the protection operation.  In the above example,\n   ULP FEC packet\
    \ #1 has length L0 (plus the header overhead).  ULP FEC\n   packet #2 with two\
    \ levels has length L0+L1 (plus the header\n   overhead).  It is longer than some\
    \ of the packets it protects\n   (packets B and C in this example), and is shorter\
    \ than some of the\n   packets it protects (packets A and D in this example).\n\
    \   Note that it's possible for the FEC packet (non-ULP and ULP) to be\n   larger\
    \ than the longest media packets it protects because of the\n   overhead from\
    \ the headers and/or if a large protection length is\n   chosen for ULP.  This\
    \ could cause difficulties if this results in the\n   FEC packet exceeding the\
    \ Maximum Transmission Unit size for the path\n   along which it is sent.\n"
- title: 8.  Protection Operation
  contents:
  - "8.  Protection Operation\n   FEC packets are formed from an \"FEC bit string\"\
    \ that is generated\n   from the data of the protected media RTP packets.  More\
    \ specifically,\n   the FEC bit string is the bitwise exclusive OR of the \"protected\
    \ bit\n   strings\" of the protected media RTP packets.\n   The following procedure\
    \ MAY be followed for the protection operation.\n   Other procedures MAY be used,\
    \ but the end result MUST be identical to\n   the one described here.\n"
- title: 8.1.  Generation of the FEC Header
  contents:
  - "8.1.  Generation of the FEC Header\n   In the case of the FEC header, the protected\
    \ bit strings (80 bits in\n   length) are generated for each media packet to be\
    \ protected at FEC\n   level 0.  It is formed by concatenating the following fields\
    \ together\n   in the order specified:\n      o The first 64 bits of the RTP header\
    \ (64 bits)\n      o Unsigned network-ordered 16-bit representation of the media\n\
    \        packet length in bytes minus 12 (for the fixed RTP header),\n       \
    \ i.e., the sum of the lengths of all the following if present:\n        the CSRC\
    \ list, extension header, RTP payload, and RTP padding\n        (16 bits)\n  \
    \ After the FEC bit string is formed by applying parity operation on\n   the protected\
    \ bit strings, the FEC header is generated from the FEC\n   bit string as follows:\n\
    \   The first (most significant) 2 bits in the FEC bit string are\n   skipped.\
    \  The next bit in the FEC bit string is written into the P\n   recovery bit of\
    \ the FEC header in the FEC packet.  The next bit in\n   the FEC bit string is\
    \ written into the E recovery bit of the FEC\n   header.  The next 4 bits of the\
    \ FEC bit string are written into the\n   CC recovery field of the FEC header.\
    \  The next bit is written into\n   the M recovery bit of the FEC header.  The\
    \ next 7 bits of the FEC bit\n   string are written into the PT recovery field\
    \ in the FEC header.  The\n   next 16 bits are skipped.  The next 32 bits of the\
    \ FEC bit string are\n   written into the TS recovery field in the FEC header.\
    \  The next 16\n   bits are written into the length recovery field in the packet\
    \ header.\n"
- title: 8.2.  Generation of the FEC Payload
  contents:
  - "8.2.  Generation of the FEC Payload\n   For generation of the FEC payload, the\
    \ protected bit strings are\n   simply the protected RTP packets.  The FEC bit\
    \ string is thus the\n   bitwise exclusive OR of these protected media RTP packets.\
    \  Such FEC\n   bit strings need to be generated for each level, as the group\
    \ of\n   protected payload packets may be different for each level.  If the\n\
    \   lengths of the protected RTP packets are not equal, each shorter\n   packet\
    \ MUST be padded to the length of the longest packet by adding\n   octet 0 at\
    \ the end.\n   For protection level n (n = 0, 1, ...), only Ln octets of data\
    \ are\n   set as the FEC level n payload data after the level n ULP header.\n\
    \   The data is the Ln octets of data starting with the (Sn + 13)th octet\n  \
    \ in the FEC bit string, where:\n   Sn = sum(Li : 0 <= i < n).\n   Li is the protection\
    \ length of level i, and S0 is defined to be 0.\n   The reason for omitting the\
    \ first 12 octets is that that information\n   is protected by the FEC header\
    \ already.\n"
- title: 9.  Recovery Procedures
  contents:
  - "9.  Recovery Procedures\n   The FEC packets allow end systems to recover from\
    \ the loss of media\n   packets.  This section describes the procedure for performing\
    \ this\n   recovery.\n   Recovery requires two distinct operations.  The first\
    \ determines\n   which packets (media and FEC) must be combined in order to recover\
    \ a\n   missing packet.  Once this is done, the second step is to actually\n \
    \  reconstruct the data.  The second step MUST be performed as described\n   below.\
    \  The first step MAY be based on any algorithm chosen by the\n   implementer.\
    \  Different algorithms result in a trade-off between\n   complexity and the ability\
    \ to recover missing packets, if possible.\n   The lost payload packets may be\
    \ recovered in full or in parts\n   depending on the data-loss situation due to\
    \ the nature of unequal\n   error protection (when it is used).  The partial recovery\
    \ of the\n   packet can be detected by checking the recovery length of the packet\n\
    \   retrieved from the FEC header against the actual length of the\n   recovered\
    \ payload data.\n"
- title: 9.1.  Reconstruction of the RTP Header
  contents:
  - "9.1.  Reconstruction of the RTP Header\n   Let T be the list of packets (FEC\
    \ and media) that can be combined to\n   recover some media packet xi at level\
    \ 0.  The procedure is as\n   follows:\n      1.  For the media packets in T,\
    \ compute the first 80 bits of the\n          protected bit string following the\
    \ procedure as described for\n          generating the FEC header in the previous\
    \ section.\n      2.  For the FEC packet in T, the FEC bit string is the 80-bit\
    \ FEC\n          header.\n      3.  Calculate the recovery bit string as the bitwise\
    \ exclusive OR\n          of the protected bit string generated from all the media\n\
    \          packets in T and the FEC bit string generated from all the FEC\n  \
    \        packets in T.\n      4.  Create a new packet with the standard 12-byte\
    \ RTP header and\n          no payload.\n      5.  Set the version of the new\
    \ packet to 2.  Skip the first 2 bits\n          in the recovery bit string.\n\
    \      6.  Set the Padding bit in the new packet to the next bit in the\n    \
    \      recovery bit string.\n      7.  Set the Extension bit in the new packet\
    \ to the next bit in the\n          recovery bit string.\n      8.  Set the CC\
    \ field to the next 4 bits in the recovery bit\n          string.\n      9.  Set\
    \ the marker bit in the new packet to the next bit in the\n          recovery\
    \ bit string.\n      10. Set the payload type in the new packet to the next 7\
    \ bits in\n          the recovery bit string.\n      11. Set the SN field in the\
    \ new packet to xi.  Skip the next 16\n          bits in the recovery bit string.\n\
    \      12. Set the TS field in the new packet to the next 32 bits in the\n   \
    \       recovery bit string.\n      13. Take the next 16 bits of the recovery\
    \ bit string.  Whatever\n          unsigned integer this represents (assuming\
    \ network-order),\n          take that many bytes from the recovery bit string\
    \ and append\n          them to the new packet.  This represents the CSRC list,\n\
    \          extension, payload, and the padding of the RTP payload.\n      14.\
    \ Set the SSRC of the new packet to the SSRC of the media stream\n          it's\
    \ protecting, i.e., the SSRC of the media stream to which\n          the FEC stream\
    \ is associated.\n   This procedure will recover the header of an RTP packet up\
    \ to the\n   SSRC field.\n"
- title: 9.2.  Reconstruction of the RTP Payload
  contents:
  - "9.2.  Reconstruction of the RTP Payload\n   Let T be the list of packets (FEC\
    \ and media) that can be combined to\n   recover some media packet xi at a certain\
    \ protection level.  The\n   procedure is as follows:\n      1.  Assume that we\
    \ are reconstructing the data for level n, the\n          first step is to get\
    \ the protection length of level n (Ln)\n          from the ULP header of level\
    \ n.\n      2.  For the FEC packets in T, the FEC bit string of level n is FEC\n\
    \          level n payload, i.e., the Ln octets of data following the ULP\n  \
    \        header of level n.\n      3.  For the media packets in T, the protected\
    \ bit string of level\n          n is Ln octets of data starting with the (Sn\
    \ + 13)th octet of\n          the packet.  Sn is the same as defined in Section\
    \ 8.2.  Note\n          that the protection of level 0 starts from the 13th octet\
    \ of\n          the media packet after the SSRC field.  The information of the\n\
    \          first 12 octets are protected by the FEC header.\n      4.  If any\
    \ of the protected bit strings of level n generated from\n          the media\
    \ packets are shorter than the protection length of\n          the current level,\
    \ pad them to that length.  The padding of\n          octet 0 MUST be added at\
    \ the end of the bit string.\n      5.  Calculate the recovery bit string as the\
    \ bitwise exclusive OR\n          of the protected bit string of level n generated\
    \ from all the\n          media packets in T and the FEC bit string of level n\
    \ generated\n          from all the FEC packets in T.\n      6.  The recovery\
    \ bit string of the current protection level as\n          generated above is\
    \ combined through concatenation with the\n          recovery bit string of all\
    \ the other levels to form the (fully\n          or partially) recovered media\
    \ packet.  Note that the recovery\n          bit string of each protection level\
    \ MUST be placed at the\n          correct location in the recovered media packet\
    \ for that level\n          based on protection length settings.\n      7.  The\
    \ total length of the recovered media packet is recovered\n          from the\
    \ recovery operation at protection level 0 of the\n          recovered media packet.\
    \  This information can be used to check\n          if the complete recovery operation\
    \ (of all levels) has\n          recovered the packet to its full length.\n  \
    \ The data protected at the lower protection level is recoverable in a\n   majority\
    \ of the cases if the higher-level protected data is\n   recoverable.  This procedure\
    \ (together with the procedure for the\n   lower protection levels) will usually\
    \ recover both the header and\n   payload of an RTP packet up to the protection\
    \ length of the current\n   level.\n"
- title: 10.  Examples
  contents:
  - "10.  Examples\n   In the first two examples considered below (Sections 10.1 and\
    \ 10.2),\n   we assume that the FEC streams are sent through a separate RTP\n\
    \   session as described in Section 14.1.  For these examples, we assume\n   that\
    \ four media packets are to be sent, A, B, C, and D, from SSRC 2.\n   Their sequence\
    \ numbers are 8, 9, 10, and 11, respectively, and have\n   timestamps of 3, 5,\
    \ 7, and 9, respectively.  Packets A and C use\n   payload type 11, and packets\
    \ B and D use payload type 18.  Packet A\n   has 200 bytes of payload, packet\
    \ B 140, packet C 100, and packet D\n   340.  Packets A and C have their marker\
    \ bit set.\n   The third example (Section 10.3) is to illustrate when the FEC\
    \ data\n   is sent as redundant data with the payload packets.\n"
- title: 10.1.  An Example Offers Similar Protection as RFC 2733
  contents:
  - "10.1.  An Example Offers Similar Protection as RFC 2733\n   We can protect the\
    \ four payload packets to their full length in one\n   single level with one FEC\
    \ packet.  This offers similar protection as\n   RFC 2733.  The scheme is as shown\
    \ in Figure 6.\n                    +-------------------+             :\n    \
    \     Packet A   |                   |             :\n                    +-------------+-----+\
    \             :\n         Packet B   |             |                   :\n   \
    \                 +---------+---+                   :\n         Packet C   | \
    \        |                       :\n                    +---------+-----------------------+\n\
    \         Packet D   |                                 |\n                   \
    \ +---------------------------------+\n                                      \
    \                :\n                    +---------------------------------+\n\
    \         Packet FEC |                                 |\n                   \
    \ +---------------------------------+\n                    :                 \
    \                :\n                    :<------------- L0 -------------->:\n\
    \         Figure 6: FEC Scheme with Single-Level Protection\n   An FEC packet\
    \ is generated from these four packets.  We assume that\n   payload type 127 is\
    \ used to indicate an FEC packet.  The resulting\n   RTP header is shown in Figure\
    \ 7.\n   The FEC header in the FEC packet is shown in Figure 8.\n   The FEC level\
    \ header for level 0 is shown in Figure 9.\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1 0|0|0|0 0 0 0|0|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Version:   2\n      Padding:   0\n      Extension: 0\n      Marker:   \
    \ 0\n      PT:        127\n      SN:        1\n      TS:        9\n      SSRC:\
    \      2\n                  Figure 7: RTP Header of FEC Packet\n    0        \
    \           1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|0|0|0|0 0 0 0|0|0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 1 0 1 1 1 0 1 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      E:         0     [this specification]\n      L:         0     [short 16-bit\
    \ mask]\n      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]\n      X rec.:    0    \
    \ [0 XOR 0 XOR 0 XOR 0]\n      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]\n      M\
    \ rec.:    0     [1 XOR 0 XOR 1 XOR 0]\n      PT rec.:   0     [11 XOR 18 XOR\
    \ 11 XOR 18]\n      SN base:   8     [min(8,9,10,11)]\n      TS rec.:   8    \
    \ [3 XOR 5 XOR 7 XOR 9]\n      len. rec.: 372   [200 XOR 140 XOR 100 XOR 340]\n\
    \               Figure 8: FEC Header of FEC Packet\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 0|1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      L0:        340   [the longest of 200, 140, 100, and 340]\n      mask: \
    \     61440 [with Bits 1, 2, 3, and 4 marked accordingly for\n               \
    \         Packets 8, 9, 10, and 11]\n      The payload length for level 0 is 340\
    \ bytes.\n               Figure 9: FEC Level Header (Level 0)\n"
- title: 10.2.  An Example with Two Protection Levels
  contents:
  - "10.2.  An Example with Two Protection Levels\n   A more complex example is to\
    \ use FEC at two levels.  The level 0 FEC\n   will provide greater protection\
    \ to the beginning part of the payload\n   packets.  The level 1 FEC will apply\
    \ additional protection to the\n   rest of the packets.  This is illustrated in\
    \ Figure 10.  In this\n   example, L0 = 70 and L1 = 90.\n              +------:--------:---+\n\
    \   Packet A   |      :        :   |\n              +------:------+-:---+\n  \
    \ Packet B   |      :      | :\n              +------:--+---+ :\n            \
    \         :        :\n              +------+        :\n   ULP #1     |      |\
    \        :\n              +------+        :\n                     :        :\n\
    \              +------:--+     :\n   Packet C   |      :  |     :\n          \
    \    +------:--+-----:-----------------+\n   Packet D   |      :        :    \
    \             |\n              +------:--------:-----------------+\n         \
    \            :        :\n              +------:--------+\n   ULP #2     |    \
    \  :        |\n              +------:--------+\n              :      :       \
    \ :\n              :<-L0->:<--L1-->:\n   Figure 10: ULP FEC Scheme with Protection\
    \ Level 0 and Level 1\n   This will result in two FEC packets - #1 and #2.\n \
    \  The resulting ULP FEC packet #1 will have the RTP header as shown in\n   Figure\
    \ 11.  The FEC header for ULP FEC packet #1 will be as shown in\n   Figure 12.\
    \  The level 0 ULP header for #1 will be as shown in Figure\n   13.\n    0   \
    \                1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1 0|0|0|0 0 0 0|1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Version:   2\n      Padding:   0\n      Extension: 0\n      Marker:   \
    \ 1\n      PT:        127\n      SN:        1\n      TS:        5\n      SSRC:\
    \      2\n               Figure 11: RTP Header of FEC Packet #1\n    0       \
    \            1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|0|0|0|0 0 0 0|0|0 0 1 1 0 0 1|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      E:         0     [this specification]\n      L:         0     [short 16-bit\
    \ mask]\n      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]\n      X rec.:    0    \
    \ [0 XOR 0 XOR 0 XOR 0]\n      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]\n      M\
    \ rec.:    0     [1 XOR 0 XOR 1 XOR 0]\n      PT rec.:   25    [11 XOR 18]\n \
    \     SN base:   8     [min(8,9)]\n      TS rec.:   6     [3 XOR 5]\n      len.\
    \ rec.: 68    [200 XOR 140]\n               Figure 12: FEC Header of ULP FEC Packet\
    \ #1\n    0                   1                   2                   3\n    0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0|1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      L0:        70\n      mask:      49152 [with Bits 1 and 2 marked accordingly\
    \ for\n                        Packets 8 and 9]\n      The payload length for\
    \ level 0 is 70 bytes.\n       Figure 13: FEC Level Header (Level 0) for FEC Packet\
    \ #1\n   The resulting FEC packet #2 will have the RTP header as shown in\n  \
    \ Figure 14.  The FEC header for FEC packet #2 will be as shown in\n   Figure\
    \ 15.  The level 0 ULP header for #2 will be as shown in Figure\n   16.  The level\
    \ 1 ULP header for #2 will be as shown in Figure 17.\n    0                  \
    \ 1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1 0|0|0|0 0 0 0|1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Version:   2\n      Padding:   0\n      Extension: 0\n      Marker:   \
    \ 1\n      PT:        127\n      SN:        2\n      TS:        9\n      SSRC:\
    \      2\n                Figure 14: RTP Header of FEC Packet #2\n    0      \
    \             1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|0|0|0|0 0 0 0|0|0 0 1 1 0 0 1|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      E:         0     [this specification]\n      L:         0     [short 16-bit\
    \ mask]\n      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]\n      X rec.:    0    \
    \ [0 XOR 0 XOR 0 XOR 0]\n      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]\n      M\
    \ rec.:    0     [1 XOR 0 XOR 1 XOR 0]\n      PT rec.:   25    [11 XOR 18]\n \
    \     SN base:   8     [min(8,9,10,11)]\n      TS rec.:   14    [7 XOR 9]\n  \
    \    len. rec.: 304   [100 XOR 340]\n               Figure 15: FEC Header of FEC\
    \ Packet #2\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0|0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      L0:        70\n      mask:      12288 [with Bits 3 and 4 marked accordingly\
    \ for\n                        Packets 10 and 11]\n      The payload length for\
    \ level 0 is 70 bytes.\n      Figure 16: FEC Level Header (Level 0) for FEC Packet\
    \ #2\n    0                   1                   2                   3\n    0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0|1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      L1:        90\n      mask:      61440 [with Bits 1, 2, 3, and 4 marked\
    \ accordingly for\n                        Packets 8, 9, 10, and 11]\n      The\
    \ payload length for level 1 is 90 bytes.\n       Figure 17: FEC Level Header\
    \ (Level 1) for FEC Packet #2\n"
- title: 10.3.  An Example with FEC as Redundant Coding
  contents:
  - "10.3.  An Example with FEC as Redundant Coding\n   This example illustrates FEC\
    \ sent as redundant coding in the same\n   stream as the payload.  We assume that\
    \ five media packets are to be\n   sent, A, B, C, D, and E, from SSRC 2.  Their\
    \ sequence numbers are 8,\n   9, 10, 11, and 12, respectively, and have timestamps\
    \ of 3, 5, 7, 9,\n   and 11, respectively.  All the media data is coded with primary\n\
    \   coding (and FEC as redundant coding only protects the primary coding)\n  \
    \ and uses payload type 11.  Packet A has 200 bytes of payload, packet\n   B 140,\
    \ packet C 100, packet D 340, and packet E 160.  Packets A and C\n   have their\
    \ marker bit set.\n   The FEC scheme we use will be with one level as illustrated\
    \ by Figure\n   6 in Section 10.1.  The protection length L0 = 340 octets.\n \
    \  A redundant coding packetization is used with payload type 100.  The\n   payload\
    \ type of the FEC is assumed to be 127.  The first four RED\n   packets, RED #1\
    \ through RED #4, each contains an individual media\n   packet, A, B, C, or D,\
    \ respectively.  The FEC data protecting the\n   media data in the first four\
    \ media packets is generated.  The fifth\n   packet, RED #5, contains this FEC\
    \ data as redundant coding along with\n   media packet E.\n   RED Packet #1: \
    \   Media Packet A\n   RED Packet #2:    Media Packet B\n   RED Packet #3:   \
    \ Media Packet C\n   RED Packet #4:    Media Packet D\n   RED Packet #5:    FEC\
    \ Packet, Media Packet E\n   RED packets #1 through #4 will have the structure\
    \ as shown in Figure\n   18.  The RTP header of the RED packet #1 is as shown\
    \ in Figure 19,\n   with all the other RED packets in similar format with corresponding\n\
    \   sequence numbers and timestamps.  The primary encoding block header\n   of\
    \ the RED packets is as shown in Figure 20.\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 RTP Header (RED) - 6 octets                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Primary Encoding Block Header (RED) - 1 octet          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Media Packet Data                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure 18: RED Packet Structure - Media Data Only\n    0          \
    \         1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1 0|0|0|0 0 0 0|0|1 1 0 0 1 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Version:   2\n      Padding:   0\n      Extension: 0\n      Marker:   \
    \ 0     [Even though media packet A has marker set]\n      PT:        100   [Payload\
    \ type for RED]\n      SN:        1\n      TS:        5\n      SSRC:      2\n\
    \               Figure 19: RTP Header of RED Packet #1\n    0 1 2 3 4 5 6 7\n\
    \   +-+-+-+-+-+-+-+-+\n   |0|0 0 0 1 0 1 1|\n   +-+-+-+-+-+-+-+-+\n      F bit:\
    \     0     [This is the primary coding data]\n      Block PT:  11    [The payload\
    \ type of media]\n        Figure 20: Primary Encoding Block Header\n   The FEC\
    \ data is generated not directly from the RED packets, but from\n   the virtual\
    \ RTP packets containing the media packet data.  Those\n   virtual RTP packets\
    \ can be very easily generated from the RED packets\n   both with and without\
    \ redundant coding included.  The conversion from\n   RED packets to virtual RTP\
    \ packets is simply done by (1) removing any\n   RED block headers and redundant\
    \ coding data, and (2) replacing the PT\n   in the RTP header with the PT of the\
    \ primary coding.\n      Note: In the payload format for redundant coding as specified\
    \ by\n      RFC 2198, the marker bit is lost as soon as the primary coding is\n\
    \      carried in the RED packets.  So the marker bit cannot be recovered\n  \
    \    regardless of whether or not the FEC is used.\n   As mentioned above, RED\
    \ packet #5 will contain the FEC data (that\n   protects media packets A, B, C,\
    \ and D) as well as the data of media\n   packet E.  The structure of RED packet\
    \ #5 is as illustrated in Figure\n   21.\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 RTP Header (RED) - 6 octets                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Redundant Encoding Block Header (RED) - 4 octets        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        FEC Packet Data                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Primary Encoding Block Header (RED) - 1 octet          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Media Packet Data                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure 21: RED Packet Structure - With FEC Data\n   The RTP header\
    \ of the RED packets with FEC included is the same as\n   shown in Figure 19,\
    \ with their corresponding sequence numbers and\n   timestamps.\n   In RED packet\
    \ #5, the redundant encoding block header for the FEC\n   packet data block is\
    \ as shown below in Figure 22.  It will be\n   followed by the FEC packet data,\
    \ which, in this case, includes an FEC\n   header (10 octets as shown in Figure\
    \ 8), ULP level 0 header (4 octets\n   as shown in Figure 9), and the ULP level\
    \ 0 data (340 octets as set\n   for level 0).  These are followed by the primary\
    \ encoding block that\n   contains the data of media packet E.\n    0        \
    \           1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 1 0 1 1 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      F bit:     1     [This is the redundant coding data]\n      Block PT: \
    \ 127   [The dynamic payload type for FEC]\n      TS Offset: 0     [The instance\
    \ at which the FEC data is\n                        transmitted]\n      Block\
    \ Len: 354   [FEC header (10 octets) plus ULP level 0 header\n               \
    \         (4 octets) and ULP level 0 data (340 octets)]\n          Figure 22:\
    \ Redundant Encoding Block Header\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   There are two ways to use FEC with encryption\
    \ in secure\n   communications: one way is to apply the FEC on already encrypted\n\
    \   payloads, and the other way is to apply the FEC before the\n   encryption.\
    \  The first case is encountered when FEC is needed by a\n   not trusted node\
    \ during transmission after the media data is\n   encrypted.  The second case\
    \ is encountered when media data is\n   protected by FEC before it is transmitted\
    \ through a secured\n   transport.\n   Since the protected payload of this FEC\
    \ is RTP packets, applying FEC\n   on encrypted payloads is primarily applicable\
    \ in the case of secure\n   RTP (SRTP) [13].  Because the FEC applies XOR across\
    \ the payload, the\n   FEC packets should be cryptographically as secure as the\
    \ original\n   payload.  In such cases, additional encryption of the FEC packets\
    \ is\n   not necessary.\n   In the following discussion, it is assumed that the\
    \ FEC is applied to\n   the payload before the encryption.  The use of FEC has\
    \ implications\n   on the usage and changing of keys for encryption.  As the FEC\
    \ packets\n   do consist of a separate stream, there are a number of combinations\n\
    \   on the usage of encryption.  These include:\n      o The FEC stream may be\
    \ encrypted, while the media stream is not.\n      o The media stream may be encrypted,\
    \ while the FEC stream is not.\n      o The media stream and FEC stream are both\
    \ encrypted, but using\n        the same key.\n      o The media stream and FEC\
    \ stream are both encrypted, but using\n        different keys.\n   The first\
    \ three of these would require all application-level\n   signaling protocols used\
    \ to be aware of the usage of FEC, and to thus\n   exchange keys and negotiate\
    \ encryption usage on the media and FEC\n   streams separately.  In the final\
    \ case, no such additional mechanisms\n   are needed.  The first two cases present\
    \ a layering violation, as ULP\n   FEC packets should be treated no differently\
    \ than other RTP packets.\n   Encrypting just one stream may also make certain\
    \ known-plaintext\n   attacks possible.  For these reasons, applications utilizing\n\
    \   encryption SHOULD encrypt both streams, i.e., the last two options.\n   Furthermore,\
    \ because the encryption may potentially be weakened by\n   the known relationship\
    \ between the media payload and FEC data for\n   certain ciphers, different encryption\
    \ keys MUST be used for each\n   stream when the media payload and the FEC data\
    \ are sent in separate\n   streams.  Note that when SRTP [13] is used for security\
    \ of the RTP\n   sessions, different keys for each RTP session are required by\
    \ the\n   SRTP specification.\n   The changing of encryption keys is another crucial\
    \ issue that needs\n   to be addressed.  Consider the case where two packets a\
    \ and b are\n   sent along with the FEC packet that protects them.  The keys used\
    \ to\n   encrypt a and b are different, so which key should be used to decode\n\
    \   the FEC packet?  In general, old keys need to be cached, so that when\n  \
    \ the keys change for the media stream, the old key can be used until\n   it is\
    \ determined that the key has changed for the ULP FEC packets as\n   well.  Furthermore,\
    \ the new key SHOULD be used to encrypt the FEC\n   packets that are generated\
    \ from a combination of payload packets\n   encrypted by the old and new keys.\
    \  The sender and the receiver need\n   to define how the encryption is performed\
    \ and how the keys are used.\n   Altering the FEC data and packets can have a\
    \ big impact on the\n   reconstruction operation.  An attack by changing some\
    \ bits in the FEC\n   data can have a significant effect on the calculation and\
    \ the\n   recovery of the payload packets.  For example, changing the length\n\
    \   recovery field can result in the recovery of a packet that is too\n   long.\
    \  Also, the computational complexity of the recovery can easily\n   be affected\
    \ for up to at least one order of magnitude.  Depending on\n   the application\
    \ scenario, it may be helpful to perform a sanity check\n   on the received payload\
    \ and FEC data before performing the recovery\n   operation and to determine the\
    \ validity of the recovered data from\n   the recovery operation before using\
    \ them.\n"
- title: 12.  Congestion Considerations
  contents:
  - "12.  Congestion Considerations\n   Another issue with the use of FEC is its impact\
    \ on network\n   congestion.  In many situations, the packet loss in the network\
    \ is\n   induced by congestions.  In such scenarios, adding FEC when\n   encountering\
    \ increasing network losses should be avoided.  If it is\n   used on a widespread\
    \ basis, this can result in increased congestion\n   and eventual congestion collapse.\
    \  The applications may include\n   stronger protections while at the same time\
    \ reduce the bandwidth for\n   the payload packets.  In any event, implementations\
    \ MUST NOT\n   substantially increase the total amount of bandwidth in use\n \
    \  (including the payload and the FEC) as network losses increase.\n   The general\
    \ congestion control considerations for transporting RTP\n   data apply; see RTP\
    \ [1] and any applicable RTP profile (e.g., RTP/AVP\n   [14]).  An additional\
    \ requirement if best-effort service is being\n   used is that users of this payload\
    \ format MUST monitor packet loss to\n   ensure that the packet loss rate is within\
    \ acceptable parameters.\n   Packet loss is considered acceptable if a TCP flow\
    \ across the same\n   network path, and experiencing the same network conditions,\
    \ would\n   achieve an average throughput, measured on a reasonable timescale,\n\
    \   that is not less than the RTP flow is achieving.  This condition can\n   be\
    \ satisfied by implementing congestion control mechanisms to adapt\n   the transmission\
    \ rate (or the number of layers subscribed for a\n   layered multicast session),\
    \ or by arranging for a receiver to leave\n   the session if the loss rate is\
    \ unacceptably high.\n"
- title: 13.  IANA Considerations
  contents:
  - "13.  IANA Considerations\n   Four new media subtypes have been registered with\
    \ IANA, as described\n   in this section.  This registration is done using the\
    \ registration\n   template [3] and following RFC 3555 [4].\n"
- title: 13.1.  Registration of audio/ulpfec
  contents:
  - "13.1.  Registration of audio/ulpfec\n   Type name: audio\n   Subtype name: ulpfec\n\
    \   Required parameters:\n   rate: The RTP timestamp rate that is used to mark\
    \ the time of\n      transmission of the FEC packet in a separate stream.  In\
    \ cases in\n      which it is sent as redundant data to another stream, the rate\n\
    \      SHALL be the same as the primary encoding it is used to protect.\n    \
    \  When used in a separate stream, the rate SHALL be larger than 1000\n      Hz,\
    \ to provide sufficient resolution to RTCP operations.  The\n      selected rate\
    \ MAY be any value above 1000 Hz but is RECOMMENDED to\n      match the rate of\
    \ the media this stream protects.\n   Optional parameters:\n   onelevelonly: This\
    \ specifies whether only one level of FEC protection\n      is used.  The permissible\
    \ values are 0 and 1.  If 1 is signaled,\n      only one level of FEC protection\
    \ SHALL be used in the stream.  If\n      0 is signaled, more than one level of\
    \ FEC protection MAY be used.\n      If omitted, it has the default value of 0.\n\
    \   Encoding considerations: This format is framed (see Section 4.8 in\n   the\
    \ template document [3]) and contains binary data.\n   Security considerations:\
    \ The same security considerations apply to\n   these media type registrations\
    \ as to the payloads for them, as\n   detailed in RFC 5109.\n   Interoperability\
    \ considerations: none\n   Published specification: RFC 5109\n   Applications\
    \ that use this media type: Multimedia applications that\n   seek to improve resiliency\
    \ to loss by sending additional data with\n   the media stream.\n   Additional\
    \ information: none\n   Person & email address to contact for further information:\n\
    \      Adam Li adamli@hyervision.com\n      IETF Audio/Video Transport Working\
    \ Group\n   Intended usage: COMMON\n   Restrictions on usage: This media, type\
    \ depends on RTP framing, and\n   hence is only defined for transfer via RTP [1].\
    \  Transport within\n   other framing protocols SHALL NOT be defined as this is\
    \ a robustness\n   mechanism for RTP.\n   Author:\n      Adam Li adamli@hyervision.com\n\
    \   Change controller:\n      IETF Audio/Video Transport Working Group delegated\
    \ from the IESG.\n"
- title: 13.2.  Registration of video/ulpfec
  contents:
  - "13.2.  Registration of video/ulpfec\n   Type name: video\n   Subtype name: ulpfec\n\
    \   Required parameters:\n   rate: The RTP timestamp rate that is used to mark\
    \ the time of\n      transmission of the FEC packet in a separate stream.  In\
    \ cases in\n      which it is sent as redundant data to another stream, the rate\n\
    \      SHALL be the same as the primary encoding it is used to protect.\n    \
    \  When used in a separate stream, the rate SHALL be larger than 1000\n      Hz\
    \ to provide sufficient resolution to RTCP operations.  The\n      selected rate\
    \ MAY be any value above 1000 Hz, but is RECOMMENDED\n      to match the rate\
    \ of the media this stream protects.\n   Optional parameters:\n   onelevelonly:\
    \ This specifies whether only one level of FEC protection\n      is used.  The\
    \ permissible values are 0 and 1.  If 1 is signaled,\n      only one level of\
    \ FEC protection SHALL be used in the stream.  If\n      0 is signaled, more than\
    \ one level of FEC protection MAY be used.\n      If omitted, it has the default\
    \ value of 0.\n   Encoding considerations: This format is framed (see Section\
    \ 4.8 in\n   the template document [3]) and contains binary data.\n   Security\
    \ considerations: The same security considerations apply to\n   these media type\
    \ registrations as to the payloads for them, as\n   detailed in RFC 5109.\n  \
    \ Interoperability considerations: none\n   Published specification: RFC 5109\n\
    \   Applications that use this media type: Multimedia applications that\n   seek\
    \ to improve resiliency to loss by sending additional data with\n   the media\
    \ stream.\n   Additional information: none\n   Person & email address to contact\
    \ for further information:\n      Adam Li adamli@hyervision.com\n      IETF Audio/Video\
    \ Transport Working Group\n   Intended usage: COMMON\n   Restrictions on usage:\
    \ This media type depends on RTP framing, and\n   hence is only defined for transfer\
    \ via RTP [1].  Transport within\n   other framing protocols SHALL NOT be defined\
    \ as this is a robustness\n   mechanism for RTP.\n   Author:\n      Adam Li adamli@hyervision.com\n\
    \   Change controller:  IETF Audio/Video Transport Working Group\n      delegated\
    \ from the IESG.\n"
- title: 13.3.  Registration of text/ulpfec
  contents:
  - "13.3.  Registration of text/ulpfec\n   Type name: text\n   Subtype name: ulpfec\n\
    \   Required parameters:\n   rate: The RTP timestamp rate that is used to mark\
    \ the time of\n      transmission of the FEC packet in a separate stream.  In\
    \ cases in\n      which it is sent as redundant data to another stream, the rate\n\
    \      SHALL be the same as the primary encoding it is used to protect.\n    \
    \  When used in a separate stream, the rate SHALL be larger than 1000\n      Hz\
    \ to provide sufficient resolution to RTCP operations.  The\n      selected rate\
    \ MAY be any value above 1000 Hz, but is RECOMMENDED\n      to match the rate\
    \ of the media this stream protects.\n   Optional parameters:\n   onelevelonly:\
    \ This specifies whether only one level of FEC protection\n      is used.  The\
    \ permissible values are 0 and 1.  If 1 is signaled,\n      only one level of\
    \ FEC protection SHALL be used in the stream.  If\n      0 is signaled, more than\
    \ one level of FEC protection MAY be used.\n      If omitted, it has the default\
    \ value of 0.\n   Encoding considerations: This format is framed (see Section\
    \ 4.8 in\n   the template document [3]) and contains binary data.\n   Security\
    \ considerations: The same security considerations apply to\n   these media type\
    \ registrations as to the payloads for them, as\n   detailed in RFC 5109.\n  \
    \ Interoperability considerations: none\n   Published specification: RFC 5109\n\
    \   Applications that use this media type: Multimedia applications that\n   seek\
    \ to improve resiliency to loss by sending additional data with\n   the media\
    \ stream.\n   Additional information: none\n   Person & email address to contact\
    \ for further information:\n      Adam Li adamli@hyervision.com\n      IETF Audio/Video\
    \ Transport Working Group\n   Intended usage: COMMON\n   Restrictions on usage:\
    \ This media type depends on RTP framing, and\n   hence is only defined for transfer\
    \ via RTP [1].  Transport within\n   other framing protocols SHALL NOT be defined\
    \ as this is a robustness\n   mechanism for RTP.\n   Author:\n      Adam Li adamli@hyervision.com\n\
    \   Change controller:\n      IETF Audio/Video Transport Working Group delegated\
    \ from the IESG.\n"
- title: 13.4.  Registration of application/ulpfec
  contents:
  - "13.4.  Registration of application/ulpfec\n   Type name: application\n   Subtype\
    \ name: ulpfec\n   Required parameters:\n   rate: The RTP timestamp rate that\
    \ is used to mark the time of\n      transmission of the FEC packet in a separate\
    \ stream.  In cases in\n      which it is sent as redundant data to another stream,\
    \ the rate\n      SHALL be the same as the primary encoding it is used to protect.\n\
    \      When used in a separate stream, the rate SHALL be larger than 1000\n  \
    \    Hz to provide sufficient resolution to RTCP operations.  The\n      selected\
    \ rate MAY be any value above 1000 Hz, but is RECOMMENDED\n      to match the\
    \ rate of the media this stream protects.\n   Optional parameters:\n   onelevelonly:\
    \ This specifies whether only one level of FEC protection\n      is used.  The\
    \ permissible values are 0 and 1.  If 1 is signaled,\n      only one level of\
    \ FEC protection SHALL be used in the stream.  If\n      0 is signaled, more than\
    \ one level of FEC protection MAY be used.\n      If omitted, it has the default\
    \ value of 0.\n   Encoding considerations: This format is framed (see Section\
    \ 4.8 in\n   the template document [3]) and contains binary data.\n   Security\
    \ considerations: The same security considerations apply to\n   these media type\
    \ registrations as to the payloads for them, as\n   detailed in RFC 5109.\n  \
    \ Interoperability considerations: none\n   Published specification: RFC 5109\n\
    \   Applications that use this media type: Multimedia applications that\n   seek\
    \ to improve resiliency to loss by sending additional data with\n   the media\
    \ stream.\n   Additional information: none\n   Person & email address to contact\
    \ for further information:\n      Adam Li adamli@hyervision.com\n      IETF Audio/Video\
    \ Transport Working Group\n   Intended usage: COMMON\n   Restrictions on usage:\
    \ This media type depends on RTP framing, and\n   hence is only defined for transfer\
    \ via RTP [1].  Transport within\n   other framing protocols SHALL NOT be defined\
    \ as this is a robustness\n   mechanism for RTP.\n   Author:\n      Adam Li adamli@hyervision.com\n\
    \   Change controller:\n      IETF Audio/Video Transport Working Group delegated\
    \ from the IESG.\n"
- title: 14.  Multiplexing of FEC
  contents:
  - "14.  Multiplexing of FEC\n   The FEC packets can be sent to the receiver along\
    \ with the protected\n   payload primarily in one of two ways: as a separate stream,\
    \ or in the\n   same stream as redundant encoding.  The configuration options\
    \ MUST be\n   indicated out of band.  This section also describes how this can\
    \ be\n   accomplished using the Session Description Protocol (SDP), specified\n\
    \   in RFC 2327 [8].\n"
- title: 14.1.  FEC as a Separate Stream
  contents:
  - "14.1.  FEC as a Separate Stream\n   When the FEC packets are sent in a separate\
    \ stream, several pieces of\n   information must be conveyed:\n   o The address\
    \ and port to which the FEC is being sent\n   o The payload type number for the\
    \ FEC\n   o Which media stream the FEC is protecting\n   There is no static payload\
    \ type assignment for FEC, so dynamic\n   payload type numbers MUST be used. \
    \ The SSRC of the FEC stream MUST\n   be set to that of the protected payload\
    \ stream.  The association of\n   the FEC stream with its corresponding stream\
    \ is done by line grouping\n   in SDP [5] with the FEC semantics [6] or other\
    \ external means.\n   Following the principles as discussed in Section 5.2 of\
    \ RFC 3550 [1],\n   multiplexing of the FEC stream and its associated payload\
    \ stream is\n   usually provided by the destination transport address (network\n\
    \   address and port number), which is different for each RTP session.\n   Sending\
    \ FEC together with the payload in one single RTP session and\n   multiplex only\
    \ by SSRC or payload type precludes: (1) the use of\n   different network paths\
    \ or network resource allocations for the\n   payload and the FEC protection data;\
    \ (2) reception of a subset of the\n   media if desired, particularly for the\
    \ hosts that do not understand\n   FEC; and (3) receiver implementations that\
    \ use separate processes for\n   the different media.  In addition, multiplexing\
    \ FEC with payload data\n   streams will affect the timing and sequence number\
    \ space of the\n   original payload stream, which is usually undesirable.  So\
    \ the FEC\n   stream and the payload stream SHOULD be sent through two separate\
    \ RTP\n   session, and multiplexing them by payload type into one single RTP\n\
    \   session SHOULD be avoided.  In addition, the FEC and the payload MUST\n  \
    \ NOT be multiplexed by SSRC into one single RTP session since they\n   always\
    \ have the same SSRC.\n   Just like any media stream, the port number and the\
    \ payload type\n   number for the FEC stream are conveyed in their m line in the\
    \ SDP.\n   There is no static payload type assignment for FEC, so dynamic\n  \
    \ payload type numbers MUST be used.  The binding to the number is\n   indicated\
    \ by an rtpmap attribute.  The name used in this binding is\n   \"ulpfec\".  The\
    \ address that the FEC stream is on is conveyed in its\n   corresponding c line.\n\
    \   The association relationship between the FEC stream and the payload\n   stream\
    \ it protects is conveyed through media line grouping in SDP\n   (RFC 3388) [5]\
    \ using FEC semantics (RFC 4756) [6].  The FEC stream\n   and the protected payload\
    \ stream form an FEC group.\n   The following is an example SDP for FEC application\
    \ in a multicast\n   session:\n       v=0\n       o=adam 289083124 289083124 IN\
    \ IP4 host.example.com\n       s=ULP FEC Seminar\n       t=0 0\n       c=IN IP4\
    \ 224.2.17.12/127\n       a=group:FEC 1 2\n       a=group:FEC 3 4\n       m=audio\
    \ 30000 RTP/AVP 0\n       a=mid:1\n       m=application 30002 RTP/AVP 100\n  \
    \     a=rtpmap:100 ulpfec/8000\n       a=mid:2\n       m=video 30004 RTP/AVP 31\n\
    \       a=mid:3\n       m=application 30004 RTP/AVP 101\n       c=IN IP4 224.2.17.13/127\n\
    \       a=rtpmap:101 ulpfec/8000\n       a=mid:4\n   The presence of two a=group\
    \ lines in this SDP indicates that there\n   are two FEC groups.  The first FEC\
    \ group, as indicated by the\n   \"a=group:FEC 1 2\" line, consists of stream\
    \ 1 (an audio stream using\n   PCM [14]) and stream 2 (the protecting FEC stream).\
    \  The FEC stream\n   is sent to the same multicast group and has the same Time\
    \ to Live\n   (TTL) as the audio, but on a port number two higher.  The second\
    \ FEC\n   group, as indicated by the \"a=group:FEC 3 4\" line, consists of stream\n\
    \   3 (a video stream) and stream 4 (the protecting FEC stream).  The FEC\n  \
    \ stream is sent to a different multicast address, but has the same\n   port number\
    \ (30004) as the payload video stream.\n"
- title: 14.2.  FEC as Redundant Encoding
  contents:
  - "14.2.  FEC as Redundant Encoding\n   When the FEC stream is being sent as a secondary\
    \ codec in the\n   redundant encoding format, this must be signaled through SDP.\
    \  To do\n   this, the procedures defined in RFC 2198 [7] are used to signal the\n\
    \   use of redundant encoding.  The FEC payload type is indicated in the\n   same\
    \ fashion as any other secondary codec.  The FEC MUST protect only\n   the main\
    \ codec, with the payload of FEC engine coming from virtual\n   RTP packets created\
    \ from the main codec data.  The virtual RTP\n   packets can be very easily converted\
    \ from the RFC 2198 packets by\n   simply (1) removing all the additional headers\
    \ and the redundant\n   coding data, and (2) replacing the payload type in the\
    \ RTP header\n   with that of the primary codec.\n      Note: In the payload format\
    \ for redundant coding as specified by\n      RFC 2198, the marker bit is lost\
    \ as soon as the primary coding is\n      carried in the RED packets.  So the\
    \ marker bit cannot be recovered\n      regardless of whether or not the FEC is\
    \ used.\n   Because the FEC data (including the ULP header) is sent in the same\n\
    \   packets as the protected payload, the FEC data is associated with the\n  \
    \ protected payload by being bundled in the same stream.\n   When the FEC stream\
    \ is sent as a secondary codec in the redundant\n   encoding format, this can\
    \ be signaled through SDP.  To do this, the\n   procedures defined in RFC 2198\
    \ [7] are used to signal the use of\n   redundant encoding.  The FEC payload type\
    \ is indicated in the same\n   fashion as any other secondary codec.  An rtpmap\
    \ attribute MUST be\n   used to indicate a dynamic payload type number for the\
    \ FEC packets.\n   The FEC MUST protect only the main codec.\n   For example:\n\
    \      m=audio 12345 RTP/AVP 121 0 5 100\n      a=rtpmap:121 red/8000/1\n    \
    \  a=rtpmap:100 ulpfec/8000\n      a=fmtp:121 0/5/100\n   This SDP indicates that\
    \ there is a single audio stream, which can\n   consist of PCM (media format 0),\
    \ DVI (media format 5), the redundant\n   encodings (indicated by media format\
    \ 121, which is bound to red\n   through the rtpmap attribute), or FEC (media\
    \ format 100, which is\n   bound to ulpfec through the rtpmap attribute).  Although\
    \ the FEC\n   format is specified as a possible coding for this stream, the FEC\n\
    \   MUST NOT be sent by itself for this stream.  Its presence in the m\n   line\
    \ is required only because non-primary codecs must be listed here\n   according\
    \ to RFC 2198.  The fmtp attribute indicates that the\n   redundant encodings\
    \ format can be used, with DVI as a secondary\n   coding and FEC as a tertiary\
    \ encoding.\n"
- title: 14.3.  Offer / Answer Consideration
  contents:
  - "14.3.  Offer / Answer Consideration\n   Some considerations are needed when SDP\
    \ is used for offer / answer\n   [15] exchange.\n   The \"onelevelonly\" parameter\
    \ is declarative.  For streams declared as\n   sendonly, the value indicates whether\
    \ only one level of FEC will be\n   sent.  For streams declared as recvonly or\
    \ sendrecv, the value\n   indicates what the receiver accepts to receive.\n  \
    \ When the FEC is sent as a separate stream and signaled through media\n   line\
    \ grouping in SDP (RFC 3388) [5] using FEC semantics (RFC 4756)\n   [6], the offering\
    \ side MUST implement both RFC 3388 and RFC 4756.\n   The rules for offer / answer\
    \ in RFC 3388 and RFC 4756 SHALL be\n   followed with the below additional consideration.\
    \  For all offers\n   with FEC, the answerer MAY refuse the separate FEC session\
    \ by setting\n   the port to 0, and remove the \"a=group\" attribute that groups\
    \ that\n   FEC session with the RTP session being protected.  If the answerer\n\
    \   accepts the usage of FEC, the answerer simply accepts the FEC RTP\n   session\
    \ and the grouping in the offer by including the same grouping\n   in the answer.\
    \  Note that the rejection of the FEC RTP session does\n   not prevent the media\
    \ sessions from being accepted and used without\n   FEC.\n   When the FEC stream\
    \ is sent as a secondary codec in the redundant\n   encoding format (RFC 2198)\
    \ [7], the offering side can indicate the\n   FEC stream as specified in Section\
    \ 14.2.  The answerer MAY reject the\n   FEC stream by removing the payload type\
    \ for the FEC stream.  To\n   accept the usage of FEC, the answerer must in the\
    \ answer include the\n   FEC payload type.  Note that in cases in which the redundancy\
    \ payload\n   format [7] is used with FEC as the only secondary codec, when the\
    \ FEC\n   stream is rejected the redundant encoding payload type SHOULD also be\n\
    \   removed.\n"
- title: 15.  Application Statement
  contents:
  - "15.  Application Statement\n   This document describes a generic protocol for\
    \ Forward Error\n   Correction supporting a wide range of short block parity FEC\n\
    \   algorithms, such as simple and interleaved parity codes.  The scheme\n   is\
    \ limited to interleaving parity codes over a distance of 48\n   packets.  This\
    \ FEC algorithm is fully compatible with hosts that are\n   not FEC-capable. \
    \ Since the media payload is not altered and the\n   protection is sent as additional\
    \ information, the receivers that are\n   unaware of the generic FEC as specified\
    \ in this document can simply\n   ignore the additional FEC information and process\
    \ the main media\n   payload.  This interoperability is particularly important\
    \ for\n   compatibility with existing hosts, and also in the scenario where\n\
    \   many different hosts need to communicate with each other at the same\n   time,\
    \ such as during multicast.\n   The generic FEC algorithm specified in this document\
    \ is also a\n   generic protection algorithm with the following features: (1)\
    \ it is\n   independent of the nature of the media being protected, whether that\n\
    \   media is audio, video, or otherwise; (2) it is flexible enough to\n   support\
    \ a wide variety of FEC mechanisms and settings; (3) it is\n   designed for adaptivity,\
    \ so that the FEC parameters can be modified\n   easily without resorting to out-of-band\
    \ signaling; and (4) it\n   supports a number of different mechanisms for transporting\
    \ the FEC\n   packets.\n   The FEC specified here also provides the user with\
    \ Unequal Error\n   Protection capabilities.  Some other algorithms may also provide\
    \ the\n   Unequal Error Protection capabilities through other means.  For\n  \
    \ example, an Unequal Erasure Protection (UXP) scheme has been proposed\n   in\
    \ the AVT Working Group in \"An RTP Payload Format for\n   Erasure-Resilient Transmission\
    \ of Progressive Multimedia Streams\".\n   The UXP scheme applies unequal error\
    \ protection to the media payloads\n   by interleaving the payload stream to be\
    \ protected with the\n   additional redundancy information obtained using Reed-Solomon\n\
    \   operations.\n   By altering the structure of the protected media payload,\
    \ the UXP\n   scheme sacrifices the backward compatibility with terminals that\
    \ do\n   not support UXP.  This makes it more difficult to apply UXP when\n  \
    \ backward compatibility is desired.  In the case of ULP, however, the\n   media\
    \ payload remains unaltered and can always be used by the\n   terminals.  The\
    \ extra protection can simply be ignored if the\n   receiving terminals do not\
    \ support ULP.\n   At the same time, also because the structure of the media payload\
    \ is\n   altered in UXP, UXP offers the unique ability to change packet size\n\
    \   independent of the original media payload structure and protection\n   applied,\
    \ and is only subject to the protocol overhead constraint.\n   This property is\
    \ useful in scenarios when altering the packet size of\n   the media at transport\
    \ level is desired.\n   Because of the interleaving used in UXP, delays will be\
    \ introduced at\n   both the encoding and decoding sides.  For UXP, all data within\
    \ a\n   transmission block need to arrive before encoding can begin, and a\n \
    \  reasonable number of packets must be received before a transmission\n   block\
    \ can be decoded.  The ULP scheme introduces little delay at the\n   encoding\
    \ side.  On the decoding side, correctly received packets can\n   be delivered\
    \ immediately.  Delay is only introduced in ULP when\n   packet losses occur.\n\
    \   Because UXP is an interleaved scheme, the unrecoverable errors\n   occurring\
    \ in data protected by UXP usually result in a number of\n   corrupted holes in\
    \ the payload stream.  In ULP, on the other hand,\n   the unrecoverable errors\
    \ due to packet loss in the bitstream usually\n   appear as contiguous missing\
    \ pieces at the end of the packets.\n   Depending on the encoding of the media\
    \ payload stream, many\n   applications may find it easier to parse and extract\
    \ data from a\n   packet with only a contiguous piece missing at the end than\
    \ a packet\n   with multiple corrupted holes, especially when the holes are not\n\
    \   coincident with the independently decodable fragment boundaries.\n   The exclusive-or\
    \ (XOR) parity check operation used by ULP is simpler\n   and faster than the\
    \ more complex operations required by Reed-Solomon\n   codes.  This makes ULP\
    \ more suitable for applications where\n   computational cost is a constraint.\n\
    \   As discussed above, both the ULP and the UXP schemes apply unequal\n   error\
    \ protection to the RTP media stream, but each uses a different\n   technique.\
    \  Both schemes have their own unique characteristics, and\n   each can be applied\
    \ to scenarios with different requirements.\n"
- title: 16.  Acknowledgments
  contents:
  - "16.  Acknowledgments\n   The following authors have made significant contributions\
    \ to this\n   document: Adam H. Li, Fang Liu, John D. Villasenor, Dong-Seek Park,\n\
    \   Jeong-Hoon Park, Yung-Lyul Lee, Jonathan D. Rosenberg, and Henning\n   Schulzrinne.\
    \  The authors would also like to acknowledge the\n   suggestions from many people,\
    \ particularly Stephen Casner, Jay\n   Fahlen, Cullen Jennings, Colin Perkins,\
    \ Tao Tian, Matthieu Tisserand,\n   Jeffery Tseng, Mark Watson, Stephen Wenger,\
    \ and Magnus Westerlund.\n"
- title: 17.  References
  contents:
  - '17.  References

    '
- title: 17.1.  Normative References
  contents:
  - "17.1.  Normative References\n   [1]  Schulzrinne, H., Casner, S., Frederick,\
    \ R., and V. Jacobson,\n        \"RTP: A Transport Protocol for Real-Time Applications\"\
    , STD 64,\n        RFC 3550, July 2003.\n   [2]  Bradner, S., \"Key words for\
    \ use in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [3]  Freed, N. and J. Klensin, \"Media Type Specifications and\n \
    \       Registration Procedures\", BCP 13, RFC 4288, December 2005.\n   [4]  Casner,\
    \ S., \"Media Type Registration of RTP Payload Formats\",\n        RFC 4855, February\
    \ 2007.\n   [5]  Camarillo, G., Eriksson, G., Holler, J., and H. Schulzrinne,\n\
    \        \"Grouping of Media Lines in the Session Description Protocol\n     \
    \   (SDP)\", RFC 3388, December 2002.\n   [6]  Li, A., \"Forward Error Correction\
    \ Grouping Semantics in Session\n        Description Protocol\", RFC 4756, November\
    \ 2006.\n   [7]  Perkins, C., Kouvelas, I., Hodson, O., Hardman, V., Handley,\
    \ M.,\n        Bolot, J., Vega-Garcia, A., and S. Fosse-Parisis, \"RTP Payload\n\
    \        for Redundant Audio Data\", RFC 2198, September 1997.\n   [8]  Handley,\
    \ M., Jacobson, V., and C. Perkins, \"SDP: Session\n        Description Protocol\"\
    , RFC 4566, July 2006.\n"
- title: 17.2.  Informative References
  contents:
  - "17.2.  Informative References\n   [9]  Rosenberg, J. and H. Schulzrinne, \"An\
    \ RTP Payload Format for\n        Generic Forward Error Correction\", RFC 2733,\
    \ December 1999.\n   [10] Perkins, C. and O. Hodson, \"Options for Repair of Streaming\n\
    \        Media\", RFC 2354, June 1998.\n   [11] Rosenberg, J. and H. Schulzrinne,\
    \ \"Registration of parityfec\n        MIME types\", RFC 3009, November 2000.\n\
    \   [12] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and\n  \
    \      J. Crowcroft, \"Forward Error Correction (FEC) Building Block\",\n    \
    \    RFC 3452, December 2002.\n   [13] Baugher, M., McGrew, D., Naslund, M., Carrara,\
    \ E., and K.\n        Norrman, \"The Secure Real-time Transport Protocol (SRTP)\"\
    , RFC\n        3711, March 2004.\n   [14] Schulzrinne, H. and S. Casner, \"RTP\
    \ Profile for Audio and Video\n        Conferences with Minimal Control\", STD\
    \ 65, RFC 3551, July 2003.\n   [15] Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer\
    \ Model with\n        Session Description Protocol (SDP)\", RFC 3264, June 2002.\n"
- title: Editor's Address
  contents:
  - "Editor's Address\n   Adam H. Li\n   10194 Wateridge Circle #152\n   San Diego,\
    \ CA 92121\n   USA\n   Phone: +1 858 622 9038\n   EMail: adamli@hyervision.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
