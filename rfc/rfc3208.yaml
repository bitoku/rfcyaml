- title: __initial_text__
  contents:
  - '             PGM Reliable Transport Protocol Specification

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Pragmatic General Multicast (PGM) is a reliable multicast transport\n\
    \   protocol for applications that require ordered or unordered,\n   duplicate-free,\
    \ multicast data delivery from multiple sources to\n   multiple receivers.  PGM\
    \ guarantees that a receiver in the group\n   either receives all data packets\
    \ from transmissions and repairs, or\n   is able to detect unrecoverable data\
    \ packet loss.  PGM is\n   specifically intended as a workable solution for multicast\n\
    \   applications with basic reliability requirements.  Its central design\n  \
    \ goal is simplicity of operation with due regard for scalability and\n   network\
    \ efficiency.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and Overview ..................................\
    \    3\n   2.  Architectural Description ..................................  \
    \  9\n   3.  Terms and Concepts .........................................   12\n\
    \   4.  Procedures - General .......................................   18\n  \
    \ 5.  Procedures - Sources .......................................   19\n   6.\
    \  Procedures - Receivers .....................................   22\n   7.  Procedures\
    \ - Network Elements ..............................   27\n   8.  Packet Formats\
    \ .............................................   31\n   9.  Options ....................................................\
    \   40\n   10. Security Considerations ....................................  \
    \ 56\n   11. Appendix A - Forward Error Correction ......................   58\n\
    \   12. Appendix B - Support for Congestion Control ................   72\n  \
    \ 13. Appendix C - SPM Requests ..................................   79\n   14.\
    \ Appendix D - Poll Mechanism ................................   82\n   15. Appendix\
    \ E - Implosion Prevention ..........................   92\n   16. Appendix F\
    \ - Transmit Window Example .......................   98\n   17  Appendix G -\
    \ Applicability Statement .......................  103\n   18. Abbreviations ..............................................\
    \  105\n   19. Acknowledgments ............................................  106\n\
    \   20. References .................................................  106\n  \
    \ 21. Authors' Addresses..........................................  108\n   22.\
    \ Full Copyright Statement ...................................  111\n"
- title: 'Nota Bene:'
  contents:
  - "Nota Bene:\n   The publication of this specification is intended to freeze the\n\
    \   definition of PGM in the interest of fostering both ongoing and\n   prospective\
    \ experimentation with the protocol.  The intent of that\n   experimentation is\
    \ to provide experience with the implementation and\n   deployment of a reliable\
    \ multicast protocol of this class so as to be\n   able to feed that experience\
    \ back into the longer-term\n   standardization process underway in the Reliable\
    \ Multicast Transport\n   Working Group of the IETF.  Appendix G provides more\
    \ specific detail\n   on the scope and status of some of this experimentation.\
    \  Reports of\n   experiments include [16-23].  Additional results and new\n \
    \  experimentation are encouraged.\n"
- title: 1.  Introduction and Overview
  contents:
  - "1.  Introduction and Overview\n   A variety of reliable protocols have been proposed\
    \ for multicast data\n   delivery, each with an emphasis on particular types of\
    \ applications,\n   network characteristics, or definitions of reliability ([1],\
    \ [2],\n   [3], [4]).  In this tradition, Pragmatic General Multicast (PGM) is\
    \ a\n   reliable transport protocol for applications that require ordered or\n\
    \   unordered, duplicate-free, multicast data delivery from multiple\n   sources\
    \ to multiple receivers.\n   PGM is specifically intended as a workable solution\
    \ for multicast\n   applications with basic reliability requirements rather than\
    \ as a\n   comprehensive solution for multicast applications with sophisticated\n\
    \   ordering, agreement, and robustness requirements.  Its central design\n  \
    \ goal is simplicity of operation with due regard for scalability and\n   network\
    \ efficiency.\n   PGM has no notion of group membership.  It simply provides reliable\n\
    \   multicast data delivery within a transmit window advanced by a source\n  \
    \ according to a purely local strategy.  Reliable delivery is provided\n   within\
    \ a source's transmit window from the time a receiver joins the\n   group until\
    \ it departs.  PGM guarantees that a receiver in the group\n   either receives\
    \ all data packets from transmissions and repairs, or\n   is able to detect unrecoverable\
    \ data packet loss.  PGM supports any\n   number of sources within a multicast\
    \ group, each fully identified by\n   a globally unique Transport Session Identifier\
    \ (TSI), but since these\n   sources/sessions operate entirely independently of\
    \ each other, this\n   specification is phrased in terms of a single source and\
    \ extends\n   without modification to multiple sources.\n   More specifically,\
    \ PGM is not intended for use with applications that\n   depend either upon acknowledged\
    \ delivery to a known group of\n   recipients, or upon total ordering amongst\
    \ multiple sources.\n   Rather, PGM is best suited to those applications in which\
    \ members may\n   join and leave at any time, and that are either insensitive\
    \ to\n   unrecoverable data packet loss or are prepared to resort to\n   application\
    \ recovery in the event.  Through its optional extensions,\n   PGM provides specific\
    \ mechanisms to support applications as disparate\n   as stock and news updates,\
    \ data conferencing, low-delay real-time\n   video transfer, and bulk data transfer.\n\
    \   In the following text, transport-layer originators of PGM data\n   packets\
    \ are referred to as sources, transport-layer consumers of PGM\n   data packets\
    \ are referred to as receivers, and network-layer entities\n   in the intervening\
    \ network are referred to as network elements.\n   Unless otherwise specified,\
    \ the term \"repair\" will be used to\n   indicate both the actual retransmission\
    \ of a copy of a missing packet\n   or the transmission of an FEC repair packet.\n"
- title: Terminology
  contents:
  - "Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [14] and\n   indicate requirement levels for compliant PGM implementations.\n"
- title: 1.1.  Summary of Operation
  contents:
  - "1.1.  Summary of Operation\n   PGM runs over a datagram multicast protocol such\
    \ as IP multicast [5].\n   In the normal course of data transfer, a source multicasts\
    \ sequenced\n   data packets (ODATA), and receivers unicast selective negative\n\
    \   acknowledgments (NAKs) for data packets detected to be missing from\n   the\
    \ expected sequence.  Network elements forward NAKs PGM-hop-by-\n   PGM-hop to\
    \ the source, and confirm each hop by multicasting a NAK\n   confirmation (NCF)\
    \ in response on the interface on which the NAK was\n   received.  Repairs (RDATA)\
    \ may be provided either by the source\n   itself or by a Designated Local Repairer\
    \ (DLR) in response to a NAK.\n   Since NAKs provide the sole mechanism for reliability,\
    \ PGM is\n   particularly sensitive to their loss.  To minimize NAK loss, PGM\n\
    \   defines a network-layer hop-by-hop procedure for reliable NAK\n   forwarding.\n\
    \   Upon detection of a missing data packet, a receiver repeatedly\n   unicasts\
    \ a NAK to the last-hop PGM network element on the\n   distribution tree from\
    \ the source.  A receiver repeats this NAK until\n   it receives a NAK confirmation\
    \ (NCF) multicast to the group from that\n   PGM network element.  That network\
    \ element responds with an NCF to\n   the first occurrence of the NAK and any\
    \ further retransmissions of\n   that same NAK from any receiver.  In turn, the\
    \ network element\n   repeatedly forwards the NAK to the upstream PGM network\
    \ element on\n   the reverse of the distribution path from the source of the original\n\
    \   data packet until it also receives an NCF from that network element.\n   Finally,\
    \ the source itself receives and confirms the NAK by\n   multicasting an NCF to\
    \ the group.\n   While NCFs are multicast to the group, they are not propagated\
    \ by PGM\n   network elements since they act as hop-by-hop confirmations.\n  \
    \ To avoid NAK implosion, PGM specifies procedures for subnet-based NAK\n   suppression\
    \ amongst receivers and NAK elimination within network\n   elements.  The usual\
    \ result is the propagation of just one copy of a\n   given NAK along the reverse\
    \ of the distribution path from any network\n   with directly connected receivers\
    \ to a source.\n   The net effect is that unicast NAKs return from a receiver\
    \ to a\n   source on the reverse of the path on which ODATA was forwarded, that\n\
    \   is, on the reverse of the distribution tree from the source.  More\n   specifically,\
    \ they return through exactly the same sequence of PGM\n   network elements through\
    \ which ODATA was forwarded, but in reverse.\n   The reasons for handling NAKs\
    \ this way will become clear in the\n   discussion of constraining repairs, but\
    \ first it's necessary to\n   describe the mechanisms for establishing the requisite\
    \ source path\n   state in PGM network elements.\n   To establish source path\
    \ state in PGM network elements, the basic\n   data transfer operation is augmented\
    \ by Source Path Messages (SPMs)\n   from a source, periodically interleaved with\
    \ ODATA.  SPMs function\n   primarily to establish source path state for a given\
    \ TSI in all PGM\n   network elements on the distribution tree from the source.\
    \  PGM\n   network elements use this information to address returning unicast\n\
    \   NAKs directly to the upstream PGM network element toward the source,\n   and\
    \ thereby insure that NAKs return from a receiver to a source on\n   the reverse\
    \ of the distribution path for the TSI.\n   SPMs are sent by a source at a rate\
    \ that serves to maintain up-to-\n   date PGM neighbor information.  In addition,\
    \ SPMs complement the role\n   of DATA packets in provoking further NAKs from\
    \ receivers, and\n   maintaining receive window state in the receivers.\n   As\
    \ a further efficiency, PGM specifies procedures for the constraint\n   of repairs\
    \ by network elements so that they reach only those network\n   segments containing\
    \ group members that did not receive the original\n   transmission.  As NAKs traverse\
    \ the reverse of the ODATA path\n   (upward), they establish repair state in the\
    \ network elements which\n   is used in turn to constrain the (downward) forwarding\
    \ of the\n   corresponding RDATA.\n   Besides procedures for the source to provide\
    \ repairs, PGM also\n   specifies options and procedures that permit designated\
    \ local\n   repairers (DLRs) to announce their availability and to redirect\n\
    \   repair requests (NAKs) to themselves rather than to the original\n   source.\
    \  In addition to these conventional procedures for loss\n   recovery through\
    \ selective ARQ, Appendix A specifies Forward Error\n   Correction (FEC) procedures\
    \ for sources to provide and receivers to\n   request general error correcting\
    \ parity packets rather than selective\n   retransmissions.\n   Finally, since\
    \ PGM operates without regular return traffic from\n   receivers, conventional\
    \ feedback mechanisms for transport flow and\n   congestion control cannot be\
    \ applied.  Appendix B specifies a TCP-\n   friendly, NE-based solution for PGM\
    \ congestion control, and cites a\n   reference to a TCP-friendly, end-to-end\
    \ solution for PGM congestion\n   control.\n   In its basic operation, PGM relies\
    \ on a purely rate-limited\n   transmission strategy in the source to bound the\
    \ bandwidth consumed\n   by PGM transport sessions and to define the transmit\
    \ window\n   maintained by the source.\n   PGM defines four basic packet types:\
    \  three that flow downstream\n   (SPMs, DATA, NCFs), and one that flows upstream\
    \ (NAKs).\n"
- title: 1.2.  Design Goals and Constraints
  contents:
  - "1.2.  Design Goals and Constraints\n   PGM has been designed to serve that broad\
    \ range of multicast\n   applications that have relatively simple reliability\
    \ requirements,\n   and to do so in a way that realizes the much advertised but\
    \ often\n   unrealized network efficiencies of multicast data transfer.  The\n\
    \   usual impediments to realizing these efficiencies are the implosion\n   of\
    \ negative and positive acknowledgments from receivers to sources,\n   repair\
    \ latency from the source, and the propagation of repairs to\n   disinterested\
    \ receivers.\n"
- title: 1.2.1.  Reliability.
  contents:
  - "1.2.1.  Reliability.\n   Reliable data delivery across an unreliable network\
    \ is conventionally\n   achieved through an end-to-end protocol in which a source\
    \ (implicitly\n   or explicitly) solicits receipt confirmation from a receiver,\
    \ and the\n   receiver responds positively or negatively.  While the frequency\
    \ of\n   negative acknowledgments is a function of the reliability of the\n  \
    \ network and the receiver's resources (and so, potentially quite low),\n   the\
    \ frequency of positive acknowledgments is fixed at at least the\n   rate at which\
    \ the transmit window is advanced, and usually more\n   often.\n   Negative acknowledgments\
    \ primarily determine repairs and reliability.\n   Positive acknowledgments primarily\
    \ determine transmit buffer\n   management.\n   When these principles are extended\
    \ without modification to multicast\n   protocols, the result, at least for positive\
    \ acknowledgments, is a\n   burden of positive acknowledgments transmitted to\
    \ the source that\n   quickly threatens to overwhelm it as the number of receivers\
    \ grows.\n   More succinctly, ACK implosion keeps ACK-based reliable multicast\n\
    \   protocols from scaling well.\n   One of the goals of PGM is to get as strong\
    \ a definition of\n   reliability as possible from as simple a protocol as possible.\
    \  ACK\n   implosion can be addressed in a variety of effective but complicated\n\
    \   ways, most of which require re-transmit capability from other than\n   the\
    \ original source.\n   An alternative is to dispense with positive acknowledgments\n\
    \   altogether, and to resort to other strategies for buffer management\n   while\
    \ retaining negative acknowledgments for repairs and reliability.\n   The approach\
    \ taken in PGM is to retain negative acknowledgments, but\n   to dispense with\
    \ positive acknowledgments and resort instead to\n   timeouts at the source to\
    \ manage transmit resources.\n   The definition of reliability with PGM is a direct\
    \ consequence of\n   this design decision.  PGM guarantees that a receiver either\
    \ receives\n   all data packets from transmissions and repairs, or is able to\
    \ detect\n   unrecoverable data packet loss.\n   PGM includes strategies for repeatedly\
    \ provoking NAKs from receivers,\n   and for adding reliability to the NAKs themselves.\
    \  By reinforcing\n   the NAK mechanism, PGM minimizes the probability that a\
    \ receiver will\n   detect a missing data packet so late that the packet is unavailable\n\
    \   for repair either from the source or from a designated local repairer\n  \
    \ (DLR).  Without ACKs and knowledge of group membership, however, PGM\n   cannot\
    \ eliminate this possibility.\n"
- title: 1.2.2.  Group Membership
  contents:
  - "1.2.2.  Group Membership\n   A second consequence of eliminating ACKs is that\
    \ knowledge of group\n   membership is neither required nor provided by the protocol.\n\
    \   Although a source may receive some PGM packets (NAKs for instance)\n   from\
    \ some receivers, the identity of the receivers does not figure in\n   the processing\
    \ of those packets.  Group membership MAY change during\n   the course of a PGM\
    \ transport session without the knowledge of or\n   consequence to the source\
    \ or the remaining receivers.\n"
- title: 1.2.3.  Efficiency
  contents:
  - "1.2.3.  Efficiency\n   While PGM avoids the implosion of positive acknowledgments\
    \ simply by\n   dispensing with ACKs, the implosion of negative acknowledgments\
    \ is\n   addressed directly.\n   Receivers observe a random back-off prior to\
    \ generating a NAK during\n   which interval the NAK is suppressed (i.e. it is\
    \ not sent, but the\n   receiver acts as if it had sent it) by the receiver upon\
    \ receipt of a\n   matching NCF.  In addition, PGM network elements eliminate\
    \ duplicate\n   NAKs received on different interfaces on the same network element.\n\
    \   The combination of these two strategies usually results in the source\n  \
    \ receiving just a single NAK for any given lost data packet.\n   Whether a repair\
    \ is provided from a DLR or the original source, it is\n   important to constrain\
    \ that repair to only those network segments\n   containing members that negatively\
    \ acknowledged the original\n   transmission rather than propagating it throughout\
    \ the group.  PGM\n   specifies procedures for network elements to use the pattern\
    \ of NAKs\n   to define a sub-tree within the group upon which to forward the\n\
    \   corresponding repair so that it reaches only those receivers that\n   missed\
    \ it in the first place.\n"
- title: 1.2.4.  Simplicity
  contents:
  - "1.2.4.  Simplicity\n   PGM is designed to achieve the greatest improvement in\
    \ reliability\n   (as compared to the usual UDP) with the least complexity.  As\
    \ a\n   result, PGM does NOT address conference control, global ordering\n   amongst\
    \ multiple sources in the group, nor recovery from network\n   partitions.\n"
- title: 1.2.5.  Operability
  contents:
  - "1.2.5.  Operability\n   PGM is designed to function, albeit with less efficiency,\
    \ even when\n   some or all of the network elements in the multicast tree have\
    \ no\n   knowledge of PGM.  To that end, all PGM data packets can be\n   conventionally\
    \ multicast routed by non-PGM network elements with no\n   loss of functionality,\
    \ but with some inefficiency in the propagation\n   of RDATA and NCFs.\n   In\
    \ addition, since NAKs are unicast to the last-hop PGM network\n   element and\
    \ NCFs are multicast to the group, NAK/NCF operation is\n   also consistent across\
    \ non-PGM network elements.  Note that for NAK\n   suppression to be most effective,\
    \ receivers should always have a PGM\n   network element as a first hop network\
    \ element between themselves and\n   every path to every PGM source.  If receivers\
    \ are several hops\n   removed from the first PGM network element, the efficacy\
    \ of NAK\n   suppression may degrade.\n"
- title: 1.3.  Options
  contents:
  - "1.3.  Options\n   In addition to the basic data transfer operation described\
    \ above, PGM\n   specifies several end-to-end options to address specific application\n\
    \   requirements.  PGM specifies options to support fragmentation, late\n   joining,\
    \ redirection, Forward Error Correction (FEC), reachability,\n   and session synchronization/termination/reset.\
    \  Options MAY be\n   appended to PGM data packet headers only by their original\n\
    \   transmitters.  While they MAY be interpreted by network elements,\n   options\
    \ are neither added nor removed by network elements.\n   All options are receiver-significant\
    \ (i.e., they must be interpreted\n   by receivers).  Some options are also network-significant\
    \ (i.e., they\n   must be interpreted by network elements).\n   Fragmentation\
    \ MAY be used in conjunction with data packets to allow a\n   transport-layer\
    \ entity at the source to break up application-layer\n   data packets into multiple\
    \ PGM data packets to conform with the\n   maximum transmission unit (MTU) supported\
    \ by the network layer.\n   Late joining allows a source to indicate whether or\
    \ not receivers may\n   request all available repairs when they initially join\
    \ a particular\n   transport session.\n   Redirection MAY be used in conjunction\
    \ with Poll Responses to allow a\n   DLR to respond to normal NCFs or POLLs with\
    \ a redirecting POLR\n   advertising its own address as an alternative re-transmitter\
    \ to the\n   original source.\n   FEC techniques MAY be applied by receivers to\
    \ use source-provided\n   parity packets rather than selective retransmissions\
    \ to effect loss\n   recovery.\n"
- title: 2.  Architectural Description
  contents:
  - "2.  Architectural Description\n   As an end-to-end transport protocol, PGM specifies\
    \ packet formats and\n   procedures for sources to transmit and for receivers\
    \ to receive data.\n   To enhance the efficiency of this data transfer, PGM also\
    \ specifies\n   packet formats and procedures for network elements to improve\
    \ the\n   reliability of NAKs and to constrain the propagation of repairs.  The\n\
    \   division of these functions is described in this section and expanded\n  \
    \ in detail in the next section.\n"
- title: 2.1.  Source Functions
  contents:
  - "2.1.  Source Functions\n      Data Transmission\n         Sources multicast ODATA\
    \ packets to the group within the\n         transmit window at a given transmit\
    \ rate.\n      Source Path State\n         Sources multicast SPMs to the group,\
    \ interleaved with ODATA if\n         present, to establish source path state\
    \ in PGM network\n         elements.\n      NAK Reliability\n         Sources\
    \ multicast NCFs to the group in response to any NAKs\n         they receive.\n\
    \      Repairs\n         Sources multicast RDATA packets to the group in response\
    \ to\n         NAKs received for data packets within the transmit window.\n  \
    \    Transmit Window Advance\n         Sources MAY advance the trailing edge of\
    \ the window according\n         to one of a number of strategies.  Implementations\
    \ MAY support\n         automatic adjustments such as keeping the window at a\
    \ fixed\n         size in bytes, a fixed number of packets or a fixed real time\n\
    \         duration.  In addition, they MAY optionally delay window\n         advancement\
    \ based on NAK-silence for a certain period.  Some\n         possible strategies\
    \ are outlined later in this document.\n"
- title: 2.2.  Receiver Functions
  contents:
  - "2.2.  Receiver Functions\n      Source Path State\n         Receivers use SPMs\
    \ to determine the last-hop PGM network\n         element for a given TSI to which\
    \ to direct their NAKs.\n      Data Reception\n         Receivers receive ODATA\
    \ within the transmit window and\n         eliminate any duplicates.\n      Repair\
    \ Requests\n         Receivers unicast NAKs to the last-hop PGM network element\
    \ (and\n         MAY optionally multicast a NAK with TTL of 1 to the local\n \
    \        group) for data packets within the receive window detected to\n     \
    \    be missing from the expected sequence.  A receiver MUST\n         repeatedly\
    \ transmit a given NAK until it receives a matching\n         NCF.\n      NAK\
    \ Suppression\n         Receivers suppress NAKs for which a matching NCF or NAK\
    \ is\n         received during the NAK transmit back-off interval.\n      Receive\
    \ Window Advance\n         Receivers immediately advance their receive windows\
    \ upon\n         receipt of any PGM data packet or SPM within the transmit\n \
    \        window that advances the receive window.\n"
- title: 2.3.  Network Element Functions
  contents:
  - "2.3.  Network Element Functions\n      Network elements forward ODATA without\
    \ intervention.\n      Source Path State\n         Network elements intercept\
    \ SPMs and use them to establish\n         source path state for the corresponding\
    \ TSI before multicast\n         forwarding them in the usual way.\n      NAK\
    \ Reliability\n         Network elements multicast NCFs to the group in response\
    \ to any\n         NAK they receive.  For each NAK received, network elements\n\
    \         create repair state recording the transport session identifier,\n  \
    \       the sequence number of the NAK, and the input interface on\n         which\
    \ the NAK was received.\n      Constrained NAK Forwarding\n         Network elements\
    \ repeatedly unicast forward only the first copy\n         of any NAK they receive\
    \ to the upstream PGM network element on\n         the distribution path for the\
    \ TSI until they receive an NCF in\n         response.  In addition, they MAY\
    \ optionally multicast this NAK\n         upstream with TTL of 1.\n      Nota\
    \ Bene: Once confirmed by an NCF, network elements discard NAK\n      packets;\
    \ NAKs are NOT retained in network elements beyond this\n      forwarding operation,\
    \ but state about the reception of them is\n      stored.\n      NAK Elimination\n\
    \         Network elements discard exact duplicates of any NAK for which\n   \
    \      they already have repair state (i.e., that has been forwarded\n       \
    \  either by themselves or a neighboring PGM network element), and\n         respond\
    \ with a matching NCF.\n      Constrained RDATA Forwarding\n         Network elements\
    \ use NAKs to maintain repair state consisting\n         of a list of interfaces\
    \ upon which a given NAK was received,\n         and they forward the corresponding\
    \ RDATA only on these\n         interfaces.\n      NAK Anticipation\n        \
    \ If a network element hears an upstream NCF (i.e., on the\n         upstream\
    \ interface for the distribution tree for the TSI), it\n         establishes repair\
    \ state without outgoing interfaces in\n         anticipation of responding to\
    \ and eliminating duplicates of the\n         NAK that may arrive from downstream.\n"
- title: 3.  Terms and Concepts
  contents:
  - "3.  Terms and Concepts\n   Before proceeding from the preceding overview to the\
    \ detail in the\n   subsequent Procedures, this section presents some concepts\
    \ and\n   definitions that make that detail more intelligible.\n"
- title: 3.1.  Transport Session Identifiers
  contents:
  - "3.1.  Transport Session Identifiers\n   Every PGM packet is identified by a:\n\
    \   TSI            transport session identifier\n   TSIs MUST be globally unique,\
    \ and only one source at a time may act\n   as the source for a transport session.\
    \  (Note that repairers do not\n   change the TSI in any RDATA they transmit).\
    \  TSIs are composed of the\n   concatenation of a globally unique source identifier\
    \ (GSI) and a\n   source-assigned data-source port.\n   Since all PGM packets\
    \ originated by receivers are in response to PGM\n   packets originated by a source,\
    \ receivers simply echo the TSI heard\n   from the source in any corresponding\
    \ packets they originate.\n   Since all PGM packets originated by network elements\
    \ are in response\n   to PGM packets originated by a receiver, network elements\
    \ simply echo\n   the TSI heard from the receiver in any corresponding packets\
    \ they\n   originate.\n"
- title: 3.2.  Sequence Numbers
  contents:
  - "3.2.  Sequence Numbers\n   PGM uses a circular sequence number space from 0 through\
    \ ((2**32) -\n   1) to identify and order ODATA packets.  Sources MUST number\
    \ ODATA\n   packets in unit increments in the order in which the corresponding\n\
    \   application data is submitted for transmission.  Within a transmit or\n  \
    \ receive window (defined below), a sequence number x is \"less\" or\n   \"older\"\
    \ than sequence number y if it numbers an ODATA packet\n   preceding ODATA packet\
    \ y, and a sequence number y is \"greater\" or\n   \"more recent\" than sequence\
    \ number x if it numbers an ODATA packet\n   subsequent to ODATA packet x.\n"
- title: 3.3.  Transmit Window
  contents:
  - "3.3.  Transmit Window\n   The description of the operation of PGM rests fundamentally\
    \ on the\n   definition of the source-maintained transmit window.  This definition\n\
    \   in turn is derived directly from the amount of transmitted data (in\n   seconds)\
    \ a source retains for repair (TXW_SECS), and the maximum\n   transmit rate (in\
    \ bytes/second) maintained by a source to regulate\n   its bandwidth utilization\
    \ (TXW_MAX_RTE).\n   In terms of sequence numbers, the transmit window is the\
    \ range of\n   sequence numbers consumed by the source for sequentially numbering\n\
    \   and transmitting the most recent TXW_SECS of ODATA packets.  The\n   trailing\
    \ (or left) edge of the transmit window (TXW_TRAIL) is defined\n   as the sequence\
    \ number of the oldest data packet available for repair\n   from a source.  The\
    \ leading (or right) edge of the transmit window\n   (TXW_LEAD) is defined as\
    \ the sequence number of the most recent data\n   packet a source has transmitted.\n\
    \   The size of the transmit window in sequence numbers (TXW_SQNS) (i.e.,\n  \
    \ the difference between the leading and trailing edges plus one) MUST\n   be\
    \ no greater than half the PGM sequence number space less one.\n   When TXW_TRAIL\
    \ is equal to TXW_LEAD, the transmit window size is one.\n   When TXW_TRAIL is\
    \ equal to TXW_LEAD plus one, the transmit window\n   size is empty.\n"
- title: 3.4.  Receive Window
  contents:
  - "3.4.  Receive Window\n   The receive window at the receivers is determined entirely\
    \ by PGM\n   packets from the source.  That is, a receiver simply obeys what the\n\
    \   source tells it in terms of window state and advancement.\n   For a given\
    \ transport session identified by a TSI, a receiver\n   maintains:\n   RXW_TRAIL\
    \      the sequence number defining the trailing edge of the\n               \
    \   receive window, the sequence number (known from data\n                  packets\
    \ and SPMs) of the oldest data packet available\n                  for repair\
    \ from the source\n   RXW_LEAD       the sequence number defining the leading\
    \ edge of the\n                  receive window, the greatest sequence number\
    \ of any\n                  received data packet within the transmit window\n\
    \   The receive window is the range of sequence numbers a receiver is\n   expected\
    \ to use to identify receivable ODATA.\n   A data packet is described as being\
    \ \"in\" the receive window if its\n   sequence number is in the receive window.\n\
    \   The receive window is advanced by the receiver when it receives an\n   SPM\
    \ or ODATA packet within the transmit window that increments\n   RXW_TRAIL.  Receivers\
    \ also advance their receive windows upon receipt\n   of any PGM data packet within\
    \ the receive window that advances the\n   receive window.\n"
- title: 3.5.  Source Path State
  contents:
  - "3.5.  Source Path State\n   To establish the repair state required to constrain\
    \ RDATA, it's\n   essential that NAKs return from a receiver to a source on the\
    \ reverse\n   of the distribution tree from the source.  That is, they must return\n\
    \   through the same sequence of PGM network elements through which the\n   ODATA\
    \ was forwarded, but in reverse.  There are two reasons for this,\n   the less\
    \ obvious one being by far the more important.\n   The first and obvious reason\
    \ is that RDATA is forwarded on the same\n   path as ODATA and so repair state\
    \ must be established on this path if\n   it is to constrain the propagation of\
    \ RDATA.\n   The second and less obvious reason is that in the absence of repair\n\
    \   state, PGM network elements do NOT forward RDATA, so the default\n   behavior\
    \ is to discard repairs.  If repair state is not properly\n   established for\
    \ interfaces on which ODATA went missing, then\n   receivers on those interfaces\
    \ will continue to NAK for lost data and\n   ultimately experience unrecoverable\
    \ data loss.\n   The principle function of SPMs is to provide the source path\
    \ state\n   required for PGM network elements to forward NAKs from one PGM\n \
    \  network element to the next on the reverse of the distribution tree\n   for\
    \ the TSI, establishing repair state each step of the way.  This\n   source path\
    \ state is simply the address of the upstream PGM network\n   element on the reverse\
    \ of the distribution tree for the TSI.  That\n   upstream PGM network element\
    \ may be more than one subnet hop away.\n   SPMs establish the identity of the\
    \ upstream PGM network element on\n   the distribution tree for each TSI in each\
    \ group in each PGM network\n   element, a sort of virtual PGM topology.  So although\
    \ NAKs are\n   unicast addressed, they are NOT unicast routed by PGM network\n\
    \   elements in the conventional sense.  Instead PGM network elements use\n  \
    \ the source path state established by SPMs to direct NAKs PGM-hop-by-\n   PGM-hop\
    \ toward the source.  The idea is to constrain NAKs to the pure\n   PGM topology\
    \ spanning the more heterogeneous underlying topology of\n   both PGM and non-PGM\
    \ network elements.\n   The result is repair state in every PGM network element\
    \ between the\n   receiver and the source so that the corresponding RDATA is never\n\
    \   discarded by a PGM network element for lack of repair state.\n   SPMs also\
    \ maintain transmit window state in receivers by advertising\n   the trailing\
    \ and leading edges of the transmit window (SPM_TRAIL and\n   SPM_LEAD).  In the\
    \ absence of data, SPMs MAY be used to close the\n   transmit window in time by\
    \ advancing the transmit window until\n   SPM_TRAIL is equal to SPM_LEAD plus\
    \ one.\n"
- title: 3.6.  Packet Contents
  contents:
  - "3.6.  Packet Contents\n   This section just provides enough short-hand to make\
    \ the Procedures\n   intelligible.  For the full details of packet contents, please\
    \ refer\n   to Packet Formats below.\n"
- title: 3.6.1.  Source Path Messages
  contents:
  - '3.6.1.  Source Path Messages

    '
- title: 3.6.1.1.  SPMs
  contents:
  - "3.6.1.1.  SPMs\n   SPMs are transmitted by sources to establish source-path state\
    \ in PGM\n   network elements, and to provide transmit-window state in receivers.\n\
    \   SPMs are multicast to the group and contain:\n   SPM_TSI        the source-assigned\
    \ TSI for the session to which the\n                  SPM corresponds\n   SPM_SQN\
    \        a sequence number assigned sequentially by the source\n             \
    \     in unit increments and scoped by SPM_TSI\n      Nota Bene: this is an entirely\
    \ separate sequence than is used to\n      number ODATA and RDATA.\n   SPM_TRAIL\
    \      the sequence number defining the trailing edge of the\n               \
    \   source's transmit window (TXW_TRAIL)\n   SPM_LEAD       the sequence number\
    \ defining the leading edge of the\n                  source's transmit window\
    \ (TXW_LEAD)\n   SPM_PATH       the network-layer address (NLA) of the interface\
    \ on\n                  the PGM network element on which the SPM is forwarded\n"
- title: 3.6.2.  Data Packets
  contents:
  - '3.6.2.  Data Packets

    '
- title: 3.6.2.1.  ODATA - Original Data
  contents:
  - "3.6.2.1.  ODATA - Original Data\n   ODATA packets are transmitted by sources\
    \ to send application data to\n   receivers.\n   ODATA packets are multicast to\
    \ the group and contain:\n   OD_TSI         the globally unique source-assigned\
    \ TSI\n   OD_TRAIL       the sequence number defining the trailing edge of the\n\
    \                  source's transmit window (TXW_TRAIL)\n                  OD_TRAIL\
    \ makes the protocol more robust in the face of\n                  lost SPMs.\
    \  By including the trailing edge of the\n                  transmit window on\
    \ every data packet, receivers that\n                  have missed any SPMs that\
    \ advanced the transmit window\n                  can still detect the case, recover\
    \ the application,\n                  and potentially re-synchronize to the transport\n\
    \                  session.\n   OD_SQN         a sequence number assigned sequentially\
    \ by the source\n                  in unit increments and scoped by OD_TSI\n"
- title: 3.6.2.2.  RDATA - Repair Data
  contents:
  - "3.6.2.2.  RDATA - Repair Data\n   RDATA packets are repair packets transmitted\
    \ by sources or DLRs in\n   response to NAKs.\n   RDATA packets are multicast\
    \ to the group and contain:\n   RD_TSI         OD_TSI of the ODATA packet for\
    \ which this is a repair\n   RD_TRAIL       the sequence number defining the trailing\
    \ edge of the\n                  source's transmit window (TXW_TRAIL).  This is\
    \ updated\n                  to the most current value when the repair is sent,\
    \ so\n                  it is not necessarily the same as OD_TRAIL of the\n  \
    \                ODATA packet for which this is a repair\n   RD_SQN         OD_SQN\
    \ of the ODATA packet for which this is a repair\n"
- title: 3.6.3.  Negative Acknowledgments
  contents:
  - '3.6.3.  Negative Acknowledgments

    '
- title: 3.6.3.1.  NAKs - Negative Acknowledgments
  contents:
  - "3.6.3.1.  NAKs - Negative Acknowledgments\n   NAKs are transmitted by receivers\
    \ to request repairs for missing data\n   packets.\n   NAKs are unicast (PGM-hop-by-PGM-hop)\
    \ to the source and contain:\n   NAK_TSI        OD_TSI of the ODATA packet for\
    \ which a repair is\n                  requested\n   NAK_SQN        OD_SQN of\
    \ the ODATA packet for which a repair is\n                  requested\n   NAK_SRC\
    \        the unicast NLA of the original source of the missing\n             \
    \     ODATA.\n   NAK_GRP        the multicast group NLA\n"
- title: 3.6.3.2.  NNAKs - Null Negative Acknowledgments
  contents:
  - "3.6.3.2.  NNAKs - Null Negative Acknowledgments\n   NNAKs are transmitted by\
    \ a DLR that receives NAKs redirected to it by\n   either receivers or network\
    \ elements to provide flow-control feed-\n   back to a source.\n   NNAKs are unicast\
    \ (PGM-hop-by-PGM-hop) to the source and contain:\n   NNAK_TSI       NAK_TSI of\
    \ the corresponding re-directed NAK.\n   NNAK_SQN       NAK_SQN of the corresponding\
    \ re-directed NAK.\n   NNAK_SRC       NAK_SRC of the corresponding re-directed\
    \ NAK.\n   NNAK_GRP       NAK_GRP of the corresponding re-directed NAK.\n"
- title: 3.6.4.  Negative Acknowledgment Confirmations
  contents:
  - '3.6.4.  Negative Acknowledgment Confirmations

    '
- title: 3.6.4.1.  NCFs - NAK confirmations
  contents:
  - "3.6.4.1.  NCFs - NAK confirmations\n   NCFs are transmitted by network elements\
    \ and sources in response to\n   NAKs.\n   NCFs are multicast to the group and\
    \ contain:\n   NCF_TSI        NAK_TSI of the NAK being confirmed\n   NCF_SQN \
    \       NAK_SQN of the NAK being confirmed\n   NCF_SRC        NAK_SRC of the NAK\
    \ being confirmed\n   NCF_GRP        NAK_GRP of the NAK being confirmed\n"
- title: 3.6.5.  Option Encodings
  contents:
  - "3.6.5.  Option Encodings\n   OPT_LENGTH      0x00 - Option's Length\n   OPT_FRAGMENT\
    \    0x01 - Fragmentation\n   OPT_NAK_LIST    0x02 - List of NAK entries\n   OPT_JOIN\
    \        0x03 - Late Joining\n   OPT_REDIRECT    0x07 - Redirect\n   OPT_SYN \
    \        0x0D - Synchronization\n   OPT_FIN         0x0E - Session Fin   receivers,\
    \ conventional\n                          feedbackish\n   OPT_RST         0x0F\
    \ - Session Reset\n   OPT_PARITY_PRM  0x08 - Forward Error Correction Parameters\n\
    \   OPT_PARITY_GRP  0x09 - Forward Error Correction Group Number\n   OPT_CURR_TGSIZE\
    \ 0x0A - Forward Error Correction Group Size\n   OPT_CR          0x10 - Congestion\
    \ Report\n   OPT_CRQST       0x11 - Congestion Report Request\n   OPT_NAK_BO_IVL\
    \  0x04 - NAK Back-Off Interval\n   OPT_NAK_BO_RNG  0x05 - NAK Back-Off Range\n\
    \   OPT_NBR_UNREACH 0x0B - Neighbor Unreachable\n   OPT_PATH_NLA    0x0C - Path\
    \ NLA\n   OPT_INVALID     0x7F - Option invalidated\n"
- title: 4.  Procedures - General
  contents:
  - "4.  Procedures - General\n   Since SPMs, NCFs, and RDATA must be treated conditionally\
    \ by PGM\n   network elements, they must be distinguished from other packets in\n\
    \   the chosen multicast network protocol if PGM network elements are to\n   extract\
    \ them from the usual switching path.\n   The most obvious way for network elements\
    \ to achieve this is to\n   examine every packet in the network for the PGM transport\
    \ protocol\n   and packet types.  However, the overhead of this approach is costly\n\
    \   for high-performance, multi-protocol network elements.  An\n   alternative,\
    \ and a requirement for PGM over IP multicast, is that\n   SPMs, NCFs, and RDATA\
    \ MUST be transmitted with the IP Router Alert\n   Option [6].  This option gives\
    \ network elements a network-layer\n   indication that a packet should be extracted\
    \ from IP switching for\n   more detailed processing.\n"
- title: 5.  Procedures - Sources
  contents:
  - '5.  Procedures - Sources

    '
- title: 5.1.  Data Transmission
  contents:
  - "5.1.  Data Transmission\n   Since PGM relies on a purely rate-limited transmission\
    \ strategy in\n   the source to bound the bandwidth consumed by PGM transport\
    \ sessions,\n   an assortment of techniques is assembled here to make that strategy\n\
    \   as conservative and robust as possible.  These techniques are the\n   minimum\
    \ REQUIRED of a PGM source.\n"
- title: 5.1.1.  Maximum Cumulative Transmit Rate
  contents:
  - "5.1.1.  Maximum Cumulative Transmit Rate\n   A source MUST number ODATA packets\
    \ in the order in which they are\n   submitted for transmission by the application.\
    \  A source MUST\n   transmit ODATA packets in sequence and only within the transmit\n\
    \   window beginning with TXW_TRAIL at no greater a rate than\n   TXW_MAX_RTE.\n\
    \   TXW_MAX_RTE is typically the maximum cumulative transmit rate of SPM,\n  \
    \ ODATA, and RDATA.  Different transmission strategies MAY define\n   TXW_MAX_RTE\
    \ as appropriate for the implementation.\n"
- title: 5.1.2.  Transmit Rate Regulation
  contents:
  - "5.1.2.  Transmit Rate Regulation\n   To regulate its transmit rate, a source\
    \ MUST use a token bucket\n   scheme or any other traffic management scheme that\
    \ yields equivalent\n   behavior.  A token bucket [7] is characterized by a continually\n\
    \   sustainable data rate (the token rate) and the extent to which the\n   data\
    \ rate may exceed the token rate for short periods of time (the\n   token bucket\
    \ size).  Over any arbitrarily chosen interval, the number\n   of bytes the source\
    \ may transmit MUST NOT exceed the token bucket\n   size plus the product of the\
    \ token rate and the chosen interval.\n   In addition, a source MUST bound the\
    \ maximum rate at which successive\n   packets may be transmitted using a leaky\
    \ bucket scheme drained at a\n   maximum transmit rate, or equivalent mechanism.\n"
- title: 5.1.3.  Outgoing Packet Ordering
  contents:
  - "5.1.3.  Outgoing Packet Ordering\n   To preserve the logic of PGM's transmit\
    \ window, a source MUST\n   strictly prioritize sending of pending NCFs first,\
    \ pending SPMs\n   second, and only send ODATA or RDATA when no NCFs or SPMs are\n\
    \   pending.  The priority of RDATA versus ODATA is application\n   dependent.\
    \  The sender MAY implement weighted bandwidth sharing\n   between RDATA and ODATA.\
    \  Note that strict prioritization of RDATA\n   over ODATA may stall progress\
    \ of ODATA if there are receivers that\n   keep generating NAKs so as to always\
    \ have RDATA pending (e.g. a\n   steady stream of late joiners with OPT_JOIN).\
    \  Strictly prioritizing\n   ODATA over RDATA may lead to a larger portion of\
    \ receivers getting\n   unrecoverable losses.\n"
- title: 5.1.4.  Ambient SPMs
  contents:
  - "5.1.4.  Ambient SPMs\n   Interleaved with ODATA and RDATA, a source MUST transmit\
    \ SPMs at a\n   rate at least sufficient to maintain current source path state\
    \ in PGM\n   network elements.  Note that source path state in network elements\n\
    \   does not track underlying changes in the distribution tree from a\n   source\
    \ until an SPM traverses the altered distribution tree.  The\n   consequence is\
    \ that NAKs may go unconfirmed both at receivers and\n   amongst network elements\
    \ while changes in the underlying distribution\n   tree take place.\n"
- title: 5.1.5.  Heartbeat SPMs
  contents:
  - "5.1.5.  Heartbeat SPMs\n   In the absence of data to transmit, a source SHOULD\
    \ transmit SPMs at\n   a decaying rate in order to assist early detection of lost\
    \ data, to\n   maintain current source path state in PGM network elements, and\
    \ to\n   maintain current receive window state in the receivers.\n   In this scheme\
    \ [8], a source maintains an inter-heartbeat timer\n   IHB_TMR which times the\
    \ interval between the most recent packet\n   (ODATA, RDATA, or SPM) transmission\
    \ and the next heartbeat\n   transmission.  IHB_TMR is initialized to a minimum\
    \ interval IHB_MIN\n   after the transmission of any data packet.  If IHB_TMR\
    \ expires, the\n   source transmits a heartbeat SPM and initializes IHB_TMR to\
    \ double\n   its previous value.  The transmission of consecutive heartbeat SPMs\n\
    \   doubles IHB each time up to a maximum interval IHB_MAX.  The\n   transmission\
    \ of any data packet initializes IHB_TMR to IHB_MIN once\n   again.  The effect\
    \ is to provoke prompt detection of missing packets\n   in the absence of data\
    \ to transmit, and to do so with minimal\n   bandwidth overhead.\n"
- title: 5.1.6.  Ambient and Heartbeat SPMs
  contents:
  - "5.1.6.  Ambient and Heartbeat SPMs\n   Ambient and heartbeat SPMs are described\
    \ as driven by separate timers\n   in this specification to highlight their contrasting\
    \ functions.\n   Ambient SPMs are driven by a count-down timer that expires regularly\n\
    \   while heartbeat SPMs are driven by a count-down timer that keeps\n   being\
    \ reset by data, and the interval of which changes once it begins\n   to expire.\
    \  The ambient SPM timer is just counting down in real-time\n   while the heartbeat\
    \ timer is measuring the inter-data-packet\n   interval.\n   In the presence of\
    \ data, no heartbeat SPMs will be transmitted since\n   the transmission of data\
    \ keeps setting the IHB_TMR back to its\n   initial value.  At the same time however,\
    \ ambient SPMs MUST be\n   interleaved into the data as a matter of course, not\
    \ necessarily as a\n   heartbeat mechanism.  This ambient transmission of SPMs\
    \ is REQUIRED\n   to keep the distribution tree information in the network current\
    \ and\n   to allow new receivers to synchronize with the session.\n   An implementation\
    \ SHOULD de-couple ambient and heartbeat SPM timers\n   sufficiently to permit\
    \ them to be configured independently of each\n   other.\n"
- title: 5.2.  Negative Acknowledgment Confirmation
  contents:
  - "5.2.  Negative Acknowledgment Confirmation\n   A source MUST immediately multicast\
    \ an NCF in response to any NAK it\n   receives.  The NCF is REQUIRED since the\
    \ alternative of responding\n   immediately with RDATA would not allow other PGM\
    \ network elements on\n   the same subnet to do NAK anticipation, nor would it\
    \ allow DLRs on\n   the same subnet to provide repairs.  A source SHOULD be able\
    \ to\n   detect a NAK storm and adopt countermeasure to protect the network\n\
    \   against a denial of service.  A possible countermeasure is to send\n   the\
    \ first NCF immediately in response to a NAK and then delay the\n   generation\
    \ of further NCFs (for identical NAKs) by a small interval,\n   so that identical\
    \ NCFs are rate-limited, without affecting the\n   ability to suppress NAKs.\n"
- title: 5.3.  Repairs
  contents:
  - "5.3.  Repairs\n   After multicasting an NCF in response to a NAK, a source MUST\
    \ then\n   multicast RDATA (while respecting TXW_MAX_RTE) in response to any NAK\n\
    \   it receives for data packets within the transmit window.\n   In the interest\
    \ of increasing the efficiency of a particular RDATA\n   packet, a source MAY\
    \ delay RDATA transmission to accommodate the\n   arrival of NAKs from the whole\
    \ loss neighborhood.  This delay SHOULD\n   not exceed twice the greatest propagation\
    \ delay in the loss\n   neighborhood.\n"
- title: 6.  Procedures - Receivers
  contents:
  - '6.  Procedures - Receivers

    '
- title: 6.1.  Data Reception
  contents:
  - "6.1.  Data Reception\n   Initial data reception\n   A receiver SHOULD initiate\
    \ data reception beginning with the first\n   data packet it receives within the\
    \ advertised transmit window.  This\n   packet's sequence number (ODATA_SQN) temporarily\
    \ defines the trailing\n   edge of the transmit window from the receiver's perspective.\
    \  That\n   is, it is assigned to RXW_TRAIL_INIT within the receiver, and until\n\
    \   the trailing edge sequence number advertised in subsequent packets\n   (SPMs\
    \ or ODATA or RDATA) increments past RXW_TRAIL_INIT, the receiver\n   MUST only\
    \ request repairs for sequence numbers subsequent to\n   RXW_TRAIL_INIT.  Thereafter,\
    \ it MAY request repairs anywhere in the\n   transmit window.  This temporary\
    \ restriction on repair requests\n   prevents receivers from requesting a potentially\
    \ large amount of\n   history when they first begin to receive a given PGM transport\n\
    \   session.\n   Note that the JOIN option, discussed later, MAY be used to provide\
    \ a\n   different value for RXW_TRAIL_INIT.\n   Receiving and discarding data\
    \ packets\n   Within a given transport session, a receiver MUST accept any ODATA\
    \ or\n   RDATA packets within the receive window.  A receiver MUST discard any\n\
    \   data packet that duplicates one already received in the transmit\n   window.\
    \  A receiver MUST discard any data packet outside of the\n   receive window.\n\
    \   Contiguous data\n   Contiguous data is comprised of those data packets within\
    \ the receive\n   window that have been received and are in the range from RXW_TRAIL\
    \ up\n   to (but not including) the first missing sequence number in the\n   receive\
    \ window.  The most recently received data packet of contiguous\n   data defines\
    \ the leading edge of contiguous data.\n   As its default mode of operation, a\
    \ receiver MUST deliver only\n   contiguous data packets to the application, and\
    \ it MUST do so in the\n   order defined by those data packets' sequence numbers.\
    \  This provides\n   applications with a reliable ordered data flow.\n   Non contiguous\
    \ data\n   PGM receiver implementations MAY optionally provide a mode of\n   operation\
    \ in which data is delivered to an application in the order\n   received.  However,\
    \ the implementation MUST only deliver complete\n   application protocol data\
    \ units (APDUs) to the application.  That is,\n   APDUs that have been fragmented\
    \ into different TPDUs MUST be\n   reassembled before delivery to the application.\n"
- title: 6.2.  Source Path Messages
  contents:
  - "6.2.  Source Path Messages\n   Receivers MUST receive and sequence SPMs for any\
    \ TSI they are\n   receiving.  An SPM is in sequence if its sequence number is\
    \ greater\n   than that of the most recent in-sequence SPM and within half the\
    \ PGM\n   number space.  Out-of-sequence SPMs MUST be discarded.\n   For each\
    \ TSI, receivers MUST use the most recent SPM to determine the\n   NLA of the\
    \ upstream PGM network element for use in NAK addressing.  A\n   receiver MUST\
    \ NOT initiate repair requests until it has received at\n   least one SPM for\
    \ the corresponding TSI.\n   Since SPMs require per-hop processing, it is likely\
    \ that they will be\n   forwarded at a slower rate than data, and that they will\
    \ arrive out\n   of sync with the data stream.  In this case, the window information\n\
    \   that the SPMs carry will be out of date.  Receivers SHOULD expect\n   this\
    \ to be the case and SHOULD detect it by comparing the packet lead\n   and trail\
    \ values with the values the receivers have stored for lead\n   and trail.  If\
    \ the SPM packet values are less, they SHOULD be\n   ignored, but the rest of\
    \ the packet SHOULD be processed as normal.\n"
- title: 6.3.  Data Recovery by Negative Acknowledgment
  contents:
  - "6.3.  Data Recovery by Negative Acknowledgment\n   Detecting missing data packets\n\
    \   Receivers MUST detect gaps in the expected data sequence in the\n   following\
    \ manners:\n      by comparing the sequence number on the most recently received\n\
    \      ODATA or RDATA packet with the leading edge of contiguous data\n      by\
    \ comparing SPM_LEAD of the most recently received SPM with the\n      leading\
    \ edge of contiguous data\n   In both cases, if the receiver has not received\
    \ all intervening data\n   packets, it MAY initiate selective NAK generation for\
    \ each missing\n   sequence number.\n   In addition, a receiver may detect a single\
    \ missing data packet by\n   receiving an NCF or multicast NAK for a data packet\
    \ within the\n   transmit window which it has not received.  In this case it MAY\n\
    \   initiate selective NAK generation for the said sequence number.\n   In all\
    \ cases, receivers SHOULD temper the initiation of NAK\n   generation to account\
    \ for simple mis-ordering introduced by the\n   network.  A possible mechanism\
    \ to achieve this is to assume loss only\n   after the reception of N packets\
    \ with sequence numbers higher than\n   those of the (assumed) lost packets. \
    \ A possible value for N is 2.\n   This method SHOULD be complemented with a timeout\
    \ based mechanism\n   that handles the loss of the last packet before a pause\
    \ in the\n   transmission of the data stream.  The leading edge field in SPMs\n\
    \   SHOULD also be taken into account in the loss detection algorithm.\n   Generating\
    \ NAKs\n   NAK generation follows the detection of a missing data packet and is\n\
    \   the cycle of:\n      waiting for a random period of time (NAK_RB_IVL) while\
    \ listening\n      for matching NCFs or NAKs\n      transmitting a NAK if a matching\
    \ NCF or NAK is not heard\n      waiting a period (NAK_RPT_IVL) for a matching\
    \ NCF and recommencing\n      NAK generation if the matching NCF is not received\n\
    \      waiting a period (NAK_RDATA_IVL) for data and recommencing NAK\n      generation\
    \ if the matching data is not received\n   The entire generation process can be\
    \ summarized by the following\n   state machine:\n                           \
    \   |\n                              | detect missing tpdu\n                 \
    \             |   - clear data retry count\n                              |  \
    \ - clear NCF retry count\n                              V\n      matching NCF\
    \ |--------------------------|\n   <---------------|   BACK-OFF_STATE        \
    \ | <----------------------\n   |               | start timer(NAK_RB_IVL)  | \
    \           ^          ^\n   |               |                          |    \
    \        |          |\n   |               |--------------------------|       \
    \     |          |\n   |       matching |         | timer expires            \
    \  |          |\n   |         NAK    |         |   - send NAK               |\
    \          |\n   |                |         |                            |   \
    \       |\n   |                V         V                            |      \
    \    |\n   |               |--------------------------|            |         \
    \ |\n   |               |    WAIT_NCF_STATE        |            |          |\n\
    \   |  matching NCF | start timer(NAK_RPT_IVL) |            |          |\n   |<--------------|\
    \                          |------------>          |\n   |               |--------------------------|\
    \ timer expires         |\n   |                    |         |         ^    -\
    \ increment NCF      |\n   |    NAK_NCF_RETRIES |         |         |      retry\
    \ count        |\n   |       exceeded     |         |         |              \
    \           |\n   |                    V         -----------                 \
    \        |\n   |                Cancelation      matching NAK                \
    \     |\n   |                                   - restart timer(NAK_RPT_IVL) \
    \  |\n   |                                                                  |\n\
    \   |                                                                  |\n   V\
    \               |--------------------------|                       |\n   --------------->|\
    \   WAIT_DATA_STATE        |----------------------->\n                   |start\
    \ timer(NAK_RDATA_IVL)|  timer expires\n                   |                 \
    \         |   - increment data\n                   |--------------------------|\
    \     retry count\n                      |        |           ^\n     NAK_DATA_RETRIES\
    \ |        |           |\n         exceeded     |        |           |\n     \
    \                 |         -----------\n                      |          matching\
    \ NCF or NAK\n                      V            - restart timer(NAK_RDATA_IVL)\n\
    \                 Cancellation\n   In any state, receipt of matching RDATA or\
    \ ODATA completes data\n   recovery and successful exit from the state machine.\
    \  State\n   transition stops any running timers.\n   In any state, if the trailing\
    \ edge of the window moves beyond the\n   sequence number, data recovery for that\
    \ sequence number terminates.\n   During NAK_RB_IVL a NAK is said to be pending.\
    \  When awaiting data or\n   an NCF, a NAK is said to be outstanding.\n   Backing\
    \ off NAK transmission\n   Before transmitting a NAK, a receiver MUST wait some\
    \ interval\n   NAK_RB_IVL chosen randomly over some time period NAK_BO_IVL.  During\n\
    \   this period, receipt of a matching NAK or a matching NCF will suspend\n  \
    \ NAK generation.  NAK_RB_IVL is counted down from the time a missing\n   data\
    \ packet is detected.\n   A value for NAK_BO_IVL learned from OPT_NAK_BO_IVL (see\
    \ 16.4.1 below)\n   MUST NOT be used by a receiver (i.e., the receiver MUST NOT\
    \ NAK)\n   unless either NAK_BO_IVL_SQN is zero, or the receiver has seen\n  \
    \ POLL_RND == 0 for POLL_SQN =< NAK_BO_IVL_SQN within half the sequence\n   number\
    \ space.\n   When a parity NAK (Appendix A, FEC) is being generated, the back-off\n\
    \   interval SHOULD be inversely biased with respect to the number of\n   parity\
    \ packets requested.  This way NAKs requesting larger numbers of\n   parity packets\
    \ are likely to be sent first and thus suppress other\n   NAKs.  A NAK for a given\
    \ transmission group suppresses another NAK\n   for the same transmission group\
    \ only if it is requesting an equal or\n   larger number of parity packets.\n\
    \   When a receiver has to transmit a sequence of NAKs, it SHOULD\n   transmit\
    \ the NAKs in order from oldest to most recent.\n   Suspending NAK generation\n\
    \   Suspending NAK generation just means waiting for either NAK_RB_IVL,\n   NAK_RPT_IVL\
    \ or NAK_RDATA_IVL to pass.  A receiver MUST suspend NAK\n   generation if a duplicate\
    \ of the NAK is already pending from this\n   receiver or the NAK is already outstanding\
    \ from this or another\n   receiver.\n   NAK suppression\n   A receiver MUST suppress\
    \ NAK generation and wait at least\n   NAK_RDATA_IVL before recommencing NAK generation\
    \ if it hears a\n   matching NCF or NAK during NAK_RB_IVL.  A matching NCF must\
    \ match\n   NCF_TSI with NAK_TSI, and NCF_SQN with NAK_SQN.\n   Transmitting a\
    \ NAK\n   Upon expiry of NAK_RB_IVL, a receiver MUST unicast a NAK to the\n  \
    \ upstream PGM network element for the TSI specifying the transport\n   session\
    \ identifier and missing sequence number.  In addition, it MAY\n   multicast a\
    \ NAK with TTL of 1 to the group, if the PGM parent is not\n   directly connected.\
    \  It also records both the address of the source\n   of the corresponding ODATA\
    \ and the address of the group in the NAK\n   header.\n   It MUST repeat the NAK\
    \ at a rate governed by NAK_RPT_IVL up to\n   NAK_NCF_RETRIES times while waiting\
    \ for a matching NCF.  It MUST then\n   wait NAK_RDATA_IVL before recommencing\
    \ NAK generation.  If it hears a\n   matching NCF or NAK during NAK_RDATA_IVL,\
    \ it MUST wait anew for\n   NAK_RDATA_IVL before recommencing NAK generation (i.e.\
    \ matching NCFs\n   and NAKs restart NAK_RDATA_IVL).\n   Completion of NAK generation\n\
    \   NAK generation is complete only upon the receipt of the matching\n   RDATA\
    \ (or even ODATA) packet at any time during NAK generation.\n   Cancellation of\
    \ NAK generation\n   NAK generation is cancelled upon the advancing of the receive\
    \ window\n   so as to exclude the matching sequence number of a pending or\n \
    \  outstanding NAK, or NAK_DATA_RETRIES / NAK_NCF_RETRIES being\n   exceeded.\
    \  Cancellation of NAK generation indicates unrecoverable\n   data loss.\n   Receiving\
    \ NCFs and multicast NAKs\n   A receiver MUST discard any NCFs or NAKs it hears\
    \ for data packets\n   outside the transmit window or for data packets it has\
    \ received.\n   Otherwise they are treated as appropriate for the current repair\n\
    \   state.\n"
- title: 7.  Procedures - Network Elements
  contents:
  - '7.  Procedures - Network Elements

    '
- title: 7.1.  Source Path State
  contents:
  - "7.1.  Source Path State\n   Upon receipt of an in-sequence SPM, a network element\
    \ records the\n   Source Path Address SPM_PATH with the multicast routing information\n\
    \   for the TSI.  If the receiving network element is on the same subnet\n   as\
    \ the forwarding network element, this address will be the same as\n   the address\
    \ of the immediately upstream network element on the\n   distribution tree for\
    \ the TSI.  If, however, non-PGM network elements\n   intervene between the forwarding\
    \ and the receiving network elements,\n   this address will be the address of\
    \ the first PGM network element\n   across the intervening network elements.\n\
    \   The network element then forwards the SPM on each outgoing interface\n   for\
    \ that TSI.  As it does so, it encodes the network address of the\n   outgoing\
    \ interface in SPM_PATH in each copy of the SPM it forwards.\n"
- title: 7.2.  NAK Confirmation
  contents:
  - "7.2.  NAK Confirmation\n   Network elements MUST immediately transmit an NCF\
    \ in response to any\n   unicast NAK they receive.  The NCF MUST be multicast\
    \ to the group on\n   the interface on which the NAK was received.\n      Nota\
    \ Bene: In order to avoid creating multicast routing state for\n      PGM network\
    \ elements across non-PGM-capable clouds, the network-\n      header source address\
    \ of NCFs transmitted by network elements MUST\n      be set to the ODATA source's\
    \ NLA, not the network element's NLA as\n      might be expected.\n   Network\
    \ elements should be able to detect a NAK storm and adopt\n   counter-measure\
    \ to protect the network against a denial of service.\n   A possible countermeasure\
    \ is to send the first NCF immediately in\n   response to a NAK and then delay\
    \ the generation of further NCFs (for\n   identical NAKs) by a small interval,\
    \ so that identical NCFs are\n   rate-limited, without affecting the ability to\
    \ suppress NAKs.\n   Simultaneously, network elements MUST establish repair state\
    \ for the\n   NAK if such state does not already exist, and add the interface\
    \ on\n   which the NAK was received to the corresponding repair interface list\n\
    \   if the interface is not already listed.\n"
- title: 7.3.  Constrained NAK Forwarding
  contents:
  - "7.3.  Constrained NAK Forwarding\n   The NAK forwarding procedures for network\
    \ elements are quite similar\n   to those for receivers, but three important differences\
    \ should be\n   noted.\n   First, network elements do NOT back off before forwarding\
    \ a NAK\n   (i.e., there is no NAK_BO_IVL) since the resulting delay of the NAK\n\
    \   would compound with each hop.  Note that NAK arrivals will be\n   randomized\
    \ by the receivers from which they originate, and this\n   factor in conjunction\
    \ with NAK anticipation and elimination will\n   combine to forestall NAK storms\
    \ on subnets with a dense network\n   element population.\n   Second, network\
    \ elements do NOT retry confirmed NAKs if RDATA is not\n   seen; they simply discard\
    \ the repair state and rely on receivers to\n   re-request the repair.  This approach\
    \ keeps the repair state in the\n   network elements relatively ephemeral and\
    \ responsive to underlying\n   routing changes.\n   Third, note that ODATA does\
    \ NOT cancel NAK forwarding in network\n   elements since it is switched by network\
    \ elements without transport-\n   layer intervention.\n      Nota Bene: Once confirmed\
    \ by an NCF, network elements discard NAK\n      packets; they are NOT retained\
    \ in network elements beyond this\n      forwarding operation.\n   NAK forwarding\
    \ requires that a network element listen to NCFs for the\n   same transport session.\
    \  NAK forwarding also requires that a network\n   element observe two time out\
    \ intervals for any given NAK (i.e., per\n   NAK_TSI and NAK_SQN): NAK_RPT_IVL\
    \ and NAK_RDATA_IVL.\n   The NAK repeat interval NAK_RPT_IVL, limits the length\
    \ of time for\n   which a network element will repeat a NAK while waiting for\
    \ a\n   corresponding NCF.  NAK_RPT_IVL is counted down from the transmission\n\
    \   of a NAK.  Expiry of NAK_RPT_IVL cancels NAK forwarding (due to\n   missing\
    \ NCF).\n   The NAK RDATA interval NAK_RDATA_IVL, limits the length of time for\n\
    \   which a network element will wait for the corresponding RDATA.\n   NAK_RDATA_IVL\
    \ is counted down from the time a matching NCF is\n   received.  Expiry of NAK_RDATA_IVL\
    \ causes the network element to\n   discard the corresponding repair state (due\
    \ to missing RDATA).\n   During NAK_RPT_IVL, a NAK is said to be pending.  During\n\
    \   NAK_RDATA_IVL, a NAK is said to be outstanding.\n   A Network element MUST\
    \ forward NAKs only to the upstream PGM network\n   element for the TSI.\n   A\
    \ network element MUST repeat a NAK at a rate of NAK_RPT_RTE for an\n   interval\
    \ of NAK_RPT_IVL until it receives a matching NCF.  A matching\n   NCF must match\
    \ NCF_TSI with NAK_TSI, and NCF_SQN with NAK_SQN.\n   Upon reception of the corresponding\
    \ NCF, network elements MUST wait\n   at least NAK_RDATA_IVL for the corresponding\
    \ RDATA.  Receipt of the\n   corresponding RDATA at any time during NAK forwarding\
    \ cancels NAK\n   forwarding and tears down the corresponding repair state in\
    \ the\n   network element.\n"
- title: 7.4.  NAK elimination
  contents:
  - "7.4.  NAK elimination\n   Two NAKs duplicate each other if they bear the same\
    \ NAK_TSI and\n   NAK_SQN.  Network elements MUST discard all duplicates of a\
    \ NAK that\n   is pending.\n   Once a NAK is outstanding, network elements MUST\
    \ discard all\n   duplicates of that NAK for NAK_ELIM_IVL.  Upon expiry of\n \
    \  NAK_ELIM_IVL, network elements MUST suspend NAK elimination for that\n   TSI/SQN\
    \ until the first duplicate of that NAK is seen after the\n   expiry of NAK_ELIM_IVL.\
    \  This duplicate MUST be forwarded in the\n   usual manner.  Once this duplicate\
    \ NAK is outstanding, network\n   elements MUST once again discard all duplicates\
    \ of that NAK for\n   NAK_ELIM_IVL, and so on.  NAK_RDATA_IVL MUST be reset each\
    \ time a NAK\n   for the corresponding TSI/SQN is confirmed (i.e., each time\n\
    \   NAK_ELIM_IVL is reset).  NAK_ELIM_IVL MUST be some small fraction of\n   NAK_RDATA_IVL.\n\
    \   NAK_ELIM_IVL acts to balance implosion prevention against repair\n   state\
    \ liveness.  That is, it results in the elimination of all but at\n   most one\
    \ NAK per NAK_ELIM_IVL thereby allowing repeated NAKs to keep\n   the repair state\
    \ alive in the PGM network elements.\n"
- title: 7.5.  NAK Anticipation
  contents:
  - "7.5.  NAK Anticipation\n   An unsolicited NCF is one that is received by a network\
    \ element when\n   the network element has no corresponding pending or outstanding\
    \ NAK.\n   Network elements MUST process unsolicited NCFs differently depending\n\
    \   on the interface on which they are received.\n   If the interface on which\
    \ an NCF is received is the same interface\n   the network element would use to\
    \ reach the upstream PGM network\n   element, the network element simply establishes\
    \ repair state for\n   NCF_TSI and NCF_SQN without adding the interface to the\
    \ repair\n   interface list, and discards the NCF.  If the repair state already\n\
    \   exists, the network element restarts the NAK_RDATA_IVL and\n   NAK_ELIM_IVL\
    \ timers and discards the NCF.\n   If the interface on which an NCF is received\
    \ is not the same\n   interface the network element would use to reach the upstream\
    \ PGM\n   network element, the network element does not establish repair state\n\
    \   and just discards the NCF.\n   Anticipated NAKs permit the elimination of\
    \ any subsequent matching\n   NAKs from downstream.  Upon establishing anticipated\
    \ repair state,\n   network elements MUST eliminate subsequent NAKs only for a\
    \ period of\n   NAK_ELIM_IVL.  Upon expiry of NAK_ELIM_IVL, network elements MUST\n\
    \   suspend NAK elimination for that TSI/SQN until the first duplicate of\n  \
    \ that NAK is seen after the expiry of NAK_ELIM_IVL.  This duplicate\n   MUST\
    \ be forwarded in the usual manner.  Once this duplicate NAK is\n   outstanding,\
    \ network elements MUST once again discard all duplicates\n   of that NAK for\
    \ NAK_ELIM_IVL, and so on.  NAK_RDATA_IVL MUST be reset\n   each time a NAK for\
    \ the corresponding TSI/SQN is confirmed (i.e.,\n   each time NAK_ELIM_IVL is\
    \ reset).  NAK_ELIM_IVL must be some small\n   fraction of NAK_RDATA_IVL.\n"
- title: 7.6.  NAK Shedding
  contents:
  - "7.6.  NAK Shedding\n   Network elements MAY implement local procedures for withholding\
    \ NAK\n   confirmations for receivers detected to be reporting excessive loss.\n\
    \   The result of these procedures would ultimately be unrecoverable data\n  \
    \ loss in the receiver.\n"
- title: 7.7.  Addressing NAKs
  contents:
  - "7.7.  Addressing NAKs\n   A PGM network element uses the source and group addresses\
    \ (NLAs)\n   contained in the transport header to find the state for the\n   corresponding\
    \ TSI, looks up the corresponding upstream PGM network\n   element's address,\
    \ uses it to re-address the (unicast) NAK, and\n   unicasts it on the upstream\
    \ interface for the distribution tree for\n   the TSI.\n"
- title: 7.8.  Constrained RDATA Forwarding
  contents:
  - "7.8.  Constrained RDATA Forwarding\n   Network elements MUST maintain repair\
    \ state for each interface on\n   which a given NAK is received at least once.\
    \  Network elements MUST\n   then use this list of interfaces to constrain the\
    \ forwarding of the\n   corresponding RDATA packet only to those interfaces in\
    \ the list.  An\n   RDATA packet corresponds to a NAK if it matches NAK_TSI and\
    \ NAK_SQN.\n   Network elements MUST maintain this repair state only until either\n\
    \   the corresponding RDATA is received and forwarded, or NAK_RDATA_IVL\n   passes\
    \ after forwarding the most recent instance of a given NAK.\n   Thereafter, the\
    \ corresponding repair state MUST be discarded.\n   Network elements SHOULD discard\
    \ and not forward RDATA packets for\n   which they have no repair state.  Note\
    \ that the consequence of this\n   procedure is that, while it constrains repairs\
    \ to the interested\n   subset of the network, loss of repair state precipitates\
    \ further NAKs\n   from neglected receivers.\n"
- title: 8.  Packet Formats
  contents:
  - "8.  Packet Formats\n   All of the packet formats described in this section are\
    \ transport-\n   layer headers that MUST immediately follow the network-layer\
    \ header\n   in the packet.  Only data packet headers (ODATA and RDATA) may be\n\
    \   followed in the packet by application data.  For each packet type,\n   the\
    \ network-header source and destination addresses are specified in\n   addition\
    \ to the format and contents of the transport layer header.\n   Recall from General\
    \ Procedures that, for PGM over IP multicast, SPMs,\n   NCFs, and RDATA MUST also\
    \ bear the IP Router Alert Option.\n   For PGM over IP, the IP protocol number\
    \ is 113.\n   In all packets the descriptions of Data-Source Port, Data-Destination\n\
    \   Port, Type, Options, Checksum, Global Source ID (GSI), and Transport\n   Service\
    \ Data Unit (TSDU) Length are:\n      Data-Source Port:\n         A random port\
    \ number generated by the source.  This port number\n         MUST be unique within\
    \ the source.  Source Port together with\n         Global Source ID forms the\
    \ TSI.\n      Data-Destination Port:\n         A globally well-known port number\
    \ assigned to the given PGM\n         application.\n      Type:\n         The\
    \ high-order two bits of the Type field encode a version\n         number, 0x0\
    \ in this instance.  The low-order nibble of the type\n         field encodes\
    \ the specific packet type.  The intervening two\n         bits (the low-order\
    \ two bits of the high-order nibble) are\n         reserved and MUST be zero.\n\
    \         Within the low-order nibble of the Type field:\n            values in\
    \ the range 0x0 through 0x3 represent SPM-like\n            packets (i.e., session-specific,\
    \ sourced by a source,\n            periodic),\n            values in the range\
    \ 0x4 through 0x7 represent DATA-like\n            packets (i.e., data and repairs),\n\
    \            values in the range 0x8 through 0xB represent NAK-like\n        \
    \    packets (i.e., hop-by-hop reliable NAK forwarding\n            procedures),\n\
    \            and values in the range 0xC through 0xF represent SPMR-like\n   \
    \         packets (i.e., session-specific, sourced by a receiver,\n          \
    \  asynchronous).\n      Options:\n         This field encodes binary indications\
    \ of the presence and\n         significance of any options.  It also directly\
    \ encodes some\n         options.\n         bit 0 set => One or more Option Extensions\
    \ are present\n         bit 1 set => One or more Options are network-significant\n\
    \            Note that this bit is clear when OPT_FRAGMENT and/or\n          \
    \  OPT_JOIN are the only options present.\n         bit 6 set => Packet is a parity\
    \ packet for a transmission group\n         of variable sized packets (OPT_VAR_PKTLEN).\
    \  Only present when\n         OPT_PARITY is also present.\n         bit 7 set\
    \ => Packet is a parity packet (OPT_PARITY)\n         Bits are numbered here from\
    \ left (0 = MSB) to right (7 = LSB).\n         All the other options (option extensions)\
    \ are encoded in\n         extensions to the PGM header.\n      Checksum:\n  \
    \       This field is the usual 1's complement of the 1's complement\n       \
    \  sum of the entire PGM packet including header.\n         The checksum does\
    \ not include a network-layer pseudo header for\n         compatibility with network\
    \ address translation.  If the\n         computed checksum is zero, it is transmitted\
    \ as all ones.  A\n         value of zero in this field means the transmitter\
    \ generated no\n         checksum.\n         Note that if any entity between a\
    \ source and a receiver\n         modifies the PGM header for any reason, it MUST\
    \ either\n         recompute the checksum or clear it.  The checksum is mandatory\n\
    \         on data packets (ODATA and RDATA).\n      Global Source ID:\n      \
    \   A globally unique source identifier.  This ID MUST NOT change\n         throughout\
    \ the duration of the transport session.  A\n         RECOMMENDED identifier is\
    \ the low-order 48 bits of the MD5 [9]\n         signature of the DNS name of\
    \ the source.  Global Source ID\n         together with Data-Source Port forms\
    \ the TSI.\n      TSDU Length:\n         The length in octets of the transport\
    \ data unit exclusive of\n         the transport header.\n         Note that those\
    \ who require the TPDU length must obtain it from\n         sum of the transport\
    \ header length (TH) and the TSDU length.\n         TH length is the sum of the\
    \ size of the particular PGM packet\n         header (type_specific_size) plus\
    \ the length of any options that\n         might be present.\n   Address Family\
    \ Indicators (AFIs) are as specified in [10].\n"
- title: 8.1.  Source Path Messages
  contents:
  - "8.1.  Source Path Messages\n   SPMs are sent by a source to establish source\
    \ path state in network\n   elements and to provide transmit window state to receivers.\n\
    \   The network-header source address of an SPM is the unicast NLA of the\n  \
    \ entity that originates the SPM.\n   The network-header destination address of\
    \ an SPM is a multicast group\n   NLA.\n    0                   1            \
    \       2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Source Port           |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Type     |    Options    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Global Source ID                   ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...    Global Source ID       |           TSDU Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     SPM's Sequence Number                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Trailing Edge Sequence Number                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Leading Edge Sequence Number                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            NLA AFI            |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            Path NLA                     ...   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+\n\
    \   | Option Extensions when present ...                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ ... -+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Source Port:\n      SPM_SPORT\n      Data-Source\
    \ Port, together with SPM_GSI forms SPM_TSI\n   Destination Port:\n      SPM_DPORT\n\
    \      Data-Destination Port\n   Type:\n      SPM_TYPE = 0x00\n   Global Source\
    \ ID:\n      SPM_GSI\n      Together with SPM_SPORT forms SPM_TSI\n   SPM's Sequence\
    \ Number\n      SPM_SQN\n      The sequence number assigned to the SPM by the\
    \ source.\n   Trailing Edge Sequence Number:\n      SPM_TRAIL\n      The sequence\
    \ number defining the current trailing edge of the\n      source's transmit window\
    \ (TXW_TRAIL).\n   Leading Edge Sequence Number:\n      SPM_LEAD\n      The sequence\
    \ number defining the current leading edge of the\n      source's transmit window\
    \ (TXW_LEAD).\n      If SPM_TRAIL == 0 and SPM_LEAD == 0x80000000, this indicates\
    \ that\n      no window information is present in the packet.\n   Path NLA:\n\
    \      SPM_PATH\n      The NLA of the interface on the network element on which\
    \ this SPM\n      was forwarded.  Initialized by a source to the source's NLA,\n\
    \      rewritten by each PGM network element upon forwarding.\n"
- title: 8.2.  Data Packets
  contents:
  - "8.2.  Data Packets\n   Data packets carry application data from a source or a\
    \ repairer to\n   receivers.\n      ODATA:\n         Original data packets transmitted\
    \ by a source.\n      RDATA:\n         Repairs transmitted by a source or by a\
    \ designated local\n         repairer (DLR) in response to a NAK.\n   The network-header\
    \ source address of a data packet is the unicast NLA\n   of the entity that originates\
    \ the data packet.\n   The network-header destination address of a data packet\
    \ is a\n   multicast group NLA.\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Source Port           |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Type     |    Options    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Global Source ID                   ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...    Global Source ID       |           TSDU Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Data Packet Sequence Number                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Trailing Edge Sequence Number                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Option Extensions when present ...                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ ... -+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   | Data ...\n   +-+-+- ...\n   Source Port:\n\
    \      OD_SPORT, RD_SPORT\n      Data-Source Port, together with Global Source\
    \ ID forms:\n      OD_TSI, RD_TSI\n   Destination Port:\n      OD_DPORT, RD_DPORT\n\
    \      Data-Destination Port\n   Type:\n      OD_TYPE =  0x04 RD_TYPE =  0x05\n\
    \   Global Source ID:\n      OD_GSI, RD_GSI\n      Together with Source Port forms:\n\
    \      OD_TSI, RD_TSI\n   Data Packet Sequence Number:\n      OD_SQN, RD_SQN\n\
    \      The sequence number originally assigned to the ODATA packet by the\n  \
    \    source.\n   Trailing Edge Sequence Number:\n      OD_TRAIL, RD_TRAIL\n  \
    \    The sequence number defining the current trailing edge of the\n      source's\
    \ transmit window (TXW_TRAIL).  In RDATA, this MAY not be\n      the same as OD_TRAIL\
    \ of the ODATA packet for which it is a repair.\n   Data:\n      Application data.\n"
- title: 8.3.  Negative Acknowledgments and Confirmations
  contents:
  - "8.3.  Negative Acknowledgments and Confirmations\n      NAK:\n         Negative\
    \ Acknowledgments are sent by receivers to request the\n         repair of an\
    \ ODATA packet detected to be missing from the\n         expected sequence.\n\
    \      N-NAK:\n         Null Negative Acknowledgments are sent by DLRs to provide\
    \ flow\n         control feedback to the source of ODATA for which the DLR has\n\
    \         provided the corresponding RDATA.\n   The network-header source address\
    \ of a NAK is the unicast NLA of the\n   entity that originates the NAK.  The\
    \ network-header source address of\n   NAK is rewritten by each PGM network element\
    \ with its own.\n   The network-header destination address of a NAK is initialized\
    \ by the\n   originator of the NAK (a receiver) to the unicast NLA of the upstream\n\
    \   PGM network element known from SPMs.  The network-header destination\n   address\
    \ of a NAK is rewritten by each PGM network element with the\n   unicast NLA of\
    \ the upstream PGM network element to which this NAK is\n   forwarded.  On the\
    \ final hop, the network-header destination address\n   of a NAK is rewritten\
    \ by the PGM network element with the unicast NLA\n   of the original source or\
    \ the unicast NLA of a DLR.\n      NCF:\n         NAK Confirmations are sent by\
    \ network elements and sources to\n         confirm the receipt of a NAK.\n  \
    \ The network-header source address of an NCF is the ODATA source's\n   NLA, not\
    \ the network element's NLA as might be expected.\n   The network-header destination\
    \ address of an NCF is a multicast group\n   NLA.\n   Note that in NAKs and N-NAKs,\
    \ unlike the other packets, the field\n   SPORT contains the Data-Destination\
    \ port and the field DPORT contains\n   the Data-Source port.  As a general rule,\
    \ the content of SPORT/DPORT\n   is determined by the direction of the flow: in\
    \ packets which travel\n   down-stream SPORT is the port number chosen in the\
    \ data source\n   (Data-Source Port) and DPORT is the data destination port number\n\
    \   (Data-Destination Port).  The opposite holds for packets which travel\n  \
    \ upstream.  This makes DPORT the protocol endpoint in the recipient\n   host,\
    \ regardless of the direction of the packet.\n    0                   1      \
    \             2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Source Port           |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Type     |    Options    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Global Source ID                   ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...    Global Source ID       |           TSDU Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Requested Sequence Number                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            NLA AFI            |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Source NLA                    ...   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+\n\
    \   |            NLA AFI            |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Multicast Group NLA                ...   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+\n\
    \   | Option Extensions when present ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ ...\n   Source Port:\n      NAK_SPORT, NNAK_SPORT\n         Data-Destination\
    \ Port\n      NCF_SPORT\n      Data-Source Port, together with Global Source ID\
    \ forms NCF_TSI\n   Destination Port:\n      NAK_DPORT, NNAK_DPORT\n         Data-Source\
    \ Port, together with Global Source ID forms:\n            NAK_TSI, NNAK_TSI\n\
    \      NCF_DPORT\n      Data-Destination Port\n   Type:\n      NAK_TYPE =  0x08\
    \ NNAK_TYPE = 0x09\n      NCF_TYPE =  0x0A\n   Global Source ID:\n      NAK_GSI,\
    \ NNAK_GSI, NCF_GSI\n      Together with Data-Source Port forms\n         NAK_TSI,\
    \ NNAK_TSI, NCF_TSI\n   Requested Sequence Number:\n      NAK_SQN, NNAK_SQN\n\
    \      NAK_SQN is the sequence number of the ODATA packet for which a\n      repair\
    \ is requested.\n      NNAK_SQN is the sequence number of the RDATA packet for\
    \ which a\n      repair has been provided by a DLR.\n      NCF_SQN\n      NCF_SQN\
    \ is NAK_SQN from the NAK being confirmed.\n   Source NLA:\n      NAK_SRC, NNAK_SRC,\
    \ NCF_SRC\n      The unicast NLA of the original source of the missing ODATA.\n\
    \   Multicast Group NLA:\n      NAK_GRP, NNAK_GRP, NCF_GRP\n      The multicast\
    \ group NLA.  NCFs MAY bear OPT_REDIRECT and/or\n      OPT_NAK_LIST\n"
- title: 9.  Options
  contents:
  - "9.  Options\n   PGM specifies several end-to-end options to address specific\n\
    \   application requirements.  PGM specifies options to support\n   fragmentation,\
    \ late joining, and redirection.\n   Options MAY be appended to PGM data packet\
    \ headers only by their\n   original transmitters.  While they MAY be interpreted\
    \ by network\n   elements, options are neither added nor removed by network elements.\n\
    \   Options are all in the TLV style, or Type, Length, Value.  The Type\n   field\
    \ is contained in the first byte, where bit 0 is the OPT_END bit,\n   followed\
    \ by 7 bits of type.  The OPT_END bit MUST be set in the last\n   option in the\
    \ option list, whichever that might be.  The Length field\n   is the total length\
    \ of the option in bytes, and directly follows the\n   Type field.  Following\
    \ the Length field are 5 reserved bits, the\n   OP_ENCODED flag, the 2 Option\
    \ Extensibility bits OPX and the\n   OP_ENCODED_NULL flag.  Last are 7 bits designated\
    \ for option specific\n   information which may be defined on a per-option basis.\
    \  If not\n   defined for a particular option, they MUST be set to 0.\n   The\
    \ Option Extensibility bits dictate the desired treatment of an\n   option if\
    \ it is unknown to the network element processing it.\n      Nota Bene:  Only\
    \ network elements pay any attention to these bits.\n      The OPX bits are defined\
    \ as follows:\n      00 -     Ignore the option\n      01 -     Invalidate the\
    \ option by changing the type to OPT_INVALID\n               = 0x7F\n      10\
    \ -     Discard the packet\n      11 -     Unsupported, and reserved for future\
    \ use\n   Some options present in data packet (ODATA and RDATA) are strictly\n\
    \   associated with the packet content (PGM payload), OPT_FRAGMENT being\n   an\
    \ example.  These options must be preserved even when the data\n   packet that\
    \ would normally contain them is not received, but its the\n   payload is recovered\
    \ though the use of FEC.  PGM specifies a\n   mechanism to accomplish this that\
    \ uses the F (OP_ENCODED) and U\n   (OP_ENCODED_NULL) bits in the option common\
    \ header.  OP_ENCODED and\n   OP_ENCODED_NULL MUST be normally set to zero except\
    \ when the option\n   is used in FEC packets to preserve original options.  See\
    \ Appendix A\n   for details.\n   There is a limit of 16 options per packet.\n\
    \   General Option Format\n    0                   1                   2     \
    \              3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|Opt. Specific|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Option Value                    ...    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...+-+-+\n"
- title: 9.1.  Option extension length - OPT_LENGTH
  contents:
  - "9.1.  Option extension length - OPT_LENGTH\n   When option extensions are appended\
    \ to the standard PGM header, the\n   extensions MUST be preceded by an option\
    \ extension length field\n   specifying the total length of all option extensions.\n\
    \   In addition, the presence of the options MUST be encoded in the\n   Options\
    \ field of the standard PGM header before the Checksum is\n   computed.\n   All\
    \ network-significant options MUST be appended before any\n   exclusively receiver-significant\
    \ options.\n   To provide an indication of the end of option extensions, OPT_END\n\
    \   (0x80) MUST be set in the Option Type field of the trailing option\n   extension.\n"
- title: 9.1.1.  OPT_LENGTH - Packet Extension Format
  contents:
  - "9.1.1.  OPT_LENGTH - Packet Extension Format\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Option Type  | Option Length |  Total length of all options  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x00\n   Option Length = 4 octets\n   Total length of all options\n\
    \      The total length in octets of all option extensions including\n      OPT_LENGTH.\n\
    \   OPT_LENGTH is NOT network-significant.\n"
- title: 9.2.  Fragmentation Option - OPT_FRAGMENT
  contents:
  - "9.2.  Fragmentation Option - OPT_FRAGMENT\n   Fragmentation allows transport-layer\
    \ entities at a source to break up\n   application protocol data units (APDUs)\
    \ into multiple PGM data\n   packets (TPDUs) to conform with the MTU supported\
    \ by the network\n   layer.  The fragmentation option MAY be applied to ODATA\
    \ and RDATA\n   packets only.\n   Architecturally, the accumulation of TSDUs into\
    \ APDUs is applied to\n   TPDUs that have already been received, duplicate eliminated,\
    \ and\n   contiguously sequenced by the receiver.  Thus APDUs MAY be\n   reassembled\
    \ across increments of the transmit window.\n"
- title: 9.2.1.  OPT_FRAGMENT - Packet Extension Contents
  contents:
  - "9.2.1.  OPT_FRAGMENT - Packet Extension Contents\n   OPT_FRAG_OFF   the offset\
    \ of the fragment from the beginning of the\n                  APDU\n   OPT_FRAG_LEN\
    \   the total length of the original APDU\n"
- title: 9.2.2.  OPT_FRAGMENT - Procedures - Sources
  contents:
  - "9.2.2.  OPT_FRAGMENT - Procedures - Sources\n   A source fragments APDUs into\
    \ a contiguous series of fragments no\n   larger than the MTU supported by the\
    \ network layer.  A source\n   sequentially and uniquely assigns OD_SQNs to these\
    \ fragments in the\n   order in which they occur in the APDU.  A source then sets\n\
    \   OPT_FRAG_OFF to the value of the offset of the fragment in the\n   original\
    \ APDU (where the first byte of the APDU is at offset 0, and\n   OPT_FRAG_OFF\
    \ numbers the first byte in the fragment), and set\n   OPT_FRAG_LEN to the value\
    \ of the total length of the original APDU.\n"
- title: 9.2.3.  OPT_FRAGMENT - Procedures - Receivers
  contents:
  - "9.2.3.  OPT_FRAGMENT - Procedures - Receivers\n   Receivers detect and accumulate\
    \ fragmented packets until they have\n   received an entire contiguous sequence\
    \ of packets comprising an APDU.\n   This sequence begins with the fragment bearing\
    \ OPT_FRAG_OFF of 0, and\n   terminates with the fragment whose length added to\
    \ its OPT_FRAG_OFF\n   is OPT_FRAG_LEN.\n"
- title: 9.2.4.  OPT_FRAGMENT - Packet Extension Format
  contents:
  - "9.2.4.  OPT_FRAGMENT - Packet Extension Format\n    0                   1   \
    \                2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    First Sequence Number                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            Offset                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            Length                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x01\n   Option Length = 12 octets\n   First Sequence Number\n\
    \      Sequence Number of the PGM DATA/RDATA packet containing the first\n   \
    \   fragment of the APDU.\n   Offset\n      The byte offset of the fragment from\
    \ the beginning of the APDU\n      (OPT_FRAG_OFF).\n   Length\n      The total\
    \ length of the original APDU (OPT_FRAG_LEN).\n   OPT_FRAGMENT is NOT network-significant.\n"
- title: 9.3.  NAK List Option - OPT_NAK_LIST
  contents:
  - "9.3.  NAK List Option - OPT_NAK_LIST\n   The NAK List option MAY be used in conjunction\
    \ with NAKs to allow\n   receivers to request transmission for more than one sequence\
    \ number\n   with a single NAK packet.  The option is limited to 62 listed NAK\n\
    \   entries.  The NAK list MUST be unique and duplicate free.  It MUST be\n  \
    \ ordered, and MUST consist of either a list of selective or a list of\n   parity\
    \ NAKs.  In general, network elements, sources and receivers\n   must process\
    \ a NAK list as if they had received individual NAKs for\n   each sequence number\
    \ in the list.  The procedures for each are\n   outlined in detail earlier in\
    \ this document.  Clarifications and\n   differences are detailed here.\n"
- title: 9.3.1.  OPT_NAK_LIST - Packet Extensions Contents
  contents:
  - "9.3.1.  OPT_NAK_LIST - Packet Extensions Contents\n   A list of sequence numbers\
    \ for which retransmission is requested.\n"
- title: 9.3.2.  OPT_NAK_LIST - Procedures - Receivers
  contents:
  - "9.3.2.  OPT_NAK_LIST - Procedures - Receivers\n   Receivers MAY append the NAK\
    \ List option to a NAK to indicate that\n   they wish retransmission of a number\
    \ of RDATA.\n   Receivers SHOULD proceed to back off NAK transmission in a manner\n\
    \   consistent with the procedures outlined for single sequence number\n   NAKs.\
    \  Note that the repair of each separate sequence number will be\n   completed\
    \ upon receipt of a separate RDATA packet.\n   Reception of an NCF or multicast\
    \ NAK containing the NAK List option\n   suspends generation of NAKs for all sequence\
    \ numbers within the NAK\n   list, as well as the sequence number within the NAK\
    \ header.\n"
- title: 9.3.3.  OPT_NAK_LIST - Procedures - Network Elements
  contents:
  - "9.3.3.  OPT_NAK_LIST - Procedures - Network Elements\n   Network elements MUST\
    \ immediately respond to a NAK with an identical\n   NCF containing the same NAK\
    \ list as the NAK itself.\n   Network elements MUST forward a NAK containing a\
    \ NAK List option if\n   any one sequence number specified by the NAK (including\
    \ that in the\n   main NAK header) is not currently outstanding.  That is, it\
    \ MUST\n   forward the NAK, if any one sequence number does not have an\n   elimination\
    \ timer running for it.  The NAK must be forwarded intact.\n   Network elements\
    \ MUST eliminate a NAK containing the NAK list option\n   only if all sequence\
    \ numbers specified by the NAK (including that in\n   the main NAK header) are\
    \ outstanding.  That is, they are all running\n   an elimination timer.\n   Upon\
    \ receipt of an unsolicited NCF containing the NAK list option, a\n   network\
    \ element MUST anticipate data for every sequence number\n   specified by the\
    \ NAK as if it had received an NCF for every sequence\n   number specified by\
    \ the NAK.\n"
- title: 9.3.4.  OPT_NAK_LIST - Procedures - Sources
  contents:
  - "9.3.4.  OPT_NAK_LIST - Procedures - Sources\n   A source MUST immediately respond\
    \ to a NAK with an identical NCF\n   containing the same NAK list as the NAK itself.\n\
    \   It MUST then multicast RDATA (while respecting TXW_MAX_RTE) for every\n  \
    \ requested sequence number.\n"
- title: 9.3.5.  OPT_NAK_LIST - Packet Extension Format
  contents:
  - "9.3.5.  OPT_NAK_LIST - Packet Extension Format\n    0                   1   \
    \                2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Requested Sequence Number 1                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  .....                                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Requested Sequence Number N                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x02\n   Option Length = 4 + (4 * number of SQNs) octets\n \
    \  Requested Sequence Number\n      A list of up to 62 additional sequence numbers\
    \ to which the NAK\n      applies.\n   OPT_NAK_LIST is network-significant.\n"
- title: 9.4.  Late Joining Option - OPT_JOIN
  contents:
  - "9.4.  Late Joining Option - OPT_JOIN\n   Late joining allows a source to bound\
    \ the amount of repair history\n   receivers may request when they initially join\
    \ a particular transport\n   session.\n   This option indicates that receivers\
    \ that join a transport session in\n   progress MAY request repair of all data\
    \ as far back as the given\n   minimum sequence number from the time they join\
    \ the transport\n   session.  The default is for receivers to receive data only\
    \ from the\n   first packet they receive and onward.\n"
- title: 9.4.1.  OPT_JOIN - Packet Extensions Contents
  contents:
  - "9.4.1.  OPT_JOIN - Packet Extensions Contents\n   OPT_JOIN_MIN   the minimum\
    \ sequence number for repair\n"
- title: 9.4.2.  OPT_JOIN - Procedures - Receivers
  contents:
  - "9.4.2.  OPT_JOIN - Procedures - Receivers\n   If a PGM packet (ODATA, RDATA,\
    \ or SPM) bears OPT_JOIN, a receiver MAY\n   initialize the trailing edge of the\
    \ receive window (RXW_TRAIL_INIT)\n   to the given Minimum Sequence Number and\
    \ proceeds with normal data\n   reception.\n"
- title: 9.4.3.  OPT_JOIN - Packet Extension Format
  contents:
  - "9.4.3.  OPT_JOIN - Packet Extension Format\n    0                   1       \
    \            2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Minimum Sequence Number                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x03\n   Option Length = 8 octets\n   Minimum Sequence Number\n\
    \      The minimum sequence number defining the initial trailing edge of\n   \
    \   the receive window for a late joining receiver.\n   OPT_JOIN is NOT network-significant.\n"
- title: 9.5.  Redirect Option - OPT_REDIRECT
  contents:
  - "9.5.  Redirect Option - OPT_REDIRECT\n   Redirection MAY be used by a designated\
    \ local repairer (DLR) to\n   advertise its own address as an alternative to the\
    \ original source,\n   for requesting repairs.\n   These procedures allow a PGM\
    \ Network Element to use a DLR that is one\n   PGM hop from it either upstream\
    \ or downstream in the multicast\n   distribution tree.  The former are referred\
    \ to as upstream DLRs.  The\n   latter are referred to as off-tree DLRs.  Off-Tree\
    \ because even\n   though they are downstream of the point of loss, they might\
    \ not lie\n   on the subtree affected by the loss.\n   A DLR MUST receive any\
    \ PGM sessions for which it wishes to provide\n   retransmissions.  A DLR SHOULD\
    \ respond to NCFs or POLLs sourced by\n   its PGM parent with a redirecting POLR\
    \ response packet containing an\n   OPT_REDIRECT which provides its own network\
    \ layer address.\n   Recipients of redirecting POLRs MAY then direct NAKs for\
    \ subsequent\n   ODATA sequence numbers to the DLR rather than to the original\
    \ source.\n   In addition, DLRs that receive redirected NAKs for which they have\n\
    \   RDATA MUST send a NULL NAK to provide flow control to the original\n   source\
    \ without also provoking a repair from that source.\n"
- title: 9.5.1.  OPT_REDIRECT - Packet Extensions Contents
  contents:
  - "9.5.1.  OPT_REDIRECT - Packet Extensions Contents\n   OPT_REDIR_NLA  the DLR's\
    \ own unicast network-layer address to which\n                  recipients of\
    \ the redirecting POLR MAY direct\n                  subsequent NAKs for the corresponding\
    \ TSI.\n"
- title: 9.5.2.  OPT_REDIRECT - Procedures - DLRs
  contents:
  - "9.5.2.  OPT_REDIRECT - Procedures - DLRs\n   A DLR MUST receive any PGM sessions\
    \ for which it wishes to provide a\n   source of repairs.  In addition to acting\
    \ as an ordinary PGM\n   receiver, a DLR MAY then respond to NCFs or relevant\
    \ POLLs sourced by\n   parent network elements (or even by the source itself)\
    \ by sending a\n   POLR containing an OPT_REDIRECT providing its own network-layer\n\
    \   address.\n   If a DLR can provide FEC repairs it MUST denote this by setting\n\
    \   OPT_PARITY in the PGM header of its POLR response.\n"
- title: 9.5.2.1.  Upstream DLRs
  contents:
  - "9.5.2.1.  Upstream DLRs\n   If the NCF completes NAK transmission initiated by\
    \ the DLR itself,\n   the DLR MUST NOT send a redirecting POLR.\n   When a DLR\
    \ receives an NCF from its upstream PGM parent, it SHOULD\n   send a redirecting\
    \ POLR, multicast to the group.  The DLR SHOULD\n   record that it is acting as\
    \ an upstream DLR for the said session.\n   Note that this POLR MUST have both\
    \ the data source's source address\n   and the router alert option in its network\
    \ header.\n   An upstream DLR MUST act as an ordinary PGM source in responding\
    \ to\n   any NAK it receives (i.e., directed to it).  That is, it SHOULD\n   respond\
    \ first with a normal NCF and then RDATA as usual.  In\n   addition, an upstream\
    \ DLR that receives redirected NAKs for which it\n   has RDATA MUST send a NULL\
    \ NAK to provide flow control to the\n   original source.  If it cannot provide\
    \ the RDATA it forwards the NAK\n   to the upstream PGM neighbor as usual.\n \
    \     Nota Bene: In order to propagate on exactly the same distribution\n    \
    \  tree as ODATA, RDATA and POLR  packets transmitted by DLRs MUST\n      bear\
    \ the ODATA source's NLA as the network-header source address,\n      not the\
    \ DLR's NLA as might be expected.\n"
- title: 9.5.2.2.  Off-Tree DLRs
  contents:
  - "9.5.2.2.  Off-Tree DLRs\n   A DLR that receives a POLL with sub-type PGM_POLL_DLR\
    \ MUST respond\n   with a unicast redirecting POLR if it provides the appropriate\n\
    \   service.  The DLR SHOULD respond using the rules outlined for polling\n  \
    \ in Appendix D of this text.  If the DLR responds, it SHOULD record\n   that\
    \ it is acting as an off-tree DLR for the said session.\n   An off-tree DLR acts\
    \ in a special way in responding to any NAK it\n   receives (i.e., directed to\
    \ it).  It MUST respond to a NAK directed\n   to it from its parent by unicasting\
    \ an NCF and RDATA to its parent.\n   The parent will then forward the RDATA down\
    \ the distribution tree.\n   The DLR uses its own and the parent's NLA addresses\
    \ in the network\n   header for the source and destination respectively.  The\
    \ unicast NCF\n   and RDATA packets SHOULD not have the router alert option. \
    \ In all\n   other ways the RDATA header should be \"as if\" the packet had come\n\
    \   from the source.\n   Again, an off-tree DLR that receives redirected NAKs\
    \ for which it has\n   RDATA MUST originate a NULL NAK to provide flow control\
    \ to the\n   original source.  It MUST originate the NULL NAK before originating\n\
    \   the RDATA.  This must be done to reduce the state held in the network\n  \
    \ element.\n   If it cannot provide the RDATA for a given NAK, an off-tree DLR\n\
    \   SHOULD confirm the NAK with a unicast NCF as normal, then immediately\n  \
    \ send a NAK for the said data packet back to its parent.\n"
- title: 9.5.2.3.  Simultaneous Upstream and Off-Tree DLR operation
  contents:
  - "9.5.2.3.  Simultaneous Upstream and Off-Tree DLR operation\n   Note that it is\
    \ possible for a DLR to provide service to its parent\n   and to downstream network\
    \ elements simultaneously.  A downstream loss\n   coupled with a loss for the\
    \ same data on some other part of the\n   distribution tree served by its parent\
    \ could cause this.  In this\n   case it may provide both upstream and off-tree\
    \ functionality\n   simultaneously.\n   Note that a DLR differentiates between\
    \ NAKs from an NE downstream or\n   from its parent by comparing the network-header\
    \ source address of the\n   NAK with it's upstream PGM parent's NLA.  The DLR\
    \ knows the parent's\n   NLA from the session's SPM messages.\n"
- title: 9.5.3.  OPT_REDIRECT - Procedures - Network Elements
  contents:
  - '9.5.3.  OPT_REDIRECT - Procedures - Network Elements

    '
- title: 9.5.3.1.  Discovering DLRs
  contents:
  - "9.5.3.1.  Discovering DLRs\n   When a PGM router receives notification of a loss\
    \ via a NAK, it\n   SHOULD first try to use a known DLR to recover the loss. \
    \ If such a\n   DLR is not known it SHOULD initiate DLR discovery.  DLR discovery\
    \ may\n   occur in two ways.  If there are upstream DLRs, the NAK transmitted\n\
    \   by this router to its PGM parent will trigger their discovery, via a\n   redirecting\
    \ POLR.  Also, a network element SHOULD initiate a search\n   for off-tree DLRs\
    \ using the PGM polling mechanism, and the sub-type\n   PGM_POLL_DLR.\n   If a\
    \ DLR can provide FEC repairs it will denote this by setting\n   OPT_PARITY in\
    \ the PGM header of its POLR response.  A network element\n   SHOULD only direct\
    \ parity NAKs to a DLR that can provide FEC repairs.\n"
- title: 9.5.3.2.  Redirected Repair
  contents:
  - "9.5.3.2.  Redirected Repair\n   When it can, a network element SHOULD use upstream\
    \ DLRs.\n   Upon receiving a redirecting POLR, network elements SHOULD record\
    \ the\n   redirecting information for the TSI, and SHOULD redirect subsequent\n\
    \   NAKs for the same TSI to the network address provided in the\n   redirecting\
    \ POLR rather than to the PGM neighbor known via the SPMs.\n   Note, however,\
    \ that a redirecting POLR is NOT regarded as matching\n   the NAK that provoked\
    \ it, so it does not complete the transmission of\n   that NAK.  Only a normal\
    \ matching NCF can complete the transmission\n   of a NAK.\n   For subsequent\
    \ NAKs, if the network element has recorded redirection\n   information for the\
    \ corresponding TSI, it MAY change the destination\n   network address of those\
    \ NAKs and attempt to transmit them to the\n   DLR.  No NAK for a specific SQN\
    \ SHOULD be sent to an off-tree DLR if\n   a NAK for the SQN has been seen on\
    \ the interface associated with the\n   DLR.  Instead the NAK SHOULD be forwarded\
    \ upstream.  Subsequent NAKs\n   for different SQNs MAY be forwarded to the said\
    \ DLR (again assuming\n   no NAK for them has been seen on the interface to the\
    \ DLR).\n   If a corresponding NCF is not received from the DLR within\n   NAK_RPT_IVL,\
    \ the network element MUST discard the redirecting\n   information for the TSI\
    \ and re-attempt to forward the NAK towards the\n   PGM upstream neighbor.\n \
    \  If a NAK is received from the DLR for a requested SQN, the network\n   element\
    \ MUST discard the redirecting information for the SQN and re-\n   attempt to\
    \ forward the NAK towards the PGM upstream neighbor.  The\n   network element\
    \ MAY still direct NAKs for different SQNs to the DLR.\n   RDATA and NCFs from\
    \ upstream DLRs will flow down the distribution\n   tree.  However, RDATA and\
    \ NCFs from off-tree DLRs will be unicast to\n   the network element.  The network\
    \ element will terminate the NCF, but\n   MUST put the source's NLA and the group\
    \ address into the network\n   header and MUST add router alert before forwarding\
    \ the RDATA packet\n   to the distribution subtree.\n   NULL NAKs from an off-tree\
    \ DLR for an RDATA packet requested from\n   that off-tree DLR MUST always be\
    \ forwarded upstream.  The network\n   element can assume that these will arrive\
    \ before the matching RDATA.\n   Other NULL NAKs are forwarded only if matching\
    \ repair state has not\n   already been created.  Network elements MUST NOT confirm\
    \ or retry\n   NULL NAKs and they MUST NOT add the receiving interface to the\
    \ repair\n   state.  If a NULL NAK is used to initially create repair state, this\n\
    \   fact must be recorded so that any subsequent non-NULL NAK will not be\n  \
    \ eliminated, but rather will be forwarded to provoke an actual repair.\n   State\
    \ created by a NULL NAK exists only for NAK_ELIM_IVL.\n"
- title: 9.5.4.  OPT_REDIRECT - Procedures - Receivers
  contents:
  - "9.5.4.  OPT_REDIRECT - Procedures - Receivers\n   These procedures are intended\
    \ to be applied in instances where a\n   receiver's first hop router on the reverse\
    \ path to the source is not\n   a PGM Network Element.  So, receivers MUST ignore\
    \ a redirecting POLR\n   from a DLR on the same IP subnet that the receiver resides\
    \ on, since\n   this is likely to suffer identical loss to the receiver and so\
    \ be\n   useless.  Therefore, these procedures are entirely OPTIONAL.  A\n   receiver\
    \ MAY choose to ignore all redirecting POLRs since in cases\n   where its first\
    \ hop router on the reverse path is PGM capable, it\n   would ignore them anyway.\
    \  Also, note that receivers will never learn\n   of off-tree DLRs.\n   Upon receiving\
    \ a redirecting POLR, receivers SHOULD record the\n   redirecting information\
    \ for the TSI, and MAY redirect subsequent NAKs\n   for the same TSI to the network\
    \ address provided in the redirecting\n   POLR rather than to the PGM neighbor\
    \ for the corresponding ODATA for\n   which the receiver is requesting repair.\
    \  Note, however, that a\n   redirecting POLR is NOT regarded as matching the\
    \ NAK that provoked\n   it, so it does not complete the transmission of that NAK.\
    \  Only a\n   normal matching NCF can complete the transmission of a NAK.\n  \
    \ For subsequent NAKs, if the receiver has recorded redirection\n   information\
    \ for the corresponding TSI, it MAY change the destination\n   network address\
    \ of those NAKs and attempt to transmit them to the\n   DLR.  If a corresponding\
    \ NCF is not received within NAK_RPT_IVL, the\n   receiver MUST discard the redirecting\
    \ information for the TSI and\n   re-attempt to forward the NAK to the PGM neighbor\
    \ for the original\n   source of the missing ODATA.\n"
- title: 9.5.5.  OPT_REDIRECT - Packet Extension Format
  contents:
  - "9.5.5.  OPT_REDIRECT - Packet Extension Format\n    0                   1   \
    \                2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            NLA AFI            |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           DLR's NLA                     ...   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+\n\
    \   Option Type = 0x07\n   Option Length = 4 + NLA length\n   DLR's NLA\n    \
    \  The DLR's own unicast network address to which recipients of the\n      redirecting\
    \ POLR may direct subsequent NAKs.\n   OPT_REDIRECT is network-significant.\n"
- title: 9.6.  OPT_SYN - Synchronization Option
  contents:
  - "9.6.  OPT_SYN - Synchronization Option\n   The SYN option indicates the starting\
    \ data packet for a session.  It\n   must only appear in ODATA or RDATA packets.\n\
    \   The SYN option MAY be used to provide a useful abstraction to\n   applications\
    \ that can simplify application design by providing stream\n   start notification.\
    \  It MAY also be used to let a late joiner to a\n   session know that it is indeed\
    \ late (i.e. it would not see the SYN\n   option).\n"
- title: 9.6.1.  OPT_SYN - Procedures - Receivers
  contents:
  - "9.6.1.  OPT_SYN - Procedures - Receivers\n   Procedures for receivers are implementation\
    \ dependent.  A receiver\n   MAY use the SYN to provide its applications with\
    \ abstractions of the\n   data stream.\n"
- title: 9.6.2.  OPT_SYN - Procedures - Sources
  contents:
  - "9.6.2.  OPT_SYN - Procedures - Sources\n   Sources MAY include OPT_SYN in the\
    \ first data for a session.  That\n   is, they MAY include the option in:\n  \
    \    the first ODATA sent on a session by a PGM source\n      any RDATA sent as\
    \ a result of loss of this ODATA packet\n      all FEC packets for the first transmission\
    \ group; in this case it\n      is interpreted as the first packet having the\
    \ SYN\n"
- title: 9.6.3.  OPT_SYN - Procedures - DLRs
  contents:
  - "9.6.3.  OPT_SYN - Procedures - DLRs\n      In an identical manner to sources,\
    \ DLRs MUST provide OPT_SYN in\n      any retransmitted data that is at the start\
    \ of a session.\n"
- title: 9.6.4.  OPT_SYN - Packet Extension Format
  contents:
  - "9.6.4.  OPT_SYN - Packet Extension Format\n       0                   1     \
    \              2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Option\
    \ Type = 0x0D\n      Option Length = 4\n      OPT_SYN is NOT network-significant.\n"
- title: 9.7.  OPT_FIN - Session Finish Option
  contents:
  - "9.7.  OPT_FIN - Session Finish Option\n      This FIN option indicates the last\
    \ data packet for a session and\n      an orderly close down.\n      The FIN option\
    \ MAY be used to provide an abstraction to\n      applications that can simplify\
    \ application design by providing\n      stream end notification.\n      This\
    \ option MAY be present in the last data packet or transmission\n      group for\
    \ a session.  The FIN PGM option MUST appear in every SPM\n      sent after the\
    \ last ODATA for a session.  The SPM_LEAD sequence\n      number in an SPM with\
    \ the FIN option indicates the last known data\n      successfully transmitted\
    \ for the session.\n"
- title: 9.7.1.  OPT_FIN - Procedures - Receivers
  contents:
  - "9.7.1.  OPT_FIN - Procedures - Receivers\n      A receiver SHOULD use receipt\
    \ of a FIN to let it know that it can\n      tear down its data structures for\
    \ the said session once a suitable\n      time period has expired (TXW_SECS).\
    \  It MAY still try to solicit\n      retransmissions within the existing transmit\
    \ window.\n      Other than this, procedures for receivers are implementation\n\
    \      dependent.  A receiver MAY use the FIN to provide its applications\n  \
    \    with abstractions of the data stream and to inform its\n      applications\
    \ that the session is ending.\n      9.7.2.  OPT_FIN - Procedures - Sources\n\
    \      Sources MUST include OPT_FIN in every SPM sent after it has been\n    \
    \  determined that the application has closed gracefully.  If a\n      source\
    \ is aware at the time of transmission that it is ending a\n      session the\
    \ source MAY include OPT_FIN in,\n      the last ODATA\n      any associated RDATAs\
    \ for the last data\n      FEC packets for the last transmission group; in this\
    \ case it is\n      interpreted as the last packet having the FIN\n   When a source\
    \ detects that it needs to send an OPT_FIN it SHOULD\n   immediately send it.\
    \  This is done either by appending it to the last\n   data packet or transmission\
    \ group or by immediately sending an SPM\n   and resetting the SPM heartbeat timer\
    \ (i.e. it does not wait for a\n   timer to expire before sending the SPM).  After\
    \ sending an OPT_FIN,\n   the session SHOULD not close and stop sending SPMs until\
    \ after a time\n   period equal to TXW_SECS.\n"
- title: 9.7.3.  OPT_FIN - Procedures - DLRs
  contents:
  - "9.7.3.  OPT_FIN - Procedures - DLRs\n   In an identical manner to sources, DLRs\
    \ MUST provide OPT_FIN in any\n   retransmitted data that is at the end of a session.\n"
- title: 9.7.4.  OPT_FIN - Packet Extension Format
  contents:
  - "9.7.4.  OPT_FIN - Packet Extension Format\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x0E\n   Option Length = 4\n   OPT_FIN is NOT network-significant.\n"
- title: 9.8.  OPT_RST - Session Reset Option
  contents:
  - "9.8.  OPT_RST - Session Reset Option\n   The RST option MAY appear in every SPM\
    \ sent after an unrecoverable\n   error is identified by the source.  This acts\
    \ to notify the receivers\n   that the session is being aborted.  This option\
    \ MAY appear only in\n   SPMs.  The SPM_LEAD sequence number in an SPM with the\
    \ RST option\n   indicates the last known data successfully transmitted for the\n\
    \   session.\n"
- title: 9.8.1.  OPT_RST - Procedures - Receivers
  contents:
  - "9.8.1.  OPT_RST - Procedures - Receivers\n   Receivers SHOULD treat the reception\
    \ of OPT_RST in an SPM as an abort\n   of the session.\n   A receiver that receives\
    \ an SPM with an OPT_RST with the N bit set\n   SHOULD not send any more NAKs\
    \ for the said session towards the\n   source.  If the N bit (see 9.8.5) is not\
    \ set, the receiver MAY\n   continue to try to solicit retransmit data within\
    \ the current\n   transmit window.\n"
- title: 9.8.2.  OPT_RST - Procedures - Sources
  contents:
  - "9.8.2.  OPT_RST - Procedures - Sources\n   Sources SHOULD include OPT_RST in\
    \ every SPM sent after it has been\n   determined that an unrecoverable error\
    \ condition has occurred.  The N\n   bit of the OPT_RST SHOULD only be sent if\
    \ the source has determined\n   that it cannot process NAKs for the session. \
    \ The cause of the\n   OPT_RST is set to an implementation specific value.  If\
    \ the error\n   code is unknown, then the value of 0x00 is used.  When a source\n\
    \   detects that it needs to send an OPT_RST it SHOULD immediately send\n   it.\
    \  This is done by immediately sending an SPM and resetting the SPM\n   heartbeat\
    \ timer (i.e. it does not wait for a timer to expire before\n   sending the SPM).\
    \  After sending an OPT_RST, the session SHOULD not\n   close and stop sending\
    \ SPMs until after a time period equal to\n   TXW_SECS.\n"
- title: 9.8.3.  OPT_RST - Procedures - DLRs
  contents:
  - "9.8.3.  OPT_RST - Procedures - DLRs\n   None.\n"
- title: 9.8.4.  OPT_RST - Packet Extension Format
  contents:
  - "9.8.4.  OPT_RST - Packet Extension Format\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|N|Error Code |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x0F\n   Option Length = 4\n   N bit\n      The N bit is set\
    \ to 1 to indicate that NAKs for previous ODATA\n      will go unanswered from\
    \ the source.  The application will tell the\n      source to turn this bit on\
    \ or off.\n   Error Code\n      The 6 bit error code field is used to forward\
    \ an error code down\n      to the receivers from the source.\n      The value\
    \ of 0x00 indicates an unknown reset reason.  Any other\n      value indicates\
    \ the application purposely aborted and gave a\n      reason (the error code value)\
    \ that may have meaning to the end\n      receiver application.  These values\
    \ are entirely application\n      dependent.\n   OPT_RST is NOT network-significant.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   In addition to the usual problems of end-to-end\
    \ authentication, PGM\n   is vulnerable to a number of security risks that are\
    \ specific to the\n   mechanisms it uses to establish source path state, to establish\n\
    \   repair state, to forward NAKs, to identify DLRs, and to distribute\n   repairs.\
    \  These mechanisms expose PGM network elements themselves to\n   security risks\
    \ since network elements not only switch but also\n   interpret SPMs, NAKs, NCFs,\
    \ and RDATA, all of which may legitimately\n   be transmitted by PGM sources,\
    \ receivers, and DLRs.  Short of full\n   authentication of all neighboring sources,\
    \ receivers, DLRs, and\n   network elements, the protocol is not impervious to\
    \ abuse.\n   So putting aside the problems of rogue PGM network elements for the\n\
    \   moment, there are enough potential security risks to network elements\n  \
    \ associated with sources, receivers, and DLRs alone.  These risks\n   include\
    \ denial of service through the exhausting of both CPU\n   bandwidth and memory,\
    \ as well as loss of (repair) data connectivity\n   through the muddling of repair\
    \ state.\n   False SPMs may cause PGM network elements to mis-direct NAKs intended\n\
    \   for the legitimate source with the result that the requested RDATA\n   would\
    \ not be forthcoming.\n   False NAKs may cause PGM network elements to establish\
    \ spurious\n   repair state that will expire only upon time-out and could lead\
    \ to\n   memory exhaustion in the meantime.\n   False NCFs may cause PGM network\
    \ elements to suspend NAK forwarding\n   prematurely (or to mis-direct NAKs in\
    \ the case of redirecting POLRs)\n   resulting eventually in loss of RDATA.\n\
    \   False RDATA may cause PGM network elements to tear down legitimate\n   repair\
    \ state resulting eventually in loss of legitimate RDATA.\n   The development\
    \ of precautions for network elements to protect\n   themselves against incidental\
    \ or unsophisticated versions of these\n   attacks is work outside of this spec\
    \ and includes:\n      Damping of jitter in the value of either the network-header\
    \ source\n      address of SPMs or the path NLA in SPMs.  While the network-header\n\
    \      source address is expected to change seldom, the path NLA is\n      expected\
    \ to change occasionally as a consequence of changes in\n      underlying multicast\
    \ routing information.\n   The extension of NAK shedding procedures to control\
    \ the volume, not\n   just the rate, of confirmed NAKs.  In either case, these\
    \ procedures\n   assist network elements in surviving NAK attacks at the expense\
    \ of\n   maintaining service.  More efficiently, network elements may use the\n\
    \   knowledge of TSIs and their associated transmit windows gleaned from\n   SPMs\
    \ to control the proliferation of repair state.\n   A three-way handshake between\
    \ network elements and DLRs that would\n   permit a network element to ascertain\
    \ with greater confidence that an\n   alleged DLR is identified by the alleged\
    \ network-header source\n   address, and is PGM conversant.\n"
- title: 11.  Appendix A - Forward Error Correction
  contents:
  - '11.  Appendix A - Forward Error Correction

    '
- title: 11.1.  Introduction
  contents:
  - "11.1.  Introduction\n   The following procedures incorporate packet-level Reed\
    \ Solomon\n   Erasure correcting techniques as described in [11] and [12] into\
    \ PGM.\n   This approach to Forward Error Correction (FEC) is based upon the\n\
    \   computation of h parity packets from k data packets for a total of n\n   packets\
    \ such that a receiver can reconstruct the k data packets out\n   of any k of\
    \ the n packets.  The original k data packets are referred\n   to as the Transmission\
    \ Group, and the total n packets as the FEC\n   Block.\n   These procedures permit\
    \ any combination of pro-active FEC or on-\n   demand FEC with conventional ARQ\
    \ (selective retransmission) within a\n   given TSI to provide any flavor of layered\
    \ or integrated FEC.  The\n   two approaches can be used by the same or different\
    \ receivers in a\n   single transport session without conflict.  Once provided\
    \ by a\n   source, the actual use of FEC or selective retransmission for loss\n\
    \   recovery in the session is entirely at the discretion of the\n   receivers.\
    \  Note however that receivers SHOULD NOT ask for selective\n   retransmissions\
    \ when FEC is available, nevertheless sources MUST\n   provide selective retransmissions\
    \ in response to selective NAKs from\n   the leading partial transmission group\
    \ (i.e. the most recent\n   transmission group, which is not yet full).  For any\
    \ group that is\n   full, the source SHOULD provide FEC on demand in response\
    \ to a\n   selective NAK.\n   Pro-active FEC refers to the technique of computing\
    \ parity packets at\n   transmission time and transmitting them as a matter of\
    \ course\n   following the data packets.  Pro-active FEC is RECOMMENDED for\n\
    \   providing loss recovery over simplex or asymmetric multicast channels\n  \
    \ over which returning repair requests is either impossible or costly.\n   It\
    \ provides increased reliability at the expense of bandwidth.\n   On-demand FEC\
    \ refers to the technique of computing parity packets at\n   repair time and transmitting\
    \ them only upon demand (i.e., receiver-\n   based loss detection and repair request).\
    \  On-demand FEC is\n   RECOMMENDED for providing loss recovery of uncorrelated\
    \ loss in very\n   large receiver populations in which the probability of any\
    \ single\n   packet being lost is substantial.  It provides equivalent reliability\n\
    \   to selective NAKs (ARQ) at no more and typically less expense of\n   bandwidth.\n\
    \   Selective NAKs are NAKs that request the retransmission of specific\n   packets\
    \ by sequence number corresponding to the sequence number of\n   any data packets\
    \ detected to be missing from the expected sequence\n   (conventional ARQ).  Selective\
    \ NAKs can be used for recovering losses\n   occurring in leading partial transmission\
    \ groups, i.e. in the most\n   recent transmission group, which is not yet full.\
    \  The RECOMMENDED\n   way of handling partial transmission groups, however, is\
    \ for the data\n   source to use variable-size transmission groups (see below).\n\
    \   Parity NAKs are NAKs that request the transmission of a specific\n   number\
    \ of parity packets by count corresponding to the count of the\n   number of data\
    \ packets detected to be missing from a group of k data\n   packets (on-demand\
    \ FEC).\n   The objective of these procedures is to incorporate these FEC\n  \
    \ techniques into PGM so that:\n      sources MAY provide parity packets either\
    \ pro-actively or on-\n      demand, interchangeably within the same TSI,\n  \
    \    receivers MAY use either selective or parity NAKs interchangeably\n     \
    \ within the same TSI (however, in a session where on-demand parity\n      is\
    \ available receivers SHOULD only use parity NAKs).\n      network elements maintain\
    \ repair state based on either selective\n      or parity NAKs in the same data\
    \ structure, altering only search,\n      RDATA constraint, and deletion algorithms\
    \ in either case,\n      and only OPTION additions to the basic packet formats\
    \ are\n      REQUIRED.\n"
- title: 11.2.  Overview
  contents:
  - "11.2.  Overview\n   Advertising FEC parameters in the transport session\n   Sources\
    \ add OPT_PARITY_PRM to SPMs to provide session-specific\n   parameters such as\
    \ the number of packets (TGSIZE == k) in a\n   transmission group.  This option\
    \ lets receivers know how many packets\n   there are in a transmission group,\
    \ and it lets network elements sort\n   repair state by transmission group number.\
    \  This option includes an\n   indication of whether pro-active and/or on-demand\
    \ parity is available\n   from the source.\n   Distinguishing parity packets from\
    \ data packets\n   Sources send pro-active parity packets as ODATA (NEs do not\
    \ forward\n   RDATA unless a repair state is present) and on-demand parity packets\n\
    \   as RDATA.  A source MUST add OPT_PARITY to the ODATA/RDATA packet\n   header\
    \ of parity packets to permit network elements and receivers to\n   distinguish\
    \ them from data packets.\n   Data and parity packet numbering\n   Parity packets\
    \ MUST be calculated over a fixed number k of data\n   packets known as the Transmission\
    \ Group.  Grouping of packets into\n   transmission groups effectively partitions\
    \ a packet sequence number\n   into a high-order portion (TG_SQN) specifying the\
    \ transmission group\n   (TG), and a low-order portion (PKT_SQN) specifying the\
    \ packet number\n   (PKT-NUM in the range 0 through k-1) within that group.  From\
    \ an\n   implementation point of view, it's handy if k, the TG size, is a\n  \
    \ power of 2.  If so, then TG_SQN and PKT_SQN can be mapped side-by-\n   side\
    \ into the 32 bit SQN.  log2(TGSIZE) is then the size in bits of\n   PKT_SQN.\n\
    \   This mapping does not reduce the effective sequence number space\n   since\
    \ parity packets marked with OPT_PARITY allow the sequence space\n   (PKT_SQN)\
    \ to be completely reused in order to number the h parity\n   packets, as long\
    \ as h is not greater than k.\n   In the case where h is greater than k, a source\
    \ MUST add\n   OPT_PARITY_GRP to any parity packet numbered j greater than k-1,\n\
    \   specifying the number m of the group of k parity packets to which the\n  \
    \ packet belongs, where m is just the quotient from the integer\n   division of\
    \ j by k.  Correspondingly, PKT-NUM for such parity packets\n   is just j modulo\
    \ k.  In other words, when a source needs to generate\n   more parity packets\
    \ than there were original data packets (perhaps\n   because of a particularly\
    \ lossy line such that a receiver lost not\n   only the original data but some\
    \ of the parity RDATA as well), use the\n   OPT_PARITY_GRP option in order to\
    \ number and identify the\n   transmission group of the extra packets that would\
    \ exceed the normal\n   sequential number space.\n   Note that parity NAKs (and\
    \ consequently their corresponding parity\n   NCFs) MUST also contain the OPT_PARITY\
    \ flag in the options field of\n   the fixed header, and that in these packets,\
    \ PKT_SQN MUST contain\n   PKT_CNT, the number of missing packets, rather than\
    \ PKT_NUM, the SQN\n   of a specific missing packet.  More on all this later.\n\
    \   Variable Transmission Group Size\n   The transmission group size advertised\
    \ in the OPT_PARITY_PRM option\n   on SPMs MUST be a power of 2 and constant for\
    \ the duration of the\n   session.  However, the actual transmission group size\
    \ used MAY not be\n   constant for the duration of the session, and MAY not be\
    \ a power of\n   2.  When a TG size different from the one advertised in\n   OPT_PARITY_PRM\
    \ is used, the TG size advertised in OPT_PARITY_PRM MUST\n   be interpreted as\
    \ specifying the maximum effective size of the TG.\n   When the actual TG size\
    \ is not a power of 2 or is smaller than the\n   max TG size, there will be sparse\
    \ utilization of the sequence number\n   space since some of the sequence numbers\
    \ that would have been\n   consumed in numbering a maximum sized TG will not be\
    \ assigned to\n   packets in the smaller TG.  The start of the next transmission\
    \ group\n   will always begin on the boundary of the maximum TG size as though\n\
    \   each of the sequence numbers had been utilized.\n   When the source decides\
    \ to use a smaller group size than that\n   advertised in OPT_PARITY_PRM, it appends\
    \ OPT_CURR_TGSIZE to the last\n   data packet (ODATA) in the truncated transmission\
    \ group.  This lets\n   the receiver know that it should not expect any more packets\
    \ in this\n   transmission group, and that it may start requesting repairs for\
    \ any\n   missing packets.  If the last data packet itself went missing, the\n\
    \   receiver will detect the end of the group when it receives a parity\n   packet\
    \ for the group, an SPM with SPM_LEAD equal to OD_SQN of the\n   last data packet,\
    \ or the first packet of the next group, whichever\n   comes first.  In addition,\
    \ any parity packet from this TG will also\n   carry the OPT_CURR_TGSIZE option\
    \ as will any SPM sent with SPM_LEAD\n   equal to OD_SQN of the last data packet.\n\
    \   Variable TSDU length\n   If a non constant TSDU length is used within a given\
    \ transmission\n   group, the size of parity packets in the corresponding FEC\
    \ block MUST\n   be equal to the size of the largest original data packet in the\n\
    \   block.  Parity packets MUST be computed by padding the original\n   packets\
    \ with zeros up to the size of the largest data packet.  Note\n   that original\
    \ data packets are transmitted without padding.\n   Receivers using a combination\
    \ of original packets and FEC packets to\n   rebuild missing packets MUST pad\
    \ the original packets in the same way\n   as the source does.  The receiver MUST\
    \ then feed the padded original\n   packets plus the parity packets to the FEC\
    \ decoder.  The decoder\n   produces the original packets padded with zeros up\
    \ to the size of the\n   largest original packet in the group.  In order for the\
    \ receiver to\n   eliminate the padding on the reconstructed data packets, the\
    \ original\n   size of the packet MUST be known, and this is accomplished as\n\
    \   follows:\n      The source, along with the packet payloads, encodes the TSDU\n\
    \      length and appends the 2-byte encoded length to the padded FEC\n      packets.\n\
    \      Receivers pad the original packets that they received to the\n      largest\
    \ original packet size and then append the TSDU length to\n      the padded packets.\
    \  They then pass them and the FEC packets to\n      the FEC decoder.\n      The\
    \ decoder produces padded original packets with their original\n      TSDU length\
    \ appended.  Receivers MUST now use this length to get\n      rid of the padding.\n\
    \   A source that transmits variable size packets MUST take into account\n   the\
    \ fact that FEC packets will have a size equal to the maximum size\n   of the\
    \ original packets plus the size of the length field (2 bytes).\n   If a fixed\
    \ packet size is used within a transmission group, the\n   encoded length is not\
    \ appended to the parity packets.  The presence\n   of the fixed header option\
    \ flag OPT_VAR_PKTLEN in parity packets\n   allows receivers to distinguish between\
    \ transmission groups with\n   variable sized packets and fixed-size ones, and\
    \ behave accordingly.\n   Payload-specific options\n   Some options present in\
    \ data packet (ODATA and RDATA) are strictly\n   associated with the packet content\
    \ (PGM payload), OPT_FRAGMENT being\n   an example.  These options must be preserved\
    \ even when the data\n   packet that would normally contain them is not received,\
    \ but its the\n   payload is recovered though the use of FEC.\n   To achieve this,\
    \ PGM encodes the content of these options in special\n   options that are inserted\
    \ in parity packets.  Two flags present in\n   the the option common-header are\
    \ used for this process:  bit F\n   (OP_ENCODED) and bit U (OP_ENCODED_NULL).\n\
    \   Whenever at least one of the original packets of a TG contains a\n   payload-specific\
    \ option of a given type, the source MUST include an\n   encoded version of that\
    \ option type in all the parity packets it\n   transmits.  The encoded option\
    \ is computed by applying FEC encoding\n   to the whole option with the exception\
    \ of the first three bytes of\n   the option common-header (E, Option Type, Option\
    \ Length, OP_ENCODED\n   and OPX fields).  The type, length and OPX of the encoded\
    \ option are\n   the same as the type, length and OPX in the original options.\n\
    \   OP_ENCODED is set to 1 (all original option have OP_ENCODED = 0).\n   The\
    \ encoding is performed using the same process that is used to\n   compute the\
    \ payload of the parity packet. i.e. the FEC encoder is fed\n   with one copy\
    \ of that option type for each original packet in the TG.\n   If one (or more)\
    \ original packet of the TG does not contain that\n   option type, an all zeroes\
    \ option is used for the encoding process.\n   To be able to distinguish this\
    \ \"dummy\" option from valid options with\n   all-zeroes payload, OP_ENCODED_NULL\
    \ is used.  OP_ENCODED_NULL is set\n   to 0 in all the original options, but the\
    \ value of 1 is used in the\n   encoding process if the option did not exist in\
    \ the original packet.\n   On the receiver side, all option with OP_ENCODED_NULL\
    \ equal to 1 are\n   discarded after decoding.\n   When a receiver recovers a\
    \ missing packet using FEC repair packets,\n   it MUST also recover payload-specific\
    \ options, if any.  The presence\n   of these can be unequivocally detected through\
    \ the presence of\n   encoded options in parity packets (encoded options have\
    \ OP_ENCODED\n   set to 1).  Receivers apply FEC-recovery to encoded options and\n\
    \   possibly original options, as they do to recover packet payloads.\n   The\
    \ FEC decoding is applied to the whole option with the exception of\n   the first\
    \ three bytes of the option common-header (E, Option Type,\n   Option Length,\
    \ OP_ENCODED and OPX fields).  Each decoded option is\n   associated with the\
    \ relative payload, unless OP_ENCODED_NULL turns\n   out to be 1, in which case\
    \ the decoded option is discarded.\n   The decoding MUST be performed using the\
    \ 1st occurrence of a given\n   option type in original/parity packets.  If one\
    \ or more original\n   packets do not contain that option type, an option of the\
    \ same type\n   with zero value must be used.  This option MUST have OP_ENCODED_NULL\n\
    \   equal to 1.\n"
- title: 11.3.  Packet Contents
  contents:
  - "11.3.  Packet Contents\n   This section just provides enough short-hand to make\
    \ the Procedures\n   intelligible.  For the full details of packet contents, please\
    \ refer\n   to Packet Formats below.\n   OPT_PARITY        indicated in pro-active\
    \ (ODATA) and on-demand\n                     (RDATA) parity packets to distinguish\
    \ them from\n                     data packets.  This option is directly encoded\
    \ in\n                     the \"Option\" field of the fixed PGM header\n   OPT_VAR_PKTLEN\
    \    MAY be present in pro-active (ODATA) and on-demand\n                    \
    \ (RDATA) parity packets to indicate that the\n                     corresponding\
    \ transmission group is composed of\n                     variable size data packets.\
    \  This option is\n                     directly encoded in the \"Option\" field\
    \ of the fixed\n                     PGM header\n   OPT_PARITY_PRM    appended\
    \ by sources to SPMs to specify session-\n                     specific parameters\
    \ such as the transmission group\n                     size and the availability\
    \ of pro-active and/or on-\n                     demand parity from the source\n\
    \   OPT_PARITY_GRP    the number of the group (greater than 0) of h\n        \
    \             parity packets to which the parity packet belongs\n            \
    \         when more than k parity packets are provided by the\n              \
    \       source\n   OPT_CURR_TGSIZE   appended by sources to the last data packet\
    \ and any\n                     parity packets in a variable sized transmission\n\
    \                     group to indicate to the receiver the actual size\n    \
    \                 of a transmission group.  May also be appended to\n        \
    \             certain SPMs\n"
- title: 11.3.1.  Parity NAKs
  contents:
  - "11.3.1.  Parity NAKs\n   NAK_TG_SQN        the high-order portion of NAK_SQN\
    \ specifying the\n                     transmission group for which parity packets\
    \ are\n                     requested\n   NAK_PKT_CNT       the low-order portion\
    \ of NAK_SQN specifying the\n                     number of missing data packets\
    \ for which parity\n                     packets are requested\n      Nota Bene:\
    \ NAK_PKT_CNT (and NCF_PKT_CNT) are 0-based counters,\n      meaning that NAK_PKT_CNT\
    \ = 0 means that 1 FEC RDATA is being\n      requested, and in general NAK_PKT_CNT\
    \ = k - 1 means that  k FEC\n      RDATA are being requested.\n"
- title: 11.3.2.  Parity NCFs
  contents:
  - "11.3.2.  Parity NCFs\n   NCF_TG_SQN        the high-order portion of NCF_SQN\
    \ specifying the\n                     transmission group for which parity packets\
    \ were\n                     requested\n   NCF_PKT_CNT       the low-order portion\
    \ of NCF_SQN specifying the\n                     number of missing data packets\
    \ for which parity\n                     packets were requested\n      Nota Bene:\
    \ NCF_PKT_CNT (and NAK_PKT_CNT) are 0-based counters,\n      meaning that NAK_PKT_CNT\
    \ = 0 means that 1 FEC RDATA is being\n      requested, and in general NAK_PKT_CNT\
    \ = k - 1 means that  k FEC\n      RDATA are being requested.\n"
- title: 11.3.3.  On-demand Parity
  contents:
  - "11.3.3.  On-demand Parity\n   RDATA_TG_SQN      the high-order portion of RDATA_SQN\
    \ specifying the\n                     transmission group to which the parity\
    \ packet\n                     belongs\n   RDATA_PKT_SQN     the low-order portion\
    \ of RDATA_SQN specifying the\n                     parity packet sequence number\
    \ within the\n                     transmission group\n"
- title: 11.3.4.  Pro-active Parity
  contents:
  - "11.3.4.  Pro-active Parity\n   ODATA_TG_SQN      the high-order portion of ODATA_SQN\
    \ specifying the\n                     transmission group to which the parity\
    \ packet\n                     belongs\n   ODATA_PKT_SQN     the low-order portion\
    \ of ODATA_SQN specifying the\n                     parity packet sequence number\
    \ within the\n                     transmission group\n"
- title: 11.4.  Procedures - Sources
  contents:
  - "11.4.  Procedures - Sources\n   If a source elects to provide parity for a given\
    \ transport session,\n   it MUST first provide the transmission group size PARITY_PRM_TGS\
    \ in\n   the OPT_PARITY_PRM option of its SPMs.  This becomes the maximum\n  \
    \ effective transmission group size in the event that the source elects\n   to\
    \ send smaller size transmission groups.  If a source elects to\n   provide proactive\
    \ parity for a given transport session, it MUST set\n   PARITY_PRM_PRO in the\
    \ OPT_PARITY_PRM option of its SPMs.  If a source\n   elects to provide on-demand\
    \ parity for a given transport session, it\n   MUST set PARITY_PRM_OND in the\
    \ OPT_PARITY_PRM option of its SPMs.\n   A source MUST send any pro-active parity\
    \ packets for a given\n   transmission group only after it has first sent all\
    \ of the\n   corresponding k data packets in that group.  Pro-active parity\n\
    \   packets MUST be sent as ODATA with OPT_PARITY in the fixed header.\n   If\
    \ a source elects to provide on-demand parity, it MUST respond to a\n   parity\
    \ NAK for a transmission group with a parity NCF.  The source\n   MUST complete\
    \ the transmission of the k original data packets and the\n   proactive parity\
    \ packets, possibly scheduled, before starting the\n   transmission of on-demand\
    \ parity packets.  Subsequently, the source\n   MUST send the number of parity\
    \ packets requested by that parity NAK.\n   On-demand parity packets MUST be sent\
    \ as RDATA with OPT_PARITY in the\n   fixed header.  Previously transmitted pro-active\
    \ parity packets\n   cannot be reused as on-demand parity packets, these MUST\
    \ be computed\n   with new, previously unused, indexes.\n   In either case, the\
    \ source MUST provide selective retransmissions\n   only in response to selective\
    \ NAKs from the leading partial\n   transmission group.  For any group that is\
    \ full, the source SHOULD\n   provide FEC on demand in response to a selective\
    \ retransmission\n   request.\n   In the absence of data to transmit, a source\
    \ SHOULD prematurely\n   terminate the current transmission group by including\
    \ OPT_CURR_TGSIZE\n   to the last data packet or to any proactive parity packets\
    \ provided.\n   If the last data packet has already been transmitted and there\
    \ is no\n   provision for sending proactive parity packets, an SPM with\n   OPT_CURR_TGSIZE\
    \ SHOULD be sent.\n   A source consolidates requests for on-demand parity in the\
    \ same\n   transmission group according to the following procedures.  If the\n\
    \   number of pending (i.e., unsent) parity packets from a previous\n   request\
    \ for on-demand parity packets is equal to or greater than\n   NAK_PKT_CNT in\
    \ a subsequent NAK, that subsequent NAK MUST be\n   confirmed but MAY otherwise\
    \ be ignored.  If the number of pending\n   (i.e., unsent) parity packets from\
    \ a previous request for on-demand\n   parity packets is less than NAK_PKT_CNT\
    \ in a subsequent NAK, that\n   subsequent NAK MUST be confirmed but the source\
    \ need only increase\n   the number of pending parity packets to NAK_PKT_CNT.\n\
    \   When a source provides parity packets relative to a transmission\n   group\
    \ with variable sized packets, it MUST compute parity packets by\n   padding the\
    \ smaller original packets with zeroes out to the size of\n   the largest of the\
    \ original packets.  The source MUST also append the\n   encoded TSDU lengths\
    \ at the end of any padding or directly to the end\n   of the largest packet,\
    \ and add the OPT_VAR_PKTLEN option as specified\n   in the overview description.\n\
    \   When a source provides variable sized transmission groups, it SHOULD\n   append\
    \ the OPT_CURR_TGSIZE option to the last data packet in the\n   shortened group,\
    \ and it MUST append the OPT_CURR_TGSIZE option to any\n   parity packets it sends\
    \ within that group.  In case the the last data\n   packet is sent before a determination\
    \ has been made to shorten the\n   group and there is no provision for sending\
    \ proactive parity packets,\n   an SPM with OPT_CURR_TGSIZE SHOULD be sent.  The\
    \ source MUST also add\n   OPT_CURR_TGSIZE to any SPM that it sends with SPM_LEAD\
    \ equal to\n   OD_SQN of the last data packet.\n   A receiver MUST NAK for the\
    \ entire number of packets missing based on\n   the maximum TG size, even if it\
    \ already knows that the actual TG size\n   is smaller.  The source MUST take\
    \ this into account and compute the\n   number of packets effectively needed as\
    \ the difference between\n   NAK_PKT_CNT and an offset computed as the difference\
    \ between the max\n   TG size and the effective TG size.\n"
- title: 11.5.  Procedures - Receivers
  contents:
  - "11.5.  Procedures - Receivers\n   If a receiver elects to make use of parity\
    \ packets for loss recovery,\n   it MUST first learn the transmission group size\
    \ PARITY_PRM_TGS from\n   OPT_PARITY_PRM in the SPMs for the TSI.  The transmission\
    \ group size\n   is used by a receiver to determine the sequence number boundaries\n\
    \   between transmission groups.\n   Thereafter, if PARITY_PRM_PRO is also set\
    \ in the SPMs for the TSI, a\n   receiver SHOULD use any pro-active parity packets\
    \ it receives for\n   loss recovery, and if PARITY_PRM_OND is also set in the\
    \ SPMs for the\n   TSI, it MAY solicit on-demand parity packets upon loss detection.\
    \  If\n   PARITY_PRM_OND is set, a receiver MUST NOT send selective NAKs,\n  \
    \ except in partial transmission groups if the source does not use the\n   variable\
    \ transmission-group size option.  Parity packets are ODATA\n   (pro-active) or\
    \ RDATA (on-demand) packets distinguished by OPT_PARITY\n   which lets receivers\
    \ know that ODATA/RDATA_TG_SQN identifies the\n   group of PARITY_PRM_TGS packets\
    \ to which the parity may be applied\n   for loss recovery in the corresponding\
    \ transmission group, and that\n   ODATA/RDATA_PKT_SQN is being reused to number\
    \ the parity packets\n   within that group.  Receivers order parity packets and\
    \ eliminate\n   duplicates within a transmission group based on ODATA/RDATA_PKT_SQN\n\
    \   and on OPT_PARITY_GRP if present.\n   To solicit on-demand parity packets,\
    \ a receiver MUST send parity NAKs\n   upon loss detection.  For the purposes\
    \ of soliciting on-demand\n   parity, loss detection occurs at transmission group\
    \ boundaries, i.e.\n   upon receipt of the last data packet in a transmission\
    \ group, upon\n   receipt of any data packet in any subsequent transmission group,\
    \ or\n   upon receipt of any parity packet in the current or a subsequent\n  \
    \ transmission group.\n   A parity NAK is simply a NAK with OPT_PARITY and NAK_PKT_CNT\
    \ set to\n   the count of the number of packets detected to be missing from the\n\
    \   transmission group specified by NAK_TG_SQN.  Note that this\n   constrains\
    \ the receiver to request no more parity packets than there\n   are data packets\
    \ in the transmission group.\n   A receiver SHOULD bias the value of NAK_BO_IVL\
    \ for parity NAKs\n   inversely proportional to NAK_PKT_CNT so that NAKs for larger\
    \ losses\n   are likely to be scheduled ahead of NAKs for smaller losses in the\n\
    \   same receiver population.\n   A confirming NCF for a parity NAK is a parity\
    \ NCF with NCF_PKT_CNT\n   equal to or greater than that specified by the parity\
    \ NAK.\n   A receiver's NAK_RDATA_IVL timer is not cancelled until all requested\n\
    \   parity packets have been received.\n   In the absence of data (detected from\
    \ SPMs bearing SPM_LEAD equal to\n   RXW_LEAD) on non-transmission-group boundaries,\
    \ receivers MAY resort\n   to selective NAKs for any missing packets in that partial\n\
    \   transmission group.\n   When a receiver handles parity packets belonging to\
    \ a transmission\n   group with variable sized packets, (detected from the presence\
    \ of the\n   OPT_VAR_PKTLEN option in the parity packets), it MUST decode them\
    \ as\n   specified in the overview description and use the decoded TSDU length\n\
    \   to get rid of the padding in the decoded packet.\n   If the source was using\
    \ a variable sized transmission group via the\n   OPT_CURR_TGSIZE, the receiver\
    \ might learn this before having\n   requested (and received) any retransmission.\
    \  The above happens if it\n   sees OPT_CURR_TGSIZE in the last data packet of\
    \ the TG, in any\n   proactive parity packet or in a SPM.  If the receivers learns\
    \ this\n   and determines that it has missed one or more packets in the\n   shortened\
    \ transmission group, it MAY then NAK for them without\n   waiting for the start\
    \ of the next transmission group.  Otherwise it\n   will start NAKing at the start\
    \ of the next transmission group.\n   In both cases, the receiver MUST NAK for\
    \ the number of packets\n   missing assuming that the size of the transmission\
    \ group is the\n   maximum effective transmission group.  In other words, the\
    \ receivers\n   cannot exploit the fact that it might already know that the\n\
    \   transmission group was smaller but MUST always NAK for the number of\n   packets\
    \ it believes are missing, plus the number of packets required\n   to bring the\
    \ total packets up to the maximum effective transmission\n   group size.\n   After\
    \ the first parity packet has been delivered to the receiver, the\n   actual TG\
    \ size is known to him, either because already known or\n   because discovered\
    \ via OPT_CURR_TGSIZE contained in the parity\n   packet.  Hence the receiver\
    \ can decode the whole group as soon as the\n   minimum number of parity packets\
    \ needed is received.\n"
- title: 11.6.  Procedures - Network Elements
  contents:
  - "11.6.  Procedures - Network Elements\n   Pro-active parity packets (ODATA with\
    \ OPT_PARITY) are switched by\n   network elements without transport-layer intervention.\n\
    \   On-demand parity packets (RDATA with OPT_PARITY) necessitate modified\n  \
    \ request, confirmation and repair constraint procedures for network\n   elements.\
    \  In the context of these procedures, repair state is\n   maintained per NAK_TSI\
    \ and NAK_TG_SQN, and in addition to recording\n   the interfaces on which corresponding\
    \ NAKs have been received,\n   records the largest value of NAK_PKT_CNT seen in\
    \ corresponding NAKs\n   on each interface.  This value is referred to as the\
    \ known packet\n   count.  The largest of the known packet counts recorded for\
    \ any\n   interface in the repair state for the transmit group or carried by an\n\
    \   NCF is referred to as the largest known packet count.\n   Upon receipt of\
    \ a parity NAK, a network element responds with the\n   corresponding parity NCF.\
    \  The corresponding parity NCF is just an\n   NCF formed in the usual way (i.e.,\
    \ a multicast copy of the NAK with\n   the packet type changed), but with the\
    \ addition of OPT_PARITY and\n   with NCF_PKT_CNT set to the larger of NAK_PKT_CNT\
    \ and the known\n   packet count for the receiving interface.  The network element\
    \ then\n   creates repair state in the usual way with the following\n   modifications.\n\
    \   If repair state for the receiving interface does not exist, the\n   network\
    \ element MUST create it and additionally record NAK_PKT_CNT\n   from the parity\
    \ NAK as the known packet count for the receiving\n   interface.\n   If repair\
    \ state for the receiving interface already exists, the\n   network element MUST\
    \ eliminate the NAK only if NAK_ELIM_IVL has not\n   expired and NAK_PKT_CNT is\
    \ equal to or less than the largest known\n   packet count.  If NAK_PKT_CNT is\
    \ greater than the known packet count\n   for the receiving interface, the network\
    \ element MUST update the\n   latter with the larger NAK_PKT_CNT.\n   Upon either\
    \ adding a new interface or updating the known packet count\n   for an existing\
    \ interface, the network element MUST determine if\n   NAK_PKT_CNT is greater\
    \ than the largest known packet count.  If so or\n   if NAK_ELIM_IVL has expired,\
    \ the network element MUST forward the\n   parity NAK in the usual way with a\
    \ value of NAK_PKT_CNT equal to the\n   largest known packet count.\n   Upon receipt\
    \ of an on-demand parity packet, a network element MUST\n   locate existing repair\
    \ state for the corresponding RDATA_TSI and\n   RDATA_TG_SQN.  If no such repair\
    \ state exists, the network element\n   MUST discard the RDATA as usual.\n   If\
    \ corresponding repair state exists, the largest known packet count\n   MUST be\
    \ decremented by one, then the network element MUST forward the\n   RDATA on all\
    \ interfaces in the existing repair state, and decrement\n   the known packet\
    \ count by one for each.  Any interfaces whose known\n   packet count is thereby\
    \ reduced to zero MUST be deleted from the\n   repair state.  If the number of\
    \ interfaces is thereby reduced to\n   zero, the repair state itself MUST be deleted.\n\
    \   Upon reception of a parity NCF, network elements MUST cancel pending\n   NAK\
    \ retransmission only if NCF_PKT_CNT is greater or equal to the\n   largest known\
    \ packet count.  Network elements MUST use parity NCFs to\n   anticipate NAKs\
    \ in the usual way with the addition of recording\n   NCF_PKT_CNT from the parity\
    \ NCF as the largest known packet count\n   with the anticipated state so that\
    \ any subsequent NAKs received with\n   NAK_PKT_CNT equal to or less than NCF_PKT_CNT\
    \ will be eliminated, and\n   any with NAK_PKT_CNT greater than NCF_PKT_CNT will\
    \ be forwarded.\n   Network elements which receive  a parity NCF with NCF_PKT_CNT\
    \ larger\n   than the largest known packet count MUST also use it to anticipate\n\
    \   NAKs, increasing the largest known packet count to reflect\n   NCF_PKT_CNT\
    \ (partial anticipation).\n   Parity NNAKs follow the usual elimination procedures\
    \ with the\n   exception that NNAKs are eliminated only if existing NAK state\
    \ has a\n   NAK_PKT_CNT greater than NNAK_PKT_CNT.\n   Network elements must take\
    \ extra precaution when the source is using\n   a variable sized transmission\
    \ group.  Network elements learn that the\n   source is using a TG size smaller\
    \ than the maximum from\n   OPT_CURR_TGSIZE in parity RDATAs or in SPMs.  When\
    \ this happens, they\n   compute a TG size offset as the difference between the\
    \ maximum TG\n   size and the actual TG size advertised by OPT_CURR_TGSIZE.  Upon\n\
    \   reception of parity RDATA, the TG size offset is used to update the\n   repair\
    \ state as follows:\n      Any interface whose known packet count is reduced to\
    \ the TG size\n      offset is deleted from the repair state.\n   This replaces\
    \ the normal rule for deleting interfaces that applies\n   when the TG size is\
    \ equal to the maximum TG size.\n"
- title: 11.7.  Procedures - DLRs
  contents:
  - "11.7.  Procedures - DLRs\n   A DLR with the ability to provide FEC repairs MUST\
    \ indicate this by\n   setting the OPT_PARITY bit in the redirecting POLR.  It\
    \ MUST then\n   process any redirected FEC NAKs in the usual way.\n"
- title: 11.8.  Packet Formats
  contents:
  - '11.8.  Packet Formats

    '
- title: 11.8.1.  OPT_PARITY_PRM - Packet Extension Format
  contents:
  - "11.8.1.  OPT_PARITY_PRM - Packet Extension Format\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|         |P O|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Transmission Group Size                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x08\n   Option Length = 8 octets\n   P-bit (PARITY_PRM_PRO)\n\
    \      Indicates when set that the source is providing pro-active parity\n   \
    \   packets.\n   O-bit (PARITY_PRM_OND)\n      Indicates when set that the source\
    \ is providing on-demand parity\n      packets.\n   At least one of PARITY_PRM_PRO\
    \ and PARITY_PRM_OND MUST be set.\n   Transmission Group Size (PARITY_PRM_TGS)\n\
    \      The number of data packets in the transmission group over which\n     \
    \ the parity packets are calculated.  If a variable transmission\n      group\
    \ size is being used, then this becomes the maximum effective\n      transmission\
    \ group size across the session.\n   OPT_PARITY_PRM MAY be appended only to SPMs.\n\
    \   OPT_PARITY_PRM is network-significant.\n"
- title: 11.8.2.  OPT_PARITY_GRP - Packet Extension Format
  contents:
  - "11.8.2.  OPT_PARITY_GRP - Packet Extension Format\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Parity Group Number                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x09\n   Option Length = 8 octets\n   Parity Group Number (PRM_GROUP)\n\
    \      The number of the group of k parity packets amongst the h parity\n    \
    \  packets within the transmission group to which the parity packet\n      belongs,\
    \ where the first k parity packets are in group zero.\n      PRM_GROUP MUST NOT\
    \ be zero.\n   OPT_PARITY_GRP MAY be appended only to parity packets.\n   OPT_PARITY_GRP\
    \ is NOT network-significant.\n"
- title: 11.8.3.  OPT_CURR_TGSIZE - Packet Extension Format
  contents:
  - "11.8.3.  OPT_CURR_TGSIZE - Packet Extension Format\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Actual Transmission Group Size                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x0A\n   Option Length = 8 octets\n   Actual Transmission Group\
    \ Size (PRM_ATGSIZE)\n      The actual number of data packets in this transmission\
    \ group.\n      This MUST be less than or equal to the maximum transmission group\n\
    \      size PARITY_PRM_TGS in OPT_PARITY_PRM.\n   OPT_CURR_TGSIZE MAY be appended\
    \ to data and parity packets (ODATA or\n   RDATA) and to SPMs.\n   OPT_CURR_TGSIZE\
    \ is network-significant except when appended to ODATA.\n"
- title: 12.  Appendix B - Support for Congestion Control
  contents:
  - '12.  Appendix B - Support for Congestion Control

    '
- title: 12.1.  Introduction
  contents:
  - "12.1.  Introduction\n   A source MUST implement strategies for congestion avoidance,\
    \ aimed at\n   providing overall network stability, fairness among competing PGM\n\
    \   flows, and some degree of fairness towards coexisting TCP flows [13].\n  \
    \ In order to do this, the source must be provided with feedback on the\n   status\
    \ of the network in terms of traffic load.  This appendix\n   specifies NE procedures\
    \ that provide such feedback to the source in a\n   scalable way.  (An alternative\
    \ TCP-friendly scheme for congestion\n   control that does not require NE support\
    \ can be found in [16]).\n   The procedures specified in this section enable the\
    \ collection and\n   selective forwarding of three types of feedback to the source:\n\
    \      o Worst link load as measured in network elements.\n      o Worst end-to-end\
    \ path load as measured in network elements.\n      o Worst end-to-end path load\
    \ as reported by receivers.\n   This specification defines in detail NE procedures,\
    \ receivers\n   procedures and packet formats.  It also defines basic procedures\
    \ in\n   receivers for generating congestion reports.  This specification does\n\
    \   not define the procedures used by PGM sources to adapt their\n   transmission\
    \ rates in response of congestion reports.  Those\n   procedures depend upon the\
    \ specific congestion control scheme.\n   PGM defines a header option that PGM\
    \ receivers may append to NAKs\n   (OPT_CR).  OPT_CR carries congestion reports\
    \ in NAKs that propagate\n   upstream towards the source.\n   During the process\
    \ of hop-by-hop reverse NAK forwarding, NEs examine\n   OPT_CR and possibly modify\
    \ its contents prior to forwarding the NAK\n   upstream.  Forwarding CRs also\
    \ has the side effect of creating\n   congestion report state in the NE.  The\
    \ presence of OPT_CR and its\n   contents also influences the normal NAK suppression\
    \ rules.  Both the\n   modification performed on the congestion report and the\
    \ additional\n   suppression rules depend on the content of the congestion report\
    \ and\n   on the congestion report state recorded in the NE as detailed below.\n\
    \   OPT_CR contains the following fields:\n   OPT_CR_NE_WL   Reports the load\
    \ in the worst link as detected though\n                  NE internal measurements\n\
    \   OPT_CR_NE_WP   Reports the load in the worst end-to-end path as\n        \
    \          detected though NE internal measurements\n   OPT_CR_RX_WP   Reports\
    \ the load in the worst end-to-end path as\n                  detected by receivers\n\
    \   A load report is either a packet drop rate (as measured at an NE's\n   interfaces)\
    \ or a packet loss rate (as measured in receivers).  Its\n   value is linearly\
    \ encoded in the range 0-0xFFFF, where 0xFFFF\n   represents a 100% loss/drop\
    \ rate.  Receivers that send a NAK bearing\n   OPT_CR determine which of the three\
    \ report fields are being reported.\n   OPT_CR also contains the following fields:\n\
    \   OPT_CR_NEL     A bit indicating that OPT_CR_NE_WL is being reported.\n   OPT_CR_NEP\
    \     A bit indicating that OPT_CR_NE_WP is being reported.\n   OPT_CR_RXP   \
    \  A bit indicating that OPT_CR_RX_WP is being reported.\n   OPT_CR_LEAD    A\
    \ SQN in the ODATA space that serves as a temporal\n                  reference\
    \ for the load report values.  This is\n                  initialized by receivers\
    \ with the leading edge of the\n                  transmit window as known at\
    \ the moment of transmitting\n                  the NAK.  This value MAY be advanced\
    \ in NEs that\n                  modify the content of OPT_CR.\n   OPT_CR_RCVR\
    \    The identity of the receiver that generated the worst\n                 \
    \ OPT_CR_RX_WP.\n   The complete format of the option is specified later.\n"
- title: 12.2.  NE-Based Worst Link Report
  contents:
  - "12.2.  NE-Based Worst Link Report\n   To permit network elements to report worst\
    \ link, receivers append\n   OPT_CR to a NAK with bit OPT_CR_NEL set and OPT_CR_NE_WL\
    \ set to zero.\n   NEs receiving NAKs that contain OPT_CR_NE_WL process the option\
    \ and\n   update per-TSI state related to it as described below.  The ultimate\n\
    \   result of the NEs' actions ensures that when a NAK leaves a sub-tree,\n  \
    \ OPT_CR_NE_WL contains a congestion report that reflects the load of\n   the\
    \ worst link in that sub-tree.  To achieve this, NEs rewrite\n   OPT_CR_NE_WL\
    \ with the worst value among the loads measured on the\n   local (outgoing) links\
    \ for the session and the congestion reports\n   received from those links.\n\
    \   Note that the mechanism described in this sub-section does not permit\n  \
    \ the monitoring of the load on (outgoing) links at non-PGM-capable\n   multicast\
    \ routers.  For this reason, NE-Based Worst Link Reports\n   SHOULD be used in\
    \ pure PGM topologies only.  Otherwise, this\n   mechanism might fail in detecting\
    \ congestion.  To overcome this\n   limitation PGM sources MAY use a heuristic\
    \ that combines NE-Based\n   Worst Link Reports and Receiver-Based Reports.\n"
- title: 12.3.  NE-Based Worst Path Report
  contents:
  - "12.3.  NE-Based Worst Path Report\n   To permit network elements to report a\
    \ worst path, receivers append\n   OPT_CR to a NAK with bit OPT_CR_NEP set and\
    \ OPT_CR_NE_WP set to zero.\n   The processing of this field is similar to that\
    \ of OPT_CR_NE_WL with\n   the difference that, on the reception of a NAK, the\
    \ value of\n   OPT_CR_NE_WP is adjusted with the load measured on the interface\
    \ on\n   which the NAK was received according to the following formula:\n   OPT_CR_NE_WP\
    \ = if_load + OPT_CR_NE_WP * (100% - if_loss_rate)\n   The worst among the adjusted\
    \ OPT_CR_NE_WP is then written in the\n   outgoing NAK.  This results in a hop-by-hop\
    \ accumulation of link loss\n   rates into a path loss rate.\n   As with OPT_CR_NE_WL,\
    \ the congestion report in OPT_CR_NE_WP may be\n   invalid if the multicast distribution\
    \ tree includes non-PGM-capable\n   routers.\n"
- title: 12.4.  Receiver-Based Worst Report
  contents:
  - "12.4.  Receiver-Based Worst Report\n   To report a packet loss rate, receivers\
    \ append OPT_CR to a NAK with\n   bit OPT_CR_RXP set and OPT_CR_RX_WP set to the\
    \ packet loss rate.  NEs\n   receiving NAKs that contain OPT_CR_RX_WP process\
    \ the option and\n   update per-TSI state related to it as described below.  The\
    \ ultimate\n   result of the NEs' actions ensures that when a NAK leaves a sub-tree,\n\
    \   OPT_CR_RX_WP contains a congestion report that reflects the load of\n   the\
    \ worst receiver in that sub-tree.  To achieve this, NEs rewrite\n   OTP_CR_RE_WP\
    \ with the worst value among the congestion reports\n   received on its outgoing\
    \ links for the session.  In addition to this,\n   OPT_CR_RCVR MUST contain the\
    \ NLA of the receiver that originally\n   measured the value of OTP_CR_RE_WP being\
    \ forwarded.\n"
- title: 12.5.  Procedures - Receivers
  contents:
  - "12.5.  Procedures - Receivers\n   To enable the generation of any type of congestion\
    \ report, receivers\n   MUST insert OPT_CR in each NAK they generate and provide\
    \ the\n   corresponding field (OPT_CR_NE_WL, OPT_CR_NE_WP, OPT_CR_RX_WP).  The\n\
    \   specific fields to be reported will be advertised to receivers in\n   OPT_CRQST\
    \ on the session's SPMs.  Receivers MUST provide only those\n   options requested\
    \ in OPT_CRQST.\n   Receivers MUST initialize OPT_CR_NE_WL and OPT_CR_NE_WP to\
    \ 0 and they\n   MUST initialize OPT_CR_RCVR to their NLA.  At the moment of sending\n\
    \   the NAK, they MUST also initialize OPT_CR_LEAD to the leading edge of\n  \
    \ the transmission window.\n   Additionally, if a receiver generates a NAK with\
    \ OPT_CR with\n   OPT_CR_RX_WP, it MUST initialize OPT_CR_RX_WP to the proper\
    \ value,\n   internally computed.\n"
- title: 12.6.  Procedures - Network Elements
  contents:
  - "12.6.  Procedures - Network Elements\n   Network elements start processing each\
    \ OPT_CR by selecting a\n   reference SQN in the ODATA space.  The reference SQN\
    \ selected is the\n   highest SQN known to the NE.  Usually this is OPT_CR_LEAD\
    \ contained\n   in the NAK received.\n   They use the selected SQN to age the\
    \ value of load measurement as\n   follows:\n      o  locally measured load values\
    \ (e.g. interface loads) are\n         considered up-to-date\n      o  load values\
    \ carried in OPT_CR are considered up-to-date and are\n         not aged so as\
    \ to be independent of variance in round-trip\n         times from the network\
    \ element to the receivers\n      o  old load values recorded in the NE are exponentially\
    \ aged\n         according to the difference between the selected reference SQN\n\
    \         and the reference SQN associated with the old load value.\n   The exponential\
    \ aging is computed so that a recorded value gets\n   scaled down by a factor\
    \ exp(-1/2) each time the expected inter-NAK\n   time elapses.  Hence the aging\
    \ formula must include the current loss\n   rate as follows:\n      aged_loss_rate\
    \ = loss_rate * exp( - SQN_difference * loss_rate /\n      2)\n   Note that the\
    \ quantity 1/loss_rate is the expected SQN_lag between\n   two NAKs, hence the\
    \ formula above can also be read as:\n      aged_loss_rate = loss_rate * exp(\
    \ - 1/2 * SQN_difference /\n      SQN_lag)\n   which equates to (loss_rate * exp(-1/2))\
    \ when the SQN_difference is\n   equal to expected SQN_lag between two NAKs.\n\
    \   All the subsequent computations refer to the aged load values.\n   Network\
    \ elements process OPT_CR by handling the three possible types\n   of congestion\
    \ reports independently.\n   For each congestion report in an incoming NAK, a\
    \ new value is\n   computed to be used in the outgoing NAK:\n      o  The new\
    \ value for OPT_CR_NE_WL is the maximum of the load\n         measured on the\
    \ outgoing interfaces for the session, the value\n         of OPT_CR_NE_WL of\
    \ the incoming NAK, and the value previously\n         sent upstream (recorded\
    \ in the NE).  All these values are as\n         obtained after the aging process.\n\
    \      o  The new value for OPT_CR_NE_WP is the maximum of the value\n       \
    \  previously sent upstream (after aging) and the value of\n         OPT_CR_NE_WP\
    \ in the incoming NAK adjusted with the load on the\n         interface upon which\
    \ the NAK was received (as described above).\n      o  The new value for OPT_CR_RX_WP\
    \ is the maximum of the value\n         previously sent upstream (after aging)\
    \ and the value of\n         OPT_CR_RX_WP in the incoming NAK.\n      o  If OPT_CR_RX_WP\
    \ was selected from the incoming NAK, the new\n         value for OPT_CR_RCVR\
    \ is the one in the incoming NAK.\n         Otherwise it is the value previously\
    \ sent upstream.\n      o  The new value for OPT_CR_LEAD is the reference SQN\
    \ selected for\n         the aging procedure.\n"
- title: 12.6.1.  Overriding Normal Suppression Rules
  contents:
  - "12.6.1.  Overriding Normal Suppression Rules\n   Normal suppression rules hold\
    \ to determine if a NAK should be\n   forwarded upstream or not.  However if any\
    \ of the outgoing congestion\n   reports has changed by more than 5% relative\
    \ to the one previously\n   sent upstream, this new NAK is not suppressed.\n"
- title: 12.6.2.  Link Load Measurement
  contents:
  - "12.6.2.  Link Load Measurement\n   PGM routers monitor the load on all their\
    \ outgoing links and record\n   it in the form of per-interface loss rate statistics.\
    \ \"load\" MUST be\n   interpreted as the percentage of the packets meant to be\
    \ forwarded on\n   the interface that were dropped.  Load statistics refer to\
    \ the\n   aggregate traffic on the links and not to PGM traffic only.\n   This\
    \ document does not specify the algorithm to be used to collect\n   such statistics,\
    \ but requires that such algorithm provide both\n   accuracy and responsiveness\
    \ in the measurement process.  As far as\n   accuracy is concerned, the expected\
    \ measurement error SHOULD be\n   upper-limited (e.g. less than than 10%).  As\
    \ far as responsiveness is\n   concerned, the measured load SHOULD converge to\
    \ the actual value in a\n   limited time (e.g. converge to 90% of the actual value\
    \ in less than\n   200 milliseconds), when the instantaneous offered load changes.\n\
    \   Whenever both requirements cannot be met at the same time, accuracy\n   SHOULD\
    \ be traded for responsiveness.\n"
- title: 12.7.  Packet Formats
  contents:
  - '12.7.  Packet Formats

    '
- title: 12.7.1.  OPT_CR - Packet Extension Format
  contents:
  - "12.7.1.  OPT_CR - Packet Extension Format\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|        L P R|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Congestion Report Reference SQN                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        NE Worst Link          |        NE Worst Path          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Rcvr Worst Path         |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            NLA AFI            |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Worst Receiver's NLA                ...   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+\n\
    \   Option Type = 0x10\n   Option Length = 20 octets + NLA length\n      L OPT_CR_NEL\
    \ bit : set indicates OPT_CR_NE_WL is being reported\n      P OPT_CR_NEP bit :\
    \ set indicates OPT_CR_NE_WP is being reported\n      R OPT_CR_RXP bit : set indicates\
    \ OPT_CR_RX_WP is being reported\n   Congestion Report Reference SQN (OPT_CR_LEAD).\n\
    \      A SQN in the ODATA space that serves as a temporal reference point\n  \
    \    for the load report values.\n   NE Worst Link (OPT_CR_NE_WL).\n      Reports\
    \ the load in the worst link as detected though NE internal\n      measurements\n\
    \   NE Worst Path (OPT_CR_NE_WP).\n      Reports the load in the worst end-to-end\
    \ path as detected though\n      NE internal measurements\n   Rcvr Worst Path\
    \ (OPT_CR_RX_WP).\n      Reports the load in the worst end-to-end path as detected\
    \ by\n      receivers\n   Worst Receiver's NLA (OPT_CR_RCVR).\n      The unicast\
    \ address of the receiver that generated the worst\n      OPT_CR_RX_WP.\n   OPT_CR\
    \ MAY be appended only to NAKs.\n   OPT-CR is network-significant.\n"
- title: 12.7.2.  OPT_CRQST - Packet Extension Format
  contents:
  - "12.7.2.  OPT_CRQST - Packet Extension Format\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|        L P R|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x11\n   Option Length = 4 octets\n      L OPT_CRQST_NEL bit\
    \ : set indicates OPT_CR_NE_WL is being\n      requested\n      P OPT_CRQST_NEP\
    \ bit : set indicates OPT_CR_NE_WP is being\n      requested\n      R OPT_CRQST_RXP\
    \ bit : set indicates OPT_CR_RX_WP is being\n      requested\n   OPT_CRQST MAY\
    \ be appended only to SPMs.\n   OPT-CRQST is network-significant.\n"
- title: 13.  Appendix C - SPM Requests
  contents:
  - '13.  Appendix C - SPM Requests

    '
- title: 13.1.  Introduction
  contents:
  - "13.1.  Introduction\n   SPM Requests (SPMRs) MAY be used to solicit an SPM from\
    \ a source in a\n   non-implosive way.  The typical application is for late-joining\n\
    \   receivers to solicit SPMs directly from a source in order to be able\n   to\
    \ NAK for missing packets without having to wait for a regularly\n   scheduled\
    \ SPM from that source.\n"
- title: 13.2.  Overview
  contents:
  - "13.2.  Overview\n   Allowing for SPMR implosion protection procedures, a receiver\
    \ MAY\n   unicast an SPMR to a source to solicit the most current session,\n \
    \  window, and path state from that source any time after the receiver\n   has\
    \ joined the group.  A receiver may learn the TSI and source to\n   which to direct\
    \ the SPMR from any other PGM packet it receives in the\n   group, or by any other\
    \ means such as from local configuration or\n   directory services.  The receiver\
    \ MUST use the usual SPM procedures\n   to glean the unicast address to which\
    \ it should direct its NAKs from\n   the solicited SPM.\n"
- title: 13.3.  Packet Contents
  contents:
  - "13.3.  Packet Contents\n   This section just provides enough short-hand to make\
    \ the Procedures\n   intelligible.  For the full details of packet contents, please\
    \ refer\n   to Packet Formats below.\n"
- title: 13.3.1.  SPM Requests
  contents:
  - "13.3.1.  SPM Requests\n   SPMRs are transmitted by receivers to solicit SPMs\
    \ from a source.\n   SPMs are unicast to a source and contain:\n   SPMR_TSI  \
    \     the source-assigned TSI for the session to which the\n                 \
    \ SPMR corresponds\n"
- title: 13.4.  Procedures - Sources
  contents:
  - "13.4.  Procedures - Sources\n   A source MUST respond immediately to an SPMR\
    \ with the corresponding\n   SPM rate limited to once per IHB_MIN per TSI.  The\
    \ corresponding SPM\n   matches SPM_TSI to SPMR_TSI and SPM_DPORT to SPMR_DPORT.\n"
- title: 13.5.  Procedures - Receivers
  contents:
  - "13.5.  Procedures - Receivers\n   To moderate the potentially implosive behavior\
    \ of SPMRs at least on a\n   densely populated subnet, receivers MUST use the\
    \ following back-off\n   and suppression procedure based on multicasting the SPMR\
    \ with a TTL\n   of 1 ahead of and in addition to unicasting the SPMR to the source.\n\
    \   The role of the multicast SPMR is to suppress the transmission of\n   identical\
    \ SPMRs from the subnet.\n   More specifically, before unicasting a given SPMR,\
    \ receivers MUST\n   choose a random delay on SPMR_BO_IVL (~250 msecs) during\
    \ which they\n   listen for a multicast of an identical SPMR.  If a receiver does\
    \ not\n   see a matching multicast SPMR within its chosen random interval, it\n\
    \   MUST first multicast its own SPMR to the group with a TTL of 1 before\n  \
    \ then unicasting its own SPMR to the source.  If a receiver does see a\n   matching\
    \ multicast SPMR within its chosen random interval, it MUST\n   refrain from unicasting\
    \ its SPMR and wait instead for the\n   corresponding SPM.\n   In addition, receipt\
    \ of the corresponding SPM within this random\n   interval SHOULD cancel transmission\
    \ of an SPMR.\n   In either case, the receiver MUST wait at least SPMR_SPM_IVL\
    \ before\n   attempting to repeat the SPMR by choosing another delay on\n   SPMR_BO_IVL\
    \ and repeating the procedure above.\n   The corresponding SPMR matches SPMR_TSI\
    \ to SPMR_TSI and SPMR_DPORT to\n   SPMR_DPORT.  The corresponding SPM matches\
    \ SPM_TSI to SPMR_TSI and\n   SPM_DPORT to SPMR_DPORT.\n"
- title: 13.6.  SPM Requests
  contents:
  - "13.6.  SPM Requests\n      SPMR:\n         SPM Requests are sent by receivers\
    \ to request the immediate\n         transmission of an SPM for the given TSI\
    \ from a source.\n   The network-header source address of an SPMR is the unicast\
    \ NLA of\n   the entity that originates the SPMR.\n   The network-header destination\
    \ address of an SPMR is the unicast NLA\n   of the source from which the corresponding\
    \ SPM is requested.\n    0                   1                   2           \
    \        3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ |         Source Port           |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Type     |    Options    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Global Source ID                   ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...    Global Source ID       |           TSDU Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Option Extensions when present ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ ...\n   Source Port:\n      SPMR_SPORT\n      Data-Destination Port\n   Destination\
    \ Port:\n      SPMR_DPORT\n      Data-Source Port, together with Global Source\
    \ ID forms SPMR_TSI\n   Type:\n      SPMR_TYPE =  0x0C\n   Global Source ID:\n\
    \      SPMR_GSI\n      Together with Source Port forms\n         SPMR_TSI\n"
- title: 14.  Appendix D - Poll Mechanism
  contents:
  - '14.  Appendix D - Poll Mechanism

    '
- title: 14.1.  Introduction
  contents:
  - "14.1.  Introduction\n      These procedures provide PGM network elements and\
    \ sources with the\n      ability to poll their downstream PGM neighbors to solicit\
    \ replies\n      in an implosion-controlled way.\n      Both general polls and\
    \ specific polls are possible.  The former\n      provide a PGM (parent) node\
    \ with a way to check if there are any\n      PGM (children) nodes connected to\
    \ it, both network elements and\n      receivers, and to estimate their number.\
    \  The latter may be used\n      by PGM parent nodes to search for nodes with\
    \ specific properties\n      among its PGM children.  An example of application\
    \ for this is DLR\n      discovery.\n      Polling is implemented using two additional\
    \ PGM packets:\n   POLL  a Poll Request that PGM parent nodes multicast to the\
    \ group to\n         perform the poll.  Similarly to NCFs, POLL packets stop at\
    \ the\n         first PGM node they reach, as they are not forwarded by PGM\n\
    \         network elements.\n   POLR a Poll Response that PGM children nodes (either\
    \ network elements\n         or receivers) use to reply to a Poll Request by addressing\
    \ it\n         to the NLA of the interface from which the triggering POLL was\n\
    \         sent.\n   The polling mechanism dictates that PGM children nodes that\
    \ receive a\n   POLL packet reply to it only if certain conditions are satisfied\
    \ and\n   ignore the POLL otherwise.  Two types of condition are possible: a\n\
    \   random condition that defines a probability of replying for the\n   polled\
    \ child, and a deterministic condition.  Both the random\n   condition and the\
    \ deterministic condition are controlled by the\n   polling PGM parent node by\
    \ specifying the probability of replying and\n   defining the deterministic condition(s)\
    \ respectively.  Random-only\n   poll, deterministic-only poll or a combination\
    \ of the two are\n   possible.\n   The random condition in polls allows the prevention\
    \ of implosion of\n   replies by controlling their number.  Given a probability\
    \ of replying\n   P and assuming that each receiver makes an independent decision,\
    \ the\n   number of expected replies to a poll is P*N where N is the number of\n\
    \   PGM children relative to the polling PGM parent.  The polling node\n   can\
    \ control the number of expected replies by specifying P in the\n   POLL packet.\n"
- title: 14.2.  Packet Contents
  contents:
  - "14.2.  Packet Contents\n   This section just provides enough short-hand to make\
    \ the Procedures\n   intelligible.  For the full details of packet contents, please\
    \ refer\n   to Packet Formats below.\n"
- title: 14.2.1.  POLL (Poll Request)
  contents:
  - "14.2.1.  POLL (Poll Request)\n   POLL_SQN       a sequence number assigned sequentially\
    \ by the polling\n                  parent in unit increments and scoped by POLL_PATH\
    \ and\n                  the TSI of the session.\n   POLL_ROUND     a poll round\
    \ sequence number.  Multiple poll rounds\n                  are possible within\
    \ a POLL_SQN.\n   POLL_S_TYPE    the sub-type of the poll request\n   POLL_PATH\
    \      the network-layer address (NLA) of the interface on\n                 \
    \ the PGM network element or source on which the POLL is\n                  transmitted\n\
    \   POLL_BO_IVL    the back-off interval that MUST be used to compute the\n  \
    \                random back-off time to wait before sending the\n           \
    \       response to a poll.  POLL_BO_IVL is expressed in\n                  microseconds.\n\
    \   POLL_RAND      a random string used to implement the randomness in\n     \
    \             replying\n   POLL_MASK      a bit-mask used to determine the probability\
    \ of random\n                  replies\n   Poll request MAY also contain options\
    \ which specify deterministic\n   conditions for the reply.  No options are currently\
    \ defined.\n"
- title: 14.2.2.  POLR (Poll Response)
  contents:
  - "14.2.2.  POLR (Poll Response)\n   POLR_SQN       POLL_SQN of the poll request\
    \ for which this is a reply\n   POLR_ROUND     POLL_ROUND of the poll request\
    \ for which this is a\n                  reply\n   Poll response MAY also contain\
    \ options.  No options are currently\n   defined.\n"
- title: 14.3.  Procedures - General
  contents:
  - '14.3.  Procedures - General

    '
- title: 14.3.1.  General Polls
  contents:
  - "14.3.1.  General Polls\n   General Polls may be used to check for and count PGM\
    \ children that\n   are 1 PGM hop downstream of an interface of a given node.\
    \  They have\n   POLL_S_TYPE equal to PGM_POLL_GENERAL.  PGM children that receive\
    \ a\n   general poll decide whether to reply to it only based on the random\n\
    \   condition present in the POLL.\n   To prevent response implosion, PGM parents\
    \ that initiate a general\n   poll SHOULD establish the probability of replying\
    \ to the poll, P, so\n   that the expected number of replies is contained.  The\
    \ expected\n   number of replies is N * P, where N is the number of children.\
    \  To be\n   able to compute this number, PGM parents SHOULD already have a rough\n\
    \   estimate of the number of children.  If they do not have a recent\n   estimate\
    \ of this number, they SHOULD send the first poll with a very\n   low probability\
    \ of replying and increase it in subsequent polls in\n   order to get the desired\
    \ number of replies.\n   To prevent poll-response implosion caused by a sudden\
    \ increase in the\n   children population occurring between two consecutive polls\
    \ with\n   increasing probability of replying, PGM parents SHOULD use poll\n \
    \  rounds.  Poll rounds allow PGM parents to \"freeze\" the size of the\n   children\
    \ population when they start a poll and to maintain it\n   constant across multiple\
    \ polls (with the same POLL_SQN but different\n   POLL_ROUND).  This works by\
    \ allowing PGM children to respond to a\n   poll only if its POLL_ROUND is zero\
    \ or if they have previously\n   received a poll with the same POLL_SQN and POLL_ROUND\
    \ equal to zero.\n   In addition to this PGM children MUST observe a random back-off\
    \ in\n   replying to a poll.  This spreads out the replies in time and allows\n\
    \   a PGM parent to abort the poll if too many replies are being\n   received.\
    \  To abort an ongoing poll a PGM parent MUST initiate\n   another poll with different\
    \ POLL_SQN.  PGM children that receive a\n   POLL MUST cancel any pending reply\
    \ for POLLs with POLL_SQN different\n   from the one of the last POLL received.\n\
    \   For a given poll with probability of replying P, a PGM parent\n   estimates\
    \ the number of children as M / P, where M is the number of\n   responses received.\
    \  PGM parents SHOULD keep polling periodically and\n   use some average of the\
    \ result of recent polls as their estimate for\n   the number of children.\n"
- title: 14.3.2.  Specific Polls
  contents:
  - "14.3.2.  Specific Polls\n   Specific polls provide a way to search for PGM children\
    \ that comply\n   to specific requisites.  As an example specific poll could be\
    \ used to\n   search for down-stream DLRs.  A specific poll is characterized by\
    \ a\n   POLL_S_TYPE different from PGM_POLL_GENERAL.  PGM children decide\n  \
    \ whether to reply to a specific poll or not based on the POLL_S_TYPE,\n   on\
    \ the random condition and on options possibly present in the POLL.\n   The way\
    \ options should be interpreted is defined by POLL_S_TYPE.  The\n   random condition\
    \ MUST be interpreted as an additional condition to be\n   satisfied.  To disable\
    \ the random condition PGM parents MUST specify\n   a probability of replying\
    \ P equal to 1.\n   PGM children MUST ignore a POLL packet if they do not understand\n\
    \   POLL_S_TYPE.  Some specific POLL_S_TYPE may also require that the\n   children\
    \ ignore a POLL if they do not fully understand all the PGM\n   options present\
    \ in the packet.\n"
- title: 14.4.  Procedures - PGM Parents (Sources or Network Elements)
  contents:
  - "14.4.  Procedures - PGM Parents (Sources or Network Elements)\n   A PGM parent\
    \ (source or network element), that wants to poll the\n   first PGM-hop children\
    \ connected to one of its outgoing interfaces\n   MUST send a POLL packet on that\
    \ interface with:\n   POLL_SQN       equal to POLL_SQN of the last POLL sent incremented\
    \ by\n                  one.  If poll rounds are used, this must be equal to\n\
    \                  POLL_SQN of the last group of rounds incremented by\n     \
    \             one.\n   POLL_ROUND     The round of the poll.  If the poll has\
    \ a single\n                  round, this must be zero.  If the poll has multiple\n\
    \                  rounds, this must be one plus the last POLL_ROUND for\n   \
    \               the same POLL_SQN, or zero if this is the first round\n      \
    \            within this POLL_SQN.\n   POLL_S_TYPE    the type of the poll.  For\
    \ general poll use\n                  PGM_POLL_GENERAL\n   POLL_PATH      set\
    \ to the NLA of the outgoing interface\n   POLL_BO_IVL    set to the wanted reply\
    \ back-off interval.  As far as\n                  the choice of this is concerned,\
    \ using NAK_BO_IVL is\n                  usually a conservative option, however\
    \ a smaller value\n                  MAY be used, if the number of expected replies\
    \ can be\n                  determined with a good confidence or if a\n      \
    \            conservatively low probability of reply (P) is being\n          \
    \        used (see POLL_MASK next).  When the number of\n                  expected\
    \ replies is unknown, a large POLL_BO_IVL\n                  SHOULD be used, so\
    \ that the poll can be effectively\n                  aborted if the number of\
    \ replies being received is too\n                  large.\n   POLL_RAND      MUST\
    \ be a random string re-computed each time a new\n                  poll is sent\
    \ on a given interface\n   POLL_MASK      determines the probability of replying,\
    \ P,  according\n                  to the relationship P = 1 / ( 2 ^ B ), where\
    \ B is the\n                  number of bits set in POLL_MASK [15].  If this is\
    \ a\n                  deterministic poll, B MUST be 0, i.e. POLL_MASK MUST\n\
    \                  be a all-zeroes bit-mask.\n      Nota Bene: POLLs transmitted\
    \ by network elements MUST bear the\n      ODATA source's network-header source\
    \ address, not the network\n      element's NLA.  POLLs MUST also be transmitted\
    \ with the IP\n      Router Alert Option [6], to be allow PGM network element\
    \ to\n      intercept them.\n   A PGM parent that has started a poll by sending\
    \ a POLL packet SHOULD\n   wait at least POLL_BO_IVL before starting another poll.\
    \  During this\n   interval it SHOULD collect all the valid response (the one\
    \ with\n   POLR_SQN and POLR_ROUND matching with the outstanding poll) and\n \
    \  process them at the end of the collection interval.\n   A PGM parent SHOULD\
    \ observe the rules mentioned in the description of\n   general procedures, to\
    \ prevent implosion of response.  These rules\n   should in general be observed\
    \ both for generic polls and specific\n   polls.  The latter however can be performed\
    \ using deterministic poll\n   (with no implosion prevention) if the expected\
    \ number of replies is\n   known to be small.  A PGM parent that issue a generic\
    \ poll with the\n   intent of estimating the children population size SHOULD use\
    \ poll\n   rounds to \"freeze\" the children that are involved in the measure\n\
    \   process.  This allows the sender to \"open the door wider\" across\n   subsequent\
    \ rounds (by increasing the probability of response),\n   without fear of being\
    \ flooded by late joiners.  Note the use of\n   rounds has the drawback of introducing\
    \ additional delay in the\n   estimate of the population size, as the estimate\
    \ obtained at the end\n   of a round-group refers to the condition present at\
    \ the time of the\n   first round.\n   A PGM parent that has started a poll SHOULD\
    \ monitor the number of\n   replies during the collection phase.  If this become\
    \ too large, the\n   PGM parent SHOULD abort the poll by immediately starting\
    \ a new poll\n   (different POLL_SQN) and specifying a very low probability of\n\
    \   replying.\n   When polling is being used to estimate the receiver population\
    \ for\n   the purpose of calculating NAK_BO_IVL, OPT_NAK_BO_IVL (see 16.4.1\n\
    \   below) MUST be appended to SPMs, MAY be appended to NCFs and POLLs,\n   and\
    \ in all cases MUST have NAK_BO_IVL_SQN set to POLL_SQN of the most\n   recent\
    \ complete round of polls, and MUST bear that round's\n   corresponding derived\
    \ value of NAK_BAK_IVL.  In this way,\n   OPT_NAK_BO_IVL provides a current value\
    \ for NAK_BO_IVL at the same\n   time as information is being gathered for the\
    \ calculation of a future\n   value of NAK_BO_IVL.\n"
- title: 14.5.  Procedures - PGM Children (Receivers or Network Elements)
  contents:
  - "14.5.  Procedures - PGM Children (Receivers or Network Elements)\n   PGM receivers\
    \ and network elements MUST compute a 32-bit random node\n   identifier (RAND_NODE_ID)\
    \ at startup time.  When a PGM child\n   (receiver or network element) receives\
    \ a POLL it MUST use its\n   RAND_NODE_ID to match POLL_RAND of incoming POLLs.\
    \  The match is\n   limited to the bits specified by POLL_MASK.  If the incoming\
    \ POLL\n   contain a POLL_MASK made of all zeroes, the match is successful\n \
    \  despite the content of POLL_RAND (deterministic reply).  If the match\n   fails,\
    \ then the receiver or network element MUST discard the POLL\n   without any further\
    \ action, otherwise it MUST check the fields\n   POLL_ROUND, POLL_S_TYPE and any\
    \ PGM option included in the POLL to\n   determine whether it SHOULD reply to\
    \ the poll.\n   If POLL_ROUND is non-zero and the PGM receiver has not received\
    \ a\n   previous poll with the same POLL_SQN and a zero POLL_ROUND, it MUST\n\
    \   discard the poll without further action.\n   If POLL_S_TYPE is equal to PGM_POLL_GENERAL,\
    \ the PGM child MUST\n   schedule a reply to the POLL despite the presence of\
    \ PGM options on\n   the POLL packet.\n   If POLL_S_TYPE is different from PGM_POLL_GENERAL,\
    \ the decision on\n   whether a reply should be scheduled depends on the actual\
    \ type and on\n   the options possibly present in the POLL.\n   If POLL_S_TYPE\
    \ is unknown to the recipient of the POLL, it MUST NOT\n   reply and ignore the\
    \ poll.  Currently the only POLL_S_TYPE defined\n   are PGM_POLL_GENERAL and PGM_POLL_DLR.\n\
    \   If a PGM receiver or network element has decided to reply to a POLL,\n   it\
    \ MUST schedule the transmission of a single POLR at a random time\n   in the\
    \ future.  The random delay is chosen in the interval [0,\n   POLL_BO_IVL].  POLL_BO_IVL\
    \ is the one contained in the POLL received.\n   When this timer expires, it MUST\
    \ send a POLR using POLL_PATH of the\n   received POLL as destination address.\
    \  POLR_SQN MUST be equal to\n   POLL_SQN and POLR_ROUND must be equal to POLL_ROUND.\
    \  The POLR MAY\n   contain PGM options according to the semantic of POLL_S_TYPE\
    \ or the\n   semantic of PGM options possibly present in the POLL.  If POLL_S_TYPE\n\
    \   is PGM_POLL_GENERAL no option is REQUIRED.\n   A PGM receiver or network element\
    \ MUST cancel any pending\n   transmission of POLRs if a new POLL is received\
    \ with POLL_SQN\n   different from POLR_SQN of the poll that scheduled POLRs.\n"
- title: 14.6.  Constant Definition
  contents:
  - "14.6.  Constant Definition\n   The POLL_S_TYPE values currently defined are:\n\
    \      PGM_POLL_GENERAL  0\n      PGM_POLL_DLR      1\n"
- title: 14.7.  Packet Formats
  contents:
  - "14.7.  Packet Formats\n   The packet formats described in this section are transport-layer\n\
    \   headers that MUST immediately follow the network-layer header in the\n   packet.\n\
    \   The descriptions of Data-Source Port, Data-Destination Port, Options,\n  \
    \ Checksum, Global Source ID (GSI), and TSDU Length are those provided\n   in\
    \ Section 8.\n"
- title: 14.7.1.  Poll Request
  contents:
  - "14.7.1.  Poll Request\n   POLL are sent by PGM parents (sources or network elements)\
    \ to\n   initiate a poll among their first PGM-hop children.\n   POLLs are sent\
    \ to the ODATA multicast group.  The network-header\n   source address of a POLL\
    \ is the ODATA source's NLA.  POLL MUST be\n   transmitted with the IP Router\
    \ Alert Option.\n    0                   1                   2               \
    \    3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \       Source Port           |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Type     |    Options    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Global Source ID                   ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...    Global Source ID       |           TSDU Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    POLL's Sequence Number                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         POLL's Round          |       POLL's Sub-type         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            NLA AFI            |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            Path NLA                     ...   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+\n\
    \   |                  POLL's  Back-off Interval                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Random String                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Matching Bit-Mask                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Option Extensions when present ...                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ ... -+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Source Port:\n      POLL_SPORT\n      Data-Source\
    \ Port, together with POLL_GSI forms POLL_TSI\n   Destination Port:\n      POLL_DPORT\n\
    \      Data-Destination Port\n   Type:\n      POLL_TYPE = 0x01\n   Global Source\
    \ ID:\n      POLL_GSI\n      Together with POLL_SPORT forms POLL_TSI\n   POLL's\
    \ Sequence Number\n      POLL_SQN\n      The sequence number assigned to the POLL\
    \ by the originator.\n   POLL's Round\n      POLL_ROUND\n      The round number\
    \ within the poll sequence number.\n   POLL's Sub-type\n      POLL_S_TYPE\n  \
    \    The sub-type of the poll request.\n   Path NLA:\n      POLL_PATH\n      The\
    \ NLA of the interface on the source or network element on which\n      this POLL\
    \ was forwarded.\n   POLL's Back-off Interval\n      POLL_BO_IVL\n      The back-off\
    \ interval used to compute a random back-off for the\n      reply, expressed in\
    \ microseconds.\n   Random String\n      POLL_RAND\n      A random string used\
    \ to implement the random condition in\n      replying.\n   Matching Bit-Mask\n\
    \      POLL_MASK\n      A  bit-mask used to determine the probability of random\
    \ replies.\n"
- title: 14.7.2.  Poll Response
  contents:
  - "14.7.2.  Poll Response\n   POLR are sent by PGM children (receivers or network\
    \ elements) to\n   reply to a POLL.\n   The network-header source address of a\
    \ POLR is the unicast NLA of the\n   entity that originates the POLR.  The network-header\
    \ destination\n   address of a POLR is initialized by the originator of the POLL\
    \ to the\n   unicast NLA of the upstream PGM element (source or network element)\n\
    \   known from the POLL that triggered the POLR.\n    0                   1  \
    \                 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Source Port           |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Type     |    Options    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Global Source ID                   ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...    Global Source ID       |           TSDU Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    POLR's Sequence Number                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         POLR's Round          |           reserved            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Option Extensions when present ...                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ ... -+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Source Port:\n      POLR_SPORT\n      Data-Destination\
    \ Port\n   Destination Port:\n      POLR_DPORT\n      Data-Source Port, together\
    \ with Global Source ID forms POLR_TSI\n   Type:\n      POLR_TYPE = 0x02\n   Global\
    \ Source ID:\n      POLR_GSI\n      Together with POLR_DPORT forms POLR_TSI\n\
    \   POLR's Sequence Number\n      POLR_SQN\n      The sequence number (POLL_SQN)\
    \ of the POLL packet for which this\n      is a reply.\n   POLR's Round\n    \
    \  POLR_ROUND\n      The round number (POLL_ROUND) of the POLL packet for which\
    \ this is\n      a reply.\n"
- title: 15.  Appendix E - Implosion Prevention
  contents:
  - '15.  Appendix E - Implosion Prevention

    '
- title: 15.1.  Introduction
  contents:
  - "15.1.  Introduction\n   These procedures are intended to prevent NAK implosion\
    \ and to limit\n   its extent in case of the loss of all or part of the suppressing\n\
    \   multicast distribution tree.  They also provide a means to adaptively\n  \
    \ tune the NAK back-off interval, NAK_BO_IVL.\n   The PGM virtual topology is\
    \ established and refreshed by SPMs.\n   Between one SPM and the next, PGM nodes\
    \ may have an out-of-date view\n   of the PGM topology due to multicast routing\
    \ changes, flapping, or a\n   link/router failure.  If any of the above happens\
    \ relative to a PGM\n   parent node, a potential NAK implosion problem arises\
    \ because the\n   parent node is unable to suppress the generation of duplicate\
    \ NAKs as\n   it cannot reach its children using NCFs.  The procedures described\n\
    \   below introduce an alternative way of performing suppression in this\n   case.\
    \  They also attempt to prevent implosion by adaptively tuning\n   NAK_BO_IVL.\n"
- title: 15.2.  Tuning NAK_BO_IVL
  contents:
  - "15.2.  Tuning NAK_BO_IVL\n   Sources and network elements continuously monitor\
    \ the number of\n   duplicated NAKs received and use this observation to tune\
    \ the NAK\n   back-off interval (NAK_BO_IVL) for the first PGM-hop receivers\n\
    \   connected to them.  Receivers learn the current value of NAK_BO_IVL\n   through\
    \ OPT_NAK_BO_IVL appended to NCFs or SPMs.\n"
- title: 15.2.1.  Procedures - Sources and Network Elements
  contents:
  - "15.2.1.  Procedures - Sources and Network Elements\n   For each TSI, sources\
    \ and network elements advertise the value of\n   NAK_BO_IVL that their first\
    \ PGM-hop receivers should use.  They\n   advertise a separate value on all the\
    \ outgoing interfaces for the TSI\n   and keep track of the last values advertised.\n\
    \   For each interface and TSI, sources and network elements count the\n   number\
    \ of NAKs received for a specific repair state (i.e., per\n   sequence number\
    \ per TSI) from the time the interface was first added\n   to the repair state\
    \ list until the time the repair state is\n   discarded.  Then they use this number\
    \ to tune the current value of\n   NAK_BO_IVL as follows:\n      Increase the\
    \ current value NAK_BO_IVL when the first duplicate NAK\n      is received for\
    \ a given SQN on a particular interface.\n   Decrease the value of NAK_BO_IVL\
    \ if no duplicate NAKs are received on\n   a particular interface for the last\
    \ NAK_PROBE_NUM measurements where\n   each measurement corresponds to the creation\
    \ of a new repair state.\n   An upper and lower limit are defined for the possible\
    \ value of\n   NAK_BO_IVL at any time.  These are NAK_BO_IVL_MAX and NAK_BO_IVL_MIN\n\
    \   respectively.  The initial value that should be used as a starting\n   point\
    \ to tune NAK_BO_IVL is NAK_BO_IVL_DEFAULT.  The policies\n   RECOMMENDED for\
    \ increasing and decreasing NAK_BO_IVL are multiplying\n   by two and dividing\
    \ by two respectively.\n   Sources and network elements advertise the current\
    \ value of\n   NAK_BO_IVL through the OPT_NAK_BO_IVL that they append to NCFs.\
    \  They\n   MAY also append OPT_NAK_BO_IVL to outgoing SPMs.\n   In order to avoid\
    \ forwarding the NAK_BO_IVL advertised by the parent,\n   network elements must\
    \ be able to recognize OPT_NAK_BO_IVL.  Network\n   elements that receive SPMs\
    \ containing OPT_NAK_BO_IVL MUST either\n   remove the option or over-write its\
    \ content (NAK_BO_IVL) with the\n   current value of NAK_BO_IVL for the outgoing\
    \ interface(s), before\n   forwarding the SPMs.\n   Sources MAY advertise the\
    \ value of NAK_BO_IVL_MAX and NAK_BO_IVL_MIN\n   to the session by appending a\
    \ OPT_NAK_BO_RNG to SPMs.\n"
- title: 15.2.2.  Procedures - Receivers
  contents:
  - "15.2.2.  Procedures - Receivers\n   Receivers learn the value of NAK_BO_IVL to\
    \ use through the option\n   OPT_NAK_BO_IVL, when this is present in NCFs or SPMs.\
    \  A value for\n   NAK_BO_IVL learned from OPT_NAK_BO_IVL MUST NOT be used by\
    \ a receiver\n   unless either NAK_BO_IVL_SQN is zero, or the receiver has seen\n\
    \   POLL_RND == 0 for POLL_SQN =< NAK_BO_IVL_SQN within half the sequence\n  \
    \ number space.  The initial value of NAK_BO_IVL is set to\n   NAK_BO_IVL_DEFAULT.\n\
    \   Receivers that receive an SPM containing OPT_NAK_BO_RNG MUST use its\n   content\
    \ to set the local values of NAK_BO_IVL_MAX and NAK_BO_IVL_MIN.\n"
- title: 15.2.3.  Adjusting NAK_BO_IVL in the absence of NAKs
  contents:
  - "15.2.3.  Adjusting NAK_BO_IVL in the absence of NAKs\n   Monitoring the number\
    \ of duplicate NAKs provides a means to track\n   indirectly the change in the\
    \ size of first PGM-hop receiver\n   population and adjust NAK_BO_IVL accordingly.\
    \  Note that the number\n   of duplicate NAKs for a given SQN is related to the\
    \ number of first\n   PGM-hop children that scheduled (or forwarded) a NAK and\
    \ not to the\n   absolute number of first PGM-hop children.  This mechanism, however,\n\
    \   does not work in the absence of packet loss, hence a large number of\n   duplicate\
    \ NAKs is possible after a period without NAKs, if many new\n   receivers have\
    \ joined the session in the meanwhile.  To address this\n   issue, PGM Sources\
    \ and network elements SHOULD periodically poll the\n   number of first PGM-hop\
    \ children using the \"general poll\" procedures\n   described in Appendix D.\
    \  If the result of the polls shows that the\n   population size has increased\
    \ significantly during a period without\n   NAKs, they SHOULD increase NAK_BO_IVL\
    \ as a safety measure.\n"
- title: 15.3.  Containing Implosion in the Presence of Network Failures
  contents:
  - '15.3.  Containing Implosion in the Presence of Network Failures

    '
- title: 15.3.1.  Detecting Network Failures
  contents:
  - "15.3.1.  Detecting Network Failures\n   In some cases PGM (parent) network elements\
    \ can promptly detect the\n   loss of all or part of the suppressing multicast\
    \ distribution tree\n   (due to network failures or route changes) by checking\
    \ their\n   multicast connectivity, when they receive NAKs.  In some other cases\n\
    \   this is not possible as the connectivity problem might occur at some\n   other\
    \ non-PGM node downstream or might take time to reflect in the\n   multicast routing\
    \ table.  To address these latter cases, PGM uses a\n   simple heuristic: a failure\
    \ is assumed for a TSI when the count of\n   duplicated NAKs received for a repair\
    \ state reaches the value\n   DUP_NAK_MAX in one of the interfaces.\n"
- title: 15.3.2.  Containing Implosion
  contents:
  - "15.3.2.  Containing Implosion\n   When a PGM source or network element detects\
    \ or assumes a failure for\n   which it looses multicast connectivity to down-stream\
    \ PGM agents\n   (either receivers or other network elements), it sends unicast\
    \ NCFs\n   to them in response to NAKs.  Downstream PGM network elements which\n\
    \   receive unicast NCFs and have multicast connectivity to the multicast\n  \
    \ session send special SPMs to prevent further NAKs until a regular SPM\n   sent\
    \ by the source refreshes the PGM tree.\n   Procedures - Sources and Network Elements\n\
    \   PGM sources or network elements which detect or assume a failure that\n  \
    \ prevents them from reaching down-stream PGM agents through multicast\n   NCFs\
    \ revert to confirming NAKs through unicast NCFs for a given TSI\n   on a given\
    \ interface.  If the PGM agent is the source itself, than it\n   MUST generate\
    \ an SPM for the TSI, in addition to sending the unicast\n   NCF.\n   Network\
    \ elements MUST keep using unicast NCFs until they receive a\n   regular SPM from\
    \ the source.\n   When a unicast NCF is sent for the reasons described above,\
    \ it MUST\n   contain the OPT_NBR_UNREACH option and the OPT_PATH_NLA option.\n\
    \   OPT_NBR_UNREACH indicates that the sender is unable to use multicast\n   to\
    \ reach downstream PGM agents.  OPT_PATH_NLA carries the network\n   layer address\
    \ of the NCF sender, namely the NLA of the interface\n   leading to the unreachable\
    \ subtree.\n   When a PGM network element receives an NCF containing the\n   OPT_NBR_UNREACH\
    \ option, it MUST ignore it if OPT_PATH_NLA specifies\n   an upstream neighbour\
    \ different from the one currently known to be\n   the upstream neighbor for the\
    \ TSI.  Assuming the network element\n   matches the OPT_PATH_NLA of the upstream\
    \ neighbour address, it MUST\n   stop forwarding NAKs for the TSI until it receives\
    \ a regular SPM for\n   the TSI.  In addition, it MUST also generate a special\
    \ SPM to prevent\n   downstream receivers from sending more NAKs.  This special\
    \ SPM MUST\n   contain the OPT_NBR_UNREACH option and SHOULD have a SPM_SQN equal\
    \ to\n   SPM_SQN of the last regular SPM forwarded.  The OPT_NBR_UNREACH\n   option\
    \ invalidates the windowing information in SPMs (SPM_TRAIL and\n   SPM_LEAD).\
    \  The PGM network element that adds the OPT_NBR_UNREACH\n   option SHOULD invalidate\
    \ the windowing information by setting\n   SPM_TRAIL to 0 and SPM_LEAD to 0x80000000.\n\
    \   PGM network elements which receive an SPM containing the\n   OPT_NBR_UNREACH\
    \ option and whose SPM_PATH matches the currently known\n   PGM parent, MUST forward\
    \ them in the normal way and MUST stop\n   forwarding NAKs for the TSI until they\
    \ receive a regular SPM for the\n   TSI.  If the SPM_PATH does not match the currently\
    \ known PGM parent,\n   the SPM containing the OPT_NBR_UNREACH option MUST be\
    \ ignored.\n   Procedures - Receivers\n   PGM receivers which receive either an\
    \ NCF or an SPM containing the\n   OPT_NBR_UNREACH option MUST stop sending NAKs\
    \ until a regular SPM is\n   received for the TSI.\n   On reception of a unicast\
    \ NCF containing the OPT_NBR_UNREACH option\n   receivers MUST generate a multicast\
    \ copy of the packet with TTL set\n   to one on the RPF interface for the data\
    \ source.  This will prevent\n   other receivers in the same subnet from generating\
    \ NAKs.\n   Receivers MUST ignore windowing information in SPMs which contain\
    \ the\n   OPT_NBR_UNREACH option.\n   Receivers MUST ignore NCFs containing the\
    \ OPT_NBR_UNREACH option if\n   the OPT_PATH_NLA specifies a neighbour different\
    \ than the one\n   currently know to be the PGM parent neighbour.  Similarly receivers\n\
    \   MUST ignore SPMs containing the OPT_NBR_UNREACH option if SPM_PATH\n   does\
    \ not match the current PGM parent.\n"
- title: 15.4.  Packet Formats
  contents:
  - '15.4.  Packet Formats

    '
- title: 15.4.1.  OPT_NAK_BO_IVL - Packet Extension Format
  contents:
  - "15.4.1.  OPT_NAK_BO_IVL - Packet Extension Format\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     NAK Back-Off Interval                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   NAK Back-Off Interval SQN                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x04\n   NAK Back-Off Interval\n      The value of NAK-generation\
    \ Back-Off Interval in microseconds.\n   NAK Back-Off Interval Sequence Number\n\
    \      The POLL_SQN to which this value of NAK_BO_IVL corresponds.  Zero\n   \
    \   is reserved and means NAK_BO_IVL is NOT being determined through\n      polling\
    \ (see Appendix D) and may be used immediately.  Otherwise,\n      NAK_BO_IVL\
    \ MUST NOT be used unless the receiver has also seen\n      POLL_ROUND = 0 for\
    \ POLL_SQN =< NAK_BO_IVL_SQN within half the\n      sequence number space.\n \
    \  OPT_NAK_BO_IVL MAY be appended to NCFs, SPMs, or POLLs.\n   OPT_NAK_BO_IVL\
    \ is network-significant.\n"
- title: 15.4.2.  OPT_NAK_BO_RNG - Packet Extension Format
  contents:
  - "15.4.2.  OPT_NAK_BO_RNG - Packet Extension Format\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Maximum  NAK Back-Off Interval                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Minimum  NAK Back-Off Interval                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x05\n   Maximum NAK Back-Off Interval\n      The maximum value\
    \ of NAK-generation Back-Off Interval in\n      microseconds.\n   Minimum NAK\
    \ Back-Off Interval\n      The minimum value of NAK-generation Back-Off Interval\
    \ in\n      microseconds.\n   OPT_NAK_BO_RNG MAY be appended to SPMs.\n   OPT_NAK_BO_RNG\
    \ is network-significant.\n"
- title: 15.4.3.  OPT_NBR_UNREACH - Packet Extension Format
  contents:
  - "15.4.3.  OPT_NBR_UNREACH - Packet Extension Format\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Option Type = 0x0B\n      When present in SPMs, it invalidates the windowing\
    \ information.\n   OPT_NBR_UNREACH MAY be appended to SPMs and NCFs.\n   OPT_NBR_UNREACH\
    \ is network-significant.\n"
- title: 15.4.4.  OPT_PATH_NLA - Packet Extension Format
  contents:
  - "15.4.4.  OPT_PATH_NLA - Packet Extension Format\n    0                   1  \
    \                 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| Option Type | Option Length |Reserved |F|OPX|U|             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            Path NLA                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Option Type = 0x0C\n   Path NLA\n      The NLA of the interface on the originating\
    \ PGM network element\n      that it uses to send multicast SPMs to the recipient\
    \ of the packet\n      containing this option.\n   OPT_PATH_NLA MAY be appended\
    \ to NCFs.\n   OPT_PATH_NLA is network-significant.\n"
- title: 16.  Appendix F - Transmit Window Example
  contents:
  - "16.  Appendix F - Transmit Window Example\n      Nota Bene: The concept of and\
    \ all references to the increment\n      window (TXW_INC) and the window increment\
    \ (TXW_ADV_SECS)\n      throughout this document are for illustrative purposes\
    \ only.  They\n      provide the shorthand with which to describe the concept\
    \ of\n      advancing the transmit window without also implying any particular\n\
    \      implementation or policy of advancement.\n   The size of the transmit window\
    \ in seconds is simply TXW_SECS.  The\n   size of the transmit window in bytes\
    \ (TXW_BYTES) is (TXW_MAX_RTE *\n   TXW_SECS).  The size of the transmit window\
    \ in sequence numbers\n   (TXW_SQNS) is (TXW_BYTES / bytes-per-packet).\n   The\
    \ fraction of the transmit window size (in seconds of data) by\n   which the transmit\
    \ window is advanced (TXW_ADV_SECS) is called the\n   window increment.  The trailing\
    \ (oldest) such fraction of the\n   transmit window itself is called the increment\
    \ window.\n   In terms of sequence numbers, the increment window is the range\
    \ of\n   sequence numbers that will be the first to be expired from the\n   transmit\
    \ window.  The trailing (or left) edge of the increment window\n   is just TXW_TRAIL,\
    \ the trailing (or left) edge of the transmit\n   window.  The leading (or right)\
    \ edge of the increment window\n   (TXW_INC) is defined as one less than the sequence\
    \ number of the\n   first data packet transmitted by the source TXW_ADV_SECS after\n\
    \   transmitting TXW_TRAIL.\n   A data packet is described as being \"in\" the\
    \ transmit or increment\n   window, respectively, if its sequence number is in\
    \ the range defined\n   by the transmit or increment window, respectively.\n \
    \  The transmit window is advanced across the increment window by the\n   source\
    \ when it increments TXW_TRAIL to TXW_INC.  When the transmit\n   window is advanced\
    \ across the increment window, the increment window\n   is emptied (i.e., TXW_TRAIL\
    \ is momentarily equal to TXW_INC), begins\n   to refill immediately as transmission\
    \ proceeds, is full again\n   TXW_ADV_SECS later (i.e., TXW_TRAIL is separated\
    \ from TXW_INC by\n   TXW_ADV_SECS of data), at which point the transmit window\
    \ is advanced\n   again, and so on.\n"
- title: 16.1.  Advancing across the Increment Window
  contents:
  - "16.1.  Advancing across the Increment Window\n   In anticipation of advancing\
    \ the transmit window, the source starts a\n   timer TXW_ADV_IVL_TMR which runs\
    \ for time period TXW_ADV_IVL.\n   TXW_ADV_IVL has a value in the range (0, TXW_ADV_SECS).\
    \  The value\n   MAY be configurable or MAY be determined statically by the strategy\n\
    \   used for advancing the transmit window.\n   When TXW_ADV_IVL_TMR is running,\
    \ a source MAY reset TXW_ADV_IVL_TMR\n   if NAKs are received for packets in the\
    \ increment window.  In\n   addition, a source MAY transmit RDATA in the increment\
    \ window with\n   priority over other data within the transmit window.\n   When\
    \ TXW_ADV_IVL_TMR expires, a source SHOULD advance the trailing\n   edge of the\
    \ transmit window from TXW_TRAIL to TXW_INC.\n   Once the transmit window is advanced\
    \ across the increment window,\n   SPM_TRAIL, OD_TRAIL and RD_TRAIL are set to\
    \ the new value of\n   TXW_TRAIL in all subsequent transmitted packets, until\
    \ the next\n   window advancement.\n   PGM does not constrain the strategies that\
    \ a source may use for\n   advancing the transmit window.  The source MAY implement\
    \ any scheme\n   or number of schemes.  Three suggested strategies are outlined\
    \ here.\n   Consider the following example:\n      Assuming a constant transmit\
    \ rate of 128kbps and a constant data\n      packet size of 1500 bytes, if a source\
    \ maintains the past 30\n      seconds of data for repair and increments its transmit\
    \ window in 5\n      second increments, then\n         TXW_MAX_RTE = 16kBps\n\
    \         TXW_ADV_SECS = 5 seconds,\n         TXW_SECS = 35 seconds,\n       \
    \  TXW_BYTES = 560kB,\n         TXW_SQNS = 383 (rounded up),\n      and the size\
    \ of the increment window in sequence numbers\n      (TXW_MAX_RTE * TXW_ADV_SECS\
    \ / 1500) = 54 (rounded down).\n   Continuing this example, the following is a\
    \ diagram of the transmit\n   window and the increment window therein in terms\
    \ of sequence numbers.\n       TXW_TRAIL                                     TXW_LEAD\n\
    \          |                                             |\n          |      \
    \                                       |\n       |--|--------------- Transmit\
    \ Window -------------|----|\n       v  |                                    \
    \         |    v\n          v                                             v\n\
    \   n-1 |  n  | n+1 | ... | n+53 | n+54 | ... | n+381 | n+382 | n+383\n      \
    \                      ^\n       ^                    |   ^\n       |--- Increment\
    \ Window|---|\n                            |\n                            |\n\
    \                         TXW_INC\n      So the values of the sequence numbers\
    \ defining these windows are:\n         TXW_TRAIL = n\n         TXW_INC = n+53\n\
    \         TXW_LEAD = n+382\n      Nota Bene: In this example the window sizes\
    \ in terms of sequence\n      numbers can be determined only because of the assumption\
    \ of a\n      constant data packet size of 1500 bytes.  When the data packet\n\
    \      sizes are variable, more or fewer sequence numbers MAY be consumed\n  \
    \    transmitting the same amount (TXW_BYTES) of data.\n   So, for a given transport\
    \ session identified by a TSI, a source\n   maintains:\n   TXW_MAX_RTE    a maximum\
    \ transmit rate in kBytes per second, the\n                  cumulative transmit\
    \ rate of some combination of SPMs,\n                  ODATA, and RDATA depending\
    \ on the transmit window\n                  advancement strategy\n   TXW_TRAIL\
    \      the sequence number defining the trailing edge of the\n               \
    \   transmit window, the sequence number of the oldest\n                  data\
    \ packet available for repair\n   TXW_LEAD       the sequence number defining\
    \ the leading edge of the\n                  transmit window, the sequence number\
    \ of the most\n                  recently transmitted ODATA packet\n   TXW_INC\
    \        the sequence number defining the leading edge of the\n              \
    \    increment window, the sequence number of the most\n                  recently\
    \ transmitted data packet amongst those that\n                  will expire upon\
    \ the next increment of the transmit\n                  window\n   PGM does not\
    \ constrain the strategies that a source may use for\n   advancing the transmit\
    \ window.  A source MAY implement any scheme or\n   number of schemes.  This is\
    \ possible because a PGM receiver must obey\n   the window provided by the source\
    \ in its packets.  Three strategies\n   are suggested within this document.\n\
    \   In the first, called \"Advance with Time\", the transmit window\n   maintains\
    \ the last TXW_SECS of data in real-time, regardless of\n   whether any data was\
    \ sent in that real time period or not.  The\n   actual number of bytes maintained\
    \ at any instant in time will vary\n   between 0 and TXW_BYTES, depending on traffic\
    \ during the last\n   TXW_SECS.  In this case, TXW_MAX_RTE is the cumulative transmit\
    \ rate\n   of SPMs and ODATA.\n   In the second, called \"Advance with Data\"\
    , the transmit window\n   maintains the last TXW_BYTES bytes of data for repair.\
    \  That is, it\n   maintains the theoretical maximum amount of data that could\
    \ be\n   transmitted in the time period TXW_SECS, regardless of when they were\n\
    \   transmitted.  In this case, TXW_MAX_RTE is the cumulative transmit\n   rate\
    \ of SPMs, ODATA, and RDATA.\n   The third strategy leaves control of the window\
    \ in the hands of the\n   application.  The API provided by a source implementation\
    \ for this,\n   could allow the application to control the window in terms of\
    \ APDUs\n   and to manually step the window.  This gives a form of Application\n\
    \   Level Framing (ALF).  In this case, TXW_MAX_RTE is the cumulative\n   transmit\
    \ rate of SPMs, ODATA, and RDATA.\n"
- title: 16.2.  Advancing with Data
  contents:
  - "16.2.  Advancing with Data\n   In the first strategy, TXW_MAX_RTE is calculated\
    \ from SPMs and both\n   ODATA and RDATA, and NAKs reset TXW_ADV_IVL_TMR.  In\
    \ this mode of\n   operation the transmit window maintains the last TXW_BYTES\
    \ bytes of\n   data for repair.  That is, it maintains the theoretical maximum\n\
    \   amount of data that could be transmitted in the time period TXW_SECS.\n  \
    \ This means that the following timers are not treated as real-time\n   timers,\
    \ instead they are \"data driven\".  That is, they expire when\n   the amount\
    \ of data that could be sent in the time period they define\n   is sent.  They\
    \ are the SPM ambient time interval, TXW_ADV_SECS,\n   TXW_SECS, TXW_ADV_IVL,\
    \ TXW_ADV_IVL_TMR and the join interval.  Note\n   that the SPM heartbeat timers\
    \ still run in real-time.\n   While TXW_ADV_IVL_TMR is running, a source uses\
    \ the receipt of a NAK\n   for ODATA within the increment window to reset timer\
    \ TXW_ADV_IVL_TMR\n   to TXW_ADV_IVL so that transmit window advancement is delayed\
    \ until\n   no NAKs for data in the increment window are seen for TXW_ADV_IVL\n\
    \   seconds.  If the transmit window should fill in the meantime, further\n  \
    \ transmissions would be suspended until the transmit window can be\n   advanced.\n\
    \   A source MUST advance the transmit window across the increment window\n  \
    \ only upon expiry of TXW_ADV_IVL_TMR.\n   This mode of operation is intended\
    \ for non-real-time, messaging\n   applications based on the receipt of complete\
    \ data at the expense of\n   delay.\n"
- title: 16.3.  Advancing with Time
  contents:
  - "16.3.  Advancing with Time\n   This strategy advances the transmit window in\
    \ real-time.  In this\n   mode of operation, TXW_MAX_RTE is calculated from SPMs\
    \ and ODATA only\n   to maintain a constant data throughput rate by consuming\
    \ extra\n   bandwidth for repairs.  TXW_ADV_IVL has the value 0 which advances\n\
    \   the transmit window without regard for whether NAKs for data in the\n   increment\
    \ window are still being received.\n   In this mode of operation, all timers are\
    \ treated as real-time\n   timers.\n   This mode of operation is intended for\
    \ real-time, streaming\n   applications based on the receipt of timely data at\
    \ the expense of\n   completeness.\n"
- title: 16.4.  Advancing under explicit application control
  contents:
  - "16.4.  Advancing under explicit application control\n   Some applications may\
    \ wish more explicit control of the transmit\n   window than that provided by\
    \ the advance with data / time strategies\n   above.  An implementation MAY provide\
    \ this mode of operation and\n   allow an application to explicitly control the\
    \ window in terms of\n   APDUs.\n"
- title: 17.  Appendix G - Applicability Statement
  contents:
  - "17.  Appendix G - Applicability Statement\n   As stated in the introduction,\
    \ PGM has been designed with a specific\n   class of applications in mind in recognition\
    \ of the fact that a\n   general solution for reliable multicast has proven elusive.\
    \  The\n   applicability of PGM is narrowed further, and perhaps more\n   significantly,\
    \ by the prototypical nature of at least four of the\n   transport elements the\
    \ protocol incorporates.  These are congestion\n   control, router assist, local\
    \ retransmission, and a programmatic API\n   for reliable multicast protocols\
    \ of this class.  At the same time as\n   standardization efforts address each\
    \ of these elements individually,\n   this publication is intended to foster experimentation\
    \ with these\n   elements in general, and to inform that standardization process\
    \ with\n   results from practise.\n   This section briefly describes some of the\
    \ experimental aspects of\n   PGM and makes non-normative references to some examples\
    \ of current\n   practise based upon them.\n   At least 3 different approaches\
    \ to congestion control can be explored\n   with PGM: a receiver-feedback based\
    \ approach, a router-assist based\n   approach, and layer-coding based approach.\
    \  The first is supported by\n   the negative acknowledgement mechanism in PGM\
    \ augmented by an\n   application-layer acknowledgement mechanism.  The second\
    \ is supported\n   by the router exception processing mechanism in PGM.  The third\
    \ is\n   supported by the FEC mechanisms in PGM.  An example of a receiver-\n\
    \   feedback based approach is provided in [16], and a proposal for a\n   router-assist\
    \ based approach was proposed in [17].  Open issues for\n   the researchers include\
    \ how do each of these approaches behave in the\n   presence of multiple competing\
    \ sessions of the same discipline or of\n   different disciplines, TCP most notably;\
    \ how do each of them behave\n   over a particular range of topologies, and over\
    \ a particular range of\n   loads; and how do each of them scale as a function\
    \ of the size of the\n   receiver population.\n   Router assist has applications\
    \ not just to implosion control and\n   retransmit constraint as described in\
    \ this specification, but also to\n   congestion control as described above, and\
    \ more generally to any\n   feature which may be enhanced by access to per-network-element\
    \ state\n   and processing.  The full range of these features is as yet\n   unexplored,\
    \ but a general mechanism for providing router assist in a\n   transport-protocol\
    \ independent way (GRA) is a topic of active\n   research [18].  That effort has\
    \ been primarily informed by the router\n   assist component of PGM, and implementation\
    \ and deployment experience\n   with PGM will continue to be fed back into the\
    \ specification and\n   eventual standardization of GRA.  Open questions facing\
    \ the\n   researchers ([19], [20], [21]) include how router-based state scales\n\
    \   relative to the feature benefit obtained, how system-wide factors\n   (such\
    \ as throughput and retransmit latency) vary relative to the\n   scale and topology\
    \ of deployed router assistance, and how incremental\n   deployment considerations\
    \ affect the tractability of router-assist\n   based features.  Router assist\
    \ may have additional implications in\n   the area of congestion control to the\
    \ extent that it may be applied\n   in multi-group layered coding schemes to increase\
    \ the granularity and\n   reduce the latency of receiver based congestion control.\n\
    \   GRA itself explicitly incorporates elements of active networking, and\n  \
    \ to the extent that the router assist component of PGM is reflected in\n   GRA,\
    \ experimentation with the narrowly defined network-element\n   functionality\
    \ of PGM will provide some of the first real world\n   experience with this promising\
    \ if controversial technology.\n   Local retransmission is not a new idea in general\
    \ in reliable\n   multicast, but the specific approach taken in PGM of locating\
    \ re-\n   transmitters on the distribution tree for the session, diverting\n \
    \  repair requests from network elements to the re-transmitters, and\n   then\
    \ propagating repairs downward from the repair point on the\n   distribution tree\
    \ raises interesting questions concerning where to\n   locate re-transmitters\
    \ in a given topology, and how network elements\n   locate those re-transmitters\
    \ and evaluate their efficiency relative\n   to other available sources of retransmissions,\
    \ most notably the\n   source itself.  This particular aspect of PGM, while fully\
    \ specified,\n   has only been implemented on the network element side, and awaits\
    \ a\n   host-side implementation before questions like these can be\n   addressed.\n\
    \   PGM presents the opportunity to develop a programming API for\n   reliable\
    \ multicast applications that reflects both those\n   applications' service requirements\
    \ as well as the services provided\n   by PGM in support of those applications\
    \ that may usefully be made\n   visible above the transport interface.  At least\
    \ a couple of host-\n   side implementations of PGM and a concomitant API have\
    \ been developed\n   for research purposes ([22], [23]), and are available as\
    \ open source\n   explicitly for the kind of experimentation described in this\
    \ section.\n   Perhaps the broadest experiment that PGM can enable in a community\
    \ of\n   researchers using a reasonable scale experimental transport protocol\n\
    \   is simply in the definition, implementation, and deployment of IP\n   multicast\
    \ applications for which the reliability provided by PGM is a\n   significant\
    \ enabler.  Experience with such applications will not just\n   illuminate the\
    \ value of reliable multicast, but will also provoke\n   practical examination\
    \ of and responses to the attendant policy issues\n   (such as peering, billing,\
    \ access control, firewalls, NATs, etc.),\n   and, if successful, will ultimately\
    \ encourage more wide spread\n   deployment of IP multicast itself.\n"
- title: 18.  Abbreviations
  contents:
  - "18.  Abbreviations\n   ACK     Acknowledgment\n   AFI     Address Family Indicator\n\
    \   ALF     Application Level Framing\n   APDU    Application Protocol Data Unit\n\
    \   ARQ     Automatic Repeat reQuest\n   DLR     Designated Local Repairer\n \
    \  GSI     Globally Unique Source Identifier\n   FEC     Forward Error Correction\n\
    \   MD5     Message-Digest Algorithm\n   MTU     Maximum Transmission Unit\n \
    \  NAK     Negative Acknowledgment\n   NCF     NAK Confirmation\n   NLA     Network\
    \ Layer Address\n   NNAK    Null Negative Acknowledgment\n   ODATA   Original\
    \ Data\n   POLL    Poll Request\n   POLR    Poll Response\n   RDATA   Repair Data\n\
    \   RSN     Receive State Notification\n   SPM     Source Path Message\n   SPMR\
    \    SPM Request\n   TG      Transmission Group\n   TGSIZE  Transmission Group\
    \ Size\n   TPDU    Transport Protocol Data Unit\n   TSDU    Transport Service\
    \ Data Unit\n   TSI     Transport Session Identifier\n   TSN     Transmit State\
    \ Notification\n"
- title: 19.  Acknowledgements
  contents:
  - "19.  Acknowledgements\n   The design and specification of PGM has been substantially\
    \ influenced\n   by reviews and revisions provided by several people who took\
    \ the time\n   to read and critique this document.  These include, in alphabetical\n\
    \   order:\n   Bob Albrightson\n   Joel Bion\n   Mark Bowles\n   Steve Deering\n\
    \   Tugrul Firatli\n   Dan Harkins\n   Dima Khoury\n   Gerard Newman\n   Dave\
    \ Oran\n   Denny Page\n   Ken Pillay\n   Chetan Rai\n   Yakov Rekhter\n   Dave\
    \ Rossetti\n   Paul Stirpe\n   Brian Whetten\n   Kyle York\n"
- title: 20.  References
  contents:
  - "20.  References\n   [1]   B. Whetten, T. Montgomery, S. Kaplan, \"A High Performance\n\
    \         Totally Ordered Multicast Protocol\", in \"Theory and Practice in\n\
    \         Distributed Systems\", Springer Verlag LCNS938, 1994.\n   [2]   S. Floyd,\
    \ V. Jacobson, C. Liu, S. McCanne, L. Zhang, \"A\n         Reliable Multicast\
    \ Framework for Light-weight Sessions and\n         Application Level Framing\"\
    , ACM Transactions on Networking,\n         November 1996.\n   [3]   J. C. Lin,\
    \ S. Paul, \"RMTP: A Reliable Multicast Transport\n         Protocol\", ACM SIGCOMM\
    \ August 1996.\n   [4]   Miller, K., Robertson, K., Tweedly, A. and M. White,\
    \ \"Multicast\n         File Transfer Protocol (MFTP) Specification\", Work In\
    \ Progress.\n   [5]   Deering, S., \"Host Extensions for IP Multicasting\", STD\
    \ 5, RFC\n         1112, August 1989.\n   [6]   Katz, D., \"IP Router Alert Option\"\
    , RFC 2113, February 1997.\n   [7]   C. Partridge, \"Gigabit Networking\", Addison\
    \ Wesley 1994.\n   [8]   H. W. Holbrook, S. K. Singhal, D. R. Cheriton, \"Log-Based\n\
    \         Receiver-Reliable Multicast for Distributed Interactive\n         Simulation\"\
    , ACM SIGCOMM 1995.\n   [9]   Rivest, R., \"The MD5 Message-Digest Algorithm\"\
    , RFC 1321, April\n         1992.\n   [10]  Reynolds, J. and J. Postel, \"Assigned\
    \ Numbers\", STD 2, RFC\n         1700, October 1994.\n   [11]  J. Nonnenmacher,\
    \ E. Biersack, D. Towsley, \"Parity-Based Loss\n         Recovery for Reliable\
    \ Multicast Transmission\", ACM SIGCOMM\n         September 1997.\n   [12]  L.\
    \ Rizzo, \"Effective Erasure Codes for Reliable Computer\n         Communication\
    \ Protocols\", Computer Communication Review, April\n         1997.\n   [13] \
    \ V. Jacobson, \"Congestion Avoidance and Control\", ACM SIGCOMM\n         August\
    \ 1988.\n   [14]  Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n\
    \         Levels\", BCP, 14, RFC 2119, March 1997.\n   [15]  J. Bolot, T. Turletti,\
    \ I. Wakeman, \"Scalable Feedback Control\n         for Multicast Video Distribution\
    \ in the Internet\", Proc.\n         ACM/Sigcomm 94, pp.  58-67.\n   [16]  L.\
    \ Rizzo, \"pgmcc: A TCP-friendly Single-Rate Multicast\n         Congestion Control\
    \ Scheme\", Proc. of ACM SIGCOMM August 2000.\n   [17]  M. Luby, L. Vicisano,\
    \ T. Speakman. \"Heterogeneous multicast\n         congestion control based on\
    \ router packet filtering\", RMT\n         working group, June 1999, Pisa, Italy.\n\
    \   [18]  Cain, B., Speakman, T. and D. Towsley, \"Generic Router Assist\n   \
    \      (GRA) Building Block, Motivation and Architecture\", Work In\n        \
    \ Progress.\n   [19]  C. Papadopoulos, and E. Laliotis,\"Incremental Deployment\
    \ of a\n         Router-assisted Reliable Multicast Scheme,\", Proc. of Networked\n\
    \         Group Communications (NGC2000), Stanford University, Palo Alto,\n  \
    \       CA. November 2000.\n   [20]  C. Papadopoulos, \"RAIMS: an Architecture\
    \ for Router-Assisted\n         Internet Multicast Services.\" Presented at ETH,\
    \ Zurich,\n         Switzerland, October 23 2000.\n   [21]  J. Chesterfield, A.\
    \ Diana, A. Greenhalgh, M. Lad, and M. Lim,\n         \"A BSD Router Implementation\
    \ of PGM\",\n         http://www.cs.ucl.ac.uk/external/m.lad/rpgm/\n   [22]  L.\
    \ Rizzo, \"A PGM Host Implementation for FreeBSD\",\n         http://www.iet.unipi.it/~luigi/pgm.html\n\
    \   [23]  M. Psaltaki, R. Araujo, G. Aldabbagh, P. Kouniakis, and A.\n       \
    \  Giannopoulos, \"Pragmatic General Multicast (PGM) host\n         implementation\
    \ for FreeBSD.\",\n         http://www.cs.ucl.ac.uk/research/darpa/pgm/PGM_FINAL.html\n"
- title: 21.  Authors' Addresses
  contents:
  - "21.  Authors' Addresses\n   Tony Speakman\n   EMail: speakman@cisco.com\n   Dino\
    \ Farinacci\n   Procket Networks\n   3850 North First Street\n   San Jose, CA\
    \ 95134\n   USA\n   EMail: dino@procket.com\n   Steven Lin\n   Juniper Networks\n\
    \   1194 N. Mathilda Ave.\n   Sunnyvale, CA 94086\n   USA\n   EMail: steven@juniper.net\n\
    \   Alex Tweedly\n   EMail: agt@cisco.com\n   Nidhi Bhaskar\n   EMail: nbhaskar@cisco.com\n\
    \   Richard Edmonstone\n   EMail: redmonst@cisco.com\n   Rajitha Sumanasekera\n\
    \   EMail: rajitha@cisco.com\n   Lorenzo Vicisano\n   Cisco Systems, Inc.\n  \
    \ 170 West Tasman Drive,\n   San Jose, CA 95134\n   USA\n   EMail: lorenzo@cisco.com\n\
    \   Jon Crowcroft\n   Department of Computer Science\n   University College London\n\
    \   Gower Street\n   London WC1E 6BT\n   UK\n   EMail: j.crowcroft@cs.ucl.ac.uk\n\
    \   Jim Gemmell\n   Microsoft Bay Area Research Center\n   301 Howard Street,\
    \ #830\n   San Francisco, CA 94105\n   USA\n   EMail: jgemmell@microsoft.com\n\
    \   Dan Leshchiner\n   Tibco Software\n   3165 Porter Dr.\n   Palo Alto, CA 94304\n\
    \   USA\n   EMail: dleshc@tibco.com\n   Michael Luby\n   Digital Fountain, Inc.\n\
    \   39141 Civic Center Drive\n   Fremont CA  94538\n   USA\n   EMail: luby@digitalfountain.com\n\
    \   Todd L. Montgomery\n   Talarian Corporation\n   124 Sherman Ave.\n   Morgantown,\
    \ WV 26501\n   USA\n   EMail: todd@talarian.com\n   Luigi Rizzo\n   Dip. di Ing.\
    \ dell'Informazione\n   Universita` di Pisa\n   via Diotisalvi 2\n   56126 Pisa\n\
    \   Italy\n   EMail: luigi@iet.unipi.it\n"
- title: 22.  Full Copyright Statement
  contents:
  - "22.  Full Copyright Statement\n   Copyright (C) The Internet Society (2001).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
