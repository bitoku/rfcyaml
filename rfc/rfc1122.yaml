- contents:
  - '        Requirements for Internet Hosts -- Communication Layers

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This RFC is an official specification for the Internet
    community.  It\n   incorporates by reference, amends, corrects, and supplements
    the\n   primary protocol standards documents relating to hosts.  Distribution\n
    \  of this document is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Summary\n   This is one RFC of a pair that defines and discusses the requirements\n
    \  for Internet host software.  This RFC covers the communications\n   protocol
    layers: link layer, IP layer, and transport layer; its\n   companion RFC-1123
    covers the application and support protocols.\n                           Table
    of Contents\n   1.  INTRODUCTION ...............................................
    \   5\n      1.1  The Internet Architecture ..............................    6\n
    \        1.1.1  Internet Hosts ....................................    6\n         1.1.2
    \ Architectural Assumptions .........................    7\n         1.1.3  Internet
    Protocol Suite ...........................    8\n         1.1.4  Embedded Gateway
    Code .............................   10\n      1.2  General Considerations .................................
    \  12\n         1.2.1  Continuing Internet Evolution .....................   12\n
    \        1.2.2  Robustness Principle ..............................   12\n         1.2.3
    \ Error Logging .....................................   13\n         1.2.4  Configuration
    .....................................   14\n      1.3  Reading this Document ..................................
    \  15\n         1.3.1  Organization ......................................   15\n
    \        1.3.2  Requirements ......................................   16\n         1.3.3
    \ Terminology .......................................   17\n      1.4  Acknowledgments
    ........................................   20\n   2. LINK LAYER ..................................................
    \  21\n      2.1  INTRODUCTION ...........................................   21\n"
  title: Summary
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n      2.2
    \ PROTOCOL WALK-THROUGH ..................................   21\n      2.3  SPECIFIC
    ISSUES ........................................   21\n         2.3.1  Trailer
    Protocol Negotiation ......................   21\n         2.3.2  Address Resolution
    Protocol -- ARP ................   22\n            2.3.2.1  ARP Cache Validation
    .........................   22\n            2.3.2.2  ARP Packet Queue .............................
    \  24\n         2.3.3  Ethernet and IEEE 802 Encapsulation ...............   24\n
    \     2.4  LINK/INTERNET LAYER INTERFACE ..........................   25\n      2.5
    \ LINK LAYER REQUIREMENTS SUMMARY ........................   26\n   3. INTERNET
    LAYER PROTOCOLS ....................................   27\n      3.1 INTRODUCTION
    ............................................   27\n      3.2  PROTOCOL WALK-THROUGH
    ..................................   29\n         3.2.1 Internet Protocol -- IP
    ............................   29\n            3.2.1.1  Version Number ...............................
    \  29\n            3.2.1.2  Checksum .....................................   29\n
    \           3.2.1.3  Addressing ...................................   29\n            3.2.1.4
    \ Fragmentation and Reassembly .................   32\n            3.2.1.5  Identification
    ...............................   32\n            3.2.1.6  Type-of-Service ..............................
    \  33\n            3.2.1.7  Time-to-Live .................................   34\n
    \           3.2.1.8  Options ......................................   35\n         3.2.2
    Internet Control Message Protocol -- ICMP ..........   38\n            3.2.2.1
    \ Destination Unreachable ......................   39\n            3.2.2.2  Redirect
    .....................................   40\n            3.2.2.3  Source Quench
    ................................   41\n            3.2.2.4  Time Exceeded ................................
    \  41\n            3.2.2.5  Parameter Problem ............................   42\n
    \           3.2.2.6  Echo Request/Reply ...........................   42\n            3.2.2.7
    \ Information Request/Reply ....................   43\n            3.2.2.8  Timestamp
    and Timestamp Reply ................   43\n            3.2.2.9  Address Mask Request/Reply
    ...................   45\n         3.2.3  Internet Group Management Protocol IGMP
    ...........   47\n      3.3  SPECIFIC ISSUES ........................................
    \  47\n         3.3.1  Routing Outbound Datagrams ........................   47\n
    \           3.3.1.1  Local/Remote Decision ........................   47\n            3.3.1.2
    \ Gateway Selection ............................   48\n            3.3.1.3  Route
    Cache ..................................   49\n            3.3.1.4  Dead Gateway
    Detection .......................   51\n            3.3.1.5  New Gateway Selection
    ........................   55\n            3.3.1.6  Initialization ...............................
    \  56\n         3.3.2  Reassembly ........................................   56\n
    \        3.3.3  Fragmentation .....................................   58\n         3.3.4
    \ Local Multihoming .................................   60\n            3.3.4.1
    \ Introduction .................................   60\n            3.3.4.2  Multihoming
    Requirements .....................   61\n            3.3.4.3  Choosing a Source
    Address ....................   64\n         3.3.5  Source Route Forwarding ...........................
    \  65\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         3.3.6
    \ Broadcasts ........................................   66\n         3.3.7  IP
    Multicasting ...................................   67\n         3.3.8  Error Reporting
    ...................................   69\n      3.4  INTERNET/TRANSPORT LAYER
    INTERFACE .....................   69\n      3.5  INTERNET LAYER REQUIREMENTS SUMMARY
    ....................   72\n   4. TRANSPORT PROTOCOLS .........................................
    \  77\n      4.1  USER DATAGRAM PROTOCOL -- UDP ..........................   77\n
    \        4.1.1  INTRODUCTION ......................................   77\n         4.1.2
    \ PROTOCOL WALK-THROUGH .............................   77\n         4.1.3  SPECIFIC
    ISSUES ...................................   77\n            4.1.3.1  Ports ........................................
    \  77\n            4.1.3.2  IP Options ...................................   77\n
    \           4.1.3.3  ICMP Messages ................................   78\n            4.1.3.4
    \ UDP Checksums ................................   78\n            4.1.3.5  UDP
    Multihoming ..............................   79\n            4.1.3.6  Invalid
    Addresses ............................   79\n         4.1.4  UDP/APPLICATION LAYER
    INTERFACE ...................   79\n         4.1.5  UDP REQUIREMENTS SUMMARY ..........................
    \  80\n      4.2  TRANSMISSION CONTROL PROTOCOL -- TCP ...................   82\n
    \        4.2.1  INTRODUCTION ......................................   82\n         4.2.2
    \ PROTOCOL WALK-THROUGH .............................   82\n            4.2.2.1
    \ Well-Known Ports .............................   82\n            4.2.2.2  Use
    of Push ..................................   82\n            4.2.2.3  Window Size
    ..................................   83\n            4.2.2.4  Urgent Pointer ...............................
    \  84\n            4.2.2.5  TCP Options ..................................   85\n
    \           4.2.2.6  Maximum Segment Size Option ..................   85\n            4.2.2.7
    \ TCP Checksum .................................   86\n            4.2.2.8  TCP
    Connection State Diagram .................   86\n            4.2.2.9  Initial
    Sequence Number Selection ............   87\n            4.2.2.10  Simultaneous
    Open Attempts ..................   87\n            4.2.2.11  Recovery from Old
    Duplicate SYN .............   87\n            4.2.2.12  RST Segment .................................
    \  87\n            4.2.2.13  Closing a Connection ........................   87\n
    \           4.2.2.14  Data Communication ..........................   89\n            4.2.2.15
    \ Retransmission Timeout ......................   90\n            4.2.2.16  Managing
    the Window .........................   91\n            4.2.2.17  Probing Zero
    Windows ........................   92\n            4.2.2.18  Passive OPEN Calls
    ..........................   92\n            4.2.2.19  Time to Live ................................
    \  93\n            4.2.2.20  Event Processing ............................   93\n
    \           4.2.2.21  Acknowledging Queued Segments ...............   94\n         4.2.3
    \ SPECIFIC ISSUES ...................................   95\n            4.2.3.1
    \ Retransmission Timeout Calculation ...........   95\n            4.2.3.2  When
    to Send an ACK Segment ..................   96\n            4.2.3.3  When to Send
    a Window Update .................   97\n            4.2.3.4  When to Send Data
    ............................   98\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n            4.2.3.5
    \ TCP Connection Failures ......................  100\n            4.2.3.6  TCP
    Keep-Alives ..............................  101\n            4.2.3.7  TCP Multihoming
    ..............................  103\n            4.2.3.8  IP Options ...................................
    \ 103\n            4.2.3.9  ICMP Messages ................................  103\n
    \           4.2.3.10  Remote Address Validation ...................  104\n            4.2.3.11
    \ TCP Traffic Patterns ........................  104\n            4.2.3.12  Efficiency
    ..................................  105\n         4.2.4  TCP/APPLICATION LAYER
    INTERFACE ...................  106\n            4.2.4.1  Asynchronous Reports
    .........................  106\n            4.2.4.2  Type-of-Service ..............................
    \ 107\n            4.2.4.3  Flush Call ...................................  107\n
    \           4.2.4.4  Multihoming ..................................  108\n         4.2.5
    \ TCP REQUIREMENT SUMMARY ...........................  108\n   5.  REFERENCES
    .................................................  112\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - 'RFC1122                       INTRODUCTION                  October 1989

    '
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "1.  INTRODUCTION\n   This document is one of a pair that defines and discusses
    the\n   requirements for host system implementations of the Internet protocol\n
    \  suite.  This RFC covers the communication protocol layers:  link\n   layer,
    IP layer, and transport layer.  Its companion RFC,\n   \"Requirements for Internet
    Hosts -- Application and Support\"\n   [INTRO:1], covers the application layer
    protocols.  This document\n   should also be read in conjunction with \"Requirements
    for Internet\n   Gateways\" [INTRO:2].\n   These documents are intended to provide
    guidance for vendors,\n   implementors, and users of Internet communication software.
    \ They\n   represent the consensus of a large body of technical experience and\n
    \  wisdom, contributed by the members of the Internet research and\n   vendor
    communities.\n   This RFC enumerates standard protocols that a host connected
    to the\n   Internet must use, and it incorporates by reference the RFCs and\n
    \  other documents describing the current specifications for these\n   protocols.
    \ It corrects errors in the referenced documents and adds\n   additional discussion
    and guidance for an implementor.\n   For each protocol, this document also contains
    an explicit set of\n   requirements, recommendations, and options.  The reader
    must\n   understand that the list of requirements in this document is\n   incomplete
    by itself; the complete set of requirements for an\n   Internet host is primarily
    defined in the standard protocol\n   specification documents, with the corrections,
    amendments, and\n   supplements contained in this RFC.\n   A good-faith implementation
    of the protocols that was produced after\n   careful reading of the RFC's and
    with some interaction with the\n   Internet technical community, and that followed
    good communications\n   software engineering practices, should differ from the
    requirements\n   of this document in only minor ways.  Thus, in many cases, the\n
    \  \"requirements\" in this RFC are already stated or implied in the\n   standard
    protocol documents, so that their inclusion here is, in a\n   sense, redundant.
    \ However, they were included because some past\n   implementation has made the
    wrong choice, causing problems of\n   interoperability, performance, and/or robustness.\n
    \  This document includes discussion and explanation of many of the\n   requirements
    and recommendations.  A simple list of requirements\n   would be dangerous, because:\n
    \  o    Some required features are more important than others, and some\n        features
    are optional.\n"
  title: 1.  INTRODUCTION
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n   o
    \   There may be valid reasons why particular vendor products that\n        are
    designed for restricted contexts might choose to use\n        different specifications.\n
    \  However, the specifications of this document must be followed to meet\n   the
    general goal of arbitrary host interoperation across the\n   diversity and complexity
    of the Internet system.  Although most\n   current implementations fail to meet
    these requirements in various\n   ways, some minor and some major, this specification
    is the ideal\n   towards which we need to move.\n   These requirements are based
    on the current level of Internet\n   architecture.  This document will be updated
    as required to provide\n   additional clarifications or to include additional
    information in\n   those areas in which specifications are still evolving.\n   This
    introductory section begins with a brief overview of the\n   Internet architecture
    as it relates to hosts, and then gives some\n   general advice to host software
    vendors.  Finally, there is some\n   guidance on reading the rest of the document
    and some terminology.\n   1.1  The Internet Architecture\n      General background
    and discussion on the Internet architecture and\n      supporting protocol suite
    can be found in the DDN Protocol\n      Handbook [INTRO:3]; for background see
    for example [INTRO:9],\n      [INTRO:10], and [INTRO:11].  Reference [INTRO:5]
    describes the\n      procedure for obtaining Internet protocol documents, while\n
    \     [INTRO:6] contains a list of the numbers assigned within Internet\n      protocols.\n
    \     1.1.1  Internet Hosts\n         A host computer, or simply \"host,\" is
    the ultimate consumer of\n         communication services.  A host generally executes
    application\n         programs on behalf of user(s), employing network and/or\n
    \        Internet communication services in support of this function.\n         An
    Internet host corresponds to the concept of an \"End-System\"\n         used in
    the OSI protocol suite [INTRO:13].\n         An Internet communication system
    consists of interconnected\n         packet networks supporting communication
    among host computers\n         using the Internet protocols.  The networks are
    interconnected\n         using packet-switching computers called \"gateways\"
    or \"IP\n         routers\" by the Internet community, and \"Intermediate Systems\"\n
    \        by the OSI world [INTRO:13].  The RFC \"Requirements for\n         Internet
    Gateways\" [INTRO:2] contains the official\n         specifications for Internet
    gateways.  That RFC together with\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         the
    present document and its companion [INTRO:1] define the\n         rules for the
    current realization of the Internet architecture.\n         Internet hosts span
    a wide range of size, speed, and function.\n         They range in size from small
    microprocessors through\n         workstations to mainframes and supercomputers.
    \ In function,\n         they range from single-purpose hosts (such as terminal
    servers)\n         to full-service hosts that support a variety of online network\n
    \        services, typically including remote login, file transfer, and\n         electronic
    mail.\n         A host is generally said to be multihomed if it has more than\n
    \        one interface to the same or to different networks.  See\n         Section
    1.1.3 on \"Terminology\".\n      1.1.2  Architectural Assumptions\n         The
    current Internet architecture is based on a set of\n         assumptions about
    the communication system.  The assumptions\n         most relevant to hosts are
    as follows:\n         (a)  The Internet is a network of networks.\n              Each
    host is directly connected to some particular\n              network(s); its connection
    to the Internet is only\n              conceptual.  Two hosts on the same network
    communicate\n              with each other using the same set of protocols that
    they\n              would use to communicate with hosts on distant networks.\n
    \        (b)  Gateways don't keep connection state information.\n              To
    improve robustness of the communication system,\n              gateways are designed
    to be stateless, forwarding each IP\n              datagram independently of other
    datagrams.  As a result,\n              redundant paths can be exploited to provide
    robust service\n              in spite of failures of intervening gateways and
    networks.\n              All state information required for end-to-end flow control\n
    \             and reliability is implemented in the hosts, in the\n              transport
    layer or in application programs.  All\n              connection control information
    is thus co-located with the\n              end points of the communication, so
    it will be lost only\n              if an end point fails.\n         (c)  Routing
    complexity should be in the gateways.\n              Routing is a complex and
    difficult problem, and ought to\n              be performed by the gateways, not
    the hosts.  An important\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n              objective
    is to insulate host software from changes caused\n              by the inevitable
    evolution of the Internet routing\n              architecture.\n         (d)  The
    System must tolerate wide network variation.\n              A basic objective
    of the Internet design is to tolerate a\n              wide range of network characteristics
    -- e.g., bandwidth,\n              delay, packet loss, packet reordering, and
    maximum packet\n              size.  Another objective is robustness against failure
    of\n              individual networks, gateways, and hosts, using whatever\n              bandwidth
    is still available.  Finally, the goal is full\n              \"open system interconnection\":
    an Internet host must be\n              able to interoperate robustly and effectively
    with any\n              other Internet host, across diverse Internet paths.\n
    \             Sometimes host implementors have designed for less\n              ambitious
    goals.  For example, the LAN environment is\n              typically much more
    benign than the Internet as a whole;\n              LANs have low packet loss
    and delay and do not reorder\n              packets.  Some vendors have fielded
    host implementations\n              that are adequate for a simple LAN environment,
    but work\n              badly for general interoperation.  The vendor justifies\n
    \             such a product as being economical within the restricted\n              LAN
    market.  However, isolated LANs seldom stay isolated\n              for long;
    they are soon gatewayed to each other, to\n              organization-wide internets,
    and eventually to the global\n              Internet system.  In the end, neither
    the customer nor the\n              vendor is served by incomplete or substandard
    Internet\n              host software.\n              The requirements spelled
    out in this document are designed\n              for a full-function Internet
    host, capable of full\n              interoperation over an arbitrary Internet
    path.\n      1.1.3  Internet Protocol Suite\n         To communicate using the
    Internet system, a host must implement\n         the layered set of protocols
    comprising the Internet protocol\n         suite.  A host typically must implement
    at least one protocol\n         from each layer.\n         The protocol layers
    used in the Internet architecture are as\n         follows [INTRO:4]:\n         o
    \ Application Layer\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n              The
    application layer is the top layer of the Internet\n              protocol suite.
    \ The Internet suite does not further\n              subdivide the application
    layer, although some of the\n              Internet application layer protocols
    do contain some\n              internal sub-layering.  The application layer of
    the\n              Internet suite essentially combines the functions of the\n
    \             top two layers -- Presentation and Application -- of the\n              OSI
    reference model.\n              We distinguish two categories of application layer\n
    \             protocols:  user protocols that provide service directly\n              to
    users, and support protocols that provide common system\n              functions.
    \ Requirements for user and support protocols\n              will be found in
    the companion RFC [INTRO:1].\n              The most common Internet user protocols
    are:\n                o  Telnet (remote login)\n                o  FTP    (file
    transfer)\n                o  SMTP   (electronic mail delivery)\n              There
    are a number of other standardized user protocols\n              [INTRO:4] and
    many private user protocols.\n              Support protocols, used for host name
    mapping, booting,\n              and management, include SNMP, BOOTP, RARP, and
    the Domain\n              Name System (DNS) protocols.\n         o  Transport
    Layer\n              The transport layer provides end-to-end communication\n              services
    for applications.  There are two primary\n              transport layer protocols
    at present:\n                o Transmission Control Protocol (TCP)\n                o
    User Datagram Protocol (UDP)\n              TCP is a reliable connection-oriented
    transport service\n              that provides end-to-end reliability, resequencing,
    and\n              flow control.  UDP is a connectionless (\"datagram\")\n              transport
    service.\n              Other transport protocols have been developed by the\n
    \             research community, and the set of official Internet\n              transport
    protocols may be expanded in the future.\n              Transport layer protocols
    are discussed in Chapter 4.\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         o
    \ Internet Layer\n              All Internet transport protocols use the Internet
    Protocol\n              (IP) to carry data from source host to destination host.\n
    \             IP is a connectionless or datagram internetwork service,\n              providing
    no end-to-end delivery guarantees. Thus, IP\n              datagrams may arrive
    at the destination host damaged,\n              duplicated, out of order, or not
    at all.  The layers above\n              IP are responsible for reliable delivery
    service when it\n              is required.  The IP protocol includes provision
    for\n              addressing, type-of-service specification, fragmentation\n
    \             and reassembly, and security information.\n              The datagram
    or connectionless nature of the IP protocol\n              is a fundamental and
    characteristic feature of the\n              Internet architecture.  Internet
    IP was the model for the\n              OSI Connectionless Network Protocol [INTRO:12].\n
    \             ICMP is a control protocol that is considered to be an\n              integral
    part of IP, although it is architecturally\n              layered upon IP, i.e.,
    it uses IP to carry its data end-\n              to-end just as a transport protocol
    like TCP or UDP does.\n              ICMP provides error reporting, congestion
    reporting, and\n              first-hop gateway redirection.\n              IGMP
    is an Internet layer protocol used for establishing\n              dynamic host
    groups for IP multicasting.\n              The Internet layer protocols IP, ICMP,
    and IGMP are\n              discussed in Chapter 3.\n         o  Link Layer\n
    \             To communicate on its directly-connected network, a host\n              must
    implement the communication protocol used to\n              interface to that
    network.  We call this a link layer or\n              media-access layer protocol.\n
    \             There is a wide variety of link layer protocols,\n              corresponding
    to the many different types of networks.\n              See Chapter 2.\n      1.1.4
    \ Embedded Gateway Code\n         Some Internet host software includes embedded
    gateway\n         functionality, so that these hosts can forward packets as a\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         gateway
    would, while still performing the application layer\n         functions of a host.\n
    \        Such dual-purpose systems must follow the Gateway Requirements\n         RFC
    [INTRO:2]  with respect to their gateway functions, and\n         must follow
    the present document with respect to their host\n         functions.  In all overlapping
    cases, the two specifications\n         should be in agreement.\n         There
    are varying opinions in the Internet community about\n         embedded gateway
    functionality.  The main arguments are as\n         follows:\n         o    Pro:
    in a local network environment where networking is\n              informal, or
    in isolated internets, it may be convenient\n              and economical to use
    existing host systems as gateways.\n              There is also an architectural
    argument for embedded\n              gateway functionality: multihoming is much
    more common\n              than originally foreseen, and multihoming forces a
    host to\n              make routing decisions as if it were a gateway.  If the\n
    \             multihomed  host contains an embedded gateway, it will\n              have
    full routing knowledge and as a result will be able\n              to make more
    optimal routing decisions.\n         o    Con: Gateway algorithms and protocols
    are still changing,\n              and they will continue to change as the Internet
    system\n              grows larger.  Attempting to include a general gateway\n
    \             function within the host IP layer will force host system\n              maintainers
    to track these (more frequent) changes.  Also,\n              a larger pool of
    gateway implementations will make\n              coordinating the changes more
    difficult.  Finally, the\n              complexity of a gateway IP layer is somewhat
    greater than\n              that of a host, making the implementation and operation\n
    \             tasks more complex.\n              In addition, the style of operation
    of some hosts is not\n              appropriate for providing stable and robust
    gateway\n              service.\n         There is considerable merit in both
    of these viewpoints.  One\n         conclusion can be drawn: an host administrator
    must have\n         conscious control over whether or not a given host acts as
    a\n         gateway.  See Section 3.1 for the detailed requirements.\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n   1.2
    \ General Considerations\n      There are two important lessons that vendors of
    Internet host\n      software have learned and which a new vendor should consider\n
    \     seriously.\n      1.2.1  Continuing Internet Evolution\n         The enormous
    growth of the Internet has revealed problems of\n         management and scaling
    in a large datagram-based packet\n         communication system.  These problems
    are being addressed, and\n         as a result there will be continuing evolution
    of the\n         specifications described in this document.  These changes will\n
    \        be carefully planned and controlled, since there is extensive\n         participation
    in this planning by the vendors and by the\n         organizations responsible
    for operations of the networks.\n         Development, evolution, and revision
    are characteristic of\n         computer network protocols today, and this situation
    will\n         persist for some years.  A vendor who develops computer\n         communication
    software for the Internet protocol suite (or any\n         other protocol suite!)
    and then fails to maintain and update\n         that software for changing specifications
    is going to leave a\n         trail of unhappy customers.  The Internet is a large\n
    \        communication network, and the users are in constant contact\n         through
    it.  Experience has shown that knowledge of\n         deficiencies in vendor software
    propagates quickly through the\n         Internet technical community.\n      1.2.2
    \ Robustness Principle\n         At every layer of the protocols, there is a general
    rule whose\n         application can lead to enormous benefits in robustness and\n
    \        interoperability [IP:1]:\n                \"Be liberal in what you accept,
    and\n                 conservative in what you send\"\n         Software should
    be written to deal with every conceivable\n         error, no matter how unlikely;
    sooner or later a packet will\n         come in with that particular combination
    of errors and\n         attributes, and unless the software is prepared, chaos
    can\n         ensue.  In general, it is best to assume that the network is\n         filled
    with malevolent entities that will send in packets\n         designed to have
    the worst possible effect.  This assumption\n         will lead to suitable protective
    design, although the most\n         serious problems in the Internet have been
    caused by\n         unenvisaged mechanisms triggered by low-probability events;\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         mere
    human malice would never have taken so devious a course!\n         Adaptability
    to change must be designed into all levels of\n         Internet host software.
    \ As a simple example, consider a\n         protocol specification that contains
    an enumeration of values\n         for a particular header field -- e.g., a type
    field, a port\n         number, or an error code; this enumeration must be assumed
    to\n         be incomplete.  Thus, if a protocol specification defines four\n
    \        possible error codes, the software must not break when a fifth\n         code
    shows up.  An undefined code might be logged (see below),\n         but it must
    not cause a failure.\n         The second part of the principle is almost as important:\n
    \        software on other hosts may contain deficiencies that make it\n         unwise
    to exploit legal but obscure protocol features.  It is\n         unwise to stray
    far from the obvious and simple, lest untoward\n         effects result elsewhere.
    \ A corollary of this is \"watch out\n         for misbehaving hosts\"; host software
    should be prepared, not\n         just to survive other misbehaving hosts, but
    also to cooperate\n         to limit the amount of disruption such hosts can cause
    to the\n         shared communication facility.\n      1.2.3  Error Logging\n
    \        The Internet includes a great variety of host and gateway\n         systems,
    each implementing many protocols and protocol layers,\n         and some of these
    contain bugs and mis-features in their\n         Internet protocol software.  As
    a result of complexity,\n         diversity, and distribution of function, the
    diagnosis of\n         Internet problems is often very difficult.\n         Problem
    diagnosis will be aided if host implementations include\n         a carefully
    designed facility for logging erroneous or\n         \"strange\" protocol events.
    \ It is important to include as much\n         diagnostic information as possible
    when an error is logged.  In\n         particular, it is often useful to record
    the header(s) of a\n         packet that caused an error.  However, care must
    be taken to\n         ensure that error logging does not consume prohibitive amounts\n
    \        of resources or otherwise interfere with the operation of the\n         host.\n
    \        There is a tendency for abnormal but harmless protocol events\n         to
    overflow error logging files; this can be avoided by using a\n         \"circular\"
    log, or by enabling logging only while diagnosing a\n         known failure.  It
    may be useful to filter and count duplicate\n         successive messages.  One
    strategy that seems to work well is:\n         (1) always count abnormalities
    and make such counts accessible\n         through the management protocol (see
    [INTRO:1]); and (2) allow\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         the
    logging of a great variety of events to be selectively\n         enabled.  For
    example, it might useful to be able to \"log\n         everything\" or to \"log
    everything for host X\".\n         Note that different managements may have differing
    policies\n         about the amount of error logging that they want normally\n
    \        enabled in a host.  Some will say, \"if it doesn't hurt me, I\n         don't
    want to know about it\", while others will want to take a\n         more watchful
    and aggressive attitude about detecting and\n         removing protocol abnormalities.\n
    \     1.2.4  Configuration\n         It would be ideal if a host implementation
    of the Internet\n         protocol suite could be entirely self-configuring.  This
    would\n         allow the whole suite to be implemented in ROM or cast into\n
    \        silicon, it would simplify diskless workstations, and it would\n         be
    an immense boon to harried LAN administrators as well as\n         system vendors.
    \ We have not reached this ideal; in fact, we\n         are not even close.\n
    \        At many points in this document, you will find a requirement\n         that
    a parameter be a configurable option.  There are several\n         different reasons
    behind such requirements.  In a few cases,\n         there is current uncertainty
    or disagreement about the best\n         value, and it may be necessary to update
    the recommended value\n         in the future.  In other cases, the value really
    depends on\n         external factors -- e.g., the size of the host and the\n
    \        distribution of its communication load, or the speeds and\n         topology
    of nearby networks -- and self-tuning algorithms are\n         unavailable and
    may be insufficient.  In some cases,\n         configurability is needed because
    of administrative\n         requirements.\n         Finally, some configuration
    options are required to communicate\n         with obsolete or incorrect implementations
    of the protocols,\n         distributed without sources, that unfortunately persist
    in many\n         parts of the Internet.  To make correct systems coexist with\n
    \        these faulty systems, administrators often have to \"mis-\n         configure\"
    the correct systems.  This problem will correct\n         itself gradually as
    the faulty systems are retired, but it\n         cannot be ignored by vendors.\n
    \        When we say that a parameter must be configurable, we do not\n         intend
    to require that its value be explicitly read from a\n         configuration file
    at every boot time.  We recommend that\n         implementors set up a default
    for each parameter, so a\n         configuration file is only necessary to override
    those defaults\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         that
    are inappropriate in a particular installation.  Thus, the\n         configurability
    requirement is an assurance that it will be\n         POSSIBLE to override the
    default when necessary, even in a\n         binary-only or ROM-based product.\n
    \        This document requires a particular value for such defaults in\n         some
    cases.  The choice of default is a sensitive issue when\n         the configuration
    item controls the accommodation to existing\n         faulty systems.  If the
    Internet is to converge successfully to\n         complete interoperability, the
    default values built into\n         implementations must implement the official
    protocol, not\n         \"mis-configurations\" to accommodate faulty implementations.\n
    \        Although marketing considerations have led some vendors to\n         choose
    mis-configuration defaults, we urge vendors to choose\n         defaults that
    will conform to the standard.\n         Finally, we note that a vendor needs to
    provide adequate\n         documentation on all configuration parameters, their
    limits and\n         effects.\n   1.3  Reading this Document\n      1.3.1  Organization\n
    \        Protocol layering, which is generally used as an organizing\n         principle
    in implementing network software, has also been used\n         to organize this
    document.  In describing the rules, we assume\n         that an implementation
    does strictly mirror the layering of the\n         protocols.  Thus, the following
    three major sections specify\n         the requirements for the link layer, the
    internet layer, and\n         the transport layer, respectively.  A companion
    RFC [INTRO:1]\n         covers application level software.  This layerist organization\n
    \        was chosen for simplicity and clarity.\n         However, strict layering
    is an imperfect model, both for the\n         protocol suite and for recommended
    implementation approaches.\n         Protocols in different layers interact in
    complex and sometimes\n         subtle ways, and particular functions often involve
    multiple\n         layers.  There are many design choices in an implementation,\n
    \        many of which involve creative \"breaking\" of strict layering.\n         Every
    implementor is urged to read references [INTRO:7] and\n         [INTRO:8].\n         This
    document describes the conceptual service interface\n         between layers using
    a functional (\"procedure call\") notation,\n         like that used in the TCP
    specification [TCP:1].  A host\n         implementation must support the logical
    information flow\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         implied
    by these calls, but need not literally implement the\n         calls themselves.
    \ For example, many implementations reflect\n         the coupling between the
    transport layer and the IP layer by\n         giving them shared access to common
    data structures.  These\n         data structures, rather than explicit procedure
    calls, are then\n         the agency for passing much of the information that
    is\n         required.\n         In general, each major section of this document
    is organized\n         into the following subsections:\n         (1)  Introduction\n
    \        (2)  Protocol Walk-Through -- considers the protocol\n              specification
    documents section-by-section, correcting\n              errors, stating requirements
    that may be ambiguous or\n              ill-defined, and providing further clarification
    or\n              explanation.\n         (3)  Specific Issues -- discusses protocol
    design and\n              implementation issues that were not included in the
    walk-\n              through.\n         (4)  Interfaces -- discusses the service
    interface to the next\n              higher layer.\n         (5)  Summary -- contains
    a summary of the requirements of the\n              section.\n         Under many
    of the individual topics in this document, there is\n         parenthetical material
    labeled \"DISCUSSION\" or\n         \"IMPLEMENTATION\". This material is intended
    to give\n         clarification and explanation of the preceding requirements\n
    \        text.  It also includes some suggestions on possible future\n         directions
    or developments.  The implementation material\n         contains suggested approaches
    that an implementor may want to\n         consider.\n         The summary sections
    are intended to be guides and indexes to\n         the text, but are necessarily
    cryptic and incomplete.  The\n         summaries should never be used or referenced
    separately from\n         the complete RFC.\n      1.3.2  Requirements\n         In
    this document, the words that are used to define the\n         significance of
    each particular requirement are capitalized.\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         These
    words are:\n         *    \"MUST\"\n              This word or the adjective \"REQUIRED\"
    means that the item\n              is an absolute requirement of the specification.\n
    \        *    \"SHOULD\"\n              This word or the adjective \"RECOMMENDED\"
    means that there\n              may exist valid reasons in particular circumstances
    to\n              ignore this item, but the full implications should be\n              understood
    and the case carefully weighed before choosing\n              a different course.\n
    \        *    \"MAY\"\n              This word or the adjective \"OPTIONAL\" means
    that this item\n              is truly optional.  One vendor may choose to include
    the\n              item because a particular marketplace requires it or\n              because
    it enhances the product, for example; another\n              vendor may omit the
    same item.\n         An implementation is not compliant if it fails to satisfy
    one\n         or more of the MUST requirements for the protocols it\n         implements.
    \ An implementation that satisfies all the MUST and\n         all the SHOULD requirements
    for its protocols is said to be\n         \"unconditionally compliant\"; one that
    satisfies all the MUST\n         requirements but not all the SHOULD requirements
    for its\n         protocols is said to be \"conditionally compliant\".\n      1.3.3
    \ Terminology\n         This document uses the following technical terms:\n         Segment\n
    \             A segment is the unit of end-to-end transmission in the\n              TCP
    protocol.  A segment consists of a TCP header followed\n              by application
    data.  A segment is transmitted by\n              encapsulation inside an IP datagram.\n
    \        Message\n              In this description of the lower-layer protocols,
    a\n              message is the unit of transmission in a transport layer\n              protocol.
    \ In particular, a TCP segment is a message.  A\n              message consists
    of a transport protocol header followed\n              by application protocol
    data.  To be transmitted end-to-\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n              end
    through the Internet, a message must be encapsulated\n              inside a datagram.\n
    \        IP Datagram\n              An IP datagram is the unit of end-to-end transmission
    in\n              the IP protocol.  An IP datagram consists of an IP header\n
    \             followed by transport layer data, i.e., of an IP header\n              followed
    by a message.\n              In the description of the internet layer (Section
    3), the\n              unqualified term \"datagram\" should be understood to refer\n
    \             to an IP datagram.\n         Packet\n              A packet is the
    unit of data passed across the interface\n              between the internet layer
    and the link layer.  It\n              includes an IP header and data.  A packet
    may be a\n              complete IP datagram or a fragment of an IP datagram.\n
    \        Frame\n              A frame is the unit of transmission in a link layer\n
    \             protocol, and consists of a link-layer header followed by\n              a
    packet.\n         Connected Network\n              A network to which a host is
    interfaced is often known as\n              the \"local network\" or the \"subnetwork\"
    relative to that\n              host.  However, these terms can cause confusion,
    and\n              therefore we use the term \"connected network\" in this\n              document.\n
    \        Multihomed\n              A host is said to be multihomed if it has multiple
    IP\n              addresses.  For a discussion of multihoming, see Section\n              3.3.4
    below.\n         Physical network interface\n              This is a physical
    interface to a connected network and\n              has a (possibly unique) link-layer
    address.  Multiple\n              physical network interfaces on a single host
    may share the\n              same link-layer address, but the address must be
    unique\n              for different hosts on the same physical network.\n         Logical
    [network] interface\n              We define a logical [network] interface to
    be a logical\n              path, distinguished by a unique IP address, to a connected\n
    \             network.  See Section 3.3.4.\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n         Specific-destination
    address\n              This is the effective destination address of a datagram,\n
    \             even if it is broadcast or multicast; see Section 3.2.1.3.\n         Path\n
    \             At a given moment, all the IP datagrams from a particular\n              source
    host to a particular destination host will\n              typically traverse the
    same sequence of gateways.  We use\n              the term \"path\" for this sequence.
    \ Note that a path is\n              uni-directional; it is not unusual to have
    different paths\n              in the two directions between a given host pair.\n
    \        MTU\n              The maximum transmission unit, i.e., the size of the\n
    \             largest packet that can be transmitted.\n         The terms frame,
    packet, datagram, message, and segment are\n         illustrated by the following
    schematic diagrams:\n         A. Transmission on connected network:\n           _______________________________________________\n
    \         | LL hdr | IP hdr |         (data)              |\n          |________|________|_____________________________|\n
    \          <---------- Frame ----------------------------->\n                    <----------Packet
    -------------------->\n         B. Before IP fragmentation or after IP reassembly:\n
    \                   ______________________________________\n                   |
    IP hdr | transport| Application Data |\n                   |________|____hdr___|__________________|\n
    \                   <--------  Datagram ------------------>\n                             <--------
    Message ----------->\n           or, for TCP:\n                    ______________________________________\n
    \                  | IP hdr |  TCP hdr | Application Data |\n                   |________|__________|__________________|\n
    \                   <--------  Datagram ------------------>\n                             <--------
    Segment ----------->\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - "RFC1122                       INTRODUCTION                  October 1989\n   1.4
    \ Acknowledgments\n      This document incorporates contributions and comments
    from a large\n      group of Internet protocol experts, including representatives
    of\n      university and research labs, vendors, and government agencies.\n      It
    was assembled primarily by the Host Requirements Working Group\n      of the Internet
    Engineering Task Force (IETF).\n      The Editor would especially like to acknowledge
    the tireless\n      dedication of the following people, who attended many long\n
    \     meetings and generated 3 million bytes of electronic mail over the\n      past
    18 months in pursuit of this document: Philip Almquist, Dave\n      Borman (Cray
    Research), Noel Chiappa, Dave Crocker (DEC), Steve\n      Deering (Stanford),
    Mike Karels (Berkeley), Phil Karn (Bellcore),\n      John Lekashman (NASA), Charles
    Lynn (BBN), Keith McCloghrie (TWG),\n      Paul Mockapetris (ISI), Thomas Narten
    (Purdue), Craig Partridge\n      (BBN), Drew Perkins (CMU), and James Van Bokkelen
    (FTP Software).\n      In addition, the following people made major contributions
    to the\n      effort: Bill Barns (Mitre), Steve Bellovin (AT&T), Mike Brescia\n
    \     (BBN), Ed Cain (DCA), Annette DeSchon (ISI), Martin Gross (DCA),\n      Phill
    Gross (NRI), Charles Hedrick (Rutgers), Van Jacobson (LBL),\n      John Klensin
    (MIT), Mark Lottor (SRI), Milo Medin (NASA), Bill\n      Melohn (Sun Microsystems),
    Greg Minshall (Kinetics), Jeff Mogul\n      (DEC), John Mullen (CMC), Jon Postel
    (ISI), John Romkey (Epilogue\n      Technology), and Mike StJohns (DCA).  The
    following also made\n      significant contributions to particular areas: Eric
    Allman\n      (Berkeley), Rob Austein (MIT), Art Berggreen (ACC), Keith Bostic\n
    \     (Berkeley), Vint Cerf (NRI), Wayne Hathaway (NASA), Matt Korn\n      (IBM),
    Erik Naggum (Naggum Software, Norway), Robert Ullmann\n      (Prime Computer),
    David Waitzman (BBN), Frank Wancho (USA), Arun\n      Welch (Ohio State), Bill
    Westfield (Cisco), and Rayan Zachariassen\n      (Toronto).\n      We are grateful
    to all, including any contributors who may have\n      been inadvertently omitted
    from this list.\n"
  title: RFC1122                       INTRODUCTION                  October 1989
- contents:
  - 'RFC1122                        LINK LAYER                   October 1989

    '
  title: RFC1122                        LINK LAYER                   October 1989
- contents:
  - "2. LINK LAYER\n   2.1  INTRODUCTION\n      All Internet systems, both hosts and
    gateways, have the same\n      requirements for link layer protocols.  These requirements
    are\n      given in Chapter 3 of \"Requirements for Internet Gateways\"\n      [INTRO:2],
    augmented with the material in this section.\n   2.2  PROTOCOL WALK-THROUGH\n
    \     None.\n   2.3  SPECIFIC ISSUES\n      2.3.1  Trailer Protocol Negotiation\n
    \        The trailer protocol [LINK:1] for link-layer encapsulation MAY\n         be
    used, but only when it has been verified that both systems\n         (host or
    gateway) involved in the link-layer communication\n         implement trailers.
    \ If the system does not dynamically\n         negotiate use of the trailer protocol
    on a per-destination\n         basis, the default configuration MUST disable the
    protocol.\n         DISCUSSION:\n              The trailer protocol is a link-layer
    encapsulation\n              technique that rearranges the data contents of packets\n
    \             sent on the physical network.  In some cases, trailers\n              improve
    the throughput of higher layer protocols by\n              reducing the amount
    of data copying within the operating\n              system.  Higher layer protocols
    are unaware of trailer\n              use, but both the sending and receiving
    host MUST\n              understand the protocol if it is used.\n              Improper
    use of trailers can result in very confusing\n              symptoms.  Only packets
    with specific size attributes are\n              encapsulated using trailers,
    and typically only a small\n              fraction of the packets being exchanged
    have these\n              attributes.  Thus, if a system using trailers exchanges\n
    \             packets with a system that does not, some packets\n              disappear
    into a black hole while others are delivered\n              successfully.\n         IMPLEMENTATION:\n
    \             On an Ethernet, packets encapsulated with trailers use a\n              distinct
    Ethernet type [LINK:1], and trailer negotiation\n              is performed at
    the time that ARP is used to discover the\n              link-layer address of
    a destination system.\n"
  title: 2. LINK LAYER
- contents:
  - "RFC1122                        LINK LAYER                   October 1989\n              Specifically,
    the ARP exchange is completed in the usual\n              manner using the normal
    IP protocol type, but a host that\n              wants to speak trailers will
    send an additional \"trailer\n              ARP reply\" packet, i.e., an ARP reply
    that specifies the\n              trailer encapsulation protocol type but otherwise
    has the\n              format of a normal ARP reply.  If a host configured to
    use\n              trailers receives a trailer ARP reply message from a\n              remote
    machine, it can add that machine to the list of\n              machines that understand
    trailers, e.g., by marking the\n              corresponding entry in the ARP cache.\n
    \             Hosts wishing to receive trailer encapsulations send\n              trailer
    ARP replies whenever they complete exchanges of\n              normal ARP messages
    for IP.  Thus, a host that received an\n              ARP request for its IP protocol
    address would send a\n              trailer ARP reply in addition to the normal
    IP ARP reply;\n              a host that sent the IP ARP request would send a
    trailer\n              ARP reply when it received the corresponding IP ARP reply.\n
    \             In this way, either the requesting or responding host in\n              an
    IP ARP exchange may request that it receive trailer\n              encapsulations.\n
    \             This scheme, using extra trailer ARP reply packets rather\n              than
    sending an ARP request for the trailer protocol type,\n              was designed
    to avoid a continuous exchange of ARP packets\n              with a misbehaving
    host that, contrary to any\n              specification or common sense, responded
    to an ARP reply\n              for trailers with another ARP reply for IP.  This
    problem\n              is avoided by sending a trailer ARP reply in response to\n
    \             an IP ARP reply only when the IP ARP reply answers an\n              outstanding
    request; this is true when the hardware\n              address for the host is
    still unknown when the IP ARP\n              reply is received.  A trailer ARP
    reply may always be sent\n              along with an IP ARP reply responding
    to an IP ARP\n              request.\n      2.3.2  Address Resolution Protocol
    -- ARP\n         2.3.2.1  ARP Cache Validation\n            An implementation
    of the Address Resolution Protocol (ARP)\n            [LINK:2] MUST provide a
    mechanism to flush out-of-date cache\n            entries.  If this mechanism
    involves a timeout, it SHOULD be\n            possible to configure the timeout
    value.\n            A mechanism to prevent ARP flooding (repeatedly sending an\n
    \           ARP Request for the same IP address, at a high rate) MUST be\n            included.
    \ The recommended maximum rate is 1 per second per\n"
  title: RFC1122                        LINK LAYER                   October 1989
- contents:
  - "RFC1122                        LINK LAYER                   October 1989\n            destination.\n
    \           DISCUSSION:\n                 The ARP specification [LINK:2] suggests
    but does not\n                 require a timeout mechanism to invalidate cache
    entries\n                 when hosts change their Ethernet addresses.  The\n                 prevalence
    of proxy ARP (see Section 2.4 of [INTRO:2])\n                 has significantly
    increased the likelihood that cache\n                 entries in hosts will become
    invalid, and therefore\n                 some ARP-cache invalidation mechanism
    is now required\n                 for hosts.  Even in the absence of proxy ARP,
    a long-\n                 period cache timeout is useful in order to\n                 automatically
    correct any bad ARP data that might have\n                 been cached.\n            IMPLEMENTATION:\n
    \                Four mechanisms have been used, sometimes in\n                 combination,
    to flush out-of-date cache entries.\n                 (1)  Timeout -- Periodically
    time out cache entries,\n                      even if they are in use.  Note
    that this timeout\n                      should be restarted when the cache entry
    is\n                      \"refreshed\" (by observing the source fields,\n                      regardless
    of target address, of an ARP broadcast\n                      from the system
    in question).  For proxy ARP\n                      situations, the timeout needs
    to be on the order\n                      of a minute.\n                 (2)  Unicast
    Poll -- Actively poll the remote host by\n                      periodically sending
    a point-to-point ARP Request\n                      to it, and delete the entry
    if no ARP Reply is\n                      received from N successive polls.  Again,
    the\n                      timeout should be on the order of a minute, and\n                      typically
    N is 2.\n                 (3)  Link-Layer Advice -- If the link-layer driver\n
    \                     detects a delivery problem, flush the\n                      corresponding
    ARP cache entry.\n                 (4)  Higher-layer Advice -- Provide a call
    from the\n                      Internet layer to the link layer to indicate a\n
    \                     delivery problem.  The effect of this call would\n                      be
    to invalidate the corresponding cache entry.\n                      This call
    would be analogous to the\n                      \"ADVISE_DELIVPROB()\" call from
    the transport layer\n                      to the Internet layer (see Section
    3.4), and in\n                      fact the ADVISE_DELIVPROB routine might in
    turn\n                      call the link-layer advice routine to invalidate\n"
  title: RFC1122                        LINK LAYER                   October 1989
- contents:
  - "RFC1122                        LINK LAYER                   October 1989\n                      the
    ARP cache entry.\n                 Approaches (1) and (2) involve ARP cache timeouts
    on\n                 the order of a minute or less.  In the absence of proxy\n
    \                ARP, a timeout this short could create noticeable\n                 overhead
    traffic on a very large Ethernet.  Therefore,\n                 it may be necessary
    to configure a host to lengthen the\n                 ARP cache timeout.\n         2.3.2.2
    \ ARP Packet Queue\n            The link layer SHOULD save (rather than discard)
    at least\n            one (the latest) packet of each set of packets destined
    to\n            the same unresolved IP address, and transmit the saved\n            packet
    when the address has been resolved.\n            DISCUSSION:\n                 Failure
    to follow this recommendation causes the first\n                 packet of every
    exchange to be lost.  Although higher-\n                 layer protocols can generally
    cope with packet loss by\n                 retransmission, packet loss does impact
    performance.\n                 For example, loss of a TCP open request causes
    the\n                 initial round-trip time estimate to be inflated.  UDP-\n
    \                based applications such as the Domain Name System are\n                 more
    seriously affected.\n      2.3.3  Ethernet and IEEE 802 Encapsulation\n         The
    IP encapsulation for Ethernets is described in RFC-894\n         [LINK:3], while
    RFC-1042 [LINK:4] describes the IP\n         encapsulation for IEEE 802 networks.
    \ RFC-1042 elaborates and\n         replaces the discussion in Section 3.4 of
    [INTRO:2].\n         Every Internet host connected to a 10Mbps Ethernet cable:\n
    \        o    MUST be able to send and receive packets using RFC-894\n              encapsulation;\n
    \        o    SHOULD be able to receive RFC-1042 packets, intermixed\n              with
    RFC-894 packets; and\n         o    MAY be able to send packets using RFC-1042
    encapsulation.\n         An Internet host that implements sending both the RFC-894
    and\n         the RFC-1042 encapsulations MUST provide a configuration switch\n
    \        to select which is sent, and this switch MUST default to RFC-\n         894.\n"
  title: RFC1122                        LINK LAYER                   October 1989
- contents:
  - "RFC1122                        LINK LAYER                   October 1989\n         Note
    that the standard IP encapsulation in RFC-1042 does not\n         use the protocol
    id value (K1=6) that IEEE reserved for IP;\n         instead, it uses a value
    (K1=170) that implies an extension\n         (the \"SNAP\") which can be used
    to hold the Ether-Type field.\n         An Internet system MUST NOT send 802 packets
    using K1=6.\n         Address translation from Internet addresses to link-layer\n
    \        addresses on Ethernet and IEEE 802 networks MUST be managed by\n         the
    Address Resolution Protocol (ARP).\n         The MTU for an Ethernet is 1500 and
    for 802.3 is 1492.\n         DISCUSSION:\n              The IEEE 802.3 specification
    provides for operation over a\n              10Mbps Ethernet cable, in which case
    Ethernet and IEEE\n              802.3 frames can be physically intermixed.  A
    receiver can\n              distinguish Ethernet and 802.3 frames by the value
    of the\n              802.3 Length field; this two-octet field coincides in the\n
    \             header with the Ether-Type field of an Ethernet frame.  In\n              particular,
    the 802.3 Length field must be less than or\n              equal to 1500, while
    all valid Ether-Type values are\n              greater than 1500.\n              Another
    compatibility problem arises with link-layer\n              broadcasts.  A broadcast
    sent with one framing will not be\n              seen by hosts that can receive
    only the other framing.\n              The provisions of this section were designed
    to provide\n              direct interoperation between 894-capable and 1042-capable\n
    \             systems on the same cable, to the maximum extent possible.\n              It
    is intended to support the present situation where\n              894-only systems
    predominate, while providing an easy\n              transition to a possible future
    in which 1042-capable\n              systems become common.\n              Note
    that 894-only systems cannot interoperate directly\n              with 1042-only
    systems.  If the two system types are set\n              up as two different logical
    networks on the same cable,\n              they can communicate only through an
    IP gateway.\n              Furthermore, it is not useful or even possible for
    a\n              dual-format host to discover automatically which format to\n
    \             send, because of the problem of link-layer broadcasts.\n   2.4  LINK/INTERNET
    LAYER INTERFACE\n      The packet receive interface between the IP layer and the
    link\n      layer MUST include a flag to indicate whether the incoming packet\n
    \     was addressed to a link-layer broadcast address.\n"
  title: RFC1122                        LINK LAYER                   October 1989
- contents:
  - "RFC1122                        LINK LAYER                   October 1989\n      DISCUSSION\n
    \          Although the IP layer does not generally know link layer\n           addresses
    (since every different network medium typically has\n           a different address
    format), the broadcast address on a\n           broadcast-capable medium is an
    important special case.  See\n           Section 3.2.2, especially the DISCUSSION
    concerning broadcast\n           storms.\n      The packet send interface between
    the IP and link layers MUST\n      include the 5-bit TOS field (see Section 3.2.1.6).\n
    \     The link layer MUST NOT report a Destination Unreachable error to\n      IP
    solely because there is no ARP cache entry for a destination.\n   2.5  LINK LAYER
    REQUIREMENTS SUMMARY\n                                                  |       |
    | | |S| |\n                                                  |       | | | |H|
    |F\n                                                  |       | | | |O|M|o\n                                                  |
    \      | |S| |U|U|o\n                                                  |       |
    |H| |L|S|t\n                                                  |       |M|O| |D|T|n\n
    \                                                 |       |U|U|M| | |o\n                                                  |
    \      |S|L|A|N|N|t\n                                                  |       |T|D|Y|O|O|t\n"
  title: RFC1122                        LINK LAYER                   October 1989
- contents:
  - 'FEATURE                                           |SECTION| | | |T|T|e

    '
  title: FEATURE                                           |SECTION| | | |T|T|e
- contents:
  - "--------------------------------------------------|-------|-|-|-|-|-|--\n                                                  |
    \      | | | | | |\n"
  title: '--------------------------------------------------|-------|-|-|-|-|-|--'
- contents:
  - 'Trailer encapsulation                             |2.3.1  | | |x| | |

    '
  title: Trailer encapsulation                             |2.3.1  | | |x| | |
- contents:
  - 'Send Trailers by default without negotiation      |2.3.1  | | | | |x|

    '
  title: Send Trailers by default without negotiation      |2.3.1  | | | | |x|
- contents:
  - "ARP                                               |2.3.2  | | | | | |\n  Flush
    out-of-date ARP cache entries             |2.3.2.1|x| | | | |\n  Prevent ARP floods
    \                             |2.3.2.1|x| | | | |\n  Cache timeout configurable
    \                     |2.3.2.1| |x| | | |\n  Save at least one (latest) unresolved
    pkt       |2.3.2.2| |x| | | |\n"
  title: ARP                                               |2.3.2  | | | | | |
- contents:
  - "Ethernet and IEEE 802 Encapsulation               |2.3.3  | | | | | |\n  Host
    able to:                                   |2.3.3  | | | | | |\n    Send & receive
    RFC-894 encapsulation          |2.3.3  |x| | | | |\n    Receive RFC-1042 encapsulation
    \               |2.3.3  | |x| | | |\n    Send RFC-1042 encapsulation                   |2.3.3
    \ | | |x| | |\n      Then config. sw. to select, RFC-894 dflt    |2.3.3  |x| |
    | | |\n  Send K1=6 encapsulation                         |2.3.3  | | | | |x|\n
    \ Use ARP on Ethernet and IEEE 802 nets           |2.3.3  |x| | | | |\n"
  title: Ethernet and IEEE 802 Encapsulation               |2.3.3  | | | | | |
- contents:
  - 'Link layer report b''casts to IP layer             |2.4    |x| | | | |

    '
  title: Link layer report b'casts to IP layer             |2.4    |x| | | | |
- contents:
  - 'IP layer pass TOS to link layer                   |2.4    |x| | | | |

    '
  title: IP layer pass TOS to link layer                   |2.4    |x| | | | |
- contents:
  - 'No ARP cache entry treated as Dest. Unreach.      |2.4    | | | | |x|

    '
  title: No ARP cache entry treated as Dest. Unreach.      |2.4    | | | | |x|
- contents:
  - 'RFC1122                      INTERNET LAYER                 October 1989

    '
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "3. INTERNET LAYER PROTOCOLS\n   3.1 INTRODUCTION\n      The Robustness Principle:
    \"Be liberal in what you accept, and\n      conservative in what you send\" is
    particularly important in the\n      Internet layer, where one misbehaving host
    can deny Internet\n      service to many other hosts.\n      The protocol standards
    used in the Internet layer are:\n      o    RFC-791 [IP:1] defines the IP protocol
    and gives an\n           introduction to the architecture of the Internet.\n      o
    \   RFC-792 [IP:2] defines ICMP, which provides routing,\n           diagnostic
    and error functionality for IP.  Although ICMP\n           messages are encapsulated
    within IP datagrams, ICMP\n           processing is considered to be (and is typically
    implemented\n           as) part of the IP layer.  See Section 3.2.2.\n      o
    \   RFC-950 [IP:3] defines the mandatory subnet extension to the\n           addressing
    architecture.\n      o    RFC-1112 [IP:4] defines the Internet Group Management\n
    \          Protocol IGMP, as part of a recommended extension to hosts\n           and
    to the host-gateway interface to support Internet-wide\n           multicasting
    at the IP level.  See Section 3.2.3.\n           The target of an IP multicast
    may be an arbitrary group of\n           Internet hosts.  IP multicasting is designed
    as a natural\n           extension of the link-layer multicasting facilities of
    some\n           networks, and it provides a standard means for local access\n
    \          to such link-layer multicasting facilities.\n      Other important
    references are listed in Section 5 of this\n      document.\n      The Internet
    layer of host software MUST implement both IP and\n      ICMP.  See Section 3.3.7
    for the requirements on support of IGMP.\n      The host IP layer has two basic
    functions:  (1) choose the \"next\n      hop\" gateway or host for outgoing IP
    datagrams and (2) reassemble\n      incoming IP datagrams.  The IP layer may also
    (3) implement\n      intentional fragmentation of outgoing datagrams.  Finally,
    the IP\n      layer must (4) provide diagnostic and error functionality.  We\n
    \     expect that IP layer functions may increase somewhat in the\n      future,
    as further Internet control and management facilities are\n      developed.\n"
  title: 3. INTERNET LAYER PROTOCOLS
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n      For
    normal datagrams, the processing is straightforward.  For\n      incoming datagrams,
    the IP layer:\n      (1)  verifies that the datagram is correctly formatted;\n
    \     (2)  verifies that it is destined to the local host;\n      (3)  processes
    options;\n      (4)  reassembles the datagram if necessary; and\n      (5)  passes
    the encapsulated message to the appropriate\n           transport-layer protocol
    module.\n      For outgoing datagrams, the IP layer:\n      (1)  sets any fields
    not set by the transport layer;\n      (2)  selects the correct first hop on the
    connected network (a\n           process called \"routing\");\n      (3)  fragments
    the datagram if necessary and if intentional\n           fragmentation is implemented
    (see Section 3.3.3); and\n      (4)  passes the packet(s) to the appropriate link-layer
    driver.\n      A host is said to be multihomed if it has multiple IP addresses.\n
    \     Multihoming introduces considerable confusion and complexity into\n      the
    protocol suite, and it is an area in which the Internet\n      architecture falls
    seriously short of solving all problems.  There\n      are two distinct problem
    areas in multihoming:\n      (1)  Local multihoming --  the host itself is multihomed;
    or\n      (2)  Remote multihoming -- the local host needs to communicate\n           with
    a remote multihomed host.\n      At present, remote multihoming MUST be handled
    at the application\n      layer, as discussed in the companion RFC [INTRO:1].
    \ A host MAY\n      support local multihoming, which is discussed in this document,\n
    \     and in particular in Section 3.3.4.\n      Any host that forwards datagrams
    generated by another host is\n      acting as a gateway and MUST also meet the
    specifications laid out\n      in the gateway requirements RFC [INTRO:2].  An
    Internet host that\n      includes embedded gateway code MUST have a configuration
    switch to\n      disable the gateway function, and this switch MUST default to
    the\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n      non-gateway
    mode.  In this mode, a datagram arriving through one\n      interface will not
    be forwarded to another host or gateway (unless\n      it is source-routed), regardless
    of whether the host is single-\n      homed or multihomed.  The host software
    MUST NOT automatically\n      move into gateway mode if the host has more than
    one interface, as\n      the operator of the machine may neither want to provide
    that\n      service nor be competent to do so.\n      In the following, the action
    specified in certain cases is to\n      \"silently discard\" a received datagram.
    \ This means that the\n      datagram will be discarded without further processing
    and that the\n      host will not send any ICMP error message (see Section 3.2.2)
    as a\n      result.  However, for diagnosis of problems a host SHOULD provide\n
    \     the capability of logging the error (see Section 1.2.3), including\n      the
    contents of the silently-discarded datagram, and SHOULD record\n      the event
    in a statistics counter.\n      DISCUSSION:\n           Silent discard of erroneous
    datagrams is generally intended\n           to prevent \"broadcast storms\".\n
    \  3.2  PROTOCOL WALK-THROUGH\n      3.2.1 Internet Protocol -- IP\n         3.2.1.1
    \ Version Number: RFC-791 Section 3.1\n            A datagram whose version number
    is not 4 MUST be silently\n            discarded.\n         3.2.1.2  Checksum:
    RFC-791 Section 3.1\n            A host MUST verify the IP header checksum on
    every received\n            datagram and silently discard every datagram that
    has a bad\n            checksum.\n         3.2.1.3  Addressing: RFC-791 Section
    3.2\n            There are now five classes of IP addresses: Class A through\n
    \           Class E.  Class D addresses are used for IP multicasting\n            [IP:4],
    while Class E addresses are reserved for\n            experimental use.\n            A
    multicast (Class D) address is a 28-bit logical address\n            that stands
    for a group of hosts, and may be either\n            permanent or transient.  Permanent
    multicast addresses are\n            allocated by the Internet Assigned Number
    Authority\n            [INTRO:6], while transient addresses may be allocated\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            dynamically
    to transient groups.  Group membership is\n            determined dynamically
    using IGMP [IP:4].\n            We now summarize the important special cases for
    Class A, B,\n            and C IP addresses, using the following notation for
    an IP\n            address:\n                { <Network-number>, <Host-number>
    }\n            or\n                { <Network-number>, <Subnet-number>, <Host-number>
    }\n            and the notation \"-1\" for a field that contains all 1 bits.\n
    \           This notation is not intended to imply that the 1-bits in an\n            address
    mask need be contiguous.\n            (a)  { 0, 0 }\n                 This host
    on this network.  MUST NOT be sent, except as\n                 a source address
    as part of an initialization procedure\n                 by which the host learns
    its own IP address.\n                 See also Section 3.3.6 for a non-standard
    use of {0,0}.\n            (b)  { 0, <Host-number> }\n                 Specified
    host on this network.  It MUST NOT be sent,\n                 except as a source
    address as part of an initialization\n                 procedure by which the
    host learns its full IP address.\n            (c)  { -1, -1 }\n                 Limited
    broadcast.  It MUST NOT be used as a source\n                 address.\n                 A
    datagram with this destination address will be\n                 received by every
    host on the connected physical\n                 network but will not be forwarded
    outside that network.\n            (d)  { <Network-number>, -1 }\n                 Directed
    broadcast to the specified network.  It MUST\n                 NOT be used as
    a source address.\n            (e)  { <Network-number>, <Subnet-number>, -1 }\n
    \                Directed broadcast to the specified subnet.  It MUST\n                 NOT
    be used as a source address.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            (f)
    \ { <Network-number>, -1, -1 }\n                 Directed broadcast to all subnets
    of the specified\n                 subnetted network.  It MUST NOT be used as
    a source\n                 address.\n            (g)  { 127, <any> }\n                 Internal
    host loopback address.  Addresses of this form\n                 MUST NOT appear
    outside a host.\n            The <Network-number> is administratively assigned
    so that\n            its value will be unique in the entire world.\n            IP
    addresses are not permitted to have the value 0 or -1 for\n            any of
    the <Host-number>, <Network-number>, or <Subnet-\n            number> fields (except
    in the special cases listed above).\n            This implies that each of these
    fields will be at least two\n            bits long.\n            For further discussion
    of broadcast addresses, see Section\n            3.3.6.\n            A host MUST
    support the subnet extensions to IP [IP:3].  As\n            a result, there will
    be an address mask of the form:\n            {-1, -1, 0} associated with each
    of the host's local IP\n            addresses; see Sections 3.2.2.9 and 3.3.1.1.\n
    \           When a host sends any datagram, the IP source address MUST\n            be
    one of its own IP addresses (but not a broadcast or\n            multicast address).\n
    \           A host MUST silently discard an incoming datagram that is\n            not
    destined for the host.  An incoming datagram is destined\n            for the
    host if the datagram's destination address field is:\n            (1)  (one of)
    the host's IP address(es); or\n            (2)  an IP broadcast address valid
    for the connected\n                 network; or\n            (3)  the address
    for a multicast group of which the host is\n                 a member on the incoming
    physical interface.\n            For most purposes, a datagram addressed to a
    broadcast or\n            multicast destination is processed as if it had been\n
    \           addressed to one of the host's IP addresses; we use the term\n            \"specific-destination
    address\" for the equivalent local IP\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            address
    of the host.  The specific-destination address is\n            defined to be the
    destination address in the IP header\n            unless the header contains a
    broadcast or multicast address,\n            in which case the specific-destination
    is an IP address\n            assigned to the physical interface on which the
    datagram\n            arrived.\n            A host MUST silently discard an incoming
    datagram containing\n            an IP source address that is invalid by the rules
    of this\n            section.  This validation could be done in either the IP\n
    \           layer or by each protocol in the transport layer.\n            DISCUSSION:\n
    \                A mis-addressed datagram might be caused by a link-\n                 layer
    broadcast of a unicast datagram or by a gateway\n                 or host that
    is confused or mis-configured.\n                 An architectural goal for Internet
    hosts was to allow\n                 IP addresses to be featureless 32-bit numbers,
    avoiding\n                 algorithms that required a knowledge of the IP address\n
    \                format.  Otherwise, any future change in the format or\n                 interpretation
    of IP addresses will require host\n                 software changes.  However,
    validation of broadcast and\n                 multicast addresses violates this
    goal; a few other\n                 violations are described elsewhere in this
    document.\n                 Implementers should be aware that applications\n                 depending
    upon the all-subnets directed broadcast\n                 address (f) may be unusable
    on some networks.  All-\n                 subnets broadcast is not widely implemented
    in vendor\n                 gateways at present, and even when it is implemented,
    a\n                 particular network administration may disable it in the\n
    \                gateway configuration.\n         3.2.1.4  Fragmentation and Reassembly:
    RFC-791 Section 3.2\n            The Internet model requires that every host support\n
    \           reassembly.  See Sections 3.3.2 and 3.3.3 for the\n            requirements
    on fragmentation and reassembly.\n         3.2.1.5  Identification: RFC-791 Section
    3.2\n            When sending an identical copy of an earlier datagram, a\n            host
    MAY optionally retain the same Identification field in\n            the copy.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            DISCUSSION:\n
    \                Some Internet protocol experts have maintained that\n                 when
    a host sends an identical copy of an earlier\n                 datagram, the new
    copy should contain the same\n                 Identification value as the original.
    \ There are two\n                 suggested advantages:  (1) if the datagrams
    are\n                 fragmented and some of the fragments are lost, the\n                 receiver
    may be able to reconstruct a complete datagram\n                 from fragments
    of the original and the copies; (2) a\n                 congested gateway might
    use the IP Identification field\n                 (and Fragment Offset) to discard
    duplicate datagrams\n                 from the queue.\n                 However,
    the observed patterns of datagram loss in the\n                 Internet do not
    favor the probability of retransmitted\n                 fragments filling reassembly
    gaps, while other\n                 mechanisms (e.g., TCP repacketizing upon\n
    \                retransmission) tend to prevent retransmission of an\n                 identical
    datagram [IP:9].  Therefore, we believe that\n                 retransmitting
    the same Identification field is not\n                 useful.  Also, a connectionless
    transport protocol like\n                 UDP would require the cooperation of
    the application\n                 programs to retain the same Identification value
    in\n                 identical datagrams.\n         3.2.1.6  Type-of-Service:
    RFC-791 Section 3.2\n            The \"Type-of-Service\" byte in the IP header
    is divided into\n            two sections:  the Precedence field (high-order 3
    bits), and\n            a field that is customarily called \"Type-of-Service\"
    or\n            \"TOS\" (low-order 5 bits).  In this document, all references\n
    \           to \"TOS\" or the \"TOS field\" refer to the low-order 5 bits\n            only.\n
    \           The Precedence field is intended for Department of Defense\n            applications
    of the Internet protocols.  The use of non-zero\n            values in this field
    is outside the scope of this document\n            and the IP standard specification.
    \ Vendors should consult\n            the Defense Communication Agency (DCA) for
    guidance on the\n            IP Precedence field and its implications for other
    protocol\n            layers.  However, vendors should note that the use of\n
    \           precedence will most likely require that its value be passed\n            between
    protocol layers in just the same way as the TOS\n            field is passed.\n
    \           The IP layer MUST provide a means for the transport layer to\n            set
    the TOS field of every datagram that is sent; the\n            default is all
    zero bits.  The IP layer SHOULD pass received\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            TOS
    values up to the transport layer.\n            The particular link-layer mappings
    of TOS contained in RFC-\n            795 SHOULD NOT be implemented.\n            DISCUSSION:\n
    \                While the TOS field has been little used in the past,\n                 it
    is expected to play an increasing role in the near\n                 future.  The
    TOS field is expected to be used to\n                 control two aspects of gateway
    operations: routing and\n                 queueing algorithms.  See Section 2
    of [INTRO:1] for\n                 the requirements on application programs to
    specify TOS\n                 values.\n                 The TOS field may also
    be mapped into link-layer\n                 service selectors.  This has been
    applied to provide\n                 effective sharing of serial lines by different
    classes\n                 of TCP traffic, for example.  However, the mappings\n
    \                suggested in RFC-795 for networks that were included in\n                 the
    Internet as of 1981 are now obsolete.\n         3.2.1.7  Time-to-Live: RFC-791
    Section 3.2\n            A host MUST NOT send a datagram with a Time-to-Live (TTL)\n
    \           value of zero.\n            A host MUST NOT discard a datagram just
    because it was\n            received with TTL less than 2.\n            The IP
    layer MUST provide a means for the transport layer to\n            set the TTL
    field of every datagram that is sent.  When a\n            fixed TTL value is
    used, it MUST be configurable.  The\n            current suggested value will
    be published in the \"Assigned\n            Numbers\" RFC.\n            DISCUSSION:\n
    \                The TTL field has two functions: limit the lifetime of\n                 TCP
    segments (see RFC-793 [TCP:1], p. 28), and\n                 terminate Internet
    routing loops.  Although TTL is a\n                 time in seconds, it also has
    some attributes of a hop-\n                 count, since each gateway is required
    to reduce the TTL\n                 field by at least one.\n                 The
    intent is that TTL expiration will cause a datagram\n                 to be discarded
    by a gateway but not by the destination\n                 host; however, hosts
    that act as gateways by forwarding\n                 datagrams must follow the
    gateway rules for TTL.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 A
    higher-layer protocol may want to set the TTL in\n                 order to implement
    an \"expanding scope\" search for some\n                 Internet resource.  This
    is used by some diagnostic\n                 tools, and is expected to be useful
    for locating the\n                 \"nearest\" server of a given class using IP\n
    \                multicasting, for example.  A particular transport\n                 protocol
    may also want to specify its own TTL bound on\n                 maximum datagram
    lifetime.\n                 A fixed value must be at least big enough for the\n
    \                Internet \"diameter,\" i.e., the longest possible path.\n                 A
    reasonable value is about twice the diameter, to\n                 allow for continued
    Internet growth.\n         3.2.1.8  Options: RFC-791 Section 3.2\n            There
    MUST be a means for the transport layer to specify IP\n            options to
    be included in transmitted IP datagrams (see\n            Section 3.4).\n            All
    IP options (except NOP or END-OF-LIST) received in\n            datagrams MUST
    be passed to the transport layer (or to ICMP\n            processing when the
    datagram is an ICMP message).  The IP\n            and transport layer MUST each
    interpret those IP options\n            that they understand and silently ignore
    the others.\n            Later sections of this document discuss specific IP option\n
    \           support required by each of ICMP, TCP, and UDP.\n            DISCUSSION:\n
    \                Passing all received IP options to the transport layer\n                 is
    a deliberate \"violation of strict layering\" that is\n                 designed
    to ease the introduction of new transport-\n                 relevant IP options
    in the future.  Each layer must\n                 pick out any options that are
    relevant to its own\n                 processing and ignore the rest.  For this
    purpose,\n                 every IP option except NOP and END-OF-LIST will include\n
    \                a specification of its own length.\n                 This document
    does not define the order in which a\n                 receiver must process multiple
    options in the same IP\n                 header.  Hosts sending multiple options
    must be aware\n                 that this introduces an ambiguity in the meaning
    of\n                 certain options when combined with a source-route\n                 option.\n
    \           IMPLEMENTATION:\n                 The IP layer must not crash as the
    result of an option\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 length
    that is outside the possible range.  For\n                 example, erroneous
    option lengths have been observed to\n                 put some IP implementations
    into infinite loops.\n            Here are the requirements for specific IP options:\n
    \           (a)  Security Option\n                 Some environments require the
    Security option in every\n                 datagram; such a requirement is outside
    the scope of\n                 this document and the IP standard specification.
    \ Note,\n                 however, that the security options described in RFC-791\n
    \                and RFC-1038 are obsolete.  For DoD applications,\n                 vendors
    should consult [IP:8] for guidance.\n            (b)  Stream Identifier Option\n
    \                This option is obsolete; it SHOULD NOT be sent, and it\n                 MUST
    be silently ignored if received.\n            (c)  Source Route Options\n                 A
    host MUST support originating a source route and MUST\n                 be able
    to act as the final destination of a source\n                 route.\n                 If
    host receives a datagram containing a completed\n                 source route
    (i.e., the pointer points beyond the last\n                 field), the datagram
    has reached its final destination;\n                 the option as received (the
    recorded route) MUST be\n                 passed up to the transport layer (or
    to ICMP message\n                 processing).  This recorded route will be reversed
    and\n                 used to form a return source route for reply datagrams\n
    \                (see discussion of IP Options in Section 4).  When a\n                 return
    source route is built, it MUST be correctly\n                 formed even if the
    recorded route included the source\n                 host (see case (B) in the
    discussion below).\n                 An IP header containing more than one Source
    Route\n                 option MUST NOT be sent; the effect on routing of\n                 multiple
    Source Route options is implementation-\n                 specific.\n                 Section
    3.3.5 presents the rules for a host acting as\n                 an intermediate
    hop in a source route, i.e., forwarding\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 a
    source-routed datagram.\n                 DISCUSSION:\n                      If
    a source-routed datagram is fragmented, each\n                      fragment will
    contain a copy of the source route.\n                      Since the processing
    of IP options (including a\n                      source route) must precede reassembly,
    the\n                      original datagram will not be reassembled until\n                      the
    final destination is reached.\n                      Suppose a source routed datagram
    is to be routed\n                      from host S to host D via gateways G1,
    G2, ... Gn.\n                      There was an ambiguity in the specification
    over\n                      whether the source route option in a datagram sent\n
    \                     out by S should be (A) or (B):\n                          (A):
    \ {>>G2, G3, ... Gn, D}     <--- CORRECT\n                          (B):  {S,
    >>G2, G3, ... Gn, D}  <---- WRONG\n                      (where >> represents
    the pointer).  If (A) is\n                      sent, the datagram received at
    D will contain the\n                      option: {G1, G2, ... Gn >>}, with S
    and D as the\n                      IP source and destination addresses.  If (B)
    were\n                      sent, the datagram received at D would again\n                      contain
    S and D as the same IP source and\n                      destination addresses,
    but the option would be:\n                      {S, G1, ...Gn >>}; i.e., the originating
    host\n                      would be the first hop in the route.\n            (d)
    \ Record Route Option\n                 Implementation of originating and processing
    the Record\n                 Route option is OPTIONAL.\n            (e)  Timestamp
    Option\n                 Implementation of originating and processing the\n                 Timestamp
    option is OPTIONAL.  If it is implemented,\n                 the following rules
    apply:\n                 o    The originating host MUST record a timestamp in
    a\n                      Timestamp option whose Internet address fields are\n
    \                     not pre-specified or whose first pre-specified\n                      address
    is the host's interface address.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 o
    \   The destination host MUST (if possible) add the\n                      current
    timestamp to a Timestamp option before\n                      passing the option
    to the transport layer or to\n                      ICMP for processing.\n                 o
    \   A timestamp value MUST follow the rules given in\n                      Section
    3.2.2.8 for the ICMP Timestamp message.\n      3.2.2 Internet Control Message
    Protocol -- ICMP\n         ICMP messages are grouped into two classes.\n         *\n
    \             ICMP error messages:\n               Destination Unreachable   (see
    Section 3.2.2.1)\n               Redirect                  (see Section 3.2.2.2)\n
    \              Source Quench             (see Section 3.2.2.3)\n               Time
    Exceeded             (see Section 3.2.2.4)\n               Parameter Problem         (see
    Section 3.2.2.5)\n         *\n              ICMP query messages:\n                Echo
    \                    (see Section 3.2.2.6)\n                Information              (see
    Section 3.2.2.7)\n                Timestamp                (see Section 3.2.2.8)\n
    \               Address Mask             (see Section 3.2.2.9)\n         If an
    ICMP message of unknown type is received, it MUST be\n         silently discarded.\n
    \        Every ICMP error message includes the Internet header and at\n         least
    the first 8 data octets of the datagram that triggered\n         the error; more
    than 8 octets MAY be sent; this header and data\n         MUST be unchanged from
    the received datagram.\n         In those cases where the Internet layer is required
    to pass an\n         ICMP error message to the transport layer, the IP protocol\n
    \        number MUST be extracted from the original header and used to\n         select
    the appropriate transport protocol entity to handle the\n         error.\n         An
    ICMP error message SHOULD be sent with normal (i.e., zero)\n         TOS bits.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n         An
    ICMP error message MUST NOT be sent as the result of\n         receiving:\n         *
    \   an ICMP error message, or\n         *    a datagram destined to an IP broadcast
    or IP multicast\n              address, or\n         *    a datagram sent as a
    link-layer broadcast, or\n         *    a non-initial fragment, or\n         *
    \   a datagram whose source address does not define a single\n              host
    -- e.g., a zero address, a loopback address, a\n              broadcast address,
    a multicast address, or a Class E\n              address.\n         NOTE: THESE
    RESTRICTIONS TAKE PRECEDENCE OVER ANY REQUIREMENT\n         ELSEWHERE IN THIS
    DOCUMENT FOR SENDING ICMP ERROR MESSAGES.\n         DISCUSSION:\n              These
    rules will prevent the \"broadcast storms\" that have\n              resulted
    from hosts returning ICMP error messages in\n              response to broadcast
    datagrams.  For example, a broadcast\n              UDP segment to a non-existent
    port could trigger a flood\n              of ICMP Destination Unreachable datagrams
    from all\n              machines that do not have a client for that destination\n
    \             port.  On a large Ethernet, the resulting collisions can\n              render
    the network useless for a second or more.\n              Every datagram that is
    broadcast on the connected network\n              should have a valid IP broadcast
    address as its IP\n              destination (see Section 3.3.6).  However, some
    hosts\n              violate this rule.  To be certain to detect broadcast\n              datagrams,
    therefore, hosts are required to check for a\n              link-layer broadcast
    as well as an IP-layer broadcast\n              address.\n         IMPLEMENTATION:\n
    \             This requires that the link layer inform the IP layer when\n              a
    link-layer broadcast datagram has been received; see\n              Section 2.4.\n
    \        3.2.2.1  Destination Unreachable: RFC-792\n            The following
    additional codes are hereby defined:\n                    6 = destination network
    unknown\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                    7
    = destination host unknown\n                    8 = source host isolated\n                    9
    = communication with destination network\n                            administratively
    prohibited\n                   10 = communication with destination host\n                            administratively
    prohibited\n                   11 = network unreachable for type of service\n
    \                  12 = host unreachable for type of service\n            A host
    SHOULD generate Destination Unreachable messages with\n            code:\n            2
    \   (Protocol Unreachable), when the designated transport\n                 protocol
    is not supported; or\n            3    (Port Unreachable), when the designated
    transport\n                 protocol (e.g., UDP) is unable to demultiplex the\n
    \                datagram but has no protocol mechanism to inform the\n                 sender.\n
    \           A Destination Unreachable message that is received MUST be\n            reported
    to the transport layer.  The transport layer SHOULD\n            use the information
    appropriately; for example, see Sections\n            4.1.3.3, 4.2.3.9, and 4.2.4
    below.  A transport protocol\n            that has its own mechanism for notifying
    the sender that a\n            port is unreachable (e.g., TCP, which sends RST
    segments)\n            MUST nevertheless accept an ICMP Port Unreachable for the\n
    \           same purpose.\n            A Destination Unreachable message that
    is received with code\n            0 (Net), 1 (Host), or 5 (Bad Source Route)
    may result from a\n            routing transient and MUST therefore be interpreted
    as only\n            a hint, not proof, that the specified destination is\n            unreachable
    [IP:11].  For example, it MUST NOT be used as\n            proof of a dead gateway
    (see Section 3.3.1).\n         3.2.2.2  Redirect: RFC-792\n            A host
    SHOULD NOT send an ICMP Redirect message; Redirects\n            are to be sent
    only by gateways.\n            A host receiving a Redirect message MUST update
    its routing\n            information accordingly.  Every host MUST be prepared
    to\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            accept
    both Host and Network Redirects and to process them\n            as described
    in Section 3.3.1.2 below.\n            A Redirect message SHOULD be silently discarded
    if the new\n            gateway address it specifies is not on the same connected\n
    \           (sub-) net through which the Redirect arrived [INTRO:2,\n            Appendix
    A], or if the source of the Redirect is not the\n            current first-hop
    gateway for the specified destination (see\n            Section 3.3.1).\n         3.2.2.3
    \ Source Quench: RFC-792\n            A host MAY send a Source Quench message
    if it is\n            approaching, or has reached, the point at which it is forced\n
    \           to discard incoming datagrams due to a shortage of\n            reassembly
    buffers or other resources.  See Section 2.2.3 of\n            [INTRO:2] for suggestions
    on when to send Source Quench.\n            If a Source Quench message is received,
    the IP layer MUST\n            report it to the transport layer (or ICMP processing).
    In\n            general, the transport or application layer SHOULD implement\n
    \           a mechanism to respond to Source Quench for any protocol\n            that
    can send a sequence of datagrams to the same\n            destination and which
    can reasonably be expected to maintain\n            enough state information to
    make this feasible.  See Section\n            4 for the handling of Source Quench
    by TCP and UDP.\n            DISCUSSION:\n                 A Source Quench may
    be generated by the target host or\n                 by some gateway in the path
    of a datagram.  The host\n                 receiving a Source Quench should throttle
    itself back\n                 for a period of time, then gradually increase the\n
    \                transmission rate again.  The mechanism to respond to\n                 Source
    Quench may be in the transport layer (for\n                 connection-oriented
    protocols like TCP) or in the\n                 application layer (for protocols
    that are built on top\n                 of UDP).\n                 A mechanism
    has been proposed [IP:14] to make the IP\n                 layer respond directly
    to Source Quench by controlling\n                 the rate at which datagrams
    are sent, however, this\n                 proposal is currently experimental and
    not currently\n                 recommended.\n         3.2.2.4  Time Exceeded:
    RFC-792\n            An incoming Time Exceeded message MUST be passed to the\n
    \           transport layer.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            DISCUSSION:\n
    \                A gateway will send a Time Exceeded Code 0 (In Transit)\n                 message
    when it discards a datagram due to an expired\n                 TTL field.  This
    indicates either a gateway routing\n                 loop or too small an initial
    TTL value.\n                 A host may receive a Time Exceeded Code 1 (Reassembly\n
    \                Timeout) message from a destination host that has timed\n                 out
    and discarded an incomplete datagram; see Section\n                 3.3.2 below.
    \ In the future, receipt of this message\n                 might be part of some
    \"MTU discovery\" procedure, to\n                 discover the maximum datagram
    size that can be sent on\n                 the path without fragmentation.\n         3.2.2.5
    \ Parameter Problem: RFC-792\n            A host SHOULD generate Parameter Problem
    messages.  An\n            incoming Parameter Problem message MUST be passed to
    the\n            transport layer, and it MAY be reported to the user.\n            DISCUSSION:\n
    \                The ICMP Parameter Problem message is sent to the\n                 source
    host for any problem not specifically covered by\n                 another ICMP
    message.  Receipt of a Parameter Problem\n                 message generally indicates
    some local or remote\n                 implementation error.\n            A new
    variant on the Parameter Problem message is hereby\n            defined:\n              Code
    1 = required option is missing.\n            DISCUSSION:\n                 This
    variant is currently in use in the military\n                 community for a
    missing security option.\n         3.2.2.6  Echo Request/Reply: RFC-792\n            Every
    host MUST implement an ICMP Echo server function that\n            receives Echo
    Requests and sends corresponding Echo Replies.\n            A host SHOULD also
    implement an application-layer interface\n            for sending an Echo Request
    and receiving an Echo Reply, for\n            diagnostic purposes.\n            An
    ICMP Echo Request destined to an IP broadcast or IP\n            multicast address
    MAY be silently discarded.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            DISCUSSION:\n
    \                This neutral provision results from a passionate debate\n                 between
    those who feel that ICMP Echo to a broadcast\n                 address provides
    a valuable diagnostic capability and\n                 those who feel that misuse
    of this feature can too\n                 easily create packet storms.\n            The
    IP source address in an ICMP Echo Reply MUST be the same\n            as the specific-destination
    address (defined in Section\n            3.2.1.3) of the corresponding ICMP Echo
    Request message.\n            Data received in an ICMP Echo Request MUST be entirely\n
    \           included in the resulting Echo Reply.  However, if sending\n            the
    Echo Reply requires intentional fragmentation that is\n            not implemented,
    the datagram MUST be truncated to maximum\n            transmission size (see
    Section 3.3.3) and sent.\n            Echo Reply messages MUST be passed to the
    ICMP user\n            interface, unless the corresponding Echo Request originated\n
    \           in the IP layer.\n            If a Record Route and/or Time Stamp
    option is received in an\n            ICMP Echo Request, this option (these options)
    SHOULD be\n            updated to include the current host and included in the
    IP\n            header of the Echo Reply message, without \"truncation\".\n            Thus,
    the recorded route will be for the entire round trip.\n            If a Source
    Route option is received in an ICMP Echo\n            Request, the return route
    MUST be reversed and used as a\n            Source Route option for the Echo Reply
    message.\n         3.2.2.7  Information Request/Reply: RFC-792\n            A
    host SHOULD NOT implement these messages.\n            DISCUSSION:\n                 The
    Information Request/Reply pair was intended to\n                 support self-configuring
    systems such as diskless\n                 workstations, to allow them to discover
    their IP\n                 network numbers at boot time.  However, the RARP and\n
    \                BOOTP protocols provide better mechanisms for a host to\n                 discover
    its own IP address.\n         3.2.2.8  Timestamp and Timestamp Reply: RFC-792\n
    \           A host MAY implement Timestamp and Timestamp Reply.  If they\n            are
    implemented, the following rules MUST be followed.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            o
    \   The ICMP Timestamp server function returns a Timestamp\n                 Reply
    to every Timestamp message that is received.  If\n                 this function
    is implemented, it SHOULD be designed for\n                 minimum variability
    in delay (e.g., implemented in the\n                 kernel to avoid delay in
    scheduling a user process).\n            The following cases for Timestamp are
    to be handled\n            according to the corresponding rules for ICMP Echo:\n
    \           o    An ICMP Timestamp Request message to an IP broadcast or\n                 IP
    multicast address MAY be silently discarded.\n            o    The IP source address
    in an ICMP Timestamp Reply MUST\n                 be the same as the specific-destination
    address of the\n                 corresponding Timestamp Request message.\n            o
    \   If a Source-route option is received in an ICMP Echo\n                 Request,
    the return route MUST be reversed and used as\n                 a Source Route
    option for the Timestamp Reply message.\n            o    If a Record Route and/or
    Timestamp option is received\n                 in a Timestamp Request, this (these)
    option(s) SHOULD\n                 be updated to include the current host and
    included in\n                 the IP header of the Timestamp Reply message.\n
    \           o    Incoming Timestamp Reply messages MUST be passed up to\n                 the
    ICMP user interface.\n            The preferred form for a timestamp value (the
    \"standard\n            value\") is in units of milliseconds since midnight Universal\n
    \           Time.  However, it may be difficult to provide this value\n            with
    millisecond resolution.  For example, many systems use\n            clocks that
    update only at line frequency, 50 or 60 times\n            per second.  Therefore,
    some latitude is allowed in a\n            \"standard value\":\n            (a)
    \ A \"standard value\" MUST be updated at least 15 times\n                 per
    second (i.e., at most the six low-order bits of the\n                 value may
    be undefined).\n            (b)  The accuracy of a \"standard value\" MUST approximate\n
    \                that of operator-set CPU clocks, i.e., correct within a\n                 few
    minutes.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n         3.2.2.9
    \ Address Mask Request/Reply: RFC-950\n            A host MUST support the first,
    and MAY implement all three,\n            of the following methods for determining
    the address mask(s)\n            corresponding to its IP address(es):\n            (1)
    \ static configuration information;\n            (2)  obtaining the address mask(s)
    dynamically as a side-\n                 effect of the system initialization process
    (see\n                 [INTRO:1]); and\n            (3)  sending ICMP Address
    Mask Request(s) and receiving ICMP\n                 Address Mask Reply(s).\n
    \           The choice of method to be used in a particular host MUST be\n            configurable.\n
    \           When method (3), the use of Address Mask messages, is\n            enabled,
    then:\n            (a)  When it initializes, the host MUST broadcast an Address\n
    \                Mask Request message on the connected network\n                 corresponding
    to the IP address.  It MUST retransmit\n                 this message a small
    number of times if it does not\n                 receive an immediate Address
    Mask Reply.\n            (b)  Until it has received an Address Mask Reply, the
    host\n                 SHOULD assume a mask appropriate for the address class\n
    \                of the IP address, i.e., assume that the connected\n                 network
    is not subnetted.\n            (c)  The first Address Mask Reply message received
    MUST be\n                 used to set the address mask corresponding to the\n
    \                particular local IP address.  This is true even if the\n                 first
    Address Mask Reply message is \"unsolicited\", in\n                 which case
    it will have been broadcast and may arrive\n                 after the host has
    ceased to retransmit Address Mask\n                 Requests.  Once the mask has
    been set by an Address\n                 Mask Reply, later Address Mask Reply
    messages MUST be\n                 (silently) ignored.\n            Conversely,
    if Address Mask messages are disabled, then no\n            ICMP Address Mask
    Requests will be sent, and any ICMP\n            Address Mask Replies received
    for that local IP address MUST\n            be (silently) ignored.\n            A
    host SHOULD make some reasonableness check on any address\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            mask
    it installs; see IMPLEMENTATION section below.\n            A system MUST NOT
    send an Address Mask Reply unless it is an\n            authoritative agent for
    address masks.  An authoritative\n            agent may be a host or a gateway,
    but it MUST be explicitly\n            configured as a address mask agent.  Receiving
    an address\n            mask via an Address Mask Reply does not give the receiver\n
    \           authority and MUST NOT be used as the basis for issuing\n            Address
    Mask Replies.\n            With a statically configured address mask, there SHOULD
    be\n            an additional configuration flag that determines whether the\n
    \           host is to act as an authoritative agent for this mask,\n            i.e.,
    whether it will answer Address Mask Request messages\n            using this mask.\n
    \           If it is configured as an agent, the host MUST broadcast an\n            Address
    Mask Reply for the mask on the appropriate interface\n            when it initializes.\n
    \           See \"System Initialization\" in [INTRO:1] for more\n            information
    about the use of Address Mask Request/Reply\n            messages.\n            DISCUSSION\n
    \                Hosts that casually send Address Mask Replies with\n                 invalid
    address masks have often been a serious\n                 nuisance.  To prevent
    this, Address Mask Replies ought\n                 to be sent only by authoritative
    agents that have been\n                 selected by explicit administrative action.\n
    \                When an authoritative agent receives an Address Mask\n                 Request
    message, it will send a unicast Address Mask\n                 Reply to the source
    IP address.  If the network part of\n                 this address is zero (see
    (a) and (b) in 3.2.1.3), the\n                 Reply will be broadcast.\n                 Getting
    no reply to its Address Mask Request messages,\n                 a host will assume
    there is no agent and use an\n                 unsubnetted mask, but the agent
    may be only temporarily\n                 unreachable.  An agent will broadcast
    an unsolicited\n                 Address Mask Reply whenever it initializes, in
    order to\n                 update the masks of all hosts that have initialized
    in\n                 the meantime.\n            IMPLEMENTATION:\n                 The
    following reasonableness check on an address mask\n                 is suggested:
    the mask is not all 1 bits, and it is\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 either
    zero or else the 8 highest-order bits are on.\n      3.2.3  Internet Group Management
    Protocol IGMP\n         IGMP [IP:4] is a protocol used between hosts and gateways
    on a\n         single network to establish hosts' membership in particular\n         multicast
    groups.  The gateways use this information, in\n         conjunction with a multicast
    routing protocol, to support IP\n         multicasting across the Internet.\n
    \        At this time, implementation of IGMP is OPTIONAL; see Section\n         3.3.7
    for more information.  Without IGMP, a host can still\n         participate in
    multicasting local to its connected networks.\n   3.3  SPECIFIC ISSUES\n      3.3.1
    \ Routing Outbound Datagrams\n         The IP layer chooses the correct next hop
    for each datagram it\n         sends.  If the destination is on a connected network,
    the\n         datagram is sent directly to the destination host; otherwise,\n
    \        it has to be routed to a gateway on a connected network.\n         3.3.1.1
    \ Local/Remote Decision\n            To decide if the destination is on a connected
    network, the\n            following algorithm MUST be used [see IP:3]:\n            (a)
    \ The address mask (particular to a local IP address for\n                 a multihomed
    host) is a 32-bit mask that selects the\n                 network number and subnet
    number fields of the\n                 corresponding IP address.\n            (b)
    \ If the IP destination address bits extracted by the\n                 address
    mask match the IP source address bits extracted\n                 by the same
    mask, then the destination is on the\n                 corresponding connected
    network, and the datagram is to\n                 be transmitted directly to the
    destination host.\n            (c)  If not, then the destination is accessible
    only through\n                 a gateway.  Selection of a gateway is described
    below\n                 (3.3.1.2).\n            A special-case destination address
    is handled as follows:\n            *    For a limited broadcast or a multicast
    address, simply\n                 pass the datagram to the link layer for the
    appropriate\n                 interface.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            *
    \   For a (network or subnet) directed broadcast, the\n                 datagram
    can use the standard routing algorithms.\n            The host IP layer MUST operate
    correctly in a minimal\n            network environment, and in particular, when
    there are no\n            gateways.  For example, if the IP layer of a host insists
    on\n            finding at least one gateway to initialize, the host will be\n
    \           unable to operate on a single isolated broadcast net.\n         3.3.1.2
    \ Gateway Selection\n            To efficiently route a series of datagrams to
    the same\n            destination, the source host MUST keep a \"route cache\"
    of\n            mappings to next-hop gateways.  A host uses the following\n            basic
    algorithm on this cache to route a datagram; this\n            algorithm is designed
    to put the primary routing burden on\n            the gateways [IP:11].\n            (a)
    \ If the route cache contains no information for a\n                 particular
    destination, the host chooses a \"default\"\n                 gateway and sends
    the datagram to it.  It also builds a\n                 corresponding Route Cache
    entry.\n            (b)  If that gateway is not the best next hop to the\n                 destination,
    the gateway will forward the datagram to\n                 the best next-hop gateway
    and return an ICMP Redirect\n                 message to the source host.\n            (c)
    \ When it receives a Redirect, the host updates the\n                 next-hop
    gateway in the appropriate route cache entry,\n                 so later datagrams
    to the same destination will go\n                 directly to the best gateway.\n
    \           Since the subnet mask appropriate to the destination address\n            is
    generally not known, a Network Redirect message SHOULD be\n            treated
    identically to a Host Redirect message; i.e., the\n            cache entry for
    the destination host (only) would be updated\n            (or created, if an entry
    for that host did not exist) for\n            the new gateway.\n            DISCUSSION:\n
    \                This recommendation is to protect against gateways that\n                 erroneously
    send Network Redirects for a subnetted\n                 network, in violation
    of the gateway requirements\n                 [INTRO:2].\n            When there
    is no route cache entry for the destination host\n            address (and the
    destination is not on the connected\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            network),
    the IP layer MUST pick a gateway from its list of\n            \"default\" gateways.
    \ The IP layer MUST support multiple\n            default gateways.\n            As
    an extra feature, a host IP layer MAY implement a table\n            of \"static
    routes\".  Each such static route MAY include a\n            flag specifying whether
    it may be overridden by ICMP\n            Redirects.\n            DISCUSSION:\n
    \                A host generally needs to know at least one default\n                 gateway
    to get started.  This information can be\n                 obtained from a configuration
    file or else from the\n                 host startup sequence, e.g., the BOOTP
    protocol (see\n                 [INTRO:1]).\n                 It has been suggested
    that a host can augment its list\n                 of default gateways by recording
    any new gateways it\n                 learns about.  For example, it can record
    every gateway\n                 to which it is ever redirected.  Such a feature,
    while\n                 possibly useful in some circumstances, may cause\n                 problems
    in other cases (e.g., gateways are not all\n                 equal), and it is
    not recommended.\n                 A static route is typically a particular preset
    mapping\n                 from destination host or network into a particular\n
    \                next-hop gateway; it might also depend on the Type-of-\n                 Service
    (see next section).  Static routes would be set\n                 up by system
    administrators to override the normal\n                 automatic routing mechanism,
    to handle exceptional\n                 situations.  However, any static routing
    information is\n                 a potential source of failure as configurations
    change\n                 or equipment fails.\n         3.3.1.3  Route Cache\n
    \           Each route cache entry needs to include the following\n            fields:\n
    \           (1)  Local IP address (for a multihomed host)\n            (2)  Destination
    IP address\n            (3)  Type(s)-of-Service\n            (4)  Next-hop gateway
    IP address\n            Field (2) MAY be the full IP address of the destination\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            host,
    or only the destination network number.  Field (3),\n            the TOS, SHOULD
    be included.\n            See Section 3.3.4.2 for a discussion of the implications
    of\n            multihoming for the lookup procedure in this cache.\n            DISCUSSION:\n
    \                Including the Type-of-Service field in the route cache\n                 and
    considering it in the host route algorithm will\n                 provide the
    necessary mechanism for the future when\n                 Type-of-Service routing
    is commonly used in the\n                 Internet.  See Section 3.2.1.6.\n                 Each
    route cache entry defines the endpoints of an\n                 Internet path.
    \ Although the connecting path may change\n                 dynamically in an
    arbitrary way, the transmission\n                 characteristics of the path
    tend to remain\n                 approximately constant over a time period longer
    than a\n                 single typical host-host transport connection.\n                 Therefore,
    a route cache entry is a natural place to\n                 cache data on the
    properties of the path.  Examples of\n                 such properties might be
    the maximum unfragmented\n                 datagram size (see Section 3.3.3),
    or the average\n                 round-trip delay measured by a transport protocol.\n
    \                This data will generally be both gathered and used by a\n                 higher
    layer protocol, e.g., by TCP, or by an\n                 application using UDP.
    \ Experiments are currently in\n                 progress on caching path properties
    in this manner.\n                 There is no consensus on whether the route cache
    should\n                 be keyed on destination host addresses alone, or allow\n
    \                both host and network addresses.  Those who favor the\n                 use
    of only host addresses argue that:\n                 (1)  As required in Section
    3.3.1.2, Redirect messages\n                      will generally result in entries
    keyed on\n                      destination host addresses; the simplest and most\n
    \                     general scheme would be to use host addresses\n                      always.\n
    \                (2)  The IP layer may not always know the address mask\n                      for
    a network address in a complex subnetted\n                      environment.\n
    \                (3)  The use of only host addresses allows the\n                      destination
    address to be used as a pure 32-bit\n                      number, which may allow
    the Internet architecture\n                      to be more easily extended in
    the future without\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                      any
    change to the hosts.\n                 The opposing view is that allowing a mixture
    of\n                 destination hosts and networks in the route cache:\n                 (1)
    \ Saves memory space.\n                 (2)  Leads to a simpler data structure,
    easily\n                      combining the cache with the tables of default and\n
    \                     static routes (see below).\n                 (3)  Provides
    a more useful place to cache path\n                      properties, as discussed
    earlier.\n            IMPLEMENTATION:\n                 The cache needs to be
    large enough to include entries\n                 for the maximum number of destination
    hosts that may be\n                 in use at one time.\n                 A route
    cache entry may also include control\n                 information used to choose
    an entry for replacement.\n                 This might take the form of a \"recently
    used\" bit, a\n                 use count, or a last-used timestamp, for example.
    \ It\n                 is recommended that it include the time of last\n                 modification
    of the entry, for diagnostic purposes.\n                 An implementation may
    wish to reduce the overhead of\n                 scanning the route cache for
    every datagram to be\n                 transmitted.  This may be accomplished
    with a hash\n                 table to speed the lookup, or by giving a connection-\n
    \                oriented transport protocol a \"hint\" or temporary\n                 handle
    on the appropriate cache entry, to be passed to\n                 the IP layer
    with each subsequent datagram.\n                 Although we have described the
    route cache, the lists\n                 of default gateways, and a table of static
    routes as\n                 conceptually distinct, in practice they may be combined\n
    \                into a single \"routing table\" data structure.\n         3.3.1.4
    \ Dead Gateway Detection\n            The IP layer MUST be able to detect the
    failure of a \"next-\n            hop\" gateway that is listed in its route cache
    and to choose\n            an alternate gateway (see Section 3.3.1.5).\n            Dead
    gateway detection is covered in some detail in RFC-816\n            [IP:11]. Experience
    to date has not produced a complete\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            algorithm
    which is totally satisfactory, though it has\n            identified several forbidden
    paths and promising techniques.\n            *    A particular gateway SHOULD
    NOT be used indefinitely in\n                 the absence of positive indications
    that it is\n                 functioning.\n            *    Active probes such
    as \"pinging\" (i.e., using an ICMP\n                 Echo Request/Reply exchange)
    are expensive and scale\n                 poorly.  In particular, hosts MUST NOT
    actively check\n                 the status of a first-hop gateway by simply pinging
    the\n                 gateway continuously.\n            *    Even when it is
    the only effective way to verify a\n                 gateway's status, pinging
    MUST be used only when\n                 traffic is being sent to the gateway
    and when there is\n                 no other positive indication to suggest that
    the\n                 gateway is functioning.\n            *    To avoid pinging,
    the layers above and/or below the\n                 Internet layer SHOULD be able
    to give \"advice\" on the\n                 status of route cache entries when
    either positive\n                 (gateway OK) or negative (gateway dead) information
    is\n                 available.\n            DISCUSSION:\n                 If
    an implementation does not include an adequate\n                 mechanism for
    detecting a dead gateway and re-routing,\n                 a gateway failure may
    cause datagrams to apparently\n                 vanish into a \"black hole\".
    \ This failure can be\n                 extremely confusing for users and difficult
    for network\n                 personnel to debug.\n                 The dead-gateway
    detection mechanism must not cause\n                 unacceptable load on the
    host, on connected networks,\n                 or on first-hop gateway(s).  The
    exact constraints on\n                 the timeliness of dead gateway detection
    and on\n                 acceptable load may vary somewhat depending on the\n
    \                nature of the host's mission, but a host generally\n                 needs
    to detect a failed first-hop gateway quickly\n                 enough that transport-layer
    connections will not break\n                 before an alternate gateway can be
    selected.\n                 Passing advice from other layers of the protocol stack\n
    \                complicates the interfaces between the layers, but it\n                 is
    the preferred approach to dead gateway detection.\n                 Advice can
    come from almost any part of the IP/TCP\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 architecture,
    but it is expected to come primarily from\n                 the transport and
    link layers.  Here are some possible\n                 sources for gateway advice:\n
    \                o    TCP or any connection-oriented transport protocol\n                      should
    be able to give negative advice, e.g.,\n                      triggered by excessive
    retransmissions.\n                 o    TCP may give positive advice when (new)
    data is\n                      acknowledged.  Even though the route may be\n                      asymmetric,
    an ACK for new data proves that the\n                      acknowleged data must
    have been transmitted\n                      successfully.\n                 o
    \   An ICMP Redirect message from a particular gateway\n                      should
    be used as positive advice about that\n                      gateway.\n                 o
    \   Link-layer information that reliably detects and\n                      reports
    host failures (e.g., ARPANET Destination\n                      Dead messages)
    should be used as negative advice.\n                 o    Failure to ARP or to
    re-validate ARP mappings may\n                      be used as negative advice
    for the corresponding\n                      IP address.\n                 o    Packets
    arriving from a particular link-layer\n                      address are evidence
    that the system at this\n                      address is alive.  However, turning
    this\n                      information into advice about gateways requires\n
    \                     mapping the link-layer address into an IP address,\n                      and
    then checking that IP address against the\n                      gateways pointed
    to by the route cache.  This is\n                      probably prohibitively
    inefficient.\n                 Note that positive advice that is given for every\n
    \                datagram received may cause unacceptable overhead in\n                 the
    implementation.\n                 While advice might be passed using required
    arguments\n                 in all interfaces to the IP layer, some transport
    and\n                 application layer protocols cannot deduce the correct\n
    \                advice.  These interfaces must therefore allow a\n                 neutral
    value for advice, since either always-positive\n                 or always-negative
    advice leads to incorrect behavior.\n                 There is another technique
    for dead gateway detection\n                 that has been commonly used but is
    not recommended.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 This
    technique depends upon the host passively\n                 receiving (\"wiretapping\")
    the Interior Gateway Protocol\n                 (IGP) datagrams that the gateways
    are broadcasting to\n                 each other.  This approach has the drawback
    that a host\n                 needs to recognize all the interior gateway protocols\n
    \                that gateways may use (see [INTRO:2]).  In addition, it\n                 only
    works on a broadcast network.\n                 At present, pinging (i.e., using
    ICMP Echo messages) is\n                 the mechanism for gateway probing when
    absolutely\n                 required.  A successful ping guarantees that the\n
    \                addressed interface and its associated machine are up,\n                 but
    it does not guarantee that the machine is a gateway\n                 as opposed
    to a host.  The normal inference is that if\n                 a Redirect or other
    evidence indicates that a machine\n                 was a gateway, successful
    pings will indicate that the\n                 machine is still up and hence still
    a gateway.\n                 However, since a host silently discards packets that
    a\n                 gateway would forward or redirect, this assumption\n                 could
    sometimes fail.  To avoid this problem, a new\n                 ICMP message under
    development will ask \"are you a\n                 gateway?\"\n            IMPLEMENTATION:\n
    \                The following specific algorithm has been suggested:\n                 o
    \   Associate a \"reroute timer\" with each gateway\n                      pointed
    to by the route cache.  Initialize the\n                      timer to a value
    Tr, which must be small enough to\n                      allow detection of a
    dead gateway before transport\n                      connections time out.\n                 o
    \   Positive advice would reset the reroute timer to\n                      Tr.
    \ Negative advice would reduce or zero the\n                      reroute timer.\n
    \                o    Whenever the IP layer used a particular gateway to\n                      route
    a datagram, it would check the corresponding\n                      reroute timer.
    \ If the timer had expired (reached\n                      zero), the IP layer
    would send a ping to the\n                      gateway, followed immediately
    by the datagram.\n                 o    The ping (ICMP Echo) would be sent again
    if\n                      necessary, up to N times.  If no ping reply was\n                      received
    in N tries, the gateway would be assumed\n                      to have failed,
    and a new first-hop gateway would\n                      be chosen for all cache
    entries pointing to the\n                      failed gateway.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 Note
    that the size of Tr is inversely related to the\n                 amount of advice
    available.  Tr should be large enough\n                 to insure that:\n                 *
    \   Any pinging will be at a low level (e.g., <10%) of\n                      all
    packets sent to a gateway from the host, AND\n                 *    pinging is
    infrequent (e.g., every 3 minutes)\n                 Since the recommended algorithm
    is concerned with the\n                 gateways pointed to by route cache entries,
    rather than\n                 the cache entries themselves, a two level data\n
    \                structure (perhaps coordinated with ARP or similar\n                 caches)
    may be desirable for implementing a route\n                 cache.\n         3.3.1.5
    \ New Gateway Selection\n            If the failed gateway is not the current
    default, the IP\n            layer can immediately switch to a default gateway.
    \ If it is\n            the current default that failed, the IP layer MUST select
    a\n            different default gateway (assuming more than one default is\n
    \           known) for the failed route and for establishing new routes.\n            DISCUSSION:\n
    \                When a gateway does fail, the other gateways on the\n                 connected
    network will learn of the failure through\n                 some inter-gateway
    routing protocol.  However, this\n                 will not happen instantaneously,
    since gateway routing\n                 protocols typically have a settling time
    of 30-60\n                 seconds.  If the host switches to an alternative\n
    \                gateway before the gateways have agreed on the failure,\n                 the
    new target gateway will probably forward the\n                 datagram to the
    failed gateway and send a Redirect back\n                 to the host pointing
    to the failed gateway (!).  The\n                 result is likely to be a rapid
    oscillation in the\n                 contents of the host's route cache during
    the gateway\n                 settling period.  It has been proposed that the
    dead-\n                 gateway logic should include some hysteresis mechanism\n
    \                to prevent such oscillations.  However, experience has\n                 not
    shown any harm from such oscillations, since\n                 service cannot
    be restored to the host until the\n                 gateways' routing information
    does settle down.\n            IMPLEMENTATION:\n                 One implementation
    technique for choosing a new default\n                 gateway is to simply round-robin
    among the default\n                 gateways in the host's list.  Another is to
    rank the\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 gateways
    in priority order, and when the current\n                 default gateway is not
    the highest priority one, to\n                 \"ping\" the higher-priority gateways
    slowly to detect\n                 when they return to service.  This pinging
    can be at a\n                 very low rate, e.g., 0.005 per second.\n         3.3.1.6
    \ Initialization\n            The following information MUST be configurable:\n
    \           (1)  IP address(es).\n            (2)  Address mask(s).\n            (3)
    \ A list of default gateways, with a preference level.\n            A manual method
    of entering this configuration data MUST be\n            provided.  In addition,
    a variety of methods can be used to\n            determine this information dynamically;
    see the section on\n            \"Host Initialization\" in [INTRO:1].\n            DISCUSSION:\n
    \                Some host implementations use \"wiretapping\" of gateway\n                 protocols
    on a broadcast network to learn what gateways\n                 exist.  A standard
    method for default gateway discovery\n                 is under development.\n
    \     3.3.2  Reassembly\n         The IP layer MUST implement reassembly of IP
    datagrams.\n         We designate the largest datagram size that can be reassembled\n
    \        by EMTU_R (\"Effective MTU to receive\"); this is sometimes\n         called
    the \"reassembly buffer size\".  EMTU_R MUST be greater\n         than or equal
    to 576, SHOULD be either configurable or\n         indefinite, and SHOULD be greater
    than or equal to the MTU of\n         the connected network(s).\n         DISCUSSION:\n
    \             A fixed EMTU_R limit should not be built into the code\n              because
    some application layer protocols require EMTU_R\n              values larger than
    576.\n         IMPLEMENTATION:\n              An implementation may use a contiguous
    reassembly buffer\n              for each datagram, or it may use a more complex
    data\n              structure that places no definite limit on the reassembled\n
    \             datagram size; in the latter case, EMTU_R is said to be\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n              \"indefinite\".\n
    \             Logically, reassembly is performed by simply copying each\n              fragment
    into the packet buffer at the proper offset.\n              Note that fragments
    may overlap if successive\n              retransmissions use different packetizing
    but the same\n              reassembly Id.\n              The tricky part of reassembly
    is the bookkeeping to\n              determine when all bytes of the datagram
    have been\n              reassembled.  We recommend Clark's algorithm [IP:10]
    that\n              requires no additional data space for the bookkeeping.\n              However,
    note that, contrary to [IP:10], the first\n              fragment header needs
    to be saved for inclusion in a\n              possible ICMP Time Exceeded (Reassembly
    Timeout) message.\n         There MUST be a mechanism by which the transport layer
    can\n         learn MMS_R, the maximum message size that can be received and\n
    \        reassembled in an IP datagram (see GET_MAXSIZES calls in\n         Section
    3.4).  If EMTU_R is not indefinite, then the value of\n         MMS_R is given
    by:\n            MMS_R = EMTU_R - 20\n         since 20 is the minimum size of
    an IP header.\n         There MUST be a reassembly timeout.  The reassembly timeout\n
    \        value SHOULD be a fixed value, not set from the remaining TTL.\n         It
    is recommended that the value lie between 60 seconds and 120\n         seconds.
    \ If this timeout expires, the partially-reassembled\n         datagram MUST be
    discarded and an ICMP Time Exceeded message\n         sent to the source host
    (if fragment zero has been received).\n         DISCUSSION:\n              The
    IP specification says that the reassembly timeout\n              should be the
    remaining TTL from the IP header, but this\n              does not work well because
    gateways generally treat TTL as\n              a simple hop count rather than
    an elapsed time.  If the\n              reassembly timeout is too small, datagrams
    will be\n              discarded unnecessarily, and communication may fail.  The\n
    \             timeout needs to be at least as large as the typical\n              maximum
    delay across the Internet.  A realistic minimum\n              reassembly timeout
    would be 60 seconds.\n              It has been suggested that a cache might be
    kept of\n              round-trip times measured by transport protocols for\n
    \             various destinations, and that these values might be used\n              to
    dynamically determine a reasonable reassembly timeout\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n              value.
    \ Further investigation of this approach is\n              required.\n              If
    the reassembly timeout is set too high, buffer\n              resources in the
    receiving host will be tied up too long,\n              and the MSL (Maximum Segment
    Lifetime) [TCP:1] will be\n              larger than necessary.  The MSL controls
    the maximum rate\n              at which fragmented datagrams can be sent using
    distinct\n              values of the 16-bit Ident field; a larger MSL lowers
    the\n              maximum rate.  The TCP specification [TCP:1] arbitrarily\n
    \             assumes a value of 2 minutes for MSL.  This sets an upper\n              limit
    on a reasonable reassembly timeout value.\n      3.3.3  Fragmentation\n         Optionally,
    the IP layer MAY implement a mechanism to fragment\n         outgoing datagrams
    intentionally.\n         We designate by EMTU_S (\"Effective MTU for sending\")
    the\n         maximum IP datagram size that may be sent, for a particular\n         combination
    of IP source and destination addresses and perhaps\n         TOS.\n         A
    host MUST implement a mechanism to allow the transport layer\n         to learn
    MMS_S, the maximum transport-layer message size that\n         may be sent for
    a given {source, destination, TOS} triplet (see\n         GET_MAXSIZES call in
    Section 3.4).  If no local fragmentation\n         is performed, the value of
    MMS_S will be:\n            MMS_S = EMTU_S - <IP header size>\n         and EMTU_S
    must be less than or equal to the MTU of the network\n         interface corresponding
    to the source address of the datagram.\n         Note that <IP header size> in
    this equation will be 20, unless\n         the IP reserves space to insert IP
    options for its own purposes\n         in addition to any options inserted by
    the transport layer.\n         A host that does not implement local fragmentation
    MUST ensure\n         that the transport layer (for TCP) or the application layer\n
    \        (for UDP) obtains MMS_S from the IP layer and does not send a\n         datagram
    exceeding MMS_S in size.\n         It is generally desirable to avoid local fragmentation
    and to\n         choose EMTU_S low enough to avoid fragmentation in any gateway\n
    \        along the path.  In the absence of actual knowledge of the\n         minimum
    MTU along the path, the IP layer SHOULD use\n         EMTU_S <= 576 whenever the
    destination address is not on a\n         connected network, and otherwise use
    the connected network's\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n         MTU.\n
    \        The MTU of each physical interface MUST be configurable.\n         A
    host IP layer implementation MAY have a configuration flag\n         \"All-Subnets-MTU\",
    indicating that the MTU of the connected\n         network is to be used for destinations
    on different subnets\n         within the same network, but not for other networks.
    \ Thus,\n         this flag causes the network class mask, rather than the subnet\n
    \        address mask, to be used to choose an EMTU_S.  For a multihomed\n         host,
    an \"All-Subnets-MTU\" flag is needed for each network\n         interface.\n
    \        DISCUSSION:\n              Picking the correct datagram size to use when
    sending data\n              is a complex topic [IP:9].\n              (a)  In
    general, no host is required to accept an IP\n                   datagram larger
    than 576 bytes (including header and\n                   data), so a host must
    not send a larger datagram\n                   without explicit knowledge or prior
    arrangement with\n                   the destination host.  Thus, MMS_S is only
    an upper\n                   bound on the datagram size that a transport protocol\n
    \                  may send; even when MMS_S exceeds 556, the transport\n                   layer
    must limit its messages to 556 bytes in the\n                   absence of other
    knowledge about the destination\n                   host.\n              (b)  Some
    transport protocols (e.g., TCP) provide a way to\n                   explicitly
    inform the sender about the largest\n                   datagram the other end
    can receive and reassemble\n                   [IP:7].  There is no corresponding
    mechanism in the\n                   IP layer.\n                   A transport
    protocol that assumes an EMTU_R larger\n                   than 576 (see Section
    3.3.2), can send a datagram of\n                   this larger size to another
    host that implements the\n                   same protocol.\n              (c)
    \ Hosts should ideally limit their EMTU_S for a given\n                   destination
    to the minimum MTU of all the networks\n                   along the path, to
    avoid any fragmentation.  IP\n                   fragmentation, while formally
    correct, can create a\n                   serious transport protocol performance
    problem,\n                   because loss of a single fragment means all the\n
    \                  fragments in the segment must be retransmitted\n                   [IP:9].\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n              Since
    nearly all networks in the Internet currently\n              support an MTU of
    576 or greater, we strongly recommend\n              the use of 576 for datagrams
    sent to non-local networks.\n              It has been suggested that a host could
    determine the MTU\n              over a given path by sending a zero-offset datagram\n
    \             fragment and waiting for the receiver to time out the\n              reassembly
    (which cannot complete!) and return an ICMP\n              Time Exceeded message.
    \ This message would include the\n              largest remaining fragment header
    in its body.  More\n              direct mechanisms are being experimented with,
    but have\n              not yet been adopted (see e.g., RFC-1063).\n      3.3.4
    \ Local Multihoming\n         3.3.4.1  Introduction\n            A multihomed
    host has multiple IP addresses, which we may\n            think of as \"logical
    interfaces\".  These logical interfaces\n            may be associated with one
    or more physical interfaces, and\n            these physical interfaces may be
    connected to the same or\n            different networks.\n            Here are
    some important cases of multihoming:\n            (a)  Multiple Logical Networks\n
    \                The Internet architects envisioned that each physical\n                 network
    would have a single unique IP network (or\n                 subnet) number.  However,
    LAN administrators have\n                 sometimes found it useful to violate
    this assumption,\n                 operating a LAN with multiple logical networks
    per\n                 physical connected network.\n                 If a host
    connected to such a physical network is\n                 configured to handle
    traffic for each of N different\n                 logical networks, then the host
    will have N logical\n                 interfaces.  These could share a single
    physical\n                 interface, or might use N physical interfaces to the\n
    \                same network.\n            (b)  Multiple Logical Hosts\n                 When
    a host has multiple IP addresses that all have the\n                 same <Network-number>
    part (and the same <Subnet-\n                 number> part, if any), the logical
    interfaces are known\n                 as \"logical hosts\".  These logical interfaces
    might\n                 share a single physical interface or might use separate\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 physical
    interfaces to the same physical network.\n            (c)  Simple Multihoming\n
    \                In this case, each logical interface is mapped into a\n                 separate
    physical interface and each physical interface\n                 is connected
    to a different physical network.  The term\n                 \"multihoming\" was
    originally applied only to this case,\n                 but it is now applied
    more generally.\n                 A host with embedded gateway functionality will\n
    \                typically fall into the simple multihoming case.  Note,\n                 however,
    that a host may be simply multihomed without\n                 containing an embedded
    gateway, i.e., without\n                 forwarding datagrams from one connected
    network to\n                 another.\n                 This case presents the
    most difficult routing problems.\n                 The choice of interface (i.e.,
    the choice of first-hop\n                 network) may significantly affect performance
    or even\n                 reachability of remote parts of the Internet.\n            Finally,
    we note another possibility that is NOT\n            multihoming:  one logical
    interface may be bound to multiple\n            physical interfaces, in order
    to increase the reliability or\n            throughput between directly connected
    machines by providing\n            alternative physical paths between them.  For
    instance, two\n            systems might be connected by multiple point-to-point
    links.\n            We call this \"link-layer multiplexing\".  With link-layer\n
    \           multiplexing, the protocols above the link layer are unaware\n            that
    multiple physical interfaces are present; the link-\n            layer device
    driver is responsible for multiplexing and\n            routing packets across
    the physical interfaces.\n            In the Internet protocol architecture, a
    transport protocol\n            instance (\"entity\") has no address of its own,
    but instead\n            uses a single Internet Protocol (IP) address.  This has\n
    \           implications for the IP, transport, and application layers,\n            and
    for the interfaces between them.  In particular, the\n            application
    software may have to be aware of the multiple IP\n            addresses of a multihomed
    host; in other cases, the choice\n            can be made within the network software.\n
    \        3.3.4.2  Multihoming Requirements\n            The following general
    rules apply to the selection of an IP\n            source address for sending
    a datagram from a multihomed\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n            host.\n
    \           (1)  If the datagram is sent in response to a received\n                 datagram,
    the source address for the response SHOULD be\n                 the specific-destination
    address of the request.  See\n                 Sections 4.1.3.5 and 4.2.3.7 and
    the \"General Issues\"\n                 section of [INTRO:1] for more specific
    requirements on\n                 higher layers.\n                 Otherwise,
    a source address must be selected.\n            (2)  An application MUST be able
    to explicitly specify the\n                 source address for initiating a connection
    or a\n                 request.\n            (3)  In the absence of such a specification,
    the networking\n                 software MUST choose a source address.  Rules
    for this\n                 choice are described below.\n            There are
    two key requirement issues related to multihoming:\n            (A)  A host MAY
    silently discard an incoming datagram whose\n                 destination address
    does not correspond to the physical\n                 interface through which
    it is received.\n            (B)  A host MAY restrict itself to sending (non-source-\n
    \                routed) IP datagrams only through the physical\n                 interface
    that corresponds to the IP source address of\n                 the datagrams.\n
    \           DISCUSSION:\n                 Internet host implementors have used
    two different\n                 conceptual models for multihoming, briefly summarized\n
    \                in the following discussion.  This document takes no\n                 stand
    on which model is preferred; each seems to have a\n                 place.  This
    ambivalence is reflected in the issues (A)\n                 and (B) being optional.\n
    \                o    Strong ES Model\n                      The Strong ES (End
    System, i.e., host) model\n                      emphasizes the host/gateway (ES/IS)
    distinction,\n                      and would therefore substitute MUST for MAY
    in\n                      issues (A) and (B) above.  It tends to model a\n                      multihomed
    host as a set of logical hosts within\n                      the same physical
    host.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                      With
    respect to (A), proponents of the Strong ES\n                      model note
    that automatic Internet routing\n                      mechanisms could not route
    a datagram to a\n                      physical interface that did not correspond
    to the\n                      destination address.\n                      Under
    the Strong ES model, the route computation\n                      for an outgoing
    datagram is the mapping:\n                         route(src IP addr, dest IP
    addr, TOS)\n                                                        -> gateway\n
    \                     Here the source address is included as a parameter\n                      in
    order to select a gateway that is directly\n                      reachable on
    the corresponding physical interface.\n                      Note that this model
    logically requires that in\n                      general there be at least one
    default gateway, and\n                      preferably multiple defaults, for
    each IP source\n                      address.\n                 o    Weak ES
    Model\n                      This view de-emphasizes the ES/IS distinction, and\n
    \                     would therefore substitute MUST NOT for MAY in\n                      issues
    (A) and (B).  This model may be the more\n                      natural one for
    hosts that wiretap gateway routing\n                      protocols, and is necessary
    for hosts that have\n                      embedded gateway functionality.\n                      The
    Weak ES Model may cause the Redirect mechanism\n                      to fail.
    \ If a datagram is sent out a physical\n                      interface that does
    not correspond to the\n                      destination address, the first-hop
    gateway will\n                      not realize when it needs to send a Redirect.
    \ On\n                      the other hand, if the host has embedded gateway\n
    \                     functionality, then it has routing information\n                      without
    listening to Redirects.\n                      In the Weak ES model, the route
    computation for an\n                      outgoing datagram is the mapping:\n
    \                        route(dest IP addr, TOS) -> gateway, interface\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n         3.3.4.3
    \ Choosing a Source Address\n            DISCUSSION:\n                 When it
    sends an initial connection request (e.g., a\n                 TCP \"SYN\" segment)
    or a datagram service request (e.g.,\n                 a UDP-based query), the
    transport layer on a multihomed\n                 host needs to know which source
    address to use.  If the\n                 application does not specify it, the
    transport layer\n                 must ask the IP layer to perform the conceptual\n
    \                mapping:\n                     GET_SRCADDR(remote IP addr, TOS)\n
    \                                              -> local IP address\n                 Here
    TOS is the Type-of-Service value (see Section\n                 3.2.1.6), and
    the result is the desired source address.\n                 The following rules
    are suggested for implementing this\n                 mapping:\n                 (a)
    \ If the remote Internet address lies on one of the\n                      (sub-)
    nets to which the host is directly\n                      connected, a corresponding
    source address may be\n                      chosen, unless the corresponding
    interface is\n                      known to be down.\n                 (b)  The
    route cache may be consulted, to see if there\n                      is an active
    route to the specified destination\n                      network through any
    network interface; if so, a\n                      local IP address corresponding
    to that interface\n                      may be chosen.\n                 (c)
    \ The table of static routes, if any (see Section\n                      3.3.1.2)
    may be similarly consulted.\n                 (d)  The default gateways may be
    consulted.  If these\n                      gateways are assigned to different
    interfaces, the\n                      interface corresponding to the gateway
    with the\n                      highest preference may be chosen.\n                 In
    the future, there may be a defined way for a\n                 multihomed host
    to ask the gateways on all connected\n                 networks for advice about
    the best network to use for a\n                 given destination.\n            IMPLEMENTATION:\n
    \                It will be noted that this process is essentially the\n                 same
    as datagram routing (see Section 3.3.1), and\n                 therefore hosts
    may be able to combine the\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                 implementation
    of the two functions.\n      3.3.5  Source Route Forwarding\n         Subject
    to restrictions given below, a host MAY be able to act\n         as an intermediate
    hop in a source route, forwarding a source-\n         routed datagram to the next
    specified hop.\n         However, in performing this gateway-like function, the
    host\n         MUST obey all the relevant rules for a gateway forwarding\n         source-routed
    datagrams [INTRO:2].  This includes the following\n         specific provisions,
    which override the corresponding host\n         provisions given earlier in this
    document:\n         (A)  TTL (ref. Section 3.2.1.7)\n              The TTL field
    MUST be decremented and the datagram perhaps\n              discarded as specified
    for a gateway in [INTRO:2].\n         (B)  ICMP Destination Unreachable (ref.
    Section 3.2.2.1)\n              A host MUST be able to generate Destination Unreachable\n
    \             messages with the following codes:\n              4    (Fragmentation
    Required but DF Set) when a source-\n                   routed datagram cannot
    be fragmented to fit into the\n                   target network;\n              5
    \   (Source Route Failed) when a source-routed datagram\n                   cannot
    be forwarded, e.g., because of a routing\n                   problem or because
    the next hop of a strict source\n                   route is not on a connected
    network.\n         (C)  IP Source Address (ref. Section 3.2.1.3)\n              A
    source-routed datagram being forwarded MAY (and normally\n              will)
    have a source address that is not one of the IP\n              addresses of the
    forwarding host.\n         (D)  Record Route Option (ref. Section 3.2.1.8d)\n
    \             A host that is forwarding a source-routed datagram\n              containing
    a Record Route option MUST update that option,\n              if it has room.\n
    \        (E)  Timestamp Option (ref. Section 3.2.1.8e)\n              A host that
    is forwarding a source-routed datagram\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n              containing
    a Timestamp Option MUST add the current\n              timestamp to that option,
    according to the rules for this\n              option.\n         To define the
    rules restricting host forwarding of source-\n         routed datagrams, we use
    the term \"local source-routing\" if the\n         next hop will be through the
    same physical interface through\n         which the datagram arrived; otherwise,
    it is \"non-local\n         source-routing\".\n         o    A host is permitted
    to perform local source-routing\n              without restriction.\n         o
    \   A host that supports non-local source-routing MUST have a\n              configurable
    switch to disable forwarding, and this switch\n              MUST default to disabled.\n
    \        o    The host MUST satisfy all gateway requirements for\n              configurable
    policy filters [INTRO:2] restricting non-\n              local forwarding.\n         If
    a host receives a datagram with an incomplete source route\n         but does
    not forward it for some reason, the host SHOULD return\n         an ICMP Destination
    Unreachable (code 5, Source Route Failed)\n         message, unless the datagram
    was itself an ICMP error message.\n      3.3.6  Broadcasts\n         Section 3.2.1.3
    defined the four standard IP broadcast address\n         forms:\n           Limited
    Broadcast:  {-1, -1}\n           Directed Broadcast:  {<Network-number>,-1}\n
    \          Subnet Directed Broadcast:\n                              {<Network-number>,<Subnet-number>,-1}\n
    \          All-Subnets Directed Broadcast: {<Network-number>,-1,-1}\n         A
    host MUST recognize any of these forms in the destination\n         address of
    an incoming datagram.\n         There is a class of hosts* that use non-standard
    broadcast\n         address forms, substituting 0 for -1.  All hosts SHOULD\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - '_________________________

    '
  title: _________________________
- contents:
  - '*4.2BSD Unix and its derivatives, but not 4.3BSD.

    '
  title: '*4.2BSD Unix and its derivatives, but not 4.3BSD.'
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n         recognize
    and accept any of these non-standard broadcast\n         addresses as the destination
    address of an incoming datagram.\n         A host MAY optionally have a configuration
    option to choose the\n         0 or the -1 form of broadcast address, for each
    physical\n         interface, but this option SHOULD default to the standard (-1)\n
    \        form.\n         When a host sends a datagram to a link-layer broadcast
    address,\n         the IP destination address MUST be a legal IP broadcast or
    IP\n         multicast address.\n         A host SHOULD silently discard a datagram
    that is received via\n         a link-layer broadcast (see Section 2.4) but does
    not specify\n         an IP multicast or broadcast destination address.\n         Hosts
    SHOULD use the Limited Broadcast address to broadcast to\n         a connected
    network.\n         DISCUSSION:\n              Using the Limited Broadcast address
    instead of a Directed\n              Broadcast address may improve system robustness.
    \ Problems\n              are often caused by machines that do not understand
    the\n              plethora of broadcast addresses (see Section 3.2.1.3), or\n
    \             that may have different ideas about which broadcast\n              addresses
    are in use.  The prime example of the latter is\n              machines that do
    not understand subnetting but are\n              attached to a subnetted net.
    \ Sending a Subnet Broadcast\n              for the connected network will confuse
    those machines,\n              which will see it as a message to some other host.\n
    \             There has been discussion on whether a datagram addressed\n              to
    the Limited Broadcast address ought to be sent from all\n              the interfaces
    of a multihomed host.  This specification\n              takes no stand on the
    issue.\n      3.3.7  IP Multicasting\n         A host SHOULD support local IP
    multicasting on all connected\n         networks for which a mapping from Class
    D IP addresses to\n         link-layer addresses has been specified (see below).
    \ Support\n         for local IP multicasting includes sending multicast datagrams,\n
    \        joining multicast groups and receiving multicast datagrams, and\n         leaving
    multicast groups.  This implies support for all of\n         [IP:4] except the
    IGMP protocol itself, which is OPTIONAL.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n         DISCUSSION:\n
    \             IGMP provides gateways that are capable of multicast\n              routing
    with the information required to support IP\n              multicasting across
    multiple networks.  At this time,\n              multicast-routing gateways are
    in the experimental stage\n              and are not widely available.  For hosts
    that are not\n              connected to networks with multicast-routing gateways
    or\n              that do not need to receive multicast datagrams\n              originating
    on other networks, IGMP serves no purpose and\n              is therefore optional
    for now.  However, the rest of\n              [IP:4] is currently recommended
    for the purpose of\n              providing IP-layer access to local network multicast\n
    \             addressing, as a preferable alternative to local broadcast\n              addressing.
    \ It is expected that IGMP will become\n              recommended at some future
    date, when multicast-routing\n              gateways have become more widely available.\n
    \        If IGMP is not implemented, a host SHOULD still join the \"all-\n         hosts\"
    group (224.0.0.1) when the IP layer is initialized and\n         remain a member
    for as long as the IP layer is active.\n         DISCUSSION:\n              Joining
    the \"all-hosts\" group will support strictly local\n              uses of multicasting,
    e.g., a gateway discovery protocol,\n              even if IGMP is not implemented.\n
    \        The mapping of IP Class D addresses to local addresses is\n         currently
    specified for the following types of networks:\n         o    Ethernet/IEEE 802.3,
    as defined in [IP:4].\n         o    Any network that supports broadcast but not
    multicast,\n              addressing: all IP Class D addresses map to the local\n
    \             broadcast address.\n         o    Any type of point-to-point link
    (e.g., SLIP or HDLC\n              links): no mapping required.  All IP multicast
    datagrams\n              are sent as-is, inside the local framing.\n         Mappings
    for other types of networks will be specified in the\n         future.\n         A
    host SHOULD provide a way for higher-layer protocols or\n         applications
    to determine which of the host's connected\n         network(s) support IP multicast
    addressing.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n      3.3.8
    \ Error Reporting\n         Wherever practical, hosts MUST return ICMP error datagrams
    on\n         detection of an error, except in those cases where returning an\n
    \        ICMP error message is specifically prohibited.\n         DISCUSSION:\n
    \             A common phenomenon in datagram networks is the \"black\n              hole
    disease\": datagrams are sent out, but nothing comes\n              back.  Without
    any error datagrams, it is difficult for\n              the user to figure out
    what the problem is.\n   3.4  INTERNET/TRANSPORT LAYER INTERFACE\n      The interface
    between the IP layer and the transport layer MUST\n      provide full access to
    all the mechanisms of the IP layer,\n      including options, Type-of-Service,
    and Time-to-Live.  The\n      transport layer MUST either have mechanisms to set
    these interface\n      parameters, or provide a path to pass them through from
    an\n      application, or both.\n      DISCUSSION:\n           Applications are
    urged to make use of these mechanisms where\n           applicable, even when
    the mechanisms are not currently\n           effective in the Internet (e.g.,
    TOS).  This will allow these\n           mechanisms to be immediately useful when
    they do become\n           effective, without a large amount of retrofitting of
    host\n           software.\n      We now describe a conceptual interface between
    the transport layer\n      and the IP layer, as a set of procedure calls.  This
    is an\n      extension of the information in Section 3.3 of RFC-791 [IP:1].\n
    \     *    Send Datagram\n                SEND(src, dst, prot, TOS, TTL, BufPTR,
    len, Id, DF, opt\n                     => result )\n           where the parameters
    are defined in RFC-791.  Passing an Id\n           parameter is optional; see
    Section 3.2.1.5.\n      *    Receive Datagram\n                RECV(BufPTR, prot\n
    \                    => result, src, dst, SpecDest, TOS, len, opt)\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n           All
    the parameters are defined in RFC-791, except for:\n                SpecDest =
    specific-destination address of datagram\n                            (defined
    in Section 3.2.1.3)\n           The result parameter dst contains the datagram's
    destination\n           address.  Since this may be a broadcast or multicast address,\n
    \          the SpecDest parameter (not shown in RFC-791) MUST be passed.\n           The
    parameter opt contains all the IP options received in the\n           datagram;
    these MUST also be passed to the transport layer.\n      *    Select Source Address\n
    \               GET_SRCADDR(remote, TOS)  -> local\n                remote = remote
    IP address\n                TOS = Type-of-Service\n                local = local
    IP address\n           See Section 3.3.4.3.\n      *    Find Maximum Datagram
    Sizes\n                GET_MAXSIZES(local, remote, TOS) -> MMS_R, MMS_S\n                MMS_R
    = maximum receive transport-message size.\n                MMS_S = maximum send
    transport-message size.\n               (local, remote, TOS defined above)\n           See
    Sections 3.3.2 and 3.3.3.\n      *    Advice on Delivery Success\n                ADVISE_DELIVPROB(sense,
    local, remote, TOS)\n           Here the parameter sense is a 1-bit flag indicating
    whether\n           positive or negative advice is being given; see the\n           discussion
    in Section 3.3.1.4. The other parameters were\n           defined earlier.\n      *
    \   Send ICMP Message\n                SEND_ICMP(src, dst, TOS, TTL, BufPTR, len,
    Id, DF, opt)\n                     -> result\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                (Parameters
    defined in RFC-791).\n           Passing an Id parameter is optional; see Section
    3.2.1.5.\n           The transport layer MUST be able to send certain ICMP\n           messages:
    \ Port Unreachable or any of the query-type\n           messages.  This function
    could be considered to be a special\n           case of the SEND() call, of course;
    we describe it separately\n           for clarity.\n      *    Receive ICMP Message\n
    \               RECV_ICMP(BufPTR ) -> result, src, dst, len, opt\n                (Parameters
    defined in RFC-791).\n           The IP layer MUST pass certain ICMP messages
    up to the\n           appropriate transport-layer routine.  This function could
    be\n           considered to be a special case of the RECV() call, of\n           course;
    we describe it separately for clarity.\n           For an ICMP error message,
    the data that is passed up MUST\n           include the original Internet header
    plus all the octets of\n           the original message that are included in the
    ICMP message.\n           This data will be used by the transport layer to locate
    the\n           connection state information, if any.\n           In particular,
    the following ICMP messages are to be passed\n           up:\n           o    Destination
    Unreachable\n           o    Source Quench\n           o    Echo Reply (to ICMP
    user interface, unless the Echo\n                Request originated in the IP
    layer)\n           o    Timestamp Reply (to ICMP user interface)\n           o
    \   Time Exceeded\n      DISCUSSION:\n           In the future, there may be additions
    to this interface to\n           pass path data (see Section 3.3.1.3) between
    the IP and\n           transport layers.\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n   3.5
    \ INTERNET LAYER REQUIREMENTS SUMMARY\n                                                 |
    \       | | | |S| |\n                                                 |        |
    | | |H| |F\n                                                 |        | | | |O|M|o\n
    \                                                |        | |S| |U|U|o\n                                                 |
    \       | |H| |L|S|t\n                                                 |        |M|O|
    |D|T|n\n                                                 |        |U|U|M| | |o\n
    \                                                |        |S|L|A|N|N|t\n                                                 |
    \       |T|D|Y|O|O|t\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - 'FEATURE                                          |SECTION | | | |T|T|e

    '
  title: FEATURE                                          |SECTION | | | |T|T|e
- contents:
  - "-------------------------------------------------|--------|-|-|-|-|-|--\n                                                 |
    \       | | | | | |\n"
  title: '-------------------------------------------------|--------|-|-|-|-|-|--'
- contents:
  - 'Implement IP and ICMP                            |3.1     |x| | | | |

    '
  title: Implement IP and ICMP                            |3.1     |x| | | | |
- contents:
  - 'Handle remote multihoming in application layer   |3.1     |x| | | | |

    '
  title: Handle remote multihoming in application layer   |3.1     |x| | | | |
- contents:
  - 'Support local multihoming                        |3.1     | | |x| | |

    '
  title: Support local multihoming                        |3.1     | | |x| | |
- contents:
  - 'Meet gateway specs if forward datagrams          |3.1     |x| | | | |

    '
  title: Meet gateway specs if forward datagrams          |3.1     |x| | | | |
- contents:
  - "Configuration switch for embedded gateway        |3.1     |x| | | | |1\n   Config
    switch default to non-gateway          |3.1     |x| | | | |1\n   Auto-config based
    on number of interfaces     |3.1     | | | | |x|1\n"
  title: Configuration switch for embedded gateway        |3.1     |x| | | | |1
- contents:
  - "Able to log discarded datagrams                  |3.1     | |x| | | |\n   Record
    in counter                             |3.1     | |x| | | |\n                                                 |
    \       | | | | | |\n"
  title: Able to log discarded datagrams                  |3.1     | |x| | | |
- contents:
  - 'Silently discard Version != 4                    |3.2.1.1 |x| | | | |

    '
  title: Silently discard Version != 4                    |3.2.1.1 |x| | | | |
- contents:
  - 'Verify IP checksum, silently discard bad dgram   |3.2.1.2 |x| | | | |

    '
  title: Verify IP checksum, silently discard bad dgram   |3.2.1.2 |x| | | | |
- contents:
  - "Addressing:                                      |        | | | | | |\n  Subnet
    addressing (RFC-950)                    |3.2.1.3 |x| | | | |\n  Src address must
    be host's own IP address      |3.2.1.3 |x| | | | |\n  Silently discard datagram
    with bad dest addr   |3.2.1.3 |x| | | | |\n  Silently discard datagram with bad
    src addr    |3.2.1.3 |x| | | | |\n"
  title: 'Addressing:                                      |        | | | | | |'
- contents:
  - 'Support reassembly                               |3.2.1.4 |x| | | | |

    '
  title: Support reassembly                               |3.2.1.4 |x| | | | |
- contents:
  - "Retain same Id field in identical datagram       |3.2.1.5 | | |x| | |\n                                                 |
    \       | | | | | |\n"
  title: Retain same Id field in identical datagram       |3.2.1.5 | | |x| | |
- contents:
  - "TOS:                                             |        | | | | | |\n  Allow
    transport layer to set TOS               |3.2.1.6 |x| | | | |\n  Pass received
    TOS up to transport layer        |3.2.1.6 | |x| | | |\n  Use RFC-795 link-layer
    mappings for TOS        |3.2.1.6 | | | |x| |\n"
  title: 'TOS:                                             |        | | | | | |'
- contents:
  - "TTL:                                             |        | | | | | |\n  Send
    packet with TTL of 0                      |3.2.1.7 | | | | |x|\n  Discard received
    packets with TTL < 2          |3.2.1.7 | | | | |x|\n  Allow transport layer to
    set TTL               |3.2.1.7 |x| | | | |\n  Fixed TTL is configurable                      |3.2.1.7
    |x| | | | |\n                                                 |        | | | |
    | |\n"
  title: 'TTL:                                             |        | | | | | |'
- contents:
  - "IP Options:                                      |        | | | | | |\n  Allow
    transport layer to send IP options       |3.2.1.8 |x| | | | |\n  Pass all IP options
    rcvd to higher layer       |3.2.1.8 |x| | | | |\n"
  title: 'IP Options:                                      |        | | | | | |'
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n  IP
    layer silently ignore unknown options       |3.2.1.8 |x| | | | |\n  Security option
    \                               |3.2.1.8a| | |x| | |\n  Send Stream Identifier
    option                  |3.2.1.8b| | | |x| |\n  Silently ignore Stream Identifer
    option        |3.2.1.8b|x| | | | |\n  Record Route option                            |3.2.1.8d|
    | |x| | |\n  Timestamp option                               |3.2.1.8e| | |x| |
    |\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "Source Route Option:                             |        | | | | | |\n  Originate
    & terminate Source Route options     |3.2.1.8c|x| | | | |\n  Datagram with completed
    SR passed up to TL     |3.2.1.8c|x| | | | |\n  Build correct (non-redundant) return
    route     |3.2.1.8c|x| | | | |\n  Send multiple SR options in one header         |3.2.1.8c|
    | | | |x|\n                                                 |        | | | | |
    |\n"
  title: 'Source Route Option:                             |        | | | | | |'
- contents:
  - "ICMP:                                            |        | | | | | |\n  Silently
    discard ICMP msg with unknown type    |3.2.2   |x| | | | |\n  Include more than
    8 octets of orig datagram    |3.2.2   | | |x| | |\n      Included octets same
    as received           |3.2.2   |x| | | | |\n  Demux ICMP Error to transport protocol
    \        |3.2.2   |x| | | | |\n  Send ICMP error message with TOS=0             |3.2.2
    \  | |x| | | |\n  Send ICMP error message for:                   |        | |
    | | | |\n   - ICMP error msg                              |3.2.2   | | | | |x|\n
    \  - IP b'cast or IP m'cast                      |3.2.2   | | | | |x|\n   - Link-layer
    b'cast                           |3.2.2   | | | | |x|\n   - Non-initial fragment
    \                       |3.2.2   | | | | |x|\n   - Datagram with non-unique src
    address        |3.2.2   | | | | |x|\n  Return ICMP error msgs (when not prohibited)
    \  |3.3.8   |x| | | | |\n                                                 |        |
    | | | | |\n  Dest Unreachable:                              |        | | | | |
    |\n    Generate Dest Unreachable (code 2/3)         |3.2.2.1 | |x| | | |\n    Pass
    ICMP Dest Unreachable to higher layer   |3.2.2.1 |x| | | | |\n    Higher layer
    act on Dest Unreach             |3.2.2.1 | |x| | | |\n      Interpret Dest Unreach
    as only hint        |3.2.2.1 |x| | | | |\n  Redirect:                                      |
    \       | | | | | |\n    Host send Redirect                           |3.2.2.2
    | | | |x| |\n    Update route cache when recv Redirect        |3.2.2.2 |x| | |
    | |\n    Handle both Host and Net Redirects           |3.2.2.2 |x| | | | |\n    Discard
    illegal Redirect                     |3.2.2.2 | |x| | | |\n  Source Quench:                                 |
    \       | | | | | |\n    Send Source Quench if buffering exceeded     |3.2.2.3
    | | |x| | |\n    Pass Source Quench to higher layer           |3.2.2.3 |x| | |
    | |\n    Higher layer act on Source Quench            |3.2.2.3 | |x| | | |\n  Time
    Exceeded: pass to higher layer            |3.2.2.4 |x| | | | |\n  Parameter Problem:
    \                            |        | | | | | |\n    Send Parameter Problem
    messages              |3.2.2.5 | |x| | | |\n    Pass Parameter Problem to higher
    layer       |3.2.2.5 |x| | | | |\n    Report Parameter Problem to user             |3.2.2.5
    | | |x| | |\n                                                 |        | | | |
    | |\n  ICMP Echo Request or Reply:                    |        | | | | | |\n    Echo
    server and Echo client                  |3.2.2.6 |x| | | | |\n"
  title: 'ICMP:                                            |        | | | | | |'
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n    Echo
    client                                  |3.2.2.6 | |x| | | |\n    Discard Echo
    Request to broadcast address    |3.2.2.6 | | |x| | |\n    Discard Echo Request
    to multicast address    |3.2.2.6 | | |x| | |\n    Use specific-dest addr as Echo
    Reply src     |3.2.2.6 |x| | | | |\n    Send same data in Echo Reply                 |3.2.2.6
    |x| | | | |\n    Pass Echo Reply to higher layer              |3.2.2.6 |x| | |
    | |\n    Reflect Record Route, Time Stamp options     |3.2.2.6 | |x| | | |\n    Reverse
    and reflect Source Route option      |3.2.2.6 |x| | | | |\n                                                 |
    \       | | | | | |\n  ICMP Information Request or Reply:             |3.2.2.7
    | | | |x| |\n  ICMP Timestamp and Timestamp Reply:            |3.2.2.8 | | |x|
    | |\n    Minimize delay variability                   |3.2.2.8 | |x| | | |1\n
    \   Silently discard b'cast Timestamp            |3.2.2.8 | | |x| | |1\n    Silently
    discard m'cast Timestamp            |3.2.2.8 | | |x| | |1\n    Use specific-dest
    addr as TS Reply src       |3.2.2.8 |x| | | | |1\n    Reflect Record Route, Time
    Stamp options     |3.2.2.6 | |x| | | |1\n    Reverse and reflect Source Route
    option      |3.2.2.8 |x| | | | |1\n    Pass Timestamp Reply to higher layer         |3.2.2.8
    |x| | | | |1\n    Obey rules for \"standard value\"              |3.2.2.8 |x|
    | | | |1\n                                                 |        | | | | |
    |\n  ICMP Address Mask Request and Reply:           |        | | | | | |\n    Addr
    Mask source configurable                |3.2.2.9 |x| | | | |\n    Support static
    configuration of addr mask    |3.2.2.9 |x| | | | |\n    Get addr mask dynamically
    during booting     |3.2.2.9 | | |x| | |\n    Get addr via ICMP Addr Mask Request/Reply
    \   |3.2.2.9 | | |x| | |\n      Retransmit Addr Mask Req if no Reply       |3.2.2.9
    |x| | | | |3\n      Assume default mask if no Reply            |3.2.2.9 | |x|
    | | |3\n      Update address mask from first Reply only  |3.2.2.9 |x| | | | |3\n
    \   Reasonableness check on Addr Mask            |3.2.2.9 | |x| | | |\n    Send
    unauthorized Addr Mask Reply msgs       |3.2.2.9 | | | | |x|\n      Explicitly
    configured to be agent          |3.2.2.9 |x| | | | |\n    Static config=> Addr-Mask-Authoritative
    flag |3.2.2.9 | |x| | | |\n      Broadcast Addr Mask Reply when init.       |3.2.2.9
    |x| | | | |3\n                                                 |        | | |
    | | |\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "ROUTING OUTBOUND DATAGRAMS:                      |        | | | | | |\n  Use
    address mask in local/remote decision      |3.3.1.1 |x| | | | |\n  Operate with
    no gateways on conn network       |3.3.1.1 |x| | | | |\n  Maintain \"route cache\"
    of next-hop gateways    |3.3.1.2 |x| | | | |\n  Treat Host and Net Redirect the
    same           |3.3.1.2 | |x| | | |\n  If no cache entry, use default gateway
    \        |3.3.1.2 |x| | | | |\n    Support multiple default gateways            |3.3.1.2
    |x| | | | |\n  Provide table of static routes                 |3.3.1.2 | | |x|
    | |\n    Flag: route overridable by Redirects         |3.3.1.2 | | |x| | |\n  Key
    route cache on host, not net address       |3.3.1.3 | | |x| | |\n  Include TOS
    in route cache                     |3.3.1.3 | |x| | | |\n                                                 |
    \       | | | | | |\n  Able to detect failure of next-hop gateway     |3.3.1.4
    |x| | | | |\n  Assume route is good forever                   |3.3.1.4 | | | |x|
    |\n"
  title: 'ROUTING OUTBOUND DATAGRAMS:                      |        | | | | | |'
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n  Ping
    gateways continuously                     |3.3.1.4 | | | | |x|\n  Ping only when
    traffic being sent              |3.3.1.4 |x| | | | |\n  Ping only when no positive
    indication          |3.3.1.4 |x| | | | |\n  Higher and lower layers give advice
    \           |3.3.1.4 | |x| | | |\n  Switch from failed default g'way to another
    \   |3.3.1.5 |x| | | | |\n  Manual method of entering config info          |3.3.1.6
    |x| | | | |\n                                                 |        | | | |
    | |\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "REASSEMBLY and FRAGMENTATION:                    |        | | | | | |\n  Able
    to reassemble incoming datagrams          |3.3.2   |x| | | | |\n    At least 576
    byte datagrams                  |3.3.2   |x| | | | |\n    EMTU_R configurable
    or indefinite            |3.3.2   | |x| | | |\n  Transport layer able to learn
    MMS_R            |3.3.2   |x| | | | |\n  Send ICMP Time Exceeded on reassembly
    timeout  |3.3.2   |x| | | | |\n    Fixed reassembly timeout value               |3.3.2
    \  | |x| | | |\n                                                 |        | |
    | | | |\n  Pass MMS_S to higher layers                    |3.3.3   |x| | | | |\n
    \ Local fragmentation of outgoing packets        |3.3.3   | | |x| | |\n     Else
    don't send bigger than MMS_S           |3.3.3   |x| | | | |\n  Send max 576 to
    off-net destination            |3.3.3   | |x| | | |\n  All-Subnets-MTU configuration
    flag             |3.3.3   | | |x| | |\n                                                 |
    \       | | | | | |\n"
  title: 'REASSEMBLY and FRAGMENTATION:                    |        | | | | | |'
- contents:
  - "MULTIHOMING:                                     |        | | | | | |\n  Reply
    with same addr as spec-dest addr         |3.3.4.2 | |x| | | |\n  Allow application
    to choose local IP addr      |3.3.4.2 |x| | | | |\n  Silently discard d'gram in
    \"wrong\" interface   |3.3.4.2 | | |x| | |\n  Only send d'gram through \"right\"
    interface     |3.3.4.2 | | |x| | |4\n                                                 |
    \       | | | | | |\n"
  title: 'MULTIHOMING:                                     |        | | | | | |'
- contents:
  - "SOURCE-ROUTE FORWARDING:                         |        | | | | | |\n  Forward
    datagram with Source Route option      |3.3.5   | | |x| | |1\n    Obey corresponding
    gateway rules             |3.3.5   |x| | | | |1\n      Update TTL by gateway rules
    \               |3.3.5   |x| | | | |1\n      Able to generate ICMP err code 4,
    5        |3.3.5   |x| | | | |1\n      IP src addr not local host                 |3.3.5
    \  | | |x| | |1\n      Update Timestamp, Record Route options     |3.3.5   |x|
    | | | |1\n    Configurable switch for non-local SRing      |3.3.5   |x| | | |
    |1\n      Defaults to OFF                            |3.3.5   |x| | | | |1\n    Satisfy
    gwy access rules for non-local SRing |3.3.5   |x| | | | |1\n    If not forward,
    send Dest Unreach (cd 5)     |3.3.5   | |x| | | |2\n                                                 |
    \       | | | | | |\n"
  title: 'SOURCE-ROUTE FORWARDING:                         |        | | | | | |'
- contents:
  - "BROADCAST:                                       |        | | | | | |\n  Broadcast
    addr as IP source addr               |3.2.1.3 | | | | |x|\n  Receive 0 or -1 broadcast
    formats OK           |3.3.6   | |x| | | |\n  Config'ble option to send 0 or -1
    b'cast       |3.3.6   | | |x| | |\n    Default to -1 broadcast                      |3.3.6
    \  | |x| | | |\n  Recognize all broadcast address formats        |3.3.6   |x|
    | | | |\n  Use IP b'cast/m'cast addr in link-layer b'cast |3.3.6   |x| | | | |\n
    \ Silently discard link-layer-only b'cast dg's   |3.3.6   | |x| | | |\n  Use Limited
    Broadcast addr for connected net   |3.3.6   | |x| | | |\n"
  title: 'BROADCAST:                                       |        | | | | | |'
- contents:
  - "RFC1122                      INTERNET LAYER                 October 1989\n                                                 |
    \       | | | | | |\n"
  title: RFC1122                      INTERNET LAYER                 October 1989
- contents:
  - "MULTICAST:                                       |        | | | | | |\n  Support
    local IP multicasting (RFC-1112)       |3.3.7   | |x| | | |\n  Support IGMP (RFC-1112)
    \                       |3.3.7   | | |x| | |\n  Join all-hosts group at startup
    \               |3.3.7   | |x| | | |\n  Higher layers learn i'face m'cast capability
    \  |3.3.7   | |x| | | |\n                                                 |        |
    | | | | |\n"
  title: 'MULTICAST:                                       |        | | | | | |'
- contents:
  - "INTERFACE:                                       |        | | | | | |\n  Allow
    transport layer to use all IP mechanisms |3.4     |x| | | | |\n  Pass interface
    ident up to transport layer     |3.4     |x| | | | |\n  Pass all IP options up
    to transport layer      |3.4     |x| | | | |\n  Transport layer can send certain
    ICMP messages |3.4     |x| | | | |\n  Pass spec'd ICMP messages up to transp.
    layer  |3.4     |x| | | | |\n     Include IP hdr+8 octets or more from orig.  |3.4
    \    |x| | | | |\n  Able to leap tall buildings at a single bound  |3.5     |
    |x| | | |\n"
  title: 'INTERFACE:                                       |        | | | | | |'
- contents:
  - 'Footnotes:

    '
  title: 'Footnotes:'
- contents:
  - '(1)  Only if feature is implemented.

    '
  title: (1)  Only if feature is implemented.
- contents:
  - '(2)  This requirement is overruled if datagram is an ICMP error message.

    '
  title: (2)  This requirement is overruled if datagram is an ICMP error message.
- contents:
  - '(3)  Only if feature is implemented and is configured "on".

    '
  title: (3)  Only if feature is implemented and is configured "on".
- contents:
  - '(4)  Unless has embedded gateway functionality or is source routed.

    '
  title: (4)  Unless has embedded gateway functionality or is source routed.
- contents:
  - 'RFC1122                  TRANSPORT LAYER -- UDP             October 1989

    '
  title: RFC1122                  TRANSPORT LAYER -- UDP             October 1989
- contents:
  - "4. TRANSPORT PROTOCOLS\n   4.1  USER DATAGRAM PROTOCOL -- UDP\n      4.1.1  INTRODUCTION\n
    \        The User Datagram Protocol UDP [UDP:1] offers only a minimal\n         transport
    service -- non-guaranteed datagram delivery -- and\n         gives applications
    direct access to the datagram service of the\n         IP layer.  UDP is used
    by applications that do not require the\n         level of service of TCP or that
    wish to use communications\n         services (e.g., multicast or broadcast delivery)
    not available\n         from TCP.\n         UDP is almost a null protocol; the
    only services it provides\n         over IP are checksumming of data and multiplexing
    by port\n         number.  Therefore, an application program running over UDP\n
    \        must deal directly with end-to-end communication problems that\n         a
    connection-oriented protocol would have handled -- e.g.,\n         retransmission
    for reliable delivery, packetization and\n         reassembly, flow control, congestion
    avoidance, etc., when\n         these are required.  The fairly complex coupling
    between IP and\n         TCP will be mirrored in the coupling between UDP and
    many\n         applications using UDP.\n      4.1.2  PROTOCOL WALK-THROUGH\n         There
    are no known errors in the specification of UDP.\n      4.1.3  SPECIFIC ISSUES\n
    \        4.1.3.1  Ports\n            UDP well-known ports follow the same rules
    as TCP well-known\n            ports; see Section 4.2.2.1 below.\n            If
    a datagram arrives addressed to a UDP port for which\n            there is no
    pending LISTEN call, UDP SHOULD send an ICMP\n            Port Unreachable message.\n
    \        4.1.3.2  IP Options\n            UDP MUST pass any IP option that it
    receives from the IP\n            layer transparently to the application layer.\n
    \           An application MUST be able to specify IP options to be sent\n            in
    its UDP datagrams, and UDP MUST pass these options to the\n            IP layer.\n"
  title: 4. TRANSPORT PROTOCOLS
- contents:
  - "RFC1122                  TRANSPORT LAYER -- UDP             October 1989\n            DISCUSSION:\n
    \                At present, the only options that need be passed\n                 through
    UDP are Source Route, Record Route, and Time\n                 Stamp.  However,
    new options may be defined in the\n                 future, and UDP need not and
    should not make any\n                 assumptions about the format or content
    of options it\n                 passes to or from the application; an exception
    to this\n                 might be an IP-layer security option.\n                 An
    application based on UDP will need to obtain a\n                 source route
    from a request datagram and supply a\n                 reversed route for sending
    the corresponding reply.\n         4.1.3.3  ICMP Messages\n            UDP MUST
    pass to the application layer all ICMP error\n            messages that it receives
    from the IP layer.  Conceptually\n            at least, this may be accomplished
    with an upcall to the\n            ERROR_REPORT routine (see Section 4.2.4.1).\n
    \           DISCUSSION:\n                 Note that ICMP error messages resulting
    from sending a\n                 UDP datagram are received asynchronously.  A
    UDP-based\n                 application that wants to receive ICMP error messages\n
    \                is responsible for maintaining the state necessary to\n                 demultiplex
    these messages when they arrive; for\n                 example, the application
    may keep a pending receive\n                 operation for this purpose.  The
    application is also\n                 responsible to avoid confusion from a delayed
    ICMP\n                 error message resulting from an earlier use of the same\n
    \                port(s).\n         4.1.3.4  UDP Checksums\n            A host
    MUST implement the facility to generate and validate\n            UDP checksums.
    \ An application MAY optionally be able to\n            control whether a UDP
    checksum will be generated, but it\n            MUST default to checksumming on.\n
    \           If a UDP datagram is received with a checksum that is non-\n            zero
    and invalid, UDP MUST silently discard the datagram.\n            An application
    MAY optionally be able to control whether UDP\n            datagrams without checksums
    should be discarded or passed to\n            the application.\n            DISCUSSION:\n
    \                Some applications that normally run only across local\n                 area
    networks have chosen to turn off UDP checksums for\n"
  title: RFC1122                  TRANSPORT LAYER -- UDP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- UDP             October 1989\n                 efficiency.
    \ As a result, numerous cases of undetected\n                 errors have been
    reported.  The advisability of ever\n                 turning off UDP checksumming
    is very controversial.\n            IMPLEMENTATION:\n                 There is
    a common implementation error in UDP\n                 checksums.  Unlike the
    TCP checksum, the UDP checksum\n                 is optional; the value zero is
    transmitted in the\n                 checksum field of a UDP header to indicate
    the absence\n                 of a checksum.  If the transmitter really calculates
    a\n                 UDP checksum of zero, it must transmit the checksum as\n                 all
    1's (65535).  No special action is required at the\n                 receiver,
    since zero and 65535 are equivalent in 1's\n                 complement arithmetic.\n
    \        4.1.3.5  UDP Multihoming\n            When a UDP datagram is received,
    its specific-destination\n            address MUST be passed up to the application
    layer.\n            An application program MUST be able to specify the IP source\n
    \           address to be used for sending a UDP datagram or to leave it\n            unspecified
    (in which case the networking software will\n            choose an appropriate
    source address).  There SHOULD be a\n            way to communicate the chosen
    source address up to the\n            application layer (e.g, so that the application
    can later\n            receive a reply datagram only from the corresponding\n
    \           interface).\n            DISCUSSION:\n                 A request/response
    application that uses UDP should use\n                 a source address for the
    response that is the same as\n                 the specific destination address
    of the request.  See\n                 the \"General Issues\" section of [INTRO:1].\n
    \        4.1.3.6  Invalid Addresses\n            A UDP datagram received with
    an invalid IP source address\n            (e.g., a broadcast or multicast address)
    must be discarded\n            by UDP or by the IP layer (see Section 3.2.1.3).\n
    \           When a host sends a UDP datagram, the source address MUST be\n            (one
    of) the IP address(es) of the host.\n      4.1.4  UDP/APPLICATION LAYER INTERFACE\n
    \        The application interface to UDP MUST provide the full services\n         of
    the IP/transport interface described in Section 3.4 of this\n"
  title: RFC1122                  TRANSPORT LAYER -- UDP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- UDP             October 1989\n         document.
    \ Thus, an application using UDP needs the functions\n         of the GET_SRCADDR(),
    GET_MAXSIZES(), ADVISE_DELIVPROB(), and\n         RECV_ICMP() calls described
    in Section 3.4.  For example,\n         GET_MAXSIZES() can be used to learn the
    effective maximum UDP\n         maximum datagram size for a particular {interface,remote\n
    \        host,TOS} triplet.\n         An application-layer program MUST be able
    to set the TTL and\n         TOS values as well as IP options for sending a UDP
    datagram,\n         and these values must be passed transparently to the IP layer.\n
    \        UDP MAY pass the received TOS up to the application layer.\n      4.1.5
    \ UDP REQUIREMENTS SUMMARY\n                                                 |
    \       | | | |S| |\n                                                 |        |
    | | |H| |F\n                                                 |        | | | |O|M|o\n
    \                                                |        | |S| |U|U|o\n                                                 |
    \       | |H| |L|S|t\n                                                 |        |M|O|
    |D|T|n\n                                                 |        |U|U|M| | |o\n
    \                                                |        |S|L|A|N|N|t\n                                                 |
    \       |T|D|Y|O|O|t\n"
  title: RFC1122                  TRANSPORT LAYER -- UDP             October 1989
- contents:
  - 'FEATURE                                          |SECTION | | | |T|T|e

    '
  title: FEATURE                                          |SECTION | | | |T|T|e
- contents:
  - "-------------------------------------------------|--------|-|-|-|-|-|--\n                                                 |
    \       | | | | | |\n    UDP                                          |        |
    | | | | |\n"
  title: '-------------------------------------------------|--------|-|-|-|-|-|--'
- contents:
  - "-------------------------------------------------|--------|-|-|-|-|-|--\n                                                 |
    \       | | | | | |\n"
  title: '-------------------------------------------------|--------|-|-|-|-|-|--'
- contents:
  - "UDP send Port Unreachable                        |4.1.3.1 | |x| | | |\n                                                 |
    \       | | | | | |\n"
  title: UDP send Port Unreachable                        |4.1.3.1 | |x| | | |
- contents:
  - "IP Options in UDP                                |        | | | | | |\n - Pass
    rcv'd IP options to applic layer         |4.1.3.2 |x| | | | |\n - Applic layer
    can specify IP options in Send   |4.1.3.2 |x| | | | |\n - UDP passes IP options
    down to IP layer        |4.1.3.2 |x| | | | |\n                                                 |
    \       | | | | | |\n"
  title: IP Options in UDP                                |        | | | | | |
- contents:
  - "Pass ICMP msgs up to applic layer                |4.1.3.3 |x| | | | |\n                                                 |
    \       | | | | | |\n"
  title: Pass ICMP msgs up to applic layer                |4.1.3.3 |x| | | | |
- contents:
  - "UDP checksums:                                   |        | | | | | |\n - Able
    to generate/check checksum               |4.1.3.4 |x| | | | |\n - Silently discard
    bad checksum                 |4.1.3.4 |x| | | | |\n - Sender Option to not generate
    checksum        |4.1.3.4 | | |x| | |\n   - Default is to checksum                      |4.1.3.4
    |x| | | | |\n - Receiver Option to require checksum           |4.1.3.4 | | |x|
    | |\n                                                 |        | | | | | |\n"
  title: 'UDP checksums:                                   |        | | | | | |'
- contents:
  - "UDP Multihoming                                  |        | | | | | |\n - Pass
    spec-dest addr to application            |4.1.3.5 |x| | | | |\n"
  title: UDP Multihoming                                  |        | | | | | |
- contents:
  - "RFC1122                  TRANSPORT LAYER -- UDP             October 1989\n -
    Applic layer can specify Local IP addr        |4.1.3.5 |x| | | | |\n - Applic
    layer specify wild Local IP addr       |4.1.3.5 |x| | | | |\n - Applic layer notified
    of Local IP addr used   |4.1.3.5 | |x| | | |\n                                                 |
    \       | | | | | |\n"
  title: RFC1122                  TRANSPORT LAYER -- UDP             October 1989
- contents:
  - 'Bad IP src addr silently discarded by UDP/IP     |4.1.3.6 |x| | | | |

    '
  title: Bad IP src addr silently discarded by UDP/IP     |4.1.3.6 |x| | | | |
- contents:
  - 'Only send valid IP source address                |4.1.3.6 |x| | | | |

    '
  title: Only send valid IP source address                |4.1.3.6 |x| | | | |
- contents:
  - 'UDP Application Interface Services               |        | | | | | |

    '
  title: UDP Application Interface Services               |        | | | | | |
- contents:
  - "Full IP interface of 3.4 for application         |4.1.4   |x| | | | |\n - Able
    to spec TTL, TOS, IP opts when send dg   |4.1.4   |x| | | | |\n - Pass received
    TOS up to applic layer          |4.1.4   | | |x| | |\n"
  title: Full IP interface of 3.4 for application         |4.1.4   |x| | | | |
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n   4.2
    \ TRANSMISSION CONTROL PROTOCOL -- TCP\n      4.2.1  INTRODUCTION\n         The
    Transmission Control Protocol TCP [TCP:1] is the primary\n         virtual-circuit
    transport protocol for the Internet suite.  TCP\n         provides reliable, in-sequence
    delivery of a full-duplex stream\n         of octets (8-bit bytes).  TCP is used
    by those applications\n         needing reliable, connection-oriented transport
    service, e.g.,\n         mail (SMTP), file transfer (FTP), and virtual terminal
    service\n         (Telnet); requirements for these application-layer protocols\n
    \        are described in [INTRO:1].\n      4.2.2  PROTOCOL WALK-THROUGH\n         4.2.2.1
    \ Well-Known Ports: RFC-793 Section 2.7\n            DISCUSSION:\n                 TCP
    reserves port numbers in the range 0-255 for\n                 \"well-known\"
    ports, used to access services that are\n                 standardized across
    the Internet.  The remainder of the\n                 port space can be freely
    allocated to application\n                 processes.  Current well-known port
    definitions are\n                 listed in the RFC entitled \"Assigned Numbers\"\n
    \                [INTRO:6].  A prerequisite for defining a new well-\n                 known
    port is an RFC documenting the proposed service\n                 in enough detail
    to allow new implementations.\n                 Some systems extend this notion
    by adding a third\n                 subdivision of the TCP port space: reserved
    ports,\n                 which are generally used for operating-system-specific\n
    \                services.  For example, reserved ports might fall\n                 between
    256 and some system-dependent upper limit.\n                 Some systems further
    choose to protect well-known and\n                 reserved ports by permitting
    only privileged users to\n                 open TCP connections with those port
    values.  This is\n                 perfectly reasonable as long as the host does
    not\n                 assume that all hosts protect their low-numbered ports\n
    \                in this manner.\n         4.2.2.2  Use of Push: RFC-793 Section
    2.8\n            When an application issues a series of SEND calls without\n            setting
    the PUSH flag, the TCP MAY aggregate the data\n            internally without
    sending it.  Similarly, when a series of\n            segments is received without
    the PSH bit, a TCP MAY queue\n            the data internally without passing
    it to the receiving\n            application.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n            The
    PSH bit is not a record marker and is independent of\n            segment boundaries.
    \ The transmitter SHOULD collapse\n            successive PSH bits when it packetizes
    data, to send the\n            largest possible segment.\n            A TCP MAY
    implement PUSH flags on SEND calls.  If PUSH flags\n            are not implemented,
    then the sending TCP: (1) must not\n            buffer data indefinitely, and
    (2) MUST set the PSH bit in\n            the last buffered segment (i.e., when
    there is no more\n            queued data to be sent).\n            The discussion
    in RFC-793 on pages 48, 50, and 74\n            erroneously implies that a received
    PSH flag must be passed\n            to the application layer.  Passing a received
    PSH flag to\n            the application layer is now OPTIONAL.\n            An
    application program is logically required to set the PUSH\n            flag in
    a SEND call whenever it needs to force delivery of\n            the data to avoid
    a communication deadlock.  However, a TCP\n            SHOULD send a maximum-sized
    segment whenever possible, to\n            improve performance (see Section 4.2.3.4).\n
    \           DISCUSSION:\n                 When the PUSH flag is not implemented
    on SEND calls,\n                 i.e., when the application/TCP interface uses
    a pure\n                 streaming model, responsibility for aggregating any\n
    \                tiny data fragments to form reasonable sized segments\n                 is
    partially borne by the application layer.\n                 Generally, an interactive
    application protocol must set\n                 the PUSH flag at least in the
    last SEND call in each\n                 command or response sequence.  A bulk
    transfer protocol\n                 like FTP should set the PUSH flag on the last
    segment\n                 of a file or when necessary to prevent buffer deadlock.\n
    \                At the receiver, the PSH bit forces buffered data to be\n                 delivered
    to the application (even if less than a full\n                 buffer has been
    received). Conversely, the lack of a\n                 PSH bit can be used to
    avoid unnecessary wakeup calls\n                 to the application process; this
    can be an important\n                 performance optimization for large timesharing
    hosts.\n                 Passing the PSH bit to the receiving application allows\n
    \                an analogous optimization within the application.\n         4.2.2.3
    \ Window Size: RFC-793 Section 3.1\n            The window size MUST be treated
    as an unsigned number, or\n            else large window sizes will appear like
    negative windows\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n            and
    TCP will not work.  It is RECOMMENDED that\n            implementations reserve
    32-bit fields for the send and\n            receive window sizes in the connection
    record and do all\n            window computations with 32 bits.\n            DISCUSSION:\n
    \                It is known that the window field in the TCP header is\n                 too
    small for high-speed, long-delay paths.\n                 Experimental TCP options
    have been defined to extend\n                 the window size; see for example
    [TCP:11].  In\n                 anticipation of the adoption of such an extension,
    TCP\n                 implementors should treat windows as 32 bits.\n         4.2.2.4
    \ Urgent Pointer: RFC-793 Section 3.1\n            The second sentence is in error:
    the urgent pointer points\n            to the sequence number of the LAST octet
    (not LAST+1) in a\n            sequence of urgent data.  The description on page
    56 (last\n            sentence) is correct.\n            A TCP MUST support a
    sequence of urgent data of any length.\n            A TCP MUST inform the application
    layer asynchronously\n            whenever it receives an Urgent pointer and there
    was\n            previously no pending urgent data, or whenever the Urgent\n            pointer
    advances in the data stream.  There MUST be a way\n            for the application
    to learn how much urgent data remains to\n            be read from the connection,
    or at least to determine\n            whether or not more urgent data remains
    to be read.\n            DISCUSSION:\n                 Although the Urgent mechanism
    may be used for any\n                 application, it is normally used to send
    \"interrupt\"-\n                 type commands to a Telnet program (see \"Using
    Telnet\n                 Synch Sequence\" section in [INTRO:1]).\n                 The
    asynchronous or \"out-of-band\" notification will\n                 allow the
    application to go into \"urgent mode\", reading\n                 data from the
    TCP connection.  This allows control\n                 commands to be sent to
    an application whose normal\n                 input buffers are full of unprocessed
    data.\n            IMPLEMENTATION:\n                 The generic ERROR-REPORT()
    upcall described in Section\n                 4.2.4.1 is a possible mechanism
    for informing the\n                 application of the arrival of urgent data.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n         4.2.2.5
    \ TCP Options: RFC-793 Section 3.1\n            A TCP MUST be able to receive
    a TCP option in any segment.\n            A TCP MUST ignore without error any
    TCP option it does not\n            implement, assuming that the option has a
    length field (all\n            TCP options defined in the future will have length
    fields).\n            TCP MUST be prepared to handle an illegal option length\n
    \           (e.g., zero) without crashing; a suggested procedure is to\n            reset
    the connection and log the reason.\n         4.2.2.6  Maximum Segment Size Option:
    RFC-793 Section 3.1\n            TCP MUST implement both sending and receiving
    the Maximum\n            Segment Size option [TCP:4].\n            TCP SHOULD
    send an MSS (Maximum Segment Size) option in\n            every SYN segment when
    its receive MSS differs from the\n            default 536, and MAY send it always.\n
    \           If an MSS option is not received at connection setup, TCP\n            MUST
    assume a default send MSS of 536 (576-40) [TCP:4].\n            The maximum size
    of a segment that TCP really sends, the\n            \"effective send MSS,\" MUST
    be the smaller of the send MSS\n            (which reflects the available reassembly
    buffer size at the\n            remote host) and the largest size permitted by
    the IP layer:\n               Eff.snd.MSS =\n                  min(SendMSS+20,
    MMS_S) - TCPhdrsize - IPoptionsize\n            where:\n            *    SendMSS
    is the MSS value received from the remote host,\n                 or the default
    536 if no MSS option is received.\n            *    MMS_S is the maximum size
    for a transport-layer message\n                 that TCP may send.\n            *
    \   TCPhdrsize is the size of the TCP header; this is\n                 normally
    20, but may be larger if TCP options are to be\n                 sent.\n            *
    \   IPoptionsize is the size of any IP options that TCP\n                 will
    pass to the IP layer with the current message.\n            The MSS value to be
    sent in an MSS option must be less than\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n            or
    equal to:\n               MMS_R - 20\n            where MMS_R is the maximum size
    for a transport-layer\n            message that can be received (and reassembled).
    \ TCP obtains\n            MMS_R and MMS_S from the IP layer; see the generic
    call\n            GET_MAXSIZES in Section 3.4.\n            DISCUSSION:\n                 The
    choice of TCP segment size has a strong effect on\n                 performance.
    \ Larger segments increase throughput by\n                 amortizing header size
    and per-datagram processing\n                 overhead over more data bytes; however,
    if the packet\n                 is so large that it causes IP fragmentation, efficiency\n
    \                drops sharply if any fragments are lost [IP:9].\n                 Some
    TCP implementations send an MSS option only if the\n                 destination
    host is on a non-connected network.\n                 However, in general the
    TCP layer may not have the\n                 appropriate information to make this
    decision, so it is\n                 preferable to leave to the IP layer the task
    of\n                 determining a suitable MTU for the Internet path.  We\n                 therefore
    recommend that TCP always send the option (if\n                 not 536) and that
    the IP layer determine MMS_R as\n                 specified in 3.3.3 and 3.4.
    \ A proposed IP-layer\n                 mechanism to measure the MTU would then
    modify the IP\n                 layer without changing TCP.\n         4.2.2.7
    \ TCP Checksum: RFC-793 Section 3.1\n            Unlike the UDP checksum (see
    Section 4.1.3.4), the TCP\n            checksum is never optional.  The sender
    MUST generate it and\n            the receiver MUST check it.\n         4.2.2.8
    \ TCP Connection State Diagram: RFC-793 Section 3.2,\n            page 23\n            There
    are several problems with this diagram:\n            (a)  The arrow from SYN-SENT
    to SYN-RCVD should be labeled\n                 with \"snd SYN,ACK\", to agree
    with the text on page 68\n                 and with Figure 8.\n            (b)
    \ There could be an arrow from SYN-RCVD state to LISTEN\n                 state,
    conditioned on receiving a RST after a passive\n                 open (see text
    page 70).\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n            (c)
    \ It is possible to go directly from FIN-WAIT-1 to the\n                 TIME-WAIT
    state (see page 75 of the spec).\n         4.2.2.9  Initial Sequence Number Selection:
    RFC-793 Section\n            3.3, page 27\n            A TCP MUST use the specified
    clock-driven selection of\n            initial sequence numbers.\n         4.2.2.10
    \ Simultaneous Open Attempts: RFC-793 Section 3.4, page\n            32\n            There
    is an error in Figure 8: the packet on line 7 should\n            be identical
    to the packet on line 5.\n            A TCP MUST support simultaneous open attempts.\n
    \           DISCUSSION:\n                 It sometimes surprises implementors
    that if two\n                 applications attempt to simultaneously connect to
    each\n                 other, only one connection is generated instead of two.\n
    \                This was an intentional design decision; don't try to\n                 \"fix\"
    it.\n         4.2.2.11  Recovery from Old Duplicate SYN: RFC-793 Section 3.4,\n
    \           page 33\n            Note that a TCP implementation MUST keep track
    of whether a\n            connection has reached SYN_RCVD state as the result
    of a\n            passive OPEN or an active OPEN.\n         4.2.2.12  RST Segment:
    RFC-793 Section 3.4\n            A TCP SHOULD allow a received RST segment to
    include data.\n            DISCUSSION\n                 It has been suggested
    that a RST segment could contain\n                 ASCII text that encoded and
    explained the cause of the\n                 RST.  No standard has yet been established
    for such\n                 data.\n         4.2.2.13  Closing a Connection: RFC-793
    Section 3.5\n            A TCP connection may terminate in two ways: (1) the normal\n
    \           TCP close sequence using a FIN handshake, and (2) an \"abort\"\n            in
    which one or more RST segments are sent and the\n            connection state
    is immediately discarded.  If a TCP\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n            connection
    is closed by the remote site, the local\n            application MUST be informed
    whether it closed normally or\n            was aborted.\n            The normal
    TCP close sequence delivers buffered data\n            reliably in both directions.
    \ Since the two directions of a\n            TCP connection are closed independently,
    it is possible for\n            a connection to be \"half closed,\" i.e., closed
    in only one\n            direction, and a host is permitted to continue sending
    data\n            in the open direction on a half-closed connection.\n            A
    host MAY implement a \"half-duplex\" TCP close sequence, so\n            that
    an application that has called CLOSE cannot continue to\n            read data
    from the connection.  If such a host issues a\n            CLOSE call while received
    data is still pending in TCP, or\n            if new data is received after CLOSE
    is called, its TCP\n            SHOULD send a RST to show that data was lost.\n
    \           When a connection is closed actively, it MUST linger in\n            TIME-WAIT
    state for a time 2xMSL (Maximum Segment Lifetime).\n            However, it MAY
    accept a new SYN from the remote TCP to\n            reopen the connection directly
    from TIME-WAIT state, if it:\n            (1)  assigns its initial sequence number
    for the new\n                 connection to be larger than the largest sequence\n
    \                number it used on the previous connection incarnation,\n                 and\n
    \           (2)  returns to TIME-WAIT state if the SYN turns out to be\n                 an
    old duplicate.\n            DISCUSSION:\n                 TCP's full-duplex data-preserving
    close is a feature\n                 that is not included in the analogous ISO
    transport\n                 protocol TP4.\n                 Some systems have
    not implemented half-closed\n                 connections, presumably because
    they do not fit into\n                 the I/O model of their particular operating
    system.  On\n                 these systems, once an application has called CLOSE,
    it\n                 can no longer read input data from the connection; this\n
    \                is referred to as a \"half-duplex\" TCP close sequence.\n                 The
    graceful close algorithm of TCP requires that the\n                 connection
    state remain defined on (at least)  one end\n                 of the connection,
    for a timeout period of 2xMSL, i.e.,\n                 4 minutes.  During this
    period, the (remote socket,\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 local
    socket) pair that defines the connection is busy\n                 and cannot
    be reused.  To shorten the time that a given\n                 port pair is tied
    up, some TCPs allow a new SYN to be\n                 accepted in TIME-WAIT state.\n
    \        4.2.2.14  Data Communication: RFC-793 Section 3.7, page 40\n            Since
    RFC-793 was written, there has been extensive work on\n            TCP algorithms
    to achieve efficient data communication.\n            Later sections of the present
    document describe required and\n            recommended TCP algorithms to determine
    when to send data\n            (Section 4.2.3.4), when to send an acknowledgment
    (Section\n            4.2.3.2), and when to update the window (Section 4.2.3.3).\n
    \           DISCUSSION:\n                 One important performance issue is \"Silly
    Window\n                 Syndrome\" or \"SWS\" [TCP:5], a stable pattern of small\n
    \                incremental window movements resulting in extremely\n                 poor
    TCP performance.  Algorithms to avoid SWS are\n                 described below
    for both the sending side (Section\n                 4.2.3.4) and the receiving
    side (Section 4.2.3.3).\n                 In brief, SWS is caused by the receiver
    advancing the\n                 right window edge whenever it has any new buffer
    space\n                 available to receive data and by the sender using any\n
    \                incremental window, no matter how small, to send more\n                 data
    [TCP:5].  The result can be a stable pattern of\n                 sending tiny
    data segments, even though both sender and\n                 receiver have a large
    total buffer space for the\n                 connection.  SWS can only occur during
    the transmission\n                 of a large amount of data; if the connection
    goes\n                 quiescent, the problem will disappear.  It is caused by\n
    \                typical straightforward implementation of window\n                 management,
    but the sender and receiver algorithms\n                 given below will avoid
    it.\n                 Another important TCP performance issue is that some\n                 applications,
    especially remote login to character-at-\n                 a-time hosts, tend
    to send streams of one-octet data\n                 segments.  To avoid deadlocks,
    every TCP SEND call from\n                 such applications must be \"pushed\",
    either explicitly\n                 by the application or else implicitly by TCP.
    \ The\n                 result may be a stream of TCP segments that contain one\n
    \                data octet each, which makes very inefficient use of\n                 the
    Internet and contributes to Internet congestion.\n                 The Nagle Algorithm
    described in Section 4.2.3.4\n                 provides a simple and effective
    solution to this\n                 problem.  It does have the effect of clumping\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 characters
    over Telnet connections; this may initially\n                 surprise users accustomed
    to single-character echo, but\n                 user acceptance has not been a
    problem.\n                 Note that the Nagle algorithm and the send SWS\n                 avoidance
    algorithm play complementary roles in\n                 improving performance.
    \ The Nagle algorithm discourages\n                 sending tiny segments when
    the data to be sent\n                 increases in small increments, while the
    SWS avoidance\n                 algorithm discourages small segments resulting
    from the\n                 right window edge advancing in small increments.\n
    \                A careless implementation can send two or more\n                 acknowledgment
    segments per data segment received.  For\n                 example, suppose the
    receiver acknowledges every data\n                 segment immediately.  When
    the application program\n                 subsequently consumes the data and increases
    the\n                 available receive buffer space again, the receiver may\n
    \                send a second acknowledgment segment to update the\n                 window
    at the sender.  The extreme case occurs with\n                 single-character
    segments on TCP connections using the\n                 Telnet protocol for remote
    login service.  Some\n                 implementations have been observed in which
    each\n                 incoming 1-character segment generates three return\n                 segments:
    (1) the acknowledgment, (2) a one byte\n                 increase in the window,
    and (3) the echoed character,\n                 respectively.\n         4.2.2.15
    \ Retransmission Timeout: RFC-793 Section 3.7, page 41\n            The algorithm
    suggested in RFC-793 for calculating the\n            retransmission timeout is
    now known to be inadequate; see\n            Section 4.2.3.1 below.\n            Recent
    work by Jacobson [TCP:7] on Internet congestion and\n            TCP retransmission
    stability has produced a transmission\n            algorithm combining \"slow
    start\" with \"congestion\n            avoidance\".  A TCP MUST implement this
    algorithm.\n            If a retransmitted packet is identical to the original\n
    \           packet (which implies not only that the data boundaries have\n            not
    changed, but also that the window and acknowledgment\n            fields of the
    header have not changed), then the same IP\n            Identification field MAY
    be used (see Section 3.2.1.5).\n            IMPLEMENTATION:\n                 Some
    TCP implementors have chosen to \"packetize\" the\n                 data stream,
    i.e., to pick segment boundaries when\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 segments
    are originally sent and to queue these\n                 segments in a \"retransmission
    queue\" until they are\n                 acknowledged.  Another design (which
    may be simpler) is\n                 to defer packetizing until each time data
    is\n                 transmitted or retransmitted, so there will be no\n                 segment
    retransmission queue.\n                 In an implementation with a segment retransmission\n
    \                queue, TCP performance may be enhanced by repacketizing\n                 the
    segments awaiting acknowledgment when the first\n                 retransmission
    timeout occurs.  That is, the\n                 outstanding segments that fitted
    would be combined into\n                 one maximum-sized segment, with a new
    IP Identification\n                 value.  The TCP would then retain this combined
    segment\n                 in the retransmit queue until it was acknowledged.\n
    \                However, if the first two segments in the\n                 retransmission
    queue totalled more than one maximum-\n                 sized segment, the TCP
    would retransmit only the first\n                 segment using the original IP
    Identification field.\n         4.2.2.16  Managing the Window: RFC-793 Section
    3.7, page 41\n            A TCP receiver SHOULD NOT shrink the window, i.e., move
    the\n            right window edge to the left.  However, a sending TCP MUST\n
    \           be robust against window shrinking, which may cause the\n            \"useable
    window\" (see Section 4.2.3.4) to become negative.\n            If this happens,
    the sender SHOULD NOT send new data, but\n            SHOULD retransmit normally
    the old unacknowledged data\n            between SND.UNA and SND.UNA+SND.WND.
    \ The sender MAY also\n            retransmit old data beyond SND.UNA+SND.WND,
    but SHOULD NOT\n            time out the connection if data beyond the right window
    edge\n            is not acknowledged.  If the window shrinks to zero, the TCP\n
    \           MUST probe it in the standard way (see next Section).\n            DISCUSSION:\n
    \                Many TCP implementations become confused if the window\n                 shrinks
    from the right after data has been sent into a\n                 larger window.
    \ Note that TCP has a heuristic to select\n                 the latest window
    update despite possible datagram\n                 reordering; as a result, it
    may ignore a window update\n                 with a smaller window than previously
    offered if\n                 neither the sequence number nor the acknowledgment\n
    \                number is increased.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n         4.2.2.17
    \ Probing Zero Windows: RFC-793 Section 3.7, page 42\n            Probing of zero
    (offered) windows MUST be supported.\n            A TCP MAY keep its offered receive
    window closed\n            indefinitely.  As long as the receiving TCP continues
    to\n            send acknowledgments in response to the probe segments, the\n
    \           sending TCP MUST allow the connection to stay open.\n            DISCUSSION:\n
    \                It is extremely important to remember that ACK\n                 (acknowledgment)
    segments that contain no data are not\n                 reliably transmitted by
    TCP.  If zero window probing is\n                 not supported, a connection
    may hang forever when an\n                 ACK segment that re-opens the window
    is lost.\n                 The delay in opening a zero window generally occurs\n
    \                when the receiving application stops taking data from\n                 its
    TCP.  For example, consider a printer daemon\n                 application, stopped
    because the printer ran out of\n                 paper.\n            The transmitting
    host SHOULD send the first zero-window\n            probe when a zero window has
    existed for the retransmission\n            timeout period (see Section 4.2.2.15),
    and SHOULD increase\n            exponentially the interval between successive
    probes.\n            DISCUSSION:\n                 This procedure minimizes delay
    if the zero-window\n                 condition is due to a lost ACK segment containing
    a\n                 window-opening update.  Exponential backoff is\n                 recommended,
    possibly with some maximum interval not\n                 specified here.  This
    procedure is similar to that of\n                 the retransmission algorithm,
    and it may be possible to\n                 combine the two procedures in the
    implementation.\n         4.2.2.18  Passive OPEN Calls:  RFC-793 Section 3.8\n
    \           Every passive OPEN call either creates a new connection\n            record
    in LISTEN state, or it returns an error; it MUST NOT\n            affect any previously
    created connection record.\n            A TCP that supports multiple concurrent
    users MUST provide\n            an OPEN call that will functionally allow an application
    to\n            LISTEN on a port while a connection block with the same\n            local
    port is in SYN-SENT or SYN-RECEIVED state.\n            DISCUSSION:\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 Some
    applications (e.g., SMTP servers) may need to\n                 handle multiple
    connection attempts at about the same\n                 time.  The probability
    of a connection attempt failing\n                 is reduced by giving the application
    some means of\n                 listening for a new connection at the same time
    that an\n                 earlier connection attempt is going through the three-\n
    \                way handshake.\n            IMPLEMENTATION:\n                 Acceptable
    implementations of concurrent opens may\n                 permit multiple passive
    OPEN calls, or they may allow\n                 \"cloning\" of LISTEN-state connections
    from a single\n                 passive OPEN call.\n         4.2.2.19  Time to
    Live: RFC-793 Section 3.9, page 52\n            RFC-793 specified that TCP was
    to request the IP layer to\n            send TCP segments with TTL = 60.  This
    is obsolete; the TTL\n            value used to send TCP segments MUST be configurable.
    \ See\n            Section 3.2.1.7 for discussion.\n         4.2.2.20  Event Processing:
    RFC-793 Section 3.9\n            While it is not strictly required, a TCP SHOULD
    be capable\n            of queueing out-of-order TCP segments.  Change the \"may\"
    in\n            the last sentence of the first paragraph on page 70 to\n            \"should\".\n
    \           DISCUSSION:\n                 Some small-host implementations have
    omitted segment\n                 queueing because of limited buffer space.  This\n
    \                omission may be expected to adversely affect TCP\n                 throughput,
    since loss of a single segment causes all\n                 later segments to
    appear to be \"out of sequence\".\n            In general, the processing of received
    segments MUST be\n            implemented to aggregate ACK segments whenever possible.\n
    \           For example, if the TCP is processing a series of queued\n            segments,
    it MUST process them all before sending any ACK\n            segments.\n            Here
    are some detailed error corrections and notes on the\n            Event Processing
    section of RFC-793.\n            (a)  CLOSE Call, CLOSE-WAIT state, p. 61: enter
    LAST-ACK\n                 state, not CLOSING.\n            (b)  LISTEN state,
    check for SYN (pp. 65, 66): With a SYN\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 bit,
    if the security/compartment or the precedence is\n                 wrong for the
    segment, a reset is sent.  The wrong form\n                 of reset is shown
    in the text; it should be:\n                   <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n
    \           (c)  SYN-SENT state, Check for SYN, p. 68: When the\n                 connection
    enters ESTABLISHED state, the following\n                 variables must be set:\n
    \                   SND.WND <- SEG.WND\n                    SND.WL1 <- SEG.SEQ\n
    \                   SND.WL2 <- SEG.ACK\n            (d)  Check security and precedence,
    p. 71: The first heading\n                 \"ESTABLISHED STATE\" should really
    be a list of all\n                 states other than SYN-RECEIVED: ESTABLISHED,
    FIN-WAIT-\n                 1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, and\n
    \                TIME-WAIT.\n            (e)  Check SYN bit, p. 71:  \"In SYN-RECEIVED
    state and if\n                 the connection was initiated with a passive OPEN,
    then\n                 return this connection to the LISTEN state and return.\n
    \                Otherwise...\".\n            (f)  Check ACK field, SYN-RECEIVED
    state, p. 72: When the\n                 connection enters ESTABLISHED state,
    the variables\n                 listed in (c) must be set.\n            (g)  Check
    ACK field, ESTABLISHED state, p. 72: The ACK is a\n                 duplicate
    if SEG.ACK =< SND.UNA (the = was omitted).\n                 Similarly, the window
    should be updated if: SND.UNA =<\n                 SEG.ACK =< SND.NXT.\n            (h)
    \ USER TIMEOUT, p. 77:\n                 It would be better to notify the application
    of the\n                 timeout rather than letting TCP force the connection\n
    \                closed.  However, see also Section 4.2.3.5.\n         4.2.2.21
    \ Acknowledging Queued Segments: RFC-793 Section 3.9\n            A TCP MAY send
    an ACK segment acknowledging RCV.NXT when a\n            valid segment arrives
    that is in the window but not at the\n            left window edge.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n            DISCUSSION:\n
    \                RFC-793 (see page 74) was ambiguous about whether or\n                 not
    an ACK segment should be sent when an out-of-order\n                 segment was
    received, i.e., when SEG.SEQ was unequal to\n                 RCV.NXT.\n                 One
    reason for ACKing out-of-order segments might be to\n                 support
    an experimental algorithm known as \"fast\n                 retransmit\".   With
    this algorithm, the sender uses the\n                 \"redundant\" ACK's to deduce
    that a segment has been\n                 lost before the retransmission timer
    has expired.  It\n                 counts the number of times an ACK has been
    received\n                 with the same value of SEG.ACK and with the same right\n
    \                window edge.  If more than a threshold number of such\n                 ACK's
    is received, then the segment containing the\n                 octets starting
    at SEG.ACK is assumed to have been lost\n                 and is retransmitted,
    without awaiting a timeout.  The\n                 threshold is chosen to compensate
    for the maximum\n                 likely segment reordering in the Internet.  There
    is\n                 not yet enough experience with the fast retransmit\n                 algorithm
    to determine how useful it is.\n      4.2.3  SPECIFIC ISSUES\n         4.2.3.1
    \ Retransmission Timeout Calculation\n            A host TCP MUST implement Karn's
    algorithm and Jacobson's\n            algorithm for computing the retransmission
    timeout (\"RTO\").\n            o    Jacobson's algorithm for computing the smoothed
    round-\n                 trip (\"RTT\") time incorporates a simple measure of
    the\n                 variance [TCP:7].\n            o    Karn's algorithm for
    selecting RTT measurements ensures\n                 that ambiguous round-trip
    times will not corrupt the\n                 calculation of the smoothed round-trip
    time [TCP:6].\n            This implementation also MUST include \"exponential
    backoff\"\n            for successive RTO values for the same segment.\n            Retransmission
    of SYN segments SHOULD use the same algorithm\n            as data segments.\n
    \           DISCUSSION:\n                 There were two known problems with the
    RTO calculations\n                 specified in RFC-793.  First, the accurate
    measurement\n                 of RTTs is difficult when there are retransmissions.\n
    \                Second, the algorithm to compute the smoothed round-\n                 trip
    time is inadequate [TCP:7], because it incorrectly\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 assumed
    that the variance in RTT values would be small\n                 and constant.
    \ These problems were solved by Karn's and\n                 Jacobson's algorithm,
    respectively.\n                 The performance increase resulting from the use
    of\n                 these improvements varies from noticeable to dramatic.\n
    \                Jacobson's algorithm for incorporating the measured RTT\n                 variance
    is especially important on a low-speed link,\n                 where the natural
    variation of packet sizes causes a\n                 large variation in RTT.  One
    vendor found link\n                 utilization on a 9.6kb line went from 10%
    to 90% as a\n                 result of implementing Jacobson's variance algorithm
    in\n                 TCP.\n            The following values SHOULD be used to
    initialize the\n            estimation parameters for a new connection:\n            (a)
    \ RTT = 0 seconds.\n            (b)  RTO = 3 seconds.  (The smoothed variance
    is to be\n                 initialized to the value that will result in this RTO).\n
    \           The recommended upper and lower bounds on the RTO are known\n            to
    be inadequate on large internets.  The lower bound SHOULD\n            be measured
    in fractions of a second (to accommodate high\n            speed LANs) and the
    upper bound should be 2*MSL, i.e., 240\n            seconds.\n            DISCUSSION:\n
    \                Experience has shown that these initialization values\n                 are
    reasonable, and that in any case the Karn and\n                 Jacobson algorithms
    make TCP behavior reasonably\n                 insensitive to the initial parameter
    choices.\n         4.2.3.2  When to Send an ACK Segment\n            A host that
    is receiving a stream of TCP data segments can\n            increase efficiency
    in both the Internet and the hosts by\n            sending fewer than one ACK
    (acknowledgment) segment per data\n            segment received; this is known
    as a \"delayed ACK\" [TCP:5].\n            A TCP SHOULD implement a delayed ACK,
    but an ACK should not\n            be excessively delayed; in particular, the
    delay MUST be\n            less than 0.5 seconds, and in a stream of full-sized\n
    \           segments there SHOULD be an ACK for at least every second\n            segment.\n
    \           DISCUSSION:\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 A
    delayed ACK gives the application an opportunity to\n                 update the
    window and perhaps to send an immediate\n                 response.  In particular,
    in the case of character-mode\n                 remote login, a delayed ACK can
    reduce the number of\n                 segments sent by the server by a factor
    of 3 (ACK,\n                 window update, and echo character all combined in
    one\n                 segment).\n                 In addition, on some large multi-user
    hosts, a delayed\n                 ACK can substantially reduce protocol processing\n
    \                overhead by reducing the total number of packets to be\n                 processed
    [TCP:5].  However, excessive delays on ACK's\n                 can disturb the
    round-trip timing and packet \"clocking\"\n                 algorithms [TCP:7].\n
    \        4.2.3.3  When to Send a Window Update\n            A TCP MUST include
    a SWS avoidance algorithm in the receiver\n            [TCP:5].\n            IMPLEMENTATION:\n
    \                The receiver's SWS avoidance algorithm determines when\n                 the
    right window edge may be advanced; this is\n                 customarily known
    as \"updating the window\".  This\n                 algorithm combines with the
    delayed ACK algorithm (see\n                 Section 4.2.3.2) to determine when
    an ACK segment\n                 containing the current window will really be
    sent to\n                 the receiver.  We use the notation of RFC-793; see\n
    \                Figures 4 and 5 in that document.\n                 The solution
    to receiver SWS is to avoid advancing the\n                 right window edge
    RCV.NXT+RCV.WND in small increments,\n                 even if data is received
    from the network in small\n                 segments.\n                 Suppose
    the total receive buffer space is RCV.BUFF.  At\n                 any given moment,
    RCV.USER octets of this total may be\n                 tied up with data that
    has been received and\n                 acknowledged but which the user process
    has not yet\n                 consumed.  When the connection is quiescent, RCV.WND
    =\n                 RCV.BUFF and RCV.USER = 0.\n                 Keeping the right
    window edge fixed as data arrives and\n                 is acknowledged requires
    that the receiver offer less\n                 than its full buffer space, i.e.,
    the receiver must\n                 specify a RCV.WND that keeps RCV.NXT+RCV.WND
    constant\n                 as RCV.NXT increases.  Thus, the total buffer space\n
    \                RCV.BUFF is generally divided into three parts:\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 |<-------
    RCV.BUFF ---------------->|\n                      1             2            3\n
    \            ----|---------|------------------|------|----\n                        RCV.NXT
    \              ^\n                                           (Fixed)\n             1
    - RCV.USER =  data received but not yet consumed;\n             2 - RCV.WND =
    \  space advertised to sender;\n             3 - Reduction = space available but
    not yet\n                             advertised.\n                 The suggested
    SWS avoidance algorithm for the receiver\n                 is to keep RCV.NXT+RCV.WND
    fixed until the reduction\n                 satisfies:\n                      RCV.BUFF
    - RCV.USER - RCV.WND  >=\n                             min( Fr * RCV.BUFF, Eff.snd.MSS
    )\n                 where Fr is a fraction whose recommended value is 1/2,\n                 and
    Eff.snd.MSS is the effective send MSS for the\n                 connection (see
    Section 4.2.2.6).  When the inequality\n                 is satisfied, RCV.WND
    is set to RCV.BUFF-RCV.USER.\n                 Note that the general effect of
    this algorithm is to\n                 advance RCV.WND in increments of Eff.snd.MSS
    (for\n                 realistic receive buffers:  Eff.snd.MSS < RCV.BUFF/2).\n
    \                Note also that the receiver must use its own\n                 Eff.snd.MSS,
    assuming it is the same as the sender's.\n         4.2.3.4  When to Send Data\n
    \           A TCP MUST include a SWS avoidance algorithm in the sender.\n            A
    TCP SHOULD implement the Nagle Algorithm [TCP:9] to\n            coalesce short
    segments.  However, there MUST be a way for\n            an application to disable
    the Nagle algorithm on an\n            individual connection.  In all cases, sending
    data is also\n            subject to the limitation imposed by the Slow Start\n
    \           algorithm (Section 4.2.2.15).\n            DISCUSSION:\n                 The
    Nagle algorithm is generally as follows:\n                      If there is unacknowledged
    data (i.e., SND.NXT >\n                      SND.UNA), then the sending TCP buffers
    all user\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                      data
    (regardless of the PSH bit), until the\n                      outstanding data
    has been acknowledged or until\n                      the TCP can send a full-sized
    segment (Eff.snd.MSS\n                      bytes; see Section 4.2.2.6).\n                 Some
    applications (e.g., real-time display window\n                 updates) require
    that the Nagle algorithm be turned\n                 off, so small data segments
    can be streamed out at the\n                 maximum rate.\n            IMPLEMENTATION:\n
    \                The sender's SWS avoidance algorithm is more difficult\n                 than
    the receivers's, because the sender does not know\n                 (directly)
    the receiver's total buffer space RCV.BUFF.\n                 An approach which
    has been found to work well is for\n                 the sender to calculate Max(SND.WND),
    the maximum send\n                 window it has seen so far on the connection,
    and to use\n                 this value as an estimate of RCV.BUFF.  Unfortunately,\n
    \                this can only be an estimate; the receiver may at any\n                 time
    reduce the size of RCV.BUFF.  To avoid a resulting\n                 deadlock,
    it is necessary to have a timeout to force\n                 transmission of data,
    overriding the SWS avoidance\n                 algorithm.  In practice, this timeout
    should seldom\n                 occur.\n                 The \"useable window\"
    [TCP:5] is:\n                      U = SND.UNA + SND.WND - SND.NXT\n                 i.e.,
    the offered window less the amount of data sent\n                 but not acknowledged.
    \ If D is the amount of data\n                 queued in the sending TCP but not
    yet sent, then the\n                 following set of rules is recommended.\n
    \                Send data:\n                 (1)  if a maximum-sized segment
    can be sent, i.e, if:\n                           min(D,U) >= Eff.snd.MSS;\n                 (2)
    \ or if the data is pushed and all queued data can\n                      be sent
    now, i.e., if:\n                          [SND.NXT = SND.UNA and] PUSHED and D
    <= U\n                      (the bracketed condition is imposed by the Nagle\n
    \                     algorithm);\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 (3)
    \ or if at least a fraction Fs of the maximum window\n                      can
    be sent, i.e., if:\n                          [SND.NXT = SND.UNA and]\n                                  min(D.U)
    >= Fs * Max(SND.WND);\n                 (4)  or if data is PUSHed and the override
    timeout\n                      occurs.\n                 Here Fs is a fraction
    whose recommended value is 1/2.\n                 The override timeout should
    be in the range 0.1 - 1.0\n                 seconds.  It may be convenient to
    combine this timer\n                 with the timer used to probe zero windows
    (Section\n                 4.2.2.17).\n                 Finally, note that the
    SWS avoidance algorithm just\n                 specified is to be used instead
    of the sender-side\n                 algorithm contained in [TCP:5].\n         4.2.3.5
    \ TCP Connection Failures\n            Excessive retransmission of the same segment
    by TCP\n            indicates some failure of the remote host or the Internet\n
    \           path.  This failure may be of short or long duration.  The\n            following
    procedure MUST be used to handle excessive\n            retransmissions of data
    segments [IP:11]:\n            (a)  There are two thresholds R1 and R2 measuring
    the amount\n                 of retransmission that has occurred for the same\n
    \                segment.  R1 and R2 might be measured in time units or\n                 as
    a count of retransmissions.\n            (b)  When the number of transmissions
    of the same segment\n                 reaches or exceeds threshold R1, pass negative
    advice\n                 (see Section 3.3.1.4) to the IP layer, to trigger\n                 dead-gateway
    diagnosis.\n            (c)  When the number of transmissions of the same segment\n
    \                reaches a threshold R2 greater than R1, close the\n                 connection.\n
    \           (d)  An application MUST be able to set the value for R2 for\n                 a
    particular connection.  For example, an interactive\n                 application
    might set R2 to \"infinity,\" giving the user\n                 control over when
    to disconnect.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n            (d)
    \ TCP SHOULD inform the application of the delivery\n                 problem
    (unless such information has been disabled by\n                 the application;
    see Section 4.2.4.1), when R1 is\n                 reached and before R2.  This
    will allow a remote login\n                 (User Telnet) application program
    to inform the user,\n                 for example.\n            The value of R1
    SHOULD correspond to at least 3\n            retransmissions, at the current RTO.
    \ The value of R2 SHOULD\n            correspond to at least 100 seconds.\n            An
    attempt to open a TCP connection could fail with\n            excessive retransmissions
    of the SYN segment or by receipt\n            of a RST segment or an ICMP Port
    Unreachable.  SYN\n            retransmissions MUST be handled in the general
    way just\n            described for data retransmissions, including notification\n
    \           of the application layer.\n            However, the values of R1 and
    R2 may be different for SYN\n            and data segments.  In particular, R2
    for a SYN segment MUST\n            be set large enough to provide retransmission
    of the segment\n            for at least 3 minutes.  The application can close
    the\n            connection (i.e., give up on the open attempt) sooner, of\n            course.\n
    \           DISCUSSION:\n                 Some Internet paths have significant
    setup times, and\n                 the number of such paths is likely to increase
    in the\n                 future.\n         4.2.3.6  TCP Keep-Alives\n            Implementors
    MAY include \"keep-alives\" in their TCP\n            implementations, although
    this practice is not universally\n            accepted.  If keep-alives are included,
    the application MUST\n            be able to turn them on or off for each TCP
    connection, and\n            they MUST default to off.\n            Keep-alive
    packets MUST only be sent when no data or\n            acknowledgement packets
    have been received for the\n            connection within an interval.  This interval
    MUST be\n            configurable and MUST default to no less than two hours.\n
    \           It is extremely important to remember that ACK segments that\n            contain
    no data are not reliably transmitted by TCP.\n            Consequently, if a keep-alive
    mechanism is implemented it\n            MUST NOT interpret failure to respond
    to any specific probe\n            as a dead connection.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n            An
    implementation SHOULD send a keep-alive segment with no\n            data; however,
    it MAY be configurable to send a keep-alive\n            segment containing one
    garbage octet, for compatibility with\n            erroneous TCP implementations.\n
    \           DISCUSSION:\n                 A \"keep-alive\" mechanism periodically
    probes the other\n                 end of a connection when the connection is
    otherwise\n                 idle, even when there is no data to be sent.  The
    TCP\n                 specification does not include a keep-alive mechanism\n
    \                because it could:  (1) cause perfectly good connections\n                 to
    break during transient Internet failures; (2)\n                 consume unnecessary
    bandwidth (\"if no one is using the\n                 connection, who cares if
    it is still good?\"); and (3)\n                 cost money for an Internet path
    that charges for\n                 packets.\n                 Some TCP implementations,
    however, have included a\n                 keep-alive mechanism.  To confirm that
    an idle\n                 connection is still active, these implementations send\n
    \                a probe segment designed to elicit a response from the\n                 peer
    TCP.  Such a segment generally contains SEG.SEQ =\n                 SND.NXT-1
    and may or may not contain one garbage octet\n                 of data.  Note
    that on a quiet connection SND.NXT =\n                 RCV.NXT, so that this SEG.SEQ
    will be outside the\n                 window.  Therefore, the probe causes the
    receiver to\n                 return an acknowledgment segment, confirming that
    the\n                 connection is still live.  If the peer has dropped the\n
    \                connection due to a network partition or a crash, it\n                 will
    respond with a RST instead of an acknowledgment\n                 segment.\n                 Unfortunately,
    some misbehaved TCP implementations fail\n                 to respond to a segment
    with SEG.SEQ = SND.NXT-1 unless\n                 the segment contains data.  Alternatively,
    an\n                 implementation could determine whether a peer responded\n
    \                correctly to keep-alive packets with no garbage data\n                 octet.\n
    \                A TCP keep-alive mechanism should only be invoked in\n                 server
    applications that might otherwise hang\n                 indefinitely and consume
    resources unnecessarily if a\n                 client crashes or aborts a connection
    during a network\n                 failure.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n         4.2.3.7
    \ TCP Multihoming\n            If an application on a multihomed host does not
    specify the\n            local IP address when actively opening a TCP connection,\n
    \           then the TCP MUST ask the IP layer to select a local IP\n            address
    before sending the (first) SYN.  See the function\n            GET_SRCADDR() in
    Section 3.4.\n            At all other times, a previous segment has either been
    sent\n            or received on this connection, and TCP MUST use the same\n
    \           local address is used that was used in those previous\n            segments.\n
    \        4.2.3.8  IP Options\n            When received options are passed up
    to TCP from the IP\n            layer, TCP MUST ignore options that it does not
    understand.\n            A TCP MAY support the Time Stamp and Record Route options.\n
    \           An application MUST be able to specify a source route when\n            it
    actively opens a TCP connection, and this MUST take\n            precedence over
    a source route received in a datagram.\n            When a TCP connection is OPENed
    passively and a packet\n            arrives with a completed IP Source Route option
    (containing\n            a return route), TCP MUST save the return route and use
    it\n            for all segments sent on this connection.  If a different\n            source
    route arrives in a later segment, the later\n            definition SHOULD override
    the earlier one.\n         4.2.3.9  ICMP Messages\n            TCP MUST act on
    an ICMP error message passed up from the IP\n            layer, directing it to
    the connection that created the\n            error.  The necessary demultiplexing
    information can be\n            found in the IP header contained within the ICMP
    message.\n            o    Source Quench\n                 TCP MUST react to a
    Source Quench by slowing\n                 transmission on the connection.  The
    RECOMMENDED\n                 procedure is for a Source Quench to trigger a \"slow\n
    \                start,\" as if a retransmission timeout had occurred.\n            o
    \   Destination Unreachable -- codes 0, 1, 5\n                 Since these Unreachable
    messages indicate soft error\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 conditions,
    TCP MUST NOT abort the connection, and it\n                 SHOULD make the information
    available to the\n                 application.\n                 DISCUSSION:\n
    \                     TCP could report the soft error condition directly\n                      to
    the application layer with an upcall to the\n                      ERROR_REPORT
    routine, or it could merely note the\n                      message and report
    it to the application only when\n                      and if the TCP connection
    times out.\n            o    Destination Unreachable -- codes 2-4\n                 These
    are hard error conditions, so TCP SHOULD abort\n                 the connection.\n
    \           o    Time Exceeded -- codes 0, 1\n                 This should be
    handled the same way as Destination\n                 Unreachable codes 0, 1,
    5 (see above).\n            o    Parameter Problem\n                 This should
    be handled the same way as Destination\n                 Unreachable codes 0,
    1, 5 (see above).\n         4.2.3.10  Remote Address Validation\n            A
    TCP implementation MUST reject as an error a local OPEN\n            call for
    an invalid remote IP address (e.g., a broadcast or\n            multicast address).\n
    \           An incoming SYN with an invalid source address must be\n            ignored
    either by TCP or by the IP layer (see Section\n            3.2.1.3).\n            A
    TCP implementation MUST silently discard an incoming SYN\n            segment
    that is addressed to a broadcast or multicast\n            address.\n         4.2.3.11
    \ TCP Traffic Patterns\n            IMPLEMENTATION:\n                 The TCP
    protocol specification [TCP:1] gives the\n                 implementor much freedom
    in designing the algorithms\n                 that control the message flow over
    the connection --\n                 packetizing, managing the window, sending\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                 acknowledgments,
    etc.  These design decisions are\n                 difficult because a TCP must
    adapt to a wide range of\n                 traffic patterns.  Experience has shown
    that a TCP\n                 implementor needs to verify the design on two extreme\n
    \                traffic patterns:\n                 o    Single-character Segments\n
    \                     Even if the sender is using the Nagle Algorithm,\n                      when
    a TCP connection carries remote login traffic\n                      across a
    low-delay LAN the receiver will generally\n                      get a stream
    of single-character segments.  If\n                      remote terminal echo
    mode is in effect, the\n                      receiver's system will generally
    echo each\n                      character as it is received.\n                 o
    \   Bulk Transfer\n                      When TCP is used for bulk transfer, the
    data\n                      stream should be made up (almost) entirely of\n                      segments
    of the size of the effective MSS.\n                      Although TCP uses a sequence
    number space with\n                      byte (octet) granularity, in bulk-transfer
    mode\n                      its operation should be as if TCP used a sequence\n
    \                     space that counted only segments.\n                 Experience
    has furthermore shown that a single TCP can\n                 effectively and
    efficiently handle these two extremes.\n                 The most important tool
    for verifying a new TCP\n                 implementation is a packet trace program.
    \ There is a\n                 large volume of experience showing the importance
    of\n                 tracing a variety of traffic patterns with other TCP\n                 implementations
    and studying the results carefully.\n         4.2.3.12  Efficiency\n            IMPLEMENTATION:\n
    \                Extensive experience has led to the following\n                 suggestions
    for efficient implementation of TCP:\n                 (a)  Don't Copy Data\n
    \                     In bulk data transfer, the primary CPU-intensive\n                      tasks
    are copying data from one place to another\n                      and checksumming
    the data.  It is vital to\n                      minimize the number of copies
    of TCP data.  Since\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                      the
    ultimate speed limitation may be fetching data\n                      across the
    memory bus, it may be useful to combine\n                      the copy with checksumming,
    doing both with a\n                      single memory fetch.\n                 (b)
    \ Hand-Craft the Checksum Routine\n                      A good TCP checksumming
    routine is typically two\n                      to five times faster than a simple
    and direct\n                      implementation of the definition.  Great care
    and\n                      clever coding are often required and advisable to\n
    \                     make the checksumming code \"blazing fast\".  See\n                      [TCP:10].\n
    \                (c)  Code for the Common Case\n                      TCP protocol
    processing can be complicated, but\n                      for most segments there
    are only a few simple\n                      decisions to be made.  Per-segment
    processing will\n                      be greatly speeded up by coding the main
    line to\n                      minimize the number of decisions in the most\n
    \                     common case.\n      4.2.4  TCP/APPLICATION LAYER INTERFACE\n
    \        4.2.4.1  Asynchronous Reports\n            There MUST be a mechanism
    for reporting soft TCP error\n            conditions to the application.  Generically,
    we assume this\n            takes the form of an application-supplied ERROR_REPORT\n
    \           routine that may be upcalled [INTRO:7] asynchronously from\n            the
    transport layer:\n               ERROR_REPORT(local connection name, reason, subreason)\n
    \           The precise encoding of the reason and subreason parameters\n            is
    not specified here.  However, the conditions that are\n            reported asynchronously
    to the application MUST include:\n            *    ICMP error message arrived
    (see 4.2.3.9)\n            *    Excessive retransmissions (see 4.2.3.5)\n            *
    \   Urgent pointer advance (see 4.2.2.4).\n            However, an application
    program that does not want to\n            receive such ERROR_REPORT calls SHOULD
    be able to\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n            effectively
    disable these calls.\n            DISCUSSION:\n                 These error reports
    generally reflect soft errors that\n                 can be ignored without harm
    by many applications.  It\n                 has been suggested that these error
    report calls should\n                 default to \"disabled,\" but this is not
    required.\n         4.2.4.2  Type-of-Service\n            The application layer
    MUST be able to specify the Type-of-\n            Service (TOS) for segments that
    are sent on a connection.\n            It not required, but the application SHOULD
    be able to\n            change the TOS during the connection lifetime.  TCP SHOULD\n
    \           pass the current TOS value without change to the IP layer,\n            when
    it sends segments on the connection.\n            The TOS will be specified independently
    in each direction on\n            the connection, so that the receiver application
    will\n            specify the TOS used for ACK segments.\n            TCP MAY
    pass the most recently received TOS up to the\n            application.\n            DISCUSSION\n
    \                Some applications (e.g., SMTP) change the nature of\n                 their
    communication during the lifetime of a\n                 connection, and therefore
    would like to change the TOS\n                 specification.\n                 Note
    also that the OPEN call specified in RFC-793\n                 includes a parameter
    (\"options\") in which the caller\n                 can specify IP options such
    as source route, record\n                 route, or timestamp.\n         4.2.4.3
    \ Flush Call\n            Some TCP implementations have included a FLUSH call,
    which\n            will empty the TCP send queue of any data for which the user\n
    \           has issued SEND calls but which is still to the right of the\n            current
    send window.  That is, it flushes as much queued\n            send data as possible
    without losing sequence number\n            synchronization.  This is useful for
    implementing the \"abort\n            output\" function of Telnet.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n         4.2.4.4
    \ Multihoming\n            The user interface outlined in sections 2.7 and 3.8
    of RFC-\n            793 needs to be extended for multihoming.  The OPEN call\n
    \           MUST have an optional parameter:\n                OPEN( ... [local
    IP address,] ... )\n            to allow the specification of the local IP address.\n
    \           DISCUSSION:\n                 Some TCP-based applications need to
    specify the local\n                 IP address to be used to open a particular
    connection;\n                 FTP is an example.\n            IMPLEMENTATION:\n
    \                A passive OPEN call with a specified \"local IP address\"\n                 parameter
    will await an incoming connection request to\n                 that address.  If
    the parameter is unspecified, a\n                 passive OPEN will await an incoming
    connection request\n                 to any local IP address, and then bind the
    local IP\n                 address of the connection to the particular address\n
    \                that is used.\n                 For an active OPEN call, a specified
    \"local IP address\"\n                 parameter will be used for opening the
    connection.  If\n                 the parameter is unspecified, the networking
    software\n                 will choose an appropriate local IP address (see\n
    \                Section 3.3.4.2) for the connection\n      4.2.5  TCP REQUIREMENT
    SUMMARY\n                                                 |        | | | |S| |\n
    \                                                |        | | | |H| |F\n                                                 |
    \       | | | |O|M|o\n                                                 |        |
    |S| |U|U|o\n                                                 |        | |H| |L|S|t\n
    \                                                |        |M|O| |D|T|n\n                                                 |
    \       |U|U|M| | |o\n                                                 |        |S|L|A|N|N|t\n
    \                                                |        |T|D|Y|O|O|t\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - 'FEATURE                                          |SECTION | | | |T|T|e

    '
  title: FEATURE                                          |SECTION | | | |T|T|e
- contents:
  - "-------------------------------------------------|--------|-|-|-|-|-|--\n                                                 |
    \       | | | | | |\n"
  title: '-------------------------------------------------|--------|-|-|-|-|-|--'
- contents:
  - "Push flag                                        |        | | | | | |\n  Aggregate
    or queue un-pushed data              |4.2.2.2 | | |x| | |\n  Sender collapse successive
    PSH flags           |4.2.2.2 | |x| | | |\n  SEND call can specify PUSH                     |4.2.2.2
    | | |x| | |\n"
  title: Push flag                                        |        | | | | | |
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n    If
    cannot: sender buffer indefinitely        |4.2.2.2 | | | | |x|\n    If cannot:
    PSH last segment                  |4.2.2.2 |x| | | | |\n  Notify receiving ALP
    of PSH                    |4.2.2.2 | | |x| | |1\n  Send max size segment when
    possible            |4.2.2.2 | |x| | | |\n                                                 |
    \       | | | | | |\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "Window                                           |        | | | | | |\n  Treat
    as unsigned number                       |4.2.2.3 |x| | | | |\n  Handle as 32-bit
    number                        |4.2.2.3 | |x| | | |\n  Shrink window from right
    \                      |4.2.2.16| | | |x| |\n  Robust against shrinking window
    \               |4.2.2.16|x| | | | |\n  Receiver's window closed indefinitely
    \         |4.2.2.17| | |x| | |\n  Sender probe zero window                       |4.2.2.17|x|
    | | | |\n    First probe after RTO                        |4.2.2.17| |x| | | |\n
    \   Exponential backoff                          |4.2.2.17| |x| | | |\n  Allow
    window stay zero indefinitely            |4.2.2.17|x| | | | |\n  Sender timeout
    OK conn with zero wind          |4.2.2.17| | | | |x|\n                                                 |
    \       | | | | | |\n"
  title: Window                                           |        | | | | | |
- contents:
  - "Urgent Data                                      |        | | | | | |\n  Pointer
    points to last octet                   |4.2.2.4 |x| | | | |\n  Arbitrary length
    urgent data sequence          |4.2.2.4 |x| | | | |\n  Inform ALP asynchronously
    of urgent data       |4.2.2.4 |x| | | | |1\n  ALP can learn if/how much urgent
    data Q'd      |4.2.2.4 |x| | | | |1\n                                                 |
    \       | | | | | |\n"
  title: Urgent Data                                      |        | | | | | |
- contents:
  - "TCP Options                                      |        | | | | | |\n  Receive
    TCP option in any segment              |4.2.2.5 |x| | | | |\n  Ignore unsupported
    options                     |4.2.2.5 |x| | | | |\n  Cope with illegal option length
    \               |4.2.2.5 |x| | | | |\n  Implement sending & receiving MSS option
    \      |4.2.2.6 |x| | | | |\n  Send MSS option unless 536                     |4.2.2.6
    | |x| | | |\n  Send MSS option always                         |4.2.2.6 | | |x|
    | |\n  Send-MSS default is 536                        |4.2.2.6 |x| | | | |\n  Calculate
    effective send seg size              |4.2.2.6 |x| | | | |\n                                                 |
    \       | | | | | |\n"
  title: TCP Options                                      |        | | | | | |
- contents:
  - "TCP Checksums                                    |        | | | | | |\n  Sender
    compute checksum                        |4.2.2.7 |x| | | | |\n  Receiver check
    checksum                        |4.2.2.7 |x| | | | |\n                                                 |
    \       | | | | | |\n"
  title: TCP Checksums                                    |        | | | | | |
- contents:
  - "Use clock-driven ISN selection                   |4.2.2.9 |x| | | | |\n                                                 |
    \       | | | | | |\n"
  title: Use clock-driven ISN selection                   |4.2.2.9 |x| | | | |
- contents:
  - "Opening Connections                              |        | | | | | |\n  Support
    simultaneous open attempts             |4.2.2.10|x| | | | |\n  SYN-RCVD remembers
    last state                  |4.2.2.11|x| | | | |\n  Passive Open call interfere
    with others        |4.2.2.18| | | | |x|\n  Function: simultan. LISTENs for same
    port      |4.2.2.18|x| | | | |\n  Ask IP for src address for SYN if necc.        |4.2.3.7
    |x| | | | |\n    Otherwise, use local addr of conn.           |4.2.3.7 |x| | |
    | |\n  OPEN to broadcast/multicast IP Address         |4.2.3.14| | | | |x|\n  Silently
    discard seg to bcast/mcast addr       |4.2.3.14|x| | | | |\n"
  title: Opening Connections                              |        | | | | | |
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n                                                 |
    \       | | | | | |\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "Closing Connections                              |        | | | | | |\n  RST
    can contain data                           |4.2.2.12| |x| | | |\n  Inform application
    of aborted conn             |4.2.2.13|x| | | | |\n  Half-duplex close connections
    \                 |4.2.2.13| | |x| | |\n    Send RST to indicate data lost               |4.2.2.13|
    |x| | | |\n  In TIME-WAIT state for 2xMSL seconds           |4.2.2.13|x| | | |
    |\n    Accept SYN from TIME-WAIT state              |4.2.2.13| | |x| | |\n                                                 |
    \       | | | | | |\n"
  title: Closing Connections                              |        | | | | | |
- contents:
  - "Retransmissions                                  |        | | | | | |\n  Jacobson
    Slow Start algorithm                  |4.2.2.15|x| | | | |\n  Jacobson Congestion-Avoidance
    algorithm        |4.2.2.15|x| | | | |\n  Retransmit with same IP ident                  |4.2.2.15|
    | |x| | |\n  Karn's algorithm                               |4.2.3.1 |x| | | |
    |\n  Jacobson's RTO estimation alg.                 |4.2.3.1 |x| | | | |\n  Exponential
    backoff                            |4.2.3.1 |x| | | | |\n  SYN RTO calc same as
    data                      |4.2.3.1 | |x| | | |\n  Recommended initial values and
    bounds          |4.2.3.1 | |x| | | |\n                                                 |
    \       | | | | | |\n"
  title: Retransmissions                                  |        | | | | | |
- contents:
  - "Generating ACK's:                                |        | | | | | |\n  Queue
    out-of-order segments                    |4.2.2.20| |x| | | |\n  Process all Q'd
    before send ACK                |4.2.2.20|x| | | | |\n  Send ACK for out-of-order
    segment              |4.2.2.21| | |x| | |\n  Delayed ACK's                                  |4.2.3.2
    | |x| | | |\n    Delay < 0.5 seconds                          |4.2.3.2 |x| | |
    | |\n    Every 2nd full-sized segment ACK'd           |4.2.3.2 |x| | | | |\n  Receiver
    SWS-Avoidance Algorithm               |4.2.3.3 |x| | | | |\n                                                 |
    \       | | | | | |\n"
  title: 'Generating ACK''s:                                |        | | | | | |'
- contents:
  - "Sending data                                     |        | | | | | |\n  Configurable
    TTL                               |4.2.2.19|x| | | | |\n  Sender SWS-Avoidance
    Algorithm                 |4.2.3.4 |x| | | | |\n  Nagle algorithm                                |4.2.3.4
    | |x| | | |\n    Application can disable Nagle algorithm      |4.2.3.4 |x| | |
    | |\n                                                 |        | | | | | |\n"
  title: Sending data                                     |        | | | | | |
- contents:
  - "Connection Failures:                             |        | | | | | |\n  Negative
    advice to IP on R1 retxs              |4.2.3.5 |x| | | | |\n  Close connection
    on R2 retxs                   |4.2.3.5 |x| | | | |\n  ALP can set R2                                 |4.2.3.5
    |x| | | | |1\n  Inform ALP of  R1<=retxs<R2                    |4.2.3.5 | |x|
    | | |1\n  Recommended values for R1, R2                  |4.2.3.5 | |x| | | |\n
    \ Same mechanism for SYNs                        |4.2.3.5 |x| | | | |\n    R2
    at least 3 minutes for SYN                |4.2.3.5 |x| | | | |\n                                                 |
    \       | | | | | |\n"
  title: 'Connection Failures:                             |        | | | | | |'
- contents:
  - "Send Keep-alive Packets:                         |4.2.3.6 | | |x| | |\n  - Application
    can request                      |4.2.3.6 |x| | | | |\n  - Default is \"off\"
    \                            |4.2.3.6 |x| | | | |\n  - Only send if idle for interval
    \              |4.2.3.6 |x| | | | |\n  - Interval configurable                        |4.2.3.6
    |x| | | | |\n"
  title: 'Send Keep-alive Packets:                         |4.2.3.6 | | |x| | |'
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n  -
    Default at least 2 hrs.                      |4.2.3.6 |x| | | | |\n  - Tolerant
    of lost ACK's                       |4.2.3.6 |x| | | | |\n                                                 |
    \       | | | | | |\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "IP Options                                       |        | | | | | |\n  Ignore
    options TCP doesn't understand          |4.2.3.8 |x| | | | |\n  Time Stamp support
    \                            |4.2.3.8 | | |x| | |\n  Record Route support                           |4.2.3.8
    | | |x| | |\n  Source Route:                                  |        | | | |
    | |\n    ALP can specify                              |4.2.3.8 |x| | | | |1\n
    \     Overrides src rt in datagram               |4.2.3.8 |x| | | | |\n    Build
    return route from src rt               |4.2.3.8 |x| | | | |\n    Later src route
    overrides                    |4.2.3.8 | |x| | | |\n                                                 |
    \       | | | | | |\n"
  title: IP Options                                       |        | | | | | |
- contents:
  - "Receiving ICMP Messages from IP                  |4.2.3.9 |x| | | | |\n  Dest.
    Unreach (0,1,5) => inform ALP            |4.2.3.9 | |x| | | |\n  Dest. Unreach
    (0,1,5) => abort conn            |4.2.3.9 | | | | |x|\n  Dest. Unreach (2-4) =>
    abort conn              |4.2.3.9 | |x| | | |\n  Source Quench => slow start                    |4.2.3.9
    | |x| | | |\n  Time Exceeded => tell ALP, don't abort         |4.2.3.9 | |x| |
    | |\n  Param Problem => tell ALP, don't abort         |4.2.3.9 | |x| | | |\n                                                 |
    \       | | | | | |\n"
  title: Receiving ICMP Messages from IP                  |4.2.3.9 |x| | | | |
- contents:
  - "Address Validation                               |        | | | | | |\n  Reject
    OPEN call to invalid IP address         |4.2.3.10|x| | | | |\n  Reject SYN from
    invalid IP address             |4.2.3.10|x| | | | |\n  Silently discard SYN to
    bcast/mcast addr       |4.2.3.10|x| | | | |\n                                                 |
    \       | | | | | |\n"
  title: Address Validation                               |        | | | | | |
- contents:
  - "TCP/ALP Interface Services                       |        | | | | | |\n  Error
    Report mechanism                         |4.2.4.1 |x| | | | |\n  ALP can disable
    Error Report Routine           |4.2.4.1 | |x| | | |\n  ALP can specify TOS for
    sending                |4.2.4.2 |x| | | | |\n    Passed unchanged to IP                       |4.2.4.2
    | |x| | | |\n  ALP can change TOS during connection           |4.2.4.2 | |x| |
    | |\n  Pass received TOS up to ALP                    |4.2.4.2 | | |x| | |\n  FLUSH
    call                                     |4.2.4.3 | | |x| | |\n  Optional local
    IP addr parm. in OPEN           |4.2.4.4 |x| | | | |\n"
  title: TCP/ALP Interface Services                       |        | | | | | |
- contents:
  - '-------------------------------------------------|--------|-|-|-|-|-|--

    '
  title: '-------------------------------------------------|--------|-|-|-|-|-|--'
- contents:
  - '-------------------------------------------------|--------|-|-|-|-|-|--

    '
  title: '-------------------------------------------------|--------|-|-|-|-|-|--'
- contents:
  - 'FOOTNOTES:

    '
  title: 'FOOTNOTES:'
- contents:
  - '(1)  "ALP" means Application-Layer program.

    '
  title: (1)  "ALP" means Application-Layer program.
- contents:
  - 'RFC1122                  TRANSPORT LAYER -- TCP             October 1989

    '
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - '5.  REFERENCES

    '
  title: 5.  REFERENCES
- contents:
  - 'INTRODUCTORY REFERENCES

    '
  title: INTRODUCTORY REFERENCES
- contents:
  - "[INTRO:1] \"Requirements for Internet Hosts -- Application and Support,\"\n     IETF
    Host Requirements Working Group, R. Braden, Ed., RFC-1123,\n     October 1989.\n"
  title: '[INTRO:1] "Requirements for Internet Hosts -- Application and Support,"'
- contents:
  - "[INTRO:2]  \"Requirements for Internet Gateways,\"  R. Braden and J.\n     Postel,
    RFC-1009, June 1987.\n"
  title: '[INTRO:2]  "Requirements for Internet Gateways,"  R. Braden and J.'
- contents:
  - "[INTRO:3]  \"DDN Protocol Handbook,\" NIC-50004, NIC-50005, NIC-50006,\n     (three
    volumes), SRI International, December 1985.\n"
  title: '[INTRO:3]  "DDN Protocol Handbook," NIC-50004, NIC-50005, NIC-50006,'
- contents:
  - "[INTRO:4]  \"Official Internet Protocols,\" J. Reynolds and J. Postel,\n     RFC-1011,
    May 1987.\n     This document is republished periodically with new RFC numbers;
    the\n     latest version must be used.\n"
  title: '[INTRO:4]  "Official Internet Protocols," J. Reynolds and J. Postel,'
- contents:
  - "[INTRO:5]  \"Protocol Document Order Information,\" O. Jacobsen and J.\n     Postel,
    RFC-980, March 1986.\n"
  title: '[INTRO:5]  "Protocol Document Order Information," O. Jacobsen and J.'
- contents:
  - "[INTRO:6]  \"Assigned Numbers,\" J. Reynolds and J. Postel, RFC-1010, May\n     1987.\n
    \    This document is republished periodically with new RFC numbers; the\n     latest
    version must be used.\n"
  title: '[INTRO:6]  "Assigned Numbers," J. Reynolds and J. Postel, RFC-1010, May'
- contents:
  - "[INTRO:7] \"Modularity and Efficiency in Protocol Implementations,\" D.\n     Clark,
    RFC-817, July 1982.\n"
  title: '[INTRO:7] "Modularity and Efficiency in Protocol Implementations," D.'
- contents:
  - "[INTRO:8] \"The Structuring of Systems Using Upcalls,\" D. Clark, 10th ACM\n
    \    SOSP, Orcas Island, Washington, December 1985.\n"
  title: '[INTRO:8] "The Structuring of Systems Using Upcalls," D. Clark, 10th ACM'
- contents:
  - 'Secondary References:

    '
  title: 'Secondary References:'
- contents:
  - "[INTRO:9]  \"A Protocol for Packet Network Intercommunication,\" V. Cerf\n     and
    R. Kahn, IEEE Transactions on Communication, May 1974.\n"
  title: '[INTRO:9]  "A Protocol for Packet Network Intercommunication," V. Cerf'
- contents:
  - "[INTRO:10]  \"The ARPA Internet Protocol,\" J. Postel, C. Sunshine, and D.\n
    \    Cohen, Computer Networks, Vol. 5, No. 4, July 1981.\n"
  title: '[INTRO:10]  "The ARPA Internet Protocol," J. Postel, C. Sunshine, and D.'
- contents:
  - "[INTRO:11]  \"The DARPA Internet Protocol Suite,\" B. Leiner, J. Postel,\n     R.
    Cole and D. Mills, Proceedings INFOCOM 85, IEEE, Washington DC,\n"
  title: '[INTRO:11]  "The DARPA Internet Protocol Suite," B. Leiner, J. Postel,'
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n     March
    1985.  Also in: IEEE Communications Magazine, March 1985.\n     Also available
    as ISI-RS-85-153.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "[INTRO:12] \"Final Text of DIS8473, Protocol for Providing the\n     Connectionless
    Mode Network Service,\" ANSI, published as RFC-994,\n     March 1986.\n"
  title: '[INTRO:12] "Final Text of DIS8473, Protocol for Providing the'
- contents:
  - "[INTRO:13] \"End System to Intermediate System Routing Exchange\n     Protocol,\"
    ANSI X3S3.3, published as RFC-995, April 1986.\n"
  title: '[INTRO:13] "End System to Intermediate System Routing Exchange'
- contents:
  - 'LINK LAYER REFERENCES

    '
  title: LINK LAYER REFERENCES
- contents:
  - "[LINK:1] \"Trailer Encapsulations,\" S. Leffler and M. Karels, RFC-893,\n     April
    1984.\n"
  title: '[LINK:1] "Trailer Encapsulations," S. Leffler and M. Karels, RFC-893,'
- contents:
  - "[LINK:2] \"An Ethernet Address Resolution Protocol,\" D. Plummer, RFC-826,\n
    \    November 1982.\n"
  title: '[LINK:2] "An Ethernet Address Resolution Protocol," D. Plummer, RFC-826,'
- contents:
  - "[LINK:3] \"A Standard for the Transmission of IP Datagrams over Ethernet\n     Networks,\"
    C. Hornig, RFC-894, April 1984.\n"
  title: '[LINK:3] "A Standard for the Transmission of IP Datagrams over Ethernet'
- contents:
  - "[LINK:4] \"A Standard for the Transmission of IP Datagrams over IEEE 802\n     \"Networks,\"
    J. Postel and J. Reynolds, RFC-1042, February 1988.\n     This RFC contains a
    great deal of information of importance to\n     Internet implementers planning
    to use IEEE 802 networks.\n"
  title: '[LINK:4] "A Standard for the Transmission of IP Datagrams over IEEE 802'
- contents:
  - 'IP LAYER REFERENCES

    '
  title: IP LAYER REFERENCES
- contents:
  - '[IP:1] "Internet Protocol (IP)," J. Postel, RFC-791, September 1981.

    '
  title: '[IP:1] "Internet Protocol (IP)," J. Postel, RFC-791, September 1981.'
- contents:
  - "[IP:2] \"Internet Control Message Protocol (ICMP),\" J. Postel, RFC-792,\n     September
    1981.\n"
  title: '[IP:2] "Internet Control Message Protocol (ICMP)," J. Postel, RFC-792,'
- contents:
  - "[IP:3] \"Internet Standard Subnetting Procedure,\" J. Mogul and J. Postel,\n
    \    RFC-950, August 1985.\n"
  title: '[IP:3] "Internet Standard Subnetting Procedure," J. Mogul and J. Postel,'
- contents:
  - "[IP:4]  \"Host Extensions for IP Multicasting,\" S. Deering, RFC-1112,\n     August
    1989.\n"
  title: '[IP:4]  "Host Extensions for IP Multicasting," S. Deering, RFC-1112,'
- contents:
  - "[IP:5] \"Military Standard Internet Protocol,\" MIL-STD-1777, Department\n     of
    Defense, August 1983.\n     This specification, as amended by RFC-963, is intended
    to describe\n"
  title: '[IP:5] "Military Standard Internet Protocol," MIL-STD-1777, Department'
- contents:
  - "RFC1122                  TRANSPORT LAYER -- TCP             October 1989\n     the
    Internet Protocol but has some serious omissions (e.g., the\n     mandatory subnet
    extension [IP:3] and the optional multicasting\n     extension [IP:4]).  It is
    also out of date.  If there is a\n     conflict, RFC-791, RFC-792, and RFC-950
    must be taken as\n     authoritative, while the present document is authoritative
    over\n     all.\n"
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - "[IP:6] \"Some Problems with the Specification of the Military Standard\n     Internet
    Protocol,\" D. Sidhu, RFC-963, November 1985.\n"
  title: '[IP:6] "Some Problems with the Specification of the Military Standard'
- contents:
  - "[IP:7] \"The TCP Maximum Segment Size and Related Topics,\" J. Postel,\n     RFC-879,
    November 1983.\n     Discusses and clarifies the relationship between the TCP
    Maximum\n     Segment Size option and the IP datagram size.\n"
  title: '[IP:7] "The TCP Maximum Segment Size and Related Topics," J. Postel,'
- contents:
  - "[IP:8] \"Internet Protocol Security Options,\"  B. Schofield, RFC-1108,\n     October
    1989.\n"
  title: '[IP:8] "Internet Protocol Security Options,"  B. Schofield, RFC-1108,'
- contents:
  - "[IP:9] \"Fragmentation Considered Harmful,\" C. Kent and J. Mogul, ACM\n     SIGCOMM-87,
    August 1987.  Published as ACM Comp Comm Review, Vol.\n     17, no. 5.\n     This
    useful paper discusses the problems created by Internet\n     fragmentation and
    presents alternative solutions.\n"
  title: '[IP:9] "Fragmentation Considered Harmful," C. Kent and J. Mogul, ACM'
- contents:
  - "[IP:10] \"IP Datagram Reassembly Algorithms,\" D. Clark, RFC-815, July\n     1982.\n
    \    This and the following paper should be read by every implementor.\n"
  title: '[IP:10] "IP Datagram Reassembly Algorithms," D. Clark, RFC-815, July'
- contents:
  - '[IP:11] "Fault Isolation and Recovery," D. Clark, RFC-816, July 1982.

    '
  title: '[IP:11] "Fault Isolation and Recovery," D. Clark, RFC-816, July 1982.'
- contents:
  - 'SECONDARY IP REFERENCES:

    '
  title: 'SECONDARY IP REFERENCES:'
- contents:
  - "[IP:12] \"Broadcasting Internet Datagrams in the Presence of Subnets,\" J.\n
    \    Mogul, RFC-922, October 1984.\n"
  title: '[IP:12] "Broadcasting Internet Datagrams in the Presence of Subnets," J.'
- contents:
  - "[IP:13] \"Name, Addresses, Ports, and Routes,\" D. Clark, RFC-814, July\n     1982.\n"
  title: '[IP:13] "Name, Addresses, Ports, and Routes," D. Clark, RFC-814, July'
- contents:
  - "[IP:14] \"Something a Host Could Do with Source Quench: The Source Quench\n     Introduced
    Delay (SQUID),\" W. Prue and J. Postel, RFC-1016, July\n     1987.\n     This
    RFC first described directed broadcast addresses.  However,\n     the bulk of
    the RFC is concerned with gateways, not hosts.\n"
  title: '[IP:14] "Something a Host Could Do with Source Quench: The Source Quench'
- contents:
  - 'RFC1122                  TRANSPORT LAYER -- TCP             October 1989

    '
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - 'UDP REFERENCES:

    '
  title: 'UDP REFERENCES:'
- contents:
  - '[UDP:1] "User Datagram Protocol," J. Postel, RFC-768, August 1980.

    '
  title: '[UDP:1] "User Datagram Protocol," J. Postel, RFC-768, August 1980.'
- contents:
  - 'TCP REFERENCES:

    '
  title: 'TCP REFERENCES:'
- contents:
  - "[TCP:1] \"Transmission Control Protocol,\" J. Postel, RFC-793, September\n     1981.\n"
  title: '[TCP:1] "Transmission Control Protocol," J. Postel, RFC-793, September'
- contents:
  - "[TCP:2] \"Transmission Control Protocol,\" MIL-STD-1778, US Department of\n     Defense,
    August 1984.\n     This specification as amended by RFC-964 is intended to describe\n
    \    the same protocol as RFC-793 [TCP:1].  If there is a conflict,\n     RFC-793
    takes precedence, and the present document is authoritative\n     over both.\n"
  title: '[TCP:2] "Transmission Control Protocol," MIL-STD-1778, US Department of'
- contents:
  - "[TCP:3] \"Some Problems with the Specification of the Military Standard\n     Transmission
    Control Protocol,\" D. Sidhu and T. Blumer, RFC-964,\n     November 1985.\n"
  title: '[TCP:3] "Some Problems with the Specification of the Military Standard'
- contents:
  - "[TCP:4] \"The TCP Maximum Segment Size and Related Topics,\" J. Postel,\n     RFC-879,
    November 1983.\n"
  title: '[TCP:4] "The TCP Maximum Segment Size and Related Topics," J. Postel,'
- contents:
  - "[TCP:5] \"Window and Acknowledgment Strategy in TCP,\" D. Clark, RFC-813,\n     July
    1982.\n"
  title: '[TCP:5] "Window and Acknowledgment Strategy in TCP," D. Clark, RFC-813,'
- contents:
  - "[TCP:6] \"Round Trip Time Estimation,\" P. Karn & C. Partridge, ACM\n     SIGCOMM-87,
    August 1987.\n"
  title: '[TCP:6] "Round Trip Time Estimation," P. Karn & C. Partridge, ACM'
- contents:
  - "[TCP:7] \"Congestion Avoidance and Control,\" V. Jacobson, ACM SIGCOMM-88,\n
    \    August 1988.\n"
  title: '[TCP:7] "Congestion Avoidance and Control," V. Jacobson, ACM SIGCOMM-88,'
- contents:
  - 'SECONDARY TCP REFERENCES:

    '
  title: 'SECONDARY TCP REFERENCES:'
- contents:
  - "[TCP:8] \"Modularity and Efficiency in Protocol Implementation,\" D.\n     Clark,
    RFC-817, July 1982.\n"
  title: '[TCP:8] "Modularity and Efficiency in Protocol Implementation," D.'
- contents:
  - 'RFC1122                  TRANSPORT LAYER -- TCP             October 1989

    '
  title: RFC1122                  TRANSPORT LAYER -- TCP             October 1989
- contents:
  - '[TCP:9] "Congestion Control in IP/TCP," J. Nagle, RFC-896, January 1984.

    '
  title: '[TCP:9] "Congestion Control in IP/TCP," J. Nagle, RFC-896, January 1984.'
- contents:
  - "[TCP:10] \"Computing the Internet Checksum,\" R. Braden, D. Borman, and C.\n
    \    Partridge, RFC-1071, September 1988.\n"
  title: '[TCP:10] "Computing the Internet Checksum," R. Braden, D. Borman, and C.'
- contents:
  - "[TCP:11] \"TCP Extensions for Long-Delay Paths,\" V. Jacobson & R. Braden,\n
    \    RFC-1072, October 1988.\n"
  title: '[TCP:11] "TCP Extensions for Long-Delay Paths," V. Jacobson & R. Braden,'
- contents:
  - "Security Considerations\n   There are many security issues in the communication
    layers of host\n   software, but a full discussion is beyond the scope of this
    RFC.\n   The Internet architecture generally provides little protection\n   against
    spoofing of IP source addresses, so any security mechanism\n   that is based upon
    verifying the IP source address of a datagram\n   should be treated with suspicion.
    \ However, in restricted\n   environments some source-address checking may be
    possible.  For\n   example, there might be a secure LAN whose gateway to the rest
    of the\n   Internet discarded any incoming datagram with a source address that\n
    \  spoofed the LAN address.  In this case, a host on the LAN could use\n   the
    source address to test for local vs. remote source.  This problem\n   is complicated
    by source routing, and some have suggested that\n   source-routed datagram forwarding
    by hosts (see Section 3.3.5) should\n   be outlawed for security reasons.\n   Security-related
    issues are mentioned in sections concerning the IP\n   Security option (Section
    3.2.1.8), the ICMP Parameter Problem message\n   (Section 3.2.2.5), IP options
    in UDP datagrams (Section 4.1.3.2), and\n   reserved TCP ports (Section 4.2.2.1).\n"
  title: Security Considerations
- contents:
  - "Author's Address\n   Robert Braden\n   USC/Information Sciences Institute\n   4676
    Admiralty Way\n   Marina del Rey, CA 90292-6695\n   Phone: (213) 822 1511\n   EMail:
    Braden@ISI.EDU\n"
  title: Author's Address
