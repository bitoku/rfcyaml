- title: __initial_text__
  contents:
  - '              Optimized Link State Routing Protocol (OLSR)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Optimized Link State Routing (OLSR)\n\
    \   protocol for mobile ad hoc networks.  The protocol is an optimization\n  \
    \ of the classical link state algorithm tailored to the requirements of\n   a\
    \ mobile wireless LAN.  The key concept used in the protocol is that\n   of multipoint\
    \ relays (MPRs).  MPRs are selected nodes which forward\n   broadcast messages\
    \ during the flooding process.  This technique\n   substantially reduces the message\
    \ overhead as compared to a classical\n   flooding mechanism, where every node\
    \ retransmits each message when it\n   receives the first copy of the message.\
    \  In OLSR, link state\n   information is generated only by nodes elected as MPRs.\
    \  Thus, a\n   second optimization is achieved by minimizing the number of control\n\
    \   messages flooded in the network.  As a third optimization, an MPR\n   node\
    \ may chose to report only links between itself and its MPR\n   selectors.  Hence,\
    \ as contrary to the classic link state algorithm,\n   partial link state information\
    \ is distributed in the network.  This\n   information is then used for route\
    \ calculation.  OLSR provides\n   optimal routes (in terms of number of hops).\
    \  The protocol is\n   particularly suitable for large and dense networks as the\
    \ technique\n   of MPRs works well in this context.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n       1.1. OLSR Terminology.  . . . . . . . . . . . . . . .\
    \ . . . .   5\n       1.2. Applicability. . . . . . . . . . . . . . . . . . .\
    \ . . .   7\n       1.3. Protocol Overview  . . . . . . . . . . . . . . . . .\
    \ . .   8\n       1.4. Multipoint Relays  . . . . . . . . . . . . . . . . . .\
    \ .   9\n   2.  Protocol Functioning  . . . . . . . . . . . . . . . . . . . .\
    \   9\n       2.1. Core Functioning   . . . . . . . . . . . . . . . . . . .  10\n\
    \       2.2. Auxiliary Functioning  . . . . . . . . . . . . . . . . .  12\n  \
    \ 3.  Packet Format and Forwarding  . . . . . . . . . . . . . . . .  13\n    \
    \   3.1. Protocol and Port Number.  . . . . . . . . . . . . . . .  13\n      \
    \ 3.2. Main Address   . . . . . . . . . . . . . . . . . . . . .  13\n       3.3.\
    \ Packet Format  . . . . . . . . . . . . . . . . . . . . .  14\n            3.3.1.\
    \ Packet Header . . . . . . . . . . . . . . . . . .  14\n            3.3.2. Message\
    \ Header  . . . . . . . . . . . . . . . . .  15\n       3.4. Packet Processing\
    \ and Message Flooding . . . . . . . . .  16\n            3.4.1. Default Forwarding\
    \ Algorithm. . . . . . . . . . .  18\n            3.4.2. Considerations on Processing\
    \ and Forwarding . . .  20\n       3.5. Message Emission and Jitter. . . . . .\
    \ . . . . . . . . .  21\n   4.  Information Repositories  . . . . . . . . . .\
    \ . . . . . . . .  22\n       4.1. Multiple Interface Association Information\
    \ Base  . . . .  22\n       4.2. Link sensing: Local Link Information Base. .\
    \ . . . . . .  22\n            4.2.1. Link Set. . . . . . . . . . . . . . . .\
    \ . . . . .  22\n       4.3. Neighbor Detection: Neighborhood Information Base.\
    \ . . .  23\n            4.3.1. Neighbor Set. . . . . . . . . . . . . . . . .\
    \ . .  23\n            4.3.2. 2-hop Neighbor Set. . . . . . . . . . . . . . .\
    \ .  23\n            4.3.3. MPR Set . . . . . . . . . . . . . . . . . . . . .\
    \  23\n            4.3.4. MPR Selector Set. . . . . . . . . . . . . . . . .  23\n\
    \       4.4. Topology Information Base  . . . . . . . . . . . . . . .  24\n  \
    \ 5.  Main Addresses and Multiple Interfaces  . . . . . . . . . . .  24\n    \
    \   5.1. MID Message Format . . . . . . . . . . . . . . . . . . .  25\n      \
    \ 5.2. MID Message Generation . . . . . . . . . . . . . . . . .  25\n       5.3.\
    \ MID Message Forwarding . . . . . . . . . . . . . . . . .  26\n       5.4. MID\
    \ Message Processing . . . . . . . . . . . . . . . . .  26\n       5.5. Resolving\
    \ a Main Address from an Interface Address . . .  27\n   6.  HELLO Message Format\
    \ and Generation . . . . . . . . . . . . .  27\n       6.1. HELLO Message Format\
    \ . . . . . . . . . . . . . . . . . .  27\n            6.1.1. Link Code as Link\
    \ Type and Neighbor Type. . . . .  29\n       6.2. HELLO Message Generation .\
    \ . . . . . . . . . . . . . . .  30\n       6.3. HELLO Message Forwarding . .\
    \ . . . . . . . . . . . . . .  33\n       6.4. HELLO Message Processing . . .\
    \ . . . . . . . . . . . . .  33\n   7.  Link Sensing  . . . . . . . . . . . .\
    \ . . . . . . . . . . . .  33\n       7.1. Populating the Link Set  . . . . .\
    \ . . . . . . . . . . .  33\n            7.1.1. HELLO Message Processing  . .\
    \ . . . . . . . . . .  34\n   8.  Neighbor Detection  . . . . . . . . . . . .\
    \ . . . . . . . . .  35\n      8.1. Populating the Neighbor Set . . . . . . .\
    \ . . . . . . . .  35\n            8.1.1. HELLO Message Processing  . . . . .\
    \ . . . . . . .  37\n       8.2. Populating the 2-hop Neighbor Set. . . . . .\
    \ . . . . . .  37\n            8.2.1. HELLO Message Processing. . . . . . . .\
    \ . . . . .  37\n       8.3. Populating the MPR set . . . . . . . . . . . . .\
    \ . . . .  38\n            8.3.1. MPR Computation . . . . . . . . . . . . . .\
    \ . . .  39\n       8.4. Populating the MPR Selector Set. . . . . . . . . . .\
    \ . .  41\n            8.4.1. HELLO Message Processing. . . . . . . . . . . .\
    \ .  41\n       8.5. Neighborhood and 2-hop Neighborhood Changes. . . . . . .\
    \  42\n   9.  Topology Discovery  . . . . . . . . . . . . . . . . . . . . .  43\n\
    \       9.1. TC Message Format. . . . . . . . . . . . . . . . . . . .  43\n  \
    \     9.2. Advertised Neighbor Set. . . . . . . . . . . . . . . . .  44\n    \
    \   9.3. TC Message Generation. . . . . . . . . . . . . . . . . .  45\n      \
    \ 9.4. TC Message Forwarding. . . . . . . . . . . . . . . . . .  45\n       9.5.\
    \ TC Message Processing. . . . . . . . . . . . . . . . . .  45\n   10. Routing\
    \ Table Calculation . . . . . . . . . . . . . . . . . .  47\n   11. Node Configuration.\
    \ . . . . . . . . . . . . . . . . . . . . .  50\n       11.1. Address Assignment.\
    \ . . . . . . . . . . . . . . . . . .  50\n       11.2. Routing Configuration\
    \ . . . . . . . . . . . . . . . . .  51\n       11.3. Data Packet Forwarding.\
    \ . . . . . . . . . . . . . . . .  51\n   12. Non OLSR Interfaces . . . . . .\
    \ . . . . . . . . . . . . . . .  51\n       12.1. HNA Message Format. . . . .\
    \ . . . . . . . . . . . . . .  52\n       12.2. Host and Network Association Information\
    \ Base . . . . .  52\n       12.3. HNA Message Generation. . . . . . . . . . .\
    \ . . . . . .  53\n       12.4. HNA Message Forwarding. . . . . . . . . . . .\
    \ . . . . .  53\n       12.5. HNA Message Processing. . . . . . . . . . . . .\
    \ . . . .  53\n       12.6. Routing Table Calculation . . . . . . . . . . . .\
    \ . . .  54\n       12.7. Interoperability Considerations . . . . . . . . . .\
    \ . .  55\n   13. Link Layer Notification . . . . . . . . . . . . . . . . . .\
    \ .  55\n       13.1. Interoperability Considerations . . . . . . . . . . . .\
    \  56\n   14. Link Hysteresis . . . . . . . . . . . . . . . . . . . . . . .  56\n\
    \       14.1. Local Link Set  . . . . . . . . . . . . . . . . . . . .  56\n  \
    \     14.2. Hello Message Generation  . . . . . . . . . . . . . . .  57\n    \
    \   14.3. Hysteresis Strategy . . . . . . . . . . . . . . . . . .  57\n      \
    \ 14.4. Interoperability Considerations . . . . . . . . . . . .  59\n   15. Redundant\
    \ Topology Information. . . . . . . . . . . . . . . .  59\n       15.1. TC_REDUNDANCY\
    \ Parameter . . . . . . . . . . . . . . . .  60\n       15.2. Interoperability\
    \ Considerations . . . . . . . . . . . .  60\n   16. MPR Redundancy. . . . . .\
    \ . . . . . . . . . . . . . . . . . .  60\n       16.1. MPR_COVERAGE Parameter.\
    \ . . . . . . . . . . . . . . . .  61\n       16.2. MPR Computation . . . . .\
    \ . . . . . . . . . . . . . . .  61\n       16.3. Interoperability Considerations\
    \ . . . . . . . . . . . .  62\n   17. IPv6 Considerations . . . . . . . . . .\
    \ . . . . . . . . . . .  63\n   18. Proposed Values for Constants . . . . . .\
    \ . . . . . . . . . .  63\n       18.1. Setting emission interval and holding\
    \ times . . . . . .  63\n       18.2. Emission Interval . . . . . . . . . . .\
    \ . . . . . . . .  64\n       18.3. Holding time  . . . . . . . . . . . . . .\
    \ . . . . . . .  64\n       18.4. Message Types . . . . . . . . . . . . . . .\
    \ . . . . . .  65\n       18.5. Link Types. . . . . . . . . . . . . . . . . .\
    \ . . . . .  65\n       18.6. Neighbor Types  . . . . . . . . . . . . . . . .\
    \ . . . .  65\n       18.7. Link Hysteresis . . . . . . . . . . . . . . . . .\
    \ . . .  66\n       18.8. Willingness . . . . . . . . . . . . . . . . . . . .\
    \ . .  66\n       18.9. Misc. Constants . . . . . . . . . . . . . . . . . . .\
    \ .  67\n   19. Sequence Numbers. . . . . . . . . . . . . . . . . . . . . . .\
    \  67\n   20. Security Considerations . . . . . . . . . . . . . . . . . . .  67\n\
    \       20.1. Confidentiality . . . . . . . . . . . . . . . . . . . .  67\n  \
    \     20.2. Integrity . . . . . . . . . . . . . . . . . . . . . . .  68\n    \
    \   20.3. Interaction with External Routing Domains . . . . . . .  69\n      \
    \ 20.4. Node Identity . . . . . . . . . . . . . . . . . . . . .  70\n   21. Flow\
    \ and congestion control . . . . . . . . . . . . . . . . .  70\n   22. IANA Considerations\
    \ . . . . . . . . . . . . . . . . . . . . .  70\n   23. Acknowledgments . . .\
    \ . . . . . . . . . . . . . . . . . . . .  71\n   24. Contributors. . . . . .\
    \ . . . . . . . . . . . . . . . . . . .  71\n   25. References. . . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  73\n   26. Authors' Addresses. . . . .\
    \ . . . . . . . . . . . . . . . . .  74\n   27. Full Copyright Statement. . .\
    \ . . . . . . . . . . . . . . . .  75\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Optimized Link State Routing Protocol (OLSR) is developed\
    \ for\n   mobile ad hoc networks.  It operates as a table driven, proactive\n\
    \   protocol, i.e., exchanges topology information with other nodes of\n   the\
    \ network regularly.  Each node selects a set of its neighbor nodes\n   as \"\
    multipoint relays\" (MPR).  In OLSR, only nodes, selected as such\n   MPRs, are\
    \ responsible for forwarding control traffic, intended for\n   diffusion into\
    \ the entire network.  MPRs provide an efficient\n   mechanism for flooding control\
    \ traffic by reducing the number of\n   transmissions required.\n   Nodes, selected\
    \ as MPRs, also have a special responsibility when\n   declaring link state information\
    \ in the network.  Indeed, the only\n   requirement for OLSR to provide shortest\
    \ path routes to all\n   destinations is that MPR nodes declare link-state information\
    \ for\n   their MPR selectors.  Additional available link-state information may\n\
    \   be utilized, e.g., for redundancy.\n   Nodes which have been selected as multipoint\
    \ relays by some neighbor\n   node(s) announce this information periodically in\
    \ their control\n   messages.  Thereby a node announces to the network, that it\
    \ has\n   reachability to the nodes which have selected it as an MPR.  In route\n\
    \   calculation, the MPRs are used to form the route from a given node to\n  \
    \ any destination in the network.  Furthermore, the protocol uses the\n   MPRs\
    \ to facilitate efficient flooding of control messages in the\n   network.\n \
    \  A node selects MPRs from among its one hop neighbors with\n   \"symmetric\"\
    , i.e., bi-directional, linkages.  Therefore, selecting\n   the route through\
    \ MPRs automatically avoids the problems associated\n   with data packet transfer\
    \ over uni-directional links (such as the\n   problem of not getting link-layer\
    \ acknowledgments for data packets at\n   each hop, for link-layers employing\
    \ this technique for unicast\n   traffic).\n   OLSR is developed to work independently\
    \ from other protocols.\n   Likewise, OLSR makes no assumptions about the underlying\
    \ link-layer.\n   OLSR inherits the concept of forwarding and relaying from HIPERLAN\
    \ (a\n   MAC layer protocol) which is standardized by ETSI [3].  The protocol\n\
    \   is developed in the IPANEMA project (part of the Euclid program) and\n   in\
    \ the PRIMA project (part of the RNRT program).\n"
- title: 1.1.  OLSR Terminology
  contents:
  - "1.1.  OLSR Terminology\n   The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC2119 [5].\n   Additionally, this document uses the following terminology:\n\
    \      node\n         A MANET router which implements the Optimized Link State\n\
    \         Routing protocol as specified in this document.\n      OLSR interface\n\
    \         A network device participating in a MANET running OLSR.  A node\n  \
    \       may have several OLSR interfaces, each interface assigned an\n       \
    \  unique IP address.\n      non OLSR interface\n         A network device, not\
    \ participating in a MANET running OLSR.  A\n         node may have several non\
    \ OLSR interfaces (wireless and/or\n         wired).  Routing information from\
    \ these interfaces MAY be\n         injected into the OLSR routing domain.\n \
    \     single OLSR interface node\n         A node which has a single OLSR interface,\
    \ participating in an\n         OLSR routing domain.\n      multiple OLSR interface\
    \ node\n         A node which has multiple OLSR interfaces, participating in an\n\
    \         OLSR routing domain.\n      main address\n         The main address\
    \ of a node, which will be used in OLSR control\n         traffic as the \"originator\
    \ address\" of all messages emitted by\n         this node.  It is the address\
    \ of one of the OLSR interfaces of\n         the node.\n         A single OLSR\
    \ interface node MUST use the address of its only\n         OLSR interface as\
    \ the main address.\n         A multiple OLSR interface node MUST choose one of\
    \ its OLSR\n         interface addresses as its \"main address\" (equivalent of\n\
    \         \"router ID\" or \"node identifier\").  It is of no importance\n   \
    \      which address is chosen, however a node SHOULD always use the\n       \
    \  same address as its main address.\n      neighbor node\n         A node X is\
    \ a neighbor node of node Y if node Y can hear node X\n         (i.e., a link\
    \ exists between an OLSR interface on node X and an\n         OLSR interface on\
    \ Y).\n      2-hop neighbor\n         A node heard by a neighbor.\n      strict\
    \ 2-hop neighbor\n         a 2-hop neighbor which is not the node itself or a\
    \ neighbor of\n         the node, and in addition is a neighbor of a neighbor,\
    \ with\n         willingness different from WILL_NEVER, of the node.\n      multipoint\
    \ relay (MPR)\n         A node which is selected by its 1-hop neighbor, node X,\
    \ to\n         \"re-transmit\" all the broadcast messages that it receives from\n\
    \         X, provided that the message is not a duplicate, and that the\n    \
    \     time to live field of the message is greater than one.\n      multipoint\
    \ relay selector (MPR selector, MS)\n         A node which has selected its 1-hop\
    \ neighbor, node X, as its\n         multipoint relay, will be called a multipoint\
    \ relay selector of\n         node X.\n      link\n         A link is a pair of\
    \ OLSR interfaces (from two different nodes)\n         susceptible to hear one\
    \ another (i.e., one may be able to\n         receive traffic from the other).\
    \  A node is said to have a link\n         to another node when one of its interface\
    \ has a link to one of\n         the interfaces of the other node.\n      symmetric\
    \ link\n         A verified bi-directional link between two OLSR interfaces.\n\
    \      asymmetric link\n         A link between two OLSR interfaces, verified\
    \ in only one\n         direction.\n      symmetric 1-hop neighborhood\n     \
    \    The symmetric 1-hop neighborhood of any node X is the set of\n         nodes\
    \ which have at least one symmetric link to X.\n      symmetric 2-hop neighborhood\n\
    \         The symmetric 2-hop neighborhood of X is the set of nodes,\n       \
    \  excluding X itself, which have a symmetric link to the\n         symmetric\
    \ 1-hop neighborhood of X.\n      symmetric strict 2-hop neighborhood\n      \
    \   The symmetric strict 2-hop neighborhood of X is the set of\n         nodes,\
    \ excluding X itself and its neighbors, which have a\n         symmetric link\
    \ to some symmetric 1-hop neighbor, with\n         willingness different of WILL_NEVER,\
    \ of X.\n"
- title: 1.2.  Applicability
  contents:
  - "1.2.  Applicability\n   OLSR is a proactive routing protocol for mobile ad-hoc\
    \ networks\n   (MANETs) [1], [2].  It is well suited to large and dense mobile\n\
    \   networks, as the optimization achieved using the MPRs works well in\n   this\
    \ context.  The larger and more dense a network, the more\n   optimization can\
    \ be achieved as compared to the classic link state\n   algorithm.  OLSR uses\
    \ hop-by-hop routing, i.e., each node uses its\n   local information to route\
    \ packets.\n   OLSR is well suited for networks, where the traffic is random and\n\
    \   sporadic between a larger set of nodes rather than being almost\n   exclusively\
    \ between a small specific set of nodes.  As a proactive\n   protocol, OLSR is\
    \ also suitable for scenarios where the communicating\n   pairs change over time:\
    \ no additional control traffic is generated in\n   this situation since routes\
    \ are maintained for all known destinations\n   at all times.\n"
- title: 1.3.  Protocol Overview
  contents:
  - "1.3.  Protocol Overview\n   OLSR is a proactive routing protocol for mobile ad\
    \ hoc networks.  The\n   protocol inherits the stability of a link state algorithm\
    \ and has the\n   advantage of having routes immediately available when needed\
    \ due to\n   its proactive nature.  OLSR is an optimization over the classical\n\
    \   link state protocol, tailored for mobile ad hoc networks.\n   OLSR minimizes\
    \ the overhead from flooding of control traffic by using\n   only selected nodes,\
    \ called MPRs, to retransmit control messages.\n   This technique significantly\
    \ reduces the number of retransmissions\n   required to flood a message to all\
    \ nodes in the network.  Secondly,\n   OLSR requires only partial link state to\
    \ be flooded in order to\n   provide shortest path routes.  The minimal set of\
    \ link state\n   information required is, that all nodes, selected as MPRs, MUST\n\
    \   declare the links to their MPR selectors.  Additional topological\n   information,\
    \ if present, MAY be utilized e.g., for redundancy\n   purposes.\n   OLSR MAY\
    \ optimize the reactivity to topological changes by reducing\n   the maximum time\
    \ interval for periodic control message transmission.\n   Furthermore, as OLSR\
    \ continuously maintains routes to all\n   destinations in the network, the protocol\
    \ is beneficial for traffic\n   patterns where a large subset of nodes are communicating\
    \ with another\n   large subset of nodes, and where the [source, destination]\
    \ pairs are\n   changing over time.  The protocol is particularly suited for large\n\
    \   and dense networks, as the optimization done using MPRs works well in\n  \
    \ this context.  The larger and more dense a network, the more\n   optimization\
    \ can be achieved as compared to the classic link state\n   algorithm.\n   OLSR\
    \ is designed to work in a completely distributed manner and does\n   not depend\
    \ on any central entity.  The protocol does NOT REQUIRE\n   reliable transmission\
    \ of control messages: each node sends control\n   messages periodically, and\
    \ can therefore sustain a reasonable loss of\n   some such messages.  Such losses\
    \ occur frequently in radio networks\n   due to collisions or other transmission\
    \ problems.\n   Also, OLSR does not require sequenced delivery of messages.  Each\n\
    \   control message contains a sequence number which is incremented for\n   each\
    \ message.  Thus the recipient of a control message can, if\n   required, easily\
    \ identify which information is more recent - even if\n   messages have been re-ordered\
    \ while in transmission.\n   Furthermore, OLSR provides support for protocol extensions\
    \ such as\n   sleep mode operation, multicast-routing etc.  Such extensions may\
    \ be\n   introduced as additions to the protocol without breaking backwards\n\
    \   compatibility with earlier versions.\n   OLSR does not require any changes\
    \ to the format of IP packets.  Thus\n   any existing IP stack can be used as\
    \ is: the protocol only interacts\n   with routing table management.\n"
- title: 1.4.  Multipoint Relays
  contents:
  - "1.4.  Multipoint Relays\n   The idea of multipoint relays is to minimize the\
    \ overhead of flooding\n   messages in the network by reducing redundant retransmissions\
    \ in the\n   same region.  Each node in the network selects a set of nodes in\
    \ its\n   symmetric 1-hop neighborhood which may retransmit its messages.  This\n\
    \   set of selected neighbor nodes is called the \"Multipoint Relay\" (MPR)\n\
    \   set of that node.  The neighbors of node N which are *NOT* in its MPR\n  \
    \ set, receive and process broadcast messages but do not retransmit\n   broadcast\
    \ messages received from node N.\n   Each node selects its MPR set from among\
    \ its 1-hop symmetric\n   neighbors.  This set is selected such that it covers\
    \ (in terms of\n   radio range) all symmetric strict 2-hop nodes.  The MPR set\
    \ of N,\n   denoted as MPR(N), is then an arbitrary subset of the symmetric 1-hop\n\
    \   neighborhood of N which satisfies the following condition: every node\n  \
    \ in the symmetric strict 2-hop neighborhood of N must have a symmetric\n   link\
    \ towards MPR(N).  The smaller a MPR set, the less control traffic\n   overhead\
    \ results from the routing protocol.  [2] gives an analysis\n   and example of\
    \ MPR selection algorithms.\n   Each node maintains information about the set\
    \ of neighbors that have\n   selected it as MPR.  This set is called the \"Multipoint\
    \ Relay\n   Selector set\" (MPR selector set) of a node.  A node obtains this\n\
    \   information from periodic HELLO messages received from the neighbors.\n  \
    \ A broadcast message, intended to be diffused in the whole network,\n   coming\
    \ from any of the MPR selectors of node N is assumed to be\n   retransmitted by\
    \ node N, if N has not received it yet.  This set can\n   change over time (i.e.,\
    \ when a node selects another MPR-set) and is\n   indicated by the selector nodes\
    \ in their HELLO messages.\n"
- title: 2.  Protocol Functioning
  contents:
  - "2.  Protocol Functioning\n   This section outlines the overall protocol functioning.\n\
    \   OLSR is modularized into a \"core\" of functionality, which is always\n  \
    \ required for the protocol to operate, and a set of auxiliary\n   functions.\n\
    \   The core specifies, in its own right, a protocol able to provide\n   routing\
    \ in a stand-alone MANET.\n   Each auxiliary function provides additional functionality,\
    \ which may\n   be applicable in specific scenarios, e.g., in case a node is\n\
    \   providing connectivity between the MANET and another routing domain.\n   All\
    \ auxiliary functions are compatible, to the extent where any\n   (sub)set of\
    \ auxiliary functions may be implemented with the core.\n   Furthermore, the protocol\
    \ allows heterogeneous nodes, i.e., nodes\n   which implement different subsets\
    \ of the auxiliary functions, to\n   coexist in the network.\n   The purpose of\
    \ dividing the functioning of OLSR into a core\n   functionality and a set of\
    \ auxiliary functions is to provide a simple\n   and easy-to-comprehend protocol,\
    \ and to provide a way of only adding\n   complexity where specific additional\
    \ functionality is required.\n"
- title: 2.1.  Core Functioning
  contents:
  - "2.1.  Core Functioning\n   The core functionality of OLSR specifies the behavior\
    \ of a node,\n   equipped with OLSR interfaces participating in the MANET and\
    \ running\n   OLSR as routing protocol.  This includes a universal specification\
    \ of\n   OLSR protocol messages and their transmission through the network, as\n\
    \   well as link sensing, topology diffusion and route calculation.\n   Specifically,\
    \ the core is made up from the following components:\n      Packet Format and\
    \ Forwarding\n         A universal specification of the packet format and an optimized\n\
    \         flooding mechanism serves as the transport mechanism for all\n     \
    \    OLSR control traffic.\n      Link Sensing\n         Link Sensing is accomplished\
    \ through periodic emission of HELLO\n         messages over the interfaces through\
    \ which connectivity is\n         checked.  A separate HELLO message is generated\
    \ for each\n         interface and emitted in correspondence with the provisions\
    \ in\n         section 7.\n         Resulting from Link Sensing is a local link\
    \ set, describing\n         links between \"local interfaces\" and \"remote interfaces\"\
    \ -\n         i.e., interfaces on neighbor nodes.\n         If sufficient information\
    \ is provided by the link-layer, this\n         may be utilized to populate the\
    \ local link set instead of HELLO\n         message exchange.\n      Neighbor\
    \ detection\n         Given a network with only single interface nodes, a node\
    \ may\n         deduct the neighbor set directly from the information exchanged\n\
    \         as part of link sensing: the \"main address\" of a single\n        \
    \ interface node is, by definition, the address of the only\n         interface\
    \ on that node.\n         In a network with multiple interface nodes, additional\n\
    \         information is required in order to map interface addresses to\n   \
    \      main addresses (and, thereby, to nodes).  This additional\n         information\
    \ is acquired through multiple interface declaration\n         (MID) messages,\
    \ described in section 5.\n      MPR Selection and MPR Signaling\n         The\
    \ objective of MPR selection is for a node to select a subset\n         of its\
    \ neighbors such that a broadcast message, retransmitted\n         by these selected\
    \ neighbors, will be received by all nodes 2\n         hops away.  The MPR set\
    \ of a node is computed such that it, for\n         each interface, satisfies\
    \ this condition.  The information\n         required to perform this calculation\
    \ is acquired through the\n         periodic exchange of HELLO messages, as described\
    \ in section 6.\n         MPR selection procedures are detailed in section 8.3.\n\
    \         MPR signaling is provided in correspondence with the provisions\n  \
    \       in the section 6.\n      Topology Control Message Diffusion\n        \
    \ Topology Control messages are diffused with the purpose of\n         providing\
    \ each node in the network with sufficient link-state\n         information to\
    \ allow route calculation.  Topology Control\n         messages are diffused in\
    \ correspondence with the provisions in\n         section 9.\n      Route Calculation\n\
    \         Given the link state information acquired through periodic\n       \
    \  message exchange, as well as the interface configuration of the\n         nodes,\
    \ the routing table for each node can be computed.  This\n         is detailed\
    \ in section 10.\n   The key notion for these mechanisms is the MPR relationship.\n\
    \   The following table specifies the component of the core functionality\n  \
    \ of OLSR, as well as their relations to this document.\n          Feature   \
    \                   |  Section\n         ------------------------------+--------------\n\
    \          Packet format and forwarding |     3\n          Information repositories\
    \     |     4\n          Main addr and multiple if.   |     5\n          Hello\
    \ messages               |     6\n          Link sensing                 |   \
    \  7\n          Neighbor detection           |     8\n          Topology discovery\
    \           |     9\n          Routing table computation    |    10\n        \
    \  Node configuration           |    11\n"
- title: 2.2.  Auxiliary Functioning
  contents:
  - "2.2.  Auxiliary Functioning\n   In addition to the core functioning of OLSR,\
    \ there are situations\n   where additional functionality is desired.  This includes\
    \ situations\n   where a node has multiple interfaces, some of which participate\
    \ in\n   another routing domain, where the programming interface to the\n   networking\
    \ hardware provides additional information in form of link\n   layer notifications\
    \ and where it is desired to provide redundant\n   topological information to\
    \ the network on expense of protocol\n   overhead.\n   The following table specifies\
    \ auxiliary functions and their relation\n   to this document.\n          Feature\
    \                      |  Section\n         ------------------------------+--------------\n\
    \          Non-OLSR interfaces          |    12\n          Link-layer notifications\
    \     |    13\n          Advanced link sensing        |    14\n          Redundant\
    \ topology           |    15\n          Redundant MPR flooding       |    16\n\
    \   The interpretation of the above table is as follows: if the feature\n   listed\
    \ is required, it SHOULD be provided as specified in the\n   corresponding section.\n"
- title: 3.  Packet Format and Forwarding
  contents:
  - "3.  Packet Format and Forwarding\n   OLSR communicates using a unified packet\
    \ format for all data related\n   to the protocol.  The purpose of this is to\
    \ facilitate extensibility\n   of the protocol without breaking backwards compatibility.\
    \  This also\n   provides an easy way of piggybacking different \"types\" of information\n\
    \   into a single transmission, and thus for a given implementation to\n   optimize\
    \ towards utilizing the maximal frame-size, provided by the\n   network.  These\
    \ packets are embedded in UDP datagrams for\n   transmission over the network.\
    \  The present document is presented\n   with IPv4 addresses.  Considerations\
    \ regarding IPv6 are given in\n   section 17.\n   Each packet encapsulates one\
    \ or more messages.  The messages share a\n   common header format, which enables\
    \ nodes to correctly accept and (if\n   applicable) retransmit messages of an\
    \ unknown type.\n   Messages can be flooded onto the entire network, or flooding\
    \ can be\n   limited to nodes within a diameter (in terms of number of hops) from\n\
    \   the originator of the message.  Thus transmitting a message to the\n   neighborhood\
    \ of a node is just a special case of flooding.  When\n   flooding any control\
    \ message, duplicate retransmissions will be\n   eliminated locally (i.e., each\
    \ node maintains a duplicate set to\n   prevent transmitting the same OLSR control\
    \ message twice) and\n   minimized in the entire network through the usage of\
    \ MPRs as\n   described in later sections.\n   Furthermore, a node can examine\
    \ the header of a message to obtain\n   information on the distance (in terms\
    \ of number of hops) to the\n   originator of the message.  This feature may be\
    \ useful in situations\n   where, e.g., the time information from a received control\
    \ messages\n   stored in a node depends on the distance to the originator.\n"
- title: 3.1.  Protocol and Port Number
  contents:
  - "3.1.  Protocol and Port Number\n   Packets in OLSR are communicated using UDP.\
    \  Port 698 has been\n   assigned by IANA for exclusive usage by the OLSR protocol.\n"
- title: 3.2.  Main Address
  contents:
  - "3.2.  Main Address\n   For a node with one interface, the main address of a node,\
    \ as defined\n   in \"OLSR Terminology\", MUST be set to the address of that interface.\n"
- title: 3.3.  Packet Format
  contents:
  - "3.3.  Packet Format\n   The basic layout of any packet in OLSR is as follows\
    \ (omitting IP and\n   UDP headers):\n       0                   1           \
    \        2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |         Packet Length         |    Packet Sequence Number     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Message Type |     Vtime     |         Message Size          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                      Originator Address                       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Time To Live |   Hop Count   |    Message Sequence Number    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   :                            MESSAGE                            :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  Message Type |     Vtime     |         Message Size          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      Originator Address                       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  Time To Live |   Hop Count   |    Message Sequence Number    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      :   \
    \                         MESSAGE                            :\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      :                                                               :\n   \
    \            (etc.)\n"
- title: 3.3.1.  Packet Header
  contents:
  - "3.3.1.  Packet Header\n      Packet Length\n         The length (in bytes) of\
    \ the packet\n      Packet Sequence Number\n         The Packet Sequence Number\
    \ (PSN) MUST be incremented by one\n         each time a new OLSR packet is transmitted.\
    \  \"Wrap-around\" is\n         handled as described in section 19.  A separate\
    \ Packet Sequence\n         Number is maintained for each interface such that\
    \ packets\n         transmitted over an interface are sequentially enumerated.\n\
    \   The IP address of the interface over which a packet was transmitted\n   is\
    \ obtainable from the IP header of the packet.\n   If the packet contains no messages\
    \ (i.e., the Packet Length is less\n   than or equal to the size of the packet\
    \ header), the packet MUST\n   silently be discarded.\n   For IPv4 addresses,\
    \ this implies that packets, where the Packet\n   Length < 16 MUST silently be\
    \ discarded.\n"
- title: 3.3.2.  Message Header
  contents:
  - "3.3.2.  Message Header\n      Message Type\n         This field indicates which\
    \ type of message is to be found in\n         the \"MESSAGE\" part.  Message types\
    \ in the range of 0-127 are\n         reserved for messages in this document and\
    \ in possible\n         extensions.\n      Vtime\n         This field indicates\
    \ for how long time after reception a node\n         MUST consider the information\
    \ contained in the message as\n         valid, unless a more recent update to\
    \ the information is\n         received.  The validity time is represented by\
    \ its mantissa\n         (four highest bits of Vtime field) and by its exponent\
    \ (four\n         lowest bits of Vtime field).  In other words:\n            \
    \  validity time = C*(1+a/16)* 2^b  [in seconds]\n         where a is the integer\
    \ represented by the four highest bits of\n         Vtime field and b the integer\
    \ represented by the four lowest\n         bits of Vtime field.  The proposed\
    \ value of the scaling factor\n         C is specified in section 18.\n      Message\
    \ Size\n         This gives the size of this message, counted in bytes and\n \
    \        measured from the beginning of the \"Message Type\" field and\n     \
    \    until the beginning of the next \"Message Type\" field (or - if\n       \
    \  there are no following messages - until the end of the packet).\n      Originator\
    \ Address\n         This field contains the main address of the node, which has\n\
    \         originally generated this message.  This field SHOULD NOT be\n     \
    \    confused with the source address from the IP header, which is\n         changed\
    \ each time to the address of the intermediate interface\n         which is re-transmitting\
    \ this message.  The Originator Address\n         field MUST *NEVER* be changed\
    \ in retransmissions.\n      Time To Live\n         This field contains the maximum\
    \ number of hops a message will\n         be transmitted.  Before a message is\
    \ retransmitted, the Time To\n         Live MUST be decremented by 1.  When a\
    \ node receives a message\n         with a Time To Live equal to 0 or 1, the message\
    \ MUST NOT be\n         retransmitted under any circumstances.  Normally, a node\
    \ would\n         not receive a message with a TTL of zero.\n         Thus, by\
    \ setting this field, the originator of a message can\n         limit the flooding\
    \ radius.\n      Hop Count\n         This field contains the number of hops a\
    \ message has attained.\n         Before a message is retransmitted, the Hop Count\
    \ MUST be\n         incremented by 1.\n         Initially, this is set to '0'\
    \ by the originator of the message.\n      Message Sequence Number\n         While\
    \ generating a message, the \"originator\" node will assign a\n         unique\
    \ identification number to each message.  This number is\n         inserted into\
    \ the Sequence Number field of the message.  The\n         sequence number is\
    \ increased by 1 (one) for each message\n         originating from the node. \
    \ \"Wrap-around\" is handled as\n         described in section 19.  Message sequence\
    \ numbers are used to\n         ensure that a given message is not retransmitted\
    \ more than once\n         by any node.\n"
- title: 3.4.  Packet Processing and Message Flooding
  contents:
  - "3.4.  Packet Processing and Message Flooding\n   Upon receiving a basic packet,\
    \ a node examines each of the \"message\n   headers\".  Based on the value of\
    \ the \"Message Type\" field, the node\n   can determine the fate of the message.\
    \  A node may receive the same\n   message several times.  Thus, to avoid re-processing\
    \ of some messages\n   which were already received and processed, each node maintains\
    \ a\n   Duplicate Set.  In this set, the node records information about the\n\
    \   most recently received messages where duplicate processing of a\n   message\
    \ is to be avoided.  For such a message, a node records a\n   \"Duplicate Tuple\"\
    \ (D_addr, D_seq_num, D_retransmitted, D_iface_list,\n   D_time), where D_addr\
    \ is the originator address of the message,\n   D_seq_num is the message sequence\
    \ number of the message,\n   D_retransmitted is a boolean indicating whether the\
    \ message has been\n   already retransmitted, D_iface_list is a list of the addresses\
    \ of the\n   interfaces on which the message has been received and D_time\n  \
    \ specifies the time at which a tuple expires and *MUST* be removed.\n   In a\
    \ node, the set of Duplicate Tuples are denoted the \"Duplicate\n   set\".\n \
    \  In this section, the term \"Originator Address\" will be used for the\n   main\
    \ address of the node which sent the message.  The term \"Sender\n   Interface\
    \ Address\" will be used for the sender address (given in the\n   IP header of\
    \ the packet containing the message) of the interface\n   which sent the message.\
    \  The term \"Receiving Interface Address\" will\n   be used for the address of\
    \ the interface of the node which received\n   the message.\n   Thus, upon receiving\
    \ a basic packet, a node MUST perform the\n   following tasks for each encapsulated\
    \ message:\n     1    If the packet contains no messages (i.e., the Packet Length\
    \ is\n          less than or equal to the size of the packet header), the\n  \
    \        packet MUST silently be discarded.\n          For IPv4 addresses, this\
    \ implies that packets, where the\n          Packet Length < 16 MUST silently\
    \ be discarded.\n     2    If the time to live of the message is less than or\
    \ equal to\n          '0' (zero), or if the message was sent by the receiving\
    \ node\n          (i.e., the Originator Address of the message is the main\n \
    \         address of the receiving node): the message MUST silently be\n     \
    \     dropped.\n     3    Processing condition:\n          3.1  if there exists\
    \ a tuple in the duplicate set, where:\n                             D_addr  \
    \  == Originator Address, AND\n                             D_seq_num == Message\
    \ Sequence Number\n               then the message has already been completely\
    \ processed\n               and MUST not be processed again.\n          3.2  Otherwise,\
    \ if the node implements the Message Type of the\n               message, the\
    \ message MUST be processed according to the\n               specifications for\
    \ the message type.\n     4    Forwarding condition:\n          4.1  if there\
    \ exists a tuple in the duplicate set, where:\n                              \
    \  D_addr    == Originator Address, AND\n                                D_seq_num\
    \ == Message Sequence Number,\n                    AND\n                     \
    \           the receiving interface (address) is\n                           \
    \     in D_iface_list\n               then the message has already been considered\
    \ for\n               forwarding and SHOULD NOT be retransmitted again.\n    \
    \      4.2  Otherwise:\n               4.2.1\n                    If the node\
    \ implements the Message Type of the\n                    message, the message\
    \ MUST be considered for\n                    forwarding according to the specifications\
    \ for\n                    the message type.\n               4.2.2\n         \
    \           Otherwise, if the node does not implement the\n                  \
    \  Message Type of the message, the message SHOULD\n                    be processed\
    \ according to the default\n                    forwarding algorithm described\
    \ below.\n"
- title: 3.4.1.  Default Forwarding Algorithm
  contents:
  - "3.4.1.  Default Forwarding Algorithm\n   The default forwarding algorithm is\
    \ the following:\n     1    If the sender interface address of the message is\
    \ not detected\n          to be in the symmetric 1-hop neighborhood of the node,\
    \ the\n          forwarding algorithm MUST silently stop here (and the message\n\
    \          MUST NOT be forwarded).\n     2    If there exists a tuple in the duplicate\
    \ set where:\n               D_addr    == Originator Address\n               D_seq_num\
    \ == Message Sequence Number\n          Then the message will be further considered\
    \ for forwarding if\n          and only if:\n               D_retransmitted is\
    \ false, AND\n               the (address of the) interface which received the\
    \ message\n               is not included among the addresses in D_iface_list\n\
    \     3    Otherwise, if such an entry doesn't exist, the message is\n       \
    \   further considered for forwarding.\n   If after those steps, the message is\
    \ not considered for forwarding,\n   then the processing of this section stops\
    \ (i.e., steps 4 to 8 are\n   ignored), otherwise, if it is still considered for\
    \ forwarding then\n   the following algorithm is used:\n     4    If the sender\
    \ interface address is an interface address of a\n          MPR selector of this\
    \ node and if the time to live of the\n          message is greater than '1',\
    \ the message MUST be retransmitted\n          (as described later in steps 6\
    \ to 8).\n     5    If an entry in the duplicate set exists, with same Originator\n\
    \          Address, and same Message Sequence Number, the entry is\n         \
    \ updated as follows:\n               D_time    = current time + DUP_HOLD_TIME.\n\
    \               The receiving interface (address) is added to\n              \
    \ D_iface_list.\n               D_retransmitted is set to true if and only if\
    \ the message\n               will be retransmitted according to step 4.\n   \
    \       Otherwise an entry in the duplicate set is recorded with:\n          \
    \     D_addr    = Originator Address\n               D_seq_num = Message Sequence\
    \ Number\n               D_time    = current time + DUP_HOLD_TIME.\n         \
    \      D_iface_list contains the receiving interface address.\n              \
    \ D_retransmitted is set to true if and only if the message\n               will\
    \ be retransmitted according to step 4.\n   If, and only if, according to step\
    \ 4, the message must be\n   retransmitted then:\n     6    The TTL of the message\
    \ is reduced by one.\n     7    The hop-count of the message is increased by one\n\
    \     8    The message is broadcast on all interfaces (Notice: The\n         \
    \ remaining fields of the message header SHOULD be left\n          unmodified.)\n"
- title: 3.4.2.  Considerations on Processing and Forwarding
  contents:
  - "3.4.2.  Considerations on Processing and Forwarding\n   It should be noted that\
    \ processing and forwarding messages are two\n   different actions, conditioned\
    \ by different rules.  Processing\n   relates to using the content of the messages,\
    \ while forwarding is\n   related to retransmitting the same message for other\
    \ nodes of the\n   network.\n   Notice that this specification includes a description\
    \ for both the\n   forwarding and the processing of each known message type. \
    \ Messages\n   with known message types MUST *NOT* be forwarded \"blindly\" by\
    \ this\n   algorithm.  Forwarding (and setting the correct message header in the\n\
    \   forwarded, known, message) is the responsibility of the algorithm\n   specifying\
    \ how the message is to be handled and, if necessary,\n   retransmitted.  This\
    \ enables a message type to be specified such that\n   the message can be modified\
    \ while in transit (e.g., to reflect the\n   route the message has taken).  It\
    \ also enables bypassing of the MPR\n   flooding mechanism if for some reason\
    \ classical flooding of a message\n   type is required, the algorithm which specifies\
    \ how such messages\n   should be handled will simply rebroadcast the message,\
    \ regardless of\n   MPRs.\n   By defining a set of message types, which MUST be\
    \ recognized by all\n   implementations of OLSR, it will be possible to extend\
    \ the protocol\n   through introduction of additional message types, while still\
    \ being\n   able to maintain compatibility with older implementations.  The\n\
    \   REQUIRED message types for the core functionality of OLSR are:\n     -   \
    \ HELLO-messages, performing the task of link sensing, neighbor\n          detection\
    \ and MPR signaling,\n     -    TC-messages, performing the task of topology declaration\n\
    \          (advertisement of link states).\n     -    MID-messages, performing\
    \ the task of declaring the presence of\n          multiple interfaces on a node.\n\
    \   Other message types include those specified in later sections, as\n   well\
    \ as possible future extensions such as messages enabling power\n   conservation\
    \ / sleep mode, multicast routing, support for\n   unidirectional links, auto-configuration/address\
    \ assignment etc.\n"
- title: 3.5.  Message Emission and Jitter
  contents:
  - "3.5.  Message Emission and Jitter\n   As a basic implementation requirement,\
    \ synchronization of control\n   messages SHOULD be avoided.  As a consequence,\
    \ OLSR control messages\n   SHOULD be emitted such that they avoid synchronization.\n\
    \   Emission of control traffic from neighboring nodes may, for various\n   reasons\
    \ (mainly timer interactions with packet processing), become\n   synchronized\
    \ such that several neighbor nodes attempt to transmit\n   control traffic simultaneously.\
    \  Depending on the nature of the\n   underlying link-layer, this may or may not\
    \ lead to collisions and\n   hence message loss - possibly loss of several subsequent\
    \ messages of\n   the same type.\n   To avoid such synchronizations, the following\
    \ simple strategy for\n   emitting control messages is proposed.  A node SHOULD\
    \ add an amount\n   of jitter to the interval at which messages are generated.\
    \  The\n   jitter must be a random value for each message generated.  Thus, for\n\
    \   a node utilizing jitter:\n        Actual message interval = MESSAGE_INTERVAL\
    \ - jitter\n   Where jitter is a value, randomly selected from the interval\n\
    \   [0,MAXJITTER] and MESSAGE_INTERVAL is the value of the message\n   interval\
    \ specified for the message being emitted (e.g.,\n   HELLO_INTERVAL for HELLO\
    \ messages, TC_INTERVAL for TC-messages etc.).\n   Jitter SHOULD also be introduced\
    \ when forwarding messages.  The\n   following simple strategy may be adopted:\
    \ when a message is to be\n   forwarded by a node, it should be kept in the node\
    \ during a short\n   period of time :\n           Keep message period = jitter\n\
    \   Where jitter is a random value in [0,MAXJITTER].\n   Notice that when the\
    \ node sends a control message, the opportunity to\n   piggyback other messages\
    \ (before their keeping period is expired) may\n   be taken to reduce the number\
    \ of packet transmissions.\n   Notice, that a minimal rate of control messages\
    \ is imposed.  A node\n   MAY send control messages at a higher rate, if beneficial\
    \ for a\n   specific deployment.\n"
- title: 4.  Information Repositories
  contents:
  - "4.  Information Repositories\n   Through the exchange of OLSR control messages,\
    \ each node accumulates\n   information about the network.  This information is\
    \ stored according\n   to the descriptions in this section.\n"
- title: 4.1.  Multiple Interface Association Information Base
  contents:
  - "4.1.  Multiple Interface Association Information Base\n   For each destination\
    \ in the network, \"Interface Association Tuples\"\n   (I_iface_addr, I_main_addr,\
    \ I_time) are recorded.  I_iface_addr is an\n   interface address of a node, I_main_addr\
    \ is the main address of this\n   node.  I_time specifies the time at which this\
    \ tuple expires and\n   *MUST* be removed.\n   In a node, the set of Interface\
    \ Association Tuples is denoted the\n   \"Interface Association Set\".\n"
- title: '4.2.  Link Sensing: Local Link Information Base'
  contents:
  - "4.2.  Link Sensing: Local Link Information Base\n   The local link information\
    \ base stores information about links to\n   neighbors.\n"
- title: 4.2.1.  Link Set
  contents:
  - "4.2.1.  Link Set\n   A node records a set of \"Link Tuples\" (L_local_iface_addr,\n\
    \   L_neighbor_iface_addr, L_SYM_time, L_ASYM_time, L_time).\n   L_local_iface_addr\
    \ is the interface address of the local node (i.e.,\n   one endpoint of the link),\
    \ L_neighbor_iface_addr is the interface\n   address of the neighbor node (i.e.,\
    \ the other endpoint of the link),\n   L_SYM_time is the time until which the\
    \ link is considered symmetric,\n   L_ASYM_time is the time until which the neighbor\
    \ interface is\n   considered heard, and L_time specifies the time at which this\
    \ record\n   expires and *MUST* be removed.  When L_SYM_time and L_ASYM_time are\n\
    \   expired, the link is considered lost.\n   This information is used when declaring\
    \ the neighbor interfaces in\n   the HELLO messages.\n   L_SYM_time is used to\
    \ decide the Link Type declared for the neighbor\n   interface.  If L_SYM_time\
    \ is not expired, the link MUST be declared\n   symmetric.  If L_SYM_time is expired,\
    \ the link MUST be declared\n   asymmetric.  If both L_SYM_time and L_ASYM_time\
    \ are expired, the link\n   MUST be declared lost.\n   In a node, the set of Link\
    \ Tuples are denoted the \"Link Set\".\n"
- title: '4.3.  Neighbor Detection: Neighborhood Information Base'
  contents:
  - "4.3.  Neighbor Detection: Neighborhood Information Base\n   The neighborhood\
    \ information base stores information about neighbors,\n   2-hop neighbors, MPRs\
    \ and MPR selectors.\n"
- title: 4.3.1.  Neighbor Set
  contents:
  - "4.3.1.  Neighbor Set\n   A node records a set of \"neighbor tuples\" (N_neighbor_main_addr,\n\
    \   N_status, N_willingness), describing neighbors.  N_neighbor_main_addr\n  \
    \ is the main address of a neighbor, N_status specifies if the node is\n   NOT_SYM\
    \ or SYM.  N_willingness in an integer between 0 and 7, and\n   specifies the\
    \ node's willingness to carry traffic on behalf of other\n   nodes.\n"
- title: 4.3.2.  2-hop Neighbor Set
  contents:
  - "4.3.2.  2-hop Neighbor Set\n   A node records a set of \"2-hop tuples\" (N_neighbor_main_addr,\n\
    \   N_2hop_addr, N_time), describing symmetric (and, since MPR links by\n   definition\
    \ are also symmetric, thereby also MPR) links between its\n   neighbors and the\
    \ symmetric 2-hop neighborhood.  N_neighbor_main_addr\n   is the main address\
    \ of a neighbor, N_2hop_addr is the main address of\n   a 2-hop neighbor with\
    \ a symmetric link to N_neighbor_main_addr, and\n   N_time specifies the time\
    \ at which the tuple expires and *MUST* be\n   removed.\n   In a node, the set\
    \ of 2-hop tuples are denoted the \"2-hop Neighbor\n   Set\".\n"
- title: 4.3.3.  MPR Set
  contents:
  - "4.3.3.  MPR Set\n   A node maintains a set of neighbors which are selected as\
    \ MPR.  Their\n   main addresses are listed in the MPR Set.\n"
- title: 4.3.4.  MPR Selector Set
  contents:
  - "4.3.4.  MPR Selector Set\n   A node records a set of MPR-selector tuples (MS_main_addr,\
    \ MS_time),\n   describing the neighbors which have selected this node as a MPR.\n\
    \   MS_main_addr is the main address of a node, which has selected this\n   node\
    \ as MPR.  MS_time specifies the time at which the tuple expires\n   and *MUST*\
    \ be removed.\n   In a node, the set of MPR-selector tuples are denoted the \"\
    MPR\n   Selector Set\".\n"
- title: 4.4.  Topology Information Base
  contents:
  - "4.4.  Topology Information Base\n   Each node in the network maintains topology\
    \ information about the\n   network.  This information is acquired from TC-messages\
    \ and is used\n   for routing table calculations.\n   Thus, for each destination\
    \ in the network, at least one \"Topology\n   Tuple\" (T_dest_addr, T_last_addr,\
    \ T_seq, T_time) is recorded.\n   T_dest_addr is the main address of a node, which\
    \ may be reached in\n   one hop from the node with the main address T_last_addr.\
    \  Typically,\n   T_last_addr is a MPR of T_dest_addr.  T_seq is a sequence number,\
    \ and\n   T_time specifies the time at which this tuple expires and *MUST* be\n\
    \   removed.\n   In a node, the set of Topology Tuples are denoted the \"Topology\
    \ Set\".\n"
- title: 5.  Main Addresses and Multiple Interfaces
  contents:
  - "5.  Main Addresses and Multiple Interfaces\n   For single OLSR interface nodes,\
    \ the relationship between an OLSR\n   interface address and the corresponding\
    \ main address is trivial: the\n   main address is the OLSR interface address.\
    \  For multiple OLSR\n   interface nodes, the relationship between OLSR interface\
    \ addresses\n   and main addresses is defined through the exchange of Multiple\n\
    \   Interface Declaration (MID) messages.  This section describes how MID\n  \
    \ messages are exchanged and processed.\n   Each node with multiple interfaces\
    \ MUST announce, periodically,\n   information describing its interface configuration\
    \ to other nodes in\n   the network.  This is accomplished through flooding a\
    \ Multiple\n   Interface Declaration message to all nodes in the network through\
    \ the\n   MPR flooding mechanism.\n   Each node in the network maintains interface\
    \ information about the\n   other nodes in the network.  This information acquired\
    \ from MID\n   messages, emitted by nodes with multiple interfaces participating\
    \ in\n   the MANET, and is used for routing table calculations.\n   Specifically,\
    \ multiple interface declaration associates multiple\n   interfaces to a node\
    \ (and to a main address) through populating the\n   multiple interface association\
    \ base in each node.\n"
- title: 5.1.  MID Message Format
  contents:
  - "5.1.  MID Message Format\n   The proposed format of a MID message is as follows:\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    OLSR Interface Address                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                    OLSR Interface Address                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                              ...                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   This\
    \ is sent as the data-portion of the general packet format\n   described in section\
    \ 3.4, with the \"Message Type\" set to MID_MESSAGE.\n   The time to live SHOULD\
    \ be set to 255 (maximum value) to diffuse the\n   message into the entire network\
    \ and Vtime set accordingly to the\n   value of MID_HOLD_TIME, as specified in\
    \ section 18.3.\n     OLSR Interface Address\n          This field contains the\
    \ address of an OLSR interface of the\n          node, excluding the nodes main\
    \ address (which already\n          indicated in the originator address).\n  \
    \ All interface addresses other than the main address of the originator\n   node\
    \ are put in the MID message.  If the maximum allowed message size\n   (as imposed\
    \ by the network) is reached while there are still\n   interface addresses which\
    \ have not been inserted into the MIDmessage,\n   more MID messages are generated\
    \ until the entire interface addresses\n   set has been sent.\n"
- title: 5.2.  MID Message Generation
  contents:
  - "5.2.  MID Message Generation\n   A MID message is sent by a node in the network\
    \ to declare its\n   multiple interfaces (if any).  I.e., the MID message contains\
    \ the\n   list of interface addresses which are associated to its main address.\n\
    \   The list of addresses can be partial in each MID message (e.g., due\n   to\
    \ message size limitations, imposed by the network), but parsing of\n   all MID\
    \ messages describing the interface set from a node MUST be\n   complete within\
    \ a certain refreshing period (MID_INTERVAL).  The\n   information diffused in\
    \ the network by these MID messages will help\n   each node to calculate its routing\
    \ table.  A node which has only a\n   single interface address participating in\
    \ the MANET (i.e., running\n   OLSR), MUST NOT generate any MID message.\n   A\
    \ node with several interfaces, where only one is participating in\n   the MANET\
    \ and running OLSR (e.g., a node is connected to a wired\n   network as well as\
    \ to a MANET) MUST NOT generate any MID messages.\n   A node with several interfaces,\
    \ where more than one is participating\n   in the MANET and running OLSR MUST\
    \ generate MID messages as\n   specified.\n"
- title: 5.3.  MID Message Forwarding
  contents:
  - "5.3.  MID Message Forwarding\n   MID messages are broadcast and retransmitted\
    \ by the MPRs in order to\n   diffuse the messages in the entire network.  The\
    \ \"default forwarding\n   algorithm\" (described in section 3.4) MUST be used\
    \ for forwarding of\n   MID messages.\n"
- title: 5.4.  MID Message Processing
  contents:
  - "5.4.  MID Message Processing\n   The tuples in the multiple interface association\
    \ set are recorded\n   with the information that is exchanged through MID messages.\n\
    \   Upon receiving a MID message, the \"validity time\" MUST be computed\n   from\
    \ the Vtime field of the message header (as described in section\n   3.3.2). \
    \ The Multiple Interface Association Information Base SHOULD\n   then be updated\
    \ as follows:\n     1    If the sender interface (NB: not originator) of this\
    \ message\n          is not in the symmetric 1-hop neighborhood of this node,\
    \ the\n          message MUST be discarded.\n     2    For each interface address\
    \ listed in the MID message:\n          2.1  If there exist some tuple in the\
    \ interface association\n               set where:\n                    I_iface_addr\
    \ == interface address, AND\n                    I_main_addr  == originator address,\n\
    \               then the holding time of that tuple is set to:\n             \
    \       I_time       = current time + validity time.\n          2.2  Otherwise,\
    \ a new tuple is recorded in the interface\n               association set where:\n\
    \                    I_iface_addr = interface address,\n                    I_main_addr\
    \  = originator address,\n                    I_time       = current time + validity\
    \ time.\n"
- title: 5.5.  Resolving a Main Address from an Interface Address
  contents:
  - "5.5.  Resolving a Main Address from an Interface Address\n   In general, the\
    \ only part of OLSR requiring use of \"interface\n   addresses\" is link sensing.\
    \  The remaining parts of OLSR operate on\n   nodes, uniquely identified by their\
    \ \"main addresses\" (effectively,\n   the main address of a node is its \"node\
    \ id\" - which for convenience\n   corresponds to the address of one of its interfaces).\
    \  In a network\n   with only single interface nodes, the main address of a node\
    \ will, by\n   definition, be equal to the interface address of the node.  In\n\
    \   networks with multiple interface nodes operating within a common OLSR\n  \
    \ area, it is required to be able to map any interface address to the\n   corresponding\
    \ main address.\n   The exchange of MID messages provides a way in which interface\n\
    \   information is acquired by nodes in the network.  This permits\n   identification\
    \ of a node's \"main address\", given one of its interface\n   addresses.\n  \
    \ Given an interface address:\n     1    if there exists some tuple in the interface\
    \ association set\n          where:\n               I_iface_addr == interface\
    \ address\n          then the result of the main address search is the originator\n\
    \          address I_main_addr of the tuple.\n     2    Otherwise, the result\
    \ of the main address search is the\n          interface address itself.\n"
- title: 6.  HELLO Message Format and Generation
  contents:
  - "6.  HELLO Message Format and Generation\n   A common mechanism is employed for\
    \ populating the local link\n   information base and the neighborhood information\
    \ base, namely\n   periodic exchange of HELLO messages.  Thus this section describes\
    \ the\n   general HELLO message mechanism, followed by a description of link\n\
    \   sensing and topology detection, respectively.\n"
- title: 6.1.  HELLO Message Format
  contents:
  - "6.1.  HELLO Message Format\n   To accommodate for link sensing, neighborhood\
    \ detection and MPR\n   selection signalling, as well as to accommodate for future\n\
    \   extensions, an approach similar to the overall packet format is\n   taken.\
    \  Thus the proposed format of a HELLO message is as follows:\n       0      \
    \             1                   2                   3\n       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Reserved             |     Htime     |  Willingness  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \   Link Code   |   Reserved    |       Link Message Size       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                  Neighbor Interface Address                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                  Neighbor Interface Address                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      :                             .  .  .                           :\n   \
    \   :                                                               :\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Link Code   |   Reserved    |       Link Message Size       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                  Neighbor Interface Address                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                  Neighbor Interface Address                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      :\
    \                                                               :\n      :   \
    \                                    :\n   (etc.)\n   This is sent as the data-portion\
    \ of the general packet format\n   described in section 3.4, with the \"Message\
    \ Type\" set to\n   HELLO_MESSAGE, the TTL field set to 1 (one) and Vtime set\
    \ accordingly\n   to the value of NEIGHB_HOLD_TIME, specified in section 18.3.\n\
    \      Reserved\n         This field must be set to \"0000000000000\" to be in\
    \ compliance\n         with this specification.\n      HTime\n         This field\
    \ specifies the HELLO emission interval used by the\n         node on this particular\
    \ interface, i.e., the time before the\n         transmission of the next HELLO\
    \ (this information may be used in\n         advanced link sensing, see section\
    \ 14).  The HELLO emission\n         interval is represented by its mantissa (four\
    \ highest bits of\n         Htime field) and by its exponent (four lowest bits\
    \ of Htime\n         field).  In other words:\n              HELLO emission interval=C*(1+a/16)*2^b\
    \  [in seconds]\n         where a is the integer represented by the four highest\
    \ bits of\n         Htime field and b the integer represented by the four lowest\n\
    \         bits of Htime field.  The proposed value of the scaling factor\n   \
    \      C is specified in section 18.\n      Willingness\n         This field specifies\
    \ the willingness of a node to carry and\n         forward traffic for other nodes.\n\
    \         A node with willingness WILL_NEVER (see section 18.8, for\n        \
    \ willingness constants) MUST never be selected as MPR by any\n         node.\
    \  A node with willingness WILL_ALWAYS MUST always be\n         selected as MPR.\
    \  By default, a node SHOULD advertise a\n         willingness of WILL_DEFAULT.\n\
    \      Link Code\n         This field specifies information about the link between\
    \ the\n         interface of the sender and the following list of neighbor\n \
    \        interfaces.  It also specifies information about the status of\n    \
    \     the neighbor.\n         Link codes, not known by a node, are silently discarded.\n\
    \      Link Message Size\n         The size of the link message, counted in bytes\
    \ and measured\n         from the beginning of the \"Link Code\" field and until\
    \ the next\n         \"Link Code\" field (or - if there are no more link types\
    \ - the\n         end of the message).\n      Neighbor Interface Address\n   \
    \      The address of an interface of a neighbor node.\n"
- title: 6.1.1.  Link Code as Link Type and Neighbor Type
  contents:
  - "6.1.1.  Link Code as Link Type and Neighbor Type\n   This document only specifies\
    \ processing of Link Codes < 16.\n   If the Link Code value is less than or equal\
    \ to 15, then it MUST be\n   interpreted as holding two different fields, of two\
    \ bits each:\n          7       6       5       4       3       2       1    \
    \   0\n      +-------+-------+-------+-------+-------+-------+-------+-------+\n\
    \      |   0   |   0   |   0   |   0   | Neighbor Type |   Link Type   |\n   \
    \   +-------+-------+-------+-------+-------+-------+-------+-------+\n   The\
    \ following four \"Link Types\" are REQUIRED by OLSR:\n     -    UNSPEC_LINK -\
    \ indicating that no specific information about\n          the links is given.\n\
    \     -    ASYM_LINK - indicating that the links are asymmetric (i.e.,\n     \
    \     the neighbor interface is \"heard\").\n     -    SYM_LINK - indicating that\
    \ the links are symmetric with the\n          interface.\n     -    LOST_LINK\
    \ - indicating that the links have been lost.\n   The following three \"Neighbor\
    \ Types\" are REQUIRED by OLSR:\n     -    SYM_NEIGH - indicating that the neighbors\
    \ have at least one\n          symmetrical link with this node.\n     -    MPR_NEIGH\
    \ - indicating that the neighbors have at least one\n          symmetrical link\
    \ AND have been selected as MPR by the sender.\n     -    NOT_NEIGH - indicating\
    \ that the nodes are either no longer or\n          have not yet become symmetric\
    \ neighbors.\n   Note that an implementation should be careful in confusing neither\n\
    \   Link Type with Neighbor Type nor the constants (confusing SYM_NEIGH\n   with\
    \ SYM_LINK for instance).\n   A link code advertising:\n          Link Type  \
    \   == SYM_LINK AND\n          Neighbor Type == NOT_NEIGH\n   is invalid, and\
    \ any links advertised as such MUST be silently\n   discarded without any processing.\n\
    \   Likewise a Neighbor Type field advertising a numerical value which is\n  \
    \ not one of the constants SYM_NEIGH, MPR_NEIGH, NOT_NEIGH, is invalid,\n   and\
    \ any links advertised as such MUST be silently discarded without\n   any processing.\n"
- title: 6.2.  HELLO Message Generation
  contents:
  - "6.2.  HELLO Message Generation\n   This involves transmitting the Link Set, the\
    \ Neighbor Set and the MPR\n   Set.  In principle, a HELLO message serves three\
    \ independent tasks:\n     -    link sensing\n     -    neighbor detection\n \
    \    -    MPR selection signaling\n   Three tasks are all are based on periodic\
    \ information exchange within\n   a nodes neighborhood, and serve the common purpose\
    \ of \"local topology\n   discovery\".  A HELLO message is therefore generated\
    \ based on the\n   information stored in the Local Link Set, the Neighbor Set\
    \ and the\n   MPR Set from the local link information base.\n   A node must perform\
    \ link sensing on each interface, in order to\n   detect links between the interface\
    \ and neighbor interfaces.\n   Furthermore, a node must advertise its entire symmetric\
    \ 1-hop\n   neighborhood on each interface in order to perform neighbor\n   detection.\
    \  Hence, for a given interface, a HELLO message will\n   contain a list of links\
    \ on that interface (with associated link\n   types), as well as a list of the\
    \ entire neighborhood (with an\n   associated neighbor types).\n   The Vtime field\
    \ is set such that it corresponds to the value of the\n   node's NEIGHB_HOLD_TIME\
    \ parameter.  The Htime field is set such that\n   it corresponds to the value\
    \ of the node's HELLO_INTERVAL parameter\n   (see section 18.3).\n   The Willingness\
    \ field is set such that it corresponds to the node's\n   willingness to forward\
    \ traffic on behalf of other nodes (see section\n   18.8).  A node MUST advertise\
    \ the same willingness on all interfaces.\n   The lists of addresses declared\
    \ in a HELLO message is a list of\n   neighbor interface addresses computed as\
    \ follows:\n   For each tuple in the Link Set, where L_local_iface_addr is the\n\
    \   interface where the HELLO is to be transmitted, and where L_time >=\n   current\
    \ time (i.e., not expired), L_neighbor_iface_addr is advertised\n   with:\n  \
    \   1    The Link Type set according to the following:\n          1.1  if L_SYM_time\
    \ >= current time (not expired)\n                    Link Type = SYM_LINK\n  \
    \        1.2  Otherwise, if L_ASYM_time >= current time (not expired)\n      \
    \         AND\n                             L_SYM_time  <  current time (expired)\n\
    \                    Link Type = ASYM_LINK\n          1.3  Otherwise, if L_ASYM_time\
    \ < current time (expired) AND\n                             L_SYM_time  < current\
    \ time (expired)\n                    Link Type = LOST_LINK\n     2    The Neighbor\
    \ Type is set according to the following:\n          2.1  If the main address,\
    \ corresponding to\n               L_neighbor_iface_addr, is included in the MPR\
    \ set:\n                    Neighbor Type = MPR_NEIGH\n          2.2  Otherwise,\
    \ if the main address, corresponding to\n               L_neighbor_iface_addr,\
    \ is included in the neighbor set:\n               2.2.1\n                   \
    \ if N_status == SYM\n                         Neighbor Type = SYM_NEIGH\n   \
    \            2.2.2\n                    Otherwise, if N_status == NOT_SYM\n  \
    \                       Neighbor Type = NOT_NEIGH\n   For each tuple in the Neighbor\
    \ Set, for which no\n   L_neighbor_iface_addr from an associated link tuple has\
    \ been\n   advertised by the previous algorithm,  N_neighbor_main_addr is\n  \
    \ advertised with:\n     - Link Type = UNSPEC_LINK,\n     - Neighbor Type set\
    \ as described in step 2 above\n   For a node with a single OLSR interface, the\
    \ main address is simply\n   the address of the OLSR interface, i.e., for a node\
    \ with a single\n   OLSR interface the main address, corresponding to\n   L_neighbor_iface_addr\
    \ is simply L_neighbor_iface_addr.\n   A HELLO message can be partial (e.g., due\
    \ to message size\n   limitations, imposed by the network), the rule being the\
    \ following,\n   on each interface: each link and each neighbor node MUST be cited\
    \ at\n   least once within a predetermined refreshing period,\n   REFRESH_INTERVAL.\
    \  To keep track of fast connectivity changes, a\n   HELLO message must be sent\
    \ at least every HELLO_INTERVAL period,\n   smaller than or equal to REFRESH_INTERVAL.\n\
    \   Notice that for limiting the impact from loss of control messages, it\n  \
    \ is desirable that a message (plus the generic packet header) can fit\n   into\
    \ a single MAC frame.\n"
- title: 6.3.  HELLO Message Forwarding
  contents:
  - "6.3.  HELLO Message Forwarding\n   Each HELLO message generated is broadcast\
    \ by the node on one\n   interface to its neighbors (i.e. the interface for which\
    \ the HELLO\n   was generated).  HELLO messages MUST never be forwarded.\n"
- title: 6.4.  HELLO Message Processing
  contents:
  - "6.4.  HELLO Message Processing\n   A node processes incoming HELLO messages for\
    \ the purpose of\n   conducting link sensing (detailed in section 7), neighbor\
    \ detection\n   and MPR selector set population (detailed in section 8)\n"
- title: 7.  Link Sensing
  contents:
  - "7.  Link Sensing\n   Link sensing populates the local link information base.\
    \  Link sensing\n   is exclusively concerned with OLSR interface addresses and\
    \ the\n   ability to exchange packets between such OLSR interfaces.\n   The mechanism\
    \ for link sensing is the periodic exchange of HELLO\n   messages.\n"
- title: 7.1.  Populating the Link Set
  contents:
  - "7.1.  Populating the Link Set\n   The Link Set is populated with information\
    \ on links to neighbor\n   nodes.  The process of populating this set is denoted\
    \ \"link sensing\"\n   and is performed using HELLO message exchange, updating\
    \ a local link\n   information base in each node.\n   Each node should detect\
    \ the links between itself and neighbor nodes.\n   Uncertainties over radio propagation\
    \ may make some links\n   unidirectional.  Consequently, all links MUST be checked\
    \ in both\n   directions in order to be considered valid.\n   A \"link\" is described\
    \ by a pair of interfaces: a local and a remote\n   interface.\n   For the purpose\
    \ of link sensing, each neighbor node (more\n   specifically, the link to each\
    \ neighbor) has an associated status of\n   either \"symmetric\" or \"asymmetric\"\
    .  \"Symmetric\" indicates, that the\n   link to that neighbor node has been verified\
    \ to be bi-directional,\n   i.e., it is possible to transmit data in both directions.\n\
    \   \"Asymmetric\" indicates that HELLO messages from the node have been\n   heard\
    \ (i.e., communication from the neighbor node is possible),\n   however it is\
    \ not confirmed that this node is also able to receive\n   messages (i.e., communication\
    \ to the neighbor node is not confirmed).\n   The information, acquired through\
    \ and used by the link sensing, is\n   accumulated in the link set.\n"
- title: 7.1.1.  HELLO Message Processing
  contents:
  - "7.1.1.  HELLO Message Processing\n   The \"Originator Address\" of a HELLO message\
    \ is the main address of\n   the node, which has emitted the message.\n   Upon\
    \ receiving a HELLO message, a node SHOULD update its Link Set.\n   Notice, that\
    \ a HELLO message MUST neither be forwarded nor be\n   recorded in the duplicate\
    \ set.\n   Upon receiving a HELLO message, the \"validity time\" MUST be computed\n\
    \   from the Vtime field of the message header (see section 3.3.2).\n   Then,\
    \ the Link Set SHOULD be updated as follows:\n     1    Upon receiving a HELLO\
    \ message, if there exists no link tuple\n          with\n               L_neighbor_iface_addr\
    \ == Source Address\n          a new tuple is created with\n               L_neighbor_iface_addr\
    \ = Source Address\n               L_local_iface_addr    = Address of the interface\n\
    \                                       which received the\n                 \
    \                      HELLO message\n               L_SYM_time            = current\
    \ time - 1 (expired)\n               L_time                = current time + validity\
    \ time\n     2    The tuple (existing or new) with:\n               L_neighbor_iface_addr\
    \ == Source Address\n          is then modified as follows:\n          2.1  L_ASYM_time\
    \ = current time + validity time;\n          2.2  if the node finds the address\
    \ of the interface which\n               received the HELLO message among the\
    \ addresses listed in\n               the link message then the tuple is modified\
    \ as follows:\n               2.2.1\n                    if Link Type is equal\
    \ to LOST_LINK then\n                         L_SYM_time = current time - 1 (i.e.,\
    \ expired)\n               2.2.2\n                    else if Link Type is equal\
    \ to SYM_LINK or ASYM_LINK\n                    then\n                       \
    \  L_SYM_time = current time + validity time,\n                         L_time\
    \     = L_SYM_time + NEIGHB_HOLD_TIME\n          2.3  L_time = max(L_time, L_ASYM_time)\n\
    \   The above rule for setting L_time is the following: a link losing its\n  \
    \ symmetry SHOULD still be advertised during at least the duration of\n   the\
    \ \"validity time\" advertised in the generated HELLO.  This allows\n   neighbors\
    \ to detect the link breakage.\n"
- title: 8.  Neighbor Detection
  contents:
  - "8.  Neighbor Detection\n   Neighbor detection populates the neighborhood information\
    \ base and\n   concerns itself with nodes and node main addresses.  The relationship\n\
    \   between OLSR interface addresses and main addresses is described in\n   section\
    \ 5.\n   The mechanism for neighbor detection is the periodic exchange of\n  \
    \ HELLO messages.\n"
- title: 8.1.  Populating the Neighbor Set
  contents:
  - "8.1.  Populating the Neighbor Set\n   A node maintains a set of neighbor tuples,\
    \ based on the link tuples.\n   This information is updated according to changes\
    \ in the Link Set.\n   The Link Set keeps the information about the links, while\
    \ the\n   Neighbor Set keeps the information about the neighbors.  There is a\n\
    \   clear association between those two sets, since a node is a neighbor\n   of\
    \ another node if and only if there is at least one link between the\n   two nodes.\n\
    \   In any case, the formal correspondence between links and neighbors is\n  \
    \ defined as follows:\n          The \"associated neighbor tuple\" of a link tuple,\
    \ is, if it\n          exists, the neighbor tuple where:\n               N_neighbor_main_addr\
    \ == main address of\n                                       L_neighbor_iface_addr\n\
    \          The \"associated link tuples\" of a neighbor tuple, are all the\n \
    \         link tuples, where:\n               N_neighbor_main_addr == main address\
    \ of\n                                       L_neighbor_iface_addr\n   The Neighbor\
    \ Set MUST be populated by maintaining the proper\n   correspondence between link\
    \ tuples and associated neighbor tuples, as\n   follows:\n     Creation\n    \
    \      Each time a link appears, that is, each time a link tuple is\n        \
    \  created, the associated neighbor tuple MUST be created, if it\n          doesn't\
    \ already exist, with the following values:\n               N_neighbor_main_addr\
    \ = main address of\n                                      L_neighbor_iface_addr\n\
    \                                      (from the link tuple)\n          In any\
    \ case, the N_status MUST then be computed as described\n          in the next\
    \ step\n     Update\n          Each time a link changes, that is, each time the\
    \ information\n          of a link tuple is modified, the node MUST ensure that\
    \ the\n          N_status of the associated neighbor tuple respects the\n    \
    \      property:\n               If the neighbor has any associated link tuple\
    \ which\n               indicates a symmetric link (i.e., with L_SYM_time >=\n\
    \               current time), then\n                    N_status is set to SYM\n\
    \               else N_status is set to NOT_SYM\n     Removal\n          Each\
    \ time a link is deleted, that is, each time a link tuple\n          is removed,\
    \ the associated neighbor tuple MUST be removed if\n          it has no longer\
    \ any associated link tuples.\n   These rules ensure that there is exactly one\
    \ associated neighbor\n   tuple for a link tuple, and that every neighbor tuple\
    \ has at least\n   one associated link tuple.\n"
- title: 8.1.1.  HELLO Message Processing
  contents:
  - "8.1.1.  HELLO Message Processing\n   The \"Originator Address\" of a HELLO message\
    \ is the main address of\n   the node, which has emitted the message.  Likewise,\
    \ the \"willingness\"\n   MUST be computed from the Willingness field of the HELLO\
    \ message (see\n   section 6.1).\n   Upon receiving a HELLO message, a node SHOULD\
    \ first update its Link\n   Set as described before.  It SHOULD then update its\
    \ Neighbor Set as\n   follows:\n     -    if the Originator Address is the N_neighbor_main_addr\
    \ from a\n          neighbor tuple included in the Neighbor Set:\n           \
    \    then, the neighbor tuple SHOULD be updated as follows:\n               N_willingness\
    \ = willingness from the HELLO message\n"
- title: 8.2.  Populating the 2-hop Neighbor Set
  contents:
  - "8.2.  Populating the 2-hop Neighbor Set\n   The 2-hop neighbor set describes\
    \ the set of nodes which have a\n   symmetric link to a symmetric neighbor.  This\
    \ information set is\n   maintained through periodic exchange of HELLO messages\
    \ as described\n   in this section.\n"
- title: 8.2.1.  HELLO Message Processing
  contents:
  - "8.2.1.  HELLO Message Processing\n   The \"Originator Address\" of a HELLO message\
    \ is the main address of\n   the node, which has emitted the message.\n   Upon\
    \ receiving a HELLO message from a symmetric neighbor, a node\n   SHOULD update\
    \ its 2-hop Neighbor Set.  Notice, that a HELLO message\n   MUST neither be forwarded\
    \ nor be recorded in the duplicate set.\n   Upon receiving a HELLO message, the\
    \ \"validity time\" MUST be computed\n   from the Vtime field of the message header\
    \ (see section 3.3.2).\n   If the Originator Address is the main address of a\n\
    \   L_neighbor_iface_addr from a link tuple included in the Link Set with\n  \
    \        L_SYM_time >= current time (not expired)\n   (in other words: if the\
    \ Originator Address is a symmetric neighbor)\n   then the 2-hop Neighbor Set\
    \ SHOULD be updated as follows:\n     1    for each address (henceforth: 2-hop\
    \ neighbor address), listed\n          in the HELLO message with Neighbor Type\
    \ equal to SYM_NEIGH or\n          MPR_NEIGH:\n          1.1  if the main address\
    \ of the 2-hop neighbor address = main\n               address of the receiving\
    \ node:\n                    silently discard the 2-hop neighbor address.\n  \
    \             (in other words: a node is not its own 2-hop neighbor).\n      \
    \    1.2  Otherwise, a 2-hop tuple is created with:\n                    N_neighbor_main_addr\
    \ =  Originator Address;\n                    N_2hop_addr          =  main address\
    \ of the\n                                            2-hop neighbor;\n      \
    \              N_time               =  current time\n                        \
    \                    + validity time.\n               This tuple may replace an\
    \ older similar tuple with same\n               N_neighbor_main_addr and N_2hop_addr\
    \ values.\n     2    For each 2-hop node listed in the HELLO message with Neighbor\n\
    \          Type equal to NOT_NEIGH, all 2-hop tuples where:\n               N_neighbor_main_addr\
    \ == Originator Address AND\n               N_2hop_addr          == main address\
    \ of the\n                                       2-hop neighbor\n          are\
    \ deleted.\n"
- title: 8.3.  Populating the MPR set
  contents:
  - "8.3.  Populating the MPR set\n   MPRs are used to flood control messages from\
    \ a node into the network\n   while reducing the number of retransmissions that\
    \ will occur in a\n   region.  Thus, the concept of MPR is an optimization of\
    \ a classical\n   flooding mechanism.\n   Each node in the network selects, independently,\
    \ its own set of MPRs\n   among its symmetric 1-hop neighborhood.  The symmetric\
    \ links with\n   MPRs are advertised with Link Type MPR_NEIGH instead of SYM_NEIGH\
    \ in\n   HELLO messages.\n   The MPR set MUST be calculated by a node in such\
    \ a way that it,\n   through the neighbors in the MPR-set, can reach all symmetric\
    \ strict\n   2-hop neighbors.  (Notice that a node, a, which is a direct neighbor\n\
    \   of another node, b, is not also a strict 2-hop neighbor of node b).\n   This\
    \ means that the union of the symmetric 1-hop neighborhoods of the\n   MPR nodes\
    \ contains the symmetric strict 2-hop neighborhood.  MPR set\n   recalculation\
    \ should occur when changes are detected in the symmetric\n   neighborhood or\
    \ in the symmetric strict 2-hop neighborhood.\n   MPRs are computed per interface,\
    \ the union of the MPR sets of each\n   interface make up the MPR set for the\
    \ node.\n   While it is not essential that the MPR set is minimal, it is\n   essential\
    \ that all strict 2-hop neighbors can be reached through the\n   selected MPR\
    \ nodes.  A node SHOULD select an MPR set such that any\n   strict 2-hop neighbor\
    \ is covered by at least one MPR node.  Keeping\n   the MPR set small ensures\
    \ that the overhead of the protocol is kept\n   at a minimum.\n   The MPR set\
    \ can coincide with the entire symmetric neighbor set.\n   This could be the case\
    \ at network initialization (and will correspond\n   to classic link-state routing).\n"
- title: 8.3.1.  MPR Computation
  contents:
  - "8.3.1.  MPR Computation\n   The following specifies a proposed heuristic for\
    \ selection of MPRs.\n   It constructs an MPR-set that enables a node to reach\
    \ any node in the\n   symmetrical strict 2-hop neighborhood through relaying by\
    \ one MPR\n   node with willingness different from WILL_NEVER.  The heuristic\
    \ MUST\n   be applied per interface, I.  The MPR set for a node is the union of\n\
    \   the MPR sets found for each interface.  The following terminology\n   will\
    \ be used in describing the heuristics:\n       neighbor of an interface\n   \
    \           a node is a \"neighbor of an interface\" if the interface\n      \
    \        (on the local node) has a link to any one interface of\n            \
    \  the neighbor node.\n       2-hop neighbors reachable from an interface\n  \
    \            the list of 2-hop neighbors of the node that can be\n           \
    \   reached from neighbors of this interface.\n       MPR set of an interface\n\
    \              a (sub)set of the neighbors of an interface with a\n          \
    \    willingness different from WILL_NEVER, selected such that\n             \
    \ through these selected nodes, all strict 2-hop neighbors\n              reachable\
    \ from that interface are reachable.\n       N:\n              N is the subset\
    \ of neighbors of the node, which are\n              neighbor of the interface\
    \ I.\n       N2:\n              The set of 2-hop neighbors reachable from the\
    \ interface\n              I, excluding:\n               (i)   the nodes only\
    \ reachable by members of N with\n                     willingness WILL_NEVER\n\
    \               (ii)  the node performing the computation\n               (iii)\
    \ all the symmetric neighbors: the nodes for which\n                     there\
    \ exists a symmetric link to this node on some\n                     interface.\n\
    \    D(y):\n              The degree of a 1-hop neighbor node y (where y is a\n\
    \              member of N), is defined as the number of symmetric\n         \
    \     neighbors of node y, EXCLUDING all the members of N and\n              EXCLUDING\
    \ the node performing the computation.\n   The proposed heuristic is as follows:\n\
    \     1    Start with an MPR set made of all members of N with\n          N_willingness\
    \ equal to WILL_ALWAYS\n     2    Calculate D(y), where y is a member of N, for\
    \ all nodes in N.\n     3    Add to the MPR set those nodes in N, which are the\
    \ *only*\n          nodes to provide reachability to a node in N2.  For example,\n\
    \          if node b in N2 can be reached only through a symmetric link\n    \
    \      to node a in N, then add node a to the MPR set.  Remove the\n         \
    \ nodes from N2 which are now covered by a node in the MPR set.\n     4    While\
    \ there exist nodes in N2 which are not covered by at\n          least one node\
    \ in the MPR set:\n          4.1  For each node in N, calculate the reachability,\
    \ i.e., the\n               number of nodes in N2 which are not yet covered by\
    \ at\n               least one node in the MPR set, and which are reachable\n\
    \               through this 1-hop neighbor;\n          4.2  Select as a MPR the\
    \ node with highest N_willingness among\n               the nodes in N with non-zero\
    \ reachability.  In case of\n               multiple choice select the node which\
    \ provides\n               reachability to the maximum number of nodes in N2.\
    \  In\n               case of multiple nodes providing the same amount of\n  \
    \             reachability, select the node as MPR whose D(y) is\n           \
    \    greater.  Remove the nodes from N2 which are now covered\n              \
    \ by a node in the MPR set.\n     5    A node's MPR set is generated from the\
    \ union of the MPR sets\n          for each interface.  As an optimization, process\
    \ each node, y,\n          in the MPR set in increasing order of N_willingness.\
    \  If all\n          nodes in N2 are still covered by at least one node in the\
    \ MPR\n          set excluding node y, and if N_willingness of node y is\n   \
    \       smaller than WILL_ALWAYS, then node y MAY be removed from the\n      \
    \    MPR set.\n   Other algorithms, as well as improvements over this algorithm,\
    \ are\n   possible.  For example, assume that in a multiple-interface scenario\n\
    \   there exists more than one link between nodes 'a' and 'b'.  If node\n   'a'\
    \ has selected node 'b' as MPR for one of its interfaces, then node\n   'b' can\
    \ be selected as MPR without additional performance loss by any\n   other interfaces\
    \ on node 'a'.\n"
- title: 8.4.  Populating the MPR Selector Set
  contents:
  - "8.4.  Populating the MPR Selector Set\n   The MPR selector set of a node, n,\
    \ is populated by the main addresses\n   of the nodes which have selected n as\
    \ MPR.  MPR selection is signaled\n   through HELLO messages.\n"
- title: 8.4.1.  HELLO Message Processing
  contents:
  - "8.4.1.  HELLO Message Processing\n   Upon receiving a HELLO message, if a node\
    \ finds one of its own\n   interface addresses in the list with a Neighbor Type\
    \ equal to\n   MPR_NEIGH, information from the HELLO message must be recorded\
    \ in the\n   MPR Selector Set.\n   The \"validity time\" MUST be computed from\
    \ the Vtime field of the\n   message header (see section 3.3.2).  The MPR Selector\
    \ Set SHOULD then\n   be updated as follows:\n     1    If there exists no MPR\
    \ selector tuple with:\n                    MS_main_addr   == Originator Address\n\
    \               then a new tuple is created with:\n                    MS_main_addr\
    \   =  Originator Address\n     2    The tuple (new or otherwise) with\n     \
    \          MS_main_addr   == Originator Address\n          is then modified as\
    \ follows:\n               MS_time        =  current time + validity time.\n \
    \  Deletion of MPR selector tuples occurs in case of expiration of the\n   timer\
    \ or in case of link breakage as described in the \"Neighborhood\n   and 2-hop\
    \ Neighborhood Changes\".\n"
- title: 8.5.  Neighborhood and 2-hop Neighborhood Changes
  contents:
  - "8.5.  Neighborhood and 2-hop Neighborhood Changes\n   A change in the neighborhood\
    \ is detected when:\n     -    The L_SYM_time field of a link tuple expires. \
    \ This is\n          considered as a neighbor loss if the link described by the\n\
    \          expired tuple was the last link with a neighbor node (on the\n    \
    \      contrary, a link with an interface may break while a link with\n      \
    \    another interface of the neighbor node remains without being\n          observed\
    \ as a neighborhood change).\n     -    A new link tuple is inserted in the Link\
    \ Set with a non\n          expired L_SYM_time or a tuple with expired L_SYM_time\
    \ is\n          modified so that L_SYM_time becomes non-expired.  This is\n  \
    \        considered as a neighbor appearance if there was previously no\n    \
    \      link tuple describing a link with the corresponding neighbor\n        \
    \  node.\n   A change in the 2-hop neighborhood is detected when a 2-hop neighbor\n\
    \   tuple expires or is deleted according to section 8.2.\n   The following processing\
    \ occurs when changes in the neighborhood or\n   the 2-hop neighborhood are detected:\n\
    \     -    In case of neighbor loss, all 2-hop tuples with\n          N_neighbor_main_addr\
    \ == Main Address of the neighbor MUST be\n          deleted.\n     -    In case\
    \ of neighbor loss, all MPR selector tuples with\n          MS_main_addr == Main\
    \ Address of the neighbor MUST be deleted\n     -    The MPR set MUST be re-calculated\
    \ when a neighbor appearance\n          or loss is detected, or when a change\
    \ in the 2-hop\n          neighborhood is detected.\n     -    An additional HELLO\
    \ message MAY be sent when the MPR set\n          changes.\n"
- title: 9.  Topology Discovery
  contents:
  - "9.  Topology Discovery\n   The link sensing and neighbor detection part of the\
    \ protocol\n   basically offers, to each node, a list of neighbors with which\
    \ it can\n   communicate directly and, in combination with the Packet Format and\n\
    \   Forwarding part, an optimized flooding mechanism through MPRs.  Based\n  \
    \ on this, topology information is disseminated through the network.\n   The present\
    \ section describes which part of the information given by\n   the link sensing\
    \ and neighbor detection is disseminated to the entire\n   network and how it\
    \ is used to construct routes.\n   Routes are constructed through advertised links\
    \ and links with\n   neighbors.  A node must at least disseminate links between\
    \ itself and\n   the nodes in its MPR-selector set, in order to provide sufficient\n\
    \   information to enable routing.\n"
- title: 9.1.  TC Message Format
  contents:
  - "9.1.  TC Message Format\n   The proposed format of a TC message is as follows:\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |              ANSN             |           Reserved            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \               Advertised Neighbor Main Address                |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |               Advertised Neighbor Main Address                |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                              ...                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This is sent as the data-portion of the general message format with\n   the\
    \ \"Message Type\" set to TC_MESSAGE.  The time to live SHOULD be set\n   to 255\
    \ (maximum value) to diffuse the message into the entire network\n   and Vtime\
    \ set accordingly to the value of TOP_HOLD_TIME, as specified\n   in section 18.3.\n\
    \     Advertised Neighbor Sequence Number (ANSN)\n          A sequence number\
    \ is associated with the advertised neighbor\n          set.  Every time a node\
    \ detects a change in its advertised\n          neighbor set, it increments this\
    \ sequence number (\"Wraparound\"\n          is handled as described in section\
    \ 19).  This number is sent\n          in this ANSN field of the TC message to\
    \ keep track of the most\n          recent information.  When a node receives\
    \ a TC message, it can\n          decide on the basis of this Advertised Neighbor\
    \ Sequence\n          Number, whether or not the received information about the\n\
    \          advertised neighbors of the originator node is more recent\n      \
    \    than what it already has.\n     Advertised Neighbor Main Address\n      \
    \    This field contains the main address of a neighbor node.  All\n         \
    \ main addresses of the advertised neighbors of the Originator\n          node\
    \ are put in the TC message.  If the maximum allowed\n          message size (as\
    \ imposed by the network) is reached while\n          there are still advertised\
    \ neighbor addresses which have not\n          been inserted into the TC-message,\
    \ more TC messages will be\n          generated until the entire advertised neighbor\
    \ set has been\n          sent.  Extra main addresses of neighbor nodes may be\
    \ included,\n          if redundancy is desired.\n     Reserved\n          This\
    \ field is reserved, and MUST be set to \"0000000000000000\"\n          for compliance\
    \ with this document.\n"
- title: 9.2.  Advertised Neighbor Set
  contents:
  - "9.2.  Advertised Neighbor Set\n   A TC message is sent by a node in the network\
    \ to declare a set of\n   links, called advertised link set which MUST include\
    \ at least the\n   links to all nodes of its MPR Selector set, i.e., the neighbors\
    \ which\n   have selected the sender node as a MPR.\n   If, for some reason, it\
    \ is required to distribute redundant TC\n   information, refer to section 15.\n\
    \   The sequence number (ANSN) associated with the advertised neighbor\n   set\
    \ is also sent with the list.  The ANSN number MUST be incremented\n   when links\
    \ are removed from the advertised neighbor set; the ANSN\n   number SHOULD be\
    \ incremented when links are added to the advertised\n   neighbor set.\n"
- title: 9.3.  TC Message Generation
  contents:
  - "9.3.  TC Message Generation\n   In order to build the topology information base,\
    \ each node, which has\n   been selected as MPR, broadcasts Topology Control (TC)\
    \ messages.  TC\n   messages are flooded to all nodes in the network and take\
    \ advantage\n   of MPRs.  MPRs enable a better scalability in the distribution\
    \ of\n   topology information [1].\n   The list of addresses can be partial in\
    \ each TC message (e.g., due to\n   message size limitations, imposed by the network),\
    \ but parsing of all\n   TC messages describing the advertised link set of a node\
    \ MUST be\n   complete within a certain refreshing period (TC_INTERVAL).  The\n\
    \   information diffused in the network by these TC messages will help\n   each\
    \ node calculate its routing table.\n   When the advertised link set of a node\
    \ becomes empty, this node\n   SHOULD still send (empty) TC-messages during the\
    \ a duration equal to\n   the \"validity time\" (typically, this will be equal\
    \ to TOP_HOLD_TIME)\n   of its previously emitted TC-messages, in order to invalidate\
    \ the\n   previous TC-messages.  It SHOULD then stop sending TC-messages until\n\
    \   some node is inserted in its advertised link set.\n   A node MAY transmit\
    \ additional TC-messages to increase its\n   reactiveness to link failures.  When\
    \ a change to the MPR selector set\n   is detected and this change can be attributed\
    \ to a link failure, a\n   TC-message SHOULD be transmitted after an interval\
    \ shorter than\n   TC_INTERVAL.\n"
- title: 9.4.  TC Message Forwarding
  contents:
  - "9.4.  TC Message Forwarding\n   TC messages are broadcast and retransmitted by\
    \ the MPRs in order to\n   diffuse the messages in the entire network.  TC messages\
    \ MUST be\n   forwarded according to the \"default forwarding algorithm\" (described\n\
    \   in section 3.4).\n"
- title: 9.5.  TC Message Processing
  contents:
  - "9.5.  TC Message Processing\n   Upon receiving a TC message, the \"validity time\"\
    \ MUST be computed\n   from the Vtime field of the message header (see section\
    \ 3.3.2).  The\n   topology set SHOULD then be updated as follows (using section\
    \ 19 for\n   comparison of ANSN):\n     1    If the sender interface (NB: not\
    \ originator) of this message\n          is not in the symmetric 1-hop neighborhood\
    \ of this node, the\n          message MUST be discarded.\n     2    If there\
    \ exist some tuple in the topology set where:\n               T_last_addr == originator\
    \ address AND\n               T_seq       >  ANSN,\n          then further processing\
    \ of this TC message MUST NOT be\n          performed and the message MUST be\
    \ silently discarded (case:\n          message received out of order).\n     3\
    \    All tuples in the topology set where:\n               T_last_addr == originator\
    \ address AND\n               T_seq       <  ANSN\n          MUST be removed from\
    \ the topology set.\n     4    For each of the advertised neighbor main address\
    \ received in\n          the TC message:\n          4.1  If there exist some tuple\
    \ in the topology set where:\n                    T_dest_addr == advertised neighbor\
    \ main address, AND\n                    T_last_addr == originator address,\n\
    \               then the holding time of that tuple MUST be set to:\n        \
    \            T_time      =  current time + validity time.\n          4.2  Otherwise,\
    \ a new tuple MUST be recorded in the topology\n               set where:\n  \
    \                  T_dest_addr = advertised neighbor main address,\n         \
    \           T_last_addr = originator address,\n                    T_seq     \
    \  = ANSN,\n                    T_time      = current time + validity time.\n"
- title: 10.  Routing Table Calculation
  contents:
  - "10.  Routing Table Calculation\n   Each node maintains a routing table which\
    \ allows it to route data,\n   destined for the other nodes in the network.  The\
    \ routing table is\n   based on the information contained in the local link information\
    \ base\n   and the topology set.  Therefore, if any of these sets are changed,\n\
    \   the routing table is recalculated to update the route information\n   about\
    \ each destination in the network.  The route entries are\n   recorded in the\
    \ routing table in the following format:\n         1.  R_dest_addr    R_next_addr\
    \    R_dist   R_iface_addr\n         2.  R_dest_addr    R_next_addr    R_dist\
    \   R_iface_addr\n         3.      ,,             ,,           ,,          ,,\n\
    \   Each entry in the table consists of R_dest_addr, R_next_addr, R_dist,\n  \
    \ and R_iface_addr.  Such entry specifies that the node identified by\n   R_dest_addr\
    \ is estimated to be R_dist hops away from the local node,\n   that the symmetric\
    \ neighbor node with interface address R_next_addr\n   is the next hop node in\
    \ the route to R_dest_addr, and that this\n   symmetric neighbor node is reachable\
    \ through the local interface with\n   the address R_iface_addr.  Entries are\
    \ recorded in the routing table\n   for each destination in the network for which\
    \ a route is known.  All\n   the destinations, for which a route is broken or\
    \ only partially\n   known, are not recorded in the table.\n   More precisely,\
    \ the routing table is updated when a change is\n   detected in either:\n    \
    \ -    the link set,\n     -    the neighbor set,\n     -    the 2-hop neighbor\
    \ set,\n     -    the topology set,\n     -    the Multiple Interface Association\
    \ Information Base,\n   More precisely, the routing table is recalculated in case\
    \ of neighbor\n   appearance or loss, when a 2-hop tuple is created or removed,\
    \ when a\n   topology tuple is created or removed or when multiple interface\n\
    \   association information changes.  The update of this routing\n   information\
    \ does not generate or trigger any messages to be\n   transmitted, neither in\
    \ the network, nor in the 1-hop neighborhood.\n   To construct the routing table\
    \ of node X, a shortest path algorithm\n   is run on the directed graph containing\
    \ the arcs X -> Y where Y is\n   any symmetric neighbor of X (with Neighbor Type\
    \ equal to SYM), the\n   arcs Y -> Z where Y is a neighbor node with willingness\
    \ different of\n   WILL_NEVER and there exists an entry in the 2-hop Neighbor\
    \ set with Y\n   as N_neighbor_main_addr and Z as N_2hop_addr, and the arcs U\
    \ -> V,\n   where there exists an entry in the topology set with V as T_dest_addr\n\
    \   and U as T_last_addr.\n   The following procedure is given as an example to\
    \ calculate (or\n   recalculate) the routing table:\n     1    All the entries\
    \ from the routing table are removed.\n     2    The new routing entries are added\
    \ starting with the\n          symmetric neighbors (h=1) as the destination nodes.\
    \ Thus, for\n          each neighbor tuple in the neighbor set where:\n      \
    \         N_status   = SYM\n          (there is a symmetric link to the neighbor),\
    \ and for each\n          associated link tuple of the neighbor node such that\
    \ L_time >=\n          current time, a new routing entry is recorded in the routing\n\
    \          table with:\n               R_dest_addr  = L_neighbor_iface_addr, of\
    \ the\n                              associated link tuple;\n               R_next_addr\
    \  = L_neighbor_iface_addr, of the\n                              associated link\
    \ tuple;\n               R_dist       = 1;\n               R_iface_addr = L_local_iface_addr\
    \ of the\n                              associated link tuple.\n          If in\
    \ the above, no R_dest_addr is equal to the main address\n          of the neighbor,\
    \ then another new routing entry with MUST be\n          added, with:\n      \
    \         R_dest_addr  = main address of the neighbor;\n               R_next_addr\
    \  = L_neighbor_iface_addr of one of the\n                              associated\
    \ link tuple with L_time >=\n               current time;\n               R_dist\
    \       = 1;\n               R_iface_addr = L_local_iface_addr of the\n      \
    \                        associated link tuple.\n     3    for each node in N2,\
    \ i.e., a 2-hop neighbor which is not a\n          neighbor node or the node itself,\
    \ and such that there exist at\n          least one entry in the 2-hop neighbor\
    \ set where\n          N_neighbor_main_addr correspond to a neighbor node with\n\
    \          willingness different of WILL_NEVER, one selects one 2-hop\n      \
    \    tuple and creates one entry in the routing table with:\n               R_dest_addr\
    \  =  the main address of the 2-hop neighbor;\n               R_next_addr  = the\
    \ R_next_addr of the entry in the\n                              routing table\
    \ with:\n                                  R_dest_addr == N_neighbor_main_addr\n\
    \                                                 of the 2-hop tuple;\n      \
    \         R_dist       = 2;\n               R_iface_addr = the R_iface_addr of\
    \ the entry in the\n                              routing table with:\n      \
    \                            R_dest_addr == N_neighbor_main_addr\n           \
    \                                      of the 2-hop tuple;\n     3    The new\
    \ route entries for the destination nodes h+1 hops away\n          are recorded\
    \ in the routing table.  The following procedure\n          MUST be executed for\
    \ each value of h, starting with h=2 and\n          incrementing it by 1 each\
    \ time.  The execution will stop if no\n          new entry is recorded in an\
    \ iteration.\n          3.1  For each topology entry in the topology table, if\
    \ its\n               T_dest_addr does not correspond to R_dest_addr of any\n\
    \               route entry in the routing table AND its T_last_addr\n       \
    \        corresponds to R_dest_addr of a route entry whose R_dist\n          \
    \     is equal to h, then a new route entry MUST be recorded in\n            \
    \   the routing table (if it does not already exist) where:\n                \
    \    R_dest_addr  = T_dest_addr;\n                    R_next_addr  = R_next_addr\
    \ of the recorded\n                                   route entry where:\n   \
    \                                R_dest_addr == T_last_addr\n                \
    \    R_dist       = h+1; and\n                    R_iface_addr = R_iface_addr\
    \ of the recorded\n                                   route entry where:\n   \
    \                                   R_dest_addr == T_last_addr.\n          3.2\
    \  Several topology entries may be used to select a next hop\n               R_next_addr\
    \ for reaching the node R_dest_addr.  When h=1,\n               ties should be\
    \ broken such that nodes with highest\n               willingness and MPR selectors\
    \ are preferred as next hop.\n     4    For each entry in the multiple interface\
    \ association base\n          where there exists a routing entry such that:\n\
    \               R_dest_addr  == I_main_addr  (of the multiple interface\n    \
    \                                        association entry)\n          AND there\
    \ is no routing entry such that:\n               R_dest_addr  == I_iface_addr\n\
    \          then a route entry is created in the routing table with:\n        \
    \       R_dest_addr  =  I_iface_addr (of the multiple interface\n            \
    \                                 association entry)\n               R_next_addr\
    \  =  R_next_addr  (of the recorded\n                                        \
    \     route entry)\n               R_dist       =  R_dist       (of the recorded\n\
    \                                             route entry)\n               R_iface_addr\
    \ =  R_iface_addr (of the recorded\n                                         \
    \       route entry).\n"
- title: 11.  Node Configuration
  contents:
  - "11.  Node Configuration\n   This section outlines how a node should be configured,\
    \ in order to\n   operate in an OLSR MANET.\n"
- title: 11.1.  Address Assignment
  contents:
  - "11.1.  Address Assignment\n   The nodes in the MANET network SHOULD be assigned\
    \ addresses within a\n   defined address sequence, i.e., the nodes in the MANET\
    \ SHOULD be\n   addressable through a network address and a netmask.\n   Likewise,\
    \ the nodes in each associated network SHOULD be assigned\n   addresses from a\
    \ defined address sequence, distinct from that being\n   used in the MANET.\n"
- title: 11.2.  Routing Configuration
  contents:
  - "11.2.  Routing Configuration\n   Any MANET node with associated networks or hosts\
    \ SHOULD be configured\n   such that it has routes set up to the interfaces with\
    \ associated\n   hosts or network.\n"
- title: 11.3.  Data Packet Forwarding
  contents:
  - "11.3.  Data Packet Forwarding\n   OLSR itself does not perform packet forwarding.\
    \  Rather, it maintains\n   the routing table in the underlying operating system,\
    \ which is\n   assumed to be forwarding packets as specified in RFC1812.\n"
- title: 12.  Non OLSR Interfaces
  contents:
  - "12.  Non OLSR Interfaces\n   A node MAY be equipped with multiple interfaces,\
    \ some of which do not\n   participate in the OLSR MANET.  These non OLSR interfaces\
    \ may be\n   point to point connections to other singular hosts or may connect\
    \ to\n   separate networks.\n   In order to provide connectivity from the OLSR\
    \ MANET interface(s) to\n   these non OLSR interface(s), a node SHOULD be able\
    \ to inject external\n   route information to the OLSR MANET.\n   Injecting routing\
    \ information from the OLSR MANET to non OLSR\n   interfaces is outside the scope\
    \ of this specification.  It should be\n   clear, however, that the routing information\
    \ for the OLSR MANET can\n   be extracted from the topology table (see section\
    \ 4.4) or directly\n   from the routing table of OLSR, and SHOULD be injected\
    \ onto the non\n   OLSR interfaces following whatever mechanism (routing protocol,\n\
    \   static configuration etc.) is provided on these interfaces.\n   An example\
    \ of such a situation could be where a node is equipped with\n   a fixed network\
    \ (e.g., an Ethernet) connecting to a larger network as\n   well as a wireless\
    \ network interface running OLSR.\n   Notice that this is a different case from\
    \ that of \"multiple\n   interfaces\", where all the interfaces are participating\
    \ in the MANET\n   through running the OLSR protocol.\n   In order to provide\
    \ this capability of injecting external routing\n   information into an OLSR MANET,\
    \ a node with such non-MANET interfaces\n   periodically issues a Host and Network\
    \ Association (HNA) message,\n   containing sufficient information for the recipients\
    \ to construct an\n   appropriate routing table.\n"
- title: 12.1.  HNA Message Format
  contents:
  - "12.1.  HNA Message Format\n   The proposed format of an HNA-message is:\n   \
    \    0                   1                   2                   3\n       0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         Network Address                       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                             Netmask                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         Network Address                       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                             Netmask                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                              ...                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   This\
    \ is sent as the data part of the general packet format with the\n   \"Message\
    \ Type\" set to HNA_MESSAGE, the TTL field set to 255 and Vtime\n   set accordingly\
    \ to the value of HNA_HOLD_TIME, as specified in\n   section 18.3.\n     Network\
    \ Address\n          The network address of the associated network\n     Netmask\n\
    \          The netmask, corresponding to the network address immediately\n   \
    \       above.\n"
- title: 12.2.  Host and Network Association Information Base
  contents:
  - "12.2.  Host and Network Association Information Base\n   Each node maintains\
    \ information concerning which nodes may act as\n   \"gateways\" to associated\
    \ hosts and networks by recording \"association\n   tuples\" (A_gateway_addr,\
    \ A_network_addr, A_netmask, A_time), where\n   A_gateway_addr is the address\
    \ of an OLSR interface of the gateway,\n   A_network_addr and A_netmask specify\
    \ the network address and netmask\n   of a network, reachable through this gateway,\
    \ and A_time specifies\n   the time at which this tuple expires and hence *MUST*\
    \ be removed.\n   The set of all association tuples in a node is called the\n\
    \   \"association set\".\n   It should be noticed, that the HNA-message can be\
    \ considered as a\n   \"generalized version\" of the TC-message: the originator\
    \ of both the\n   HNA- and TC-messages announce \"reachability\" to some other\
    \ host(s).\n   In the TC-message, no netmask is required, since all reachability\
    \ is\n   announced on a per-host basis.  In HNA-messages, announcing\n   reachability\
    \ to an address sequence through a network- and netmask\n   address is typically\
    \ preferred over announcing reachability to\n   individual host addresses.\n \
    \  An important difference between TC- and HNA-messages is, that a TC\n   message\
    \ may have a canceling effect on previous information (if the\n   ANSN is incremented),\
    \ whereas information in HNA-messages is removed\n   only upon expiration.\n"
- title: 12.3.  HNA Message Generation
  contents:
  - "12.3.  HNA Message Generation\n   A node with associated hosts and/or networks\
    \ SHOULD periodically\n   generate a Host and Network Association (HNA) message,\
    \ containing\n   pairs of (network address, netmask) corresponding to the connected\n\
    \   hosts and networks.  HNA-messages SHOULD be transmitted periodically\n   every\
    \ HNA_INTERVAL.  The Vtime is set accordingly to the value of\n   HNA_HOLD_TIME,\
    \ as specified in section 18.3.\n   A node without any associated hosts and/or\
    \ networks SHOULD NOT\n   generate HNA-messages.\n"
- title: 12.4.  HNA Message Forwarding
  contents:
  - "12.4.  HNA Message Forwarding\n   Upon receiving a HNA message, and thus following\
    \ the rules of section\n   3, in this version of the specification, the message\
    \ MUST be\n   forwarded according to section 3.4.\n"
- title: 12.5.  HNA Message Processing
  contents:
  - "12.5.  HNA Message Processing\n   In this section, the term \"originator address\"\
    \ is used to designate\n   the main address on the OLSR MANET of the node which\
    \ originally\n   issued the HNA-message.\n   Upon processing a HNA-message, the\
    \ \"validity time\" MUST be computed\n   from the Vtime field of the message header\
    \ (see section 3.3.2).  The\n   association base SHOULD then be updated as follows:\n\
    \   1    If the sender interface (NB: not originator) of this message\n      \
    \  is not in the symmetric 1-hop neighborhood of this node, the\n        message\
    \ MUST be discarded.\n   2    Otherwise, for each (network address, netmask) pair\
    \ in the\n        message:\n        2.1  if an entry in the association set already\
    \ exists, where:\n                  A_gateway_addr == originator address\n   \
    \               A_network_addr == network address\n                  A_netmask\
    \      == netmask\n             then the holding time for that tuple MUST be set\
    \ to:\n                  A_time         =  current time + validity time\n    \
    \    2.2  otherwise, a new tuple MUST be recorded with:\n                  A_gateway_addr\
    \ =  originator address\n                  A_network_addr =  network address\n\
    \                  A_netmask      =  netmask\n                  A_time       \
    \  =  current time + validity time\n"
- title: 12.6.  Routing Table Calculation
  contents:
  - "12.6.  Routing Table Calculation\n   In addition to the routing table computation\
    \ as described in section\n   10, the host and network association set MUST be\
    \ added as follows:\n   For each tuple in the association set,\n     1    If there\
    \ is no entry in the routing table with:\n               R_dest_addr     == A_network_addr/A_netmask\n\
    \          then a new routing entry is created.\n     2    If a new routing entry\
    \ was created at the previous step, or\n          else if there existed one with:\n\
    \               R_dest_addr     == A_network_addr/A_netmask\n               R_dist\
    \          >  dist to A_gateway_addr of\n                                  current\
    \ association set tuple,\n          then the routing entry is modified as follows:\n\
    \               R_dest_addr     =  A_network_addr/A_netmask\n               R_next_addr\
    \     =  the next hop on the path\n                                  from the\
    \ node to A_gateway_addr\n               R_dist          =  dist to A_gateway_addr\n\
    \               R_next_addr and R_iface_addr MUST be set to the same\n       \
    \        values as the tuple from the routing set with R_dest_addr\n         \
    \      == A_gateway_addr.\n"
- title: 12.7.  Interoperability Considerations
  contents:
  - "12.7.  Interoperability Considerations\n   Nodes, which do not implement support\
    \ for non OLSR interfaces, can\n   coexist in a network with nodes which do implement\
    \ support for non\n   OLSR interfaces: the generic packet format and message forwarding\n\
    \   (section 3) ensures that HNA messages are correctly forwarded by all\n   nodes.\
    \  Nodes which implement support for non OLSR interfaces may\n   thus transmit\
    \ and process HNA messages according to this section.\n   Nodes, which do not\
    \ implement support for non OLSR interfaces can not\n   take advantage of the\
    \ functionality specified in this section,\n   however they will forward HNA messages\
    \ correctly, as specified in\n   section 3.\n"
- title: 13.  Link Layer Notification
  contents:
  - "13.  Link Layer Notification\n   OLSR is designed not to impose or expect any\
    \ specific information\n   from the link layer.  However, if information from\
    \ the link-layer\n   describing link breakage is available, a node MAY use this\
    \ as\n   described in this section.\n   If link layer information describing connectivity\
    \ to neighboring\n   nodes is available (i.e., loss of connectivity such as through\n\
    \   absence of a link layer acknowledgment), this information is used in\n   addition\
    \ to the information from the HELLO-messages to maintain the\n   neighbor information\
    \ base and the MPR selector set.\n   Thus, upon receiving a link-layer notification\
    \ that the link between\n   a node and a neighbor interface is broken, the following\
    \ actions are\n   taken with respect to link sensing:\n   Each link tuple in the\
    \ local link set SHOULD, in addition to what is\n   described in section 4.2,\
    \ include a L_LOST_LINK_time field.\n   L_LOST_LINK_time is a timer for declaring\
    \ a link as lost when an\n   established link becomes pending.  (Notice, that\
    \ this is a subset of\n   what is recommended in section 14, thus link hysteresis\
    \ and link\n   layer notifications can coexist).\n   HELLO message generation\
    \ should consider those new fields as follows:\n     1    if L_LOST_LINK_time\
    \ is not expired, the link is advertised\n          with a link type of LOST_LINK.\
    \  In addition, it is not\n          considered as a symmetric link in the updates\
    \ of the\n          associated neighbor tuple (see section 8.1).\n     2    if\
    \ the link to a neighboring symmetric or asymmetric interface\n          is broken,\
    \ the corresponding link tuple is modified:\n          L_LOST_LINK_time and L_time\
    \ are set to current time +\n          NEIGHB_HOLD_TIME.\n     3    this is considered\
    \ as a link loss and the appropriate\n          processing described in section\
    \ 8.5 should be\n          performed.\n"
- title: 13.1.  Interoperability Considerations
  contents:
  - "13.1.  Interoperability Considerations\n   Link layer notifications provide,\
    \ for a node, an additional criterion\n   by which a node may determine if a link\
    \ to a neighbor node is lost.\n   Once a link is detected as lost, it is advertised,\
    \ in accordance with\n   the provisions described in the previous sections of\
    \ this\n   specification.\n"
- title: 14.  Link Hysteresis
  contents:
  - "14.  Link Hysteresis\n   Established links should be as reliable as possible\
    \ to avoid data\n   packet loss.  This implies that link sensing should be robust\
    \ against\n   bursty loss or transient connectivity between nodes.  Hence, to\n\
    \   enhance the robustness of the link sensing mechanism, the following\n   implementation\
    \ recommendations SHOULD be considered.\n"
- title: 14.1.  Local Link Set
  contents:
  - "14.1.  Local Link Set\n   Each link tuple in the local link set SHOULD, in addition\
    \ to what is\n   described in section 4.2, include a L_link_pending field, a\n\
    \   L_link_quality field, and a L_LOST_LINK_time field.  L_link_pending\n   is\
    \ a boolean value specifying if the link is considered pending\n   (i.e., the\
    \ link is not considered established).  L_link_quality is a\n   dimensionless\
    \ number between 0 and 1 describing the quality of the\n   link.  L_LOST_LINK_time\
    \ is a timer for declaring a link as lost when\n   an established link becomes\
    \ pending.\n"
- title: 14.2.  Hello Message Generation
  contents:
  - "14.2.  Hello Message Generation\n   HELLO message generation should consider\
    \ those new fields as follows:\n     1    if L_LOST_LINK_time is not expired,\
    \ the link is advertised\n          with a link type of LOST_LINK.\n     2   \
    \ otherwise, if L_LOST_LINK_time is expired and L_link_pending\n          is set\
    \ to \"true\", the link SHOULD NOT be advertised at all;\n     3    otherwise,\
    \ if L_LOST_LINK_time is expired and L_link_pending\n          is set to \"false\"\
    , the link is advertised as described\n          previously in section 6.\n  \
    \ A node considers that it has a symmetric link for each link tuple\n   where:\n\
    \     1    L_LOST_LINK_time is expired, AND\n     2    L_link_pending is \"false\"\
    , AND\n     3    L_SYM_time is not expired.\n   This definition for \"symmetric\
    \ link\" SHOULD be used in updating the\n   associated neighbor tuple (see section\
    \ 8.1) for computing the\n   N_status of a neighbor node.  This definition SHOULD\
    \ thereby also be\n   used as basis for the symmetric neighborhood when computing\
    \ the MPR\n   set, as well as for \"the symmetric neighbors\" in the first steps\
    \ of\n   the routing table calculation.\n   Apart from the above, what has been\
    \ described previously does not\n   interfere with the advanced link sensing fields\
    \ in the link tuples.\n   The L_link_quality, L_link_pending and L_LOST_LINK_time\
    \ fields are\n   exclusively updated according to the present section.  This section\n\
    \   does not modify the function of any other fields in the link tuples.\n"
- title: 14.3.  Hysteresis Strategy
  contents:
  - "14.3.  Hysteresis Strategy\n   The link between a node and some of its neighbor\
    \ interfaces might be\n   \"bad\", i.e., from time to time let HELLOs pass through\
    \ only to fade\n   out immediately after.  In this case, the neighbor information\
    \ base\n   would contain a bad link for at least \"validity time\".  The following\n\
    \   hysteresis strategy SHOULD be adopted to counter this situation.\n   For each\
    \ neighbor interface NI heard by interface I, the\n   L_link_quality field of\
    \ the corresponding Link Tuple determines the\n   establishment of the link. \
    \ The value of L_link_quality is compared\n   to two thresholds HYST_THRESHOLD_HIGH,\
    \ HYST_THRESHOLD_LOW, fixed\n   between 0 and 1 and such that HYST_THRESHOLD_HIGH\
    \ >=\n   HYST_THRESHOLD_LOW.\n   The L_link_pending field is set according to\
    \ the following:\n     1    if L_link_quality > HYST_THRESHOLD_HIGH:\n       \
    \        L_link_pending   = false\n               L_LOST_LINK_time = current time\
    \ - 1 (expired)\n     2    otherwise, if L_link_quality < HYST_THRESHOLD_LOW:\n\
    \               L_link_pending   = true\n               L_LOST_LINK_time = min\
    \ (L_time, current time +\n               NEIGHB_HOLD_TIME)\n               (the\
    \ link is then considered as lost according to section\n               8.5 and\
    \ this may produce a neighbor loss).\n     3    otherwise, if HYST_THRESHOLD_LOW\
    \ <= L_link_quality\n                                           <= HYST_THRESHOLD_HIGH:\n\
    \               L_link_pending and L_LOST_LINK_time remain unchanged.\n   The\
    \ condition for considering a link established is thus stricter\n   than the condition\
    \ for dropping a link.  Notice thus, that a link can\n   be dropped based on either\
    \ timer expiration (as described in section\n   7) or on L_link_quality dropping\
    \ below HYST_THRESHOLD_LOW.\n   Also notice, that even if a link is not considered\
    \ as established by\n   the link hysteresis, the link tuples are still updated\
    \ for each\n   received HELLO message (as described in section 7).  Specifically,\n\
    \   this implies that, regardless of whether or not the link hysteresis\n   considers\
    \ a link as \"established\", tuples in the link set do not\n   expire except as\
    \ determined by the L_time field of the link tuples.\n   As a basic implementation\
    \ requirement, an estimation of the link\n   quality must be maintained and stored\
    \ in the L_link_quality field.\n   If some measure of the signal/noise level on\
    \ a received message is\n   available (e.g., as a link layer notification), then\
    \ it can be used\n   as estimation after normalization.\n   If no signal/noise\
    \ information or other link quality information is\n   available from the link\
    \ layer, an algorithm such as the following can\n   be utilized (it is an exponentially\
    \ smoothed moving average of the\n   transmission success rate).  The algorithm\
    \ is parameterized by a\n   scaling parameter HYST_SCALING which is a number fixed\
    \ between 0 and\n   1.  For each neighbor interface NI heard by interface I, the\
    \ first\n   time NI is heard by I, L_link_quality is set to HYST_SCALING\n   (L_link_pending\
    \ is set to true and L_LOST_LINK_time to current time -\n   1).\n   A tuple is\
    \ updated according to two rules.  Every time an OLSR packet\n   emitted by NI\
    \ is received by I, the stability rule is applied:\n          L_link_quality =\
    \ (1-HYST_SCALING)*L_link_quality\n                           + HYST_SCALING.\n\
    \     When an OLSR packet emitted by NI is lost by I, the instability\n     rule\
    \ is applied:\n          L_link_quality = (1-HYST_SCALING)*L_link_quality.\n \
    \  The loss of OLSR packet is detected by tracking the missing Packet\n   Sequence\
    \ Numbers on a per interface basis and by \"long period of\n   silence\" from\
    \ a node.  A \"long period of silence may be detected\n   thus: if no OLSR packet\
    \ has been received on interface I from\n   interface NI during HELLO emission\
    \ interval of interface NI (computed\n   from the Htime field in the last HELLO\
    \ message received from NI), a\n   loss of an OLSR packet is detected.\n"
- title: 14.4.  Interoperability Considerations
  contents:
  - "14.4.  Interoperability Considerations\n   Link hysteresis determines, for a\
    \ node, the criteria at which a link\n   to a neighbor node is accepted or rejected.\
    \  Nodes in a network may\n   have different criteria, according to the nature\
    \ of the media over\n   which they are communicating.  Once a link is accepted,\
    \ it is\n   advertised, in accordance with the provisions described in the\n \
    \  previous sections of this specification.\n"
- title: 15.  Redundant Topology Information
  contents:
  - "15.  Redundant Topology Information\n   In order to provide redundancy to topology\
    \ information base, the\n   advertised link set of a node MAY contain links to\
    \ neighbor nodes\n   which are not in MPR selector set of the node.  The advertised\
    \ link\n   set MAY contain links to the whole neighbor set of the node.  The\n\
    \   minimal set of links that any node MUST advertise in its TC messages\n   is\
    \ the links to its MPR selectors.  The advertised link set can be\n   built according\
    \ to the following rule based on a local parameter\n   called TC_REDUNDANCY parameter.\n"
- title: 15.1.  TC_REDUNDANCY Parameter
  contents:
  - "15.1.  TC_REDUNDANCY Parameter\n   The parameter TC_REDUNDANCY specifies, for\
    \ the local node, the amount\n   of information that MAY be included in the TC\
    \ messages.  The\n   parameter SHOULD be interpreted as follows:\n     -    if\
    \ the TC_REDUNDANCY parameter of the node is 0, then the\n          advertised\
    \ link set of the node is limited  to the MPR\n          selector set (as described\
    \ in section 8.3),\n     -    if the TC_REDUNDANCY parameter of the node is 1,\
    \ then the\n          advertised link set of the node is the union of its MPR\
    \ set\n          and its MPR selector set,\n     -    if the TC_REDUNDANCY parameter\
    \ of the node is 2, then the\n          advertised link set of the node is the\
    \ full neighbor link set.\n   A node with willingness equal to WILL_NEVER SHOULD\
    \ have TC_REDUNDANCY\n   also equal to zero.\n"
- title: 15.2.  Interoperability Considerations
  contents:
  - "15.2.  Interoperability Considerations\n   A TC message is sent by a node in\
    \ the network to declare a set of\n   links, called advertised link set, which\
    \ MUST include at least the\n   links to all nodes of its MPR Selector set, i.e.,\
    \ the neighbors which\n   have selected the sender node as a MPR.  This is sufficient\n\
    \   information to ensure that routes can be computed in accordance with\n   section\
    \ 10.\n   The provisions in this section specifies how additional information\n\
    \   may be declared, as specified through a TC_REDUNDANCY parameter.\n   TC_REDUNDANCY\
    \ = 0 implies that the information declared corresponds\n   exactly to the MPR\
    \ Selector set, identical to section 9.  Other\n   values of TC_REDUNDANCY specifies\
    \ additional information to be\n   declared, i.e., the contents of the MPR Selector\
    \ set is always\n   declared.  Thus, nodes with different values of TC_REDUNDANCY\
    \ may\n   coexist in a network: control messages are carried by all nodes in\n\
    \   accordance with section 3, and all nodes will receive at least the\n   link-state\
    \ information required to construct routes as described in\n   section 10.\n"
- title: 16.  MPR Redundancy
  contents:
  - "16.  MPR Redundancy\n   MPR redundancy specifies the ability for a node to select\
    \ redundant\n   MPRs.  Section 4.5 specifies that a node should select its MPR\
    \ set to\n   be as small as possible, in order to reduce protocol overhead.  The\n\
    \   criteria for selecting MPRs is, that all strict 2-hop nodes must be\n   reachable\
    \ through, at least, one MPR node.  Redundancy of the MPR set\n   affects the\
    \ overhead through affecting the amount of links being\n   advertised, the amount\
    \ of nodes advertising links and the efficiency\n   of the MPR flooding mechanism.\
    \  On the other hand, redundancy in the\n   MPR set ensures that reachability\
    \ for a node is advertised by more\n   nodes, thus additional links are diffused\
    \ to the network.\n   While, in general, a minimal MPR set provides the least\
    \ overhead,\n   there are situations in which overhead can be traded off for other\n\
    \   benefits.  For example, a node may decide to increase its MPR\n   coverage\
    \ if it observes many changes in its neighbor information base\n   caused by mobility,\
    \ while otherwise keeping a low MPR coverage.\n"
- title: 16.1.  MPR_COVERAGE Parameter
  contents:
  - "16.1.  MPR_COVERAGE Parameter\n   The MPR coverage is defined by a single local\
    \ parameter,\n   MPR_COVERAGE, specifying by how many MPR nodes any strict 2-hop\
    \ node\n   should be covered.  MPR_COVERAGE=1 specifies that the overhead of the\n\
    \   protocol is kept at a minimum and causes the MPR selection to operate\n  \
    \ as described in section 8.3.1.  MPR_COVERAGE=m ensures that, if\n   possible,\
    \ a node selects its MPR set such that all strict 2-hop nodes\n   for an interface\
    \ are reachable through at least m MPR nodes on that\n   interface.  MPR_COVERAGE\
    \ can assume any integer value > 0.  The\n   heuristic MUST be applied per interface,\
    \ I.  The MPR set for a node\n   is the union of the MPR sets found for each interface.\n\
    \   Notice that MPR_COVERAGE can be tuned locally without affecting the\n   consistency\
    \ of the protocol.  For example, nodes in a network may\n   operate with different\
    \ values of MPR_COVERAGE.\n"
- title: 16.2.  MPR Computation
  contents:
  - "16.2.  MPR Computation\n   Using MPR coverage, the MPR selection heuristics is\
    \ extended from\n   that described in the section 8.3.1 by one definition:\n \
    \    Poorly covered node:\n          A poorly covered node is a node in N2 which\
    \ is covered by less\n          than MPR_COVERAGE nodes in N.\n   The proposed\
    \ heuristic for selecting MPRs is then as follows:\n     1    Start with an MPR\
    \ set made of all members of N with\n          willingness equal to WILL_ALWAYS\n\
    \     2    Calculate D(y), where y is a member of N, for all nodes in N.\n   \
    \  3    Select as MPRs those nodes in N which cover the poorly covered\n     \
    \     nodes in N2.  The nodes are then removed from N2 for the rest\n        \
    \  of the computation.\n     4    While there exist nodes in N2 which are not\
    \ covered by at\n          least MPR_COVERAGE nodes in the MPR set:\n        \
    \  4.1  For each node in N, calculate the reachability, i.e.,\n              \
    \ the number of nodes in N2 which are not yet covered\n               by at least\
    \ MPR_COVERAGE nodes in the MPR set, and\n               which are reachable through\
    \ this 1-hop neighbor;\n          4.2  Select as a MPR the node with highest willingness\
    \ among\n               the nodes in N with non-zero reachability.  In case of\n\
    \               multiple choice select the node which provides\n             \
    \  reachability to the maximum number of nodes in N2.  In\n               case\
    \ of multiple nodes providing the same amount of\n               reachability,\
    \ select the node as MPR whose D(y) is\n               greater.  Remove the nodes\
    \ from N2 which are now covered\n               by MPR_COVERAGE nodes in the MPR\
    \ set.\n     5    A node's MPR set is generated from the union of the MPR sets\n\
    \          for each interface.  As an optimization, process each node, y,\n  \
    \        in the MPR set in increasing order of N_willingness.  If all\n      \
    \    nodes in N2 are still covered by at least MPR_COVERAGE nodes\n          in\
    \ the MPR set excluding node y, and if N_willingness of node\n          y is smaller\
    \ than WILL_ALWAYS, then node y MAY be removed from\n          the MPR set.\n\
    \   When the MPR set has been computed, all the corresponding main\n   addresses\
    \ are stored in the MPR Set.\n"
- title: 16.3.  Interoperability Considerations
  contents:
  - "16.3.  Interoperability Considerations\n   The MPR set of a node MUST, according\
    \ to section 8.3, be calculated\n   by a node in such a way that it, through the\
    \ neighbors in the MPR-\n   set, can reach all symmetric strict 2-hop neighbors.\
    \  This is\n   achieved by the heuristics in this section, for all values of\n\
    \   MPR_COVERAGE > 0.  MPR_COVERAGE is a local parameter for each node.\n   Setting\
    \ this parameter affects only the amount of redundancy in part\n   of the network.\n\
    \   Notice that for MPR_COVERAGE=1, the heuristics in this section is\n   identical\
    \ to the heuristics specified in the section 8.3.1.\n   Nodes with different values\
    \ of MPR_COVERAGE may coexist in a network:\n   control messages are carried by\
    \ all nodes in accordance with section\n   3, and all nodes will receive at least\
    \ the link-state information\n   required to construct routes as described in\
    \ sections 9 and 10.\n"
- title: 17.  IPv6 Considerations
  contents:
  - "17.  IPv6 Considerations\n   All the operations and parameters described in this\
    \ document used by\n   OLSR for IP version 4 are the same as those used by OLSR\
    \ for IP\n   version 6.  To operate with IP version 6, the only required change\
    \ is\n   to replace the IPv4 addresses with IPv6 address.  The minimum packet\n\
    \   and message sizes (under which there is rejection) should be adjusted\n  \
    \ accordingly, considering the greater size of IPv6 addresses.\n"
- title: 18.  Proposed Values for Constants
  contents:
  - "18.  Proposed Values for Constants\n   This section list the values for the constants\
    \ used in the\n   description of the protocol.\n"
- title: 18.1.  Setting emission intervals and holding times
  contents:
  - "18.1.  Setting emission intervals and holding times\n   The proposed constant\
    \ for C is the following:\n          C = 1/16 seconds (equal to 0.0625 seconds)\n\
    \   C is a scaling factor for the \"validity time\" calculation (\"Vtime\"\n \
    \  and \"Htime\" fields in message headers, see section 18.3).  The\n   \"validity\
    \ time\" advertisement is designed such that nodes in a\n   network may have different\
    \ and individually tuneable emission\n   intervals, while still interoperate fully.\
    \  For protocol functioning\n   and interoperability to work:\n     -    the advertised\
    \ holding time MUST always be greater than the\n          refresh interval of\
    \ the advertised information.  Moreover, it\n          is recommended that the\
    \ relation between the interval (from\n          section 18.2), and the hold time\
    \ is kept as specified\n          in section 18.3, to allow for reasonable packet\
    \ loss.\n     -    the constant C SHOULD be set to the suggested value.  In order\n\
    \          to achieve interoperability, C MUST be the same on all nodes.\n   \
    \  -    the emission intervals (section 18.2), along with the\n          advertised\
    \ holding times (subject to the above constraints)\n          MAY be selected\
    \ on a per node basis.\n   Note that the timer resolution of a given implementation\
    \ might not be\n   sufficient to wake up the system on precise refresh times or\
    \ on\n   precise expire times: the implementation SHOULD round up the\n   'validity\
    \ time' (\"Vtime\" and \"Htime\" of packets) to compensate for\n   coarser timer\
    \ resolution, at least in the case where \"validity time\"\n   could be shorter\
    \ than the sum of emission interval and maximum\n   expected timer error.\n"
- title: 18.2.  Emission Intervals
  contents:
  - "18.2.  Emission Intervals\n          HELLO_INTERVAL        = 2 seconds\n    \
    \      REFRESH_INTERVAL      = 2 seconds\n          TC_INTERVAL           = 5\
    \ seconds\n          MID_INTERVAL          = TC_INTERVAL\n          HNA_INTERVAL\
    \          = TC_INTERVAL\n"
- title: 18.3.  Holding Time
  contents:
  - "18.3.  Holding Time\n          NEIGHB_HOLD_TIME      = 3 x REFRESH_INTERVAL\n\
    \          TOP_HOLD_TIME         = 3 x TC_INTERVAL\n          DUP_HOLD_TIME  \
    \       = 30 seconds\n          MID_HOLD_TIME         = 3 x MID_INTERVAL\n   \
    \       HNA_HOLD_TIME         = 3 x HNA_INTERVAL\n   The Vtime in the message\
    \ header (see section 3.3.2), and the Htime in\n   the HELLO message (see section\
    \ 6.1) are the fields which hold\n   information about the above values in mantissa\
    \ and exponent format\n   (rounded up).  In other words:\n     value = C*(1+a/16)*2^b\
    \ [in seconds]\n   where a is the integer represented by the four highest bits\
    \ of the\n   field and b the integer represented by the four lowest bits of the\n\
    \   field.\n   Notice, that for the previous proposed value of C, (1/16 seconds),\n\
    \   the values, in seconds, expressed by the formula above can be stored,\n  \
    \ without loss of precision, in binary fixed point or floating point\n   numbers\
    \ with at least 8 bits of fractional part.  This corresponds\n   with NTP time-stamps\
    \ and single precision IEEE Standard 754 floating\n   point numbers.\n   Given\
    \ one of the above holding times, a way of computing the\n   mantissa/exponent\
    \ representation of a number T (of seconds) is the\n   following:\n     -    find\
    \ the largest integer 'b' such that: T/C >= 2^b\n     -    compute the expression\
    \ 16*(T/(C*(2^b))-1), which may not be a\n          integer, and round it up.\
    \  This results in the value for 'a'\n     -    if 'a' is equal to 16: increment\
    \ 'b' by one, and set 'a' to 0\n     -    now, 'a' and 'b' should be integers\
    \ between 0 and 15, and the\n          field will be a byte holding the value\
    \ a*16+b\n   For instance, for values of 2 seconds, 6 seconds, 15 seconds, and\
    \ 30\n   seconds respectively, a and b would be: (a=0,b=5), (a=8,b=6),\n   (a=14,b=7)\
    \ and (a=14,b=8) respectively.\n"
- title: 18.4.  Message Types
  contents:
  - "18.4.  Message Types\n          HELLO_MESSAGE         = 1\n          TC_MESSAGE\
    \            = 2\n          MID_MESSAGE           = 3\n          HNA_MESSAGE \
    \          = 4\n"
- title: 18.5.  Link Types
  contents:
  - "18.5.  Link Types\n          UNSPEC_LINK           = 0\n          ASYM_LINK \
    \            = 1\n          SYM_LINK              = 2\n          LOST_LINK   \
    \          = 3\n"
- title: 18.6.  Neighbor Types
  contents:
  - "18.6.  Neighbor Types\n          NOT_NEIGH             = 0\n          SYM_NEIGH\
    \             = 1\n          MPR_NEIGH             = 2\n"
- title: 18.7.  Link Hysteresis
  contents:
  - "18.7.  Link Hysteresis\n          HYST_THRESHOLD_HIGH   = 0.8\n          HYST_THRESHOLD_LOW\
    \    = 0.3\n          HYST_SCALING          = 0.5\n"
- title: 18.8.  Willingness
  contents:
  - "18.8.  Willingness\n          WILL_NEVER            = 0\n          WILL_LOW \
    \             = 1\n          WILL_DEFAULT          = 3\n          WILL_HIGH  \
    \           = 6\n          WILL_ALWAYS           = 7\n   The willingness of a\
    \ node may be set to any integer value from 0 to\n   7, and specifies how willing\
    \ a node is to be forwarding traffic on\n   behalf of other nodes.  Nodes will,\
    \ by default, have a willingness\n   WILL_DEFAULT.  WILL_NEVER indicates a node\
    \ which does not wish to\n   carry traffic for other nodes, for example due to\
    \ resource\n   constraints (like being low on battery).  WILL_ALWAYS indicates\
    \ that\n   a node always should be selected to carry traffic on behalf of other\n\
    \   nodes, for example due to resource abundance (like permanent power\n   supply,\
    \ high capacity interfaces to other nodes).\n   A node may dynamically change\
    \ its willingness as its conditions\n   change.\n   One possible application would,\
    \ for example, be for a node, connected\n   to a permanent power supply and with\
    \ fully charged batteries, to\n   advertise a willingness of WILL_ALWAYS.  Upon\
    \ being disconnected from\n   the permanent power supply (e.g., a PDA being taken\
    \ out of its\n   charging cradle), a willingness of WILL_DEFAULT is advertised.\
    \  As\n   battery capacity is drained, the willingness would be further\n   reduced.\
    \  First to the intermediate value between WILL_DEFAULT and\n   WILL_LOW, then\
    \ to WILL_LOW and finally to WILL_NEVER, when the\n   battery capacity of the\
    \ node does no longer support carrying foreign\n   traffic.\n"
- title: 18.9.  Misc. Constants
  contents:
  - "18.9.  Misc. Constants\n          TC_REDUNDANCY         = 0\n          MPR COVERAGE\
    \          = 1\n          MAXJITTER             = HELLO_INTERVAL / 4\n"
- title: 19.  Sequence Numbers
  contents:
  - "19.  Sequence Numbers\n   Sequence numbers are used in OLSR with the purpose\
    \ of discarding\n   \"old\" information, i.e., messages received out of order.\
    \  However\n   with a limited number of bits for representing sequence numbers,\n\
    \   wrap-around (that the sequence number is incremented from the maximum\n  \
    \ possible value to zero) will occur.  To prevent this from interfering\n   with\
    \ the operation of the protocol, the following MUST be observed.\n   The term\
    \ MAXVALUE designates in the following the largest possible\n   value for a sequence\
    \ number.\n   The sequence number S1 is said to be \"greater than\" the sequence\n\
    \   number S2 if:\n          S1 > S2 AND S1 - S2 <= MAXVALUE/2 OR\n          S2\
    \ > S1 AND S2 - S1 > MAXVALUE/2\n   Thus when comparing two messages, it is possible\
    \ - even in the\n   presence of wrap-around - to determine which message contains\
    \ the\n   most recent information.\n"
- title: 20.  Security Considerations
  contents:
  - "20.  Security Considerations\n   Currently, OLSR does not specify any special\
    \ security measures.  As a\n   proactive routing protocol, OLSR makes a target\
    \ for various attacks.\n   The various possible vulnerabilities are discussed\
    \ in this section.\n"
- title: 20.1.  Confidentiality
  contents:
  - "20.1.  Confidentiality\n   Being a proactive protocol, OLSR periodically diffuses\
    \ topological\n   information.  Hence, if used in an unprotected wireless network,\
    \ the\n   network topology is revealed to anyone who listens to OLSR control\n\
    \   messages.\n   In situations where the confidentiality of the network topology\
    \ is of\n   importance, regular cryptographic techniques such as exchange of OLSR\n\
    \   control traffic messages encrypted by PGP [9] or encrypted by some\n   shared\
    \ secret key can be applied to ensure that control traffic can\n   be read and\
    \ interpreted by only those authorized to do so.\n"
- title: 20.2.  Integrity
  contents:
  - "20.2.  Integrity\n   In OLSR, each node is injecting topological information\
    \ into the\n   network through transmitting HELLO messages and, for some nodes,\
    \ TC\n   messages.  If some nodes for some reason, malicious or malfunction,\n\
    \   inject invalid control traffic, network integrity may be compromised.\n  \
    \ Therefore, message authentication is recommended.\n   Different such situations\
    \ may occur, for instance:\n     1    a node generates TC (or HNA) messages, advertising\
    \ links to\n          non-neighbor nodes:\n     2    a node generates TC (or HNA)\
    \ messages, pretending to be\n          another node,\n     3    a node generates\
    \ HELLO messages, advertising non-neighbor\n          nodes,\n     4    a node\
    \ generates HELLO messages, pretending to be another\n          node.\n     5\
    \    a node forwards altered control messages,\n     6    a node does not broadcast\
    \ control messages,\n     7    a node does not select multipoint relays correctly.\n\
    \     8    a node forwards broadcast control messages unaltered, but does\n  \
    \        not forward unicast data traffic;\n     9    a node \"replays\" previously\
    \ recorded control traffic from\n          another node.\n   Authentication of\
    \ the originator node for control messages (for\n   situation 2, 4 and 5) and\
    \ on the individual links announced in the\n   control messages (for situation\
    \ 1 and 3) may be used as a\n   countermeasure.  However to prevent nodes from\
    \ repeating old (and\n   correctly authenticated) information (situation 9) temporal\n\
    \   information is required, allowing a node to positively identify such\n   delayed\
    \ messages.\n   In general, digital signatures and other required security\n \
    \  information may be transmitted as a separate OLSR message type,\n   thereby\
    \ allowing that \"secured\" and \"unsecured\" nodes can coexist in\n   the same\
    \ network, if desired.\n   Specifically, the authenticity of entire OLSR control\
    \ messages can be\n   established through employing IPsec authentication headers,\
    \ whereas\n   authenticity of individual links (situation 1 and 3) require\n \
    \  additional security information to be distributed.\n   An important consideration\
    \ is, that all control messages in OLSR are\n   transmitted either to all nodes\
    \ in the neighborhood (HELLO messages)\n   or broadcast to all nodes in the network\
    \ (e.g., TC messages).\n   For example, a control message in OLSR is always a\
    \ point-to-\n   multipoint transmission.  It is therefore important that the\n\
    \   authentication mechanism employed permits that any receiving node can\n  \
    \ validate the authenticity of a message.  As an analogy, given a block\n   of\
    \ text, signed by a PGP private key, then anyone with the\n   corresponding public\
    \ key can verify the authenticity of the text.\n"
- title: 20.3.  Interaction with External Routing Domains
  contents:
  - "20.3.  Interaction with External Routing Domains\n   OLSR does, through the HNA\
    \ messages specified in section 12, provide\n   a basic mechanism for injecting\
    \ external routing information to the\n   OLSR domain.  Section 12 also specifies\
    \ that routing information can\n   be extracted from the topology table or the\
    \ routing table of OLSR\n   and, potentially, injected into an external domain\
    \ if the routing\n   protocol governing that domain permits.\n   Other than as\
    \ described in the section 20.2, when operating nodes,\n   connecting OLSR to\
    \ an external routing domain, care MUST be taken not\n   to allow potentially\
    \ insecure and un-trustworthy information to be\n   injected from the OLSR domain\
    \ to external routing domains.  Care MUST\n   be taken to validate the correctness\
    \ of information prior to it being\n   injected as to avoid polluting routing\
    \ tables with invalid\n   information.\n   A recommended way of extending connectivity\
    \ from an existing routing\n   domain to an OLSR routed MANET is to assign an\
    \ IP prefix (under the\n   authority of the nodes/gateways connecting the MANET\
    \ with the exiting\n   routing domain) exclusively to the OLSR MANET area, and\
    \ to configure\n   the gateways statically to advertise routes to that IP sequence\
    \ to\n   nodes in the existing routing domain.\n"
- title: 20.4.  Node Identity
  contents:
  - "20.4.  Node Identity\n   OLSR does not make any assumption about node addresses,\
    \ other than\n   that each node is assumed to have a unique IP address.\n"
- title: 21.  Flow and congestion control
  contents:
  - "21.  Flow and congestion control\n   Due to its proactive nature, the OLSR protocol\
    \ has a natural control\n   over the flow of its control traffic.  Nodes transmits\
    \ control\n   message at predetermined rates fixed by predefined refresh intervals.\n\
    \   Furthermore the MPR optimization greatly saves on control overhead,\n   and\
    \ this is done on two sides.  First, the packets that advertise the\n   topology\
    \ are much shorter since only MPR selectors may be advertised.\n   Second, the\
    \ cost of flooding this information is greatly reduced\n   since only MPR nodes\
    \ forward the broadcast packets.  In dense\n   networks, the reduction of control\
    \ traffic can be of several orders\n   of magnitude compared to routing protocols\
    \ using classical flooding\n   (such as OSPF) [10].  This feature naturally provides\
    \ more bandwidth\n   for useful data traffic and pushes further the frontier of\n\
    \   congestion.  Since the control traffic is continuous and periodic, it\n  \
    \ keeps more stable the quality of the links used in routing, where\n   reactive\
    \ protocols, with bursty floodings for route discoveries and\n   repairs, may\
    \ damage the link qualities for short times by causing\n   numerous collisions\
    \ on those links, possibly provoking route repair\n   cascades.  However, in certain\
    \ OLSR options, some control messages\n   may be intentionally sent in advance\
    \ of their deadline(TC or Hello\n   messages) in order to increase the reactiveness\
    \ of the protocol\n   against topology changes.  This may cause a small, temporary\
    \ and\n   local increase of control traffic.\n"
- title: 22.  IANA Considerations
  contents:
  - "22.  IANA Considerations\n   OLSR defines a \"Message Type\" field for control\
    \ messages.  A new\n   registry has been created for the values for this Message\
    \ Type field,\n   and the following values assigned:\n       Message Type    \
    \         Value\n      --------------------      -----\n       HELLO_MESSAGE \
    \             1\n       TC_MESSAGE                 2\n       MID_MESSAGE     \
    \           3\n       HNA_MESSAGE                4\n   Future values in the range\
    \ 5-127 of the Message Type can be allocated\n   using standards action [7].\n\
    \   Additionally, values in the range 128-255 are reserved for\n   private/local\
    \ use.\n"
- title: 23.  Acknowledgments
  contents:
  - "23.  Acknowledgments\n   The authors would like to thank Joseph Macker\n   <macker@itd.nrl.navy.mil>\
    \ and his team, including Justin Dean\n   <jdean@itd.nrl.navy.mil>, for their\
    \ valuable suggestions on the\n   advanced neighbor sensing mechanism and other\
    \ various aspects of the\n   protocol, including careful review of the protocol\
    \ specification.\n   The authors would also like to thank Christopher Dearlove\n\
    \   <chris.dearlove@baesystems.com> for valuable input on the MPR\n   selection\
    \ heuristics and for careful reviews of the protocol\n   specification.\n"
- title: 24.  Contributors
  contents:
  - "24.  Contributors\n   During the development of this specification, the following\
    \ list of\n   people contributed.  The contributors are listed alphabetically.\n\
    \   Cedric Adjih\n   Project HIPERCOM\n   INRIA Rocquencourt, BP 105\n   78153\
    \ Le Chesnay Cedex, France\n   Phone: +33 1 3963 5215\n   EMail: Cedric.Adjih@inria.fr\n\
    \   Thomas Heide Clausen\n   Project HIPERCOM\n   INRIA Rocquencourt, BP 105\n\
    \   78153 Le Chesnay Cedex, France\n   Phone: +33 1 3963 5133\n   EMail: T.Clausen@computer.org\n\
    \   Philippe Jacquet\n   Project HIPERCOM\n   INRIA Rocquencourt, BP 105\n   78153\
    \ Le Chesnay Cedex, France\n   Phone: +33 1 3963 5263\n   EMail: Philippe.Jacquet@inria.fr\n\
    \   Anis Laouiti\n   Project HIPERCOM\n   INRIA Rocquencourt, BP 105\n   78153\
    \ Le Chesnay Cedex, France\n   Phone: +33 1 3963 5088\n   EMail: Anis.Laouiti@inria.fr\n\
    \   Pascale Minet\n   Project HIPERCOM\n   INRIA Rocquencourt, BP 105\n   78153\
    \ Le Chesnay Cedex, France\n   Phone: +33 1 3963 5233\n   EMail: Pascale.Minet@inria.fr\n\
    \   Paul Muhlethaler\n   Project HIPERCOM\n   INRIA Rocquencourt, BP 105\n   78153\
    \ Le Chesnay Cedex, France\n   Phone: +33 1 3963 5278\n   EMail: Paul.Muhlethaler@inria.fr\n\
    \   Amir Qayyum\n   Center for Advanced Research in Engineering Pvt. Ltd.\n  \
    \ 19 Ataturk Avenue\n   Islamabad, Pakistan\n   Phone: +92-51-2874115\n   EMail:\
    \ amir@carepvtltd.com\n   Laurent Viennot\n   Project HIPERCOM\n   INRIA Rocquencourt,\
    \ BP 105\n   78153 Le Chesnay Cedex, France\n   Phone: +33 1 3963 5225\n   EMail:\
    \ Laurent.Viennot@inria.fr\n"
- title: 25.  References
  contents:
  - '25.  References

    '
- title: 25.1.  Normative References
  contents:
  - "25.1.  Normative References\n   [5]   Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [7]   T.  Clausen, P.  Jacquet, A.  Laouiti, P.  Muhlethaler, A.\n       \
    \  Qayyum and L.  Viennot.  Optimized Link State Routing Protocol.\n         IEEE\
    \ INMIC Pakistan 2001.\n"
- title: 25.2.  Informative References
  contents:
  - "25.2.  Informative References\n   [1]   P. Jacquet, P. Minet, P. Muhlethaler,\
    \ N. Rivierre.  Increasing\n         reliability in cable free radio LANs: Low\
    \ level forwarding in\n         HIPERLAN.  Wireless Personal Communications, 1996.\n\
    \   [2]   A.  Qayyum, L.  Viennot, A.  Laouiti.  Multipoint relaying: An\n   \
    \      efficient technique for flooding in mobile wireless networks.\n       \
    \  35th Annual Hawaii International Conference on System Sciences\n         (HICSS'2001).\n\
    \   [3]   ETSI STC-RES10 Committee.  Radio equipment and systems:\n         HIPERLAN\
    \ type 1, functional specifications ETS 300-652, ETSI,\n         June 1996.\n\
    \   [4]   P. Jacquet and L. Viennot, Overhead in Mobile Ad-hoc Network\n     \
    \    Protocols, INRIA research report RR-3965, 2000.\n   [6]   T. Clausen, G.\
    \ Hansen, L. Christensen and G. Behrmann.  The\n         Optimized Link State\
    \ Routing Protocol, Evaluation through\n         Experiments and Simulation. \
    \ IEEE Symposium on \"Wireless\n         Personal Mobile Communications\", September\
    \ 2001.\n   [8]   Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA\n\
    \         Considerations Section in RFCs\",  BCP 26, RFC 2434, October\n     \
    \    1998.\n   [9]   Atkins, D., Stallings, W. and P. Zimmermann, \"PGP Message\n\
    \         Exchange Formats\", RFC 1991, August 1996.\n   [10]  P. Jacquet, A.\
    \ Laouiti, P. Minet, L. Viennot.  Performance\n         analysis of OLSR multipoint\
    \ relay flooding in two ad hoc\n         wireless network models, INRIA research\
    \ report RR-4260, 2001.\n"
- title: 26.  Authors' Addresses
  contents:
  - "26.  Authors' Addresses\n   Thomas Heide Clausen\n   Project HIPERCOM\n   INRIA\
    \ Rocquencourt, BP 105\n   78153 Le Chesnay Cedex, France\n   Phone: +33 1 3963\
    \ 5133\n   EMail: T.Clausen@computer.org\n   Philippe Jacquet,\n   Project HIPERCOM,\n\
    \   INRIA Rocquencourt, BP 105\n   78153 Le Chesnay Cedex, France\n   Phone: +33\
    \ 1 3963 5263,\n   EMail: Philippe.Jacquet@inria.fr\n"
- title: 27.  Full Copyright Statement
  contents:
  - "27.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assignees.\n\
    \   This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
