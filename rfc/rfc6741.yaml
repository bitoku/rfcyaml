- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                          RJ Atkinson
  contents:
  - "Internet Research Task Force (IRTF)                          RJ Atkinson\n  \
    \             Identifier-Locator Network Protocol (ILNP)\n                   \
    \    Engineering Considerations\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes common (i.e., version independent)\n   engineering\
    \ details for the Identifier-Locator Network Protocol\n   (ILNP), which is an\
    \ experimental, evolutionary enhancement to IP.\n   This document is a product\
    \ of the IRTF Routing Research Group.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Research Task\n   Force (IRTF).\
    \  The IRTF publishes the results of Internet-related\n   research and development\
    \ activities.  These results might not be\n   suitable for deployment.  This RFC\
    \ represents the individual\n   opinion(s) of one or more members of the Routing\
    \ Research Group of\n   the Internet Research Task Force (IRTF).  Documents approved\
    \ for\n   publication by the IRSG are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6741.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n   This document\
    \ may not be modified, and derivative works of it may not\n   be created, except\
    \ to format it for publication as an RFC or to\n   translate it into languages\
    \ other than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Document Roadmap ...........................................4\n  \
    \    1.2. Terminology ................................................5\n   2.\
    \ ILNP Identifiers ................................................5\n      2.1.\
    \ Syntax .....................................................6\n      2.2. Default\
    \ Values for an Identifier ...........................6\n      2.3. Local-Scoped\
    \ Identifier Values .............................6\n      2.4. Multicast Identifiers\
    \ ......................................7\n      2.5. Administration of Identifier\
    \ Values ........................7\n   3. Encoding of Identifiers and Locators\
    \ for ILNPv6 .................7\n      3.1. Encoding of I and L Values .................................7\n\
    \      3.2. Network-Level Packet Formats ..............................10\n  \
    \    3.3. Encoding of Identifiers and Locators for ILNPv4 ...........11\n   4.\
    \ Transport-Layer Changes ........................................12\n      4.1.\
    \ End-System State ..........................................12\n      4.2. TCP/UDP\
    \ Checksum Handling .................................12\n      4.3. ICMP Checksum\
    \ Handling ....................................12\n   5. ILNP Communication Cache\
    \ (ILCC) ................................13\n      5.1. Formal Definition .........................................13\n\
    \      5.2. Ageing ILCC Entries .......................................15\n  \
    \    5.3. Large Numbers of Locators .................................15\n    \
    \  5.4. Lookups into the ILCC .....................................16\n   6. Handling\
    \ Location/Connectivity Changes .........................16\n      6.1. Node Location/Connectivity\
    \ Changes ........................16\n      6.2. Network Connectivity/Locator\
    \ Changes ......................17\n   7. Subnetting .....................................................17\n\
    \      7.1. Subnetting for ILNPv6 .....................................18\n  \
    \    7.2. Subnetting for ILNPv4 .....................................19\n    \
    \  7.3. Subnetting for Router-Router Links in IPv6/ILNPv6 .........19\n   8. DNS\
    \ Considerations .............................................19\n      8.1. Secure\
    \ Dynamic DNS Update .................................19\n      8.2. New DNS RR\
    \ Types ..........................................20\n      8.4. DNS TTL Values\
    \ for ILNP RRS Types .........................21\n      8.5. IP/ILNP Dual Operation\
    \ and Transition .....................21\n   9. IP Security for ILNP ...........................................22\n\
    \      9.1. IPsec Security Association Enhancements for ILNP ..........22\n  \
    \    9.2. IP Authentication Header Enhancements for ILNP ............23\n    \
    \  9.3. Key Management Considerations .............................23\n   10.\
    \ Backwards Compatibility and Incremental Deployment ............24\n      10.1.\
    \ Priorities in the Design of ILNPv6 and ILNPv4 ............24\n      10.2. Infrastructure\
    \ ...........................................25\n      10.3. Core Protocols ...........................................25\n\
    \      10.4. Scope of End-System Changes ..............................26\n  \
    \    10.5. Applications .............................................27\n    \
    \  10.6. Interworking between IP and ILNP .........................27\n   11.\
    \ Security Considerations .......................................28\n      11.1.\
    \ Authenticating ICMP Messages .............................29\n      11.2. Forged\
    \ Identifier Attacks ................................31\n   12. Privacy Considerations\
    \ ........................................31\n   13. Operational Considerations\
    \ ....................................31\n      13.1. Session Liveness and Reachability\
    \ ........................32\n      13.2. Key Management Considerations ............................33\n\
    \      13.3. Point-to-Point Router Links ..............................33\n  \
    \ 14. Referrals and Application Programming Interfaces ..............34\n    \
    \  14.1. BSD Sockets APIs .........................................34\n      14.2.\
    \ Java (and Other) APIs ....................................34\n      14.3. Referrals\
    \ in the Future ..................................35\n   15. References ....................................................35\n\
    \      15.1. Normative References .....................................35\n  \
    \    15.2. Informative References ...................................36\n   16.\
    \ Acknowledgements ..............................................38\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The ILNP document set has had extensive review within the\
    \ IRTF\n   Routing RG.  ILNP is one of the recommendations made by the RG\n  \
    \ Chairs.  Separately, various refereed research papers on ILNP have\n   also\
    \ been published during this decade.  So, the ideas contained\n   herein have\
    \ had much broader review than IRTF Routing RG.  The views\n   in this document\
    \ were considered controversial by the Routing RG, but\n   the RG reached a consensus\
    \ that the document still should be\n   published.  The Routing RG has had remarkably\
    \ little consensus on\n   anything, so virtually all Routing RG outputs are considered\n\
    \   controversial.\n   At present, the Internet research and development community\
    \ is\n   exploring various approaches to evolving the Internet Architecture to\n\
    \   solve a variety of issues including, but not limited to, scalability\n   of\
    \ inter-domain routing [RFC4984].  A wide range of other issues\n   (e.g., site\
    \ multihoming, node multihoming, site/subnet mobility, node\n   mobility) are\
    \ also active concerns at present.  Several different\n   classes of evolution\
    \ are being considered by the Internet research\n   and development community.\
    \  One class is often called \"Map and\n   Encapsulate\", where traffic would\
    \ be mapped and then tunnelled\n   through the inter-domain core of the Internet.\
    \  Another class being\n   considered is sometimes known as \"Identifier/Locator\
    \ Split\".  This\n   document relates to a proposal that is in the latter class\
    \ of\n   evolutionary approaches.\n   The Identifier-Locator Network Protocol\
    \ (ILNP) is an experimental\n   network protocol that provides evolutionary enhancements\
    \ to IP.  ILNP\n   is backwards compatible with IP and is incrementally deployable.\
    \  The\n   best starting point for learning about ILNP is the ILNP Architectural\n\
    \   Description, which includes a document roadmap [RFC6740].\n"
- title: 1.1.  Document Roadmap
  contents:
  - "1.1.  Document Roadmap\n   This document describes engineering and implementation\
    \ considerations\n   that are common to both ILNP for IPv4 (ILNPv4) and ILNP for\
    \ IPv6\n   (ILNPv6).\n   The ILNP architecture can have more than one engineering\n\
    \   instantiation.  For example, one can imagine a \"clean-slate\"\n   engineering\
    \ design based on the ILNP architecture.  In separate\n   documents, we describe\
    \ two specific engineering instances of ILNP.\n   The term \"ILNPv6\" refers precisely\
    \ to an instance of ILNP that is\n   based upon, and backwards compatible with,\
    \ IPv6.  The term \"ILNPv4\"\n   refers precisely to an instance of ILNP that\
    \ is based upon, and\n   backwards compatible with, IPv4.\n   Many engineering\
    \ aspects common to both ILNPv4 and ILNPv6 are\n   described in this document.\
    \  A full engineering specification for\n   either ILNPv6 or ILNPv4 is beyond\
    \ the scope of this document.\n   Readers are referred to other related ILNP documents\
    \ for details not\n   described here:\n   a) [RFC6740] is the main architectural\
    \ description of ILNP, including\n      the concept of operations.\n   b) [RFC6742]\
    \ defines additional DNS resource records that support\n      ILNP.\n   c) [RFC6743]\
    \ defines a new ICMPv6 Locator Update message used by an\n      ILNP node to inform\
    \ its correspondent nodes of any changes to its\n      set of valid Locators.\n\
    \   d) [RFC6744] defines a new IPv6 Nonce Destination Option used by\n      ILNPv6\
    \ nodes (1) to indicate to ILNP correspondent nodes (by\n      inclusion within\
    \ the initial packets of an ILNP session) that the\n      node is operating in\
    \ the ILNP mode and (2) to prevent off-path\n      attacks against ILNP ICMP messages.\
    \  This Nonce is used, for\n      example, with all ILNP ICMPv6 Locator Update\
    \ messages that are\n      exchanged among ILNP correspondent nodes.\n   e) [RFC6745]\
    \ defines a new ICMPv4 Locator Update message used by an\n      ILNP node to inform\
    \ its correspondent nodes of any changes to its\n      set of valid Locators.\n\
    \   f) [RFC6746] defines a new IPv4 Nonce Option used by ILNPv4 nodes to\n   \
    \   carry a security nonce to prevent off-path attacks against ILNP\n      ICMP\
    \ messages and also defines a new IPv4 Identifier Option used\n      by ILNPv4\
    \ nodes.\n   g) [RFC6747] describes extensions to Address Resolution Protocol\n\
    \      (ARP) for use with ILNPv4.\n   h) [RFC6748] describes optional engineering\
    \ and deployment functions\n      for ILNP.  These are not required for the operation\
    \ or use of ILNP\n      and are provided as additional options.\n"
- title: 1.2.  Terminology
  contents:
  - "1.2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ [RFC2119].\n   Several technical terms (e.g., \"ILNP session\") that are used\
    \ by this\n   document are defined in [RFC6740].  It is strongly recommended that\n\
    \   one read [RFC6740] before reading this document.\n"
- title: 2.  ILNP Identifiers
  contents:
  - "2.  ILNP Identifiers\n   All ILNP nodes must have at least one Node Identifier\
    \ (or just\n   \"Identifier\") value.  However, there are various options for\n\
    \   generating those Identifier values.  We describe, in this section,\n   the\
    \ relevant engineering issues related to Identifier generation and\n   usage.\n\
    \   Note well that an ILNP Node Identifier names an ILNP-capable node,\n   and\
    \ it is NOT bound to a specific interface of that node.  So a given\n   ILNP Node\
    \ Identifier is valid on all active interfaces of the node to\n   which that ILNP\
    \ Identifier is bound.  This is true even if the bits\n   used to form the Identifier\
    \ value happened to be taken from a\n   specific interface as an engineering convenience.\n"
- title: 2.1.  Syntax
  contents:
  - "2.1.  Syntax\n   ILNP Identifiers are always unsigned 64-bit strings, and they\
    \ may be\n   realised as 64-bit unsigned integers.  Both ILNPv4 and ILNPv6 use\
    \ the\n   Modified EUI-64 [IEEE-EUI] syntax that is used by IPv6 interface\n \
    \  identifiers [RFC4291], Section 2.5.1, as shown in Figure 2.1.\n      +--------------------------------------------------+\n\
    \      |  6 id bits  | U bit | G bit |      24 id bits    |\n      +--------------------------------------------------+\n\
    \      |                   32 id bits                     |\n      +--------------------------------------------------+\n\
    \   Figure 2.1: Node Identifier Format as Used for IPv6, Using the\n   Same Syntax\
    \ as in RFC 4291, Section 2.5.1.\n   That syntax contains two special reserved\
    \ bit flags.  One flag (the U\n   bit) indicates whether the value has \"universal\"\
    \ (i.e., global) scope\n   (1) or \"local\" (0) scope.  The other flag (the G\
    \ bit) indicates\n   whether the value is an \"individual\" address (1) or \"\
    group\" (i.e.,\n   multicast) (0) address.\n   However, this format does allow\
    \ other values to be set, by use of\n   administrative or other policy control,\
    \ as required, by setting the U\n   bit to \"local\".\n"
- title: 2.2.  Default Values for an Identifier
  contents:
  - "2.2.  Default Values for an Identifier\n   By default, this value, including\
    \ the U bit and G bit, are set as\n   described in Section 2.5.1 of [RFC4291].\
    \  Where no other value of\n   Identifier is available for an ILNP node, this\
    \ is the value that MUST\n   be used.\n   Because ILNP Identifiers might have\
    \ local scope, and also to handle\n   the case where two nodes at different locations\
    \ happen to be using\n   the same global scope Identifier (e.g., due to a manufacturing\
    \ fault\n   in a network chipset or card), implementers must be careful in how\n\
    \   ILNP Identifiers are handled within an end system's networking\n   implementation.\
    \  Some details are discussed in Section 4 below.\n"
- title: 2.3.  Local-Scoped Identifier Values
  contents:
  - "2.3.  Local-Scoped Identifier Values\n   ILNP Identifiers for a node also MAY\
    \ have the Scope bit of the Node\n   Identifier set to \"local\" scope.  Locally\
    \ unique identifiers MAY be\n   Cryptographically Generated, created following\
    \ the procedures used\n   for IPv6 Cryptographically Generated Addresses (CGAs)\
    \ [RFC3972]\n   [RFC4581] [RFC4982].\n   Also, locally unique identifiers MAY\
    \ be used to create the ILNP\n   equivalent to the Privacy Extensions for IPv6,\
    \ generating ILNP\n   Identifiers following the procedures used for IPv6 [RFC4941].\n"
- title: 2.4.  Multicast Identifiers
  contents:
  - "2.4.  Multicast Identifiers\n   An ILNP Identifier with the G bit set to \"group\"\
    \ names an ILNP\n   multicast group, while an ILNP Identifier with the G bit set\
    \ to\n   \"individual\" names an individual ILNP node.  However, this usage of\n\
    \   multicast for Identifiers for ILNP is currently undefined: ILNP uses\n   IPv6\
    \ multicast for ILNPv6 and IPv4 multicast for ILNPv4 and uses the\n   multicast\
    \ address formats defined as appropriate.\n   The use of multicast Identifiers\
    \ and design of an enhanced multicast\n   capability for ILNPv6 and ILNPv4 is\
    \ currently work in progress.\n"
- title: 2.5.  Administration of Identifier Values
  contents:
  - "2.5.  Administration of Identifier Values\n   Note that just as IPv6 does not\
    \ need global, centralised\n   administrative management of its interface identifiers,\
    \ so ILNPv6\n   does not need global, centralised administrative management of\
    \ the\n   Node Identifier (NID) values.\n"
- title: 3.  Encoding of Identifiers and Locators for ILNPv6
  contents:
  - '3.  Encoding of Identifiers and Locators for ILNPv6

    '
- title: 3.1.  Encoding of I and L Values
  contents:
  - "3.1.  Encoding of I and L Values\n   With ILNPv6, the Identifier and Locator\
    \ values within a packet are\n   encoded in the existing space for the IPv6 address.\
    \  In general, the\n   ILNPv6 Locator has the same syntax and semantics as the\
    \ current IPv6\n   unicast routing prefix, as shown in Figure 3.1:\n   /* IPv6\
    \ */\n   |            64 bits                  |         64 bits         |\n \
    \  +-------------------------------------+-------------------------+\n   |   IPv6\
    \ Unicast Routing Prefix       |  Interface Identifier   |\n   +-------------------------------------+-------------------------+\n\
    \   /* ILNPv6 */\n   |            64 bits                  |         64 bits \
    \        |\n   +-------------------------------------+-------------------------+\n\
    \   |             Locator                 |  Node Identifier (NID)  |\n   +-------------------------------------+-------------------------+\n\
    \   Figure 3.1: The General Format of Encoding of I/NID and L Values\n   for ILNPv6\
    \ into the IPv6 Address Bits\n   The syntactical structure of the IPv6 address\
    \ spaces remains as given\n   in Section 2.5.4 of [RFC4291], and an example is\
    \ shown in Figure 3.2,\n   which is based in part on [RFC3177] (which has since\
    \ been obsoleted\n   by [RFC6177]).\n   /* IPv6 */\n   | 3 |     45 bits     \
    \    |  16 bits  |       64 bits           |\n   +---+---------------------+-----------+-------------------------+\n\
    \   |001|global routing prefix| subnet ID |  Interface Identifier   |\n   +---+---------------------+-----------+-------------------------+\n\
    \   /* ILNPv6 */\n   |             64 bits                 |       64 bits   \
    \        |\n   +---+---------------------+-----------+-------------------------+\n\
    \   |          Locator (L64)              |  Node Identifier (NID)  |\n   +---+---------------------+-----------+-------------------------+\n\
    \   Figure 3.2: Example of IPv6 Address Format as Used in ILNPv6\n   The global\
    \ routing prefix bits and subnet ID bits above are as for\n   [RFC3177], but could\
    \ be different, e.g., as for [RFC6177].\n   The ILNPv6 Locator uses the upper\
    \ 64-bits of the 128-bit IPv6 address\n   space.  It has the same syntax and semantics\
    \ as today's IPv6 routing\n   prefix.  So, an ILNPv6 packet carrying a Locator\
    \ value can be used\n   just like an IPv6 packet today as far as core routers\
    \ are concerned.\n   The example in Figure 3.2 happens to use a /48 prefix, as\
    \ was\n   recommended by [RFC3177].  However, more recent advice is that\n   prefixes\
    \ need not be fixed at /48 and could be up to /64 [RFC6177].\n   This change,\
    \ however, does not impact the syntax or semantics of the\n   Locator value.\n\
    \   The ILNPv6 Identifier value uses the lower 64-bits of the 128-bit\n   IPv6\
    \ address.  It has the same syntax as an IPv6 identifier, but\n   different semantics.\
    \  This provides a fixed-length non-topological\n   name for a node.  Identifiers\
    \ are bound to nodes, not to interfaces\n   of a node.  All ILNP Identifiers MUST\
    \ comply with the modified EUI-64\n   syntax already specified for IPv6's \"interface\
    \ identifier\" values, as\n   described in Section 2.1.\n   IEEE EUI-64 Identifiers\
    \ can have either global-scope or local-scope.\n   So ILNP Identifiers also can\
    \ have either global-scope or local-scope.\n   A reserved bit in the modified\
    \ EUI-64 syntax clearly indicates\n   whether a given Identifier has global-scope\
    \ or local-scope.  A node\n   is not required to use a global-scope Identifier,\
    \ although that is\n   the recommended practice.  Note that the syntax of the\
    \ Node\n   Identifier field has exactly the same syntax as that defined for IPv6\n\
    \   address in Section 2.5.1 of [RFC4291].  (This is based on the IEEE\n   EUI-64\
    \ syntax [IEEE-EUI], but is not the same.)\n   Most commonly, Identifiers have\
    \ global-scope and are derived from one\n   or more IEEE 802 or IEEE 1394 'MAC\
    \ Addresses' (sic) already\n   associated with the node, following the procedure\
    \ already defined for\n   IPv6 [RFC4291].  Global-scope identifiers have a high\
    \ probability of\n   being globally unique.  This approach eliminates the need\
    \ to manage\n   Identifiers, among other benefits.\n   Local-scope Identifiers\
    \ MUST be unique within the context of their\n   Locators.  The existing mechanisms\
    \ of the IPv4 Address Resolution\n   Protocol [RFC826] and IPv6 Stateless Address\
    \ Autoconfiguration\n   (SLAAC) [RFC4862] automatically enforce this constraint.\n\
    \   For example, on an Ethernet-based IPv4 subnetwork the ARP Reply\n   message\
    \ is sent via link-layer broadcast, thereby advertising the\n   current binding\
    \ between an IPv4 address and a Media Access Control\n   (MAC) address to all\
    \ nodes on that IPv4 subnetwork.  (Note also that\n   a well-known, long standing,\
    \ issue with ARP is that it cannot be\n   authenticated.)  Local-scope Identifiers\
    \ MUST NOT be used with other\n   Locators without first ensuring uniqueness in\
    \ the context of those\n   other Locators e.g., by using IPv6 Neighbour Discovery's\
    \ Duplicate\n   Address Detection mechanism when using ILNPv6 or by sending an\
    \ ARP\n   Request when using ILNPv4.\n   Other methods might be used to generate\
    \ local-scope Identifiers.  For\n   example, one might derive Identifiers using\
    \ some form of\n   cryptographic generation or using the methods specified in\
    \ the IPv6\n   Privacy Extensions [RFC4941] to Stateless Address Autoconfiguration\n\
    \   (SLAAC) [RFC4862].  When cryptographic generation of Identifiers\n   using\
    \ methods described in RFC 3972 is in use, only the Identifier is\n   included,\
    \ never the Locator, thereby preserving roaming capability.\n   One could also\
    \ imagine creating a local-scope Identifier by taking a\n   cryptographic hash\
    \ of a node's public key.  Of course, in the\n   unlikely event of an Identifier\
    \ collision, for example, when a node\n   has chosen to use a local-scope Identifier\
    \ value, the node remains\n   free to use some other local-scope Identifier value(s).\n\
    \   It is worth remembering here that an IPv6 address names a specific\n   network\
    \ interface on a specific node, but an ILNPv6 Identifier names\n   the node itself,\
    \ not a specific interface on the node.  This\n   difference in definition is\
    \ essential to providing seamless support\n   for mobility and multihoming, which\
    \ are discussed in more detail\n   later in this note.\n"
- title: 3.2.  Network-Level Packet Formats
  contents:
  - "3.2.  Network-Level Packet Formats\n   ILNPv6 Locator and Identifier values are\
    \ encoded into IPv6 address\n   space and ILNPv6 uses directly the Classic IPv6\
    \ packet format, as\n   shown in Figure 3.3.  This is also the view of an ILNPv6\
    \ packet as\n   seen by core routers -- they simply use the Locator value (top\n\
    \   64-bits of the address field) just as they would use an IPv6 prefix\n   today\
    \ (e.g., either as /48 or as /64 when using sub-network routing).\n    0     \
    \              1                   2                   3\n    0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Version| Traffic Class |           Flow Label                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Payload Length       |   Next Header |  Hop Limit    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Source Address                         |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \                                                 +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Destination  Address                   |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \                                                 +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Figure 3.3: Existing (\"Classic\") IPv6 Header\n   In essence, the Locator\
    \ names a subnetwork.  (Locators can also be\n   referred to as Routing Prefixes\
    \ if discussing Classic IPv6).  Of\n   course, backwards compatibility requirements\
    \ mean that ILNPv6\n   Locators use the same number space as IPv6 routing prefixes.\
    \  This\n   ensures that no changes are needed to deployed IPv6 routers when\n\
    \   deploying ILNPv6.\n   The low-order 64-bits of the IPv6 address become the\
    \ Identifier.\n   Details of the Identifier were discussed above.  The Identifier\
    \ is\n   only used by end-systems, so Figure 3.4 shows the view of the same\n\
    \   packet format, but as viewed by an ILNPv6 node.  As this only needs\n   to\
    \ be parsed in this way by the end-system, so ILNPv6 deployment is\n   enabled\
    \ incrementally by updating end-systems as required.\n    0                  \
    \ 1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Version| Traffic Class |           Flow Label                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Payload Length       |   Next Header |  Hop Limit    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Source Locator                         |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Source Identifier                       |\n   |  \
    \                                                             |\n   +        \
    \                                                       +\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Destination Locator                     |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Destination Identifier                    |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Figure 3.4: ILNPv6 Header as Seen by ILNPv6-Enabled End-Systems\n"
- title: 3.3.  Encoding of Identifiers and Locators for ILNPv4
  contents:
  - "3.3.  Encoding of Identifiers and Locators for ILNPv4\n   Encoding of Identifier\
    \ and Locator values for ILNPv4 is not as\n   straightforward as for ILNPv6. \
    \ In analogy to ILNPv6, in ILNPv4, the\n   Locator value is a routing prefix for\
    \ IPv4, but is at most 30 bits.\n   Source Locator values are carried in the source\
    \ address field of the\n   IPv4 header, and destination Locator values in the\
    \ destination\n   address field.  So, just like for ILNPv6, for ILNPv4, packet\
    \ routing\n   can be performed by routers examining existing prefix values in\
    \ the\n   IPv4 header.\n   However, for ILNPv4, additional option headers have\
    \ to be used to\n   carry the Identifier value as there is not enough room in\
    \ the normal\n   IPv4 header fields.  A 64-bit Identifier value is carried in\
    \ an\n   option header.  So, the detailed explanation of the ILNPv4 packet\n \
    \  header is to be found in [RFC6746].\n"
- title: 4.  Transport-Layer Changes
  contents:
  - "4.  Transport-Layer Changes\n   ILNP uses an Identifier value in order to form\
    \ the invariant end-\n   system state for end-to-end protocols.  Currently, transport\n\
    \   protocols such as TCP and UDP use all the bits of an IP Address to\n   form\
    \ such state.  So, transport protocol implementations MUST be\n   modified in\
    \ order to operate over ILNP.\n"
- title: 4.1.  End-System State
  contents:
  - "4.1.  End-System State\n   Currently, TCP and UDP, for example, use the 4-tuple:\n\
    \      <local port, remote port, local IP Address, remote IP Address>\n   for\
    \ the end-system state for a transport layer end-point.  For ILNP,\n   implementations\
    \ must be modified to instead use the following:\n        <local port, remote\
    \ port, local Identifier, remote Identifier>\n"
- title: 4.2.  TCP/UDP Checksum Handling
  contents:
  - "4.2.  TCP/UDP Checksum Handling\n   In IP-based implementations, the TCP or UDP\
    \ pseudo-header checksum\n   calculations include all the bits of the IP Address.\
    \  By contrast,\n   when calculating the TCP or UDP pseudo-header checksums for\
    \ use with\n   ILNP, only the Identifier values are included in the TCP or UDP\n\
    \   pseudo-header checksum calculations.\n   To minimise the changes required\
    \ within transport protocol\n   implementations, and to maximise interoperability,\
    \ current\n   implementations are modified to zero the Locator fields (only for\
    \ the\n   purpose of TCP or UDP checksum calculations).  For example, for\n  \
    \ ILNPv6, this means that the existing code for IPv6 can be used, with\n   the\
    \ ILNPv6 Identifier bits occupying the lower 64 bits of the IPv6\n   address field,\
    \ and the upper 64 bits of the IPv6 address filed being\n   set to zero.  For\
    \ ILNPv4, the Identifier fields are carried in an\n   IPv4 Option [RFC6746].\n\
    \   Section 7 describes methods for incremental deployment of this ILNP-\n   specific\
    \ change and backwards compatibility with non-upgraded nodes\n   (e.g., classic\
    \ IPv4 or IPv6 nodes) in more detail.\n"
- title: 4.3.  ICMP Checksum Handling
  contents:
  - "4.3.  ICMP Checksum Handling\n   To maximise backwards compatibility, the ILNPv6\
    \ ICMP checksum is\n   always calculated in the same way as for IPv6 ICMP.  Similarly,\
    \ the\n   ILNPv4 ICMP checksum is always calculated in the same way as for IPv4\n\
    \   ICMP.\n"
- title: 5.  ILNP Communication Cache (ILCC)
  contents:
  - "5.  ILNP Communication Cache (ILCC)\n   For operational purposes, implementations\
    \ need to have a local cache\n   of state information that allow communication\
    \ endpoints to be\n   constructed and for communication protocols to operate.\
    \  Such cache\n   information is common today, e.g., IPv4 nodes commonly maintain\
    \ an\n   Address Resolution Protocol (ARP) cache with information relating to\n\
    \   current and recent Correspondent Nodes (CNs); IPv6 nodes maintain a\n   Neighbor\
    \ Discovery (ND) table with information relating to current\n   and CNs.  Likewise,\
    \ ILNP maintains an Identifier Locator\n   Communication Cache (ILCC) with information\
    \ relating to the operation\n   of ILNP.\n   The ILCC is a (logical) set of data\
    \ values required for ILNP to\n   operate.  These values are maintained by the\
    \ endpoints of each ILNP\n   session.\n   In theory, this cache is within the\
    \ ILNP network-layer.  However,\n   many network protocol implementations do not\
    \ have strict protocol\n   separation or layering.  So there is no requirement\
    \ that the ILCC be\n   kept partitioned from transport-layer protocols.\n   Note\
    \ that, in many implementations, much of the information required\n   for the\
    \ ILCC may already be present.  Where some additional\n   information is required\
    \ for ILNP, from an engineering viewpoint, the\n   ILCC could be implemented by\
    \ extending or enhancing existing data\n   structures within existing implementations.\
    \  For example, by adding\n   appropriate flags to the data structures in existing\
    \ implementations.\n   Note that the ILCC does not impose any extra state maintenance\n\
    \   requirements for applications or applications servers.  For example,\n   in\
    \ the case of, say, HTTP, there will be no additional state for a\n   server to\
    \ maintain, and any TCP state will be handled by the ILNP\n   code in the OS just\
    \ as for IP.\n"
- title: 5.1.  Formal Definition
  contents:
  - "5.1.  Formal Definition\n   The ILCC contains information about both the local\
    \ node and also\n   about current or recent correspondent nodes, as follows.\n\
    \   Information about the local node:\n      - Each currently valid Identifier\
    \ value, including its Identifier\n        Precedence and whether it is active\
    \ at present.\n      - Each currently valid Locator value, including its associated\n\
    \        local interface(s), its Locator Precedence and whether it is\n      \
    \  active at present.\n      - Each currently valid IL Vector (I-LV), including\
    \ whether it is\n        active at present.\n   Information about each correspondent\
    \ node:\n      - Most recent set of Identifiers, including lifetime and validity\n\
    \        for each.\n      - Most recent set of Locators, including lifetime and\
    \ validity for\n        each.\n      - Nonce value for packets from the local\
    \ host to the\n        correspondent.\n      - Nonce value for packets from the\
    \ correspondent to the local\n        host.\n   In the above list for the ILNP\
    \ Communication Cache:\n      - A \"valid\" item is usable, from an administrative\
    \ point of view,\n        but it might or might not be in use at present.\n  \
    \    - The \"validity\" parameter for the correspondent node indicates\n     \
    \   one of several different states for a datum.  These include at\n        least\
    \ the following:\n         - \"valid\": data is usable and has not expired.\n\
    \         - \"active\": data is usable, has not expired, and is in active\n  \
    \         use at present.\n         - \"expired\": data is still in use at present,\
    \ but is beyond its\n           expiration (i.e., without a replacement value).\n\
    \         - \"aged\": data was recently in use, but is not in active use at\n\
    \           present, and is beyond its expiration.\n      - The \"lifetime\" parameter\
    \ is an implementation-specific\n        representation of the validity lifetime\
    \ for the associated data\n        element.  In normal operation, the Lifetime\
    \ for a correspondent\n        node's Locator(s) are learned from the DNS Time-To-Live\
    \ (DNS\n        TTL) value associated with DNS records (NID, L32, L64, etc.) of\n\
    \        the Fully Qualified Domain Name (FQDN) owner name of the\n        correspondent\
    \ node.  For time, a node might use UTC (e.g., via\n        Network Time Protocol)\
    \ or perhaps some node-specific time (e.g.,\n        seconds since node boot).\n"
- title: 5.2.  Ageing ILCC Entries
  contents:
  - "5.2.  Ageing ILCC Entries\n   As a practical engineering matter, it is not sensible\
    \ to flush all\n   Locator values associated with an existing ILNP session's\n\
    \   correspondent node even if the DNS TTL associated with those Locator\n   values\
    \ expires.\n   In some situations, a CN might be disconnected briefly when moving\n\
    \   location (e.g., immediate handover, which sometimes is called \"break\n  \
    \ before make\").  If this happens, there might be a brief pause before\n   the\
    \ Correspondent Node can (a) update its own L values in the DNS,\n   and (b) send\
    \ an ICMP Locator Update message to the local node with\n   information about\
    \ its new location.  Implementers ought to try to\n   maintain ILNP sessions even\
    \ when such events occur.\n   Instead, Locator values cached for a correspondent\
    \ node SHOULD be\n   marked as \"aged\" when their TTL has expired, but retained\
    \ until\n   either the next Locator Update message is received, there is other\n\
    \   indication that a given Locator is not working any longer, there is\n   positive\
    \ indication that the Correspondent Node has terminated the\n   ILNP session (e.g.,\
    \ TCP RST if the only transport-layer session for\n   this ILNP session is a TCP\
    \ session), until some appropriate timeout\n   (e.g., 2*MSL for TCP if the only\
    \ transport-layer session for this\n   ILNP session is a TCP session), or the\
    \ ILNP session has been inactive\n   for several minutes (e.g., no transport-layer\
    \ session exists for this\n   ILNP session) and the storage space associated with\
    \ the aged entry\n   needs to be reclaimed.\n   Separately, received authenticated\
    \ Locator Update messages cause the\n   ILCC entries listed above to be updated.\n\
    \   Similarly, if there is indication that an ILNP session with a\n   Correspondent\
    \ Node remains active and the DNS TTL associated with\n   that Correspondent Node's\
    \ active Identifier value(s) has expired,\n   those remote Identifier value(s)\
    \ ought to be marked as \"expired\", but\n   retained since they are in active\
    \ use.\n"
- title: 5.3.  Large Numbers of Locators
  contents:
  - "5.3.  Large Numbers of Locators\n   Implementers should keep in mind that a node\
    \ or site might have a\n   large number of concurrent Locators, and it should\
    \ ensure that a\n   system fault does not arise if the system receives an authentic\
    \ ICMP\n   Locator Update containing a large number of Locator values.\n"
- title: 5.4.  Lookups into the ILCC
  contents:
  - "5.4.  Lookups into the ILCC\n   For received packets containing an ILNP Nonce\
    \ Option, lookups in the\n   ILCC MUST use the <remote Identifier, Nonce> tuple\
    \ as the lookup key.\n   For all other ILNP packets, lookups in the ILNP Correspondent\
    \ Cache\n   MUST use the <remote Locator, remote Identifier> tuple, i.e., the\n\
    \   remote I-LV, as the lookup key.\n   These two checks between them facilitate\
    \ situations where, perhaps\n   due to deployment of Local-scope Identifiers,\
    \ more than one\n   correspondent node is using the same Identifier value.\n \
    \  (NOTE: Other mechanisms, such as IPv6 Neighbor Discovery, ensure that\n   two\
    \ different nodes are incapable of using a given I-LV at the same\n   location,\
    \ i.e., on the same link.)\n   While Locators are omitted from the transport-layer\
    \ checksum, an\n   implementation SHOULD use Locator values to distinguish between\n\
    \   correspondents coincidentally using the same Identifier value (e.g.,\n   due\
    \ to deployment of Local-scope Identifier values) when\n   demultiplexing to determine\
    \ which application(s) should receive the\n   user data delivered by the transport-layer\
    \ protocol.\n"
- title: 6.  Handling Location/Connectivity Changes
  contents:
  - "6.  Handling Location/Connectivity Changes\n   In normal operation, an ILNP node\
    \ uses the DNS for initial rendezvous\n   in setting up ILNP sessions.  The use\
    \ of DNS for initial rendezvous\n   with mobile nodes was earlier proposed by\
    \ others [PHG02] and then\n   separately reinvented by the current authors later\
    \ on.\n"
- title: 6.1.  Node Location/Connectivity Changes
  contents:
  - "6.1.  Node Location/Connectivity Changes\n   To handle the move of a node or\
    \ a change to the upstream connectivity\n   of a multihomed node, we add a new\
    \ ICMP control message [RFC6745]\n   [RFC6743].  The ICMP Locator Update (LU)\
    \ message is used by a node to\n   inform its existing CNs that the set of valid\
    \ Locators for the node\n   has changed.  This mechanism can be used to add newly\
    \ valid Locators,\n   to remove no longer valid Locators, or to do both at the\
    \ same time.\n   The LU mechanism is analogous to the Binding Update mechanism\
    \ in\n   Mobile IPv6, but in ILNP, such messages are used any time Locator\n \
    \  value changes need to be notified to CNs, e.g., for multihomed hosts\n   as\
    \ well as for mobile hosts.\n   Further, if the node wishes to be able to receive\
    \ new incoming ILNP\n   sessions, the node normally uses Secure Dynamic DNS Update\
    \ [RFC3007]\n   to ensure that a correct set of Locator values are present in\
    \ the\n   appropriate DNS records (i.e., L32, L64) in the DNS for that node\n\
    \   [RFC6742].  This enables any new correspondents to correctly initiate\n  \
    \ a new ILNP session with the node at its new location.\n   While the Locator\
    \ Update control message could be an entirely new\n   protocol running over UDP,\
    \ for example, there is no obvious advantage\n   to creating a new protocol rather\
    \ than using a new ICMP message.  So\n   ILNP defines a new ICMP Locator Update\
    \ message for both IPv4 and\n   IPv6.\n"
- title: 6.2.  Network Connectivity/Locator Changes
  contents:
  - "6.2.  Network Connectivity/Locator Changes\n   As a DNS performance optimisation,\
    \ the LP DNS resource record MAY be\n   used to avoid requiring each node on a\
    \ subnetwork to update its DNS\n   L64 record entries when that subnetwork's location\
    \ (e.g., upstream\n   connectivity) changes [RFC6742].  This can reduce the number\
    \ of DNS\n   updates required when a subnetwork moves from Order (number of nodes\n\
    \   on subnetwork) to Order(1).\n   In this case, the nodes on the subnetwork\
    \ each would have an LP\n   record pointing to a common FQDN used to name that\
    \ subnetwork.  In\n   turn, that subnetwork's domain name would have one or more\
    \ L64\n   record(s) in the DNS.  Since the contents of an LP record are stable,\n\
    \   relatively long DNS TTL values can be associated with these records\n   facilitating\
    \ DNS caching.  By contrast, the DNS TTL of an L32 or L64\n   record for a mobile\
    \ or multihomed node should be small.  Experimental\n   work at the University\
    \ of St Andrews indicates that the DNS continues\n   to work well even with very\
    \ low (e.g., zero) DNS TTL values [BA11].\n   Correspondents of a node on a mobile\
    \ subnetwork using this DNS\n   performance optimisation would initially perform\
    \ a normal FQDN lookup\n   for a node.  If that lookup returned another FQDN in\
    \ an LP record as\n   additional data, then the correspondent would perform a\
    \ lookup on\n   that FQDN and expect an L32 or L64 record returned as additional\n\
    \   data, in order to learn the Locator value to use to reach that target\n  \
    \ node.  (Of course, a lookup that did not return any ILNP-related DNS\n   records\
    \ would result in an ordinary IPv4 session or ordinary IPv6\n   session being\
    \ initiated, instead.)\n"
- title: 7.  Subnetting
  contents:
  - "7.  Subnetting\n   For ILNPv4 and ILNPv6, the Locator value includes the subnetting\n\
    \   information, as that also is topological information.  As well as\n   being\
    \ architecturally correct, the placement of subnetting as part of\n   the Locator\
    \ is also convenient from an engineering point of view in\n   both IPv4 and IPv6.\n\
    \   We consider that a Locator value, L consists of two parts:\n   - L_pp: the\
    \ Locator prefix part, which occupies the most significant\n     bits in the address\
    \ (for both ILNPv4 and ILNPv6).\n   - L_ss: Locator subnetwork selector, which\
    \ occupies bits just after\n     the L_pp.\n   For each of ILNPv4 and ILNPv6,\
    \ L_pp gets its value from the provider-\n   assigned routing prefix for IPv4\
    \ and IPv6, respectively.  For L_ss,\n   in each case of ILNPv4 and ILNPv6, the\
    \ L_ss bits are located in the\n   part of the address space which you might expect\
    \ them to be located\n   if IPv4 or IPv6 addresses were being used, respectively.\n"
- title: 7.1.  Subnetting for ILNPv6
  contents:
  - "7.1.  Subnetting for ILNPv6\n   For ILNPv6, recall that the Locator value is\
    \ encoded to be\n   syntactically similar to an IPv6 address prefix, as shown\
    \ in Figure\n   7.1.\n   /* IPv6 */\n   | 3 |     45 bits         |  16 bits \
    \ |     64 bits             |\n   +---+---------------------+-----------+-------------------------+\n\
    \   |001|global routing prefix| subnet ID |  Interface Identifier   |\n   +---+---------------------+-----------+-------------------------+\n\
    \   /* ILNPv6 */\n   |             64 bits                 |     64 bits     \
    \        |\n   +---+---------------------+-----------+-------------------------+\n\
    \   |          Locator (L64)              |  Node Identifier (NID)  |\n   +---+---------------------+-----------+-------------------------+\n\
    \   +<-------- L_pp --------->+<- L_ss -->+\n     L_pp = Locator prefix part (assigned\
    \ IPv6 prefix)\n     L_ss = Locator subnet selector (locally managed subnet ID)\n\
    \   Figure 7.1: IPv6 Address Format [RFC3587] as Used in ILNPv6,\n   Showing How\
    \ Subnets Can Be Identified\n   Note that the subnet ID forms part of the Locator\
    \ value.  Note also\n   that [RFC6177] allows the global routing prefix to be\
    \ more than 45\n   bits, and for the subnet ID to be smaller, but still preserving\
    \ the\n   64-bit size of the Locator.\n"
- title: 7.2.  Subnetting for ILNPv4
  contents:
  - "7.2.  Subnetting for ILNPv4\n   For ILNPv4, the L_pp value is an IPv4 routing\
    \ prefix as used today,\n   which is typically less than 32 bits.  However, the\
    \ ILNPv4 Locator\n   value is carried in the 32-bit IP Address space, so the bits\
    \ not used\n   for the routing prefix could be used for L_ss, e.g., for a /24\
    \ IPv4\n   prefix, the situation would be as shown in Figure 7.2.\n          \
    \  24 bits           8 bits\n   +------------------------+----------+\n   |  \
    \       Locator (L32)             |\n   +------------------------+----------+\n\
    \   +<------- L_pp --------->+<- L_ss ->+\n   L_pp = Locator prefix part (assigned\
    \ IPv4 prefix)\n   L_ss = Locator subnet selector (locally managed subnet ID)\n\
    \   Figure 7.2: IPv4 Address Format for /24 IPv4 Prefix, as Used in\n   ILNPv4,\
    \ Showing How Subnets Can Be Identified\n   Note that the L_ss occupies bits that\
    \ in an IPv4 address would\n   normally be the host part of the address, which\
    \ the site network\n   could use for subnetting in any case.\n"
- title: 7.3.  Subnetting for Router-Router Links in IPv6/ILNPv6
  contents:
  - "7.3.  Subnetting for Router-Router Links in IPv6/ILNPv6\n   There is a special\
    \ case of /127 prefixes used in router-router,\n   point-to-point links for IPv6\
    \ [RFC6164].  ILNPv6 does not preclude\n   such use.\n"
- title: 8.  DNS Considerations
  contents:
  - "8.  DNS Considerations\n   ILNP makes use of DNS for name resolution, as does\
    \ IP.  Unlike IP,\n   ILNP also uses DNS to support features such as mobility\
    \ and\n   multihoming.  While such usage is appropriate use of the DNS, it is\n\
    \   important to discuss operational and engineering issues that may\n   impact\
    \ DNS usage.\n"
- title: 8.1.  Secure Dynamic DNS Update
  contents:
  - "8.1.  Secure Dynamic DNS Update\n   When a host that expects incoming connections\
    \ changes one or more of\n   its Locator values, the host normally uses the IETF\
    \ Secure Dynamic\n   DNS Update protocol [RFC3007] to update the set of currently\
    \ valid\n   Locator values associated with its FQDN.  This ensures that the\n\
    \   authoritative DNS server for its FQDN will be able to generate an\n   accurate\
    \ set of Locator values if the DNS server receives DNS name\n   resolution request\
    \ for its FQDN.\n   Liu and Albitz [LA06] report that Secure Dynamic DNS Update\
    \ has been\n   supported on the client-side for several years now in widely deployed\n\
    \   operating systems (e.g., MS Windows, Apple Mac OS X, UNIX, and Linux)\n  \
    \ and also in DNS server software (e.g., BIND).  Publicly available\n   product\
    \ data sheets indicate that some other DNS server software\n   packages, such\
    \ as that from Nominum, also support this capability.\n   For example, Microsoft\
    \ Windows XP (and later versions), the freely\n   distributable BIND DNS software\
    \ package (used in Apple Mac OS X and\n   in most UNIX systems), and the commercial\
    \ Nominum DNS server all\n   implement support for Secure Dynamic DNS Update and\
    \ are known to\n   interoperate [LA06].  There are credible reports that when\
    \ a site\n   deploys Microsoft's Active Directory, the site (silently)\n   automatically\
    \ deploys Secure Dynamic DNS Update [LA06].  So, many\n   sites have already deployed\
    \ Secure Dynamic DNS Update even though\n   they are not actively using it (and\
    \ might not be aware they have\n   already deployed that protocol) [LA06].\n \
    \  So DNS update via Secure Dynamic DNS Update is not only standards-\n   based,\
    \ but also readily available in widely deployed systems today.\n"
- title: 8.2.  New DNS RR Types
  contents:
  - "8.2.  New DNS RR Types\n   As part of this proposal, additional DNS resource\
    \ records have been\n   proposed in a separate document [RFC6742].  These new\
    \ records are\n   summarised in Table 6.1.\n    new DNS RR type |  Purpose\n \
    \  -----------------+------------------------------------------------\n      \
    \    NID       | store the value of a Node Identifier\n          L32       | store\
    \ the value of a 32-bit Locator for ILNPv4\n          L64       | store the value\
    \ of a 64-bit Locator for ILNPv6\n          LP        | points to a (several)\
    \ L32 and/or L64 record(s)\n   -----------------+------------------------------------------------\n\
    \   Table 6.1. Summary of new DNS RR Types for ILNP\n   With this proposal, mobile\
    \ or multihomed nodes and sites are expected\n   to use the existing \"Secure\
    \ Dynamic DNS Update\" protocol to keep\n   their Node Identifier (NID) and Locator\
    \ (L32 and/or L43) records\n   correct in their authoritative DNS server(s) [RFC3007]\
    \ [RFC6742].\n   Reverse DNS lookups, to find a node's FQDN from the combination\
    \ of a\n   Locator and related Identifier value, can be performed as at present.\n"
- title: 8.3.  DNS TTL Values for ILNP RRS Types
  contents:
  - "8.3.  DNS TTL Values for ILNP RRS Types\n   Existing DNS specifications require\
    \ that DNS clients and DNS\n   resolvers honour the TTL values provided by the\
    \ DNS servers.  In the\n   context of this proposal, short DNS TTL values are\
    \ assigned to\n   particular DNS records to ensure that the ubiquitous DNS caching\n\
    \   resolvers do not cache volatile values (e.g., Locator records of a\n   mobile\
    \ node) and consequently return stale information to new\n   requestors.\n   The\
    \ TTL values for L32 and L64 records may have to be relatively low\n   (perhaps\
    \ a few seconds) in order to support mobility and multihoming.\n   Low TTL values\
    \ may be of concern to administrators who might think\n   that this would reduce\
    \ efficacy of DNS caching increase DNS load\n   significantly.\n   Previous research\
    \ by others indicates that DNS caching is largely\n   ineffective, with the exception\
    \ of NS records and the addresses of\n   DNS servers referred to by NS records\
    \ [SBK02].  This means DNS\n   caching performance and DNS load will not be adversely\
    \ affected by\n   assigning very short TTL values (down to zero) to the Locator\
    \ records\n   of typical nodes for an edge site [BA11].  It also means that it\
    \ is\n   preferable to deploy the DNS server function on nodes that have\n   longer\
    \ DNS TTL values, rather than on nodes that have shorter DNS TTL\n   values.\n\
    \   LP records normally are stable and will have relatively long TTL\n   values,\
    \ even if the L32 or L64 records they point to have values that\n   have relatively\
    \ low TTL values.\n   Identifier values might be very long-lived (e.g., days)\
    \ when they\n   have been generated from an IEEE MAC address on the system.\n\
    \   Identifier values might have a shorter lifetime (e.g., hours or\n   minutes)\
    \ if they have been cryptographically generated [RFC3972],\n   have been created\
    \ by the IPv6 Privacy Extensions [RFC4941], or\n   otherwise have the EUI-64 scope\
    \ bit set to \"local-scope\".  Note that\n   when ILNP is used, the cryptographic\
    \ generation method described in\n   RFC 3972 is used only for the Identifier,\
    \ omitting the Locator,\n   thereby preserving roaming capability.  Note that\
    \ a given ILNP\n   session normally will use a single Identifier value for the\
    \ lifetime\n   of that ILNP session.\n"
- title: 8.4.  IP/ILNP Dual Operation and Transition
  contents:
  - "8.4.  IP/ILNP Dual Operation and Transition\n   During a long transition period,\
    \ a node that is ILNP-capable SHOULD\n   have not only NID and L32/L64 (or NID\
    \ and LP) records present in its\n   authoritative DNS server but also SHOULD\
    \ have A/AAAA records in the\n   DNS for the benefit of non-upgraded nodes.  Then,\
    \ when any CN\n   performs an FQDN lookup for that node, it will receive the A/AAAA\n\
    \   with the appropriate NID, L32/L64 records, and/or LP records as\n   \"additional\
    \ data\".\n   Existing DNS specifications require that a DNS resolver or DNS client\n\
    \   ignore unrecognised DNS record types.  So, gratuitously appending NID\n  \
    \ and Locator (i.e., L32, L64, or LP) records as \"additional data\" in\n   DNS\
    \ responses to A/AAAA queries ought not to create any operational\n   issues.\
    \  So, IP only nodes would use the A/AAAA RRs, but ILNP-capable\n   nodes would\
    \ be able to use the NID, L32/L64 and/or LP records are\n   required.\n   There\
    \ is nothing to prevent this capability being implemented\n   strictly inside\
    \ a DNS server, whereby the DNS server synthesises a\n   set of A/AAAA records\
    \ to advertise from the NID and Locator (i.e.,\n   L32, L64, or LP) values that\
    \ the node has kept updated in that DNS\n   server.  Indeed, such a capability\
    \ may be desirable, reducing the\n   amount of manual configuration required for\
    \ a site, and reducing the\n   potential for errors as the A/AAAA records would\
    \ be automatically\n   generated.\n"
- title: 9.  IP Security for ILNP
  contents:
  - "9.  IP Security for ILNP\n   The primary conceptual difference from ordinary\
    \ IP security (IPsec)\n   is that ILNP IP Security omits all use of, and all reference\
    \ to,\n   Locator values.  This leads to several small, but important, changes\n\
    \   to IPsec when it is used with ILNP sessions.\n"
- title: 9.1.  IPsec Security Association Enhancements for ILNP
  contents:
  - "9.1.  IPsec Security Association Enhancements for ILNP\n   IPsec Security Associations\
    \ for ILNP only include the Identifier\n   values for the endpoints, and omit\
    \ the Locator values.  As an\n   implementation detail, ILNP implementations MUST\
    \ be able to\n   distinguish between different Security Associations with ILNP\n\
    \   correspondents (at different locations, with different ILNP Nonce\n   values\
    \ in use) that happen to use the same Identifier values (e.g.,\n   due to an inadvertent\
    \ Identifier collision when using identifier\n   values generated by using the\
    \ IPv6 Privacy Addressing extension).\n   One possible way to distinguish between\
    \ such different ILNP sessions\n   is to maintain a mapping between the IPsec\
    \ Security Association\n   Database (SAD) entry and the corresponding ILCC entry.\n\
    \   Consistent with this enhancement to the definition of an IPsec\n   Security\
    \ Association, when processing received IPsec packets\n   associated with an ILNP\
    \ session, ILNP implementations ignore the\n   Locator bits of the received packet\
    \ and only consider the Identifier\n   bits.  This means, for example, that if\
    \ an ILNP correspondent node\n   moves to a different subnetwork, and thus is\
    \ using a different Source\n   Locator in the header of its ILNP IPsec packets,\
    \ the ILNP session\n   will continue to work and will continue to be secure.\n\
    \   Since implementations of ILNP are also required to support IP,\n   implementers\
    \ need to ensure that ILNP IPsec Security Associations can\n   be distinguished\
    \ from ordinary IPsec Security Associations.  The\n   details of this are left\
    \ to the implementer.  As an example, one\n   possible implementation strategy\
    \ would be to retain a single IPsec\n   Security Association Database (SAD), but\
    \ add an internal flag bit to\n   each entry of that IPsec SAD to indicate whether\
    \ ILNP is in use for\n   that particular IPsec Security Association.\n"
- title: 9.2.  IP Authentication Header Enhancements for ILNP
  contents:
  - "9.2.  IP Authentication Header Enhancements for ILNP\n   Similarly, for an ILNP\
    \ session using IPsec, the IPsec Authentication\n   Header (AH) only includes\
    \ the Identifier values for the endpoints in\n   its authentication calculations,\
    \ and it omits the Source Locator and\n   Destination Locator fields from its\
    \ authentication calculations.\n   This enables IPsec AH to work well even when\
    \ used with ILNP localised\n   numbering [RFC6748] or other situations where a\
    \ Locator value might\n   change while the packet travels from origin to destination.\n"
- title: 9.3.  Key Management Considerations
  contents:
  - "9.3.  Key Management Considerations\n   In order to distinguish at the network-layer\
    \ between multiple ILNP\n   nodes that happen to be using the same Node Identifier\
    \ values (e.g.,\n   because the identifier values were generated using the IPv6\
    \ Privacy\n   Addressing method), key management packets being used to set up\
    \ an\n   ILNP IPsec session MUST include the ILNP Nonce Option.\n   Similarly,\
    \ key management protocols used with IPsec are enhanced to\n   deprecate use of\
    \ IP Addresses as identifiers and to substitute the\n   use of the new Node Identifier\
    \ values for that purpose.  This results\n   in an ILNP IPsec Security Association\
    \ that is independent of the\n   Locator values that might be used.\n   For ILNPv6\
    \ implementations, the ILNP Node Identifier (64-bits) is\n   smaller than the\
    \ IPv6 Address (128-bits).  So support for ILNPv6\n   IPsec is accomplished by\
    \ zeroing the upper-64 bits of the IPv6\n   Address fields in the application-layer\
    \ key management protocol,\n   while retaining the Node Identifier value in the\
    \ lower-64 bits of the\n   application-layer key management protocol.\n   For\
    \ ILNPv4 implementations, enhancements to the key management\n   protocol likely\
    \ will be needed, because existing key management\n   protocols rely on 32-bit\
    \ IPv4 addresses, while ILNP Node Identifiers\n   are 64-bits.  Such enhancements\
    \ are beyond the scope of this\n   specification.\n"
- title: 10.  Backwards Compatibility and Incremental Deployment
  contents:
  - "10.  Backwards Compatibility and Incremental Deployment\n   Experience with IPv6\
    \ deployment over the past many years has shown\n   that it is important for any\
    \ new network protocol to provide\n   backwards compatibility with the deployed\
    \ IP base and should be\n   incrementally deployable, ideally requiring modification\
    \ of only\n   those nodes that wish to use ILNP and not requiring the modification\n\
    \   of nodes that do not intend to use ILNP.  The two instances of ILNP,\n   ILNPv4\
    \ and ILNPv6, are intended to be, respectively, backwards\n   compatible with,\
    \ and incrementally deployable on, the existing IPv4\n   and IPv6 installed bases.\
    \  Indeed, ILNPv4 and ILNPv6 can each be\n   seen, from an engineering viewpoint,\
    \ as supersets of the IPv4 and\n   IPv6, respectively.\n   However, in some cases,\
    \ ILNP introduces functions that supersede\n   equivalent functions available\
    \ in IP.  For example, ILNP has a\n   mobility model, and so it does not need\
    \ to use the models for Mobile\n   IPv4 or Mobile IPv6.\n   As ILNP changes, the\
    \ use of end-to-end namespaces, for the most part,\n   it is only end-systems\
    \ that need to be modified.  However, in order\n   to leverage existing engineering\
    \ (e.g., existing protocols), in some\n   cases, there is a compromise, and these\
    \ are highlighted in this\n   section.\n"
- title: 10.1.  Priorities in the Design of ILNPv6 and ILNPv4
  contents:
  - "10.1.  Priorities in the Design of ILNPv6 and ILNPv4\n   In the engineering design\
    \ of ILNPv6 and ILNPv4, we have used the\n   following priorities.  In some ways,\
    \ this choice is arbitrary, and it\n   may be equally valid to \"invert\" these\
    \ priorities for a different\n   architectural and engineering design.\n   1.\
    \  Infrastructure\n   As much of the deployed IP network infrastructure should\
    \ be used\n   without change.  That is, routers and switches should require minimal\n\
    \   or zero modifications in order to run ILNP.  As much as possible of\n   the\
    \ existing installed base of core protocols should be reused.\n   2.  Core protocols\n\
    \   As much of the deployed network control protocols, such as routing,\n   should\
    \ be used without change.  That is, existing routing protocols\n   and switch\
    \ configuration should require minimal or zero modifications\n   in order to run\
    \ ILNP.\n   3.  Scope of end-system changes\n   Any nodes that do not need to\
    \ run ILNP should not need to be\n   upgraded.  It should be possible to have\
    \ a site network that has a\n   mix of IP-only and ILNP-capable nodes without\
    \ any changes required to\n   the IP-only nodes.\n   4.  Applications\n   There\
    \ should be minimal impact on applications, even though ILNP\n   requires end-to-end\
    \ protocols to be upgraded.  Indeed, for those\n   applications that are \"well\
    \ behaved\" (e.g., do not use IP Address\n   values directly for application state\
    \ or application configuration),\n   there should be little or no effort required\
    \ in enabling them to\n   operate over ILNP.\n   Each of these items is discussed\
    \ in its own section below.\n"
- title: 10.2.  Infrastructure
  contents:
  - "10.2.  Infrastructure\n   ILNP is designed to be deployed on existing infrastructure.\
    \  No new\n   infrastructure is required to run ILNP as it will be implemented\
    \ as a\n   software upgrade impacting only end-to-end protocols.  Existing\n \
    \  routing protocols can be reused: no new routing protocols are\n   required.\
    \  This means that network operators and service providers do\n   not need to\
    \ learn about, test, and deploy new protocols, or change\n   the structure of\
    \ their network in order for ILNP to be deployed.\n   Exceptionally, edge routers\
    \ supporting ILNPv4 hosts will need to\n   support an enhanced version of ARP.\n"
- title: 10.3.  Core Protocols
  contents:
  - "10.3.  Core Protocols\n   Existing routing and other control protocols should\
    \ not need to\n   change in devices such as switches and routers.  We believe\
    \ this to\n   be true for ILNPv6.  However, for ILNPv4, we believe that ARP will\n\
    \   need to be enhanced in edge routers (or Layer 3 switches) that\n   support\
    \ ILNPv4 hosts.  Backbone and transit routers still ought not\n   require changes\
    \ for either ILNPv4 or ILNPv6.\n   For both ILNPv4 and ILNPv6, the basic packet\
    \ format for packets\n   reuses that format that is seen by routers for IPv4 and\
    \ IPv6,\n   respectively.  Specifically, as the ILNP Locator value is always a\n\
    \   routing prefix (either IPv4 or IPv6), routing protocols should work\n   unchanged.\n\
    \   Both ILNPv4 and ILNPv6 introduce new header options (e.g., Nonce\n   Option\
    \ messages) and ICMP messages (e.g., Locator Update messages)\n   that are used\
    \ to enable end-to-end signalling.  For packet\n   forwarding, depending on the\
    \ forwarding policies used by some\n   providers or site border routers, there\
    \ may need to be modifications\n   to those policies to allow the new header options\
    \ and new ICMP\n   messages to be forwarded.  However, as the header options and\
    \ new\n   ICMP messages are end-to-end, such modifications are likely to be in\n\
    \   configuration files (or firewall policy on edge routers), as core\n   routers\
    \ do NOT need to parse and act upon the information contained\n   in the header\
    \ options or ICMP messages.\n"
- title: 10.4.  Scope of End-System Changes
  contents:
  - "10.4.  Scope of End-System Changes\n   Only end-systems that need to use ILNP\
    \ need to be updated in order\n   for ILNP to be used at a site.\n   There are\
    \ three exceptions to this statement as follows:\n   a) ILNPv4 ARP: as the Identifier\
    \ value for IPv4 cannot fit into the\n      normal 20-byte IPv4 packet header\
    \ (a header extension is used),\n      ARP must be modified.  This only impacts\
    \ end-systems that use\n      ILNPv4 and those switches or site border routers\
    \ that are the\n      first hop from an ILNPv4 node.  For ILNPv6, as the I and\
    \ L values\n      fit into the existing basic IPv6 packet, IPv6 Neighbour Discovery\n\
    \      can operate without modification.\n   b) Use of IP NAT: Where IP NAT or\
    \ NAPT is in use for a site, existing\n      NAT/NAPT device will rewrite address\
    \ fields in ILNPv4 packets or\n      ILNPv6 packets.  To avoid this, the NAT should\
    \ either (i) be\n      configured to allow the pass-through of packets originating\
    \ from\n      ILNP-capable nodes (e.g., by filtering on source address fields\
    \ in\n      the IP header); or (ii) should be enhanced to recognise ILNPv4 or\n\
    \      ILNPv6 packets (e.g., by looking for the ILNP Nonce Option).\n   c) Site\
    \ Border Routers (SBRs) in ILNP Advanced Deployment scenarios:\n      There are\
    \ options to use an ILNP-capable Site Border Router (SBR)\n      as described\
    \ in another document [RFC6748].  In such scenarios,\n      the SBR(s) need to\
    \ be ILNP-capable.\n   Other than these exceptions, it is entirely possible to\
    \ have a site\n   that uses a mix of IP and ILNP nodes and requires no changes\
    \ to nodes\n   other than the nodes that wish to use ILNP.  For example, if a\
    \ user\n   on a site wishes to have his laptop use ILNPv6, only that laptop\n\
    \   would need to have an upgraded stack: no other devices (end-systems,\n   Layer\
    \ 2 switches or routers) at that site would need to be upgraded.\n"
- title: 10.5.  Applications
  contents:
  - "10.5.  Applications\n   As noted, in the Architecture Description [RFC6740],\
    \ those\n   applications that do not use IP Address values in application state\n\
    \   or configuration data are considered to be \"well behaved\".\n   Applications\
    \ that work today through a NAT or Network Address Port\n   Translation (NAPT)\
    \ device without application-specific support are\n   also considered \"well behaved\"\
    .  Such applications might use DNS\n   FQDNs or application-specific name spaces.\
    \  (Note Well: application-\n   specific name spaces should not be derived from\
    \ IP Address values.)\n   For well-behaved applications, replacing IP with ILNP\
    \ should have no\n   impact.  That is, well-behaved applications should work unmodified\n\
    \   over ILNP.\n   Those applications that directly use IP Address values in application\n\
    \   state or configuration will need to be modified for operation over\n   ILNP.\
    \  Examples of such applications include the following:\n   - FTP: which uses\
    \ IP Address values in the application-layer\n     protocol.  In practice, use\
    \ of Secure Copy (SCP) is growing, while\n     use of FTP is either flat or declining,\
    \ in part due to the improved\n     security provided by SCP.\n   - SNMP: which\
    \ uses IP Address values in MIB definitions, and values\n     derived from IP\
    \ Address values in SNMP object names.\n   Further experimentation in this area\
    \ is planned to validate these\n   details.\n"
- title: 10.6.  Interworking between IP and ILNP
  contents:
  - "10.6.  Interworking between IP and ILNP\n   A related topic is interworking:\
    \ for example, how would an IPv6 node\n   communicate with an ILNPv6 node?  Currently,\
    \ we make the assumption\n   that ILNP nodes \"drop down\" to using IP when communicating\
    \ with a\n   non-ILNP capable node, i.e., there is no interworking as such.  In\n\
    \   the future, it may be beneficial to define interworking scenarios\n   that\
    \ do not rely on having ILNP nodes fall back to IP, for example,\n   by the use\
    \ of suitable protocol translation gateways or middleboxes.\n   For now, a simplified\
    \ summary of the process for interaction between\n   ILNP hosts and non-ILNP hosts\
    \ is as follows:\n   a) For a host initiating communication using DNS, the resolution\
    \ of\n      the FQDN for the remote host will return at least one NID record\n\
    \      and at least one of an L32 record (for ILNPv4) or an L64 record\n     \
    \ (for ILNPv6).  Then, the host knows that the remote host supports\n      ILNP.\n\
    \   b) When a host has I and L values for a remote host, the initial\n      packet\
    \ to initiate communication MUST contain a Nonce Header\n      [RFC6746] [RFC6744]\
    \ that indicates to the remote host that this\n      packet is attempting to set\
    \ up an ILNP session.\n   c) When a receiving host sees a Nonce Header, if it\
    \ DOES support ILNP\n      it will proceed to set up an ILNP session.\n   d) When\
    \ a receiving host sees a Nonce Header, if it DOES NOT support\n      ILNP, it\
    \ will reject the packet and this will be indicated to the\n      sender through\
    \ an ICMP message [RFC6743] [RFC6745].  Upon\n      receiving the ICMP messages,\
    \ the sender will re-initiate\n      communication using standard IPv4 or IPv6.\n\
    \   Many observers in the community expect IPv4 to remain in place for a\n   long\
    \ time even though IPv6 has been available for over a decade.\n   With a similar\
    \ anticipation, it is likely that in the future there\n   will be a mixed environment\
    \ of both IP and ILNP hosts.  Until there\n   is a better understanding of the\
    \ deployment and usage scenarios that\n   will develop, it is not clear what interworking\
    \ scenarios would be\n   useful to define and focus on between IP and ILNP.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   There are numerous security considerations for\
    \ ILNP from an\n   engineering viewpoint.  Overall, ILNP and its capabilities\
    \ are no\n   less secure than IP and equivalent IP capabilities.  In some cases,\n\
    \   ILNP has the potential to be more secure, or offer security\n   capability\
    \ in a more harmonised manner, for example, with ILNP's use\n   of IPsec in conjunction\
    \ with multihoming and mobility.  [RFC6740]\n   describes several security considerations\
    \ that apply to ILNP and is\n   included here by reference.\n   ILNP offers an\
    \ enhanced version of IP security (IPsec).  The details\n   of IP Security for\
    \ ILNP were described separately above.  All ILNP\n   implementations MUST support\
    \ the use of the IP Authentication Header\n   (AH) for ILNP and also the IP Encapsulating\
    \ Security Payload (ESP)\n   for ILNP, but deployment and use of IPsec for ILNP\
    \ remains a matter\n   for local operational security policy.\n"
- title: 11.1.  Authenticating ICMP Messages
  contents:
  - "11.1.  Authenticating ICMP Messages\n   Separate documents propose a new IPv4\
    \ Option [RFC6746] and a new IPv6\n   Destination Option [RFC6744].  Each of these\
    \ options can be used to\n   carry an ILNP Nonce value end-to-end between communicating\
    \ nodes.\n   That nonce provides protection against off-path attacks on an ILNP\n\
    \   session.  These ILNP Nonce Options are used ONLY for ILNP and not for\n  \
    \ IP.  The nonce values are exchanged in the initial packets of an ILNP\n   session\
    \ by including them in those initial/handshake packets.\n   ALL ICMP Locator Update\
    \ messages MUST include an ILNP Nonce Option\n   and MUST include the correct\
    \ ILNP Nonce value for the claimed sender\n   and intended recipient of that ICMP\
    \ Locator Update message.  There\n   are no exceptions to this rule.  ICMP Locator\
    \ Update messages MAY be\n   protected by IPsec, but they still MUST include an\
    \ ILNP Nonce Option\n   and the ILNP Nonce Option still MUST include the correct\
    \ ILNP Nonce\n   value.\n   When a node has an active ILNP session, and that node\
    \ changes its\n   Locator set, it SHOULD include the appropriate ILNP Nonce Option\
    \ in\n   the first few data packets sent using a new Locator value so that the\n\
    \   recipient can validate the received data packets as valid (despite\n   having\
    \ an unexpected Source Locator value).\n   Any ILNP Locator Update messages received\
    \ without an ILNP Nonce\n   Option MUST be discarded as forgeries.\n   Any ILNP\
    \ Locator Update messages received with an ILNP Nonce Option,\n   but that do\
    \ NOT have the correct ILNP Nonce value inside the ILNP\n   Nonce Option, MUST\
    \ be discarded as forgeries.\n   When the claimed sender of an ICMP message is\
    \ known to be a current\n   ILNP correspondent of the recipient (e.g., has a valid,\
    \ non-expired,\n   ILCC entry), then any ICMP error messages from that claimed\
    \ sender\n   MUST include the ILNP Nonce Option and MUST include the correct ILNP\n\
    \   Nonce value (i.e., correct for that sender recipient pair) in that\n   ILNP\
    \ Nonce Option.\n   When the claimed sender of an ICMP error message is known\
    \ to be a\n   current ILNP correspondent of the recipient (e.g., has a valid,\
    \ non-\n   expired, ILCC entry), then any ICMP error messages from that claimed\n\
    \   sender that are received without an ILNP Nonce Option MUST be\n   discarded\
    \ as forgeries.\n   When the claimed sender of an ICMP error message is known\
    \ to be a\n   current ILNP correspondent of the recipient (e.g., has a valid,\
    \ non-\n   expired, ILCC entry), then any ICMP error messages from that claimed\n\
    \   sender that contain an ILNP Nonce Option, but that do NOT have the\n   correct\
    \ ILNP Nonce value inside the ILNP Nonce Option, MUST be\n   discarded as forgeries.\n\
    \   ICMP messages (not including ICMP Locator Update messages) with a\n   claimed\
    \ sender that is NOT known to be a current ILNP correspondent\n   of the recipient\
    \ (e.g., does not have a valid, non-expired, ILCC\n   entry) MAY include the ILNP\
    \ Nonce Option, but, in this case, the ILNP\n   Nonce Option is ignored by the\
    \ recipient upon receipt, since the\n   recipient has no way to authenticate the\
    \ received ILNP Nonce value.\n   Received ICMP messages (not including ICMP Locator\
    \ Update messages)\n   with a claimed sender that is NOT known to be a current\
    \ ILNP\n   correspondent of the recipient (e.g., does not have a valid, non-\n\
    \   expired, ILCC entry) do NOT require the ILNP Nonce Option because the\n  \
    \ security risks are no different than for deployed IPv4 and IPv6 --\n   provided\
    \ that the received ICMP message is not an ICMP Locator Update\n   message.  Such\
    \ ICMP messages (e.g., Destination Unreachable, Packet\n   Too Big) might legitimately\
    \ originate in an intermediate system along\n   the path of an ILNP session. \
    \ That intermediate system might not be\n   ILNP capable.  Even if ILNP capable\
    \ itself, that intermediate system\n   might not know which of the packets it\
    \ forwards are part of ILNP\n   sessions.\n   When ILNP is in use, IP Security\
    \ for ILNP also MAY be used to protect\n   stronger protections for ICMP packets\
    \ associated with an ILNP\n   session.  Even in this case, the ILNP Nonce Option\
    \ also MUST be\n   present and MUST contain the correct ILNP Nonce value.  This\n\
    \   simplifies packet processing and enables rapid discard of any forged\n   packets\
    \ from an off-path attacker that lack either the ILNP Nonce\n   Option or the\
    \ correct ILNP Nonce value -- without requiring\n   computationally expensive\
    \ IPsec processing.  Received ICMP messages\n   that are protected by ILNP IP\
    \ Security, but fail the recipient's\n   IPsec checks, MUST be dropped as forgeries.\
    \  If a deployment chooses\n   to use ILNP IPsec ESP to protect its ICMP messages\
    \ and is NOT also\n   using ILNP IPsec AH with those messages, then the ILNP Nonce\
    \ Option\n   MUST be placed in the ILNP packet after the ILNP IPsec ESP header,\n\
    \   rather than before the ILNP IPsec ESP header, to ensure that the\n   Nonce\
    \ Option is protected in transit.\n   Receipt of any ICMP message that is dropped\
    \ or discarded as a forgery\n   SHOULD cause the details of the received forged\
    \ ICMP packet (e.g.,\n   Source and Destination Locators / Source and Destination\
    \ Identifiers\n   / Source and Destination IP Addresses, ICMP message type, receiving\n\
    \   interface, receive date, receive time) to be logged in the receiving\n   system's\
    \ security logs.  Implementations MAY rate-limit such logging\n   in order to\
    \ reduce operational risk of denial-of-service attacks on\n   the system logging\
    \ functions.  The details of system logging are\n   implementation specific.\n"
- title: 11.2.  Forged Identifier Attacks
  contents:
  - "11.2.  Forged Identifier Attacks\n   The ILNP Communication Cache (ILCC) contains\
    \ two unidirectional nonce\n   values (one used in control messages sent by this\
    \ node, a different\n   one used to authenticate messages from the other node)\
    \ for each\n   active or recent ILNP session.  The ILCC also contains the currently\n\
    \   valid set of Locators and set of Identifiers for each correspondent\n   node.\n\
    \   If a received ILNP packet contains valid Identifier values and a\n   valid\
    \ Destination Locator, but contains a Source Locator value that\n   is not present\
    \ in the ILCC, the packet MUST be dropped as an invalid\n   packet and a security\
    \ event SHOULD be logged, UNLESS the packet also\n   contains a Nonce Destination\
    \ Option with the correct value used for\n   packets from the node with that Source\
    \ Identifier to this node.  This\n   prevents an off-path attacker from stealing\
    \ an existing ILNP session.\n"
- title: 12.  Privacy Considerations
  contents:
  - "12.  Privacy Considerations\n   There are no additional privacy issues created\
    \ by ILNP compared to\n   IP.  Please see Section 10 of [RFC6740] for more detailed\
    \ discussion\n   of Privacy Considerations.\n   ILNPv6 supports use of the IPv6\
    \ Privacy Extensions for Stateless\n   Address Autoconfiguration in IPv6 [RFC4941]\
    \ to enable identity\n   privacy (see also Section 2).\n   Location Privacy can\
    \ be provided by locator rewriting techniques as\n   described in Section 7 of\
    \ [RFC6748].\n   A description of various possibilities for obtaining both identity\n\
    \   privacy and location privacy with ILNP can be found in [BAK11].\n"
- title: 13.  Operational Considerations
  contents:
  - "13.  Operational Considerations\n   This section covers various operational considerations\
    \ relating to\n   ILNP, including potential session liveness and reachability\n\
    \   considerations and Key Management considerations.  Again, the\n   situation\
    \ is similar to IP, but it is useful to explain the issues in\n   relation to\
    \ ILNP nevertheless.\n"
- title: 13.1.  Session Liveness and Reachability
  contents:
  - "13.1.  Session Liveness and Reachability\n   For bidirectional flows, such as\
    \ a TCP/ILNP session, each node knows\n   whether the current path in use is working\
    \ by the reception of data\n   packets, acknowledgements, or both.  Therefore,\
    \ as with TCP/IP,\n   TCP/ILNP does not need special path probes.  UDP/ILNP sessions\
    \ with\n   acknowledgements work similarly and do not need special path probes.\n\
    \   In the deployed Internet, the sending node for a UDP/IP session\n   without\
    \ acknowledgements does not know for certain that all packets\n   are received\
    \ by the intended receiving node.  Such UDP/ILNP sessions\n   have the same properties\
    \ as UDP/IP sessions in this respect.  The\n   receiver(s) of such an UDP/ILNP\
    \ session SHOULD send a gratuitous IP\n   packet containing an ILNP Nonce Option\
    \ to the sender, in order to\n   enable the receiver to subsequently send ICMP\
    \ Locator Updates if\n   appropriate [RFC6744].  In this case, UDP/ILNP sessions\
    \ fare better\n   than UDP/IP sessions, still without using network path probes.\n\
    \   A mobile (or multihomed) node may change its connectivity more\n   quickly\
    \ than DNS can be updated.  This situation is unlikely,\n   particularly given\
    \ the widespread use of link-layer mobility\n   mechanisms (e.g., GSM, IEEE 802\
    \ bridging) in combination with\n   network-layer mobility.  However, the situation\
    \ is equivalent to the\n   situation where a traditional IP node is moving faster\
    \ than the\n   Mobile IPv4 or Mobile IPv6 agents/servers can be updated with the\n\
    \   mobile node's new location.  So the issue is not new in any way to\n   ILNP.\
    \  In all cases, Mobile IPv4 and Mobile IPv6 and ILNP, a node\n   moving that\
    \ quickly might be temporarily unreachable until it remains\n   at a given network-layer\
    \ location (e.g., IP subnetwork, ILNP Locator\n   value) long enough for the location\
    \ update mechanisms (for Mobile\n   IPv4, for Mobile IPv6, or ILNP) to catch up.\n\
    \   Another potential issue for IP is what is sometimes called \"Path\n   Liveness\"\
    \ or, in the case of ILNP, \"Locator Liveness\".  This refers\n   to the question\
    \ of whether an IP packet with a particular destination\n   Locator value will\
    \ be able to reach the intended destination network\n   or not, given that some\
    \ otherwise valid paths might be unusable by\n   the sending node (e.g., due to\
    \ security policy or other\n   administrative choice).  In fact, this issue has\
    \ existed in the IPv4\n   Internet for decades.\n   For example, an IPv4 server\
    \ might have multiple valid IP Addresses,\n   each advertised to the world via\
    \ a DNS A record.  However, at a given\n   moment in time, it is possible that\
    \ a given sending node might not be\n   able to use a given (otherwise valid)\
    \ destination IPv4 address in an\n   IP packet to reach that IPv4 server.\n  \
    \ Indeed, for ILNPv6, as the ILNP packet reuses the IPv6 packet header\n   and\
    \ uses IPv6 routing prefixes as Locator values, such liveness\n   considerations\
    \ are no worse than they are for IPv6 today.  For\n   example, for IPv6, if a\
    \ host, H, performs a DNS lookup for an FQDN\n   for remote host F, and receives\
    \ a AAAA RR with IPv6 address F_A, this\n   does not mean necessarily that H can\
    \ reach F on its F_A using its\n   current connectivity, i.e., an IPv6 path may\
    \ not be available from H\n   to F at that point in time.\n   So we see that using\
    \ an Identifier/Locator Split architecture does\n   not create this issue, nor\
    \ does it make this issue worse than it is\n   with the deployed IPv4 Internet.\n\
    \   In ILNP, the same conceptual approach described in [RFC5534] (Locator\n  \
    \ Pair Exploration for SHIM6) can be reused.  Alternatively, an ILNP\n   node\
    \ can reuse the existing IPv4 methods for determining whether a\n   given path\
    \ to the target destination is currently usable, for which\n   existing methods\
    \ leverage transport-layer session state information\n   that the communicating\
    \ end systems are already keeping for transport-\n   layer protocol reasons.\n\
    \   Lastly, it is important to note that the ICMP Locator Update\n   mechanism\
    \ described in [RFC6743] [RFC6745] is a performance\n   optimisation, significantly\
    \ shortening the network-layer handoff time\n   if/when a correspondent changes\
    \ location.  Architecturally, using\n   ICMP is no different from using UDP, of\
    \ course.\n"
- title: 13.2.  Key Management Considerations
  contents:
  - "13.2.  Key Management Considerations\n   ILNP potentially has advantages over\
    \ either form of Mobile IP with\n   respect to key management, given that ILNP\
    \ is using Secure Dynamic\n   DNS Update -- which capability is much more widely\
    \ available today in\n   deployed desktop and server environments (e.g., Microsoft\
    \ Windows,\n   Mac OS X, Linux, other UNIX), as well as being widely available\
    \ today\n   in deployed DNS server software (e.g., Microsoft and the freely\n\
    \   available BIND) and appliances [LA06], than the security enhancements\n  \
    \ needed by either Mobile IPv4 or Mobile IPv6.\n   In the IESG, there is work\
    \ in progress that addresses use of DNS to\n   support key management for entities\
    \ having DNS Fully Qualified Domain\n   Names.\n"
- title: 13.3.  Point-to-Point Router Links
  contents:
  - "13.3.  Point-to-Point Router Links\n   As a special case, for the operational\
    \ reasons described in\n   [RFC6164], ILNPv6 deployments MAY continue to use classic\
    \ IPv6 with a\n   /127 routing prefix on router to router point-to-point links\
    \ (e.g.,\n   SONET/SDH).  Because an ILNPv6 packet and an IPv6 packet are\n  \
    \ indistinguishable for forwarding purposes to a transit router, this\n   should\
    \ not create any operational difficulty for ILNPv6 traffic\n   travelling over\
    \ such links.\n"
- title: 14.  Referrals and Application Programming Interfaces
  contents:
  - "14.  Referrals and Application Programming Interfaces\n   This section is concerned\
    \ with support for using existing (\"legacy\")\n   applications over ILNP, including\
    \ both referrals and Application\n   Programming Interfaces (APIs).\n   ILNP does\
    \ NOT require that well-behaved applications be modified to\n   use a new networking\
    \ API, nor does it require applications be\n   modified to use extensions to an\
    \ existing API.  Existing well-behaved\n   IP applications should work over ILNP\
    \ without modification using\n   existing networking APIs.\n"
- title: 14.1.  BSD Sockets APIs
  contents:
  - "14.1.  BSD Sockets APIs\n   The existing BSD Sockets API can continue to be used\
    \ with ILNP\n   underneath the API.  That API can be implemented in a manner that\n\
    \   hides the underlying protocol changes from the applications.  For\n   example,\
    \ the combination of a Locator and an Identifier can be used\n   with the API\
    \ in the place of an IPv6 address.\n   So it is believed that existing IP address\
    \ referrals can continue to\n   work properly in most cases.  For a rapidly moving\
    \ target node,\n   referrals might break in at least some cases.  The potential\
    \ for\n   referral breakage is necessarily dependent upon the specific\n   application\
    \ and implementation being considered.\n   It is suggested, however, that a new,\
    \ optional, more abstract, C\n   language API be created so that new applications\
    \ may avoid delving\n   into low-level details of the underlying network protocols.\
    \  Such an\n   API would be useful today, even with the existing IPv4 and IPv6\n\
    \   Internet, whether or not ILNP were ever widely deployed.\n"
- title: 14.2.  Java (and Other) APIs
  contents:
  - "14.2.  Java (and Other) APIs\n   Most existing Java APIs already use abstracted\
    \ network programming\n   interfaces, for example, in the java.Net.URL class.\
    \  Because these\n   APIs already hide the low-level network-protocol details\
    \ from the\n   applications, the applications using these APIs (and the APIs\n\
    \   themselves) don't need any modification to work equally well with\n   IPv4,\
    \ IPv6, ILNP, and probably also HIP.\n   Other programming languages, such as\
    \ C++, python and ruby, also\n   provide higher-level APIs that abstract away\
    \ from sockets, even\n   though sockets may be used beneath those APIs.\n"
- title: 14.3.  Referrals in the Future
  contents:
  - "14.3.  Referrals in the Future\n   The approach proposed in [REFERRAL] appears\
    \ to be very suitable for\n   use with ILNP, in addition to being suitable for\
    \ use with the\n   deployed Internet.  Protocols using that approach would not\
    \ need\n   modification to have their referrals work well with IPv4, IPv6, ILNP,\n\
    \   and probably also other network protocols (e.g., HIP).\n   A sensible approach\
    \ to referrals is to use FQDNs, as is commonly done\n   today with web URLs. \
    \ This approach is highly portable across\n   different network protocols, even\
    \ with both the IPv4 Internet or the\n   IPv6 Internet.\n"
- title: 15.  References
  contents:
  - '15.  References

    '
- title: 15.1.  Normative References
  contents:
  - "15.1.  Normative References\n   [IEEE-EUI]   IEEE, \"Guidelines for 64-bit Global\
    \ Identifier (EUI-64)\n                Registration Authority\", <http://standards.ieee.org/\n\
    \                regauth/oui/tutorials/EUI64.html>, IEEE, Piscataway, NJ,\n  \
    \              USA, March 1997.\n   [RFC2119]    Bradner, S., \"Key words for\
    \ use in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC3007]    Wellington, B., \"Secure Domain Name System (DNS)\
    \ Dynamic\n                Update\", RFC 3007, November 2000.\n   [RFC3177]  \
    \  IAB and IESG, \"IAB/IESG Recommendations on IPv6 Address\n                Allocations\
    \ to Sites\", RFC 3177, September 2001.\n   [RFC3587]    Hinden, R., Deering,\
    \ S., and E. Nordmark, \"IPv6 Global\n                Unicast Address Format\"\
    , RFC 3587, August 2003.\n   [RFC4862]    Thomson, S., Narten, T., and T. Jinmei,\
    \ \"IPv6 Stateless\n                Address Autoconfiguration\", RFC 4862, September\
    \ 2007.\n   [RFC4984]    Meyer, D., Ed., Zhang, L., Ed., and K. Fall, Ed.,\n \
    \               \"Report from the IAB Workshop on Routing and\n              \
    \  Addressing\", RFC 4984, September 2007.\n   [RFC6177]    Narten, T., Huston,\
    \ G., and L. Roberts, \"IPv6 Address\n                Assignment to End Sites\"\
    , BCP 157, RFC 6177, March 2011.\n   [RFC6740]    Atkinson, R. and S. Bhatti,\
    \ \"Identifier-Locator Network\n                Protocol (ILNP) Architectural\
    \ Description\", RFC 6740,\n                November 2012.\n   [RFC6742]    Atkinson,\
    \ R., Bhatti, S. and S. Rose, \"DNS Resource\n                Records for the\
    \ Identifier-Locator Network Protocol\n                (ILNP)\", RFC 6742, November\
    \ 2012.\n   [RFC6743]    Atkinson, R. and S. Bhatti, \"ICMPv6 Locator Update\n\
    \                Message\", RFC 6743, November 2012.\n   [RFC6744]    Atkinson,\
    \ R. and S. Bhatti, \"IPv6 Nonce Destination\n                Option for the Identifier-Locator\
    \ Network Protocol for\n                IPv6 (ILNPv6)\", RFC 6744, November 2012.\n\
    \   [RFC6745]    Atkinson, R. and S. Bhatti,  \"ICMP Locator Update\n        \
    \        Message for the Identifier-Locator Network Protocol for\n           \
    \     IPv4 (ILNPv4)\", RFC 6745, November 2012.\n   [RFC6746]    Atkinson, R.\
    \ and S.Bhatti, \"IPv4 Options for the\n                Identifier-Locator Network\
    \ Protocol (ILNP)\", RFC 6746,\n                November 2012.\n   [RFC6747] \
    \   Atkinson, R. and S. Bhatti, \"Address Resolution Protocol\n              \
    \  (ARP) Extension for the Identifier-Locator Network\n                Protocol\
    \ for IPv4 (ILNPv4)\", RFC 6747, November 2012.\n"
- title: 15.2.  Informative References
  contents:
  - "15.2.  Informative References\n   [BA11]       Bhatti, S. and R. Atkinson, \"\
    Reducing DNS Caching\",\n                Proceedings of IEEE Global Internet Symposium\
    \ (GI2011),\n                Shanghai, P.R. China, 15 April 2011.\n   [BAK11]\
    \      Bhatti, S.N., Atkinson, R., and J. Klemets, \"Integrating\n           \
    \     Challenged Networks\", Proceedings of IEEE Military\n                Communications\
    \ Conference (MILCOM), IEEE, Baltimore, MD,\n                USA, Nov 2011.\n\
    \   [LA06]       Liu, C. and P. Albitz, \"DNS and Bind\", 5th Edition,\n     \
    \           O'Reilly & Associates, Sebastopol, CA, USA, 2006.  ISBN\n        \
    \        0-596-10057-4.\n   [PHG02]      Pappas, A., Hailes, S. and R. Giaffreda,\
    \ \"Mobile Host\n                Location Tracking through DNS\", Proceedings\
    \ of IEEE\n                London Communications Symposium, IEEE, September 2002,\n\
    \                London, England, UK.\n   [SBK02]      Snoeren, A., Balakrishnan,\
    \ H. and M. Frans Kaashoek,\n                \"Reconsidering Internet Mobility\"\
    , Proceedings of 8th\n                Workshop on Hot Topics in Operating Systems,\
    \ IEEE,\n                Elmau, Germany, May 2001.\n   [REFERRAL]   Carpenter,\
    \ B., Boucadair, M., Halpern, J., Jiang, S.,\n                and K. Moore, \"\
    A Generic Referral Object for Internet\n                Entities\", Work in Progress,\
    \ October 2009.\n   [RFC826]     Plummer, D., \"Ethernet Address Resolution Protocol:\
    \ Or\n                Converting Network Protocol Addresses to 48.bit Ethernet\n\
    \                Address for Transmission on Ethernet Hardware\", STD 37,\n  \
    \              RFC 826, November 1982.\n   [RFC3972]    Aura, T., \"Cryptographically\
    \ Generated Addresses (CGA)\",\n                RFC 3972, March 2005.\n   [RFC4291]\
    \    Hinden, R. and S. Deering, \"IP Version 6 Addressing\n                Architecture\"\
    , RFC 4291, February 2006.\n   [RFC4581]    Bagnulo, M. and J. Arkko, \"Cryptographically\
    \ Generated\n                Addresses (CGA) Extension Field Format\", RFC 4581,\n\
    \                October 2006.\n   [RFC4941]    Narten, T., Draves, R., and S.\
    \ Krishnan, \"Privacy\n                Extensions for Stateless Address Autoconfiguration\
    \ in\n                IPv6\", RFC 4941, September 2007.\n   [RFC4982]    Bagnulo,\
    \ M. and J. Arkko, \"Support for Multiple Hash\n                Algorithms in\
    \ Cryptographically Generated Addresses\n                (CGAs)\", RFC 4982, July\
    \ 2007.\n   [RFC5534]    Arkko, J. and I. van Beijnum, \"Failure Detection and\n\
    \                Locator Pair Exploration Protocol for IPv6 Multihoming\",\n \
    \               RFC 5534, June 2009.\n   [RFC6164]    Kohno, M., Nitzan, B., Bush,\
    \ R., Matsuzaki, Y., Colitti,\n                L., and T. Narten, \"Using 127-Bit\
    \ IPv6 Prefixes on\n                Inter-Router Links\", RFC 6164, April 2011.\n\
    \   [RFC6748]    Atkinson, R. and S. Bhatti, \"Optional Advanced\n           \
    \     Deployment Scenarios for the Identifier-Locator Network\n              \
    \  Protocol (ILNP)\", RFC 6748, November 2012.\n"
- title: 16.  Acknowledgements
  contents:
  - "16.  Acknowledgements\n   Steve Blake, Stephane Bortzmeyer, Mohamed Boucadair,\
    \ Noel Chiappa,\n   Wes George, Steve Hailes, Joel Halpern, Mark Handley, Volker\
    \ Hilt,\n   Paul Jakma, Dae-Young Kim, Tony Li, Yakov Rehkter, Bruce Simpson,\n\
    \   Robin Whittle and John Wroclawski (in alphabetical order) provided\n   review\
    \ and feedback on earlier versions of this document.  Steve\n   Blake provided\
    \ an especially thorough review of an early version of\n   the entire ILNP document\
    \ set, which was extremely helpful.  We also\n   wish to thank the anonymous reviewers\
    \ of the various ILNP papers for\n   their feedback.\n   Roy Arends provided expert\
    \ guidance on technical and procedural\n   aspects of DNS issues.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   RJ Atkinson\n   Consultant\n   San Jose, CA 95125\n  \
    \ USA\n   EMail: rja.lists@gmail.com\n   SN Bhatti\n   School of Computer Science\n\
    \   University of St Andrews\n   North Haugh, St Andrews\n   Fife  KY16 9SX\n\
    \   Scotland, UK\n   EMail: saleem@cs.st-andrews.ac.uk\n"
