- title: __initial_text__
  contents:
  - '                 Defending TCP Against Spoofing Attacks

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   Recent analysis of potential attacks on core Internet infrastructure\n\
    \   indicates an increased vulnerability of TCP connections to spurious\n   resets\
    \ (RSTs), sent with forged IP source addresses (spoofing).  TCP\n   has always\
    \ been susceptible to such RST spoofing attacks, which were\n   indirectly protected\
    \ by checking that the RST sequence number was\n   inside the current receive\
    \ window, as well as via the obfuscation of\n   TCP endpoint and port numbers.\
    \  For pairs of well-known endpoints\n   often over predictable port pairs, such\
    \ as BGP or between web servers\n   and well-known large-scale caches, increases\
    \ in the path bandwidth-\n   delay product of a connection have sufficiently increased\
    \ the receive\n   window space that off-path third parties can brute-force generate\
    \ a\n   viable RST sequence number.  The susceptibility to attack increases\n\
    \   with the square of the bandwidth, and thus presents a significant\n   vulnerability\
    \ for recent high-speed networks.  This document\n   addresses this vulnerability,\
    \ discussing proposed solutions at the\n   transport level and their inherent\
    \ challenges, as well as existing\n   network level solutions and the feasibility\
    \ of their deployment.\n   This document focuses on vulnerabilities due to spoofed\
    \ TCP segments,\n   and includes a discussion of related ICMP spoofing attacks\
    \ on TCP\n   connections.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Background ......................................................4\n  \
    \    2.1. Review of TCP Windows ......................................5\n    \
    \  2.2. Recent BGP Attacks Using TCP RSTs ..........................6\n      2.3.\
    \ TCP RST Vulnerability ......................................6\n      2.4. What\
    \ Changed - the Ever-Opening Advertised Receive Window ..7\n   3. Proposed Solutions\
    \ and Mitigations .............................10\n      3.1. Transport Layer\
    \ Solutions .................................10\n           3.1.1. TCP MD5 Authentication\
    \ .............................11\n           3.1.2. TCP RST Window Attenuation\
    \ .........................11\n           3.1.3. TCP Timestamp Authentication\
    \ .......................12\n           3.1.4. Other TCP Cookies ..................................13\n\
    \           3.1.5. Other TCP Considerations ...........................13\n  \
    \         3.1.6. Other Transport Protocol Solutions .................14\n    \
    \  3.2. Network Layer (IP) Solutions ..............................14\n      \
    \     3.2.1. Address Filtering ..................................15\n        \
    \   3.2.2. IPsec ..............................................16\n   4. ICMP\
    \ ...........................................................17\n   5. Issues\
    \ .........................................................18\n      5.1. Transport\
    \ Layer (e.g., TCP) ...............................18\n      5.2. Network Layer\
    \ (IP) ........................................19\n      5.3. Application Layer\
    \ .........................................21\n      5.4. Link Layer ................................................21\n\
    \      5.5. Issues Discussion .........................................21\n  \
    \ 6. Security Considerations ........................................22\n   7.\
    \ Conclusions ....................................................23\n   8. Acknowledgments\
    \ ................................................23\n   9. Informative References\
    \ .........................................24\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Analysis of the Internet infrastructure has recently demonstrated\
    \ a\n   new version of a vulnerability in BGP connections between core\n   routers\
    \ using an attack based on RST spoofing from off-path attackers\n   [9][10][48].\
    \  The attack itself is not new, having been documented\n   nearly six years earlier\
    \ [20].  Such connections, typically using\n   TCP, can be susceptible to off-path\
    \ third-party reset (RST) segments\n   with forged source addresses (spoofed),\
    \ which terminate the TCP\n   connection.  BGP routers react to a terminated TCP\
    \ connection in\n   various ways, which can amplify the impact of an attack, ranging\
    \ from\n   restarting the connection to deciding that the other router is\n  \
    \ unreachable and thus flushing the BGP routes [37].  This sort of\n   attack\
    \ affects other protocols besides BGP, involving any long-lived\n   connection\
    \ between well-known endpoints.  The impact on the Internet\n   infrastructure\
    \ can be substantial (especially for the BGP case), and\n   warrants immediate\
    \ attention.\n   TCP, like many other protocols, can be susceptible to these off-path\n\
    \   third-party spoofing attacks.  Such attacks rely on the increase of\n   commodity\
    \ platforms supporting public access to previously privileged\n   resources, such\
    \ as system-level (i.e., root) access.  Given such\n   access, it is trivial for\
    \ anyone to generate a packet with any header\n   desired.\n   This, coupled with\
    \ the lack of sufficient address filtering to drop\n   such spoofed traffic, can\
    \ increase the potential for off-path third-\n   party spoofing attacks [9][10][48].\
    \  Proposed solutions include the\n   deployment of existing Internet network\
    \ and transport security as\n   well as modifications to transport protocols that\
    \ reduce its\n   vulnerability to generated attacks [13][15][20][36][46].\n  \
    \ One way to defeat spoofing is to validate the segments of a\n   connection,\
    \ either at the transport level or the network level.  TCP\n   with MD5 extensions\
    \ provides this authentication at the transport\n   level, and IPsec provides\
    \ authentication at the network level\n   [20][24][27].  In both cases, their\
    \ deployment overhead may be\n   prohibitive, e.g., it may not be feasible for\
    \ public services, such\n   as web servers, to be configured with the appropriate\
    \ certificate\n   authorities of large numbers of peers (for IPsec using the Internet\n\
    \   Key Exchange Protocol (IKE)), or shared secrets (for IPsec in\n   shared-secret\
    \ mode, or TCP/MD5), because many clients may need to be\n   configured rapidly\
    \ without external assistance.  Services located on\n   public web servers connecting\
    \ to large-scale caches or BGP with\n   larger numbers of peers can fall into\
    \ this category.\n   The remainder of this document outlines the recent attack\
    \ scenario in\n   detail and describes and compares a variety of solutions, including\n\
    \   existing solutions based on TCP/MD5 and IPsec, as well as recently\n   proposed\
    \ solutions, including modifications to TCP's RST processing\n   [36], modifications\
    \ to TCP's timestamp processing [34], and\n   modifications to IPsec and TCP/MD5\
    \ keying [45].  This document\n   focuses on spoofing of TCP segments, although\
    \ a discussion of related\n   spoofing of ICMP packets based on spoofed TCP contents\
    \ is also\n   discussed.\n   Note that the description of these attacks is not\
    \ new; attacks using\n   RSTs on BGP have been known since 1998, and were the\
    \ reason for the\n   development of TCP/MD5 [20].  The recent attack scenario\
    \ was first\n   documented by Convery at a NANOG (North American Network Operators'\n\
    \   Group) meeting in 2003, but that analysis assumed the entire sequence\n  \
    \ space (2^32 packets) needed to be covered for an attack to succeed\n   [10].\
    \  Watson's more detailed analysis discovered that a single\n   packet anywhere\
    \ in the current window could succeed at an attack\n   [48].  This document adds\
    \ the observation that susceptibility to\n   attack is directly proportional to\
    \ the square of bandwidth, due to\n   the coupling between the linear increase\
    \ in receive window size and\n   linear increase in rate of a potential attack,\
    \ as well as comparing\n   the variety of more recent proposals, including modifications\
    \ to TCP,\n   use of IPsec, and use of TCP/MD5 to resist such attacks.\n"
- title: 2.  Background
  contents:
  - "2.  Background\n   The recent analysis of potential attacks on BGP has again\
    \ raised the\n   issue of TCP's vulnerability to off-path third-party spoofing\
    \ attacks\n   [9][10][48].  A variety of such attacks have been known for several\n\
    \   years, including sending RSTs, SYNs, and even ACKs in an attempt to\n   affect\
    \ an existing connection or to load down servers.  These attacks\n   often combine\
    \ external knowledge (e.g., to indicate the IP addresses\n   to attack, the destination\
    \ port number, and sometimes the Initial\n   Sequence Number (ISN)) with brute-force\
    \ capabilities enabled by\n   modern computers and network bandwidths (e.g., to\
    \ scan all source\n   ports or an entire window space).  Overall, such attacks\
    \ are\n   countered by the use of some form of authentication at the network\n\
    \   (e.g., IPsec), transport (e.g., SYN cookies, TCP/MD5), or other\n   layers.\
    \  TCP already includes a weak form of such authentication in\n   its check of\
    \ segment sequence numbers against the current receiver\n   window.  Increases\
    \ in the bandwidth-delay product for certain long\n   connections have sufficiently\
    \ weakened this type of weak\n   authentication to make reliance on it inadvisable.\n"
- title: 2.1.  Review of TCP Windows
  contents:
  - "2.1.  Review of TCP Windows\n   Before proceeding, it is useful to review the\
    \ terminology and\n   components of TCP's windowing algorithm.  TCP connections\
    \ have three\n   kinds of windows [1][35]:\n   o  Send window (SND.WND): the latest\
    \ send window size.\n   o  Receive window (RCV.WND): the latest advertised receive\
    \ window\n      size.\n   o  Congestion window (CWND): the window determined by\
    \ congestion\n      feedback that limits how much of RCV.WND can be in-flight\
    \ in a\n      round-trip time.\n   For TCP connections in most modern implementations,\
    \ SND.WND and\n   RCV.WND are the size of the corresponding send and receive socket\n\
    \   buffers, and are configurable using socket buffer resizing commands.\n   CWND\
    \ determines how much data can be in transit in a round-trip time,\n   SND.WND\
    \ determines how much data the sender is willing to store on\n   its side for\
    \ possible retransmission due to loss, and RCV.WND\n   determines the ability\
    \ of the receiver to accommodate that loss and\n   reorder received packets. \
    \ CWND never grows beyond RCV.WND.\n   High bandwidth-delay product networks need\
    \ CWND to be sufficiently\n   large to accommodate as much data as can be in transit\
    \ in a round\n   trip time; otherwise, their performance will suffer.  As a result,\
    \ it\n   is recommended that users and various automatic programs increase\n \
    \  RCV.WND to at least the size of bandwidth*delay (the bandwidth-delay\n   product)\
    \ [23][38].\n   As the bandwidth-delay product of the network increases, however,\n\
    \   such increases in the advertised receive window can cause increased\n   susceptibility\
    \ to spoofing attacks, as the remainder of this document\n   shows.  This assumes,\
    \ however, that the receive window size (e.g.,\n   via increased receive socket\
    \ buffer configuration) is increased with\n   the increased bandwidth-delay product;\
    \ if not, then connection\n   performance will degrade, but susceptibility to\
    \ spoofing attacks will\n   increase only linearly (with the rate at which the\
    \ attacker can send\n   spoofed packets), not as the square of the bandwidth.\
    \  Note that\n   either increase depends on the receive window itself, and is\n\
    \   independent of the congestion state or amount of data transmitted.\n"
- title: 2.2.  Recent BGP Attacks Using TCP RSTs
  contents:
  - "2.2.  Recent BGP Attacks Using TCP RSTs\n   BGP represents a particular vulnerability\
    \ to spoofing attacks because\n   it uses TCP connectivity to infer routability,\
    \ so losing a TCP\n   connection with a BGP peer can result in the flushing of\
    \ routes to\n   that peer [37].\n   Until six years ago, such connections were\
    \ assumed difficult to\n   attack because they were described by a few comparatively\
    \ obscure\n   parameters [20].  Most TCP connections are protected by multiple\n\
    \   levels of obfuscation except at the endpoints of the connection:\n   o  Both\
    \ endpoint addresses are usually not well-known; although\n      server addresses\
    \ are advertised, clients are somewhat anonymous.\n   o  Both port numbers are\
    \ usually not well-known; the server's is\n      usually advertised (representing\
    \ the service), but the client's is\n      typically sufficiently unpredictable\
    \ to an off-path third-party.\n   o  Valid sequence number space is not well-known.\n\
    \   o  Connections are relatively short-lived and valid sequence space\n     \
    \ changes, so any attempt to guess (e.g., by external knowledge or\n      brute\
    \ force) the above information is unlikely to be useful.\n   BGP represents an\
    \ exception to the above criteria (though not the\n   only case).  Both endpoints\
    \ can be well-known, or guessed using hints\n   from part of an AS path.  The\
    \ destination port is typically fixed to\n   indicate the BGP service.  The source\
    \ port used by a BGP router is\n   sometimes fixed and advertised to enable firewall\
    \ configuration; even\n   when not fixed, there are only approximately 65,000\
    \ valid source\n   ports, which thus may be exhaustively attacked.  Connections\
    \ are\n   long- lived, and, as noted before, some BGP implementations interpret\n\
    \   successive TCP connection failures as routing failures, discarding\n   the\
    \ corresponding routing information.  In addition, the valid\n   sequence number\
    \ space once thought to provide some protection has\n   been significantly weakened\
    \ by increasing advertised receive window\n   sizes.\n"
- title: 2.3.  TCP RST Vulnerability
  contents:
  - "2.3.  TCP RST Vulnerability\n   TCP has a known vulnerability to third-party\
    \ spoofed segments.  SYN\n   flooding consumes server resources in half-open connections,\n\
    \   affecting the server's ability to open new connections [4][11].  ACK\n   spoofing\
    \ can cause connections to transmit too much data too quickly,\n   creating network\
    \ congestion and segment loss, causing connections to\n   slow to a crawl.  In\
    \ the most recent attacks on BGP, RSTs cause\n   connections to be dropped.  As\
    \ noted earlier, some BGP\n   implementations interpret TCP connection termination,\
    \ or a series of\n   such failures, as a network failure [37].  This causes routers\
    \ to\n   drop the BGP routing information already exchanged, in addition to\n\
    \   inhibiting their ongoing exchanges, thus amplifying the impact of the\n  \
    \ attack.  The result can affect routing paths throughout the Internet.\n   The\
    \ dangerous effects of RSTs on TCP have been known for many years,\n   even when\
    \ used by the legitimate endpoints of a connection.  TCP RSTs\n   cause the receiver\
    \ to drop all connection state; because the source\n   is not required to maintain\
    \ a TIME_WAIT state, such a RST can cause\n   premature reuse of address/port\
    \ pairs, potentially allowing segments\n   from a previous connection to contaminate\
    \ the data of a new\n   connection, known as TIME_WAIT assassination [8].  In\
    \ this case,\n   assassination occurs inadvertently as the result of duplicate\n\
    \   segments from a legitimate source, and can be avoided by blocking RST\n  \
    \ processing while in TIME_WAIT.  However, assassination can be useful\n   to\
    \ deliberately reduce the state held at servers; this requires that\n   the source\
    \ of the RSTs go into TIME_WAIT state to avoid such hazards,\n   and that RSTs\
    \ are not blocked in the TIME_WAIT state [12].\n   Firewalls and load balancers,\
    \ so-called 'middleboxes', sometimes emit\n   RSTs on behalf of transited connections\
    \ to optimize server\n   performance, as noted in RFC 3360 [14].  This is effectively\
    \ an on-\n   path RST attack in which the RSTs are sent for benign or beneficial\n\
    \   intent.  There are numerous hazards with such use of RSTs, outlined\n   in\
    \ that RFC.\n"
- title: 2.4.  What Changed - the Ever-Opening Advertised Receive Window
  contents:
  - "2.4.  What Changed - the Ever-Opening Advertised Receive Window\n   RSTs represent\
    \ a hazard to TCP, especially when completely\n   unvalidated.  Fortunately, there\
    \ are a number of obfuscation\n   mechanisms that make it difficult for off-path\
    \ third parties to forge\n   (spoof) valid RSTs, as noted earlier.  We have already\
    \ shown it is\n   easy to learn both endpoint addresses and ports for some protocols,\n\
    \   notably BGP.  The final obfuscation is the segment sequence number.\n   TCP\
    \ segments include a sequence number, which enables out-of-order\n   receiver\
    \ processing as well as duplicate detection.  The sequence\n   number space is\
    \ also used to manage congestion, and indicates the\n   index of the next byte\
    \ to be transmitted or received.  For RSTs, this\n   is relevant because legitimate\
    \ RSTs use the next sequence number in\n   the transmitter window, and the receiver\
    \ checks that incoming RSTs\n   have a sequence number in the expected receive\
    \ window.  Such\n   processing is intended to eliminate duplicate segments (somewhat\
    \ moot\n   for RSTs, though), and to drop RSTs that were part of previous\n  \
    \ connections.\n   TCP uses two window mechanisms, a primary mechanism for reordering\n\
    \   and congestion control (which uses a space of 32 bits), and a\n   secondary\
    \ mechanism that scales this window [23][35].  The valid\n   advertised receive\
    \ window is a fraction, not to exceed approximately\n   half, of this space, or\
    \ ~2 billion (2 * 10^9, i.e., 2E9 or 2 U.S.\n   billion).  Under typical configurations,\
    \ the majority of TCP\n   connections open to a very small fraction of this space,\
    \ e.g.,\n   10,000-60,000(approximately 5-100 segments).  This is because the\n\
    \   advertised receive window typically matches the receive socket buffer\n  \
    \ size.  It is recommended that this buffer be tuned to match the needs\n   of\
    \ the connection, either manually or by automatic external means\n   [38].\n \
    \  On a low-loss path, the advertised receive window should be\n   configured\
    \ to match the path bandwidth-delay product, including\n   buffering delays (assume\
    \ 1 packet/hop) [38].  Many paths in the\n   Internet have end-to-end bandwidths\
    \ of under 1 Mbps, latencies under\n   100 ms, and are under 15 hops, resulting\
    \ in fairly small advertised\n   receive windows as above (under 35,000 bytes).\
    \  Under these\n   conditions, and further assuming that the initial sequence\
    \ number is\n   suitably (pseudo-randomly) chosen, a valid guessed sequence number\n\
    \   would have odds of 1 in 57,000 of falling within the advertised\n   receive\
    \ window.  Put differently, a blind (i.e., off-path) attacker\n   would need to\
    \ send 57,000 RSTs with suitably spaced sequence number\n   guesses within one\
    \ round-trip time to successfully reset a\n   connection.  At 1 Mbps, 57,000 (40\
    \ byte) RSTs would take only 20\n   seconds to transmit, but this presumes that\
    \ both IP addresses and\n   both ports are known.  Absent knowledge of the source\
    \ port, an off-\n   path spoofer would need to try at least the entire range of\
    \ 49152-\n   65535, or 16,384 different ports, resulting in an attack that would\n\
    \   take over 91 hours.  Because most TCP connections are comparatively\n   short-lived,\
    \ even this moderate variation in the source port is\n   sufficient for such environments,\
    \ although further port randomization\n   may be recommended [29].\n   Recent\
    \ use of high bandwidth paths of 10 Gbps and higher results in\n   bandwidth-delay\
    \ products over 125 MB -- approximately 1/10 of TCP's\n   overall maximum advertised\
    \ receive window size (i.e., assuming the\n   receive socket buffers are increased\
    \ as much as possible) excluding\n   scale, assuming the receiver allocates sufficient\
    \ buffering (as\n   discussed in Section 2).  Even under networks that are ten\
    \ times\n   slower (1 Gbps), the active advertised receive window covers 1/100th\n\
    \   of the overall window size.  At these speeds, it takes only 10-100\n   packets,\
    \ or less than 32 microseconds, to correctly guess a valid\n   sequence number\
    \ and kill a connection.  A table of corresponding\n   exposure to various amounts\
    \ of RSTs is shown below, for various line\n   rates, assuming the more conventional\
    \ 100-ms latencies (though even\n   100 ms is large for BGP cases):\n        \
    \  BW       BW*delay     RSTs needed     Time needed\n      ------------------------------------------------------------\n\
    \       10 Gbps   125       MB          35     1 us (microsecond)\n        1 Gbps\
    \    12.5     MB         344   110 us\n      100 Mbps     1.25    MB       3,436\
    \    10 ms (millisecond)\n       10 Mbps     0.125   MB      34,360     1 second\n\
    \        1 Mbps     0.0125  MB     343,598     2 minutes\n      100 Kbps     0.00125\
    \ MB   3,435,974     3 hours\n                Figure 1: Time needed to kill a\
    \ connection\n   This table demonstrates that the effect of bandwidth on the\n\
    \   vulnerability is squared; for every increase in bandwidth, there is a\n  \
    \ linear decrease in the number of sequence number guesses needed, as\n   well\
    \ as a linear decrease in the time needed to send a set of\n   guesses.  Notably,\
    \ as inter-router link bandwidths approach 1 Mbps,\n   an 'exhaustive' attack\
    \ becomes practical.  Checking that the RST\n   sequence number is somewhere in\
    \ the advertised receive window, out of\n   the overall maximum receive window\
    \ (2^32), is an insufficient\n   obfuscation.\n   Note that this table makes a\
    \ number of assumptions:\n   1. The overall bandwidth-delay product is relatively\
    \ fixed.\n   2. Traffic losses are negligible (insufficient to affect the\n  \
    \    congestion window over the duration of most of the connection).\n   3. The\
    \ advertised receive window is a large fraction of the overall\n      maximum\
    \ receive window size, e.g., because the receive socket\n      buffers are set\
    \ to match a large bandwidth-delay product.\n   4. The attack bandwidth is similar\
    \ to the end-to-end path bandwidth.\n   Of these assumptions, the last two are\
    \ more notable.  The issue of\n   receive socket buffers was discussed in Section\
    \ 2.  Figure 1\n   summarized the time to a successful attack based on large advertised\n\
    \   receive windows, but many current commercial routers have limits of\n   128\
    \ KB for large devices, 32 KB for medium, and as little as 4 KB for\n   modest\
    \ ones.  Figure 2 shows the time and bandwidths needed to\n   accomplish an attack\
    \ on BGP sessions in the time shown for 100-ms\n   latencies; for even short-range\
    \ network latencies (10 ms), these\n   sessions can be still be attacked over\
    \ short timescales (minutes to\n   hours).\n                   Receive\n     \
    \     BW     Buffer Size  RSTs needed     Time needed\n      ------------------------------------------------------------\n\
    \       10 Mbps     0.128 MB        33,555     1 second\n        3 Mbps     0.032\
    \ MB       134,218    40 seconds\n      300 Kbps     0.004 MB     1,073,742  \
    \   1 hour\n      Figure 2: Time needed to kill a connection with limited buffers\n\
    \   The issue of the attack bandwidth is considered reasonable as\n   follows:\n\
    \   1. RSTs are substantially easier to send than data; they can be\n      precomputed\
    \ and they are smaller than data packets (40 bytes).\n   2. Although susceptible\
    \ connections use somewhat less ubiquitous\n      high-bandwidth paths, the attack\
    \ may be distributed, at which\n      point only the ingress link of the attack\
    \ is the primary\n      limitation.\n   3. For the purposes of the above table,\
    \ we assume that the ingress at\n      the attack has the same bandwidth as the\
    \ path, as an\n      approximation.\n   The previous sections discussed the nature\
    \ of the recent attacks on\n   BGP due to the vulnerability of TCP to RST spoofing\
    \ attacks, due\n   largely to recent increases in the fraction of the TCP advertised\n\
    \   receive window space in use for a single, long-lived connection.\n"
- title: 3.  Proposed Solutions and Mitigations
  contents:
  - "3.  Proposed Solutions and Mitigations\n   TCP currently authenticates received\
    \ RSTs using the address and port\n   pair numbers, and checks that the sequence\
    \ number is inside the valid\n   receiver window.  The previous section demonstrated\
    \ how TCP has\n   become more vulnerable to RST spoofing attacks due to the increases\n\
    \   in the receive window size.  There are a number of current and\n   proposed\
    \ solutions to this vulnerability, all attempting to provide\n   evidence that\
    \ a received RST is legitimate.\n"
- title: 3.1.  Transport Layer Solutions
  contents:
  - "3.1.  Transport Layer Solutions\n   The transport layer represents the last place\
    \ that segments can be\n   authenticated before they affect connection management.\
    \  TCP has a\n   variety of current and proposed mechanisms to increase the\n\
    \   authentication of segments, protecting against both off-path and on-\n   path\
    \ third-party spoofing attacks.  Other transport protocols, such\n   as SCTP and\
    \ DCCP, also have limited antispoofing mechanisms.\n"
- title: 3.1.1.  TCP MD5 Authentication
  contents:
  - "3.1.1.  TCP MD5 Authentication\n   An extension to TCP supporting MD5 authentication\
    \ was developed in\n   1998 specifically to authenticate BGP connections (although\
    \ it can be\n   used for any TCP connection) [20].  The extension relies on a\
    \ pre-\n   shared secret key to authenticate the entire TCP segment, including\n\
    \   the data, TCP header, and TCP pseudo-header (certain fields of the IP\n  \
    \ header).  All segments are protected, including RSTs, to be accepted\n   only\
    \ when their signature matches.  This option, although widely\n   deployed in\
    \ Internet routers, is considered undeployable for\n   widespread use because\
    \ the need for pre-shared keys [3][30].  It\n   further is considered computationally\
    \ expensive for either hosts or\n   routers due to the overhead of MD5 [43][44].\n\
    \   There are also concerns about the use of MD5 due to recent collision-\n  \
    \ based attacks [22].  Similar concerns exist for SHA-1, and the IETF\n   is currently\
    \ evaluating how these attacks impact the recommendation\n   for using these hashes,\
    \ both in TCP/MD5 and in the IPsec suite.  For\n   the purposes of this discussion,\
    \ the particular algorithm used in\n   either protocol suite is not the focus,\
    \ and there is ongoing work to\n   allow TCP/MD5 to evolve to a more general TCP\
    \ security option\n   [6][47].\n"
- title: 3.1.2.  TCP RST Window Attenuation
  contents:
  - "3.1.2.  TCP RST Window Attenuation\n   A recent proposal extends TCP to further\
    \ constrain received RST to\n   match the expected next sequence number [36].\
    \  This restores TCP's\n   resistance to spurious RSTs, effectively limiting the\
    \ receive window\n   for RSTs to a single number.  As a result, an attacker would\
    \ need to\n   send 2^32 different packets to brute-force guess the sequence number\n\
    \   (worst case, the average would be half that); this makes TCP's\n   vulnerability\
    \ to attack independent of the size of the receive window\n   (RCV.WND).  The\
    \ extension further modifies the RST receiver to react\n   to incorrectly-numbered\
    \ RSTs, by sending a zero-length ACK.  If the\n   RST source is legitimate, upon\
    \ receipt of an ACK, the closed source\n   would presumably emit a RST with the\
    \ sequence number matching the\n   ACK, correctly resetting the intended recipient.\
    \  This modification\n   changes TCP's control processing, adding to its complexity\
    \ and thus\n   potentially affecting its correctness (in contrast to adding MD5\n\
    \   signatures, which is orthogonal to TCP control processing\n   altogether).\
    \  For example, there may be complications between RSTs of\n   different connections\
    \ between the same pair of endpoints because RSTs\n   flush the TIME-WAIT (as\
    \ mentioned earlier).  Further, this proposal\n   modifies TCP so that, under\
    \ some circumstances, a RST causes a reply\n   (an ACK), in violation of generally\
    \ accepted practice, if not gentle\n   recommendation -- although this can be\
    \ omitted, allowing timeouts to\n   suffice.  The advantage to this proposal is\
    \ that it can be deployed\n   incrementally and has benefit to the endpoint on\
    \ which it is\n   deployed.  The other advantage to this proposal is that the\
    \ window\n   attenuation described here makes the vulnerability to spoofed RST\n\
    \   packets independent of the size of the receive window.\n   A variant of this\
    \ proposal uses a different value to attenuate the\n   window of viable RSTs.\
    \  It requires RSTs to carry the initial\n   sequence number rather than the next\
    \ expected sequence number, i.e.,\n   the value negotiated on connection establishment\
    \ [42][49].  This\n   proposal has the advantage of using an explicitly negotiated\
    \ value,\n   but at the cost of changing the behavior of an unmodified endpoint\
    \ to\n   a currently valid RST.  It would thus be more difficult, without\n  \
    \ additional mechanism, to deploy incrementally.\n   Another variant of this proposal\
    \ involves increasing TCP's window\n   space, rather than decreasing the valid\
    \ range for RSTs, i.e.,\n   increasing the sequence space from 32 bits to 64 bits.\
    \  This has the\n   equivalent effect -- the ratio of the valid sequence numbers\
    \ for any\n   segment to the overall sequence number space is significantly\n\
    \   reduced.  The use of the larger space, as with current schemes to\n   establish\
    \ weak authentication using initial sequence numbers (ISNs),\n   is contingent\
    \ on using suitably random values for the ISN.  Such\n   randomness adds additional\
    \ complexity to TCP both in specification\n   and implementation, and provides\
    \ only very weak authentication.  Such\n   a modification is not obviously backward\
    \ compatible, and would be\n   thus difficult to deploy.\n   A converse variant\
    \ of increasing TCP's window space is to decrease\n   the receive window (RCV.WND)\
    \ explicitly, which would further reduce\n   the effectiveness of spoofed RSTs\
    \ with random sequence numbers.  This\n   alternative may reduce the throughput\
    \ of the connection, if the\n   advertised receive window is smaller than the\
    \ bandwidth-delay product\n   of the connection.\n"
- title: 3.1.3.  TCP Timestamp Authentication
  contents:
  - "3.1.3.  TCP Timestamp Authentication\n   Another way to authenticate TCP segments\
    \ is via its timestamp option,\n   using the value as a sort of authentication\
    \ [34].  This requires that\n   the receiver TCP discard segments whose timestamp\
    \ is outside the\n   accepted window, which is derived from the timestamps of\
    \ other\n   packets from the same connection.  This technique uses an existing\n\
    \   TCP option, but also requires modified TCP control processing (with\n   the\
    \ same caveats) and may be difficult to deploy incrementally\n   without further\
    \ modifications.  Additionally, the timestamp value may\n   be easier to guess\
    \ because it can be derived predictably, either\n   assuming it represents actual\
    \ time at the host, or by probing the\n   host using unrelated benign traffic.\n"
- title: 3.1.4.  Other TCP Cookies
  contents:
  - "3.1.4.  Other TCP Cookies\n   All of the above techniques are variants of cookies,\
    \ otherwise\n   meaningless data whose value is used to validate the packet. \
    \ In the\n   case of MD5 checksums, the cookie is computed based on a shared\n\
    \   secret.  Note that even a signature can be guessed, and presents a 1\n   in\
    \ 2^(signature length) probability of attack.  The primary\n   difference is that\
    \ MD5 signatures are effectively one-time cookies,\n   not predictable based on\
    \ on-path snooping, because they are dependent\n   on packet data and thus do\
    \ not repeat.  Window attenuation sequence\n   numbers can be guessed by snooping\
    \ the sequence number of current\n   packets of an existing connection, and timestamps\
    \ can be guessed even\n   less directly, either by separate benign connections\
    \ or by assuming\n   they roughly correlate to local time.  These variants of\
    \ cookies are\n   similar in spirit to TCP SYN cookies, again patching a vulnerability\n\
    \   to off-path third-party spoofing attacks based on a (fairly weak,\n   excepting\
    \ MD5) form of authentication.  Another form of cookie is the\n   source port\
    \ itself, which can be randomized but provides only 16 bits\n   of protection\
    \ (65,000 combinations), which may be exhaustively\n   attacked.  This can be\
    \ combined with destination port randomization\n   as well, but that would require\
    \ a separate coordination mechanism (so\n   both parties know which ports to use),\
    \ which is equivalent to (and as\n   infeasible for large-scale deployments as)\
    \ exchanging a shared secret\n   [39].\n"
- title: 3.1.5.  Other TCP Considerations
  contents:
  - "3.1.5.  Other TCP Considerations\n   The analysis of the potential for RST spoofing\
    \ above assumes that the\n   advertised receive window is opened to the maximum\
    \ extent suggested\n   by the bandwidth-delay product of the end-to-end path,\
    \ and that the\n   window is opened to an appreciable fraction of the overall\
    \ sequence\n   number space.  As noted earlier, for most common cases, connections\n\
    \   are too brief or over bandwidths too low for such a large window to\n   be\
    \ useful.  Expanding TCP's sequence number space is a direct way to\n   further\
    \ avoid such vulnerability, even for long connections over\n   emerging bandwidths.\
    \  If either manual tuning or automatic tuning of\n   the advertised receive window\
    \ (via receive buffer tuning) is not\n   provided, this is not an issue (although\
    \ connection performance will\n   suffer) [38].\n   It may be sufficient for the\
    \ endpoint to limit the advertised receive\n   window by deliberately leaving\
    \ it small.  If the receive socket\n   buffer is limited, e.g., to the ubiquitous\
    \ default of 64 KB, the\n   advertised receive window will not be as vulnerable\
    \ even for very\n   long connections over very high bandwidths.  The vulnerability\
    \ will\n   grow linearly with the increased network speed, but not as the\n  \
    \ square.  The consequence is lower sustained throughput, where only\n   one window's\
    \ worth of data per round-trip time (RTT) is exchanged.\n   This will keep the\
    \ connection open longer; for long-lived connections\n   with continuous sourced\
    \ data, this may continue to present an attack\n   opportunity, albeit a sparse\
    \ and slow-moving target.  For the most\n   recent case where BGP data is being\
    \ exchanged between Internet\n   routers, the data is bursty and the aggregate\
    \ traffic may be small\n   (i.e., unlikely to cover a substantial portion of the\
    \ sequence space,\n   even if long-lived), so smaller advertised receive windows\
    \ (via small\n   receiver buffers) may, in some cases, sufficiently address the\n\
    \   immediate problem.  This assumes that the routing tables can be\n   exchanged\
    \ quickly enough with bandwidth reduced due to the smaller\n   buffers, or perhaps\
    \ that the advertised receive window is opened only\n   during a large burst exchange\
    \ (e.g., via some other signal between\n   the two routers, or a time-based signal,\
    \ though either would be\n   nonstandard).\n"
- title: 3.1.6.  Other Transport Protocol Solutions
  contents:
  - "3.1.6.  Other Transport Protocol Solutions\n   Segment authentication has been\
    \ addressed at the transport layer in\n   other protocols.  Both SCTP and DCCP\
    \ include cookies for connection\n   establishment and use them to authenticate\
    \ a variety of other control\n   messages [28][41].  The inclusion of such mechanism\
    \ at the transport\n   protocol, although emerging as standard practice, complicates\
    \ the\n   design and implementation of new protocols [32].  As new attacks are\n\
    \   discovered (SYN floods, RSTs, etc.), each protocol must be modified\n   individually\
    \ to compensate.  A network solution may be more\n   appropriate and efficient.\n\
    \   It should be noted that RST attacks, which rely on brute-force, are\n   relatively\
    \ easy for intrusion detection software to detect at the TCP\n   layer.  Any connection\
    \ that receives a large number of invalid --\n   outside-window -- RSTs might\
    \ have subsequent RSTs blocked, to defeat\n   such attacks.  This would have the\
    \ side-effect of blocking legitimate\n   RSTs to that connection, which might\
    \ then interfere with cleaning up\n   the transport state between the endpoint\
    \ peers.  This side-effect,\n   coupled with the increased monitoring load, might\
    \ render such\n   solutions undesirable in the general case, but they might usefully\
    \ be\n   applied to special cases, e.g., for BGP for routers.\n"
- title: 3.2.  Network Layer (IP) Solutions
  contents:
  - "3.2.  Network Layer (IP) Solutions\n   There are two primary variants of network\
    \ layer solutions to\n   spoofing: address filtering and IPsec.  Address filtering\
    \ is an\n   indirect system that relies on other parties to filter packets sent\n\
    \   upstream of an attack, but does not necessarily require participation\n  \
    \ of the packet source.  IPsec requires cooperation between the\n   endpoints\
    \ wanting to avoid attack on their connection, which\n   currently involves preexisting\
    \ shared knowledge of either a shared\n   key or shared certificate authority.\n"
- title: 3.2.1.  Address Filtering
  contents:
  - "3.2.1.  Address Filtering\n   Address filtering is often proposed as an alternative\
    \ to protocol\n   mechanisms to defeat IP source address spoofing [2][13].  Address\n\
    \   filtering restricts traffic from downstream sources across transit\n   networks\
    \ based on the IP source address.  A kind of filtering already\n   occurs at the\
    \ endpoints of a connection, because attack messages must\n   match the socket\
    \ pair to succeed; again, note that such attacks\n   require knowing the entire\
    \ socket pair, and are unlikely except in\n   particular cases.  This section\
    \ discusses filtering based on address\n   only, typically done at the borders\
    \ of an AS.\n   It can also restrict core-to-edge paths to reject traffic that\
    \ should\n   have originated further toward the edge.  It cannot restrict traffic\n\
    \   from edges lacking filtering through the core to a particular edge.\n   As\
    \ a result, each border router must perform the appropriate\n   filtering for\
    \ overall protection to result; failure of any border\n   router to filter defeats\
    \ the protection of all participants inside\n   the border, and potentially those\
    \ outside as well.  Address filtering\n   at the border can protect those inside\
    \ the border from some kinds of\n   spoofing, i.e., connections among those inside\
    \ a border, because only\n   interior addresses should originate inside the border.\
    \  It cannot,\n   however, protect connections including endpoints outside the\
    \ border\n   (i.e., those that traverse the AS boundary) except to restrict where\n\
    \   the traffic enters from, e.g., if it expected from one AS and not\n   another.\n\
    \   As a result, address filtering is not a local solution that can be\n   deployed\
    \ to protect communicating pairs, but rather relies on a\n   distributed infrastructure\
    \ of trusted gateways filtering forged\n   traffic where it enters the network.\
    \  It is not feasible for local,\n   incremental deployment, but may be applicable\
    \ to connections among\n   those inside the protected border in some scenarios.\
    \  Applying\n   filtering can also be useful to reduce the network load of spoofed\n\
    \   traffic [31].\n   A more recent variant of address filtering checks the IP\
    \ TTL (Time to\n   Live) field, relying on the TTL set by the other end of the\n\
    \   connection [15].  This technique has been used to provide filtering\n   for\
    \ BGP.  It assumes the connection source TTL is set to 255; packets\n   at the\
    \ receiver are checked for TTL=255, and others are dropped.\n   This restricts\
    \ traffic to one hop upstream of the receiver (i.e., a\n   BGP router), but those\
    \ hops could include other user programs at\n   those nodes (e.g., the BGP router's\
    \ peer) or any traffic those nodes\n   accept via tunnels -- because tunnels need\
    \ not decrement TTLs,\n   notably for \"bump in the wire\" (BITW) or BITW-equivalent\
    \ scenarios\n   [33] (see also Section 5.1 of [15] and [16]).  TTL filtering works\n\
    \   only where all traffic from the other end of the tunnel is trusted,\n   i.e.,\
    \ where it does not originate or transit spoofed traffic.  The\n   use of TTL\
    \ rather than link or network security also assumes an\n   untampered point-to-point\
    \ link, where no other traffic can be spoofed\n   onto a link.\n   This method\
    \ of filtering works best where traffic originates one hop\n   away, so that the\
    \ address filtering is based on the trust of only\n   directly-connected (tunneled\
    \ or otherwise) nodes.  Like conventional\n   address filtering, this reduces\
    \ spoofing traffic in general, but is\n   not considered a reliable security mechanism\
    \ because it relies on\n   distributed filtering (e.g., the fact that upstream\
    \ nodes do not\n   terminate tunnels arbitrarily).\n"
- title: 3.2.2.  IPsec
  contents:
  - "3.2.2.  IPsec\n   TCP is susceptible to RSTs, but also to other off-path and\
    \ on-path\n   spoofing attacks, including SYN attacks.  Other transport protocols,\n\
    \   such as UDP and RTP are equally susceptible.  Although emerging\n   transport\
    \ protocols attempt to defeat such attacks at the transport\n   layer, such attacks\
    \ take advantage of network layer identity\n   spoofing.  The packet is coming\
    \ from an endpoint that is spoofing\n   another endpoint, either upstream or somewhere\
    \ else in the Internet.\n   IPsec was designed specifically to establish and enforce\n\
    \   authentication of a packet's source and contents in order to most\n   directly\
    \ and explicitly address this security vulnerability.\n   The larger problem with\
    \ IPsec is that of key distribution and use.\n   IPsec is often cumbersome, and\
    \ has only recently been supported in\n   many end-system operating systems. \
    \ More importantly, it relies on\n   preshared keys, signed X.509 certificates,\
    \ or a trusted third-party\n   (e.g., Kerberos) key infrastructure to establish\
    \ and exchange keying\n   information (e.g., via IKE).  Each of these issues presents\n\
    \   challenges when using IPsec to secure traffic to a well-known server,\n  \
    \ whose clients may not support IPsec or may not have registered with a\n   previously-known\
    \ certificate authority (CA).\n   These keying challenges are being addressed\
    \ in the IETF in ways that\n   will enable servers secure associations with other\
    \ parties without\n   advance coordination [45][46].  This can be especially useful\
    \ for\n   publicly-available servers, or for protecting connections to servers\n\
    \   that -- for whatever reason -- have not or will not deploy\n   conventional\
    \ IPsec certificates (i.e., core Internet BGP routers).\n"
- title: 4.  ICMP
  contents:
  - "4.  ICMP\n   Just as spoofed TCP packets can terminate a connection, so too can\n\
    \   spoofed ICMP packets.  ICMP can be used to launch a variety of\n   attacks\
    \ on TCP including connection resets, path-MTU attacks, and can\n   also be used\
    \ to attack the host with non-TCP 'ping of death' and\n   'smurf attacks', etc.\
    \ [40].  ICMP thus represents a substantial\n   threat to TCP, but this is not\
    \ the focus of this document, although a\n   number of protections are discussed\
    \ below because some are comparable\n   to TCP anti-spoofing techniques.  Note\
    \ also that ICMP attacks on TCP\n   assume that the socket pair is known by the\
    \ attacker, which is\n   unlikely except for a subset of services between pairs\
    \ of widely-\n   known endpoints.\n   TCP headers can be included inside certain\
    \ ICMP messages [7].  There\n   have been recent suggestions to validate the sequence\
    \ number of TCP\n   headers when they occur inside ICMP messages [18].  This sequence\n\
    \   checking is similar to checks that would occur for conventional data\n   packets\
    \ in TCP, but is being proposed in the spirit of the RST window\n   attenuation\
    \ described in Section 3.1.2.\n   Some such checks may be reasonable, especially\
    \ where they parallel\n   the validations already performed by TCP processing,\
    \ notably where\n   they emulate the semantics of such processing.  For example,\
    \ the TCP\n   checksum should be validated (if the entire TCP segment is contained\n\
    \   in the ICMP message) before any fields of the TCP header are\n   examined,\
    \ to avoid reacting to corrupted packets.  Similarly, if the\n   TCP MD5 option\
    \ is present, its signature should probably be validated\n   before considering\
    \ the contents of the message.  Such validation can\n   ensure that the packet\
    \ was not corrupted prior to the ICMP generation\n   (checksum), that the packet\
    \ was one sent by the source (IPsec or\n   TCP/MD5 authenticated), or that the\
    \ packet was not in the network for\n   an excess of 2*MSL (valid sequence number).\n\
    \   ICMP presents a particular challenge because some messages can reset\n   a\
    \ connection more easily -- with less validation -- than even some\n   spoofed\
    \ TCP segments.  One other proposed alternative is to change\n   TCP's reaction\
    \ to ICMPs after a connection is established; that may\n   leave TCP susceptible\
    \ during connection establishment and modifies\n   TCP's reaction to certain valid\
    \ network events [19].  This considers\n   the context-sensitivity of ICMP messages,\
    \ as does IPsec in some\n   tunneled configurations, but the recommendations are\
    \ ambiguous\n   regarding such filtering [27].\n   Ultimately, requiring TCP ICMP\
    \ messages to be 'in window' may be\n   insufficient protection, as this document\
    \ shows for spoofed data.\n   ICMP packets can be authenticated when originating\
    \ at known, trusted\n   endpoints, such as endpoints of connections or routers\
    \ in known\n   domains with preexisting IPsec associations.  Unfortunately, they\n\
    \   also can originate at other places in the network.  In addition, some\n  \
    \ networks filter all ICMP packets because validation may not be\n   possible,\
    \ especially because they can be injected from anywhere in a\n   network, and\
    \ so cannot be easily and locally address filtered [27].\n   As a result, they\
    \ are not addressed separately in the issues or\n   security considerations of\
    \ this document further.\n"
- title: 5.  Issues
  contents:
  - "5.  Issues\n   There are a number of existing and proposed solutions addressing\
    \ the\n   vulnerability of transport protocols in general (and TCP in specific)\n\
    \   to off-path third-party spoofing attacks.  As shown, these operate at\n  \
    \ the transport or network layer.  Transport solutions require separate\n   modification\
    \ of each transport protocol, addressing network identity\n   spoofing separately\
    \ in the context of each transport association.\n   Network solutions require\
    \ distributed coordination (filtering) or can\n   be computationally intensive\
    \ and require pervasive registration of\n   certificate authorities with every\
    \ possible endpoint\n   (authentication).  This section explains these observations\
    \ further.\n"
- title: 5.1.  Transport Layer (e.g., TCP)
  contents:
  - "5.1.  Transport Layer (e.g., TCP)\n   Transport solutions rely on shared cookies\
    \ to authenticate segments,\n   including data, transport header, and even pseudo-header\
    \ (e.g., fixed\n   portions of the outer IP header in TCP).  Because the Internet\
    \ relies\n   on stateless network protocols, it makes sense to rely on state\n\
    \   establishment and maintenance available in some transport layers not\n   only\
    \ for the connection but for authentication state.  Three-way\n   handshakes and\
    \ heartbeats can be used to negotiate authentication\n   state in conjunction\
    \ with connection parameters, which can be stored\n   with connection state easily.\n\
    \   As noted earlier, transport layer solutions require separate\n   modification\
    \ of all transport protocols to include authentication.\n   Not all transport\
    \ protocols support negotiated endpoint state (e.g.,\n   UDP), and legacy protocols\
    \ have been notoriously difficult to safely\n   augment.  Not all authentication\
    \ solutions are created equal, either,\n   and relying on a variety of transport\
    \ solutions exposes end-systems\n   to increased potential for incorrectly specified\
    \ or implemented\n   solutions.  Transport authentication has often been developed\
    \ piece-\n   wise, in response to specific attacks, e.g., SYN cookies and RST\n\
    \   window attenuation [4][36].\n   Transport layer solutions are not only per-protocol,\
    \ but often per-\n   connection.  This has both advantages and drawbacks.  One\
    \ advantage\n   to transport layer solutions is that they can protect the transport\n\
    \   protocol when lower layers have failed, e.g., due to bugs in\n   implementation.\
    \  TCP already includes a variety of packet validation\n   mechanisms to protect\
    \ in these cases, e.g., checking that RSTs are\n   in-window.  More strict checks\
    \ can increase the protections provided,\n   e.g., to protect against misaddressed\
    \ RSTs that end up in-window (via\n   TCPsecure) or to protect against connection\
    \ interruption due to RSTs,\n   SYNs, or data injection from misaddressed packets\
    \ (TCP/MD5) [36].\n   Another advantage is that transport layer protections can\
    \ be more\n   specifically limited to a particular connection.  Because each\n\
    \   connection negotiates its state separately, that state can be more\n   specifically\
    \ tied to that connection.  This is both an advantage and\n   a drawback.  It\
    \ can make it easier to tie security to an individual\n   connection, although\
    \ in practice a shared secret or certificate will\n   generally be shared across\
    \ multiple connections.\n   As a drawback, each transport connection needs to\
    \ negotiate and\n   maintain authentication state separately.  Some overhead is\
    \ not\n   amortized over multiple connections, e.g., overheads in packet\n   exchanges,\
    \ whereas other overheads are not amortized over different\n   transport protocols,\
    \ e.g., design and implementation complexity --\n   both as would be the case\
    \ in a network layer solution.  Because the\n   authentication happens later in\
    \ packet processing than is required,\n   additional endpoint resources may be\
    \ needlessly consumed, e.g., in\n   demultiplexing received packets, indexing\
    \ connection identifiers, and\n   continuing to buffer spoofed packets, etc.,\
    \ only to be dropped later\n   at the transport layer.\n"
- title: 5.2.  Network Layer (IP)
  contents:
  - "5.2.  Network Layer (IP)\n   A network layer solution avoids the hazards of multiple\
    \ transport\n   variants, using a single shared endpoint authentication mechanism\n\
    \   early in receiver packet processing to discard unauthenticated\n   packets\
    \ at the network layer instead.  This defeats spoofing entirely\n   because spoofing\
    \ involves masquerading as another endpoint, and\n   network layer security validates\
    \ the endpoint as the source of the\n   packets it emits.  Such a network level\
    \ solution protects all\n   transport protocols as a result, including both legacy\
    \ and emerging\n   protocols, and reduces the complexity of these protocols as\
    \ well.  A\n   shared solution also reduces protocol overhead, and decouples the\n\
    \   management (and refreshing) of authentication state from that of\n   individual\
    \ transport connections.  Finally, a network layer solution\n   protects not only\
    \ the transport layer but the network layer as well,\n   e.g., from IGMP, and\
    \ some kinds of ICMP (Section 4), spoofing\n   attacks.\n   The IETF Proposed\
    \ Standard protocol for network layer authentication\n   is IPsec [27].  IPsec\
    \ specifies the overall architecture, including\n   header authentication (AH)\
    \ [25] and encapsulation (ESP) modes [26].\n   AH authenticates both the IP header\
    \ and IP data, whereas ESP\n   authenticates only the IP data (e.g., transport\
    \ header and payload).\n   AH is being phased out since ESP is more efficient\
    \ and the Security\n   Parameters Index (SPI) includes sufficient information\
    \ to verify the\n   IP header anyway [27].  These two modes describe the security\
    \ applied\n   to individual packets within the IPsec system; key exchange and\n\
    \   management is performed either out-of-band (via pre-shared keys) or\n   by\
    \ an automated key exchange protocol, e.g., IKE [24].\n   IPsec already provides\
    \ authentication of an IP header and its data\n   contents sufficient to defeat\
    \ both on-path and off-path third-party\n   spoofing attacks.  IKE can configure\
    \ authentication between two\n   endpoints on a per-endpoint, per-protocol, or\
    \ per-connection basis,\n   as desired.  IKE also can perform automatic periodic\
    \ re-keying,\n   further defeating crypto-analysis based on snooping (clandestine\
    \ data\n   collection).  The use of IPsec is already commonly strongly\n   recommended\
    \ for protected infrastructure.\n   Existing IPsec is not appropriate for many\
    \ deployments.  It is\n   computationally intensive both in key management and\
    \ individual\n   packet authentication [43].  This computational overhead can\
    \ be\n   prohibitive, and so often requires additional hardware, especially in\n\
    \   commercial routers.  As importantly, IKE is not anonymous; keys can\n   be\
    \ exchanged between parties only if they trust each other's X.509\n   certificates,\
    \ trust some other third-party to help with key\n   generation (e.g., Kerberos),\
    \ or pre-share a key.  These certificates\n   provide identification (the other\
    \ party knows who you are) only where\n   the certificates themselves are signed\
    \ by certificate authorities\n   (CAs) that both parties already trust.  To a\
    \ large extent, the CAs\n   themselves are the pre-shared keys that help IKE establish\
    \ security\n   association keys, which are then used in the authentication\n \
    \  algorithms.\n   Alternative mechanisms are under development to address this\n\
    \   limitation, to allow publicly-accessible servers to secure\n   connections\
    \ to clients not known in advance, or to allow unilateral\n   relaxation of identity\
    \ validation so that the remaining protections\n   of IPsec can be made available\
    \ [45][46].  In particular, these\n   mechanisms can prevent a client (but without\
    \ knowing who that client\n   is) from being affected by spoofing from other clients,\
    \ even when the\n   attackers are on the same communications path.\n   IPsec,\
    \ although widely available both in commercial routers and\n   commodity end-systems,\
    \ is not often used except between parties that\n   already have a preexisting\
    \ relationship (employee/employer, between\n   two ISPs, etc.).  Servers to anonymous\
    \ clients (e.g., customer/\n   business) or more open services (e.g., BGP, where\
    \ routers may have\n   large numbers of peers) are unmanageable, due to the breadth\
    \ and flux\n   of CAs.  New endpoints cannot establish IPsec associations with\
    \ such\n   servers unless their own certificate is signed by a CA already\n  \
    \ trusted by the server.  Different servers -- even within the same\n   overall\
    \ system (e.g., BGP) -- often cannot or will not trust\n   overlapping subsets\
    \ of CAs in general.\n"
- title: 5.3.  Application Layer
  contents:
  - "5.3.  Application Layer\n   There are a number of application layer authentication\
    \ mechanisms,\n   often implicit within end-to-end encryption.  Application layer\n\
    \   security (e.g., TLS, SSH, or MD5 checksums within a BGP stream)\n   provides\
    \ the ultimate protection of application data from all\n   intermediaries, including\
    \ network routers as well as exposure at\n   other layers in the end-systems.\
    \  This is the only way to ultimately\n   protect the application data.\n   Application\
    \ authentication cannot protect either the network or\n   transport protocols\
    \ from spoofing attacks, however.  Spoofed packets\n   interfere with network\
    \ processing or reset transport connections\n   before the application checks\
    \ the data.  Authentication needs to\n   winnow these packets and drop them before\
    \ they interfere at these\n   lower layers.\n   An alternate application layer\
    \ solution would involve resilience to\n   reset connections.  If the application\
    \ can recover from such\n   connection interruptions, then such attacks have less\
    \ impact.\n   Unfortunately, attackers still affect the application, e.g., in\
    \ the\n   cost of restarting connections, delays until connections are\n   restarted,\
    \ or increased connection establishment messages on the\n   network.  Some applications\
    \ -- notably BGP -- even interpret TCP\n   connection reliability as an indicator\
    \ of route path stability, which\n   is why attacks on BGP have such substantial\
    \ consequences.\n"
- title: 5.4.  Link Layer
  contents:
  - "5.4.  Link Layer\n   Link layer security operates separately on each hop of an\
    \ Internet.\n   Such security can be critical in protecting link resources, such\
    \ as\n   bandwidth and link management protocols.  Protection at this layer\n\
    \   cannot suffice for network or transport layers, because it cannot\n   authenticate\
    \ the endpoint source of a packet.  Link authentication\n   ensures only the source\
    \ of the current link hop where it is examined.\n"
- title: 5.5.  Issues Discussion
  contents:
  - "5.5.  Issues Discussion\n   The issues raised in this section suggest that there\
    \ are challenges\n   with all solutions to transport protection from spoofing\
    \ attacks.\n   This raises the potential need for alternate security levels. \
    \ While\n   it is already widely recognized that security needs to occur\n   simultaneously\
    \ at many protocol layers, there also may be utility in\n   supporting a variety\
    \ of strengths at a single layer.  For example,\n   IPsec already supports a variety\
    \ of algorithms (MD5, SHA1, etc., for\n   authentication), but always assumes\
    \ that:\n   1. The entire body of the packet is secured.\n   2. Security associations\
    \ are established only where identity is\n      authenticated by a known certificate\
    \ authority or other pre-shared\n      key.\n   3. Both on-path and off-path third-party\
    \ spoofing attacks must be\n      defeated.\n   These assumptions are prohibitive,\
    \ especially in many cases of\n   spoofing attacks.  For spoofing, the primary\
    \ issue is whether packets\n   are coming from the same party the server can reach.\
    \  Only the IP\n   header is fundamentally in question, so securing the entire\
    \ packet\n   (1) is computational overkill.  It is sufficient to authenticate\
    \ the\n   other party as \"a party you have exchanged packets with\", rather than\n\
    \   establishing their trusted identity (\"Bill\" vs. \"Bob\") as in (2).\n  \
    \ Finally, many cookie systems use clear-text (unencrypted), fixed\n   cookie\
    \ values, providing reasonable (1 in 2^{cookie-size}) protection\n   against off-path\
    \ third-party spoof attacks, but not addressing on-\n   path attacks at all. \
    \ Such potential solutions are discussed in the\n   Better Than Nothing Security\
    \ (BTNS) documents [5][45][46].  Note also\n   that NULL Encryption in IPsec applies\
    \ a variant of this cookie, where\n   the SPI is the cookie, and no further encryption\
    \ is applied [17].\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This entire document focuses on increasing the\
    \ security of transport\n   protocols and their resistance to spoofing attacks.\
    \  Security is\n   addressed throughout.\n   This document describes a number\
    \ of techniques for defeating spoofing\n   attacks.  Those relying on clear-text\
    \ cookies, either explicit or\n   implicit (e.g., window sequence attenuation)\
    \ do not protect from on-\n   path spoofing attacks, since valid values can be\
    \ learned from prior\n   traffic.  Those relying on true authentication algorithms\
    \ are\n   stronger, protecting even from on-path attacks, because the\n   authentication\
    \ hash in a single packet approaches the behavior of\n   \"one-time\" cookies.\n\
    \   The security of various levels of the protocol stack is addressed.\n   Spoofing\
    \ attacks are fundamentally identity masquerading, so we\n   believe the most\
    \ appropriate solutions defeat these at the network\n   layer, where end-to-end\
    \ identity lies.  Some transport protocols\n   subsume endpoint identity information\
    \ from the network layer (e.g.,\n   TCP pseudo-headers), whereas others establish\
    \ per-connection identity\n   based on exchanged nonces (e.g., SCTP).  It is reasonable,\
    \ if not\n   recommended, to address security at all layers of the protocol stack.\n\
    \   Note that Network Address Translators (NATs) and other middleboxes\n   complicate\
    \ the design and deployment of techniques to defeat spoofing\n   attacks.  Devices\
    \ such as these, that modify IP and/or TCP headers\n   in-transit, generate traffic\
    \ equivalent to a spoofing attack, and\n   thus should be inhibited by antispoofing\
    \ mechanisms.  Details of\n   these middlebox-related problems are out of scope\
    \ for this document,\n   but issues thereof are addressed in RFCs and emerging\
    \ documents that\n   discuss the interactions between such devices and the Internet\n\
    \   architecture, e.g., [21].  Fortunately, many of the most critical\n   TCP-based\
    \ connections -- in particular, those supporting routing\n   protocols like BGP\
    \ -- do not traverse such middleboxes, and are not\n   affected by this limitation.\n"
- title: 7.  Conclusions
  contents:
  - "7.  Conclusions\n   This document describes the details of the recent BGP spoofing\n\
    \   attacks involving spurious RSTs, which could be used to shutdown TCP\n   connections.\
    \  It summarizes and discusses a variety of current and\n   proposed solutions\
    \ at various protocol layers.\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   This document was inspired by discussions in the TCPM\
    \ WG\n   <http://www.ietf.org/html.charters/tcpm-charter.html> about the\n   recent\
    \ spoofed RST attacks on BGP routers, including R. Stewart's\n   document (whose\
    \ author list has since evolved) [36][42].  The\n   analysis of the attack issues,\
    \ alternate solutions, and the anonymous\n   security proposed solutions were\
    \ the result of discussions on that\n   list as well as with USC/ISI's T. Faber,\
    \ A. Falk, G. Finn, and Y.\n   Wang.  R. Atkinson suggested the UDP variant of\
    \ TCP/MD5, P. Goyette\n   suggested using the ISN to seed TCP/MD5, and L. Wood\
    \ suggested using\n   the ISN to validate RSTs.  Other improvements are due to\
    \ the input of\n   various members of the IETF's TCPM WG, notably detailed feedback\
    \ from\n   F. Gont, P. Savola, and A. Hoenes.\n   This document was prepared using\
    \ 2-Word-v2.0.template.dot.\n"
- title: 9.  Informative References
  contents:
  - "9.  Informative References\n   [1]   Allman, M., Paxson, V., and W. Stevens,\
    \ \"TCP Congestion\n         Control\", RFC 2581, April 1999.\n   [2]   Baker,\
    \ F. and P. Savola, \"Ingress Filtering for Multihomed\n         Networks\", BCP\
    \ 84, RFC 3704, March 2004.\n   [3]   Bellovin, S. and A. Zinin, \"Standards Maturity\
    \ Variance\n         Regarding the TCP MD5 Signature Option (RFC 2385) and the\
    \ BGP-4\n         Specification\", RFC 4278, January 2006.\n   [4]   Bernstein,\
    \ D., \"SYN cookies\", 1997,\n         <http://cr.yp.to/syncookies.html>.\n  \
    \ [5]   Better Than Nothing Security [BTNS] WG web pages,\n         <http://www.postel.org/anonsec>.\n\
    \   [6]   Bonica, R., Weis, B., Viswanathan, S., Lange, A., and O.\n         Wheeler,\
    \ \"Authentication for TCP-based Routing and Management\n         Protocols\"\
    , Work in Progress, February 2007.\n   [7]   Braden, R., \"Requirements for Internet\
    \ Hosts - Communication\n         Layers\", STD 3, RFC 1122, October 1989.\n \
    \  [8]   Braden, R., \"TIME-WAIT Assassination Hazards in TCP\", RFC 1337,\n \
    \        May 1992.\n   [9]   CERT alert: \"Technical Cyber Security Alert TA04-111A:\n\
    \         Vulnerabilities in TCP\", April 20, 2004,\n         <http://www.us-cert.gov/cas/techalerts/TA04-111A.html>.\n\
    \   [10]  Convery, S., and M. Franz, \"BGP Vulnerability Testing:\n         Separating\
    \ Fact from FUD\", 2003,\n         <http://www.nanog.org/mtg-0306/pdf/franz.pdf>.\n\
    \   [11]  Eddy, W., \"TCP SYN Flooding Attacks and Common Mitigations\",\n   \
    \      Work in Progress, May 2007.\n   [12]  Faber, T., J. Touch, and W. Yue,\
    \ \"The TIME-WAIT state in TCP\n         and Its Effect on Busy Servers\", Proc.\
    \ Infocom 1999, pp. 1573-\n         1583, Mar. 1999.\n   [13]  Ferguson, P. and\
    \ D. Senie, \"Network Ingress Filtering:\n         Defeating Denial of Service\
    \ Attacks which employ IP Source\n         Address Spoofing\", BCP 38, RFC 2827,\
    \ May 2000.\n   [14]  Floyd, S., \"Inappropriate TCP Resets Considered Harmful\"\
    , BCP\n         60, RFC 3360, August 2002.\n   [15]   Gill, V., Heasley, J., and\
    \ D. Meyer, \"The Generalized TTL\n         Security Mechanism (GTSM)\", RFC 3682,\
    \ February 2004.\n   [16]  Gill, V., Heasley, J., Meyer, D., Savola, P., Ed.,\
    \ and C.\n         Pignataro, \"The Generalized TTL Security Mechanism (GTSM)\"\
    ,\n         Work in Progress, June 2007.\n   [17]  Glenn, R. and S. Kent, \"The\
    \ NULL Encryption Algorithm and Its\n         Use With IPsec\", RFC 2410, November\
    \ 1998.\n   [18]  Gont, F., \"ICMP attacks against TCP\", Work in Progress, May\n\
    \         2007.\n   [19]  Gont, F., \"TCP's Reaction to Soft Errors\", Work in\
    \ Progress,\n         June 2007.\n   [20]  Heffernan, A., \"Protection of BGP\
    \ Sessions via the TCP MD5\n         Signature Option\", RFC 2385, August 1998.\n\
    \   [21]  Holdrege, M. and P. Srisuresh, \"Protocol Complications with the\n \
    \        IP Network Address Translator\", RFC 3027, January 2001.\n   [22]  Housley,\
    \ R., Post to IETF Discussion mailing list regarding his\n         IETF 64 Security\
    \ Area presentation,\n         ID=7.0.0.10.2.20051124135914.00f50558@vigilsec.com,\
    \ Nov. 24,\n         2005, <http://www1.ietf.org/\n         mail-archive/ietf/Current/maillist.html>.\n\
    \   [23]  Jacobson, V., Braden, R., and D. Borman, \"TCP Extensions for\n    \
    \     High Performance\", RFC 1323, May 1992.\n   [24]  Kaufman, C., Ed., \"Internet\
    \ Key Exchange (IKEv2) Protocol\", RFC\n         4306, December 2005.\n   [25]\
    \  Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.\n   [26] \
    \ Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303,\n         December\
    \ 2005.\n   [27]  Kent, S. and K. Seo, \"Security Architecture for the Internet\n\
    \         Protocol\", RFC 4301, December 2005.\n   [28]  Kohler, E., Handley,\
    \ M., and S. Floyd, \"Datagram Congestion\n         Control Protocol (DCCP)\"\
    , RFC 4340, March 2006.\n   [29]  Larsen, M., and F. Gont, \"Port Randomization\"\
    , Work in\n         Progress, February 2007.\n   [30]  Leech, M., \"Key Management\
    \ Considerations for the TCP MD5\n         Signature Option\", RFC 3562, July\
    \ 2003.\n   [31]  Moore, D., G. Voelker, and S. Savage, \"Inferring Internet\n\
    \         Denial-of-Service Activity\", Proc. Usenix Security Symposium,\n   \
    \      Aug. 2001.\n   [32]  O'Malley, S. and L. Peterson, \"TCP Extensions Considered\n\
    \         Harmful\", RFC 1263, October 1991.\n   [33]  Perkins, C., \"IP Encapsulation\
    \ within IP\", RFC 2003, October\n         1996.\n   [34]  Poon, K., \"Use of\
    \ TCP timestamp option to defend against blind\n         spoofing attack\", Work\
    \ in Progress, October 2004.\n   [35]  Postel, J., \"Transmission Control Protocol\"\
    , STD 7, RFC 793,\n         September 1981.\n   [36]  Ramaiah, A., Stewart, R.,\
    \ and M. Dalal, \"Improving TCP's\n         Robustness to Blind In-Window Attacks\"\
    , Work in Progress, July\n         2007.\n   [37]  Rekhter, Y., Ed., Li, T., Ed.,\
    \ and S. Hares, Ed., \"A Border\n         Gateway Protocol 4 (BGP-4)\", RFC 4271,\
    \ January 2006.\n   [38]  Semke, J., J. Mahdavi, and M. Mathis, \"Automatic TCP\
    \ Buffer\n         Tuning\", ACM SIGCOMM '98/ Computer Communication Review, volume\n\
    \         28, number 4, Oct. 1998.\n   [39]  Shepard, T., \"Reassign Port Number\
    \ option for TCP\", Work in\n         Progress, July 2004.\n   [40]  Shirey, R.,\
    \ \"Internet Security Glossary, Version 2\", Work in\n         Progress, November\
    \ 2006.\n   [41]  Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer,\n\
    \         H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V.\n         Paxson,\
    \ \"Stream Control Transmission Protocol\", RFC 2960,\n         October 2000.\n\
    \   [42]  TCPM: IETF TCPM Working Group and mailing list,\n         <http://www.ietf.org/html.charters/tcpm-charter.html>.\n\
    \   [43]  Touch, J., \"Report on MD5 Performance\", RFC 1810, June 1995.\n   [44]\
    \  Touch, J., \"Performance Analysis of MD5\", Proc. Sigcomm 1995,\n         pp.\
    \ 77-86, Mar. 1999.\n   [45]  Touch, J., \"ANONsec: Anonymous Security to Defend\
    \ Against\n         Spoofing Attacks\", Work in Progress, May 2004.\n   [46] \
    \ Touch, J., Black, D., and Y. Wang, \"Problem and Applicability\n         Statement\
    \ for Better Than Nothing Security (BTNS)\", Work in\n         Progress, February\
    \ 2007.\n   [47]  Touch, J. and A. Mankin, \"The TCP Simple Authentication\n \
    \        Option\", Work in Progress, July 2007.\n   [48]  Watson, P., \"Slipping\
    \ in the Window: TCP Reset attacks\",\n         Presentation at 2004 CanSecWest,\n\
    \         <http://cansecwest.com/csw04archive.html>.\n   [49]  Wood, L., Post\
    \ to TCPM mailing list regarding use of ISN in\n         RSTs, ID=Pine.GSO.4.50.0404232249570.5889-\n\
    \         100000@argos.ee.surrey.ac.uk, Apr. 23, 2004,\n         <http://www1.ietf.org/mail-archive/web/tcpm/current/\n\
    \         msg00213.html>.\n"
- title: Author's Addresses
  contents:
  - "Author's Addresses\n   Joe Touch\n   USC/ISI\n   4676 Admiralty Way\n   Marina\
    \ del Rey, CA 90292-6695\n   U.S.A.\n   Phone: +1 (310) 448-9151\n   Fax:   +1\
    \ (310) 448-9300\n   EMail: touch@isi.edu\n   URI:   http://www.isi.edu/touch\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
