- title: __initial_text__
  contents:
  - "            A Distributed Capability Computing System (DCCS)\n   This paper was\
    \ prepared for submission to the international\n   Conference on Computer Communication,\
    \ ICCC-76, August 3, 1976,\n   Toronto, Canada.\n   This is a preprint of a paper\
    \ intended for publication in a journal\n   of proceedings.  Since changes may\
    \ be made before publication, this\n   preprint is made available with the understanding\
    \ that it will not be\n   cited without the permission of the author.\n   The\
    \ work reported in this paper was supported in part under contract\n   #EPA-IAG-D5-E681-DB\
    \ with the Environmental Protection Agency and in\n   part under contract #[RA]\
    \ 76-12 with the Department Of\n   Transportation.  The report was prepared for\
    \ the U.S. Energy Research\n   and Development Agency under contract #W-7405-Eng-48.\n"
- title: A Distributed Capability Computing System (DCCS)
  contents:
  - "A Distributed Capability Computing System (DCCS)\n   This paper describes a distributed\
    \ computing system.  The first\n   portion introduces an idealized operating system\
    \ called CCS\n   (Capability Computing System).  In the second portion, the DCCS\n\
    \   protocols are defined and the processes necessary to support the DCCS\n  \
    \ on a CCS are described.  The remainder of the paper discusses\n   utilizing\
    \ the DCCS protocol in a computer network involving\n   heterogeneous systems\
    \ and presents some applications.  The\n   applications presented are to optimally\
    \ solve the single copy problem\n   for distributed data access and to construct\
    \ a transparent network\n   resource optimization mechanism.\n"
- title: The Capability Computing System (CCS)
  contents:
  - "The Capability Computing System (CCS)\n   The CCS, though not exactly like any\
    \ existing operating system, is\n   much like some of the existing capability\
    \ list (C-list) operating\n   systems described in the literature [1-7].  Many\
    \ of the features of\n   the CCS come from a proposed modification to the RATS\
    \ operating\n   system [1-3].\n   In the documentation for most computer systems\
    \ there are many\n   references to different types of objects.  Typical objects\
    \ discussed\n   are: files, processes, jobs, accounts, semaphores, tasks, words,\n\
    \   devices, forks, events, etc. etc.. One of the intents of C-list\n   systems\
    \ is to provide a uniform method of access to all such objects.\n   Having all\
    \ CCS objects accessed through a uniform mechanism allow\n   DCCS to be implemented\
    \ in a type independent manner.\n   The CCS is a multiprocessing system supporting\
    \ an active element\n   called a process.  For most purposes, the reader's intuitive\
    \ notion\n   of what a process is should suffice.  A process is capable of\n \
    \  executing instructions like those in commercially available\n   computers.\
    \  It has a memory area associated with it and has some\n   status indicators\
    \ like \"RUN\" and \"WAIT\".  In C-list systems, however,\n   a process also has\
    \ a capability list (C-list).  This list is an area\n   in which pointers to the\
    \ objects that the process is allowed to\n   access are maintained.  These pointers\
    \ are protected by the system.\n   The process itself is only allowed to use its\
    \ C-list as a source of\n   capabilities to access and as a repository for capabilities\
    \ that it\n   has been granted.  Figure 1 diagrams some typical processes that\
    \ are\n   discussed later.  In the diagrams, the left half of a process box is\n\
    \   the C-list and the right half is the memory.\n   The key to the uniform access\
    \ method in the CCS is the invocation\n   mechanism.  This is the mechanism by\
    \ which a process makes a request\n   on a capability in its C-list.  An invocation\
    \ is closely analogous to\n   a subroutine call on most computer systems.  When\
    \ a request is made,\n   the invoking process passes some parameters to a service\
    \ routine and\n   receives some parameters in return.\n   There are, however,\
    \ several major differences between the invocation\n   mechanism and the usual\
    \ subroutine calling mechanisms.  The first\n   difference is that the service\
    \ routine called is generally not in the\n   process's memory space.  The service\
    \ routine is pointed to by the\n   protected capability and can be implemented\
    \ in hardware, microcode,\n   system kernel code, in another arbitrary process,\
    \ or, as we shall see\n   in the DCCS, in another computer system.  In Fig. 1.\
    \ for example, the\n   serving process is servicing on invocation on the semaphore\n\
    \   requestor.\n   A second difference is that, when invoking a capability, other\n\
    \   capabilities can be passed and returned along with strictly data\n   parameters.\
    \  In the DCCS, capabilities and data can also be passed\n   through a communication\
    \ network.\n   The final important distinction of the invocation mechanism can\
    \ best\n   be illustrated by considering the analogy to the outside teller\n \
    \  windows often seen at banks.  These windows usually contain a drawer\n   that\
    \ can be opened by the customer and teller are not both.  Except\n   for this\
    \ drawer, the customer and teller are physically isolated.  In\n   the case of\
    \ the invocation mechanism, the invoking process explicitly\n   passes certain\
    \ capabilities and information to the service routine\n   and designated C-list\
    \ locations and memory areas for the return\n   parameters.  Except for these\
    \ parameters, the invoking process and\n   the serving routine are isolated. \
    \ In the DCCS, this protection\n   mechanism is extended throughout a network\
    \ of systems.\n   In the CCS, invoking a capability is the only way that a process\
    \ can\n   pass or receive information or capabilities.  All of what are often\n\
    \   referred to as system calls on a typical operating system are\n   invocations\
    \ on appropriate capabilities in the CCS.  A CCs C-list\n   envelopes its process.\
    \  This fact is needed in order to transparently\n   move processes as described\
    \ in the second application on network\n   optimization (page 23).\n"
- title: CCS Capabilities
  contents:
  - "CCS Capabilities\n   To build the DCCS, we will assume certain primitive capabilities\
    \ in\n   the CCS.  The invocations below are represented for simplicity rather\n\
    \   than for efficiency or practicality.  In practice, capabilities\n   generally\
    \ have more highly optimized invocations with various error\n   returns, etc..\
    \  To characterize a capability, it suffices to describe\n   what it returns as\
    \ a function of what it is passed.  In the notation\n   used below, the passed\
    \ parameter list is followed by a \">\" and then\n   the returned parameter list.\
    \  In each parameter list the data\n   parameters are followed by a \"\" and then\
    \ the capability parameters.\n   1. File Capability\n      a. \"Read\", index;\
    \ > data;\n         \"Read\" the data at the specified index.  \"Read\" and the\
    \ index\n         are passed.  Data is returned.\n      b. \"Write\", index, data;\
    \ > ;\n         Write the data into the area at the specified index.  \"Write\"\
    ,\n         the index, and the data are passed.  Nothing is returned.\n   2. Directory\
    \ Capability\n      a. \"Take\", index; > ; capability\n         \"Take\" the\
    \ capability from the specified index in the\n         directory.  \"Take\" and\
    \ the index are passed.  The capability is\n         returned.\n      b. \"Give\"\
    , index; capability> ;\n         \"Give\" the capability to the directory at the\
    \ index specified.\n         \"Give\" and the index are passed information.  The\
    \ capability is\n         also passed.  Nothing is returned.\n      c. \"Find\"\
    ; capability> result, index;\n         A directory, like a process C-list, is\
    \ a repository for\n         capabilities.  The first two invocations are analogous\
    \ to the\n         two file invocations presented except that they involve\n \
    \        capability parameters moved between directory and C-list\n         instead\
    \ of between file and memory.  The last invocation\n         searches the directory\
    \ for the passed capability.  If an\n         identical capability is found, \"\
    Yes\" and the smallest index of\n         such a capability are returned.  Otherwise\
    \ \"No\" and 0 are\n         returned.\n   3. Nil Capability\n      When a directory\
    \ is initially created, it contains only nil\n      capabilities.  Nil always\
    \ returns \"Empty\".\n   4. Process Capability\n      a. \"Read\", index; > data;\n\
    \      b. \"Write\", index, data; > ;\n      c. \"Take\", index; > ; capability\n\
    \      d. \"Give\", index; capability> ;\n      e. \"Find\"; capability> result,\
    \ index;\n      f. \"Start\"; > ;\n      g. \"Stop\"; > ;\n   The a. and b. invocations\
    \ go to the process's memory space.  C., d.,\n   and e. go to its C-list. F. and\
    \ g. start and stop process execution.\n"
- title: The CCS Extension Mechanism
  contents:
  - "The CCS Extension Mechanism\n   There is one more basic capability mechanism\
    \ needed for the CCS\n   implementation of the DCCS.  This mechanism allows processes\
    \ to set\n   themselves up to create new capabilities that they can service. \
    \ Such\n   mechanisms differ widely on existing C-list systems.  A workable\n\
    \   mechanism is described.  Another primitive capability is needed to\n   start\
    \ things off:\n   5. Server Capability\n      a. \"Create requestor\", requestor\
    \ number; > ; requestor\n      b. \"My requestor?\"; capability> answer, requestor\
    \ number;\n      c. \"Wait\"; > reason, requestor number, PD; request\n   Two\
    \ capabilities were introduced above besides the server, the\n   requestor and\
    \ request capabilities.  These capabilities will be\n   described as the invocations\
    \ on a server are described.\n   The first invocation creates and returns a requestor\
    \ capability.  The\n   number that is passed is associated with the requestor.\
    \  The\n   requestor capability is the new capability being created.  Any sort\n\
    \   of invocation can be performed on a requestor.  This is their whole\n   reason\
    \ for existence.  A process with a server capability can make a\n   requestor\
    \ look like any kind of capability.\n   The \"My requestor?\" invocation can be\
    \ used to determine if a\n   capability is a requestor on the invoked server,\
    \ it returns either:\n      \"Yes\", requestor number; or \"No\",0;\n   The last\
    \ invocation \"Wait\"s until something that requires the\n   server's attention\
    \ happens.  There are two important events that a\n   service routine needs to\
    \ be notified about.  If the last capability\n   to a requestor is overwritten\
    \ so that the requestor cannot again be\n   invoked until a new one is created,\
    \ the \"wait\" returns:\n      \"Deleted\", requestor number, 0; Nil\n   The last\
    \ two parameters, 0 and Nil, are just filler for the returned\n   PD and request\
    \ (see 5c).  When a \"wait\" returns \"Deleted\", the\n   service routine can\
    \ recycle any resources being used to service the\n   numbered requestor (e.g.,\
    \ the requestor number).\n   The most important event that causes a \"wait\" to\
    \ return is when one\n   of the requestors for the server is invoked.  In this\
    \ case the server\n   returns:\n      \"Invoked\", requestor number, PD; request\n\
    \   The third parameter, labeled PD, stands for Parameter Descriptor.  It\n  \
    \ describes the number of each kind of parameter passing each way\n   during a\
    \ requestor invocation.  Specifically, it consists of four\n   numbers: Data bits\
    \ passed, capabilities passed, data bits requested,\n   and capabilities requested.\n\
    \   The last parameter received, the request capability, is used by the\n   serving\
    \ process to retrieve the passed parameters and to return the\n   requested parameters\
    \ to the requesting process.  Accordingly, it has\n   the following invocations:\n\
    \   6. Request Capability\n      a. \"Read parameters\"; > {The passed parameters\n\
    \      b. \"Return\", {The return parameters}> ;\n   The \"Return\" invocation\
    \ has the additional effect of restarting the\n   requesting process.\n   One\
    \ thing that should be noted about the server mechanism is that\n   invocations\
    \ on a server's requestors are queued until the server is\n   \"wait\"ed upon.\
    \  This is one reason that a request is given a separate\n   capability.  The\
    \ serving process can, if it chooses, give the request\n   to some other process\
    \ for servicing, while it goes back and waits on\n   its server for more requests.\
    \  The corresponding situation in the\n   outside bank window analogy would be\
    \ the case where the teller gives\n   the request to someone else for service\
    \ so that the teller can return\n   to waiting customers.  The request capability\
    \ points back to the\n   requesting process so that the return can be properly\
    \ effected.\n   A sample service, that of the well known semaphore [8] service\n\
    \   routine keeps a table containing the semaphore values for each\n   semaphore\
    \ that it is servicing.  It also keeps a list of queued\n   requests that represent\
    \ the processes that become hung in the\n   semaphore by \"P\"ing the semaphore\
    \ when it has a value less than or\n   equal to zero.  The invocations on a semaphore\
    \ are:\n   7. Semaphore\n      a. \"P\"; > ;\n      b. \"V\"; > ;\n   A diagram\
    \ and flow chart for the semaphore serving process is given\n   in Figures 1.\
    \ and 2. The flow charts are given include most of the\n   basic capability invocations,\
    \ but do not include detailed\n   descriptions of table searches.  The table structure\
    \ for the\n   semaphore service routine includes entries for each supported\n\
    \   semaphore.  Each entry contains the semaphore value and a link into a\n  \
    \ list of pointers to the requests hung in the semaphore (if any).\n   The most\
    \ important feature of the server mechanism is that, by using\n   it, the functioning\
    \ of any capability can be emulated.\n   This property, similar to the insertion\
    \ property discussed in [9], is\n   the cornerstone of the DCCS.  The basic idea\
    \ of the emulation is to\n   have the server \"wait\" for requests and pass them\
    \ on to the\n   capability being emulated.  Such emulation of a single capability\
    \ is\n   flow charted in Figure 3.  The emulation flow charted is an overview\n\
    \   that doesn't handle all situations correctly.  For example, a\n   capability\
    \ may not return to invocations in the same order that they\n   are received.\
    \  These situations also appear in the DCCS, so their\n   handling will be discussed\
    \ there rather than here.  It is important\n   to note that, except for delays\
    \ due to processing and communication,\n   the emulation done in the DCCS is exact.\n"
- title: The DCCS Implementation
  contents:
  - "The DCCS Implementation\n   The DCCS will initially be described on a network\
    \ of CCS systems.  We\n   will assume that there exists a network capability:\n\
    \   8. Network Capability\n      a. \"Input\"; > Host no., message;\n      b.\
    \ \"Output\", Host no., message > ;\n      It is assumed that the \"Output\" invocation\
    \ returns immediately\n      after queuing the message for output and that the\
    \ \"input\"\n      invocation waits until message is available.\n   For pedagogical\
    \ purposes, the description of the DCCS will be broken\n   into two parts.  First\
    \ a brief overview of the important mechanisms\n   will be given.  The overview\
    \ will  gloss over some important issues\n   that will be resolved individually\
    \ in the more complete description\n   that follows the overview.\n   The intent\
    \ of the DCCS is to allow capabilities on one host to be\n   referenced by processes\
    \ on other hosts having the appropriate\n   capabilities.  To do this, each host\
    \ keeps a list of capabilities\n   that it supports for use by other hosts.  Each\
    \ host also supports a\n   server, which gives out requestors that are made to\
    \ appear as if they\n   were the corresponding capability supported by the remote\
    \ host.  When\n   one of these emulated requestors is invoked, its parameters\
    \ are\n   passed by the emulating host through the network to the supporting\n\
    \   host.  The supporting host then sees to it that the proper capability\n  \
    \ is invoked and passed the parameters.  When the invoked parameters\n   are passed\
    \ back through the network to the emulating host.  The\n   emulating host then\
    \ returns the return parameters to the requesting\n   process.\n   For example,\
    \ let us take the \"Read\" request on a file diagrammed in\n   figure 4.  When\
    \ the emulated file (a requestor) is invoked, the\n   emulating process receives\
    \ \"invoke\", requestor number, PD; request.\n   The requestor number that is\
    \ returned is actually a descriptor\n   consisting of two numbers: Host number,\
    \ capability number.  These\n   descriptors are called Remote Capability Descriptors\
    \ (RCDs).  An RCD\n   identifies a host and a capability in the list of capabilities\n\
    \   supported by that host.  After receiving a request, the emulating\n   process\
    \ reads the parameters passed by the requesting process and\n   sends them along\
    \ with the Parameters Descriptor to the remote host in\n   an \"invoke\" message.\n\
    \   When the remote host receives this information, it passes the\n   parameters\
    \ to the supported file capability by invoking it and\n   specifies the proper\
    \ return parameters as noted in the Parameter\n   Descriptor.  When the invoked\
    \ file return parameters, the returned\n   data is passed back through the network\
    \ to the emulating host in a\n   \"Return\" message.  The returned data is then\
    \ returned to the\n   requesting process by performing a \"Return\" invocation\
    \ on the request\n   capability initially received by the emulating host.  When\
    \ the\n   requesting process is awakened by the return, it will appear to it\n\
    \   exactly as if a local file had been invoked.\n   This works fine when the\
    \ parameters being passed and returned consist\n   simply of information, but\
    \ what happens when there are capabilities\n   involved? In this case the routines\
    \ use the existing remote\n   capability access mechanism and pass the appropriate\
    \ descriptor.  As\n   an example, the \"Take\" invocation on a directory is diagrammed\
    \ in\n   figure 5.  The only essential difference is the fact that a\n   capability\
    \ has to be returned.  When the capability is returned by\n   the invoked directory\
    \ (or whatever it really is), the supporting host\n   allocates a new slot in\
    \ its supported capability list for the\n   capability and returns a new descriptor\
    \ to the emulating host.  When\n   the emulating host receives the descriptor,\
    \ it creates a new\n   requestor with the returned descriptor as its requestor\
    \ number and\n   returns the requestor to the invoking process.  The requestor\
    \ so\n   returned acts as the capability taken from the remotely accessed\n  \
    \ directory and can be invoked exactly as if were the real capability.\n   One\
    \ important thing to notice about this mechanism is that neither\n   the emulating\
    \ host nor the supporting host need to have any idea what\n   kind of capabilities\
    \ they are supporting.  The mechanism is\n   independent of their type.  Also\
    \ important is the fact that neither\n   host need trust the other host with anything\
    \ more than the\n   capabilities that it has been rightfully granted.  Even the\
    \ DCCS\n   processes themselves need only be trusted with the network\n   capabilities\
    \ and with the supported capabilities.  Finally, note that\n   no secret passwords\
    \ which might be disclosed are needed for security.\n   The DCCS directly extends\
    \ the CCS protection mechanisms,\n   A more complete description of the DCCS will\
    \ now be given.  To avoid\n   unnecessary complication, however, several issues\
    \ such as error\n   indications, system restart and recovery, network malfunctions,\n\
    \   message size limitations, resource problems, etc. are not discussed.\n   These\
    \ issues are not unique to the DCCS and their solutions are not\n   pertinent\
    \ here.\n   As noted earlier, the complete DCCS must address several issues that\n\
    \   were glossed over in the initial overview.  As these issues are\n   discussed,\
    \ several message types are introduced beyond the \"Invoke\"\n   and \"Return\"\
    \ messages discussed in the overview.  The formats for all\n   the DCCS messages\
    \ are summarized in figure 6.\n   A. Timing -\n      Invocations can take a very\
    \ long time to complete.  We saw an\n      example in the semaphore capability\
    \ earlier.  An even more graphic\n      example might be a clock capability that\
    \ was requested to return\n      nothing AFTER 100 years had passed.  Clearly\
    \ we don't want to have\n      the emulating process wait until it receives a\
    \ \"Return\" message\n      from the remote host before servicing more invocations.\n\
    \      What is done in the emulating host is to add the request\n      capability\
    \ to a list of pending requests after sending the\n      \"invoke\" message to\
    \ the supporting host (this is somewhat like the\n      semaphore example earlier).\
    \  The emulator can then go back and\n      wait for more local requests.\n  \
    \    There is a similar problem on the supporting side.  We don't want\n     \
    \ the process waiting on the network input capability to simply\n      invoke\
    \ the supported capability and wait for return.  What it must\n      do is to\
    \ set up an invocation process to actually invoke the\n      supported capability\
    \ so that pending network input can be promptly\n      serviced.  The invoking\
    \ process must then return the parameters\n      after it receives them.\n   \
    \   These additional mechanisms add complication of multiple requests\n      active\
    \ between hosts.  These requests are identified by a Remote\n      Request Number\
    \ (RRN).  The RRN is an index into the list of\n      pending requests.\n   B.\
    \ Loops -\n      If host A passes a capability to host B, and B is requested to\n\
    \      pass the requestor that is being used to emulate the capability\n     \
    \ back to host A, should B simply add the requestor to its support\n      list\
    \ and allow A to access it remotely? If it did, when the new\n      requestor\
    \ was invoked on A, the parameters would be passed to B\n      where they would\
    \ be passed to the requestor by the invoking\n      process.  Invoking the requestor\
    \ would cause the parameters to be\n      passed back through the network to A\
    \ where the real capability\n      would finally be invoked.  Then the return\
    \ parameters would have\n      to go through the reverse procedure to get back\
    \ A via B.  This is\n      clearly not an optimal mechanism,\n      The solution\
    \ to this problem makes use of the \"My requestor?\"\n      invocation on a server\
    \ capability described in 5b.  When B checks\n      a capability that is to be\
    \ returned to A with the \"My requestor?\"\n      invocation and finds that the\
    \ capability is one of its requestors\n      with a requestor number indicating\
    \ that it is supported on A, it\n      can simply return the requestor number\
    \ (recall that is this is\n      really a Remote Capability Descriptor, RCD) to\
    \ A, containing the\n      fact that the capability specified is one that is local\
    \ to A and\n      giving A the index to the capability in its supported capability\n\
    \      list.\n   C. Security\n      The mechanism presented in B. brings up something\
    \ of a security\n      issue.  If B. tries to invoke a capability in A's supported\
    \ list,\n      should A allow B access without question? If it did, any host on\n\
    \      the network could maliciously invoke any capability supported by\n    \
    \  any other host.  To allow access only if it has been granted\n      through\
    \ the standard invocation mechanism, each host can maintain\n      a bit vector\
    \ indicating which hosts have access to a given\n      capability.  If a host\
    \ does receive an invalid request, it is an\n      error condition.\n   D. Indirection\n\
    \      There is an additional twist on a Loop problem noted in B..  This\n   \
    \   variation comes up when A passes a capability to B who then wants\n      to\
    \ pass it to C.  Here again B may unambiguously specify which\n      capability\
    \ is to be passed by simply sending the Remote Capability\n      Descriptor (RCD)\
    \ that is knows it by.  The RCD indicates that the\n      capability, however,\
    \ A would probably not believe that C should\n      have access to it.\n     \
    \ B must tell A. \"1, who have access to your 1'th capability, want\n      to\
    \ grant it to host C\".  To do this, another message type is used.\n      The\
    \ \"Give\" message specifies the supported capability and the host\n      that\
    \ it should be given to (refer to figure 6).  Here again,\n      giving away a\
    \ capability that you don't have is an error\n      condition.\n   E. Acknowledgement\
    \ -\n      There is one last problem with the \"Give\" message.  If B sends the\n\
    \      \"Give\" message to A and then continues to send the Remote\n      Capability\
    \ Descriptor (RCD) to C, C may try to use the RCD before\n      the \"Give\" is\
    \ received by A.  For this reason, B must wait until A\n      has \"ACK\"nowledged\
    \ the \"Give\" message before sending the RCD to C.\n      This mechanism requires\
    \ that hosts queue un\"ACK\"nowledged \"Give\"s.\n      The format for an \"ACK\"\
    \ is given in figure 6.  This queueing may\n      be avoided for most \"Give\"\
    s after the first for a given RCD, but\n      only at the cost of much additional\
    \ memory and broadcasting\n      \"Delete\"s (See F. below).\n   F. Deletion -\n\
    \      If all the requestors on A for a given capability supported on B\n    \
    \  are deleted.  A may tell B so that B may:\n      a. Delete A's validation bit\
    \ in the bit vector for the specified\n      capability and\n      b. If there\
    \ are no hosts left that require support of the given\n      capability, the capability\
    \ may be deleted from the supported\n      capability list.\n      This function\
    \ requires a new \"Delete\" message.\n   Figure 6 is a summary of the message\
    \ formats.  Figure7-11 flow chart\n   the complete DCCS.  In the flow charts,\
    \ abbreviations are used to\n   indicates the directories:\n      CSL - Capability\
    \ Support List\n      RRL - Remote Request List\n      IPL - Invocation Process\
    \ List\n   The table manipulation is not given in detail.  Three tables are\n\
    \   needed.  The first is associated with the CSL and contains the bit\n   vectors\
    \ indicating access as noted in C. above.  The second table is\n   associated\
    \ with the RRL.  It contains a host number for each active\n   request.  An attempted\
    \ return on a request by a host other that the\n   requested host is an error.\
    \  The final table is a message buffer\n   containing the pending \"Invoke\" and\
    \ \"Return\" requests.\n   In order to avoid hazards in referencing the CSL and\
    \ its table, a\n   semaphore called the CSLS is used.  A message buffer semaphore,\
    \ MBS,\n   is similarly used to lock the message buffer.  For the RRL and IPL\
    \ no\n   locks are needed with the algorithms given.\n"
- title: Generalization and Application
  contents:
  - "Generalization and Application\n   To implement the DCCS, we assumed a network\
    \ of CCS systems.  The\n   specifications of the CCS were, however, very loose.\
    \  For example, no\n   mention was made of instruction sets.  Any CCS-like implementation\n\
    \   could use the mechanisms described herein to snare their objects.  A\n   process\
    \ passed to system with a different instruction set, for\n   example, could be\
    \ used as an efficient emulator.\n   The most important generalization of the\
    \ DCCS is to note that a given\n   implementation has no idea what kind of host\
    \ it is talking to over\n   the network.  Any sort of host could implement a protocol\
    \ using the\n   messages given.  For example, a single user system might allow\
    \ its\n   user to perform arbitrary invocations on remote capabilities and keep\n\
    \   a table of returned capabilities.  Such a system might also support\n   some\
    \ kind of standard terminal capability that could be given to\n   remote processes.\
    \  On a multi-user system, similar functions could be\n   performed for each user.\n\
    \   In some sense, any system implementing the DCCS protocol becomes a\n   C-list\
    \ system.  The single user system could, for example, set up\n   remote processes\
    \ servicing remote server capabilities giving out\n   requestors to the single\
    \ user system or any other systems.  Returns\n   from invocations could appear\
    \ on the single user's terminal by remote\n   invocation of the terminal capability,\
    \ etc..\n   Implementing the DCCS on non-C-list systems is similar in some\n \
    \  respects to what happened with some host to host protocol\n   implementations\
    \ on the Department Of Defense's ARPA network [10].\n   The ARPA network host\
    \ to host protocols allows a process on one\n   system to communicate with a process\
    \ on another.  Many of the ARPA\n   net protocol implementations had the effect\
    \ of introducing local\n   process to process communication in hosts that formerly\
    \ had none.\n   Applications\n      I. Single Copy\n         The first application\
    \ is a solution to what I have dubbed the\n         single copy problem for information\
    \ resources.  Whenever a\n         process receives information from a information\
    \ resource, it\n         can only receive a local copy of the information.  This\
    \ fact is\n         apparent when the information come from a distributed data\n\
    \         base, but is also true in tightly coupled virtual memory\n         situations\
    \ where information from shared memory must be copied\n         into local registers\
    \ for processing.  Once a process has a\n         local copy of some information,\
    \ it might like to try to insure\n         that the information remains current,\
    \ i.e., that it is the\n         single copy.\n         The traditional solution\
    \ to this problem is to lock the\n         information resource with a semaphore\
    \ before making a local\n         copy and then invalidate the local copy before\
    \ unlocking the\n         resource.  This solution suffers from the fact that,\
    \ even\n         though other processes may not be requesting the copied data,\n\
    \         the data must be unlocked quickly just in case.  This can\n        \
    \ result in many needless copies being made.\n         What is needed is a mechanism\
    \ for invalidating local copies\n         exactly when requests by other processes\
    \ would force\n         invalidation.  To offer such a mechanism, an information\n\
    \         resource can have, in addition to the usual reading and writing\n  \
    \       invocations, the following:\n            \"White lock\", portion; > ;\
    \ write notify\n            \"RW lock\", portion; >; RW notify\n         The important\
    \ invocation on the notify capabilities is:\n            \"Wait for notification\"\
    ; > reason;\n         The basic idea is to allow a process to request that it\
    \ be\n         notified if an attempt is being made to invalidate its copy.\n\
    \         If the copy is used for reading only, the process need only\n      \
    \   request notifications of attempted modifications of the data\n         (\"\
    Write lock\").  When a process is so notified, it is expected\n         to invalidate\
    \ its copy and delete its write notify capability\n         to inform the information\
    \ resource server that the pending\n         write access may proceed.\n     \
    \    In the read write lock case, the RW notify capability may also\n        \
    \ be used for reading and writing the portion.  Any other access\n         to\
    \ the portion will cause notification.  When notified, the\n         process with\
    \ the RW notify capability is expected to write back\n         the latest copy\
    \ of the information before deleting its RW\n         notify capability.\n   \
    \      Space does not permit presenting more details for this\n         mechanism.\
    \  The important fact to notice is that it permits an\n         information resource\
    \ to be shared in such a way that, though\n         the information may be widely\
    \ distributed, it is made to appear\n         as a single copy.  This mechanism\
    \ has important applications to\n         distributed data bases.\n      II. Network\
    \ Resource Optimization\n         The application that probably best demonstrates\
    \ the usefulness\n         of the DCCS is the sort of network optimization capability\
    \ that\n         can be used to create at least the primitive capabilities\n \
    \        introduced earlier:\n         9. Account Capability\n            a. \"\
    Create\", type; >; capability\n            The passed type parameter could at\
    \ least be any of: \"File\",\n            \"Directory\", \"Process\", or \"Server\"\
    .  The appropriate type\n            of capability would be returned.  The resources\
    \ used for the\n            capability are charged to the particular account.\n\
    \         Now suppose that a user on one CCS system within a DCCS network\n  \
    \       has remote access to account capabilities on several other CCS\n     \
    \    systems.  This user could create what might be called a super\n         account\
    \ capability to optimize use of his network resources.\n         The super account\
    \ capability would actually be a requestor\n         serviced by a process with\
    \ optimization desired would be\n         completely under user control, but some\
    \ of the more obvious\n         examples are presented:\n         1. Static Object\
    \ Creation Optimization\n            a. When a new file is requested, create it\
    \ on the system\n               with the fastest access or the least cost per\
    \ bit.\n            b. When a process is requested, create it on the system with\n\
    \               the fastest current response or with the least cost per\n    \
    \           instruction.\n         2. Dynamic optimization.\n            To do\
    \ dynamic optimization, the super account would not give\n            the requesting\
    \ process the capability that it received from\n            the remote account\
    \ after its static optimization, but would\n            give out a requestor that\
    \ it would make function like the\n            actual capability except optimized.\n\
    \            a. When network conditions or user needs charges, files can\n   \
    \            be moved to more effective systems.  changes in cost\n          \
    \     conditions might result in file movement.  Charges in\n               reliability\
    \ conditions might result in movement of files\n               and/or in addition\
    \ or deletion of multiple copies.\n            b. If system load conditions or\
    \ CPU charges change, it might\n               be effective to relocate a process.\
    \  The super account\n               service process could: create a new process\
    \ on a more\n               effective system, stop the old process, move the old\
    \ C-\n               list and memory to the new process and start the new\n  \
    \             process up.  The emulation process given to the user\n         \
    \      would never appear to change.\n            c. Similar optimizations can\
    \ be done on any other\n               capabilities.\n            Such a super\
    \ account can automatically optimize a user's\n            network resources to\
    \ suit the user's needs without changing\n            the functional characteristics\
    \ of the objects being\n            optimized.\n"
- title: Final Note
  contents:
  - "Final Note\n   The DCCS mechanisms defined in this paper are currently being\n\
    \   implemented on a Digital Equipment Corporation PDP-11/45 computer for\n  \
    \ use as an experimental protocol on the ARPA computer network [10].\n   The DCCS\
    \ protocol will also form the basis for a gateway between the\n   ARPA network\
    \ and Energy Research and Developement Agency's CTR\n   network [11].  It is the\
    \ authors hope that the DCCS mechanism will\n   hasten the approach of the kind\
    \ of networks that are needed to create\n   a truly free market in computational\
    \ resources.\n   Acknowledgements\n   The author would like to thank the administrators\
    \ and staff of the\n   Computer Research Project at the Lawrence Livemore Laboratory\
    \ for\n   creating the kind of environment conductive to the ideas presented in\n\
    \   this paper.  Special thanks are due to Charles Landau for many of the\n  \
    \ C-list ideas as implemented in the current RATS system.\n"
- title: References
  contents:
  - "References\n   1. C. R. Landau, The RATS Operating System, Lawrence Livermore\n\
    \   Laboratory, Report UCRL-77378 (1975)\n   2. C. R. Landau, An Introduction\
    \ to RATS (RISOS/ARPA Terminal\n   System): An Operating System for the DEC PDP-11/45,\
    \ Lawrence\n   Livermore Laboratory, Report UCRL-51582 (1974)\n   3. J. E. Donnelley,\
    \ Notes on RATS and Capability List Operating\n   Systems, Lawrence Livermore\
    \ Laboratory, Report UCID-16902 (1975)\n   4. B. W. Lampson, \"On Reliable and\
    \ Extendable Operating Systems\",\n   Techniques in Software Engineering, NATO\
    \ Sci Comm. Workshop Material,\n   Vol. II (1969)\n   5. W. Wulf, et. al., \"\
    HYDRA: The Kernel of a Multiprocessor Operating\n   System\", Communications of\
    \ the ACM 17 6 (1974)\n   6. P. Neumann et. al., \"On the Design of a Provably\
    \ Secure Operating\n   System\" International Workshop on Protection in Operating\
    \ Systems,\n   IRIA (1974)\n   7. R. S. Fabry, \"Capability-Based Addressing\"\
    , CACM 17 7 (1974)\n   8. E. W. Dijkstra, \"Cooperating Sequential Processes\"\
    , published in\n   Programming Languages, F. Genuys, editor, Academic Press, pp.\
    \ 43-112\n   (1968)\n   9. F. A. Akkoyunlu, et. al., \"Some Constraints and Tradeoffs\
    \ in the\n   Design of Network Communications\", Proceedings of the Fifth Symposium\n\
    \   on Operating System Principles, Vol. 9 No. 5 pp. 67-74 (1975)\n   10. L. G.\
    \ Roberts and B. D. Wessler, \"Computer Network Development to\n   Achieve Resource\
    \ Sharing\", AFLPS Conference Proceedings 36, pp.\n   543-549 (1970)\n   11. \"\
    National CTR Computer Center\", Lawrence Livermore Laboratory\n   Energy and Technology\
    \ Review, Lawrence Livermore Laboratory UCRL-\n   52000-75-12, December (1975)\n\
    \   The figures are not included in the online version.  Interested\n   readers\
    \ can obtain a hardcopy version of the documents including the\n   figures by\
    \ requesting a copy of UCRL-77800 from:\n   Technical Information Department\n\
    \   Lawrence Livermore Laboratory\n   University of California Livermore, California\
    \ 94550\n   Questions or comments would be appreciated and should be directed\
    \ to\n   the author:\n   Though the U.S. mail:\n   James E. Donnelley\n   Lawrence\
    \ Livermore Laboratory L-307\n   P. O. Box 808\n   Livermore, California 94550\n\
    \   By telephone:\n   (415)447-1100 ext. 3406\n   Via ARPA net mail:\n   JED@BBN\n\
    \   \"This report was prepared as an account of work sponsored by the\n   United\
    \ States Government.  Neither the United States nor the United\n   States Energy\
    \ Research & Development Administration, nor any of their\n   employees, nor any\
    \ of their contractors, subcontractors or their\n   employees, makes any warranty,\
    \ express or implied, or assumes any\n   legal liability or responsibility for\
    \ the accuracy, completeness or\n   usefulness of any information, apparatus,\
    \ product or process\n   disclosed, or represents that its use would not infringe\
    \ privately-\n   owned rights.\"\n"
