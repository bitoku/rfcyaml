- title: __initial_text__
  contents:
  - '  The Terminal Access Controller Access-Control System Plus (TACACS+)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Terminal Access Controller Access-Control\n\
    \   System Plus (TACACS+) protocol, which is widely deployed today to\n   provide\
    \ Device Administration for routers, network access servers,\n   and other networked\
    \ computing devices via one or more centralized\n   servers.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are candidates for any level of Internet\n\
    \   Standard; see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8907.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n   2.  Conventions\n   3.  Technical\
    \ Definitions\n     3.1.  Client\n     3.2.  Server\n     3.3.  Packet\n     3.4.\
    \  Connection\n     3.5.  Session\n     3.6.  Treatment of Enumerated Protocol\
    \ Values\n     3.7.  Treatment of Text Strings\n   4.  TACACS+ Packets and Sessions\n\
    \     4.1.  The TACACS+ Packet Header\n     4.2.  The TACACS+ Packet Body\n  \
    \   4.3.  Single Connection Mode\n     4.4.  Session Completion\n     4.5.  Data\
    \ Obfuscation\n   5.  Authentication\n     5.1.  The Authentication START Packet\
    \ Body\n     5.2.  The Authentication REPLY Packet Body\n     5.3.  The Authentication\
    \ CONTINUE Packet Body\n     5.4.  Description of Authentication Process\n   \
    \    5.4.1.  Version Behavior\n       5.4.2.  Common Authentication Flows\n  \
    \     5.4.3.  Aborting an Authentication Session\n   6.  Authorization\n     6.1.\
    \  The Authorization REQUEST Packet Body\n     6.2.  The Authorization REPLY Packet\
    \ Body\n   7.  Accounting\n     7.1.  The Account REQUEST Packet Body\n     7.2.\
    \  The Accounting REPLY Packet Body\n   8.  Argument-Value Pairs\n     8.1.  Value\
    \ Encoding\n     8.2.  Authorization Arguments\n     8.3.  Accounting Arguments\n\
    \   9.  Privilege Levels\n   10. Security Considerations\n     10.1.  General\
    \ Security of the Protocol\n     10.2.  Security of Authentication Sessions\n\
    \     10.3.  Security of Authorization Sessions\n     10.4.  Security of Accounting\
    \ Sessions\n     10.5.  TACACS+ Best Practices\n       10.5.1.  Shared Secrets\n\
    \       10.5.2.  Connections and Obfuscation\n       10.5.3.  Authentication\n\
    \       10.5.4.  Authorization\n       10.5.5.  Redirection Mechanism\n   11.\
    \ IANA Considerations\n   12. References\n     12.1.  Normative References\n \
    \    12.2.  Informative References\n   Acknowledgements\n   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes the Terminal Access Controller Access-Control\n\
    \   System Plus (TACACS+) protocol.  It was conceived initially as a\n   general\
    \ Authentication, Authorization, and Accounting (AAA) protocol.\n   It is widely\
    \ deployed today but is mainly confined for a specific\n   subset of AAA called\
    \ Device Administration, which includes\n   authenticating access to network devices,\
    \ providing central\n   authorization of operations, and auditing of those operations.\n\
    \   A wide range of TACACS+ clients and servers is already deployed in\n   the\
    \ field.  The TACACS+ protocol they are based on is defined in a\n   document\
    \ that was originally intended for IETF publication, but was\n   never standardized.\
    \  The document is known as \"The Draft\"\n   [THE-DRAFT].\n   This Draft was\
    \ a product of its time and did not address all of the\n   key security concerns\
    \ that are considered when designing modern\n   standards.  Therefore, deployment\
    \ must be executed with care.  These\n   concerns are addressed in Section 10.\n\
    \   The primary intent of this informational document is to clarify the\n   subset\
    \ of \"The Draft\", which is common to implementations supporting\n   Device Administration.\
    \  It is intended that all implementations that\n   conform to this document will\
    \ conform to \"The Draft\".  However, it is\n   not intended that all implementations\
    \ that conform to \"The Draft\"\n   will conform to this document.  The following\
    \ features from \"The\n   Draft\" have been removed:\n   *  This document officially\
    \ removes SENDPASS for security reasons.\n   *  The normative description of legacy\
    \ features such as the Apple\n      Remote Access Protocol (ARAP) and outbound\
    \ authentication has been\n      removed.\n   *  The Support for forwarding to\
    \ an alternative daemon\n      (TAC_PLUS_AUTHEN_STATUS_FOLLOW) has been deprecated.\n\
    \   The TACACS+ protocol allows for arbitrary length and content\n   authentication\
    \ exchanges to support alternative authentication\n   mechanisms.  It is extensible\
    \ to provide for site customization and\n   future development features, and it\
    \ uses TCP to ensure reliable\n   delivery.  The protocol allows the TACACS+ client\
    \ to request fine-\n   grained access control and allows the server to respond\
    \ to each\n   component of that request.\n   The separation of authentication,\
    \ authorization, and accounting is a\n   key element of the design of TACACS+\
    \ protocol.  Essentially, it makes\n   TACACS+ a suite of three protocols.  This\
    \ document will address each\n   one in separate sections.  Although TACACS+ defines\
    \ all three, an\n   implementation or deployment is not required to employ all\
    \ three.\n   Separating the elements is useful for the Device Administration use\n\
    \   case, specifically, for authorization and accounting of individual\n   commands\
    \ in a session.  Note that there is no provision made at the\n   protocol level\
    \ to associate authentication requests with\n   authorization requests.\n"
- title: 2.  Conventions
  contents:
  - "2.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n\
    \   capitals, as shown here.\n"
- title: 3.  Technical Definitions
  contents:
  - "3.  Technical Definitions\n   This section provides a few basic definitions that\
    \ are applicable to\n   this document.\n"
- title: 3.1.  Client
  contents:
  - "3.1.  Client\n   The client is any device that initiates TACACS+ protocol requests\
    \ to\n   mediate access, mainly for the Device Administration use case.\n"
- title: 3.2.  Server
  contents:
  - "3.2.  Server\n   The server receives TACACS+ protocol requests and replies according\n\
    \   to its business model in accordance with the flows defined in this\n   document.\n"
- title: 3.3.  Packet
  contents:
  - "3.3.  Packet\n   All uses of the word packet in this document refer to TACACS+\n\
    \   protocol data units unless explicitly noted otherwise.  The informal\n   term\
    \ \"packet\" has become an established part of the definition.\n"
- title: 3.4.  Connection
  contents:
  - "3.4.  Connection\n   TACACS+ uses TCP for its transport.  TCP Server port 49\
    \ is allocated\n   by IANA for TACACS+ traffic.\n"
- title: 3.5.  Session
  contents:
  - "3.5.  Session\n   The concept of a session is used throughout this document.\
    \  A TACACS+\n   session is a single authentication sequence, a single authorization\n\
    \   exchange, or a single accounting exchange.\n   An accounting and authorization\
    \ session will consist of a single pair\n   of packets (the request and its reply).\
    \  An authentication session\n   may involve an arbitrary number of packets being\
    \ exchanged.  The\n   session is an operational concept that is maintained between\
    \ the\n   TACACS+ client and server.  It does not necessarily correspond to a\n\
    \   given user or user action.\n"
- title: 3.6.  Treatment of Enumerated Protocol Values
  contents:
  - "3.6.  Treatment of Enumerated Protocol Values\n   This document describes various\
    \ enumerated values in the packet\n   header and the headers for specific packet\
    \ types.  For example, in\n   the authentication start packet type, this document\
    \ defines the\n   action field with three values: TAC_PLUS_AUTHEN_LOGIN,\n   TAC_PLUS_AUTHEN_CHPASS,\
    \ and TAC_PLUS_AUTHEN_SENDAUTH.\n   If the server does not implement one of the\
    \ defined options in a\n   packet that it receives, or it encounters an option\
    \ that is not\n   listed in this document for a header field, then it should respond\n\
    \   with an ERROR and terminate the session.  This will allow the client\n   to\
    \ try a different option.\n   If an error occurs but the type of the incoming\
    \ packet cannot be\n   determined, a packet with the identical cleartext header\
    \ but with a\n   sequence number incremented by one and the length set to zero\
    \ MUST be\n   returned to indicate an error.\n"
- title: 3.7.  Treatment of Text Strings
  contents:
  - "3.7.  Treatment of Text Strings\n   The TACACS+ protocol makes extensive use\
    \ of text strings.  \"The\n   Draft\" intended that these strings would be treated\
    \ as byte arrays\n   where each byte would represent a US-ASCII character.\n \
    \  More recently, server implementations have been extended to interwork\n   with\
    \ external identity services, and so a more nuanced approach is\n   needed.  Usernames\
    \ MUST be encoded and handled using the\n   UsernameCasePreserved Profile specified\
    \ in [RFC8265].  The security\n   considerations in Section 8 of [RFC8265] apply.\n\
    \   Where specifically mentioned, data fields contain arrays of arbitrary\n  \
    \ bytes as required for protocol processing.  These are not intended to\n   be\
    \ made visible through user interface to users.\n   All other text fields in TACACS+\
    \ MUST be treated as printable byte\n   arrays of US-ASCII as defined by [RFC0020].\
    \  The term \"printable\"\n   used here means the fields MUST exclude the \"Control\
    \ Characters\"\n   defined in Section 5.2 of [RFC0020].\n"
- title: 4.  TACACS+ Packets and Sessions
  contents:
  - '4.  TACACS+ Packets and Sessions

    '
- title: 4.1.  The TACACS+ Packet Header
  contents:
  - "4.1.  The TACACS+ Packet Header\n   All TACACS+ packets begin with the following\
    \ 12-byte header.  The\n   header describes the remainder of the packet:\n   \
    \ 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n   |major\
    \  | minor  |                |                |                |\n   |version|\
    \ version|      type      |     seq_no     |   flags        |\n   The following\
    \ general rules apply to all TACACS+ packet types:\n   *  To signal that any variable-length\
    \ data fields are unused, the\n      corresponding length values are set to zero.\
    \  Such fields MUST be\n      ignored, and treated as if not present.\n   *  The\
    \ lengths of data and message fields in a packet are specified\n      by their\
    \ corresponding length field (and are not null terminated).\n   *  All length\
    \ values are unsigned and in network byte order.\n   major_version\n      This\
    \ is the major TACACS+ version number.\n      TAC_PLUS_MAJOR_VER := 0xc\n   minor_version\n\
    \      This is the minor TACACS+ version number.\n      TAC_PLUS_MINOR_VER_DEFAULT\
    \ := 0x0\n      TAC_PLUS_MINOR_VER_ONE := 0x1\n   type\n      This is the packet\
    \ type.\n      Options are:\n      TAC_PLUS_AUTHEN := 0x01 (Authentication)\n\
    \      TAC_PLUS_AUTHOR := 0x02 (Authorization)\n      TAC_PLUS_ACCT := 0x03 (Accounting)\n\
    \   seq_no\n      This is the sequence number of the current packet.  The first\n\
    \      packet in a session MUST have the sequence number 1, and each\n      subsequent\
    \ packet will increment the sequence number by one.\n      TACACS+ clients only\
    \ send packets containing odd sequence numbers,\n      and TACACS+ servers only\
    \ send packets containing even sequence\n      numbers.\n      The sequence number\
    \ must never wrap, i.e., if the sequence number\n      2^(8)-1 is ever reached,\
    \ that session must terminate and be\n      restarted with a sequence number of\
    \ 1.\n   flags\n      This field contains various bitmapped flags.\n      The\
    \ flag bit:\n      TAC_PLUS_UNENCRYPTED_FLAG := 0x01\n      This flag indicates\
    \ that the sender did not obfuscate the body of\n      the packet.  This option\
    \ MUST NOT be used in production.  The\n      application of this flag will be\
    \ covered in \"Security\n      Considerations\" (Section 10).\n      This flag\
    \ SHOULD be clear in all deployments.  Modern network\n      traffic tools support\
    \ encrypted traffic when configured with the\n      shared secret (see \"Shared\
    \ Secrets\" (Section 10.5.1)), so\n      obfuscated mode can and SHOULD be used\
    \ even during test.\n      The single-connection flag:\n      TAC_PLUS_SINGLE_CONNECT_FLAG\
    \ := 0x04\n      This flag is used to allow a client and server to negotiate\n\
    \      \"Single Connection Mode\" (Section 4.3).\n      All other bits MUST be\
    \ ignored when reading, and SHOULD be set to\n      zero when writing.\n   session_id\n\
    \      The Id for this TACACS+ session.  This field does not change for\n    \
    \  the duration of the TACACS+ session.  This number MUST be\n      generated\
    \ by a cryptographically strong random number generation\n      method.  Failure\
    \ to do so will compromise security of the session.\n      For more details, refer\
    \ to [RFC4086].\n   length\n      The total length of the packet body (not including\
    \ the header).\n      Implementations MUST allow control over maximum packet sizes\n\
    \      accepted by TACACS+ Servers.  The recommended maximum packet size\n   \
    \   is 2^(16).\n"
- title: 4.2.  The TACACS+ Packet Body
  contents:
  - "4.2.  The TACACS+ Packet Body\n   The TACACS+ body types are defined in the packet\
    \ header.  The next\n   sections of this document will address the contents of\
    \ the different\n   TACACS+ bodies.\n"
- title: 4.3.  Single Connection Mode
  contents:
  - "4.3.  Single Connection Mode\n   Single Connection Mode is intended to improve\
    \ performance where there\n   is a lot of traffic between a client and a server\
    \ by allowing the\n   client to multiplex multiple sessions on a single TCP connection.\n\
    \   The packet header contains the TAC_PLUS_SINGLE_CONNECT_FLAG used by\n   the\
    \ client and server to negotiate the use of Single Connection Mode.\n   The client\
    \ sets this flag to indicate that it supports multiplexing\n   TACACS+ sessions\
    \ over a single TCP connection.  The client MUST NOT\n   send a second packet\
    \ on a connection until single-connect status has\n   been established.\n   To\
    \ indicate it will support Single Connection Mode, the server sets\n   this flag\
    \ in the first reply packet in response to the first request\n   from a client.\
    \  The server may set this flag even if the client does\n   not set it, but the\
    \ client may ignore the flag and close the\n   connection after the session completes.\n\
    \   The flag is only relevant for the first two packets on a connection,\n   to\
    \ allow the client and server to establish Single Connection Mode.\n   No provision\
    \ is made for changing Single Connection Mode after the\n   first two packets;\
    \ the client and server MUST ignore the flag after\n   the second packet on a\
    \ connection.\n   If Single Connection Mode has not been established in the first\
    \ two\n   packets of a TCP connection, then both the client and the server\n \
    \  close the connection at the end of the first session.\n   The client negotiates\
    \ Single Connection Mode to improve efficiency.\n   The server may refuse to allow\
    \ Single Connection Mode for the client.\n   For example, it may not be appropriate\
    \ to allocate a long-lasting TCP\n   connection to a specific client in some deployments.\
    \  Even if the\n   server is configured to permit Single Connection Mode for a\
    \ specific\n   client, the server may close the connection.  For example, a server\n\
    \   MUST be configured to time out a Single Connection Mode TCP\n   connection\
    \ after a specific period of inactivity to preserve its\n   resources.  The client\
    \ MUST accommodate such closures on a TCP\n   session even after Single Connection\
    \ Mode has been established.\n   The TCP connection underlying the Single Connection\
    \ Mode will close\n   eventually either because of the timeout from the server\
    \ or from an\n   intermediate link.  If a session is in progress when the client\n\
    \   detects disconnect, then the client should handle it as described in\n   \"\
    Session Completion\" (Section 4.4).  If a session is not in progress,\n   then\
    \ the client will need to detect this and restart the Single\n   Connection Mode\
    \ when it initiates the next session.\n"
- title: 4.4.  Session Completion
  contents:
  - "4.4.  Session Completion\n   The REPLY packets defined for the packet types in\
    \ the sections below\n   (Authentication, Authorization, and Accounting) contain\
    \ a status\n   field.  The complete set of options for this field depend upon\
    \ the\n   packet type, but all three REPLY packet types define values\n   representing\
    \ PASS, ERROR, and FAIL, which indicate the last packet of\n   a regular session\
    \ (one that is not aborted).\n   The server responds with a PASS or a FAIL to\
    \ indicate that the\n   processing of the request completed and that the client\
    \ can apply the\n   result (PASS or FAIL) to control the execution of the action\
    \ that\n   prompted the request to be sent to the server.\n   The server responds\
    \ with an ERROR to indicate that the processing of\n   the request did not complete.\
    \  The client cannot apply the result,\n   and it MUST behave as if the server\
    \ could not be connected to.  For\n   example, the client tries alternative methods,\
    \ if they are available,\n   such as sending the request to a backup server or\
    \ using local\n   configuration to determine whether the action that prompted\
    \ the\n   request should be executed.\n   Refer to \"Aborting an Authentication\
    \ Session\" (Section 5.4.3) for\n   details on handling additional status options.\n\
    \   When the session is complete, the TCP connection should be handled as\n  \
    \ follows, according to whether Single Connection Mode was negotiated:\n   * \
    \ If Single Connection Mode was not negotiated, then the connection\n      should\
    \ be closed.\n   *  If Single Connection Mode was enabled, then the connection\
    \ SHOULD\n      be left open (see \"Single Connection Mode\" (Section 4.3)) but\
    \ may\n      still be closed after a timeout period to preserve deployment\n \
    \     resources.\n   *  If Single Connection Mode was enabled, but an ERROR occurred\
    \ due\n      to connection issues (such as an incorrect secret (see\n      Section\
    \ 4.5)), then any further new sessions MUST NOT be accepted\n      on the connection.\
    \  If there are any sessions that have already\n      been established, then they\
    \ MAY be completed.  Once all active\n      sessions are completed, then the connection\
    \ MUST be closed.\n   It is recommended that client implementations provide robust\
    \ schemes\n   for dealing with servers that cannot be connected to.  Options\n\
    \   include providing a list of servers for redundancy and an option for\n   a\
    \ local fallback configuration if no servers can be reached.  Details\n   will\
    \ be implementation specific.\n   The client should manage connections and handle\
    \ the case of a server\n   that establishes a connection but does not respond.\
    \  The exact\n   behavior is implementation specific.  It is recommended that\
    \ the\n   client close the connection after a configurable timeout.\n"
- title: 4.5.  Data Obfuscation
  contents:
  - "4.5.  Data Obfuscation\n   The body of packets may be obfuscated.  The following\
    \ sections\n   describe the obfuscation method that is supported in the protocol.\n\
    \   In \"The Draft\", this process was actually referred to as Encryption,\n \
    \  but the algorithm would not meet modern standards and so will not be\n   termed\
    \ as encryption in this document.\n   The obfuscation mechanism relies on a secret\
    \ key, a shared secret\n   value that is known to both the client and the server.\
    \  The secret\n   keys MUST remain secret.\n   Server implementations MUST allow\
    \ a unique secret key to be\n   associated with each client.  It is a site-dependent\
    \ decision as to\n   whether or not the use of separate keys is appropriate.\n\
    \   The flag field MUST be configured with TAC_PLUS_UNENCRYPTED_FLAG set\n   to\
    \ 0 so that the packet body is obfuscated by XORing it bytewise with\n   a pseudo-random\
    \ pad:\n      ENCRYPTED {data} = data ^(pseudo_pad)\n   The packet body can then\
    \ be de-obfuscated by XORing it bytewise with\n   a pseudo-random pad.\n     \
    \ data = ENCRYPTED {data} ^(pseudo_pad)\n   The pad is generated by concatenating\
    \ a series of MD5 hashes (each 16\n   bytes long) and truncating it to the length\
    \ of the input data.\n   Whenever used in this document, MD5 refers to the \"\
    RSA Data Security,\n   Inc.  MD5 Message-Digest Algorithm\" as specified in [RFC1321].\n\
    \      pseudo_pad = {MD5_1 [,MD5_2 [ ... ,MD5_n]]} truncated to len(data)\n  \
    \ The first MD5 hash is generated by concatenating the session_id, the\n   secret\
    \ key, the version number, and the sequence number, and then\n   running MD5 over\
    \ that stream.  All of those input values are\n   available in the packet header,\
    \ except for the secret key, which is a\n   shared secret between the TACACS+\
    \ client and server.\n   The version number and session_id are extracted from\
    \ the header.\n   Subsequent hashes are generated by using the same input stream\
    \ but\n   concatenating the previous hash value at the end of the input stream.\n\
    \      MD5_1 = MD5{session_id, key, version, seq_no} MD5_2 =\n      MD5{session_id,\
    \ key, version, seq_no, MD5_1} ....  MD5_n =\n      MD5{session_id, key, version,\
    \ seq_no, MD5_n-1}\n   When a server detects that the secrets it has configured\
    \ for the\n   device do not match, it MUST return ERROR.  For details of TCP\n\
    \   connection handling on ERROR, refer to \"Session Completion\"\n   (Section\
    \ 4.4).\n      TAC_PLUS_UNENCRYPTED_FLAG == 0x1\n   This option is deprecated\
    \ and MUST NOT be used in production.  In\n   this case, the entire packet body\
    \ is in cleartext.  A request MUST be\n   dropped if TAC_PLUS_UNENCRYPTED_FLAG\
    \ is set to true.\n   After a packet body is de-obfuscated, the lengths of the\
    \ component\n   values in the packet are summed.  If the sum is not identical\
    \ to the\n   cleartext datalength value from the header, the packet MUST be\n\
    \   discarded and an ERROR signaled.  For details of TCP connection\n   handling\
    \ on ERROR, refer to \"Session Completion\" (Section 4.4).\n   Commonly, such\
    \ failures are seen when the keys are mismatched between\n   the client and the\
    \ TACACS+ server.\n"
- title: 5.  Authentication
  contents:
  - "5.  Authentication\n   Authentication is the action of determining who a user\
    \ (or entity)\n   is.  Authentication can take many forms.  Traditional authentication\n\
    \   employs a name and a fixed password.  However, fixed passwords are\n   vulnerable\
    \ security, so many modern authentication mechanisms utilize\n   \"one-time\"\
    \ passwords or a challenge-response query.  TACACS+ is\n   designed to support\
    \ all of these and be flexible enough to handle any\n   future mechanisms.  Authentication\
    \ generally takes place when the\n   user first logs in to a machine or requests\
    \ a service of it.\n   Authentication is not mandatory; it is a site-configured\
    \ option.\n   Some sites do not require it.  Others require it only for certain\n\
    \   services (see \"Authorization\" (Section 6)).  Authentication may also\n \
    \  take place when a user attempts to gain extra privileges and must\n   identify\
    \ himself or herself as someone who possesses the required\n   information (passwords,\
    \ etc.) for those privileges.\n"
- title: 5.1.  The Authentication START Packet Body
  contents:
  - "5.1.  The Authentication START Packet Body\n    1 2 3 4 5 6 7 8  1 2 3 4 5 6\
    \ 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n   |    action      |    priv_lvl   \
    \ |  authen_type   | authen_service |\n   |    user_len    |    port_len    |\
    \  rem_addr_len  |    data_len    |\n   |    user ...\n   |    port ...\n   |\
    \    rem_addr ...\n   |    data...\n   Packet fields are as follows:\n   action\n\
    \      This indicates the authentication action.\n      Valid values are:\n  \
    \    TAC_PLUS_AUTHEN_LOGIN := 0x01\n      TAC_PLUS_AUTHEN_CHPASS := 0x02\n   \
    \   TAC_PLUS_AUTHEN_SENDAUTH := 0x04\n   priv_lvl\n      This indicates the privilege\
    \ level that the user is authenticating\n      as.  Please refer to \"Privilege\
    \ Levels\" (Section 9).\n   authen_type\n      The type of authentication.  Please\
    \ see \"Common Authentication\n      Flows\" (Section 5.4.2).\n      Valid values\
    \ are:\n      TAC_PLUS_AUTHEN_TYPE_ASCII := 0x01\n      TAC_PLUS_AUTHEN_TYPE_PAP\
    \ := 0x02\n      TAC_PLUS_AUTHEN_TYPE_CHAP := 0x03\n      TAC_PLUS_AUTHEN_TYPE_MSCHAP\
    \ := 0x05\n      TAC_PLUS_AUTHEN_TYPE_MSCHAPV2 := 0x06\n   authen_service\n  \
    \    This is the service that is requesting the authentication.\n      Valid values\
    \ are:\n      TAC_PLUS_AUTHEN_SVC_NONE := 0x00\n      TAC_PLUS_AUTHEN_SVC_LOGIN\
    \ := 0x01\n      TAC_PLUS_AUTHEN_SVC_ENABLE := 0x02\n      TAC_PLUS_AUTHEN_SVC_PPP\
    \ := 0x03\n      TAC_PLUS_AUTHEN_SVC_PT := 0x05\n      TAC_PLUS_AUTHEN_SVC_RCMD\
    \ := 0x06\n      TAC_PLUS_AUTHEN_SVC_X25 := 0x07\n      TAC_PLUS_AUTHEN_SVC_NASI\
    \ := 0x08\n      TAC_PLUS_AUTHEN_SVC_FWPROXY := 0x09\n      The TAC_PLUS_AUTHEN_SVC_NONE\
    \ option is intended for the\n      authorization application of this field that\
    \ indicates that no\n      authentication was performed by the device.\n     \
    \ The TAC_PLUS_AUTHEN_SVC_LOGIN option indicates regular login (as\n      opposed\
    \ to ENABLE) to a client device.\n      The TAC_PLUS_AUTHEN_SVC_ENABLE option\
    \ identifies the ENABLE\n      authen_service, which refers to a service requesting\n\
    \      authentication in order to grant the user different privileges.\n     \
    \ This is comparable to the Unix \"su(1)\" command, which substitutes\n      the\
    \ current user's identity with another.  An authen_service value\n      of NONE\
    \ is only to be used when none of the other authen_service\n      values are appropriate.\
    \  ENABLE may be requested independently; no\n      requirements for previous\
    \ authentications or authorizations are\n      imposed by the protocol.\n    \
    \  Other options are included for legacy/backwards compatibility.\n   user, user_len\n\
    \      The username is optional in this packet, depending upon the class\n   \
    \   of authentication.  If it is absent, the client MUST set user_len\n      to\
    \ 0.  If included, the user_len indicates the length of the user\n      field,\
    \ in bytes.\n   port, port_len\n      The name of the client port on which the\
    \ authentication is taking\n      place.  The value of this field is free-format\
    \ text and is client\n      specific.  Examples of this argument include \"tty10\"\
    \ to denote the\n      tenth tty line, and \"async10\" to denote the tenth async\
    \ interface.\n      The client documentation SHOULD define the values and their\n\
    \      meanings for this field.  For details of text encoding, see\n      \"Treatment\
    \ of Text Strings\" (Section 3.7).  The port_len indicates\n      the length of\
    \ the port field, in bytes.\n   rem_addr, rem_addr_len\n      A string indicating\
    \ the remote location from which the user has\n      connected to the client.\
    \  For details of text encoding, see\n      \"Treatment of Text Strings\" (Section\
    \ 3.7).\n      When TACACS+ was used for dial-up services, this value contained\n\
    \      the caller ID.\n      When TACACS+ is used for Device Administration, the\
    \ user is\n      normally connected via a network, and in this case, the value\
    \ is\n      intended to hold a network address, IPv4 or IPv6.  For IPv6\n    \
    \  address text representation defined, please see [RFC5952].\n      This field\
    \ is optional (since the information may not be\n      available).  The rem_addr_len\
    \ indicates the length of the user\n      field, in bytes.\n   data, data_len\n\
    \      The data field is used to send data appropriate for the action and\n  \
    \    authen_type.  It is described in more detail in \"Common\n      Authentication\
    \ Flows\" (Section 5.4.2).  The data_len field\n      indicates the length of\
    \ the data field, in bytes.\n"
- title: 5.2.  The Authentication REPLY Packet Body
  contents:
  - "5.2.  The Authentication REPLY Packet Body\n   The TACACS+ server sends only\
    \ one type of authentication packet (a\n   REPLY packet) to the client.\n    1\
    \ 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n   |     status\
    \     |      flags     |        server_msg_len           |\n   |           data_len\
    \              |        server_msg ...\n   |           data ...\n   status\n \
    \     The current status of the authentication.\n      Valid values are:\n   \
    \   TAC_PLUS_AUTHEN_STATUS_PASS := 0x01\n      TAC_PLUS_AUTHEN_STATUS_FAIL :=\
    \ 0x02\n      TAC_PLUS_AUTHEN_STATUS_GETDATA := 0x03\n      TAC_PLUS_AUTHEN_STATUS_GETUSER\
    \ := 0x04\n      TAC_PLUS_AUTHEN_STATUS_GETPASS := 0x05\n      TAC_PLUS_AUTHEN_STATUS_RESTART\
    \ := 0x06\n      TAC_PLUS_AUTHEN_STATUS_ERROR := 0x07\n      TAC_PLUS_AUTHEN_STATUS_FOLLOW\
    \ := 0x21\n   flags\n      Bitmapped flags that modify the action to be taken.\n\
    \      The following values are defined:\n      TAC_PLUS_REPLY_FLAG_NOECHO :=\
    \ 0x01\n   server_msg, server_msg_len\n      A message to be displayed to the\
    \ user.  This field is optional.\n      The server_msg_len indicates the length\
    \ of the server_msg field,\n      in bytes.  For details of text encoding, see\
    \ \"Treatment of Text\n      Strings\" (Section 3.7).\n   data, data_len\n   \
    \   A field that holds data that is a part of the authentication\n      exchange\
    \ and is intended for client processing, not the user.  It\n      is not a printable\
    \ text encoding.  Examples of its use are shown\n      in \"Common Authentication\
    \ Flows\" (Section 5.4.2).  The data_len\n      indicates the length of the data\
    \ field, in bytes.\n"
- title: 5.3.  The Authentication CONTINUE Packet Body
  contents:
  - "5.3.  The Authentication CONTINUE Packet Body\n   This packet is sent from the\
    \ client to the server following the\n   receipt of a REPLY packet.\n    1 2 3\
    \ 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n   |         \
    \ user_msg len           |            data_len             |\n   |     flags \
    \     |  user_msg ...\n   |    data ...\n   +----------------+\n   user_msg, user_msg_len\n\
    \      A field that is the string that the user entered, or the client\n     \
    \ provided on behalf of the user, in response to the server_msg from\n      a\
    \ REPLY packet.  The user_len indicates the length of the user\n      field, in\
    \ bytes.\n   data, data_len\n      This field carries information that is specific\
    \ to the action and\n      the authen_type for this session.  Valid uses of this\
    \ field are\n      described below.  It is not a printable text encoding.  The\n\
    \      data_len indicates the length of the data field, in bytes.\n   flags\n\
    \      This holds the bitmapped flags that modify the action to be taken.\n  \
    \    The following values are defined:\n      TAC_PLUS_CONTINUE_FLAG_ABORT :=\
    \ 0x01\n"
- title: 5.4.  Description of Authentication Process
  contents:
  - "5.4.  Description of Authentication Process\n   The action, authen_type, and\
    \ authen_service fields (described above)\n   combine to indicate what kind of\
    \ authentication is to be performed.\n   Every authentication START, REPLY, and\
    \ CONTINUE packet includes a\n   data field.  The use of this field is dependent\
    \ upon the kind of\n   authentication.\n   This document defines a core set of\
    \ authentication flows to be\n   supported by TACACS+.  Each authentication flow\
    \ consists of a START\n   packet.  The server responds either with a request for\
    \ more\n   information (GETDATA, GETUSER, or GETPASS) or a termination PASS,\n\
    \   FAIL, ERROR, or RESTART.  The actions and meanings when the server\n   sends\
    \ a RESTART or ERROR are common and are described further below.\n   When the\
    \ REPLY status equals TAC_PLUS_AUTHEN_STATUS_GETDATA,\n   TAC_PLUS_AUTHEN_STATUS_GETUSER,\
    \ or TAC_PLUS_AUTHEN_STATUS_GETPASS,\n   authentication continues and the server\
    \ SHOULD provide server_msg\n   content for the client to prompt the user for\
    \ more information.  The\n   client MUST then return a CONTINUE packet containing\
    \ the requested\n   information in the user_msg field.\n   The client should interpret\
    \ TAC_PLUS_AUTHEN_STATUS_GETUSER as a\n   request for a username and TAC_PLUS_AUTHEN_STATUS_GETPASS\
    \ as a\n   request for a password.  The TAC_PLUS_AUTHEN_STATUS_GETDATA is the\n\
    \   generic request for more information to flexibly support future\n   requirements.\n\
    \   If the information being requested by the server from the client is\n   sensitive,\
    \ then the server should set the TAC_PLUS_REPLY_FLAG_NOECHO\n   flag.  When the\
    \ client queries the user for the information, the\n   response MUST NOT be reflected\
    \ in the user interface as it is\n   entered.\n   The data field is only used\
    \ in the REPLY where explicitly defined\n   below.\n"
- title: 5.4.1.  Version Behavior
  contents:
  - "5.4.1.  Version Behavior\n   The TACACS+ protocol is versioned to allow revisions\
    \ while\n   maintaining backwards compatibility.  The version number is in every\n\
    \   packet header.  The changes between minor_version 0 and 1 apply only\n   to\
    \ the authentication process, and all deal with the way that\n   Challenge Handshake\
    \ Authentication Protocol (CHAP) and Password\n   Authentication Protocol (PAP)\
    \ authentications are handled.\n   minor_version 1 may only be used for authentication\
    \ kinds that\n   explicitly call for it in the table below:\n                |\
    \ ASCII       | v0    | v0     | -        |\n                | PAP         | v1\
    \    | -      | v1       |\n                | CHAP        | v1    | -      | v1\
    \       |\n                | MS-CHAPv1/2 | v1    | -      | v1       |\n     \
    \               Table 1: TACACS+ Protocol Versioning\n   The '-' symbol represents\
    \ that the option is not valid.\n   All authorization and accounting and ASCII\
    \ authentication use\n   minor_version 0.\n   PAP, CHAP, and MS-CHAP login use\
    \ minor_version 1.  The normal\n   exchange is a single START packet from the\
    \ client and a single REPLY\n   from the server.\n   The removal of SENDPASS was\
    \ prompted by security concerns and is no\n   longer considered part of the TACACS+\
    \ protocol.\n"
- title: 5.4.2.  Common Authentication Flows
  contents:
  - "5.4.2.  Common Authentication Flows\n   This section describes common authentication\
    \ flows.  If the server\n   does not implement an option, it MUST respond with\n\
    \   TAC_PLUS_AUTHEN_STATUS_FAIL.\n"
- title: 5.4.2.1.  ASCII Login
  contents:
  - "5.4.2.1.  ASCII Login\n       action = TAC_PLUS_AUTHEN_LOGIN\n       authen_type\
    \ = TAC_PLUS_AUTHEN_TYPE_ASCII\n       minor_version = 0x0\n   This is a standard\
    \ ASCII authentication.  The START packet MAY\n   contain the username.  If the\
    \ user does not include the username,\n   then the server MUST obtain it from\
    \ the client with a CONTINUE\n   TAC_PLUS_AUTHEN_STATUS_GETUSER.  If the user\
    \ does not provide a\n   username, then the server can send another\n   TAC_PLUS_AUTHEN_STATUS_GETUSER\
    \ request, but the server MUST limit the\n   number of retries that are permitted;\
    \ the recommended limit is three\n   attempts.  When the server has the username,\
    \ it will obtain the\n   password using a continue with TAC_PLUS_AUTHEN_STATUS_GETPASS.\
    \  ASCII\n   login uses the user_msg field for both the username and password.\n\
    \   The data fields in both the START and CONTINUE packets are not used\n   for\
    \ ASCII logins; any content MUST be ignored.  The session is\n   composed of a\
    \ single START followed by zero or more pairs of REPLYs\n   and CONTINUEs, followed\
    \ by a final REPLY indicating PASS, FAIL, or\n   ERROR.\n"
- title: 5.4.2.2.  PAP Login
  contents:
  - "5.4.2.2.  PAP Login\n       action = TAC_PLUS_AUTHEN_LOGIN\n       authen_type\
    \ = TAC_PLUS_AUTHEN_TYPE_PAP\n       minor_version = 0x1\n   The entire exchange\
    \ MUST consist of a single START packet and a\n   single REPLY.  The START packet\
    \ MUST contain a username and the data\n   field MUST contain the PAP ASCII password.\
    \  A PAP authentication only\n   consists of a username and password [RFC1334]\
    \ (Obsolete).  The REPLY\n   from the server MUST be either a PASS, FAIL, or ERROR.\n"
- title: 5.4.2.3.  CHAP Login
  contents:
  - "5.4.2.3.  CHAP Login\n       action = TAC_PLUS_AUTHEN_LOGIN\n       authen_type\
    \ = TAC_PLUS_AUTHEN_TYPE_CHAP\n       minor_version = 0x1\n   The entire exchange\
    \ MUST consist of a single START packet and a\n   single REPLY.  The START packet\
    \ MUST contain the username in the user\n   field, and the data field is a concatenation\
    \ of the PPP id, the\n   challenge, and the response.\n   The length of the challenge\
    \ value can be determined from the length\n   of the data field minus the length\
    \ of the id (always 1 octet) and the\n   length of the response field (always\
    \ 16 octets).\n   To perform the authentication, the server calculates the PPP\
    \ hash as\n   defined in PPP Authentication [RFC1334] and then compares that value\n\
    \   with the response.  The MD5 algorithm option is always used.  The\n   REPLY\
    \ from the server MUST be a PASS, FAIL, or ERROR.\n   The selection of the challenge\
    \ and its length are not an aspect of\n   the TACACS+ protocol.  However, it is\
    \ strongly recommended that the\n   client/endstation interaction be configured\
    \ with a secure challenge.\n   The TACACS+ server can help by rejecting authentications\
    \ where the\n   challenge is below a minimum length (minimum recommended is 8\
    \ bytes).\n"
- title: 5.4.2.4.  MS-CHAP v1 Login
  contents:
  - "5.4.2.4.  MS-CHAP v1 Login\n       action = TAC_PLUS_AUTHEN_LOGIN\n       authen_type\
    \ = TAC_PLUS_AUTHEN_TYPE_MSCHAP\n       minor_version = 0x1\n   The entire exchange\
    \ MUST consist of a single START packet and a\n   single REPLY.  The START packet\
    \ MUST contain the username in the user\n   field, and the data field will be\
    \ a concatenation of the PPP id, the\n   MS-CHAP challenge, and the MS-CHAP response.\n\
    \   The length of the challenge value can be determined from the length\n   of\
    \ the data field minus the length of the id (always 1 octet) and the\n   length\
    \ of the response field (always 49 octets).\n   To perform the authentication,\
    \ the server will use a combination of\n   MD4 and DES on the user's secret and\
    \ the challenge, as defined in\n   [RFC2433], and then compare the resulting value\
    \ with the response.\n   The REPLY from the server MUST be a PASS or FAIL.\n \
    \  For best practices, please refer to [RFC2433].  The TACACS+ server\n   MUST\
    \ reject authentications where the challenge deviates from 8 bytes\n   as defined\
    \ in the RFC.\n"
- title: 5.4.2.5.  MS-CHAP v2 Login
  contents:
  - "5.4.2.5.  MS-CHAP v2 Login\n       action = TAC_PLUS_AUTHEN_LOGIN\n       authen_type\
    \ = TAC_PLUS_AUTHEN_TYPE_MSCHAPV2\n       minor_version = 0x1\n   The entire exchange\
    \ MUST consist of a single START packet and a\n   single REPLY.  The START packet\
    \ MUST contain the username in the user\n   field, and the data field will be\
    \ a concatenation of the PPP id, the\n   MS-CHAP challenge, and the MS-CHAP response.\n\
    \   The length of the challenge value can be determined from the length\n   of\
    \ the data field minus the length of the id (always 1 octet) and the\n   length\
    \ of the response field (always 49 octets).\n   To perform the authentication,\
    \ the server will use the algorithm\n   specified [RFC2759] on the user's secret\
    \ and challenge, and then\n   compare the resulting value with the response. \
    \ The REPLY from the\n   server MUST be a PASS or FAIL.\n   For best practices\
    \ for MS-CHAP v2, please refer to [RFC2759].  The\n   TACACS+ server MUST reject\
    \ authentications where the challenge\n   deviates from 16 bytes as defined in\
    \ the RFC.\n"
- title: 5.4.2.6.  Enable Requests
  contents:
  - "5.4.2.6.  Enable Requests\n       action = TAC_PLUS_AUTHEN_LOGIN\n       priv_lvl\
    \ = implementation dependent\n       authen_type = not used\n       service =\
    \ TAC_PLUS_AUTHEN_SVC_ENABLE\n   This is an \"ENABLE\" request, used to change\
    \ the current running\n   privilege level of a user.  The exchange MAY consist\
    \ of multiple\n   messages while the server collects the information it requires\
    \ in\n   order to allow changing the principal's privilege level.  This\n   exchange\
    \ is very similar to an ASCII login (Section 5.4.2.1).\n   In order to readily\
    \ distinguish \"ENABLE\" requests from other types of\n   request, the value of\
    \ the authen_service field MUST be set to\n   TAC_PLUS_AUTHEN_SVC_ENABLE when\
    \ requesting an ENABLE.  It MUST NOT be\n   set to this value when requesting\
    \ any other operation.\n"
- title: 5.4.2.7.  ASCII Change Password Request
  contents:
  - "5.4.2.7.  ASCII Change Password Request\n   action = TAC_PLUS_AUTHEN_CHPASS\n\
    \   authen_type = TAC_PLUS_AUTHEN_TYPE_ASCII\n   This exchange consists of multiple\
    \ messages while the server collects\n   the information it requires in order\
    \ to change the user's password.\n   It is very similar to an ASCII login.  The\
    \ status value\n   TAC_PLUS_AUTHEN_STATUS_GETPASS MUST only be used when requesting\
    \ the\n   \"new\" password.  It MAY be sent multiple times.  When requesting the\n\
    \   \"old\" password, the status value MUST be set to\n   TAC_PLUS_AUTHEN_STATUS_GETDATA.\n"
- title: 5.4.3.  Aborting an Authentication Session
  contents:
  - "5.4.3.  Aborting an Authentication Session\n   The client may prematurely terminate\
    \ a session by setting the\n   TAC_PLUS_CONTINUE_FLAG_ABORT flag in the CONTINUE\
    \ message.  If this\n   flag is set, the data portion of the message may contain\
    \ a text\n   explaining the reason for the abort.  This text will be handled by\n\
    \   the server according to the requirements of the deployment.  For\n   details\
    \ of text encoding, see \"Treatment of Text Strings\"\n   (Section 3.7).  For\
    \ more details about session termination, refer to\n   \"Session Completion\"\
    \ (Section 4.4).\n   In cases of PASS, FAIL, or ERROR, the server can insert a\
    \ message\n   into server_msg to be displayed to the user.\n   \"The Draft\" [THE-DRAFT]\
    \ defined a mechanism to direct authentication\n   requests to an alternative\
    \ server.  This mechanism is regarded as\n   insecure, is deprecated, and is not\
    \ covered here.  The client should\n   treat TAC_PLUS_AUTHEN_STATUS_FOLLOW as\
    \ TAC_PLUS_AUTHEN_STATUS_FAIL.\n   If the status equals TAC_PLUS_AUTHEN_STATUS_ERROR,\
    \ then the host is\n   indicating that it is experiencing an unrecoverable error\
    \ and the\n   authentication will proceed as if that host could not be contacted.\n\
    \   The data field may contain a message to be printed on an\n   administrative\
    \ console or log.\n   If the status equals TAC_PLUS_AUTHEN_STATUS_RESTART, then\
    \ the\n   authentication sequence is restarted with a new START packet from the\n\
    \   client, with a new session Id and seq_no set to 1.  This REPLY packet\n  \
    \ indicates that the current authen_type value (as specified in the\n   START\
    \ packet) is not acceptable for this session.  The client may try\n   an alternative\
    \ authen_type.\n   If a client does not implement the TAC_PLUS_AUTHEN_STATUS_RESTART\n\
    \   option, then it MUST process the response as if the status was\n   TAC_PLUS_AUTHEN_STATUS_FAIL.\n"
- title: 6.  Authorization
  contents:
  - "6.  Authorization\n   In the TACACS+ protocol, authorization is the action of\
    \ determining\n   what a user is allowed to do.  Generally, authentication precedes\n\
    \   authorization, though it is not mandatory that a client use the same\n   service\
    \ for authentication that it will use for authorization.  An\n   authorization\
    \ request may indicate that the user is not authenticated\n   (we don't know who\
    \ they are).  In this case, it is up to the server\n   to determine, according\
    \ to its configuration, if an unauthenticated\n   user is allowed the services\
    \ in question.\n   Authorization does not merely provide yes or no answers, but\
    \ it may\n   also customize the service for the particular user.  A common use\
    \ of\n   authorization is to provision a shell session when a user first logs\n\
    \   into a device to administer it.  The TACACS+ server might respond to\n   the\
    \ request by allowing the service, but placing a time restriction\n   on the login\
    \ shell.  For a list of common arguments used in\n   authorization, see \"Authorization\
    \ Arguments\" (Section 8.2).\n   In the TACACS+ protocol, an authorization is\
    \ always a single pair of\n   messages: a REQUEST from the client followed by\
    \ a REPLY from the\n   server.\n   The authorization REQUEST message contains\
    \ a fixed set of fields that\n   indicate how the user was authenticated and a\
    \ variable set of\n   arguments that describe the services and options for which\n\
    \   authorization is requested.\n   The REPLY contains a variable set of response\
    \ arguments (argument-\n   value pairs) that can restrict or modify the client's\
    \ actions.\n"
- title: 6.1.  The Authorization REQUEST Packet Body
  contents:
  - "6.1.  The Authorization REQUEST Packet Body\n     1 2 3 4 5 6 7 8  1 2 3 4 5\
    \ 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n   |  authen_method |    priv_lvl \
    \   |  authen_type   | authen_service |\n   |    user_len    |    port_len   \
    \ |  rem_addr_len  |    arg_cnt     |\n   |   arg_1_len    |   arg_2_len    |\
    \      ...       |   arg_N_len    |\n   |   user ...\n   |   port ...\n   |  \
    \ rem_addr ...\n   |   arg_1 ...\n   |   arg_2 ...\n   |   ...\n   |   arg_N ...\n\
    \   authen_method\n      This field allows the client to indicate the authentication\
    \ method\n      used to acquire user information.\n      TAC_PLUS_AUTHEN_METH_NOT_SET\
    \ := 0x00\n      TAC_PLUS_AUTHEN_METH_NONE := 0x01\n      TAC_PLUS_AUTHEN_METH_KRB5\
    \ := 0x02\n      TAC_PLUS_AUTHEN_METH_LINE := 0x03\n      TAC_PLUS_AUTHEN_METH_ENABLE\
    \ := 0x04\n      TAC_PLUS_AUTHEN_METH_LOCAL := 0x05\n      TAC_PLUS_AUTHEN_METH_TACACSPLUS\
    \ := 0x06\n      TAC_PLUS_AUTHEN_METH_GUEST := 0x08\n      TAC_PLUS_AUTHEN_METH_RADIUS\
    \ := 0x10\n      TAC_PLUS_AUTHEN_METH_KRB4 := 0x11\n      TAC_PLUS_AUTHEN_METH_RCMD\
    \ := 0x20\n      As this information is not always subject to verification, it\
    \ MUST\n      NOT be used in policy evaluation.  LINE refers to a fixed password\n\
    \      associated with the terminal line used to gain access.  LOCAL is a\n  \
    \    client local user database.  ENABLE is a command that\n      authenticates\
    \ in order to grant new privileges.  TACACSPLUS is, of\n      course, TACACS+.\
    \  GUEST is an unqualified guest authentication.\n      RADIUS is the RADIUS authentication\
    \ protocol.  RCMD refers to\n      authentication provided via the R-command protocols\
    \ from Berkeley\n      Unix.  KRB5 [RFC4120] and KRB4 [KRB4] are Kerberos versions\
    \ 5 and\n      4.\n      As mentioned above, this field is used by the client\
    \ to indicate\n      how it performed the authentication.  One of the options\n\
    \      (TAC_PLUS_AUTHEN_METH_TACACSPLUS := 0x06) is TACACS+ itself, and\n    \
    \  so the detail of how the client performed this option is given in\n      \"\
    Authentication\" (Section 5).  For all other options, such as KRB\n      and RADIUS,\
    \ the TACACS+ protocol did not play any part in the\n      authentication phase;\
    \ as those interactions were not conducted\n      using the TACACS+ protocol,\
    \ they will not be documented here.  For\n      implementers of clients who need\
    \ details of the other protocols,\n      please refer to the respective Kerberos\
    \ [RFC4120] and RADIUS\n      [RFC3579] RFCs.\n   priv_lvl\n      This field is\
    \ used in the same way as the priv_lvl field in\n      authentication request\
    \ and is described in \"Privilege Levels\"\n      (Section 9).  It indicates the\
    \ user's current privilege level.\n   authen_type\n      This field corresponds\
    \ to the authen_type field in\n      \"Authentication\" (Section 5).  It indicates\
    \ the type of\n      authentication that was performed.  If this information is\
    \ not\n      available, then the client will set authen_type to\n      TAC_PLUS_AUTHEN_TYPE_NOT_SET\
    \ := 0x00.  This value is valid only in\n      authorization and accounting requests.\n\
    \   authen_service\n      This field is the same as the authen_service field in\n\
    \      \"Authentication\" (Section 5).  It indicates the service through\n   \
    \   which the user authenticated.\n   user, user_len\n      This field contains\
    \ the user's account name.  The user_len MUST\n      indicate the length of the\
    \ user field, in bytes.\n   port, port_len\n      This field matches the port\
    \ field in \"Authentication\" (Section 5).\n      The port_len indicates the length\
    \ of the port field, in bytes.\n   rem_addr, rem_addr_len\n      This field matches\
    \ the rem_addr field in \"Authentication\"\n      (Section 5).  The rem_addr_len\
    \ indicates the length of the port\n      field, in bytes.\n   arg_cnt\n     \
    \ This represents the number of authorization arguments to follow.\n   arg_1 ...\
    \ arg_N, arg_1_len .... arg_N_len\n      These arguments are the primary elements\
    \ of the authorization\n      interaction.  In the request packet, they describe\
    \ the specifics\n      of the authorization that is being requested.  Each argument\
    \ is\n      encoded in the packet as a single arg field (arg_1...  arg_N) with\n\
    \      a corresponding length field (which indicates the length of each\n    \
    \  argument in bytes).\n      The authorization arguments in both the REQUEST\
    \ and the REPLY are\n      argument-value pairs.  The argument and the value are\
    \ in a single\n      string and are separated by either a \"=\" (0X3D) or a \"\
    *\" (0X2A).\n      The equals sign indicates a mandatory argument.  The asterisk\n\
    \      indicates an optional one.  For details of text encoding, see\n      \"\
    Treatment of Text Strings\" (Section 3.7).\n      An argument name MUST NOT contain\
    \ either of the separators.  An\n      argument value MAY contain the separators.\
    \  This means that the\n      arguments must be parsed until the first separator\
    \ is encountered;\n      all characters in the argument, after this separator,\
    \ are\n      interpreted as the argument value.\n      Optional arguments are\
    \ ones that may be disregarded by either\n      client or server.  Mandatory arguments\
    \ require that the receiving\n      side can handle the argument, that is, its\
    \ implementation and\n      configuration includes the details of how to act on\
    \ it.  If the\n      client receives a mandatory argument that it cannot handle,\
    \ it\n      MUST consider the authorization to have failed.  The value part of\n\
    \      an argument-value pair may be empty, that is, the length of the\n     \
    \ value may be zero.\n      Argument-value strings are not NULL terminated; rather,\
    \ their\n      length value indicates their end.  The maximum length of an\n \
    \     argument-value string is 255 characters.  The minimum is two\n      characters\
    \ (one name-value character and the separator).\n      Though the arguments allow\
    \ extensibility, a common core set of\n      authorization arguments SHOULD be\
    \ supported by clients and\n      servers; these are listed in \"Authorization\
    \ Arguments\"\n      (Section 8.2).\n"
- title: 6.2.  The Authorization REPLY Packet Body
  contents:
  - "6.2.  The Authorization REPLY Packet Body\n    1 2 3 4 5 6 7 8  1 2 3 4 5 6 7\
    \ 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n   |    status      |     arg_cnt    |\
    \         server_msg len          |\n   +            data_len             |  \
    \  arg_1_len   |    arg_2_len   |\n   |      ...       |   arg_N_len    |    \
    \     server_msg ...\n   |   data ...\n   |   arg_1 ...\n   |   arg_2 ...\n  \
    \ |   ...\n   |   arg_N ...\n   status\n      This field indicates the authorization\
    \ status.\n      TAC_PLUS_AUTHOR_STATUS_PASS_ADD := 0x01\n          If the status\
    \ equals TAC_PLUS_AUTHOR_STATUS_PASS_ADD, then the\n          arguments specified\
    \ in the request are authorized and the\n          arguments in the response MUST\
    \ be applied according to the\n          rules described above.\n          To\
    \ approve the authorization with no modifications, the server\n          sets\
    \ the status to TAC_PLUS_AUTHOR_STATUS_PASS_ADD and the\n          arg_cnt to\
    \ 0.\n      TAC_PLUS_AUTHOR_STATUS_PASS_REPL := 0x02\n          If the status\
    \ equals TAC_PLUS_AUTHOR_STATUS_PASS_REPL, then\n          the client MUST use\
    \ the authorization argument-value pairs (if\n          any) in the response instead\
    \ of the authorization argument-\n          value pairs from the request.\n  \
    \    TAC_PLUS_AUTHOR_STATUS_FAIL := 0x10\n          If the status equals TAC_PLUS_AUTHOR_STATUS_FAIL,\
    \ then the\n          requested authorization MUST be denied.\n      TAC_PLUS_AUTHOR_STATUS_ERROR\
    \ := 0x11\n          A status of TAC_PLUS_AUTHOR_STATUS_ERROR indicates an error\n\
    \          occurred on the server.  For the differences between ERROR and\n  \
    \        FAIL, refer to \"Session Completion\" (Section 4.4).  None of\n     \
    \     the arg values have any relevance if an ERROR is set and must\n        \
    \  be ignored.\n      TAC_PLUS_AUTHOR_STATUS_FOLLOW := 0x21\n          When the\
    \ status equals TAC_PLUS_AUTHOR_STATUS_FOLLOW, the\n          arg_cnt MUST be\
    \ 0.  In that case, the actions to be taken and\n          the contents of the\
    \ data field are identical to the\n          TAC_PLUS_AUTHEN_STATUS_FOLLOW status\
    \ for authentication.\n   server_msg, server_msg_len\n      This is a string that\
    \ may be presented to the user.  The\n      server_msg_len indicates the length\
    \ of the server_msg field, in\n      bytes.  For details of text encoding, see\
    \ \"Treatment of Text\n      Strings\" (Section 3.7).\n   data, data_len\n   \
    \   This is a string that may be presented on an administrative\n      display,\
    \ console, or log.  The decision to present this message is\n      client specific.\
    \  The data_len indicates the length of the data\n      field, in bytes.  For\
    \ details of text encoding, see \"Treatment of\n      Text Strings\" (Section\
    \ 3.7).\n   arg_cnt\n      This represents the number of authorization arguments\
    \ to follow.\n   arg_1 ... arg_N, arg_1_len .... arg_N_len\n      The arguments\
    \ describe the specifics of the authorization that is\n      being requested.\
    \  For details of the content of the args, refer to\n      \"Authorization Arguments\"\
    \ (Section 8.2).  Each argument is encoded\n      in the packet as a single arg\
    \ field (arg_1... arg_N) with a\n      corresponding length field (which indicates\
    \ the length of each\n      argument in bytes).\n"
- title: 7.  Accounting
  contents:
  - "7.  Accounting\n   Accounting is typically the third action after authentication\
    \ and\n   authorization.  But again, neither authentication nor authorization\n\
    \   is required.  Accounting is the action of recording what a user is\n   doing\
    \ and/or has done.  Accounting in TACACS+ can serve two purposes:\n   it may be\
    \ used as an auditing tool for security services, and it may\n   also be used\
    \ to account for services used such as in a billing\n   environment.  To this\
    \ end, TACACS+ supports three types of accounting\n   records: Start records indicate\
    \ that a service is about to begin,\n   Stop records indicate that a service has\
    \ just terminated, and Update\n   records are intermediate notices that indicate\
    \ that a service is\n   still being performed.  TACACS+ accounting records contain\
    \ all the\n   information used in the authorization records and also contain\n\
    \   accounting-specific information such as start and stop times (when\n   appropriate)\
    \ and resource usage information.  A list of accounting\n   arguments is defined\
    \ in \"Accounting Arguments\" (Section 8.3).\n"
- title: 7.1.  The Account REQUEST Packet Body
  contents:
  - "7.1.  The Account REQUEST Packet Body\n    1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8 \
    \ 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n   |      flags     |  authen_method |   \
    \ priv_lvl    |  authen_type   |\n   | authen_service |    user_len    |    port_len\
    \    |  rem_addr_len  |\n   |    arg_cnt     |   arg_1_len    |   arg_2_len  \
    \  |      ...       |\n   |   arg_N_len    |    user ...\n   |   port ...\n  \
    \ |   rem_addr ...\n   |   arg_1 ...\n   |   arg_2 ...\n   |   ...\n   |   arg_N\
    \ ...\n   flags\n      This holds bitmapped flags.\n      Valid values are:\n\
    \      TAC_PLUS_ACCT_FLAG_START := 0x02\n      TAC_PLUS_ACCT_FLAG_STOP := 0x04\n\
    \      TAC_PLUS_ACCT_FLAG_WATCHDOG := 0x08\n   All other fields are defined in\
    \ \"Authentication\" (Section 5) and\n   \"Authorization\" (Section 6) and have\
    \ the same semantics.  They\n   provide details for the conditions on the client,\
    \ and authentication\n   context, so that these details may be logged for accounting\
    \ purposes.\n   See \"Accounting Arguments\" (Section 8.3) for the dictionary\
    \ of\n   arguments relevant to accounting.\n"
- title: 7.2.  The Accounting REPLY Packet Body
  contents:
  - "7.2.  The Accounting REPLY Packet Body\n   The purpose of accounting is to record\
    \ the action that has occurred\n   on the client.  The server MUST reply with\
    \ success only when the\n   accounting request has been recorded.  If the server\
    \ did not record\n   the accounting request, then it MUST reply with ERROR.\n\
    \    1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n   |\
    \         server_msg len          |            data_len             |\n   |  \
    \   status     |         server_msg ...\n   |     data ...\n   +----------------+\n\
    \   status\n      This is the return status.\n      Values are:\n      TAC_PLUS_ACCT_STATUS_SUCCESS\
    \ := 0x01\n      TAC_PLUS_ACCT_STATUS_ERROR := 0x02\n      TAC_PLUS_ACCT_STATUS_FOLLOW\
    \ := 0x21\n          When the status equals TAC_PLUS_ACCT_STATUS_FOLLOW, the\n\
    \          actions to be taken and the contents of the data field are\n      \
    \    identical to the TAC_PLUS_AUTHEN_STATUS_FOLLOW status for\n          authentication.\n\
    \   server_msg, server_msg_len\n      This is a string that may be presented to\
    \ the user.  The\n      server_msg_len indicates the length of the server_msg\
    \ field, in\n      bytes.  For details of text encoding, see \"Treatment of Text\n\
    \      Strings\" (Section 3.7).\n   data, data_len\n      This is a string that\
    \ may be presented on an administrative\n      display, console, or log.  The\
    \ decision to present this message is\n      client specific.  The data_len indicates\
    \ the length of the data\n      field, in bytes.  For details of text encoding,\
    \ see \"Treatment of\n      Text Strings\" (Section 3.7).\n   TACACS+ accounting\
    \ is intended to record various types of events on\n   clients, for example: login\
    \ sessions, command entry, and others as\n   required by the client implementation.\
    \  These events are collectively\n   referred to in \"The Draft\" [THE-DRAFT]\
    \ as \"tasks\".\n   The TAC_PLUS_ACCT_FLAG_START flag indicates that this is a\
    \ start\n   accounting message.  Start messages will only be sent once when a\n\
    \   task is started.  The TAC_PLUS_ACCT_FLAG_STOP indicates that this is\n   a\
    \ stop record and that the task has terminated.  The\n   TAC_PLUS_ACCT_FLAG_WATCHDOG\
    \ flag means that this is an update record.\n    | Watchdog | Stop | Start | Flags\
    \ & 0xE | Meaning                 |\n    | 0        | 0    | 0     | 0       \
    \    | INVALID                 |\n    | 0        | 0    | 1     | 2          \
    \ | Start Accounting Record |\n    | 0        | 1    | 0     | 4           | Stop\
    \ Accounting Record  |\n    | 0        | 1    | 1     | 6           | INVALID\
    \                 |\n    | 1        | 0    | 0     | 8           | Watchdog, no\
    \ update     |\n    | 1        | 0    | 1     | A           | Watchdog, with update\
    \   |\n    | 1        | 1    | 0     | C           | INVALID                 |\n\
    \    | 1        | 1    | 1     | E           | INVALID                 |\n   \
    \                Table 2: Summary of Accounting Packets\n   The START and STOP\
    \ flags are mutually exclusive.\n   The WATCHDOG flag is used by the client to\
    \ communicate ongoing status\n   of a long-running task.  Update records are sent\
    \ at the client's\n   discretion.  The frequency of the update depends upon the\
    \ intended\n   application: a watchdog to provide progress indication will require\n\
    \   higher frequency than a daily keep-alive.  When the WATCHDOG flag is\n   set\
    \ along with the START flag, it indicates that the update record\n   provides\
    \ additional or updated arguments from the original START\n   record.  If the\
    \ START flag is not set, then this indicates only that\n   task is still running,\
    \ and no new information is provided (servers\n   MUST ignore any arguments).\
    \  The STOP flag MUST NOT be set in\n   conjunction with the WATCHDOG flag.\n\
    \   The server MUST respond with TAC_PLUS_ACCT_STATUS_ERROR if the client\n  \
    \ requests an INVALID option.\n"
- title: 8.  Argument-Value Pairs
  contents:
  - "8.  Argument-Value Pairs\n   TACACS+ is intended to be an extensible protocol.\
    \  The arguments used\n   in Authorization and Accounting are not limited by this\
    \ document.\n   Some arguments are defined below for common use cases.  Clients\
    \ MUST\n   use these arguments when supporting the corresponding use cases.\n"
- title: 8.1.  Value Encoding
  contents:
  - "8.1.  Value Encoding\n   All argument values are encoded as strings.  For details\
    \ of text\n   encoding, see \"Treatment of Text Strings\" (Section 3.7).  The\n\
    \   following type representations SHOULD be followed.\n   Numeric\n      All\
    \ numeric values in an argument-value string are provided as\n      decimal numbers,\
    \ unless otherwise stated.  All arguments include a\n      length field, and TACACS+\
    \ implementations MUST verify that they\n      can accommodate the lengths of\
    \ numeric arguments before attempting\n      to process them.  If the length cannot\
    \ be accommodated, then the\n      argument MUST be regarded as not handled and\
    \ the logic in\n      \"Authorization\" (Section 6.1) regarding the processing\
    \ of\n      arguments MUST be applied.\n   Boolean\n      All Boolean arguments\
    \ are encoded with values \"true\" or \"false\".\n   IP-Address\n      It is recommended\
    \ that hosts be specified as an IP address so as\n      to avoid any ambiguities.\
    \  For details of text encoding, see\n      \"Treatment of Text Strings\" (Section\
    \ 3.7).  IPv4 addresses are\n      specified as octet numerics separated by dots\
    \ ('.').  IPv6 address\n      text representation is defined in [RFC5952].\n \
    \  Date Time\n      Absolute date/times are specified in seconds since the epoch,\n\
    \      12:00am, January 1, 1970.  The time zone MUST be UTC unless a time\n  \
    \    zone argument is specified.\n   String\n      Many values have no specific\
    \ type representation and are\n      interpreted as plain strings.\n   Empty Values\n\
    \      Arguments may be submitted with no value, in which case they\n      consist\
    \ of the name and the mandatory or optional separator.  For\n      example, the\
    \ argument \"cmd\", which has no value, is transmitted as\n      a string of four\
    \ characters \"cmd=\".\n"
- title: 8.2.  Authorization Arguments
  contents:
  - "8.2.  Authorization Arguments\n   service (String)\n      The primary service.\
    \  Specifying a service argument indicates that\n      this is a request for authorization\
    \ or accounting of that service.\n      For example: \"shell\", \"tty-server\"\
    , \"connection\", \"system\" and\n      \"firewall\"; others may be chosen for\
    \ the required application.\n      This argument MUST always be included.\n  \
    \ protocol (String)\n      A field that may be used to indicate a subset of a\
    \ service.\n   cmd (String)\n      A shell (exec) command.  This indicates the\
    \ command name of the\n      command that is to be run.  The \"cmd\" argument\
    \ MUST be specified\n      if service equals \"shell\".\n      Authorization of\
    \ shell commands is a common use case for the\n      TACACS+ protocol.  Command\
    \ Authorization generally takes one of\n      two forms: session based or command\
    \ based.\n      For session-based shell authorization, the \"cmd\" argument will\n\
    \      have an empty value.  The client determines which commands are\n      allowed\
    \ in a session according to the arguments present in the\n      authorization.\n\
    \      In command-based authorization, the client requests that the\n      server\
    \ determine whether a command is allowed by making an\n      authorization request\
    \ for each command.  The \"cmd\" argument will\n      have the command name as\
    \ its value.\n   cmd-arg (String)\n      An argument to a shell (exec) command.\
    \  This indicates an argument\n      for the shell command that is to be run.\
    \  Multiple cmd-arg\n      arguments may be specified, and they are order dependent.\n\
    \   acl (Numeric)\n      A number representing a connection access list.  Applicable\
    \ only\n      to session-based shell authorization.  For details of text\n   \
    \   encoding, see \"Treatment of Text Strings\" (Section 3.7).\n   inacl (String)\n\
    \      The identifier (name) of an interface input access list.  For\n      details\
    \ of text encoding, see \"Treatment of Text Strings\"\n      (Section 3.7).\n\
    \   outacl (String)\n      The identifier (name) of an interface output access\
    \ list.  For\n      details of text encoding, see \"Treatment of Text Strings\"\
    \n      (Section 3.7).\n   addr (IP-Address)\n      A network address.\n   addr-pool\
    \ (String)\n      The identifier of an address pool from which the client can\
    \ assign\n      an address.\n   timeout (Numeric)\n      An absolute timer for\
    \ the connection (in minutes).  A value of\n      zero indicates no timeout.\n\
    \   idletime (Numeric)\n      An idle-timeout for the connection (in minutes).\
    \  A value of zero\n      indicates no timeout.\n   autocmd (String)\n      An\
    \ auto-command to run.  Applicable only to session-based shell\n      authorization.\n\
    \   noescape (Boolean)\n      Prevents the user from using an escape character.\
    \  Applicable only\n      to session-based shell authorization.\n   nohangup (Boolean)\n\
    \      Boolean.  Do not disconnect after an automatic command.\n      Applicable\
    \ only to session-based shell authorization.\n   priv-lvl (Numeric)\n      The\
    \ privilege level to be assigned.  Please refer to \"Privilege\n      Levels\"\
    \ (Section 9).\n"
- title: 8.3.  Accounting Arguments
  contents:
  - "8.3.  Accounting Arguments\n   The following arguments are defined for TACACS+\
    \ accounting only.\n   They MUST precede any argument-value pairs that are defined\
    \ in\n   \"Authorization\" (Section 6).\n   task_id (String)\n      Start and\
    \ stop records for the same event MUST have matching\n      task_id argument values.\
    \  The client MUST ensure that active\n      task_ids are not duplicated; a client\
    \ MUST NOT reuse a task_id in\n      a start record until it has sent a stop record\
    \ for that task_id.\n      Servers MUST NOT make assumptions about the format\
    \ of a task_id.\n   start_time (Date Time)\n      The time the action started\
    \ (in seconds since the epoch).\n   stop_time (Date Time)\n      The time the\
    \ action stopped (in seconds since the epoch).\n   elapsed_time (Numeric)\n  \
    \    The elapsed time in seconds for the action.\n   timezone (String)\n     \
    \ The time zone abbreviation for all timestamps included in this\n      packet.\
    \  A database of time zones is maintained in [TZDB].\n   event (String)\n    \
    \  Used only when \"service=system\".  Current values are \"net_acct\",\n    \
    \  \"cmd_acct\", \"conn_acct\", \"shell_acct\", \"sys_acct\", and\n      \"clock_change\"\
    .  These indicate system-level changes.  The flags\n      field SHOULD indicate\
    \ whether the service started or stopped.\n   reason (String)\n      Accompanies\
    \ an event argument.  It describes why the event\n      occurred.\n   bytes (Numeric)\n\
    \      The number of bytes transferred by this action.\n   bytes_in (Numeric)\n\
    \      The number of bytes transferred by this action from the endstation\n  \
    \    to the client port.\n   bytes_out (Numeric)\n      The number of bytes transferred\
    \ by this action from the client to\n      the endstation port.\n   paks (Numeric)\n\
    \      The number of packets transferred by this action.\n   paks_in (Numeric)\n\
    \      The number of input packets transferred by this action from the\n     \
    \ endstation to the client port.\n   paks_out (Numeric)\n      The number of output\
    \ packets transferred by this action from the\n      client port to the endstation.\n\
    \   err_msg (String)\n      A string describing the status of the action.  For\
    \ details of text\n      encoding, see \"Treatment of Text Strings\" (Section\
    \ 3.7).\n   Where the TACACS+ deployment is used to support the Device\n   Administration\
    \ use case, it is often required to log all commands\n   entered into client devices.\
    \  To support this mode of operation,\n   TACACS+ client devices MUST be configured\
    \ to send an accounting start\n   packet for every command entered, irrespective\
    \ of how the commands\n   were authorized.  These \"Command Accounting\" packets\
    \ MUST include the\n   \"service\" and \"cmd\" arguments, and if needed, the \"\
    cmd-arg\" arguments\n   detailed in Section 8.2.\n"
- title: 9.  Privilege Levels
  contents:
  - "9.  Privilege Levels\n   The TACACS+ protocol supports flexible authorization\
    \ schemes through\n   the extensible arguments.\n   The privilege levels scheme\
    \ is built into the protocol and has been\n   extensively used as an option for\
    \ Session-based shell authorization.\n   Privilege levels are ordered values from\
    \ 0 to 15 with each level\n   being a superset of the next lower value.  Configuration\
    \ and\n   implementation of the client will map actions (such as the permission\n\
    \   to execute specific commands) to different privilege levels.  The\n   allocation\
    \ of commands to privilege levels is highly dependent upon\n   the deployment.\
    \  Common allocations are as follows:\n      TAC_PLUS_PRIV_LVL_MIN := 0x00.  The\
    \ level normally allocated to an\n      unauthenticated session.\n      TAC_PLUS_PRIV_LVL_USER\
    \ := 0x01.  The level normally allocated to a\n      regular authenticated session.\n\
    \      TAC_PLUS_PRIV_LVL_ROOT := 0x0f.  The level normally allocated to a\n  \
    \    session authenticated by a highly privileged user to allow\n      commands\
    \ with significant system impact.\n      TAC_PLUS_PRIV_LVL_MAX := 0x0f.  The highest\
    \ privilege level.\n   A privilege level can be assigned to a shell (exec) session\
    \ when it\n   starts.  The client will permit the actions associated with this\n\
    \   level to be executed.  This privilege level is returned by the server\n  \
    \ in a session-based shell authorization (when \"service\" equals \"shell\"\n\
    \   and \"cmd\" is empty).  When a user is required to perform actions that\n\
    \   are mapped to a higher privilege level, an ENABLE-type\n   reauthentication\
    \ can be initiated by the client.  The client will\n   insert the required privilege\
    \ level into the authentication header\n   for ENABLE authentication requests.\n\
    \   The use of privilege levels to determine session-based access to\n   commands\
    \ and resources is not mandatory for clients.  Although the\n   privilege-level\
    \ scheme is widely supported, its lack of flexibility\n   in requiring a single\
    \ monotonic hierarchy of permissions means that\n   other session-based command\
    \ authorization schemes have evolved.\n   However, it is still common enough that\
    \ it SHOULD be supported by\n   servers.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   \"The Draft\" [THE-DRAFT] from 1998 did not\
    \ address all of the key\n   security concerns that are considered when designing\
    \ modern\n   standards.  This section addresses known limitations and concerns\n\
    \   that will impact overall security of the protocol and systems where\n   this\
    \ protocol is deployed to manage central authentication,\n   authorization, or\
    \ accounting for network Device Administration.\n   Multiple implementations of\
    \ the protocol described in \"The Draft\"\n   [THE-DRAFT] have been deployed.\
    \  As the protocol was never\n   standardized, current implementations may be\
    \ incompatible in non-\n   obvious ways, giving rise to additional security risks.\
    \  This section\n   does not claim to enumerate all possible security vulnerabilities.\n"
- title: 10.1.  General Security of the Protocol
  contents:
  - "10.1.  General Security of the Protocol\n   The TACACS+ protocol does not include\
    \ a security mechanism that would\n   meet modern-day requirements.  These security\
    \ mechanisms would be\n   best referred to as \"obfuscation\" and not \"encryption\"\
    , since they\n   provide no meaningful integrity, privacy, or replay protection.\
    \  An\n   attacker with access to the data stream should be assumed to be able\n\
    \   to read and modify all TACACS+ packets.  Without mitigation, a range\n   of\
    \ risks such as the following are possible:\n   *  Accounting information may\
    \ be modified by the man-in-the-middle\n      attacker, making such logs unsuitable\
    \ and not trustable for\n      auditing purposes.\n   *  Invalid or misleading\
    \ values may be inserted by the man-in-the-\n      middle attacker in various\
    \ fields at known offsets to try and\n      circumvent the authentication or authorization\
    \ checks even inside\n      the obfuscated body.\n   While the protocol provides\
    \ some measure of transport privacy, it is\n   vulnerable to at least the following\
    \ attacks:\n   *  Brute-force attacks exploiting increased efficiency of MD5 digest\n\
    \      computation.\n   *  Known plaintext attacks that may decrease the cost\
    \ of brute-force\n      attacks.\n   *  Chosen plaintext attacks that may decrease\
    \ the cost of a brute-\n      force attacks.\n   *  No forward secrecy.\n   Even\
    \ though, to the best knowledge of the authors, this method of\n   encryption\
    \ wasn't rigorously tested, enough information is available\n   that it is best\
    \ referred to as \"obfuscation\" and not \"encryption\".\n   For these reasons,\
    \ users deploying the TACACS+ protocol in their\n   environments MUST limit access\
    \ to known clients and MUST control the\n   security of the entire transmission\
    \ path.  Attackers who can guess\n   the key or otherwise break the obfuscation\
    \ will gain unrestricted and\n   undetected access to all TACACS+ traffic.  Ensuring\
    \ that a\n   centralized AAA system like TACACS+ is deployed on a secured\n  \
    \ transport is essential to managing the security risk of such an\n   attack.\n\
    \   The following parts of this section enumerate only the session-\n   specific\
    \ risks that are in addition to general risk associated with\n   bare obfuscation\
    \ and lack of integrity checking.\n"
- title: 10.2.  Security of Authentication Sessions
  contents:
  - "10.2.  Security of Authentication Sessions\n   Authentication sessions SHOULD\
    \ be used via a secure transport (see\n   \"TACACS+ Best Practices\" (Section\
    \ 10.5)) as the man-in-the-middle\n   attack may completely subvert them.  Even\
    \ CHAP, which may be\n   considered resistant to password interception, is unsafe\
    \ as it does\n   not protect the username from a trivial man-in-the-middle attack.\n\
    \   This document deprecates the redirection mechanism using the\n   TAC_PLUS_AUTHEN_STATUS_FOLLOW\
    \ option, which was included in \"The\n   Draft\".  As part of this process, the\
    \ secret key for a new server was\n   sent to the client.  This public exchange\
    \ of secret keys means that\n   once one session is broken, it may be possible\
    \ to leverage that key\n   to attacking connections to other servers.  This mechanism\
    \ MUST NOT\n   be used in modern deployments.  It MUST NOT be used outside a secured\n\
    \   deployment.\n"
- title: 10.3.  Security of Authorization Sessions
  contents:
  - "10.3.  Security of Authorization Sessions\n   Authorization sessions SHOULD be\
    \ used via a secure transport (see\n   \"TACACS+ Best Practices\" (Section 10.5))\
    \ as it's trivial to execute a\n   successful man-in-the-middle attack that changes\
    \ well-known plaintext\n   in either requests or responses.\n   As an example,\
    \ take the field \"authen_method\".  It's not unusual in\n   actual deployments\
    \ to authorize all commands received via the device\n   local serial port (a console\
    \ port), as that one is usually considered\n   secure by virtue of the device\
    \ located in a physically secure\n   location.  If an administrator would configure\
    \ the authorization\n   system to allow all commands entered by the user on a\
    \ local console\n   to aid in troubleshooting, that would give all access to all\
    \ commands\n   to any attacker that would be able to change the \"authen_method\"\
    \ from\n   TAC_PLUS_AUTHEN_METH_TACACSPLUS to TAC_PLUS_AUTHEN_METH_LINE.  In\n\
    \   this regard, the obfuscation provided by the protocol itself wouldn't\n  \
    \ help much, because:\n   *  A lack of integrity means that any byte in the payload\
    \ may be\n      changed without either side detecting the change.\n   *  Known\
    \ plaintext means that an attacker would know with certainty\n      which octet\
    \ is the target of the attack (in this case, first octet\n      after the header).\n\
    \   *  In combination with known plaintext, the attacker can determine\n     \
    \ with certainty the value of the crypto-pad octet used to obfuscate\n      the\
    \ original octet.\n"
- title: 10.4.  Security of Accounting Sessions
  contents:
  - "10.4.  Security of Accounting Sessions\n   Accounting sessions SHOULD be used\
    \ via a secure transport (see\n   \"TACACS+ Best Practices\" (Section 10.5)).\
    \  Although Accounting\n   sessions are not directly involved in authentication\
    \ or authorizing\n   operations on the device, man-in-the-middle attackers may\
    \ do any of\n   the following:\n   *  Replace accounting data with new valid values\
    \ or garbage that can\n      confuse auditors or hide information related to their\n\
    \      authentication and/or authorization attack attempts.\n   *  Try and poison\
    \ an accounting log with entries designed to make\n      systems behave in unintended\
    \ ways (these systems could be TACACS+\n      servers and any other systems that\
    \ would manage accounting\n      entries).\n   In addition to these direct manipulations,\
    \ different client\n   implementations pass a different fidelity of accounting\
    \ data.  Some\n   vendors have been observed in the wild that pass sensitive data\
    \ like\n   passwords, encryption keys, and the like as part of the accounting\n\
    \   log.  Due to a lack of strong encryption with perfect forward\n   secrecy,\
    \ this data may be revealed in the future, leading to a\n   security incident.\n"
- title: 10.5.  TACACS+ Best Practices
  contents:
  - "10.5.  TACACS+ Best Practices\n   With respect to the observations about the\
    \ security issues described\n   above, a network administrator MUST NOT rely on\
    \ the obfuscation of\n   the TACACS+ protocol.  TACACS+ MUST be used within a\
    \ secure\n   deployment; TACACS+ MUST be deployed over networks that ensure\n\
    \   privacy and integrity of the communication and MUST be deployed over\n   a\
    \ network that is separated from other traffic.  Failure to do so\n   will impact\
    \ overall network security.\n   The following recommendations impose restrictions\
    \ on how the protocol\n   is applied.  These restrictions were not imposed in\
    \ \"The Draft\".  New\n   implementations, and upgrades of current implementations,\
    \ MUST\n   implement these recommendations.  Vendors SHOULD provide mechanisms\n\
    \   to assist the administrator to achieve these best practices.\n"
- title: 10.5.1.  Shared Secrets
  contents:
  - "10.5.1.  Shared Secrets\n   TACACS+ servers and clients MUST treat shared secrets\
    \ as sensitive\n   data to be managed securely, as would be expected for other\
    \ sensitive\n   data such as identity credential information.  TACACS+ servers\
    \ MUST\n   NOT leak sensitive data.\n   For example:\n   *  TACACS+ servers MUST\
    \ NOT expose shared secrets in logs.\n   *  TACACS+ servers MUST allow a dedicated\
    \ secret key to be defined\n      for each client.\n   *  TACACS+ server management\
    \ systems MUST provide a mechanism to\n      track secret key lifetimes and notify\
    \ administrators to update\n      them periodically.  TACACS+ server administrators\
    \ SHOULD change\n      secret keys at regular intervals.\n   *  TACACS+ servers\
    \ SHOULD warn administrators if secret keys are not\n      unique per client.\n\
    \   *  TACACS+ server administrators SHOULD always define a secret for\n     \
    \ each client.\n   *  TACACS+ servers and clients MUST support shared keys that\
    \ are at\n      least 32 characters long.\n   *  TACACS+ servers MUST support\
    \ policy to define minimum complexity\n      for shared keys.\n   *  TACACS+ clients\
    \ SHOULD NOT allow servers to be configured without\n      a shared secret key\
    \ or shared key that is less than 16 characters\n      long.\n   *  TACACS+ server\
    \ administrators SHOULD configure secret keys of a\n      minimum of 16 characters\
    \ in length.\n"
- title: 10.5.2.  Connections and Obfuscation
  contents:
  - "10.5.2.  Connections and Obfuscation\n   TACACS+ servers MUST allow the definition\
    \ of individual clients.  The\n   servers MUST only accept network connection\
    \ attempts from these\n   defined known clients.\n   TACACS+ servers MUST reject\
    \ connections that have\n   TAC_PLUS_UNENCRYPTED_FLAG set.  There MUST always\
    \ be a shared secret\n   set on the server for the client requesting the connection.\n\
    \   If an invalid shared secret is detected when processing packets for a\n  \
    \ client, TACACS+ servers MUST NOT accept any new sessions on that\n   connection.\
    \  TACACS+ servers MUST terminate the connection on\n   completion of any sessions\
    \ that were previously established with a\n   valid shared secret on that connection.\n\
    \   TACACS+ clients MUST NOT set TAC_PLUS_UNENCRYPTED_FLAG.  Clients MUST\n  \
    \ be implemented in a way that requires explicit configuration to\n   enable the\
    \ use of TAC_PLUS_UNENCRYPTED_FLAG.  This option MUST NOT be\n   used when the\
    \ client is in production.\n   When a TACACS+ client receives responses from servers\
    \ where:\n   *  the response packet was received from the server configured with\
    \ a\n      shared key, but the packet has TAC_PLUS_UNENCRYPTED_FLAG set, and\n\
    \   *  the response packet was received from the server configured not to\n  \
    \    use obfuscation, but the packet has TAC_PLUS_UNENCRYPTED_FLAG not\n     \
    \ set,\n   the TACACS+ client MUST close the TCP session, and process the\n  \
    \ response in the same way that a TAC_PLUS_AUTHEN_STATUS_FAIL\n   (authentication\
    \ sessions) or TAC_PLUS_AUTHOR_STATUS_FAIL\n   (authorization sessions) was received.\n"
- title: 10.5.3.  Authentication
  contents:
  - "10.5.3.  Authentication\n   To help TACACS+ administrators select stronger authentication\n\
    \   options, TACACS+ servers MUST allow the administrator to configure\n   the\
    \ server to only accept challenge/response options for\n   authentication (TAC_PLUS_AUTHEN_TYPE_CHAP\
    \ or\n   TAC_PLUS_AUTHEN_TYPE_MSCHAP or TAC_PLUS_AUTHEN_TYPE_MSCHAPV2 for\n  \
    \ authen_type).\n   TACACS+ server administrators SHOULD enable the option mentioned\
    \ in\n   the previous paragraph.  TACACS+ server deployments SHOULD only\n   enable\
    \ other options (such as TAC_PLUS_AUTHEN_TYPE_ASCII or\n   TAC_PLUS_AUTHEN_TYPE_PAP)\
    \ when unavoidable due to requirements of\n   identity/password systems.\n   TACACS+\
    \ server administrators SHOULD NOT allow the same credentials\n   to be applied\
    \ in challenge-based (TAC_PLUS_AUTHEN_TYPE_CHAP or\n   TAC_PLUS_AUTHEN_TYPE_MSCHAP\
    \ or TAC_PLUS_AUTHEN_TYPE_MSCHAPV2) and\n   non-challenge-based authen_type options,\
    \ as the insecurity of the\n   latter will compromise the security of the former.\n\
    \   TAC_PLUS_AUTHEN_SENDAUTH and TAC_PLUS_AUTHEN_SENDPASS options\n   mentioned\
    \ in \"The Draft\" SHOULD NOT be used due to their security\n   implications.\
    \  TACACS+ servers SHOULD NOT implement them.  If they\n   must be implemented,\
    \ the servers MUST default to the options being\n   disabled and MUST warn the\
    \ administrator that these options are not\n   secure.\n"
- title: 10.5.4.  Authorization
  contents:
  - "10.5.4.  Authorization\n   The authorization and accounting features are intended\
    \ to provide\n   extensibility and flexibility.  There is a base dictionary defined\
    \ in\n   this document, but it may be extended in deployments by using new\n \
    \  argument names.  The cost of the flexibility is that administrators\n   and\
    \ implementers MUST ensure that the argument and value pairs shared\n   between\
    \ the clients and servers have consistent interpretation.\n   TACACS+ clients\
    \ that receive an unrecognized mandatory argument MUST\n   evaluate server response\
    \ as if they received\n   TAC_PLUS_AUTHOR_STATUS_FAIL.\n"
- title: 10.5.5.  Redirection Mechanism
  contents:
  - "10.5.5.  Redirection Mechanism\n   \"The Draft\" described a redirection mechanism\n\
    \   (TAC_PLUS_AUTHEN_STATUS_FOLLOW).  This feature is difficult to\n   secure.\
    \  The option to send secret keys in the server list is\n   particularly insecure,\
    \ as it can reveal client shared secrets.\n   TACACS+ servers MUST deprecate the\
    \ redirection mechanism.\n   If the redirection mechanism is implemented, then\
    \ TACACS+ servers\n   MUST disable it by default and MUST warn TACACS+ server\n\
    \   administrators that it must only be enabled within a secure\n   deployment\
    \ due to the risks of revealing shared secrets.\n   TACACS+ clients SHOULD deprecate\
    \ this feature by treating\n   TAC_PLUS_AUTHEN_STATUS_FOLLOW as TAC_PLUS_AUTHEN_STATUS_FAIL.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [RFC0020]  Cerf, V., \"ASCII format for network\
    \ interchange\", STD 80,\n              RFC 20, DOI 10.17487/RFC0020, October\
    \ 1969,\n              <https://www.rfc-editor.org/info/rfc20>.\n   [RFC1321]\
    \  Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n             \
    \ DOI 10.17487/RFC1321, April 1992,\n              <https://www.rfc-editor.org/info/rfc1321>.\n\
    \   [RFC1334]  Lloyd, B. and W. Simpson, \"PPP Authentication Protocols\",\n \
    \             RFC 1334, DOI 10.17487/RFC1334, October 1992,\n              <https://www.rfc-editor.org/info/rfc1334>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2433]\
    \  Zorn, G. and S. Cobb, \"Microsoft PPP CHAP Extensions\",\n              RFC\
    \ 2433, DOI 10.17487/RFC2433, October 1998,\n              <https://www.rfc-editor.org/info/rfc2433>.\n\
    \   [RFC2759]  Zorn, G., \"Microsoft PPP CHAP Extensions, Version 2\",\n     \
    \         RFC 2759, DOI 10.17487/RFC2759, January 2000,\n              <https://www.rfc-editor.org/info/rfc2759>.\n\
    \   [RFC3579]  Aboba, B. and P. Calhoun, \"RADIUS (Remote Authentication\n   \
    \           Dial In User Service) Support For Extensible\n              Authentication\
    \ Protocol (EAP)\", RFC 3579,\n              DOI 10.17487/RFC3579, September 2003,\n\
    \              <https://www.rfc-editor.org/info/rfc3579>.\n   [RFC4086]  Eastlake\
    \ 3rd, D., Schiller, J., and S. Crocker,\n              \"Randomness Requirements\
    \ for Security\", BCP 106, RFC 4086,\n              DOI 10.17487/RFC4086, June\
    \ 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n   [RFC4120]\
    \  Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The\n              Kerberos\
    \ Network Authentication Service (V5)\", RFC 4120,\n              DOI 10.17487/RFC4120,\
    \ July 2005,\n              <https://www.rfc-editor.org/info/rfc4120>.\n   [RFC5952]\
    \  Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6\n              Address\
    \ Text Representation\", RFC 5952,\n              DOI 10.17487/RFC5952, August\
    \ 2010,\n              <https://www.rfc-editor.org/info/rfc5952>.\n   [RFC8174]\
    \  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119\
    \ Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,\
    \ <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8265]  Saint-Andre, P. and\
    \ A. Melnikov, \"Preparation,\n              Enforcement, and Comparison of Internationalized\
    \ Strings\n              Representing Usernames and Passwords\", RFC 8265,\n \
    \             DOI 10.17487/RFC8265, October 2017,\n              <https://www.rfc-editor.org/info/rfc8265>.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [KRB4]     Miller, S., Neuman, C., Schiller,\
    \ J., and J. Saltzer,\n              \"Section E.2.1: Kerberos Authentication\
    \ and Authorization\n              System\", MIT Project Athena, Cambridge, Massachusetts,\n\
    \              December 1987.\n   [THE-DRAFT]\n              Carrel, D. and L.\
    \ Grant, \"The TACACS+ Protocol Version\n              1.78\", Work in Progress,\
    \ Internet-Draft, draft-grant-\n              tacacs-02, January 1997,\n     \
    \         <https://tools.ietf.org/html/draft-grant-tacacs-02>.\n   [TZDB]    \
    \ Eggert, P. and A. Olson, \"Sources for Time Zone and\n              Daylight\
    \ Saving Time Data\", 1987,\n              <https://www.iana.org/time-zones>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to thank the following reviewers\
    \ whose\n   comments and contributions made considerable improvements to this\n\
    \   document: Alan DeKok, Alexander Clouter, Chris Janicki, Tom Petch,\n   Robert\
    \ Drake, and John Heasley, among many others.\n   The authors would particularly\
    \ like to thank Alan DeKok, who provided\n   significant insights and recommendations\
    \ on all aspects of the\n   document and the protocol.  Alan DeKok has dedicated\
    \ considerable\n   time and effort to help improve the document, identifying weaknesses\n\
    \   and providing remediation.\n   The authors would also like to thank the support\
    \ from the OPSAWG\n   Chairs and advisors, especially Joe Clarke.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Thorsten Dahm\n   Google Inc.\n   1600 Amphitheatre Parkway\n\
    \   Mountain View, CA 94043\n   United States of America\n   Email: thorstendlux@google.com\n\
    \   Andrej Ota\n   Google Inc.\n   1600 Amphitheatre Parkway\n   Mountain View,\
    \ CA 94043\n   United States of America\n   Email: andrej@ota.si\n   Douglas C.\
    \ Medway Gash\n   Cisco Systems, Inc.\n   170 West Tasman Dr.\n   San Jose, CA\
    \ 95134\n   United States of America\n   Email: dcmgash@cisco.com\n   David Carrel\n\
    \   IPsec Research\n   Email: carrel@ipsec.org\n"
