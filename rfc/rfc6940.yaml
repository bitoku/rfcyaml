- title: __initial_text__
  contents:
  - '         REsource LOcation And Discovery (RELOAD) Base Protocol

    '
- title: Abstract
  contents:
  - "Abstract\n   This specification defines REsource LOcation And Discovery (RELOAD),\n\
    \   a peer-to-peer (P2P) signaling protocol for use on the Internet.  A\n   P2P\
    \ signaling protocol provides its clients with an abstract storage\n   and messaging\
    \ service between a set of cooperating peers that form\n   the overlay network.\
    \  RELOAD is designed to support a P2P Session\n   Initiation Protocol (P2PSIP)\
    \ network, but can be utilized by other\n   applications with similar requirements\
    \ by defining new usages that\n   specify the Kinds of data that need to be stored\
    \ for a particular\n   application.  RELOAD defines a security model based on\
    \ a certificate\n   enrollment service that provides unique identities.  NAT traversal\
    \ is\n   a fundamental service of the protocol.  RELOAD also allows access\n \
    \  from \"client\" nodes that do not need to route traffic or store data\n   for\
    \ others.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6940.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   7\n     1.1.  Basic Setting . . . . . . . . . . . . . . . . . .\
    \ . . . .   8\n     1.2.  Architecture  . . . . . . . . . . . . . . . . . . .\
    \ . . .  10\n       1.2.1.  Usage Layer . . . . . . . . . . . . . . . . . . .\
    \ . .  13\n       1.2.2.  Message Transport . . . . . . . . . . . . . . . . .\
    \ .  13\n       1.2.3.  Storage . . . . . . . . . . . . . . . . . . . . . . .\
    \  14\n       1.2.4.  Topology Plug-in  . . . . . . . . . . . . . . . . . .  15\n\
    \       1.2.5.  Forwarding and Link Management Layer  . . . . . . . .  16\n  \
    \   1.3.  Security  . . . . . . . . . . . . . . . . . . . . . . . .  16\n    \
    \ 1.4.  Structure of This Document  . . . . . . . . . . . . . . .  17\n   2. \
    \ Requirements Language . . . . . . . . . . . . . . . . . . . .  18\n   3.  Terminology\
    \ . . . . . . . . . . . . . . . . . . . . . . . . .  18\n   4.  Overlay Management\
    \ Overview . . . . . . . . . . . . . . . . .  21\n     4.1.  Security and Identification\
    \ . . . . . . . . . . . . . . .  21\n       4.1.1.  Shared-Key Security . . .\
    \ . . . . . . . . . . . . . .  23\n     4.2.  Clients . . . . . . . . . . . .\
    \ . . . . . . . . . . . . .  23\n       4.2.1.  Client Routing  . . . . . . .\
    \ . . . . . . . . . . . .  24\n       4.2.2.  Minimum Functionality Requirements\
    \ for Clients  . . .  25\n     4.3.  Routing . . . . . . . . . . . . . . . . .\
    \ . . . . . . . .  25\n     4.4.  Connectivity Management . . . . . . . . . .\
    \ . . . . . . .  29\n     4.5.  Overlay Algorithm Support . . . . . . . . . .\
    \ . . . . . .  30\n       4.5.1.  Support for Pluggable Overlay Algorithms  .\
    \ . . . . .  30\n       4.5.2.  Joining, Leaving, and Maintenance Overview  .\
    \ . . . .  30\n     4.6.  First-Time Setup  . . . . . . . . . . . . . . . . .\
    \ . . .  32\n       4.6.1.  Initial Configuration . . . . . . . . . . . . . .\
    \ . .  32\n       4.6.2.  Enrollment  . . . . . . . . . . . . . . . . . . . .\
    \ .  32\n       4.6.3.  Diagnostics . . . . . . . . . . . . . . . . . . . . .\
    \  33\n   5.  Application Support Overview  . . . . . . . . . . . . . . . .  33\n\
    \     5.1.  Data Storage  . . . . . . . . . . . . . . . . . . . . . .  33\n  \
    \     5.1.1.  Storage Permissions . . . . . . . . . . . . . . . . .  34\n    \
    \   5.1.2.  Replication . . . . . . . . . . . . . . . . . . . . .  35\n     5.2.\
    \  Usages  . . . . . . . . . . . . . . . . . . . . . . . . .  36\n     5.3.  Service\
    \ Discovery . . . . . . . . . . . . . . . . . . . .  36\n     5.4.  Application\
    \ Connectivity  . . . . . . . . . . . . . . . .  36\n   6.  Overlay Management\
    \ Protocol . . . . . . . . . . . . . . . . .  37\n     6.1.  Message Receipt and\
    \ Forwarding  . . . . . . . . . . . . .  37\n       6.1.1.  Responsible ID  .\
    \ . . . . . . . . . . . . . . . . . .  38\n       6.1.2.  Other ID  . . . . .\
    \ . . . . . . . . . . . . . . . . .  38\n       6.1.3.  Opaque ID . . . . . .\
    \ . . . . . . . . . . . . . . . .  40\n     6.2.  Symmetric Recursive Routing\
    \ . . . . . . . . . . . . . . .  41\n       6.2.1.  Request Origination . . .\
    \ . . . . . . . . . . . . . .  41\n       6.2.2.  Response Origination  . . .\
    \ . . . . . . . . . . . . .  42\n     6.3.  Message Structure . . . . . . . .\
    \ . . . . . . . . . . . .  42\n       6.3.1.  Presentation Language . . . . .\
    \ . . . . . . . . . . .  43\n         6.3.1.1.  Common Definitions  . . . . .\
    \ . . . . . . . . . .  44\n       6.3.2.  Forwarding Header . . . . . . . . .\
    \ . . . . . . . . .  46\n         6.3.2.1.  Processing Configuration Sequence\
    \ Numbers . . . .  49\n         6.3.2.2.  Destination and Via Lists . . . . .\
    \ . . . . . . .  50\n         6.3.2.3.  Forwarding Option . . . . . . . . . .\
    \ . . . . . .  52\n       6.3.3.  Message Contents Format . . . . . . . . . .\
    \ . . . . .  53\n         6.3.3.1.  Response Codes and Response Errors  . . .\
    \ . . . .  54\n       6.3.4.  Security Block  . . . . . . . . . . . . . . . .\
    \ . . .  57\n     6.4.  Overlay Topology  . . . . . . . . . . . . . . . . . .\
    \ . .  60\n       6.4.1.  Topology Plug-in Requirements . . . . . . . . . . .\
    \ .  60\n       6.4.2.  Methods and Types for Use by Topology Plug-ins  . . .\
    \  61\n         6.4.2.1.  Join  . . . . . . . . . . . . . . . . . . . . . .  61\n\
    \         6.4.2.2.  Leave . . . . . . . . . . . . . . . . . . . . . .  62\n  \
    \       6.4.2.3.  Update  . . . . . . . . . . . . . . . . . . . . .  63\n    \
    \     6.4.2.4.  RouteQuery  . . . . . . . . . . . . . . . . . . .  63\n      \
    \   6.4.2.5.  Probe . . . . . . . . . . . . . . . . . . . . . .  65\n     6.5.\
    \  Forwarding and Link Management Layer  . . . . . . . . . .  67\n       6.5.1.\
    \  Attach  . . . . . . . . . . . . . . . . . . . . . . .  67\n         6.5.1.1.\
    \  Request Definition  . . . . . . . . . . . . . . .  68\n         6.5.1.2.  Response\
    \ Definition . . . . . . . . . . . . . . .  70\n         6.5.1.3.  Using ICE with\
    \ RELOAD . . . . . . . . . . . . . .  71\n         6.5.1.4.  Collecting STUN Servers\
    \ . . . . . . . . . . . . .  71\n         6.5.1.5.  Gathering Candidates  . .\
    \ . . . . . . . . . . . .  72\n         6.5.1.6.  Prioritizing Candidates . .\
    \ . . . . . . . . . . .  72\n         6.5.1.7.  Encoding the Attach Message .\
    \ . . . . . . . . . .  73\n         6.5.1.8.  Verifying ICE Support . . . . .\
    \ . . . . . . . . .  74\n         6.5.1.9.  Role Determination  . . . . . . .\
    \ . . . . . . . .  74\n         6.5.1.10. Full ICE  . . . . . . . . . . . . .\
    \ . . . . . . .  74\n         6.5.1.11. No-ICE  . . . . . . . . . . . . . . .\
    \ . . . . . .  75\n         6.5.1.12. Subsequent Offers and Answers . . . . .\
    \ . . . . .  75\n         6.5.1.13. Sending Media . . . . . . . . . . . . . .\
    \ . . . .  75\n         6.5.1.14. Receiving Media . . . . . . . . . . . . . .\
    \ . . .  75\n       6.5.2.  AppAttach . . . . . . . . . . . . . . . . . . . .\
    \ . .  75\n         6.5.2.1.  Request Definition  . . . . . . . . . . . . . .\
    \ .  76\n         6.5.2.2.  Response Definition . . . . . . . . . . . . . . .\
    \  77\n       6.5.3.  Ping  . . . . . . . . . . . . . . . . . . . . . . . .  77\n\
    \         6.5.3.1.  Request Definition  . . . . . . . . . . . . . . .  77\n  \
    \       6.5.3.2.  Response Definition . . . . . . . . . . . . . . .  77\n    \
    \   6.5.4.  ConfigUpdate  . . . . . . . . . . . . . . . . . . . .  78\n      \
    \   6.5.4.1.  Request Definition  . . . . . . . . . . . . . . .  78\n        \
    \ 6.5.4.2.  Response Definition . . . . . . . . . . . . . . .  79\n     6.6. \
    \ Overlay Link Layer  . . . . . . . . . . . . . . . . . . .  80\n       6.6.1.\
    \  Future Overlay Link Protocols . . . . . . . . . . . .  81\n         6.6.1.1.\
    \  HIP . . . . . . . . . . . . . . . . . . . . . . .  82\n         6.6.1.2.  ICE-TCP\
    \ . . . . . . . . . . . . . . . . . . . . .  82\n         6.6.1.3.  Message-Oriented\
    \ Transports . . . . . . . . . . .  82\n         6.6.1.4.  Tunneled Transports\
    \ . . . . . . . . . . . . . . .  82\n       6.6.2.  Framing Header  . . . . .\
    \ . . . . . . . . . . . . . .  83\n       6.6.3.  Simple Reliability  . . . .\
    \ . . . . . . . . . . . . .  84\n         6.6.3.1.  Stop and Wait Sender Algorithm\
    \  . . . . . . . . .  85\n       6.6.4.  DTLS/UDP with SR  . . . . . . . . . .\
    \ . . . . . . . .  86\n       6.6.5.  TLS/TCP with FH, No-ICE . . . . . . . .\
    \ . . . . . . .  86\n       6.6.6.  DTLS/UDP with SR, No-ICE  . . . . . . . .\
    \ . . . . . .  87\n     6.7.  Fragmentation and Reassembly  . . . . . . . . .\
    \ . . . . .  87\n   7.  Data Storage Protocol . . . . . . . . . . . . . . . .\
    \ . . . .  88\n     7.1.  Data Signature Computation  . . . . . . . . . . . .\
    \ . . .  90\n     7.2.  Data Models . . . . . . . . . . . . . . . . . . . . .\
    \ . .  91\n       7.2.1.  Single Value  . . . . . . . . . . . . . . . . . . .\
    \ .  91\n       7.2.2.  Array . . . . . . . . . . . . . . . . . . . . . . . .\
    \  92\n       7.2.3.  Dictionary  . . . . . . . . . . . . . . . . . . . . .  92\n\
    \     7.3.  Access Control Policies . . . . . . . . . . . . . . . . .  93\n  \
    \     7.3.1.  USER-MATCH  . . . . . . . . . . . . . . . . . . . . .  93\n    \
    \   7.3.2.  NODE-MATCH  . . . . . . . . . . . . . . . . . . . . .  93\n      \
    \ 7.3.3.  USER-NODE-MATCH . . . . . . . . . . . . . . . . . . .  93\n       7.3.4.\
    \  NODE-MULTIPLE . . . . . . . . . . . . . . . . . . . .  94\n     7.4.  Data\
    \ Storage Methods  . . . . . . . . . . . . . . . . . .  94\n       7.4.1.  Store\
    \ . . . . . . . . . . . . . . . . . . . . . . . .  94\n         7.4.1.1.  Request\
    \ Definition  . . . . . . . . . . . . . . .  94\n         7.4.1.2.  Response Definition\
    \ . . . . . . . . . . . . . . . 100\n         7.4.1.3.  Removing Values . . .\
    \ . . . . . . . . . . . . . . 101\n       7.4.2.  Fetch . . . . . . . . . . .\
    \ . . . . . . . . . . . . . 102\n         7.4.2.1.  Request Definition  . . .\
    \ . . . . . . . . . . . . 102\n         7.4.2.2.  Response Definition . . . .\
    \ . . . . . . . . . . . 104\n       7.4.3.  Stat  . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 105\n         7.4.3.1.  Request Definition  . . . . . .\
    \ . . . . . . . . . 105\n         7.4.3.2.  Response Definition . . . . . . .\
    \ . . . . . . . . 106\n       7.4.4.  Find  . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 107\n         7.4.4.1.  Request Definition  . . . . . . . . .\
    \ . . . . . . 108\n         7.4.4.2.  Response Definition . . . . . . . . . .\
    \ . . . . . 108\n       7.4.5.  Defining New Kinds  . . . . . . . . . . . . .\
    \ . . . . 109\n   8.  Certificate Store Usage . . . . . . . . . . . . . . . .\
    \ . . . 110\n   9.  TURN Server Usage . . . . . . . . . . . . . . . . . . . .\
    \ . . 110\n   10. Chord Algorithm . . . . . . . . . . . . . . . . . . . . . .\
    \ . 112\n     10.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 113\n     10.2.  Hash Function  . . . . . . . . . . . . . . . . . . . . . 114\n\
    \     10.3.  Routing  . . . . . . . . . . . . . . . . . . . . . . . . 114\n  \
    \   10.4.  Redundancy . . . . . . . . . . . . . . . . . . . . . . . 114\n    \
    \ 10.5.  Joining  . . . . . . . . . . . . . . . . . . . . . . . . 115\n     10.6.\
    \  Routing Attaches . . . . . . . . . . . . . . . . . . . . 116\n     10.7.  Updates\
    \  . . . . . . . . . . . . . . . . . . . . . . . . 117\n       10.7.1.  Handling\
    \ Neighbor Failures . . . . . . . . . . . . . 118\n       10.7.2.  Handling Finger\
    \ Table Entry Failure  . . . . . . . . 119\n       10.7.3.  Receiving Updates\
    \  . . . . . . . . . . . . . . . . . 119\n       10.7.4.  Stabilization  . . .\
    \ . . . . . . . . . . . . . . . . 120\n         10.7.4.1.  Updating the Neighbor\
    \ Table  . . . . . . . . . . 120\n         10.7.4.2.  Refreshing the Finger Table\
    \  . . . . . . . . . . 121\n         10.7.4.3.  Adjusting Finger Table Size  .\
    \ . . . . . . . . . 122\n         10.7.4.4.  Detecting Partitioning . . . . .\
    \ . . . . . . . . 122\n     10.8.  Route Query  . . . . . . . . . . . . . . .\
    \ . . . . . . . 123\n     10.9.  Leaving  . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 123\n   11. Enrollment and Bootstrap  . . . . . . . . . . . . .\
    \ . . . . . 124\n     11.1.  Overlay Configuration  . . . . . . . . . . . . .\
    \ . . . . 124\n       11.1.1.  RELAX NG Grammar . . . . . . . . . . . . . . .\
    \ . . . 132\n     11.2.  Discovery through Configuration Server . . . . . . .\
    \ . . 134\n     11.3.  Credentials  . . . . . . . . . . . . . . . . . . . . .\
    \ . 135\n       11.3.1.  Self-Generated Credentials . . . . . . . . . . . . .\
    \ 137\n     11.4.  Contacting a Bootstrap Node  . . . . . . . . . . . . . . 138\n\
    \   12. Message Flow Example  . . . . . . . . . . . . . . . . . . . . 138\n  \
    \ 13. Security Considerations . . . . . . . . . . . . . . . . . . . 144\n    \
    \ 13.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 144\n     13.2.\
    \  Attacks on P2P Overlays  . . . . . . . . . . . . . . . . 145\n     13.3.  Certificate-Based\
    \ Security . . . . . . . . . . . . . . . 145\n     13.4.  Shared-Secret Security\
    \ . . . . . . . . . . . . . . . . . 147\n     13.5.  Storage Security . . . .\
    \ . . . . . . . . . . . . . . . . 147\n       13.5.1.  Authorization  . . . .\
    \ . . . . . . . . . . . . . . . 147\n       13.5.2.  Distributed Quota  . . .\
    \ . . . . . . . . . . . . . . 148\n       13.5.3.  Correctness  . . . . . . .\
    \ . . . . . . . . . . . . . 148\n       13.5.4.  Residual Attacks . . . . . .\
    \ . . . . . . . . . . . . 149\n     13.6.  Routing Security . . . . . . . . .\
    \ . . . . . . . . . . . 149\n       13.6.1.  Background . . . . . . . . . . .\
    \ . . . . . . . . . . 150\n       13.6.2.  Admissions Control . . . . . . . .\
    \ . . . . . . . . . 150\n       13.6.3.  Peer Identification and Authentication\
    \ . . . . . . . 151\n       13.6.4.  Protecting the Signaling . . . . . . . .\
    \ . . . . . . 151\n       13.6.5.  Routing Loops and DoS Attacks  . . . . . .\
    \ . . . . . 152\n       13.6.6.  Residual Attacks . . . . . . . . . . . . . .\
    \ . . . . 152\n   14. IANA Considerations . . . . . . . . . . . . . . . . . .\
    \ . . . 153\n     14.1.  Well-Known URI Registration  . . . . . . . . . . . .\
    \ . . 153\n     14.2.  Port Registrations . . . . . . . . . . . . . . . . . .\
    \ . 153\n     14.3.  Overlay Algorithm Types  . . . . . . . . . . . . . . . .\
    \ 154\n     14.4.  Access Control Policies  . . . . . . . . . . . . . . . . 154\n\
    \     14.5.  Application-ID . . . . . . . . . . . . . . . . . . . . . 155\n  \
    \   14.6.  Data Kind-ID . . . . . . . . . . . . . . . . . . . . . . 155\n    \
    \ 14.7.  Data Model . . . . . . . . . . . . . . . . . . . . . . . 156\n     14.8.\
    \  Message Codes  . . . . . . . . . . . . . . . . . . . . . 156\n     14.9.  Error\
    \ Codes  . . . . . . . . . . . . . . . . . . . . . . 158\n     14.10. Overlay\
    \ Link Types . . . . . . . . . . . . . . . . . . . 159\n     14.11. Overlay Link\
    \ Protocols . . . . . . . . . . . . . . . . . 159\n     14.12. Forwarding Options\
    \ . . . . . . . . . . . . . . . . . . . 160\n     14.13. Probe Information Types\
    \  . . . . . . . . . . . . . . . . 160\n     14.14. Message Extensions . . . .\
    \ . . . . . . . . . . . . . . . 161\n     14.15. Reload URI Scheme  . . . . .\
    \ . . . . . . . . . . . . . . 161\n       14.15.1.  URI Registration  . . . .\
    \ . . . . . . . . . . . . . 162\n     14.16. Media Type Registration  . . . .\
    \ . . . . . . . . . . . . 162\n     14.17. XML Namespace Registration . . . .\
    \ . . . . . . . . . . . 163\n       14.17.1.  Config URL  . . . . . . . . . .\
    \ . . . . . . . . . . 164\n       14.17.2.  Config Chord URL  . . . . . . . .\
    \ . . . . . . . . . 164\n   15. Acknowledgments . . . . . . . . . . . . . . .\
    \ . . . . . . . . 164\n   16. References  . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 165\n     16.1.  Normative References . . . . . . . . . . . .\
    \ . . . . . . 165\n     16.2.  Informative References . . . . . . . . . . . .\
    \ . . . . . 167\n   Appendix A.  Routing Alternatives . . . . . . . . . . . .\
    \ . . . . 171\n     A.1.  Iterative vs. Recursive . . . . . . . . . . . . . .\
    \ . . . 171\n     A.2.  Symmetric vs. Forward Response  . . . . . . . . . . .\
    \ . . 171\n     A.3.  Direct Response . . . . . . . . . . . . . . . . . . . .\
    \ . 172\n     A.4.  Relay Peers . . . . . . . . . . . . . . . . . . . . . . .\
    \ 173\n     A.5.  Symmetric Route Stability . . . . . . . . . . . . . . . . 173\n\
    \   Appendix B.  Why Clients? . . . . . . . . . . . . . . . . . . . . 174\n  \
    \   B.1.  Why Not Only Peers? . . . . . . . . . . . . . . . . . . . 174\n    \
    \ B.2.  Clients as Application-Level Agents . . . . . . . . . . . 175\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines REsource LOcation And Discovery (RELOAD),\
    \ a\n   peer-to-peer (P2P) signaling protocol for use on the Internet.\n   RELOAD\
    \ provides a generic, self-organizing overlay network service,\n   allowing nodes\
    \ to route messages to other nodes and to store and\n   retrieve data in the overlay.\
    \  RELOAD provides several features that\n   are critical for a successful P2P\
    \ protocol for the Internet:\n   Security Framework:  A P2P network will often\
    \ be established among a\n      set of peers that do not trust each other.  RELOAD\
    \ leverages a\n      central enrollment server to provide credentials for each\
    \ peer,\n      which can then be used to authenticate each operation.  This\n\
    \      greatly reduces the possible attack surface.\n   Usage Model:  RELOAD is\
    \ designed to support a variety of\n      applications, including P2P multimedia\
    \ communications with the\n      Session Initiation Protocol (SIP) [SIP-RELOAD].\
    \  RELOAD allows the\n      definition of new application usages, each of which\
    \ can define its\n      own data types, along with the rules for their use.  This\
    \ allows\n      RELOAD to be used with new applications through a simple\n   \
    \   documentation process that supplies the details for each\n      application.\n\
    \   NAT Traversal:  RELOAD is designed to function in environments where\n   \
    \   many, if not most, of the nodes are behind NATs or firewalls.\n      Operations\
    \ for NAT traversal are part of the base design,\n      including using Interactive\
    \ Connectivity Establishment (ICE)\n      [RFC5245] to establish new RELOAD or\
    \ application protocol\n      connections.\n   Optimized Routing:  The very nature\
    \ of overlay algorithms introduces\n      a requirement that peers participating\
    \ in the P2P network route\n      requests on behalf of other peers in the network.\
    \  This introduces\n      a load on those other peers in the form of bandwidth\
    \ and\n      processing power.  RELOAD has been defined with a simple,\n     \
    \ lightweight forwarding header, thus minimizing the amount of\n      effort for\
    \ intermediate peers.\n   Pluggable Overlay Algorithms:  RELOAD has been designed\
    \ with an\n      abstract interface to the overlay layer to simplify implementing\
    \ a\n      variety of structured (e.g., distributed hash tables (DHTs)) and\n\
    \      unstructured overlay algorithms.  The idea here is that RELOAD\n      provides\
    \ a generic structure that can fit most types of overlay\n      topologies (ring,\
    \ hyperspace, etc.).  To instantiate an actual\n      network, you combine RELOAD\
    \ with a specific overlay algorithm,\n      which defines how to construct the\
    \ overlay topology and route\n      messages efficiently within it.  This specification\
    \ also defines\n      how RELOAD is used with the Chord-based [Chord] DHT algorithm,\n\
    \      which is mandatory to implement.  Specifying a default \"mandatory-\n \
    \     to-implement\" overlay algorithm promotes interoperability, while\n    \
    \  extensibility allows selection of overlay algorithms optimized for\n      a\
    \ particular application.\n   Support for Clients:  RELOAD clients differ from\
    \ RELOAD peers\n      primarily in that they do not store information on behalf\
    \ of other\n      nodes in the overlay.  Rather, they use the overlay only to\
    \ locate\n      users and resources, as well as to store information and to\n\
    \      contact other nodes.\n   These properties were designed specifically to\
    \ meet the requirements\n   for a P2P protocol to support SIP.  This document\
    \ defines the base\n   protocol for the distributed storage and location service,\
    \ as well as\n   critical usage for NAT traversal.  The SIP Usage itself is described\n\
    \   separately in [SIP-RELOAD].  RELOAD is not limited to usage by SIP\n   and\
    \ could serve as a tool for supporting other P2P applications with\n   similar\
    \ needs.\n"
- title: 1.1.  Basic Setting
  contents:
  - "1.1.  Basic Setting\n   In this section, we provide a brief overview of the operational\n\
    \   setting for RELOAD.  A RELOAD Overlay Instance consists of a set of\n   nodes\
    \ arranged in a partly connected graph.  Each node in the overlay\n   is assigned\
    \ a numeric Node-ID for the lifetime of the node, which,\n   together with the\
    \ specific overlay algorithm in use, determines its\n   position in the graph\
    \ and the set of nodes it connects to.  The\n   Node-ID is also tightly coupled\
    \ to the certificate (see\n   Section 13.3).  The figure below shows a trivial\
    \ example which isn't\n   drawn from any particular overlay algorithm, but was\
    \ chosen for\n   convenience of representation.\n      +--------+            \
    \  +--------+              +--------+\n      | Node 10|--------------| Node 20|--------------|\
    \ Node 30|\n      +--------+              +--------+              +--------+\n\
    \          |                       |                       |\n          |    \
    \                   |                       |\n      +--------+              +--------+\
    \              +--------+\n      | Node 40|--------------| Node 50|--------------|\
    \ Node 60|\n      +--------+              +--------+              +--------+\n\
    \          |                       |                       |\n          |    \
    \                   |                       |\n      +--------+              +--------+\
    \              +--------+\n      | Node 70|--------------| Node 80|--------------|\
    \ Node 90|\n      +--------+              +--------+              +--------+\n\
    \                                  |\n                                  |\n  \
    \                            +--------+\n                              | Node\
    \ 85|\n                              |(Client)|\n                            \
    \  +--------+\n   Because the graph is not fully connected, when a node wants\
    \ to send a\n   message to another node, it may need to route it through the network.\n\
    \   For instance, Node 10 can talk directly to nodes 20 and 40, but not\n   to\
    \ Node 70.  In order to send a message to Node 70, it would first\n   send it\
    \ to Node 40, with instructions to pass it along to Node 70.\n   Different overlay\
    \ algorithms will have different connectivity graphs,\n   but the general idea\
    \ behind all of them is to allow any node in the\n   graph to efficiently reach\
    \ every other node within a small number of\n   hops.\n   The RELOAD network is\
    \ not only a messaging network.  It is also a\n   storage network, albeit one\
    \ designed for small-scale transient\n   storage rather than for bulk storage\
    \ of large objects.  Records are\n   stored under numeric addresses, called Resource-IDs,\
    \ which occupy the\n   same space as node identifiers.  Peers are responsible\
    \ for storing\n   the data associated with some set of addresses, as determined\
    \ by\n   their Node-ID.  For instance, we might say that every peer is\n   responsible\
    \ for storing any data value which has an address less than\n   or equal to its\
    \ own Node-ID, but greater than the next lowest\n   Node-ID.  Thus, Node 20 would\
    \ be responsible for storing values\n   11-20.\n   RELOAD also supports clients.\
    \  These are nodes which have Node-IDs\n   but do not participate in routing or\
    \ storage.  For instance, in the\n   figure above, Node 85 is a client.  It can\
    \ route to the rest of the\n   RELOAD network via Node 80, but no other node will\
    \ route through it,\n   and Node 90 is still responsible for addresses in the\
    \ range [81..90].\n   We refer to non-client nodes as peers.\n   Other applications\
    \ (for instance, SIP) can be defined on top of\n   RELOAD and can use these two\
    \ basic RELOAD services to provide their\n   own services.\n"
- title: 1.2.  Architecture
  contents:
  - "1.2.  Architecture\n   RELOAD is fundamentally an overlay network.  The following\
    \ figure\n   shows the layered RELOAD architecture.\n            Application\n\
    \        +-------+  +-------+\n        | SIP   |  | XMPP  |  ...\n        | Usage\
    \ |  | Usage |\n        +-------+  +-------+\n    ------------------------------------\
    \ Messaging Service Boundary\n    +------------------+     +---------+\n    |\
    \     Message      |<--->| Storage |\n    |    Transport     |     +---------+\n\
    \    +------------------+           ^\n           ^       ^               |\n\
    \           |       v               v\n           |     +-------------------+\n\
    \           |     |    Topology       |\n           |     |    Plug-in       \
    \ |\n           |     +-------------------+\n           |         ^\n        \
    \   v         v\n        +------------------+\n        |  Forwarding &    |\n\
    \        | Link Management  |\n        +------------------+\n    ------------------------------------\
    \ Overlay Link Service Boundary\n         +-------+  +-------+\n         |TLS\
    \    |  |DTLS   |  ...\n         |Overlay|  |Overlay|\n         |Link   |  |Link\
    \   |\n         +-------+  +-------+\n   The major components of RELOAD are:\n\
    \   Usage Layer:  Each application defines a RELOAD Usage, which is a set\n  \
    \    of data Kinds and behaviors which describe how to use the services\n    \
    \  provided by RELOAD.  These usages all talk to RELOAD through a\n      common\
    \ Message Transport Service.\n   Message Transport:  Handles end-to-end reliability,\
    \ manages request\n      state for the usages, and forwards Store and Fetch operations\
    \ to\n      the Storage component.  It delivers message responses to the\n   \
    \   component initiating the request.\n   Storage:  The Storage component is responsible\
    \ for processing\n      messages relating to the storage and retrieval of data.\
    \  It talks\n      directly to the Topology Plug-in to manage data replication\
    \ and\n      migration, and it talks to the Message Transport component to send\n\
    \      and receive messages.\n   Topology Plug-in:  The Topology Plug-in is responsible\
    \ for\n      implementing the specific overlay algorithm being used.  It uses\n\
    \      the Message Transport component to send and receive overlay\n      management\
    \ messages, the Storage component to manage data\n      replication, and the Forwarding\
    \ Layer to control hop-by-hop\n      message forwarding.  This component superficially\
    \ parallels\n      conventional routing algorithms, but is more tightly coupled\
    \ to\n      the Forwarding Layer, because there is no single \"Routing Table\"\
    \n      equivalent used by all overlay algorithms.  The Topology Plug-in\n   \
    \   has two functions: constructing the local forwarding instructions\n      and\
    \ selecting the operational topology (i.e., creating links by\n      sending overlay\
    \ management messages).\n   Forwarding and Link Management Layer:  Stores and\
    \ implements the\n      Routing Table by providing packet forwarding services\
    \ between\n      nodes.  It also handles establishing new links between nodes,\n\
    \      including setting up connections for overlay links across NATs\n      using\
    \ ICE.\n   Overlay Link Layer:  Responsible for actually transporting traffic\n\
    \      directly between nodes.  Transport Layer Security (TLS) [RFC5246]\n   \
    \   and Datagram Transport Layer Security (DTLS) [RFC6347] are the\n      currently\
    \ defined \"overlay link layer\" protocols used by RELOAD\n      for hop-by-hop\
    \ communication.  Each such protocol includes the\n      appropriate provisions\
    \ for per-hop framing and hop-by-hop ACKs\n      needed by unreliable underlying\
    \ transports.  New protocols can be\n      defined, as described in Sections 6.6.1\
    \ and 11.1.  As this\n      document defines only TLS and DTLS, we use those terms\
    \ throughout\n      the remainder of the document with the understanding that\
    \ some\n      future specification may add new overlay link layers.\n   To further\
    \ clarify the roles of the various layers, the following\n   figure parallels\
    \ the architecture with each layer's role from an\n   overlay perspective and\
    \ implementation layer in the Internet:\n    Internet    | Internet Model  |\n\
    \    Model       |   Equivalent    |          Reload\n                |   in Overlay\
    \    |       Architecture\n   -------------+-----------------+------------------------------------\n\
    \                |                 |    +-------+  +-------+\n               \
    \ |  Application    |    | SIP   |  | XMPP  |  ...\n                |        \
    \         |    | Usage |  | Usage |\n                |                 |    +-------+\
    \  +-------+\n                |                 |  ----------------------------------\n\
    \                |                 |+------------------+     +---------+\n   \
    \             |   Transport     ||     Message      |<--->| Storage |\n      \
    \          |                 ||    Transport     |     +---------+\n         \
    \       |                 |+------------------+           ^\n                |\
    \                 |       ^       ^               |\n                |       \
    \          |       |       v               v\n   Application  |              \
    \   |       |     +-------------------+\n                |   (Routing)     | \
    \      |     |     Topology      |\n                |                 |      \
    \ |     |     Plug-in       |\n                |                 |       |   \
    \  +-------------------+\n                |                 |       |        \
    \ ^\n                |                 |       v         v\n                |\
    \    Network      |    +------------------+\n                |               \
    \  |    |  Forwarding &    |\n                |                 |    | Link Management\
    \  |\n                |                 |    +------------------+\n          \
    \      |                 |  ----------------------------------\n   Transport \
    \   |      Link       |     +-------+  +------+\n                |           \
    \      |     |TLS    |  |DTLS  |  ...\n                |                 |   \
    \  +-------+  +------+\n   -------------+-----------------+------------------------------------\n\
    \     Network    |\n                |\n       Link     |\n   In addition to the\
    \ above components, nodes may communicate with a\n   central provisioning infrastructure\
    \ (not shown) to get configuration\n   information, authentication credentials,\
    \ and the initial set of nodes\n   to communicate with to join the overlay.\n"
- title: 1.2.1.  Usage Layer
  contents:
  - "1.2.1.  Usage Layer\n   The top layer, called the Usage Layer, has application\
    \ usages, such\n   as the SIP Registration Usage [SIP-RELOAD], that use the abstract\n\
    \   Message Transport Service provided by RELOAD.  The goal of this layer\n  \
    \ is to implement application-specific usages of the generic overlay\n   services\
    \ provided by RELOAD.  The Usage defines how a specific\n   application maps its\
    \ data into something that can be stored in the\n   overlay, where to store the\
    \ data, how to secure the data, and finally\n   how applications can retrieve\
    \ and use the data.\n   The architecture diagram shows both a SIP Usage and an\
    \ XMPP Usage.  A\n   single application may require multiple usages; for example,\
    \ a\n   voicemail feature in a softphone application that stores links to the\n\
    \   messages in the overlay would require a different usage than the type\n  \
    \ of rendezvous service of XMPP or SIP.  A usage may define multiple\n   Kinds\
    \ of data that are stored in the overlay and may also rely on\n   Kinds originally\
    \ defined by other usages.\n   Because the security and storage policies for each\
    \ Kind are dictated\n   by the usage defining the Kind, the usages may be coupled\
    \ with the\n   Storage component to provide security policy enforcement and to\n\
    \   implement appropriate storage strategies according to the needs of\n   the\
    \ usage.  The exact implementation of such an interface is outside\n   the scope\
    \ of this specification.\n"
- title: 1.2.2.  Message Transport
  contents:
  - "1.2.2.  Message Transport\n   The Message Transport component provides a generic\
    \ message routing\n   service for the overlay.  The Message Transport layer is\
    \ responsible\n   for end-to-end message transactions.  Each peer is identified\
    \ by its\n   location in the overlay, as determined by its Node-ID.  A component\n\
    \   that is a client of the Message Transport can perform two basic\n   functions:\n\
    \   o  Send a message to a given peer specified by Node-ID or to the peer\n  \
    \    responsible for a particular Resource-ID.\n   o  Receive messages that other\
    \ peers sent to a Node-ID or Resource-ID\n      for which the receiving peer is\
    \ responsible.\n   All usages rely on the Message Transport component to send\
    \ and\n   receive messages from peers.  For instance, when a usage wants to\n\
    \   store data, it does so by sending Store requests.  Note that the\n   Storage\
    \ component and the Topology Plug-in are themselves clients of\n   the Message\
    \ Transport, because they need to send and receive messages\n   from other peers.\n\
    \   The Message Transport Service is responsible for end-to-end\n   reliability,\
    \ which is accomplished by timer-based retransmissions.\n   Unlike the Internet\
    \ transport layer, however, this layer does not\n   provide congestion control.\
    \  RELOAD is a request-response protocol,\n   with no more than two pairs of request-response\
    \ messages used in\n   typical transactions between pairs of nodes; therefore,\
    \ there are no\n   opportunities to observe and react to end-to-end congestion.\
    \  As with\n   all Internet applications, implementers are strongly discouraged\
    \ from\n   writing applications that react to loss by immediately retrying the\n\
    \   transaction.\n   The Message Transport Service is similar to those described\
    \ as\n   providing \"key-based routing\" (KBR) [wikiKBR], although as RELOAD\n\
    \   supports different overlay algorithms (including non-DHT overlay\n   algorithms)\
    \ that calculate keys (storage indices, not encryption\n   keys) in different\
    \ ways, the actual interface needs to accept\n   Resource Names rather than actual\
    \ keys.\n   The Forwarding and Link Management layers are responsible for\n  \
    \ maintaining the overlay in the face of changes in the available nodes\n   and\
    \ underlying network supporting the overlay (the Internet).  They\n   also handle\
    \ congestion control between overlay neighbors, and\n   exchange routing updates\
    \ and data replicas in addition to forwarding\n   end-to-end messages.\n   Real-world\
    \ experience has shown that a fixed timeout for the end-to-\n   end retransmission\
    \ timer is sufficient for practical overlay\n   networks.  This timer is adjustable\
    \ via the overlay configuration.\n   As the overlay configuration can be rapidly\
    \ updated, this value could\n   be dynamically adjusted at coarse time scales,\
    \ although algorithms\n   for determining how to accomplish this are beyond the\
    \ scope of this\n   specification.  In many cases, however, other means of improving\n\
    \   network performance, such as having the Topology Plug-in remove lossy\n  \
    \ links from use in overlay routing or reducing the overall hop count\n   of end-to-end\
    \ paths, will be more effective than simply increasing\n   the retransmission\
    \ timer.\n"
- title: 1.2.3.  Storage
  contents:
  - "1.2.3.  Storage\n   One of the major functions of RELOAD is storage of data,\
    \ that is,\n   allowing nodes to store data in the overlay and to retrieve data\n\
    \   stored by other nodes or by themselves.  The Storage component is\n   responsible\
    \ for processing data storage and retrieval messages.  For\n   instance, the Storage\
    \ component might receive a Store request for a\n   given resource from the Message\
    \ Transport.  It would then query the\n   appropriate usage before storing the\
    \ data value(s) in its local data\n   store and sending a response to the Message\
    \ Transport for delivery to\n   the requesting node.  Typically, these messages\
    \ will come from other\n   nodes, but depending on the overlay topology, a node\
    \ might be\n   responsible for storing data for itself as well, especially if\
    \ the\n   overlay is small.\n   A peer's Node-ID determines the set of resources\
    \ that it will be\n   responsible for storing.  However, the exact mapping between\
    \ these is\n   determined by the overlay algorithm in use.  The Storage component\n\
    \   will only receive a Store request from the Message Transport if this\n   peer\
    \ is responsible for that Resource-ID.  The Storage component is\n   notified\
    \ by the Topology Plug-in when the Resource-IDs for which it\n   is responsible\
    \ change, and the Storage component is then responsible\n   for migrating resources\
    \ to other peers.\n"
- title: 1.2.4.  Topology Plug-in
  contents:
  - "1.2.4.  Topology Plug-in\n   RELOAD is explicitly designed to work with a variety\
    \ of overlay\n   algorithms.  In order to facilitate this, the overlay algorithm\n\
    \   implementation is provided by a Topology Plug-in so that each overlay\n  \
    \ can select an appropriate overlay algorithm that relies on the common\n   RELOAD\
    \ core protocols and code.\n   The Topology Plug-in is responsible for maintaining\
    \ the overlay\n   algorithm Routing Table, which is consulted by the Forwarding\
    \ and\n   Link Management Layer before routing a message.  When connections are\n\
    \   made or broken, the Forwarding and Link Management Layer notifies the\n  \
    \ Topology Plug-in, which adjusts the Routing Table as appropriate.\n   The Topology\
    \ Plug-in will also instruct the Forwarding and Link\n   Management Layer to form\
    \ new connections as dictated by the\n   requirements of the overlay algorithm\
    \ Topology.  The Topology Plug-in\n   issues periodic update requests through\
    \ Message Transport to maintain\n   and update its Routing Table.\n   As peers\
    \ enter and leave, resources may be stored on different peers,\n   so the Topology\
    \ Plug-in also keeps track of which peers are\n   responsible for which resources.\
    \  As peers join and leave, the\n   Topology Plug-in instructs the Storage component\
    \ to issue resource\n   migration requests as appropriate, in order to ensure\
    \ that other\n   peers have whatever resources they are now responsible for. \
    \ The\n   Topology Plug-in is also responsible for providing for redundant data\n\
    \   storage to protect against loss of information in the event of a peer\n  \
    \ failure and to protect against compromised or subversive peers.\n"
- title: 1.2.5.  Forwarding and Link Management Layer
  contents:
  - "1.2.5.  Forwarding and Link Management Layer\n   The Forwarding and Link Management\
    \ Layer is responsible for getting a\n   message to the next peer, as determined\
    \ by the Topology Plug-in.\n   This layer establishes and maintains the network\
    \ connections as\n   needed by the Topology Plug-in.  This layer is also responsible\
    \ for\n   setting up connections to other peers through NATs and firewalls\n \
    \  using ICE, and it can elect to forward traffic using relays for NAT\n   and\
    \ firewall traversal.\n   Congestion control is implemented at this layer to protect\
    \ the\n   Internet paths used to form the link in the overlay.  Additionally,\n\
    \   retransmission is performed to improve the reliability of end-to-end\n   transactions.\
    \  The relation of this layer to the Message Transport\n   Layer can be likened\
    \ to the relation of the link-level congestion\n   control and retransmission\
    \ in modern wireless networks ` to Internet\n   transport protocols.\n   This\
    \ layer provides a generic interface that allows the Topology\n   Plug-in to control\
    \ the overlay and resource operations and messages.\n   Because each overlay algorithm\
    \ is defined and functions differently,\n   we generically refer to the table\
    \ of other peers that the overlay\n   algorithm maintains and uses to route requests\
    \ as a Routing Table.\n   The Topology Plug-in actually owns the Routing Table,\
    \ and forwarding\n   decisions are made by querying the Topology Plug-in for the\
    \ next hop\n   for a particular Node-ID or Resource-ID.  If this node is the\n\
    \   destination of the message, the message is delivered to the Message\n   Transport.\n\
    \   This layer also utilizes a framing header to encapsulate messages as\n   they\
    \ are forwarded along each hop.  This header aids reliability\n   congestion control,\
    \ flow control, etc.  It has meaning only in the\n   context of that individual\
    \ link.\n   The Forwarding and Link Management Layer sits on top of the Overlay\n\
    \   Link Layer protocols that carry the actual traffic.  This\n   specification\
    \ defines how to use DTLS and TLS protocols to carry\n   RELOAD messages.\n"
- title: 1.3.  Security
  contents:
  - "1.3.  Security\n   RELOAD's security model is based on each node having one or\
    \ more\n   public key certificates.  In general, these certificates will be\n\
    \   assigned by a central server, which also assigns Node-IDs, although\n   self-signed\
    \ certificates can be used in closed networks.  These\n   credentials can be leveraged\
    \ to provide communications security for\n   RELOAD messages.  RELOAD provides\
    \ communications security at three\n   levels:\n   Connection level:  Connections\
    \ between nodes are secured with TLS,\n      DTLS, or potentially some to-be-defined\
    \ future protocol.\n   Message level:  Each RELOAD message is signed.\n   Object\
    \ Level:  Stored objects are signed by the creating node.\n   These three levels\
    \ of security work together to allow nodes to verify\n   the origin and correctness\
    \ of data they receive from other nodes,\n   even in the face of malicious activity\
    \ by other nodes in the overlay.\n   RELOAD also provides access control built\
    \ on top of these\n   communications security features.  Because the peer responsible\
    \ for\n   storing a piece of data can validate the signature on the data being\n\
    \   stored, it can determine whether or not a given operation is\n   permitted.\n\
    \   RELOAD also provides an optional shared-secret-based admission\n   control\
    \ feature using shared secrets and TLS pre-shared keys (PSK) or\n   TLS Secure\
    \ Remote Password (SRP).  In order to form a TLS connection\n   to any node in\
    \ the overlay, a new node needs to know the shared\n   overlay key, thus restricting\
    \ access to authorized users only.  This\n   feature is used together with certificate-based\
    \ access control, not\n   as a replacement for it.  It is typically used when\
    \ self-signed\n   certificates are being used but would generally not be used\
    \ when the\n   certificates were all signed by an enrollment server.\n"
- title: 1.4.  Structure of This Document
  contents:
  - "1.4.  Structure of This Document\n   The remainder of this document is structured\
    \ as follows.\n   o  Section 3 provides definitions of terms used in this document.\n\
    \   o  Section 4 provides an overview of the mechanisms used to establish\n  \
    \    and maintain the overlay.\n   o  Section 5 provides an overview of the mechanism\
    \ RELOAD provides to\n      support other applications.\n   o  Section 6 defines\
    \ the protocol messages that RELOAD uses to\n      establish and maintain the\
    \ overlay.\n   o  Section 7 defines the protocol messages that are used to store\
    \ and\n      retrieve data using RELOAD.\n   o  Section 8 defines the Certificate\
    \ Store Usages.\n   o  Section 9 defines the TURN Server Usage needed to locate\
    \ TURN\n      (Traversal Using Relays around NAT) servers for NAT traversal.\n\
    \   o  Section 10 defines a specific Topology Plug-in using a Chord-based\n  \
    \    algorithm.\n   o  Section 11 defines the mechanisms that new RELOAD nodes\
    \ use to\n      join the overlay for the first time.\n   o  Section 12 provides\
    \ an extended example.\n"
- title: 2.  Requirements Language
  contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   Terms in this document are defined in-line when used and\
    \ are also\n   defined below for reference.  The definitions in this section use\n\
    \   terminology and concepts that are not explained until later in the\n   specification.\n\
    \   Admitting Peer (AP):  A peer in the overlay which helps the Joining\n    \
    \  Node join the Overlay.\n   Bootstrap Node:  A network node used by Joining\
    \ Nodes to help locate\n      the Admitting Peer.\n   Client:  A host that is\
    \ able to store data in and retrieve data from\n      the overlay, but does not\
    \ participate in routing or data storage\n      for the overlay.\n   Configuration\
    \ Document:  An XML document containing all the Overlay\n      Parameters for\
    \ one overlay instance.\n   Connection Table:  Contains connection information\
    \ for the set of\n      nodes to which a node is directly connected, which include\
    \ nodes\n      that are not yet available for routing.\n   Destination List: \
    \ A list of Node-IDs, Resource-IDs, and Opaque IDs\n      through which a message\
    \ is to be routed, in strict order.  A\n      single Node-ID, Resource-ID, or\
    \ Opaque ID is a trivial form of\n      Destination List.  When multiple Node-IDs\
    \ are specified, a\n      Destination List is a loose source route.  The list\
    \ is reduced hop\n      by hop, and does not include the source but does include\
    \ the\n      destination.\n   DHT:  A distributed hash table.  A DHT is an abstract\
    \ storage service\n      realized by storing the contents of the hash table across\
    \ a set of\n      peers.\n   ID:  A generic term for any kind of identifiers in\
    \ an Overlay.  This\n      document specifies an ID as being an Application-ID,\
    \ a Kind-ID, a\n      Node-ID, a transaction ID, a component ID, a response ID,\
    \ a\n      Resource-ID, or an Opaque ID.\n   Joining Node (JN):  A node that is\
    \ attempting to become a peer in a\n      particular Overlay.\n   Kind:  A Kind\
    \ defines a particular type of data that can be stored in\n      the overlay.\
    \  Applications define new Kinds to store the data they\n      use.  Each Kind\
    \ is identified with a unique integer called a\n      Kind-ID.\n   Kind-ID:  A\
    \ unique 32-bit value identifying a Kind.  Kind-IDs are\n      either private\
    \ or allocated by IANA (see Section 14.6).\n   Maximum Request Lifetime:  The\
    \ maximum time a request will wait for a\n      response.  This value is equal\
    \ to the value of the overlay\n      reliability value (defined in Section 11.1)\
    \ multiplied by the\n      number of transmissions (defined in Section 6.2.1),\
    \ and so\n      defaults to 15 seconds.\n   Node:  The term \"node\" refers to\
    \ a host that may be either a peer or\n      a client.  Because RELOAD uses the\
    \ same protocol for both clients\n      and peers, much of the text applies equally\
    \ to both.  Therefore,\n      we use \"node\" when the text applies to both clients\
    \ and peers, and\n      we use the more specific term (i.e., \"client\" or \"\
    peer\") when the\n      text applies only to clients or only to peers.\n   Node-ID:\
    \  A value of fixed but configurable length that uniquely\n      identifies a\
    \ node.  Node-IDs of all 0s and all 1s are reserved.  A\n      value of 0 is not\
    \ used in the wire protocol, but can be used to\n      indicate an invalid node\
    \ in implementations and APIs.  The Node-ID\n      of all 1s is used on the wire\
    \ protocol as a wildcard.\n   Overlay Algorithm:  An overlay algorithm defines\
    \ the rules for\n      determining which peers in an overlay store a particular\
    \ piece of\n      data and for determining a topology of interconnections amongst\n\
    \      peers in order to find a piece of data.\n   Overlay Instance:  A specific\
    \ overlay algorithm and the collection of\n      peers that are collaborating\
    \ to provide read and write access to\n      it.  Any number of overlay instances\
    \ can be running in an IP\n      network at a time, and each operates in isolation\
    \ of the others.\n   Overlay Parameters:  A set of values that are shared among\
    \ all nodes\n      in an overlay.  The overlay parameters are distributed in an\
    \ XML\n      document called the Configuration Document.\n   Peer:  A host that\
    \ is participating in the overlay.  Peers are\n      responsible for holding some\
    \ portion of the data that has been\n      stored in the overlay, and they are\
    \ responsible for routing\n      messages on behalf of other hosts as needed by\
    \ the Overlay\n      Algorithm.\n   Peer Admission:  The act of admitting a node\
    \ (the Joining Node) into\n      an Overlay.  After the admission process is over,\
    \ the Joining Node\n      is a fully functional peer of the overlay.  During the\
    \ admission\n      process, the Joining Node may need to present credentials to\
    \ prove\n      that it has sufficient authority to join the overlay.\n   Resource:\
    \  An object or group of objects stored in a P2P network.\n   Resource-ID:  A\
    \ value that identifies some resources and which is\n      used as a key for storing\
    \ and retrieving the resource.  Often this\n      is not human friendly/readable.\
    \  One way to generate a Resource-ID\n      is by applying a mapping function\
    \ to some other unique name (e.g.,\n      user name or service name) for the resource.\
    \  The Resource-ID is\n      used by the distributed database algorithm to determine\
    \ the peer\n      or peers that are responsible for storing the data for the\n\
    \      overlay.  In structured P2P networks, Resource-IDs are generally\n    \
    \  fixed length and are formed by hashing the Resource Name.  In\n      unstructured\
    \ networks, Resource Names may be used directly as\n      Resource-IDs and may\
    \ be of variable length.\n   Resource Name:  The name by which a resource is identified.\
    \  In\n      unstructured P2P networks, the Resource Name is sometimes used\n\
    \      directly as a Resource-ID.  In structured P2P networks, the\n      Resource\
    \ Name is typically mapped into a Resource-ID by using the\n      string as the\
    \ input to hash function.  Structured and unstructured\n      P2P networks are\
    \ described in [RFC5694].  A SIP resource, for\n      example, is often identified\
    \ by its AOR (address-of-record), which\n      is an example of a Resource Name.\n\
    \   Responsible Peer:  The peer that is responsible for a specific\n      resource,\
    \ as defined by the Topology Plug-in algorithm.\n   Routing Table:  The set of\
    \ directly connected peers which a node can\n      use to forward overlay messages.\
    \  In normal operation, these peers\n      will all be in the Connection Table,\
    \ but not vice versa, because\n      some peers may not yet be available for routing.\
    \  Peers may send\n      messages directly to peers that are in their Connection\
    \ Tables,\n      but may forward messages to peers that are not in their Connection\n\
    \      Table only through peers that are in the Routing Table.\n   Successor Replacement\
    \ Hold-Down Time:  The amount of time to wait\n      before starting replication\
    \ when a new successor is found; it\n      defaults to 30 seconds.\n   Transaction\
    \ ID:  A randomly chosen identifier selected by the\n      originator of a request\
    \ that is used to correlate requests and\n      responses.\n   Usage:  The definition\
    \ of a set of data structures (data Kinds) that\n      an application wants to\
    \ store in the overlay.  A usage may also\n      define a set of network protocols\
    \ (Application IDs) that can be\n      tunneled over TLS or DTLS direct connections\
    \ between nodes.  For\n      example, the SIP Usage defines a SIP registration\
    \ data Kind, which\n      contains information on how to reach a SIP endpoint,\
    \ and two\n      Application IDs corresponding to the SIP and SIPS protocols.\n\
    \   User:  A physical person identified by the certificates assigned to\n    \
    \  them.\n   User Name:  A name identifying a user of the overlay, typically used\n\
    \      as a Resource Name or as a label on a resource that identifies the\n  \
    \    user owning the resource.\n"
- title: 4.  Overlay Management Overview
  contents:
  - "4.  Overlay Management Overview\n   The most basic function of RELOAD is as a\
    \ generic overlay network.\n   Nodes need to be able to join the overlay, form\
    \ connections to other\n   nodes, and route messages through the overlay to nodes\
    \ to which they\n   are not directly connected.  This section provides an overview\
    \ of the\n   mechanisms that perform these functions.\n"
- title: 4.1.  Security and Identification
  contents:
  - "4.1.  Security and Identification\n   The overlay parameters are specified in\
    \ a Configuration Document.\n   Because the parameters include security-critical\
    \ information, such as\n   the certificate signing trust anchors, the Configuration\
    \ Document\n   needs to be retrieved securely.  The initial Configuration Document\n\
    \   is either initially fetched over HTTPS or manually provisioned.\n   Subsequent\
    \ Configuration Document updates are received either as a\n   result of being\
    \ refreshed periodically by the configuration server,\n   or, more commonly, by\
    \ being flood-filled through the overlay, which\n   allows for fast propagation\
    \ once an update is pushed.  In the latter\n   case, updates are via digital signatures\
    \ that trace back to the\n   initial Configuration Document.\n   Every node in\
    \ the RELOAD overlay is identified by a Node-ID.  The\n   Node-ID is used for\
    \ three major purposes:\n   o  To address the node itself.\n   o  To determine\
    \ the node's position in the overlay topology (if the\n      overlay is structured;\
    \ overlays do not need to be structured).\n   o  To determine the set of resources\
    \ for which the node is\n      responsible.\n   Each node has a certificate [RFC5280]\
    \ containing its Node-ID in a\n   subjectAltName extension, which is unique within\
    \ an overlay instance.\n   The certificate serves multiple purposes:\n   o  It\
    \ entitles the user to store data at specific locations in the\n      Overlay\
    \ Instance.  Each data Kind defines the specific rules for\n      determining\
    \ which certificates can access each Resource-ID/Kind-ID\n      pair.  For instance,\
    \ some Kinds might allow anyone to write at a\n      given location, whereas others\
    \ might restrict writes to the owner\n      of a single certificate.\n   o  It\
    \ entitles the user to operate a node that has a Node-ID found in\n      the certificate.\
    \  When the node forms a connection to another\n      peer, it uses this certificate\
    \ so that a node connecting to it\n      knows it is connected to the correct\
    \ node.  (Technically, a TLS or\n      DTLS association with client authentication\
    \ is formed.)  In\n      addition, the node can sign messages, thus providing\
    \ integrity and\n      authentication for messages which are sent from the node.\n\
    \   o  It entitles the user to use the user name found in the\n      certificate.\n\
    \   If a user has more than one device, typically they would get one\n   certificate\
    \ for each device.  This allows each device to act as a\n   separate peer.\n \
    \  RELOAD supports multiple certificate issuance models.  The first is\n   based\
    \ on a central enrollment process, which allocates a unique name\n   and Node-ID\
    \ and puts them in a certificate for the user.  All peers\n   in a particular\
    \ Overlay Instance have the enrollment server as a\n   trust anchor and so can\
    \ verify any other peer's certificate.\n   The second model is useful in settings,\
    \ when a group of users want to\n   set up an overlay network but are not concerned\
    \ about attack by other\n   users in the network.  For instance, users on a LAN\
    \ might want to set\n   up a short-term ad hoc network without going to the trouble\
    \ of\n   setting up an enrollment server.  RELOAD supports the use of self-\n\
    \   generated, self-signed certificates.  When self-signed certificates\n   are\
    \ used, the node also generates its own Node-ID and user name.  The\n   Node-ID\
    \ is computed as a digest of the public key, to prevent Node-ID\n   theft.  Note\
    \ that the relevant cryptographic property for the digest\n   is partial preimage\
    \ resistance.  Collision resistance is not needed,\n   because an attacker who\
    \ can create two nodes with the same Node-ID\n   but a different public key obtains\
    \ no advantage.  This model is still\n   subject to a number of known attacks\
    \ (most notably, Sybil attacks\n   [Sybil]) and can be safely used only in closed\
    \ networks where users\n   are mutually trusting.  Another drawback of this approach\
    \ is that the\n   user's data is then tied to their key, so if a key is changed,\
    \ any\n   data stored under their Node-ID needs to be re-stored.  This is not\n\
    \   an issue for centrally issued Node-IDs provided that the\n   Certification\
    \ Authority (CA) reissues the same Node-ID when a new\n   certificate is generated.\n\
    \   The general principle here is that the security mechanisms (TLS or\n   DTLS\
    \ at the data link layer and message signatures at the message\n   transport layer)\
    \ are always used, even if the certificates are self-\n   signed.  This allows\
    \ for a single set of code paths in the systems,\n   with the only difference\
    \ being whether certificate verification is\n   used to chain to a single root\
    \ of trust.\n"
- title: 4.1.1.  Shared-Key Security
  contents:
  - "4.1.1.  Shared-Key Security\n   RELOAD also provides an admission control system\
    \ based on shared\n   keys.  In this model, the peers all share a single key which\
    \ is used\n   to authenticate the peer-to-peer connections via TLS-PSK [RFC4279]\
    \ or\n   TLS-SRP [RFC5054].\n"
- title: 4.2.  Clients
  contents:
  - "4.2.  Clients\n   RELOAD defines a single protocol that is used both as the peer\n\
    \   protocol and as the client protocol for the overlay.  Having a single\n  \
    \ protocol simplifies implementation, particularly for devices that may\n   act\
    \ in either role, and allows clients to inject messages directly\n   into the\
    \ overlay.\n   We use the term \"peer\" to identify a node in the overlay that\
    \ routes\n   messages for nodes other than those to which it is directly\n   connected.\
    \  Peers also have storage responsibilities.  We use the\n   term \"client\" to\
    \ refer to nodes that do not have routing or storage\n   responsibilities.  When\
    \ text applies to both peers and clients, we\n   will simply refer to such devices\
    \ as \"nodes\".\n   RELOAD's client support allows nodes that are not participating\
    \ in\n   the overlay as peers to utilize the same implementation and to\n   benefit\
    \ from the same security mechanisms as the peers.  Clients\n   possess and use\
    \ certificates that authorize the user to store data at\n   certain locations\
    \ in the overlay.  The Node-ID in the certificate is\n   used to identify the\
    \ particular client as a member of the overlay and\n   to authenticate its messages.\n\
    \   In RELOAD, unlike some other designs, clients are not first-class\n   entities.\
    \  From the perspective of a peer, a client is a node that\n   has connected to\
    \ the overlay, but that has not yet taken steps to\n   insert itself into the\
    \ overlay topology.  It might never do so (if\n   it's a client), or it might\
    \ eventually do so (if it's just a node\n   that is taking a long time to join).\
    \  The routing and storage rules\n   for RELOAD provide for correct behavior by\
    \ peers regardless of\n   whether other nodes attached to them are clients or\
    \ peers.  Of\n   course, a client implementation needs to know that it intends\
    \ to be a\n   client, but this localizes complexity only to that node.\n   For\
    \ more discussion about the motivation for RELOAD's client support,\n   see Appendix\
    \ B.\n"
- title: 4.2.1.  Client Routing
  contents:
  - "4.2.1.  Client Routing\n   Clients may insert themselves in the overlay in two\
    \ ways:\n   o  Establish a connection to the peer responsible for the client's\n\
    \      Node-ID in the overlay.  Then, requests may be sent from/to the\n     \
    \ client using its Node-ID in the same manner as if it were a peer,\n      because\
    \ the responsible peer in the overlay will handle the final\n      step of routing\
    \ to the client.  This may require a TURN [RFC5766]\n      relay in cases where\
    \ NATs or firewalls prevent a client from\n      forming a direct connection with\
    \ its responsible peer.  Note that\n      clients that choose this option need\
    \ to process Update messages\n      from the peer (Section 6.4.2.3).  These updates\
    \ can indicate that\n      the peer is no longer responsible for the client's\
    \ Node-ID.  The\n      client would then need to form a connection to the appropriate\n\
    \      peer.  Failure to do so will result in the client no longer\n      receiving\
    \ messages.\n   o  Establish a connection with an arbitrary peer in the overlay\n\
    \      (perhaps based on network proximity or an inability to establish a\n  \
    \    direct connection with the responsible peer).  In this case, the\n      client\
    \ will rely on RELOAD's Destination List feature\n      (Section 6.3.2.2) to ensure\
    \ reachability.  The client can initiate\n      requests, and any node in the\
    \ overlay that knows the Destination\n      List to its current location can reach\
    \ it, but the client is not\n      directly reachable using only its Node-ID.\
    \  If the client is to\n      receive incoming requests from other members of\
    \ the overlay, the\n      Destination List needed to reach the client needs to\
    \ be learnable\n      via other mechanisms, such as being stored in the overlay\
    \ by a\n      usage.  A client connected this way using a certificate with only\n\
    \      a single Node-ID can proceed to use the connection without\n      performing\
    \ an Attach (Section 6.5.1).  A client wishing to connect\n      using this mechanism\
    \ with a certificate with multiple Node-IDs can\n      use a Ping (Section 6.5.3)\
    \ to probe the Node-ID of the node to\n      which it is connected before performing\
    \ the Attach.\n"
- title: 4.2.2.  Minimum Functionality Requirements for Clients
  contents:
  - "4.2.2.  Minimum Functionality Requirements for Clients\n   A node may act as\
    \ a client simply because it does not have the\n   capacity or need to act as\
    \ a peer in the overlay, or because it does\n   not even have an implementation\
    \ of the Topology Plug-in defined in\n   Section 6.4.1, needed to act as a peer\
    \ in the overlay.  In order to\n   exchange RELOAD messages with a peer, a client\
    \ needs to meet a\n   minimum level of functionality.  Such a client will:\n \
    \  o  Implement RELOAD's connection-management operations that are used\n    \
    \  to establish the connection with the peer.\n   o  Implement RELOAD's data retrieval\
    \ methods (with client\n      functionality).\n   o  Be able to calculate Resource-IDs\
    \ used by the overlay.\n   o  Possess security credentials needed by the overlay\
    \ that it is\n      implementing.\n   A client speaks the same protocol as the\
    \ peers, knows how to\n   calculate Resource-IDs, and signs its requests in the\
    \ same manner as\n   peers.  While a client does not necessarily require a full\n\
    \   implementation of the overlay algorithm, calculating the Resource-ID\n   requires\
    \ an implementation of an appropriate algorithm for the\n   overlay.\n"
- title: 4.3.  Routing
  contents:
  - "4.3.  Routing\n   This section discusses the capabilities of RELOAD's routing\
    \ layer and\n   the protocol features used to implement the capabilities, and\n\
    \   provides a brief overview of how they are used.  Appendix A discusses\n  \
    \ some alternative designs and the trade-offs that would be necessary\n   to support\
    \ them.\n   RELOAD's routing provides the following capabilities:\n   Resource-based\
    \ Routing:   RELOAD supports routing messages based\n      solely on the name\
    \ of the resource.  Such messages are delivered\n      to a node that is responsible\
    \ for that resource.  Both structured\n      and unstructured overlays are supported,\
    \ so the route may not be\n      deterministic for all Topology Plug-ins.\n  \
    \ Node-based Routing:   RELOAD supports routing messages to a specific\n     \
    \ node in the overlay.\n   Clients:   RELOAD supports requests from and to clients\
    \ that do not\n      participate in overlay routing.  The clients are located\
    \ via\n      either of the mechanisms described above.\n   NAT Traversal:   RELOAD\
    \ supports establishing and using connections\n      between nodes separated by\
    \ one or more NATs, including locating\n      peers behind NATs for those overlays\
    \ allowing/requiring it.\n   Low State:   RELOAD's routing algorithms do not require\
    \ significant\n      state (i.e., state linear or greater in the number of outstanding\n\
    \      messages that have passed through it) to be stored on intermediate\n  \
    \    peers.\n   Routability in Unstable Topologies:   Overlay topology changes\n\
    \      constantly in an overlay of moderate size due to the failure of\n     \
    \ individual nodes and links in the system.  RELOAD's routing allows\n      peers\
    \ to reroute messages when a failure is detected, and replies\n      can be returned\
    \ to the requesting node as long as the peers that\n      originally forwarded\
    \ the successful request do not fail before the\n      response is returned.\n\
    \   RELOAD's routing utilizes three basic mechanisms:\n   Destination Lists: \
    \  While, in principle, it is possible to just\n      inject a message into the\
    \ overlay with a single Node-ID as the\n      destination, RELOAD provides a source-routing\
    \ capability in the\n      form of \"Destination Lists\".  A Destination List\
    \ provides a list\n      of the nodes through which a message flows in order (i.e.,\
    \ it is\n      loose source routed).  The minimal Destination List contains just\n\
    \      a single value.\n   Via Lists:   In order to allow responses to follow\
    \ the same path as\n      requests, each message also contains a \"Via List\"\
    , which is\n      appended to by each node a message traverses.  This Via List\
    \ can\n      then be inverted and used as a Destination List for the response.\n\
    \   RouteQuery:   The RouteQuery method allows a node to query a peer for\n  \
    \    the next hop it will use to route a message.  This method is\n      useful\
    \ for diagnostics and for iterative routing (see\n      Section 6.4.2.4).\n  \
    \ The basic routing mechanism that RELOAD uses is symmetric recursive.\n   We\
    \ will first describe symmetric recursive routing and then discuss\n   its advantages\
    \ in terms of the requirements discussed above.\n   Symmetric recursive routing\
    \ requires that a request message follow a\n   path through the overlay to the\
    \ destination: each peer forwards the\n   message closer to its destination. \
    \ The return path of the response\n   goes through the same nodes as the request\
    \ (though it may also go\n   through some new intermediate nodes due to topology\
    \ changes).  Note\n   that a failure on the reverse path caused by a topology\
    \ change after\n   the request was sent will be handled by the end-to-end retransmission\n\
    \   of the response as described in Section 6.2.1.  For example, the\n   following\
    \ figure shows a message following a route from A to Z\n   through B and X:\n\
    \   A         B         X         Z\n   -------------------------------\n   ---------->\n\
    \   Dest=Z\n            ---------->\n            Via=A\n            Dest=Z\n \
    \                     ---------->\n                      Via=A,B\n           \
    \           Dest=Z\n                      <----------\n                      \
    \ Dest=X,B,A\n            <----------\n               Dest=B,A\n   <----------\n\
    \        Dest=A\n   Note that this figure does not indicate whether A is a client\
    \ or\n   peer.  A forwards its request to B, and the response is returned to A\n\
    \   in the same manner regardless of A's role in the overlay.\n   This figure\
    \ shows use of full Via Lists by intermediate peers B and\n   X.  However, if\
    \ B and/or X are willing to store state, then they may\n   elect to truncate the\
    \ lists and save the truncated information\n   internally using the transaction\
    \ ID as a key to allow it to be\n   retrieved later.  Later, when the response\
    \ message arrives, the\n   transaction ID would be used to recover the truncated\
    \ information and\n   return the response message along the path from which the\
    \ request\n   arrived.  This option requires a greater amount of state to be stored\n\
    \   on intermediate peers, but saves a small amount of bandwidth and\n   reduces\
    \ the need for modifying the message en route.  Selection of\n   this mode of\
    \ operation is a choice for the individual peer; the\n   techniques are interoperable\
    \ even on a single message.  The figure\n   below shows B using full Via Lists,\
    \ but X truncating them to X1 and\n   saving the state internally.\n   A     \
    \    B         X         Z\n   -------------------------------\n   ---------->\n\
    \   Dest=Z\n            ---------->\n            Via=A\n            Dest=Z\n \
    \                     ---------->\n                      Via=X1\n            \
    \          Dest=Z\n                      <----------\n                       \
    \ Dest=X,X1\n              <----------\n                 Dest=B,A\n   <----------\n\
    \        Dest=A\n   As before, when B receives the message, B creates a Via List\n\
    \   consisting of [A].  However, instead of sending [A, B], X creates an\n   opaque\
    \ ID X1 which maps internally to [A, B] (perhaps by being an\n   encryption of\
    \ [A, B]) and then forwards to Z with only X1 as the Via\n   List.  When the response\
    \ arrives at X, it maps X1 back to [A, B],\n   then inverts it to produce the\
    \ new Destination List [B, A], and\n   finally routes it to B.\n   RELOAD also\
    \ supports a basic iterative \"routing\" mode, in which the\n   intermediate peers\
    \ merely return a response indicating the next hop,\n   but do not actually forward\
    \ the message to that next hop themselves.\n   Iterative routing is implemented\
    \ using the RouteQuery method (see\n   Section 6.4.2.4), which requests this behavior.\
    \  Note that iterative\n   routing is selected only by the initiating node.\n"
- title: 4.4.  Connectivity Management
  contents:
  - "4.4.  Connectivity Management\n   In order to provide efficient routing, a peer\
    \ needs to maintain a set\n   of direct connections to other peers in the Overlay\
    \ Instance.  Due to\n   the presence of NATs, these connections often cannot be\
    \ formed\n   directly.  Instead, we use the Attach request to establish a\n  \
    \ connection.  Attach uses Interactive Connectivity Establishment (ICE)\n   [RFC5245]\
    \ to establish the connection.  It is assumed that the reader\n   is familiar\
    \ with ICE.\n   Say that peer A wishes to form a direct connection to peer B,\
    \ either\n   to join the overlay or to add more connections in its Routing Table.\n\
    \   It gathers ICE candidates and packages them up in an Attach request,\n   which\
    \ it sends to B through usual overlay routing procedures.  B does\n   its own\
    \ candidate gathering and sends back a response with its\n   candidates.  A and\
    \ B then do ICE connectivity checks on the candidate\n   pairs.  The result is\
    \ a connection between A and B.  At this point, A\n   and B MAY send messages\
    \ directly between themselves without going\n   through other overlay peers. \
    \ In other words, A and B are in each\n   other's Connection Tables.  They MAY\
    \ then execute an Update process,\n   resulting in additions to each other's Routing\
    \ Tables, and may then\n   become able to route messages through each other to\
    \ other overlay\n   nodes.\n   There are two cases where Attach is not used. \
    \ The first is when a\n   peer is joining the overlay and is not connected to\
    \ any peers.  In\n   order to support this case, a small number of bootstrap nodes\n\
    \   typically need to be publicly accessible so that new peers can\n   directly\
    \ connect to them.  Section 11 contains more detail on this.\n   The second case\
    \ is when a client connects to a peer at an arbitrary\n   IP address, rather than\
    \ to its responsible peer, as described in the\n   second bullet point of Section\
    \ 4.2.1.\n   In general, a peer needs to maintain connections to all of the peers\n\
    \   near it in the Overlay Instance and to enough other peers to have\n   efficient\
    \ routing (the details on what \"enough\" and \"near\" mean\n   depend on the\
    \ specific overlay).  If a peer cannot form a connection\n   to some other peer,\
    \ this is not necessarily a disaster; overlays can\n   route correctly even without\
    \ fully connected links.  However, a peer\n   needs to try to maintain the specified\
    \ Routing Table defined by the\n   Topology Plug-in algorithm and needs to form\
    \ new connections if it\n   detects that it has fewer direct connections than\
    \ specified by the\n   algorithm.  This also implies that peers, in accordance\
    \ with the\n   Topology Plug-in algorithm, need to periodically verify that the\n\
    \   connected peers are still alive and, if not, need to try to re-form\n   the\
    \ connections or form alternate ones.  See Section 10.7.4.3 for an\n   example\
    \ on how a specific overlay algorithm implements these\n   constraints.\n"
- title: 4.5.  Overlay Algorithm Support
  contents:
  - "4.5.  Overlay Algorithm Support\n   The Topology Plug-in allows RELOAD to support\
    \ a variety of overlay\n   algorithms.  This specification defines a DHT based\
    \ on Chord, which\n   is mandatory to implement, but the base RELOAD protocol\
    \ is designed\n   to support a variety of overlay algorithms.  The information\
    \ needed\n   to implement this DHT is fully contained in this specification, but\n\
    \   it is easier to understand if you are familiar with Chord-based\n   [Chord]\
    \ DHTs.  A nice tutorial can be found at [wikiChord].\n"
- title: 4.5.1.  Support for Pluggable Overlay Algorithms
  contents:
  - "4.5.1.  Support for Pluggable Overlay Algorithms\n   RELOAD defines three methods\
    \ for overlay maintenance: Join, Update,\n   and Leave.  However, the contents\
    \ of these messages, when they are\n   sent, and their precise semantics are specified\
    \ by the actual overlay\n   algorithm, which is specified by configuration for\
    \ all nodes in the\n   overlay and thus is known to nodes before they attempt\
    \ to join the\n   overlay.  RELOAD merely provides a framework of commonly needed\n\
    \   methods that provide uniformity of notation (and ease of debugging)\n   for\
    \ a variety of overlay algorithms.\n"
- title: 4.5.2.  Joining, Leaving, and Maintenance Overview
  contents:
  - "4.5.2.  Joining, Leaving, and Maintenance Overview\n   When a new peer wishes\
    \ to join the Overlay Instance, it will need a\n   Node-ID that it is allowed\
    \ to use and a set of credentials which\n   match that Node-ID.  When an enrollment\
    \ server is used, the Node-ID\n   used is the one found in the certificate received\
    \ from the enrollment\n   server.  The details of the joining procedure are defined\
    \ by the\n   overlay algorithm, but the general steps for joining an Overlay\n\
    \   Instance are:\n   o  Form connections to some other peers.\n   o  Acquire\
    \ the data values this peer is responsible for storing.\n   o  Inform the other\
    \ peers which were previously responsible for that\n      data that this peer\
    \ has taken over responsibility.\n   The first thing the peer needs to do is to\
    \ form a connection to some\n   bootstrap node.  Because this is the first connection\
    \ the peer makes,\n   these nodes will need public IP addresses so that they can\
    \ be\n   connected to directly.  Once a peer has connected to one or more\n  \
    \ bootstrap nodes, it can form connections in the usual way, by routing\n   Attach\
    \ messages through the overlay to other nodes.  After a peer has\n   connected\
    \ to the overlay for the first time, it can cache the set of\n   past adjacencies\
    \ which have public IP addresses and can attempt to\n   use them as future bootstrap\
    \ nodes.  Note that this requires some\n   notion of which addresses are likely\
    \ to be public as discussed in\n   Section 9.\n   After a peer has connected to\
    \ a bootstrap node, it then needs to take\n   up its appropriate place in the\
    \ overlay.  This requires two major\n   operations:\n   o  Form connections to\
    \ other peers in the overlay to populate its\n      Routing Table.\n   o  Get\
    \ a copy of the data it is now responsible for storing, and\n      assume responsibility\
    \ for that data.\n   The second operation is performed by contacting the Admitting\
    \ Peer\n   (AP), the node which is currently responsible for the relevant\n  \
    \ section of the overlay.\n   The details of this operation depend mostly on the\
    \ overlay algorithm\n   involved, but a typical case would be:\n   1.  JN sends\
    \ a Join request to AP announcing its intention to join.\n   2.  AP sends a Join\
    \ response.\n   3.  AP does a sequence of Stores to JN to give it the data it\
    \ will\n       need.\n   4.  AP does Updates to JN and to other peers to tell\
    \ them about its\n       own Routing Table.  At this point, both JN and AP consider\
    \ JN\n       responsible for some section of the Overlay Instance.\n   5.  JN\
    \ makes its own connections to the appropriate peers in the\n       Overlay Instance.\n\
    \   After this process completes, JN is a full member of the Overlay\n   Instance\
    \ and can process Store/Fetch requests.\n   Note that the first node is a special\
    \ case.  When ordinary nodes\n   cannot form connections to the bootstrap nodes,\
    \ then they are not\n   part of the overlay.  However, the first node in the overlay\
    \ can\n   obviously not connect to other nodes.  In order to support this case,\n\
    \   potential first nodes (which can also initially serve as bootstrap\n   nodes)\
    \ need to somehow be instructed that they are the entire\n   overlay, rather than\
    \ part of an existing overlay (e.g., by comparing\n   their IP address to the\
    \ bootstrap IP addresses in the configuration\n   file).\n   Note that clients\
    \ do not perform either of these operations.\n"
- title: 4.6.  First-Time Setup
  contents:
  - "4.6.  First-Time Setup\n   Previous sections addressed how RELOAD works after\
    \ a node has\n   connected.  This section provides an overview of how users get\n\
    \   connected to the overlay for the first time.  RELOAD is designed so\n   that\
    \ users can start with the name of the overlay they wish to join\n   and perhaps\
    \ an account name and password, and can leverage these into\n   having a working\
    \ peer with minimal user intervention.  This helps\n   avoid the problems that\
    \ have been experienced with conventional SIP\n   clients in which users need\
    \ to manually configure a large number of\n   settings.\n"
- title: 4.6.1.  Initial Configuration
  contents:
  - "4.6.1.  Initial Configuration\n   In the first phase of the setup process, the\
    \ user starts with the\n   name of the overlay and uses it to download an initial\
    \ set of overlay\n   configuration parameters.  The node does a DNS SRV [RFC2782]\
    \ lookup\n   on the overlay name to get the address of a configuration server.\
    \  It\n   can then connect to this server with HTTPS [RFC2818] to download a\n\
    \   Configuration Document which contains the basic overlay configuration\n  \
    \ parameters as well as a set of bootstrap nodes which can be used to\n   join\
    \ the overlay.  The details of the relationships between names in\n   the HTTPS\
    \ certificates and the overlay names are described in\n   Section 11.2.\n   If\
    \ a node already has the valid Configuration Document that it\n   received by\
    \ an out-of-band method, this step can be skipped.  Note\n   that this out-of-band\
    \ method needs to provide authentication and\n   integrity, because the Configuration\
    \ Document contains the trust\n   anchors used by the overlay.\n"
- title: 4.6.2.  Enrollment
  contents:
  - "4.6.2.  Enrollment\n   If the overlay is using centralized enrollment, then a\
    \ user needs to\n   acquire a certificate before joining the overlay.  The certificate\n\
    \   attests both to the user's name within the overlay and to the\n   Node-IDs\
    \ which they are permitted to operate.  In this case, the\n   Configuration Document\
    \ will contain the address of an enrollment\n   server which can be used to obtain\
    \ such a certificate and will also\n   contain the trust anchor, so this document\
    \ must be retrieved securely\n   (see Section 11.2).  The enrollment server may\
    \ (and probably will)\n   require some sort of account name for the user and a\
    \ password before\n   issuing the certificate.  The enrollment server's ability\
    \ to ensure\n   attackers cannot get a large number of certificates for the overlay\n\
    \   is one of the cornerstones of RELOAD's security.\n"
- title: 4.6.3.  Diagnostics
  contents:
  - "4.6.3.  Diagnostics\n   Significant advice around managing a RELOAD overlay and\
    \ extensions\n   for diagnostics are described in [P2P-DIAGNOSTICS].\n"
- title: 5.  Application Support Overview
  contents:
  - "5.  Application Support Overview\n   RELOAD is not intended to be used alone,\
    \ but rather as a substrate\n   for other applications.  These applications can\
    \ use RELOAD for a\n   variety of purposes:\n   o  To store data in the overlay\
    \ and to retrieve data stored by other\n      nodes.\n   o  As a discovery mechanism\
    \ for services such as TURN.\n   o  To form direct connections which can be used\
    \ to transmit\n      application-level messages without using the overlay.\n \
    \  This section provides an overview of these services.\n"
- title: 5.1.  Data Storage
  contents:
  - "5.1.  Data Storage\n   RELOAD provides operations to Store and Fetch data.  Each\
    \ location in\n   the Overlay Instance is referenced by a Resource-ID.  However,\
    \ each\n   location may contain data elements corresponding to multiple Kinds\n\
    \   (e.g., certificate and SIP registration).  Similarly, there may be\n   multiple\
    \ elements of a given Kind, as shown below:\n                      +--------------------------------+\n\
    \                      |            Resource-ID         |\n                  \
    \    |                                |\n                      | +------------+\
    \  +------------+ |\n                      | |   Kind 1   |  |   Kind 2   | |\n\
    \                      | |            |  |            | |\n                  \
    \    | | +--------+ |  | +--------+ | |\n                      | | | Value  |\
    \ |  | | Value  | | |\n                      | | +--------+ |  | +--------+ |\
    \ |\n                      | |            |  |            | |\n              \
    \        | | +--------+ |  | +--------+ | |\n                      | | | Value\
    \  | |  | | Value  | | |\n                      | | +--------+ |  | +--------+\
    \ | |\n                      | |            |  +------------+ |\n            \
    \          | | +--------+ |                 |\n                      | | | Value\
    \  | |                 |\n                      | | +--------+ |             \
    \    |\n                      | +------------+                 |\n           \
    \           +--------------------------------+\n   Each Kind is identified by\
    \ a Kind-ID, which is a code point either\n   assigned by IANA or allocated out\
    \ of a private range.  As part of the\n   Kind definition, protocol designers\
    \ may define constraints (such as\n   limits on size) on the values which may\
    \ be stored.  For many Kinds,\n   the set may be restricted to a single value,\
    \ while some sets may be\n   allowed to contain multiple identical items, and\
    \ others may have only\n   unique items.  Note that a Kind may be employed by\
    \ multiple usages,\n   and new usages are encouraged to use previously defined\
    \ Kinds where\n   possible.  We define the following data models in this document,\n\
    \   although other usages can define their own structures:\n   single value: \
    \ There can be at most one item in the set, and any\n      value overwrites the\
    \ previous item.\n   array:  Many values can be stored and addressed by a numeric\
    \ index.\n   dictionary:  The values stored are indexed by a key.  Often, this\
    \ key\n      is one of the values from the certificate of the peer sending the\n\
    \      Store request.\n   In order to protect stored data from tampering by other\
    \ nodes, each\n   stored value is individually digitally signed by the node which\n\
    \   created it.  When a value is retrieved, the digital signature can be\n   verified\
    \ to detect tampering.  If the certificate used to verify the\n   stored value\
    \ signature expires, the value can no longer be retrieved\n   (although it may\
    \ not be immediately garbage collected by the storing\n   node), and the creating\
    \ node will need to store the value again if it\n   desires that the stored value\
    \ continue to be available.\n"
- title: 5.1.1.  Storage Permissions
  contents:
  - "5.1.1.  Storage Permissions\n   A major issue in peer-to-peer storage networks\
    \ is minimizing the\n   burden of becoming a peer and, in particular, minimizing\
    \ the amount\n   of data which any peer needs to store for other nodes.  RELOAD\n\
    \   addresses this issue by allowing any given node to store data only at\n  \
    \ a small number of locations in the overlay, with those locations\n   being determined\
    \ by the node's certificate.  When a peer uses a Store\n   request to place data\
    \ at a location authorized by its certificate, it\n   signs that data with the\
    \ private key that corresponds to its\n   certificate.  Then the peer responsible\
    \ for storing the data is able\n   to verify that the peer issuing the request\
    \ is authorized to make\n   that request.  Each data Kind defines the exact rules\
    \ for determining\n   what certificate is appropriate.\n   The most natural rule\
    \ is that a certificate authorizes a user to\n   store data keyed with their user\
    \ name X.  Thus, only a user with a\n   certificate for \"alice@example.org\"\
    \ could write to that location in\n   the overlay (see Section 11.3).  However,\
    \ other usages can define any\n   rules they choose, including publicly writable\
    \ values.\n   The digital signature over the data serves two purposes.  First,\
    \ it\n   allows the peer responsible for storing the data to verify that this\n\
    \   Store is authorized.  Second, it provides integrity for the data.\n   The\
    \ signature is saved along with the data value (or values) so that\n   any reader\
    \ can verify the integrity of the data.  Of course, the\n   responsible peer can\
    \ \"lose\" the value, but it cannot undetectably\n   modify it.\n   The size requirements\
    \ of the data being stored in the overlay are\n   variable.  For instance, a SIP\
    \ AOR and voicemail differ widely in the\n   storage size.  RELOAD leaves it to\
    \ the usage and overlay\n   configuration to limit size imbalances of various\
    \ Kinds.\n"
- title: 5.1.2.  Replication
  contents:
  - "5.1.2.  Replication\n   Replication in P2P overlays can be used to provide:\n\
    \   persistence:  if the responsible peer crashes and/or if the storing\n    \
    \  peer leaves the overlay\n   security:  to guard against DoS attacks by the\
    \ responsible peer or\n      routing attacks to that responsible peer\n   load\
    \ balancing:  to balance the load of queries for popular resources\n   A variety\
    \ of schemes are used in P2P overlays to achieve some of\n   these goals.  Common\
    \ techniques include replicating on neighbors of\n   the responsible peer, randomly\
    \ locating replicas around the overlay,\n   and replicating along the path to\
    \ the responsible peer.\n   The core RELOAD specification does not specify a particular\n\
    \   replication strategy.  Instead, the first level of replication\n   strategies\
    \ is determined by the overlay algorithm, which can base the\n   replication strategy\
    \ on its particular topology.  For example, Chord\n   places replicas on successor\
    \ peers, which will take over\n   responsibility if the responsible peer fails\
    \ [Chord].\n   If additional replication is needed, for example, if data persistence\n\
    \   is particularly important for a particular usage, then that usage may\n  \
    \ specify additional replication, such as implementing random\n   replications\
    \ by inserting a different well-known constant into the\n   Resource Name used\
    \ to store each replicated copy of the resource.\n   Such replication strategies\
    \ can be added independently of the\n   underlying algorithm, and their usage\
    \ can be determined based on the\n   needs of the particular usage.\n"
- title: 5.2.  Usages
  contents:
  - "5.2.  Usages\n   By itself, the distributed storage layer provides only the\n\
    \   infrastructure on which applications are built.  In order to do\n   anything\
    \ useful, a usage needs to be defined.  Each usage needs to\n   specify several\
    \ things:\n   o  Register Kind-ID code points for any Kinds that the usage defines\n\
    \      (Section 14.6).\n   o  Define the data structure for each of the Kinds\
    \ (the value member\n      in Section 7.2).  If the data structure contains character\n\
    \      strings, conversion rules between characters and the binary\n      storage\
    \ need to be specified.\n   o  Define access control rules for each of the Kinds\
    \ (Section 7.3).\n   o  Define how the Resource Name is used to form the Resource-ID\
    \ where\n      each Kind is stored.\n   o  Describe how values will be merged\
    \ when a network partition is\n      being healed.\n   The Kinds defined by a\
    \ usage may also be applied to other usages.\n   However, a need for different\
    \ parameters, such as a different access\n   control model, would imply the need\
    \ to create a new Kind.\n"
- title: 5.3.  Service Discovery
  contents:
  - "5.3.  Service Discovery\n   RELOAD does not currently define a generic service\
    \ discovery\n   algorithm as part of the base protocol, although a simplistic\
    \ TURN-\n   specific discovery mechanism is provided.  A variety of service\n\
    \   discovery algorithms can be implemented as extensions to the base\n   protocol,\
    \ such as the service discovery algorithm ReDIR\n   [opendht-sigcomm05] and [REDIR-RELOAD].\n"
- title: 5.4.  Application Connectivity
  contents:
  - "5.4.  Application Connectivity\n   There is no requirement that a RELOAD Usage\
    \ needs to use RELOAD's\n   primitives for establishing its own communication\
    \ if it already\n   possesses its own means of establishing connections.  For\
    \ example,\n   one could design a RELOAD-based resource discovery protocol which\n\
    \   used HTTP to retrieve the actual data.\n   For more common situations, however,\
    \ it is the overlay itself --\n   rather than an external authority such as DNS\
    \ -- which is used to\n   establish a connection.  RELOAD provides connectivity\
    \ to applications\n   using the AppAttach method.  For example, if a P2PSIP node\
    \ wishes to\n   establish a SIP dialog with another P2PSIP node, it will use\n\
    \   AppAttach to establish a direct connection with the other node.  This\n  \
    \ new connection is separate from the peer protocol connection.  It is\n   a dedicated\
    \ DTLS or TLS flow used only for the SIP dialog.\n"
- title: 6.  Overlay Management Protocol
  contents:
  - "6.  Overlay Management Protocol\n   This section defines the basic protocols\
    \ used to create, maintain,\n   and use the RELOAD overlay network.  We start\
    \ by defining the basic\n   concept of how message destinations are interpreted\
    \ when routing\n   messages.  We then describe the symmetric recursive routing\
    \ model,\n   which is RELOAD's default routing algorithm.  Finally, we define\
    \ the\n   message structure and the messages used to join and maintain the\n \
    \  overlay.\n"
- title: 6.1.  Message Receipt and Forwarding
  contents:
  - "6.1.  Message Receipt and Forwarding\n   When a node receives a message, it first\
    \ examines the overlay,\n   version, and other header fields to determine whether\
    \ the message is\n   one it can process.  If any of these are incorrect, as defined\
    \ in\n   Section 6.3.2, it is an error and the message MUST be discarded.  The\n\
    \   peer SHOULD generate an appropriate error, but local policy can\n   override\
    \ this and cause the message to be silently dropped.\n   Once the peer has determined\
    \ that the message is correctly formatted\n   (note that this does not include\
    \ signature-checking on intermediate\n   nodes as the message may be fragmented),\
    \ it examines the first entry\n   on the Destination List.  There are three possible\
    \ cases here:\n   o  The first entry on the Destination List is an ID for which\
    \ the\n      peer is responsible.  A peer is always responsible for the\n    \
    \  wildcard Node-ID.  Handling of this case is described in\n      Section 6.1.1.\n\
    \   o  The first entry on the Destination List is an ID for which another\n  \
    \    peer is responsible.  Handling of this case is described in\n      Section\
    \ 6.1.2.\n   o  The first entry on the Destination List is an opaque ID that is\n\
    \      being used for Destination List compression.  Handling of this\n      case\
    \ is described in Section 6.1.3.  Note that opaque IDs can be\n      distinguished\
    \ from Node-IDs and Resource-IDs on the wire as\n      described in Section 6.3.2.2.\n\
    \   These cases are handled as discussed below.\n"
- title: 6.1.1.  Responsible ID
  contents:
  - "6.1.1.  Responsible ID\n   If the first entry on the Destination List is an ID\
    \ for which the\n   peer is responsible, there are several (mutually exclusive)\
    \ subcases\n   to consider.\n   o  If the entry is a Resource-ID, then it MUST\
    \ be the only entry on\n      the Destination List.  If there are other entries,\
    \ the message\n      MUST be silently dropped.  Otherwise, the message is destined\
    \ for\n      this node, so the node MUST verify the signature as described in\n\
    \      Section 7.1 and MUST pass it to the upper layers.  \"Upper layers\"\n \
    \     is used here to mean the components above the \"Overlay Link\n      Service\
    \ Boundary\" line in the figure in Section 1.2.\n   o  If the entry is a Node-ID\
    \ which equals this node's Node-ID, then\n      the message is destined for this\
    \ node.  If it is the only entry on\n      the Destination List, the message is\
    \ destined for this node and so\n      the node passes it to the upper layers.\
    \  Otherwise, the node\n      removes the entry from the Destination List and\
    \ repeats the\n      routing process with the next entry on the Destination List.\
    \  If\n      the message is a response and list compression was used, then the\n\
    \      node first modifies the Destination List to reinsert the saved\n      state,\
    \ e.g., by unpacking any opaque IDs.\n   o  If the entry is the wildcard Node-ID\
    \ (all \"1\"s), the message is\n      destined for this node, and the node passes\
    \ the message to the\n      upper layers.  A message with a wildcard Node-ID as\
    \ its first\n      entry is never forwarded; it is consumed locally.\n   o  If\
    \ the entry is a Node-ID which is not equal to this node, then\n      the node\
    \ MUST drop the message silently unless the Node-ID\n      corresponds to a node\
    \ which is directly connected to this node\n      (i.e., a client).  In the latter\
    \ case, the node MUST attempt to\n      forward the message to the destination\
    \ node as described in the\n      next section (though this may fail for connectivity\
    \ reasons,\n      because the TTL has expired, or because of some other error.)\n\
    \   Note that this process implies that in order to address a message to\n   \"\
    the peer that controls region X\", a sender sends to Resource-ID X,\n   not Node-ID\
    \ X.\n"
- title: 6.1.2.  Other ID
  contents:
  - "6.1.2.  Other ID\n   If the first entry on the Destination List is neither an\
    \ opaque ID\n   nor an ID the peer is responsible for, then the peer MUST forward\
    \ the\n   message towards that entry.  This means that it MUST select one of\n\
    \   the peers to which it is connected and which is most likely to be\n   responsible\
    \ (according to the Topology Plug-in) for the first entry\n   on the Destination\
    \ List.  For the CHORD-RELOAD topology, the routing\n   to the most likely responsible\
    \ node is explained in Section 10.3.  If\n   the first entry on the Destination\
    \ List is in the peer's Connection\n   Table, the peer MUST forward the message\
    \ to that peer directly.\n   Otherwise, the peer consults the Routing Table to\
    \ forward the\n   message.\n   Any intermediate peer which forwards a RELOAD request\
    \ MUST ensure\n   that if it receives a response to that message, the response\
    \ can be\n   routed back through the set of nodes through which the request\n\
    \   passed.  The peer selects one of these approaches:\n   o  The peer can add\
    \ an entry to the Via List in the forwarding header\n      that will enable it\
    \ to determine the correct node.  This is done\n      by appending to the Via\
    \ List the Node-ID of the node from which\n      the request was received.\n \
    \  o  The peer can keep per-transaction state which will allow it to\n      determine\
    \ the correct node.\n   As an example of the first strategy, consider an example\
    \ with nodes\n   A, B, C, D, and E.  If node D receives a message from node C\
    \ with Via\n   List [A, B], then D would forward to the next node E with Via List\n\
    \   [A, B, C].  Now, if E wants to respond to the message, it reverses\n   the\
    \ Via List to produce the Destination List, resulting in\n   [D, C, B, A].  When\
    \ D forwards the response to C, the Destination\n   List will contain [C, B, A].\n\
    \   As an example of the second strategy, if node D receives a message\n   from\
    \ node C with transaction ID X (as assigned by A) and Via List\n   [A, B], it\
    \ could store [X, C] in its state database and forward the\n   message with the\
    \ Via List unchanged.  When D receives the response,\n   it consults its state\
    \ database for transaction ID X, determines that\n   the request came from C,\
    \ and forwards the response to C.\n   Intermediate peers which modify the Via\
    \ List are not required to\n   simply add entries.  The only requirement is that\
    \ the peer MUST be\n   able to reconstruct the correct Destination List on the\
    \ return route.\n   RELOAD provides explicit support for this functionality in\
    \ the form\n   of opaque IDs, which can replace any number of Via List entries.\n\
    \   For instance, in the above example, Node D might send E a Via List\n   containing\
    \ only the opaque ID I.  E would then use the Destination\n   List [D, I] to send\
    \ its return message.  When D processes this\n   Destination List, it would detect\
    \ that I is an opaque ID, recover the\n   Via List [A, B, C], and reverse that\
    \ to produce the correct\n   Destination List [C, B, A] before sending it to C.\
    \  This feature is\n   called \"list compression\".  Possibilities for an opaque\
    \ ID include a\n   compressed and/or encrypted version of the original Via List\
    \ and an\n   index into a state database containing the original Via List, but\
    \ the\n   details are a local matter.\n   No matter what mechanism for storing\
    \ Via List state is used, if an\n   intermediate peer exits the overlay, then\
    \ on the return trip the\n   message cannot be forwarded and will be dropped.\
    \  The ordinary\n   timeout and retransmission mechanisms provide stability over\
    \ this\n   type of failure.\n   Note that if an intermediate peer retains per-transaction\
    \ state\n   instead of modifying the Via List, it needs some mechanism for timing\n\
    \   out that state; otherwise, its state database will grow without\n   bound.\
    \  Whatever algorithm is used, unless a FORWARD_CRITICAL\n   forwarding option\
    \ (Section 6.3.2.3) or an overlay configuration\n   option explicitly indicates\
    \ this state is not needed, the state MUST\n   be maintained for at least the\
    \ value of the overlay-reliability-timer\n   configuration parameter and MAY be\
    \ kept longer.  Future extensions,\n   such as [P2PSIP-RELAY], may define mechanisms\
    \ for determining when\n   this state does not need to be retained.\n   There\
    \ is no requirement to ensure that a request issued after the\n   receipt of a\
    \ response follows the same path as the response.  As a\n   consequence, there\
    \ is no requirement to use either of the mechanisms\n   described above (Via List\
    \ or state retention) when processing a\n   response message.\n   A node receiving\
    \ a request from another node MUST ensure that any\n   response to that request\
    \ exits that node with a Destination List\n   equal to the concatenation of the\
    \ Node-ID of the node from which the\n   request was received with the Via List\
    \ in the original request.  The\n   intermediate node normally learns the Node-ID\
    \ that the other node is\n   using via an Attach, but a node using a certificate\
    \ with a single\n   Node-ID MAY elect not to send an Attach (see Section 4.2.1,\
    \ bullet\n   2).  If a node with a certificate with multiple Node-IDs attempts\
    \ to\n   route a message other than a Ping or Attach through a node without\n\
    \   performing an Attach, the receiving node MUST reject the request with\n  \
    \ an Error_Forbidden error.  The node MUST implement support for\n   returning\
    \ responses to a Ping or Attach request made by a Joining\n   Node Attaching to\
    \ its responsible peer.\n"
- title: 6.1.3.  Opaque ID
  contents:
  - "6.1.3.  Opaque ID\n   If the first entry on the Destination List is an opaque\
    \ ID (e.g., a\n   compressed Via List), the peer MUST replace the entry with the\n\
    \   original Via List that it replaced and then re-examine the\n   Destination\
    \ List to determine which of the three cases in Section 6.1\n   now applies.\n"
- title: 6.2.  Symmetric Recursive Routing
  contents:
  - "6.2.  Symmetric Recursive Routing\n   This section defines RELOAD's Symmetric\
    \ Recursive Routing algorithm,\n   which is the default algorithm used by nodes\
    \ to route messages\n   through the overlay.  All implementations MUST implement\
    \ this routing\n   algorithm.  An overlay MAY be configured to use alternative\
    \ routing\n   algorithms, and alternative routing algorithms MAY be selected on\
    \ a\n   per-message basis.  That is, a node in an overlay which supports\n   Symmetric\
    \ Recursive Routing and some other routing algorithm called\n   XXX might use\
    \ Symmetric Recursive Routing some of the time and XXX at\n   other times.\n"
- title: 6.2.1.  Request Origination
  contents:
  - "6.2.1.  Request Origination\n   In order to originate a message to a given Node-ID\
    \ or Resource-ID, a\n   node MUST construct an appropriate Destination List. \
    \ The simplest\n   such Destination List is a single entry containing the Node-ID\
    \ or\n   Resource-ID.  The resulting message MUST be forwarded to its\n   destination\
    \ via the normal overlay routing mechanisms.  The node MAY\n   also construct\
    \ a more complicated Destination List for source\n   routing.\n   Once the message\
    \ is constructed, the node sends the message to an\n   adjacent peer.  If the\
    \ first entry on the Destination List is\n   directly connected, then the message\
    \ MUST be routed down that\n   connection.  Otherwise, the Topology Plug-in MUST\
    \ be consulted to\n   determine the appropriate next hop.\n   Parallel requests\
    \ for a resource are a common solution to improve\n   reliability in the face\
    \ of churn or subversive peers.  Parallel\n   searches for usage-specified replicas\
    \ are managed by the usage layer,\n   for instance, by having the usage store\
    \ data at multiple\n   Resource-IDs, with the requesting node sending requests\
    \ to each of\n   those Resource-IDs.  However, a single request MAY also be routed\n\
    \   through multiple adjacent peers, even when they are known to be\n   suboptimal,\
    \ to improve reliability [vulnerabilities-acsac04].  Such\n   parallel searches\
    \ MAY be specified by the Topology Plug-in, in which\n   case it would return\
    \ multiple next hops and the request would be\n   routed to all of them.\n   Because\
    \ messages can be lost in transit through the overlay, RELOAD\n   incorporates\
    \ an end-to-end reliability mechanism.  When an\n   originating node transmits\
    \ a request, it MUST set a timer to the\n   current overlay-reliability-timer.\
    \  If a response has not been\n   received when the timer fires, the request MUST\
    \ be retransmitted with\n   the same transaction identifier.  The request MAY\
    \ be retransmitted up\n   to 4 times, for a total of 5 messages.  After the timer\
    \ for the fifth\n   transmission fires, the message MUST be considered to have\
    \ failed.\n   Although the originating node will be doing both end-to-end and\
    \ hop-\n   by-hop retransmissions, the end-by-end retransmission procedure is\n\
    \   not followed by intermediate nodes.  They follow the hop-by-hop\n   reliability\
    \ procedure described in Section 6.6.3.\n   The above algorithm can result in\
    \ multiple requests being delivered\n   to a node.  Receiving nodes MUST generate\
    \ semantically equivalent\n   responses to retransmissions of the same request\
    \ (this can be\n   determined by the transaction ID) if the request is received\
    \ within\n   the maximum request lifetime (15 seconds).  For some requests (e.g.,\n\
    \   Fetch), this can be accomplished merely by processing the request\n   again.\
    \  For other requests (e.g., Store), it may be necessary to\n   maintain state\
    \ for the duration of the request lifetime.\n"
- title: 6.2.2.  Response Origination
  contents:
  - "6.2.2.  Response Origination\n   When a peer sends a response to a request using\
    \ this routing\n   algorithm, it MUST construct the Destination List by reversing\
    \ the\n   order of the entries on the Via List.  This has the result that the\n\
    \   response traverses the same peers as the request traversed, except in\n  \
    \ reverse order (symmetric routing) and possibly with extra nodes\n   (loose routing).\n"
- title: 6.3.  Message Structure
  contents:
  - "6.3.  Message Structure\n   RELOAD is a message-oriented request/response protocol.\
    \  The messages\n   are encoded using binary fields.  All integers are represented\
    \ in\n   network byte order.  The general philosophy behind the design was to\n\
    \   use Type, Length, Value (TLV) fields to allow for extensibility.\n   However,\
    \ for the parts of a structure that were required in all\n   messages, we just\
    \ define these in a fixed position, as adding a type\n   and length for them is\
    \ unnecessary and would only increase bandwidth\n   and introduce new potential\
    \ interoperability issues.\n   Each message has three parts, which are concatenated,\
    \ as shown below:\n     +-------------------------+\n     |    Forwarding Header\
    \    |\n     +-------------------------+\n     |    Message Contents     |\n \
    \    +-------------------------+\n     |     Security Block      |\n     +-------------------------+\n\
    \   The contents of these parts are as follows:\n   Forwarding Header:  Each message\
    \ has a generic header which is used\n      to forward the message between peers\
    \ and to its final destination.\n      This header is the only information that\
    \ an intermediate peer\n      (i.e., one that is not the target of a message)\
    \ needs to examine.\n      Section 6.3.2 describes the format of this part.\n\
    \   Message Contents:  The message being delivered between the peers.\n      From\
    \ the perspective of the forwarding layer, the contents are\n      opaque; however,\
    \ they are interpreted by the higher layers.\n      Section 6.3.3 describes the\
    \ format of this part.\n   Security Block:  A security block containing certificates\
    \ and a\n      digital signature over the \"Message Contents\" section.  Note\
    \ that\n      this signature can be computed without parsing the message\n   \
    \   contents.  All messages MUST be signed by their originator.\n      Section\
    \ 6.3.4 describes the format of this part.\n"
- title: 6.3.1.  Presentation Language
  contents:
  - "6.3.1.  Presentation Language\n   The structures defined in this document are\
    \ defined using a C-like\n   syntax based on the presentation language used to\
    \ define TLS\n   [RFC5246].  Advantages of this style include:\n   o  It is familiar\
    \ enough that most readers can grasp it quickly.\n   o  The ability to define\
    \ nested structures allows a separation\n      between high-level and low-level\
    \ message structures.\n   o  It has a straightforward wire encoding that allows\
    \ quick\n      implementation, but the structures can be comprehended without\n\
    \      knowing the encoding.\n   o  It is possible to mechanically compile encoders\
    \ and decoders.\n   Several idiosyncrasies of this language are worth noting:\n\
    \   o  All lengths are denoted in bytes, not objects.\n   o  Variable-length values\
    \ are denoted like arrays, with angle\n      brackets.\n   o  \"select\" is used\
    \ to indicate variant structures.\n   For instance, \"uint16 array<0..2^8-2>;\"\
    \ represents up to 254 bytes,\n   which corresponds to up to 127 values of two\
    \ bytes (16 bits) each.\n   A repetitive structure member shares a common notation\
    \ with a member\n   containing a variable-length block of data.  The latter always\
    \ starts\n   with \"opaque\", whereas the former does not.  For instance, the\n\
    \   following denotes a variable block of data:\n                     opaque data<0..2^32-1>;\n\
    \   whereas the following denotes a list of 0, 1, or more instances of\n   the\
    \ Name element:\n                     Name names<0..2^32-1>;\n"
- title: 6.3.1.1.  Common Definitions
  contents:
  - "6.3.1.1.  Common Definitions\n   This section provides an introduction to the\
    \ presentation language\n   used throughout RELOAD.\n   An enum represents an\
    \ enumerated type.  The values associated with\n   each possibility are represented\
    \ in parentheses, and the maximum\n   value is represented as a nameless value,\
    \ for purposes of describing\n   the width of the containing integral type.  For\
    \ instance, Boolean\n   represents a true or false:\n         enum { false(0),\
    \ true(1), (255) } Boolean;\n   A boolean value is either a 1 or a 0.  The max\
    \ value of 255 indicates\n   that this is represented as a single byte on the\
    \ wire.\n   The NodeId, shown below, represents a single Node-ID.\n          \
    \   typedef opaque       NodeId[NodeIdLength];\n   A NodeId is a fixed-length\
    \ structure represented as a series of\n   bytes, with the most significant byte\
    \ first.  The length is set on a\n   per-overlay basis within the range of 16-20\
    \ bytes (128 to 160 bits).\n   (See Section 11.1 for how NodeIdLength is set.)\
    \  Note that the use of\n   \"typedef\" here is an extension to the TLS language,\
    \ but its meaning\n   should be relatively obvious.  Also note that the [ size\
    \ ] syntax\n   defines a fixed-length element that does not include the length\
    \ of\n   the element in the on-the-wire encoding.\n   A ResourceId, shown below,\
    \ represents a single Resource-ID.\n             typedef opaque       ResourceId<0..2^8-1>;\n\
    \   Like a NodeId, a ResourceId is an opaque string of bytes, but unlike\n   NodeIds,\
    \ ResourceIds are variable length, up to 254 bytes (2040 bits)\n   in length.\
    \  On the wire, each ResourceId is preceded by a single\n   length byte (allowing\
    \ lengths up to 255 bytes).  Thus, the 3-byte\n   value \"FOO\" would be encoded\
    \ as: 03 46 4f 4f.  Note the < range >\n   syntax defines a variable length element\
    \ that includes the length of\n   the element in the on-the-wire encoding.  The\
    \ number of bytes to\n   encode the length on the wire is derived by range; i.e.,\
    \ it is the\n   minimum number of bytes which can encode the largest range value.\n\
    \   A more complicated example is IpAddressPort, which represents a\n   network\
    \ address and can be used to carry either an IPv6 or IPv4\n   address:\n     \
    \   enum { invalidAddressType(0), ipv4_address(1), ipv6_address(2),\n        \
    \     (255) } AddressType;\n        struct {\n          uint32               \
    \   addr;\n          uint16                  port;\n        } IPv4AddrPort;\n\
    \        struct {\n          uint128                 addr;\n          uint16 \
    \                 port;\n        } IPv6AddrPort;\n        struct {\n         \
    \ AddressType             type;\n          uint8                   length;\n \
    \         select (type) {\n            case ipv4_address:\n               IPv4AddrPort\
    \       v4addr_port;\n            case ipv6_address:\n               IPv6AddrPort\
    \       v6addr_port;\n            /* This structure can be extended */\n     \
    \     };\n        } IpAddressPort;\n   The first two fields in the structure are\
    \ the same no matter what\n   kind of address is being represented:\n   type:\
    \  The type of address (IPv4 or IPv6).\n   length:  The length of the rest of\
    \ the structure.\n   By having the type and the length appear at the beginning\
    \ of the\n   structure regardless of the kind of address being represented, an\n\
    \   implementation which does not understand new address type X can still\n  \
    \ parse the IpAddressPort field and then discard it if it is not\n   needed.\n\
    \   The rest of the IpAddressPort structure is either an IPv4AddrPort or\n   an\
    \ IPv6AddrPort.  Both of these simply consist of an address\n   represented as\
    \ an integer and a 16-bit port.  As an example, here is\n   the wire representation\
    \ of the IPv4 address \"192.0.2.1\" with port\n   \"6084\".\n             01 \
    \          ; type    = IPv4\n             06           ; length  = 6\n       \
    \      c0 00 02 01  ; address = 192.0.2.1\n             17 c4        ; port  \
    \  = 6084\n   Unless a given structure that uses a select explicitly allows for\n\
    \   unknown types in the select, any unknown type SHOULD be treated as a\n   parsing\
    \ error, and the whole message SHOULD be discarded with no\n   response.\n"
- title: 6.3.2.  Forwarding Header
  contents:
  - "6.3.2.  Forwarding Header\n   The forwarding header is defined as a ForwardingHeader\
    \ structure, as\n   shown below.\n        struct {\n          uint32         \
    \    relo_token;\n          uint32             overlay;\n          uint16    \
    \         configuration_sequence;\n          uint8              version;\n   \
    \       uint8              ttl;\n          uint32             fragment;\n    \
    \      uint32             length;\n          uint64             transaction_id;\n\
    \          uint32             max_response_length;\n          uint16         \
    \    via_list_length;\n          uint16             destination_list_length;\n\
    \          uint16             options_length;\n          Destination        via_list[via_list_length];\n\
    \          Destination        destination_list\n                             \
    \  [destination_list_length];\n          ForwardingOption   options[options_length];\n\
    \        } ForwardingHeader;\n   The contents of the structure are:\n   relo_token:\
    \  The first four bytes identify this message as a RELOAD\n      message.  This\
    \ field MUST contain the value 0xd2454c4f (the string\n      \"RELO\" with the\
    \ high bit of the first byte set).\n   overlay:  The 32-bit checksum/hash of the\
    \ overlay being used.  This\n      MUST be formed by taking the lower 32 bits\
    \ of the SHA-1 [RFC3174]\n      hash of the overlay name.  The purpose of this\
    \ field is to allow\n      nodes to participate in multiple overlays and to detect\
    \ accidental\n      misconfiguration.  This is not a security-critical function.\
    \  The\n      overlay name MUST consist of a sequence of characters that would\n\
    \      be allowable as a DNS name.  Specifically, as it is used in a DNS\n   \
    \   lookup, it will need to be compliant with the grammar for the\n      domain\
    \ as specified in Section 2.3.1 of [RFC1035].\n   configuration_sequence:  The\
    \ sequence number of the configuration\n      file.  See Section 6.3.2.1 for details.\n\
    \   version:  The version of the RELOAD protocol being used times 10.\n      RELOAD\
    \ version numbers are fixed-point decimal numbers between\n      fixed-point integer\
    \ between 0.1 and 25.4.  This document describes\n      version 1.0, with a value\
    \ of 0x0a.  (Note that versions used prior\n      to the publication of this RFC\
    \ used version number 0.1.)  Nodes\n      MUST reject messages with other versions.\n\
    \   ttl:  An 8-bit field indicating the number of iterations, or hops, a\n   \
    \   message can experience before it is discarded.  The TTL (time-to-\n      live)\
    \ value MUST be decremented by one at every hop along the\n      route the message\
    \ traverses just before transmission.  If a\n      received message has a TTL\
    \ of 0 and the message is not destined\n      for the receiving node, then the\
    \ message MUST NOT be propagated\n      further, and an Error_TTL_Exceeded error\
    \ should be generated.  The\n      initial value of the TTL SHOULD be 100 and\
    \ MUST NOT exceed 100\n      unless defined otherwise by the overlay configuration.\n\
    \      Implementations which receive messages with a TTL greater than the\n  \
    \    current value of initial-ttl (or the default of 100) MUST discard\n     \
    \ the message and send an Error_TTL_Exceeded error.\n   fragment:  This field\
    \ is used to handle fragmentation.  The high bit\n      (0x80000000) MUST be set\
    \ for historical reasons.  If the next bit\n      (0x40000000) is set to 1, it\
    \ indicates that this is the last (or\n      only) fragment.  The next six bits\
    \ (0x20000000 through 0x01000000)\n      are reserved and SHOULD be set to zero.\
    \  The remainder of the\n      field is used to indicate the fragment offset;\
    \ see Section 6.7 for\n      details.\n   length:  The count in bytes of the size\
    \ of the message, including the\n      header, after the eventual fragmentation.\n\
    \   transaction_id:  A unique 64-bit number that identifies this\n      transaction\
    \ and also allows receivers to disambiguate transactions\n      which are otherwise\
    \ identical.  In order to provide a high\n      probability that transaction IDs\
    \ are unique, they MUST be randomly\n      generated.  Responses use the same\
    \ transaction ID as the request\n      to which they correspond.  Transaction\
    \ IDs are also used for\n      fragment reassembly.  See Section 6.7 for details.\n\
    \   max_response_length:  The maximum size in bytes of a response.  This\n   \
    \   is used by requesting nodes to avoid receiving (unexpected) very\n      large\
    \ responses.  If this value is non-zero, responding peers MUST\n      check that\
    \ any response would not exceed it and if so generate an\n      Error_Incompatible_with_Overlay\
    \ value.  This value SHOULD be set\n      to zero for responses.\n   via_list_length:\
    \  The length of the Via List in bytes.  Note that in\n      this field and the\
    \ following two length fields, we depart from the\n      usual variable-length\
    \ convention of having the length immediately\n      precede the value, in order\
    \ to make it easier for hardware\n      decoding engines to quickly determine\
    \ the length of the header.\n   destination_list_length:  The length of the Destination\
    \ List in\n      bytes.\n   options_length:  The length of the header options\
    \ in bytes.\n   via_list:  The via_list contains the sequence of destinations\
    \ through\n      which the message has passed.  The via_list starts out empty\
    \ and\n      grows as the message traverses each peer.  In stateless cases, the\n\
    \      previous hop that the message is from is appended to the Via List\n   \
    \   as specified in Section 6.1.2.\n   destination_list:  The destination_list\
    \ contains a sequence of\n      destinations through which the message should\
    \ pass.  The\n      Destination List is constructed by the message originator.\
    \  The\n      first element on the Destination List is where the message goes\n\
    \      next.  Generally, the list shrinks as the message traverses each\n    \
    \  listed peer, though if list compression is used, this may not be\n      true.\n\
    \   options:  Contains a series of ForwardingOption entries.  See\n      Section\
    \ 6.3.2.3.\n"
- title: 6.3.2.1.  Processing Configuration Sequence Numbers
  contents:
  - "6.3.2.1.  Processing Configuration Sequence Numbers\n   In order to be part of\
    \ the overlay, a node MUST have a copy of the\n   overlay Configuration Document.\
    \  In order to allow for configuration\n   document changes, each version of the\
    \ Configuration Document MUST\n   contain a sequence number which MUST be monotonically\
    \ increasing mod\n   65535.  Because the sequence number may, in principle, wrap,\
    \ greater\n   than or less than are interpreted by modulo arithmetic as in TCP.\n\
    \   When a destination node receives a request, it MUST check that the\n   configuration_sequence\
    \ field is equal to its own configuration\n   sequence number.  If they do not\
    \ match, the node MUST generate an\n   error, either Error_Config_Too_Old or Error_Config_Too_New.\
    \  In\n   addition, if the configuration file in the request is too old, the\n\
    \   node MUST generate a ConfigUpdate message to update the requesting\n   node.\
    \  This allows new Configuration Documents to propagate quickly\n   throughout\
    \ the system.  The one exception to this rule is that if the\n   configuration_sequence\
    \ field is equal to 65535 and the message type\n   is ConfigUpdate, then the message\
    \ MUST be accepted regardless of the\n   receiving node's configuration sequence\
    \ number.  Since 65535 is a\n   special value, peers sending a new configuration\
    \ when the\n   configuration sequence is currently 65534 MUST set the configuration\n\
    \   sequence number to 0 when they send a new configuration.\n"
- title: 6.3.2.2.  Destination and Via Lists
  contents:
  - "6.3.2.2.  Destination and Via Lists\n   The Destination List and Via List are\
    \ sequences of Destination\n   values:\n     enum { invalidDestinationType(0),\
    \ node(1), resource(2),\n            opaque_id_type(3), /* 128-255 not allowed\
    \ */ (255) }\n          DestinationType;\n     select (destination_type) {\n \
    \     case node:\n             NodeId               node_id;\n      case resource:\n\
    \             ResourceId           resource_id;\n      case opaque_id_type:\n\
    \             opaque               opaque_id<0..2^8-1>;\n          /* This structure\
    \ may be extended with new types */\n     } DestinationData;\n     struct {\n\
    \        DestinationType         type;\n        uint8                   length;\n\
    \        DestinationData         destination_data;\n     } Destination;\n    \
    \ struct {\n        uint16               opaque_id; /* Top bit MUST be 1 */\n\
    \     } Destination;\n   If the destination structure is a 16-bit integer, then\
    \ the first bit\n   MUST be set to 1, and it MUST be treated as if it were a full\n\
    \   structure with a DestinationType of opaque_id_type and an opaque_id\n   that\
    \ was 2 bytes long with the value of the 16-bit integer.  If the\n   destination\
    \ structure starts with DestinationType, then the first bit\n   MUST be set to\
    \ 0, and the destination structure must use a TLV\n   structure with the following\
    \ contents:\n   type\n      The type of the DestinationData Payload Data Unit\
    \ (PDU).  It may\n      be one of \"node\", \"resource\", or \"opaque_id_type\"\
    .\n   length\n      The length of the destination_data.\n   destination_data\n\
    \      The destination value itself, which is an encoded DestinationData\n   \
    \   structure that depends on the value of \"type\".\n   Note that the destination\
    \ structure encodes a Type, Length, Value.\n   The Length field specifies the\
    \ length of the DestinationData values,\n   which allows the addition of new DestinationTypes.\
    \  It also allows an\n   implementation which does not understand a given DestinationType\
    \ to\n   skip over it.\n   A DestinationData can be one of three types:\n   node\n\
    \      A Node-ID.\n   opaque\n      A compressed list of Node-IDs and an eventual\
    \ Resource-ID.\n      Because this value has been compressed by one of the peers,\
    \ it is\n      meaningful only to that peer and cannot be decoded by other peers.\n\
    \      Thus, it is represented as an opaque string.\n   resource\n      The Resource-ID\
    \ of the resource which is desired.  This type MUST\n      appear only in the\
    \ final location of a Destination List and MUST\n      NOT appear in a Via List.\
    \  It is meaningless to try to route\n      through a resource.\n   One possible\
    \ encoding of the 16-bit integer version as an opaque\n   identifier is to encode\
    \ an index into a Connection Table.  To avoid\n   misrouting responses in the\
    \ event a response is delayed and the\n   Connection Table entry has changed,\
    \ the identifier SHOULD be split\n   between an index and a generation counter\
    \ for that index.  When a\n   Node first joins the overlay, the generation counters\
    \ SHOULD be\n   initialized to random values.  An implementation MAY use 12 bits\
    \ for\n   the Connection Table index and 3 bits for the generation counter.\n\
    \   (Note that this does not suggest a 4096-entry Connection Table for\n   every\
    \ peer, only the ability to encode for a larger Connection\n   Table.)  When a\
    \ Connection Table slot is used for a new connection,\n   the generation counter\
    \ is incremented (with wrapping).  Connection\n   Table slots are used on a rotating\
    \ basis to maximize the time\n   interval between uses of the same slot for different\
    \ connections.\n   When routing a message to an entry in the Destination List\
    \ encoding a\n   Connection Table entry, the peer MUST confirm that the generation\n\
    \   counter matches the current generation counter of that index before\n   forwarding\
    \ the message.  If it does not match, the message MUST be\n   silently dropped.\n"
- title: 6.3.2.3.  Forwarding Option
  contents:
  - "6.3.2.3.  Forwarding Option\n   The Forwarding header can be extended with forwarding\
    \ header options,\n   which are a series of ForwardingOption structures:\n   \
    \ enum { invalidForwardingOptionType(0), (255) }\n      ForwardingOptionType;\n\
    \    struct {\n      ForwardingOptionType      type;\n      uint8            \
    \         flags;\n      uint16                    length;\n      select (type)\
    \ {\n            /* This type may be extended */\n      };\n    } ForwardingOption;\n\
    \   Each ForwardingOption consists of the following values:\n   type\n      The\
    \ type of the option.  This structure allows for unknown options\n      types.\n\
    \   flags\n      Three flags are defined: FORWARD_CRITICAL(0x01),\n      DESTINATION_CRITICAL(0x02),\
    \ and RESPONSE_COPY(0x04).  These flags\n      MUST NOT be set in a response.\
    \  If the FORWARD_CRITICAL flag is\n      set, any peer that would forward the\
    \ message but does not\n      understand this option MUST reject the request with\
    \ an\n      Error_Unsupported_Forwarding_Option error response.  If the\n    \
    \  DESTINATION_CRITICAL flag is set, any node that generates a\n      response\
    \ to the message but does not understand the forwarding\n      option MUST reject\
    \ the request with an\n      Error_Unsupported_Forwarding_Option error response.\
    \  If the\n      RESPONSE_COPY flag is set, any node generating a response MUST\n\
    \      copy the option from the request to the response except that the\n    \
    \  RESPONSE_COPY, FORWARD_CRITICAL, and DESTINATION_CRITICAL flags\n      MUST\
    \ be cleared.\n   length\n      The length of the rest of the structure.  Note\
    \ that a 0 length may\n      be reasonable if the mere presence of the option\
    \ is meaningful and\n      no value is required.\n   option\n      The option\
    \ value.\n"
- title: 6.3.3.  Message Contents Format
  contents:
  - "6.3.3.  Message Contents Format\n   The second major part of a RELOAD message\
    \ is the contents part, which\n   is defined by MessageContents:\n   enum { invalidMessageExtensionType(0),\n\
    \          (2^16-1) } MessageExtensionType;\n   struct {\n     MessageExtensionType\
    \  type;\n     Boolean               critical;\n     opaque                extension_contents<0..2^32-1>;\n\
    \   } MessageExtension;\n   struct {\n     uint16                 message_code;\n\
    \     opaque                 message_body<0..2^32-1>;\n     MessageExtension \
    \      extensions<0..2^32-1>;\n   } MessageContents;\n   The contents of this\
    \ structure are as follows:\n   message_code\n      This indicates the message\
    \ that is being sent.  The code space is\n      broken up as follows:\n      0x0\
    \  Invalid Message Code.  This code will never be assigned.\n      0x1 .. 0x7FFF\
    \  Requests and responses.  These code points are\n         always paired, with\
    \ requests being an odd value and the\n         corresponding response being the\
    \ request code plus 1.  Thus,\n         \"probe_request\" (the Probe request)\
    \ has the value 1 and\n         \"probe_answer\" (the Probe response) has the\
    \ value 2\n      0x8000 .. 0xFFFE  Reserved\n      0xFFFF  Error\n      The message\
    \ codes are defined in Section 14.8.\n   message_body\n      The message body\
    \ itself, represented as a variable-length string\n      of bytes.  The bytes\
    \ themselves are dependent on the code value.\n      See the sections describing\
    \ the various RELOAD methods (Join,\n      Update, Attach, Store, Fetch, etc.)\
    \ for the definitions of the\n      payload contents.\n   extensions\n      Extensions\
    \ to the message.  Currently no extensions are defined,\n      but new extensions\
    \ can be defined by the process described in\n      Section 14.14.\n   All extensions\
    \ have the following form:\n   type\n      The extension type.\n   critical\n\
    \      Whether this extension needs to be understood in order to process\n   \
    \   the message.  If critical = True and the recipient does not\n      understand\
    \ the message, it MUST generate an\n      Error_Unknown_Extension error.  If critical\
    \ = False, the recipient\n      MAY choose to process the message even if it does\
    \ not understand\n      the extension.\n   extension_contents\n      The contents\
    \ of the extension (which are extension dependent).\n   The subsections 6.4.2,\
    \ 6.5, and 7 describe structures that are\n   inserted inside the message_body\
    \ member, depending on the value of\n   the message_code value.  For example,\
    \ a message_code value of\n   join_req means that the structure named JoinReq\
    \ is inserted inside\n   message_body.  This document does not contain a mapping\
    \ between\n   message_code values and structure names, as the conversion between\n\
    \   the two is obvious.\n   Similarly, this document uses the name of the structure\
    \ without the\n   \"Req\" or \"Ans\" suffix to mean the execution of a transaction\n\
    \   consisting of the matching request and answer.  For example, when the\n  \
    \ text says \"perform an Attach\", it must be understood as performing a\n   transaction\
    \ composed of an AttachReq and an AttachAns.\n"
- title: 6.3.3.1.  Response Codes and Response Errors
  contents:
  - "6.3.3.1.  Response Codes and Response Errors\n   A node processing a request\
    \ MUST return its status in the\n   message_code field.  If the request was a\
    \ success, then the message\n   code MUST be set to the response code that matches\
    \ the request (i.e.,\n   the next code up).  The response payload is then as defined\
    \ in the\n   request/response descriptions.\n   If the request has failed, then\
    \ the message code MUST be set to\n   0xffff (error) and the payload MUST be an\
    \ error_response message, as\n   shown below.\n   When the message code is 0xFFFF,\
    \ the payload MUST be an\n   ErrorResponse:\n         public struct {\n      \
    \     uint16             error_code;\n           opaque             error_info<0..2^16-1>;\n\
    \         } ErrorResponse;\n   The contents of this structure are as follows:\n\
    \   error_code\n      A numeric error code indicating the error that occurred.\n\
    \   error_info\n      An optional arbitrary byte string.  Unless otherwise specified,\n\
    \      this will be a UTF-8 text string that provides further information\n  \
    \    about what went wrong.  Developers are encouraged to include\n      enough\
    \ diagnostic information to be useful in error_info.  The\n      specific text\
    \ to be used and any relevant language or encoding\n      thereof is left to the\
    \ implementation.\n   The following error code values are defined.  The numeric\
    \ values for\n   these are defined in Section 14.9.\n   Error_Forbidden\n    \
    \  The requesting node does not have permission to make this request.\n   Error_Not_Found\n\
    \      The resource or node cannot be found or does not exist.\n   Error_Request_Timeout\n\
    \      A response to the request has not been received in a suitable\n      amount\
    \ of time.  The requesting node MAY resend the request at a\n      later time.\n\
    \   Error_Data_Too_Old\n      A store cannot be completed because the storage_time\
    \ precedes the\n      existing value.\n   Error_Data_Too_Large\n      A store\
    \ cannot be completed because the requested object exceeds\n      the size limits\
    \ for that Kind.\n   Error_Generation_Counter_Too_Low\n      A store cannot be\
    \ completed because the generation counter\n      precedes the existing value.\n\
    \   Error_Incompatible_with_Overlay\n      A peer receiving the request is using\
    \ a different overlay, overlay\n      algorithm, or hash algorithm, or some other\
    \ parameter that is\n      inconsistent with the overlay configuration.\n   Error_Unsupported_Forwarding_Option\n\
    \      A node received the request with a forwarding options flagged as\n    \
    \  critical, but the node does not support this option.  See\n      Section 6.3.2.3.\n\
    \   Error_TTL_Exceeded\n      A peer received the request in which the TTL was\
    \ decremented to\n      zero.  See Section 6.3.2.\n   Error_Message_Too_Large\n\
    \      A peer received a request that was too large.  See Section 6.6.\n   Error_Response_Too_Large\n\
    \      A node would have generated a response that is too large per the\n    \
    \  max_response_length field.\n   Error_Config_Too_Old\n      A destination node\
    \ received a request with a configuration\n      sequence that is too old.  See\
    \ Section 6.3.2.1.\n   Error_Config_Too_New\n      A destination node received\
    \ a request with a configuration\n      sequence that is too new.  See Section\
    \ 6.3.2.1.\n   Error_Unknown_Kind\n      A destination peer received a request\
    \ with an unknown Kind-ID.\n      See Section 7.4.1.2.\n   Error_In_Progress\n\
    \      An Attach to this peer is already in progress.  See\n      Section 6.5.1.2.\n\
    \   Error_Unknown_Extension\n      A destination node received a request with\
    \ an unknown extension.\n   Error_Invalid_Message\n      Something about this\
    \ message is invalid, but it does not fit the\n      other error codes.  When\
    \ this message is sent, implementations\n      SHOULD provide some meaningful\
    \ description in error_info to aid in\n      debugging.\n   Error_Exp_A\n    \
    \  For the purposes of experimentation.  It is not meant for vendor-\n      specific\
    \ use of any sort and MUST NOT be used for operational\n      deployments.\n \
    \  Error_Exp_B\n      For the purposes of experimentation.  It is not meant for\
    \ vendor-\n      specific use of any sort and MUST NOT be used for operational\n\
    \      deployments.\n"
- title: 6.3.4.  Security Block
  contents:
  - "6.3.4.  Security Block\n   The third part of a RELOAD message is the security\
    \ block.  The\n   security block is represented by a SecurityBlock structure:\n\
    \   struct {\n      CertificateType     type;   // From RFC 6091\n      opaque\
    \              certificate<0..2^16-1>;\n   } GenericCertificate;\n   struct {\n\
    \      GenericCertificate certificates<0..2^16-1>;\n      Signature          signature;\n\
    \   } SecurityBlock;\n   The contents of this structure are:\n   certificates\n\
    \      A bucket of certificates.\n   signature\n      A signature.\n   The certificates\
    \ bucket SHOULD contain all the certificates necessary\n   to verify every signature\
    \ in both the message and the internal\n   message objects, except for those certificates\
    \ in a root-cert element\n   of the current configuration file.  This is the only\
    \ location in the\n   message which contains certificates, thus allowing only\
    \ a single copy\n   of each certificate to be sent.  In systems that have an alternative\n\
    \   certificate distribution mechanism, some certificates MAY be omitted.\n  \
    \ However, unless an alternative mechanism for immediately generating\n   certificates,\
    \ such as shared secret security (Section 13.4) is used,\n   implementers MUST\
    \ include all referenced certificates.\n   NOTE TO IMPLEMENTERS: This requirement\
    \ implies that a peer storing\n   data is obligated to retain certificates for\
    \ the data that it holds.\n   Each certificate is represented by a GenericCertificate\
    \ structure,\n   which has the following contents:\n   type\n      The type of\
    \ the certificate, as defined in [RFC6091].  Only the\n      use of X.509 certificates\
    \ is defined in this document.\n   certificate\n      The encoded version of the\
    \ certificate.  For X.509 certificates,\n      it is the Distinguished Encoding\
    \ Rules (DER) form.\n   The signature is computed over the payload and parts of\
    \ the\n   forwarding header.  In case of a Store, the payload MUST contain an\n\
    \   additional signature computed as described in Section 7.1.  All\n   signatures\
    \ MUST be formatted using the Signature element.  This\n   element is also used\
    \ in other contexts where signatures are needed.\n   The input structure to the\
    \ signature computation MAY vary depending\n   on the data element being signed.\n\
    \     enum { invalidSignerIdentityType(0),\n            cert_hash(1), cert_hash_node_id(2),\n\
    \            none(3)\n            (255) } SignerIdentityType;\n     struct {\n\
    \       select (identity_type) {\n         case cert_hash;\n           HashAlgorithm\
    \      hash_alg;              // From TLS\n           opaque             certificate_hash<0..2^8-1>;\n\
    \         case cert_hash_node_id:\n           HashAlgorithm      hash_alg;   \
    \           // From TLS\n           opaque             certificate_node_id_hash<0..2^8-1>;\n\
    \         case none:\n           /* empty */\n         /* This structure may be\
    \ extended with new types if necessary*/\n       };\n     } SignerIdentityValue;\n\
    \     struct {\n       SignerIdentityType     identity_type;\n       uint16  \
    \               length;\n       SignerIdentityValue    identity[SignerIdentity.length];\n\
    \     } SignerIdentity;\n     struct {\n        SignatureAndHashAlgorithm    \
    \ algorithm;   // From TLS\n        SignerIdentity                identity;\n\
    \        opaque                        signature_value<0..2^16-1>;\n     } Signature;\n\
    \   The Signature construct contains the following values:\n   algorithm\n   \
    \   The signature algorithm in use.  The algorithm definitions are\n      found\
    \ in the IANA TLS SignatureAlgorithm and HashAlgorithm\n      registries.  All\
    \ implementations MUST support RSASSA-PKCS1-v1_5\n      [RFC3447] signatures with\
    \ SHA-256 hashes [RFC6234].\n   identity\n      The identity, as defined in the\
    \ two paragraphs following this\n      list, used to form the signature.\n   signature_value\n\
    \      The value of the signature.\n      Note that storage operations allow for\
    \ special values of algorithm\n      and identity.  See the Store Request definition\
    \ (Section 7.4.1.1)\n      and the Fetch Response definition (Section 7.4.2.2).\n\
    \   There are two permitted identity formats, one for a certificate with\n   only\
    \ one Node-ID and one for a certificate with multiple Node-IDs.\n   In the first\
    \ case, the cert_hash type MUST be used.  The hash_alg\n   field is used to indicate\
    \ the algorithm used to produce the hash.\n   The certificate_hash contains the\
    \ hash of the certificate object\n   (i.e., the DER-encoded certificate).\n  \
    \ In the second case, the cert_hash_node_id type MUST be used.  The\n   hash_alg\
    \ is as in cert_hash, but the cert_hash_node_id is computed\n   over the NodeId\
    \ used to sign concatenated with the certificate; i.e.,\n   H(NodeId || certificate).\
    \  The NodeId is represented without any\n   framing or length fields, as simple\
    \ raw bytes.  This is safe because\n   NodeIds are a fixed length for a given\
    \ overlay.\n   For signatures over messages, the input to the signature is computed\n\
    \   over:\n      overlay || transaction_id || MessageContents || SignerIdentity\n\
    \   where overlay and transaction_id come from the forwarding header and\n   ||\
    \ indicates concatenation.\n   The input to signatures over data values is different\
    \ and is\n   described in Section 7.1.\n   All RELOAD messages MUST be signed.\
    \  Intermediate nodes do not verify\n   signatures.  Upon receipt (and fragment\
    \ reassembly, if needed), the\n   destination node MUST verify the signature and\
    \ the authorizing\n   certificate.  If the signature fails, the implementation\
    \ SHOULD\n   simply drop the message and MUST NOT process it.  This check provides\n\
    \   a minimal level of assurance that the sending node is a valid part of\n  \
    \ the overlay, and it provides cryptographic authentication of the\n   sending\
    \ node.  In addition, responses MUST be checked as follows by\n   the requesting\
    \ node:\n   1.  The response to a message sent to a Node-ID MUST have been sent\n\
    \       by that Node-ID unless the response has been sent to the wildcard\n  \
    \     Node-ID.\n   2.  The response to a message sent to a Resource-ID MUST have\
    \ been\n       sent by a Node-ID which is at least as close to the target\n  \
    \     Resource-ID as any node in the requesting node's Neighbor Table.\n   The\
    \ second condition serves as a primitive check for responses from\n   wildly wrong\
    \ nodes but is not a complete check.  Note that in periods\n   of churn, it is\
    \ possible for the requesting node to obtain a closer\n   neighbor while the request\
    \ is outstanding.  This will cause the\n   response to be rejected and the request\
    \ to be retransmitted.\n   In addition, some methods (especially Store) have additional\n\
    \   authentication requirements, which are described in the sections\n   covering\
    \ those methods.\n"
- title: 6.4.  Overlay Topology
  contents:
  - "6.4.  Overlay Topology\n   As discussed in previous sections, RELOAD defines\
    \ a default overlay\n   topology (CHORD-RELOAD) but allows for other topologies\
    \ through the\n   use of Topology Plug-ins.  This section describes the requirements\n\
    \   for new Topology Plug-ins and the methods that RELOAD provides for\n   overlay\
    \ topology maintenance.\n"
- title: 6.4.1.  Topology Plug-in Requirements
  contents:
  - "6.4.1.  Topology Plug-in Requirements\n   When specifying a new overlay algorithm,\
    \ at least the following MUST\n   be described:\n   o  Joining procedures, including\
    \ the contents of the Join message.\n   o  Stabilization procedures, including\
    \ the contents of the Update\n      message, the frequency of topology probes\
    \ and keepalives, and the\n      mechanism used to detect when peers have disconnected.\n\
    \   o  Exit procedures, including the contents of the Leave message.\n   o  The\
    \ length of the Resource-IDs and for DHTs the hash algorithm to\n      compute\
    \ the hash of an identifier.\n   o  The procedures that peers use to route messages.\n\
    \   o  The replication strategy used to ensure data redundancy.\n   All overlay\
    \ algorithms MUST specify maintenance procedures that send\n   Updates to clients\
    \ and peers that have established connections to the\n   peer responsible for\
    \ a particular ID when the responsibility for that\n   ID changes.  Because tracking\
    \ this information is difficult, overlay\n   algorithms MAY simply specify that\
    \ an Update is sent to all members\n   of the Connection Table whenever the range\
    \ of IDs for which the peer\n   is responsible changes.\n"
- title: 6.4.2.  Methods and Types for Use by Topology Plug-ins
  contents:
  - "6.4.2.  Methods and Types for Use by Topology Plug-ins\n   This section describes\
    \ the methods that Topology Plug-ins use to\n   join, leave, and maintain the\
    \ overlay.\n"
- title: 6.4.2.1.  Join
  contents:
  - "6.4.2.1.  Join\n   A new peer (which already has credentials) uses the JoinReq\
    \ message\n   to join the overlay.  The JoinReq is sent to the responsible peer\n\
    \   depending on the routing mechanism described in the Topology Plug-in.\n  \
    \ This message notifies the responsible peer that the new peer is\n   taking over\
    \ some of the overlay and that it needs to synchronize its\n   state.\n      \
    \   struct {\n            NodeId                joining_peer_id;\n           \
    \ opaque                overlay_specific_data<0..2^16-1>;\n         } JoinReq;\n\
    \   The minimal JoinReq contains only the Node-ID which the sending peer\n   wishes\
    \ to assume.  Overlay algorithms MAY specify other data to\n   appear in this\
    \ request.  Receivers of the JoinReq MUST verify that\n   the joining_peer_id\
    \ field matches the Node-ID used to sign the\n   message and, if not, the message\
    \ MUST be rejected with an\n   Error_Forbidden error.\n   Because joins may be\
    \ executed only between nodes which are directly\n   adjacent, receiving peers\
    \ MUST verify that any JoinReq they receive\n   arrives from a transport channel\
    \ that is bound to the Node-ID to be\n   assumed by the Joining Node.  Implementations\
    \ MUST use DTLS\n   anti-replay mechanisms, thus preventing replay attacks.\n\
    \   If the request succeeds, the responding peer responds with a JoinAns\n   message,\
    \ as defined below:\n         struct {\n            opaque                overlay_specific_data<0..2^16-1>;\n\
    \         } JoinAns;\n   If the request succeeds, the responding peer MUST follow\
    \ up by\n   executing the right sequence of Stores and Updates to transfer the\n\
    \   appropriate section of the overlay space to the Joining Node.  In\n   addition,\
    \ overlay algorithms MAY define data to appear in the\n   response payload that\
    \ provides additional information.\n   Joining Nodes MUST verify that the signature\
    \ on the JoinAns message\n   matches the expected target (i.e., the adjacency\
    \ over which they are\n   joining).  If not, they MUST discard the message.\n\
    \   In general, nodes which cannot form connections SHOULD report an\n   error\
    \ to the user.  However, implementations MUST provide some\n   mechanism whereby\
    \ nodes can determine that they are potentially the\n   first node and can take\
    \ responsibility for the overlay.  (The idea is\n   to avoid having ordinary nodes\
    \ try to become responsible for the\n   entire overlay during a partition.)  This\
    \ specification does not\n   mandate any particular mechanism, but a configuration\
    \ flag or setting\n   seems appropriate.\n"
- title: 6.4.2.2.  Leave
  contents:
  - "6.4.2.2.  Leave\n   The LeaveReq message is used to indicate that a node is exiting\
    \ the\n   overlay.  A node SHOULD send this message to each peer with which it\n\
    \   is directly connected prior to exiting the overlay.\n         struct {\n \
    \           NodeId                leaving_peer_id;\n            opaque       \
    \         overlay_specific_data<0..2^16-1>;\n         } LeaveReq;\n   LeaveReq\
    \ contains only the Node-ID of the leaving peer.  Overlay\n   algorithms MAY specify\
    \ other data to appear in this request.\n   Receivers of the LeaveReq MUST verify\
    \ that the leaving_peer_id field\n   matches the Node-ID used to sign the message\
    \ and, if not, the message\n   MUST be rejected with an Error_Forbidden error.\n\
    \   Because leaves may be executed only between nodes which are directly\n   adjacent,\
    \ receiving peers MUST verify that any LeaveReq they receive\n   arrives from\
    \ a transport channel that is bound to the Node-ID to be\n   assumed by the leaving\
    \ peer.  This also prevents replay attacks,\n   provided that DTLS anti-replay\
    \ is used.\n   Upon receiving a Leave request, a peer MUST update its own Routing\n\
    \   Table and send the appropriate Store/Update sequences to re-stabilize\n  \
    \ the overlay.\n   LeaveAns is an empty message.\n"
- title: 6.4.2.3.  Update
  contents:
  - "6.4.2.3.  Update\n   Update is the primary overlay-specific maintenance message.\
    \  It is\n   used by the sender to notify the recipient of the sender's view of\n\
    \   the current state of the overlay (that is, its routing state), and it\n  \
    \ is up to the recipient to take whatever actions are appropriate to\n   deal\
    \ with the state change.  In general, peers send Update messages\n   to all their\
    \ adjacencies whenever they detect a topology shift.\n   When a peer receives\
    \ an Attach request with the send_update flag set\n   to True (Section 6.4.2.4.1),\
    \ it MUST send an Update message back to\n   the sender of the Attach request\
    \ after completion of the\n   corresponding ICE check and TLS connection.  Note\
    \ that the sender of\n   such an Attach request may not have joined the overlay\
    \ yet.\n   When a peer detects through an Update that it is no longer\n   responsible\
    \ for any data value it is storing, it MUST attempt to\n   Store a copy to the\
    \ correct node unless it knows the newly\n   responsible node already has a copy\
    \ of the data.  This prevents data\n   loss during large-scale topology shifts,\
    \ such as the merging of\n   partitioned overlays.\n   The contents of the UpdateReq\
    \ message are completely overlay\n   specific.  The UpdateAns response is expected\
    \ to be either success or\n   an error.\n"
- title: 6.4.2.4.  RouteQuery
  contents:
  - "6.4.2.4.  RouteQuery\n   The RouteQuery request allows the sender to ask a peer\
    \ where they\n   would route a message directed to a given destination.  In other\n\
    \   words, a RouteQuery for a destination X requests the Node-ID for the\n   node\
    \ that the receiving peer would next route to in order to get to\n   X.  A RouteQuery\
    \ can also request that the receiving peer initiate an\n   Update request to transfer\
    \ the receiving peer's Routing Table.\n   One important use of the RouteQuery\
    \ request is to support iterative\n   routing.  The sender selects one of the\
    \ peers in its Routing\n   Table and sends it a RouteQuery message with the destination\
    \ field\n   set to the Node-ID or Resource-ID to which it wishes to route.  The\n\
    \   receiving peer responds with information about the peers to which the\n  \
    \ request would be routed.  The sending peer MAY then use the Attach\n   method\
    \ to attach to that peer(s) and repeat the RouteQuery.\n   Eventually, the sender\
    \ gets a response from a peer that is closest to\n   the identifier in the destination\
    \ field as determined by the Topology\n   Plug-in.  At that point, the sender\
    \ can send messages directly to\n   that peer.\n"
- title: 6.4.2.4.1.  Request Definition
  contents:
  - "6.4.2.4.1.  Request Definition\n   A RouteQueryReq message indicates the peer\
    \ or resource that the\n   requesting node is interested in.  It also contains\
    \ a \"send_update\"\n   option that allows the requesting node to request a full\
    \ copy of the\n   other peer's Routing Table.\n         struct {\n           Boolean\
    \                send_update;\n           Destination            destination;\n\
    \           opaque                 overlay_specific_data<0..2^16-1>;\n       \
    \  } RouteQueryReq;\n   The contents of the RouteQueryReq message are as follows:\n\
    \   send_update\n      A single byte.  This may be set to True to indicate that\
    \ the\n      requester wishes the responder to initiate an Update request\n  \
    \    immediately.  Otherwise, this value MUST be set to False.\n   destination\n\
    \      The destination which the requester is interested in.  This may be\n  \
    \    any valid destination object, including a Node-ID, opaque ID, or\n      Resource-ID.\n\
    \      Note: If implementations are using opaque IDs for privacy\n      purposes,\
    \ answering RouteQueryReqs for opaque IDs will allow the\n      requester to translate\
    \ an opaque ID.  Implementations MAY wish to\n      consider limiting the use\
    \ of RouteQuery for opaque IDs in such\n      cases.\n   overlay_specific_data\n\
    \      Other data as appropriate for the overlay.\n"
- title: 6.4.2.4.2.  Response Definition
  contents:
  - "6.4.2.4.2.  Response Definition\n   A response to a successful RouteQueryReq\
    \ request is a RouteQueryAns\n   message.  This message is completely overlay\
    \ specific.\n"
- title: 6.4.2.5.  Probe
  contents:
  - "6.4.2.5.  Probe\n   Probe provides primitive \"exploration\" services: it allows\
    \ a node to\n   determine which resources another node is responsible for.  A\
    \ probe\n   can be addressed to a specific Node-ID or to the peer controlling\
    \ a\n   given location (by using a Resource-ID).  In either case, the target\n\
    \   node responds with a simple response containing some status\n   information.\n"
- title: 6.4.2.5.1.  Request Definition
  contents:
  - "6.4.2.5.1.  Request Definition\n   The ProbeReq message contains a list (potentially\
    \ empty) of the\n   pieces of status information that the requester would like\
    \ the\n   responder to provide.\n        enum { invalidProbeInformationType(0),\
    \ responsible_set(1),\n               num_resources(2), uptime(3), (255) }\n \
    \            ProbeInformationType;\n        struct {\n          ProbeInformationType\
    \     requested_info<0..2^8-1>;\n        } ProbeReq;\n   The currently defined\
    \ values for ProbeInformationType are:\n   responsible_set\n      Indicates that\
    \ the peer should Respond with the fraction of the\n      overlay for which the\
    \ responding peer is responsible.\n   num_resources\n      Indicates that the\
    \ peer should Respond with the number of\n      resources currently being stored\
    \ by the peer.  Note that multiple\n      values under the same Resource-ID are\
    \ counted only once.\n   uptime\n      Indicates that the peer should Respond\
    \ with how long the peer has\n      been up, in seconds.\n"
- title: 6.4.2.5.2.  Response Definition
  contents:
  - "6.4.2.5.2.  Response Definition\n   A successful ProbeAns response contains the\
    \ information elements\n   requested by the peer.\n         struct {\n       \
    \    select (type) {\n             case responsible_set:\n               uint32\
    \             responsible_ppb;\n             case num_resources:\n           \
    \    uint32             num_resources;\n             case uptime:\n          \
    \     uint32             uptime;\n             /* This type may be extended */\n\
    \           };\n         } ProbeInformationData;\n         struct {\n        \
    \   ProbeInformationType    type;\n           uint8                   length;\n\
    \           ProbeInformationData    value;\n         } ProbeInformation;\n   \
    \      struct {\n           ProbeInformation        probe_info<0..2^16-1>;\n \
    \        } ProbeAns;\n   A ProbeAns message contains a sequence of ProbeInformation\n\
    \   structures.  Each has a \"length\" indicating the length of the\n   following\
    \ value field.  This structure allows for unknown option\n   types.\n   Each of\
    \ the current possible Probe information types is a 32-bit\n   unsigned integer.\
    \  For type \"responsible_ppb\", it is the fraction of\n   the overlay for which\
    \ the peer is responsible, in parts per billion.\n   For type \"num_resources\"\
    , it is the number of resources the peer is\n   storing.  For the type \"uptime\"\
    , it is the number of seconds the peer\n   has been up.\n   The responding peer\
    \ SHOULD include any values that the requesting\n   node requested and that it\
    \ recognizes.  They SHOULD be returned in\n   the requested order.  Any other\
    \ values MUST NOT be returned.\n"
- title: 6.5.  Forwarding and Link Management Layer
  contents:
  - "6.5.  Forwarding and Link Management Layer\n   Each node maintains connections\
    \ to a set of other nodes defined by\n   the Topology Plug-in.  This section defines\
    \ the methods RELOAD uses\n   to form and maintain connections between nodes in\
    \ the overlay.  Three\n   methods are defined:\n   Attach\n      Used to form\
    \ RELOAD connections between nodes using ICE for NAT\n      traversal.  When node\
    \ A wants to connect to node B, it sends an\n      Attach message to node B through\
    \ the overlay.  The Attach contains\n      A's ICE parameters.  B responds with\
    \ its ICE parameters, and the\n      two nodes perform ICE to form connection.\
    \  Attach also allows two\n      nodes to connect via No-ICE instead of full ICE.\n\
    \   AppAttach\n      Used to form application-layer connections between nodes.\n\
    \   Ping\n      A simple request/response which is used to verify connectivity\
    \ of\n      the target peer.\n"
- title: 6.5.1.  Attach
  contents:
  - "6.5.1.  Attach\n   A node sends an Attach request when it wishes to establish\
    \ a direct\n   Overlay Link connection to another node for the purpose of sending\n\
    \   RELOAD messages.  A client that can establish a connection directly\n   need\
    \ not send an Attach, as described in the second bullet of\n   Section 4.2.1.\n\
    \   As described in Section 6.1, an Attach may be routed to either a\n   Node-ID\
    \ or a Resource-ID.  An Attach routed to a specific Node-ID\n   will fail if that\
    \ node is not reached.  An Attach routed to a\n   Resource-ID will establish a\
    \ connection with the peer currently\n   responsible for that Resource-ID, which\
    \ may be useful in establishing\n   a direct connection to the responsible peer\
    \ for use with frequent or\n   large resource updates.\n   An Attach, in and of\
    \ itself, does not result in updating the Routing\n   Table of either node.  That\
    \ function is performed by Updates.  If\n   node A has Attached to node B, but\
    \ has not received any Updates from\n   B, it MAY route messages which are directly\
    \ addressed to B through\n   that channel, but it MUST NOT route messages through\
    \ B to other peers\n   via that channel.  The process of Attaching is separate\
    \ from the\n   process of becoming a peer (using Join and Update), to prevent\
    \ half-\n   open states where a node has started to form connections but is not\n\
    \   really ready to act as a peer.  Thus, clients (unlike peers) can\n   simply\
    \ Attach without sending Join or Update.\n"
- title: 6.5.1.1.  Request Definition
  contents:
  - "6.5.1.1.  Request Definition\n   An Attach request message contains the requesting\
    \ node ICE connection\n   parameters formatted into a binary structure.\n    \
    \    enum { invalidOverlayLinkType(0), DTLS-UDP-SR(1),\n               DTLS-UDP-SR-NO-ICE(3),\
    \ TLS-TCP-FH-NO-ICE(4),\n               (255) } OverlayLinkType;\n        enum\
    \ { invalidCandType(0),\n               host(1), srflx(2), /* RESERVED(3), */\
    \ relay(4),\n               (255) } CandType;\n        struct {\n          opaque\
    \                name<0..2^16-1>;\n          opaque                value<0..2^16-1>;\n\
    \        } IceExtension;\n        struct {\n          IpAddressPort         addr_port;\n\
    \          OverlayLinkType       overlay_link;\n          opaque             \
    \   foundation<0..255>;\n          uint32                priority;\n         \
    \ CandType              type;\n          select (type) {\n            case host:\n\
    \              ;          /* Empty */\n            case srflx:\n            case\
    \ relay:\n              IpAddressPort     rel_addr_port;\n          };\n     \
    \     IceExtension          extensions<0..2^16-1>;\n        } IceCandidate;\n\
    \        struct {\n          opaque                ufrag<0..2^8-1>;\n        \
    \  opaque                password<0..2^8-1>;\n          opaque               \
    \ role<0..2^8-1>;\n          IceCandidate          candidates<0..2^16-1>;\n  \
    \        Boolean               send_update;\n        } AttachReqAns;\n   The values\
    \ contained in AttachReqAns are:\n   ufrag\n      The username fragment (from\
    \ ICE).\n   password\n      The ICE password.\n   role\n      An active/passive/actpass\
    \ attribute from RFC 4145 [RFC4145].  This\n      value MUST be \"passive\" for\
    \ the offerer (the peer sending the\n      Attach request) and \"active\" for\
    \ the answerer (the peer sending\n      the Attach response).\n   candidates\n\
    \      One or more ICE candidate values, as described below.\n   send_update\n\
    \      Has the same meaning as the send_update field in RouteQueryReq.\n   Each\
    \ ICE candidate is represented as an IceCandidate structure, which\n   is a direct\
    \ translation of the information from the ICE string\n   structures, with the\
    \ exception of the component ID.  Since there is\n   only one component, it is\
    \ always 1, and thus left out of the\n   structure.  The remaining values are\
    \ specified as follows:\n   addr_port\n      Corresponds to the ICE connection-address\
    \ and port productions.\n   overlay_link\n      Corresponds to the ICE transport\
    \ production.  Overlay Link\n      protocols used with No-ICE MUST specify \"\
    No-ICE\" in their\n      description.  Future overlay link values can be added\
    \ by defining\n      new OverlayLinkType values in the IANA registry as described\
    \ in\n      Section 14.10.  Future extensions to the encapsulation or framing\n\
    \      that provide for backward compatibility with the previously\n      specified\
    \ encapsulation or framing values MUST use the same\n      OverlayLinkType value\
    \ that was previously defined.\n      OverlayLinkType protocols are defined in\
    \ Section 6.6\n      A single AttachReqAns MUST NOT include both candidates whose\n\
    \      OverlayLinkType protocols use ICE (the default) and candidates\n      that\
    \ specify \"No-ICE\".\n   foundation\n      Corresponds to the ICE foundation\
    \ production.\n   priority\n      Corresponds to the ICE priority production.\n\
    \   type\n      Corresponds to the ICE cand-type production.\n   rel_addr_port\n\
    \      Corresponds to the ICE rel-addr and rel-port productions.  It is\n    \
    \  present only for types \"relay\", \"prfix\", and \"srflx\".\n   extensions\n\
    \      ICE extensions.  The name and value fields correspond to binary\n     \
    \ translations of the equivalent fields in the ICE extensions.\n   These values\
    \ should be generated using the procedures described in\n   Section 6.5.1.3.\n"
- title: 6.5.1.2.  Response Definition
  contents:
  - "6.5.1.2.  Response Definition\n   If a peer receives an Attach request, it MUST\
    \ determine how to\n   process the request as follows:\n   o  If the peer has\
    \ not initiated an Attach request to the originating\n      peer of this Attach\
    \ request, it MUST process this request and\n      SHOULD generate its own response\
    \ with an AttachReqAns.  It should\n      then begin ICE checks.\n   o  If the\
    \ peer has already sent an Attach request to and received the\n      response\
    \ from the originating peer of this Attach request and, as\n      a result, an\
    \ ICE check and TLS connection are in progress, then it\n      SHOULD generate\
    \ an Error_In_Progress error instead of an\n      AttachReqAns.\n   o  If the\
    \ peer has already sent an Attach request to but not yet\n      received the response\
    \ from the originating peer of this Attach\n      request, it SHOULD apply the\
    \ following tie-breaker heuristic to\n      determine how to handle this Attach\
    \ request and the incomplete\n      Attach request it has sent out:\n      * \
    \ If the peer's own Node-ID is smaller when compared as big-\n         endian\
    \ unsigned integers, it MUST cancel retransmission of its\n         own incomplete\
    \ Attach request.  It MUST then process this\n         Attach request, generate\
    \ an AttachReqAns response, and proceed\n         with the corresponding ICE check.\n\
    \      *  If the peer's own Node-ID is larger when compared as big-endian\n  \
    \       unsigned integers, it MUST generate an Error_In_Progress error\n     \
    \    to this Attach request, and then proceed to wait for and\n         complete\
    \ the Attach and the corresponding ICE check it has\n         originated.\n  \
    \ o  If the peer is overloaded or detects some other kind of error, it\n     \
    \ MAY generate an error instead of an AttachReqAns.\n   When a peer receives an\
    \ Attach response, it SHOULD parse the response\n   and begin its own ICE checks.\n"
- title: 6.5.1.3.  Using ICE with RELOAD
  contents:
  - "6.5.1.3.  Using ICE with RELOAD\n   This section describes the profile of ICE\
    \ that is used with RELOAD.\n   RELOAD implementations MUST implement full ICE.\n\
    \   In ICE, as defined by [RFC5245], the Session Description Protocol\n   (SDP)\
    \ is used to carry the ICE parameters.  In RELOAD, this function\n   is performed\
    \ by a binary encoding in the Attach method.  This\n   encoding is more restricted\
    \ than the SDP encoding because the RELOAD\n   environment is simpler:\n   o \
    \ Only a single media stream is supported.\n   o  In this case, the \"stream\"\
    \ refers not to RTP or other types of\n      media, but rather to a connection\
    \ for RELOAD itself or other\n      application-layer protocols, such as SIP.\n\
    \   o  RELOAD allows only for a single offer/answer exchange.  Unlike the\n  \
    \    usage of ICE within SIP, there is never a need to send a\n      subsequent\
    \ offer to update the default candidates to match the\n      ones selected by\
    \ ICE.\n   An agent follows the ICE specification as described in [RFC5245] with\n\
    \   the changes and additional procedures described in the subsections\n   below.\n"
- title: 6.5.1.4.  Collecting STUN Servers
  contents:
  - "6.5.1.4.  Collecting STUN Servers\n   ICE relies on the node having one or more\
    \ Session Traversal Utilities\n   for NAT (STUN) servers to use.  In conventional\
    \ ICE, it is assumed\n   that nodes are configured with one or more STUN servers\
    \ through some\n   out-of-band mechanism.  This is still possible in RELOAD, but\
    \ RELOAD\n   also learns STUN servers as it connects to other peers.\n   A peer\
    \ on a well-provisioned wide-area overlay will be configured\n   with one or more\
    \ bootstrap nodes.  These nodes make an initial list\n   of STUN servers.  However,\
    \ as the peer forms connections with\n   additional peers, it builds more peers\
    \ that it can use like STUN\n   servers.\n   Because complicated NAT topologies\
    \ are possible, a peer may need more\n   than one STUN server.  Specifically,\
    \ a peer that is behind a single\n   NAT will typically observe only two IP addresses\
    \ in its STUN checks:\n   its local address and its server reflexive address from\
    \ a STUN server\n   outside its NAT.  However, if more NATs are involved, a peer\
    \ may\n   learn additional server reflexive addresses (which vary based on\n \
    \  where in the topology the STUN server is).  To maximize the chance of\n   achieving\
    \ a direct connection, a peer SHOULD group other peers by the\n   peer-reflexive\
    \ addresses it discovers through them.  It SHOULD then\n   select one peer from\
    \ each group to use as a STUN server for future\n   connections.\n   Only peers\
    \ to which the peer currently has connections may be used.\n   If the connection\
    \ to that host is lost, it MUST be removed from the\n   list of STUN servers,\
    \ and a new server from the same group MUST be\n   selected unless there are no\
    \ others servers in the group, in which\n   case some other peer MAY be used.\n"
- title: 6.5.1.5.  Gathering Candidates
  contents:
  - "6.5.1.5.  Gathering Candidates\n   When a node wishes to establish a connection\
    \ for the purposes of\n   RELOAD signaling or application signaling, it follows\
    \ the process of\n   gathering candidates as described in Section 4 of ICE [RFC5245].\n\
    \   RELOAD utilizes a single component.  Consequently, gathering for\n   these\
    \ \"streams\" requires a single component.  In the case where a\n   node has not\
    \ yet found a TURN server, the agent would not include a\n   relayed candidate.\n\
    \   The ICE specification assumes that an ICE agent is configured with,\n   or\
    \ somehow knows of, TURN and STUN servers.  RELOAD provides a way\n   for an agent\
    \ to learn these by querying the overlay, as described in\n   Sections 6.5.1.4\
    \ and 9.\n   The default candidate selection described in Section 4.1.4 of ICE\
    \ is\n   ignored; defaults are not signaled or utilized by RELOAD.\n   An alternative\
    \ to using the full ICE supported by the Attach request\n   is to use the No-ICE\
    \ mechanism by providing candidates with \"No-ICE\"\n   Overlay Link protocols.\
    \  Configuration for the overlay indicates\n   whether or not these Overlay Link\
    \ protocols can be used.  An overlay\n   MUST be either all ICE or all No-ICE.\n\
    \   No-ICE will not work in all the scenarios where ICE would work, but\n   in\
    \ some cases, particularly those with no NATs or firewalls, it will\n   work.\n"
- title: 6.5.1.6.  Prioritizing Candidates
  contents:
  - "6.5.1.6.  Prioritizing Candidates\n   Standardization of additional protocols\
    \ for use with ICE is expected,\n   including TCP [RFC6544] and protocols such\
    \ as the Stream Control\n   Transmission Protocol (SCTP) [RFC4960] and Datagram\
    \ Congestion\n   Control Protocol (DCCP) [RFC4340].  UDP encapsulations for SCTP\
    \ and\n   DCCP would expand the Overlay Link protocols available for RELOAD.\n\
    \   When additional protocols are available, the following prioritization\n  \
    \ is RECOMMENDED:\n   o  Highest priority is assigned to protocols that offer\
    \ well-\n      understood congestion and flow control without head-of-line\n \
    \     blocking, for example, SCTP without message ordering, DCCP, and\n      those\
    \ protocols encapsulated using UDP.\n   o  Second highest priority is assigned\
    \ to protocols that offer well-\n      understood congestion and flow control,\
    \ but that have head-of-line\n      blocking, such as TCP.\n   o  Lowest priority\
    \ is assigned to protocols encapsulated over UDP\n      that do not implement\
    \ well-established congestion control\n      algorithms.  The DTLS/UDP with Simple\
    \ Reliability (SR) overlay\n      link protocol is an example of such a protocol.\n\
    \   Head-of-line blocking is undesirable in an Overlay Link protocol,\n   because\
    \ the messages carried on a RELOAD link are independent, rather\n   than stream-oriented.\
    \  Therefore, if message N on a link is lost,\n   delaying message N+1 on that\
    \ same link until N is successfully\n   retransmitted does nothing other than\
    \ increase the latency for the\n   transaction of message N+1, as they are unrelated\
    \ to each other.\n   Therefore, while the high quality, performance, and availability\
    \ of\n   modern TCP implementations makes them very attractive, their\n   performance\
    \ as Overlay Link protocols is not optimal.\n   Note that none of the protocols\
    \ defined in this document meets these\n   conditions, but it is expected that\
    \ new Overlay Link protocols\n   defined in the future will fill this gap.\n"
- title: 6.5.1.7.  Encoding the Attach Message
  contents:
  - "6.5.1.7.  Encoding the Attach Message\n   Section 4.3 of ICE describes procedures\
    \ for encoding the SDP for\n   conveying RELOAD candidates.  Instead of actually\
    \ encoding an SDP\n   message, the candidate information (IP address and port\
    \ and transport\n   protocol, priority, foundation, type, and related address)\
    \ is carried\n   within the attributes of the Attach request or its response.\n\
    \   Similarly, the username fragment and password are carried in the\n   Attach\
    \ message or its response.  Section 6.5.1 describes the detailed\n   attribute\
    \ encoding for Attach.  The Attach request and its response\n   do not contain\
    \ any default candidates or the ice-lite attribute, as\n   these features of ICE\
    \ are not used by RELOAD.\n   Since the Attach request contains the candidate\
    \ information and short\n   term credentials, it is considered as an offer for\
    \ a single media\n   stream that happens to be encoded in a format different than\
    \ SDP, but\n   is otherwise considered a valid offer for the purposes of following\n\
    \   the ICE specification.  Similarly, the Attach response is considered\n   a\
    \ valid answer for the purposes of following the ICE specification.\n"
- title: 6.5.1.8.  Verifying ICE Support
  contents:
  - "6.5.1.8.  Verifying ICE Support\n   An agent MUST skip the verification procedures\
    \ in Sections 5.1 and\n   6.1 of ICE.  Since RELOAD requires full ICE from all\
    \ agents, this\n   check is not required.\n"
- title: 6.5.1.9.  Role Determination
  contents:
  - "6.5.1.9.  Role Determination\n   The roles of controlling and controlled, as\
    \ described in Section 5.2\n   of ICE, are still utilized with RELOAD.  However,\
    \ the offerer (the\n   entity sending the Attach request) will always be controlling,\
    \ and\n   the answerer (the entity sending the Attach response) will always be\n\
    \   controlled.  The connectivity checks MUST still contain the ICE-\n   CONTROLLED\
    \ and ICE-CONTROLLING attributes, however, even though the\n   role reversal capability\
    \ for which they are defined will never be\n   needed with RELOAD.  This is to\
    \ allow for a common codebase between\n   ICE for RELOAD and ICE for SDP.\n"
- title: 6.5.1.10.  Full ICE
  contents:
  - "6.5.1.10.  Full ICE\n   When the overlay uses ICE, connectivity checks and nominations\
    \ are\n   used as in regular ICE.\n"
- title: 6.5.1.10.1.  Connectivity Checks
  contents:
  - "6.5.1.10.1.  Connectivity Checks\n   The processes of forming check lists in\
    \ Section 5.7 of ICE,\n   scheduling checks in Section 5.8, and checking connectivity\
    \ checks in\n   Section 7 are used with RELOAD without change.\n"
- title: 6.5.1.10.2.  Concluding ICE
  contents:
  - "6.5.1.10.2.  Concluding ICE\n   The procedures in Section 8 of ICE are followed\
    \ to conclude ICE, with\n   the following exceptions:\n   o  The controlling agent\
    \ MUST NOT attempt to send an updated offer\n      once the state of its single\
    \ media stream reaches Completed.\n   o  Once the state of ICE reaches Completed,\
    \ the agent can immediately\n      free all unused candidates.  This is because\
    \ RELOAD does not have\n      the concept of forking, and thus the three-second\
    \ delay in\n      Section 8.3 of ICE does not apply.\n"
- title: 6.5.1.10.3.  Media Keepalives
  contents:
  - "6.5.1.10.3.  Media Keepalives\n   STUN MUST be utilized for the keepalives described\
    \ in Section 10 of\n   ICE.\n"
- title: 6.5.1.11.  No-ICE
  contents:
  - "6.5.1.11.  No-ICE\n   No-ICE is selected when either side has provided \"no ICE\"\
    \ Overlay\n   Link candidates.  STUN is not used for connectivity checks when\
    \ doing\n   No-ICE; instead, the DTLS or TLS handshake (or similar security layer\n\
    \   of future overlay link protocols) forms the connectivity check.  The\n   certificate\
    \ exchanged during the TLS or DTLS handshake MUST match the\n   node which sent\
    \ the AttachReqAns, and if it does not, the connection\n   MUST be closed.\n"
- title: 6.5.1.12.  Subsequent Offers and Answers
  contents:
  - "6.5.1.12.  Subsequent Offers and Answers\n   An agent MUST NOT send a subsequent\
    \ offer or answer.  Thus, the\n   procedures in Section 9 of ICE MUST be ignored.\n"
- title: 6.5.1.13.  Sending Media
  contents:
  - "6.5.1.13.  Sending Media\n   The procedures of Section 11 of ICE apply to RELOAD\
    \ as well.\n   However, in this case, the \"media\" takes the form of application-\n\
    \   layer protocols (e.g., RELOAD) over TLS or DTLS.  Consequently, once\n   ICE\
    \ processing completes, the agent will begin TLS or DTLS procedures\n   to establish\
    \ a secure connection.  The node that sent the Attach\n   request MUST be the\
    \ TLS server.  The other node MUST be the TLS\n   client.  The server MUST request\
    \ TLS client authentication.  The\n   nodes MUST verify that the certificate presented\
    \ in the handshake\n   matches the identity of the other peer as found in the\
    \ Attach\n   message.  Once the TLS or DTLS signaling is complete, the application\n\
    \   protocol is free to use the connection.\n   The concept of a previous selected\
    \ pair for a component does not\n   apply to RELOAD, since ICE restarts are not\
    \ possible with RELOAD.\n"
- title: 6.5.1.14.  Receiving Media
  contents:
  - "6.5.1.14.  Receiving Media\n   An agent MUST be prepared to receive packets for\
    \ the application\n   protocol (TLS or DTLS carrying RELOAD) at any time.  The\
    \ jitter and\n   RTP considerations in Section 11 of ICE do not apply to RELOAD.\n"
- title: 6.5.2.  AppAttach
  contents:
  - "6.5.2.  AppAttach\n   A node sends an AppAttach request when it wishes to establish\
    \ a\n   direct connection to another node for the purposes of sending\n   application-layer\
    \ messages.  AppAttach is nearly identical to Attach,\n   except for the purpose\
    \ of the connection: it is used to transport\n   non-RELOAD \"media\".  A separate\
    \ request is used to avoid implementer\n   confusion between the two methods (this\
    \ was found to be a real\n   problem with initial implementations).  The AppAttach\
    \ request and its\n   response contain an application attribute, which indicates\
    \ what\n   protocol is to be run over the connection.\n"
- title: 6.5.2.1.  Request Definition
  contents:
  - "6.5.2.1.  Request Definition\n   An AppAttachReq message contains the requesting\
    \ node's ICE connection\n   parameters formatted into a binary structure.\n  \
    \      struct {\n          opaque                  ufrag<0..2^8-1>;\n        \
    \  opaque                  password<0..2^8-1>;\n          uint16             \
    \     application;\n          opaque                  role<0..2^8-1>;\n      \
    \    IceCandidate            candidates<0..2^16-1>;\n        } AppAttachReq;\n\
    \   The values contained in AppAttachReq and AppAttachAns are:\n   ufrag\n   \
    \   The username fragment (from ICE).\n   password\n      The ICE password.\n\
    \   application\n      A 16-bit Application-ID, as defined in the Section 14.5.\
    \  This\n      number represents the IANA-registered application that is going\
    \ to\n      send data on this connection.\n   role\n      An active/passive/actpass\
    \ attribute from RFC 4145 [RFC4145].\n   candidates\n      One or more ICE candidate\
    \ values.\n   The application using the connection that is set up with this request\n\
    \   is responsible for providing traffic of sufficient frequency to keep\n   the\
    \ NAT and Firewall binding alive.  Applications will often send\n   traffic every\
    \ 25 seconds to ensure this.\n"
- title: 6.5.2.2.  Response Definition
  contents:
  - "6.5.2.2.  Response Definition\n   If a peer receives an AppAttach request, it\
    \ SHOULD process the\n   request and generate its own response with a AppAttachAns.\
    \  It should\n   then begin ICE checks.  When a peer receives an AppAttach response,\n\
    \   it SHOULD parse the response and begin its own ICE checks.  If the\n   Application\
    \ ID is not supported, the peer MUST reply with an\n   Error_Not_Found error.\n\
    \        struct {\n          opaque                  ufrag<0..2^8-1>;\n      \
    \    opaque                  password<0..2^8-1>;\n          uint16           \
    \       application;\n          opaque                  role<0..2^8-1>;\n    \
    \      IceCandidate            candidates<0..2^16-1>;\n        } AppAttachAns;\n\
    \   The meaning of the fields is the same as in the AppAttachReq.\n"
- title: 6.5.3.  Ping
  contents:
  - "6.5.3.  Ping\n   Ping is used to test connectivity along a path.  A ping can\
    \ be\n   addressed to a specific Node-ID, to the peer controlling a given\n  \
    \ location (by using a Resource-ID), or to the wildcard Node-ID.\n"
- title: 6.5.3.1.  Request Definition
  contents:
  - "6.5.3.1.  Request Definition\n   The PingReq structure is used to make a Ping\
    \ request.\n        struct {\n          opaque<0..2^16-1> padding;\n        }\
    \ PingReq;\n   The Ping request is empty of meaningful contents.  However, it\
    \ may\n   contain up to 65535 bytes of padding to facilitate the discovery of\n\
    \   overlay maximum packet sizes.\n"
- title: 6.5.3.2.  Response Definition
  contents:
  - "6.5.3.2.  Response Definition\n   A successful PingAns response contains the\
    \ information elements\n   requested by the peer.\n         struct {\n       \
    \    uint64                 response_id;\n           uint64                 time;\n\
    \         } PingAns;\n   A PingAns message contains the following elements:\n\
    \   response_id\n      A randomly generated 64-bit response ID.  This is used\
    \ to\n      distinguish Ping responses.\n   time\n      The time when the Ping\
    \ response was created, represented in the\n      same way as storage_time, defined\
    \ in Section 7.\n"
- title: 6.5.4.  ConfigUpdate
  contents:
  - "6.5.4.  ConfigUpdate\n   The ConfigUpdate method is used to push updated configuration\
    \ data\n   across the overlay.  Whenever a node detects that another node has\n\
    \   old configuration data, it MUST generate a ConfigUpdate request.  The\n  \
    \ ConfigUpdate request allows updating of two kinds of data: the\n   configuration\
    \ data (Section 6.3.2.1) and the Kind information\n   (Section 7.4.1.1).\n"
- title: 6.5.4.1.  Request Definition
  contents:
  - "6.5.4.1.  Request Definition\n   The ConfigUpdateReq structure is used to provide\
    \ updated\n   configuration information.\n        enum { invalidConfigUpdateType(0),\
    \ config(1), kind(2), (255) }\n             ConfigUpdateType;\n        typedef\
    \ uint32           KindId;\n        typedef opaque           KindDescription<0..2^16-1>;\n\
    \        struct {\n          ConfigUpdateType       type;\n          uint32  \
    \               length;\n          select (type) {\n            case config:\n\
    \                        opaque             config_data<0..2^24-1>;\n        \
    \    case kind:\n                        KindDescription    kinds<0..2^24-1>;\n\
    \            /* This structure may be extended with new types */\n          };\n\
    \        } ConfigUpdateReq;\n   The ConfigUpdateReq message contains the following\
    \ elements:\n   type\n      The type of the contents of the message.  This structure\
    \ allows\n      for unknown content types.\n   length\n      The length of the\
    \ remainder of the message.  This is included to\n      preserve backward compatibility\
    \ and is 32 bits instead of 24 to\n      facilitate easy conversion between network\
    \ and host byte order.\n   config_data (type==config)\n      The contents of the\
    \ Configuration Document.\n   kinds (type==kind)\n      One or more XML kind-block\
    \ productions (see Section 11.1).  These\n      MUST be encoded with UTF-8 and\
    \ assume a default namespace of\n      \"urn:ietf:params:xml:ns:p2p:config-base\"\
    .\n"
- title: 6.5.4.2.  Response Definition
  contents:
  - "6.5.4.2.  Response Definition\n   The ConfigUpdateAns structure is used to respond\
    \ to a ConfigUpdateReq\n   request.\n        struct {\n        } ConfigUpdateAns;\n\
    \   If the ConfigUpdateReq is of type \"config\", it MUST be processed only\n\
    \   if all the following are true:\n   o  The sequence number in the document\
    \ is greater than the current\n      configuration sequence number.\n   o  The\
    \ Configuration Document is correctly digitally signed (see\n      Section 11\
    \ for details on signatures).\n   Otherwise, appropriate errors MUST be generated.\n\
    \   If the ConfigUpdateReq is of type \"kind\", it MUST be processed only\n  \
    \ if it is correctly digitally signed by an acceptable Kind signer\n   (i.e.,\
    \ one listed in the current configuration file).  Details on the\n   kind-signer\
    \ field in the configuration file are described in\n   Section 11.1.  In addition,\
    \ if the Kind update conflicts with an\n   existing known Kind (i.e., it is signed\
    \ by a different signer), then\n   it should be rejected with an Error_Forbidden\
    \ error.  This should not\n   happen in correctly functioning overlays.\n   If\
    \ the update is acceptable, then the node MUST reconfigure itself to\n   match\
    \ the new information.  This may include adding permissions for\n   new Kinds,\
    \ deleting old Kinds, or even, in extreme circumstances,\n   exiting and re-entering\
    \ the overlay, if, for instance, the DHT\n   algorithm has changed.\n   If an\
    \ implementation misses enough ConfigUpdates that include key\n   changes, it\
    \ is possible that it will no longer be able to verify new\n   valid ConfigUpdates.\
    \  In this case, the only available recovery\n   mechanism is to attempt to retrieve\
    \ a new Configuration Document,\n   typically by the mechanisms used for initial\
    \ bootstrapping.  It is up\n   to implementers whether or how to decide to employ\
    \ this sort of\n   recovery mechanism.\n   The response for ConfigUpdate is empty.\n"
- title: 6.6.  Overlay Link Layer
  contents:
  - "6.6.  Overlay Link Layer\n   RELOAD can use multiple Overlay Link protocols to\
    \ send its messages.\n   Because ICE is used to establish connections (see Section\
    \ 6.5.1.3),\n   RELOAD nodes are able to detect which Overlay Link protocols are\n\
    \   offered by other nodes and establish connections between them.  Any\n   link\
    \ protocol needs to be able to establish a secure, authenticated\n   connection\
    \ and to provide data origin authentication and message\n   integrity for individual\
    \ data elements.  RELOAD currently supports\n   three Overlay Link protocols:\n\
    \   o  DTLS [RFC6347] over UDP with Simple Reliability (SR)\n      (OverlayLinkType=DTLS-UDP-SR)\n\
    \   o  TLS [RFC5246] over TCP with Framing Header, No-ICE\n      (OverlayLinkType=TLS-TCP-FH-NO-ICE)\n\
    \   o  DTLS [RFC6347] over UDP with SR, No-ICE\n      (OverlayLinkType=DTLS-UDP-SR-NO-ICE)\n\
    \   Note that although UDP does not properly have \"connections\", both TLS\n\
    \   and DTLS have a handshake that establishes a similar, stateful\n   association.\
    \  We refer to these as \"connections\" for the purposes of\n   this document.\n\
    \   If a peer receives a message that is larger than the value of max-\n   message-size\
    \ defined in the overlay configuration, the peer SHOULD\n   send an Error_Message_Too_Large\
    \ error and then close the TLS or DTLS\n   session from which the message was\
    \ received.  Note that this error\n   can be sent and the session closed before\
    \ the peer receives the\n   complete message.  If the forwarding header is larger\
    \ than the max-\n   message-size, the receiver SHOULD close the TLS or DTLS session\n\
    \   without sending an error.\n   The RELOAD mechanism requires that failed links\
    \ be quickly removed\n   from the Routing Table so end-to-end retransmission can\
    \ handle lost\n   messages.  Overlay Link protocols MUST be designed with a mechanism\n\
    \   that quickly signals a likely failure, and implementations SHOULD\n   quickly\
    \ act to remove a failed link from the Routing Table when\n   receiving this signal.\
    \  The entry can be restored if it proves to\n   resume functioning, or it can\
    \ be replaced at some point in the future\n   if necessary.  Section 10.7.2 contains\
    \ more details specific to the\n   CHORD-RELOAD Topology Plug-in.\n   The Framing\
    \ Header (FH) is used to frame messages and provide timing\n   when used on a\
    \ reliable stream-based transport protocol.  Simple\n   Reliability (SR) uses\
    \ the FH to provide congestion control and\n   partial reliability when using\
    \ unreliable message-oriented transport\n   protocols.  We will first define each\
    \ of these algorithms in Sections\n   6.6.2 and 6.6.3, and then define Overlay\
    \ Link protocols that use them\n   in Sections 6.6.4, 6.6.5, and 6.6.6.\n   Note:\
    \ We expect future Overlay Link protocols to define replacements\n   for all components\
    \ of these protocols, including the Framing Header.\n   The three protocols that\
    \ we will discuss have been chosen for\n   simplicity of implementation and reasonable\
    \ performance.\n"
- title: 6.6.1.  Future Overlay Link Protocols
  contents:
  - "6.6.1.  Future Overlay Link Protocols\n   It is possible to define new link-layer\
    \ protocols and apply them to a\n   new overlay using the \"overlay-link-protocol\"\
    \ configuration directive\n   (see Section 11.1.).  However, any new protocols\
    \ MUST meet the\n   following requirements:\n   Endpoint authentication:  When\
    \ a node forms an association with\n      another endpoint, it MUST be possible\
    \ to cryptographically verify\n      that the endpoint has a given Node-ID.\n\
    \   Traffic origin authentication and integrity:  When a node receives\n     \
    \ traffic from another endpoint, it MUST be possible to\n      cryptographically\
    \ verify that the traffic came from a given\n      association and that it has\
    \ not been modified in transit from the\n      other endpoint in the association.\
    \  The overlay link protocol MUST\n      also provide replay prevention/detection.\n\
    \   Traffic confidentiality:  When a node sends traffic to another\n      endpoint,\
    \ it MUST NOT be possible for a third party that is not\n      involved in the\
    \ association to determine the contents of that\n      traffic.\n   Any new overlay\
    \ protocol MUST be defined via Standards Action\n   [RFC5226].  See Section 14.11.\n"
- title: 6.6.1.1.  HIP
  contents:
  - "6.6.1.1.  HIP\n   In a Host Identity Protocol Based Overlay Networking Environment\
    \ (HIP\n   BONE) [RFC6079], HIP [RFC5201] provides connection management (e.g.,\n\
    \   NAT traversal and mobility) and security for the overlay network.\n   The\
    \ P2PSIP Working Group has expressed interest in supporting a HIP-\n   based link\
    \ protocol.  Such support would require specifying such\n   details as:\n   o\
    \  How to issue certificates which provide identities meaningful to\n      the\
    \ HIP base exchange.  We anticipate that this would require a\n      mapping between\
    \ Overlay Routable Cryptographic Hash Identifiers\n      (ORCHIDs) and NodeIds.\n\
    \   o  How to carry the HIP I1 and I2 messages.\n   o  How to carry RELOAD messages\
    \ over HIP.\n   [HIP-RELOAD] documents work in progress on using RELOAD with the\
    \ HIP\n   BONE.\n"
- title: 6.6.1.2.  ICE-TCP
  contents:
  - "6.6.1.2.  ICE-TCP\n   The ICE-TCP RFC [RFC6544] allows TCP to be supported as\
    \ an Overlay\n   Link protocol that can be added using ICE.\n"
- title: 6.6.1.3.  Message-Oriented Transports
  contents:
  - "6.6.1.3.  Message-Oriented Transports\n   Modern message-oriented transports\
    \ offer high performance and good\n   congestion control, and they avoid head-of-line\
    \ blocking in case of\n   lost data.  These characteristics make them preferable\
    \ as underlying\n   transport protocols for RELOAD links.  SCTP without message\
    \ ordering\n   and DCCP are two examples of such protocols.  However, currently\
    \ they\n   are not well-supported by commonly available NATs, and specifications\n\
    \   for ICE session establishment are not available.\n"
- title: 6.6.1.4.  Tunneled Transports
  contents:
  - "6.6.1.4.  Tunneled Transports\n   As of the time of this writing, there is significant\
    \ interest in the\n   IETF community in tunneling other transports over UDP, which\
    \ is\n   motivated by the situation that UDP is well-supported by modern NAT\n\
    \   hardware and by the fact that performance similar to a native\n   implementation\
    \ can be achieved.  Currently, SCTP, DCCP, and a generic\n   tunneling extension\
    \ are being proposed for message-oriented\n   protocols.  Once ICE traversal has\
    \ been specified for these tunneled\n   protocols, they should be straightforward\
    \ to support as overlay link\n   protocols.\n"
- title: 6.6.2.  Framing Header
  contents:
  - "6.6.2.  Framing Header\n   In order to support unreliable links and to allow\
    \ for quick detection\n   of link failures when using reliable end-to-end transports,\
    \ each\n   message is wrapped in a very simple framing layer (FramedMessage),\n\
    \   which is used only for each hop.  This layer contains a sequence\n   number\
    \ which can then be used for ACKs.  The same header is used for\n   both reliable\
    \ and unreliable transports for simplicity of\n   implementation.\n   The definition\
    \ of FramedMessage is:\n        enum { data(128), ack(129), (255) } FramedMessageType;\n\
    \        struct {\n          FramedMessageType       type;\n          select (type)\
    \ {\n            case data:\n              uint32              sequence;\n   \
    \           opaque              message<0..2^24-1>;\n            case ack:\n \
    \             uint32              ack_sequence;\n              uint32        \
    \      received;\n          };\n        } FramedMessage;\n   The type field of\
    \ the PDU is set to indicate whether the message is\n   data or an acknowledgement.\n\
    \   If the message is of type \"data\", then the remainder of the PDU is as\n\
    \   follows:\n   sequence\n      The sequence number.  This increments by one\
    \ for each framed\n      message sent over this transport session.\n   message\n\
    \      The message that is being transmitted.\n   Each connection has it own sequence\
    \ number space.  Initially, the\n   value is zero, and it increments by exactly\
    \ one for each message sent\n   over that connection.\n   When the receiver receives\
    \ a message, it SHOULD immediately send an\n   ACK message.  The receiver MUST\
    \ keep track of the 32 most recent\n   sequence numbers received on this association\
    \ in order to generate\n   the appropriate ACK.\n   If the PDU is of type \"ack\"\
    , the contents are as follows:\n   ack_sequence\n      The sequence number of\
    \ the message being acknowledged.\n   received\n      A bitmask indicating if\
    \ each of the previous 32 sequence numbers\n      before this packet has been\
    \ among the 32 packets most recently\n      received on this connection.  When\
    \ a packet is received with a\n      sequence number N, the receiver looks at\
    \ the sequence number of\n      the 32 previously received packets on this connection.\
    \  We call\n      the previously received packet number M.  For each of the previous\n\
    \      32 packets, if the sequence number M is less than N but greater\n     \
    \ than N-32, the N-M bit of the received bitmask is set to one;\n      otherwise,\
    \ it is set to zero.  Note that a bit being set to one\n      indicates positively\
    \ that a particular packet was received, but a\n      bit being set to zero means\
    \ only that it is unknown whether or not\n      the packet has been received,\
    \ because it might have been received\n      before the 32 most recently received\
    \ packets.\n   The received field bits in the ACK provide a high degree of\n \
    \  redundancy so that the sender can figure out which packets the\n   receiver\
    \ has received and can then estimate packet loss rates.  If\n   the sender also\
    \ keeps track of the time at which recent sequence\n   numbers have been sent,\
    \ the RTT (round-trip time) can be estimated.\n   Note that because retransmissions\
    \ receive new sequence numbers,\n   multiple ACKs may be received for the same\
    \ message.  This approach\n   provides more information than traditional TCP sequence\
    \ numbers, but\n   care must be taken when applying algorithms designed based\
    \ on TCP's\n   stream-oriented sequence number.\n"
- title: 6.6.3.  Simple Reliability
  contents:
  - "6.6.3.  Simple Reliability\n   When RELOAD is carried over DTLS or another unreliable\
    \ link protocol,\n   it needs to be used with a reliability and congestion control\n\
    \   mechanism, which is provided on a hop-by-hop basis.  The basic\n   principle\
    \ is that each message, regardless of whether or not it\n   carries a request\
    \ or response, will get an ACK and be reliably\n   retransmitted.  The receiver's\
    \ job is very simple, and is limited to\n   just sending ACKs.  All the complexity\
    \ is at the sender side.  This\n   allows the sending implementation to trade\
    \ off performance versus\n   implementation complexity without affecting the wire\
    \ protocol.\n   Because the receiver's role is limited to providing packet\n \
    \  acknowledgements, a wide variety of congestion control algorithms can\n   be\
    \ implemented on the sender side while using the same basic wire\n   protocol.\
    \  The sender algorithm used MUST meet the requirements of\n   [RFC5405].\n"
- title: 6.6.3.1.  Stop and Wait Sender Algorithm
  contents:
  - "6.6.3.1.  Stop and Wait Sender Algorithm\n   This section describes one possible\
    \ implementation of a sender\n   algorithm for Simple Reliability.  It is adequate\
    \ for overlays\n   running on underlying networks with low latency and loss (LANs)\
    \ or\n   low-traffic overlays on the Internet.\n   A node MUST NOT have more than\
    \ one unacknowledged message on the DTLS\n   connection at a time.  Note that\
    \ because retransmissions of the same\n   message are given new sequence numbers,\
    \ there may be multiple\n   unacknowledged sequence numbers in use.\n   The RTO\
    \ (Retransmission TimeOut) is based on an estimate of the RTT.\n   The value for\
    \ RTO is calculated separately for each DTLS session.\n   Implementations can\
    \ use a static value for RTO or a dynamic estimate,\n   which will result in better\
    \ performance.  For implementations that\n   use a static value, the default value\
    \ for RTO is 500 ms.  Nodes MAY\n   use smaller values of RTO if it is known that\
    \ all nodes are within\n   the local network.  The default RTO MAY be set to a\
    \ larger value,\n   which is RECOMMENDED if it is known in advance (such as on\
    \ high-\n   latency access links) that the RTT is larger.\n   Implementations\
    \ that use a dynamic estimate to compute the RTO MUST\n   use the algorithm described\
    \ in RFC 6298 [RFC6298], with the exception\n   that the value of RTO SHOULD NOT\
    \ be rounded up to the nearest second,\n   but instead rounded up to the nearest\
    \ millisecond.  The RTT of a\n   successful STUN transaction from the ICE stage\
    \ is used as the initial\n   measurement for formula 2.2 of RFC 6298.  The sender\
    \ keeps track of\n   the time each message was sent for all recently sent messages.\
    \  Any\n   time an ACK is received, the sender can compute the RTT for that\n\
    \   message by looking at the time the ACK was received and the time when\n  \
    \ the message was sent.  This is used as a subsequent RTT measurement\n   for\
    \ formula 2.3 of RFC 6298 to update the RTO estimate.  (Note that\n   because\
    \ retransmissions receive new sequence numbers, all received\n   ACKs are used.)\n\
    \   An initiating node SHOULD retransmit a message if it has not received\n  \
    \ an ACK after an interval of RTO (transit nodes do not retransmit at\n   this\
    \ layer).  The node MUST double the time to wait after each\n   retransmission.\
    \  For each retransmission, the sequence number MUST be\n   incremented.\n   Retransmissions\
    \ continue until a response is received, until a total\n   of 5 requests have\
    \ been sent, until there has been a hard ICMP error\n   [RFC1122], or until a\
    \ TLS alert indicating the end of the connection\n   has been sent or received.\
    \  The sender knows a response was received\n   when it receives an ACK with a\
    \ sequence number that indicates it is a\n   response to one of the transmissions\
    \ of this message.  For example,\n   assuming an RTO of 500 ms, requests would\
    \ be sent at times 0 ms, 500\n   ms, 1500 ms, 3500 ms, and 7500 ms.  If all retransmissions\
    \ for a\n   message fail, then the sending node SHOULD close the connection\n\
    \   routing the message.\n   To determine when a link might be failing without\
    \ waiting for the\n   final timeout, observe when no ACKs have been received for\
    \ an entire\n   RTO interval, and then wait for three retransmissions to occur\
    \ beyond\n   that point.  If no ACKs have been received by the time the third\n\
    \   retransmission occurs, it is RECOMMENDED that the link be removed\n   from\
    \ the Routing Table.  The link MAY be restored to the Routing\n   Table if ACKs\
    \ resume before the connection is closed, as described\n   above.\n   A sender\
    \ MUST wait 10 ms between receipt of an ACK and transmission\n   of the next message.\n"
- title: 6.6.4.  DTLS/UDP with SR
  contents:
  - "6.6.4.  DTLS/UDP with SR\n   This overlay link protocol consists of DTLS over\
    \ UDP while\n   implementing the SR protocol.  STUN connectivity checks and\n\
    \   keepalives are used.  Any compliant sender algorithm may be used.\n"
- title: 6.6.5.  TLS/TCP with FH, No-ICE
  contents:
  - "6.6.5.  TLS/TCP with FH, No-ICE\n   This overlay link protocol consists of TLS\
    \ over TCP with the framing\n   header.  Because ICE is not used, STUN connectivity\
    \ checks are not\n   used upon establishing the TCP connection, nor are they used\
    \ for\n   keepalives.\n   Because the TCP layer's application-level timeout is\
    \ too slow to be\n   useful for overlay routing, the Overlay Link implementation\
    \ MUST use\n   the framing header to measure the RTT of the connection and calculate\n\
    \   an RTO as specified in Section 2 of [RFC6298].  The resulting RTO is\n   not\
    \ used for retransmissions, but rather as a timeout to indicate\n   when the link\
    \ SHOULD be removed from the Routing Table.  It is\n   RECOMMENDED that such a\
    \ connection be retained for 30 seconds to\n   determine if the failure was transient\
    \ before concluding the link has\n   failed permanently.\n   When sending candidates\
    \ for TLS/TCP with FH, No-ICE, a passive\n   candidate MUST be provided.\n"
- title: 6.6.6.  DTLS/UDP with SR, No-ICE
  contents:
  - "6.6.6.  DTLS/UDP with SR, No-ICE\n   This overlay link protocol consists of DTLS\
    \ over UDP while\n   implementing the Simple Reliability protocol.  Because ICE\
    \ is not\n   used, no STUN connectivity checks or keepalives are used.\n"
- title: 6.7.  Fragmentation and Reassembly
  contents:
  - "6.7.  Fragmentation and Reassembly\n   In order to allow transmission over datagram\
    \ protocols such as DTLS,\n   RELOAD messages may be fragmented.\n   Any node\
    \ along the path can fragment the message, but only the final\n   destination\
    \ reassembles the fragments.  When a node takes a packet\n   and fragments it,\
    \ each fragment has a full copy of the forwarding\n   header, but the data after\
    \ the forwarding header is broken up into\n   appropriately sized chunks.  The\
    \ size of the payload chunks needs to\n   take into account space to allow the\
    \ Via and Destination Lists to\n   grow.  Each fragment MUST contain a full copy\
    \ of the Via List,\n   Destination List, and ForwardingOptions and MUST contain\
    \ at least 256\n   bytes of the message body.  If these elements cannot fit within\
    \ the\n   MTU of the underlying datagram protocol, RELOAD fragmentation is not\n\
    \   performed, and IP-layer fragmentation is allowed to occur.  The\n   length\
    \ field MUST contain the size of the message after\n   fragmentation.  When a\
    \ message MUST be fragmented, it SHOULD be split\n   into equal-sized fragments\
    \ that are no larger than the Path MTU\n   (PMTU) of the next overlay link minus\
    \ 32 bytes.  This is to allow the\n   Via List to grow before further fragmentation\
    \ is required.\n   Note that this fragmentation is not optimal for the end-to-end\n\
    \   path -- a message may be refragmented multiple times as it traverses\n   the\
    \ overlay, but it is assembled only at the final destination.  This\n   option\
    \ has been chosen as it is far easier to implement than end-to-\n   end (e2e)\
    \ PMTU discovery across an ever-changing overlay and it\n   effectively addresses\
    \ the reliability issues of relying on IP-layer\n   fragmentation.  However, Ping\
    \ can be used to allow e2e PMTU discovery\n   to be implemented if desired.\n\
    \   Upon receipt of a fragmented message by the intended peer, the peer\n   holds\
    \ the fragments in a holding buffer until the entire message has\n   been received.\
    \  The message is then reassembled into a single message\n   and processed.  In\
    \ order to mitigate denial-of-service (DoS) attacks,\n   receivers SHOULD time\
    \ out incomplete fragments after the maximum\n   request lifetime (15 seconds).\
    \  This time was derived from looking at\n   the end-to-end retransmission time\
    \ and saving fragments long enough\n   for the full end-to-end retransmissions\
    \ to take place.  Ideally, the\n   receiver would have enough buffer space to\
    \ deal with as many\n   fragments as can arrive in the maximum request lifetime.\
    \  However, if\n   the receiver runs out of buffer space to reassemble a message,\
    \ it\n   MUST drop the message.\n   The fragment field of the forwarding header\
    \ is used to encode\n   fragmentation information.  The offset is the number of\
    \ bytes between\n   the end of the forwarding header and the start of the data.\
    \  The\n   first fragment therefore has an offset of 0.  The last fragment\n \
    \  indicator MUST be appropriately set.  If the message is not\n   fragmented,\
    \ it is simply treated as if it is the only fragment: the\n   last fragment bit\
    \ is set and the offset is 0, resulting in a fragment\n   value of 0xC0000000.\n\
    \   Note: The reason for this definition of the fragment field is that\n   originally,\
    \ the high bit was defined in part of the specification as\n   \"is fragmented\"\
    , so there was some specification ambiguity about how\n   to encode messages with\
    \ only one fragment.  This ambiguity was\n   resolved in favor of always encoding\
    \ as the \"last\" fragment with\n   offset 0, thus simplifying the receiver code\
    \ path, but resulting in\n   the high bit being redundant.  Because messages MUST\
    \ be set with the\n   high bit set to 1, implementations SHOULD discard any message\
    \ with it\n   set to 0.  Implementations (presumably legacy ones) which choose\
    \ to\n   accept such messages MUST either ignore the remaining bits or ensure\n\
    \   that they are 0.  They MUST NOT try to interpret as fragmented\n   messages\
    \ with the high bit set low.\n"
- title: 7.  Data Storage Protocol
  contents:
  - "7.  Data Storage Protocol\n   RELOAD provides a set of generic mechanisms for\
    \ storing and\n   retrieving data in the Overlay Instance.  These mechanisms can\
    \ be\n   used for new applications simply by defining new code points and a\n\
    \   small set of rules.  No new protocol mechanisms are required.\n   The basic\
    \ unit of stored data is a single StoredData structure:\n        struct {\n  \
    \        uint32                  length;\n          uint64                  storage_time;\n\
    \          uint32                  lifetime;\n          StoredDataValue      \
    \   value;\n          Signature               signature;\n        } StoredData;\n\
    \   The contents of this structure are as follows:\n   length\n      The size\
    \ of the StoredData structure, in bytes, excluding the size\n      of length itself.\n\
    \   storage_time\n      The time when the data was stored, represented as the\
    \ number of\n      milliseconds elapsed since midnight Jan 1, 1970 UTC, not counting\n\
    \      leap seconds.  This will have the same values for seconds as\n      standard\
    \ UNIX or POSIX time.  More information can be found at\n      [UnixTime].  Any\
    \ attempt to store a data value with a storage time\n      before that of a value\
    \ already stored at this location MUST\n      generate an Error_Data_Too_Old error.\
    \  This prevents rollback\n      attacks.  The node SHOULD make a best-effort\
    \ attempt to use a\n      correct clock to determine this number.  However, the\
    \ protocol\n      does not require synchronized clocks: the receiving peer uses\
    \ the\n      storage time in the previous store, not its own clock.  Clock\n \
    \     values are used so that when clocks are generally synchronized,\n      data\
    \ may be stored in a single transaction, rather than querying\n      for the value\
    \ of a counter before the actual store.\n      If a node attempting to store new\
    \ data in response to a user\n      request (rather than as an overlay maintenance\
    \ operation such as\n      occurs when healing the overlay from a partition) is\
    \ rejected with\n      an Error_Data_Too_Old error, the node MAY elect to perform\
    \ its\n      store using a storage_time that increments the value used with the\n\
    \      previous store (this may be obtained by doing a Fetch).  This\n      situation\
    \ may occur when the clocks of nodes storing to this\n      location are not properly\
    \ synchronized.\n   lifetime\n      The validity period for the data, in seconds,\
    \ starting from the\n      time the peer receives the StoreReq.\n   value\n  \
    \    The data value itself, as described in Section 7.2.\n   signature\n     \
    \ A signature, as defined in Section 7.1.\n   Each Resource-ID specifies a single\
    \ location in the Overlay Instance.\n   However, each location may contain multiple\
    \ StoredData values,\n   distinguished by Kind-ID.  The definition of a Kind describes\
    \ both\n   the data values which may be stored and the data model of the data.\n\
    \   Some data models allow multiple values to be stored under the same\n   Kind-ID.\
    \  Section 7.2 describes the available data models.  Thus, for\n   instance, a\
    \ given Resource-ID might contain a single-value element\n   stored under Kind-ID\
    \ X and an array containing multiple values stored\n   under Kind-ID Y.\n"
- title: 7.1.  Data Signature Computation
  contents:
  - "7.1.  Data Signature Computation\n   Each StoredData element is individually\
    \ signed.  However, the\n   signature also must be self-contained and must cover\
    \ the Kind-ID and\n   Resource-ID, even though they are not present in the StoredData\n\
    \   structure.  The input to the signature algorithm is:\n      resource_id ||\
    \ kind || storage_time || StoredDataValue ||\n      SignerIdentity\n   where ||\
    \ indicates concatenation and where these values are:\n   resource_id\n      The\
    \ Resource-ID where this data is stored.\n   kind\n      The Kind-ID for this\
    \ data.\n   storage_time\n      The contents of the storage_time data value.\n\
    \   StoredDataValue\n      The contents of the stored data value, as described\
    \ in the\n      previous sections.\n   SignerIdentity\n      The signer identity,\
    \ as defined in Section 6.3.4.\n   Once the signature has been computed, the signature\
    \ is represented\n   using a signature element, as described in Section 6.3.4.\n\
    \   Note that there is no necessary relationship between the validity\n   window\
    \ of a certificate and the expiry of the data it is\n   authenticating.  When\
    \ signatures are verified, the current time MUST\n   be compared to the certificate\
    \ validity period.  Stored data MAY be\n   set to expire after the signing certificate's\
    \ validity period.  Such\n   signatures are not considered valid after the signing\
    \ certificate\n   expires.  Implementations may \"garbage collect\" such data\
    \ at their\n   convenience, either by purging it automatically (perhaps by setting\n\
    \   the upper bound on data storage to the lifetime of the signing\n   certificate)\
    \ or by simply leaving it in place until it expires\n   naturally and relying\
    \ on users of that data to notice the expired\n   signing certificate.\n"
- title: 7.2.  Data Models
  contents:
  - "7.2.  Data Models\n   The protocol currently defines the following data models:\n\
    \   o  single value\n   o  array\n   o  dictionary\n   These are represented with\
    \ the StoredDataValue structure.  The actual\n   data model is known from the\
    \ Kind being stored.\n        struct {\n          Boolean                exists;\n\
    \          opaque                 value<0..2^32-1>;\n        } DataValue;\n  \
    \      struct {\n          select (DataModel) {\n            case single_value:\n\
    \              DataValue             single_value_entry;\n            case array:\n\
    \              ArrayEntry            array_entry;\n            case dictionary:\n\
    \              DictionaryEntry       dictionary_entry;\n            /* This structure\
    \ may be extended */\n          };\n        } StoredDataValue;\n   The following\
    \ sections discuss the properties of each data model.\n"
- title: 7.2.1.  Single Value
  contents:
  - "7.2.1.  Single Value\n   A single-value element is a simple sequence of bytes.\
    \  There may be\n   only one single-value element for each Resource-ID, Kind-ID\
    \ pair.\n   A single value element is represented as a DataValue, which contains\n\
    \   the following two elements:\n   exists\n      This value indicates whether\
    \ the value exists at all.  If it is\n      set to False, it means that no value\
    \ is present.  If it is True,\n      this means that a value is present.  This\
    \ gives the protocol a\n      mechanism for indicating nonexistence as opposed\
    \ to emptiness.\n   value\n      The stored data.\n"
- title: 7.2.2.  Array
  contents:
  - "7.2.2.  Array\n   An array is a set of opaque values addressed by an integer\
    \ index.\n   Arrays are zero based.  Note that arrays can be sparse.  For\n  \
    \ instance, a Store of \"X\" at index 2 in an empty array produces an\n   array\
    \ with the values [ NA, NA, \"X\"].  Future attempts to fetch\n   elements at\
    \ index 0 or 1 will return values with \"exists\" set to\n   False.\n   An array\
    \ element is represented as an ArrayEntry:\n         struct {\n           uint32\
    \                  index;\n           DataValue               value;\n       \
    \  } ArrayEntry;\n   The contents of this structure are:\n   index\n      The\
    \ index of the data element in the array.\n   value\n      The stored data.\n"
- title: 7.2.3.  Dictionary
  contents:
  - "7.2.3.  Dictionary\n   A dictionary is a set of opaque values indexed by an opaque\
    \ key, with\n   one value for each key.  A single dictionary entry is represented\
    \ as\n   a DictionaryEntry:\n         typedef opaque           DictionaryKey<0..2^16-1>;\n\
    \         struct {\n           DictionaryKey          key;\n           DataValue\
    \              value;\n         } DictionaryEntry;\n   The contents of this structure\
    \ are:\n   key\n      The dictionary key for this value.\n   value\n      The\
    \ stored data.\n"
- title: 7.3.  Access Control Policies
  contents:
  - "7.3.  Access Control Policies\n   Every Kind which is storable in an overlay\
    \ MUST be associated with an\n   access control policy.  This policy defines whether\
    \ a request from a\n   given node to operate on a given value should succeed or\
    \ fail.  It is\n   anticipated that only a small number of generic access control\n\
    \   policies are required.  To that end, this section describes a small\n   set\
    \ of such policies, and Section 14.4 establishes a registry for new\n   policies,\
    \ if required.  Each policy has a short string identifier\n   which is used to\
    \ reference it in the Configuration Document.\n   In the following policies, the\
    \ term \"signer\" refers to the signer of\n   the StoredValue object and, in the\
    \ case of non-replica stores, to the\n   signer of the StoreReq message.  That\
    \ is, in a non-replica store,\n   both the signer of the StoredValue and the signer\
    \ of the StoreReq\n   MUST conform to the policy.  In the case of a replica store,\
    \ the\n   signer of the StoredValue MUST conform to the policy, and the\n   StoreReq\
    \ itself MUST be checked as described in Section 7.4.1.1.\n"
- title: 7.3.1.  USER-MATCH
  contents:
  - "7.3.1.  USER-MATCH\n   In the USER-MATCH policy, a given value MUST be written\
    \ (or\n   overwritten) if and only if the signer's certificate has a user name\n\
    \   which hashes (using the hash function for the overlay) to the\n   Resource-ID\
    \ for the resource.  Recall that the certificate may,\n   depending on the overlay\
    \ configuration, be self-signed.\n"
- title: 7.3.2.  NODE-MATCH
  contents:
  - "7.3.2.  NODE-MATCH\n   In the NODE-MATCH policy, a given value MUST be written\
    \ (or\n   overwritten) if and only if the signer's certificate has a specified\n\
    \   Node-ID which hashes (using the hash function for the overlay) to the\n  \
    \ Resource-ID for the resource and that Node-ID is the one indicated in\n   the\
    \ SignerIdentity value cert_hash.\n"
- title: 7.3.3.  USER-NODE-MATCH
  contents:
  - "7.3.3.  USER-NODE-MATCH\n   The USER-NODE-MATCH policy may be used only with\
    \ dictionary types.\n   In the USER-NODE-MATCH policy, a given value MUST be written\
    \ (or\n   overwritten) if and only if the signer's certificate has a user name\n\
    \   which hashes (using the hash function for the overlay) to the\n   Resource-ID\
    \ for the resource.  In addition, the dictionary key MUST\n   be equal to the\
    \ Node-ID in the certificate, and that Node-ID MUST be\n   the one indicated in\
    \ the SignerIdentity value cert_hash.\n"
- title: 7.3.4.  NODE-MULTIPLE
  contents:
  - "7.3.4.  NODE-MULTIPLE\n   In the NODE-MULTIPLE policy, a given value MUST be\
    \ written (or\n   overwritten) if and only if the signer's certificate contains\
    \ a\n   Node-ID such that H(Node-ID || i) is equal to the Resource-ID for\n  \
    \ some small integer value of i and that Node-ID is the one indicated\n   in the\
    \ SignerIdentity value cert_hash.  When this policy is in use,\n   the maximum\
    \ value of i MUST be specified in the Kind definition.\n   Note that because i\
    \ is not carried on the wire, the verifier MUST\n   iterate through potential\
    \ i values, up to the maximum value, to\n   determine whether a store is acceptable.\n"
- title: 7.4.  Data Storage Methods
  contents:
  - "7.4.  Data Storage Methods\n   RELOAD provides several methods for storing and\
    \ retrieving data:\n   o  Store values in the overlay.\n   o  Fetch values from\
    \ the overlay.\n   o  Stat: Get metadata about values in the overlay.\n   o  Find\
    \ the values stored at an individual peer.\n   These methods are described in\
    \ the following sections.\n"
- title: 7.4.1.  Store
  contents:
  - "7.4.1.  Store\n   The Store method is used to store data in the overlay.  The\
    \ format of\n   the Store request depends on the data model, which is determined\
    \ by\n   the Kind.\n"
- title: 7.4.1.1.  Request Definition
  contents:
  - "7.4.1.1.  Request Definition\n   A StoreReq message is a sequence of StoreKindData\
    \ values, each of\n   which represents a sequence of stored values for a given\
    \ Kind.  The\n   same Kind-ID MUST NOT be used twice in a given store request.\
    \  Each\n   value is then processed in turn.  These operations MUST be atomic.\n\
    \   If any operation fails, the state MUST be rolled back to what it was\n   before\
    \ the request was received.\n   The store request is defined by the StoreReq structure:\n\
    \       struct {\n           KindId                 kind;\n           uint64 \
    \                generation_counter;\n           StoredData             values<0..2^32-1>;\n\
    \       } StoreKindData;\n       struct {\n           ResourceId             resource;\n\
    \           uint8                  replica_number;\n           StoreKindData \
    \         kind_data<0..2^32-1>;\n       } StoreReq;\n   A single Store request\
    \ stores data of a number of Kinds to a single\n   resource location.  The contents\
    \ of the structure are:\n   resource\n      The resource at which to store.\n\
    \   replica_number\n      The number of this replica.  When a storing peer saves\
    \ replicas to\n      other peers, each peer is assigned a replica number, starting\
    \ from\n      1, that is sent in the Store message.  This field is set to 0 when\n\
    \      a node is storing its own data.  This allows peers to distinguish\n   \
    \   replica writes from original writes.  Different topologies may\n      choose\
    \ to allocate or interpret the replica number differently\n      (see Section\
    \ 10.4).\n   kind_data\n      A series of elements, one for each Kind of data\
    \ to be stored.\n   The peer MUST check that it is responsible for the resource\
    \ if the\n   replica number is zero; if it is not, the peer must reject the\n\
    \   request.  The peer MUST check that it expects to be a replica for the\n  \
    \ resource and that the request sender is consistent with being the\n   responsible\
    \ node (i.e., that the receiving peer does not know of a\n   better node) if the\
    \ replica number is nonzero; if the request sender\n   is not consistent, it should\
    \ reject the request.\n   Each StoreKindData element represents the data to be\
    \ stored for a\n   single Kind-ID.  The contents of the element are:\n   kind\n\
    \      The Kind-ID.  Implementations MUST reject requests corresponding\n    \
    \  to unknown Kinds.\n   generation_counter\n      The expected current state\
    \ of the generation counter\n      (approximately the number of times that this\
    \ object has been\n      written; see below for details).\n   values\n      The\
    \ value or values to be stored.  This may contain one or more\n      stored_data\
    \ values, depending on the data model associated with\n      each Kind.\n   The\
    \ peer MUST perform the following checks:\n   o  The Kind-ID is known and supported.\n\
    \   o  The signatures over each individual data element, if any, are\n      valid.\
    \  If this check fails, the request MUST be rejected with an\n      Error_Forbidden\
    \ error.\n   o  Each element is signed by a credential which is authorized to\n\
    \      write this Kind at this Resource-ID.  If this check fails, the\n      request\
    \ MUST be rejected with an Error_Forbidden error.\n   o  For original (non-replica)\
    \ stores, the StoreReq is signed by a\n      credential which is authorized to\
    \ write this Kind at this\n      Resource-ID.  If this check fails, the request\
    \ MUST be rejected\n      with an Error_Forbidden error.\n   o  For replica stores,\
    \ the StoreReq is signed by a Node-ID which is a\n      plausible node to either\
    \ have originally stored the value or have\n      been in the replica set.  What\
    \ this means is overlay specific, but\n      in the case of the Chord-based DHT\
    \ defined in this specification,\n      replica StoreReqs MUST come from nodes\
    \ which are either in the\n      known replica set for a given resource or which\
    \ are closer than\n      some node in the replica set.  If this check fails, the\
    \ request\n      MUST be rejected with an Error_Forbidden error.\n   o  For original\
    \ (non-replica) stores, the peer MUST check that if the\n      generation counter\
    \ is nonzero, it equals the current value of the\n      generation counter for\
    \ this Kind.  This feature allows the\n      generation counter to be used in\
    \ a way similar to the HTTP ETag\n      feature.\n   o  For replica Stores, the\
    \ peer MUST set the generation counter to\n      match the generation counter\
    \ in the message and MUST NOT check the\n      generation counter against the\
    \ current value.  Replica Stores MUST\n      NOT use a generation counter of 0.\n\
    \   o  The storage time values are greater than that of any values which\n   \
    \   would be replaced by this Store.\n   o  The size and number of the stored\
    \ values are consistent with the\n      limits specified in the overlay configuration.\n\
    \   o  If the data is signed with identity_type set to \"none\" and/or\n     \
    \ SignatureAndHashAlgorithm values set to {0, 0} (\"anonymous\" and\n      \"\
    none\"), the StoreReq MUST be rejected with an Error_forbidden\n      error. \
    \ Only synthesized data returned by the storage can use\n      these values (see\
    \ Section 7.4.2.2)\n   If all these checks succeed, the peer MUST attempt to store\
    \ the data\n   values.  For non-replica stores, if the store succeeds and the\
    \ data\n   is changed, then the peer MUST increase the generation counter by at\n\
    \   least 1.  If there are multiple stored values in a single\n   StoreKindData,\
    \ it is permissible for the peer to increase the\n   generation counter by only\
    \ 1 for the entire Kind-ID or by 1 or more\n   than 1 for each value.  Accordingly,\
    \ all stored data values MUST have\n   a generation counter of 1 or greater. 0\
    \ is used in the Store request\n   to indicate that the generation counter should\
    \ be ignored for\n   processing this request.  However, the responsible peer should\n\
    \   increase the stored generation counter and should return the correct\n   generation\
    \ counter in the response.\n   When a peer stores data previously stored by another\
    \ node (e.g., for\n   replicas or topology shifts), it MUST adjust the lifetime\
    \ value\n   downward to reflect the amount of time the value was stored at the\n\
    \   peer.  The adjustment SHOULD be implemented by an algorithm\n   equivalent\
    \ to the following: at the time the peer initially receives\n   the StoreReq,\
    \ it notes the local time T.  When it then attempts to do\n   a StoreReq to another\
    \ node, it should decrement the lifetime value by\n   the difference between the\
    \ current local time and T.\n   Unless otherwise specified by the usage, if a\
    \ peer attempts to store\n   data previously stored by another node (e.g., for\
    \ replicas or\n   topology shifts) and that store fails with either an\n   Error_Generation_Counter_Too_Low\
    \ or an Error_Data_Too_Old error, the\n   peer MUST fetch the newer data from\
    \ the peer generating the error and\n   use that to replace its own copy.  This\
    \ rule allows resynchronization\n   after partitions heal.\n   When a network\
    \ partition is being healed and unless otherwise\n   specified, the default merging\
    \ rule is to act as if all the values\n   that need to be merged were stored and\
    \ as if the order they were\n   stored in corresponds to the stored time values\
    \ associated with (and\n   carried in) their values.  Because the stored time\
    \ values are those\n   associated with the peer which did the writing, clock skew\
    \ is\n   generally not an issue.  If two nodes are on different partitions,\n\
    \   write to the same location, and have clock skew, this can create\n   merge\
    \ conflicts.  However, because RELOAD deliberately segregates\n   storage so that\
    \ data from different users and peers is stored in\n   different locations, and\
    \ a single peer will typically only be in a\n   single network partition, this\
    \ case will generally not arise.\n   The properties of stores for each data model\
    \ are as follows:\n   single-value:  A store of a new single-value element creates\
    \ the\n      element if it does not exist and overwrites any existing value\n\
    \      with the new value.\n   array:  A store of an array entry replaces (or\
    \ inserts) the given\n      value at the location specified by the index.  Because\
    \ arrays are\n      sparse, a store past the end of the array extends it with\n\
    \      nonexistent values (exists = False) as required.  A store at index\n  \
    \    0xffffffff places the new value at the end of the array,\n      regardless\
    \ of the length of the array.  The resulting StoredData\n      has the correct\
    \ index value when it is subsequently fetched.\n   dictionary:  A store of a dictionary\
    \ entry replaces (or inserts) the\n      given value at the location specified\
    \ by the dictionary key.\n   The following figure shows the relationship between\
    \ these structures\n   for an example store which stores the following values\
    \ at resource\n   \"1234\":\n   o  The value \"abc\" is in the single-value location\
    \ for Kind X.\n   o  The value \"foo\" at index 0 is in the array for Kind Y.\n\
    \   o  The value \"bar\" at index 1 is in the array for Kind Y.\n            \
    \                         Store\n                                resource=1234\n\
    \                              replica_number = 0\n                          \
    \         /      \\\n                                  /        \\\n         \
    \             StoreKindData        StoreKindData\n                  kind=X (Single-Value)\
    \    kind=Y (Array)\n                generation_counter = 99    generation_counter\
    \ = 107\n                           |                    /\\\n               \
    \            |                   /  \\\n                       StoredData    \
    \         /    \\\n             storage_time = xxxxxxx          /      \\\n  \
    \                 lifetime = 86400         /        \\\n                   signature\
    \ = XXXX        /          \\\n                           |               |  \
    \         |\n                           |        StoredData       StoredData\n\
    \                           |    storage_time =       storage_time =\n       \
    \                    |          yyyyyyyy       zzzzzzz\n                     \
    \      |  lifetime = 86400       lifetime = 33200\n                          \
    \ |  signature = YYYY       signature = ZZZZ\n                           |   \
    \            |           |\n                    StoredDataValue        |     \
    \      |\n                     value=\"abc\"           |           |\n       \
    \                                    |           |\n                         \
    \         StoredDataValue  StoredDataValue\n                                 \
    \       index=0      index=1\n                                     value=\"foo\"\
    \    value=\"bar\"\n"
- title: 7.4.1.2.  Response Definition
  contents:
  - "7.4.1.2.  Response Definition\n   In response to a successful Store request,\
    \ the peer MUST return a\n   StoreAns message containing a series of StoreKindResponse\
    \ elements,\n   which contains the current value of the generation counter for\
    \ each\n   Kind-ID, as well as a list of the peers where the data will be\n  \
    \ replicated by the node processing the request.\n        struct {\n         \
    \ KindId                  kind;\n          uint64                  generation_counter;\n\
    \          NodeId                  replicas<0..2^16-1>;\n        } StoreKindResponse;\n\
    \        struct {\n          StoreKindResponse       kind_responses<0..2^16-1>;\n\
    \        } StoreAns;\n   The contents of each StoreKindResponse are:\n   kind\n\
    \      The Kind-ID being represented.\n   generation_counter\n      The current\
    \ value of the generation counter for that Kind-ID.\n   replicas\n      The list\
    \ of other peers at which the data was/will be replicated.\n      In overlays\
    \ and applications where the responsible peer is\n      intended to store redundant\
    \ copies, this allows the storing node\n      to independently verify that the\
    \ replicas have in fact been\n      stored.  It does this verification by using\
    \ the Stat method (see\n      Section 7.4.3).  Note that the storing node is not\
    \ required to\n      perform this verification.\n   The response itself is just\
    \ StoreKindResponse values packed end to\n   end.\n   If any of the generation\
    \ counters in the request precede the\n   corresponding stored generation counter,\
    \ then the peer MUST fail the\n   entire request and respond with an Error_Generation_Counter_Too_Low\n\
    \   error.  The error_info in the ErrorResponse MUST be a StoreAns\n   response\
    \ containing the correct generation counter for each Kind and\n   the replica\
    \ list, which will be empty.  For original (non-replica)\n   stores, a node which\
    \ receives such an error SHOULD attempt to fetch\n   the data and, if the storage_time\
    \ value is newer, replace its own\n   data with that newer data.  This rule improves\
    \ data consistency in\n   the case of partitions and merges.\n   If the data being\
    \ stored is too large for the allowed limit by the\n   given usage, then the peer\
    \ MUST fail the request and generate an\n   Error_Data_Too_Large error.\n   If\
    \ any type of request tries to access a data Kind that the peer does\n   not know\
    \ about, the peer MUST fail the request and generate an\n   Error_Unknown_Kind\
    \ error.  The error_info in the Error_Response is:\n              KindId     \
    \   unknown_kinds<0..2^8-1>;\n   which lists all the Kinds that were unrecognized.\
    \  A node which\n   receives this error MUST generate a ConfigUpdate message which\n\
    \   contains the appropriate Kind definition (assuming which, in fact, a\n   Kind\
    \ which was defined in the configuration document was used).\n"
- title: 7.4.1.3.  Removing Values
  contents:
  - "7.4.1.3.  Removing Values\n   RELOAD does not have an explicit Remove operation.\
    \  Rather, values\n   are Removed by storing \"nonexistent\" values in their place.\
    \  Each\n   DataValue contains a boolean value called \"exists\" which indicates\n\
    \   whether a value is present at that location.  In order to effectively\n  \
    \ remove a value, the owner stores a new DataValue with \"exists\" set to\n  \
    \ False:\n      exists = False\n      value = {} (0 length)\n   The owner SHOULD\
    \ use a lifetime for the nonexistent value that is at\n   least as long as the\
    \ remainder of the lifetime of the value it is\n   replacing.  Otherwise, it is\
    \ possible for the original value to be\n   accidentally or maliciously re-stored\
    \ after the storing node has\n   expired it.  Note that a window of vulnerability\
    \ for replay attack\n   still exists after the original lifetime has expired (as\
    \ with any\n   store).  This attack can be mitigated by doing a nonexistent store\n\
    \   with a very long lifetime.\n   Storing nodes MUST treat these nonexistent\
    \ values the same way they\n   treat any other stored value, including overwriting\
    \ the existing\n   value, replicating them, and aging them out as necessary when\
    \ the\n   lifetime expires.  When a stored nonexistent value's lifetime\n   expires,\
    \ it is simply removed from the storing node, as happens when\n   any other stored\
    \ value expires.\n   Note that in the case of arrays and dictionaries, expiration\
    \ may\n   create an implicit, unsigned \"nonexistent\" value to represent a gap\n\
    \   in the data structure, as might happen when any value is aged out.\n   However,\
    \ this value isn't persistent, nor is it replicated.  It is\n   simply synthesized\
    \ by the storing node.\n"
- title: 7.4.2.  Fetch
  contents:
  - "7.4.2.  Fetch\n   The Fetch request retrieves one or more data elements stored\
    \ at a\n   given Resource-ID.  A single Fetch request can retrieve multiple\n\
    \   different Kinds.\n"
- title: 7.4.2.1.  Request Definition
  contents:
  - "7.4.2.1.  Request Definition\n   Fetch requests are defined by the FetchReq structure:\n\
    \        struct {\n          int32            first;\n          int32        \
    \    last;\n        } ArrayRange;\n        struct {\n          KindId        \
    \          kind;\n          uint64                  generation;\n          uint16\
    \                  length;\n          select (DataModel) {\n            case single_value:\
    \ ;    /* Empty */\n            case array:\n                 ArrayRange     \
    \  indices<0..2^16-1>;\n            case dictionary:\n                 DictionaryKey\
    \    keys<0..2^16-1>;\n            /* This structure may be extended */\n    \
    \      } model_specifier;\n        } StoredDataSpecifier;\n        struct {\n\
    \          ResourceId              resource;\n          StoredDataSpecifier  \
    \   specifiers<0..2^16-1>;\n        } FetchReq;\n   The contents of the Fetch\
    \ requests are as follows:\n   resource\n      The Resource-ID to fetch from.\n\
    \   specifiers\n      A sequence of StoredDataSpecifier values, each specifying\
    \ some of\n      the data values to retrieve.\n   Each StoredDataSpecifier specifies\
    \ a single Kind of data to retrieve\n   and, if appropriate, the subset of values\
    \ that are to be retrieved.\n   The contents of the StoredDataSpecifier structure\
    \ are as follows:\n   kind\n      The Kind-ID of the data being fetched.  Implementations\
    \ SHOULD\n      reject requests corresponding to unknown Kinds unless specifically\n\
    \      configured otherwise.\n   DataModel\n      The data model of the data.\
    \  This is not transmitted on the wire,\n      but comes from the definition of\
    \ the Kind.\n   generation\n      The last generation counter that the requesting\
    \ node saw.  This\n      may be used to avoid unnecessary fetches, or it may be\
    \ set to\n      zero.\n   length\n      The length of the rest of the structure,\
    \ thus allowing\n      extensibility.\n   model_specifier\n      A reference to\
    \ the data value being requested within the data\n      model specified for the\
    \ Kind.  For instance, if the data model is\n      \"array\", it might specify\
    \ some subset of the values.\n   The model_specifier is as follows:\n   o  If\
    \ the data model is single value, the specifier is empty.\n   o  If the data model\
    \ is array, the specifier contains a list of\n      ArrayRange elements, each\
    \ of which contains two integers.  The\n      first integer is the beginning of\
    \ the range, and the second is the\n      end of the range.  0 is used to indicate\
    \ the first element, and\n      0xffffffff is used to indicate the final element.\
    \  The first\n      integer MUST be less than or equal to the second.  While multiple\n\
    \      ranges MAY be specified, they MUST NOT overlap.\n   o  If the data model\
    \ is dictionary, then the specifier contains a\n      list of the dictionary keys\
    \ being requested.  If no keys are\n      specified, then this is a wildcard fetch\
    \ and all key-value pairs\n      are returned.\n   The generation counter is used\
    \ to indicate the requester's expected\n   state of the storing peer.  If the\
    \ generation counter in the request\n   matches the stored counter, then the storing\
    \ peer returns a response\n   with no StoredData values.\n"
- title: 7.4.2.2.  Response Definition
  contents:
  - "7.4.2.2.  Response Definition\n   The response to a successful Fetch request\
    \ is a FetchAns message\n   containing the data requested by the requester.\n\
    \         struct {\n           KindId                 kind;\n           uint64\
    \                 generation;\n           StoredData             values<0..2^32-1>;\n\
    \         } FetchKindResponse;\n         struct {\n           FetchKindResponse\
    \      kind_responses<0..2^32-1>;\n         } FetchAns;\n   The FetchAns structure\
    \ contains a series of FetchKindResponse\n   structures.  There MUST be one FetchKindResponse\
    \ element for each\n   Kind-ID in the request.\n   The contents of the FetchKindResponse\
    \ structure are as follows:\n   kind\n      The Kind that this structure is for.\n\
    \   generation\n      The generation counter for this Kind.\n   values\n     \
    \ The relevant values.  If the generation counter in the request\n      matches\
    \ the generation counter in the stored data, then no\n      StoredData values\
    \ are returned.  Otherwise, all relevant data\n      values MUST be returned.\
    \  A nonexistent value (i.e., one which the\n      node has no knowledge of) is\
    \ represented by a synthetic value with\n      \"exists\" set to False and has\
    \ an empty signature.  Specifically,\n      the identity_type is set to \"none\"\
    , the SignatureAndHashAlgorithm\n      values are set to {0, 0} (\"anonymous\"\
    \ and \"none\", respectively),\n      and the signature value is of zero length.\
    \  This removes the need\n      for the responding node to do signatures for values\
    \ which do not\n      exist.  These signatures are unnecessary, as the entire\
    \ response\n      is signed by that node.  Note that entries which have been removed\n\
    \      by the procedure given in Section 7.4.1.3 and which have not yet\n    \
    \  expired also have exists = False, but have valid signatures from\n      the\
    \ node which did the store.\n   Upon receipt of a FetchAns message, nodes MUST\
    \ verify the signatures\n   on all the received values.  Any values with invalid\
    \ signatures\n   (including expired certificates) MUST be discarded.  Note that\
    \ this\n   implies that implementations which wish to store data for long\n  \
    \ periods of time must have certificates with appropriate expiration\n   dates\
    \ or must re-store periodically.  Implementations MAY return the\n   subset of\
    \ values with valid signatures, but in that case, they SHOULD\n   somehow signal\
    \ to the application that a partial response was\n   received.\n   There is one\
    \ subtle point about signature computation on arrays.  If\n   the storing node\
    \ uses the append feature (where the\n   index=0xffffffff), then the index in\
    \ the StoredData that is returned\n   will not match that used by the storing\
    \ node, which would break the\n   signature.  In order to avoid this issue, the\
    \ index value in the\n   array is set to zero before the signature is computed.\
    \  This implies\n   that malicious storing nodes can reorder array entries without\
    \ being\n   detected.\n"
- title: 7.4.3.  Stat
  contents:
  - "7.4.3.  Stat\n   The Stat request is used to get metadata (length, generation\
    \ counter,\n   digest, etc.) for a stored element without retrieving the element\n\
    \   itself.  The name is from the UNIX stat(2) system call, which\n   performs\
    \ a similar function for files in a file system.  It also\n   allows the requesting\
    \ node to get a list of matching elements without\n   requesting the entire element.\n"
- title: 7.4.3.1.  Request Definition
  contents:
  - "7.4.3.1.  Request Definition\n   The Stat request is identical to the Fetch request.\
    \  It simply\n   specifies the elements to get metadata about.\n        struct\
    \ {\n          ResourceId              resource;\n          StoredDataSpecifier\
    \     specifiers<0..2^16-1>;\n        } StatReq;\n"
- title: 7.4.3.2.  Response Definition
  contents:
  - "7.4.3.2.  Response Definition\n   The Stat response contains the same sort of\
    \ entries that a Fetch\n   response would contain.  However, instead of containing\
    \ the element\n   data, it contains metadata.\n        struct {\n          Boolean\
    \                exists;\n          uint32                 value_length;\n   \
    \       HashAlgorithm          hash_algorithm;\n          opaque             \
    \    hash_value<0..255>;\n        } MetaData;\n        struct {\n          uint32\
    \                 index;\n          MetaData               value;\n        } ArrayEntryMeta;\n\
    \        struct {\n          DictionaryKey          key;\n          MetaData \
    \              value;\n        } DictionaryEntryMeta;\n        struct {\n    \
    \      select (DataModel) {\n            case single_value:\n              MetaData\
    \              single_value_entry;\n            case array:\n              ArrayEntryMeta\
    \        array_entry;\n            case dictionary:\n              DictionaryEntryMeta\
    \   dictionary_entry;\n            /* This structure may be extended */\n    \
    \      };\n        } MetaDataValue;\n        struct {\n          uint32      \
    \            value_length;\n          uint64                  storage_time;\n\
    \          uint32                  lifetime;\n          MetaDataValue        \
    \   metadata;\n        } StoredMetaData;\n        struct {\n          KindId \
    \                kind;\n          uint64                 generation;\n       \
    \   StoredMetaData         values<0..2^32-1>;\n        } StatKindResponse;\n \
    \       struct {\n          StatKindResponse      kind_responses<0..2^32-1>;\n\
    \        } StatAns;\n   The structures used in StatAns parallel those used in\
    \ FetchAns: a\n   response consists of multiple StatKindResponse values, one for\
    \ each\n   Kind that was in the request.  The contents of the StatKindResponse\n\
    \   are the same as those in the FetchKindResponse, except that the\n   values\
    \ list contains StoredMetaData entries instead of StoredData\n   entries.\n  \
    \ The contents of the StoredMetaData structure are the same as the\n   corresponding\
    \ fields in StoredData, except that there is no signature\n   field and the value\
    \ is a MetaDataValue rather than a StoredDataValue.\n   A MetaDataValue is a variant\
    \ structure, like a StoredDataValue,\n   except for the types of each arm, which\
    \ replace DataValue with\n   MetaData.\n   The only new structure is MetaData,\
    \ which has the following contents:\n   exists\n      Same as in DataValue.\n\
    \   value_length\n      The length of the stored value.\n   hash_algorithm\n \
    \     The hash algorithm used to perform the digest of the value.\n   hash_value\n\
    \      A digest using hash_algorithm on the value field of the DataValue,\n  \
    \    including its 4 leading length bytes.\n"
- title: 7.4.4.  Find
  contents:
  - "7.4.4.  Find\n   The Find request can be used to explore the Overlay Instance.\
    \  A Find\n   request for a Resource-ID R and a Kind-ID T retrieves the\n   Resource-ID,\
    \ if any, of the resource of Kind T known to the target\n   peer which is closest\
    \ to R.  This method can be used to walk the\n   Overlay Instance by iteratively\
    \ fetching R_n+1=nearest(1 + R_n).\n"
- title: 7.4.4.1.  Request Definition
  contents:
  - "7.4.4.1.  Request Definition\n   The FindReq message contains a Resource-ID and\
    \ a series of Kind-IDs\n   identifying the resource the peer is interested in.\n\
    \     struct {\n       ResourceId                 resource;\n       KindId   \
    \                  kinds<0..2^8-1>;\n     } FindReq;\n   The request contains\
    \ a list of Kind-IDs which the Find is for, as\n   indicated below:\n   resource\n\
    \      The desired Resource-ID.\n   kinds\n      The desired Kind-IDs.  Each value\
    \ MUST appear only once.\n      Otherwise, the request MUST be rejected with an\
    \ error.\n"
- title: 7.4.4.2.  Response Definition
  contents:
  - "7.4.4.2.  Response Definition\n   A response to a successful Find request is\
    \ a FindAns message\n   containing the closest Resource-ID on the peer for each\
    \ Kind\n   specified in the request.\n    struct {\n      KindId             \
    \         kind;\n      ResourceId                  closest;\n    } FindKindData;\n\
    \    struct {\n      FindKindData                results<0..2^16-1>;\n    } FindAns;\n\
    \   If the processing peer is not responsible for the specified\n   Resource-ID,\
    \ it SHOULD return an Error_Not_Found error code.\n   For each Kind-ID in the\
    \ request, the response MUST contain a\n   FindKindData indicating the closest\
    \ Resource-ID for that Kind-ID,\n   unless the Kind is not allowed to be used\
    \ with Find, in which case a\n   FindKindData for that Kind-ID MUST NOT be included\
    \ in the response.\n   If a Kind-ID is not known, then the corresponding Resource-ID\
    \ MUST be\n   0.  Note that different Kind-IDs may have different closest\n  \
    \ Resource-IDs.\n   The response is simply a series of FindKindData elements,\
    \ one per\n   Kind, concatenated end to end.  The contents of each element are:\n\
    \   kind\n      The Kind-ID.\n   closest\n      The closest Resource-ID to the\
    \ specified Resource-ID.  It is 0 if\n      no Resource-ID is known.\n   Note\
    \ that the response does not contain the contents of the data\n   stored at these\
    \ Resource-IDs.  If the requester wants this, it must\n   retrieve it using Fetch.\n"
- title: 7.4.5.  Defining New Kinds
  contents:
  - "7.4.5.  Defining New Kinds\n   There are two ways to define a new Kind.  The\
    \ first is by writing a\n   document and registering the Kind-ID with IANA.  This\
    \ is the\n   preferred method for Kinds which may be widely used and reused. \
    \ The\n   second method is to simply define the Kind and its parameters in the\n\
    \   Configuration Document using the section of Kind-ID space set aside\n   for\
    \ private use.  This method MAY be used to define ad hoc Kinds in\n   new overlays.\n\
    \   However a Kind is defined, the definition MUST include:\n   o  The meaning\
    \ of the data to be stored (in some textual form).\n   o  The Kind-ID.\n   o \
    \ The data model (single value, array, dictionary, etc.).\n   o  The access control\
    \ model.\n   In addition, when Kinds are registered with IANA, each Kind is\n\
    \   assigned a short string name which is used to refer to it in\n   Configuration\
    \ Documents.\n   While each Kind needs to define what data model is used for its\
    \ data,\n   this does not mean that it must define new data models.  Where\n \
    \  practical, Kinds should use the existing data models.  The intention\n   is\
    \ that the basic data model set be sufficient for most applications/\n   usages.\n"
- title: 8.  Certificate Store Usage
  contents:
  - "8.  Certificate Store Usage\n   The Certificate Store Usage allows a node to\
    \ store its certificate in\n   the overlay.\n   A user/node MUST store its certificate\
    \ at Resource-IDs derived from\n   two Resource Names:\n   o  The user name in\
    \ the certificate.\n   o  The Node-ID in the certificate.\n   Note that in the\
    \ second case, the certificate for a peer is not\n   stored at its Node-ID but\
    \ rather at a hash of its Node-ID.  The\n   intention here (as is common throughout\
    \ RELOAD) is to avoid making a\n   peer responsible for its own data.\n   New\
    \ certificates are stored at the end of the list.  This structure\n   allows users\
    \ to store an old and a new certificate that both have the\n   same Node-ID, which\
    \ allows for migration of certificates when they\n   are renewed.\n   This usage\
    \ defines the following Kinds:\n   Name:  CERTIFICATE_BY_NODE\n   Data Model:\
    \  The data model for CERTIFICATE_BY_NODE data is array.\n   Access Control: \
    \ NODE-MATCH\n   Name:  CERTIFICATE_BY_USER\n   Data Model:  The data model for\
    \ CERTIFICATE_BY_USER data is array.\n   Access Control:  USER-MATCH\n"
- title: 9.  TURN Server Usage
  contents:
  - "9.  TURN Server Usage\n   The TURN Server Usage allows a RELOAD peer to advertise\
    \ that it is\n   prepared to be a TURN server, as defined in [RFC5766].  When\
    \ a node\n   starts up, it joins the overlay network and forms several connections\n\
    \   in the process.  If the ICE stage in any of these connections returns\n  \
    \ a reflexive address that is not the same as the peer's perceived\n   address,\
    \ then the peer is behind a NAT and SHOULD NOT be a candidate\n   for a TURN server.\
    \  Additionally, if the peer's IP address is in the\n   private address space\
    \ range as defined by [RFC1918], then it is also\n   SHOULD NOT be a candidate\
    \ for a TURN server.  Otherwise, the peer\n   SHOULD assume that it is a potential\
    \ TURN server and follow the\n   procedures below.\n   If the node is a candidate\
    \ for a TURN server, it will insert some\n   pointers in the overlay so that other\
    \ peers can find it.  The overlay\n   configuration file specifies a turn-density\
    \ parameter that indicates\n   how many times each TURN server SHOULD record itself\
    \ in the overlay.\n   Typically, this should be set to the reciprocal of the estimate\
    \ of\n   what percentage of peers will act as TURN servers.  If the turn-\n  \
    \ density is not set to zero, for each value, called d, between 1 and\n   turn-density,\
    \ the peer forms a Resource Name by concatenating its\n   Node-ID and the value\
    \ d.  This Resource Name is hashed to form a\n   Resource-ID.  The address of\
    \ the peer is stored at that Resource-ID\n   using type TURN-SERVICE and the TurnServer\
    \ object:\n        struct {\n          uint8                   iteration;\n  \
    \        IpAddressPort           server_address;\n        } TurnServer;\n   The\
    \ contents of this structure are as follows:\n   iteration\n      The d value.\n\
    \   server_address\n      The address at which the TURN server can be contacted.\n\
    \   Note:  Correct functioning of this algorithm depends on having turn-\n   \
    \   density be a reasonable estimate of the reciprocal of the\n      proportion\
    \ of nodes in the overlay that can act as TURN servers.\n      If the turn-density\
    \ value in the configuration file is too low,\n      the process of finding TURN\
    \ servers becomes more expensive, as\n      multiple candidate Resource-IDs must\
    \ be probed to find a TURN\n      server.\n   Peers that provide this service\
    \ need to support the TURN extensions\n   to STUN for media relay, as defined\
    \ in [RFC5766].\n   This usage defines the following Kind to indicate that a peer\
    \ is\n   willing to act as a TURN server:\n   Name:  TURN-SERVICE\n   Data Model:\
    \  The TURN-SERVICE Kind stores a single value for each\n      Resource-ID.\n\
    \   Access Control:  NODE-MULTIPLE, with a maximum iteration of counter\n    \
    \  20.\n   Peers MAY find other servers by selecting a random Resource-ID and\n\
    \   then doing a Find request for the appropriate Kind-ID with that\n   Resource-ID.\
    \  The Find request gets routed to a random peer based on\n   the Resource-ID.\
    \  If that peer knows of any servers, they will be\n   returned.  The returned\
    \ response may be empty if the peer does not\n   know of any servers, in which\
    \ case the process gets repeated with\n   some other random Resource-ID.  As long\
    \ as the ratio of servers\n   relative to peers is not too low, this approach\
    \ will result in\n   finding a server relatively quickly.\n   Note to implementers:\
    \ The certificates used by TurnServer entries\n   need to be retained, as described\
    \ in Section 6.3.4.\n"
- title: 10.  Chord Algorithm
  contents:
  - "10.  Chord Algorithm\n   This algorithm is assigned the name CHORD-RELOAD to\
    \ indicate that it\n   is an adaptation of the basic Chord-based DHT algorithm.\n\
    \   This algorithm differs from the Chord algorithm that was originally\n   presented\
    \ in [Chord].  It has been updated based on more recent\n   research results and\
    \ implementation experiences, and to adapt it to\n   the RELOAD protocol.  Here\
    \ is a short list of differences:\n   o  The original Chord algorithm specified\
    \ that a single predecessor\n      and a successor list be stored.  The CHORD-RELOAD\
    \ algorithm\n      attempts to have more than one predecessor and successor. \
    \ The\n      predecessor sets help other neighbors learn their successor list.\n\
    \   o  The original Chord specification and analysis called for iterative\n  \
    \    routing.  RELOAD specifies recursive routing.  In addition to the\n     \
    \ performance implications, the cost of NAT traversal dictates\n      recursive\
    \ routing.\n   o  Finger Table entries are indexed in the opposite order.  Original\n\
    \      Chord specifies finger[0] as the immediate successor of the peer.\n   \
    \   CHORD-RELOAD specifies finger[0] as the peer 180 degrees around\n      the\
    \ ring from the peer.  This change was made to simplify\n      discussion and\
    \ implementation of variable-sized Finger Tables.\n      However, with either\
    \ approach, no more than O(log N) entries\n      should typically be stored in\
    \ a Finger Table.\n   o  The stabilize() and fix_fingers() algorithms in the original\
    \ Chord\n      algorithm are merged into a single periodic process.\n      Stabilization\
    \ is implemented slightly differently because of the\n      larger neighborhood,\
    \ and fix_fingers is not as aggressive to\n      reduce load, nor does it search\
    \ for optimal matches of the Finger\n      Table entries.\n   o  RELOAD allows\
    \ for a 128-bit hash instead of a 160-bit hash, as\n      RELOAD is not designed\
    \ to be used in networks with close to or\n      more than 2^128 nodes or objects\
    \ (and it is hard to see how one\n      would assemble such a network).\n   o\
    \  RELOAD uses randomized finger entries, as described in\n      Section 10.7.4.2.\n\
    \   o  The CHORD-RELOAD algorithm allows the use of either reactive or\n     \
    \ periodic recovery.  The original Chord paper used periodic\n      recovery.\
    \  Reactive recovery provides better performance in small\n      overlays, but\
    \ is believed to be unstable in large overlays\n      (greater than 1000) with\
    \ high levels of churn\n      [handling-churn-usenix04].  The overlay configuration\
    \ file\n      specifies a \"chord-reactive\" element that indicates whether\n\
    \      reactive recovery should be used.\n"
- title: 10.1.  Overview
  contents:
  - "10.1.  Overview\n   The algorithm described here, CHORD-RELOAD, is a modified\
    \ version of\n   the Chord algorithm.  In Chord (and in the algorithm described\
    \ here),\n   nodes are arranged in a ring, with node n being adjacent to nodes\
    \ n-1\n   and n+1 and with all arithmetic being done modulo 2^{k}, where k is\n\
    \   the length of the Node-ID in bits, so that node 2^{k} - 1 is directly\n  \
    \ before node 0.\n   Each peer keeps track of a Finger Table and a Neighbor Table.\
    \  The\n   Neighbor Table contains at least the three peers before and after\n\
    \   this peer in the DHT ring.  There may not be three entries in all\n   cases,\
    \ such as small rings or while the ring topology is changing.\n   The first entry\
    \ in the Finger Table contains the peer halfway around\n   the ring from this\
    \ peer, the second entry contains the peer that is\n   1/4th of the way around,\
    \ the third entry contains the peer that is\n   1/8th of the way around, and so\
    \ on.  Fundamentally, the Chord DHT can\n   be thought of as a doubly linked list\
    \ formed by knowing the\n   successors and predecessor peers in the Neighbor Table,\
    \ sorted by the\n   Node-ID.  As long as the successor peers are correct, the\
    \ DHT will\n   return the correct result.  The pointers to the prior peers are\
    \ kept\n   to enable the insertion of new peers into the list structure.\n   Keeping\
    \ multiple predecessor and successor pointers makes it possible\n   to maintain\
    \ the integrity of the data structure even when consecutive\n   peers simultaneously\
    \ fail.  The Finger Table forms a skip list\n   [wikiSkiplist] so that entries\
    \ in the linked list can be found in\n   O(log(N)) time instead of the typical\
    \ O(N) time that a linked list\n   would provide, where N represents the number\
    \ of nodes in the DHT.\n   The Neighbor Table and Finger Table entries contain\
    \ logical Node-IDs\n   as values, but the actual mapping of an IP level addressing\n\
    \   information to reach that Node-ID is kept in the Connection Table.\n   A peer,\
    \ x, is responsible for a particular Resource-ID, k, if k is\n   less than or\
    \ equal to x and k is greater than p, where p is the\n   Node-ID of the previous\
    \ peer in the Neighbor Table.  Care must be\n   taken when computing to note that\
    \ all math is modulo 2^128.\n"
- title: 10.2.  Hash Function
  contents:
  - "10.2.  Hash Function\n   For this Chord-based Topology Plug-in, the size of the\
    \ Resource-ID is\n   128 bits.  The hash of a Resource-ID MUST be computed using\
    \ SHA-1\n   [RFC3174], and then the SHA-1 result MUST be truncated to the most\n\
    \   significant 128 bits.\n"
- title: 10.3.  Routing
  contents:
  - "10.3.  Routing\n   The Routing Table is conceptually the union of the Neighbor\
    \ Table and\n   the Finger Table.\n   If a peer is not responsible for a Resource-ID\
    \ k, but is directly\n   connected to a node with Node-ID k, then it MUST route\
    \ the message to\n   that node.  Otherwise, it MUST route the request to the peer\
    \ in the\n   Routing Table that has the largest Node-ID that is in the interval\n\
    \   between the peer and k. If no such node is found, the peer finds the\n   smallest\
    \ Node-ID that is greater than k and MUST route the message to\n   that node.\n"
- title: 10.4.  Redundancy
  contents:
  - "10.4.  Redundancy\n   When a peer receives a Store request for Resource-ID k\
    \ and it is\n   responsible for Resource-ID k, it MUST store the data and return\
    \ a\n   success response.  It MUST then send a Store request to its successor\n\
    \   in the Neighbor Table and to that peer's successor, incrementing the\n   replica\
    \ number for each successor.  Note that these Store requests\n   are addressed\
    \ to those specific peers, even though the Resource-ID\n   they are being asked\
    \ to store is outside the range that they are\n   responsible for.  The peers\
    \ receiving these SHOULD check that they\n   came from an appropriate predecessor\
    \ in their Neighbor Table and that\n   they are in a range that this predecessor\
    \ is responsible for.  Then,\n   they MUST store the data.  They do not themselves\
    \ perform further\n   Stores, because they can determine that they are not responsible\
    \ for\n   the Resource-ID.\n   Note that this Topology Plug-in does not use the\
    \ replica number for\n   purposes other than knowing the difference between a\
    \ replica and a\n   non-replica.\n   Managing replicas as the overlay changes\
    \ is described in\n   Section 10.7.3.\n   The sequential replicas used in this\
    \ overlay algorithm protect\n   against peer failure but not against malicious\
    \ peers.  Additional\n   replication from the Usage is required to protect resources\
    \ from such\n   attacks, as discussed in Section 13.5.4.\n"
- title: 10.5.  Joining
  contents:
  - "10.5.  Joining\n   The join process for a Joining Node (JN) with Node-ID n is\
    \ as\n   follows:\n   1.  JN MUST connect to its chosen bootstrap node, as specified\
    \ in\n       Section 11.4.\n   2.  JN SHOULD send an Attach request to the Admitting\
    \ Peer (AP) for\n       Resource-ID n+1.  The \"send_update\" flag can be used\
    \ to acquire\n       the Routing Table of AP.\n   3.  JN SHOULD send Attach requests\
    \ to initiate connections to each of\n       the peers in the Neighbor Table as\
    \ well as to the desired peers\n       in the Finger Table.  Note that this does\
    \ not populate their\n       Routing Tables, but only their Connection Tables,\
    \ so JN will not\n       get messages that it is expected to route to other nodes.\n\
    \   4.  JN MUST enter into its Routing Table all the peers that it has\n     \
    \  successfully contacted.\n   5.  JN MUST send a Join to AP.  The AP MUST send\
    \ the response to the\n       Join.\n   6.  AP MUST do a series of Store requests\
    \ to JN to store the data\n       that JN will be responsible for.\n   7.  AP\
    \ MUST send JN an Update explicitly labeling JN as its\n       predecessor.  At\
    \ this point, JN is part of the ring and is\n       responsible for a section\
    \ of the overlay.  AP MAY now forget any\n       data which is assigned to JN\
    \ and not AP.  AP SHOULD NOT forget\n       any data where AP is the replica set\
    \ for the data.\n   8.  The AP MUST send an Update to all of its neighbors (including\
    \ JN)\n       with the new values of its neighbor set (including JN).\n   9. \
    \ JN MUST send Updates to all of the peers in its Neighbor Table.\n   If JN sends\
    \ an Attach to AP with send_update, it immediately knows\n   most of its expected\
    \ neighbors from AP's Routing Table update and MAY\n   directly connect to them.\
    \  This is the RECOMMENDED procedure.\n   If for some reason JN does not get AP's\
    \ Routing Table, it MAY still\n   populate its Neighbor Table incrementally. \
    \ It SHOULD send a Ping\n   directed at Resource-ID n+1 (directly after its own\
    \ Resource-ID).\n   This allows JN to discover its own successor.  Call that node\
    \ p0.  JN\n   then SHOULD send a Ping to p0+1 to discover its successor (p1).\
    \  This\n   process MAY be repeated to discover as many successors as desired.\n\
    \   The values for the two peers before p will be found at a later stage,\n  \
    \ when n receives an Update.  An alternate procedure is to send\n   Attaches to\
    \ those nodes rather than Pings, which form the connections\n   immediately, but\
    \ may be slower if the nodes need to collect ICE\n   candidates.\n   In order\
    \ to set up its i'th Finger Table entry, JN MUST send an\n   Attach to peer n+2^(128-i).\
    \  This will be routed to a peer in\n   approximately the right location around\
    \ the ring.  (Note that the\n   first entry in the Finger Table has i=1 and not\
    \ i=0 in this\n   formulation.)\n   The Joining Node MUST NOT send any Update\
    \ message placing itself in\n   the overlay until it has successfully completed\
    \ an Attach with each\n   peer that should be in its Neighbor Table.\n"
- title: 10.6.  Routing Attaches
  contents:
  - "10.6.  Routing Attaches\n   When a peer needs to Attach to a new peer in its\
    \ Neighbor Table, it\n   MUST source-route the Attach request through the peer\
    \ from which it\n   learned the new peer's Node-ID.  Source-routing these requests\
    \ allows\n   the overlay to recover from instability.\n   All other Attach requests,\
    \ such as those for new Finger\n   Table entries, are routed conventionally through\
    \ the overlay.\n"
- title: 10.7.  Updates
  contents:
  - "10.7.  Updates\n   An Update for this DHT is defined as:\n        enum { invalidChordUpdateType(0),\n\
    \               peer_ready(1), neighbors(2), full(3), (255) }\n             ChordUpdateType;\n\
    \        struct {\n           uint32                 uptime;\n           ChordUpdateType\
    \        type;\n           select (type){\n            case peer_ready:      \
    \             /* Empty */\n              ;\n            case neighbors:\n    \
    \          NodeId              predecessors<0..2^16-1>;\n              NodeId\
    \              successors<0..2^16-1>;\n            case full:\n              NodeId\
    \              predecessors<0..2^16-1>;\n              NodeId              successors<0..2^16-1>;\n\
    \              NodeId              fingers<0..2^16-1>;\n          };\n       \
    \ } ChordUpdate;\n   The \"uptime\" field contains the time this peer has been\
    \ up in\n   seconds.\n   The \"type\" field contains the type of the update, which\
    \ depends on\n   the reason the update was sent.\n   peer_ready\n      This peer\
    \ is ready to receive messages.  This message is used to\n      indicate that\
    \ a node which has Attached is a peer and can be\n      routed through.  It is\
    \ also used as a connectivity check to non-\n      neighbor peers.\n   neighbors\n\
    \      This version is sent to members of the Chord Neighbor Table.\n   full\n\
    \      This version is sent to peers which request an Update with a\n      RouteQueryReq.\n\
    \   If the message is of type \"neighbors\", then the contents of the\n   message\
    \ will be:\n   predecessors\n      The predecessor set of the Updating peer.\n\
    \   successors\n      The successor set of the Updating peer.\n   If the message\
    \ is of type \"full\", then the contents of the message\n   will be:\n   predecessors\n\
    \      The predecessor set of the Updating peer.\n   successors\n      The successor\
    \ set of the Updating peer.\n   fingers\n      The Finger Table of the Updating\
    \ peer, in numerically ascending\n      order.\n   A peer MUST maintain an association\
    \ (via Attach) to every member of\n   its neighbor set.  A peer MUST attempt to\
    \ maintain at least three\n   predecessors and three successors, even though this\
    \ will not be\n   possible if the ring is very small.  It is RECOMMENDED that\
    \ O(log(N))\n   predecessors and successors be maintained in the neighbor set.\
    \  There\n   are many ways to estimate N, some of which are discussed in\n   [DHT-RELOAD].\n"
- title: 10.7.1.  Handling Neighbor Failures
  contents:
  - "10.7.1.  Handling Neighbor Failures\n   Every time a connection to a peer in\
    \ the Neighbor Table is lost (as\n   determined by connectivity pings or the failure\
    \ of some request), the\n   peer MUST remove the entry from its Neighbor Table\
    \ and replace it\n   with the best match it has from the other peers in its Routing\
    \ Table.\n   If using reactive recovery, the peer MUST send an immediate Update\
    \ to\n   all nodes in its Neighbor Table.  The update will contain all the\n \
    \  Node-IDs of the current entries of the table (after the failed one\n   has\
    \ been removed).  Note that when replacing a successor, the peer\n   SHOULD delay\
    \ the creation of new replicas for the successor\n   replacement hold-down time\
    \ (30 seconds) after removing the failed\n   entry from its Neighbor Table in\
    \ order to allow a triggered update to\n   inform it of a better match for its\
    \ Neighbor Table.\n   If the neighbor failure affects the peer's range of responsible\
    \ IDs,\n   then the Update MUST be sent to all nodes in its Connection Table.\n\
    \   A peer MAY attempt to reestablish connectivity with a lost neighbor\n   either\
    \ by waiting additional time to see if connectivity returns or\n   by actively\
    \ routing a new Attach to the lost peer.  Details for these\n   procedures are\
    \ beyond the scope of this document.  In the case of an\n   attempt to reestablish\
    \ connectivity with a lost neighbor, the peer\n   MUST be removed from the Neighbor\
    \ Table.  Such a peer is returned to\n   the Neighbor Table once connectivity\
    \ is reestablished.\n   If connectivity is lost to all successor peers in the\
    \ Neighbor Table,\n   then this peer SHOULD behave as if it is joining the network\
    \ and MUST\n   use Pings to find a peer and send it a Join.  If connectivity is\
    \ lost\n   to all the peers in the Finger Table, this peer SHOULD assume that\
    \ it\n   has been disconnected from the rest of the network, and it SHOULD\n \
    \  periodically try to join the DHT.\n"
- title: 10.7.2.  Handling Finger Table Entry Failure
  contents:
  - "10.7.2.  Handling Finger Table Entry Failure\n   If a Finger Table entry is found\
    \ to have failed (as determined by\n   connectivity pings or the failure of some\
    \ request), all references to\n   the failed peer MUST be removed from the Finger\
    \ Table and replaced\n   with the closest preceding peer from the Finger Table\
    \ or Neighbor\n   Table.\n   If using reactive recovery, the peer MUST initiate\
    \ a search for a new\n   Finger Table entry, as described below.\n"
- title: 10.7.3.  Receiving Updates
  contents:
  - "10.7.3.  Receiving Updates\n   When a peer x receives an Update request, it examines\
    \ the Node-IDs in\n   the UpdateReq and at its Neighbor Table and decides if this\
    \ UpdateReq\n   would change its Neighbor Table.  This is done by taking the set\
    \ of\n   peers currently in the Neighbor Table and comparing them to the peers\n\
    \   in the Update request.  There are two major cases:\n   o  The UpdateReq contains\
    \ peers that match x's Neighbor Table, so no\n      change is needed to the neighbor\
    \ set.\n   o  The UpdateReq contains peers that x does not know about that\n \
    \     should be in x's Neighbor Table; i.e., they are closer than\n      entries\
    \ in the Neighbor Table.\n   In the first case, no change is needed.\n   In the\
    \ second case, x MUST attempt to Attach to the new peers, and if\n   it is successful,\
    \ it MUST adjust its neighbor set accordingly.  Note\n   that x can maintain the\
    \ now inferior peers as neighbors, but it MUST\n   remember the closer ones.\n\
    \   After any Pings and Attaches are done, if the Neighbor Table changes\n   and\
    \ the peer is using reactive recovery, the peer MUST send an Update\n   request\
    \ to each member of its Connection Table.  These Update\n   requests are what\
    \ end up filling in the predecessor/successor tables\n   of peers that this peer\
    \ is a neighbor to.  A peer MUST NOT enter\n   itself in its successor or predecessor\
    \ table and instead should leave\n   the entries empty.\n   If peer x is responsible\
    \ for a Resource-ID R and x discovers that the\n   replica set for R (the next\
    \ two nodes in its successor set) has\n   changed, it MUST send a Store for any\
    \ data associated with R to any\n   new node in the replica set.  It SHOULD NOT\
    \ delete data from peers\n   which have left the replica set.\n   When peer x\
    \ detects that it is no longer in the replica set for a\n   resource R (i.e.,\
    \ there are three predecessors between x and R), it\n   SHOULD delete all data\
    \ associated with R from its local store.\n   When a peer discovers that its range\
    \ of responsible IDs has changed,\n   it MUST send an Update to all entries in\
    \ its Connection Table.\n"
- title: 10.7.4.  Stabilization
  contents:
  - "10.7.4.  Stabilization\n   There are four components to stabilization:\n   1.\
    \  Exchange Updates with all peers in its Neighbor Table to exchange\n       state.\n\
    \   2.  Search for better peers to place in its Finger Table.\n   3.  Search to\
    \ determine if the current Finger Table size is\n       sufficiently large.\n\
    \   4.  Search to determine if the overlay has partitioned and needs to\n    \
    \   recover.\n"
- title: 10.7.4.1.  Updating the Neighbor Table
  contents:
  - "10.7.4.1.  Updating the Neighbor Table\n   A peer MUST periodically send an Update\
    \ request to every peer in its\n   Neighbor Table.  The purpose of this is to\
    \ keep the predecessor and\n   successor lists up to date and to detect failed\
    \ peers.  The default\n   time is about every ten minutes, but the configuration\
    \ server SHOULD\n   set this in the Configuration Document using the \"chord-update-\n\
    \   interval\" element (denominated in seconds).  A peer SHOULD randomly\n   offset\
    \ these Update requests so they do not occur all at once.\n"
- title: 10.7.4.2.  Refreshing the Finger Table
  contents:
  - "10.7.4.2.  Refreshing the Finger Table\n   A peer MUST periodically search for\
    \ new peers to replace invalid\n   entries in the Finger Table.  For peer x, the\
    \ i'th Finger Table entry\n   is valid if it is in the range [ x+2^( 128-i ),\n\
    \   x+2^( 128-(i-1) )-1 ].  Invalid entries occur in the Finger\n   Table when\
    \ a previous Finger Table entry has failed or when no peer\n   has been found\
    \ in that range.\n   Two possible methods for searching for new peers for the\
    \ Finger\n   Table entries are presented:\n   Alternative 1: A peer selects one\
    \ entry in the Finger Table from\n   among the invalid entries.  It pings for\
    \ a new peer for that Finger\n   Table entry.  The selection SHOULD be exponentially\
    \ weighted to\n   attempt to replace earlier (lower i) entries in the Finger Table.\
    \  A\n   simple way to implement this selection is to search through the\n   Finger\
    \ Table entries from i=1, and each time an invalid entry is\n   encountered, send\
    \ a Ping to replace that entry with probability 0.5.\n   Alternative 2: A peer\
    \ monitors the Update messages received from its\n   connections to observe when\
    \ an Update indicates a peer that would be\n   used to replace an invalid Finger\
    \ Table entry, i, and flags that\n   entry in the Finger Table.  Every \"chord-ping-interval\"\
    \ seconds, the\n   peer selects from among those flagged candidates using an\n\
    \   exponentially weighted probability, as above.\n   When searching for a better\
    \ entry, the peer SHOULD send the Ping to a\n   Node-ID selected randomly from\
    \ that range.  Random selection is\n   preferred over a search for strictly spaced\
    \ entries to minimize the\n   effect of churn on overlay routing [minimizing-churn-sigcomm06].\
    \  An\n   implementation or subsequent specification MAY choose a method for\n\
    \   selecting Finger Table entries other than choosing randomly within\n   the\
    \ range.  Any such alternate methods SHOULD be employed only on\n   Finger Table\
    \ stabilization and not for the selection of initial\n   Finger Table entries\
    \ unless the alternative method is faster and\n   imposes less overhead on the\
    \ overlay.\n   A peer SHOULD NOT send Ping requests looking for new finger table\n\
    \   entries more often than the configuration element \"chord-ping-\n   interval\"\
    , which defaults to 3600 seconds (one per hour).\n   A peer MAY choose to keep\
    \ connections to multiple peers that can act\n   for a given Finger Table entry.\n"
- title: 10.7.4.3.  Adjusting Finger Table Size
  contents:
  - "10.7.4.3.  Adjusting Finger Table Size\n   If the Finger Table has fewer than\
    \ 16 entries, the node SHOULD\n   attempt to discover more fingers to grow the\
    \ size of the table to 16.\n   The value 16 was chosen to ensure high odds of\
    \ a node maintaining\n   connectivity to the overlay even with strange network\
    \ partitions.\n   For many overlays, 16 Finger Table entries will be enough, but\
    \ as an\n   overlay grows very large, more than 16 entries may be required in\
    \ the\n   Finger Table for efficient routing.  An implementation SHOULD be\n \
    \  capable of increasing the number of entries in the Finger Table to\n   128\
    \ entries.\n   Although log(N) entries are all that are required for optimal\n\
    \   performance, careful implementation of stabilization will result in\n   no\
    \ additional traffic being generated when maintaining a Finger\n   Table larger\
    \ than log(N) entries.  Implementers are encouraged to\n   make use of RouteQuery\
    \ and algorithms for determining where new\n   Finger Table entries may be found.\
    \  Complete details of possible\n   implementations are outside the scope of this\
    \ specification.\n   A simple approach to sizing the Finger Table is to ensure\
    \ that the\n   Finger Table is large enough to contain at least the final successor\n\
    \   in the peer's Neighbor Table.\n"
- title: 10.7.4.4.  Detecting Partitioning
  contents:
  - "10.7.4.4.  Detecting Partitioning\n   To detect that a partitioning has occurred\
    \ and to heal the overlay, a\n   peer P MUST periodically repeat the discovery\
    \ process used in the\n   initial join for the overlay to locate an appropriate\
    \ bootstrap node,\n   B.  P SHOULD then send a Ping for its own Node-ID routed\
    \ through B.\n   If a response is received from peer S', which is not P's successor,\n\
    \   then the overlay is partitioned and P SHOULD send an Attach to S'\n   routed\
    \ through B, followed by an Update sent to S'.  (Note that S'\n   may not be in\
    \ P's Neighbor Table once the overlay is healed, but the\n   connection will allow\
    \ S' to discover appropriate neighbor entries for\n   itself via its own stabilization.)\n\
    \   Future specifications may describe alternative mechanisms for\n   determining\
    \ when to repeat the discovery process.\n"
- title: 10.8.  Route Query f.in 3
  contents:
  - "10.8.  Route Query f.in 3\n       For CHORD-RELOAD, the RouteQueryReq contains\
    \ no additional\n       information.  The RouteQueryAns contains the single Node-ID\
    \ of\n       the next peer to which the responding peer would have routed the\n\
    \       request message in recursive routing:\n      struct {\n         NodeId\
    \                  next_peer;\n      } ChordRouteQueryAns;\n   The contents of\
    \ this structure are as follows:\n   next_peer\n      The peer to which the responding\
    \ peer would route the message in\n      order to deliver it to the destination\
    \ listed in the request.\n   If the requester has set the send_update flag, the\
    \ responder SHOULD\n   initiate an Update immediately after sending the RouteQueryAns.\n"
- title: 10.9.  Leaving
  contents:
  - "10.9.  Leaving\n   To support extensions, such as [DHT-RELOAD], peers SHOULD\
    \ send a\n   Leave request to all members of their Neighbor Table before exiting\n\
    \   the Overlay Instance.  The overlay_specific_data field MUST contain\n   the\
    \ ChordLeaveData structure, defined below:\n              enum { invalidChordLeaveType(0),\n\
    \                      from_succ(1), from_pred(2), (255) }\n                 \
    \   ChordLeaveType;\n               struct {\n                 ChordLeaveType\
    \         type;\n                  select (type) {\n                    case from_succ:\n\
    \                      NodeId            successors<0..2^16-1>;\n            \
    \        case from_pred:\n                      NodeId           predecessors<0..2^16-1>;\n\
    \                  };\n               } ChordLeaveData;\n   The \"type\" field\
    \ indicates whether the Leave request was sent by a\n   predecessor or a successor\
    \ of the recipient:\n   from_succ\n      The Leave request was sent by a successor.\n\
    \   from_pred\n      The Leave request was sent by a predecessor.\n   If the type\
    \ of the request is \"from_succ\", the contents will be:\n   successors\n    \
    \  The sender's successor list.\n   If the type of the request is \"from_pred\"\
    , the contents will be:\n   predecessors\n      The sender's predecessor list.\n\
    \   Any peer which receives a Leave for a peer n in its neighbor set MUST\n  \
    \ follow procedures as if it had detected a peer failure as described\n   in Section\
    \ 10.7.1.\n"
- title: 11.  Enrollment and Bootstrap
  contents:
  - "11.  Enrollment and Bootstrap\n   The section defines the format of the configuration\
    \ data as well the\n   process to join a new overlay.\n"
- title: 11.1.  Overlay Configuration
  contents:
  - "11.1.  Overlay Configuration\n   This specification defines a new content type\n\
    \   \"application/p2p-overlay+xml\" for a MIME entity that contains overlay\n\
    \   information.  An example document is shown below:\n   <?xml version=\"1.0\"\
    \ encoding=\"UTF-8\"?>\n   <overlay xmlns=\"urn:ietf:params:xml:ns:p2p:config-base\"\
    \n      xmlns:ext=\"urn:ietf:params:xml:ns:p2p:config-ext1\"\n      xmlns:chord=\"\
    urn:ietf:params:xml:ns:p2p:config-chord\">\n      <configuration instance-name=\"\
    overlay.example.org\" sequence=\"22\"\n          expiration=\"2002-10-10T07:00:00Z\"\
    \ ext:ext-example=\"stuff\" >\n          <topology-plugin> CHORD-RELOAD </topology-plugin>\n\
    \          <node-id-length>16</node-id-length>\n          <root-cert>\n   MIIDJDCCAo2gAwIBAgIBADANBgkqhkiG9w0BAQUFADBwMQswCQYDVQQGEwJVUzET\n\
    \   MBEGA1UECBMKQ2FsaWZvcm5pYTERMA8GA1UEBxMIU2FuIEpvc2UxDjAMBgNVBAoT\n   BXNpcGl0MSkwJwYDVQQLEyBTaXBpdCBUZXN0IENlcnRpZmljYXRlIEF1dGhvcml0\n\
    \   eTAeFw0wMzA3MTgxMjIxNTJaFw0xMzA3MTUxMjIxNTJaMHAxCzAJBgNVBAYTAlVT\n   MRMwEQYDVQQIEwpDYWxpZm9ybmlhMREwDwYDVQQHEwhTYW4gSm9zZTEOMAwGA1UE\n\
    \   ChMFc2lwaXQxKTAnBgNVBAsTIFNpcGl0IFRlc3QgQ2VydGlmaWNhdGUgQXV0aG9y\n   aXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDIh6DkcUDLDyK9BEUxkud\n\
    \   +nJ4xrCVGKfgjHm6XaSuHiEtnfELHM+9WymzkBNzZpJu30yzsxwfKoIKugdNUrD4\n   N3viCicwcN35LgP/KnbN34cavXHr4ZlqxH+OdKB3hQTpQa38A7YXdaoz6goW2ft5\n\
    \   Mi74z03GNKP/G9BoKOGd5QIDAQABo4HNMIHKMB0GA1UdDgQWBBRrRhcU6pR2JYBU\n   bhNU2qHjVBShtjCBmgYDVR0jBIGSMIGPgBRrRhcU6pR2JYBUbhNU2qHjVBShtqF0\n\
    \   pHIwcDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExETAPBgNVBAcT\n   CFNhbiBKb3NlMQ4wDAYDVQQKEwVzaXBpdDEpMCcGA1UECxMgU2lwaXQgVGVzdCBD\n\
    \   ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0B\n   AQUFAAOBgQCWbRvv1ZGTRXxbH8/EqkdSCzSoUPrs+rQqR0xdQac9wNY/nlZbkR3O\n\
    \   qAezG6Sfmklvf+DOg5RxQq/+Y6I03LRepc7KeVDpaplMFGnpfKsibETMipwzayNQ\n   QgUf4cKBiF+65Ue7hZuDJa2EMv8qW4twEhGDYclpFU9YozyS1OhvUg==\n\
    \          </root-cert>\n          <root-cert> YmFkIGNlcnQK </root-cert>\n   \
    \       <enrollment-server>https://example.org</enrollment-server>\n         \
    \ <enrollment-server>https://example.net</enrollment-server>\n          <self-signed-permitted\n\
    \                    digest=\"sha1\">false</self-signed-permitted>\n         \
    \ <bootstrap-node address=\"192.0.0.1\" port=\"6084\" />\n          <bootstrap-node\
    \ address=\"192.0.2.2\" port=\"6084\" />\n          <bootstrap-node address=\"\
    2001:DB8::1\" port=\"6084\" />\n          <turn-density> 20 </turn-density>\n\
    \          <clients-permitted> false </clients-permitted>\n          <no-ice>\
    \ false </no-ice>\n          <chord:chord-update-interval>\n              400</chord:chord-update-interval>\n\
    \          <chord:chord-ping-interval>30</chord:chord-ping-interval>\n       \
    \   <chord:chord-reactive> true </chord:chord-reactive>\n          <shared-secret>\
    \ password </shared-secret>\n          <max-message-size>4000</max-message-size>\n\
    \          <initial-ttl> 30 </initial-ttl>\n          <overlay-reliability-timer>\
    \ 3000 </overlay-reliability-timer>\n          <overlay-link-protocol>TLS</overlay-link-protocol>\n\
    \          <configuration-signer>47112162e84c69ba</configuration-signer>\n   \
    \       <kind-signer> 47112162e84c69ba </kind-signer>\n          <kind-signer>\
    \ 6eba45d31a900c06 </kind-signer>\n          <bad-node> 6ebc45d31a900c06 </bad-node>\n\
    \          <bad-node> 6ebc45d31a900ca6 </bad-node>\n          <ext:example-extension>\
    \ foo </ext:example-extension>\n          <mandatory-extension>\n            \
    \  urn:ietf:params:xml:ns:p2p:config-ext1\n          </mandatory-extension>\n\
    \          <required-kinds>\n            <kind-block>\n              <kind name=\"\
    SIP-REGISTRATION\">\n                  <data-model>SINGLE</data-model>\n     \
    \             <access-control>USER-MATCH</access-control>\n                  <max-count>1</max-count>\n\
    \                  <max-size>100</max-size>\n              </kind>\n         \
    \     <kind-signature>\n                   VGhpcyBpcyBub3QgcmlnaHQhCg==\n    \
    \          </kind-signature>\n            </kind-block>\n            <kind-block>\n\
    \              <kind id=\"2000\">\n                  <data-model>ARRAY</data-model>\n\
    \                  <access-control>NODE-MULTIPLE</access-control>\n          \
    \        <max-node-multiple>3</max-node-multiple>\n                  <max-count>22</max-count>\n\
    \                  <max-size>4</max-size>\n                  <ext:example-kind-extension>\
    \ 1\n                          </ext:example-kind-extension>\n              </kind>\n\
    \              <kind-signature>\n                 VGhpcyBpcyBub3QgcmlnaHQhCg==\n\
    \              </kind-signature>\n            </kind-block>\n          </required-kinds>\n\
    \      </configuration>\n      <signature> VGhpcyBpcyBub3QgcmlnaHQhCg== </signature>\n\
    \      <configuration instance-name=\"other.example.net\">\n      </configuration>\n\
    \      <signature> VGhpcyBpcyBub3QgcmlnaHQhCg== </signature>\n    </overlay>\n\
    \   The file MUST be a well-formed XML document, and it SHOULD contain an\n  \
    \ encoding declaration in the XML declaration.  The file MUST use the\n   UTF-8\
    \ character encoding.  The namespaces for the elements defined in\n   this specification\
    \ are urn:ietf:params:xml:ns:p2p:config-base and\n   urn:ietf:params:xml:ns:p2p:config-chord.\n\
    \   Note that elements or attributes that are defined as type xsd:boolean\n  \
    \ in the RELAX NG schema (Section 11.1.1) have two lexical\n   representations,\
    \ \"1\" or \"true\" for the concept true, and \"0\" or\n   \"false\" for the concept\
    \ false.  Whitespace and case processing\n   follows the rules of [OASIS.relax_ng]\
    \ and XML Schema Datatypes\n   [W3C.REC-xmlschema-2-20041028].\n   The file MAY\
    \ contain multiple \"configuration\" elements, where each\n   one contains the\
    \ configuration information for a different overlay.\n   Each configuration element\
    \ MAY be followed by signature elements that\n   provide a signature over the\
    \ preceding configuration element.  Each\n   configuration element has the following\
    \ attributes:\n   instance-name\n      The name of the overlay (referred to as\
    \ \"overlay name\" in this\n      specification)\n   expiration\n      Time in\
    \ the future at which this overlay configuration is no\n      longer valid.  The\
    \ node SHOULD retrieve a new copy of the\n      configuration at a randomly selected\
    \ time that is before the\n      expiration time.  Note that if the certificates\
    \ expire before a\n      new configuration is retried, the node will not be able\
    \ to\n      validate the configuration file.  All times MUST conform to the\n\
    \      Internet date/time format defined in [RFC3339] and be specified\n     \
    \ using UTC.\n   sequence\n      A monotonically increasing sequence number between\
    \ 0 and 2^16-2.\n   Inside each overlay element, the following elements can occur:\n\
    \   topology-plug-in\n      This element defines the overlay algorithm being used.\
    \  If\n      missing, the default is \"CHORD-RELOAD\".\n   node-id-length\n  \
    \    This element contains the length of a NodeId (NodeIdLength), in\n      bytes.\
    \  This value MUST be between 16 (128 bits) and 20 (160\n      bits).  If this\
    \ element is not present, the default of 16 is used.\n   root-cert\n      This\
    \ element contains a base-64-encoded X.509v3 certificate that\n      is a root\
    \ trust anchor used to sign all certificates in this\n      overlay.  There can\
    \ be more than one root-cert element.\n   enrollment-server\n      This element\
    \ contains the URL at which the enrollment server can\n      be reached in a \"\
    url\" element.  This URL MUST be of type \"https:\".\n      More than one enrollment-server\
    \ element MAY be present.  Note that\n      there is no necessary relationship\
    \ between the overlay name/\n      configuration server name and the enrollment\
    \ server name.\n   self-signed-permitted\n      This element indicates whether\
    \ self-signed certificates are\n      permitted.  If it is set to \"true\", then\
    \ self-signed certificates\n      are allowed, in which case the enrollment-server\
    \ and root-cert\n      elements MAY be absent.  Otherwise, it SHOULD be absent,\
    \ but MAY\n      be set to \"false\".  This element also contains an attribute\n\
    \      \"digest\", which indicates the digest to be used to compute the\n    \
    \  Node-ID.  Valid values for this parameter are \"sha1\" and \"sha256\",\n  \
    \    representing SHA-1 [RFC3174] and SHA-256 [RFC6234], respectively.\n     \
    \ Implementations MUST support both of these algorithms.\n   bootstrap-node\n\
    \      This element represents the address of one of the bootstrap nodes.\n  \
    \    It has an attribute called \"address\" that represents the IP\n      address\
    \ (either IPv4 or IPv6, since they can be distinguished) and\n      an optional\
    \ attribute called \"port\" that represents the port and\n      defaults to 6084.\
    \  The IPv6 address is in typical hexadecimal form\n      using standard period\
    \ and colon separators as specified in\n      [RFC5952].  More than one bootstrap-node\
    \ element MAY be present.\n   turn-density\n      This element is a positive integer\
    \ that represents the approximate\n      reciprocal of density of nodes that can\
    \ act as TURN servers.  For\n      example, if 5% of the nodes can act as TURN\
    \ servers, this element\n      would be set to 20.  If it is not present, the\
    \ default value is 1.\n      If there are no TURN servers in the overlay, it is\
    \ set to zero.\n   clients-permitted\n      This element represents whether clients\
    \ are permitted or whether\n      all nodes must be peers.  If clients are permitted,\
    \ the element\n      MUST be set to \"true\" or be absent.  If the nodes are not\
    \ allowed\n      to remain clients after the initial join, the element MUST be\
    \ set\n      to \"false\".  There is currently no way for the overlay to enforce\n\
    \      this.\n   no-ice\n      This element represents whether nodes are REQUIRED\
    \ to use the\n      \"No-ICE\" Overlay Link protocols in this overlay.  If it\
    \ is absent,\n      it is treated as if it were set to \"false\".\n   chord-update-interval\n\
    \      The update frequency for the CHORD-RELOAD Topology Plug-in (see\n     \
    \ Section 10).\n   chord-ping-interval\n      The Ping frequency for the CHORD-RELOAD\
    \ Topology Plug-in (see\n      Section 10).\n   chord-reactive\n      Whether\
    \ reactive recovery SHOULD be used for this overlay.  It is\n      set to \"true\"\
    \ or \"false\".  If missing, the default is \"true\" (see\n      Section 10).\n\
    \   shared-secret\n      If shared secret mode is used, this element contains\
    \ the shared\n      secret.  The security guarantee here is that any agent which\
    \ is\n      able to access the Configuration Document (presumably protected by\n\
    \      some sort of HTTP access control or network topology) is able to\n    \
    \  recover the shared secret and hence join the overlay.\n   max-message-size\n\
    \      Maximum size, in bytes, of any message in the overlay.  If this\n     \
    \ value is not present, the default is 5000.\n   initial-ttl\n      Initial default\
    \ TTL for messages (see Section 6.3.2).  If this\n      value is not present,\
    \ the default is 100.\n   overlay-reliability-timer\n      Default value for the\
    \ end-to-end retransmission timer for\n      messages, in milliseconds.  If not\
    \ present, the default value is\n      3000.  The value MUST be at least 200 milliseconds,\
    \ which means\n      the minimum time delay before dropping a link is 1000\n \
    \     milliseconds.\n   overlay-link-protocol\n      Indicates a permissible overlay\
    \ link protocol (see Section 6.6.1\n      for requirements for such protocols).\
    \  An arbitrary number of\n      these elements may appear.  If none appear, then\
    \ this implies the\n      default value, \"TLS\", which refers to the use of TLS\
    \ and DTLS.  If\n      one or more elements appear, then no default value applies.\n\
    \   kind-signer\n      This contains a single Node-ID in hexadecimal and indicates\
    \ that\n      the certificate with this Node-ID is allowed to sign Kinds.\n  \
    \    Identifying kind-signer by Node-ID instead of certificate allows\n      the\
    \ use of short-lived certificates without constantly having to\n      provide\
    \ an updated configuration file.\n   configuration-signer\n      This contains\
    \ a single Node-ID in hexadecimal and indicates that\n      the certificate with\
    \ this Node-ID is allowed to sign\n      configurations for this instance-name.\
    \  Identifying the signer by\n      Node-ID instead of certificate allows the\
    \ use of short-lived\n      certificates without constantly having to provide\
    \ an updated\n      configuration file.\n   bad-node\n      This contains a single\
    \ Node-ID in hexadecimal and indicates that\n      the certificate with this Node-ID\
    \ MUST NOT be considered valid.\n      This allows certificate revocation.  An\
    \ arbitrary number of these\n      elements can be provided.  Note that because\
    \ certificates may\n      expire, bad-node entries need be present only for the\
    \ lifetime of\n      the certificate.  Technically speaking, bad Node-IDs may\
    \ be reused\n      after their certificates have expired.  The requirement for\n\
    \      Node-IDs to be pseudorandomly generated gives this event a\n      vanishing\
    \ probability.\n   mandatory-extension\n      This element contains the name of\
    \ an XML namespace that a node\n      joining the overlay MUST support.  The presence\
    \ of a mandatory-\n      extension element does not require the extension to be\
    \ used in the\n      current configuration file, but can indicate that it may\
    \ be used\n      in the future.  Note that the namespace is case-sensitive, as\n\
    \      specified in Section 2.3 of [w3c-xml-namespaces].  More than one\n    \
    \  mandatory-extension element MAY be present.\n   Inside each configuration element,\
    \ the required-kinds element MAY\n   also occur.  This element indicates the Kinds\
    \ that members MUST\n   support and contains multiple kind-block elements that\
    \ each define a\n   single Kind that MUST be supported by nodes in the overlay.\
    \  Each\n   kind-block consists of a single kind element and a kind-signature.\n\
    \   The kind element defines the Kind.  The kind-signature is the\n   signature\
    \ computed over the kind element.\n   Each kind element has either an id attribute\
    \ or a name attribute.\n   The name attribute is a string representing the Kind\
    \ (the name\n   registered to IANA), while the id is an integer Kind-ID allocated\
    \ out\n   of private space.\n   In addition, the kind element MUST contain the\
    \ following elements:\n   max-count\n      The maximum number of values which\
    \ members of the overlay must\n      support.\n   data-model\n      The data model\
    \ to be used.\n   max-size\n      The maximum size of individual values.\n   access-control\n\
    \      The access control model to be used.\n   The kind element MAY also contain\
    \ the following element:\n   max-node-multiple\n      If the access control is\
    \ NODE-MULTIPLE, this element MUST be\n      included.  This indicates the maximum\
    \ value for the i counter.  It\n      MUST be an integer greater than 0.\n   All\
    \ of the non-optional values MUST be provided.  If the Kind is\n   registered\
    \ with IANA, the data-model and access-control elements MUST\n   match those in\
    \ the Kind registration, and clients MUST ignore them in\n   favor of the IANA\
    \ versions.  Multiple kind-block elements MAY be\n   present.\n   The kind-block\
    \ element also MUST contain a \"kind-signature\" element.\n   This signature is\
    \ computed across the kind element from the beginning\n   of the first < of the\
    \ kind element to the end of the last > of the\n   kind element in the same way\
    \ as the signature element described later\n   in this section. kind-block elements\
    \ MUST be signed by a node listed\n   in the kind-signers block of the current\
    \ configuration.  Receivers\n   MUST verify the signature prior to accepting a\
    \ kind-block.\n   The configuration element MUST be treated as a binary blob that\n\
    \   cannot be changed -- including any whitespace changes -- or the\n   signature\
    \ will break.  The signature MUST be computed by taking each\n   configuration\
    \ element and starting from, and including, the first <\n   at the start of <configuration>\
    \ up to and including the > in </\n   configuration> and treating this as a binary\
    \ blob that MUST be signed\n   using the standard SecurityBlock defined in Section\
    \ 6.3.4.  The\n   SecurityBlock MUST be base-64 encoded using the base64 alphabet\
    \ from\n   [RFC4648] and MUST be put in the signature element following the\n\
    \   configuration object in the configuration file.  Any configuration\n   file\
    \ MUST be signed by one of the configuration-signer elements from\n   the previous\
    \ extant configuration.  Recipients MUST verify the\n   signature prior to accepting\
    \ the configuration file.\n   When a node receives a new configuration file, it\
    \ MUST change its\n   configuration to meet the new requirements.  This may require\
    \ the\n   node to exit the DHT and rejoin.  If a node is not capable of\n   supporting\
    \ the new requirements, it MUST exit the overlay.  If some\n   information about\
    \ a particular Kind changes from what the node\n   previously knew about the Kind\
    \ (for example, the max size), the new\n   information in the configuration files\
    \ overrides any previously\n   learned information.  If any Kind data was signed\
    \ by a node that is\n   no longer allowed to sign Kinds, that Kind MUST be discarded\
    \ along\n   with any stored information of that Kind.  Note that forcing an\n\
    \   avalanche restart of the overlay with a configuration change that\n   requires\
    \ rejoining the overlay may result in serious performance\n   problems, including\
    \ total collapse of the network if configuration\n   parameters are not properly\
    \ considered.  Such an event may be\n   necessary in case of a compromised CA\
    \ or similar problem, but for\n   large overlays, it should be avoided in almost\
    \ all circumstances.\n"
- title: 11.1.1.  RELAX NG Grammar
  contents:
  - "11.1.1.  RELAX NG Grammar\n   The grammar for the configuration data is:\n  \
    \ namespace chord = \"urn:ietf:params:xml:ns:p2p:config-chord\"\n   namespace\
    \ local = \"\"\n   default namespace p2pcf = \"urn:ietf:params:xml:ns:p2p:config-base\"\
    \n   namespace rng = \"http://relaxng.org/ns/structure/1.0\"\n   anything =\n\
    \       (element * { anything }\n        | attribute * { text }\n        | text)*\n\
    \   foreign-elements = element * - (p2pcf:* | local:* | chord:*)\n           \
    \           { anything }*\n   foreign-attributes = attribute * - (p2pcf:*|local:*|chord:*)\n\
    \                        { text }*\n   foreign-nodes = (foreign-attributes | foreign-elements)*\n\
    \   start =  element p2pcf:overlay {\n         overlay-element\n   }\n   overlay-element\
    \ &=  element configuration {\n               attribute instance-name { xsd:string\
    \ },\n               attribute expiration { xsd:dateTime }?,\n               attribute\
    \ sequence { xsd:long }?,\n               foreign-attributes*,\n             \
    \  parameter\n           }+\n   overlay-element &= element signature {\n     \
    \          attribute algorithm { signature-algorithm-type }?,\n              \
    \ xsd:base64Binary\n           }*\n   signature-algorithm-type |= \"rsa-sha1\"\
    \n   signature-algorithm-type |=  xsd:string # signature alg extensions\n   parameter\
    \ &= element topology-plugin { topology-plugin-type }?\n   topology-plugin-type\
    \ |= xsd:string # topo plugin extensions\n   parameter &= element max-message-size\
    \ { xsd:unsignedInt }?\n   parameter &= element initial-ttl { xsd:int }?\n   parameter\
    \ &= element root-cert { xsd:base64Binary }*\n   parameter &= element required-kinds\
    \ { kind-block* }?\n   parameter &= element enrollment-server { xsd:anyURI }*\n\
    \   parameter &= element kind-signer {  xsd:string }*\n   parameter &= element\
    \ configuration-signer {  xsd:string }*\n   parameter &= element bad-node {  xsd:string\
    \ }*\n   parameter &= element no-ice { xsd:boolean }?\n   parameter &= element\
    \ shared-secret { xsd:string }?\n   parameter &= element overlay-link-protocol\
    \ { xsd:string }*\n   parameter &= element clients-permitted { xsd:boolean }?\n\
    \   parameter &= element turn-density { xsd:unsignedByte }?\n   parameter &= element\
    \ node-id-length { xsd:int }?\n   parameter &= element mandatory-extension { xsd:string\
    \ }*\n   parameter &= foreign-elements*\n   parameter &=\n       element self-signed-permitted\
    \ {\n           attribute digest { self-signed-digest-type },\n           xsd:boolean\n\
    \       }?\n   self-signed-digest-type |= \"sha1\"\n   self-signed-digest-type\
    \ |=  xsd:string # signature digest extensions\n   parameter &= element bootstrap-node\
    \ {\n                   attribute address { xsd:string },\n                  \
    \ attribute port { xsd:int }?\n                }*\n   kind-block = element kind-block\
    \ {\n       element kind {\n           (  attribute name { kind-names }\n    \
    \          | attribute id { xsd:unsignedInt } ),\n           kind-parameter\n\
    \       } &\n       element kind-signature  {\n           attribute algorithm\
    \ { signature-algorithm-type }?,\n           xsd:base64Binary\n       }?\n   }\n\
    \   kind-parameter &= element max-count { xsd:int }\n   kind-parameter &= element\
    \ max-size { xsd:int }\n   kind-parameter &= element max-node-multiple { xsd:int\
    \ }?\n   kind-parameter &= element data-model { data-model-type }\n   data-model-type\
    \ |= \"SINGLE\"\n   data-model-type |= \"ARRAY\"\n   data-model-type |= \"DICTIONARY\"\
    \n   data-model-type |=  xsd:string # data model extensions\n   kind-parameter\
    \ &= element access-control { access-control-type }\n   access-control-type |=\
    \ \"USER-MATCH\"\n   access-control-type |= \"NODE-MATCH\"\n   access-control-type\
    \ |= \"USER-NODE-MATCH\"\n   access-control-type |= \"NODE-MULTIPLE\"\n   access-control-type\
    \ |= xsd:string # access control extensions\n   kind-parameter &= foreign-elements*\n\
    \   kind-names |= \"TURN-SERVICE\"\n   kind-names |= \"CERTIFICATE_BY_NODE\"\n\
    \   kind-names |= \"CERTIFICATE_BY_USER\"\n   kind-names |= xsd:string # kind\
    \ extensions\n   # Chord specific parameters\n   topology-plugin-type |= \"CHORD-RELOAD\"\
    \n   parameter &= element chord:chord-ping-interval { xsd:int }?\n   parameter\
    \ &= element chord:chord-update-interval { xsd:int }?\n   parameter &= element\
    \ chord:chord-reactive { xsd:boolean }?\n"
- title: 11.2.  Discovery through Configuration Server
  contents:
  - "11.2.  Discovery through Configuration Server\n   When a node first enrolls in\
    \ a new overlay, it starts with a\n   discovery process to find a configuration\
    \ server.\n   The node MAY start by determining the overlay name.  This value\
    \ MUST\n   be provided by the user or some other out-of-band provisioning\n  \
    \ mechanism.  The out-of-band mechanism MAY also provide an optional\n   URL for\
    \ the configuration server.  If a URL for the configuration\n   server is not\
    \ provided, the node MUST do a DNS SRV query using a\n   Service name of \"reload-config\"\
    \ and a protocol of TCP to find a\n   configuration server and form the URL by\
    \ appending a path of\n   \"/.well-known/reload-config\" to the overlay name.\
    \  This uses the\n   \"well-known URI\" framework defined in [RFC5785].  For example,\
    \ if the\n   overlay name was example.com, the URL would be\n   \"https://example.com/.well-known/reload-config\"\
    .\n   Once an address and URL for the configuration server are determined,\n \
    \  the peer MUST form an HTTPS connection to that IP address.  If an\n   optional\
    \ URL for the configuration server was provided, the\n   certificate MUST match\
    \ the domain name from the URL as described in\n   [RFC2818]; otherwise, the certificate\
    \ MUST match the overlay name as\n   described in [RFC2818].  If the HTTPS certificates\
    \ pass the name\n   matching, the node MUST fetch a new copy of the configuration\
    \ file.\n   To do this, the peer performs a GET to the URL.  The result of the\n\
    \   HTTP GET is an XML configuration file described above.  If the XML is\n  \
    \ not valid or the instance-name attribute of the overlay-element in\n   the XML\
    \ does not match the overlay name, this configurations file\n   SHOULD be discarded.\
    \  Otherwise, the new configuration MUST replace\n   any previously learned configuration\
    \ file for this overlay.\n   For overlays that do not use a configuration server,\
    \ nodes MUST\n   obtain the configuration information needed to join the overlay\n\
    \   through some out-of-band approach, such as an XML configuration file\n   sent\
    \ over email.\n"
- title: 11.3.  Credentials
  contents:
  - "11.3.  Credentials\n   If the Configuration Document contains an enrollment-server\
    \ element,\n   credentials are REQUIRED to join the Overlay Instance.  A peer\
    \ which\n   does not yet have credentials MUST contact the enrollment server to\n\
    \   acquire them.\n   RELOAD defines its own trivial certificate request protocol.\
    \  We\n   would have liked to have used an existing protocol, but were\n   concerned\
    \ about the implementation burden of even the simplest of\n   those protocols,\
    \ such as [RFC5272] and [RFC5273].  The objective was\n   to have a protocol which\
    \ could be easily implemented in a Web server\n   which the operator did not control\
    \ (e.g., in a hosted service) and\n   which was compatible with the existing certificate-handling\
    \ tooling\n   as used with the Web certificate infrastructure.  This means\n \
    \  accepting bare PKCS#10 requests and returning a single bare X.509\n   certificate.\
    \  Although the MIME types for these objects are defined,\n   none of the existing\
    \ protocols support exactly this model.\n   The certificate request protocol MUST\
    \ be performed over HTTPS.  The\n   server certificate MUST match the overlay\
    \ name as described in\n   [RFC2818].  The request MUST be an HTTP POST with the\
    \ parameters\n   encoded as described in [RFC2388] and with the following properties:\n\
    \   o  If authentication is required, there MUST be form parameters of\n     \
    \ \"password\" and \"username\" containing the user's account name and\n     \
    \ password in the clear (hence the need for HTTPS).  The username\n      and password\
    \ strings MUST be UTF-8 strings compared as binary\n      objects.  Applications\
    \ using RELOAD SHOULD define any needed\n      string preparation as per [RFC4013]\
    \ or its successor documents.\n   o  If more than one Node-ID is required, there\
    \ MUST be a form\n      parameter of \"nodeids\" containing the number of Node-IDs\
    \ required.\n   o  There MUST be a form parameter of \"csr\" with a content type\
    \ of\n      \"application/pkcs10\", as defined in [RFC2311], that contains the\n\
    \      certificate signing request (CSR).\n   o  The Accept header MUST contain\
    \ the type \"application/pkix-cert\",\n      indicating the type that is expected\
    \ in the response.\n   The enrollment server MUST authenticate the request using\
    \ the\n   provided account name and password.  The reason for using the RFC\n\
    \   2388 \"multipart/form-data\" encoding is so that the password parameter\n\
    \   will not be encoded in the URL, to reduce the chance of accidental\n   leakage\
    \ of the password.  If the authentication succeeds and the\n   requested user\
    \ name in the CSR is acceptable, the server MUST\n   generate and return a certificate\
    \ for the CSR in the \"csr\" parameter\n   of the request.  The SubjectAltName\
    \ field in the certificate MUST\n   contain the following values:\n   o  One or\
    \ more Node-IDs which MUST be cryptographically random\n      [RFC4086].  Each\
    \ MUST be chosen by the enrollment server in such a\n      way that it is unpredictable\
    \ to the requesting user.  For example,\n      the user MUST NOT be informed of\
    \ potential (random) Node-IDs prior\n      to authenticating.  Each is placed\
    \ in the subjectAltName using the\n      uniformResourceIdentifier type, each\
    \ MUST contain RELOAD URI, as\n      described in Section 14.15, and each MUST\
    \ contain a Destination\n      List with a single entry of type \"node_id\". \
    \ The enrollment server\n      SHOULD maintain a mapping of users to Node-IDs\
    \ and if the same\n      user returns (e.g., to have their certificate re-issued),\
    \ the\n      enrollment server should return the same Node-IDs, thus avoiding\n\
    \      the need for implementations to re-store all their data when their\n  \
    \    certificates expire.\n   o  A single name (the \"user name\") that this user\
    \ is allowed to use\n      in the overlay, using type rfc822Name.  Enrollment\
    \ servers SHOULD\n      take care to allow only legal characters in the name (e.g.,\
    \ no\n      embedded NULs), rather than simply accepting any name provided by\n\
    \      the user.  In some usages, the right side of the user name will\n     \
    \ match the overlay name, but there is no requirement for this match\n      in\
    \ this specification.  Applications using this specification MAY\n      define\
    \ such a requirement or MAY otherwise limit the allowed range\n      of allowed\
    \ user names.\n   The SubjectAltName field in the certificate MUST NOT contain\
    \ any\n   identities other than those listed above.  The subject distinguished\n\
    \   name in the certificate MUST be empty.\n   The certificate MUST be returned\
    \ as type \"application/pkix-cert\", as\n   defined in [RFC2585], with an HTTP\
    \ status code of 200 OK.\n   Certificate processing errors SHOULD result in an\
    \ HTTP return code of\n   403 Forbidden, along with a body of type \"text/plain\"\
    \ and body that\n   consists of one of the tokens defined in the following list:\n\
    \   failed_authentication\n      The account name and password combination used\
    \ in the HTTPS\n      request was not valid.\n   username_not_available\n    \
    \  The requested user name in the CSR was not acceptable.\n   Node-IDs_not_available\n\
    \      The number of Node-IDs requested was not acceptable.\n   bad_CSR\n    \
    \  There was some other problem with the CSR.\n   If the client receives an unknown\
    \ token in the body, it SHOULD treat\n   it as a failure for an unknown reason.\n\
    \   The client MUST check that the returned certificate chains back to\n   one\
    \ of the certificates received in the \"root-cert\" list of the\n   overlay configuration\
    \ data (including PKIX BasicConstraints checks).\n   The node then reads the certificate\
    \ to find the Node-ID it can use.\n"
- title: 11.3.1.  Self-Generated Credentials
  contents:
  - "11.3.1.  Self-Generated Credentials\n   If the \"self-signed-permitted\" element\
    \ is present in the\n   configuration and is set to \"true\", then a node MUST\
    \ generate its own\n   self-signed certificate to join the overlay.  The self-signed\n\
    \   certificate MAY contain any user name of the user's choice.\n   For self-signed\
    \ certificates containing only one Node-ID, the Node-ID\n   MUST be computed by\
    \ applying the digest specified in the self-signed-\n   permitted element to the\
    \ DER representation of the user's public key\n   (more specifically, the subjectPublicKeyInfo)\
    \ and taking the high-\n   order bits.  For self-signed certificates containing\
    \ multiple\n   Node-IDs, the index of the Node-ID (from 1 to the number of Node-IDs\n\
    \   needed) must be prepended as a 4-byte big-endian integer to the DER\n   representation\
    \ of the user's public key and taking the high-order\n   bits.  When accepting\
    \ a self-signed certificate, nodes MUST check\n   that the Node-ID and public\
    \ keys match.  This prevents Node-ID theft.\n   Once the node has constructed\
    \ a self-signed certificate, it MAY join\n   the overlay.  It MUST store its certificate\
    \ in the overlay\n   (Section 8), but SHOULD look to see if the user name is already\
    \ taken\n   and, if so, choose another user name.  Note that this provides\n \
    \  protection only against accidental name collisions.  Name theft is\n   still\
    \ possible.  If protection against name theft is desired, then\n   the enrollment\
    \ service MUST be used.\n"
- title: 11.4.  Contacting a Bootstrap Node
  contents:
  - "11.4.  Contacting a Bootstrap Node\n   In order to join the overlay, the Joining\
    \ Node MUST contact a node in\n   the overlay.  Typically this means contacting\
    \ the bootstrap nodes,\n   since they are reachable by the local peer or have\
    \ public IP\n   addresses.  If the Joining Node has cached a list of peers that\
    \ it\n   has previously been connected with in this overlay, as an\n   optimization\
    \ it MAY attempt to use one or more of them as bootstrap\n   nodes before falling\
    \ back to the bootstrap nodes listed in the\n   configuration file.\n   When contacting\
    \ a bootstrap node, the Joining Node MUST first form\n   the DTLS or TLS connection\
    \ to the bootstrap node and then send an\n   Attach request over this connection\
    \ with the destination Resource-ID\n   set to the Joining Node's Node-ID plus\
    \ 1.\n   When the requester node finally does receive a response from some\n \
    \  responding node, it MUST use the Node-ID in the response to start\n   sending\
    \ requests to join the Overlay Instance as described in\n   Section 6.4.\n   After\
    \ a node has successfully joined the overlay network, it will\n   have direct\
    \ connections to several peers.  Some MAY be added to the\n   cached bootstrap\
    \ nodes list and used in future boots.  Peers that are\n   not directly connected\
    \ MUST NOT be cached.  The suggested number of\n   peers to cache is 10.  Algorithms\
    \ for determining which peers to\n   cache are beyond the scope of this specification.\n"
- title: 12.  Message Flow Example
  contents:
  - "12.  Message Flow Example\n   The following abbreviations are used in the message\
    \ flow diagrams:\n   JN = Joining Node, AP = Admitting Peer, NP = next peer after\
    \ the AP,\n   NNP = next next peer which is the peer after NP, PP = previous peer\n\
    \   before the AP, PPP = previous previous peer which is the peer before\n   the\
    \ PP, BP = bootstrap node.\n   In the following example, we assume that JN has\
    \ formed a connection\n   to one of the bootstrap nodes.  JN then sends an Attach\
    \ through that\n   peer to a Resource-ID of itself plus 1 (JN+1).  It gets routed\
    \ to the\n   AP, because JN is not yet part of the overlay.  When AP responds,\
    \ JN\n   and the AP use ICE to set up a connection and then set up DTLS.  Once\n\
    \   AP has connected to JN, AP sends to JN an Update to populate its\n   Routing\
    \ Table.  The following example shows the Update happening\n   after the DTLS\
    \ connection is formed, but it could also happen before,\n   in which case the\
    \ Update would often be routed through other nodes.\n       JN        PPP    \
    \   PP        AP        NP        NNP       BP\n        |         |         |\
    \         |         |         |         |\n        |         |         |     \
    \    |         |         |         |\n        |         |         |         |\
    \         |         |         |\n        |AttachReq Dest=JN+1|         |     \
    \    |         |         |\n        |---------------------------------------------------------->|\n\
    \        |         |         |         |         |         |         |\n     \
    \   |         |         |         |         |         |         |\n        | \
    \        |         |         |AttachReq Dest=JN+1|         |\n        |      \
    \   |         |         |<----------------------------|\n        |         | \
    \        |         |         |         |         |\n        |         |      \
    \   |         |         |         |         |\n        |         |         | \
    \        |AttachAns          |         |\n        |         |         |      \
    \   |---------------------------->|\n        |         |         |         | \
    \        |         |         |\n        |         |         |         |      \
    \   |         |         |\n        |AttachAns          |         |         | \
    \        |         |\n        |<----------------------------------------------------------|\n\
    \        |         |         |         |         |         |         |\n     \
    \   |ICE      |         |         |         |         |         |\n        |<===========================>|\
    \         |         |         |\n        |         |         |         |     \
    \    |         |         |\n        |TLS      |         |         |         |\
    \         |         |\n        |<...........................>|         |     \
    \    |         |\n        |         |         |         |         |         |\
    \         |\n        |         |         |         |         |         |     \
    \    |\n        |         |         |         |         |         |         |\n\
    \        |UpdateReq|         |         |         |         |         |\n     \
    \   |<----------------------------|         |         |         |\n        | \
    \        |         |         |         |         |         |\n        |      \
    \   |         |         |         |         |         |\n        |UpdateAns| \
    \        |         |         |         |         |\n        |---------------------------->|\
    \         |         |         |\n        |         |         |         |     \
    \    |         |         |\n        |         |         |         |         |\
    \         |         |\n        |         |         |         |         |     \
    \    |         |\n                                 Figure 1\n   The JN then forms\
    \ connections to the appropriate neighbors, such as\n   NP, by sending an Attach\
    \ which gets routed via other nodes.  When NP\n   responds, JN and NP use ICE\
    \ and DTLS to set up a connection.\n       JN        PPP       PP        AP  \
    \      NP        NNP       BP\n        |         |         |         |       \
    \  |         |         |\n        |         |         |         |         |  \
    \       |         |\n        |         |         |         |         |       \
    \  |         |\n        |AttachReq NP       |         |         |         |  \
    \       |\n        |---------------------------->|         |         |       \
    \  |\n        |         |         |         |         |         |         |\n\
    \        |         |         |         |         |         |         |\n     \
    \   |         |         |         |AttachReq NP       |         |\n        | \
    \        |         |         |-------->|         |         |\n        |      \
    \   |         |         |         |         |         |\n        |         | \
    \        |         |         |         |         |\n        |         |      \
    \   |         |AttachAns|         |         |\n        |         |         | \
    \        |<--------|         |         |\n        |         |         |      \
    \   |         |         |         |\n        |         |         |         | \
    \        |         |         |\n        |AttachAns|         |         |      \
    \   |         |         |\n        |<----------------------------|         | \
    \        |         |\n        |         |         |         |         |      \
    \   |         |\n        |         |         |         |         |         | \
    \        |\n        |ICE      |         |         |         |         |      \
    \   |\n        |<=====================================>|         |         |\n\
    \        |         |         |         |         |         |         |\n     \
    \   |         |         |         |         |         |         |\n        |TLS\
    \      |         |         |         |         |         |\n        |<.....................................>|\
    \         |         |\n        |         |         |         |         |     \
    \    |         |\n        |         |         |         |         |         |\
    \         |\n        |         |         |         |         |         |     \
    \    |\n        |         |         |         |         |         |         |\n\
    \                                 Figure 2\n   The JN also needs to populate its\
    \ Finger Table (for the Chord-based\n   DHT).  It issues an Attach to a variety\
    \ of locations around the\n   overlay.  The diagram below shows JN sending an\
    \ Attach halfway around\n   the Chord ring to the JN + 2^127.\n       JN     \
    \   NP        XX        TP\n        |         |         |         |\n        |\
    \         |         |         |\n        |         |         |         |\n   \
    \     |AttachReq JN+2<<126|         |\n        |-------->|         |         |\n\
    \        |         |         |         |\n        |         |         |      \
    \   |\n        |         |AttachReq JN+2<<126|\n        |         |-------->|\
    \         |\n        |         |         |         |\n        |         |    \
    \     |         |\n        |         |         |AttachReq JN+2<<126\n        |\
    \         |         |-------->|\n        |         |         |         |\n   \
    \     |         |         |         |\n        |         |         |AttachAns|\n\
    \        |         |         |<--------|\n        |         |         |      \
    \   |\n        |         |         |         |\n        |         |AttachAns|\
    \         |\n        |         |<--------|         |\n        |         |    \
    \     |         |\n        |         |         |         |\n        |AttachAns|\
    \         |         |\n        |<--------|         |         |\n        |    \
    \     |         |         |\n        |ICE      |         |         |\n       \
    \ |<===========================>|\n        |         |         |         |\n \
    \       |TLS      |         |         |\n        |<...........................>|\n\
    \        |         |         |         |\n        |         |         |      \
    \   |\n                                 Figure 3\n   Once JN has a reasonable\
    \ set of connections, it is ready to take its\n   place in the DHT.  It does this\
    \ by sending a Join to AP.  AP sends a\n   series of Store requests to JN to store\
    \ the data that JN will be\n   responsible for.  AP then sends JN an Update that\
    \ explicitly labels\n   JN as its predecessor.  At this point, JN is part of the\
    \ ring and is\n   responsible for a section of the overlay.  AP can now forget\
    \ any data\n   which is assigned to JN and not to AP.\n       JN        PPP  \
    \     PP        AP        NP        NNP       BP\n        |         |        \
    \ |         |         |         |         |\n        |         |         |   \
    \      |         |         |         |\n        |         |         |        \
    \ |         |         |         |\n        |JoinReq  |         |         |   \
    \      |         |         |\n        |---------------------------->|        \
    \ |         |         |\n        |         |         |         |         |   \
    \      |         |\n        |         |         |         |         |        \
    \ |         |\n        |JoinAns  |         |         |         |         |   \
    \      |\n        |<----------------------------|         |         |        \
    \ |\n        |         |         |         |         |         |         |\n \
    \       |         |         |         |         |         |         |\n      \
    \  |StoreReq Data A    |         |         |         |         |\n        |<----------------------------|\
    \         |         |         |\n        |         |         |         |     \
    \    |         |         |\n        |         |         |         |         |\
    \         |         |\n        |StoreAns |         |         |         |     \
    \    |         |\n        |---------------------------->|         |         |\
    \         |\n        |         |         |         |         |         |     \
    \    |\n        |         |         |         |         |         |         |\n\
    \        |StoreReq Data B    |         |         |         |         |\n     \
    \   |<----------------------------|         |         |         |\n        | \
    \        |         |         |         |         |         |\n        |      \
    \   |         |         |         |         |         |\n        |StoreAns | \
    \        |         |         |         |         |\n        |---------------------------->|\
    \         |         |         |\n        |         |         |         |     \
    \    |         |         |\n        |         |         |         |         |\
    \         |         |\n        |UpdateReq|         |         |         |     \
    \    |         |\n        |<----------------------------|         |         |\
    \         |\n        |         |         |         |         |         |     \
    \    |\n        |         |         |         |         |         |         |\n\
    \        |UpdateAns|         |         |         |         |         |\n     \
    \   |---------------------------->|         |         |         |\n        | \
    \        |         |         |         |         |         |\n        |      \
    \   |         |         |         |         |         |\n        |         | \
    \        |         |         |         |         |\n        |         |      \
    \   |         |         |         |         |\n                              \
    \   Figure 4\n   In Chord, JN's Neighbor Table needs to contain its own predecessors.\n\
    \   It couldn't connect to them previously, because it did not yet know\n   their\
    \ addresses.  However, now that it has received an Update from\n   AP, as in the\
    \ previous diagram, it has AP's predecessors, which are\n   also its own, so it\
    \ sends Attaches to them.  Below, it is shown\n   connecting only to AP's closest\
    \ predecessor, PP.\n       JN        PPP       PP        AP        NP        NNP\
    \       BP\n        |         |         |         |         |         |      \
    \   |\n        |         |         |         |         |         |         |\n\
    \        |         |         |         |         |         |         |\n     \
    \   |AttachReq Dest=PP  |         |         |         |         |\n        |---------------------------->|\
    \         |         |         |\n        |         |         |         |     \
    \    |         |         |\n        |         |         |         |         |\
    \         |         |\n        |         |         |AttachReq Dest=PP  |     \
    \    |         |\n        |         |         |<--------|         |         |\
    \         |\n        |         |         |         |         |         |     \
    \    |\n        |         |         |         |         |         |         |\n\
    \        |         |         |AttachAns|         |         |         |\n     \
    \   |         |         |-------->|         |         |         |\n        | \
    \        |         |         |         |         |         |\n        |      \
    \   |         |         |         |         |         |\n        |AttachAns| \
    \        |         |         |         |         |\n        |<----------------------------|\
    \         |         |         |\n        |         |         |         |     \
    \    |         |         |\n        |         |         |         |         |\
    \         |         |\n        |TLS      |         |         |         |     \
    \    |         |\n        |...................|         |         |         |\
    \         |\n        |         |         |         |         |         |     \
    \    |\n        |         |         |         |         |         |         |\n\
    \        |UpdateReq|         |         |         |         |         |\n     \
    \   |------------------>|         |         |         |         |\n        | \
    \        |         |         |         |         |         |\n        |      \
    \   |         |         |         |         |         |\n        |UpdateAns| \
    \        |         |         |         |         |\n        |<------------------|\
    \         |         |         |         |\n        |         |         |     \
    \    |         |         |         |\n        |         |         |         |\
    \         |         |         |\n        |UpdateReq|         |         |     \
    \    |         |         |\n        |---------------------------->|         |\
    \         |         |\n        |         |         |         |         |     \
    \    |         |\n        |         |         |         |         |         |\
    \         |\n        |UpdateAns|         |         |         |         |     \
    \    |\n        |<----------------------------|         |         |         |\n\
    \        |         |         |         |         |         |         |\n     \
    \   |         |         |         |         |         |         |\n        |UpdateReq|\
    \         |         |         |         |         |\n        |-------------------------------------->|\
    \         |         |\n        |         |         |         |         |     \
    \    |         |\n        |         |         |         |         |         |\
    \         |\n        |UpdateAns|         |         |         |         |     \
    \    |\n        |<--------------------------------------|         |         |\n\
    \        |         |         |         |         |         |         |\n     \
    \   |         |         |         |         |         |         |\n          \
    \                       Figure 5\n   Finally, now that JN has a copy of all the\
    \ data and is ready to route\n   messages and receive requests, it sends Updates\
    \ to everyone in its\n   Routing Table to tell them it is ready to go.  Below,\
    \ it is shown\n   sending such an update to TP.\n           JN        NP     \
    \   XX        TP\n            |         |         |         |\n            | \
    \        |         |         |\n            |         |         |         |\n\
    \            |UpdateReq|         |         |\n            |---------------------------->|\n\
    \            |         |         |         |\n            |         |        \
    \ |         |\n            |UpdateAns|         |         |\n            |<----------------------------|\n\
    \            |         |         |         |\n            |         |        \
    \ |         |\n            |         |         |         |\n            |    \
    \     |         |         |\n                                 Figure 6\n"
- title: 13.  Security Considerations
  contents:
  - '13.  Security Considerations

    '
- title: 13.1.  Overview
  contents:
  - "13.1.  Overview\n   RELOAD provides a generic storage service, albeit one designed\
    \ to be\n   useful for P2PSIP.  In this section, we discuss security issues that\n\
    \   are likely to be relevant to any usage of RELOAD.  More background\n   information\
    \ can be found in [RFC5765].\n   In any Overlay Instance, any given user depends\
    \ on a number of peers\n   with which they have no well-defined relationship except\
    \ that they\n   are fellow members of the Overlay Instance.  In practice, these\
    \ other\n   nodes may be friendly, lazy, curious, or outright malicious.  No\n\
    \   security system can provide complete protection in an environment\n   where\
    \ most nodes are malicious.  The goal of security in RELOAD is to\n   provide\
    \ strong security guarantees of some properties even in the\n   face of a large\
    \ number of malicious nodes and to allow the overlay to\n   function correctly\
    \ in the face of a modest number of malicious nodes.\n   P2PSIP deployments require\
    \ the ability to authenticate both peers and\n   resources (users) without the\
    \ active presence of a trusted entity in\n   the system.  We describe two mechanisms.\
    \  The first mechanism is\n   based on public key certificates and is suitable\
    \ for general\n   deployments.  The second is an admission control mechanism based\
    \ on\n   an overlay-wide shared symmetric key.\n"
- title: 13.2.  Attacks on P2P Overlays
  contents:
  - "13.2.  Attacks on P2P Overlays\n   The two basic functions provided by overlay\
    \ nodes are storage and\n   routing: some peer is responsible for storing a node's\
    \ data and for\n   allowing a third node to fetch this stored data, while other\
    \ peers\n   are responsible for routing messages to and from the storing nodes.\n\
    \   Each of these issues is covered in the following sections.\n   P2P overlays\
    \ are subject to attacks by subversive nodes that may\n   attempt to disrupt routing,\
    \ corrupt or remove user registrations, or\n   eavesdrop on signaling.  The certificate-based\
    \ security algorithms we\n   describe in this specification are intended to protect\
    \ overlay\n   routing and user registration information in RELOAD messages.\n\
    \   To protect the signaling from attackers pretending to be valid nodes\n   (or\
    \ nodes other than themselves), the first requirement is to ensure\n   that all\
    \ messages are received from authorized members of the\n   overlay.  For this\
    \ reason, RELOAD MUST transport all messages over a\n   secure channel (TLS and\
    \ DTLS are defined in this document) which\n   provides message integrity and\
    \ authentication of the directly\n   communicating peer.  In addition, messages\
    \ and data MUST be digitally\n   signed with the sender's private key, providing\
    \ end-to-end security\n   for communications.\n"
- title: 13.3.  Certificate-Based Security
  contents:
  - "13.3.  Certificate-Based Security\n   This specification stores users' registrations\
    \ and possibly other\n   data in an overlay network.  This requires a solution\
    \ both to\n   securing this data and to securing, as well as possible, the routing\n\
    \   in the overlay.  Both types of security are based on requiring that\n   every\
    \ entity in the system (whether user or peer) authenticate\n   cryptographically\
    \ using an asymmetric key pair tied to a certificate.\n   When a user enrolls\
    \ in the Overlay Instance, they request or are\n   assigned a unique name, such\
    \ as \"alice@dht.example.net\".  These names\n   MUST be unique and are meant\
    \ to be chosen and used by humans much\n   like a SIP address-of-record (AOR)\
    \ or an email address.  The user\n   MUST also be assigned one or more Node-IDs\
    \ by the central enrollment\n   authority.  Both the name and the Node-IDs are\
    \ placed in the\n   certificate, along with the user's public key.\n   Each certificate\
    \ enables an entity to act in two sorts of roles:\n   o  As a user, storing data\
    \ at specific Resource-IDs in the Overlay\n      Instance corresponding to the\
    \ user name.\n   o  As a overlay peer with the Node-IDs listed in the certificate.\n\
    \   Note that since only users of this Overlay Instance need to validate\n   a\
    \ certificate, this usage does not require a global Public Key\n   Infrastructure\
    \ (PKI).  Instead, certificates MUST be signed by a\n   central enrollment authority\
    \ which acts as the certificate authority\n   for the Overlay Instance.  This\
    \ authority signs each node's\n   certificate.  Because each node possesses the\
    \ CA's certificate (which\n   they receive upon enrollment), they can verify the\
    \ certificates of\n   the other entities in the overlay without further communication.\n\
    \   Because the certificates contain the user's/node's public key,\n   communications\
    \ from the user/node can, in turn, be verified.\n   If self-signed certificates\
    \ are used, then the security provided is\n   significantly decreased, since attackers\
    \ can mount Sybil attacks.  In\n   addition, attackers cannot trust the user names\
    \ in certificates\n   (although they can trust the Node-IDs, because they are\n\
    \   cryptographically verifiable).  This scheme may be appropriate for\n   some\
    \ small deployments, such as a small office or an ad hoc overlay\n   set up among\
    \ participants in a meeting where all hosts on the network\n   are trusted.  Some\
    \ additional security can be provided by using the\n   shared secret admission\
    \ control scheme as well.\n   Because all stored data is signed by the owner of\
    \ the data, the\n   storing node can verify that the storer is authorized to perform\
    \ a\n   store at that Resource-ID and also can allow any consumer of the data\n\
    \   to verify the provenance and integrity of the data when it retrieves\n   it.\n\
    \   Note that RELOAD does not itself provide a revocation/status\n   mechanism\
    \ (although certificates may, of course, include Online\n   Certificate Status\
    \ Protocol [OCSP] responder information).  Thus,\n   certificate lifetimes SHOULD\
    \ be chosen to balance the compromise\n   window versus the cost of certificate\
    \ renewal.  Because RELOAD is\n   already designed to operate in the face of some\
    \ fraction of malicious\n   nodes, this form of compromise is not fatal.\n   All\
    \ implementations MUST implement certificate-based security.\n"
- title: 13.4.  Shared-Secret Security
  contents:
  - "13.4.  Shared-Secret Security\n   RELOAD also supports a shared secret admission\
    \ control scheme that\n   relies on a single key that is shared among all members\
    \ of the\n   overlay.  It is appropriate for small groups that wish to form a\n\
    \   private network without complexity.  In shared secret mode, all the\n   peers\
    \ MUST share a single symmetric key which is used to key TLS-PSK\n   or TLS-SRP\
    \ mode.  A peer which does not know the key cannot form TLS\n   connections with\
    \ any other peer and therefore cannot join the\n   overlay.\n   One natural approach\
    \ to a shared-secret scheme is to use a user-\n   entered password as the key.\
    \  The difficulty with this is that in\n   TLS-PSK mode, such keys are very susceptible\
    \ to dictionary attacks.\n   If passwords are used as the source of shared keys,\
    \ then TLS-SRP is a\n   superior choice, because it is not subject to dictionary\
    \ attacks.\n"
- title: 13.5.  Storage Security
  contents:
  - "13.5.  Storage Security\n   When certificate-based security is used in RELOAD,\
    \ any given\n   Resource-ID/Kind-ID pair is bound to some small set of certificates.\n\
    \   In order to write data, the writer must prove possession of the\n   private\
    \ key for one of those certificates.  Moreover, all data is\n   stored, signed\
    \ with the same private key that was used to authorize\n   the storage.  This\
    \ set of rules makes questions of authorization and\n   data integrity, which\
    \ have historically been thorny for overlays,\n   relatively simple.\n"
- title: 13.5.1.  Authorization
  contents:
  - "13.5.1.  Authorization\n   When a node wants to store some value, it MUST first\
    \ digitally sign\n   the value with its own private key.  It then sends a Store\
    \ request\n   that contains both the value and the signature towards the storing\n\
    \   peer (which is defined by the Resource Name construction algorithm\n   for\
    \ that particular Kind of value).\n   When the storing peer receives the request,\
    \ it MUST determine whether\n   the storing node is authorized to store at this\
    \ Resource-ID/Kind-ID\n   pair.  Determining this requires comparing the user's\
    \ identity to the\n   requirements of the access control model (see Section 7.3).\
    \  If it\n   satisfies those requirements, the user is authorized to write,\n\
    \   pending quota checks, as described in the next section.\n   For example, consider\
    \ a certificate with the following properties:\n          User name: alice@dht.example.com\n\
    \          Node-ID:   013456789abcdef\n          Serial:    1234\n   If Alice\
    \ wishes to Store a value of the \"SIP Location\" Kind, the\n   Resource Name\
    \ will be the SIP AOR \"sip:alice@dht.example.com\".  The\n   Resource-ID will\
    \ be determined by hashing the Resource Name.  Because\n   SIP Location uses the\
    \ USER-NODE-MATCH policy, it first verifies that\n   the user name in the certificate\
    \ hashes to the requested Resource-ID.\n   It then verifies that the Node-ID in\
    \ the certificate matches the\n   dictionary key being used for the store.  If\
    \ both of these checks\n   succeed, the Store is authorized.  Note that because\
    \ the access\n   control model is different for different Kinds, the exact set\
    \ of\n   checks will vary.\n"
- title: 13.5.2.  Distributed Quota
  contents:
  - "13.5.2.  Distributed Quota\n   Being a peer in an Overlay Instance carries with\
    \ it the\n   responsibility to store data for a given region of the Overlay\n\
    \   Instance.  However, allowing nodes to store unlimited amounts of data\n  \
    \ would create unacceptable burdens on peers and would also enable\n   trivial\
    \ denial-of-service (DoS) attacks.  RELOAD addresses this issue\n   by requiring\
    \ configurations to define maximum sizes for each Kind of\n   stored data.  Attempts\
    \ to store values exceeding this size MUST be\n   rejected.  (If peers are inconsistent\
    \ about this, then strange\n   artifacts will happen when the zone of responsibility\
    \ shifts and a\n   different peer becomes responsible for overlarge data.)  Because\
    \ each\n   Resource-ID/Kind-ID pair is bound to a small set of certificates,\n\
    \   these size restrictions also create a distributed quota mechanism,\n   with\
    \ the quotas administered by the central configuration server.\n   Allowing different\
    \ Kinds of data to have different size restrictions\n   allows new usages the\
    \ flexibility to define limits that fit their\n   needs without requiring all\
    \ usages to have expansive limits.\n"
- title: 13.5.3.  Correctness
  contents:
  - "13.5.3.  Correctness\n   Because each stored value is signed, it is trivial for\
    \ any retrieving\n   node to verify the integrity of the stored value.  More care\
    \ needs to\n   be taken to prevent version rollback attacks.  Rollback attacks\
    \ on\n   storage are prevented by the use of store times and lifetime values\n\
    \   in each store.  A lifetime represents the latest time at which the\n   data\
    \ is valid and thus limits (although does not completely prevent)\n   the ability\
    \ of the storing node to perform a rollback attack on\n   retrievers.  In order\
    \ to prevent a rollback attack at the time of the\n   Store request, it is REQUIRED\
    \ that storage times be monotonically\n   increasing.  Storing peers MUST reject\
    \ Store requests with storage\n   times smaller than or equal to those that they\
    \ are currently storing.\n   In addition, a fetching node which receives a data\
    \ value with a\n   storage time older than the result of the previous fetch knows\
    \ that a\n   rollback has occurred.\n"
- title: 13.5.4.  Residual Attacks
  contents:
  - "13.5.4.  Residual Attacks\n   The mechanisms described here provide a high degree\
    \ of security, but\n   some attacks remain possible.  Most simply, it is possible\
    \ for\n   storing peers to refuse to store a value (i.e., they reject any\n  \
    \ request).  In addition, a storing peer can deny knowledge of values\n   which\
    \ it has previously accepted.  To some extent, these attacks can\n   be ameliorated\
    \ by attempting to store to and retrieve from replicas,\n   but a retrieving node\
    \ does not know whether or not it should try\n   this, as there is a cost to doing\
    \ so.\n   The certificate-based authentication scheme prevents a single peer\n\
    \   from being able to forge data owned by other peers.  Furthermore,\n   although\
    \ a subversive peer can refuse to return data resources for\n   which it is responsible,\
    \ it cannot return forged data, because it\n   cannot provide authentication for\
    \ such registrations.  Therefore,\n   parallel searches for redundant registrations\
    \ can mitigate most of\n   the effects of a compromised peer.  The ultimate reliability\
    \ of such\n   an overlay is a statistical question based on the replication factor\n\
    \   and the percentage of compromised peers.\n   In addition, when a Kind is multivalued\
    \ (e.g., an array data model),\n   the storing peer can return only some subset\
    \ of the values, thus\n   biasing its responses.  This can be countered by using\
    \ single values\n   rather than sets, but that makes coordination between multiple\n\
    \   storing agents much more difficult.  This is a trade-off that must be\n  \
    \ made when designing any usage.\n"
- title: 13.6.  Routing Security
  contents:
  - "13.6.  Routing Security\n   Because the storage security system guarantees (within\
    \ limits) the\n   integrity of the stored data, routing security focuses on stopping\n\
    \   the attacker from performing a DoS attack that misroutes requests in\n   the\
    \ overlay.  There are a few obvious observations to make about\n   this.  First,\
    \ it is easy to ensure that an attacker is at least a\n   valid node in the Overlay\
    \ Instance.  Second, this is a DoS attack\n   only.  Third, if a large percentage\
    \ of the nodes on the Overlay\n   Instance are controlled by the attacker, it\
    \ is probably impossible to\n   perfectly secure against this.\n"
- title: 13.6.1.  Background
  contents:
  - "13.6.1.  Background\n   In general, attacks on DHT routing are mounted by the\
    \ attacker\n   arranging to route traffic through one or two nodes that it controls.\n\
    \   In the Eclipse attack [Eclipse], the attacker tampers with messages\n   to\
    \ and from nodes for which it is on-path with respect to a given\n   victim node.\
    \  This allows it to pretend to be all the nodes that are\n   reachable through\
    \ it.  In the Sybil attack [Sybil], the attacker\n   registers a large number\
    \ of nodes and is therefore able to capture a\n   large amount of the traffic\
    \ through the DHT.\n   Both the Eclipse and Sybil attacks require the attacker\
    \ to be able to\n   exercise control over her Node-IDs.  The Sybil attack requires\
    \ the\n   creation of a large number of peers.  The Eclipse attack requires\n\
    \   that the attacker be able to impersonate specific peers.  In both\n   cases,\
    \ RELOAD attempts to mitigate these attacks by the use of\n   centralized, certificate-based\
    \ admission control.\n"
- title: 13.6.2.  Admissions Control
  contents:
  - "13.6.2.  Admissions Control\n   Admission to a RELOAD Overlay Instance is controlled\
    \ by requiring\n   that each peer have a certificate containing its Node-ID. \
    \ The\n   requirement to have a certificate is enforced by using certificate-\n\
    \   based mutual authentication on each connection.  (Note: the following\n  \
    \ applies only when self-signed certificates are not used.)  Whenever a\n   peer\
    \ connects to another peer, each side automatically checks that\n   the other\
    \ has a suitable certificate.  These Node-IDs MUST be\n   randomly assigned by\
    \ the central enrollment server.  This has two\n   benefits:\n   o  It allows\
    \ the enrollment server to limit the number of Node-IDs\n      issued to any individual\
    \ user.\n   o  It prevents the attacker from choosing specific Node-IDs.\n   The\
    \ first property allows protection against Sybil attacks (provided\n   that the\
    \ enrollment server uses strict rate-limiting policies).  The\n   second property\
    \ deters but does not completely prevent Eclipse\n   attacks.  Because an Eclipse\
    \ attacker must impersonate peers on the\n   other side of the attacker, the attacker\
    \ must have a certificate for\n   suitable Node-IDs, which requires him to repeatedly\
    \ query the\n   enrollment server for new certificates, which will match only\
    \ by\n   chance.  From the attacker's perspective, the difficulty is that if\n\
    \   the attacker has only a small number of certificates, the region of\n   the\
    \ Overlay Instance he is impersonating appears to be very sparsely\n   populated\
    \ by comparison to the victim's local region.\n"
- title: 13.6.3.  Peer Identification and Authentication
  contents:
  - "13.6.3.  Peer Identification and Authentication\n   In general, whenever a peer\
    \ engages in overlay activity that might\n   affect the Routing Table, it must\
    \ establish its identity.  This\n   happens in two ways.  First, whenever a peer\
    \ establishes a direct\n   connection to another peer, it authenticates via certificate-based\n\
    \   mutual authentication.  All messages between peers are sent over this\n  \
    \ protected channel, and therefore the peers can verify the data origin\n   of\
    \ the last-hop peer for requests and responses without further\n   cryptography.\n\
    \   In some situations, however, it is desirable to be able to establish\n   the\
    \ identity of a peer with whom one is not directly connected.  The\n   most natural\
    \ case is when a peer Updates its state.  At this point,\n   other peers may need\
    \ to update their view of the overlay structure,\n   but they need to verify that\
    \ the Update message came from the actual\n   peer rather than from an attacker.\
    \  To prevent having a peer accept\n   Update messages from an attacker, all overlay\
    \ routing messages are\n   signed by the peer that generated them.\n   For messages\
    \ that impact the topology of the overlay, replay is\n   typically prevented by\
    \ having the information come directly from, or\n   be verified by, the nodes\
    \ that claimed to have generated the update.\n   Data storage replay detection\
    \ is done by signing the time of the node\n   that generated the signature on\
    \ the Store request, thus providing a\n   time-based replay protection, but the\
    \ time synchronization is needed\n   only between peers that can write to the\
    \ same location.\n"
- title: 13.6.4.  Protecting the Signaling
  contents:
  - "13.6.4.  Protecting the Signaling\n   The goal here is to stop an attacker from\
    \ knowing who is signaling\n   what to whom.  An attacker is unlikely to be able\
    \ to observe the\n   activities of a specific individual, given the randomization\
    \ of IDs\n   and routing based on the present peers discussed above.  Furthermore,\n\
    \   because messages can be routed using only the header information, the\n  \
    \ actual body of the RELOAD message can be encrypted during\n   transmission.\n\
    \   There are two lines of defense here.  The first is the use of TLS or\n   DTLS\
    \ for each communications link between peers.  This provides\n   protection against\
    \ attackers who are not members of the overlay.  The\n   second line of defense\
    \ is to digitally sign each message.  This\n   prevents adversarial peers from\
    \ modifying messages in flight, even if\n   they are on the routing path.\n"
- title: 13.6.5.  Routing Loops and DoS Attacks
  contents:
  - "13.6.5.  Routing Loops and DoS Attacks\n   Source-routing mechanisms are known\
    \ to create the possibility for DoS\n   amplification, especially by the induction\
    \ of routing loops\n   [RFC5095].  In order to limit amplification, the initial-ttl\
    \ value in\n   the configuration file SHOULD be set to a value slightly larger\
    \ than\n   the longest expected path through the network.  For Chord, experience\n\
    \   has shown that log(2) of the number of nodes in the network + 5 is a\n   safe\
    \ bound.  Because nodes are required to enforce the initial-ttl as\n   the maximum\
    \ value, an attacker cannot achieve an amplification factor\n   greater than initial-ttl,\
    \ thus limiting the additional capabilities\n   provided by source routing.\n\
    \   In order to prevent the use of loops for targeted implementation\n   attacks,\
    \ implementations SHOULD check the Destination List for\n   duplicate entries\
    \ and discard such records with an\n   \"Error_Invalid_Message\" error.  This\
    \ does not completely prevent\n   loops, but it does require that at least one\
    \ attacker node be part of\n   the loop.\n"
- title: 13.6.6.  Residual Attacks
  contents:
  - "13.6.6.  Residual Attacks\n   The routing security mechanisms in RELOAD are designed\
    \ to contain\n   rather than eliminate attacks on routing.  It is still possible\
    \ for\n   an attacker to mount a variety of attacks.  In particular, if an\n \
    \  attacker is able to take up a position on the overlay routing between\n   A\
    \ and B, it can make it appear as if B does not exist or is\n   disconnected.\
    \  It can also advertise false network metrics in an\n   attempt to reroute traffic.\
    \  However, these are primarily DoS\n   attacks.\n   The certificate-based security\
    \ scheme secures the namespace, but if\n   an individual peer is compromised or\
    \ if an attacker obtains a\n   certificate from the CA, then a number of subversive\
    \ peers can still\n   appear in the overlay.  While these peers cannot falsify\
    \ responses to\n   resource queries, they can respond with error messages, effecting\
    \ a\n   DoS attack on the resource registration.  They can also subvert\n   routing\
    \ to other compromised peers.  To defend against such attacks,\n   a resource\
    \ search must still consist of parallel searches for\n   replicated registrations.\n"
- title: 14.  IANA Considerations
  contents:
  - "14.  IANA Considerations\n   This section contains the new code points registered\
    \ by this\n   document.\n"
- title: 14.1.  Well-Known URI Registration
  contents:
  - "14.1.  Well-Known URI Registration\n   IANA has registered a \"well-known URI\"\
    \ as described in [RFC5785]:\n           +----------------------------+----------------------+\n\
    \           | URI suffix:                | reload-config        |\n          \
    \ | Change controller:         | IETF <iesg@ietf.org> |\n           | Specification\
    \ document(s): | RFC 6940             |\n           | Related information:   \
    \    | None                 |\n           +----------------------------+----------------------+\n"
- title: 14.2.  Port Registrations
  contents:
  - "14.2.  Port Registrations\n   IANA has already allocated a TCP port for the main\
    \ peer-to-peer\n   protocol.  This port had the name p2psip-enroll and the port\
    \ number\n   of 6084.  Per this document, IANA has updated this registration to\n\
    \   change the service name to reload-config.\n   IANA has made the following\
    \ port registration:\n   +-----------------------------+-------------------------------------+\n\
    \   | Registration Technical      | IETF Chair <chair@ietf.org>         |\n  \
    \ | Contact                     |                                     |\n   |\
    \ Registration Owner          | IETF <iesg@ietf.org>                |\n   | Transport\
    \ Protocol          | TCP                                 |\n   | Port Number\
    \                 | 6084                                |\n   | Service Name \
    \               | reload-config                       |\n   | Description    \
    \             | Peer-to-Peer Infrastructure         |\n   |                  \
    \           | Configuration                       |\n   +-----------------------------+-------------------------------------+\n"
- title: 14.3.  Overlay Algorithm Types
  contents:
  - "14.3.  Overlay Algorithm Types\n   IANA has created a \"RELOAD Overlay Algorithm\
    \ Types\" Registry.\n   Entries in this registry are strings denoting the names\
    \ of overlay\n   algorithms, as described in Section 11.1 of [RFC6940].  The\n\
    \   registration policy for this registry is \"IETF Review\" [RFC522].  The\n\
    \   initial contents of this registry are:\n                      +----------------+-----------+\n\
    \                      | Algorithm Name | Reference |\n                      +----------------+-----------+\n\
    \                      | CHORD-RELOAD   |  RFC 6940 |\n                      |\
    \ EXP-OVERLAY    |  RFC 6940 |\n                      +----------------+-----------+\n\
    \   The value EXP-OVERLAY has been made available for the purposes of\n   experimentation.\
    \  This value is not meant for vendor-specific use of\n   any sort, and it MUST\
    \ NOT be used for operational deployments.\n"
- title: 14.4.  Access Control Policies
  contents:
  - "14.4.  Access Control Policies\n   IANA has created a \"RELOAD Access Control\
    \ Policies\" Registry.\n   Entries in this registry are strings denoting access\
    \ control\n   policies, as described in Section 7.3 of [RFC6940].  New entries\
    \ in\n   this registry SHALL be registered via Standards Action [RFC5226].\n \
    \  The initial contents of this registry are:\n                      +-----------------+-----------+\n\
    \                      | Access Policy   | Reference |\n                     \
    \ +-----------------+-----------+\n                      | USER-MATCH      | \
    \ RFC 6940 |\n                      | NODE-MATCH      |  RFC 6940 |\n        \
    \              | USER-NODE-MATCH |  RFC 6940 |\n                      | NODE-MULTIPLE\
    \   |  RFC 6940 |\n                      | EXP-MATCH       |  RFC 6940 |\n   \
    \                   +-----------------+-----------+\n   The value EXP-MATCH has\
    \ been made available for the purposes of\n   experimentation.  This value is\
    \ not meant for vendor-specific use of\n   any sort, and it MUST NOT be used for\
    \ operational deployments.\n"
- title: 14.5.  Application-ID
  contents:
  - "14.5.  Application-ID\n   IANA has created a \"RELOAD Application-ID\" Registry.\
    \  Entries in this\n   registry are 16-bit integers denoting Application-IDs,\
    \ as described\n   in Section 6.5.2 of [RFC6940].  Code points in the range 1\
    \ to 32767\n   SHALL be registered via Standards Action [RFC5226].  Code points\
    \ in\n   the range 32768 to 61440 SHALL be registered via Expert Review\n   [RFC5226].\
    \  Code points in the range 61441 to 65534 are reserved for\n   private use. \
    \ The initial contents of this registry are:\n     +-------------+----------------+-------------------------------+\n\
    \     | Application | Application-ID |                 Specification |\n     +-------------+----------------+-------------------------------+\n\
    \     | INVALID     |              0 |                      RFC 6940 |\n     |\
    \ SIP         |           5060 | Reserved for use by SIP Usage |\n     | SIP \
    \        |           5061 | Reserved for use by SIP Usage |\n     | Reserved \
    \   |          65535 |                      RFC 6940 |\n     +-------------+----------------+-------------------------------+\n"
- title: 14.6.  Data Kind-ID
  contents:
  - "14.6.  Data Kind-ID\n   IANA has created a \"RELOAD Data Kind-ID\" registry.\
    \  Entries in this\n   registry are 32-bit integers denoting data Kinds, as described\
    \ in\n   Section 5.2 of [RFC6940].  Code points in the range 0x00000001 to\n \
    \  0x7FFFFFFF SHALL be registered via Standards Action [RFC5226].  Code\n   points\
    \ in the range 0x8000000 to 0xF0000000 SHALL be registered via\n   Expert Review\
    \ [RFC5226].  Code points in the range 0xF0000001 to\n   0xFFFFFFFE are reserved\
    \ for private use via the Kind description\n   mechanism described in Section\
    \ 11 of [RFC6940].  The initial contents\n   of this registry are:\n         \
    \    +---------------------+------------+-----------+\n             | Kind   \
    \             |    Kind-ID | Reference |\n             +---------------------+------------+-----------+\n\
    \             | INVALID             |        0x0 |  RFC 6940 |\n             |\
    \ TURN-SERVICE        |        0x2 |  RFC 6940 |\n             | CERTIFICATE_BY_NODE\
    \ |        0x3 |  RFC 6940 |\n             | CERTIFICATE_BY_USER |       0x10\
    \ |  RFC 6940 |\n             | Reserved            | 0x7fffffff |  RFC 6940 |\n\
    \             | Reserved            | 0xfffffffe |  RFC 6940 |\n             +---------------------+------------+-----------+\n"
- title: 14.7.  Data Model
  contents:
  - "14.7.  Data Model\n   IANA has created a \"RELOAD Data Model\" registry.  Entries\
    \ in this\n   registry are strings denoting data models, as described in\n   Section\
    \ 7.2 of [RFC6940].  New entries in this registry SHALL be\n   registered via\
    \ Standards Action [RFC5226].  The initial contents of\n   this registry are:\n\
    \                        +------------+-----------+\n                        |\
    \ Data Model | Reference |\n                        +------------+-----------+\n\
    \                        | INVALID    |  RFC 6940 |\n                        |\
    \ SINGLE     |  RFC 6940 |\n                        | ARRAY      |  RFC 6940 |\n\
    \                        | DICTIONARY |  RFC 6940 |\n                        |\
    \ EXP-DATA   |  RFC 6940 |\n                        | RESERVED   |  RFC 6940 |\n\
    \                        +------------+-----------+\n   The value EXP-DATA has\
    \ been made available for the purposes of\n   experimentation.  This value is\
    \ not meant for vendor-specific use of\n   any sort, and it MUST NOT be used for\
    \ operational deployments.\n"
- title: 14.8.  Message Codes
  contents:
  - "14.8.  Message Codes\n   IANA has created a \"RELOAD Message Codes\" registry.\
    \  Entries in this\n   registry are 16-bit integers denoting method codes, as\
    \ described in\n   Section 6.3.3 of [RFC6940].  These codes SHALL be registered\
    \ via\n   Standards Action [RFC5226].  The initial contents of this registry\n\
    \   are:\n   +-------------------------------------+----------------+-----------+\n\
    \   | Message Code Name                   |     Code Value | Reference |\n   +-------------------------------------+----------------+-----------+\n\
    \   | invalidMessageCode                  |            0x0 |  RFC 6940 |\n   |\
    \ probe_req                           |            0x1 |  RFC 6940 |\n   | probe_ans\
    \                           |            0x2 |  RFC 6940 |\n   | attach_req  \
    \                        |            0x3 |  RFC 6940 |\n   | attach_ans     \
    \                     |            0x4 |  RFC 6940 |\n   | Unassigned        \
    \                  |            0x5 |           |\n   | Unassigned           \
    \               |            0x6 |           |\n   | store_req               \
    \            |            0x7 |  RFC 6940 |\n   | store_ans                  \
    \         |            0x8 |  RFC 6940 |\n   | fetch_req                     \
    \      |            0x9 |  RFC 6940 |\n   | fetch_ans                        \
    \   |            0xA |  RFC 6940 |\n   | Unassigned (was remove_req)         |\
    \            0xB |  RFC 6940 |\n   | Unassigned (was remove_ans)         |   \
    \         0xC |  RFC 6940 |\n   | find_req                            |      \
    \      0xD |  RFC 6940 |\n   | find_ans                            |         \
    \   0xE |  RFC 6940 |\n   | join_req                            |            0xF\
    \ |  RFC 6940 |\n   | join_ans                            |           0x10 | \
    \ RFC 6940 |\n   | leave_req                           |           0x11 |  RFC\
    \ 6940 |\n   | leave_ans                           |           0x12 |  RFC 6940\
    \ |\n   | update_req                          |           0x13 |  RFC 6940 |\n\
    \   | update_ans                          |           0x14 |  RFC 6940 |\n   |\
    \ route_query_req                     |           0x15 |  RFC 6940 |\n   | route_query_ans\
    \                     |           0x16 |  RFC 6940 |\n   | ping_req          \
    \                  |           0x17 |  RFC 6940 |\n   | ping_ans             \
    \               |           0x18 |  RFC 6940 |\n   | stat_req                \
    \            |           0x19 |  RFC 6940 |\n   | stat_ans                   \
    \         |           0x1A |  RFC 6940 |\n   | Unassigned (was attachlite_req)\
    \     |           0x1B |  RFC 6940 |\n   | Unassigned (was attachlite_ans)   \
    \  |           0x1C |  RFC 6940 |\n   | app_attach_req                      |\
    \           0x1D |  RFC 6940 |\n   | app_attach_ans                      |   \
    \        0x1E |  RFC 6940 |\n   | Unassigned (was app_attachlite_req) |      \
    \     0x1F |  RFC 6940 |\n   | Unassigned (was app_attachlite_ans) |         \
    \  0x20 |  RFC 6940 |\n   | config_update_req                   |           0x21\
    \ |  RFC 6940 |\n   | config_update_ans                   |           0x22 | \
    \ RFC 6940 |\n   | exp_a_req                           |           0x23 |  RFC\
    \ 6940 |\n   | exp_a_ans                           |           0x24 |  RFC 6940\
    \ |\n   | exp_b_req                           |           0x25 |  RFC 6940 |\n\
    \   | exp_b_ans                           |           0x26 |  RFC 6940 |\n   |\
    \ Reserved                            | 0x8000..0xFFFE |  RFC 6940 |\n   | error\
    \                               |         0xFFFF |  RFC 6940 |\n   +-------------------------------------+----------------+-----------+\n\
    \   The values exp_a_req, exp_a_ans, exp_b_req, and exp_b_ans have been\n   made\
    \ available for the purposes of experimentation.  These values are\n   not meant\
    \ for vendor-specific use of any sort, and they MUST NOT be\n   used for operational\
    \ deployments.\n"
- title: 14.9.  Error Codes
  contents:
  - "14.9.  Error Codes\n   IANA has created a \"RELOAD Error Code\" registry.  Entries\
    \ in this\n   registry are 16-bit integers denoting error codes, as described\
    \ in\n   Section 6.3.3.1 of [RFC6940].  New entries SHALL be defined via\n   Standards\
    \ Action [RFC5226].  The initial contents of this registry\n   are:\n   +-------------------------------------+----------------+-----------+\n\
    \   | Error Code Name                     |     Code Value | Reference |\n   +-------------------------------------+----------------+-----------+\n\
    \   | invalidErrorCode                    |            0x0 |  RFC 6940 |\n   |\
    \ Unassigned                          |            0x1 |           |\n   | Error_Forbidden\
    \                     |            0x2 |  RFC 6940 |\n   | Error_Not_Found   \
    \                  |            0x3 |  RFC 6940 |\n   | Error_Request_Timeout\
    \               |            0x4 |  RFC 6940 |\n   | Error_Generation_Counter_Too_Low\
    \    |            0x5 |  RFC 6940 |\n   | Error_Incompatible_with_Overlay    \
    \ |            0x6 |  RFC 6940 |\n   | Error_Unsupported_Forwarding_Option | \
    \           0x7 |  RFC 6940 |\n   | Error_Data_Too_Large                |    \
    \        0x8 |  RFC 6940 |\n   | Error_Data_Too_Old                  |       \
    \     0x9 |  RFC 6940 |\n   | Error_TTL_Exceeded                  |          \
    \  0xA |  RFC 6940 |\n   | Error_Message_Too_Large             |            0xB\
    \ |  RFC 6940 |\n   | Error_Unknown_Kind                  |            0xC | \
    \ RFC 6940 |\n   | Error_Unknown_Extension             |            0xD |  RFC\
    \ 6940 |\n   | Error_Response_Too_Large            |            0xE |  RFC 6940\
    \ |\n   | Error_Config_Too_Old                |            0xF |  RFC 6940 |\n\
    \   | Error_Config_Too_New                |           0x10 |  RFC 6940 |\n   |\
    \ Error_In_Progress                   |           0x11 |  RFC 6940 |\n   | Error_Exp_A\
    \                         |           0x12 |  RFC 6940 |\n   | Error_Exp_B   \
    \                      |           0x13 |  RFC 6940 |\n   | Error_Invalid_Message\
    \               |           0x14 |  RFC 6940 |\n   | Reserved                \
    \            | 0x8000..0xFFFE |  RFC 6940 |\n   +-------------------------------------+----------------+-----------+\n\
    \   The values Error_Exp_A and Error_Exp_B have been made available for\n   the\
    \ purposes of experimentation.  These values are not meant for\n   vendor-specific\
    \ use of any sort, and they MUST NOT be used for\n   operational deployments.\n"
- title: 14.10.  Overlay Link Types
  contents:
  - "14.10.  Overlay Link Types\n   IANA has created a \"RELOAD Overlay Link Registry\"\
    .  Entries in this\n   registry are 8-bit integers, as described in Section 6.5.1.1\
    \ of\n   [RFC6940].  For more information on the link types defined here, see\n\
    \   Section 6.6 of [RFC6940].  New entries SHALL be defined via Standards\n  \
    \ Action [RFC5226].  This registry has been initially populated with\n   the following\
    \ values:\n                 +--------------------+------+-----------+\n      \
    \           | Protocol           | Code | Reference |\n                 +--------------------+------+-----------+\n\
    \                 | INVALID-PROTOCOL   |    0 |  RFC 6940 |\n                \
    \ | DTLS-UDP-SR        |    1 |  RFC 6940 |\n                 | DTLS-UDP-SR-NO-ICE\
    \ |    3 |  RFC 6940 |\n                 | TLS-TCP-FH-NO-ICE  |    4 |  RFC 6940\
    \ |\n                 | EXP-LINK           |    5 |  RFC 6940 |\n            \
    \     | Reserved           |  255 |  RFC 6940 |\n                 +--------------------+------+-----------+\n\
    \   The value EXP-LINK has been made available for the purposes of\n   experimentation.\
    \  This value is not meant for vendor-specific use of\n   any sort, and it MUST\
    \ NOT be used for operational deployments.\n"
- title: 14.11.  Overlay Link Protocols
  contents:
  - "14.11.  Overlay Link Protocols\n   IANA has created a \"RELOAD Overlay Link Protocol\
    \ Registry\".  Entries\n   in this registry are strings denoting protocols as\
    \ described in\n   Section 11.1 of this document and SHALL be defined via Standards\n\
    \   Action [RFC5226].  This registry has been initially populated with\n   the\
    \ following values:\n                       +---------------+-----------+\n  \
    \                     | Link Protocol | Reference |\n                       +---------------+-----------+\n\
    \                       | TLS           |  RFC 6940 |\n                      \
    \ | EXP-PROTOCOL  |  RFC 6940 |\n                       +---------------+-----------+\n\
    \   The value EXP-PROTOCOL has been made available for the purposes of\n   experimentation.\
    \  This value is not meant for vendor-specific use of\n   any sort, and it MUST\
    \ NOT be used for operational deployments.\n"
- title: 14.12.  Forwarding Options
  contents:
  - "14.12.  Forwarding Options\n   IANA has created a \"RELOAD Forwarding Option\
    \ Registry\".  Entries in\n   this registry are 8-bit integers denoting options,\
    \ as described in\n   Section 6.3.2.3 of [RFC6940].  Values between 1 and 127\
    \ SHALL be\n   defined via Standards Action [RFC5226].  Entries in this registry\n\
    \   between 128 and 254 SHALL be defined via Specification Required\n   [RFC5226].\
    \  This registry has been initially populated with the\n   following values:\n\
    \              +-------------------------+------+-----------+\n              |\
    \ Forwarding Option       | Code | Reference |\n              +-------------------------+------+-----------+\n\
    \              | invalidForwardingOption |    0 |  RFC 6940 |\n              |\
    \ exp-forward             |    1 |  RFC 6940 |\n              | Reserved     \
    \           |  255 |  RFC 6940 |\n              +-------------------------+------+-----------+\n\
    \   The value exp-forward has been made available for the purposes of\n   experimentation.\
    \  This value is not meant for vendor-specific use of\n   any sort, and it MUST\
    \ NOT be used for operational deployments.\n"
- title: 14.13.  Probe Information Types
  contents:
  - "14.13.  Probe Information Types\n   IANA has created a \"RELOAD Probe Information\
    \ Type Registry\".  Entries\n   are 8-bit integers denoting types as described\
    \ in Section 6.4.2.5.1\n   of [RFC6940] and SHALL be defined via Standards Action\
    \ [RFC5226].\n   This registry has been initially populated with the following\
    \ values:\n                 +--------------------+------+-----------+\n      \
    \           | Probe Option       | Code | Reference |\n                 +--------------------+------+-----------+\n\
    \                 | invalidProbeOption |    0 |  RFC 6940 |\n                \
    \ | responsible_set    |    1 |  RFC 6940 |\n                 | num_resources\
    \      |    2 |  RFC 6940 |\n                 | uptime             |    3 |  RFC\
    \ 6940 |\n                 | exp-probe          |    4 |  RFC 6940 |\n       \
    \          | Reserved           |  255 |  RFC 6940 |\n                 +--------------------+------+-----------+\n\
    \   The value exp-probe has been made available for the purposes of\n   experimentation.\
    \  This value is not meant for vendor-specific use of\n   any sort, and it MUST\
    \ NOT be used for operational deployments.\n"
- title: 14.14.  Message Extensions
  contents:
  - "14.14.  Message Extensions\n   IANA has created a \"RELOAD Extensions Registry\"\
    .  Entries in this\n   registry are 8-bit integers denoting extensions as described\
    \ in\n   Section 6.3.3 of [RFC6940] and SHALL be defined via Specification\n \
    \  Required [RFC5226].  This registry has been initially populated with\n   the\
    \ following values:\n           +-----------------------------+--------+-----------+\n\
    \           | Extensions Name             |   Code | Reference |\n           +-----------------------------+--------+-----------+\n\
    \           | invalidMessageExtensionType |    0x0 |  RFC 6940 |\n           |\
    \ exp-ext                     |    0x1 |  RFC 6940 |\n           | Reserved  \
    \                  | 0xFFFF |  RFC 6940 |\n           +-----------------------------+--------+-----------+\n\
    \   The value exp-ext has been made available for the purposes of\n   experimentation.\
    \  This value is not meant for vendor-specific use of\n   any sort, and it MUST\
    \ NOT be used for operational deployments.\n"
- title: 14.15.  Reload URI Scheme
  contents:
  - "14.15.  Reload URI Scheme\n   This section describes the scheme for a reload\
    \ URI, which can be used\n   to refer to either:\n   o  A peer, e.g., as used\
    \ in a certificate (see Section 11.3 of\n      [RFC6940]).\n   o  A resource inside\
    \ a peer.\n   The reload URI is defined using a subset of the URI schema specified\n\
    \   in Appendix A of RFC 3986 [RFC3986] and the associated URI Guidelines\n  \
    \ [RFC4395] per the following ABNF syntax:\n      RELOAD-URI = \"reload://\" destination\
    \ \"@\" overlay \"/\"\n               [specifier]\n      destination = 1*HEXDIG\n\
    \      overlay = reg-name\n      specifier = 1*HEXDIG\n   The definitions of these\
    \ productions are as follows:\n   destination\n      A hexadecimal-encoded Destination\
    \ List object (i.e., multiple\n      concatenated Destination objects with no\
    \ length prefix prior to\n      the object as a whole).\n   overlay\n      The\
    \ name of the overlay.\n   specifier\n      A hexadecimal-encoded StoredDataSpecifier\
    \ indicating the data\n      element.\n   If no specifier is present, this URI\
    \ addresses the peer which can be\n   reached via the indicated Destination List\
    \ at the indicated overlay\n   name.  If a specifier is present, the URI addresses\
    \ the data value.\n"
- title: 14.15.1.  URI Registration
  contents:
  - "14.15.1.  URI Registration\n   The following summarizes the information necessary\
    \ to register the\n   reload URI.\n   URI Scheme Name:  reload\n   Status:   permanent\n\
    \   URI Scheme Syntax:  see Section 14.15 of RFC 6940\n   URI Scheme Semantics:\
    \  The reload URI is intended to be used as a\n      reference to a RELOAD peer\
    \ or resource.\n   Encoding Considerations:  The reload URI is not intended to\
    \ be human-\n      readable text, so it is encoded entirely in US-ASCII.\n   Applications/protocols\
    \ that Use this URI Scheme:  The RELOAD protocol\n      described in RFC 6940.\n\
    \   Interoperability Considerations:  See RFC 6940.\n   Security Considerations:\
    \  See RFC 6940\n   Contact:  Cullen Jennings <fluffy@cisco.com>\n   Author/Change\
    \ Controller:  IESG\n   References:  RFC 6940\n"
- title: 14.16.  Media Type Registration
  contents:
  - "14.16.  Media Type Registration\n   Type Name: application\n   Subtype Name:\
    \ p2p-overlay+xml\n   Required Parameters: none\n   Optional Parameters: none\n\
    \   Encoding Considerations: Must be binary encoded.\n   Security Considerations:\
    \ This media type is typically not used to\n   transport information that needs\
    \ to be kept confidential.  However,\n   there are cases where it is integrity\
    \ of the information is\n   important.  For these cases, using a digital signature\
    \ is\n   RECOMMENDED.  One way of doing this is specified in RFC 6940.  In the\n\
    \   case when the media includes a shared-secret element, the contents of\n  \
    \ the file MUST be kept confidential or else anyone who can see the\n   shared\
    \ secret can affect the RELOAD overlay network.\n   Interoperability Considerations:\
    \ No known interoperability\n   consideration beyond those identified for application/xml\
    \ in\n   [RFC3023].\n   Published Specification: RFC 6940\n   Applications that\
    \ Use this Media Type: The type is used to configure\n   the peer-to-peer overlay\
    \ networks defined in RFC 6940.\n   Additional Information: The syntax for this\
    \ media type is specified\n   in Section 11.1 of [RFC6940].  The contents MUST\
    \ be valid XML that is\n   compliant with the RELAX NG grammar specified in RFC\
    \ 6940 and that\n   use the UTF-8[RFC3629] character encoding.\n      Magic Number(s):\
    \ none\n      File Extension(s): relo\n      Macintosh File Type Code(s): none\n\
    \   Person & Email Address to Contact for Further Information: Cullen\n   Jennings\
    \ <fluffy@cisco.com>\n   Intended Usage: COMMON\n   Restrictions on Usage: None\n\
    \   Author: Cullen Jennings <fluffy@cisco.com>\n   Change Controller: IESG\n"
- title: 14.17.  XML Namespace Registration
  contents:
  - "14.17.  XML Namespace Registration\n   This document registers two URIs for the\
    \ config and config-chord XML\n   namespaces in the IETF XML registry defined\
    \ in [RFC3688].\n"
- title: 14.17.1.  Config URL
  contents:
  - "14.17.1.  Config URL\n   URI: urn:ietf:params:xml:ns:p2p:config-base\n   Registrant\
    \ Contact: IESG.\n   XML: N/A, the requested URIs are XML namespaces\n"
- title: 14.17.2.  Config Chord URL
  contents:
  - "14.17.2.  Config Chord URL\n   URI: urn:ietf:params:xml:ns:p2p:config-chord\n\
    \   Registrant Contact: The IESG.\n   XML: N/A, the requested URIs are XML namespaces\n"
- title: 15.  Acknowledgments
  contents:
  - "15.  Acknowledgments\n   This specification is a merge of the \"REsource LOcation\
    \ And Discovery\n   (RELOAD)\" document by David A. Bryan, Marcia Zangrilli, and\
    \ Bruce B.\n   Lowekamp; the \"Address Settlement by Peer to Peer\" document by\
    \ Cullen\n   Jennings, Jonathan Rosenberg, and Eric Rescorla; the \"Security\n\
    \   Extensions for RELOAD\" document by Bruce B. Lowekamp and James\n   Deverick;\
    \ the \"A Chord-based DHT for Resource Lookup in P2PSIP\" by\n   Marcia Zangrilli\
    \ and David A. Bryan; and the Peer-to-Peer Protocol\n   (P2PP) document by Salman\
    \ A. Baset, Henning Schulzrinne, and Marcin\n   Matuszewski.  Thanks to the authors\
    \ of [RFC5389] for text included\n   from that document.  Vidya Narayanan provided\
    \ many comments and\n   improvements.\n   The ideas and text for the Chord-specific\
    \ extension data to the Leave\n   mechanisms were provided by Jouni Maenpaa, Gonzalo\
    \ Camarillo, and\n   Jani Hautakorpi.\n   Thanks to the many people who contributed,\
    \ including Ted Hardie,\n   Michael Chen, Dan York, Das Saumitra, Lyndsay Campbell,\
    \ Brian Rosen,\n   David Bryan, Dave Craig, and Julian Cain.  Extensive last call\n\
    \   comments were provided by Jouni Maenpaa, Roni Even, Gonzalo\n   Camarillo,\
    \ Ari Keranen, John Buford, Michael Chen, Frederic-Philippe\n   Met, Mary Barnes,\
    \ Roland Bless, David Bryan, and Polina Goltsman.\n   Special thanks to Marc Petit-Huguenin,\
    \ who provided an amazing amount\n   of detailed review.\n   Dean Willis and Marc\
    \ Petit-Huguenin helped resolve and provided text\n   to fix many comments received\
    \ during the IESG review.\n"
- title: 16.  References
  contents:
  - '16.  References

    '
- title: 16.1.  Normative References
  contents:
  - "16.1.  Normative References\n   [OASIS.relax_ng]\n              Bray, T. and\
    \ M. Murata, \"RELAX NG Specification\", December\n              2001.\n   [RFC1918]\
    \  Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and\n              E.\
    \ Lear, \"Address Allocation for Private Internets\", BCP\n              5, RFC\
    \ 1918, February 1996.\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [RFC2388]  Masinter, L., \"Returning Values from Forms: multipart/\n     \
    \         form-data\", RFC 2388, August 1998.\n   [RFC2585]  Housley, R. and P.\
    \ Hoffman, \"Internet X.509 Public Key\n              Infrastructure Operational\
    \ Protocols: FTP and HTTP\", RFC\n              2585, May 1999.\n   [RFC2782]\
    \  Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for\n              specifying\
    \ the location of services (DNS SRV)\", RFC 2782,\n              February 2000.\n\
    \   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.\n   [RFC3023]\
    \  Murata, M., St. Laurent, S., and D. Kohn, \"XML Media\n              Types\"\
    , RFC 3023, January 2001.\n   [RFC3174]  Eastlake, D. and P. Jones, \"US Secure\
    \ Hash Algorithm 1\n              (SHA1)\", RFC 3174, September 2001.\n   [RFC3339]\
    \  Klyne, G., Ed. and C. Newman, \"Date and Time on the\n              Internet:\
    \ Timestamps\", RFC 3339, July 2002.\n   [RFC3447]  Jonsson, J. and B. Kaliski,\
    \ \"Public-Key Cryptography\n              Standards (PKCS) #1: RSA Cryptography\
    \ Specifications\n              Version 2.1\", RFC 3447, February 2003.\n   [RFC3629]\
    \  Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\"\
    , STD 63, RFC 3629, November 2003.\n   [RFC3986]  Berners-Lee, T., Fielding, R.,\
    \ and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic\
    \ Syntax\", STD 66, RFC\n              3986, January 2005.\n   [RFC4279]  Eronen,\
    \ P. and H. Tschofenig, \"Pre-Shared Key Ciphersuites\n              for Transport\
    \ Layer Security (TLS)\", RFC 4279, December\n              2005.\n   [RFC4395]\
    \  Hansen, T., Hardie, T., and L. Masinter, \"Guidelines and\n              Registration\
    \ Procedures for New URI Schemes\", BCP 35, RFC\n              4395, February\
    \ 2006.\n   [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n\
    \              Encodings\", RFC 4648, October 2006.\n   [RFC5226]  Narten, T.\
    \ and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n   [RFC5245]\
    \  Rosenberg, J., \"Interactive Connectivity Establishment\n              (ICE):\
    \ A Protocol for Network Address Translator (NAT)\n              Traversal for\
    \ Offer/Answer Protocols\", RFC 5245, April\n              2010.\n   [RFC5246]\
    \  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)\
    \ Protocol Version 1.2\", RFC 5246, August 2008.\n   [RFC5272]  Schaad, J. and\
    \ M. Myers, \"Certificate Management over CMS\n              (CMC)\", RFC 5272,\
    \ June 2008.\n   [RFC5273]  Schaad, J. and M. Myers, \"Certificate Management\
    \ over CMS\n              (CMC): Transport Protocols\", RFC 5273, June 2008.\n\
    \   [RFC5389]  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,\n         \
    \     \"Session Traversal Utilities for NAT (STUN)\", RFC 5389,\n            \
    \  October 2008.\n   [RFC5405]  Eggert, L. and G. Fairhurst, \"Unicast UDP Usage\
    \ Guidelines\n              for Application Designers\", BCP 145, RFC 5405, November\n\
    \              2008.\n   [RFC5766]  Mahy, R., Matthews, P., and J. Rosenberg,\
    \ \"Traversal Using\n              Relays around NAT (TURN): Relay Extensions\
    \ to Session\n              Traversal Utilities for NAT (STUN)\", RFC 5766, April\
    \ 2010.\n   [RFC5952]  Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6\n\
    \              Address Text Representation\", RFC 5952, August 2010.\n   [RFC6091]\
    \  Mavrogiannopoulos, N. and D. Gillmor, \"Using OpenPGP Keys\n              for\
    \ Transport Layer Security (TLS) Authentication\", RFC\n              6091, February\
    \ 2011.\n   [RFC6234]  Eastlake, D. and T. Hansen, \"US Secure Hash Algorithms\n\
    \              (SHA and SHA-based HMAC and HKDF)\", RFC 6234, May 2011.\n   [RFC6298]\
    \  Paxson, V., Allman, M., Chu, J., and M. Sargent,\n              \"Computing\
    \ TCP's Retransmission Timer\", RFC 6298, June\n              2011.\n   [RFC6347]\
    \  Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n              Security\
    \ Version 1.2\", RFC 6347, January 2012.\n   [W3C.REC-xmlschema-2-20041028]\n\
    \              Malhotra, A. and P. Biron, \"XML Schema Part 2: Datatypes\n   \
    \           Second Edition\", World Wide Web Consortium Recommendation\n     \
    \         REC-xmlschema-2-20041028, October 2004,\n              <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.\n\
    \   [w3c-xml-namespaces]\n              Bray, T., Hollander, D., Layman, A., Tobin,\
    \ R., and\n              University of Edinburgh and W3C, \"Namespaces in XML\
    \ 1.0\n              (Third Edition)\", December 2008.\n"
- title: 16.2.  Informative References
  contents:
  - "16.2.  Informative References\n   [Chord]    Stoica, I., Morris, R., Liben-Nowell,\
    \ D., Karger, D.,\n              Kaashoek, M., Dabek, F., and H. Balakrishnan,\
    \ \"Chord: A\n              Scalable Peer-to-peer Lookup Protocol for Internet\n\
    \              Applications\", IEEE/ACM Transactions on Networking Volume\n  \
    \            11, Issue 1, 17-32, Feb 2003, 2001.\n   [DHT-RELOAD]\n          \
    \    Maenpaa, J. and G. Camarillo, \"A Self-tuning Distributed\n             \
    \ Hash Table (DHT) for REsource LOcation And Discovery\n              (RELOAD)\"\
    , Work in Progress, August 2013.\n   [Eclipse]  Singh, A., Ngan, T., Druschel,\
    \ T., and D. Wallach,\n              \"Eclipse Attacks on Overlay Networks: Threats\
    \ and\n              Defenses\", INFOCOM 2006, April 2006.\n   [P2P-DIAGNOSTICS]\n\
    \              Song, H., Jiang, X., Even, R., and D. Bryan, \"P2P Overlay\n  \
    \            Diagnostics\", Work in Progress, August 2013.\n   [P2PSIP-RELAY]\n\
    \              Zong, N., Jiang, X., Even, R., and Y. Zhang, \"An extension\n \
    \             to RELOAD to support Relay Peer Routing\", Work in\n           \
    \   Progress, October 2013.\n   [REDIR-RELOAD]\n              Maenpaa, J. and\
    \ G. Camarillo, \"Service Discovery Usage for\n              REsource LOcation\
    \ And Discovery (RELOAD)\", Work in\n              Progress, August 2013.\n  \
    \ [RFC1035]  Mockapetris, P., \"Domain names - implementation and\n          \
    \    specification\", STD 13, RFC 1035, November 1987.\n   [RFC1122]  Braden,\
    \ R., \"Requirements for Internet Hosts -\n              Communication Layers\"\
    , STD 3, RFC 1122, October 1989.\n   [RFC2311]  Dusse, S., Hoffman, P., Ramsdell,\
    \ B., Lundblade, L., and\n              L. Repka, \"S/MIME Version 2 Message Specification\"\
    , RFC\n              2311, March 1998.\n   [RFC3688]  Mealling, M., \"The IETF\
    \ XML Registry\", BCP 81, RFC 3688,\n              January 2004.\n   [RFC4013]\
    \  Zeilenga, K., \"SASLprep: Stringprep Profile for User Names\n             \
    \ and Passwords\", RFC 4013, February 2005.\n   [RFC4086]  Eastlake, D., Schiller,\
    \ J., and S. Crocker, \"Randomness\n              Requirements for Security\"\
    , BCP 106, RFC 4086, June 2005.\n   [RFC4145]  Yon, D. and G. Camarillo, \"TCP-Based\
    \ Media Transport in\n              the Session Description Protocol (SDP)\",\
    \ RFC 4145,\n              September 2005.\n   [RFC4340]  Kohler, E., Handley,\
    \ M., and S. Floyd, \"Datagram\n              Congestion Control Protocol (DCCP)\"\
    , RFC 4340, March 2006.\n   [RFC4787]  Audet, F. and C. Jennings, \"Network Address\
    \ Translation\n              (NAT) Behavioral Requirements for Unicast UDP\",\
    \ BCP 127,\n              RFC 4787, January 2007.\n   [RFC4960]  Stewart, R.,\
    \ \"Stream Control Transmission Protocol\", RFC\n              4960, September\
    \ 2007.\n   [RFC5054]  Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin,\n\
    \              \"Using the Secure Remote Password (SRP) Protocol for TLS\n   \
    \           Authentication\", RFC 5054, November 2007.\n   [RFC5095]  Abley, J.,\
    \ Savola, P., and G. Neville-Neil, \"Deprecation\n              of Type 0 Routing\
    \ Headers in IPv6\", RFC 5095, December\n              2007.\n   [RFC5201]  Moskowitz,\
    \ R., Nikander, P., Jokela, P., and T. Henderson,\n              \"Host Identity\
    \ Protocol\", RFC 5201, April 2008.\n   [RFC5280]  Cooper, D., Santesson, S.,\
    \ Farrell, S., Boeyen, S.,\n              Housley, R., and W. Polk, \"Internet\
    \ X.509 Public Key\n              Infrastructure Certificate and Certificate Revocation\
    \ List\n              (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5694]  Camarillo,\
    \ G., Ed., and IAB, \"Peer-to-Peer (P2P)\n              Architecture: Definition,\
    \ Taxonomies, Examples, and\n              Applicability\", RFC 5694, November\
    \ 2009.\n   [RFC5765]  Schulzrinne, H., Marocco, E., and E. Ivov, \"Security\n\
    \              Issues and Solutions in Peer-to-Peer Systems for Realtime\n   \
    \           Communications\", RFC 5765, February 2010.\n   [RFC5785]  Nottingham,\
    \ M. and E. Hammer-Lahav, \"Defining Well-Known\n              Uniform Resource\
    \ Identifiers (URIs)\", RFC 5785, April\n              2010.\n   [RFC6079]  Camarillo,\
    \ G., Nikander, P., Hautakorpi, J., Keranen, A.,\n              and A. Johnston,\
    \ \"HIP BONE: Host Identity Protocol (HIP)\n              Based Overlay Networking\
    \ Environment (BONE)\", RFC 6079,\n              January 2011.\n   [RFC6544] \
    \ Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach,\n              \"TCP\
    \ Candidates with Interactive Connectivity\n              Establishment (ICE)\"\
    , RFC 6544, March 2012.\n   [RFC7086]  Keranen, A., Camarillo, G., and J. Maenpaa,\
    \ \"Host Identity\n              Protocol-Based Overlay Networking Environment\
    \ (HIP BONE)\n              Instance Specification for REsource LOcation And Discovery\n\
    \              (RELOAD)\", RFC 7086, January 2014.\n   [SIP-RELOAD]\n        \
    \      Jennings, C., Lowekamp, B., Rescorla, E., Baset, S.,\n              Schulzrinne,\
    \ H., and T. Schmidt, \"A SIP Usage for RELOAD\",\n              Work in Progress,\
    \ July 2013.\n   [Sybil]    Douceur, J., \"The Sybil Attack\", IPTPS 02, March\
    \ 2002.\n   [UnixTime] Wikipedia, \"Unix Time\", 2013, <http://en.wikipedia.org/w/\n\
    \              index.php?title=Unix_time&oldid=551527446>.\n   [bryan-design-hotp2p08]\n\
    \              Bryan, D., Lowekamp, B., and M. Zangrilli, \"The Design of\n  \
    \            a Versatile, Secure P2PSIP Communications Architecture for\n    \
    \          the Public Internet\", Hot-P2P'08, 2008.\n   [handling-churn-usenix04]\n\
    \              Rhea, S., Geels, D., Roscoe, T., and J. Kubiatowicz,\n        \
    \      \"Handling Churn in a DHT\", In Proc. of the USENIX Annual\n          \
    \    Technical Conference June 2004 USENIX 2004, 2004.\n   [lookups-churn-p2p06]\n\
    \              Wu, D., Tian, Y., and K. Ng, \"Analytical Study on\n          \
    \    Improving DHT Lookup Performance under Churn\", IEEE\n              P2P'06,\
    \ 2006.\n   [minimizing-churn-sigcomm06]\n              Godfrey, P., Shenker,\
    \ S., and I. Stoica, \"Minimizing Churn\n              in Distributed Systems\"\
    , SIGCOMM 2006, 2006.\n   [non-transitive-dhts-worlds05]\n              Freedman,\
    \ M., Lakshminarayanan, K., Rhea, S., and I.\n              Stoica, \"Non-Transitive\
    \ Connectivity and DHTs\", WORLDS'05,\n              2005.\n   [opendht-sigcomm05]\n\
    \              Rhea, S., Godfrey, B., Karp, B., Kubiatowicz, J.,\n           \
    \   Ratnasamy, S., Shenker, S., Stoica, I., and H. Yu,\n              \"OpenDHT:\
    \ A Public DHT and its Uses\", SIGCOMM'05, 2005.\n   [vulnerabilities-acsac04]\n\
    \              Srivatsa, M. and L. Liu, \"Vulnerabilities and Security\n     \
    \         Threats in Structured Peer-to-Peer Systems: A Quantitative\n       \
    \       Analysis\", ACSAC 2004, 2004.\n   [wikiChord]\n              Wikipedia,\
    \ \"Chord (peer-to-peer)\", 2013,\n              <http://en.wikipedia.org/w/\n\
    \              index.php?title=Chord_%28peer-to-peer%29&oldid=549516287>.\n  \
    \ [wikiKBR]  Wikipedia, \"Key-based routing\", 2013, <en.wikipedia.org/w/\n  \
    \            index.php?title=Key-based_routing&oldid=543850833>.\n   [wikiSkiplist]\n\
    \              Wikipedia, \"Skip list\", 2013, <http://en.wikipedia.org/w/\n \
    \             index.php?title=Skip_list&oldid=551304213>.\n"
- title: Appendix A.  Routing Alternatives
  contents:
  - "Appendix A.  Routing Alternatives\n   Significant discussion has been focused\
    \ on the selection of a routing\n   algorithm for P2PSIP.  This section discusses\
    \ the motivations for\n   selecting symmetric recursive routing for RELOAD and\
    \ describes the\n   extensions that would be required to support additional routing\n\
    \   algorithms.\n"
- title: A.1.  Iterative vs. Recursive
  contents:
  - "A.1.  Iterative vs. Recursive\n   Iterative routing has a number of advantages.\
    \  It is easier to debug,\n   consumes fewer resources on intermediate peers,\
    \ and allows the\n   querying peer to identify and route around misbehaving peers\n\
    \   [non-transitive-dhts-worlds05].  However, in the presence of NATs,\n   iterative\
    \ routing is intolerably expensive, because a new connection\n   must be established\
    \ for each hop (using ICE) [bryan-design-hotp2p08].\n   Iterative routing is supported\
    \ through the RouteQuery mechanism and\n   is primarily intended for debugging.\
    \  It also allows the querying\n   peer to evaluate the routing decisions made\
    \ by the peers at each hop,\n   consider alternatives, and perhaps detect at what\
    \ point the\n   forwarding path fails.\n"
- title: A.2.  Symmetric vs. Forward Response
  contents:
  - "A.2.  Symmetric vs. Forward Response\n   An alternative to the symmetric recursive\
    \ routing method used by\n   RELOAD is forward-only routing, where the response\
    \ is routed to the\n   requester as if it were a new message initiated by the\
    \ responder.\n   (In the previous example, Z sends the response to A as if it\
    \ were\n   sending a request.)  Forward-only routing requires no state in either\n\
    \   the message or intermediate peers.\n   The drawback of forward-only routing\
    \ is that it does not work when\n   the overlay is unstable.  For example, if\
    \ A is in the process of\n   joining the overlay and is sending a Join request\
    \ to Z, it is not yet\n   reachable via forward-only routing.  Even if it is established\
    \ in the\n   overlay, if network failures produce temporary instability, A may\
    \ not\n   be reachable (and may be trying to stabilize its network connectivity\n\
    \   via Attach messages).\n   Furthermore, forward-only responses are less likely\
    \ to reach the\n   querying peer than symmetric recursive ones are, because the\
    \ forward\n   path is more likely to have a failed peer than is the request path\n\
    \   (which was just tested to route the request)\n   [non-transitive-dhts-worlds05].\n\
    \   An extension to RELOAD that supports forward-only routing but relies\n   on\
    \ symmetric responses as a fallback would be possible, but due to\n   the complexities\
    \ of determining when to use forward-only routing and\n   when to fallback to\
    \ symmetric routing, we have chosen not to include\n   it as an option at this\
    \ point.\n"
- title: A.3.  Direct Response
  contents:
  - "A.3.  Direct Response\n   Another routing option is direct response routing,\
    \ in which the\n   response is returned directly to the querying node.  In the\
    \ previous\n   example, if A encodes its IP address in the request, then Z can\n\
    \   simply deliver the response directly to A.  In the absence of NATs or\n  \
    \ other connectivity issues, this is the optimal routing technique.\n   The challenge\
    \ of implementing direct response routing is the presence\n   of NATs.  There\
    \ are a number of complexities that must be addressed.\n   In this discussion,\
    \ we will continue our assumption that A issued the\n   request and Z is generating\
    \ the response.\n   o  The IP address listed by A may be unreachable, either due\
    \ to NAT\n      or firewall rules.  Therefore, a direct response technique must\n\
    \      fallback to symmetric response [non-transitive-dhts-worlds05].\n      The\
    \ hop-by-hop ACKs used by RELOAD allow Z to determine when A has\n      received\
    \ the message (and the TLS negotiation will provide earlier\n      confirmation\
    \ that A is reachable), but this fallback requires a\n      timeout that will\
    \ increase the response latency whenever A is not\n      reachable from Z.\n \
    \  o  Whenever A is behind a NAT it, will have multiple candidate IP\n      addresses,\
    \ each of which must be advertised to ensure\n      connectivity.  Therefore,\
    \ Z will need to attempt multiple\n      connections to deliver the response.\n\
    \   o  One (or all) of A's candidate addresses may route from Z to a\n      different\
    \ device on the Internet.  In the worst case, these nodes\n      may actually\
    \ be running RELOAD on the same port.  Therefore, it is\n      absolutely necessary\
    \ to establish a secure connection to\n      authenticate A before delivering\
    \ the response.  This step\n      diminishes the efficiency of direct response\
    \ routing, because\n      multiple round-trips are required before the message\
    \ can be\n      delivered.\n   o  If A is behind a NAT and does not have a connection\
    \ already\n      established with Z, there are only two ways the direct response\n\
    \      will work.  The first is that A and Z must both be behind the same\n  \
    \    NAT, in which case the NAT is not involved.  In the more common\n      case,\
    \ when Z is outside A's NAT, the response will be received\n      only if A's\
    \ NAT implements endpoint-independent filtering.  As the\n      choice of filtering\
    \ mode conflates application transparency with\n      security [RFC4787] and no\
    \ clear recommendation is available, the\n      prevalence of this feature in\
    \ future devices remains unclear.\n   An extension to RELOAD that supports direct\
    \ response routing but\n   relies on symmetric responses as a fallback would be\
    \ possible, but\n   due to the complexities of determining when to use direct\
    \ response\n   routing and when to fallback to symmetric routing, and the reduced\n\
    \   performance for responses to peers behind restrictive NATs, we have\n   chosen\
    \ not to include it as an option at this point.\n"
- title: A.4.  Relay Peers
  contents:
  - "A.4.  Relay Peers\n   [P2PSIP-RELAY] has proposed implementing a form of direct\
    \ response by\n   having A identify a peer, Q, that will be directly reachable\
    \ by any\n   other peer.  A uses Attach to establish a connection with Q and\n\
    \   advertises Q's IP address in the request sent to Z.  Z sends the\n   response\
    \ to Q, which relays it to A.  This then reduces the latency\n   to two hops,\
    \ and Z is negotiating a secure connection to Q.\n   This technique relies on\
    \ the relative population of nodes such as A\n   that require relay peers and\
    \ peers such as Q that are capable of\n   serving as a relay peer.  It also requires\
    \ nodes to be able to\n   identify which category they are in.  This identification\
    \ problem has\n   turned out to be hard to solve and is still an open area of\n\
    \   exploration.\n   An extension to RELOAD that supports relay peers is possible,\
    \ but due\n   to the complexities of implementing such an alternative, we have\
    \ not\n   added such a feature to RELOAD at this point.\n   A concept similar\
    \ to relay peers, essentially choosing a relay peer\n   at random, has previously\
    \ been suggested to solve problems of pair-\n   wise non-transitivity [non-transitive-dhts-worlds05],\
    \ but\n   deterministic filtering provided by NATs makes random relay peers no\n\
    \   more likely to work than the responding peer.\n"
- title: A.5.  Symmetric Route Stability
  contents:
  - "A.5.  Symmetric Route Stability\n   A common concern about symmetric recursive\
    \ routing has been that one\n   or more peers along the request path may fail\
    \ before the response is\n   received.  The significance of this problem essentially\
    \ depends on\n   the response latency of the overlay.  An overlay that produces\
    \ slow\n   responses will be vulnerable to churn, whereas responses that are\n\
    \   delivered very quickly are vulnerable only to failures that occur\n   over\
    \ that small interval.\n   The other aspect of this issue is whether the request\
    \ itself can be\n   successfully delivered.  Assuming typical connection maintenance\n\
    \   intervals, the time period between the last maintenance and the\n   request\
    \ being sent will be orders of magnitude greater than the delay\n   between the\
    \ request being forwarded and the response being received.\n   Therefore, if the\
    \ path was stable enough to be available to route the\n   request, it is almost\
    \ certainly going to remain available to route\n   the response.\n   An overlay\
    \ that is unstable enough to suffer this type of failure\n   frequently is unlikely\
    \ to be able to support reliable functionality\n   regardless of the routing mechanism.\
    \  However, regardless of the\n   stability of the return path, studies show that\
    \ in the event of high\n   churn, iterative routing is a better solution to ensure\
    \ request\n   completion [lookups-churn-p2p06] [non-transitive-dhts-worlds05]\n\
    \   Finally, because RELOAD retries the end-to-end request, that retry\n   will\
    \ address the issues of churn that remain.\n"
- title: Appendix B.  Why Clients?
  contents:
  - "Appendix B.  Why Clients?\n   There are a wide variety of reasons a node may\
    \ act as a client rather\n   than as a peer.  This section outlines some of those\
    \ scenarios and\n   how the client's behavior changes based on its capabilities.\n"
- title: B.1.  Why Not Only Peers?
  contents:
  - "B.1.  Why Not Only Peers?\n   For a number of reasons, a particular node may\
    \ be forced to act as a\n   client even though it is willing to act as a peer.\
    \  These include:\n   o  The node does not have appropriate network connectivity,\
    \ typically\n      because it has a low-bandwidth network connection.\n   o  The\
    \ node may not have sufficient resources, such as computing\n      power, storage\
    \ space, or battery power.\n   o  The overlay algorithm may dictate specific requirements\
    \ for peer\n      selection.  These may include participating in the overlay to\n\
    \      determine trustworthiness, controlling the number of peers in the\n   \
    \   overlay to reduce overly long routing paths, and ensuring minimum\n      application\
    \ uptime before a node can join as a peer.\n   The ultimate criteria for a node\
    \ to become a peer are determined by\n   the overlay algorithm and specific deployment.\
    \  A node acting as a\n   client that has a full implementation of RELOAD and\
    \ the appropriate\n   overlay algorithm is capable of locating its responsible\
    \ peer in the\n   overlay and using Attach to establish a direct connection to\
    \ that\n   peer.  In that way, it may elect to be reachable under either of the\n\
    \   routing approaches listed above.  Particularly for overlay algorithms\n  \
    \ that elect nodes to serve as peers based on trustworthiness or\n   population,\
    \ the overlay algorithm may require such a client to locate\n   itself at a particular\
    \ place in the overlay.\n"
- title: B.2.  Clients as Application-Level Agents
  contents:
  - "B.2.  Clients as Application-Level Agents\n   SIP defines an extensive protocol\
    \ for registration and security\n   between a client and its registrar/proxy server(s).\
    \  Any SIP device\n   can act as a client of a RELOAD-based P2PSIP overlay if\
    \ it contacts a\n   peer that implements the server-side functionality required\
    \ by the\n   SIP protocol.  In this case, the peer would be acting as if it were\n\
    \   the user's peer and would need the appropriate credentials for that\n   user.\n\
    \   Application-level support for clients is defined by a usage.  A usage\n  \
    \ offering support for application-level clients should specify how the\n   security\
    \ of the system is maintained when the data is moved between\n   the application\
    \ and RELOAD layers.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Cullen Jennings\n   Cisco\n   400 3rd Avenue SW, Suite\
    \ 350\n   Calgary\n   Canada\n   EMail: fluffy@cisco.com\n   Bruce B. Lowekamp\
    \ (editor)\n   Skype\n   Palo Alto, CA\n   USA\n   EMail: bbl@lowekamp.net\n \
    \  Eric Rescorla\n   RTFM, Inc.\n   2064 Edgewood Drive\n   Palo Alto, CA  94303\n\
    \   USA\n   Phone: +1 650 678 2350\n   EMail: ekr@rtfm.com\n   Salman A. Baset\n\
    \   Columbia University\n   1214 Amsterdam Avenue\n   New York, NY\n   USA\n \
    \  EMail: salman@cs.columbia.edu\n   Henning Schulzrinne\n   Columbia University\n\
    \   1214 Amsterdam Avenue\n   New York, NY\n   USA\n   EMail: hgs@cs.columbia.edu\n"
