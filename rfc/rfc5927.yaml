- title: __initial_text__
  contents:
  - '                        ICMP Attacks against TCP

    '
- title: Abstract
  contents:
  - "Abstract\n   This document discusses the use of the Internet Control Message\n\
    \   Protocol (ICMP) to perform a variety of attacks against the\n   Transmission\
    \ Control Protocol (TCP).  Additionally, this document\n   describes a number\
    \ of widely implemented modifications to TCP's\n   handling of ICMP error messages\
    \ that help to mitigate these issues.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc5927.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n   2.  Background . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  5\n     2.1.  The Internet Control Message Protocol (ICMP) . . .\
    \ . . . .  5\n       2.1.1.  ICMP for IP version 4 (ICMPv4) . . . . . . . . .\
    \ . . .  5\n       2.1.2.  ICMP for IP version 6 (ICMPv6) . . . . . . . . . .\
    \ . .  6\n     2.2.  Handling of ICMP Error Messages  . . . . . . . . . . . .\
    \ .  6\n     2.3.  Handling of ICMP Error Messages in the Context of IPsec  .\
    \  7\n   3.  Constraints in the Possible Solutions  . . . . . . . . . . . .  8\n\
    \   4.  General Counter-Measures against ICMP Attacks  . . . . . . . . 10\n  \
    \   4.1.  TCP Sequence Number Checking . . . . . . . . . . . . . . . 10\n    \
    \ 4.2.  Port Randomization . . . . . . . . . . . . . . . . . . . . 11\n     4.3.\
    \  Filtering ICMP Error Messages Based on the ICMP Payload  . 11\n   5.  Blind\
    \ Connection-Reset Attack  . . . . . . . . . . . . . . . . 12\n     5.1.  Description\
    \  . . . . . . . . . . . . . . . . . . . . . . . 12\n     5.2.  Attack-Specific\
    \ Counter-Measures . . . . . . . . . . . . . 13\n   6.  Blind Throughput-Reduction\
    \ Attack  . . . . . . . . . . . . . . 16\n     6.1.  Description  . . . . . .\
    \ . . . . . . . . . . . . . . . . . 16\n     6.2.  Attack-Specific Counter-Measures\
    \ . . . . . . . . . . . . . 16\n   7.  Blind Performance-Degrading Attack . .\
    \ . . . . . . . . . . . . 16\n     7.1.  Description  . . . . . . . . . . . .\
    \ . . . . . . . . . . . 16\n     7.2.  Attack-Specific Counter-Measures . . .\
    \ . . . . . . . . . . 18\n     7.3.  The Counter-Measure for the PMTUD Attack\
    \ in Action . . . . 22\n       7.3.1.  Normal Operation for Bulk Transfers  .\
    \ . . . . . . . . 22\n       7.3.2.  Operation during Path-MTU Changes  . . .\
    \ . . . . . . . 24\n       7.3.3.  Idle Connection Being Attacked . . . . . .\
    \ . . . . . . 25\n       7.3.4.  Active Connection Being Attacked after Discovery\n\
    \               of the Path-MTU  . . . . . . . . . . . . . . . . . . . 26\n  \
    \     7.3.5.  TCP Peer Attacked when Sending Small Packets Just\n            \
    \   after the Three-Way Handshake  . . . . . . . . . . . . 26\n     7.4.  Pseudo-Code\
    \ for the Counter-Measure for the Blind\n           Performance-Degrading Attack\
    \ . . . . . . . . . . . . . . . 27\n   8.  Security Considerations  . . . . .\
    \ . . . . . . . . . . . . . . 30\n   9.  Acknowledgements . . . . . . . . . .\
    \ . . . . . . . . . . . . . 32\n   10. References . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . 32\n     10.1. Normative References . . . . . . . .\
    \ . . . . . . . . . . . 32\n     10.2. Informative References . . . . . . . .\
    \ . . . . . . . . . . 33\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   ICMP [RFC0792] [RFC4443] is a fundamental part of the TCP/IP\
    \ protocol\n   suite, and is used mainly for reporting network error conditions.\n\
    \   However, the current specifications do not recommend any kind of\n   validation\
    \ checks on the received ICMP error messages, thus allowing\n   a variety of attacks\
    \ against TCP [RFC0793] by means of ICMP, which\n   include blind connection-reset,\
    \ blind throughput-reduction, and blind\n   performance-degrading attacks.  All\
    \ of these attacks can be performed\n   even when the attacker is off-path, without\
    \ the need to sniff the\n   packets that correspond to the attacked TCP connection.\n\
    \   While the possible security implications of ICMP have been known in\n   the\
    \ research community for a long time, there has never been an\n   official proposal\
    \ on how to deal with these vulnerabilities.  In\n   2005, a disclosure process\
    \ was carried out by the UK's National\n   Infrastructure Security Co-ordination\
    \ Centre (NISCC) (now CPNI,\n   Centre for the Protection of National Infrastructure),\
    \ with the\n   collaboration of other computer emergency response teams.  A large\n\
    \   number of implementations were found vulnerable to either all or a\n   subset\
    \ of the attacks discussed in this document [NISCC][US-CERT].\n   The affected\
    \ systems ranged from TCP/IP implementations meant for\n   desktop computers,\
    \ to TCP/IP implementations meant for core Internet\n   routers.\n   It is clear\
    \ that implementations should be more cautious when\n   processing ICMP error\
    \ messages, to eliminate or mitigate the use of\n   ICMP to perform attacks against\
    \ TCP [RFC4907].\n   This document aims to raise awareness of the use of ICMP\
    \ to perform a\n   variety of attacks against TCP, and discusses several counter-\n\
    \   measures that eliminate or minimize the impact of these attacks.\n   Most\
    \ of the these counter-measures can be implemented while still\n   remaining compliant\
    \ with the current specifications, as they simply\n   describe reasons for not\
    \ taking the advice provided in the\n   specifications in terms of \"SHOULDs\"\
    , but still comply with the\n   requirements stated as \"MUSTs\".\n   We note\
    \ that the counter-measures discussed in this document are not\n   part of standard\
    \ TCP behavior, and this document does not change that\n   state of affairs. \
    \ The consensus of the TCPM WG (TCP Maintenance and\n   Minor Extensions Working\
    \ Group) was to document this widespread\n   implementation of nonstandard TCP\
    \ behavior but to not change the TCP\n   standard.\n   Section 2 provides background\
    \ information on ICMP.  Section 3\n   discusses the constraints in the general\
    \ counter-measures that can be\n   implemented against the attacks described in\
    \ this document.\n   Section 4 describes several general validation checks that\
    \ can be\n   implemented to mitigate any ICMP-based attack.  Finally, Section\
    \ 5,\n   Section 6, and Section 7, discuss a variety of ICMP attacks that can\n\
    \   be performed against TCP, and describe attack-specific counter-\n   measures\
    \ that eliminate or greatly mitigate their impact.\n   The key words \"MUST\"\
    , \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to\
    \ be interpreted as described in RFC 2119 [RFC2119].\n"
- title: 2.  Background
  contents:
  - '2.  Background

    '
- title: 2.1.  The Internet Control Message Protocol (ICMP)
  contents:
  - "2.1.  The Internet Control Message Protocol (ICMP)\n   The Internet Control Message\
    \ Protocol (ICMP) is used in the Internet\n   architecture mainly to perform the\
    \ fault-isolation function, that is,\n   the group of actions that hosts and routers\
    \ take to determine that\n   there is some network failure [RFC0816].\n   When\
    \ an intermediate router detects a network problem while trying to\n   forward\
    \ an IP packet, it will usually send an ICMP error message to\n   the source system,\
    \ to inform the source system of the network problem\n   taking place.  In the\
    \ same way, there are a number of scenarios in\n   which an end-system may generate\
    \ an ICMP error message if it finds a\n   problem while processing a datagram.\
    \  The received ICMP errors are\n   handed to the corresponding transport-protocol\
    \ instance, which will\n   usually perform a fault recovery function.\n   It is\
    \ important to note that ICMP error messages are transmitted\n   unreliably and\
    \ may be discarded due to data corruption, network\n   congestion, or rate-limiting.\
    \  Thus, while they provide useful\n   information, upper-layer protocols cannot\
    \ depend on ICMP for correct\n   operation.\n   It should be noted that there\
    \ are no timeliness requirements for ICMP\n   error messages.  ICMP error messages\
    \ could be delayed for various\n   reasons, and at least in theory could be received\
    \ with an arbitrarily\n   long delay.  For example, there are no existing requirements\
    \ that a\n   router flush any queued ICMP error messages when it is rebooted.\n"
- title: 2.1.1.  ICMP for IP version 4 (ICMPv4)
  contents:
  - "2.1.1.  ICMP for IP version 4 (ICMPv4)\n   [RFC0792] specifies the Internet Control\
    \ Message Protocol (ICMP) to\n   be used with the Internet Protocol version 4\
    \ (IPv4) -- henceforth\n   \"ICMPv4\".  It defines, among other things, a number\
    \ of error messages\n   that can be used by end-systems and intermediate systems\
    \ to report\n   errors to the sending system.  The Host Requirements RFC [RFC1122]\n\
    \   classifies ICMPv4 error messages into those that indicate \"soft\n   errors\"\
    , and those that indicate \"hard errors\", thus roughly defining\n   the semantics\
    \ of them.\n   The ICMPv4 specification [RFC0792] also defines the ICMPv4 Source\n\
    \   Quench message (type 4, code 0), which is meant to provide a\n   mechanism\
    \ for flow control and congestion control.\n   [RFC1191] defines a mechanism called\
    \ \"Path MTU Discovery\" (PMTUD),\n   which makes use of ICMPv4 error messages\
    \ of type 3 (Destination\n   Unreachable), code 4 (fragmentation needed and DF\
    \ bit set) to allow\n   systems to determine the MTU of an arbitrary internet\
    \ path.\n   Finally, [RFC4884] redefines selected ICMPv4 messages to include an\n\
    \   extension structure and a length attribute, such that those ICMPv4\n   messages\
    \ can carry additional information by encoding that\n   information in the extension\
    \ structure.\n   Appendix D of [RFC4301] provides information about which ICMPv4\
    \ error\n   messages are produced by hosts, intermediate routers, or both.\n"
- title: 2.1.2.  ICMP for IP version 6 (ICMPv6)
  contents:
  - "2.1.2.  ICMP for IP version 6 (ICMPv6)\n   [RFC4443] specifies the Internet Control\
    \ Message Protocol (ICMPv6) to\n   be used with the Internet Protocol version\
    \ 6 (IPv6) [RFC2460].\n   [RFC4443] defines the \"Packet Too Big\" (type 2, code\
    \ 0) error\n   message, which is analogous to the ICMPv4 \"fragmentation needed\
    \ and\n   DF bit set\" (type 3, code 4) error message.  [RFC1981] defines the\n\
    \   Path MTU Discovery mechanism for IP version 6, which makes use of\n   these\
    \ messages to determine the MTU of an arbitrary internet path.\n   Finally, [RFC4884]\
    \ redefines selected ICMPv6 messages to include an\n   extension structure and\
    \ a length attribute, such that those ICMPv6\n   messages can carry additional\
    \ information by encoding that\n   information in the extension structure.\n \
    \  Appendix D of [RFC4301] provides information about which ICMPv6 error\n   messages\
    \ are produced by hosts, intermediate routers, or both.\n"
- title: 2.2.  Handling of ICMP Error Messages
  contents:
  - "2.2.  Handling of ICMP Error Messages\n   The Host Requirements RFC [RFC1122]\
    \ states in Section 4.2.3.9 that\n   TCP MUST act on an ICMP error message passed\
    \ up from the IP layer,\n   directing it to the connection that triggered the\
    \ error.\n   In order to allow ICMP messages to be demultiplexed by the receiving\n\
    \   system, part of the original packet that triggered the message is\n   included\
    \ in the payload of the ICMP error message.  Thus, the\n   receiving system can\
    \ use that information to match the ICMP error to\n   the transport protocol instance\
    \ that triggered it.\n   Neither the Host Requirements RFC [RFC1122] nor the original\
    \ TCP\n   specification [RFC0793] recommends any validation checks on the\n  \
    \ received ICMP messages.  Thus, as long as the ICMP payload contains\n   the\
    \ information that identifies an existing communication instance,\n   it will\
    \ be processed by the corresponding transport-protocol\n   instance, and the corresponding\
    \ action will be performed.\n   Therefore, in the case of TCP, an attacker could\
    \ send a crafted ICMP\n   error message to the attacked system, and, as long as\
    \ he is able to\n   guess the four-tuple (i.e., Source IP Address, Source TCP\
    \ port,\n   Destination IP Address, and Destination TCP port) that identifies\
    \ the\n   communication instance to be attacked, he will be able to use ICMP to\n\
    \   perform a variety of attacks.\n   Generally, the four-tuple required to perform\
    \ these attacks is not\n   known.  However, as discussed in [Watson] and [RFC4953],\
    \ there are a\n   number of scenarios (notably that of TCP connections established\n\
    \   between two BGP routers [RFC4271]) in which an attacker may be able\n   to\
    \ know or guess the four-tuple that identifies a TCP connection.  In\n   such\
    \ a case, if we assume the attacker knows the two systems involved\n   in the\
    \ TCP connection to be attacked, both the client-side and the\n   server-side\
    \ IP addresses could be known or be within a reasonable\n   number of possibilities.\
    \  Furthermore, as most Internet services use\n   the so-called \"well-known\"\
    \ ports, only the client port number might\n   need to be guessed.  In such a\
    \ scenario, an attacker would need to\n   send, in principle, at most 65536 packets\
    \ to perform any of the\n   attacks described in this document.  These issues\
    \ are exacerbated by\n   the fact that most systems choose the port numbers they\
    \ use for\n   outgoing connections from a subset of the whole port number space,\n\
    \   thus reducing the amount of work needed to successfully perform these\n  \
    \ attacks.\n   The need to be more cautious when processing received ICMP error\n\
    \   messages in order to mitigate or eliminate the impact of the attacks\n   described\
    \ in this RFC has been documented by the Internet\n   Architecture Board (IAB)\
    \ in [RFC4907].\n"
- title: 2.3.  Handling of ICMP Error Messages in the Context of IPsec
  contents:
  - "2.3.  Handling of ICMP Error Messages in the Context of IPsec\n   Section 5.2\
    \ of [RFC4301] describes the processing of inbound IP\n   traffic in the case\
    \ of \"unprotected-to-protected\".  In the case of\n   ICMP, when an unprotected\
    \ ICMP error message is received, it is\n   matched to the corresponding security\
    \ association by means of the SPI\n   (Security Parameters Index) included in\
    \ the payload of the ICMP error\n   message.  Then, local policy is applied to\
    \ determine whether to\n   accept or reject the message and, if accepted, what\
    \ action to take as\n   a result.  For example, if an ICMP Destination Unreachable\
    \ message is\n   received, the implementation must decide whether to act on it,\
    \ reject\n   it, or act on it with constraints.  Section 8 (\"Path MTU/DF\n  \
    \ Processing\") discusses the processing of unauthenticated ICMPv4\n   \"fragmentation\
    \ needed and DF bit set\" (type 3, code 4) and ICMPv6\n   \"Packet Too Big\" (type\
    \ 2, code 0) messages when an IPsec\n   implementation is configured to process\
    \ (vs. ignore) such messages.\n   Section 6.1.1 of [RFC4301] notes that processing\
    \ of unauthenticated\n   ICMP error messages may result in denial or degradation\
    \ of service,\n   and therefore it would be desirable to ignore such messages.\n\
    \   However, it also notes that in many cases, ignoring these ICMP\n   messages\
    \ can degrade service, e.g., because of a failure to process\n   PMTUD and redirection\
    \ messages, and therefore there is also a\n   motivation for accepting and acting\
    \ upon them.  It finally states\n   that to accommodate both ends of this spectrum,\
    \ a compliant IPsec\n   implementation MUST permit a local administrator to configure\
    \ an\n   IPsec implementation to accept or reject unauthenticated ICMP\n   traffic,\
    \ and that this control MUST be at the granularity of ICMP\n   type and MAY be\
    \ at the granularity of ICMP type and code.\n   Additionally, an implementation\
    \ SHOULD incorporate mechanisms and\n   parameters for dealing with such traffic.\n\
    \   Thus, the policy to apply for the processing of unprotected ICMP\n   error\
    \ messages is left up to the implementation and administrator.\n"
- title: 3.  Constraints in the Possible Solutions
  contents:
  - "3.  Constraints in the Possible Solutions\n   If a host wants to perform validation\
    \ checks on the received ICMP\n   error messages before acting on them, it is\
    \ limited by the piece of\n   the packet that triggered the error that the sender\
    \ of the ICMP error\n   message chose to include in the ICMP payload.  This constrains\
    \ the\n   possible validation checks, as the number of bytes of the packet that\n\
    \   triggered the error message that is included in the ICMP payload is\n   limited.\n\
    \   For ICMPv4, [RFC0792] states that the IP header plus the first\n   64 bits\
    \ of the packet that triggered the ICMPv4 message are to be\n   included in the\
    \ payload of the ICMPv4 error message.  Thus, it is\n   assumed that all data\
    \ needed to identify a transport protocol\n   instance and process the ICMPv4\
    \ error message is contained in the\n   first 64 bits of the transport protocol\
    \ header.  Section 3.2.2 of\n   [RFC1122] states that \"the Internet header and\
    \ at least the first 8\n   data octets of the datagram that triggered the error\"\
    \ are to be\n   included in the payload of ICMPv4 error messages, and that \"\
    more than\n   8 octets MAY be sent\", thus allowing implementations to include\
    \ more\n   data from the original packet than those required by the original\n\
    \   ICMPv4 specification.  The \"Requirements for IP Version 4 Routers\"\n   RFC\
    \ [RFC1812] states that ICMPv4 error messages \"SHOULD contain as\n   much of\
    \ the original datagram as possible without the length of the\n   ICMP datagram\
    \ exceeding 576 bytes\".\n   Thus, for ICMPv4 messages generated by hosts, we\
    \ can only expect to\n   get the entire IP header of the original packet, plus\
    \ the first\n   64 bits of its payload.  For TCP, this means that the only fields\n\
    \   that will be included in the ICMPv4 payload are the source port\n   number,\
    \ the destination port number, and the 32-bit TCP sequence\n   number.  This clearly\
    \ imposes a constraint on the possible validation\n   checks that can be performed,\
    \ as there is not much information\n   available on which to perform them.\n \
    \  This means, for example, that even if TCP were signing its segments\n   by\
    \ means of the TCP MD5 signature option [RFC2385], this mechanism\n   could not\
    \ be used as a counter-measure against ICMP-based attacks,\n   because, as ICMP\
    \ messages include only a piece of the TCP segment\n   that triggered the error,\
    \ the MD5 [RFC1321] signature could not be\n   recalculated.  In the same way,\
    \ even if the attacked peer were\n   authenticating its packets at the IP layer\
    \ [RFC4301], because only a\n   part of the original IP packet would be available,\
    \ the signature used\n   for authentication could not be recalculated, and thus\
    \ the\n   authentication header in the original packet could not be used as a\n\
    \   counter-measure for ICMP-based attacks against TCP.\n   [RFC4884] updated\
    \ [RFC0792] and specified that ICMPv4 Destination\n   Unreachable (type 3), Time\
    \ Exceeded (type 11), and Parameter Problem\n   (type 12) messages that have an\
    \ ICMP Extension Structure appended\n   include at least 128 octets in the \"\
    original datagram\" field.  This\n   would improve the situation, but at the time\
    \ of this writing,\n   [RFC4884] is not yet widely deployed for end-systems.\n\
    \   For IPv6, the payload of ICMPv6 error messages includes as many\n   octets\
    \ from the IPv6 packet that triggered the ICMPv6 error message\n   as will fit\
    \ without making the resulting ICMPv6 error message exceed\n   the minimum IPv6\
    \ MTU (1280 octets) [RFC4443].  Thus, more information\n   is available than in\
    \ the IPv4 case.\n   Hosts could require ICMP error messages to be authenticated\n\
    \   [RFC4301], in order to act upon them.  However, while this\n   requirement\
    \ could make sense for those ICMP error messages sent by\n   hosts, it would not\
    \ be feasible for those ICMP error messages\n   generated by routers, as this\
    \ would imply either that the attacked\n   system should have a security association\
    \ [RFC4301] with every\n   existing intermediate system, or that it should be\
    \ able to establish\n   one dynamically.  Current levels of deployment of protocols\
    \ for\n   dynamic establishment of security associations makes this unfeasible.\n\
    \   Additionally, this would require routers to use certificates with\n   paths\
    \ compatible for all hosts on the network.  Finally, there may be\n   some scenarios,\
    \ such as embedded devices, in which the processing\n   power requirements of\
    \ authentication might not allow IPsec\n   authentication to be implemented effectively.\n"
- title: 4.  General Counter-Measures against ICMP Attacks
  contents:
  - "4.  General Counter-Measures against ICMP Attacks\n   The following subsections\
    \ describe a number of mitigation techniques\n   that help to eliminate or mitigate\
    \ the impact of the attacks\n   discussed in this document.  Rather than being\
    \ alternative counter-\n   measures, they can be implemented together to increase\
    \ the protection\n   against these attacks.\n"
- title: 4.1.  TCP Sequence Number Checking
  contents:
  - "4.1.  TCP Sequence Number Checking\n   The current specifications do not impose\
    \ any validity checks on the\n   TCP segment that is contained in the ICMP payload.\
    \  For instance, no\n   checks are performed to verify that a received ICMP error\
    \ message has\n   been triggered by a segment that was \"in flight\" to the destination.\n\
    \   Thus, even stale ICMP error messages will be acted upon.\n   Many TCP implementations\
    \ have incorporated a validation check such\n   that they react only to those\
    \ ICMP error messages that appear to\n   relate to segments currently \"in flight\"\
    \ to the destination system.\n   These implementations check that the TCP sequence\
    \ number contained in\n   the payload of the ICMP error message is within the\
    \ range\n   SND.UNA =< SEG.SEQ < SND.NXT.  This means that they require that the\n\
    \   sequence number be within the range of the data already sent but not\n   yet\
    \ acknowledged.  If an ICMP error message does not pass this check,\n   it is\
    \ discarded.\n   Even if an attacker were able to guess the four-tuple that identifies\n\
    \   the TCP connection, this additional check would reduce the\n   possibility\
    \ of considering a spoofed ICMP packet as valid to\n   Flight_Size/2^^32 (where\
    \ Flight_Size is the number of data bytes\n   already sent to the remote peer,\
    \ but not yet acknowledged [RFC5681]).\n   For connections in the SYN-SENT or\
    \ SYN-RECEIVED states, this would\n   reduce the possibility of considering a\
    \ spoofed ICMP packet as valid\n   to 1/2^^32.  For a TCP endpoint with no data\
    \ \"in flight\", this would\n   completely eliminate the possibility of success\
    \ of these attacks.\n   This validation check has been implemented in Linux [Linux]\
    \ for many\n   years, in OpenBSD [OpenBSD] since 2004, and in FreeBSD [FreeBSD]\
    \ and\n   NetBSD [NetBSD] since 2005.\n   It is important to note that while this\
    \ check greatly increases the\n   number of packets required to perform any of\
    \ the attacks discussed in\n   this document, this may not be enough in those\
    \ scenarios in which\n   bandwidth is easily available and/or large TCP windows\
    \ [RFC1323] are\n   in use.  Additionally, this validation check does not help\
    \ to prevent\n   on-path attacks, that is, attacks performed in scenarios in which\
    \ the\n   attacker can sniff the packets that correspond to the target TCP\n \
    \  connection.\n   It should be noted that, as there are no timeliness requirements\
    \ for\n   ICMP error messages, the TCP Sequence Number check described in this\n\
    \   section might cause legitimate ICMP error messages to be discarded.\n   Also,\
    \ even if this check is enforced, TCP might end up responding to\n   stale ICMP\
    \ error messages (e.g., if the Sequence Number for the\n   corresponding direction\
    \ of the data transfer wraps around).\n"
- title: 4.2.  Port Randomization
  contents:
  - "4.2.  Port Randomization\n   As discussed in the previous sections, in order\
    \ to perform any of the\n   attacks described in this document, an attacker would\
    \ need to guess\n   (or know) the four-tuple that identifies the connection to\
    \ be\n   attacked.  Increasing the port number range used for outgoing TCP\n \
    \  connections, and randomizing the port number chosen for each outgoing\n   TCP\
    \ connection, would make it harder for an attacker to perform any\n   of the attacks\
    \ discussed in this document.\n   [PORT-RANDOM] recommends that transport protocols\
    \ randomize the\n   ephemeral ports used by clients, and proposes a number of\n\
    \   randomization algorithms.\n"
- title: 4.3.  Filtering ICMP Error Messages Based on the ICMP Payload
  contents:
  - "4.3.  Filtering ICMP Error Messages Based on the ICMP Payload\n   The source\
    \ address of ICMP error messages does not need to be spoofed\n   to perform the\
    \ attacks described in this document, as the ICMP error\n   messages might legitimately\
    \ come from an intermediate system.\n   Therefore, simple filtering based on the\
    \ source address of ICMP error\n   messages does not serve as a counter-measure\
    \ against these attacks.\n   However, a more advanced packet filtering can be\
    \ implemented in\n   middlebox devices such as firewalls and NATs.  Middleboxes\n\
    \   implementing such advanced filtering look at the payload of the ICMP\n   error\
    \ messages, and perform ingress and egress packet filtering based\n   on the source\
    \ address of the IP header contained in the payload of\n   the ICMP error message.\
    \  As the source address contained in the\n   payload of the ICMP error message\
    \ does need to be spoofed to perform\n   the attacks described in this document,\
    \ this kind of advanced\n   filtering serves as a counter-measure against these\
    \ attacks.  As with\n   traditional egress filtering [IP-filtering], egress filtering\
    \ based\n   on the ICMP payload can help to prevent users of the network being\n\
    \   protected by the firewall from successfully performing ICMP attacks\n   against\
    \ TCP connections established between external systems.\n   Additionally, ingress\
    \ filtering based on the ICMP payload can prevent\n   TCP connections established\
    \ between internal systems from being\n   attacked by external systems.  [ICMP-Filtering]\
    \ provides examples of\n   ICMP filtering based on the ICMP payload.\n   This\
    \ filtering technique has been implemented in OpenBSD's Packet\n   Filter [OpenBSD-PF],\
    \ which has in turn been ported to a number of\n   systems, including FreeBSD\
    \ [FreeBSD].\n"
- title: 5.  Blind Connection-Reset Attack
  contents:
  - '5.  Blind Connection-Reset Attack

    '
- title: 5.1.  Description
  contents:
  - "5.1.  Description\n   When TCP is handed an ICMP error message, it will perform\
    \ its fault\n   recovery function, as follows:\n   o  If the network problem being\
    \ reported is a \"hard error\", TCP will\n      abort the corresponding connection.\n\
    \   o  If the network problem being reported is a \"soft error\", TCP will\n \
    \     just record this information, and repeatedly retransmit its data\n     \
    \ until they either get acknowledged, or the connection times out.\n   The Host\
    \ Requirements RFC [RFC1122] states (in Section 4.2.3.9) that\n   a host SHOULD\
    \ abort the corresponding connection when receiving an\n   ICMPv4 error message\
    \ that indicates a \"hard error\", and states that\n   ICMPv4 error messages of\
    \ type 3 (Destination Unreachable), codes 2\n   (protocol unreachable), 3 (port\
    \ unreachable), and 4 (fragmentation\n   needed and DF bit set) should be considered\
    \ as indicating \"hard\n   errors\".  In the case of ICMPv4 port unreachables,\
    \ the specifications\n   are ambiguous, as Section 4.2.3.9 of [RFC1122] states\
    \ that TCP SHOULD\n   abort the corresponding connection in response to them,\
    \ but\n   Section 3.2.2.1 of the same RFC ([RFC1122]) states that TCP MUST\n \
    \  abort the connection in response to them.\n   While [RFC4443] did not exist\
    \ when [RFC1122] was published, one could\n   extrapolate the concept of \"hard\
    \ errors\" to ICMPv6 error messages of\n   type 1 (Destination Unreachable), codes\
    \ 1 (communication with\n   destination administratively prohibited), and 4 (port\
    \ unreachable).\n   Thus, an attacker could use ICMP to perform a blind connection-reset\n\
    \   attack by sending any ICMP error message that indicates a \"hard\n   error\"\
    \ to either of the two TCP endpoints of the connection.  Because\n   of TCP's\
    \ fault recovery policy, the connection would be immediately\n   aborted.\n  \
    \ Some stacks are known to extrapolate ICMP \"hard errors\" across TCP\n   connections,\
    \ increasing the impact of this attack, as a single ICMP\n   packet could bring\
    \ down all the TCP connections between the\n   corresponding peers.\n   It is\
    \ important to note that even if TCP itself were protected\n   against the blind\
    \ connection-reset attack described in [Watson] and\n   [TCPM-TCPSECURE] by means\
    \ of authentication at the network layer\n   [RFC4301], by means of the TCP MD5\
    \ signature option [RFC2385], by\n   means of the TCP-AO [RFC5925], or by means\
    \ of the mechanism specified\n   in [TCPM-TCPSECURE], the blind connection-reset\
    \ attack described in\n   this document would still succeed.\n"
- title: 5.2.  Attack-Specific Counter-Measures
  contents:
  - "5.2.  Attack-Specific Counter-Measures\n   An analysis of the circumstances in\
    \ which ICMP messages that indicate\n   \"hard errors\" may be received can shed\
    \ some light on opportunities to\n   mitigate the impact of ICMP-based blind connection-reset\
    \ attacks.\n   ICMPv4 type 3 (Destination Unreachable), code 2 (protocol\n   \
    \   unreachable)\n      This ICMP error message indicates that the host sending\
    \ the ICMP\n      error message received a packet meant for a transport protocol\
    \ it\n      does not support.  For connection-oriented protocols such as TCP,\n\
    \      one could expect to receive such an error as the result of a\n      connection-establishment\
    \ attempt.  However, it would be strange to\n      get such an error during the\
    \ life of a connection, as this would\n      indicate that support for that transport\
    \ protocol has been removed\n      from the system sending the error message during\
    \ the life of the\n      corresponding connection.\n   ICMPv4 type 3 (Destination\
    \ Unreachable), code 3 (port unreachable)\n      This error message indicates\
    \ that the system sending the ICMP\n      error message received a packet meant\
    \ for a socket (IP address,\n      port number) on which there is no process listening.\
    \  Those\n      transport protocols that have their own mechanisms for signaling\n\
    \      this condition should not be receiving these error messages, as\n     \
    \ the protocol would signal the port unreachable condition by means\n      of\
    \ its own mechanisms.  Assuming that once a connection is\n      established it\
    \ is not usual for the transport protocol to change\n      (or be reloaded), it\
    \ should be unusual to get these error\n      messages.\n   ICMPv4 type 3 (Destination\
    \ Unreachable), code 4 (fragmentation needed\n      and DF bit set)\n      This\
    \ error message indicates that an intermediate node needed to\n      fragment\
    \ a datagram, but the DF (Don't Fragment) bit in the IP\n      header was set.\
    \  It is considered a \"soft error\" when TCP\n      implements PMTUD, and a \"\
    hard error\" if TCP does not implement\n      PMTUD.  Those TCP/IP stacks that\
    \ do not implement PMTUD (or have\n      disabled it) but support IP fragmentation/reassembly\
    \ should not be\n      sending their IP packets with the DF bit set, and thus\
    \ should not\n      be receiving these ICMP error messages.  Some TCP/IP stacks\
    \ that\n      do not implement PMTUD and that do not support IP fragmentation/\n\
    \      reassembly are known to send their packets with the DF bit set,\n     \
    \ and thus could legitimately receive these ICMP error messages.\n   ICMPv6 type\
    \ 1 (Destination Unreachable), code 1 (communication with\n      destination administratively\
    \ prohibited)\n      This error message indicates that the destination is unreachable\n\
    \      because of an administrative policy.  For connection-oriented\n      protocols\
    \ such as TCP, one could expect to receive such an error\n      as the result\
    \ of a connection-establishment attempt.  Receiving\n      such an error for a\
    \ connection in any of the synchronized states\n      would mean that the administrative\
    \ policy changed during the life\n      of the connection.  However, in the same\
    \ way this error condition\n      (which was not present when the connection was\
    \ established)\n      appeared, it could get solved in the near term.\n   ICMPv6\
    \ type 1 (Destination Unreachable), code 4 (port unreachable)\n      This error\
    \ message is analogous to the ICMPv4 type 3 (Destination\n      Unreachable),\
    \ code 3 (port unreachable) error message discussed\n      above.  Therefore,\
    \ the same considerations apply.\n   The Host Requirements RFC [RFC1122] states\
    \ in Section 4.2.3.9 that\n   TCP SHOULD abort the corresponding connection in\
    \ response to ICMPv4\n   messages of type 3 (Destination Unreachable), codes 2\
    \ (protocol\n   unreachable), 3 (port unreachable), and 4 (fragmentation needed\
    \ and\n   DF bit set).  However, Section 3.2.2.1 states that TCP MUST accept an\n\
    \   ICMPv4 port unreachable (type 3, code 3) for the same purpose as a\n   RST.\
    \  Therefore, for ICMPv4 messages of type 3, codes 2 and 4, there\n   is room\
    \ to go against the advice provided in the existing\n   specifications, while\
    \ in the case of ICMPv4 messages of type 3,\n   code 3, there is ambiguity in\
    \ the specifications that may or may not\n   provide some room to go against that\
    \ advice.\n   Based on this analysis, most popular TCP implementations treat all\n\
    \   ICMP \"hard errors\" received for connections in any of the\n   synchronized\
    \ states (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT,\n   CLOSING, LAST-ACK,\
    \ or TIME-WAIT) as \"soft errors\".  That is, they do\n   not abort the corresponding\
    \ connection upon receipt of them.\n   Additionally, they do not extrapolate ICMP\
    \ errors across TCP\n   connections.  This policy is based on the premise that\
    \ TCP should be\n   as robust as possible.  Aborting the connection would be to\
    \ ignore\n   the valuable feature of the Internet -- that for many internal\n\
    \   failures, it reconstructs its function without any disruption of the\n   endpoints\
    \ [RFC0816].\n   It should be noted that treating ICMP \"hard errors\" as \"soft\
    \ errors\"\n   for connections in any of the synchronized states may prevent TCP\n\
    \   from responding quickly to a legitimate ICMP error message.\n   It is interesting\
    \ to note that, as ICMP error messages are\n   transmitted unreliably, transport\
    \ protocols should not depend on them\n   for correct functioning.  In the event\
    \ one of these messages were\n   legitimate, the corresponding connection would\
    \ eventually time out.\n   Also, applications may still be notified asynchronously\
    \ about the\n   error condition, and thus may still abort their connections on\
    \ their\n   own if they consider it appropriate.\n   In scenarios such as that\
    \ in which an intermediate system sets the DF\n   bit in the segments transmitted\
    \ by a TCP that does not implement\n   PMTUD, or the TCP at one of the endpoints\
    \ of the connection is\n   dynamically disabled, TCP would only abort the connection\
    \ after a\n   USER TIMEOUT [RFC0793], losing responsiveness.  However, these\n\
    \   scenarios are very unlikely in production environments, and it is\n   probably\
    \ preferable to potentially lose responsiveness for the sake\n   of robustness.\
    \  It should also be noted that applications may still\n   be notified asynchronously\
    \ about the error condition, and thus may\n   still abort their connections on\
    \ their own if they consider it\n   appropriate.\n   In scenarios of multipath\
    \ routing or route changes, failures in some\n   (but not all) of the paths may\
    \ elicit ICMP error messages that would\n   likely not cause a connection abort\
    \ if any of the counter-measures\n   described in this section were implemented.\
    \  However, aborting the\n   connection would be to ignore the valuable feature\
    \ of the Internet --\n   that for many internal failures, it reconstructs its\
    \ function without\n   any disruption of the endpoints [RFC0816].  That is, communication\n\
    \   should survive if there is still a working path to the destination\n   system\
    \ [DClark].  Additionally, applications may still be notified\n   asynchronously\
    \ about the error condition, and thus may still abort\n   their connections on\
    \ their own if they consider it appropriate.\n   This counter-measure has been\
    \ implemented in BSD-derived TCP/IP\n   implementations (e.g., [FreeBSD], [NetBSD],\
    \ and [OpenBSD]) for more\n   than ten years [Wright][McKusick].  The Linux kernel\
    \ has also\n   implemented this policy for more than ten years [Linux].\n"
- title: 6.  Blind Throughput-Reduction Attack
  contents:
  - '6.  Blind Throughput-Reduction Attack

    '
- title: 6.1.  Description
  contents:
  - "6.1.  Description\n   The Host Requirements RFC [RFC1122] states in Section 4.2.3.9\
    \ that\n   hosts MUST react to ICMPv4 Source Quench messages by slowing\n   transmission\
    \ on the connection.  Thus, an attacker could send ICMPv4\n   Source Quench (type\
    \ 4, code 0) messages to a TCP endpoint to make it\n   reduce the rate at which\
    \ it sends data to the other endpoint of the\n   connection.  [RFC1122] further\
    \ adds that the RECOMMENDED procedure is\n   to put the corresponding connection\
    \ in the slow-start phase of TCP's\n   congestion control algorithm [RFC5681].\
    \  In the case of those\n   implementations that use an initial congestion window\
    \ of one segment,\n   a sustained attack would reduce the throughput of the attacked\n\
    \   connection to about SMSS (Sender Maximum Segment Size) [RFC5681]\n   bytes\
    \ per RTT (round-trip time).  The throughput achieved during an\n   attack might\
    \ be a little higher if a larger initial congestion window\n   is in use [RFC3390].\n"
- title: 6.2.  Attack-Specific Counter-Measures
  contents:
  - "6.2.  Attack-Specific Counter-Measures\n   As discussed in the \"Requirements\
    \ for IP Version 4 Routers\" RFC\n   [RFC1812], research seems to suggest that\
    \ ICMPv4 Source Quench\n   messages are an ineffective (and unfair) antidote for\
    \ congestion.\n   [RFC1812] further states that routers SHOULD NOT send ICMPv4\
    \ Source\n   Quench messages in response to congestion.  Furthermore, TCP\n  \
    \ implements its own congestion control mechanisms ([RFC5681]\n   [RFC3168]) that\
    \ do not depend on ICMPv4 Source Quench messages.\n   Based on this reasoning,\
    \ a large number of implementations completely\n   ignore ICMPv4 Source Quench\
    \ messages meant for TCP connections.  This\n   behavior has been implemented\
    \ in, at least, Linux [Linux] since 2004,\n   and in FreeBSD [FreeBSD], NetBSD\
    \ [NetBSD], and OpenBSD [OpenBSD]\n   since 2005.  However, it must be noted that\
    \ this behavior violates\n   the requirement in [RFC1122] to react to ICMPv4 Source\
    \ Quench\n   messages by slowing transmission on the connection.\n"
- title: 7.  Blind Performance-Degrading Attack
  contents:
  - '7.  Blind Performance-Degrading Attack

    '
- title: 7.1.  Description
  contents:
  - "7.1.  Description\n   When one IP system has a large amount of data to send to\
    \ another\n   system, the data will be transmitted as a series of IP datagrams.\
    \  It\n   is usually preferable that these datagrams be of the largest size\n\
    \   that does not require fragmentation anywhere along the path from the\n   source\
    \ to the destination.  This datagram size is referred to as the\n   Path MTU (PMTU)\
    \ and is equal to the minimum of the MTUs of each hop\n   in the path.  A technique\
    \ called \"Path MTU Discovery\" (PMTUD) lets IP\n   systems determine the Path\
    \ MTU of an arbitrary internet path.\n   [RFC1191] and [RFC1981] specify the PMTUD\
    \ mechanism for IPv4 and\n   IPv6, respectively.\n   The PMTUD mechanism for IPv4\
    \ uses the Don't Fragment (DF) bit in the\n   IP header to dynamically discover\
    \ the Path MTU.  The basic idea\n   behind the PMTUD mechanism is that a source\
    \ system assumes that the\n   MTU of the path is that of the first hop, and sends\
    \ all its datagrams\n   with the DF bit set.  If any of the datagrams is too large\
    \ to be\n   forwarded without fragmentation by some intermediate router, the\n\
    \   router will discard the corresponding datagram and will return an\n   ICMPv4\
    \ \"Destination Unreachable, fragmentation needed and DF set\"\n   (type 3, code\
    \ 4) error message to the sending system.  This message\n   will report the MTU\
    \ of the constricting hop, so that the sending\n   system can reduce the assumed\
    \ Path-MTU accordingly.\n   For IPv6, intermediate systems do not fragment packets.\
    \  Thus,\n   there's an \"implicit\" DF bit set in every packet sent on a network.\n\
    \   If any of the datagrams is too large to be forwarded without\n   fragmentation\
    \ by some intermediate router, the router will discard\n   the corresponding datagram,\
    \ and will return an ICMPv6 \"Packet Too\n   Big\" (type 2, code 0) error message\
    \ to the sending system.  This\n   message will report the MTU of the constricting\
    \ hop, so that the\n   sending system can reduce the assumed Path-MTU accordingly.\n\
    \   As discussed in both [RFC1191] and [RFC1981], the Path-MTU Discovery\n   mechanism\
    \ can be used to attack TCP.  An attacker could send a\n   crafted ICMPv4 \"Destination\
    \ Unreachable, fragmentation needed and DF\n   set\" packet (or their ICMPv6 counterpart)\
    \ to the sending system,\n   advertising a small Next-Hop MTU.  As a result, the\
    \ attacked system\n   would reduce the size of the packets it sends for the corresponding\n\
    \   connection accordingly.\n   The effect of this attack is two-fold.  On one\
    \ hand, it will increase\n   the headers/data ratio, thus increasing the overhead\
    \ needed to send\n   data to the remote TCP endpoint.  On the other hand, if the\
    \ attacked\n   system wanted to keep the same throughput it was achieving before\n\
    \   being attacked, it would have to increase the packet rate.  On\n   virtually\
    \ all systems, this will lead to an increased processing\n   overhead, thus degrading\
    \ the overall system performance.\n   A particular scenario that may take place\
    \ is one in which an attacker\n   reports a Next-Hop MTU smaller than or equal\
    \ to the amount of bytes\n   needed for headers (IP header, plus TCP header).\
    \  For example, if the\n   attacker reports a Next-Hop MTU of 68 bytes, and the\
    \ amount of bytes\n   used for headers (IP header, plus TCP header) is larger\
    \ than\n   68 bytes, the assumed Path-MTU will not even allow the attacked\n \
    \  system to send a single byte of application data without\n   fragmentation.\
    \  This particular scenario might lead to unpredictable\n   results.  Another\
    \ possible scenario is one in which a TCP connection\n   is being secured by means\
    \ of IPsec.  If the Next-Hop MTU reported by\n   the attacker is smaller than\
    \ the amount of bytes needed for headers\n   (IP and IPsec, in this case), the\
    \ assumed Path-MTU will not even\n   allow the attacked system to send a single\
    \ byte of the TCP header\n   without fragmentation.  This is another scenario\
    \ that may lead to\n   unpredictable results.\n   For IPv4, the reported Next-Hop\
    \ MTU could be as small as 68 octets,\n   as [RFC0791] requires every internet\
    \ module to be able to forward a\n   datagram of 68 octets without further fragmentation.\
    \  For IPv6, while\n   the required minimum IPv6 MTU is 1280, the reported Next-Hop\
    \ MTU can\n   be smaller than 1280 octets [RFC2460].  If the reported Next-Hop\
    \ MTU\n   is smaller than the minimum IPv6 MTU, the receiving host is not\n  \
    \ required to reduce the Path-MTU to a value smaller than 1280, but is\n   required\
    \ to include a fragmentation header in the outgoing packets to\n   that destination\
    \ from that moment on.\n"
- title: 7.2.  Attack-Specific Counter-Measures
  contents:
  - "7.2.  Attack-Specific Counter-Measures\n   The IETF has standardized a Path-MTU\
    \ Discovery mechanism called\n   \"Packetization Layer Path MTU Discovery\" (PLPMTUD)\
    \ that does not\n   depend on ICMP error messages.  Implementation of the aforementioned\n\
    \   mechanism in replacement of the traditional PMTUD (specified in\n   [RFC1191]\
    \ and [RFC1981]) eliminates this vulnerability.  However, it\n   can also lead\
    \ to an increase in PMTUD convergence time.\n   This section describes a modification\
    \ to the PMTUD mechanism\n   specified in [RFC1191] and [RFC1981] that has been\
    \ incorporated in\n   OpenBSD and NetBSD (since 2005) to improve TCP's resistance\
    \ to the\n   blind performance-degrading attack described in Section 7.1.  The\n\
    \   described counter-measure basically disregards ICMP messages when a\n   connection\
    \ makes progress, without violating any of the requirements\n   stated in [RFC1191]\
    \ and [RFC1981].\n   Henceforth, we will refer to both ICMPv4 \"fragmentation\
    \ needed and DF\n   bit set\" and ICMPv6 \"Packet Too Big\" messages as \"ICMP\
    \ Packet Too\n   Big\" messages.\n   In addition to the general validation check\
    \ described in Section 4.1,\n   these implementations include a modification to\
    \ TCP's reaction to\n   ICMP \"Packet Too Big\" error messages that disregards\
    \ them when a\n   connection makes progress, and honors them only after the\n\
    \   corresponding data have been retransmitted a specified number of\n   times.\
    \  This means that upon receipt of an ICMP \"Packet Too Big\"\n   error message,\
    \ TCP just records this information, and honors it only\n   when the corresponding\
    \ data have already been retransmitted a\n   specified number of times.\n   While\
    \ this basic policy would greatly mitigate the impact of the\n   attack against\
    \ the PMTUD mechanism, it would also mean that it might\n   take TCP more time\
    \ to discover the Path-MTU for a TCP connection.\n   This would be particularly\
    \ annoying for connections that have just\n   been established, as it might take\
    \ TCP several transmission attempts\n   (and the corresponding timeouts) before\
    \ it discovers the PMTU for the\n   corresponding connection.  Thus, this policy\
    \ would increase the time\n   it takes for data to begin to be received at the\
    \ destination host.\n   In order to protect TCP from the attack against the PMTUD\
    \ mechanism,\n   while still allowing TCP to quickly determine the initial Path-MTU\n\
    \   for a connection, the aforementioned implementations have divided the\n  \
    \ traditional PMTUD mechanism into two stages: Initial Path-MTU\n   Discovery\
    \ and Path-MTU Update.\n   The Initial Path-MTU Discovery stage is when TCP tries\
    \ to send\n   segments that are larger than the ones that have so far been sent\
    \ and\n   acknowledged for this connection.  That is, in the Initial Path-MTU\n\
    \   Discovery stage, TCP has no record of these large segments getting to\n  \
    \ the destination host, and thus these implementations believe the\n   network\
    \ when it reports that these packets are too large to reach the\n   destination\
    \ host without being fragmented.\n   The Path-MTU Update stage is when TCP tries\
    \ to send segments that are\n   equal to or smaller than the ones that have already\
    \ been sent and\n   acknowledged for this connection.  During the Path-MTU Update\
    \ stage,\n   TCP already has knowledge of the estimated Path-MTU for the given\n\
    \   connection.  Thus, in this case, these implementations are more\n   cautious\
    \ with the errors being reported by the network.\n   In order to allow TCP to\
    \ distinguish segments between those\n   performing Initial Path-MTU Discovery\
    \ and those performing Path-MTU\n   Update, two new variables are introduced to\
    \ TCP: maxsizesent and\n   maxsizeacked.\n   The maxsizesent variable holds the\
    \ size (in octets) of the largest\n   packet that has so far been sent for this\
    \ connection.  It is\n   initialized to 68 (the minimum IPv4 MTU) when the underlying\
    \ Internet\n   Protocol is IPv4, and is initialized to 1280 (the minimum IPv6\
    \ MTU)\n   when the underlying Internet Protocol is IPv6.  Whenever a packet\n\
    \   larger than maxsizesent octets is sent, maxsizesent is set to that\n   value.\n\
    \   On the other hand, maxsizeacked holds the size (in octets) of the\n   largest\
    \ packet (data, plus headers) that has so far been acknowledged\n   for this connection.\
    \  It is initialized to 68 (the minimum IPv4 MTU)\n   when the underlying Internet\
    \ Protocol is IPv4, and is initialized to\n   1280 (the minimum IPv6 MTU) when\
    \ the underlying Internet Protocol is\n   IPv6.  Whenever an acknowledgement for\
    \ a packet larger than\n   maxsizeacked octets is received, maxsizeacked is set\
    \ to the size of\n   that acknowledged packet.  Note that because of TCP's cumulative\n\
    \   acknowledgement, a single ACK may acknowledge the receipt of more\n   than\
    \ one packet.  When that happens, the algorithm may \"incorrectly\"\n   assume\
    \ it is in the \"Path-MTU Update\" stage, rather than the \"Initial\n   Path-MTU\
    \ Discovery\" stage (as described below).\n   Upon receipt of an ICMP \"Packet\
    \ Too Big\" error message, the Next-Hop\n   MTU claimed by the ICMP message (henceforth\
    \ \"claimedmtu\") is compared\n   with maxsizesent.  If claimedmtu is larger than\
    \ maxsizesent, then the\n   ICMP error message is silently discarded.  The rationale\
    \ for this is\n   that the ICMP error message cannot be legitimate if it claims\
    \ to have\n   been triggered by a packet larger than the largest packet we have\
    \ so\n   far sent for this connection.\n   If this check is passed, claimedmtu\
    \ is compared with maxsizeacked.\n   If claimedmtu is equal to or larger than\
    \ maxsizeacked, TCP is\n   supposed to be at the Initial Path-MTU Discovery stage,\
    \ and thus the\n   ICMP \"Packet Too Big\" error message is honored immediately.\
    \  That is,\n   the assumed Path-MTU is updated according to the Next-Hop MTU\
    \ claimed\n   in the ICMP error message.  Also, maxsizesent is reset to the minimum\n\
    \   MTU of the Internet Protocol in use (68 for IPv4, and 1280 for IPv6).\n  \
    \ On the other hand, if claimedmtu is smaller than maxsizeacked, TCP is\n   supposed\
    \ to be in the Path-MTU Update stage.  At this stage, these\n   implementations\
    \ are more cautious with the errors being reported by\n   the network, and therefore\
    \ just record the received error message,\n   and delay the update of the assumed\
    \ Path-MTU.\n   To perform this delay, one new variable and one new parameter\
    \ are\n   introduced to TCP: nsegrto and MAXSEGRTO.  The nsegrto variable holds\n\
    \   the number of times a specified segment has timed out.  It is\n   initialized\
    \ to zero, and is incremented by one every time the\n   corresponding segment\
    \ times out.  MAXSEGRTO specifies the number of\n   times a given segment must\
    \ time out before an ICMP \"Packet Too Big\"\n   error message can be honored,\
    \ and can be set, in principle, to any\n   value greater than or equal to 0.\n\
    \   Thus, if nsegrto is greater than or equal to MAXSEGRTO, and there's a\n  \
    \ pending ICMP \"Packet Too Big\" error message, the corresponding error\n   message\
    \ is processed.  At that point, maxsizeacked is set to\n   claimedmtu, and maxsizesent\
    \ is set to 68 (for IPv4) or 1280 (for\n   IPv6).\n   If, while there is a pending\
    \ ICMP \"Packet Too Big\" error message, the\n   TCP SEQ claimed by the pending\
    \ message is acknowledged (i.e., an ACK\n   that acknowledges that sequence number\
    \ is received), then the\n   \"pending error\" condition is cleared.\n   The rationale\
    \ behind performing this delayed processing of ICMP\n   \"Packet Too Big\" messages\
    \ is that if there is progress on the\n   connection, the ICMP \"Packet Too Big\"\
    \ errors must be a false claim.\n   By checking for progress on the connection,\
    \ rather than just for\n   staleness of the received ICMP messages, TCP is protected\
    \ from attack\n   even if the offending ICMP messages are \"in window\", and as\
    \ a\n   corollary, is made more robust to spurious ICMP messages triggered\n \
    \  by, for example, corrupted TCP segments.\n   MAXSEGRTO can be set, in principle,\
    \ to any value greater than or\n   equal to 0.  Setting MAXSEGRTO to 0 would make\
    \ TCP perform the\n   traditional PMTUD mechanism defined in [RFC1191] and [RFC1981].\
    \  A\n   MAXSEGRTO of 1 provides enough protection for most cases.  In any\n \
    \  case, implementations are free to choose higher values for this\n   constant.\
    \  MAXSEGRTO could be a function of the Next-Hop MTU claimed\n   in the received\
    \ ICMP \"Packet Too Big\" message.  That is, higher\n   values for MAXSEGRTO could\
    \ be imposed when the received ICMP \"Packet\n   Too Big\" message claims a Next-Hop\
    \ MTU that is smaller than some\n   specified value.  Both OpenBSD and NetBSD\
    \ set MAXSEGRTO to 1.\n   In the event a higher level of protection is desired\
    \ at the expense\n   of a higher delay in the discovery of the Path-MTU, an implementation\n\
    \   could consider TCP to always be in the Path-MTU Update stage, thus\n   always\
    \ delaying the update of the assumed Path-MTU.\n   Section 7.3 shows this counter-measure\
    \ in action.  Section 7.4 shows\n   this counter-measure in pseudo-code.\n   It\
    \ is important to note that the mechanism described in this section\n   is an\
    \ improvement to the current Path-MTU discovery mechanism, to\n   mitigate its\
    \ security implications.  The current PMTUD mechanism, as\n   specified by [RFC1191]\
    \ and [RFC1981], still suffers from some\n   functionality problems [RFC2923]\
    \ that this document does not aim to\n   address.  A mechanism that addresses\
    \ those issues is described in\n   [RFC4821].\n"
- title: 7.3.  The Counter-Measure for the PMTUD Attack in Action
  contents:
  - "7.3.  The Counter-Measure for the PMTUD Attack in Action\n   This section illustrates\
    \ the operation of the counter-measure for the\n   ICMP attack against the PMTUD\
    \ mechanism that has been implemented in\n   OpenBSD and NetBSD.  It shows both\
    \ how the fix protects TCP from\n   being attacked and how the counter-measure\
    \ works in normal scenarios.\n   As discussed in Section 7.2, this section assumes\
    \ the PMTUD-specific\n   counter-measure is implemented in addition to the TCP\
    \ sequence number\n   checking described in Section 4.1.\n   Figure 1 illustrates\
    \ a hypothetical scenario in which two hosts are\n   connected by means of three\
    \ intermediate routers.  It also shows the\n   MTU of each hypothetical hop. \
    \ All the following subsections assume\n   the network setup of this figure.\n\
    \   Also, for simplicity's sake, all subsections assume an IP header of\n   20\
    \ octets and a TCP header of 20 octets.  Thus, for example, when the\n   PMTU\
    \ is assumed to be 1500 octets, TCP will send segments that\n   contain, at most,\
    \ 1460 octets of data.\n   For simplicity's sake, all the following subsections\
    \ assume the TCP\n   implementation at Host 1 (H1) has chosen a MAXSEGRTO of 1.\n\
    \   +----+        +----+        +----+        +----+        +----+\n   | H1 |--------|\
    \ R1 |--------| R2 |--------| R3 |--------| H2 |\n   +----+        +----+    \
    \    +----+        +----+        +----+\n         MTU=4464      MTU=2048     \
    \ MTU=1500      MTU=4464\n                      Figure 1: Hypothetical Scenario\n"
- title: 7.3.1.  Normal Operation for Bulk Transfers
  contents:
  - "7.3.1.  Normal Operation for Bulk Transfers\n   This subsection shows the counter-measure\
    \ in normal operation, when a\n   TCP connection is used for bulk transfers. \
    \ That is, it shows how the\n   counter-measure works when there is no attack\
    \ taking place and a TCP\n   connection is used for transferring large amounts\
    \ of data.  This\n   section assumes that just after the connection is established,\
    \ one of\n   the TCP endpoints begins to transfer data in packets that are as\n\
    \   large as possible.\n       Host 1                                       Host\
    \ 2\n   1.    -->            <SEQ=100><CTL=SYN>           -->\n   2.    <--  \
    \    <SEQ=X><ACK=101><CTL=SYN,ACK>      <--\n   3.    -->       <SEQ=101><ACK=X+1><CTL=ACK>\
    \       -->\n   4.    --> <SEQ=101><ACK=X+1><CTL=ACK><DATA=4424>  -->\n   5. \
    \      <--- ICMP \"Packet Too Big\" MTU=2048, TCPseq#=101 <--- R1\n   6.    -->\
    \ <SEQ=101><ACK=X+1><CTL=ACK><DATA=2008>  -->\n   7.       <--- ICMP \"Packet\
    \ Too Big\" MTU=1500, TCPseq#=101 <--- R2\n   8.    --> <SEQ=101><ACK=X+1><CTL=ACK><DATA=1460>\
    \  -->\n   9.    <--      <SEQ=X+1><ACK=1561><CTL=ACK>       <--\n           \
    \    Figure 2: Normal Operation for Bulk Transfers\n   The nsegrto variable is\
    \ initialized to zero.  Both maxsizeacked and\n   maxsizesent are initialized\
    \ to the minimum MTU for the Internet\n   Protocol being used (68 for IPv4, and\
    \ 1280 for IPv6).\n   In lines 1 to 3, the three-way handshake takes place, and\
    \ the\n   connection is established.  In line 4, H1 tries to send a full-sized\n\
    \   TCP segment.  As described by [RFC1191] and [RFC1981], in this case,\n   TCP\
    \ will try to send a segment with 4424 bytes of data, which will\n   result in\
    \ an IP packet of 4464 octets.  Therefore, maxsizesent is set\n   to 4464.  When\
    \ the packet reaches R1, it elicits an ICMP \"Packet Too\n   Big\" error message.\n\
    \   In line 5, H1 receives the ICMP error message, which reports a Next-\n   Hop\
    \ MTU of 2048 octets.  After performing the TCP sequence number\n   check described\
    \ in Section 4.1, the Next-Hop MTU reported by the ICMP\n   error message (claimedmtu)\
    \ is compared with maxsizesent.  As it is\n   smaller than maxsizesent, it passes\
    \ the check, and thus is then\n   compared with maxsizeacked.  As claimedmtu is\
    \ larger than\n   maxsizeacked, TCP assumes that the corresponding TCP segment\
    \ was\n   performing the Initial PMTU Discovery.  Therefore, the TCP at H1\n \
    \  honors the ICMP message by updating the assumed Path-MTU.  The\n   maxsizesent\
    \ variable is reset to the minimum MTU of the Internet\n   Protocol in use (68\
    \ for IPv4, and 1280 for IPv6).\n   In line 6, the TCP at H1 sends a segment with\
    \ 2008 bytes of data,\n   which results in an IP packet of 2048 octets.  The maxsizesent\n\
    \   variable is thus set to 2008 bytes.  When the packet reaches R2, it\n   elicits\
    \ an ICMP \"Packet Too Big\" error message.\n   In line 7, H1 receives the ICMP\
    \ error message, which reports a Next-\n   Hop MTU of 1500 octets.  After performing\
    \ the TCP sequence number\n   check, the Next-Hop MTU reported by the ICMP error\
    \ message\n   (claimedmtu) is compared with maxsizesent.  As it is smaller than\n\
    \   maxsizesent, it passes the check, and thus is then compared with\n   maxsizeacked.\
    \  As claimedmtu is larger than maxsizeacked, TCP assumes\n   that the corresponding\
    \ TCP segment was performing the Initial PMTU\n   Discovery.  Therefore, the TCP\
    \ at H1 honors the ICMP message by\n   updating the assumed Path-MTU.  The maxsizesent\
    \ variable is reset to\n   the minimum MTU of the Internet Protocol in use.\n\
    \   In line 8, the TCP at H1 sends a segment with 1460 bytes of data,\n   which\
    \ results in an IP packet of 1500 octets.  Thus, maxsizesent is\n   set to 1500.\
    \  This packet reaches H2, where it elicits an\n   acknowledgement (ACK) segment.\n\
    \   In line 9, H1 finally gets the acknowledgement for the data segment.\n   As\
    \ the corresponding packet was larger than maxsizeacked, TCP updates\n   maxsizeacked,\
    \ setting it to 1500.  At this point, TCP has discovered\n   the Path-MTU for\
    \ this TCP connection.\n"
- title: 7.3.2.  Operation during Path-MTU Changes
  contents:
  - "7.3.2.  Operation during Path-MTU Changes\n   Let us suppose a TCP connection\
    \ between H1 and H2 has already been\n   established, and that the PMTU for the\
    \ connection has already been\n   discovered to be 1500.  At this point, both\
    \ maxsizesent and\n   maxsizeacked are equal to 1500, and nsegrto is equal to\
    \ 0.  Suppose\n   some time later the PMTU decreases to 1492.  For simplicity,\
    \ let us\n   suppose that the Path-MTU has decreased because the MTU of the link\n\
    \   between R2 and R3 has decreased from 1500 to 1492.  Figure 3\n   illustrates\
    \ how the counter-measure would work in this scenario.\n       Host 1        \
    \                               Host 2\n   1.                   (Path-MTU decreases)\n\
    \   2.    -->  <SEQ=100><ACK=X><CTL=ACK><DATA=1460>   -->\n   3.       <--- ICMP\
    \ \"Packet Too Big\" MTU=1492, TCPseq#=100 <--- R2\n   4.                   (Segment\
    \ times out)\n   5.    -->  <SEQ=100><ACK=X><CTL=ACK><DATA=1452>   -->\n   6.\
    \    <--        <SEQ=X><ACK=1552><CTL=ACK>       <--\n                Figure 3:\
    \ Operation during Path-MTU Changes\n   In line 1, the Path-MTU for this connection\
    \ decreases from 1500 to\n   1492.  In line 2, the TCP at H1, without being aware\
    \ of the Path-MTU\n   change, sends a 1500-byte packet to H2.  When the packet\
    \ reaches R2,\n   it elicits an ICMP \"Packet Too Big\" error message.\n   In\
    \ line 3, H1 receives the ICMP error message, which reports a Next-\n   Hop MTU\
    \ of 1492 octets.  After performing the TCP sequence number\n   check, the Next-Hop\
    \ MTU reported by the ICMP error message\n   (claimedmtu) is compared with maxsizesent.\
    \  As claimedmtu is smaller\n   than maxsizesent, it is then compared with maxsizeacked.\
    \  As\n   claimedmtu is smaller than maxsizeacked (full-sized packets were\n \
    \  getting to the remote endpoint), this packet is assumed to be\n   performing\
    \ Path-MTU Update, and a \"pending error\" condition is\n   recorded.\n   In line\
    \ 4, the segment times out.  Thus, nsegrto is incremented by 1.\n   As nsegrto\
    \ is greater than or equal to MAXSEGRTO, the assumed Path-\n   MTU is updated.\
    \  The nsegrto variable is reset to 0, maxsizeacked is\n   set to claimedmtu,\
    \ and maxsizesent is set to the minimum MTU of the\n   Internet Protocol in use.\n\
    \   In line 5, H1 retransmits the data using the updated PMTU, and thus\n   maxsizesent\
    \ is set to 1492.  The resulting packet reaches H2, where\n   it elicits an acknowledgement\
    \ (ACK) segment.\n   In line 6, H1 finally gets the acknowledgement for the data\
    \ segment.\n   At this point, TCP has discovered the new Path-MTU for this TCP\n\
    \   connection.\n"
- title: 7.3.3.  Idle Connection Being Attacked
  contents:
  - "7.3.3.  Idle Connection Being Attacked\n   Let us suppose a TCP connection between\
    \ H1 and H2 has already been\n   established, and the PMTU for the connection\
    \ has already been\n   discovered to be 1500.  Figure 4 shows a sample time-line\
    \ diagram\n   that illustrates an idle connection being attacked.\n       Host\
    \ 1                                       Host 2\n   1.    -->   <SEQ=100><ACK=X><CTL=ACK><DATA=50>\
    \    -->\n   2.    <--        <SEQ=X><ACK=150><CTL=ACK>        <--\n   3.    \
    \   <--- ICMP \"Packet Too Big\" MTU=68, TCPseq#=100 <---\n   4.       <--- ICMP\
    \ \"Packet Too Big\" MTU=68, TCPseq#=100 <---\n   5.       <--- ICMP \"Packet\
    \ Too Big\" MTU=68, TCPseq#=100 <---\n                 Figure 4: Idle Connection\
    \ Being Attacked\n   In line 1, H1 sends its last bunch of data.  In line 2, H2\n\
    \   acknowledges the receipt of these data.  Then the connection becomes\n   idle.\
    \  In lines 3, 4, and 5, an attacker sends forged ICMP \"Packet\n   Too Big\"\
    \ error messages to H1.  Regardless of how many packets it\n   sends and of the\
    \ TCP sequence number each ICMP packet includes, none\n   of these ICMP error\
    \ messages will pass the TCP sequence number check\n   described in Section 4.1,\
    \ as H1 has no unacknowledged data \"in\n   flight\" to H2.  Therefore, the attack\
    \ does not succeed.\n"
- title: 7.3.4.  Active Connection Being Attacked after Discovery of the Path-MTU
  contents:
  - "7.3.4.  Active Connection Being Attacked after Discovery of the Path-MTU\n  \
    \ Let us suppose an attacker attacks a TCP connection for which the\n   PMTU has\
    \ already been discovered.  In this case, as illustrated in\n   Figure 1, the\
    \ PMTU would be found to be 1500 bytes.  Figure 5 shows a\n   possible packet\
    \ exchange.\n       Host 1                                       Host 2\n   1.\
    \    -->  <SEQ=100><ACK=X><CTL=ACK><DATA=1460>   -->\n   2.    -->  <SEQ=1560><ACK=X><CTL=ACK><DATA=1460>\
    \  -->\n   3.    -->  <SEQ=3020><ACK=X><CTL=ACK><DATA=1460>  -->\n   4.    -->\
    \  <SEQ=4480><ACK=X><CTL=ACK><DATA=1460>  -->\n   5.       <--- ICMP \"Packet\
    \ Too Big\" MTU=68, TCPseq#=100 <---\n   6.    <--       <SEQ=X><CTL=ACK><ACK=1560>\
    \        <--\n    Figure 5: Active Connection Being Attacked after Discovery of\
    \ PMTU\n   As we assume the PMTU has already been discovered, we also assume\n\
    \   both maxsizesent and maxsizeacked are equal to 1500.  We assume\n   nsegrto\
    \ is equal to zero, as there have been no segment timeouts.\n   In lines 1, 2,\
    \ 3, and 4, H1 sends four data segments to H2.  In\n   line 5, an attacker sends\
    \ a forged ICMP error message to H1.  We\n   assume the attacker is lucky enough\
    \ to guess both the four-tuple that\n   identifies the connection and a valid\
    \ TCP sequence number.  As the\n   Next-Hop MTU claimed in the ICMP \"Packet Too\
    \ Big\" message\n   (claimedmtu) is smaller than maxsizeacked, this packet is\
    \ assumed to\n   be performing Path-MTU Update.  Thus, the error message is recorded.\n\
    \   In line 6, H1 receives an acknowledgement for the segment sent in\n   line\
    \ 1, before it times out.  At this point, the \"pending error\"\n   condition\
    \ is cleared, and the recorded ICMP \"Packet Too Big\" error\n   message is ignored.\
    \  Therefore, the attack does not succeed.\n"
- title: 7.3.5.  TCP Peer Attacked when Sending Small Packets Just after the
  contents:
  - "7.3.5.  TCP Peer Attacked when Sending Small Packets Just after the\n       \
    \ Three-Way Handshake\n   This section analyzes a scenario in which a TCP peer\
    \ that is sending\n   small segments just after the connection has been established\
    \ is\n   attacked.  The connection could be in use by protocols such as SMTP\n\
    \   [RFC5321] and HTTP [RFC2616], for example, which usually behave like\n   this.\n\
    \   Figure 6 shows a possible packet exchange for such a scenario.\n       Host\
    \ 1                                       Host 2\n   1.    -->           <SEQ=100><CTL=SYN>\
    \            -->\n   2.    <--      <SEQ=X><ACK=101><CTL=SYN,ACK>      <--\n \
    \  3.    -->       <SEQ=101><ACK=X+1><CTL=ACK>       -->\n   4.    -->  <SEQ=101><ACK=X+1><CTL=ACK><DATA=100>\
    \  -->\n   5.    <--       <SEQ=X+1><ACK=201><CTL=ACK>       <--\n   6.    -->\
    \  <SEQ=201><ACK=X+1><CTL=ACK><DATA=100>  -->\n   7.    -->  <SEQ=301><ACK=X+1><CTL=ACK><DATA=100>\
    \  -->\n   8.       <--- ICMP \"Packet Too Big\" MTU=150, TCPseq#=201 <---\n \
    \         Figure 6: TCP Peer Attacked when Sending Small Packets\n           \
    \         Just after the Three-Way Handshake\n   The nsegrto variable is initialized\
    \ to zero.  Both maxsizesent and\n   maxsizeacked are initialized to the minimum\
    \ MTU for the Internet\n   Protocol being used (68 for IPv4, and 1280 for IPv6).\n\
    \   In lines 1 to 3, the three-way handshake takes place, and the\n   connection\
    \ is established.  At this point, the assumed Path-MTU for\n   this connection\
    \ is 4464.  In line 4, H1 sends a small segment (which\n   results in a 140-byte\
    \ packet) to H2.  Therefore, maxsizesent is set\n   to 140.  In line 5, this segment\
    \ is acknowledged, and thus\n   maxsizeacked is set to 140.\n   In lines 6 and\
    \ 7, H1 sends two small segments to H2.  In line 8,\n   while the segments from\
    \ lines 6 and 7 are still \"in flight\" to H2, an\n   attacker sends a forged\
    \ ICMP \"Packet Too Big\" error message to H1.\n   Assuming the attacker is lucky\
    \ enough to guess a valid TCP sequence\n   number, this ICMP message will pass\
    \ the TCP sequence number check.\n   The Next-Hop MTU reported by the ICMP error\
    \ message (claimedmtu) is\n   then compared with maxsizesent.  As claimedmtu is\
    \ larger than\n   maxsizesent, the ICMP error message is silently discarded.\n\
    \   Therefore, the attack does not succeed.\n"
- title: 7.4.  Pseudo-Code for the Counter-Measure for the Blind Performance-
  contents:
  - "7.4.  Pseudo-Code for the Counter-Measure for the Blind Performance-\n      Degrading\
    \ Attack\n   This section contains a pseudo-code version of the counter-measure\n\
    \   described in Section 7.2 for the blind performance-degrading attack\n   described\
    \ in Section 7.  It is meant as guidance for developers on\n   how to implement\
    \ this counter-measure.\n   The pseudo-code makes use of the following variables,\
    \ constants, and\n   functions:\n   ack\n      Variable holding the acknowledgement\
    \ number contained in the TCP\n      segment that has just been received.\n  \
    \ acked_packet_size\n      Variable holding the packet size (data, plus headers)\
    \ that the ACK\n      that has just been received is acknowledging.\n   adjust_mtu()\n\
    \      Function that adjusts the MTU for this connection, according to\n     \
    \ the ICMP \"Packet Too Big\" that was last received.\n   claimedmtu\n      Variable\
    \ holding the Next-Hop MTU advertised by the ICMP \"Packet\n      Too Big\" error\
    \ message.\n   claimedtcpseq\n      Variable holding the TCP sequence number contained\
    \ in the payload\n      of the ICMP \"Packet Too Big\" message that has just been\
    \ received\n      or was last recorded.\n   current_mtu\n      Variable holding\
    \ the assumed Path-MTU for this connection.\n   drop_message()\n      Function\
    \ that performs the necessary actions to drop the ICMP\n      message being processed.\n\
    \   initial_mtu\n      Variable holding the MTU for new connections, as explained\
    \ in\n      [RFC1191] and [RFC1981].\n   maxsizeacked\n      Variable holding\
    \ the largest packet size (data, plus headers) that\n      has so far been acked\
    \ for this connection, as explained in\n      Section 7.2.\n   maxsizesent\n \
    \     Variable holding the largest packet size (data, plus headers) that\n   \
    \   has so far been sent for this connection, as explained in\n      Section 7.2.\n\
    \   nsegrto\n      Variable holding the number of times this segment has timed\
    \ out,\n      as explained in Section 7.2.\n   packet_size\n      Variable holding\
    \ the size of the IP datagram being sent.\n   pending_message\n      Variable\
    \ (flag) that indicates whether there is a pending ICMP\n      \"Packet Too Big\"\
    \ message to be processed.\n   save_message()\n      Function that records the\
    \ ICMP \"Packet Too Big\" message that has\n      just been received.\n   MINIMUM_MTU\n\
    \      Constant holding the minimum MTU for the Internet Protocol in use\n   \
    \   (68 for IPv4, and 1280 for IPv6).\n   MAXSEGRTO\n      Constant holding the\
    \ number of times a given segment must time out\n      before an ICMP \"Packet\
    \ Too Big\" error message can be honored.\n   EVENT: New TCP connection\n    current_mtu\
    \ = initial_mtu;\n    maxsizesent = MINIMUM_MTU;\n    maxsizeacked = MINIMUM_MTU;\n\
    \    nsegrto = 0;\n    pending_message = 0;\n   EVENT: Segment is sent\n    if\
    \ (packet_size > maxsizesent)\n         maxsizesent = packet_size;\n   EVENT:\
    \ Segment is received\n    if (acked_packet_size > maxsizeacked)\n         maxsizeacked\
    \ = acked_packet_size;\n    if (pending_message)\n         if (ack > claimedtcpseq){\n\
    \              pending_message = 0;\n              nsegrto = 0;\n         }\n\
    \   EVENT: ICMP \"Packet Too Big\" message is received\n    if (claimedmtu <=\
    \ MINIMUM_MTU)\n         drop_message();\n    if (claimedtcpseq < SND.UNA || claimedtcpseq\
    \ >= SND.NXT)\n         drop_message();\n    else {\n         if (claimedmtu >\
    \ maxsizesent || claimedmtu >= current_mtu)\n              drop_message();\n \
    \        else {\n              if (claimedmtu > maxsizeacked){\n             \
    \      adjust_mtu();\n                   current_mtu = claimedmtu;\n         \
    \          maxsizesent = MINIMUM_MTU;\n              }\n              else {\n\
    \                   pending_message = 1;\n                   save_message();\n\
    \              }\n         }\n    }\n   EVENT: Segment times out\n    nsegrto++;\n\
    \    if (pending_message && nsegrto >= MAXSEGRTO){\n         adjust_mtu();\n \
    \        nsegrto = 0;\n         pending_message = 0;\n         maxsizeacked =\
    \ claimedmtu;\n         maxsizesent = MINIMUM_MTU;\n         current_mtu = claimedmtu;\n\
    \    }\n   Notes:\n      All comparisons between sequence numbers must be performed\
    \ using\n      sequence number arithmetic.\n      The pseudo-code implements the\
    \ mechanism described in Section 7.2,\n      the TCP sequence number checking\
    \ described in Section 4.1, and the\n      validation check on the advertised\
    \ Next-Hop MTU described in\n      [RFC1191] and [RFC1981].\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   This document describes the use of ICMP error\
    \ messages to perform a\n   number of attacks against TCP, and describes a number\
    \ of widely\n   implemented counter-measures that either eliminate or reduce the\n\
    \   impact of these attacks when they are performed by off-path\n   attackers.\n\
    \   Section 4.1 describes a validation check that could be enforced on\n   ICMP\
    \ error messages, such that TCP reacts only to those ICMP error\n   messages that\
    \ appear to relate to segments currently \"in flight\" to\n   the destination\
    \ system.  This requires more effort on the side of an\n   off-path attacker at\
    \ the expense of possible reduced responsiveness\n   to network errors.\n   Section\
    \ 4.2 describes how randomization of TCP ephemeral ports\n   requires more effort\
    \ on the side of the attacker to successfully\n   exploit any of the attacks described\
    \ in this document.\n   Section 4.3 describes how ICMP error messages could possibly\
    \ be\n   filtered based on their payload, to prevent users of the local\n   network\
    \ from successfully performing attacks against third-party\n   connections.  This\
    \ is analogous to ingress filtering and egress\n   filtering of IP packets [IP-filtering].\n\
    \   Section 5.2 describes an attack-specific counter-measure for the\n   blind\
    \ connection-reset attack.  It describes the processing of ICMP\n   \"hard errors\"\
    \ as \"soft errors\" when they are received for connections\n   in any of the\
    \ synchronized states.  This counter-measure eliminates\n   the aforementioned\
    \ vulnerability in synchronized connections at the\n   expense of possible reduced\
    \ responsiveness in some network scenarios.\n   Section 6.2 describes an attack-specific\
    \ counter-measure for the\n   blind throughput-reduction attack.  It suggests\
    \ that the\n   aforementioned vulnerability can be eliminated by ignoring ICMPv4\n\
    \   Source Quench messages meant for TCP connections.  This is in\n   accordance\
    \ with research results that indicate that ICMPv4 Source\n   Quench messages are\
    \ ineffective and are an unfair antidote for\n   congestion.\n   Finally, Section\
    \ 7.2 describes an attack-specific counter-measure for\n   the blind performance-degrading\
    \ attack.  It consists of the\n   validation check described in Section 4.1, with\
    \ a modification that\n   makes TCP react to ICMP \"Packet Too Big\" error messages\
    \ such that\n   they are processed when an outstanding TCP segment times out.\
    \  This\n   counter-measure parallels the Packetization Layer Path MTU Discovery\n\
    \   (PLPMTUD) mechanism [RFC4821].  It should be noted that if this\n   counter-measure\
    \ is implemented, in some scenarios TCP may respond\n   more slowly to valid ICMP\
    \ \"Packet Too Big\" error messages.\n   A discussion of these and other attack\
    \ vectors for performing similar\n   attacks against TCP (along with possible\
    \ counter-measures) can be\n   found in [CPNI-TCP] and [TCP-SECURITY].\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   This document was inspired by Mika Liljeberg, while\
    \ discussing some\n   issues related to [RFC5461] by private e-mail.  The author\
    \ would like\n   to thank (in alphabetical order): Bora Akyol, Mark Allman, Ran\n\
    \   Atkinson, James Carlson, Alan Cox, Theo de Raadt, Wesley Eddy, Lars\n   Eggert,\
    \ Ted Faber, Juan Fraschini, Markus Friedl, Guillermo Gont,\n   John Heffner,\
    \ Alfred Hoenes, Vivek Kakkar, Michael Kerrisk, Mika\n   Liljeberg, Matt Mathis,\
    \ David Miller, Toby Moncaster, Miles Nordin,\n   Eloy Paris, Kacheong Poon, Andrew\
    \ Powell, Pekka Savola, Donald Smith,\n   Pyda Srisuresh, Fred Templin, and Joe\
    \ Touch for contributing many\n   valuable comments.\n   Juan Fraschini and the\
    \ author of this document implemented freely\n   available audit tools to help\
    \ vendors audit their systems by\n   reproducing the attacks discussed in this\
    \ document.  These tools are\n   available at http://www.gont.com.ar/tools/index.html.\n\
    \   Markus Friedl, Chad Loder, and the author of this document produced\n   and\
    \ tested in OpenBSD [OpenBSD] the first implementation of the\n   counter-measure\
    \ described in Section 7.2.  This first implementation\n   helped to test the\
    \ effectiveness of the ideas introduced in this\n   document, and has served as\
    \ a reference implementation for other\n   operating systems.\n   The author would\
    \ like to thank the UK's Centre for the Protection of\n   National Infrastructure\
    \ (CPNI) -- formerly the National\n   Infrastructure Security Co-ordination Centre\
    \ (NISCC) -- for\n   coordinating the disclosure of these issues with a large\
    \ number of\n   vendors and CSIRTs (Computer Security Incident Response Teams).\n\
    \   The author wishes to express deep and heartfelt gratitude to Jorge\n   Oscar\
    \ Gont and Nelida Garcia, for their precious motivation and\n   guidance.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC0791]         Postel, J., \"Internet Protocol\"\
    , STD 5, RFC 791,\n                     September 1981.\n   [RFC0792]        \
    \ Postel, J., \"Internet Control Message Protocol\",\n                     STD\
    \ 5, RFC 792, September 1981.\n   [RFC0793]         Postel, J., \"Transmission\
    \ Control Protocol\", STD 7,\n                     RFC 793, September 1981.\n\
    \   [RFC1122]         Braden, R., \"Requirements for Internet Hosts -\n      \
    \               Communication Layers\", STD 3, RFC 1122,\n                   \
    \  October 1989.\n   [RFC1191]         Mogul, J. and S. Deering, \"Path MTU discovery\"\
    ,\n                     RFC 1191, November 1990.\n   [RFC1812]         Baker,\
    \ F., \"Requirements for IP Version 4 Routers\",\n                     RFC 1812,\
    \ June 1995.\n   [RFC1981]         McCann, J., Deering, S., and J. Mogul, \"Path\
    \ MTU\n                     Discovery for IP version 6\", RFC 1981, August 1996.\n\
    \   [RFC2119]         Bradner, S., \"Key words for use in RFCs to Indicate\n \
    \                    Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2460]\
    \         Deering, S. and R. Hinden, \"Internet Protocol,\n                  \
    \   Version 6 (IPv6) Specification\", RFC 2460,\n                     December\
    \ 1998.\n   [RFC4301]         Kent, S. and K. Seo, \"Security Architecture for\
    \ the\n                     Internet Protocol\", RFC 4301, December 2005.\n  \
    \ [RFC4443]         Conta, A., Deering, S., and M. Gupta, \"Internet\n       \
    \              Control Message Protocol (ICMPv6) for the Internet\n          \
    \           Protocol Version 6 (IPv6) Specification\", RFC 4443,\n           \
    \          March 2006.\n   [RFC4884]         Bonica, R., Gan, D., Tappan, D.,\
    \ and C. Pignataro,\n                     \"Extended ICMP to Support Multi-Part\
    \ Messages\",\n                     RFC 4884, April 2007.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [CPNI-TCP]        CPNI, \"Security Assessment\
    \ of the Transmission\n                     Control Protocol (TCP)\", http://www.cpni.gov.uk/\n\
    \                     Docs/tn-03-09-security-assessment-TCP.pdf, 2009.\n   [DClark]\
    \          Clark, D., \"The Design Philosophy of the DARPA\n                 \
    \    Internet Protocols\", Computer Communication\n                     Review\
    \ Vol. 18, No. 4, 1988.\n   [FreeBSD]         The FreeBSD Project, http://www.freebsd.org.\n\
    \   [ICMP-Filtering]  Gont, F., \"Filtering of ICMP error messages\",  http\n\
    \                     ://www.gont.com.ar/papers/\n                     filtering-of-icmp-error-messages.pdf.\n\
    \   [IP-filtering]    NISCC, \"NISCC Technical Note 01/2006: Egress and\n    \
    \                 Ingress Filtering\",\n                      http://www.cpni.gov.uk/Docs/re-20060420-00294.pdf,\n\
    \                     2006.\n   [Linux]           The Linux Project, \"http://www.kernel.org\"\
    .\n   [McKusick]        McKusick, M., Bostic, K., Karels, M., and J.\n       \
    \              Quarterman, \"The Design and Implementation of the\n          \
    \           4.4 BSD Operating System\", Addison-Wesley, 1996.\n   [NISCC]    \
    \       NISCC, \"NISCC Vulnerability Advisory 532967/NISCC/\n                \
    \     ICMP: Vulnerability Issues in ICMP packets with TCP\n                  \
    \   payloads\",  http://www.cpni.gov.uk/docs/\n                     re-20050412-00303.pdf?lang=en,\
    \ 2005.\n   [NetBSD]          The NetBSD Project, \"http://www.netbsd.org\".\n\
    \   [OpenBSD]         The OpenBSD Project, \"http://www.openbsd.org\".\n   [OpenBSD-PF]\
    \      The OpenBSD Packet Filter,\n                     \"http://www.openbsd.org/faq/pf/\"\
    .\n   [PORT-RANDOM]     Larsen, M. and F. Gont, \"Transport Protocol Port\n  \
    \                   Randomization Recommendations\", Work in Progress,\n     \
    \                April 2010.\n   [RFC0816]         Clark, D., \"Fault isolation\
    \ and recovery\", RFC 816,\n                     July 1982.\n   [RFC1321]    \
    \     Rivest, R., \"The MD5 Message-Digest Algorithm\",\n                    \
    \ RFC 1321, April 1992.\n   [RFC1323]         Jacobson, V., Braden, B., and D.\
    \ Borman, \"TCP\n                     Extensions for High Performance\", RFC 1323,\n\
    \                     May 1992.\n   [RFC2385]         Heffernan, A., \"Protection\
    \ of BGP Sessions via the\n                     TCP MD5 Signature Option\", RFC\
    \ 2385, August 1998.\n   [RFC2616]         Fielding, R., Gettys, J., Mogul, J.,\
    \ Frystyk, H.,\n                     Masinter, L., Leach, P., and T. Berners-Lee,\n\
    \                     \"Hypertext Transfer Protocol -- HTTP/1.1\",\n         \
    \            RFC 2616, June 1999.\n   [RFC2923]         Lahey, K., \"TCP Problems\
    \ with Path MTU Discovery\",\n                     RFC 2923, September 2000.\n\
    \   [RFC3168]         Ramakrishnan, K., Floyd, S., and D. Black, \"The\n     \
    \                Addition of Explicit Congestion Notification (ECN)\n        \
    \             to IP\", RFC 3168, September 2001.\n   [RFC3390]         Allman,\
    \ M., Floyd, S., and C. Partridge,\n                     \"Increasing TCP's Initial\
    \ Window\", RFC 3390,\n                     October 2002.\n   [RFC4271]      \
    \   Rekhter, Y., Li, T., and S. Hares, \"A Border\n                     Gateway\
    \ Protocol 4 (BGP-4)\", RFC 4271,\n                     January 2006.\n   [RFC4821]\
    \         Mathis, M. and J. Heffner, \"Packetization Layer\n                 \
    \    Path MTU Discovery\", RFC 4821, March 2007.\n   [RFC4907]         Aboba,\
    \ B., \"Architectural Implications of Link\n                     Indications\"\
    , RFC 4907, June 2007.\n   [RFC4953]         Touch, J., \"Defending TCP Against\
    \ Spoofing\n                     Attacks\", RFC 4953, July 2007.\n   [RFC5321]\
    \         Klensin, J., \"Simple Mail Transfer Protocol\",\n                  \
    \   RFC 5321, October 2008.\n   [RFC5461]         Gont, F., \"TCP's Reaction to\
    \ Soft Errors\",\n                     RFC 5461, February 2009.\n   [RFC5681]\
    \         Allman, M., Paxson, V., and E. Blanton, \"TCP\n                    \
    \ Congestion Control\", RFC 5681, September 2009.\n   [RFC5925]         Touch,\
    \ J., Mankin, A., and R. Bonica, \"The TCP\n                     Authentication\
    \ Option\", RFC 5925, June 2010.\n   [TCP-SECURITY]    Gont, F., \"Security Assessment\
    \ of the Transmission\n                     Control Protocol (TCP)\", Work in\
    \ Progress,\n                     February 2010.\n   [TCPM-TCPSECURE]  Ramaiah,\
    \ A., Stewart, R., and M. Dalal, \"Improving\n                     TCP's Robustness\
    \ to Blind In-Window Attacks\", Work\n                     in Progress, May 2010.\n\
    \   [US-CERT]         US-CERT, \"US-CERT Vulnerability Note VU#222750:\n     \
    \                TCP/IP Implementations do not adequately validate\n         \
    \            ICMP error messages\",\n                     http://www.kb.cert.org/vuls/id/222750,\
    \ 2005.\n   [Watson]          Watson, P., \"Slipping in the Window: TCP Reset\n\
    \                     Attacks\", CanSecWest Conference, 2004.\n   [Wright]   \
    \       Wright, G. and W. Stevens, \"TCP/IP Illustrated,\n                   \
    \  Volume 2: The Implementation\", Addison-\n                     Wesley, 1994.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Fernando Gont\n   Universidad Tecnologica Nacional / Facultad\
    \ Regional Haedo\n   Evaristo Carriego 2644\n   Haedo, Provincia de Buenos Aires\
    \  1706\n   Argentina\n   Phone: +54 11 4650 8472\n   EMail: fernando@gont.com.ar\n\
    \   URI:   http://www.gont.com.ar\n"
