- title: __initial_text__
  contents:
  - '                   RPCSEC_GSS Protocol Specification

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes an ONC/RPC security flavor that allows RPC\n\
    \   protocols to access the Generic Security Services Application\n   Programming\
    \ Interface (referred to henceforth as GSS-API).\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 2\n   2.  The ONC RPC Message Protocol . . . . . . . . . . . . .\
    \ . . . . 2\n   3.  Flavor Number Assignment . . . . . . . . . . . . . . . . .\
    \ . . 3\n   4.  New auth_stat Values . . . . . . . . . . . . . . . . . . . . .\
    \ 3\n   5.  Elements of the RPCSEC_GSS Security Protocol . . . . . . . . . 3\n\
    \   5.1.  Version Selection  . . . . . . . . . . . . . . . . . . . . . 5\n   5.2.\
    \  Context Creation . . . . . . . . . . . . . . . . . . . . . . 5\n   5.2.1. \
    \ Mechanism and QOP Selection  . . . . . . . . . . . . . . . 5\n   5.2.2.  Context\
    \ Creation Requests  . . . . . . . . . . . . . . . . 6\n   5.2.3.  Context Creation\
    \ Responses . . . . . . . . . . . . . . . . 8\n   5.2.3.1.  Context Creation Response\
    \ - Successful Acceptance  . . . 8\n   5.2.3.1.1.  Client Processing of Successful\
    \ Context Creation\n               Responses  . . . . . . . . . . . . . . . .\
    \ . . . . . . 9\n   5.2.3.2.  Context Creation Response - Unsuccessful Cases .\
    \ . . . . 9\n   5.3.  RPC Data Exchange  . . . . . . . . . . . . . . . . . . .\
    \ .  10\n   5.3.1.  RPC Request Header . . . . . . . . . . . . . . . . . . . \
    \ 10\n   5.3.2.  RPC Request Data . . . . . . . . . . . . . . . . . . . .  11\n\
    \   5.3.2.1.  RPC Request Data - No Data Integrity . . . . . . . . .  11\n   5.3.2.2.\
    \  RPC Request Data - With Data Integrity . . . . . . . .  11\n   5.3.2.3.  RPC\
    \ Request Data - With Data Privacy . . . . . . . . .  12\n   5.3.3.  Server Processing\
    \ of RPC Data Requests . . . . . . . . .  12\n   5.3.3.1.  Context Management\
    \ . . . . . . . . . . . . . . . . . .  12\n   5.3.3.2.  Server Reply - Request\
    \ Accepted  . . . . . . . . . . .  14\n   5.3.3.3.  Server Reply - Request Denied\
    \  . . . . . . . . . . . .  15\n   5.3.3.4.  Mapping of GSS-API Errors to Server\
    \ Responses  . . . .  16\n   5.3.3.4.1.  GSS_GetMIC() Failure . . . . . . . .\
    \ . . . . . . . .  16\n   5.3.3.4.2.  GSS_VerifyMIC() Failure  . . . . . . . .\
    \ . . . . . .  16\n   5.3.3.4.3.  GSS_Unwrap() Failure . . . . . . . . . . . .\
    \ . . . .  16\n   5.3.3.4.4.  GSS_Wrap() Failure . . . . . . . . . . . . . . .\
    \ . .  16\n   5.4.  Context Destruction  . . . . . . . . . . . . . . . . . . .\
    \  17\n   6.  Set of GSS-API Mechanisms  . . . . . . . . . . . . . . . . .  17\n\
    \   7.  Security Considerations  . . . . . . . . . . . . . . . . . .  18\n   7.1.\
    \  Privacy of Call Header . . . . . . . . . . . . . . . . . .  18\n   7.2.  Sequence\
    \ Number Attacks  . . . . . . . . . . . . . . . . .  18\n   7.2.1.  Sequence Numbers\
    \ Above the Window  . . . . . . . . . . .  18\n   7.2.2.  Sequence Numbers Within\
    \ or Below the Window  . . . . . .  18\n   7.3.  Message Stealing Attacks . .\
    \ . . . . . . . . . . . . . . .  19\n   Appendix A. GSS-API Major Status Codes\
    \ . . . . . . . . . . . . .  20\n   Acknowledgements . . . . . . . . . . . . .\
    \ . . . . . . . . . . .  22\n   Authors' Addresses . . . . . . . . . . . . . .\
    \ . . . . . . . . .  23\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes the protocol used by the RPCSEC_GSS\
    \ security\n   flavor.  Security flavors have been called authentication flavors\
    \ for\n   historical reasons. This memo recognizes that there are two other\n\
    \   security services besides authentication, integrity, and privacy, and\n  \
    \ so defines a new RPCSEC_GSS security flavor.\n   The protocol is described using\
    \ the XDR language [Srinivasan-xdr].\n   The reader is assumed to be familiar\
    \ with ONC RPC and the security\n   flavor mechanism [Srinivasan-rpc].  The reader\
    \ is also assumed to be\n   familiar with the GSS-API framework [Linn].  The RPCSEC_GSS\
    \ security\n   flavor uses GSS-API interfaces to provide security services that\
    \ are\n   independent of the underlying security mechanism.\n"
- title: 2.  The ONC RPC Message Protocol
  contents:
  - "2.  The ONC RPC Message Protocol\n   This memo refers to the following XDR types\
    \ of the ONC RPC protocol,\n   which are described in the document entitled Remote\
    \ Procedure Call\n   Protocol Specification Version 2 [Srinivasan-rpc]:\n    \
    \  msg_type\n      reply_stat\n      auth_flavor\n      accept_stat\n      reject_stat\n\
    \      auth_stat\n      opaque_auth\n      rpc_msg\n      call_body\n      reply_body\n\
    \      accepted_reply\n      rejected_reply\n"
- title: 3.  Flavor Number Assignment
  contents:
  - "3.  Flavor Number Assignment\n   The RPCSEC_GSS security flavor has been assigned\
    \ the value of 6:\n      enum auth_flavor {\n          ...\n          RPCSEC_GSS\
    \ = 6      /* RPCSEC_GSS security flavor */\n      };\n"
- title: 4.  New auth_stat Values
  contents:
  - "4.  New auth_stat Values\n   RPCSEC_GSS requires the addition of two new values\
    \ to the auth_stat\n   enumerated type definition:\n      enum auth_stat {\n \
    \             ...\n              /*\n               * RPCSEC_GSS errors\n    \
    \           */\n              RPCSEC_GSS_CREDPROBLEM = 13,\n              RPCSEC_GSS_CTXPROBLEM\
    \ = 14\n      };\n   The descriptions of these two new values are defined later\
    \ in this\n   memo.\n"
- title: 5.  Elements of the RPCSEC_GSS Security Protocol
  contents:
  - "5.  Elements of the RPCSEC_GSS Security Protocol\n   An RPC session based on\
    \ the RPCSEC_GSS security flavor consists of\n   three phases: context creation,\
    \ RPC data exchange, and context\n   destruction.  In the following discussion,\
    \ protocol elements for\n   these three phases are described.\n   The following\
    \ description of the RPCSEC_GSS protocol uses some of the\n   definitions within\
    \ XDR language description of the RPC protocol.\n   Context creation and destruction\
    \ use control messages that are not\n   dispatched to service procedures registered\
    \ by an RPC server.  The\n   program and version numbers used in these control\
    \ messages are the\n   same as the RPC service's program and version numbers.\
    \  The procedure\n   number used is NULLPROC (zero).  A field in the credential\n\
    \   information (the gss_proc field which is defined in the\n   rpc_gss_cred_t\
    \ structure below) specifies whether a message is to be\n   interpreted as a control\
    \ message or a regular RPC message.  If this\n   field is set to RPCSEC_GSS_DATA,\
    \ no control action is implied; in\n   this case, it is a regular data message.\
    \  If this field is set to any\n   other value, a control action is implied. \
    \ This is described in the\n   following sections.\n   Just as with normal RPC\
    \ data exchange messages, the transaction\n   identifier (the xid field in struct\
    \ rpc_msg), should be set to unique\n   values on each call for context creation\
    \ and context destruction.\n   The following definitions are used for describing\
    \ the protocol.\n      /* RPCSEC_GSS control procedures */\n      enum rpc_gss_proc_t\
    \ {\n              RPCSEC_GSS_DATA = 0,\n              RPCSEC_GSS_INIT = 1,\n\
    \              RPCSEC_GSS_CONTINUE_INIT = 2,\n              RPCSEC_GSS_DESTROY\
    \ = 3\n      };\n      /* RPCSEC_GSS services */\n      enum rpc_gss_service_t\
    \ {\n          /* Note: the enumerated value for 0 is reserved. */\n         \
    \ rpc_gss_svc_none = 1,\n          rpc_gss_svc_integrity = 2,\n          rpc_gss_svc_privacy\
    \ = 3\n      };\n      /* Credential */\n      /*\n       * Note: version 0 is\
    \ reserved for possible future\n       * definition of a version negotiation protocol\n\
    \       *\n       */\n      #define RPCSEC_GSS_VERS_1 1\n      struct rpc_gss_cred_t\
    \ {\n          union switch (unsigned int version) { /* version of\n         \
    \                                             RPCSEC_GSS */\n          case RPCSEC_GSS_VERS_1:\n\
    \              struct {\n                  rpc_gss_proc_t gss_proc;  /* control\
    \ procedure */\n                  unsigned int seq_num;   /* sequence number */\n\
    \                  rpc_gss_service_t service; /* service used */\n           \
    \       opaque handle<>;       /* context handle */\n              } rpc_gss_cred_vers_1_t;\n\
    \          }\n      };\n      /* Maximum sequence number value */\n      #define\
    \ MAXSEQ 0x80000000\n"
- title: 5.1.  Version Selection
  contents:
  - "5.1.  Version Selection\n   This document defines just one protocol version (RPCSEC_GSS_VERS_1).\n\
    \   The client should assume that the server supports RPCSEC_GSS_VERS_1\n   and\
    \ issue a Context Creation message (as described in the section\n   RPCSEC_GSS_VERS_1,\
    \ the RPC response will have a reply_stat of\n   MSG_DENIED, a rejection status\
    \ of AUTH_ERROR, and an auth_stat of\n   AUTH_REJECTED_CRED.\n"
- title: 5.2.  Context Creation
  contents:
  - "5.2.  Context Creation\n   Before RPC data is exchanged on a session using the\
    \ RPCSEC_GSS\n   flavor, a context must be set up between the client and the server.\n\
    \   Context creation may involve zero or more RPC exchanges.  The number\n   of\
    \ exchanges depends on the security mechanism.\n"
- title: 5.2.1.  Mechanism and QOP Selection
  contents:
  - "5.2.1.  Mechanism and QOP Selection\n   There is no facility in the RPCSEC_GSS\
    \ protocol to negotiate GSS-API\n   mechanism identifiers or QOP values. At minimum,\
    \ it is expected that\n   implementations of the RPCSEC_GSS protocol provide a\
    \ means to:\n   *    specify mechanism identifiers, QOP values, and RPCSEC_GSS\n\
    \        service values on the client side, and to\n   *    enforce mechanism\
    \ identifiers, QOP values, and RPCSEC_GSS\n        service values on a per-request\
    \ basis on the server side.\n   It is necessary that above capabilities exist\
    \ so that applications\n   have the means to conform the required set of required\
    \ set of\n   <mechanism, QOP, service> tuples (See the section entitled Set of\n\
    \   GSS-API Mechanisms).  An application may negotiate <mechanism, QOP,\n   service>\
    \ selection within its protocol or via an out of band\n   protocol. Hence it may\
    \ be necessary for RPCSEC_GSS implementations to\n   provide programming interfaces\
    \ for the specification and enforcement\n   of <mechanism, QOP, service>.\n  \
    \ Additionally, implementations may depend on negotiation schemes\n   constructed\
    \ as pseudo-mechanisms under the GSS-API.  Because such\n   schemes are below\
    \ the GSS-API layer, the RPCSEC_GSS protocol, as\n   specified in this document,\
    \ can make use of them.\n"
- title: 5.2.2.  Context Creation Requests
  contents:
  - "5.2.2.  Context Creation Requests\n   The first RPC request from the client to\
    \ the server initiates context\n   creation.  Within the RPC message protocol's\
    \ call_body structure,\n   rpcvers is set to 2. prog and vers are always those\
    \ for the service\n   being accessed.  The proc is always set to NULLPROC (zero).\n\
    \   Within the RPC message protocol's cred structure, flavor is set to\n   RPCSEC_GSS\
    \ (6).  The opaque data of the cred structure (the body\n   field) constituting\
    \ the credential encodes the rpc_gss_cred_t\n   structure defined previously.\n\
    \   The values of the fields contained in the rpc_gss_cred_t structure\n   are\
    \ set as follows.  The version field is set to the version of the\n   RPCSEC_GSS\
    \ protocol the client wants to use.  The remainder of this\n   memo documents\
    \ version RPCSEC_GSS_VERS_1 of RPCSEC_GSS, and so the\n   version field would\
    \ be set to RPCSEC_GSS_VERS_1.  The gss_proc field\n   must be set to RPCSEC_GSS_INIT\
    \ for the first creation request.  In\n   subsequent creation requests, the gss_proc\
    \ field must be set to\n   RPCSEC_GSS_CONTINUE_INIT.  In a creation request, the\
    \ seq_num and\n   service fields are undefined and both must be ignored by the\
    \ server.\n   In the first creation request, the handle field is NULL (opaque\
    \ data\n   of zero length).  In subsequent creation requests, handle must be\n\
    \   equal to the value returned by the server.  The handle field serves\n   as\
    \ the identifier for the context, and will not change for the\n   duration of\
    \ the context, including responses to\n   RPCSEC_GSS_CONTINUE_INIT.\n   The verifier\
    \ field in the RPC message header is also described by the\n   opaque_auth structure.\
    \  All creation requests have the NULL verifier\n   (AUTH_NONE flavor with zero\
    \ length opaque data).\n   Following the verifier are the call data (procedure\
    \ specific\n   parameters).  Note that the proc field of the call_body structure\
    \ is\n   set to NULLPROC, and thus normally there would be zero octets\n   following\
    \ the verifier.  However, since there is no RPC data exchange\n   during a context\
    \ creation, it is safe to transfer information\n   following the verifier.  It\
    \ is necessary to \"overload\" the call data\n   in this way, rather than pack\
    \ the GSS-API token into the RPC header,\n   because RPC Version 2 restricts the\
    \ amount of data that can be sent\n   in the header.  The opaque body of the credential\
    \ and verifier fields\n   can be each at most 400 octets long, and GSS tokens\
    \ can be longer\n   than 800 octets.\n   The call data for a context creation\
    \ request is described by the\n   following structure for all creation requests:\n\
    \      struct rpc_gss_init_arg {\n          opaque gss_token<>;\n      };\n  \
    \ Here, gss_token is the token returned by the call to  GSS-API's\n   GSS_Init_sec_context()\
    \ routine, opaquely encoded.  The value of this\n   field will likely be different\
    \ in each creation request, if there is\n   more than one creation request.  If\
    \ no token is returned by the call\n   to GSS_Init_sec_context(), the context\
    \ must have been created\n   (assuming no errors), and there will not be any more\
    \ creation\n   requests.\n   When GSS_Init_sec_context() is called, the parameters\n\
    \   replay_det_req_flag and sequence_req_flag must be turned off. The\n   reasons\
    \ for this are:\n   *    ONC RPC can be used over unreliable transports and provides\
    \ no\n        layer to reliably re-assemble messages. Thus it is possible for\n\
    \        gaps in message sequencing to occur, as well as out of order\n      \
    \  messages.\n   *    RPC servers can be multi-threaded, and thus the order in\
    \ which\n        GSS-API messages are signed or wrapped can be different from\
    \ the\n        order in which the messages are verified or unwrapped, even if\n\
    \        the requests are sent on reliable transports.\n   *    To maximize convenience\
    \ of implementation, the order in which an\n        ONC RPC entity will verify\
    \ the header and verify/unwrap the body\n        of an RPC call or reply is left\
    \ unspecified.\n   The RPCSEC_GSS protocol provides for protection from replay\
    \ attack,\n   yet tolerates out-of-order delivery or processing of messages and\n\
    \   tolerates dropped requests.\n"
- title: 5.2.3.  Context Creation Responses
  contents:
  - '5.2.3.  Context Creation Responses

    '
- title: 5.2.3.1.  Context Creation Response - Successful Acceptance
  contents:
  - "5.2.3.1.  Context Creation Response - Successful Acceptance\n   The response\
    \ to a successful creation request has an MSG_ACCEPTED\n   response with a status\
    \ of SUCCESS.  The results field encodes a\n   response with the following structure:\n\
    \      struct rpc_gss_init_res {\n              opaque handle<>;\n           \
    \   unsigned int gss_major;\n              unsigned int gss_minor;\n         \
    \     unsigned int seq_window;\n              opaque gss_token<>;\n      };\n\
    \   Here, handle is non-NULL opaque data that serves as the context\n   identifier.\
    \ The client must use this value in all subsequent requests\n   whether control\
    \ messages or otherwise).  The gss_major and gss_minor\n   fields contain the\
    \ results of the call to GSS_Accept_sec_context()\n   executed by the server.\
    \  The values for the gss_major field are\n   defined in Appendix A of this document.\
    \  The values for the gss_minor\n   field are GSS-API mechanism specific and are\
    \ defined in the\n   mechanism's specification.  If gss_major is not one of GSS_S_COMPLETE\n\
    \   or GSS_S_CONTINUE_NEEDED, the context setup has failed; in this case\n   handle\
    \ and gss_token must be set to NULL by the server.  The value of\n   gss_minor\
    \ is dependent on the value of gss_major and the security\n   mechanism used.\
    \  The gss_token field contains any token returned by\n   the GSS_Accept_sec_context()\
    \ call executed by the server.  A token\n   may be returned for both successful\
    \ values of gss_major.  If the\n   value is GSS_S_COMPLETE, it indicates that\
    \ the server is not\n   expecting any more tokens, and the RPC Data Exchange phase\
    \ must begin\n   on the subsequent request from the client. If the value is\n\
    \   GSS_S_CONTINUE_NEEDED, the server is expecting another token.  Hence\n   the\
    \ client must send at least one more creation request (with\n   gss_proc set to\
    \ RPCSEC_GSS_CONTINUE_INIT in the request's credential)\n   carrying the required\
    \ token.\n   In a successful response, the seq_window field is set to the sequence\n\
    \   window length supported by the server for this context.  This window\n   specifies\
    \ the maximum number of client requests that may be\n   outstanding for this context.\
    \ The server will accept \"seq_window\"\n   requests at a time, and these may\
    \ be out of order.  The client may\n   use this number to determine the number\
    \ of threads that can\n   simultaneously send requests on this context.\n   If\
    \ gss_major is GSS_S_COMPLETE, the verifier's (the verf element in\n   the response)\
    \ flavor field is set to RPCSEC_GSS, and the body field\n   set to the checksum\
    \ of the seq_window (in network order). The QOP\n   used for this checksum is\
    \ 0 (zero), which is the default QOP.  For\n   all other values of gss_major,\
    \ a NULL verifier (AUTH_NONE flavor with\n   zero-length opaque data) is used.\n"
- title: 5.2.3.1.1.  Client Processing of Successful Context Creation Responses
  contents:
  - "5.2.3.1.1.  Client Processing of Successful Context Creation Responses\n   If\
    \ the value of gss_major in the response is GSS_S_CONTINUE_NEEDED,\n   then the\
    \ client, per the GSS-API specification, must invoke\n   GSS_Init_sec_context()\
    \ using the token returned in gss_token in the\n   context creation response.\
    \ The client must then generate a context\n   creation request, with gss_proc\
    \ set to RPCSEC_GSS_CONTINUE_INIT.\n   If the value of gss_major in the response\
    \ is GSS_S_COMPLETE, and if\n   the client's previous invocation of GSS_Init_sec_context()\
    \ returned a\n   gss_major value of GSS_S_CONTINUE_NEEDED, then the client, per\
    \ the\n   GSS-API specification, must invoke GSS_Init_sec_context() using the\n\
    \   token returned in gss_token in the context creation response. If\n   GSS_Init_sec_context()\
    \ returns GSS_S_COMPLETE, the context is\n   successfully set up, and the RPC\
    \ data exchange phase must begin on\n   the subsequent request from the client.\n"
- title: 5.2.3.2.  Context Creation Response - Unsuccessful Cases
  contents:
  - "5.2.3.2.  Context Creation Response - Unsuccessful Cases\n   An MSG_ACCEPTED\
    \ reply (to a creation request) with an acceptance\n   status of other than SUCCESS\
    \ has a NULL verifier (flavor set to\n   AUTH_NONE, and zero length opaque data\
    \ in the body field), and is\n   formulated as usual for different status values.\n\
    \   An MSG_DENIED reply (to a creation request) is also formulated as\n   usual.\
    \  Note that MSG_DENIED could be returned because the server's\n   RPC implementation\
    \ does not recognize the RPCSEC_GSS security flavor.\n   RFC 1831 does not specify\
    \ the appropriate reply status in this\n   instance, but common implementation\
    \ practice appears to be to return\n   a rejection status of AUTH_ERROR with an\
    \ auth_stat of\n   AUTH_REJECTEDCRED. Even though two new values (RPCSEC_GSS_CREDPROBLEM\n\
    \   and RPCSEC_GSS_CTXPROBLEM) have been defined for the auth_stat type,\n   neither\
    \ of these two can be returned in responses to context creation\n   requests.\
    \  The auth_stat new values can be used for responses to\n   normal (data) requests.\
    \  This is described later.\n   MSG_DENIED might also be returned if the RPCSEC_GSS\
    \ version number in\n   the credential is not supported on the server. In that\
    \ case, the\n   server returns a rejection status of AUTH_ERROR, with an auth_stat\
    \ of\n   AUTH_REJECTED_CRED.\n"
- title: 5.3.  RPC Data Exchange
  contents:
  - "5.3.  RPC Data Exchange\n   The data exchange phase is entered after a context\
    \ has been\n   successfully set up. The format of the data exchanged depends on\
    \ the\n   security service used for the request.  Although clients can change\n\
    \   the security service and QOP used on a per-request basis, this may\n   not\
    \ be acceptable to all RPC services; some RPC services may \"lock\"\n   the data\
    \ exchange phase into using the QOP and service used on the\n   first data exchange\
    \ message.  For all three modes of service (no data\n   integrity, data integrity,\
    \ data privacy), the RPC request header has\n   the same format.\n"
- title: 5.3.1.  RPC Request Header
  contents:
  - "5.3.1.  RPC Request Header\n   The credential has the opaque_auth structure described\
    \ earlier.  The\n   flavor field is set to RPCSEC_GSS.  The credential body is\
    \ created by\n   XDR encoding the rpc_gss_cred_t structure listed earlier into\
    \ an\n   octet stream, and then opaquely encoding this octet stream as the\n \
    \  body field.\n   Values of the fields contained in the rpc_gss_cred_t structure\
    \ are\n   set as follows.  The version field is set to same version value that\n\
    \   was used to create the context, which within the scope of this memo\n   will\
    \ always be RPCSEC_GSS_VERS_1.  The gss_proc field is set to\n   RPCSEC_GSS_DATA.\
    \  The service field is set to indicate the desired\n   service (one of rpc_gss_svc_none,\
    \ rpc_gss_svc_integrity, or\n   rpc_gss_svc_privacy).  The handle field is set\
    \ to the context handle\n   value received from the RPC server during context\
    \ creation.  The\n   seq_num field can start at any value below MAXSEQ, and must\
    \ be\n   incremented (by one or more) for successive requests.  Use of\n   sequence\
    \ numbers is described in detail when server processing of the\n   request is\
    \ discussed.\n   The verifier has the opaque_auth structure described earlier.\
    \  The\n   flavor field is set to RPCSEC_GSS.  The body field is set as follows.\n\
    \   The checksum of the RPC header (up to and including the credential)\n   is\
    \ computed using the GSS_GetMIC() call with the desired QOP.  This\n   returns\
    \ the checksum as an opaque octet stream and its length.  This\n   is encoded\
    \ into the body field.  Note that the QOP is not explicitly\n   specified anywhere\
    \ in the request.  It is implicit in the checksum or\n   encrypted data.  The\
    \ same QOP value as is used for the header\n   checksum must also be used for\
    \ the data (for checksumming or\n   encrypting), unless the service used for the\
    \ request is\n   rpc_gss_svc_none.\n"
- title: 5.3.2.  RPC Request Data
  contents:
  - '5.3.2.  RPC Request Data

    '
- title: 5.3.2.1.  RPC Request Data - No Data Integrity
  contents:
  - "5.3.2.1.  RPC Request Data - No Data Integrity\n   If the service specified is\
    \ rpc_gss_svc_none, the data (procedure\n   arguments) are not integrity or privacy\
    \ protected.  They are sent in\n   exactly the same way as they would be if the\
    \ AUTH_NONE flavor were\n   used (following the verifier).  Note, however, that\
    \ since the RPC\n   header is integrity protected, the sender will still be authenticated\n\
    \   in this case.\n"
- title: 5.3.2.2.  RPC Request Data - With Data Integrity
  contents:
  - "5.3.2.2.  RPC Request Data - With Data Integrity\n   When data integrity is used,\
    \ the request data is represented as\n   follows:\n      struct rpc_gss_integ_data\
    \ {\n          opaque databody_integ<>;\n          opaque checksum<>;\n      };\n\
    \   The databody_integ field is created as follows.  A structure\n   consisting\
    \ of a sequence number followed by the procedure arguments\n   is constructed.\
    \ This is shown below as the type rpc_gss_data_t:\n      struct rpc_gss_data_t\
    \ {\n          unsigned int seq_num;\n          proc_req_arg_t arg;\n      };\n\
    \   Here, seq_num must have the same value as in the credential.  The\n   type\
    \ proc_req_arg_t is the procedure specific XDR type describing the\n   procedure\
    \ arguments (and so is not specified here).  The octet stream\n   corresponding\
    \ to the XDR encoded rpc_gss_data_t structure and its\n   length are placed in\
    \ the databody_integ field. Note that because the\n   XDR type of databody_integ\
    \ is opaque, the XDR encoding of\n   databody_integ will include an initial four\
    \ octet length field,\n   followed by the XDR encoded octet stream of rpc_gss_data_t.\n\
    \   The checksum field represents the checksum of the XDR encoded octet\n   stream\
    \ corresponding to the XDR encoded rpc_gss_data_t structure\n   (note, this is\
    \ not the checksum of the databody_integ field).  This\n   is obtained using the\
    \ GSS_GetMIC() call, with the same QOP as was\n   used to compute the header checksum\
    \ (in the verifier). The\n   GSS_GetMIC() call returns the checksum as an opaque\
    \ octet stream and\n   its length. The checksum field of struct rpc_gss_integ_data\
    \ has an\n   XDR type of opaque. Thus the checksum length from GSS_GetMIC() is\n\
    \   encoded as a four octet  length field, followed by the checksum,\n   padded\
    \ to a multiple of four octets.\n"
- title: 5.3.2.3.  RPC Request Data - With Data Privacy
  contents:
  - "5.3.2.3.  RPC Request Data - With Data Privacy\n   When data privacy is used,\
    \ the request data is represented as\n   follows:\n      struct rpc_gss_priv_data\
    \ {\n          opaque databody_priv<>\n      };\n   The databody_priv field is\
    \ created as follows.  The rpc_gss_data_t\n   structure described earlier is constructed\
    \ again in the same way as\n   for the case of data integrity.  Next, the GSS_Wrap()\
    \ call is invoked\n   to encrypt the octet stream corresponding to the rpc_gss_data_t\n\
    \   structure, using the same value for QOP (argument qop_req to\n   GSS_Wrap())\
    \ as was used for the header checksum (in the verifier) and\n   conf_req_flag\
    \ (an argument to GSS_Wrap()) of TRUE.  The GSS_Wrap()\n   call returns an opaque\
    \ octet stream (representing the encrypted\n   rpc_gss_data_t structure) and its\
    \ length, and this is encoded as the\n   databody_priv field. Since databody_priv\
    \ has an XDR type of opaque,\n   the length returned by GSS_Wrap() is encoded\
    \ as the four octet\n   length, followed by the encrypted octet stream (padded\
    \ to a multiple\n   of four octets).\n"
- title: 5.3.3.  Server Processing of RPC Data Requests
  contents:
  - '5.3.3.  Server Processing of RPC Data Requests

    '
- title: 5.3.3.1.  Context Management
  contents:
  - "5.3.3.1.  Context Management\n   When a request is received by the server, the\
    \ following are verified\n   to be acceptable:\n   *    the version number in\
    \ the credential\n   *    the service specified in the credential\n   *    the\
    \ context handle specified in the credential\n   *    the header checksum in the\
    \ verifier (via GSS_VerifyMIC())\n   *    the sequence number (seq_num) specified\
    \ in the credential (more\n        on this follows)\n   The gss_proc field in\
    \ the credential must be set to RPCSEC_GSS_DATA\n   for data requests (otherwise,\
    \ the message will be interpreted as a\n   control message).\n   The server maintains\
    \ a window of \"seq_window\" sequence numbers,\n   starting with the last sequence\
    \ number seen and extending backwards.\n   If a sequence number higher than the\
    \ last number seen is received\n   (AND if GSS_VerifyMIC() on the header checksum\
    \ from the verifier\n   returns GSS_S_COMPLETE), the window is moved forward to\
    \ the new\n   sequence number.  If the last sequence number seen is N, the server\n\
    \   is prepared to receive requests with sequence numbers in the range N\n   through\
    \ (N - seq_window + 1), both inclusive.  If the sequence number\n   received falls\
    \ below this range, it is silently discarded.  If the\n   sequence number is within\
    \ this range, and the server has not seen it,\n   the request is accepted, and\
    \ the server turns on a bit to \"remember\"\n   that this sequence number has\
    \ been seen.  If the server determines\n   that it has already seen a sequence\
    \ number within the window, the\n   request is silently discarded. The server\
    \ should select a seq_window\n   value based on the number requests it expects\
    \ to process\n   simultaneously. For example, in a threaded implementation seq_window\n\
    \   might be equal to the number of server threads. There are no known\n   security\
    \ issues with selecting a large window. The primary issue is\n   how much space\
    \ the server is willing to allocate to keep track of\n   requests received within\
    \ the window.\n   The reason for discarding requests silently is that the server\
    \ is\n   unable to determine if the duplicate or out of range request was due\n\
    \   to a sequencing problem in the client, network, or the operating\n   system,\
    \ or due to some quirk in routing, or a replay attack by an\n   intruder.  Discarding\
    \ the request allows the client to recover after\n   timing out, if indeed the\
    \ duplication was unintentional or well\n   intended.  Note that a consequence\
    \ of the silent discard is that\n   clients may increment the seq_num by more\
    \ than one. The effect of\n   this is that the window will move forward more quickly.\
    \ It is not\n   believed that there is any benefit to doing this.\n   Note that\
    \ the sequence number algorithm requires that the client\n   increment the sequence\
    \ number even if it is retrying a request with\n   the same RPC transaction identifier.\
    \  It is not infrequent for\n   clients to get into a situation where they send\
    \ two or more attempts\n   and a slow server sends the reply for the first attempt.\
    \ With\n   RPCSEC_GSS, each request and reply will have a unique sequence\n  \
    \ number. If the client wishes to improve turn around time on the RPC\n   call,\
    \ it can cache the RPCSEC_GSS sequence number of each request it\n   sends. Then\
    \ when it receives a response with a matching RPC\n   transaction identifier,\
    \ it can compute the checksum of each sequence\n   number in the cache to try\
    \ to match the checksum in the reply's\n   verifier.\n   The data is decoded according\
    \ to the service specified in the\n   credential.  In the case of integrity or\
    \ privacy, the server ensures\n   that the QOP value is acceptable, and that it\
    \ is the same as that\n   used for the header checksum in the verifier.  Also,\
    \ in the case of\n   integrity or privacy, the server will reject the message\
    \ (with a\n   reply status of MSG_ACCEPTED, and an acceptance status of\n   GARBAGE_ARGS)\
    \ if the sequence number embedded in the request body is\n   different from the\
    \ sequence number in the credential.\n"
- title: 5.3.3.2.  Server Reply - Request Accepted
  contents:
  - "5.3.3.2.  Server Reply - Request Accepted\n   An MSG_ACCEPTED reply to a request\
    \ in the data exchange phase will\n   have the verifier's (the verf element in\
    \ the response) flavor field\n   set to RPCSEC_GSS, and the body field set to\
    \ the checksum (the output\n   of GSS_GetMIC()) of the sequence number (in network\
    \ order) of the\n   corresponding request.  The QOP used is the same as the QOP\
    \ used for\n   the corresponding request.\n   If the status of the reply is not\
    \ SUCCESS, the rest of the message is\n   formatted as usual.\n   If the status\
    \ of the message is SUCCESS, the format of the rest of\n   the message depends\
    \ on the service specified in the corresponding\n   request message. Basically,\
    \ what follows the verifier in this case\n   are the procedure results, formatted\
    \ in different ways depending on\n   the requested service.\n   If no data integrity\
    \ was requested, the procedure results are\n   formatted as for the AUTH_NONE\
    \ security flavor.\n   If data integrity was requested, the results are encoded\
    \ in exactly\n   the same way as the procedure arguments were in the corresponding\n\
    \   request.  See the section 'RPC Request Data - With Data Integrity.'\n   The\
    \ only difference is that the structure representing the\n   procedure's result\
    \ - proc_res_arg_t - must be substituted in place of\n   the request argument\
    \ structure proc_req_arg_t.  The QOP used for the\n   checksum must be the same\
    \ as that used for constructing the reply\n   verifier.\n   If data privacy was\
    \ requested, the results are encoded in exactly the\n   same way as the procedure\
    \ arguments were in the corresponding\n   request.  See the section 'RPC Request\
    \ Data - With Data Privacy.' The\n   QOP used for  encryption must be the same\
    \ as that used for\n   constructing the reply verifier.\n"
- title: 5.3.3.3.  Server Reply - Request Denied
  contents:
  - "5.3.3.3.  Server Reply - Request Denied\n   An MSG_DENIED reply (to a data request)\
    \ is formulated as usual.  Two\n   new values (RPCSEC_GSS_CREDPROBLEM and RPCSEC_GSS_CTXPROBLEM)\
    \ have\n   been defined for the auth_stat type.  When the reason for denial of\n\
    \   the request is a reject_stat of AUTH_ERROR, one of the two new\n   auth_stat\
    \ values could be returned in addition to the existing\n   values.  These two\
    \ new values have special significance from the\n   existing reasons for denial\
    \ of a request.\n   The server maintains a list of contexts for the clients that\
    \ are\n   currently in session with it.  Normally, a context is destroyed when\n\
    \   the client ends the session corresponding to it.  However, due to\n   resource\
    \ constraints, the server may destroy a context prematurely\n   (on an LRU basis,\
    \ or if the server machine is rebooted, for example).\n   In this case, when a\
    \ client request comes in, there may not be a\n   context corresponding to its\
    \ handle. The server rejects the request,\n   with the reason RPCSEC_GSS_CREDPROBLEM\
    \ in this case.  Upon receiving\n   this error, the client must refresh the context\
    \ - that is,\n   reestablish it after destroying the old one - and try the request\n\
    \   again.  This error is also returned if the context handle matches\n   that\
    \ of a different context that was allocated after the client's\n   context was\
    \ destroyed (this will be detected by a failure in\n   verifying the header checksum).\n\
    \   If the GSS_VerifyMIC() call on the header checksum (contained in the\n   verifier)\
    \ fails to return GSS_S_COMPLETE, the server rejects the\n   request and returns\
    \ an auth_stat of RPCSEC_GSS_CREDPROBLEM.\n   When the client's sequence number\
    \ exceeds the maximum the server will\n   allow, the server will reject the request\
    \ with the reason\n   RPCSEC_GSS_CTXPROBLEM.  Also, if security credentials become\
    \ stale\n   while in use (due to ticket expiry in the case of the Kerberos V5\n\
    \   mechanism, for example), the failures which result cause the\n   RPCSEC_GSS_CTXPROBLEM\
    \ reason to be returned.  In these cases also,\n   the client must refresh the\
    \ context, and retry the request.\n   For other errors, retrying will not rectify\
    \ the problem and the\n   client must not refresh the context until the problem\
    \ causing the\n   client request to be denied is rectified.\n   If the version\
    \ field in the credential does not match the version of\n   RPCSEC_GSS that was\
    \ used when the context was created, the\n   AUTH_BADCRED value is returned.\n\
    \   If there is a problem with the credential, such a bad length, illegal\n  \
    \ control procedure, or an illegal service, the appropriate auth_stat\n   status\
    \ is AUTH_BADCRED.\n   Other errors can be returned as appropriate.\n"
- title: 5.3.3.4.  Mapping of GSS-API Errors to Server Responses
  contents:
  - "5.3.3.4.  Mapping of GSS-API Errors to Server Responses\n   During the data exchange\
    \ phase, the server may invoke GSS_GetMIC(),\n   GSS_VerifyMIC(), GSS_Unwrap(),\
    \ and GSS_Wrap(). If any of these\n   routines fail to return GSS_S_COMPLETE,\
    \ then various unsuccessful\n   responses can be returned. The are described as\
    \ follows for each of\n   the aforementioned four interfaces.\n"
- title: 5.3.3.4.1.  GSS_GetMIC() Failure
  contents:
  - "5.3.3.4.1.  GSS_GetMIC() Failure\n   When GSS_GetMIC() is called to generate\
    \ the verifier in the response,\n   a failure results in an RPC response with\
    \ a reply status of\n   MSG_DENIED, reject status of AUTH_ERROR and an auth status\
    \ of\n   RPCSEC_GSS_CTXPROBLEM.\n   When GSS_GetMIC() is called to sign the call\
    \ results (service is\n   rpc_gss_svc_integrity), a failure results in no RPC\
    \ response being\n   sent. Since ONC RPC server applications will typically control\
    \ when a\n   response is sent, the failure indication will be returned to the\n\
    \   server application and it can take appropriate action (such as\n   logging\
    \ the error).\n"
- title: 5.3.3.4.2.  GSS_VerifyMIC() Failure
  contents:
  - "5.3.3.4.2.  GSS_VerifyMIC() Failure\n   When GSS_VerifyMIC() is called to verify\
    \ the verifier in request, a\n   failure results in an RPC response with a reply\
    \ status of MSG_DENIED,\n   reject status of AUTH_ERROR and an auth status of\n\
    \   RPCSEC_GSS_CREDPROBLEM.\n   When GSS_VerifyMIC() is called to verify the call\
    \ arguments (service\n   is rpc_gss_svc_integrity), a failure results in an RPC\
    \ response with\n   a reply status of MSG_ACCEPTED, and an acceptance status of\n\
    \   GARBAGE_ARGS.\n"
- title: 5.3.3.4.3.  GSS_Unwrap() Failure
  contents:
  - "5.3.3.4.3.  GSS_Unwrap() Failure\n   When GSS_Unwrap() is called to decrypt the\
    \ call arguments (service is\n   rpc_gss_svc_privacy), a failure results in an\
    \ RPC response with a\n   reply status of MSG_ACCEPTED, and an acceptance status\
    \ of\n   GARBAGE_ARGS.\n"
- title: 5.3.3.4.4.  GSS_Wrap() Failure
  contents:
  - "5.3.3.4.4.  GSS_Wrap() Failure\n   When GSS_Wrap() is called to encrypt the call\
    \ results (service is\n   rpc_gss_svc_privacy), a failure results in no RPC response\
    \ being\n   sent. Since ONC RPC server applications will typically control when\
    \ a\n   response is sent, the failure indication will be returned to the\n   application\
    \ and it can take appropriate action (such as logging the\n   error).\n"
- title: 5.4.  Context Destruction
  contents:
  - "5.4.  Context Destruction\n   When the client is done using the session, it must\
    \ send a control\n   message informing the server that it no longer requires the\
    \ context.\n   This message is formulated just like a data request packet, with\
    \ the\n   following differences:  the credential has gss_proc set to\n   RPCSEC_GSS_DESTROY,\
    \ the procedure specified in the header is\n   NULLPROC, and there are no procedure\
    \ arguments.  The sequence number\n   in the request must be valid, and the header\
    \ checksum in the verifier\n   must be valid, for the server to accept the message.\
    \  The server\n   sends a response as it would to a data request.  The client\
    \ and\n   server must then destroy the context for the session.\n   If the request\
    \ to destroy the context fails for some reason, the\n   client need not take any\
    \ special action.  The server must be prepared\n   to deal with situations where\
    \ clients never inform the server that\n   they no longer are in session and so\
    \ don't need the server to\n   maintain a context.  An LRU mechanism or an aging\
    \ mechanism should be\n   employed by the server to clean up in such cases.\n"
- title: 6.  Set of GSS-API Mechanisms
  contents:
  - "6.  Set of GSS-API Mechanisms\n   RPCSEC_GSS is effectively a \"pass-through\"\
    \ to the GSS-API layer, and\n   as such it is inappropriate for the RPCSEC_GSS\
    \ specification to\n   enumerate a minimum set of required security mechanisms\
    \ and/or\n   quality of protections.\n   If an application protocol specification\
    \ references RPCSEC_GSS, the\n   protocol specification must list a mandatory\
    \ set of { mechanism, QOP,\n   service } triples, such that an implementation\
    \ cannot claim\n   conformance to the protocol specification unless it implements\
    \ the\n   set of triples. Within each triple, mechanism is a GSS-API security\n\
    \   mechanism, QOP is a valid quality-of-protection within the mechanism,\n  \
    \ and service is either rpc_gss_svc_integrity or rpc_gss_svc_privacy.\n   For\
    \ example, a network filing protocol built on RPC that depends on\n   RPCSEC_GSS\
    \ for security, might require that Kerberos V5 with the\n   default QOP using\
    \ the rpc_gss_svc_integrity service be supported by\n   implementations conforming\
    \ to the network filing protocol\n   specification.\n"
- title: 7.  Security Considerations
  contents:
  - '7.  Security Considerations

    '
- title: 7.1.  Privacy of Call Header
  contents:
  - "7.1.  Privacy of Call Header\n   The reader will note that for the privacy option,\
    \ only the call\n   arguments and results are encrypted. Information about the\n\
    \   application in the form of RPC program number, program version\n   number,\
    \ and program procedure number is transmitted in the clear.\n   Encrypting these\
    \ fields in the RPC call header would have changed the\n   size and format of\
    \ the call header. This would have required revising\n   the RPC protocol which\
    \ was beyond the scope of this proposal. Storing\n   the encrypted numbers in\
    \ the credential would have obviated a\n   protocol change, but would have introduced\
    \ more overloading of fields\n   and would have made implementations of RPC more\
    \ complex. Even if the\n   fields were encrypted somehow, in most cases an attacker\
    \ can\n   determine the program number and version number by examining the\n \
    \  destination address of the request and querying the rpcbind service\n   on\
    \ the destination host [Srinivasan-bind].  In any case, even by not\n   encrypting\
    \ the three numbers, RPCSEC_GSS still improves the state of\n   security over\
    \ what existing RPC services have had available\n   previously. Implementors of\
    \ new RPC services that are concerned about\n   this risk may opt to design in\
    \ a \"sub-procedure\" field that is\n   included in the service specific call\
    \ arguments.\n"
- title: 7.2.  Sequence Number Attacks
  contents:
  - '7.2.  Sequence Number Attacks

    '
- title: 7.2.1.  Sequence Numbers Above the Window
  contents:
  - "7.2.1.  Sequence Numbers Above the Window\n   An attacker cannot coax the server\
    \ into raising the sequence number\n   beyond the range the legitimate client\
    \ is aware of (and thus engineer\n   a denial of server attack) without constructing\
    \ an RPC request that\n   will pass the header checksum. If the cost of verifying\
    \ the header\n   checksum is sufficiently large (depending on the speed of the\n\
    \   processor doing the checksum and the cost of checksum algorithm), it\n   is\
    \ possible to envision a denial of service attack (vandalism, in the\n   form\
    \ of wasting processing resources) whereby the attacker sends\n   requests that\
    \ are above the window. The simplest method might be for\n   the attacker to monitor\
    \ the network traffic and then choose a\n   sequence number that is far above\
    \ the current sequence number. Then\n   the attacker can send bogus requests using\
    \ the above window sequence\n   number.\n"
- title: 7.2.2.  Sequence Numbers Within or Below the Window
  contents:
  - "7.2.2.  Sequence Numbers Within or Below the Window\n   If the attacker sends\
    \ requests that are within or below the window,\n   then even if the header checksum\
    \ is successfully verified, the server\n   will silently discard the requests\
    \ because the server assumes it has\n   already processed the request. In this\
    \ case, a server can optimize by\n   skipping the header checksum verification\
    \ if the sequence number is\n   below the window, or if it is within the window,\
    \ not attempt the\n   checksum verification if the sequence number has already\
    \ been seen.\n"
- title: 7.3.  Message Stealing Attacks
  contents:
  - "7.3.  Message Stealing Attacks\n   This proposal does not address attacks where\
    \ an attacker can block or\n   steal messages without being detected by the server.\
    \ To implement\n   such protection would be tantamount to assuming a state in\
    \ the RPC\n   service. RPCSEC_GSS does not worsen this situation.\n"
- title: Appendix A. GSS-API Major Status Codes
  contents:
  - "Appendix A. GSS-API Major Status Codes\n   The GSS-API definition [Linn] does\
    \ not include numerical values for\n   the various GSS-API major status codes.\
    \ It is expected that this will\n   be addressed in future RFC. Until then, this\
    \ appendix defines the\n   values for each GSS-API major status code listed in\
    \ the GSS-API\n   definition.  If in the future, the GSS-API definition defines\
    \ values\n   for the codes that are different than what follows, then implementors\n\
    \   of RPCSEC_GSS will be obliged to map them into the values defined\n   below.\
    \ If in the future, the GSS-API definition defines additional\n   status codes\
    \ not defined below, then the RPCSEC_GSS definition will\n   subsume those additional\
    \ values.\n   Here are the definitions of each GSS_S_* major status that the\n\
    \   implementor of RPCSEC_GSS can expect in the gss_major major field of\n   rpc_gss_init_res.\
    \  These definitions are not in RPC description\n   language form.  The numbers\
    \ are in base 16 (hexadecimal):\n      GSS_S_COMPLETE                  0x00000000\n\
    \      GSS_S_CONTINUE_NEEDED           0x00000001\n      GSS_S_DUPLICATE_TOKEN\
    \           0x00000002\n      GSS_S_OLD_TOKEN                 0x00000004\n   \
    \   GSS_S_UNSEQ_TOKEN               0x00000008\n      GSS_S_GAP_TOKEN        \
    \         0x00000010\n      GSS_S_BAD_MECH                  0x00010000\n     \
    \ GSS_S_BAD_NAME                  0x00020000\n      GSS_S_BAD_NAMETYPE       \
    \       0x00030000\n      GSS_S_BAD_BINDINGS              0x00040000\n      GSS_S_BAD_STATUS\
    \                0x00050000\n      GSS_S_BAD_MIC                   0x00060000\n\
    \      GSS_S_BAD_SIG                   0x00060000\n      GSS_S_NO_CRED       \
    \            0x00070000\n      GSS_S_NO_CONTEXT                0x00080000\n  \
    \    GSS_S_DEFECTIVE_TOKEN           0x00090000\n      GSS_S_DEFECTIVE_CREDENTIAL\
    \      0x000a0000\n      GSS_S_CREDENTIALS_EXPIRED       0x000b0000\n      GSS_S_CONTEXT_EXPIRED\
    \           0x000c0000\n      GSS_S_FAILURE                   0x000d0000\n   \
    \   GSS_S_BAD_QOP                   0x000e0000\n      GSS_S_UNAUTHORIZED     \
    \         0x000f0000\n      GSS_S_UNAVAILABLE               0x00100000\n     \
    \ GSS_S_DUPLICATE_ELEMENT         0x00110000\n      GSS_S_NAME_NOT_MN        \
    \       0x00120000\n      GSS_S_CALL_INACCESSIBLE_READ    0x01000000\n      GSS_S_CALL_INACCESSIBLE_WRITE\
    \   0x02000000\n      GSS_S_CALL_BAD_STRUCTURE        0x03000000\n   Note that\
    \ the GSS-API major status is split into three fields as\n   follows:\n      \
    \  Most Significant Bit                     Least Significant Bit\n        |------------------------------------------------------------|\n\
    \        | Calling Error | Routine Error  |    Supplementary Info     |\n    \
    \    |------------------------------------------------------------|\n      Bit\
    \ 31           24 23            16 15                        0\n   Up to one status\
    \ in the Calling Error field can be logically ORed\n   with up to one status in\
    \ the Routine Error field which in turn can be\n   logically ORed with zero or\
    \ more statuses in the Supplementary Info\n   field. If the resulting major status\
    \ has a non-zero Calling Error\n   and/or a non-zero Routine Error, then the applicable\
    \ GSS-API\n   operation has failed.  For purposes of RPCSEC_GSS, this means that\n\
    \   the GSS_Accept_sec_context() call executed by the server has failed.\n   If\
    \ the major status is equal GSS_S_COMPLETE, then this indicates the\n   absence\
    \ of any Errors or Supplementary Info.\n   The meanings of most of the GSS_S_*\
    \ status are defined in the GSS-API\n   definition, which the exceptions of:\n\
    \   GSS_S_BAD_MIC       This code has the same meaning as GSS_S_BAD_SIG.\n   GSS_S_CALL_INACCESSIBLE_READ\n\
    \                        A required input parameter could not be read.\n   GSS_S_CALL_INACCESSIBLE_WRITE\n\
    \                        A required input parameter could not be written.\n  \
    \ GSS_S_CALL_BAD_STRUCTURE\n                       A parameter was malformed.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Much of the protocol was based on the AUTH_GSSAPI security\
    \ flavor\n   developed by Open Vision Technologies [Jaspan].  In particular, we\n\
    \   acknowledge Barry Jaspan, Marc Horowitz, John Linn, and Ellen\n   McDermott.\n\
    \   Raj Srinivasan designed RPCSEC_GSS [Eisler] with input from Mike\n   Eisler.\
    \  Raj, Roland Schemers, Lin Ling, and Alex Chiu contributed to\n   Sun Microsystems'\
    \ implementation of RPCSEC_GSS.\n   Brent Callaghan, Marc Horowitz, Barry Jaspan,\
    \ John Linn, Hilarie\n   Orman, Martin Rex, Ted Ts'o, and John Wroclawski analyzed\
    \ the\n   specification and gave valuable feedback.\n   Steve Nahm and Kathy Slattery\
    \ reviewed various drafts of this\n   specification.\n   Much of content of Appendix\
    \ A was excerpted from John Wray's Work in\n   Progress on GSS-API Version 2 C-bindings.\n"
- title: References
  contents:
  - "References\n   [Eisler]            Eisler, M., Schemers, R., and Srinivasan,\
    \ R.\n                       (1996).  \"Security Mechanism Independence in ONC\n\
    \                       RPC,\" Proceedings of the Sixth Annual USENIX\n      \
    \                 Security Symposium, pp. 51-65.\n   [Jaspan]            Jaspan,\
    \ B. (1995). \"GSS-API Security for ONC\n                       RPC,\" `95 Proceedings\
    \ of The Internet Society\n                       Symposium on Network and Distributed\
    \ System\n                       Security, pp. 144- 151.\n   [Linn]          \
    \    Linn, J., \"Generic Security Service Application\n                      \
    \ Program Interface, Version 2\", RFC 2078, January\n                       1997.\n\
    \   [Srinivasan-bind]   Srinivasan, R., \"Binding Protocols for\n            \
    \           ONC RPC Version 2\", RFC 1833, August 1995.\n   [Srinivasan-rpc] \
    \   Srinivasan, R., \"RPC: Remote Procedure Call\n                       Protocol\
    \ Specification Version 2\", RFC 1831,\n                       August 1995.\n\
    \   [Srinivasan-xdr]    Srinivasan, R., \"XDR: External Data\n               \
    \        Representation Standard\", RFC 1832, August 1995.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Michael Eisler\n   Sun Microsystems, Inc.\n   M/S UCOS03\n\
    \   2550 Garcia Avenue\n   Mountain View, CA 94043\n   Phone: +1 (719) 599-9026\n\
    \   EMail: mre@eng.sun.com\n   Alex Chiu\n   Sun Microsystems, Inc.\n   M/S UMPK17-203\n\
    \   2550 Garcia Avenue\n   Mountain View, CA 94043\n   Phone: +1 (415) 786-6465\n\
    \   EMail: hacker@eng.sun.com\n   Lin Ling\n   Sun Microsystems, Inc.\n   M/S\
    \ UMPK17-201\n   2550 Garcia Avenue\n   Mountain View, CA 94043\n   Phone: +1\
    \ (415) 786-5084\n   EMail: lling@eng.sun.com\n"
