- title: __initial_text__
  contents:
  - " Traversal Using Relays around NAT (TURN): Relay Extensions to Session\n    \
    \               Traversal Utilities for NAT (STUN)\n"
- title: Abstract
  contents:
  - "Abstract\n   If a host is located behind a NAT, it can be impossible for that\
    \ host\n   to communicate directly with other hosts (peers) in certain\n   situations.\
    \  In these situations, it is necessary for the host to use\n   the services of\
    \ an intermediate node that acts as a communication\n   relay.  This specification\
    \ defines a protocol, called \"Traversal\n   Using Relays around NAT\" (TURN),\
    \ that allows the host to control the\n   operation of the relay and to exchange\
    \ packets with its peers using\n   the relay.  TURN differs from other relay control\
    \ protocols in that\n   it allows a client to communicate with multiple peers\
    \ using a single\n   relay address.\n   The TURN protocol was designed to be used\
    \ as part of the Interactive\n   Connectivity Establishment (ICE) approach to\
    \ NAT traversal, though it\n   can also be used without ICE.\n   This document\
    \ obsoletes RFCs 5766 and 6156.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8656.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n   2.  Terminology\n   3.  Overview of\
    \ Operation\n     3.1.  Transports\n     3.2.  Allocations\n     3.3.  Permissions\n\
    \     3.4.  Send Mechanism\n     3.5.  Channels\n     3.6.  Unprivileged TURN\
    \ Servers\n     3.7.  Avoiding IP Fragmentation\n     3.8.  RTP Support\n    \
    \ 3.9.  Happy Eyeballs for TURN\n   4.  Discovery of TURN Server\n     4.1.  TURN\
    \ URI Scheme Semantics\n   5.  General Behavior\n   6.  Allocations\n   7.  Creating\
    \ an Allocation\n     7.1.  Sending an Allocate Request\n     7.2.  Receiving\
    \ an Allocate Request\n     7.3.  Receiving an Allocate Success Response\n   \
    \  7.4.  Receiving an Allocate Error Response\n   8.  Refreshing an Allocation\n\
    \     8.1.  Sending a Refresh Request\n     8.2.  Receiving a Refresh Request\n\
    \     8.3.  Receiving a Refresh Response\n   9.  Permissions\n   10. CreatePermission\n\
    \     10.1.  Forming a CreatePermission Request\n     10.2.  Receiving a CreatePermission\
    \ Request\n     10.3.  Receiving a CreatePermission Response\n   11. Send and\
    \ Data Methods\n     11.1.  Forming a Send Indication\n     11.2.  Receiving a\
    \ Send Indication\n     11.3.  Receiving a UDP Datagram\n     11.4.  Receiving\
    \ a Data Indication\n     11.5.  Receiving an ICMP Packet\n     11.6.  Receiving\
    \ a Data Indication with an ICMP Attribute\n   12. Channels\n     12.1.  Sending\
    \ a ChannelBind Request\n     12.2.  Receiving a ChannelBind Request\n     12.3.\
    \  Receiving a ChannelBind Response\n     12.4.  The ChannelData Message\n   \
    \  12.5.  Sending a ChannelData Message\n     12.6.  Receiving a ChannelData Message\n\
    \     12.7.  Relaying Data from the Peer\n   13. Packet Translations\n     13.1.\
    \  IPv4-to-IPv6 Translations\n     13.2.  IPv6-to-IPv6 Translations\n     13.3.\
    \  IPv6-to-IPv4 Translations\n   14. UDP-to-UDP Relay\n   15. TCP-to-UDP Relay\n\
    \   16. UDP-to-TCP Relay\n   17. STUN Methods\n   18. STUN Attributes\n     18.1.\
    \  CHANNEL-NUMBER\n     18.2.  LIFETIME\n     18.3.  XOR-PEER-ADDRESS\n     18.4.\
    \  DATA\n     18.5.  XOR-RELAYED-ADDRESS\n     18.6.  REQUESTED-ADDRESS-FAMILY\n\
    \     18.7.  EVEN-PORT\n     18.8.  REQUESTED-TRANSPORT\n     18.9.  DONT-FRAGMENT\n\
    \     18.10. RESERVATION-TOKEN\n     18.11. ADDITIONAL-ADDRESS-FAMILY\n     18.12.\
    \ ADDRESS-ERROR-CODE\n     18.13. ICMP\n   19. STUN Error Response Codes\n   20.\
    \ Detailed Example\n   21. Security Considerations\n     21.1.  Outsider Attacks\n\
    \       21.1.1.  Obtaining Unauthorized Allocations\n       21.1.2.  Offline Dictionary\
    \ Attacks\n       21.1.3.  Faked Refreshes and Permissions\n       21.1.4.  Fake\
    \ Data\n       21.1.5.  Impersonating a Server\n       21.1.6.  Eavesdropping\
    \ Traffic\n       21.1.7.  TURN Loop Attack\n     21.2.  Firewall Considerations\n\
    \       21.2.1.  Faked Permissions\n       21.2.2.  Blacklisted IP Addresses\n\
    \       21.2.3.  Running Servers on Well-Known Ports\n     21.3.  Insider Attacks\n\
    \       21.3.1.  DoS against TURN Server\n       21.3.2.  Anonymous Relaying of\
    \ Malicious Traffic\n       21.3.3.  Manipulating Other Allocations\n     21.4.\
    \  Tunnel Amplification Attack\n     21.5.  Other Considerations\n   22. IANA\
    \ Considerations\n   23. IAB Considerations\n   24. Changes since RFC 5766\n \
    \  25. Updates to RFC 6156\n   26. References\n     26.1.  Normative References\n\
    \     26.2.  Informative References\n   Acknowledgements\n   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   A host behind a NAT may wish to exchange packets with other\
    \ hosts,\n   some of which may also be behind NATs.  To do this, the hosts\n \
    \  involved can use \"hole punching\" techniques (see [RFC5128]) in an\n   attempt\
    \ to discover a direct communication path; that is, a\n   communication path that\
    \ goes from one host to another through\n   intervening NATs and routers but does\
    \ not traverse any relays.\n   As described in [RFC5128] and [RFC4787], hole punching\
    \ techniques\n   will fail if both hosts are behind NATs that are not well behaved.\n\
    \   For example, if both hosts are behind NATs that have a mapping\n   behavior\
    \ of \"address-dependent mapping\" or \"address- and port-\n   dependent mapping\"\
    \ (see Section 4.1 of [RFC4787]), then hole punching\n   techniques generally\
    \ fail.\n   When a direct communication path cannot be found, it is necessary\
    \ to\n   use the services of an intermediate host that acts as a relay for the\n\
    \   packets.  This relay typically sits in the public Internet and relays\n  \
    \ packets between two hosts that both sit behind NATs.\n   In many enterprise\
    \ networks, direct UDP transmissions are not\n   permitted between clients on\
    \ the internal networks and external IP\n   addresses.  To permit media sessions\
    \ in such a situation to use UDP\n   and avoid forcing them through TCP, an Enterprise\
    \ Firewall can be\n   configured to allow UDP traffic relayed through an Enterprise\
    \ relay\n   server.  WebRTC requires support for this scenario (see\n   Section\
    \ 2.3.5.1 of [RFC7478]).  Some users of SIP or WebRTC want IP\n   location privacy\
    \ from the remote peer.  In this scenario, the client\n   can select a relay server\
    \ offering IP location privacy and only\n   convey the relayed candidates to the\
    \ peer for ICE connectivity checks\n   (see Section 4.2.4 of [SEC-WEBRTC]).\n\
    \   This specification defines a protocol, called \"TURN\", that allows a\n  \
    \ host behind a NAT (called the \"TURN client\") to request that another\n   host\
    \ (called the \"TURN server\") act as a relay.  The client can\n   arrange for\
    \ the server to relay packets to and from certain other\n   hosts (called \"peers\"\
    ), and the client can control aspects of how the\n   relaying is done.  The client\
    \ does this by obtaining an IP address\n   and port on the server, called the\
    \ \"relayed transport address\".  When\n   a peer sends a packet to the relayed\
    \ transport address, the server\n   relays the transport protocol data from the\
    \ packet to the client.\n   The data encapsulated within a message header that\
    \ allows the client\n   to know the peer from which the transport protocol data\
    \ was relayed\n   by the server.  If the server receives an ICMP error packet,\
    \ the\n   server also relays certain Layer 3 and 4 header fields from the ICMP\n\
    \   header to the client.  When the client sends a message to the server,\n  \
    \ the server identifies the remote peer from the message header and\n   relays\
    \ the message data to the intended peer.\n   A client using TURN must have some\
    \ way to communicate the relayed\n   transport address to its peers and to learn\
    \ each peer's IP address\n   and port (more precisely, each peer's server-reflexive\
    \ transport\n   address; see Section 3).  How this is done is out of the scope\
    \ of the\n   TURN protocol.  One way this might be done is for the client and\n\
    \   peers to exchange email messages.  Another way is for the client and\n   its\
    \ peers to use a special-purpose \"introduction\" or \"rendezvous\"\n   protocol\
    \ (see [RFC5128] for more details).\n   If TURN is used with ICE [RFC8445], then\
    \ the relayed transport\n   address and the IP addresses and ports of the peers\
    \ are included in\n   the ICE candidate information that the rendezvous protocol\
    \ must\n   carry.  For example, if TURN and ICE are used as part of a multimedia\n\
    \   solution using SIP [RFC3261], then SIP serves the role of the\n   rendezvous\
    \ protocol, carrying the ICE candidate information inside\n   the body of SIP\
    \ messages [SDP-ICE].  If TURN and ICE are used with\n   some other rendezvous\
    \ protocol, then ICE provides guidance on the\n   services the rendezvous protocol\
    \ must perform.\n   Though the use of a TURN server to enable communication between\
    \ two\n   hosts behind NATs is very likely to work, it comes at a high cost to\n\
    \   the provider of the TURN server since the server typically needs a\n   high-bandwidth\
    \ connection to the Internet.  As a consequence, it is\n   best to use a TURN\
    \ server only when a direct communication path\n   cannot be found.  When the\
    \ client and a peer use ICE to determine the\n   communication path, ICE will\
    \ use hole punching techniques to search\n   for a direct path first and only\
    \ use a TURN server when a direct path\n   cannot be found.\n   TURN was originally\
    \ invented to support multimedia sessions signaled\n   using SIP.  Since SIP supports\
    \ forking, TURN supports multiple peers\n   per relayed transport address; a feature\
    \ not supported by other\n   approaches (e.g., SOCKS [RFC1928]).  However, care\
    \ has been taken to\n   make sure that TURN is suitable for other types of applications.\n\
    \   TURN was designed as one piece in the larger ICE approach to NAT\n   traversal.\
    \  Implementors of TURN are urged to investigate ICE and\n   seriously consider\
    \ using it for their application.  However, it is\n   possible to use TURN without\
    \ ICE.\n   TURN is an extension to the Session Traversal Utilities for NAT\n \
    \  (STUN) protocol [RFC8489].  Most, though not all, TURN messages are\n   STUN-formatted\
    \ messages.  A reader of this document should be\n   familiar with STUN.\n   The\
    \ TURN specification was originally published as [RFC5766], which\n   was updated\
    \ by [RFC6156] to add IPv6 support.  This document\n   supersedes and obsoletes\
    \ both [RFC5766] and [RFC6156].\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n\
    \   capitals, as shown here.\n   Readers are expected to be familiar with [RFC8489]\
    \ and the terms\n   defined there.\n   The following terms are used in this document:\n\
    \   TURN:\n      The protocol spoken between a TURN client and a TURN server.\
    \  It\n      is an extension to the STUN protocol [RFC8489].  The protocol\n \
    \     allows a client to allocate and use a relayed transport address.\n   TURN\
    \ client:\n      A STUN client that implements this specification.\n   TURN server:\n\
    \      A STUN server that implements this specification.  It relays data\n   \
    \   between a TURN client and its peer(s).\n   Peer:\n      A host with which\
    \ the TURN client wishes to communicate.  The TURN\n      server relays traffic\
    \ between the TURN client and its peer(s).\n      The peer does not interact with\
    \ the TURN server using the protocol\n      defined in this document; rather,\
    \ the peer receives data sent by\n      the TURN server, and the peer sends data\
    \ towards the TURN server.\n   Transport Address:\n      The combination of an\
    \ IP address and a port.\n   Host Transport Address:\n      A transport address\
    \ on a client or a peer.\n   Server-Reflexive Transport Address:\n      A transport\
    \ address on the \"external side\" of a NAT.  This address\n      is allocated\
    \ by the NAT to correspond to a specific host transport\n      address.\n   Relayed\
    \ Transport Address:\n      A transport address on the TURN server that is used\
    \ for relaying\n      packets between the client and a peer.  A peer sends to\
    \ this\n      address on the TURN server, and the packet is then relayed to the\n\
    \      client.\n   TURN Server Transport Address:\n      A transport address on\
    \ the TURN server that is used for sending\n      TURN messages to the server.\
    \  This is the transport address that\n      the client uses to communicate with\
    \ the server.\n   Peer Transport Address:\n      The transport address of the\
    \ peer as seen by the server.  When the\n      peer is behind a NAT, this is the\
    \ peer's server-reflexive\n      transport address.\n   Allocation:\n      The\
    \ relayed transport address granted to a client through an\n      Allocate request,\
    \ along with related state, such as permissions\n      and expiration timers.\n\
    \   5-tuple:\n      The combination (client IP address and port, server IP address\
    \ and\n      port, and transport protocol (currently one of UDP, TCP, DTLS/UDP,\n\
    \      or TLS/TCP)) used to communicate between the client and the\n      server.\
    \  The 5-tuple uniquely identifies this communication\n      stream.  The 5-tuple\
    \ also uniquely identifies the Allocation on\n      the server.\n   Transport\
    \ Protocol:\n      The protocol above IP that carries TURN Requests, Responses,\
    \ and\n      Indications as well as providing identifiable flows using a\n   \
    \   5-tuple.  In this specification, UDP and TCP are defined as\n      transport\
    \ protocols; this document also describes the use of UDP\n      and TCP in combination\
    \ with a security layer using DTLS and TLS,\n      respectively.\n   Channel:\n\
    \      A channel number and associated peer transport address.  Once a\n     \
    \ channel number is bound to a peer's transport address, the client\n      and\
    \ server can use the more bandwidth-efficient ChannelData\n      message to exchange\
    \ data.\n   Permission:\n      The IP address and transport protocol (but not\
    \ the port) of a peer\n      that is permitted to send traffic to the TURN server\
    \ and have that\n      traffic relayed to the TURN client.  The TURN server will\
    \ only\n      forward traffic to its client from peers that match an existing\n\
    \      permission.\n   Realm:\n      A string used to describe the server or a\
    \ context within the\n      server.  The realm tells the client which username\
    \ and password\n      combination to use to authenticate requests.\n   Nonce:\n\
    \      A string chosen at random by the server and included in the server\n  \
    \    response.  To prevent replay attacks, the server should change the\n    \
    \  nonce regularly.\n   (D)TLS:\n      This term is used for statements that apply\
    \ to both Transport\n      Layer Security [RFC8446] and Datagram Transport Layer\
    \ Security\n      [RFC6347].\n"
- title: 3.  Overview of Operation
  contents:
  - "3.  Overview of Operation\n   This section gives an overview of the operation\
    \ of TURN.  It is non-\n   normative.\n   In a typical configuration, a TURN client\
    \ is connected to a private\n   network [RFC1918] and, through one or more NATs,\
    \ to the public\n   Internet.  On the public Internet is a TURN server.  Elsewhere\
    \ in the\n   Internet are one or more peers with which the TURN client wishes\
    \ to\n   communicate.  These peers may or may not be behind one or more NATs.\n\
    \   The client uses the server as a relay to send packets to these peers\n   and\
    \ to receive packets from these peers.\n                         TURN        \
    \      |            / ^|  Peer A |\n      Client's           Server          \
    \  |           /  ||         |\n      Host Transport     Transport         | \
    \        //   ||         |\n      Address            Address           |     \
    \  //     |+---------+\n   198.51.100.2:49721  192.0.2.15:3478     |+-+  //  \
    \   Peer A\n   |         ||   |N|      ||         | //               |       \
    \  |\n   | TURN    |v   | |      v| TURN    |/                 |         |\n \
    \  | Client  |----|A|-------| Server  |------------------|  Peer B |\n   |   \
    \      |    |T||      |         ||                ||         |\n            Client's\
    \                   |             Peer B\n            Server-Reflexive     Relayed\
    \             Transport\n            Transport Address    Transport Address  \
    \ Address\n            192.0.2.1:7000       192.0.2.15:50000    192.0.2.210:49191\n\
    \   Figure 1 shows a typical deployment.  In this figure, the TURN client\n  \
    \ and the TURN server are separated by a NAT, with the client on the\n   private\
    \ side and the server on the public side of the NAT.  This NAT\n   is assumed\
    \ to be a \"bad\" NAT; for example, it might have a mapping\n   property of \"\
    address-and-port-dependent mapping\" (see [RFC4787]).\n   The client talks to\
    \ the server from a (IP address, port) combination\n   called the client's \"\
    host transport address\".  (The combination of an\n   IP address and port is called\
    \ a \"transport address\".)\n   The client sends TURN messages from its host transport\
    \ address to a\n   transport address on the TURN server that is known as the \"\
    TURN\n   server transport address\".  The client learns the TURN server\n   transport\
    \ address through some unspecified means (e.g.,\n   configuration), and this address\
    \ is typically used by many clients\n   simultaneously.\n   Since the client is\
    \ behind a NAT, the server sees packets from the\n   client as coming from a transport\
    \ address on the NAT itself.  This\n   address is known as the client's \"server-reflexive\
    \ transport\n   address\"; packets sent by the server to the client's server-reflexive\n\
    \   transport address will be forwarded by the NAT to the client's host\n   transport\
    \ address.\n   The client uses TURN commands to create and manipulate an ALLOCATION\n\
    \   on the server.  An allocation is a data structure on the server.\n   This\
    \ data structure contains, amongst other things, the relayed\n   transport address\
    \ for the allocation.  The relayed transport address\n   is the transport address\
    \ on the server that peers can use to have the\n   server relay data to the client.\
    \  An allocation is uniquely\n   identified by its relayed transport address.\n\
    \   Once an allocation is created, the client can send application data\n   to\
    \ the server along with an indication of to which peer the data is\n   to be sent,\
    \ and the server will relay this data to the intended peer.\n   The client sends\
    \ the application data to the server inside a TURN\n   message; at the server,\
    \ the data is extracted from the TURN message\n   and sent to the peer in a UDP\
    \ datagram.  In the reverse direction, a\n   peer can send application data in\
    \ a UDP datagram to the relayed\n   transport address for the allocation; the\
    \ server will then\n   encapsulate this data inside a TURN message and send it\
    \ to the client\n   along with an indication of which peer sent the data.  Since\
    \ the TURN\n   message always contains an indication of which peer the client\
    \ is\n   communicating with, the client can use a single allocation to\n   communicate\
    \ with multiple peers.\n   When the peer is behind a NAT, the client must identify\
    \ the peer\n   using its server-reflexive transport address rather than its host\n\
    \   transport address.  For example, to send application data to Peer A\n   in\
    \ the example above, the client must specify 192.0.2.150:32102 (Peer\n   A's server-reflexive\
    \ transport address) rather than 203.0.113.2:49582\n   (Peer A's host transport\
    \ address).\n   Each allocation on the server belongs to a single client and has\n\
    \   either one or two relayed transport addresses that are used only by\n   that\
    \ allocation.  Thus, when a packet arrives at a relayed transport\n   address\
    \ on the server, the server knows for which client the data is\n   intended.\n\
    \   The client may have multiple allocations on a server at the same\n   time.\n"
- title: 3.1.  Transports
  contents:
  - "3.1.  Transports\n   TURN, as defined in this specification, always uses UDP\
    \ between the\n   server and the peer.  However, this specification allows the\
    \ use of\n   any one of UDP, TCP, Transport Layer Security (TLS) over TCP, or\n\
    \   Datagram Transport Layer Security (DTLS) over UDP to carry the TURN\n   messages\
    \ between the client and the server.\n           | TURN client to TURN server\
    \ | TURN server to peer |\n           |            UDP             |         UDP\
    \         |\n           |            TCP             |         UDP         |\n\
    \           |        TLS-over-TCP        |         UDP         |\n           |\
    \       DTLS-over-UDP        |         UDP         |\n   If TCP or TLS-over-TCP\
    \ is used between the client and the server,\n   then the server will convert\
    \ between these transports and UDP\n   transport when relaying data to/from the\
    \ peer.\n   Since this version of TURN only supports UDP between the server and\n\
    \   the peer, it is expected that most clients will prefer to use UDP\n   between\
    \ the client and the server as well.  That being the case, some\n   readers may\
    \ wonder: Why also support TCP and TLS-over-TCP?\n   TURN supports TCP transport\
    \ between the client and the server because\n   some firewalls are configured\
    \ to block UDP entirely.  These firewalls\n   block UDP but not TCP, in part because\
    \ TCP has properties that make\n   the intention of the nodes being protected\
    \ by the firewall more\n   obvious to the firewall.  For example, TCP has a three-way\
    \ handshake\n   that makes it clearer that the protected node really wishes to\
    \ have\n   that particular connection established, while for UDP, the best the\n\
    \   firewall can do is guess which flows are desired by using filtering\n   rules.\
    \  Also, TCP has explicit connection teardown; while for UDP,\n   the firewall\
    \ has to use timers to guess when the flow is finished.\n   TURN supports TLS-over-TCP\
    \ transport and DTLS-over-UDP transport\n   between the client and the server\
    \ because (D)TLS provides additional\n   security properties not provided by TURN's\
    \ default digest\n   authentication, properties that some clients may wish to\
    \ take\n   advantage of.  In particular, (D)TLS provides a way for the client\
    \ to\n   ascertain that it is talking to the correct server and provides for\n\
    \   confidentiality of TURN control messages.  If (D)TLS transport is\n   used\
    \ between the TURN client and the TURN server, refer to\n   Section 6.2.3 of [RFC8489]\
    \ for more information about cipher suites,\n   server certificate validation,\
    \ and authentication of TURN servers.\n   The guidance given in [RFC7525] MUST\
    \ be followed to avoid attacks on\n   (D)TLS.  TURN does not require (D)TLS because\
    \ the overhead of using\n   (D)TLS is higher than that of digest authentication;\
    \ for example,\n   using (D)TLS likely means that most application data will be\
    \ doubly\n   encrypted (once by (D)TLS and once to ensure it is still encrypted\
    \ in\n   the UDP datagram).\n   There is an extension to TURN for TCP transport\
    \ between the server\n   and the peers [RFC6062].  For this reason, allocations\
    \ that use UDP\n   between the server and the peers are known as \"UDP allocations\"\
    ,\n   while allocations that use TCP between the server and the peers are\n  \
    \ known as \"TCP allocations\".  This specification describes only UDP\n   allocations.\n\
    \   In some applications for TURN, the client may send and receive\n   packets\
    \ other than TURN packets on the host transport address it uses\n   to communicate\
    \ with the server.  This can happen, for example, when\n   using TURN with ICE.\
    \  In these cases, the client can distinguish TURN\n   packets from other packets\
    \ by examining the source address of the\n   arriving packet; those arriving from\
    \ the TURN server will be TURN\n   packets.  The algorithm of demultiplexing packets\
    \ received from\n   multiple protocols on the host transport address is discussed\
    \ in\n   [RFC7983].\n"
- title: 3.2.  Allocations
  contents:
  - "3.2.  Allocations\n   To create an allocation on the server, the client uses\
    \ an Allocate\n   transaction.  The client sends an Allocate request to the server,\
    \ and\n   the server replies with an Allocate success response containing the\n\
    \   allocated relayed transport address.  The client can include\n   attributes\
    \ in the Allocate request that describe the type of\n   allocation it desires\
    \ (e.g., the lifetime of the allocation).  Since\n   relaying data has security\
    \ implications, the server requires that the\n   client authenticate itself, typically\
    \ using STUN's long-term\n   credential mechanism or the STUN Extension for Third-Party\n\
    \   Authorization [RFC7635], to show that it is authorized to use the\n   server.\n\
    \   Once a relayed transport address is allocated, a client must keep the\n  \
    \ allocation alive.  To do this, the client periodically sends a\n   Refresh request\
    \ to the server.  TURN deliberately uses a different\n   method (Refresh rather\
    \ than Allocate) for refreshes to ensure that\n   the client is informed if the\
    \ allocation vanishes for some reason.\n   The frequency of the Refresh transaction\
    \ is determined by the\n   lifetime of the allocation.  The default lifetime of\
    \ an allocation is\n   10 minutes; this value was chosen to be long enough so\
    \ that\n   refreshing is not typically a burden on the client while expiring\n\
    \   allocations where the client has unexpectedly quit in a timely\n   manner.\
    \  However, the client can request a longer lifetime in the\n   Allocate request\
    \ and may modify its request in a Refresh request, and\n   the server always indicates\
    \ the actual lifetime in the response.  The\n   client must issue a new Refresh\
    \ transaction within \"lifetime\" seconds\n   of the previous Allocate or Refresh\
    \ transaction.  Once a client no\n   longer wishes to use an allocation, it should\
    \ delete the allocation\n   using a Refresh request with a requested lifetime\
    \ of zero.\n   Both the server and client keep track of a value known as the\n\
    \   \"5-tuple\".  At the client, the 5-tuple consists of the client's host\n \
    \  transport address, the server transport address, and the transport\n   protocol\
    \ used by the client to communicate with the server.  At the\n   server, the 5-tuple\
    \ value is the same except that the client's host\n   transport address is replaced\
    \ by the client's server-reflexive\n   address since that is the client's address\
    \ as seen by the server.\n   Both the client and the server remember the 5-tuple\
    \ used in the\n   Allocate request.  Subsequent messages between the client and\
    \ the\n   server use the same 5-tuple.  In this way, the client and server know\n\
    \   which allocation is being referred to.  If the client wishes to\n   allocate\
    \ a second relayed transport address, it must create a second\n   allocation using\
    \ a different 5-tuple (e.g., by using a different\n   client host address or port).\n\
    \      |  NOTE: While the terminology used in this document refers to\n      |\
    \  5-tuples, the TURN server can store whatever identifier it\n      |  likes\
    \ that yields identical results.  Specifically, an\n      |  implementation may\
    \ use a file descriptor in place of a 5-tuple\n      |  to represent a TCP connection.\n\
    \   TURN                                 TURN          Peer         Peer\n   client\
    \                               server         A            B\n     |-- Allocate\
    \ request --------------->|            |            |\n     |   (invalid or missing\
    \ credentials) |            |            |\n     |<--------------- Allocate failure\
    \ --|            |            |\n     |              (401 Unauthenticated) | \
    \           |            |\n     |-- Allocate request --------------->|      \
    \      |            |\n     |               (valid credentials)  |           \
    \ |            |\n     |<---------- Allocate success resp --|            |   \
    \         |\n     |            (192.0.2.15:50000)      |            |        \
    \    |\n     |-- Refresh request ---------------->|            |            |\n\
    \     |<----------- Refresh success resp --|            |            |\n   In\
    \ Figure 2, the client sends an Allocate request to the server with\n   invalid\
    \ or missing credentials.  Since the server requires that all\n   requests be\
    \ authenticated using STUN's long-term credential\n   mechanism, the server rejects\
    \ the request with a 401 (Unauthorized)\n   error code.  The client then tries\
    \ again, this time including\n   credentials.  This time, the server accepts the\
    \ Allocate request and\n   returns an Allocate success response containing (amongst\
    \ other\n   things) the relayed transport address assigned to the allocation.\n\
    \   Sometime later, the client decides to refresh the allocation; thus,\n   it\
    \ sends a Refresh request to the server.  The refresh is accepted\n   and the\
    \ server replies with a Refresh success response.\n"
- title: 3.3.  Permissions
  contents:
  - "3.3.  Permissions\n   To ease concerns amongst enterprise IT administrators that\
    \ TURN could\n   be used to bypass corporate firewall security, TURN includes\
    \ the\n   notion of permissions.  TURN permissions mimic the address-restricted\n\
    \   filtering mechanism of NATs that comply with [RFC4787].\n   An allocation\
    \ can have zero or more permissions.  Each permission\n   consists of an IP address\
    \ and a lifetime.  When the server receives a\n   UDP datagram on the allocation's\
    \ relayed transport address, it first\n   checks the list of permissions.  If\
    \ the source IP address of the\n   datagram matches a permission, the application\
    \ data is relayed to the\n   client; otherwise, the UDP datagram is silently discarded.\n\
    \   A permission expires after 5 minutes if it is not refreshed, and\n   there\
    \ is no way to explicitly delete a permission.  This behavior was\n   selected\
    \ to match the behavior of a NAT that complies with [RFC4787].\n   The client\
    \ can install or refresh a permission using either a\n   CreatePermission request\
    \ or a ChannelBind request.  Using the\n   CreatePermission request, multiple\
    \ permissions can be installed or\n   refreshed with a single request; this is\
    \ important for applications\n   that use ICE.  For security reasons, permissions\
    \ can only be\n   installed or refreshed by transactions that can be authenticated;\n\
    \   thus, Send indications and ChannelData messages (which are used to\n   send\
    \ data to peers) do not install or refresh any permissions.\n   Note that permissions\
    \ are within the context of an allocation, so\n   adding or expiring a permission\
    \ in one allocation does not affect\n   other allocations.\n"
- title: 3.4.  Send Mechanism
  contents:
  - "3.4.  Send Mechanism\n   There are two mechanisms for the client and peers to\
    \ exchange\n   application data using the TURN server.  The first mechanism uses\
    \ the\n   Send and Data methods, the second mechanism uses channels.  Common to\n\
    \   both mechanisms is the ability of the client to communicate with\n   multiple\
    \ peers using a single allocated relayed transport address;\n   thus, both mechanisms\
    \ include a means for the client to indicate to\n   the server which peer should\
    \ receive the data and for the server to\n   indicate to the client which peer\
    \ sent the data.\n   The Send mechanism uses Send and Data indications.  Send\
    \ indications\n   are used to send application data from the client to the server,\n\
    \   while Data indications are used to send application data from the\n   server\
    \ to the client.\n   When using the Send mechanism, the client sends a Send indication\
    \ to\n   the TURN server containing (a) an XOR-PEER-ADDRESS attribute\n   specifying\
    \ the (server-reflexive) transport address of the peer and\n   (b) a DATA attribute\
    \ holding the application data.  When the TURN\n   server receives the Send indication,\
    \ it extracts the application data\n   from the DATA attribute and sends it in\
    \ a UDP datagram to the peer,\n   using the allocated relay address as the source\
    \ address.  Note that\n   there is no need to specify the relayed transport address\
    \ since it is\n   implied by the 5-tuple used for the Send indication.\n   In\
    \ the reverse direction, UDP datagrams arriving at the relayed\n   transport address\
    \ on the TURN server are converted into Data\n   indications and sent to the client,\
    \ with the server-reflexive\n   transport address of the peer included in an XOR-PEER-ADDRESS\n\
    \   attribute and the data itself in a DATA attribute.  Since the relayed\n  \
    \ transport address uniquely identified the allocation, the server\n   knows which\
    \ client should receive the data.\n   Some ICMP (Internet Control Message Protocol)\
    \ packets arriving at the\n   relayed transport address on the TURN server may\
    \ be converted into\n   Data indications and sent to the client, with the transport\
    \ address\n   of the peer included in an XOR-PEER-ADDRESS attribute and the ICMP\n\
    \   type and code in an ICMP attribute.  ICMP attribute forwarding always\n  \
    \ uses Data indications containing the XOR-PEER-ADDRESS and ICMP\n   attributes,\
    \ even when using the channel mechanism to forward UDP\n   data.\n   Send and\
    \ Data indications cannot be authenticated since the long-term\n   credential\
    \ mechanism of STUN does not support authenticating\n   indications.  This is\
    \ not as big an issue as it might first appear\n   since the client-to-server\
    \ leg is only half of the total path to the\n   peer.  Applications that want\
    \ end-to-end security should encrypt the\n   data sent between the client and\
    \ a peer.\n   Because Send indications are not authenticated, it is possible for\
    \ an\n   attacker to send bogus Send indications to the server, which will\n \
    \  then relay these to a peer.  To partly mitigate this attack, TURN\n   requires\
    \ that the client install a permission towards a peer before\n   sending data\
    \ to it using a Send indication.  The technique to fully\n   mitigate the attack\
    \ is discussed in Section 21.1.4.\n   TURN                                TURN\
    \           Peer          Peer\n   client                              server\
    \          A             B\n     |-- CreatePermission req (Peer A) ->|       \
    \      |             |\n     |<- CreatePermission success resp --|           \
    \  |             |\n     |--- Send ind (Peer A)------------->|             | \
    \            |\n     |<------------- Data ind (Peer A) --|             |     \
    \        |\n     |--- Send ind (Peer B)------------->|             |         \
    \    |\n   In Figure 3, the client has already created an allocation and now\n\
    \   wishes to send data to its peers.  The client first creates a\n   permission\
    \ by sending the server a CreatePermission request\n   specifying Peer A's (server-reflexive)\
    \ IP address in the XOR-PEER-\n   ADDRESS attribute; if this was not done, the\
    \ server would not relay\n   data between the client and the server.  The client\
    \ then sends data\n   to Peer A using a Send indication; at the server, the application\n\
    \   data is extracted and forwarded in a UDP datagram to Peer A, using\n   the\
    \ relayed transport address as the source transport address.  When\n   a UDP datagram\
    \ from Peer A is received at the relayed transport\n   address, the contents are\
    \ placed into a Data indication and forwarded\n   to the client.  Later, the client\
    \ attempts to exchange data with Peer\n   B; however, no permission has been installed\
    \ for Peer B, so the Send\n   indication from the client and the UDP datagram\
    \ from the peer are\n   both dropped by the server.\n"
- title: 3.5.  Channels
  contents:
  - "3.5.  Channels\n   For some applications (e.g., Voice over IP (VoIP)), the 36\
    \ bytes of\n   overhead that a Send indication or Data indication adds to the\n\
    \   application data can substantially increase the bandwidth required\n   between\
    \ the client and the server.  To remedy this, TURN offers a\n   second way for\
    \ the client and server to associate data with a\n   specific peer.\n   This second\
    \ way uses an alternate packet format known as the\n   \"ChannelData message\"\
    .  The ChannelData message does not use the STUN\n   header used by other TURN\
    \ messages, but instead has a 4-byte header\n   that includes a number known as\
    \ a \"channel number\".  Each channel\n   number in use is bound to a specific\
    \ peer; thus, it serves as a\n   shorthand for the peer's host transport address.\n\
    \   To bind a channel to a peer, the client sends a ChannelBind request\n   to\
    \ the server and includes an unbound channel number and the\n   transport address\
    \ of the peer.  Once the channel is bound, the client\n   can use a ChannelData\
    \ message to send the server data destined for\n   the peer.  Similarly, the server\
    \ can relay data from that peer\n   towards the client using a ChannelData message.\n\
    \   Channel bindings last for 10 minutes unless refreshed; this lifetime\n   was\
    \ chosen to be longer than the permission lifetime.  Channel\n   bindings are\
    \ refreshed by sending another ChannelBind request\n   rebinding the channel to\
    \ the peer.  Like permissions (but unlike\n   allocations), there is no way to\
    \ explicitly delete a channel binding;\n   the client must simply wait for it\
    \ to time out.\n   TURN                                TURN           Peer   \
    \       Peer\n   client                              server          A       \
    \      B\n     |-- ChannelBind req --------------->|             |           \
    \  |\n     | (Peer A to 0x4001)                |             |             |\n\
    \     |<---------- ChannelBind succ resp -|             |             |\n    \
    \ |-- (0x4001) data ----------------->|             |             |\n     |<------------------\
    \ (0x4001) data -|             |             |\n     |--- Send ind (Peer A)------------->|\
    \             |             |\n     |<------------------ (0x4001) data -|    \
    \         |             |\n   Figure 4 shows the channel mechanism in use.  The\
    \ client has already\n   created an allocation and now wishes to bind a channel\
    \ to Peer A.  To\n   do this, the client sends a ChannelBind request to the server,\n\
    \   specifying the transport address of Peer A and a channel number\n   (0x4001).\
    \  After that, the client can send application data\n   encapsulated inside ChannelData\
    \ messages to Peer A: this is shown as\n   \"(0x4001) data\" where 0x4001 is the\
    \ channel number.  When the\n   ChannelData message arrives at the server, the\
    \ server transfers the\n   data to a UDP datagram and sends it to Peer A (which\
    \ is the peer\n   bound to channel number 0x4001).\n   In the reverse direction,\
    \ when Peer A sends a UDP datagram to the\n   relayed transport address, this\
    \ UDP datagram arrives at the server on\n   the relayed transport address assigned\
    \ to the allocation.  Since the\n   UDP datagram was received from Peer A, which\
    \ has a channel number\n   assigned to it, the server encapsulates the data into\
    \ a ChannelData\n   message when sending the data to the client.\n   Once a channel\
    \ has been bound, the client is free to intermix\n   ChannelData messages and\
    \ Send indications.  In the figure, the client\n   later decides to use a Send\
    \ indication rather than a ChannelData\n   message to send additional data to\
    \ Peer A.  The client might decide\n   to do this, for example, so it can use\
    \ the DONT-FRAGMENT attribute\n   (see the next section).  However, once a channel\
    \ is bound, the server\n   will always use a ChannelData message, as shown in\
    \ the call flow.\n   Note that ChannelData messages can only be used for peers\
    \ to which\n   the client has bound a channel.  In the example above, Peer A has\n\
    \   been bound to a channel, but Peer B has not, so application data to\n   and\
    \ from Peer B would use the Send mechanism.\n"
- title: 3.6.  Unprivileged TURN Servers
  contents:
  - "3.6.  Unprivileged TURN Servers\n   This version of TURN is designed so that\
    \ the server can be\n   implemented as an application that runs in user space\
    \ under commonly\n   available operating systems without requiring special privileges.\n\
    \   This design decision was made to make it easy to deploy a TURN\n   server:\
    \ for example, to allow a TURN server to be integrated into a\n   peer-to-peer\
    \ application so that one peer can offer NAT traversal\n   services to another\
    \ peer and to use (D)TLS to secure the TURN\n   connection.\n   This design decision\
    \ has the following implications for data relayed\n   by a TURN server:\n   *\
    \  The value of the Diffserv field may not be preserved across the\n      server;\n\
    \   *  The Time to Live (TTL) field may be reset, rather than\n      decremented,\
    \ across the server;\n   *  The Explicit Congestion Notification (ECN) field may\
    \ be reset by\n      the server;\n   *  There is no end-to-end fragmentation since\
    \ the packet is\n      reassembled at the server.\n   Future work may specify\
    \ alternate TURN semantics that address these\n   limitations.\n"
- title: 3.7.  Avoiding IP Fragmentation
  contents:
  - "3.7.  Avoiding IP Fragmentation\n   For reasons described in [FRAG-HARMFUL],\
    \ applications, especially\n   those sending large volumes of data, should avoid\
    \ having their\n   packets fragmented.  [FRAG-FRAGILE] discusses issues associated\
    \ with\n   IP fragmentation and proposes alternatives to IP fragmentation.\n \
    \  Applications using TCP can, more or less, ignore this issue because\n   fragmentation\
    \ avoidance is now a standard part of TCP, but\n   applications using UDP (and,\
    \ thus, any application using this version\n   of TURN) need to avoid IP fragmentation\
    \ by sending sufficiently small\n   messages or by using UDP fragmentation [UDP-OPT].\
    \  Note that the UDP\n   fragmentation option needs to be supported by both endpoints,\
    \ and at\n   the time of writing of this document, UDP fragmentation support is\n\
    \   under discussion and is not deployed.\n   The application running on the client\
    \ and the peer can take one of\n   two approaches to avoid IP fragmentation until\
    \ UDP fragmentation\n   support is available.  The first uses messages that are\
    \ limited to a\n   predetermined fixed maximum, and the second relies on network\n\
    \   feedback to adapt that maximum.\n   The first approach is to avoid sending\
    \ large amounts of application\n   data in the TURN messages/UDP datagrams exchanged\
    \ between the client\n   and the peer.  This is the approach taken by most VoIP\
    \ applications.\n   In this approach, the application MUST assume a Path MTU (PMTU)\
    \ of\n   1280 bytes because IPv6 requires that every link in the Internet has\n\
    \   an MTU of 1280 octets or greater as specified in [RFC8200].  If IPv4\n   support\
    \ on legacy or otherwise unusual networks is a consideration,\n   the application\
    \ MAY assume an effective MTU of 576 bytes for IPv4\n   datagrams, as every IPv4\
    \ host must be capable of receiving a packet\n   with a length equal to 576 bytes\
    \ as discussed in [RFC0791] and\n   [RFC1122].\n   The exact amount of application\
    \ data that can be included while\n   avoiding fragmentation depends on the details\
    \ of the TURN session\n   between the client and the server: whether UDP, TCP,\
    \ or (D)TLS\n   transport is used; whether ChannelData messages or Send/Data\n\
    \   indications are used; and whether any additional attributes (such as\n   the\
    \ DONT-FRAGMENT attribute) are included.  Another factor, which is\n   hard to\
    \ determine, is whether the MTU is reduced somewhere along the\n   path for other\
    \ reasons, such as the use of IP-in-IP tunneling.\n   As a guideline, sending\
    \ a maximum of 500 bytes of application data in\n   a single TURN message (by\
    \ the client on the client-to-server leg) or\n   a UDP datagram (by the peer on\
    \ the peer-to-server leg) will generally\n   avoid IP fragmentation.  To further\
    \ reduce the chance of\n   fragmentation, it is recommended that the client use\
    \ ChannelData\n   messages when transferring significant volumes of data since\
    \ the\n   overhead of the ChannelData message is less than Send and Data\n   indications.\n\
    \   The second approach the client and peer can take to avoid\n   fragmentation\
    \ is to use a path MTU discovery algorithm to determine\n   the maximum amount\
    \ of application data that can be sent without\n   fragmentation.  The classic\
    \ path MTU discovery algorithm defined in\n   [RFC1191] may not be able to discover\
    \ the MTU of the transmission\n   path between the client and the peer since:\n\
    \   *  A probe packet with a Don't Fragment (DF) bit in the IPv4 header\n    \
    \  set to test a path for a larger MTU can be dropped by routers, or\n   *  ICMP\
    \ error messages can be dropped by middleboxes.\n   As a result, the client and\
    \ server need to use a path MTU discovery\n   algorithm that does not require\
    \ ICMP messages.  The Packetized Path\n   MTU Discovery algorithm defined in [RFC4821]\
    \ is one such algorithm,\n   and a set of algorithms is defined in [MTU-DATAGRAM].\n\
    \   [MTU-STUN] is an implementation of [RFC4821] that uses STUN to\n   discover\
    \ the path MTU; so it might be a suitable approach to be used\n   in conjunction\
    \ with a TURN server that supports the DONT-FRAGMENT\n   attribute.  When the\
    \ client includes the DONT-FRAGMENT attribute in a\n   Send indication, this tells\
    \ the server to set the DF bit in the\n   resulting UDP datagram that it sends\
    \ to the peer.  Since some servers\n   may be unable to set the DF bit, the client\
    \ should also include this\n   attribute in the Allocate request; any server that\
    \ does not support\n   the DONT-FRAGMENT attribute will indicate this by rejecting\
    \ the\n   Allocate request.  If the TURN server carrying out packet translation\n\
    \   from IPv4-to-IPv6 is unable to access the state of the Don't Fragment\n  \
    \ (DF) bit in the IPv4 header, it MUST reject the Allocate request with\n   the\
    \ DONT-FRAGMENT attribute.\n"
- title: 3.8.  RTP Support
  contents:
  - "3.8.  RTP Support\n   One of the envisioned uses of TURN is as a relay for clients\
    \ and\n   peers wishing to exchange real-time data (e.g., voice or video) using\n\
    \   RTP.  To facilitate the use of TURN for this purpose, TURN includes\n   some\
    \ special support for older versions of RTP.\n   Old versions of RTP [RFC3550]\
    \ required that the RTP stream be on an\n   even port number and the associated\
    \ RTP Control Protocol (RTCP)\n   stream, if present, be on the next highest port.\
    \  To allow clients to\n   work with peers that still require this, TURN allows\
    \ the client to\n   request that the server allocate a relayed transport address\
    \ with an\n   even port number and optionally request the server reserve the next-\n\
    \   highest port number for a subsequent allocation.\n"
- title: 3.9.  Happy Eyeballs for TURN
  contents:
  - "3.9.  Happy Eyeballs for TURN\n   If an IPv4 path to reach a TURN server is found,\
    \ but the TURN\n   server's IPv6 path is not working, a dual-stack TURN client\
    \ can\n   experience a significant connection delay compared to an IPv4-only\n\
    \   TURN client.  To overcome these connection setup problems, the TURN\n   client\
    \ needs to query both A and AAAA records for the TURN server\n   specified using\
    \ a domain name and try connecting to the TURN server\n   using both IPv6 and\
    \ IPv4 addresses in a fashion similar to the Happy\n   Eyeballs mechanism defined\
    \ in [RFC8305].  The TURN client performs\n   the following steps based on the\
    \ transport protocol being used to\n   connect to the TURN server.\n   *  For\
    \ TCP or TLS-over-TCP, the results of the Happy Eyeballs\n      procedure [RFC8305]\
    \ are used by the TURN client for sending its\n      TURN messages to the server.\n\
    \   *  For clear text UDP, send TURN Allocate requests to both IP address\n  \
    \    families as discussed in [RFC8305] without authentication\n      information.\
    \  If the TURN server requires authentication, it will\n      send back a 401\
    \ unauthenticated response; the TURN client will use\n      the first UDP connection\
    \ on which a 401 error response is\n      received.  If a 401 error response is\
    \ received from both IP\n      address families, then the TURN client can silently\
    \ abandon the\n      UDP connection on the IP address family with lower precedence.\
    \  If\n      the TURN server does not require authentication (as described in\n\
    \      Section 9 of [RFC8155]), it is possible for both Allocate requests\n  \
    \    to succeed.  In this case, the TURN client sends a Refresh with a\n     \
    \ LIFETIME value of zero on the allocation using the IP address\n      family\
    \ with lower precedence to delete the allocation.\n   *  For DTLS over UDP, initiate\
    \ a DTLS handshake to both IP address\n      families as discussed in [RFC8305],\
    \ and use the first DTLS session\n      that is established.  If the DTLS session\
    \ is established on both\n      IP address families, then the client sends a DTLS\
    \ close_notify\n      alert to terminate the DTLS session using the IP address\
    \ family\n      with lower precedence.  If the TURN over DTLS server has been\n\
    \      configured to require a cookie exchange (Section 4.2 of [RFC6347])\n  \
    \    and a HelloVerifyRequest is received from the TURN servers on both\n    \
    \  IP address families, then the client can silently abandon the\n      connection\
    \ on the IP address family with lower precedence.\n"
- title: 4.  Discovery of TURN Server
  contents:
  - "4.  Discovery of TURN Server\n   Methods of TURN server discovery, including\
    \ using anycast, are\n   described in [RFC8155].  If a host with multiple interfaces\
    \ discovers\n   a TURN server in each interface, the mechanism described in [RFC7982]\n\
    \   can be used by the TURN client to influence the TURN server\n   selection.\
    \  The syntax of the \"turn\" and \"turns\" URIs are defined in\n   Section 3.1\
    \ of [RFC7065].  DTLS as a transport protocol for TURN is\n   defined in [RFC7350].\n"
- title: 4.1.  TURN URI Scheme Semantics
  contents:
  - "4.1.  TURN URI Scheme Semantics\n   The \"turn\" and \"turns\" URI schemes are\
    \ used to designate a TURN\n   server (also known as a \"relay\") on Internet\
    \ hosts accessible using\n   the TURN protocol.  The TURN protocol supports sending\
    \ messages over\n   UDP, TCP, TLS-over-TCP, or DTLS-over-UDP.  The \"turns\" URI\
    \ scheme\n   MUST be used when TURN is run over TLS-over-TCP or in DTLS-over-UDP,\n\
    \   and the \"turn\" scheme MUST be used otherwise.  The required <host>\n   part\
    \ of the \"turn\" URI denotes the TURN server host.  The <port>\n   part, if present,\
    \ denotes the port on which the TURN server is\n   awaiting connection requests.\
    \  If it is absent, the default port is\n   3478 for both UDP and TCP.  The default\
    \ port for TURN over TLS and\n   TURN over DTLS is 5349.\n"
- title: 5.  General Behavior
  contents:
  - "5.  General Behavior\n   This section contains general TURN processing rules\
    \ that apply to all\n   TURN messages.\n   TURN is an extension to STUN.  All\
    \ TURN messages, with the exception\n   of the ChannelData message, are STUN-formatted\
    \ messages.  All the\n   base processing rules described in [RFC8489] apply to\
    \ STUN-formatted\n   messages.  This means that all the message-forming and message-\n\
    \   processing descriptions in this document are implicitly prefixed with\n  \
    \ the rules of [RFC8489].\n   [RFC8489] specifies an authentication mechanism\
    \ called the \"long-term\n   credential mechanism\".  TURN servers and clients\
    \ MUST implement this\n   mechanism, and the authentication options are discussed\
    \ in\n   Section 7.2.\n   Note that the long-term credential mechanism applies\
    \ only to requests\n   and cannot be used to authenticate indications; thus, indications\
    \ in\n   TURN are never authenticated.  If the server requires requests to be\n\
    \   authenticated, then the server's administrator MUST choose a realm\n   value\
    \ that will uniquely identify the username and password\n   combination that the\
    \ client must use, even if the client uses\n   multiple servers under different\
    \ administrations.  The server's\n   administrator MAY choose to allocate a unique\
    \ username to each\n   client, or it MAY choose to allocate the same username\
    \ to more than\n   one client (for example, to all clients from the same department\
    \ or\n   company).  For each Allocate request, the server SHOULD generate a\n\
    \   new random nonce when the allocation is first attempted following the\n  \
    \ randomness recommendations in [RFC4086] and SHOULD expire the nonce\n   at least\
    \ once every hour during the lifetime of the allocation.  The\n   server uses\
    \ the mechanism described in Section 9.2 of [RFC8489] to\n   indicate that it\
    \ supports [RFC8489].\n   All requests after the initial Allocate must use the\
    \ same username as\n   that used to create the allocation to prevent attackers\
    \ from\n   hijacking the client's allocation.\n   Specifically, if:\n   *  the\
    \ server requires the use of the long-term credential mechanism,\n      and;\n\
    \   *  a non-Allocate request passes authentication under this mechanism,\n  \
    \    and;\n   *  the 5-tuple identifies an existing allocation, but;\n   *  the\
    \ request does not use the same username as used to create the\n      allocation,\n\
    \   then the request MUST be rejected with a 441 (Wrong Credentials)\n   error.\n\
    \   When a TURN message arrives at the server from the client, the server\n  \
    \ uses the 5-tuple in the message to identify the associated\n   allocation. \
    \ For all TURN messages (including ChannelData) EXCEPT an\n   Allocate request,\
    \ if the 5-tuple does not identify an existing\n   allocation, then the message\
    \ MUST either be rejected with a 437\n   Allocation Mismatch error (if it is a\
    \ request) or be silently ignored\n   (if it is an indication or a ChannelData\
    \ message).  A client\n   receiving a 437 error response to a request other than\
    \ Allocate MUST\n   assume the allocation no longer exists.\n   [RFC8489] defines\
    \ a number of attributes, including the SOFTWARE and\n   FINGERPRINT attributes.\
    \  The client SHOULD include the SOFTWARE\n   attribute in all Allocate and Refresh\
    \ requests and MAY include it in\n   any other requests or indications.  The server\
    \ SHOULD include the\n   SOFTWARE attribute in all Allocate and Refresh responses\
    \ (either\n   success or failure) and MAY include it in other responses or\n \
    \  indications.  The client and the server MAY include the FINGERPRINT\n   attribute\
    \ in any STUN-formatted messages defined in this document.\n   TURN does not use\
    \ the backwards-compatibility mechanism described in\n   [RFC8489].\n   TURN,\
    \ as defined in this specification, supports both IPv4 and IPv6.\n   IPv6 support\
    \ in TURN includes IPv4-to-IPv6, IPv6-to-IPv6, and IPv6-\n   to-IPv4 relaying.\
    \  When only a single address type is desired, the\n   REQUESTED-ADDRESS-FAMILY\
    \ attribute is used to explicitly request the\n   address type the TURN server\
    \ will allocate (e.g., an IPv4-only node\n   may request the TURN server to allocate\
    \ an IPv6 address).  If both\n   IPv4 and IPv6 are desired, the single ADDITIONAL-ADDRESS-FAMILY\n\
    \   attribute indicates a request to the server to allocate one IPv4 and\n   one\
    \ IPv6 relay address in a single Allocate request.  This saves\n   local ports\
    \ on the client and reduces the number of messages sent\n   between the client\
    \ and the TURN server.\n   By default, TURN runs on the same ports as STUN: 3478\
    \ for TURN over\n   UDP and TCP, and 5349 for TURN over (D)TLS.  However, TURN\
    \ has its\n   own set of Service Record (SRV) names: \"turn\" for UDP and TCP,\
    \ and\n   \"turns\" for (D)TLS.  Either the DNS resolution procedures or the\n\
    \   ALTERNATE-SERVER procedures, both described in Section 7, can be used\n  \
    \ to run TURN on a different port.\n   To ensure interoperability, a TURN server\
    \ MUST support the use of UDP\n   transport between the client and the server,\
    \ and it SHOULD support\n   the use of TCP, TLS-over-TCP, and DTLS-over-UDP transports.\n\
    \   When UDP or DTLS-over-UDP transport is used between the client and\n   the\
    \ server, the client will retransmit a request if it does not\n   receive a response\
    \ within a certain timeout period.  Because of this,\n   the server may receive\
    \ two (or more) requests with the same 5-tuple\n   and same transaction id.  STUN\
    \ requires that the server recognize\n   this case and treat the request as idempotent\
    \ (see [RFC8489]).  Some\n   implementations may choose to meet this requirement\
    \ by remembering\n   all received requests and the corresponding responses for\
    \ 40 seconds\n   (Section 6.3.1 of [RFC8489]).  Other implementations may choose\
    \ to\n   reprocess the request and arrange that such reprocessing returns\n  \
    \ essentially the same response.  To aid implementors who choose the\n   latter\
    \ approach (the so-called \"stateless stack approach\"), this\n   specification\
    \ includes some implementation notes on how this might be\n   done.  Implementations\
    \ are free to choose either approach or some\n   other approach that gives the\
    \ same results.\n   To mitigate either intentional or unintentional denial-of-service\n\
    \   attacks against the server by clients with valid usernames and\n   passwords,\
    \ it is RECOMMENDED that the server impose limits on both\n   the number of allocations\
    \ active at one time for a given username and\n   on the amount of bandwidth those\
    \ allocations can use.  The server\n   should reject new allocations that would\
    \ exceed the limit on the\n   allowed number of allocations active at one time\
    \ with a 486\n   (Allocation Quota Exceeded) (see Section 7.2), and since UDP\
    \ does not\n   include a congestion control mechanism, it should discard application\n\
    \   data traffic that exceeds the bandwidth quota.\n"
- title: 6.  Allocations
  contents:
  - "6.  Allocations\n   All TURN operations revolve around allocations, and all TURN\
    \ messages\n   are associated with either a single or dual allocation.  An\n \
    \  allocation conceptually consists of the following state data:\n   *  the relayed\
    \ transport address or addresses;\n   *  the 5-tuple: (client's IP address, client's\
    \ port, server IP\n      address, server port, and transport protocol);\n   *\
    \  the authentication information;\n   *  the time-to-expiry for each relayed\
    \ transport address;\n   *  a list of permissions for each relayed transport address;\n\
    \   *  a list of channel-to-peer bindings for each relayed transport\n      address.\n\
    \   The relayed transport address is the transport address allocated by\n   the\
    \ server for communicating with peers, while the 5-tuple describes\n   the communication\
    \ path between the client and the server.  On the\n   client, the 5-tuple uses\
    \ the client's host transport address; on the\n   server, the 5-tuple uses the\
    \ client's server-reflexive transport\n   address.  The relayed transport address\
    \ MUST be unique across all\n   allocations so it can be used to uniquely identify\
    \ the allocation,\n   and an allocation in this context can be either a single\
    \ or dual\n   allocation.\n   The authentication information (e.g., username,\
    \ password, realm, and\n   nonce) is used to both verify subsequent requests and\
    \ to compute the\n   message integrity of responses.  The username, realm, and\
    \ nonce\n   values are initially those used in the authenticated Allocate request\n\
    \   that creates the allocation, though the server can change the nonce\n   value\
    \ during the lifetime of the allocation using a 438 (Stale Nonce)\n   reply. \
    \ For security reasons, the server MUST NOT store the password\n   explicitly\
    \ and MUST store the key value, which is a cryptographic\n   hash over the username,\
    \ realm, and password (see Section 16.1.3 of\n   [RFC8489]).\n   Note that if\
    \ the response contains a PASSWORD-ALGORITHMS attribute\n   and this attribute\
    \ contains both MD5 and SHA-256 algorithms, and the\n   client also supports both\
    \ the algorithms, the request MUST contain a\n   PASSWORD-ALGORITHM attribute\
    \ with the SHA-256 algorithm.\n   The time-to-expiry is the time in seconds left\
    \ until the allocation\n   expires.  Each Allocate or Refresh transaction sets\
    \ this timer, which\n   then ticks down towards zero.  By default, each Allocate\
    \ or Refresh\n   transaction resets this timer to the default lifetime value of\
    \ 600\n   seconds (10 minutes), but the client can request a different value in\n\
    \   the Allocate and Refresh request.  Allocations can only be refreshed\n   using\
    \ the Refresh request; sending data to a peer does not refresh an\n   allocation.\
    \  When an allocation expires, the state data associated\n   with the allocation\
    \ can be freed.\n   The list of permissions is described in Section 9 and the\
    \ list of\n   channels is described in Section 12.\n"
- title: 7.  Creating an Allocation
  contents:
  - "7.  Creating an Allocation\n   An allocation on the server is created using an\
    \ Allocate transaction.\n"
- title: 7.1.  Sending an Allocate Request
  contents:
  - "7.1.  Sending an Allocate Request\n   The client forms an Allocate request as\
    \ follows.\n   The client first picks a host transport address.  It is RECOMMENDED\n\
    \   that the client pick a currently unused transport address, typically\n   by\
    \ allowing the underlying OS to pick a currently unused port.\n   The client then\
    \ picks a transport protocol that the client supports\n   to use between the client\
    \ and the server based on the transport\n   protocols supported by the server.\
    \  Since this specification only\n   allows UDP between the server and the peers,\
    \ it is RECOMMENDED that\n   the client pick UDP unless it has a reason to use\
    \ a different\n   transport.  One reason to pick a different transport would be\
    \ that\n   the client believes, either through configuration or discovery or by\n\
    \   experiment, that it is unable to contact any TURN server using UDP.\n   See\
    \ Section 3.1 for more discussion.\n   The client also picks a server transport\
    \ address, which SHOULD be\n   done as follows.  The client uses one or more procedures\
    \ described in\n   [RFC8155] to discover a TURN server and uses the TURN server\n\
    \   resolution mechanism defined in [RFC5928] and [RFC7350] to get a list\n  \
    \ of server transport addresses that can be tried to create a TURN\n   allocation.\n\
    \   The client MUST include a REQUESTED-TRANSPORT attribute in the\n   request.\
    \  This attribute specifies the transport protocol between the\n   server and\
    \ the peers (note that this is *not* the transport protocol\n   that appears in\
    \ the 5-tuple).  In this specification, the REQUESTED-\n   TRANSPORT type is always\
    \ UDP.  This attribute is included to allow\n   future extensions to specify other\
    \ protocols.\n   If the client wishes to obtain a relayed transport address of\
    \ a\n   specific address type, then it includes a REQUESTED-ADDRESS-FAMILY\n \
    \  attribute in the request.  This attribute indicates the specific\n   address\
    \ type the client wishes the TURN server to allocate.  Clients\n   MUST NOT include\
    \ more than one REQUESTED-ADDRESS-FAMILY attribute in\n   an Allocate request.\
    \  Clients MUST NOT include a REQUESTED-ADDRESS-\n   FAMILY attribute in an Allocate\
    \ request that contains a RESERVATION-\n   TOKEN attribute, for the reason that\
    \ the server uses the previously\n   reserved transport address corresponding\
    \ to the included token and\n   the client cannot obtain a relayed transport address\
    \ of a specific\n   address type.\n   If the client wishes to obtain one IPv6\
    \ and one IPv4 relayed\n   transport address, then it includes an ADDITIONAL-ADDRESS-FAMILY\n\
    \   attribute in the request.  This attribute specifies that the server\n   must\
    \ allocate both address types.  The attribute value in the\n   ADDITIONAL-ADDRESS-FAMILY\
    \ MUST be set to 0x02 (IPv6 address family).\n   Clients MUST NOT include REQUESTED-ADDRESS-FAMILY\
    \ and ADDITIONAL-\n   ADDRESS-FAMILY attributes in the same request.  Clients\
    \ MUST NOT\n   include the ADDITIONAL-ADDRESS-FAMILY attribute in an Allocate\n\
    \   request that contains a RESERVATION-TOKEN attribute.  Clients MUST\n   NOT\
    \ include the ADDITIONAL-ADDRESS-FAMILY attribute in an Allocate\n   request that\
    \ contains an EVEN-PORT attribute with the R (Reserved)\n   bit set to 1.  The\
    \ reason behind the restriction is that if the EVEN-\n   PORT attribute with the\
    \ R bit set to 1 is allowed with the\n   ADDITIONAL-ADDRESS-FAMILY attribute,\
    \ two tokens will have to be\n   returned in the success response and changes\
    \ will be required to the\n   way the RESERVATION-TOKEN attribute is handled.\n\
    \   If the client wishes the server to initialize the time-to-expiry\n   field\
    \ of the allocation to some value other than the default\n   lifetime, then it\
    \ MAY include a LIFETIME attribute specifying its\n   desired value.  This is\
    \ just a hint, and the server may elect to use\n   a different value.  Note that\
    \ the server will ignore requests to\n   initialize the field to less than the\
    \ default value.\n   If the client wishes to later use the DONT-FRAGMENT attribute\
    \ in one\n   or more Send indications on this allocation, then the client SHOULD\n\
    \   include the DONT-FRAGMENT attribute in the Allocate request.  This\n   allows\
    \ the client to test whether this attribute is supported by the\n   server.\n\
    \   If the client requires the port number of the relayed transport\n   address\
    \ to be even, the client includes the EVEN-PORT attribute.  If\n   this attribute\
    \ is not included, then the port can be even or odd.  By\n   setting the R bit\
    \ in the EVEN-PORT attribute to 1, the client can\n   request that the server\
    \ reserve the next highest port number (on the\n   same IP address) for a subsequent\
    \ allocation.  If the R bit is 0, no\n   such request is made.\n   The client\
    \ MAY also include a RESERVATION-TOKEN attribute in the\n   request to ask the\
    \ server to use a previously reserved port for the\n   allocation.  If the RESERVATION-TOKEN\
    \ attribute is included, then the\n   client MUST omit the EVEN-PORT attribute.\n\
    \   Once constructed, the client sends the Allocate request on the\n   5-tuple.\n"
- title: 7.2.  Receiving an Allocate Request
  contents:
  - "7.2.  Receiving an Allocate Request\n   When the server receives an Allocate\
    \ request, it performs the\n   following checks:\n   1.   The TURN server provided\
    \ by the local or access network MAY\n        allow an unauthenticated request\
    \ in order to accept Allocation\n        requests from new and/or guest users\
    \ in the network who do not\n        necessarily possess long-term credentials\
    \ for STUN\n        authentication.  The security implications of STUN and making\n\
    \        STUN authentication optional are discussed in [RFC8155].\n        Otherwise,\
    \ the server MUST require that the request be\n        authenticated.  If the\
    \ request is authenticated, the\n        authentication MUST be done either using\
    \ the long-term\n        credential mechanism of [RFC8489] or using the STUN Extension\n\
    \        for Third-Party Authorization [RFC7635] unless the client and\n     \
    \   server agree to use another mechanism through some procedure\n        outside\
    \ the scope of this document.\n   2.   The server checks if the 5-tuple is currently\
    \ in use by an\n        existing allocation.  If yes, the server rejects the request\n\
    \        with a 437 (Allocation Mismatch) error.\n   3.   The server checks if\
    \ the request contains a REQUESTED-TRANSPORT\n        attribute.  If the REQUESTED-TRANSPORT\
    \ attribute is not included\n        or is malformed, the server rejects the request\
    \ with a 400 (Bad\n        Request) error.  Otherwise, if the attribute is included\
    \ but\n        specifies a protocol that is not supported by the server, the\n\
    \        server rejects the request with a 442 (Unsupported Transport\n      \
    \  Protocol) error.\n   4.   The request may contain a DONT-FRAGMENT attribute.\
    \  If it does,\n        but the server does not support sending UDP datagrams\
    \ with the\n        DF bit set to 1 (see Sections 14 and 15), then the server\
    \ treats\n        the DONT-FRAGMENT attribute in the Allocate request as an\n\
    \        unknown comprehension-required attribute.\n   5.   The server checks\
    \ if the request contains a RESERVATION-TOKEN\n        attribute.  If yes, and\
    \ the request also contains an EVEN-PORT\n        or REQUESTED-ADDRESS-FAMILY\
    \ or ADDITIONAL-ADDRESS-FAMILY\n        attribute, the server rejects the request\
    \ with a 400 (Bad\n        Request) error.  Otherwise, it checks to see if the\
    \ token is\n        valid (i.e., the token is in range and has not expired, and\
    \ the\n        corresponding relayed transport address is still available).  If\n\
    \        the token is not valid for some reason, the server rejects the\n    \
    \    request with a 508 (Insufficient Capacity) error.\n   6.   The server checks\
    \ if the request contains both REQUESTED-\n        ADDRESS-FAMILY and ADDITIONAL-ADDRESS-FAMILY\
    \ attributes.  If\n        yes, then the server rejects the request with a 400\
    \ (Bad\n        Request) error.\n   7.   If the server does not support the address\
    \ family requested by\n        the client in REQUESTED-ADDRESS-FAMILY, or if the\
    \ allocation of\n        the requested address family is disabled by local policy,\
    \ it\n        MUST generate an Allocate error response, and it MUST include an\n\
    \        ERROR-CODE attribute with the 440 (Address Family not Supported)\n  \
    \      response code.  If the REQUESTED-ADDRESS-FAMILY attribute is\n        absent\
    \ and the server does not support the IPv4 address family,\n        the server\
    \ MUST include an ERROR-CODE attribute with the 440\n        (Address Family not\
    \ Supported) response code.  If the REQUESTED-\n        ADDRESS-FAMILY attribute\
    \ is absent and the server supports the\n        IPv4 address family, the server\
    \ MUST allocate an IPv4 relayed\n        transport address for the TURN client.\n\
    \   8.   The server checks if the request contains an EVEN-PORT attribute\n  \
    \      with the R bit set to 1.  If yes, and the request also contains\n     \
    \   an ADDITIONAL-ADDRESS-FAMILY attribute, the server rejects the\n        request\
    \ with a 400 (Bad Request) error.  Otherwise, the server\n        checks if it\
    \ can satisfy the request (i.e., can allocate a\n        relayed transport address\
    \ as described below).  If the server\n        cannot satisfy the request, then\
    \ the server rejects the request\n        with a 508 (Insufficient Capacity) error.\n\
    \   9.   The server checks if the request contains an ADDITIONAL-ADDRESS-\n  \
    \      FAMILY attribute.  If yes, and the attribute value is 0x01 (IPv4\n    \
    \    address family), then the server rejects the request with a 400\n       \
    \ (Bad Request) error.  Otherwise, the server checks if it can\n        allocate\
    \ relayed transport addresses of both address types.  If\n        the server cannot\
    \ satisfy the request, then the server rejects\n        the request with a 508\
    \ (Insufficient Capacity) error.  If the\n        server can partially meet the\
    \ request, i.e., if it can only\n        allocate one relayed transport address\
    \ of a specific address\n        type, then it includes ADDRESS-ERROR-CODE attribute\
    \ in the\n        success response to inform the client the reason for partial\n\
    \        failure of the request.  The error code value signaled in the\n     \
    \   ADDRESS-ERROR-CODE attribute could be 440 (Address Family not\n        Supported)\
    \ or 508 (Insufficient Capacity).  If the server can\n        fully meet the request,\
    \ then the server allocates one IPv4 and\n        one IPv6 relay address and returns\
    \ an Allocate success response\n        containing the relayed transport addresses\
    \ assigned to the dual\n        allocation in two XOR-RELAYED-ADDRESS attributes.\n\
    \   10.  At any point, the server MAY choose to reject the request with a\n  \
    \      486 (Allocation Quota Reached) error if it feels the client is\n      \
    \  trying to exceed some locally defined allocation quota.  The\n        server\
    \ is free to define this allocation quota any way it\n        wishes, but it SHOULD\
    \ define it based on the username used to\n        authenticate the request and\
    \ not on the client's transport\n        address.\n   11.  Also, at any point,\
    \ the server MAY choose to reject the request\n        with a 300 (Try Alternate)\
    \ error if it wishes to redirect the\n        client to a different server.  The\
    \ use of this error code and\n        attribute follows the specification in [RFC8489].\n\
    \   If all the checks pass, the server creates the allocation.  The\n   5-tuple\
    \ is set to the 5-tuple from the Allocate request, while the\n   list of permissions\
    \ and the list of channels are initially empty.\n   The server chooses a relayed\
    \ transport address for the allocation as\n   follows:\n   *  If the request contains\
    \ a RESERVATION-TOKEN attribute, the server\n      uses the previously reserved\
    \ transport address corresponding to\n      the included token (if it is still\
    \ available).  Note that the\n      reservation is a server-wide reservation and\
    \ is not specific to a\n      particular allocation since the Allocate request\
    \ containing the\n      RESERVATION-TOKEN uses a different 5-tuple than the Allocate\n\
    \      request that made the reservation.  The 5-tuple for the Allocate\n    \
    \  request containing the RESERVATION-TOKEN attribute can be any\n      allowed\
    \ 5-tuple; it can use a different client IP address and\n      port, a different\
    \ transport protocol, and even a different server\n      IP address and port (provided,\
    \ of course, that the server IP\n      address and port are ones on which the\
    \ server is listening for\n      TURN requests).\n   *  If the request contains\
    \ an EVEN-PORT attribute with the R bit set\n      to 0, then the server allocates\
    \ a relayed transport address with\n      an even port number.\n   *  If the request\
    \ contains an EVEN-PORT attribute with the R bit set\n      to 1, then the server\
    \ looks for a pair of port numbers N and N+1\n      on the same IP address, where\
    \ N is even.  Port N is used in the\n      current allocation, while the relayed\
    \ transport address with port\n      N+1 is assigned a token and reserved for\
    \ a future allocation.  The\n      server MUST hold this reservation for at least\
    \ 30 seconds and MAY\n      choose to hold longer (e.g., until the allocation\
    \ with port N\n      expires).  The server then includes the token in a RESERVATION-\n\
    \      TOKEN attribute in the success response.\n   *  Otherwise, the server allocates\
    \ any available relayed transport\n      address.\n   In all cases, the server\
    \ SHOULD only allocate ports from the range\n   49152 - 65535 (the Dynamic and/or\
    \ Private Port range [PORT-NUMBERS]),\n   unless the TURN server application knows,\
    \ through some means not\n   specified here, that other applications running on\
    \ the same host as\n   the TURN server application will not be impacted by allocating\
    \ ports\n   outside this range.  This condition can often be satisfied by running\n\
    \   the TURN server application on a dedicated machine and/or by\n   arranging\
    \ that any other applications on the machine allocate ports\n   before the TURN\
    \ server application starts.  In any case, the TURN\n   server SHOULD NOT allocate\
    \ ports in the range 0 - 1023 (the Well-\n   Known Port range) to discourage clients\
    \ from using TURN to run\n   standard services.\n      |  NOTE: The use of randomized\
    \ port assignments to avoid certain\n      |  types of attacks is described in\
    \ [RFC6056].  It is RECOMMENDED\n      |  that a TURN server implement a randomized\
    \ port assignment\n      |  algorithm from [RFC6056].  This is especially applicable\
    \ to\n      |  servers that choose to pre-allocate a number of ports from the\n\
    \      |  underlying OS and then later assign them to allocations; for\n     \
    \ |  example, a server may choose this technique to implement the\n      |  EVEN-PORT\
    \ attribute.\n   The server determines the initial value of the time-to-expiry\
    \ field\n   as follows.  If the request contains a LIFETIME attribute, then the\n\
    \   server computes the minimum of the client's proposed lifetime and the\n  \
    \ server's maximum allowed lifetime.  If this computed value is greater\n   than\
    \ the default lifetime, then the server uses the computed lifetime\n   as the\
    \ initial value of the time-to-expiry field.  Otherwise, the\n   server uses the\
    \ default lifetime.  It is RECOMMENDED that the server\n   use a maximum allowed\
    \ lifetime value of no more than 3600 seconds (1\n   hour).  Servers that implement\
    \ allocation quotas or charge users for\n   allocations in some way may wish to\
    \ use a smaller maximum allowed\n   lifetime (perhaps as small as the default\
    \ lifetime) to more quickly\n   remove orphaned allocations (that is, allocations\
    \ where the\n   corresponding client has crashed or terminated, or the client\n\
    \   connection has been lost for some reason).  Also, note that the time-\n  \
    \ to-expiry is recomputed with each successful Refresh request, and\n   thus,\
    \ the value computed here applies only until the first refresh.\n   Once the allocation\
    \ is created, the server replies with a success\n   response.  The success response\
    \ contains:\n   *  An XOR-RELAYED-ADDRESS attribute containing the relayed transport\n\
    \      address or two XOR-RELAYED-ADDRESS attributes containing the\n      relayed\
    \ transport addresses.\n   *  A LIFETIME attribute containing the current value\
    \ of the time-to-\n      expiry timer.\n   *  A RESERVATION-TOKEN attribute (if\
    \ a second relayed transport\n      address was reserved).\n   *  An XOR-MAPPED-ADDRESS\
    \ attribute containing the client's IP address\n      and port (from the 5-tuple).\n\
    \      |  NOTE: The XOR-MAPPED-ADDRESS attribute is included in the\n      | \
    \ response as a convenience to the client.  TURN itself does not\n      |  make\
    \ use of this value, but clients running ICE can often need\n      |  this value\
    \ and can thus avoid having to do an extra Binding\n      |  transaction with\
    \ some STUN server to learn it.\n   The response (either success or error) is\
    \ sent back to the client on\n   the 5-tuple.\n      |  NOTE: When the Allocate\
    \ request is sent over UDP, [RFC8489]\n      |  requires that the server handle\
    \ the possible retransmissions of\n      |  the request so that retransmissions\
    \ do not cause multiple\n      |  allocations to be created.  Implementations\
    \ may achieve this\n      |  using the so-called \"stateless stack approach\"\
    \ as follows.  To\n      |  detect retransmissions when the original request was\
    \ successful\n      |  in creating an allocation, the server can store the transaction\n\
    \      |  id that created the request with the allocation data and\n      |  compare\
    \ it with incoming Allocate requests on the same 5-tuple.\n      |  Once such\
    \ a request is detected, the server can stop parsing\n      |  the request and\
    \ immediately generate a success response.  When\n      |  building this response,\
    \ the value of the LIFETIME attribute can\n      |  be taken from the time-to-expiry\
    \ field in the allocate state\n      |  data, even though this value may differ\
    \ slightly from the\n      |  LIFETIME value originally returned.  In addition,\
    \ the server\n      |  may need to store an indication of any reservation token\n\
    \      |  returned in the original response so that this may be returned\n   \
    \   |  in any retransmitted responses.\n      |  \n      |  For the case where\
    \ the original request was unsuccessful in\n      |  creating an allocation, the\
    \ server may choose to do nothing\n      |  special.  Note, however, that there\
    \ is a rare case where the\n      |  server rejects the original request but accepts\
    \ the\n      |  retransmitted request (because conditions have changed in the\n\
    \      |  brief intervening time period).  If the client receives the\n      |\
    \  first failure response, it will ignore the second (success)\n      |  response\
    \ and believe that an allocation was not created.  An\n      |  allocation created\
    \ in this manner will eventually time out\n      |  since the client will not\
    \ refresh it.  Furthermore, if the\n      |  client later retries with the same\
    \ 5-tuple but a different\n      |  transaction id, it will receive a 437 (Allocation\
    \ Mismatch)\n      |  error response, which will cause it to retry with a different\n\
    \      |  5-tuple.  The server may use a smaller maximum lifetime value\n    \
    \  |  to minimize the lifetime of allocations \"orphaned\" in this\n      |  manner.\n"
- title: 7.3.  Receiving an Allocate Success Response
  contents:
  - "7.3.  Receiving an Allocate Success Response\n   If the client receives an Allocate\
    \ success response, then it MUST\n   check that the mapped address and the relayed\
    \ transport address or\n   addresses are part of an address family or families\
    \ that the client\n   understands and is prepared to handle.  If these addresses\
    \ are not\n   part of an address family or families that the client is prepared\
    \ to\n   handle, then the client MUST delete the allocation (Section 8) and\n\
    \   MUST NOT attempt to create another allocation on that server until it\n  \
    \ believes the mismatch has been fixed.\n   Otherwise, the client creates its\
    \ own copy of the allocation data\n   structure to track what is happening on\
    \ the server.  In particular,\n   the client needs to remember the actual lifetime\
    \ received back from\n   the server, rather than the value sent to the server\
    \ in the request.\n   The client must also remember the 5-tuple used for the request\
    \ and\n   the username and password it used to authenticate the request to\n \
    \  ensure that it reuses them for subsequent messages.  The client also\n   needs\
    \ to track the channels and permissions it establishes on the\n   server.\n  \
    \ If the client receives an Allocate success response but with an\n   ADDRESS-ERROR-CODE\
    \ attribute in the response and the error code value\n   signaled in the ADDRESS-ERROR-CODE\
    \ attribute is 440 (Address Family\n   not Supported), the client MUST NOT retry\
    \ its request for the\n   rejected address type.  If the client receives an ADDRESS-ERROR-CODE\n\
    \   attribute in the response and the error code value signaled in the\n   ADDRESS-ERROR-CODE\
    \ attribute is 508 (Insufficient Capacity), the\n   client SHOULD wait at least\
    \ 1 minute before trying to request any\n   more allocations on this server for\
    \ the rejected address type.\n   The client will probably wish to send the relayed\
    \ transport address\n   to peers (using some method not specified here) so the\
    \ peers can\n   communicate with it.  The client may also wish to use the server-\n\
    \   reflexive address it receives in the XOR-MAPPED-ADDRESS attribute in\n   its\
    \ ICE processing.\n"
- title: 7.4.  Receiving an Allocate Error Response
  contents:
  - "7.4.  Receiving an Allocate Error Response\n   If the client receives an Allocate\
    \ error response, then the\n   processing depends on the actual error code returned:\n\
    \   408 (Request timed out):\n      There is either a problem with the server\
    \ or a problem reaching\n      the server with the chosen transport.  The client\
    \ considers the\n      current transaction as having failed but MAY choose to\
    \ retry the\n      Allocate request using a different transport (e.g., TCP instead\
    \ of\n      UDP).\n   300 (Try Alternate):\n      The server would like the client\
    \ to use the server specified in\n      the ALTERNATE-SERVER attribute instead.\
    \  The client considers the\n      current transaction as having failed, but it\
    \ SHOULD try the\n      Allocate request with the alternate server before trying\
    \ any other\n      servers (e.g., other servers discovered using the DNS resolution\n\
    \      procedures).  When trying the Allocate request with the alternate\n   \
    \   server, the client follows the ALTERNATE-SERVER procedures\n      specified\
    \ in [RFC8489].\n   400 (Bad Request):\n      The server believes the client's\
    \ request is malformed for some\n      reason.  The client considers the current\
    \ transaction as having\n      failed.  The client MAY notify the user or operator\
    \ and SHOULD NOT\n      retry the request with this server until it believes the\
    \ problem\n      has been fixed.\n   401 (Unauthorized):\n      If the client\
    \ has followed the procedures of the long-term\n      credential mechanism and\
    \ still gets this error, then the server is\n      not accepting the client's\
    \ credentials.  In this case, the client\n      considers the current transaction\
    \ as having failed and SHOULD\n      notify the user or operator.  The client\
    \ SHOULD NOT send any\n      further requests to this server until it believes\
    \ the problem has\n      been fixed.\n   403 (Forbidden):\n      The request is\
    \ valid, but the server is refusing to perform it,\n      likely due to administrative\
    \ restrictions.  The client considers\n      the current transaction as having\
    \ failed.  The client MAY notify\n      the user or operator and SHOULD NOT retry\
    \ the same request with\n      this server until it believes the problem has been\
    \ fixed.\n   420 (Unknown Attribute):\n      If the client included a DONT-FRAGMENT\
    \ attribute in the request\n      and the server rejected the request with a 420\
    \ error code and\n      listed the DONT-FRAGMENT attribute in the UNKNOWN-ATTRIBUTES\n\
    \      attribute in the error response, then the client now knows that\n     \
    \ the server does not support the DONT-FRAGMENT attribute.  The\n      client\
    \ considers the current transaction as having failed but MAY\n      choose to\
    \ retry the Allocate request without the DONT-FRAGMENT\n      attribute.\n   437\
    \ (Allocation Mismatch):\n      This indicates that the client has picked a 5-tuple\
    \ that the\n      server sees as already in use.  One way this could happen is\
    \ if an\n      intervening NAT assigned a mapped transport address that was used\n\
    \      by another client that recently crashed.  The client considers the\n  \
    \    current transaction as having failed.  The client SHOULD pick\n      another\
    \ client transport address and retry the Allocate request\n      (using a different\
    \ transaction id).  The client SHOULD try three\n      different client transport\
    \ addresses before giving up on this\n      server.  Once the client gives up\
    \ on the server, it SHOULD NOT try\n      to create another allocation on the\
    \ server for 2 minutes.\n   438 (Stale Nonce):\n      See the procedures for the\
    \ long-term credential mechanism\n      [RFC8489].\n   440 (Address Family not\
    \ Supported):\n      The server does not support the address family requested\
    \ by the\n      client.  If the client receives an Allocate error response with\n\
    \      the 440 (Address Family not Supported) error code, the client MUST\n  \
    \    NOT retry the request.\n   441 (Wrong Credentials):\n      The client should\
    \ not receive this error in response to an\n      Allocate request.  The client\
    \ MAY notify the user or operator and\n      SHOULD NOT retry the same request\
    \ with this server until it\n      believes the problem has been fixed.\n   442\
    \ (Unsupported Transport Address):\n      The client should not receive this error\
    \ in response to a request\n      for a UDP allocation.  The client MAY notify\
    \ the user or operator\n      and SHOULD NOT reattempt the request with this server\
    \ until it\n      believes the problem has been fixed.\n   486 (Allocation Quota\
    \ Reached):\n      The server is currently unable to create any more allocations\
    \ with\n      this username.  The client considers the current transaction as\n\
    \      having failed.  The client SHOULD wait at least 1 minute before\n     \
    \ trying to create any more allocations on the server.\n   508 (Insufficient Capacity):\n\
    \      The server has no more relayed transport addresses available or\n     \
    \ has none with the requested properties, or the one that was\n      reserved\
    \ is no longer available.  The client considers the current\n      operation as\
    \ having failed.  If the client is using either the\n      EVEN-PORT or the RESERVATION-TOKEN\
    \ attribute, then the client MAY\n      choose to remove or modify this attribute\
    \ and try again\n      immediately.  Otherwise, the client SHOULD wait at least\
    \ 1 minute\n      before trying to create any more allocations on this server.\n\
    \   Note that the error code values 486 and 508 indicate to a\n   eavesdropper\
    \ that several other users are using the server at this\n   time, similar to that\
    \ of the HTTP error response code 503, but it\n   does not reveal any information\
    \ about the users using the TURN\n   server.\n   An unknown error response MUST\
    \ be handled as described in [RFC8489].\n"
- title: 8.  Refreshing an Allocation
  contents:
  - "8.  Refreshing an Allocation\n   A Refresh transaction can be used to either\
    \ (a) refresh an existing\n   allocation and update its time-to-expiry or (b)\
    \ delete an existing\n   allocation.\n   If a client wishes to continue using\
    \ an allocation, then the client\n   MUST refresh it before it expires.  It is\
    \ suggested that the client\n   refresh the allocation roughly 1 minute before\
    \ it expires.  If a\n   client no longer wishes to use an allocation, then it\
    \ SHOULD\n   explicitly delete the allocation.  A client MAY refresh an allocation\n\
    \   at any time for other reasons.\n"
- title: 8.1.  Sending a Refresh Request
  contents:
  - "8.1.  Sending a Refresh Request\n   If the client wishes to immediately delete\
    \ an existing allocation, it\n   includes a LIFETIME attribute with a value of\
    \ zero.  All other forms\n   of the request refresh the allocation.\n   When refreshing\
    \ a dual allocation, the client includes a REQUESTED-\n   ADDRESS-FAMILY attribute\
    \ indicating the address family type that\n   should be refreshed.  If no REQUESTED-ADDRESS-FAMILY\
    \ attribute is\n   included, then the request should be treated as applying to\
    \ all\n   current allocations.  The client MUST only include a family type it\n\
    \   previously allocated and has not yet deleted.  This process can also\n   be\
    \ used to delete an allocation of a specific address type by setting\n   the lifetime\
    \ of that Refresh request to zero.  Deleting a single\n   allocation destroys\
    \ any permissions or channels associated with that\n   particular allocation;\
    \ it MUST NOT affect any permissions or channels\n   associated with allocations\
    \ for the other address family.\n   The Refresh transaction updates the time-to-expiry\
    \ timer of an\n   allocation.  If the client wishes the server to set the time-to-\n\
    \   expiry timer to something other than the default lifetime, it\n   includes\
    \ a LIFETIME attribute with the requested value.  The server\n   then computes\
    \ a new time-to-expiry value in the same way as it does\n   for an Allocate transaction,\
    \ with the exception that a requested\n   lifetime of zero causes the server to\
    \ immediately delete the\n   allocation.\n"
- title: 8.2.  Receiving a Refresh Request
  contents:
  - "8.2.  Receiving a Refresh Request\n   When the server receives a Refresh request,\
    \ it processes the request\n   as per Section 5 plus the specific rules mentioned\
    \ here.\n   If the server receives a Refresh Request with a REQUESTED-ADDRESS-\n\
    \   FAMILY attribute and the attribute value does not match the address\n   family\
    \ of the allocation, the server MUST reply with a 443 (Peer\n   Address Family\
    \ Mismatch) Refresh error response.\n   The server computes a value called the\
    \ \"desired lifetime\" as follows:\n   if the request contains a LIFETIME attribute\
    \ and the attribute value\n   is zero, then the \"desired lifetime\" is zero.\
    \  Otherwise, if the\n   request contains a LIFETIME attribute, then the server\
    \ computes the\n   minimum of the client's requested lifetime and the server's\
    \ maximum\n   allowed lifetime.  If this computed value is greater than the default\n\
    \   lifetime, then the \"desired lifetime\" is the computed value.\n   Otherwise,\
    \ the \"desired lifetime\" is the default lifetime.\n   Subsequent processing\
    \ depends on the \"desired lifetime\" value:\n   *  If the \"desired lifetime\"\
    \ is zero, then the request succeeds and\n      the allocation is deleted.\n \
    \  *  If the \"desired lifetime\" is non-zero, then the request succeeds\n   \
    \   and the allocation's time-to-expiry is set to the \"desired\n      lifetime\"\
    .\n   If the request succeeds, then the server sends a success response\n   containing:\n\
    \   *  A LIFETIME attribute containing the current value of the time-to-\n   \
    \   expiry timer.\n      |  NOTE: A server need not do anything special to implement\n\
    \      |  idempotency of Refresh requests over UDP using the \"stateless\n   \
    \   |  stack approach\".  Retransmitted Refresh requests with a non-\n      |\
    \  zero \"desired lifetime\" will simply refresh the allocation.  A\n      | \
    \ retransmitted Refresh request with a zero \"desired lifetime\"\n      |  will\
    \ cause a 437 (Allocation Mismatch) response if the\n      |  allocation has already\
    \ been deleted, but the client will treat\n      |  this as equivalent to a success\
    \ response (see below).\n"
- title: 8.3.  Receiving a Refresh Response
  contents:
  - "8.3.  Receiving a Refresh Response\n   If the client receives a success response\
    \ to its Refresh request with\n   a non-zero lifetime, it updates its copy of\
    \ the allocation data\n   structure with the time-to-expiry value contained in\
    \ the response.\n   If the client receives a 437 (Allocation Mismatch) error response\
    \ to\n   its request to refresh the allocation, it should consider the\n   allocation\
    \ no longer exists.  If the client receives a 438 (Stale\n   Nonce) error to its\
    \ request to refresh the allocation, it should\n   reattempt the request with\
    \ the new nonce value.\n   If the client receives a 437 (Allocation Mismatch)\
    \ error response to\n   a request to delete the allocation, then the allocation\
    \ no longer\n   exists and it should consider its request as having effectively\n\
    \   succeeded.\n"
- title: 9.  Permissions
  contents:
  - "9.  Permissions\n   For each allocation, the server keeps a list of zero or more\n\
    \   permissions.  Each permission consists of an IP address and an\n   associated\
    \ time-to-expiry.  While a permission exists, all peers\n   using the IP address\
    \ in the permission are allowed to send data to\n   the client.  The time-to-expiry\
    \ is the number of seconds until the\n   permission expires.  Within the context\
    \ of an allocation, a\n   permission is uniquely identified by its associated\
    \ IP address.\n   By sending either CreatePermission requests or ChannelBind requests,\n\
    \   the client can cause the server to install or refresh a permission\n   for\
    \ a given IP address.  This causes one of two things to happen:\n   *  If no permission\
    \ for that IP address exists, then a permission is\n      created with the given\
    \ IP address and a time-to-expiry equal to\n      Permission Lifetime.\n   * \
    \ If a permission for that IP address already exists, then the time-\n      to-expiry\
    \ for that permission is reset to Permission Lifetime.\n   The Permission Lifetime\
    \ MUST be 300 seconds (= 5 minutes).\n   Each permission's time-to-expiry decreases\
    \ down once per second until\n   it reaches zero, at which point, the permission\
    \ expires and is\n   deleted.\n   CreatePermission and ChannelBind requests may\
    \ be freely intermixed on\n   a permission.  A given permission may be initially\
    \ installed and/or\n   refreshed with a CreatePermission request and then later\
    \ refreshed\n   with a ChannelBind request, or vice versa.\n   When a UDP datagram\
    \ arrives at the relayed transport address for the\n   allocation, the server\
    \ extracts the source IP address from the IP\n   header.  The server then compares\
    \ this address with the IP address\n   associated with each permission in the\
    \ list of permissions for the\n   allocation.  Note that only addresses are compared\
    \ and port numbers\n   are not considered.  If no match is found, relaying is\
    \ not permitted\n   and the server silently discards the UDP datagram.  If an\
    \ exact match\n   is found, the permission check is considered to have succeeded\
    \ and\n   the server continues to process the UDP datagram as specified\n   elsewhere\
    \ (Section 11.3).\n   The permissions for one allocation are totally unrelated\
    \ to the\n   permissions for a different allocation.  If an allocation expires,\n\
    \   all its permissions expire with it.\n      |  NOTE: Though TURN permissions\
    \ expire after 5 minutes, many NATs\n      |  deployed at the time of publication\
    \ expire their UDP bindings\n      |  considerably faster.  Thus, an application\
    \ using TURN will\n      |  probably wish to send some sort of keep-alive traffic\
    \ at a much\n      |  faster rate.  Applications using ICE should follow the keep-\n\
    \      |  alive guidelines of ICE [RFC8445], and applications not using\n    \
    \  |  ICE are advised to do something similar.\n"
- title: 10.  CreatePermission
  contents:
  - "10.  CreatePermission\n   TURN supports two ways for the client to install or\
    \ refresh\n   permissions on the server.  This section describes one way: the\n\
    \   CreatePermission request.\n   A CreatePermission request may be used in conjunction\
    \ with either the\n   Send mechanism in Section 11 or the Channel mechanism in\
    \ Section 12.\n"
- title: 10.1.  Forming a CreatePermission Request
  contents:
  - "10.1.  Forming a CreatePermission Request\n   The client who wishes to install\
    \ or refresh one or more permissions\n   can send a CreatePermission request to\
    \ the server.\n   When forming a CreatePermission request, the client MUST include\
    \ at\n   least one XOR-PEER-ADDRESS attribute and MAY include more than one\n\
    \   such attribute.  The IP address portion of each XOR-PEER-ADDRESS\n   attribute\
    \ contains the IP address for which a permission should be\n   installed or refreshed.\
    \  The port portion of each XOR-PEER-ADDRESS\n   attribute will be ignored and\
    \ can be any arbitrary value.  The\n   various XOR-PEER-ADDRESS attributes MAY\
    \ appear in any order.  The\n   client MUST only include XOR-PEER-ADDRESS attributes\
    \ with addresses\n   of the same address family as that of the relayed transport\
    \ address\n   for the allocation.  For dual allocations obtained using the\n \
    \  ADDITIONAL-ADDRESS-FAMILY attribute, the client MAY include XOR-PEER-\n   ADDRESS\
    \ attributes with addresses of IPv4 and IPv6 address families.\n"
- title: 10.2.  Receiving a CreatePermission Request
  contents:
  - "10.2.  Receiving a CreatePermission Request\n   When the server receives the\
    \ CreatePermission request, it processes\n   as per Section 5 plus the specific\
    \ rules mentioned here.\n   The message is checked for validity.  The CreatePermission\
    \ request\n   MUST contain at least one XOR-PEER-ADDRESS attribute and MAY contain\n\
    \   multiple such attributes.  If no such attribute exists, or if any of\n   these\
    \ attributes are invalid, then a 400 (Bad Request) error is\n   returned.  If\
    \ the request is valid, but the server is unable to\n   satisfy the request due\
    \ to some capacity limit or similar, then a 508\n   (Insufficient Capacity) error\
    \ is returned.\n   If an XOR-PEER-ADDRESS attribute contains an address of an\
    \ address\n   family that is not the same as that of a relayed transport address\n\
    \   for the allocation, the server MUST generate an error response with\n   the\
    \ 443 (Peer Address Family Mismatch) response code.\n   The server MAY impose\
    \ restrictions on the IP address allowed in the\n   XOR-PEER-ADDRESS attribute;\
    \ if a value is not allowed, the server\n   rejects the request with a 403 (Forbidden)\
    \ error.\n   If the message is valid and the server is capable of carrying out\
    \ the\n   request, then the server installs or refreshes a permission for the\n\
    \   IP address contained in each XOR-PEER-ADDRESS attribute as described\n   in\
    \ Section 9.  The port portion of each attribute is ignored and may\n   be any\
    \ arbitrary value.\n   The server then responds with a CreatePermission success\
    \ response.\n   There are no mandatory attributes in the success response.\n \
    \     |  NOTE: A server need not do anything special to implement\n      |  idempotency\
    \ of CreatePermission requests over UDP using the\n      |  \"stateless stack\
    \ approach\".  Retransmitted CreatePermission\n      |  requests will simply refresh\
    \ the permissions.\n"
- title: 10.3.  Receiving a CreatePermission Response
  contents:
  - "10.3.  Receiving a CreatePermission Response\n   If the client receives a valid\
    \ CreatePermission success response,\n   then the client updates its data structures\
    \ to indicate that the\n   permissions have been installed or refreshed.\n"
- title: 11.  Send and Data Methods
  contents:
  - "11.  Send and Data Methods\n   TURN supports two mechanisms for sending and receiving\
    \ data from\n   peers.  This section describes the use of the Send and Data\n\
    \   mechanisms, while Section 12 describes the use of the Channel\n   mechanism.\n"
- title: 11.1.  Forming a Send Indication
  contents:
  - "11.1.  Forming a Send Indication\n   The client can use a Send indication to\
    \ pass data to the server for\n   relaying to a peer.  A client may use a Send\
    \ indication even if a\n   channel is bound to that peer.  However, the client\
    \ MUST ensure that\n   there is a permission installed for the IP address of the\
    \ peer to\n   which the Send indication is being sent; this prevents a third party\n\
    \   from using a TURN server to send data to arbitrary destinations.\n   When\
    \ forming a Send indication, the client MUST include an XOR-PEER-\n   ADDRESS\
    \ attribute and a DATA attribute.  The XOR-PEER-ADDRESS\n   attribute contains\
    \ the transport address of the peer to which the\n   data is to be sent, and the\
    \ DATA attribute contains the actual\n   application data to be sent to the peer.\n\
    \   The client MAY include a DONT-FRAGMENT attribute in the Send\n   indication\
    \ if it wishes the server to set the DF bit on the UDP\n   datagram sent to the\
    \ peer.\n"
- title: 11.2.  Receiving a Send Indication
  contents:
  - "11.2.  Receiving a Send Indication\n   When the server receives a Send indication,\
    \ it processes as per\n   Section 5 plus the specific rules mentioned here.\n\
    \   The message is first checked for validity.  The Send indication MUST\n   contain\
    \ both an XOR-PEER-ADDRESS attribute and a DATA attribute.  If\n   one of these\
    \ attributes is missing or invalid, then the message is\n   discarded.  Note that\
    \ the DATA attribute is allowed to contain zero\n   bytes of data.\n   The Send\
    \ indication may also contain the DONT-FRAGMENT attribute.  If\n   the server\
    \ is unable to set the DF bit on outgoing UDP datagrams when\n   this attribute\
    \ is present, then the server acts as if the DONT-\n   FRAGMENT attribute is an\
    \ unknown comprehension-required attribute\n   (and thus the Send indication is\
    \ discarded).\n   The server also checks that there is a permission installed\
    \ for the\n   IP address contained in the XOR-PEER-ADDRESS attribute.  If no such\n\
    \   permission exists, the message is discarded.  Note that a Send\n   indication\
    \ never causes the server to refresh the permission.\n   The server MAY impose\
    \ restrictions on the IP address and port values\n   allowed in the XOR-PEER-ADDRESS\
    \ attribute; if a value is not allowed,\n   the server silently discards the Send\
    \ indication.\n   If everything is OK, then the server forms a UDP datagram as\
    \ follows:\n   *  the source transport address is the relayed transport address\
    \ of\n      the allocation, where the allocation is determined by the 5-tuple\n\
    \      on which the Send indication arrived;\n   *  the destination transport\
    \ address is taken from the XOR-PEER-\n      ADDRESS attribute;\n   *  the data\
    \ following the UDP header is the contents of the value\n      field of the DATA\
    \ attribute.\n   The handling of the DONT-FRAGMENT attribute (if present), is\n\
    \   described in Sections 14 and 15.\n   The resulting UDP datagram is then sent\
    \ to the peer.\n"
- title: 11.3.  Receiving a UDP Datagram
  contents:
  - "11.3.  Receiving a UDP Datagram\n   When the server receives a UDP datagram at\
    \ a currently allocated\n   relayed transport address, the server looks up the\
    \ allocation\n   associated with the relayed transport address.  The server then\n\
    \   checks to see whether the set of permissions for the allocation allow\n  \
    \ the relaying of the UDP datagram as described in Section 9.\n   If relaying\
    \ is permitted, then the server checks if there is a\n   channel bound to the\
    \ peer that sent the UDP datagram (see\n   Section 12).  If a channel is bound,\
    \ then processing proceeds as\n   described in Section 12.7.\n   If relaying is\
    \ permitted but no channel is bound to the peer, then\n   the server forms and\
    \ sends a Data indication.  The Data indication\n   MUST contain both an XOR-PEER-ADDRESS\
    \ and a DATA attribute.  The DATA\n   attribute is set to the value of the \"\
    data octets\" field from the\n   datagram, and the XOR-PEER-ADDRESS attribute\
    \ is set to the source\n   transport address of the received UDP datagram.  The\
    \ Data indication\n   is then sent on the 5-tuple associated with the allocation.\n"
- title: 11.4.  Receiving a Data Indication
  contents:
  - "11.4.  Receiving a Data Indication\n   When the client receives a Data indication,\
    \ it checks that the Data\n   indication contains an XOR-PEER-ADDRESS attribute\
    \ and discards the\n   indication if it does not.  The client SHOULD also check\
    \ that the\n   XOR-PEER-ADDRESS attribute value contains an IP address with which\n\
    \   the client believes there is an active permission and discard the\n   Data\
    \ indication otherwise.\n      |  NOTE: The latter check protects the client against\
    \ an attacker\n      |  who somehow manages to trick the server into installing\n\
    \      |  permissions not desired by the client.\n   If the XOR-PEER-ADDRESS is\
    \ present and valid, the client checks that\n   the Data indication contains either\
    \ a DATA attribute or an ICMP\n   attribute and discards the indication if it\
    \ does not.  Note that a\n   DATA attribute is allowed to contain zero bytes of\
    \ data.  Processing\n   of Data indications with an ICMP attribute is described\
    \ in\n   Section 11.6.\n   If the Data indication passes the above checks, the\
    \ client delivers\n   the data octets inside the DATA attribute to the application,\
    \ along\n   with an indication that they were received from the peer whose\n \
    \  transport address is given by the XOR-PEER-ADDRESS attribute.\n"
- title: 11.5.  Receiving an ICMP Packet
  contents:
  - "11.5.  Receiving an ICMP Packet\n   When the server receives an ICMP packet,\
    \ the server verifies that the\n   type is either 3 or 11 for an ICMPv4 [RFC0792]\
    \ packet or either 1, 2,\n   or 3 for an ICMPv6 [RFC4443] packet.  It also verifies\
    \ that the IP\n   packet in the ICMP packet payload contains a UDP header.  If\
    \ either\n   of these conditions fail, then the ICMP packet is silently dropped.\n\
    \   If a UDP header is present, the server extracts the source and\n   destination\
    \ IP address and UDP port information.\n   The server looks up the allocation\
    \ whose relayed transport address\n   corresponds to the encapsulated packet's\
    \ source IP address and UDP\n   port.  If no such allocation exists, the packet\
    \ is silently dropped.\n   The server then checks to see whether the set of permissions\
    \ for the\n   allocation allows the relaying of the ICMP packet.  For ICMP packets,\n\
    \   the source IP address MUST NOT be checked against the permissions\n   list\
    \ as it would be for UDP packets.  Instead, the server extracts\n   the destination\
    \ IP address from the encapsulated IP header.  The\n   server then compares this\
    \ address with the IP address associated with\n   each permission in the list\
    \ of permissions for the allocation.  If no\n   match is found, relaying is not\
    \ permitted and the server silently\n   discards the ICMP packet.  Note that only\
    \ addresses are compared and\n   port numbers are not considered.\n   If relaying\
    \ is permitted, then the server forms and sends a Data\n   indication.  The Data\
    \ indication MUST contain both an XOR-PEER-\n   ADDRESS and an ICMP attribute.\
    \  The ICMP attribute is set to the\n   value of the type and code fields from\
    \ the ICMP packet.  The IP\n   address portion of XOR-PEER-ADDRESS attribute is\
    \ set to the\n   destination IP address in the encapsulated IP header.  At the\
    \ time of\n   writing of this specification, Socket APIs on some operating systems\n\
    \   do not deliver the destination port in the encapsulated UDP header to\n  \
    \ applications without superuser privileges.  If destination port in\n   the encapsulated\
    \ UDP header is available to the server, then the port\n   portion of the XOR-PEER-ADDRESS\
    \ attribute is set to the destination\n   port; otherwise, the port portion is\
    \ set to zero.  The Data\n   indication is then sent on the 5-tuple associated\
    \ with the\n   allocation.\n      |  Implementation Note: New ICMP types or codes\
    \ can be defined in\n      |  future specifications.  If the server receives an\
    \ ICMP error\n      |  packet, and the new type or code field can help the client\
    \ to\n      |  make use of the ICMP error notification and generate feedback\n\
    \      |  to the application layer, the server sends the Data indication\n   \
    \   |  with an ICMP attribute conveying the new ICMP type or code.\n"
- title: 11.6.  Receiving a Data Indication with an ICMP Attribute
  contents:
  - "11.6.  Receiving a Data Indication with an ICMP Attribute\n   When the client\
    \ receives a Data indication with an ICMP attribute, it\n   checks that the Data\
    \ indication contains an XOR-PEER-ADDRESS\n   attribute and discards the indication\
    \ if it does not.  The client\n   SHOULD also check that the XOR-PEER-ADDRESS\
    \ attribute value contains\n   an IP address with an active permission and discard\
    \ the Data\n   indication otherwise.\n   If the Data indication passes the above\
    \ checks, the client signals\n   the application of the error condition along\
    \ with an indication that\n   it was received from the peer whose transport address\
    \ is given by the\n   XOR-PEER-ADDRESS attribute.  The application can make sense\
    \ of the\n   meaning of the type and code values in the ICMP attribute by using\n\
    \   the family field in the XOR-PEER-ADDRESS attribute.\n"
- title: 12.  Channels
  contents:
  - "12.  Channels\n   Channels provide a way for the client and server to send application\n\
    \   data using ChannelData messages, which have less overhead than Send\n   and\
    \ Data indications.\n   The ChannelData message (see Section 12.4) starts with\
    \ a two-byte\n   field that carries the channel number.  The values of this field\
    \ are\n   allocated as follows:\n     | 0x0000 through 0x3FFF: | These values\
    \ can never be used for   |\n     | 0x4000 through 0x4FFF: | These values are\
    \ the allowed channel |\n     | 0x5000 through 0xFFFF: | Reserved (For DTLS-SRTP\
    \ multiplexing |\n   Note that the channel number range is not backwards compatible\
    \ with\n   [RFC5766], which could prevent a client compliant with RFC 5766 from\n\
    \   establishing channel bindings with a TURN server that complies with\n   this\
    \ specification.\n   According to [RFC7983], ChannelData messages can be distinguished\n\
    \   from other multiplexed protocols by examining the first byte of the\n   message:\n\
    \   | [0..3]     |                         STUN                         |\n  \
    \ | [16..19]   |                         ZRTP                         |\n   |\
    \ [20..63]   |                         DTLS                         |\n   | [64..79]\
    \   |                     TURN Channel                     |\n   | [128..191]\
    \ |                       RTP/RTCP                       |\n   | Others     |\
    \              Reserved; MUST be dropped               |\n   |            |  \
    \            and an alert MAY be logged              |\n   Reserved values may\
    \ be used in the future by other protocols.  When\n   the client uses channel\
    \ binding, it MUST comply with the\n   demultiplexing scheme discussed above.\n\
    \   Channel bindings are always initiated by the client.  The client can\n   bind\
    \ a channel to a peer at any time during the lifetime of the\n   allocation. \
    \ The client may bind a channel to a peer before\n   exchanging data with it or\
    \ after exchanging data with it (using Send\n   and Data indications) for some\
    \ time, or may choose never to bind a\n   channel to it.  The client can also\
    \ bind channels to some peers while\n   not binding channels to other peers.\n\
    \   Channel bindings are specific to an allocation so that the use of a\n   channel\
    \ number or peer transport address in a channel binding in one\n   allocation\
    \ has no impact on their use in a different allocation.  If\n   an allocation\
    \ expires, all its channel bindings expire with it.\n   A channel binding consists\
    \ of:\n   *  a channel number;\n   *  a transport address (of the peer); and\n\
    \   *  A time-to-expiry timer.\n   Within the context of an allocation, a channel\
    \ binding is uniquely\n   identified either by the channel number or by the peer's\
    \ transport\n   address.  Thus, the same channel cannot be bound to two different\n\
    \   transport addresses, nor can the same transport address be bound to\n   two\
    \ different channels.\n   A channel binding lasts for 10 minutes unless refreshed.\
    \  Refreshing\n   the binding (by the server receiving a ChannelBind request rebinding\n\
    \   the channel to the same peer) resets the time-to-expiry timer back to\n  \
    \ 10 minutes.\n   When the channel binding expires, the channel becomes unbound.\
    \  Once\n   unbound, the channel number can be bound to a different transport\n\
    \   address, and the transport address can be bound to a different\n   channel\
    \ number.  To prevent race conditions, the client MUST wait 5\n   minutes after\
    \ the channel binding expires before attempting to bind\n   the channel number\
    \ to a different transport address or the transport\n   address to a different\
    \ channel number.\n   When binding a channel to a peer, the client SHOULD be prepared\
    \ to\n   receive ChannelData messages on the channel from the server as soon\n\
    \   as it has sent the ChannelBind request.  Over UDP, it is possible for\n  \
    \ the client to receive ChannelData messages from the server before it\n   receives\
    \ a ChannelBind success response.\n   In the other direction, the client MAY elect\
    \ to send ChannelData\n   messages before receiving the ChannelBind success response.\
    \  Doing\n   so, however, runs the risk of having the ChannelData messages dropped\n\
    \   by the server if the ChannelBind request does not succeed for some\n   reason\
    \ (e.g., packet lost if the request is sent over UDP or the\n   server being unable\
    \ to fulfill the request).  A client that wishes to\n   be safe should either\
    \ queue the data or use Send indications until\n   the channel binding is confirmed.\n"
- title: 12.1.  Sending a ChannelBind Request
  contents:
  - "12.1.  Sending a ChannelBind Request\n   A channel binding is created or refreshed\
    \ using a ChannelBind\n   transaction.  A ChannelBind transaction also creates\
    \ or refreshes a\n   permission towards the peer (see Section 9).\n   To initiate\
    \ the ChannelBind transaction, the client forms a\n   ChannelBind request.  The\
    \ channel to be bound is specified in a\n   CHANNEL-NUMBER attribute, and the\
    \ peer's transport address is\n   specified in an XOR-PEER-ADDRESS attribute.\
    \  Section 12.2 describes\n   the restrictions on these attributes.  The client\
    \ MUST only include\n   an XOR-PEER-ADDRESS attribute with an address of the same\
    \ address\n   family as that of a relayed transport address for the allocation.\n\
    \   Rebinding a channel to the same transport address that it is already\n   bound\
    \ to provides a way to refresh a channel binding and the\n   corresponding permission\
    \ without sending data to the peer.  Note,\n   however, that permissions need\
    \ to be refreshed more frequently than\n   channels.\n"
- title: 12.2.  Receiving a ChannelBind Request
  contents:
  - "12.2.  Receiving a ChannelBind Request\n   When the server receives a ChannelBind\
    \ request, it processes as per\n   Section 5 plus the specific rules mentioned\
    \ here.\n   The server checks the following:\n   *  The request contains both\
    \ a CHANNEL-NUMBER and an XOR-PEER-ADDRESS\n      attribute;\n   *  The channel\
    \ number is in the range 0x4000 through 0x4FFF\n      (inclusive);\n   *  The\
    \ channel number is not currently bound to a different transport\n      address\
    \ (same transport address is OK);\n   *  The transport address is not currently\
    \ bound to a different\n      channel number.\n   If any of these tests fail,\
    \ the server replies with a 400 (Bad\n   Request) error.  If the XOR-PEER-ADDRESS\
    \ attribute contains an\n   address of an address family that is not the same\
    \ as that of a\n   relayed transport address for the allocation, the server MUST\n\
    \   generate an error response with the 443 (Peer Address Family\n   Mismatch)\
    \ response code.\n   The server MAY impose restrictions on the IP address and\
    \ port values\n   allowed in the XOR-PEER-ADDRESS attribute; if a value is not\
    \ allowed,\n   the server rejects the request with a 403 (Forbidden) error.\n\
    \   If the request is valid, but the server is unable to fulfill the\n   request\
    \ due to some capacity limit or similar, the server replies\n   with a 508 (Insufficient\
    \ Capacity) error.\n   Otherwise, the server replies with a ChannelBind success\
    \ response.\n   There are no required attributes in a successful ChannelBind\n\
    \   response.\n   If the server can satisfy the request, then the server creates\
    \ or\n   refreshes the channel binding using the channel number in the\n   CHANNEL-NUMBER\
    \ attribute and the transport address in the XOR-PEER-\n   ADDRESS attribute.\
    \  The server also installs or refreshes a\n   permission for the IP address in\
    \ the XOR-PEER-ADDRESS attribute as\n   described in Section 9.\n      |  NOTE:\
    \ A server need not do anything special to implement\n      |  idempotency of\
    \ ChannelBind requests over UDP using the\n      |  \"stateless stack approach\"\
    .  Retransmitted ChannelBind requests\n      |  will simply refresh the channel\
    \ binding and the corresponding\n      |  permission.  Furthermore, the client\
    \ must wait 5 minutes before\n      |  binding a previously bound channel number\
    \ or peer address to a\n      |  different channel, eliminating the possibility\
    \ that the\n      |  transaction would initially fail but succeed on a\n     \
    \ |  retransmission.\n"
- title: 12.3.  Receiving a ChannelBind Response
  contents:
  - "12.3.  Receiving a ChannelBind Response\n   When the client receives a ChannelBind\
    \ success response, it updates\n   its data structures to record that the channel\
    \ binding is now active.\n   It also updates its data structures to record that\
    \ the corresponding\n   permission has been installed or refreshed.\n   If the\
    \ client receives a ChannelBind failure response that indicates\n   that the channel\
    \ information is out of sync between the client and\n   the server (e.g., an unexpected\
    \ 400 \"Bad Request\" response), then it\n   is RECOMMENDED that the client immediately\
    \ delete the allocation and\n   start afresh with a new allocation.\n"
- title: 12.4.  The ChannelData Message
  contents:
  - "12.4.  The ChannelData Message\n   The ChannelData message is used to carry application\
    \ data between the\n   client and the server.  It has the following format:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   |         Channel\
    \ Number        |            Length             |\n   /                      \
    \ Application Data                        /\n   The Channel Number field specifies\
    \ the number of the channel on which\n   the data is traveling, and thus, the\
    \ address of the peer that is\n   sending or is to receive the data.\n   The Length\
    \ field specifies the length in bytes of the application\n   data field (i.e.,\
    \ it does not include the size of the ChannelData\n   header).  Note that 0 is\
    \ a valid length.\n   The Application Data field carries the data the client is\
    \ trying to\n   send to the peer, or that the peer is sending to the client.\n"
- title: 12.5.  Sending a ChannelData Message
  contents:
  - "12.5.  Sending a ChannelData Message\n   Once a client has bound a channel to\
    \ a peer, then when the client has\n   data to send to that peer, it may use either\
    \ a ChannelData message or\n   a Send indication; that is, the client is not obligated\
    \ to use the\n   channel when it exists and may freely intermix the two message\
    \ types\n   when sending data to the peer.  The server, on the other hand, MUST\n\
    \   use the ChannelData message if a channel has been bound to the peer.\n   The\
    \ server uses a Data indication to signal the XOR-PEER-ADDRESS and\n   ICMP attributes\
    \ to the client even if a channel has been bound to the\n   peer.\n   The fields\
    \ of the ChannelData message are filled in as described in\n   Section 12.4.\n\
    \   Over TCP and TLS-over-TCP, the ChannelData message MUST be padded to\n   a\
    \ multiple of four bytes in order to ensure the alignment of\n   subsequent messages.\
    \  The padding is not reflected in the length\n   field of the ChannelData message,\
    \ so the actual size of a ChannelData\n   message (including padding) is (4 +\
    \ Length) rounded up to the nearest\n   multiple of 4 (see Section 14 of [RFC8489]).\
    \  Over UDP, the padding\n   is not required but MAY be included.\n   The ChannelData\
    \ message is then sent on the 5-tuple associated with\n   the allocation.\n"
- title: 12.6.  Receiving a ChannelData Message
  contents:
  - "12.6.  Receiving a ChannelData Message\n   The receiver of the ChannelData message\
    \ uses the first byte to\n   distinguish it from other multiplexed protocols as\
    \ described in\n   Table 3.  If the message uses a value in the reserved range\
    \ (0x5000\n   through 0xFFFF), then the message is silently discarded.\n   If\
    \ the ChannelData message is received in a UDP datagram, and if the\n   UDP datagram\
    \ is too short to contain the claimed length of the\n   ChannelData message (i.e.,\
    \ the UDP header length field value is less\n   than the ChannelData header length\
    \ field value + 4 + 8), then the\n   message is silently discarded.\n   If the\
    \ ChannelData message is received over TCP or over TLS-over-TCP,\n   then the\
    \ actual length of the ChannelData message is as described in\n   Section 12.5.\n\
    \   If the ChannelData message is received on a channel that is not bound\n  \
    \ to any peer, then the message is silently discarded.\n   On the client, it is\
    \ RECOMMENDED that the client discard the\n   ChannelData message if the client\
    \ believes there is no active\n   permission towards the peer.  On the server,\
    \ the receipt of a\n   ChannelData message MUST NOT refresh either the channel\
    \ binding or\n   the permission towards the peer.\n   On the server, if no errors\
    \ are detected, the server relays the\n   application data to the peer by forming\
    \ a UDP datagram as follows:\n   *  the source transport address is the relayed\
    \ transport address of\n      the allocation, where the allocation is determined\
    \ by the 5-tuple\n      on which the ChannelData message arrived;\n   *  the destination\
    \ transport address is the transport address to\n      which the channel is bound;\n\
    \   *  the data following the UDP header is the contents of the data\n      field\
    \ of the ChannelData message.\n   The resulting UDP datagram is then sent to the\
    \ peer.  Note that if\n   the Length field in the ChannelData message is 0, then\
    \ there will be\n   no data in the UDP datagram, but the UDP datagram is still\
    \ formed and\n   sent (Section 4.1 of [RFC6263]).\n"
- title: 12.7.  Relaying Data from the Peer
  contents:
  - "12.7.  Relaying Data from the Peer\n   When the server receives a UDP datagram\
    \ on the relayed transport\n   address associated with an allocation, the server\
    \ processes it as\n   described in Section 11.3.  If that section indicates that\
    \ a\n   ChannelData message should be sent (because there is a channel bound\n\
    \   to the peer that sent to the UDP datagram), then the server forms and\n  \
    \ sends a ChannelData message as described in Section 12.5.\n   When the server\
    \ receives an ICMP packet, the server processes it as\n   described in Section\
    \ 11.5.\n"
- title: 13.  Packet Translations
  contents:
  - "13.  Packet Translations\n   This section addresses IPv4-to-IPv6, IPv6-to-IPv4,\
    \ and IPv6-to-IPv6\n   translations.  Requirements for translation of the IP addresses\
    \ and\n   port numbers of the packets are described above.  The following\n  \
    \ sections specify how to translate other header fields.\n   As discussed in Section\
    \ 3.6, translations in TURN are designed so\n   that a TURN server can be implemented\
    \ as an application that runs in\n   user space under commonly available operating\
    \ systems and that does\n   not require special privileges.  The translations\
    \ specified in the\n   following sections follow this principle.\n   The descriptions\
    \ below have two parts: a preferred behavior and an\n   alternate behavior.  The\
    \ server SHOULD implement the preferred\n   behavior, but if that is not possible\
    \ for a particular field, the\n   server MUST implement the alternate behavior\
    \ and MUST NOT do anything\n   else for the reasons detailed in [RFC7915].  The\
    \ TURN server solely\n   relies on the DF bit in the IPv4 header and the Fragment\
    \ header in\n   the IPv6 header to handle fragmentation using the approach described\n\
    \   in [RFC7915] and does not rely on the DONT-FRAGMENT attribute;\n   ignoring\
    \ the DONT-FRAGMENT attribute is only applicable for UDP-to-\n   UDP relay and\
    \ not for TCP-to-UDP relay.\n"
- title: 13.1.  IPv4-to-IPv6 Translations
  contents:
  - "13.1.  IPv4-to-IPv6 Translations\n   Time to Live (TTL) field\n      Preferred\
    \ Behavior: As specified in Section 4 of [RFC7915].\n      Alternate Behavior:\
    \ Set the outgoing value to the default for\n      outgoing packets.\n   Traffic\
    \ Class\n      Preferred behavior: As specified in Section 4 of [RFC7915].\n \
    \     Alternate behavior: The TURN server sets the Traffic Class to the\n    \
    \  default value for outgoing packets.\n   Flow Label\n      Preferred behavior:\
    \ The TURN server can use the 5-tuple of relayed\n      transport address, peer\
    \ transport address, and UDP protocol number\n      to identify each flow and\
    \ to generate and set the flow label value\n      in the IPv6 packet as discussed\
    \ in Section 3 of [RFC6437].  If the\n      TURN server is incapable of generating\
    \ the flow label value from\n      the IPv6 packet's 5-tuple, it sets the Flow\
    \ label to zero.\n      Alternate behavior: The alternate behavior is the same\
    \ as the\n      preferred behavior for a TURN server that does not support flow\n\
    \      labels.\n   Hop Limit\n      Preferred behavior: As specified in Section\
    \ 4 of [RFC7915].\n      Alternate behavior: The TURN server sets the Hop Limit\
    \ to the\n      default value for outgoing packets.\n   Fragmentation\n      Preferred\
    \ behavior: As specified in Section 4 of [RFC7915].\n      Alternate behavior:\
    \ The TURN server assembles incoming fragments.\n      The TURN server follows\
    \ its default behavior to send outgoing\n      packets.\n      For both preferred\
    \ and alternate behavior, the DONT-FRAGMENT\n      attribute MUST be ignored by\
    \ the server.\n   Extension Headers\n      Preferred behavior: The outgoing packet\
    \ uses the system defaults\n      for IPv6 extension headers, with the exception\
    \ of the Fragment\n      header as described above.\n      Alternate behavior:\
    \ Same as preferred.\n"
- title: 13.2.  IPv6-to-IPv6 Translations
  contents:
  - "13.2.  IPv6-to-IPv6 Translations\n   Flow Label\n   NOTE: The TURN server should\
    \ consider that it is handling two\n   different IPv6 flows.  Therefore, the Flow\
    \ label [RFC6437] SHOULD NOT\n   be copied as part of the translation.\n     \
    \ Preferred behavior: The TURN server can use the 5-tuple of relayed\n      transport\
    \ address, peer transport address, and UDP protocol number\n      to identify\
    \ each flow and to generate and set the flow label value\n      in the IPv6 packet\
    \ as discussed in Section 3 of [RFC6437].  If the\n      TURN server is incapable\
    \ of generating the flow label value from\n      the IPv6 packet's 5-tuple, it\
    \ sets the Flow label to zero.\n      Alternate behavior: The alternate behavior\
    \ is the same as the\n      preferred behavior for a TURN server that does not\
    \ support flow\n      labels.\n   Hop Limit\n      Preferred behavior: The TURN\
    \ server acts as a regular router with\n      respect to decrementing the Hop\
    \ Limit and generating an ICMPv6\n      error if it reaches zero.\n      Alternate\
    \ behavior: The TURN server sets the Hop Limit to the\n      default value for\
    \ outgoing packets.\n   Fragmentation\n      Preferred behavior: If the incoming\
    \ packet did not include a\n      Fragment header and the outgoing packet size\
    \ does not exceed the\n      outgoing link's MTU, the TURN server sends the outgoing\
    \ packet\n      without a Fragment header.\n      If the incoming packet did not\
    \ include a Fragment header and the\n      outgoing packet size exceeds the outgoing\
    \ link's MTU, the TURN\n      server drops the outgoing packet and sends an ICMP\
    \ message of type\n      2 code 0 (\"Packet too big\") to the sender of the incoming\
    \ packet.\n      If the ICMPv6 packet (\"Packet too big\") is being sent to the\
    \ peer,\n      the TURN server SHOULD reduce the MTU reported in the ICMP message\n\
    \      by 48 bytes to allow room for the overhead of a Data indication.\n    \
    \  If the incoming packet included a Fragment header and the outgoing\n      packet\
    \ size (with a Fragment header included) does not exceed the\n      outgoing link's\
    \ MTU, the TURN server sends the outgoing packet\n      with a Fragment header.\
    \  The TURN server sets the fields of the\n      Fragment header as appropriate\
    \ for a packet originating from the\n      server.\n      If the incoming packet\
    \ included a Fragment header and the outgoing\n      packet size exceeds the outgoing\
    \ link's MTU, the TURN server MUST\n      fragment the outgoing packet into fragments\
    \ of no more than 1280\n      bytes.  The TURN server sets the fields of the Fragment\
    \ header as\n      appropriate for a packet originating from the server.\n   \
    \   Alternate behavior: The TURN server assembles incoming fragments.\n      The\
    \ TURN server follows its default behavior to send outgoing\n      packets.\n\
    \      For both preferred and alternate behavior, the DONT-FRAGMENT\n      attribute\
    \ MUST be ignored by the server.\n   Extension Headers\n      Preferred behavior:\
    \ The outgoing packet uses the system defaults\n      for IPv6 extension headers,\
    \ with the exception of the Fragment\n      header as described above.\n     \
    \ Alternate behavior: Same as preferred.\n"
- title: 13.3.  IPv6-to-IPv4 Translations
  contents:
  - "13.3.  IPv6-to-IPv4 Translations\n   Type of Service and Precedence\n      Preferred\
    \ behavior: As specified in Section 5 of [RFC7915].\n      Alternate behavior:\
    \ The TURN server sets the Type of Service and\n      Precedence to the default\
    \ value for outgoing packets.\n   Time to Live\n      Preferred behavior: As specified\
    \ in Section 5 of [RFC7915].\n      Alternate behavior: The TURN server sets the\
    \ Time to Live to the\n      default value for outgoing packets.\n   Fragmentation\n\
    \      Preferred behavior: As specified in Section 5 of [RFC7915].\n      Additionally,\
    \ when the outgoing packet's size exceeds the outgoing\n      link's MTU, the\
    \ TURN server needs to generate an ICMP error\n      (ICMPv6 \"Packet too big\"\
    ) reporting the MTU size.  If the ICMPv4\n      packet (Destination Unreachable\
    \ (Type 3) with Code 4) is being\n      sent to the peer, the TURN server SHOULD\
    \ reduce the MTU reported\n      in the ICMP message by 48 bytes to allow room\
    \ for the overhead of\n      a Data indication.\n      Alternate behavior: The\
    \ TURN server assembles incoming fragments.\n      The TURN server follows its\
    \ default behavior to send outgoing\n      packets.\n      For both preferred\
    \ and alternate behavior, the DONT-FRAGMENT\n      attribute MUST be ignored by\
    \ the server.\n"
- title: 14.  UDP-to-UDP Relay
  contents:
  - "14.  UDP-to-UDP Relay\n   This section describes how the server sets various\
    \ fields in the IP\n   header for UDP-to-UDP relay from the client to the peer\
    \ or vice\n   versa.  The descriptions in this section apply (a) when the server\n\
    \   sends a UDP datagram to the peer or (b) when the server sends a Data\n   indication\
    \ or ChannelData message to the client over UDP transport.\n   The descriptions\
    \ in this section do not apply to TURN messages sent\n   over TCP or TLS transport\
    \ from the server to the client.\n   The descriptions below have two parts: a\
    \ preferred behavior and an\n   alternate behavior.  The server SHOULD implement\
    \ the preferred\n   behavior, but if that is not possible for a particular field,\
    \ then it\n   SHOULD implement the alternative behavior.\n   Differentiated Services\
    \ Code Point (DSCP) field [RFC2474]\n      Preferred Behavior: Set the outgoing\
    \ value to the incoming value\n      unless the server includes a differentiated\
    \ services classifier\n      and marker [RFC2474].\n      Alternate Behavior:\
    \ Set the outgoing value to a fixed value, which\n      by default is Best Effort\
    \ unless configured otherwise.\n      In both cases, if the server is immediately\
    \ adjacent to a\n      differentiated services classifier and marker, then DSCP\
    \ MAY be\n      set to any arbitrary value in the direction towards the\n    \
    \  classifier.\n   Explicit Congestion Notification (ECN) field [RFC3168]\n  \
    \    Preferred Behavior: Set the outgoing value to the incoming value.\n     \
    \ The server may perform Active Queue Management, in which case it\n      SHOULD\
    \ behave as an ECN-aware router [RFC3168] and can mark\n      traffic with Congestion\
    \ Experienced (CE) instead of dropping the\n      packet.  The use of ECT(1) is\
    \ subject to experimental usage\n      [RFC8311].\n      Alternate Behavior: Set\
    \ the outgoing value to Not-ECT (=0b00).\n   IPv4 Fragmentation fields (applicable\
    \ only for IPv4-to-IPv4 relay)\n      Preferred Behavior: When the server sends\
    \ a packet to a peer in\n      response to a Send indication containing the DONT-FRAGMENT\n\
    \      attribute, then set the outgoing UDP packet to not fragment.  In\n    \
    \  all other cases, when sending an outgoing packet containing\n      application\
    \ data (e.g., Data indication, a ChannelData message, or\n      the DONT-FRAGMENT\
    \ attribute not included in the Send indication),\n      copy the DF bit from\
    \ the DF bit of the incoming packet that\n      contained the application data.\n\
    \      Set the other fragmentation fields (Identification, More\n      Fragments,\
    \ Fragment Offset) as appropriate for a packet\n      originating from the server.\n\
    \      Alternate Behavior: As described in the Preferred Behavior, except\n  \
    \    always assume the incoming DF bit is 0.\n      In both the Preferred and\
    \ Alternate Behaviors, the resulting\n      packet may be too large for the outgoing\
    \ link.  If this is the\n      case, then the normal fragmentation rules apply\
    \ [RFC1122].\n   IPv4 Options\n      Preferred Behavior: The outgoing packet uses\
    \ the system defaults\n      for IPv4 options.\n      Alternate Behavior: Same\
    \ as preferred.\n"
- title: 15.  TCP-to-UDP Relay
  contents:
  - "15.  TCP-to-UDP Relay\n   This section describes how the server sets various\
    \ fields in the IP\n   header for TCP-to-UDP relay from the client to the peer.\
    \  The\n   descriptions in this section apply when the server sends a UDP\n  \
    \ datagram to the peer.  Note that the server does not perform per-\n   packet\
    \ translation for TCP-to-UDP relaying.\n   Multipath TCP [TCP-EXT] is not supported\
    \ by this version of TURN\n   because TCP multipath is not used by either SIP\
    \ or WebRTC protocols\n   [RFC7478] for media and non-media data.  TCP connection\
    \ between the\n   TURN client and server can use the TCP Authentication Option\
    \ (TCP-AO)\n   [RFC5925], but UDP does not provide a similar type of authentication,\n\
    \   though it might be added in the future [UDP-OPT].  Even if both TCP-\n   AO\
    \ and UDP authentication would be used between TURN client and\n   server, it\
    \ would not change the end-to-end security properties of the\n   application payload\
    \ being relayed.  Therefore, applications using\n   TURN will need to secure their\
    \ application data end to end\n   appropriately, e.g., Secure Real-time Transport\
    \ Protocol (SRTP) for\n   RTP applications.  Note that the TCP-AO option obsoletes\
    \ the TCP MD5\n   option.\n   Unlike UDP, TCP without the TCP Fast Open extension\
    \ [RFC7413] does\n   not support 0-RTT session resumption.  The TCP user timeout\
    \ [RFC5482]\n   equivalent for application data relayed by the TURN is the use\
    \ of RTP\n   control protocol (RTCP).  As a reminder, RTCP is a fundamental and\n\
    \   integral part of RTP.\n   The descriptions below have two parts: a preferred\
    \ behavior and an\n   alternate behavior.  The server SHOULD implement the preferred\n\
    \   behavior, but if that is not possible for a particular field, then it\n  \
    \ SHOULD implement the alternative behavior.\n   For the UDP datagram sent to\
    \ the peer based on a Send Indication or\n   ChannelData message arriving at the\
    \ TURN server over a TCP Transport,\n   the server sets various fields in the\
    \ IP header as follows:\n   Differentiated Services Code Point (DSCP) field [RFC2474]\n\
    \      Preferred Behavior: The TCP connection can only use a single DSCP,\n  \
    \    so inter-flow differentiation is not possible; see Section 5.1 of\n     \
    \ [RFC7657].  The server sets the outgoing value to the DSCP used by\n      the\
    \ TCP connection, unless the server includes a differentiated\n      services\
    \ classifier and marker [RFC2474].\n      Alternate Behavior: Set the outgoing\
    \ value to a fixed value, which\n      by default is Best Effort unless configured\
    \ otherwise.\n      In both cases, if the server is immediately adjacent to a\n\
    \      differentiated services classifier and marker, then DSCP MAY be\n     \
    \ set to any arbitrary value in the direction towards the\n      classifier.\n\
    \   Explicit Congestion Notification (ECN) field [RFC3168]\n      Preferred Behavior:\
    \ No mechanism is defined to indicate what ECN\n      value should be used for\
    \ the outgoing UDP datagrams of an\n      allocation; therefore, set the outgoing\
    \ value to Not-ECT (=0b00).\n      Alternate Behavior: Same as preferred.\n  \
    \ IPv4 Fragmentation fields (applicable only for IPv4-to-IPv4 relay)\n      Preferred\
    \ Behavior: When the server sends a packet to a peer in\n      response to a Send\
    \ indication containing the DONT-FRAGMENT\n      attribute, set the outgoing UDP\
    \ packet to not fragment.  In all\n      other cases, when sending an outgoing\
    \ UDP packet containing\n      application data (e.g., Data indication, ChannelData\
    \ message, or\n      DONT-FRAGMENT attribute not included in the Send indication),\
    \ set\n      the DF bit in the outgoing IP header to 0.\n      Alternate Behavior:\
    \ Same as preferred.\n   IPv6 Fragmentation fields\n      Preferred Behavior:\
    \ If the TCP traffic arrives over IPv6, the\n      server relies on the presence\
    \ of the DONT-FRAGMENT attribute in\n      the send indication to set the outgoing\
    \ UDP packet to not\n      fragment.\n      Alternate Behavior: Same as preferred.\n\
    \   IPv4 Options\n      Preferred Behavior: The outgoing packet uses the system\
    \ defaults\n      for IPv4 options.\n      Alternate Behavior: Same as preferred.\n"
- title: 16.  UDP-to-TCP Relay
  contents:
  - "16.  UDP-to-TCP Relay\n   This section describes how the server sets various\
    \ fields in the IP\n   header for UDP-to-TCP relay from the peer to the client.\
    \  The\n   descriptions in this section apply when the server sends a Data\n \
    \  indication or ChannelData message to the client over TCP or TLS\n   transport.\
    \  Note that the server does not perform per-packet\n   translation for UDP-to-TCP\
    \ relaying.\n   The descriptions below have two parts: a preferred behavior and\
    \ an\n   alternate behavior.  The server SHOULD implement the preferred\n   behavior,\
    \ but if that is not possible for a particular field, then it\n   SHOULD implement\
    \ the alternative behavior.\n   The TURN server sets IP header fields in the TCP\
    \ packets on a per-\n   connection basis for the TCP connection as follows:\n\
    \   Differentiated Services Code Point (DSCP) field [RFC2474]\n      Preferred\
    \ Behavior: Ignore the incoming DSCP value.  When TCP is\n      used between the\
    \ client and the server, a single DSCP should be\n      used for all traffic on\
    \ that TCP connection.  Note, TURN/ICE\n      occurs before application data is\
    \ exchanged.\n      Alternate Behavior: Same as preferred.\n   Explicit Congestion\
    \ Notification (ECN) field [RFC3168]\n      Preferred Behavior: Ignore; ECN signals\
    \ are dropped in the TURN\n      server for the incoming UDP datagrams from the\
    \ peer.\n      Alternate Behavior: Same as preferred.\n   Fragmentation\n    \
    \  Preferred Behavior: Any fragmented packets are reassembled in the\n      server\
    \ and then forwarded to the client over the TCP connection.\n      ICMP messages\
    \ resulting from the UDP datagrams sent to the peer\n      are processed by the\
    \ server as described in Section 11.5 and\n      forwarded to the client using\
    \ TURN's mechanism for relevant ICMP\n      types and codes.\n      Alternate\
    \ Behavior: Same as preferred.\n   Extension Headers\n      Preferred behavior:\
    \ The outgoing packet uses the system defaults\n      for IPv6 extension headers.\n\
    \      Alternate behavior: Same as preferred.\n   IPv4 Options\n      Preferred\
    \ Behavior: The outgoing packet uses the system defaults\n      for IPv4 options.\n\
    \      Alternate Behavior: Same as preferred.\n"
- title: 17.  STUN Methods
  contents:
  - "17.  STUN Methods\n   This section lists the code points for the STUN methods\
    \ defined in\n   this specification.  See elsewhere in this document for the semantics\n\
    \   of these methods.\n           | 0x003 | Allocate         | (only request/response\
    \ |\n           | 0x004 | Refresh          | (only request/response |\n      \
    \     | 0x006 | Send             | (only indication       |\n           | 0x007\
    \ | Data             | (only indication       |\n           | 0x008 | CreatePermission\
    \ | (only request/response |\n           | 0x009 | ChannelBind      | (only request/response\
    \ |\n"
- title: 18.  STUN Attributes
  contents:
  - "18.  STUN Attributes\n   This STUN extension defines the following attributes:\n\
    \                  | 0x000C | CHANNEL-NUMBER            |\n                  |\
    \ 0x000D | LIFETIME                  |\n                  | 0x0010 | Reserved\
    \ (was BANDWIDTH)  |\n                  | 0x0012 | XOR-PEER-ADDRESS          |\n\
    \                  | 0x0013 | DATA                      |\n                  |\
    \ 0x0016 | XOR-RELAYED-ADDRESS       |\n                  | 0x0017 | REQUESTED-ADDRESS-FAMILY\
    \  |\n                  | 0x0018 | EVEN-PORT                 |\n             \
    \     | 0x0019 | REQUESTED-TRANSPORT       |\n                  | 0x001A | DONT-FRAGMENT\
    \             |\n                  | 0x0021 | Reserved (was TIMER-VAL)  |\n  \
    \                | 0x0022 | RESERVATION-TOKEN         |\n                  | 0x8000\
    \ | ADDITIONAL-ADDRESS-FAMILY |\n                  | 0x8001 | ADDRESS-ERROR-CODE\
    \        |\n                  | 0x8004 | ICMP                      |\n   Some\
    \ of these attributes have lengths that are not multiples of 4.\n   By the rules\
    \ of STUN, any attribute whose length is not a multiple of\n   4 bytes MUST be\
    \ immediately followed by 1 to 3 padding bytes to\n   ensure the next attribute\
    \ (if any) would start on a 4-byte boundary\n   (see [RFC8489]).\n"
- title: 18.1.  CHANNEL-NUMBER
  contents:
  - "18.1.  CHANNEL-NUMBER\n   The CHANNEL-NUMBER attribute contains the number of\
    \ the channel.  The\n   value portion of this attribute is 4 bytes long and consists\
    \ of a\n   16-bit unsigned integer followed by a two-octet RFFU (Reserved For\n\
    \   Future Use) field, which MUST be set to 0 on transmission and MUST be\n  \
    \ ignored on reception.\n    0                   1                   2       \
    \            3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n   |        Channel Number         |         RFFU = 0              |\n"
- title: 18.2.  LIFETIME
  contents:
  - "18.2.  LIFETIME\n   The LIFETIME attribute represents the duration for which\
    \ the server\n   will maintain an allocation in the absence of a refresh.  The\
    \ TURN\n   client can include the LIFETIME attribute with the desired lifetime\n\
    \   in Allocate and Refresh requests.  The value portion of this\n   attribute\
    \ is 4 bytes long and consists of a 32-bit unsigned integral\n   value representing\
    \ the number of seconds remaining until expiration.\n"
- title: 18.3.  XOR-PEER-ADDRESS
  contents:
  - "18.3.  XOR-PEER-ADDRESS\n   The XOR-PEER-ADDRESS attribute specifies the address\
    \ and port of the\n   peer as seen from the TURN server.  (For example, the peer's\
    \ server-\n   reflexive transport address if the peer is behind a NAT.)  It is\n\
    \   encoded in the same way as the XOR-MAPPED-ADDRESS attribute\n   [RFC8489].\n"
- title: 18.4.  DATA
  contents:
  - "18.4.  DATA\n   The DATA attribute is present in all Send indications.  If the\
    \ ICMP\n   attribute is not present in a Data indication, it contains a DATA\n\
    \   attribute.  The value portion of this attribute is variable length\n   and\
    \ consists of the application data (that is, the data that would\n   immediately\
    \ follow the UDP header if the data was sent directly\n   between the client and\
    \ the peer).  The application data is equivalent\n   to the \"UDP user data\"\
    \ and does not include the \"surplus area\"\n   defined in Section 4 of [UDP-OPT].\
    \  If the length of this attribute\n   is not a multiple of 4, then padding must\
    \ be added after this\n   attribute.\n"
- title: 18.5.  XOR-RELAYED-ADDRESS
  contents:
  - "18.5.  XOR-RELAYED-ADDRESS\n   The XOR-RELAYED-ADDRESS attribute is present in\
    \ Allocate responses.\n   It specifies the address and port that the server allocated\
    \ to the\n   client.  It is encoded in the same way as the XOR-MAPPED-ADDRESS\n\
    \   attribute [RFC8489].\n"
- title: 18.6.  REQUESTED-ADDRESS-FAMILY
  contents:
  - "18.6.  REQUESTED-ADDRESS-FAMILY\n   This attribute is used in Allocate and Refresh\
    \ requests to specify\n   the address type requested by the client.  The value\
    \ of this\n   attribute is 4 bytes with the following format:\n    0         \
    \          1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   |     Family    |          \
    \  Reserved                           |\n   Family:  There are two values defined\
    \ for this field and specified in\n      Section 14.1 of [RFC8489]: 0x01 for IPv4\
    \ addresses and 0x02 for\n      IPv6 addresses.\n   Reserved:  At this point,\
    \ the 24 bits in the Reserved field MUST be\n      set to zero by the client and\
    \ MUST be ignored by the server.\n"
- title: 18.7.  EVEN-PORT
  contents:
  - "18.7.  EVEN-PORT\n   This attribute allows the client to request that the port\
    \ in the\n   relayed transport address be even and (optionally) that the server\n\
    \   reserve the next-higher port number.  The value portion of this\n   attribute\
    \ is 1 byte long.  Its format is:\n      0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n\
    \     |R|    RFFU     |\n     +-+-+-+-+-+-+-+-+\n   The value contains a single\
    \ 1-bit flag:\n   R:  If 1, the server is requested to reserve the next-higher\
    \ port\n      number (on the same IP address) for a subsequent allocation.  If\n\
    \      0, no such reservation is requested.\n   RFFU:  Reserved For Future Use.\n\
    \   The RFFU field must be set to zero on transmission and ignored on\n   reception.\n\
    \   Since the length of this attribute is not a multiple of 4, padding\n   must\
    \ immediately follow this attribute.\n"
- title: 18.8.  REQUESTED-TRANSPORT
  contents:
  - "18.8.  REQUESTED-TRANSPORT\n   This attribute is used by the client to request\
    \ a specific transport\n   protocol for the allocated transport address.  The\
    \ value of this\n   attribute is 4 bytes with the following format:\n    0   \
    \                1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   |    Protocol   |    \
    \                RFFU                       |\n   The Protocol field specifies\
    \ the desired protocol.  The code points\n   used in this field are taken from\
    \ those allowed in the Protocol field\n   in the IPv4 header and the NextHeader\
    \ field in the IPv6 header\n   [PROTOCOL-NUMBERS].  This specification only allows\
    \ the use of code\n   point 17 (User Datagram Protocol).\n   The RFFU field MUST\
    \ be set to zero on transmission and MUST be\n   ignored on reception.  It is\
    \ reserved for future uses.\n"
- title: 18.9.  DONT-FRAGMENT
  contents:
  - "18.9.  DONT-FRAGMENT\n   This attribute is used by the client to request that\
    \ the server set\n   the DF (Don't Fragment) bit in the IP header when relaying\
    \ the\n   application data onward to the peer and for determining the server\n\
    \   capability in Allocate requests.  This attribute has no value part,\n   and\
    \ thus, the attribute length field is 0.\n"
- title: 18.10.  RESERVATION-TOKEN
  contents:
  - "18.10.  RESERVATION-TOKEN\n   The RESERVATION-TOKEN attribute contains a token\
    \ that uniquely\n   identifies a relayed transport address being held in reserve\
    \ by the\n   server.  The server includes this attribute in a success response\
    \ to\n   tell the client about the token, and the client includes this\n   attribute\
    \ in a subsequent Allocate request to request the server use\n   that relayed\
    \ transport address for the allocation.\n   The attribute value is 8 bytes and\
    \ contains the token value.\n"
- title: 18.11.  ADDITIONAL-ADDRESS-FAMILY
  contents:
  - "18.11.  ADDITIONAL-ADDRESS-FAMILY\n   This attribute is used by clients to request\
    \ the allocation of an\n   IPv4 and IPv6 address type from a server.  It is encoded\
    \ in the same\n   way as the REQUESTED-ADDRESS-FAMILY attribute; see Section 18.6.\
    \  The\n   ADDITIONAL-ADDRESS-FAMILY attribute MAY be present in the Allocate\n\
    \   request.  The attribute value of 0x02 (IPv6 address) is the only\n   valid\
    \ value in Allocate request.\n"
- title: 18.12.  ADDRESS-ERROR-CODE
  contents:
  - "18.12.  ADDRESS-ERROR-CODE\n   This attribute is used by servers to signal the\
    \ reason for not\n   allocating the requested address family.  The value portion\
    \ of this\n   attribute is variable length with the following format:\n      \
    \ 0                   1                   2                   3\n       0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      |  Family \
    \      |    Reserved             |Class|     Number    |\n      |      Reason\
    \ Phrase (variable)                                ..\n   Family:  There are two\
    \ values defined for this field and specified in\n      Section 14.1 of [RFC8489]:\
    \ 0x01 for IPv4 addresses and 0x02 for\n      IPv6 addresses.\n   Reserved:  At\
    \ this point, the 13 bits in the Reserved field MUST be\n      set to zero by\
    \ the server and MUST be ignored by the client.\n   Class:  The Class represents\
    \ the hundreds digit of the error code and\n      is defined in Section 14.8 of\
    \ [RFC8489].\n   Number:  This 8-bit field contains the reason the server cannot\n\
    \      allocate one of the requested address types.  The error code\n      values\
    \ could be either 440 (Address Family not Supported) or 508\n      (Insufficient\
    \ Capacity).  The number representation is defined in\n      Section 14.8 of [RFC8489].\n\
    \   Reason Phrase:  The recommended reason phrases for error codes 440\n     \
    \ and 508 are explained in Section 19.  The reason phrase MUST be a\n      UTF-8\
    \ [RFC3629] encoded sequence of less than 128 characters\n      (which can be\
    \ as long as 509 bytes when encoding them or 763 bytes\n      when decoding them).\n"
- title: 18.13.  ICMP
  contents:
  - "18.13.  ICMP\n   This attribute is used by servers to signal the reason a UDP\
    \ packet\n   was dropped.  The following is the format of the ICMP attribute.\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  |  Reserved                     |  ICMP Type  |  ICMP Code      |\n   Reserved:\
    \  This field MUST be set to 0 when sent and MUST be ignored\n      when received.\n\
    \   ICMP Type:  The field contains the value of the ICMP type.  Its\n      interpretation\
    \ depends on whether the ICMP was received over IPv4\n      or IPv6.\n   ICMP\
    \ Code:  The field contains the value of the ICMP code.  Its\n      interpretation\
    \ depends on whether the ICMP was received over IPv4\n      or IPv6.\n   Error\
    \ Data:  This field size is 4 bytes long.  If the ICMPv6 type is\n      2 (\"\
    Packet too big\" message) or ICMPv4 type is 3 (Destination\n      Unreachable)\
    \ and Code is 4 (fragmentation needed and DF set), the\n      Error Data field\
    \ will be set to the Maximum Transmission Unit of\n      the next-hop link (Section\
    \ 3.2 of [RFC4443] and Section 4 of\n      [RFC1191]).  For other ICMPv6 types\
    \ and ICMPv4 types and codes,\n      the Error Data field MUST be set to zero.\n"
- title: 19.  STUN Error Response Codes
  contents:
  - "19.  STUN Error Response Codes\n   This document defines the following error\
    \ response codes:\n   403 (Forbidden):\n      The request was valid but cannot\
    \ be performed due to\n      administrative or similar restrictions.\n   437 (Allocation\
    \ Mismatch):\n      A request was received by the server that requires an allocation\n\
    \      to be in place, but no allocation exists, or a request was\n      received\
    \ that requires no allocation, but an allocation exists.\n   440 (Address Family\
    \ not Supported):\n      The server does not support the address family requested\
    \ by the\n      client.\n   441 (Wrong Credentials):\n      (Wrong Credentials):\
    \ The credentials in the (non-Allocate) request\n      do not match those used\
    \ to create the allocation.\n   442 (Unsupported Transport Protocol):\n      The\
    \ Allocate request asked the server to use a transport protocol\n      between\
    \ the server and the peer that the server does not support.\n      NOTE: This\
    \ does NOT refer to the transport protocol used in the\n      5-tuple.\n   443\
    \ (Peer Address Family Mismatch):\n      A peer address is part of a different\
    \ address family than that of\n      the relayed transport address of the allocation.\n\
    \   486 (Allocation Quota Reached):\n      No more allocations using this username\
    \ can be created at the\n      present time.\n   508 (Insufficient Capacity):\n\
    \      The server is unable to carry out the request due to some capacity\n  \
    \    limit being reached.  In an Allocate response, this could be due\n      to\
    \ the server having no more relayed transport addresses available\n      at that\
    \ time, having none with the requested properties, or the\n      one that corresponds\
    \ to the specified reservation token is not\n      available.\n"
- title: 20.  Detailed Example
  contents:
  - "20.  Detailed Example\n   This section gives an example of the use of TURN, showing\
    \ in detail\n   the contents of the messages exchanged.  The example uses the\
    \ network\n   diagram shown in the Overview (Figure 1).\n   For each message,\
    \ the attributes included in the message and their\n   values are shown.  For\
    \ convenience, values are shown in a human-\n   readable format rather than showing\
    \ the actual octets; for example,\n   \"XOR-RELAYED-ADDRESS=192.0.2.15:9000\"\
    \ shows that the XOR-RELAYED-\n   ADDRESS attribute is included with an address\
    \ of 192.0.2.15 and a\n   port of 9000; here, the address and port are shown before\
    \ the xor-ing\n   is done.  For attributes with string-like values (e.g.,\n  \
    \ SOFTWARE=\"Example client, version 1.03\" and\n   NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"\
    ), the value of the attribute\n   is shown in quotes for readability, but these\
    \ quotes do not appear in\n   the actual value.\n   TURN                     \
    \            TURN          Peer         Peer\n   client                      \
    \         server         A            B\n     |--- Allocate request -------------->|\
    \            |            |\n     |    Transaction-Id=0xA56250D3F17ABE679422DE85\
    \    |            |\n     |    SOFTWARE=\"Example client, version 1.03\"     \
    \ |            |\n     |    LIFETIME=3600 (1 hour)          |            |   \
    \         |\n     |    REQUESTED-TRANSPORT=17 (UDP)    |            |        \
    \    |\n     |    DONT-FRAGMENT                   |            |            |\n\
    \     |<-- Allocate error response --------|            |            |\n     |\
    \    Transaction-Id=0xA56250D3F17ABE679422DE85    |            |\n     |    SOFTWARE=\"\
    Example server, version 1.17\"      |            |\n     |    ERROR-CODE=401 (Unauthorized)\
    \   |            |            |\n     |    REALM=\"example.com\"             |\
    \            |            |\n     |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"\
    \     |            |\n     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |\
    \            |\n     |--- Allocate request -------------->|            |     \
    \       |\n     |    Transaction-Id=0xC271E932AD7446A32C234492    |          \
    \  |\n     |    SOFTWARE=\"Example client 1.03\"  |            |            |\n\
    \     |    LIFETIME=3600 (1 hour)          |            |            |\n     |\
    \    REQUESTED-TRANSPORT=17 (UDP)    |            |            |\n     |    DONT-FRAGMENT\
    \                   |            |            |\n     |    USERNAME=\"George\"\
    \               |            |            |\n     |    REALM=\"example.com\" \
    \            |            |            |\n     |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"\
    \     |            |\n     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |\
    \            |\n     |    PASSWORD-ALGORITHM=SHA256       |            |     \
    \       |\n     |    MESSAGE-INTEGRITY=...           |            |          \
    \  |\n     |    MESSAGE-INTEGRITY-SHA256=...    |            |            |\n\
    \     |<-- Allocate success response ------|            |            |\n     |\
    \    Transaction-Id=0xC271E932AD7446A32C234492    |            |\n     |    SOFTWARE=\"\
    Example server, version 1.17\"      |            |\n     |    LIFETIME=1200 (20\
    \ minutes)      |            |            |\n     |    XOR-RELAYED-ADDRESS=192.0.2.15:50000\
    \         |            |\n     |    XOR-MAPPED-ADDRESS=192.0.2.1:7000        \
    \    |            |\n     |    MESSAGE-INTEGRITY-SHA256=...    |            |\
    \            |\n   The client begins by selecting a host transport address to\
    \ use for\n   the TURN session; in this example, the client has selected\n   198.51.100.2:49721\
    \ as shown in Figure 1.  The client then sends an\n   Allocate request to the\
    \ server at the server transport address.  The\n   client randomly selects a 96-bit\
    \ transaction id of\n   0xA56250D3F17ABE679422DE85 for this transaction; this\
    \ is encoded in\n   the transaction id field in the fixed header.  The client\
    \ includes a\n   SOFTWARE attribute that gives information about the client's\n\
    \   software; here, the value is \"Example client, version 1.03\" to\n   indicate\
    \ that this is version 1.03 of something called the \"Example\n   client\".  The\
    \ client includes the LIFETIME attribute because it\n   wishes the allocation\
    \ to have a longer lifetime than the default of\n   10 minutes; the value of this\
    \ attribute is 3600 seconds, which\n   corresponds to 1 hour.  The client must\
    \ always include a REQUESTED-\n   TRANSPORT attribute in an Allocate request,\
    \ and the only value\n   allowed by this specification is 17, which indicates\
    \ UDP transport\n   between the server and the peers.  The client also includes\
    \ the DONT-\n   FRAGMENT attribute because it wishes to use the DONT-FRAGMENT\n\
    \   attribute later in Send indications; this attribute consists of only\n   an\
    \ attribute header; there is no value part.  We assume the client\n   has not\
    \ recently interacted with the server; thus, the client does\n   not include the\
    \ USERNAME, USERHASH, REALM, NONCE, PASSWORD-\n   ALGORITHMS, PASSWORD-ALGORITHM,\
    \ MESSAGE-INTEGRITY, or MESSAGE-\n   INTEGRITY-SHA256 attribute.  Finally, note\
    \ that the order of\n   attributes in a message is arbitrary (except for the MESSAGE-\n\
    \   INTEGRITY, MESSAGE-INTEGRITY-SHA256 and FINGERPRINT attributes), and\n   the\
    \ client could have used a different order.\n   Servers require any request to\
    \ be authenticated.  Thus, when the\n   server receives the initial Allocate request,\
    \ it rejects the request\n   because the request does not contain the authentication\
    \ attributes.\n   Following the procedures of the long-term credential mechanism\
    \ of\n   STUN [RFC8489], the server includes an ERROR-CODE attribute with a\n\
    \   value of 401 (Unauthorized), a REALM attribute that specifies the\n   authentication\
    \ realm used by the server (in this case, the server's\n   domain \"example.com\"\
    ), and a nonce value in a NONCE attribute.  The\n   NONCE attribute starts with\
    \ the \"nonce cookie\" with the STUN Security\n   Feature \"Password algorithm\"\
    \ bit set to 1.  The server includes a\n   PASSWORD-ALGORITHMS attribute that\
    \ specifies the list of algorithms\n   that the server can use to derive the long-term\
    \ password.  If the\n   server sets the STUN Security Feature \"Username anonymity\"\
    \ bit to 1,\n   then the client uses the USERHASH attribute instead of the USERNAME\n\
    \   attribute in the Allocate request to anonymize the username.  The\n   server\
    \ also includes a SOFTWARE attribute that gives information\n   about the server's\
    \ software.\n   The client, upon receipt of the 401 error, reattempts the Allocate\n\
    \   request, this time including the authentication attributes.  The\n   client\
    \ selects a new transaction id and then populates the new\n   Allocate request\
    \ with the same attributes as before.  The client\n   includes a USERNAME attribute\
    \ and uses the realm value received from\n   the server to help it determine which\
    \ value to use; here, the client\n   is configured to use the username \"George\"\
    \ for the realm\n   \"example.com\".  The client includes the PASSWORD-ALGORITHM\
    \ attribute\n   indicating the algorithm that the server must use to derive the\
    \ long-\n   term password.  The client also includes the REALM, PASSWORD-\n  \
    \ ALGORITHMS, and NONCE attributes, which are just copied from the 401\n   error\
    \ response.  Finally, the client includes MESSAGE-INTEGRITY-\n   SHA256 attribute\
    \ as the last attributes in the message whose value is\n   Hashed Message Authentication\
    \ Code - Secure Hash Algorithm 2 (HMAC-\n   SHA2) hash over the contents of the\
    \ message (shown as just \"...\"\n   above); this HMAC-SHA2 computation includes\
    \ a password value.  Thus,\n   an attacker cannot compute the message integrity\
    \ value without\n   somehow knowing the secret password.\n   The server, upon\
    \ receipt of the authenticated Allocate request,\n   checks that everything is\
    \ OK, then creates an allocation.  The server\n   replies with an Allocate success\
    \ response.  The server includes a\n   LIFETIME attribute giving the lifetime\
    \ of the allocation; here, the\n   server has reduced the client's requested 1-hour\
    \ lifetime to just 20\n   minutes because this particular server doesn't allow\
    \ lifetimes longer\n   than 20 minutes.  The server includes an XOR-RELAYED-ADDRESS\n\
    \   attribute whose value is the relayed transport address of the\n   allocation.\
    \  The server includes an XOR-MAPPED-ADDRESS attribute\n   whose value is the\
    \ server-reflexive address of the client; this value\n   is not used otherwise\
    \ in TURN but is returned as a convenience to the\n   client.  The server includes\
    \ a MESSAGE-INTEGRITY-SHA256 attribute to\n   authenticate the response and to\
    \ ensure its integrity; note that the\n   response does not contain the USERNAME,\
    \ REALM, and NONCE attributes.\n   The server also includes a SOFTWARE attribute.\n\
    \   TURN                                 TURN          Peer         Peer\n   client\
    \                               server         A            B\n     |--- CreatePermission\
    \ request ------>|            |            |\n     |    Transaction-Id=0xE5913A8F460956CA277D3319\
    \    |            |\n     |    XOR-PEER-ADDRESS=192.0.2.150:0  |            |\
    \            |\n     |    USERNAME=\"George\"               |            |   \
    \         |\n     |    REALM=\"example.com\"             |            |      \
    \      |\n     |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |         \
    \   |\n     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n\
    \     |    PASSWORD-ALGORITHM=SHA256       |            |            |\n     |\
    \    MESSAGE-INTEGRITY-SHA256=...    |            |            |\n     |<-- CreatePermission\
    \ success resp.--|            |            |\n     |    Transaction-Id=0xE5913A8F460956CA277D3319\
    \    |            |\n     |    MESSAGE-INTEGRITY-SHA256=...    |            |\
    \            |\n   The client then creates a permission towards Peer A in preparation\n\
    \   for sending it some application data.  This is done through a\n   CreatePermission\
    \ request.  The XOR-PEER-ADDRESS attribute contains\n   the IP address for which\
    \ a permission is established (the IP address\n   of peer A); note that the port\
    \ number in the attribute is ignored\n   when used in a CreatePermission request,\
    \ and here it has been set to\n   0; also, note how the client uses Peer A's server-reflexive\
    \ IP\n   address and not its (private) host address.  The client uses the same\n\
    \   username, realm, and nonce values as in the previous request on the\n   allocation.\
    \  Though it is allowed to do so, the client has chosen not\n   to include a SOFTWARE\
    \ attribute in this request.\n   The server receives the CreatePermission request,\
    \ creates the\n   corresponding permission, and then replies with a CreatePermission\n\
    \   success response.  Like the client, the server chooses not to include\n  \
    \ the SOFTWARE attribute in its reply.  Again, note how success\n   responses\
    \ contain a MESSAGE-INTEGRITY-SHA256 attribute (assuming the\n   server uses the\
    \ long-term credential mechanism) but no USERNAME,\n   REALM, and NONCE attributes.\n\
    \   TURN                                 TURN          Peer         Peer\n   client\
    \                               server         A            B\n     |--- Send\
    \ indication --------------->|            |            |\n     |    Transaction-Id=0x1278E9ACA2711637EF7D3328\
    \    |            |\n     |    XOR-PEER-ADDRESS=192.0.2.150:32102           |\
    \            |\n     |    DONT-FRAGMENT                   |            |     \
    \       |\n     |    DATA=...                        |            |          \
    \  |\n     |<-- Data indication ----------------|            |            |\n\
    \     |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF    |            |\n     |\
    \    XOR-PEER-ADDRESS=192.0.2.150:32102           |            |\n     |    DATA=...\
    \                        |            |            |\n   The client now sends\
    \ application data to Peer A using a Send\n   indication.  Peer A's server-reflexive\
    \ transport address is specified\n   in the XOR-PEER-ADDRESS attribute, and the\
    \ application data (shown\n   here as just \"...\") is specified in the DATA attribute.\
    \  The client\n   is doing a form of path MTU discovery at the application layer\
    \ and,\n   thus, specifies (by including the DONT-FRAGMENT attribute) that the\n\
    \   server should set the DF bit in the UDP datagram to send to the peer.\n  \
    \ Indications cannot be authenticated using the long-term credential\n   mechanism\
    \ of STUN, so no MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-\n   SHA256 attribute\
    \ is included in the message.  An application wishing\n   to ensure that its data\
    \ is not altered or forged must integrity-\n   protect its data at the application\
    \ level.\n   Upon receipt of the Send indication, the server extracts the\n  \
    \ application data and sends it in a UDP datagram to Peer A, with the\n   relayed\
    \ transport address as the source transport address of the\n   datagram and with\
    \ the DF bit set as requested.  Note that had the\n   client not previously established\
    \ a permission for Peer A's server-\n   reflexive IP address, the server would\
    \ have silently discarded the\n   Send indication instead.\n   Peer A then replies\
    \ with its own UDP datagram containing application\n   data.  The datagram is\
    \ sent to the relayed transport address on the\n   server.  When this arrives,\
    \ the server creates a Data indication\n   containing the source of the UDP datagram\
    \ in the XOR-PEER-ADDRESS\n   attribute, and the data from the UDP datagram in\
    \ the DATA attribute.\n   The resulting Data indication is then sent to the client.\n\
    \   TURN                                 TURN          Peer          Peer\n  \
    \ client                               server         A             B\n     |---\
    \ ChannelBind request ----------->|            |             |\n     |    Transaction-Id=0x6490D3BC175AFF3D84513212\
    \    |             |\n     |    CHANNEL-NUMBER=0x4000           |            |\
    \             |\n     |    XOR-PEER-ADDRESS=192.0.2.210:49191           |    \
    \         |\n     |    USERNAME=\"George\"               |            |      \
    \       |\n     |    REALM=\"example.com\"             |            |        \
    \     |\n     |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |          \
    \   |\n     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |             |\n\
    \     |    PASSWORD-ALGORITHM=SHA256       |            |             |\n    \
    \ |    MESSAGE-INTEGRITY-SHA256=...    |            |             |\n     |<--\
    \ ChannelBind success response ---|            |             |\n     |    Transaction-Id=0x6490D3BC175AFF3D84513212\
    \    |             |\n     |    MESSAGE-INTEGRITY-SHA256=...    |            |\
    \             |\n   The client now binds a channel to Peer B, specifying a free\
    \ channel\n   number (0x4000) in the CHANNEL-NUMBER attribute, and Peer B's\n\
    \   transport address in the XOR-PEER-ADDRESS attribute.  As before, the\n   client\
    \ reuses the username, realm, and nonce from its last request in\n   the message.\n\
    \   Upon receipt of the request, the server binds the channel number to\n   the\
    \ peer, installs a permission for Peer B's IP address, and then\n   replies with\
    \ a ChannelBind success response.\n   TURN                                TURN\
    \           Peer          Peer\n   client                              server\
    \          A             B\n     |--- ChannelData ------------------>|       \
    \      |             |\n     |    Channel-number=0x4000          |--- UDP datagram\
    \ --------->|\n     |    Data=...                       |    Data=...        \
    \       |\n     |<-- ChannelData -------------------|             |          \
    \   |\n     |    Channel-number=0x4000          |             |             |\n\
    \     |    Data=...                       |             |             |\n   The\
    \ client now sends a ChannelData message to the server with data\n   destined\
    \ for Peer B.  The ChannelData message is not a STUN message;\n   thus, it has\
    \ no transaction id.  Instead, it has only three fields: a\n   channel number,\
    \ data, and data length; here, the channel number field\n   is 0x4000 (the channel\
    \ the client just bound to Peer B).  When the\n   server receives the ChannelData\
    \ message, it checks that the channel\n   is currently bound (which it is) and\
    \ then sends the data onward to\n   Peer B in a UDP datagram, using the relayed\
    \ transport address as the\n   source transport address, and 192.0.2.210:49191\
    \ (the value of the\n   XOR-PEER-ADDRESS attribute in the ChannelBind request)\
    \ as the\n   destination transport address.\n   Later, Peer B sends a UDP datagram\
    \ back to the relayed transport\n   address.  This causes the server to send a\
    \ ChannelData message to the\n   client containing the data from the UDP datagram.\
    \  The server knows\n   to which client to send the ChannelData message because\
    \ of the\n   relayed transport address at which the UDP datagram arrived, and\
    \ it\n   knows to use channel 0x4000 because this is the channel bound to\n  \
    \ 192.0.2.210:49191.  Note that if there had not been any channel\n   number bound\
    \ to that address, the server would have used a Data\n   indication instead.\n\
    \   TURN                                 TURN          Peer         Peer\n   client\
    \                               server         A            B\n     |--- ChannelBind\
    \ request ----------->|            |            |\n     |    Transaction-Id=0xE5913A8F46091637EF7D3328\
    \    |            |\n     |    CHANNEL-NUMBER=0x4000           |            |\
    \            |\n     |    XOR-PEER-ADDRESS=192.0.2.210:49191           |     \
    \       |\n     |    USERNAME=\"George\"               |            |        \
    \    |\n     |    REALM=\"example.com\"             |            |           \
    \ |\n     |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |            |\n\
    \     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n     |\
    \    PASSWORD-ALGORITHM=SHA256       |            |            |\n     |    MESSAGE-INTEGRITY-SHA256=...\
    \    |            |            |\n     |<-- ChannelBind success response ---|\
    \            |            |\n     |    Transaction-Id=0xE5913A8F46091637EF7D3328\
    \    |            |\n     |    MESSAGE-INTEGRITY-SHA256=...    |            |\
    \            |\n   The channel binding lasts for 10 minutes unless refreshed.\
    \  The TURN\n   client refreshes the binding by sending a ChannelBind request\n\
    \   rebinding the channel to the same peer (Peer B's IP address).  The\n   server\
    \ processes the ChannelBind request, rebinds the channel to the\n   same peer,\
    \ and resets the time-to-expiry timer back to 10 minutes.\n   TURN           \
    \                      TURN          Peer         Peer\n   client            \
    \                   server         A            B\n     |--- Refresh request --------------->|\
    \            |            |\n     |    Transaction-Id=0x0864B3C27ADE9354B4312414\
    \    |            |\n     |    SOFTWARE=\"Example client 1.03\"  |           \
    \ |            |\n     |    USERNAME=\"George\"               |            | \
    \           |\n     |    REALM=\"example.com\"             |            |    \
    \        |\n     |    NONCE=\"oobMatJos2gAAAadl7W7PeDU4hKE72jda\"    |       \
    \     |\n     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n\
    \     |    PASSWORD-ALGORITHM=SHA256       |            |            |\n     |\
    \    MESSAGE-INTEGRITY-SHA256=...    |            |            |\n     |<-- Refresh\
    \ error response ---------|            |            |\n     |    Transaction-Id=0x0864B3C27ADE9354B4312414\
    \    |            |\n     |    SOFTWARE=\"Example server, version 1.17\"     \
    \ |            |\n     |    ERROR-CODE=438 (Stale Nonce)    |            |   \
    \         |\n     |    REALM=\"example.com\"             |            |      \
    \      |\n     |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |         \
    \   |\n     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n\
    \     |--- Refresh request --------------->|            |            |\n     |\
    \    Transaction-Id=0x427BD3E625A85FC731DC4191    |            |\n     |    SOFTWARE=\"\
    Example client 1.03\"  |            |            |\n     |    USERNAME=\"George\"\
    \               |            |            |\n     |    REALM=\"example.com\" \
    \            |            |            |\n     |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"\
    \     |            |\n     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |\
    \            |\n     |    PASSWORD-ALGORITHM=SHA256       |            |     \
    \       |\n     |    MESSAGE-INTEGRITY-SHA256=...    |            |          \
    \  |\n     |<-- Refresh success response -------|            |            |\n\
    \     |    Transaction-Id=0x427BD3E625A85FC731DC4191    |            |\n     |\
    \    SOFTWARE=\"Example server, version 1.17\"      |            |\n     |   \
    \ LIFETIME=600 (10 minutes)       |            |            |\n     |    MESSAGE-INTEGRITY=...\
    \           |            |            |\n   Sometime before the 20-minute lifetime\
    \ is up, the client refreshes\n   the allocation.  This is done using a Refresh\
    \ request.  As before,\n   the client includes the latest username, realm, and\
    \ nonce values in\n   the request.  The client also includes the SOFTWARE attribute,\n\
    \   following the recommended practice of always including this attribute\n  \
    \ in Allocate and Refresh messages.  When the server receives the\n   Refresh\
    \ request, it notices that the nonce value has expired and so\n   replies with\
    \ a 438 (Stale Nonce) error given a new nonce value.  The\n   client then reattempts\
    \ the request, this time with the new nonce\n   value.  This second attempt is\
    \ accepted, and the server replies with\n   a success response.  Note that the\
    \ client did not include a LIFETIME\n   attribute in the request, so the server\
    \ refreshes the allocation for\n   the default lifetime of 10 minutes (as can\
    \ be seen by the LIFETIME\n   attribute in the success response).\n"
- title: 21.  Security Considerations
  contents:
  - "21.  Security Considerations\n   This section considers attacks that are possible\
    \ in a TURN deployment\n   and discusses how they are mitigated by mechanisms\
    \ in the protocol or\n   recommended practices in the implementation.\n   Most\
    \ of the attacks on TURN are mitigated by the server requiring\n   requests be\
    \ authenticated.  Thus, this specification requires the use\n   of authentication.\
    \  The mandatory-to-implement mechanism is the long-\n   term credential mechanism\
    \ of STUN.  Other authentication mechanisms\n   of equal or stronger security\
    \ properties may be used.  However, it is\n   important to ensure that they can\
    \ be invoked in an interoperable way.\n"
- title: 21.1.  Outsider Attacks
  contents:
  - "21.1.  Outsider Attacks\n   Outsider attacks are ones where the attacker has\
    \ no credentials in\n   the system and is attempting to disrupt the service seen\
    \ by the\n   client or the server.\n"
- title: 21.1.1.  Obtaining Unauthorized Allocations
  contents:
  - "21.1.1.  Obtaining Unauthorized Allocations\n   An attacker might wish to obtain\
    \ allocations on a TURN server for any\n   number of nefarious purposes.  A TURN\
    \ server provides a mechanism for\n   sending and receiving packets while cloaking\
    \ the actual IP address of\n   the client.  This makes TURN servers an attractive\
    \ target for\n   attackers who wish to use it to mask their true identity.\n \
    \  An attacker might also wish to simply utilize the services of a TURN\n   server\
    \ without paying for them.  Since TURN services require\n   resources from the\
    \ provider, it is anticipated that their usage will\n   come with a cost.\n  \
    \ These attacks are prevented using the long-term credential mechanism,\n   which\
    \ allows the TURN server to determine the identity of the\n   requestor and whether\
    \ the requestor is allowed to obtain the\n   allocation.\n"
- title: 21.1.2.  Offline Dictionary Attacks
  contents:
  - "21.1.2.  Offline Dictionary Attacks\n   The long-term credential mechanism used\
    \ by TURN is subject to offline\n   dictionary attacks.  An attacker that is capable\
    \ of eavesdropping on\n   a message exchange between a client and server can determine\
    \ the\n   password by trying a number of candidate passwords and seeing if one\n\
    \   of them is correct.  This attack works when the passwords are low\n   entropy\
    \ such as a word from the dictionary.  This attack can be\n   mitigated by using\
    \ strong passwords with large entropy.  In\n   situations where even stronger\
    \ mitigation is required, (D)TLS\n   transport between the client and the server\
    \ can be used.\n"
- title: 21.1.3.  Faked Refreshes and Permissions
  contents:
  - "21.1.3.  Faked Refreshes and Permissions\n   An attacker might wish to attack\
    \ an active allocation by sending it a\n   Refresh request with an immediate expiration\
    \ in order to delete it\n   and disrupt service to the client.  This is prevented\
    \ by\n   authentication of refreshes.  Similarly, an attacker wishing to send\n\
    \   CreatePermission requests to create permissions to undesirable\n   destinations\
    \ is prevented from doing so through authentication.  The\n   motivations for\
    \ such an attack are described in Section 21.2.\n"
- title: 21.1.4.  Fake Data
  contents:
  - "21.1.4.  Fake Data\n   An attacker might wish to send data to the client or the\
    \ peer as if\n   they came from the peer or client, respectively.  To do that,\
    \ the\n   attacker can send the client a faked Data indication or ChannelData\n\
    \   message, or send the TURN server a faked Send indication or\n   ChannelData\
    \ message.\n   Since indications and ChannelData messages are not authenticated,\n\
    \   this attack is not prevented by TURN.  However, this attack is\n   generally\
    \ present in IP-based communications and is not substantially\n   worsened by\
    \ TURN.  Consider a normal, non-TURN IP session between\n   hosts A and B.  An\
    \ attacker can send packets to B as if they came\n   from A by sending packets\
    \ towards B with a spoofed IP address of A.\n   This attack requires the attacker\
    \ to know the IP addresses of A and\n   B.  With TURN, an attacker wishing to\
    \ send packets towards a client\n   using a Data indication needs to know its\
    \ IP address (and port), the\n   IP address and port of the TURN server, and the\
    \ IP address and port\n   of the peer (for inclusion in the XOR-PEER-ADDRESS attribute).\
    \  To\n   send a fake ChannelData message to a client, an attacker needs to\n\
    \   know the IP address and port of the client, the IP address and port\n   of\
    \ the TURN server, and the channel number.  This particular\n   combination is\
    \ mildly more guessable than in the non-TURN case.\n   These attacks are more\
    \ properly mitigated by application-layer\n   authentication techniques.  In the\
    \ case of real-time traffic, usage\n   of SRTP [RFC3711] prevents these attacks.\n\
    \   In some situations, the TURN server may be situated in the network\n   such\
    \ that it is able to send to hosts to which the client cannot\n   directly send.\
    \  This can happen, for example, if the server is\n   located behind a firewall\
    \ that allows packets from outside the\n   firewall to be delivered to the server,\
    \ but not to other hosts behind\n   the firewall.  In these situations, an attacker\
    \ could send the server\n   a Send indication with an XOR-PEER-ADDRESS attribute\
    \ containing the\n   transport address of one of the other hosts behind the firewall.\
    \  If\n   the server was to allow relaying of traffic to arbitrary peers, then\n\
    \   this would provide a way for the attacker to attack arbitrary hosts\n   behind\
    \ the firewall.\n   To mitigate this attack, TURN requires that the client establish\
    \ a\n   permission to a host before sending it data.  Thus, an attacker can\n\
    \   only attack hosts with which the client is already communicating\n   unless\
    \ the attacker is able to create authenticated requests.\n   Furthermore, the\
    \ server administrator may configure the server to\n   restrict the range of IP\
    \ addresses and ports to which it will relay\n   data.  To provide even greater\
    \ security, the server administrator can\n   require that the client use (D)TLS\
    \ for all communication between the\n   client and the server.\n"
- title: 21.1.5.  Impersonating a Server
  contents:
  - "21.1.5.  Impersonating a Server\n   When a client learns a relayed address from\
    \ a TURN server, it uses\n   that relayed address in application protocols to\
    \ receive traffic.\n   Therefore, an attacker wishing to intercept or redirect\
    \ that traffic\n   might try to impersonate a TURN server and provide the client\
    \ with a\n   faked relayed address.\n   This attack is prevented through the long-term\
    \ credential mechanism,\n   which provides message integrity for responses in\
    \ addition to\n   verifying that they came from the server.  Furthermore, an attacker\n\
    \   cannot replay old server responses as the transaction id in the STUN\n   header\
    \ prevents this.  Replay attacks are further thwarted through\n   frequent changes\
    \ to the nonce value.\n"
- title: 21.1.6.  Eavesdropping Traffic
  contents:
  - "21.1.6.  Eavesdropping Traffic\n   If the TURN client and server use the STUN\
    \ Extension for Third-Party\n   Authorization [RFC7635] (for example, it is used\
    \ in WebRTC), the\n   username does not reveal the real user's identity; the USERNAME\n\
    \   attribute carries an ephemeral and unique key identifier.  If the\n   TURN\
    \ client and server use the STUN long-term credential mechanism\n   and the username\
    \ reveals the real user's identity, the client MUST\n   either use the USERHASH\
    \ attribute instead of the USERNAME attribute\n   to anonymize the username or\
    \ use (D)TLS transport between the client\n   and the server.\n   If the TURN\
    \ client and server use the STUN long-term credential\n   mechanism, and realm\
    \ information is privacy sensitive, TURN can be\n   run over (D)TLS.  As a reminder,\
    \ STUN Extension for Third-Party\n   Authorization does not use realm.\n   The\
    \ SOFTWARE attribute can reveal the specific software version of\n   the TURN\
    \ client and server to the eavesdropper, and it might possibly\n   allow attacks\
    \ against vulnerable software that is known to contain\n   security vulnerabilities.\
    \  If the software version is known to\n   contain security vulnerabilities, TURN\
    \ SHOULD be run over (D)TLS to\n   prevent leaking the SOFTWARE attribute in clear\
    \ text.  If zero-day\n   vulnerabilities are detected in the software version,\
    \ the endpoint\n   policy can be modified to mandate the use of (D)TLS until the\
    \ patch\n   is in place to fix the flaw.\n   TURN concerns itself primarily with\
    \ authentication and message\n   integrity.  Confidentiality is only a secondary\
    \ concern as TURN\n   control messages do not include information that is particularly\n\
    \   sensitive with the exception of USERNAME, REALM, and SOFTWARE.  The\n   primary\
    \ protocol content of the messages is the IP address of the\n   peer.  If it is\
    \ important to prevent an eavesdropper on a TURN\n   connection from learning\
    \ this, TURN can be run over (D)TLS.\n   Confidentiality for the application data\
    \ relayed by TURN is best\n   provided by the application protocol itself since\
    \ running TURN over\n   (D)TLS does not protect application data between the server\
    \ and the\n   peer.  If confidentiality of application data is important, then\
    \ the\n   application should encrypt or otherwise protect its data.  For\n   example,\
    \ for real-time media, confidentiality can be provided by\n   using SRTP.\n"
- title: 21.1.7.  TURN Loop Attack
  contents:
  - "21.1.7.  TURN Loop Attack\n   An attacker might attempt to cause data packets\
    \ to loop indefinitely\n   between two TURN servers.  The attack goes as follows:\
    \ first, the\n   attacker sends an Allocate request to server A using the source\n\
    \   address of server B.  Server A will send its response to server B,\n   and\
    \ for the attack to succeed, the attacker must have the ability to\n   either\
    \ view or guess the contents of this response so that the\n   attacker can learn\
    \ the allocated relayed transport address.  The\n   attacker then sends an Allocate\
    \ request to server B using the source\n   address of server A.  Again, the attacker\
    \ must be able to view or\n   guess the contents of the response so it can learn\
    \ the allocated\n   relayed transport address.  Using the same spoofed source\
    \ address\n   technique, the attacker then binds a channel number on server A\
    \ to\n   the relayed transport address on server B and similarly binds the\n \
    \  same channel number on server B to the relayed transport address on\n   server\
    \ A.  Finally, the attacker sends a ChannelData message to\n   server A.\n   The\
    \ result is a data packet that loops from the relayed transport\n   address on\
    \ server A to the relayed transport address on server B,\n   then from server\
    \ B's transport address to server A's transport\n   address, and then around the\
    \ loop again.\n   This attack is mitigated as follows: by requiring all requests\
    \ to be\n   authenticated and/or by randomizing the port number allocated for\
    \ the\n   relayed transport address, the server forces the attacker to either\n\
    \   intercept or view responses sent to a third party (in this case, the\n   other\
    \ server) so that the attacker can authenticate the requests and\n   learn the\
    \ relayed transport address.  Without one of these two\n   measures, an attacker\
    \ can guess the contents of the responses without\n   needing to see them, which\
    \ makes the attack much easier to perform.\n   Furthermore, by requiring authenticated\
    \ requests, the server forces\n   the attacker to have credentials acceptable\
    \ to the server, which\n   turns this from an outsider attack into an insider\
    \ attack and allows\n   the attack to be traced back to the client initiating\
    \ it.\n   The attack can be further mitigated by imposing a per-username limit\n\
    \   on the bandwidth used to relay data by allocations owned by that\n   username\
    \ to limit the impact of this attack on other allocations.\n   More mitigation\
    \ can be achieved by decrementing the TTL when relaying\n   data packets (if the\
    \ underlying OS allows this).\n"
- title: 21.2.  Firewall Considerations
  contents:
  - "21.2.  Firewall Considerations\n   A key security consideration of TURN is that\
    \ TURN should not weaken\n   the protections afforded by firewalls deployed between\
    \ a client and a\n   TURN server.  It is anticipated that TURN servers will often\
    \ be\n   present on the public Internet, and clients may often be inside\n   enterprise\
    \ networks with corporate firewalls.  If TURN servers\n   provide a \"backdoor\"\
    \ for reaching into the enterprise, TURN will be\n   blocked by these firewalls.\n\
    \   TURN servers therefore emulate the behavior of NAT devices that\n   implement\
    \ address-dependent filtering [RFC4787], a property common in\n   many firewalls\
    \ as well.  When a NAT or firewall implements this\n   behavior, packets from\
    \ an outside IP address are only allowed to be\n   sent to an internal IP address\
    \ and port if the internal IP address\n   and port had recently sent a packet\
    \ to that outside IP address.  TURN\n   servers introduce the concept of permissions,\
    \ which provide exactly\n   this same behavior on the TURN server.  An attacker\
    \ cannot send a\n   packet to a TURN server and expect it to be relayed towards\
    \ the\n   client, unless the client has tried to contact the attacker first.\n\
    \   It is important to note that some firewalls have policies that are\n   even\
    \ more restrictive than address-dependent filtering.  Firewalls\n   can also be\
    \ configured with address- and port-dependent filtering, or\n   they can be configured\
    \ to disallow inbound traffic entirely.  In\n   these cases, if a client is allowed\
    \ to connect the TURN server,\n   communications to the client will be less restrictive\
    \ than what the\n   firewall would normally allow.\n"
- title: 21.2.1.  Faked Permissions
  contents:
  - "21.2.1.  Faked Permissions\n   In firewalls and NAT devices, permissions are\
    \ granted implicitly\n   through the traversal of a packet from the inside of\
    \ the network\n   towards the outside peer.  Thus, a permission cannot, by definition,\n\
    \   be created by any entity except one inside the firewall or NAT.  With\n  \
    \ TURN, this restriction no longer holds.  Since the TURN server sits\n   outside\
    \ the firewall, an attacker outside the firewall can now send a\n   message to\
    \ the TURN server and try to create a permission for itself.\n   This attack is\
    \ prevented because all messages that create permissions\n   (i.e., ChannelBind\
    \ and CreatePermission) are authenticated.\n"
- title: 21.2.2.  Blacklisted IP Addresses
  contents:
  - "21.2.2.  Blacklisted IP Addresses\n   Many firewalls can be configured with blacklists\
    \ that prevent a\n   client behind the firewall from sending packets to, or receiving\n\
    \   packets from, ranges of blacklisted IP addresses.  This is\n   accomplished\
    \ by inspecting the source and destination addresses of\n   packets entering and\
    \ exiting the firewall, respectively.\n   This feature is also present in TURN\
    \ since TURN servers are allowed\n   to arbitrarily restrict the range of addresses\
    \ of peers that they\n   will relay to.\n"
- title: 21.2.3.  Running Servers on Well-Known Ports
  contents:
  - "21.2.3.  Running Servers on Well-Known Ports\n   A malicious client behind a\
    \ firewall might try to connect to a TURN\n   server and obtain an allocation\
    \ that it then uses to run a server.\n   For example, a client might try to run\
    \ a DNS server or FTP server.\n   This is not possible in TURN.  A TURN server\
    \ will never accept\n   traffic from a peer for which the client has not installed\
    \ a\n   permission.  Thus, peers cannot just connect to the allocated port in\n\
    \   order to obtain the service.\n"
- title: 21.3.  Insider Attacks
  contents:
  - "21.3.  Insider Attacks\n   In insider attacks, a client has legitimate credentials\
    \ but defies\n   the trust relationship that goes with those credentials.  These\n\
    \   attacks cannot be prevented by cryptographic means but need to be\n   considered\
    \ in the design of the protocol.\n"
- title: 21.3.1.  DoS against TURN Server
  contents:
  - "21.3.1.  DoS against TURN Server\n   A client wishing to disrupt service to other\
    \ clients might obtain an\n   allocation and then flood it with traffic in an\
    \ attempt to swamp the\n   server and prevent it from servicing other legitimate\
    \ clients.  This\n   is mitigated by the recommendation that the server limit\
    \ the amount\n   of bandwidth it will relay for a given username.  This won't\
    \ prevent\n   a client from sending a large amount of traffic, but it allows the\n\
    \   server to immediately discard traffic in excess.\n   Since each allocation\
    \ uses a port number on the IP address of the\n   TURN server, the number of allocations\
    \ on a server is finite.  An\n   attacker might attempt to consume all of them\
    \ by requesting a large\n   number of allocations.  This is prevented by the recommendation\
    \ that\n   the server impose a limit on the number of allocations active at a\n\
    \   time for a given username.\n"
- title: 21.3.2.  Anonymous Relaying of Malicious Traffic
  contents:
  - "21.3.2.  Anonymous Relaying of Malicious Traffic\n   TURN servers provide a degree\
    \ of anonymization.  A client can send\n   data to peers without revealing its\
    \ own IP address.  TURN servers may\n   therefore become attractive vehicles for\
    \ attackers to launch attacks\n   against targets without fear of detection. \
    \ Indeed, it is possible\n   for a client to chain together multiple TURN servers\
    \ such that any\n   number of relays can be used before a target receives a packet.\n\
    \   Administrators who are worried about this attack can maintain logs\n   that\
    \ capture the actual source IP and port of the client and perhaps\n   even every\
    \ permission that client installs.  This will allow for\n   forensic tracing to\
    \ determine the original source should it be\n   discovered that an attack is\
    \ being relayed through a TURN server.\n"
- title: 21.3.3.  Manipulating Other Allocations
  contents:
  - "21.3.3.  Manipulating Other Allocations\n   An attacker might attempt to disrupt\
    \ service to other users of the\n   TURN server by sending Refresh requests or\
    \ CreatePermission requests\n   that (through source address spoofing) appear\
    \ to be coming from\n   another user of the TURN server.  TURN prevents this by\
    \ requiring\n   that the credentials used in CreatePermission, Refresh, and\n\
    \   ChannelBind messages match those used to create the initial\n   allocation.\
    \  Thus, the fake requests from the attacker will be\n   rejected.\n"
- title: 21.4.  Tunnel Amplification Attack
  contents:
  - "21.4.  Tunnel Amplification Attack\n   An attacker might attempt to cause data\
    \ packets to loop numerous\n   times between a TURN server and a tunnel between\
    \ IPv4 and IPv6.  The\n   attack goes as follows:\n   Suppose an attacker knows\
    \ that a tunnel endpoint will forward\n   encapsulated packets from a given IPv6\
    \ address (this doesn't\n   necessarily need to be the tunnel endpoint's address).\
    \  Suppose he\n   then spoofs two packets from this address:\n   1.  An Allocate\
    \ request asking for a v4 address, and\n   2.  A ChannelBind request establishing\
    \ a channel to the IPv4 address\n       of the tunnel endpoint.\n   Then, he has\
    \ set up an amplification attack:\n   *  The TURN server will re-encapsulate IPv6\
    \ UDP data in v4 and send\n      it to the tunnel endpoint.\n   *  The tunnel\
    \ endpoint will de-encapsulate packets from the v4\n      interface and send them\
    \ to v6.\n   So, if the attacker sends a packet of the following form:\n     IPv6:\
    \ src=2001:DB8:1::1 dst=2001:DB8::2\n     UDP:  <ports>\n     TURN: <channel id>\n\
    \     IPv6: src=2001:DB8:1::1 dst=2001:DB8::2\n     UDP:  <ports>\n     TURN:\
    \ <channel id>\n     IPv6: src=2001:DB8:1::1 dst=2001:DB8::2\n     UDP:  <ports>\n\
    \     TURN: <channel id>\n     ...\n   then the TURN server and the tunnel endpoint\
    \ will send it back and\n   forth until the last TURN header is consumed, at which\
    \ point the TURN\n   server will send an empty packet that the tunnel endpoint\
    \ will drop.\n   The amplification potential here is limited by the MTU, so it's\
    \ not\n   huge: IPv6+UDP+TURN takes 334 bytes, so a four-to-one amplification\n\
    \   out of a 1500-byte packet is possible.  But, the attacker could still\n  \
    \ increase traffic volume by sending multiple packets or by\n   establishing multiple\
    \ channels spoofed from different addresses\n   behind the same tunnel endpoint.\n\
    \   The attack is mitigated as follows.  It is RECOMMENDED that TURN\n   servers\
    \ not accept allocation or channel-binding requests from\n   addresses known to\
    \ be tunneled, and that they not forward data to\n   such addresses.  In particular,\
    \ a TURN server MUST NOT accept Teredo\n   or 6to4 addresses in these requests.\n"
- title: 21.5.  Other Considerations
  contents:
  - "21.5.  Other Considerations\n   Any relay addresses learned through an Allocate\
    \ request will not\n   operate properly with IPsec Authentication Header (AH)\
    \ [RFC4302] in\n   transport or tunnel mode.  However, tunnel-mode IPsec Encapsulating\n\
    \   Security Payload (ESP) [RFC4303] should still operate.\n"
- title: 22.  IANA Considerations
  contents:
  - "22.  IANA Considerations\n   The code points for the STUN methods defined in\
    \ this specification\n   are listed in Section 17.  IANA has updated the references\
    \ from\n   [RFC5766] to this document (for the STUN methods listed in\n   Section\
    \ 17).\n   The code points for the STUN attributes defined in this specification\n\
    \   are listed in Section 18.  IANA has updated the references from\n   [RFC5766]\
    \ to this document (for the STUN attributes CHANNEL-NUMBER,\n   LIFETIME, Reserved\
    \ (was BANDWIDTH), XOR-PEER-ADDRESS, DATA, XOR-\n   RELAYED-ADDRESS, REQUESTED-ADDRESS-FAMILY,\
    \ EVEN-PORT, REQUESTED-\n   TRANSPORT, DONT-FRAGMENT, Reserved (was TIMER-VAL),\
    \ and RESERVATION-\n   TOKEN listed in Section 18).\n   The code points for the\
    \ STUN error codes defined in this\n   specification are listed in Section 19.\
    \  IANA has updated the\n   references from [RFC5766] and [RFC6156] to this document\
    \ (for the\n   STUN error codes listed in Section 19).\n   IANA has updated the\
    \ references to [RFC5766] to this document for the\n   SRV service name of \"\
    turn\" for TURN over UDP or TCP and the service\n   name of \"turns\" for TURN\
    \ over (D)TLS.\n   IANA has created a registry for TURN channel numbers (the \"\
    Traversal\n   Using Relays around NAT (TURN) Channel Numbers\" registry), initially\n\
    \   populated as follows:\n   | 0x0000 through         | Reserved and not available\
    \ for use since |\n   | 0x3FFF:                | they conflict with the STUN header.\
    \      |\n   | 0x4000 through         | A TURN implementation is free to use \
    \    |\n   | 0x4FFF:                | channel numbers in this range.         \
    \  |\n   | 0x5000 through         | Reserved (For DTLS-SRTP multiplexing     |\n\
    \   | 0xFFFF:                | collision avoidance, see [RFC7983])      |\n  \
    \ Any change to this registry must be made through an IETF Standards\n   Action.\n"
- title: 23.  IAB Considerations
  contents:
  - "23.  IAB Considerations\n   The IAB has studied the problem of Unilateral Self-Address\
    \ Fixing\n   (UNSAF), which is the general process by which a client attempts\
    \ to\n   determine its address in another realm on the other side of a NAT\n \
    \  through a collaborative protocol reflection mechanism [RFC3424].  The\n   TURN\
    \ extension is an example of a protocol that performs this type of\n   function.\
    \  The IAB has mandated that any protocols developed for this\n   purpose document\
    \ a specific set of considerations.  These\n   considerations and the responses\
    \ for TURN are documented in this\n   section.\n   Consideration 1: Precise definition\
    \ of a specific, limited-scope\n   problem that is to be solved with the UNSAF\
    \ proposal.  A short-term\n   fix should not be generalized to solve other problems.\
    \  Such\n   generalizations lead to the prolonged dependence on and usage of the\n\
    \   supposed short-term fix, meaning that it is no longer accurate to\n   call\
    \ it \"short-term\".\n   Response: TURN is a protocol for communication between\
    \ a relay (=\n   TURN server) and its client.  The protocol allows a client that\
    \ is\n   behind a NAT to obtain and use a public IP address on the relay.  As\n\
    \   a convenience to the client, TURN also allows the client to determine\n  \
    \ its server-reflexive transport address.\n   Consideration 2: Description of\
    \ an exit strategy/transition plan.\n   The better short-term fixes are the ones\
    \ that will naturally see less\n   and less use as the appropriate technology\
    \ is deployed.\n   Response: TURN will no longer be needed once there are no longer\
    \ any\n   NATs.  Unfortunately, as of the date of publication of this document,\n\
    \   it no longer seems very likely that NATs will go away any time soon.\n   However,\
    \ the need for TURN will also decrease as the number of NATs\n   with the mapping\
    \ property of Endpoint-Independent Mapping [RFC4787]\n   increases.\n   Consideration\
    \ 3: Discussion of specific issues that may render\n   systems more \"brittle\"\
    .  For example, approaches that involve using\n   data at multiple network layers\
    \ create more dependencies, increase\n   debugging challenges, and make it harder\
    \ to transition.\n   Response: TURN is \"brittle\" in that it requires the NAT\
    \ bindings\n   between the client and the server to be maintained unchanged for\
    \ the\n   lifetime of the allocation.  This is typically done using keep-\n  \
    \ alives.  If this is not done, then the client will lose its\n   allocation and\
    \ can no longer exchange data with its peers.\n   Consideration 4: Identify requirements\
    \ for longer-term, sound\n   technical solutions; contribute to the process of\
    \ finding the right\n   longer-term solution.\n   Response: The need for TURN\
    \ will be reduced once NATs implement the\n   recommendations for NAT UDP behavior\
    \ documented in [RFC4787].\n   Applications are also strongly urged to use ICE\
    \ [RFC8445] to\n   communicate with peers; though ICE uses TURN, it does so only\
    \ as a\n   last resort, and it uses it in a controlled manner.\n   Consideration\
    \ 5: Discussion of the impact of the noted practical\n   issues with existing\
    \ deployed NATs and experience reports.\n   Response: Some NATs deployed today\
    \ exhibit a mapping behavior other\n   than Endpoint-Independent mapping.  These\
    \ NATs are difficult to work\n   with, as they make it difficult or impossible\
    \ for protocols like ICE\n   to use server-reflexive transport addresses on those\
    \ NATs.  A client\n   behind such a NAT is often forced to use a relay protocol\
    \ like TURN\n   because \"UDP hole punching\" techniques [RFC5128] do not work.\n"
- title: 24.  Changes since RFC 5766
  contents:
  - "24.  Changes since RFC 5766\n   This section lists the major changes in the TURN\
    \ protocol from the\n   original [RFC5766] specification.\n   *  IPv6 support.\n\
    \   *  REQUESTED-ADDRESS-FAMILY attribute.\n   *  Description of the tunnel amplification\
    \ attack.\n   *  DTLS support.\n   *  Add support for receiving ICMP packets.\n\
    \   *  Updates PMTUD.\n   *  Discovery of TURN server.\n   *  TURN URI Scheme\
    \ Semantics.\n   *  Happy Eyeballs for TURN.\n   *  Align with the changes in\
    \ STUN [RFC8489].\n"
- title: 25.  Updates to RFC 6156
  contents:
  - "25.  Updates to RFC 6156\n   This section lists the major updates to [RFC6156]\
    \ in this\n   specification.\n   *  ADDITIONAL-ADDRESS-FAMILY and ADDRESS-ERROR-CODE\
    \ attributes.\n   *  440 (Address Family not Supported) and 443 (Peer Address\
    \ Family\n      Mismatch) responses.\n   *  More details on packet translation.\n\
    \   *  TCP-to-UDP and UDP-to-TCP relaying.\n"
- title: 26.  References
  contents:
  - '26.  References

    '
- title: 26.1.  Normative References
  contents:
  - "26.1.  Normative References\n   [PROTOCOL-NUMBERS]\n              IANA, \"Protocol\
    \ Numbers\",\n              <https://www.iana.org/assignments/protocol-numbers>.\n\
    \   [RFC0792]  Postel, J., \"Internet Control Message Protocol\", STD 5,\n   \
    \           RFC 792, DOI 10.17487/RFC0792, September 1981,\n              <https://www.rfc-editor.org/info/rfc792>.\n\
    \   [RFC1122]  Braden, R., Ed., \"Requirements for Internet Hosts -\n        \
    \      Communication Layers\", STD 3, RFC 1122,\n              DOI 10.17487/RFC1122,\
    \ October 1989,\n              <https://www.rfc-editor.org/info/rfc1122>.\n  \
    \ [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n          \
    \    Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2474]\
    \  Nichols, K., Blake, S., Baker, F., and D. Black,\n              \"Definition\
    \ of the Differentiated Services Field (DS\n              Field) in the IPv4 and\
    \ IPv6 Headers\", RFC 2474,\n              DOI 10.17487/RFC2474, December 1998,\n\
    \              <https://www.rfc-editor.org/info/rfc2474>.\n   [RFC3168]  Ramakrishnan,\
    \ K., Floyd, S., and D. Black, \"The Addition\n              of Explicit Congestion\
    \ Notification (ECN) to IP\",\n              RFC 3168, DOI 10.17487/RFC3168, September\
    \ 2001,\n              <https://www.rfc-editor.org/info/rfc3168>.\n   [RFC3629]\
    \  Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\"\
    , STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n              2003, <https://www.rfc-editor.org/info/rfc3629>.\n\
    \   [RFC4443]  Conta, A., Deering, S., and M. Gupta, Ed., \"Internet\n       \
    \       Control Message Protocol (ICMPv6) for the Internet\n              Protocol\
    \ Version 6 (IPv6) Specification\", STD 89,\n              RFC 4443, DOI 10.17487/RFC4443,\
    \ March 2006,\n              <https://www.rfc-editor.org/info/rfc4443>.\n   [RFC6347]\
    \  Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n              Security\
    \ Version 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n              January 2012,\
    \ <https://www.rfc-editor.org/info/rfc6347>.\n   [RFC6437]  Amante, S., Carpenter,\
    \ B., Jiang, S., and J. Rajahalme,\n              \"IPv6 Flow Label Specification\"\
    , RFC 6437,\n              DOI 10.17487/RFC6437, November 2011,\n            \
    \  <https://www.rfc-editor.org/info/rfc6437>.\n   [RFC7065]  Petit-Huguenin, M.,\
    \ Nandakumar, S., Salgueiro, G., and P.\n              Jones, \"Traversal Using\
    \ Relays around NAT (TURN) Uniform\n              Resource Identifiers\", RFC\
    \ 7065, DOI 10.17487/RFC7065,\n              November 2013, <https://www.rfc-editor.org/info/rfc7065>.\n\
    \   [RFC7350]  Petit-Huguenin, M. and G. Salgueiro, \"Datagram Transport\n   \
    \           Layer Security (DTLS) as Transport for Session Traversal\n       \
    \       Utilities for NAT (STUN)\", RFC 7350, DOI 10.17487/RFC7350,\n        \
    \      August 2014, <https://www.rfc-editor.org/info/rfc7350>.\n   [RFC7525] \
    \ Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations\
    \ for Secure Use of Transport Layer\n              Security (TLS) and Datagram\
    \ Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,\
    \ May\n              2015, <https://www.rfc-editor.org/info/rfc7525>.\n   [RFC7915]\
    \  Bao, C., Li, X., Baker, F., Anderson, T., and F. Gont,\n              \"IP/ICMP\
    \ Translation Algorithm\", RFC 7915,\n              DOI 10.17487/RFC7915, June\
    \ 2016,\n              <https://www.rfc-editor.org/info/rfc7915>.\n   [RFC7982]\
    \  Martinsen, P., Reddy, T., Wing, D., and V. Singh,\n              \"Measurement\
    \ of Round-Trip Time and Fractional Loss Using\n              Session Traversal\
    \ Utilities for NAT (STUN)\", RFC 7982,\n              DOI 10.17487/RFC7982, September\
    \ 2016,\n              <https://www.rfc-editor.org/info/rfc7982>.\n   [RFC8174]\
    \  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119\
    \ Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,\
    \ <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8200]  Deering, S. and R.\
    \ Hinden, \"Internet Protocol, Version 6\n              (IPv6) Specification\"\
    , STD 86, RFC 8200,\n              DOI 10.17487/RFC8200, July 2017,\n        \
    \      <https://www.rfc-editor.org/info/rfc8200>.\n   [RFC8305]  Schinazi, D.\
    \ and T. Pauly, \"Happy Eyeballs Version 2:\n              Better Connectivity\
    \ Using Concurrency\", RFC 8305,\n              DOI 10.17487/RFC8305, December\
    \ 2017,\n              <https://www.rfc-editor.org/info/rfc8305>.\n   [RFC8446]\
    \  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n             \
    \ Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n\
    \   [RFC8489]  Petit-Huguenin, M., Salgueiro, G., Rosenberg, J., Wing,\n     \
    \         D., Mahy, R., and P. Matthews, \"Session Traversal\n              Utilities\
    \ for NAT (STUN)\", RFC 8489, DOI 10.17487/RFC8489,\n              February 2020,\
    \ <https://www.rfc-editor.org/info/rfc8489>.\n"
- title: 26.2.  Informative References
  contents:
  - "26.2.  Informative References\n   [FRAG-FRAGILE]\n              Bonica, R., Baker,\
    \ F., Huston, G., Hinden, R., Troan, O.,\n              and F. Gont, \"IP Fragmentation\
    \ Considered Fragile\", Work\n              in Progress, Internet-Draft, draft-ietf-intarea-frag-\n\
    \              fragile-17, 30 September 2019,\n              <https://tools.ietf.org/html/draft-ietf-intarea-frag-\n\
    \              fragile-17>.\n   [FRAG-HARMFUL]\n              Kent, C. and J.\
    \ Mogul, \"Fragmentation Considered Harmful\",\n              December 1987, <https://www.hpl.hp.com/techreports/Compaq-\n\
    \              DEC/WRL-87-3.pdf>.\n   [MTU-DATAGRAM]\n              Fairhurst,\
    \ G., Jones, T., Tuexen, M., Ruengeler, I., and\n              T. Voelker, \"\
    Packetization Layer Path MTU Discovery for\n              Datagram Transports\"\
    , Work in Progress, Internet-Draft,\n              draft-ietf-tsvwg-datagram-plpmtud-14,\
    \ 12 February 2020,\n              <https://tools.ietf.org/html/draft-ietf-tsvwg-datagram-\n\
    \              plpmtud-14>.\n   [MTU-STUN] Petit-Huguenin, M., Salgueiro, G.,\
    \ and F. Garrido,\n              \"Packetization Layer Path MTU Discovery (PLMTUD)\
    \ For UDP\n              Transports Using Session Traversal Utilities for NAT\n\
    \              (STUN)\", Work in Progress, Internet-Draft, draft-ietf-\n     \
    \         tram-stun-pmtud-15, 17 December 2019,\n              <https://tools.ietf.org/html/draft-ietf-tram-stun-pmtud-\n\
    \              15>.\n   [PORT-NUMBERS]\n              IANA, \"Service Name and\
    \ Transport Protocol Port Number\n              Registry\",\n              <https://www.iana.org/assignments/port-numbers>.\n\
    \   [RFC0791]  Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n          \
    \    DOI 10.17487/RFC0791, September 1981,\n              <https://www.rfc-editor.org/info/rfc791>.\n\
    \   [RFC1191]  Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191,\n \
    \             DOI 10.17487/RFC1191, November 1990,\n              <https://www.rfc-editor.org/info/rfc1191>.\n\
    \   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G.\n    \
    \          J., and E. Lear, \"Address Allocation for Private\n              Internets\"\
    , BCP 5, RFC 1918, DOI 10.17487/RFC1918,\n              February 1996, <https://www.rfc-editor.org/info/rfc1918>.\n\
    \   [RFC1928]  Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and\n   \
    \           L. Jones, \"SOCKS Protocol Version 5\", RFC 1928,\n              DOI\
    \ 10.17487/RFC1928, March 1996,\n              <https://www.rfc-editor.org/info/rfc1928>.\n\
    \   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n    \
    \          A., Peterson, J., Sparks, R., Handley, M., and E.\n              Schooler,\
    \ \"SIP: Session Initiation Protocol\", RFC 3261,\n              DOI 10.17487/RFC3261,\
    \ June 2002,\n              <https://www.rfc-editor.org/info/rfc3261>.\n   [RFC3424]\
    \  Daigle, L., Ed. and IAB, \"IAB Considerations for\n              UNilateral\
    \ Self-Address Fixing (UNSAF) Across Network\n              Address Translation\"\
    , RFC 3424, DOI 10.17487/RFC3424,\n              November 2002, <https://www.rfc-editor.org/info/rfc3424>.\n\
    \   [RFC3550]  Schulzrinne, H., Casner, S., Frederick, R., and V.\n          \
    \    Jacobson, \"RTP: A Transport Protocol for Real-Time\n              Applications\"\
    , STD 64, RFC 3550, DOI 10.17487/RFC3550,\n              July 2003, <https://www.rfc-editor.org/info/rfc3550>.\n\
    \   [RFC3711]  Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.\n   \
    \           Norrman, \"The Secure Real-time Transport Protocol (SRTP)\",\n   \
    \           RFC 3711, DOI 10.17487/RFC3711, March 2004,\n              <https://www.rfc-editor.org/info/rfc3711>.\n\
    \   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n             \
    \ \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n             \
    \ DOI 10.17487/RFC4086, June 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n\
    \   [RFC4302]  Kent, S., \"IP Authentication Header\", RFC 4302,\n           \
    \   DOI 10.17487/RFC4302, December 2005,\n              <https://www.rfc-editor.org/info/rfc4302>.\n\
    \   [RFC4303]  Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n      \
    \        RFC 4303, DOI 10.17487/RFC4303, December 2005,\n              <https://www.rfc-editor.org/info/rfc4303>.\n\
    \   [RFC4787]  Audet, F., Ed. and C. Jennings, \"Network Address\n           \
    \   Translation (NAT) Behavioral Requirements for Unicast\n              UDP\"\
    , BCP 127, RFC 4787, DOI 10.17487/RFC4787, January\n              2007, <https://www.rfc-editor.org/info/rfc4787>.\n\
    \   [RFC4821]  Mathis, M. and J. Heffner, \"Packetization Layer Path MTU\n   \
    \           Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007,\n       \
    \       <https://www.rfc-editor.org/info/rfc4821>.\n   [RFC5128]  Srisuresh, P.,\
    \ Ford, B., and D. Kegel, \"State of Peer-to-\n              Peer (P2P) Communication\
    \ across Network Address\n              Translators (NATs)\", RFC 5128, DOI 10.17487/RFC5128,\
    \ March\n              2008, <https://www.rfc-editor.org/info/rfc5128>.\n   [RFC5482]\
    \  Eggert, L. and F. Gont, \"TCP User Timeout Option\",\n              RFC 5482,\
    \ DOI 10.17487/RFC5482, March 2009,\n              <https://www.rfc-editor.org/info/rfc5482>.\n\
    \   [RFC5766]  Mahy, R., Matthews, P., and J. Rosenberg, \"Traversal Using\n \
    \             Relays around NAT (TURN): Relay Extensions to Session\n        \
    \      Traversal Utilities for NAT (STUN)\", RFC 5766,\n              DOI 10.17487/RFC5766,\
    \ April 2010,\n              <https://www.rfc-editor.org/info/rfc5766>.\n   [RFC5925]\
    \  Touch, J., Mankin, A., and R. Bonica, \"The TCP\n              Authentication\
    \ Option\", RFC 5925, DOI 10.17487/RFC5925,\n              June 2010, <https://www.rfc-editor.org/info/rfc5925>.\n\
    \   [RFC5928]  Petit-Huguenin, M., \"Traversal Using Relays around NAT\n     \
    \         (TURN) Resolution Mechanism\", RFC 5928,\n              DOI 10.17487/RFC5928,\
    \ August 2010,\n              <https://www.rfc-editor.org/info/rfc5928>.\n   [RFC6056]\
    \  Larsen, M. and F. Gont, \"Recommendations for Transport-\n              Protocol\
    \ Port Randomization\", BCP 156, RFC 6056,\n              DOI 10.17487/RFC6056,\
    \ January 2011,\n              <https://www.rfc-editor.org/info/rfc6056>.\n  \
    \ [RFC6062]  Perreault, S., Ed. and J. Rosenberg, \"Traversal Using\n        \
    \      Relays around NAT (TURN) Extensions for TCP Allocations\",\n          \
    \    RFC 6062, DOI 10.17487/RFC6062, November 2010,\n              <https://www.rfc-editor.org/info/rfc6062>.\n\
    \   [RFC6156]  Camarillo, G., Novo, O., and S. Perreault, Ed., \"Traversal\n \
    \             Using Relays around NAT (TURN) Extension for IPv6\",\n         \
    \     RFC 6156, DOI 10.17487/RFC6156, April 2011,\n              <https://www.rfc-editor.org/info/rfc6156>.\n\
    \   [RFC6263]  Marjou, X. and A. Sollaud, \"Application Mechanism for\n      \
    \        Keeping Alive the NAT Mappings Associated with RTP / RTP\n          \
    \    Control Protocol (RTCP) Flows\", RFC 6263,\n              DOI 10.17487/RFC6263,\
    \ June 2011,\n              <https://www.rfc-editor.org/info/rfc6263>.\n   [RFC7413]\
    \  Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, \"TCP\n              Fast\
    \ Open\", RFC 7413, DOI 10.17487/RFC7413, December 2014,\n              <https://www.rfc-editor.org/info/rfc7413>.\n\
    \   [RFC7478]  Holmberg, C., Hakansson, S., and G. Eriksson, \"Web Real-\n   \
    \           Time Communication Use Cases and Requirements\", RFC 7478,\n     \
    \         DOI 10.17487/RFC7478, March 2015,\n              <https://www.rfc-editor.org/info/rfc7478>.\n\
    \   [RFC7635]  Reddy, T., Patil, P., Ravindranath, R., and J. Uberti,\n      \
    \        \"Session Traversal Utilities for NAT (STUN) Extension for\n        \
    \      Third-Party Authorization\", RFC 7635,\n              DOI 10.17487/RFC7635,\
    \ August 2015,\n              <https://www.rfc-editor.org/info/rfc7635>.\n   [RFC7657]\
    \  Black, D., Ed. and P. Jones, \"Differentiated Services\n              (Diffserv)\
    \ and Real-Time Communication\", RFC 7657,\n              DOI 10.17487/RFC7657,\
    \ November 2015,\n              <https://www.rfc-editor.org/info/rfc7657>.\n \
    \  [RFC7983]  Petit-Huguenin, M. and G. Salgueiro, \"Multiplexing Scheme\n   \
    \           Updates for Secure Real-time Transport Protocol (SRTP)\n         \
    \     Extension for Datagram Transport Layer Security (DTLS)\",\n            \
    \  RFC 7983, DOI 10.17487/RFC7983, September 2016,\n              <https://www.rfc-editor.org/info/rfc7983>.\n\
    \   [RFC8155]  Patil, P., Reddy, T., and D. Wing, \"Traversal Using Relays\n \
    \             around NAT (TURN) Server Auto Discovery\", RFC 8155,\n         \
    \     DOI 10.17487/RFC8155, April 2017,\n              <https://www.rfc-editor.org/info/rfc8155>.\n\
    \   [RFC8311]  Black, D., \"Relaxing Restrictions on Explicit Congestion\n   \
    \           Notification (ECN) Experimentation\", RFC 8311,\n              DOI\
    \ 10.17487/RFC8311, January 2018,\n              <https://www.rfc-editor.org/info/rfc8311>.\n\
    \   [RFC8445]  Keranen, A., Holmberg, C., and J. Rosenberg, \"Interactive\n  \
    \            Connectivity Establishment (ICE): A Protocol for Network\n      \
    \        Address Translator (NAT) Traversal\", RFC 8445,\n              DOI 10.17487/RFC8445,\
    \ July 2018,\n              <https://www.rfc-editor.org/info/rfc8445>.\n   [SDP-ICE]\
    \  Petit-Huguenin, M., Nandakumar, S., Holmberg, C., Keranen,\n              A.,\
    \ and R. Shpount, \"Session Description Protocol (SDP)\n              Offer/Answer\
    \ procedures for Interactive Connectivity\n              Establishment (ICE)\"\
    , Work in Progress, Internet-Draft,\n              draft-ietf-mmusic-ice-sip-sdp-39,\
    \ 13 August 2019,\n              <https://tools.ietf.org/html/draft-ietf-mmusic-ice-sip-\n\
    \              sdp-39>.\n   [SEC-WEBRTC]\n              Rescorla, E., \"Security\
    \ Considerations for WebRTC\", Work\n              in Progress, Internet-Draft,\
    \ draft-ietf-rtcweb-security-\n              12, 5 July 2019, <https://tools.ietf.org/html/draft-ietf-\n\
    \              rtcweb-security-12>.\n   [TCP-EXT]  Ford, A., Raiciu, C., Handley,\
    \ M., Bonaventure, O., and C.\n              Paasch, \"TCP Extensions for Multipath\
    \ Operation with\n              Multiple Addresses\", Work in Progress, Internet-Draft,\n\
    \              draft-ietf-mptcp-rfc6824bis-18, 8 June 2019,\n              <https://tools.ietf.org/html/draft-ietf-mptcp-rfc6824bis-\n\
    \              18>.\n   [UDP-OPT]  Touch, J., \"Transport Options for UDP\", Work\
    \ in Progress,\n              Internet-Draft, draft-ietf-tsvwg-udp-options-08,\
    \ 12\n              September 2019, <https://tools.ietf.org/html/draft-ietf-\n\
    \              tsvwg-udp-options-08>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Most of the text in this note comes from the original TURN\n\
    \   specification, [RFC5766].  The authors would like to thank Rohan\n   Mahy,\
    \ coauthor of the original TURN specification, and everyone who\n   had contributed\
    \ to that document.  The authors would also like to\n   acknowledge that this\
    \ document inherits material from [RFC6156].\n   Thanks to Justin Uberti, Pal\
    \ Martinsen, Oleg Moskalenko, Aijun Wang,\n   and Simon Perreault for their help\
    \ on the ADDITIONAL-ADDRESS-FAMILY\n   mechanism.  The authors would like to thank\
    \ Gonzalo Salgueiro, Simon\n   Perreault, Jonathan Lennox, Brandon Williams, Karl\
    \ Stahl, Noriyuki\n   Torii, Nils Ohlmeier, Dan Wing, Vijay Gurbani, Joseph Touch,\
    \ Justin\n   Uberti, Christopher Wood, Roman Danyliw, Eric Vyncke, Adam Roach,\n\
    \   Suresh Krishnan, Mirja Kuehlewind, Benjamin Kaduk, and Oleg\n   Moskalenko\
    \ for comments and review.  The authors would like to thank\n   Marc Petit-Huguenin\
    \ for his contributions to the text.\n   Special thanks to Magnus Westerlund for\
    \ the detailed AD review.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Tirumaleswar Reddy (editor)\n   McAfee, Inc.\n   Embassy\
    \ Golf Link Business Park\n   Bangalore 560071\n   Karnataka\n   India\n   Email:\
    \ kondtir@gmail.com\n   Alan Johnston (editor)\n   Villanova University\n   Villanova,\
    \ PA\n   United States of America\n   Email: alan.b.johnston@gmail.com\n   Philip\
    \ Matthews\n   Alcatel-Lucent\n   600 March Road\n   Ottawa Ontario\n   Canada\n\
    \   Email: philip_matthews@magma.ca\n   Jonathan Rosenberg\n   jdrosen.net\n \
    \  Edison, NJ\n   United States of America\n"
