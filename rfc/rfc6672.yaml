- contents:
  - '                      DNAME Redirection in the DNS

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The DNAME record provides redirection for a subtree of the domain\n
    \  name tree in the DNS.  That is, all names that end with a particular\n   suffix
    are redirected to another part of the DNS.  This document\n   obsoletes the original
    specification in RFC 2672 as well as updates\n   the document on representing
    IPv6 addresses in DNS (RFC 3363).\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6672.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n     1.1.  Requirements Language  . . . . . . . . . . . . . .
    . . . .  4\n   2.  The DNAME Resource Record  . . . . . . . . . . . . . . . .
    . .  5\n     2.1.  Format . . . . . . . . . . . . . . . . . . . . . . . . . .
    \ 5\n     2.2.  The DNAME Substitution . . . . . . . . . . . . . . . . . .  5\n
    \    2.3.  DNAME Owner Name Matching the QNAME  . . . . . . . . . . .  6\n     2.4.
    \ Names next to and below a DNAME Record . . . . . . . . . .  7\n     2.5.  Compression
    of the DNAME Record  . . . . . . . . . . . . .  7\n   3.  Processing . . . . .
    . . . . . . . . . . . . . . . . . . . . .  8\n     3.1.  CNAME Synthesis  . .
    . . . . . . . . . . . . . . . . . . .  8\n     3.2.  Server Algorithm . . . .
    . . . . . . . . . . . . . . . . .  9\n     3.3.  Wildcards  . . . . . . . . .
    . . . . . . . . . . . . . . . 10\n     3.4.  Acceptance and Intermediate Storage
    \ . . . . . . . . . . . 11\n       3.4.1.  Resolver Algorithm . . . . . . . .
    . . . . . . . . . . 11\n   4.  DNAME Discussions in Other Documents . . . . .
    . . . . . . . . 12\n   5.  Other Issues with DNAME  . . . . . . . . . . . . .
    . . . . . . 13\n     5.1.  Canonical Hostnames Cannot Be below DNAME Owners .
    . . . . 13\n     5.2.  Dynamic Update and DNAME . . . . . . . . . . . . . . .
    . . 13\n     5.3.  DNSSEC and DNAME . . . . . . . . . . . . . . . . . . . . .
    14\n       5.3.1.  Signed DNAME, Unsigned Synthesized CNAME . . . . . . . 14\n
    \      5.3.2.  DNAME Bit in NSEC Type Map . . . . . . . . . . . . . . 14\n       5.3.3.
    \ DNAME Chains as Strong as the Weakest Link . . . . . . 14\n       5.3.4.  Validators
    Must Understand DNAME . . . . . . . . . . . 14\n         5.3.4.1.  Invalid Name
    Error Response Caused by DNAME in\n                   Bitmap . . . . . . . . .
    . . . . . . . . . . . . . 15\n         5.3.4.2.  Valid Name Error Response Involving
    DNAME in\n                   Bitmap . . . . . . . . . . . . . . . . . . . . .
    . 15\n         5.3.4.3.  Response with Synthesized CNAME  . . . . . . . . . 16\n
    \  6.  Examples of DNAME Use in a Zone  . . . . . . . . . . . . . . . 16\n     6.1.
    \ Organizational Renaming  . . . . . . . . . . . . . . . . . 16\n     6.2.  Classless
    Delegation of Shorter Prefixes . . . . . . . . . 17\n     6.3.  Network Renumbering
    Support  . . . . . . . . . . . . . . . 17\n   7.  IANA Considerations  . . . .
    . . . . . . . . . . . . . . . . . 18\n   8.  Security Considerations  . . . .
    . . . . . . . . . . . . . . . 18\n   9.  Acknowledgments  . . . . . . . . . .
    . . . . . . . . . . . . . 18\n   10. References . . . . . . . . . . . . . . .
    . . . . . . . . . . . 19\n     10.1. Normative References . . . . . . . . . .
    . . . . . . . . . 19\n     10.2. Informative References . . . . . . . . . . .
    . . . . . . . 20\n   Appendix A.  Changes from RFC 2672 . . . . . . . . . . .
    . . . . . 21\n     A.1.  Changes to Server Behavior . . . . . . . . . . . . .
    . . . 21\n     A.2.  Changes to Client Behavior . . . . . . . . . . . . . . .
    . 21\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   DNAME is a DNS resource record type originally defined in
    RFC 2672\n   [RFC2672].  DNAME provides redirection from a part of the DNS name\n
    \  tree to another part of the DNS name tree.\n   The DNAME RR and the CNAME RR
    [RFC1034] cause a lookup to\n   (potentially) return data corresponding to a domain
    name different\n   from the queried domain name.  The difference between the two\n
    \  resource records is that the CNAME RR directs the lookup of data at\n   its
    owner to another single name, whereas a DNAME RR directs lookups\n   for data
    at descendants of its owner's name to corresponding names\n   under a different
    (single) node of the tree.\n   For example, take looking through a zone (see RFC
    1034 [RFC1034],\n   Section 4.3.2, step 3) for the domain name \"foo.example.com\",
    and a\n   DNAME resource record is found at \"example.com\" indicating that all\n
    \  queries under \"example.com\" be directed to \"example.net\".  The lookup\n
    \  process will return to step 1 with the new query name of\n   \"foo.example.net\".
    \ Had the query name been \"www.foo.example.com\",\n   the new query name would
    be \"www.foo.example.net\".\n   This document is a revision of the original specification
    of DNAME in\n   RFC 2672 [RFC2672].  DNAME was conceived to help with the problem
    of\n   maintaining address-to-name mappings in a context of network\n   renumbering.
    \ With a careful setup, a renumbering event in the\n   network causes no change
    to the authoritative server that has the\n   address-to-name mappings.  Examples
    in practice are classless reverse\n   address space delegations.\n   Another usage
    of DNAME lies in aliasing of name spaces.  For example,\n   a zone administrator
    may want subtrees of the DNS to contain the same\n   information.  Examples include
    punycode [RFC3492] alternates for\n   domain spaces.\n   This revision of the
    DNAME specification does not change the wire\n   format or the handling of DNAME
    resource records.  Discussion is\n   added on problems that may be encountered
    when using DNAME.\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\" \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in RFC\n   2119 [RFC2119].\n"
    title: 1.1.  Requirements Language
  title: 1.  Introduction
- contents:
  - '2.  The DNAME Resource Record

    '
  - contents:
    - "2.1.  Format\n   The DNAME RR has mnemonic DNAME and type code 39 (decimal).
      \ It is\n   CLASS-insensitive.\n   Its RDATA is comprised of a single field,
      <target>, which contains a\n   fully qualified domain name that MUST be sent
      in uncompressed form\n   [RFC1035] [RFC3597].  The <target> field MUST be present.
      \ The\n   presentation format of <target> is that of a domain name [RFC1035].\n
      \  The presentation format of the RR is as follows:\n           <owner> <ttl>
      <class> DNAME <target>\n   The effect of the DNAME RR is the substitution of
      the record's\n   <target> for its owner name, as a suffix of a domain name.
      \ This\n   substitution is to be applied for all names below the owner name
      of\n   the DNAME RR.  This substitution has to be applied for every DNAME RR\n
      \  found in the resolution process, which allows fairly lengthy valid\n   chains
      of DNAME RRs.\n   Details of the substitution process, methods to avoid conflicting\n
      \  resource records, and rules for specific corner cases are given in\n   the
      following subsections.\n"
    title: 2.1.  Format
  - contents:
    - "2.2.  The DNAME Substitution\n   When following step 3 of the algorithm in
      RFC 1034 [RFC1034], Section\n   4.3.2, \"start matching down, label by label,
      in the zone\" and a node\n   is found to own a DNAME resource record, a DNAME
      substitution occurs.\n   The name being sought may be the original query name
      or a name that\n   is the result of a CNAME resource record being followed or
      a\n   previously encountered DNAME.  As in the case when finding a CNAME\n   resource
      record or NS resource record set, the processing of a DNAME\n   will happen
      prior to finding the desired domain name.\n   A DNAME substitution is performed
      by replacing the suffix labels of\n   the name being sought matching the owner
      name of the DNAME resource\n   record with the string of labels in the RDATA
      field.  The matching\n   labels end with the root label in all cases.  Only
      whole labels are\n   replaced.  See the table of examples for common cases and
      corner\n   cases.\n   In the table below, the QNAME refers to the query name.
      \ The owner is\n   the DNAME owner domain name, and the target refers to the
      target of\n   the DNAME record.  The result is the resulting name after performing\n
      \  the DNAME substitution on the query name. \"no match\" means that the\n   query
      did not match the DNAME, and thus no substitution is performed\n   and a possible
      error message is returned (if no other result is\n   possible).  Thus, every
      line contains one example substitution.  In\n   the examples below, 'cyc' and
      'shortloop' contain loops.\n    QNAME            owner  DNAME   target         result\n
      \   ---------------- -------------- -------------- -----------------\n    com.
      \            example.com.   example.net.   <no match>\n    example.com.     example.com.
      \  example.net.   [0]\n    a.example.com.   example.com.   example.net.   a.example.net.\n
      \   a.b.example.com. example.com.   example.net.   a.b.example.net.\n    ab.example.com.
      \ b.example.com. example.net.   <no match>\n    foo.example.com. example.com.
      \  example.net.   foo.example.net.\n    a.x.example.com. x.example.com. example.net.
      \  a.example.net.\n    a.example.com.   example.com.   y.example.net. a.y.example.net.\n
      \   cyc.example.com. example.com.   example.com.   cyc.example.com.\n    cyc.example.com.
      example.com.   c.example.com. cyc.c.example.com.\n    shortloop.x.x.   x.             .
      \             shortloop.x.\n    shortloop.x.     x.             .              shortloop.\n
      \  [0] The result depends on the QTYPE.  If the QTYPE = DNAME, then\n       the
      result is \"example.com.\", else \"<no match>\".\n                   Table 1.
      DNAME Substitution Examples\n   It is possible for DNAMEs to form loops, just
      as CNAMEs can form\n   loops.  DNAMEs and CNAMEs can chain together to form
      loops.  A single\n   corner case DNAME can form a loop.  Resolvers and servers
      should be\n   cautious in devoting resources to a query, but be aware that fairly\n
      \  long chains of DNAMEs may be valid.  Zone content administrators\n   should
      take care to ensure that there are no loops that could occur\n   when using
      DNAME or DNAME/CNAME redirection.\n   The domain name can get too long during
      substitution.  For example,\n   suppose the target name of the DNAME RR is 250
      octets in length\n   (multiple labels), if an incoming QNAME that has a first
      label over 5\n   octets in length, the result would be a name over 255 octets.
      \ If\n   this occurs, the server returns an RCODE of YXDOMAIN [RFC2136].  The\n
      \  DNAME record and its signature (if the zone is signed) are included\n   in
      the answer as proof for the YXDOMAIN (value 6) RCODE.\n"
    title: 2.2.  The DNAME Substitution
  - contents:
    - "2.3.  DNAME Owner Name Matching the QNAME\n   Unlike a CNAME RR, a DNAME RR
      redirects DNS names subordinate to its\n   owner name; the owner name of a DNAME
      is not redirected itself.  The\n   domain name that owns a DNAME record is allowed
      to have other\n   resource record types at that domain name, except DNAMEs,
      CNAMEs, or\n   other types that have restrictions on what they can coexist with.\n
      \  When there is a match of the QTYPE to a type (or types) also owned by\n   the
      owner name, the response is sourced from the owner name.  For\n   example, a
      QTYPE of ANY would return the (available) types at the\n   owner name, not the
      target name.\n   DNAME RRs MUST NOT appear at the same owner name as an NS RR
      unless\n   the owner name is the zone apex; if it is not the zone apex, then
      the\n   NS RR signifies a delegation point, and the DNAME RR must in that\n
      \  case appear below the zone cut at the zone apex of the child zone.\n   If
      a DNAME record is present at the zone apex, there is still a need\n   to have
      the customary SOA and NS resource records there as well.\n   Such a DNAME cannot
      be used to mirror a zone completely, as it does\n   not mirror the zone apex.\n
      \  These rules also allow DNAME records to be queried through caches\n   that
      are RFC 1034 [RFC1034] compliant and are DNAME unaware.\n"
    title: 2.3.  DNAME Owner Name Matching the QNAME
  - contents:
    - "2.4.  Names next to and below a DNAME Record\n   Resource records MUST NOT
      exist at any subdomain of the owner of a\n   DNAME RR.  To get the contents
      for names subordinate to that owner\n   name, the DNAME redirection must be
      invoked and the resulting target\n   queried.  A server MAY refuse to load a
      zone that has data at a\n   subdomain of a domain name owning a DNAME RR.  If
      the server does\n   load the zone, those names below the DNAME RR will be occluded
      as\n   described in RFC 2136 [RFC2136], Section 7.18.  Also, a server ought\n
      \  to refuse to load a zone subordinate to the owner of a DNAME record\n   in
      the ancestor zone.  See Section 5.2 for further discussion related\n   to dynamic
      update.\n   DNAME is a singleton type, meaning only one DNAME is allowed per\n
      \  name.  The owner name of a DNAME can only have one DNAME RR, and no\n   CNAME
      RRs can exist at that name.  These rules make sure that for a\n   single domain
      name, only one redirection exists; thus, there's no\n   confusion about which
      one to follow.  A server ought to refuse to\n   load a zone that violates these
      rules.\n"
    title: 2.4.  Names next to and below a DNAME Record
  - contents:
    - "2.5.  Compression of the DNAME Record\n   The DNAME owner name can be compressed
      like any other owner name.\n   The DNAME RDATA target name MUST NOT be sent
      out in compressed form\n   and MUST be downcased for DNS Security Extensions
      (DNSSEC)\n   validation.\n   Although the previous DNAME specification [RFC2672]
      (that is\n   obsoleted by this specification) talked about signaling to allow\n
      \  compression of the target name, such signaling has never been\n   specified,
      nor is it specified in this document.\n   RFC 2672 (obsoleted by this document)
      states that the Extended DNS\n   (EDNS) version has a means for understanding
      DNAME and DNAME target\n   name compression.  This document revises RFC 2672,
      in that there is\n   no EDNS version signaling for DNAME.\n"
    title: 2.5.  Compression of the DNAME Record
  title: 2.  The DNAME Resource Record
- contents:
  - '3.  Processing

    '
  - contents:
    - "3.1.  CNAME Synthesis\n   When preparing a response, a server performing a
      DNAME substitution\n   will, in all cases, include the relevant DNAME RR in
      the answer\n   section.  Relevant cases includes the following:\n   1.  The
      DNAME is being employed as a substitution instruction.\n   2.  The DNAME itself
      matches the QTYPE, and the owner name matches\n       QNAME.\n   When the owner
      name matches the QNAME and the QTYPE matches another\n   type owned there, the
      DNAME is not included in the answer.\n   A CNAME RR with Time to Live (TTL)
      equal to the corresponding DNAME\n   RR is synthesized and included in the answer
      section when the DNAME\n   is employed as a substitution instruction.  The owner
      name of the\n   CNAME is the QNAME of the query.  The DNSSEC specification ([RFC4033]\n
      \  [RFC4034] [RFC4035]) says that the synthesized CNAME does not have to\n   be
      signed.  The signed DNAME has an RRSIG, and a validating resolver\n   can check
      the CNAME against the DNAME record and validate the\n   signature over the DNAME
      RR.\n   Servers MUST be able to answer a query for a synthesized CNAME.  Like\n
      \  other query types, this invokes the DNAME, and then the server\n   synthesizes
      the CNAME and places it into the answer section.  If the\n   server in question
      is a cache, the synthesized CNAME's TTL SHOULD be\n   equal to the decremented
      TTL of the cached DNAME.\n   Resolvers MUST be able to handle a synthesized
      CNAME TTL of zero or a\n   value equal to the TTL of the corresponding DNAME
      record (as some\n   older, authoritative server implementations set the TTL
      of\n   synthesized CNAMEs to zero).  A TTL of zero means that the CNAME can\n
      \  be discarded immediately after processing the answer.\n"
    title: 3.1.  CNAME Synthesis
  - contents:
    - "3.2.  Server Algorithm\n   Below is the revised version of the server algorithm,
      which appears\n   in RFC 2672, Section 4.1.\n   1.  Set or clear the value of
      recursion available in the response\n       depending on whether the name server
      is willing to provide\n       recursive service.  If recursive service is available
      and\n       requested via the RD bit in the query, go to step 5; otherwise,\n
      \      step 2.\n   2.  Search the available zones for the zone which is the
      nearest\n       ancestor to QNAME.  If such a zone is found, go to step 3;\n
      \      otherwise, step 4.\n   3.  Start matching down, label by label, in the
      zone.  The matching\n       process can terminate several ways:\n       A.  If
      the whole of QNAME is matched, we have found the node.\n           If the data
      at the node is a CNAME, and QTYPE does not match\n           CNAME, copy the
      CNAME RR into the answer section of the\n           response, change QNAME to
      the canonical name in the CNAME RR,\n           and go back to step 1.\n           Otherwise,
      copy all RRs which match QTYPE into the answer\n           section and go to
      step 6.\n       B.  If a match would take us out of the authoritative data,
      we\n           have a referral.  This happens when we encounter a node with\n
      \          NS RRs marking cuts along the bottom of a zone.\n           Copy
      the NS RRs for the sub-zone into the authority section\n           of the reply.
      \ Put whatever addresses are available into the\n           additional section,
      using glue RRs if the addresses are not\n           available from authoritative
      data or the cache.  Go to step\n           4.\n       C.  If at some label,
      a match is impossible (i.e., the\n           corresponding label does not exist),
      look to see whether the\n           last label matched has a DNAME record.\n
      \          If a DNAME record exists at that point, copy that record into\n           the
      answer section.  If substitution of its <target> for its\n           <owner>
      in QNAME would overflow the legal size for a <domain-\n           name>, set
      RCODE to YXDOMAIN [RFC2136] and exit; otherwise,\n           perform the substitution
      and continue.  The server MUST\n           synthesize a CNAME record as described
      above and include it\n           in the answer section.  Go back to step 1.\n
      \          If there was no DNAME record, look to see if the \"*\" label\n           exists.\n
      \          If the \"*\" label does not exist, check whether the name we\n           are
      looking for is the original QNAME in the query or a name\n           we have
      followed due to a CNAME or DNAME.  If the name is\n           original, set
      an authoritative name error in the response and\n           exit.  Otherwise,
      just exit.\n           If the \"*\" label does exist, match RRs at that node
      against\n           QTYPE.  If any match, copy them into the answer section,
      but\n           set the owner of the RR to be QNAME, and not the node with\n
      \          the \"*\" label.  If the data at the node with the \"*\" label is\n
      \          a CNAME, and QTYPE doesn't match CNAME, copy the CNAME RR\n           into
      the answer section of the response changing the owner\n           name to the
      QNAME, change QNAME to the canonical name in the\n           CNAME RR, and go
      back to step 1.  Otherwise, go to step 6.\n   4.  Start matching down in the
      cache.  If QNAME is found in the\n       cache, copy all RRs attached to it
      that match QTYPE into the\n       answer section.  If QNAME is not found in
      the cache but a DNAME\n       record is present at an ancestor of QNAME, copy
      that DNAME record\n       into the answer section.  If there was no delegation
      from\n       authoritative data, look for the best one from the cache, and put\n
      \      it in the authority section.  Go to step 6.\n   5.  Use the local resolver
      or a copy of its algorithm to answer the\n       query.  Store the results,
      including any intermediate CNAMEs and\n       DNAMEs, in the answer section
      of the response.\n   6.  Using local data only, attempt to add other RRs that
      may be\n       useful to the additional section of the query.  Exit.\n   Note
      that there will be at most one ancestor with a DNAME as\n   described in step
      4 unless some zone's data is in violation of the\n   no-descendants limitation
      in Section 3.  An implementation might take\n   advantage of this limitation
      by stopping the search of step 3c or\n   step 4 when a DNAME record is encountered.\n"
    title: 3.2.  Server Algorithm
  - contents:
    - "3.3.  Wildcards\n   The use of DNAME in conjunction with wildcards is discouraged\n
      \  [RFC4592].  Thus, records of the form \"*.example.com DNAME\n   example.net\"
      SHOULD NOT be used.\n   The interaction between the expansion of the wildcard
      and the\n   redirection of the DNAME is non-deterministic.  Due to the fact
      that\n   the processing is non-deterministic, DNSSEC validating resolvers may\n
      \  not be able to validate a wildcarded DNAME.\n   A server MAY give a warning
      that the behavior is unspecified if such\n   a wildcarded DNAME is loaded.  The
      server MAY refuse it, refuse to\n   load the zone, or refuse dynamic updates.\n"
    title: 3.3.  Wildcards
  - contents:
    - "3.4.  Acceptance and Intermediate Storage\n   Recursive caching name servers
      can encounter data at names below the\n   owner name of a DNAME RR, due to a
      change at the authoritative server\n   where data from before and after the
      change resides in the cache.\n   This conflict situation is a transitional phase
      that ends when the\n   old data times out.  The caching name server can opt
      to store both\n   old and new data and treat each as if the other did not exist,
      or\n   drop the old data, or drop the longer domain name.  In any approach,\n
      \  consistency returns after the older data TTL times out.\n   Recursive caching
      name servers MUST perform CNAME synthesis on behalf\n   of clients.\n   If a
      recursive caching name server encounters a DNSSEC validated\n   DNAME RR that
      contradicts information already in the cache (excluding\n   CNAME records),
      it SHOULD cache the DNAME RR, but it MAY cache the\n   CNAME record received
      along with it, subject to the rules for CNAME.\n   If the DNAME RR cannot be
      validated via DNSSEC (i.e., not BOGUS, but\n   not able to validate), the recursive
      caching server SHOULD NOT cache\n   the DNAME RR but MAY cache the CNAME record
      received along with it,\n   subject to the rules for CNAME.\n"
    - contents:
      - "3.4.1.  Resolver Algorithm\n   Below is the revised version of the resolver
        algorithm, which appears\n   in RFC 2672, Section 4.2.\n   1.  See if the
        answer is in local information or can be synthesized\n       from a cached
        DNAME; if so, return it to the client.\n   2.  Find the best servers to ask.\n
        \  3.  Send queries until one returns a response.\n   4.  Analyze the response,
        either:\n       A.  If the response answers the question or contains a name\n
        \          error, cache the data as well as return it back to the\n           client.\n
        \      B.  If the response contains a better delegation to other\n           servers,
        cache the delegation information, and go to step 2.\n       C.  If the response
        shows a CNAME and that is not the answer\n           itself, cache the CNAME,
        change the SNAME to the canonical\n           name in the CNAME RR, and go
        to step 1.\n       D.  If the response shows a DNAME and that is not the answer\n
        \          itself, cache the DNAME (upon successful DNSSEC validation if\n
        \          the client is a validating resolver).  If substitution of the\n
        \          DNAME's target name for its owner name in the SNAME would\n           overflow
        the legal size for a domain name, return an\n           implementation-dependent
        error to the application; otherwise,\n           perform the substitution
        and go to step 1.\n       E.  If the response shows a server failure or other
        bizarre\n           contents, delete the server from the SLIST and go back
        to\n           step 3.\n"
      title: 3.4.1.  Resolver Algorithm
    title: 3.4.  Acceptance and Intermediate Storage
  title: 3.  Processing
- contents:
  - "4.  DNAME Discussions in Other Documents\n   In Section 10.3 of [RFC2181], the
    discussion on MX and NS records\n   touches on redirection by CNAMEs, but this
    also holds for DNAMEs.\n   Section 10.3 (\"MX and NS records\") of [RFC2181] states:\n
    \          The domain name used as the value of a NS resource record,\n           or
    part of the value of a MX resource record must not be\n           an alias.  Not
    only is the specification clear on this\n           point, but using an alias
    in either of these positions\n           neither works as well as might be hoped,
    nor well fulfills\n           the ambition that may have led to this approach.
    \ This\n           domain name must have as its value one or more address\n           records.
    \ Currently those will be A records, however in\n           the future other record
    types giving addressing\n           information may be acceptable.  It can also
    have other\n           RRs, but never a CNAME RR.\n   The DNAME RR is discussed
    in RFC 3363, Section 4, on A6 and DNAME.\n   The opening premise of this section
    is demonstrably wrong, and so the\n   conclusion based on that premise is wrong.
    \ In particular, [RFC3363]\n   deprecates the use of DNAME in the IPv6 reverse
    tree.  Based on the\n   experience gained in the meantime, [RFC3363] is revised,
    dropping all\n   constraints on having DNAME RRs in these zones [RFC6434].  This
    would\n   greatly improve the manageability of the IPv6 reverse tree.  These\n
    \  changes are made explicit below.\n   In [RFC3363], the following paragraph
    is updated by this document,\n   and the use of DNAME RRs in the reverse tree
    is no longer deprecated.\n     The issues for DNAME in the reverse mapping tree
    appears to be\n     closely tied to the need to use fragmented A6 in the main
    tree: if\n     one is necessary, so is the other, and if one isn't necessary,
    the\n     other isn't either.  Therefore, in moving RFC 2874 to experimental,\n
    \    the intent of this document is that use of DNAME RRs in the reverse\n     tree
    be deprecated.\n"
  title: 4.  DNAME Discussions in Other Documents
- contents:
  - "5.  Other Issues with DNAME\n   There are several issues to be aware of about
    the use of DNAME.\n"
  - contents:
    - "5.1.  Canonical Hostnames Cannot Be below DNAME Owners\n   The names listed
      as target names of MX, NS, PTR, and SRV [RFC2782]\n   records must be canonical
      hostnames.  This means no CNAME or DNAME\n   redirection may be present during
      DNS lookup of the address records\n   for the host.  This is discussed in RFC
      2181 [RFC2181], Section 10.3,\n   and RFC 1912 [RFC1912], Section 2.4.  For
      SRV, see RFC 2782\n   [RFC2782], page 4.\n   The upshot of this is that although
      the lookup of a PTR record can\n   involve DNAMEs, the name listed in the PTR
      record cannot fall under a\n   DNAME.  The same holds for NS, SRV, and MX records.
      \ For example,\n   when punycode [RFC3492] alternates for a zone use DNAME,
      then the NS,\n   MX, SRV, and PTR records that point to that zone must use names
      that\n   are not aliases in their RDATA.  Then, what must be done is to have\n
      \  the domain names with DNAME substitution already applied to it as the\n   MX,
      NS, PTR, and SRV data.  These are valid canonical hostnames.\n"
    title: 5.1.  Canonical Hostnames Cannot Be below DNAME Owners
  - contents:
    - "5.2.  Dynamic Update and DNAME\n   DNAME records can be added, changed, and
      removed in a zone using\n   dynamic update transactions.  Adding a DNAME RR
      to a zone occludes\n   any domain names that may exist under the added DNAME.\n
      \  If a dynamic update message attempts to add a DNAME with a given\n   owner
      name, but a CNAME is associated with that name, then the server\n   MUST ignore
      the DNAME.  If a DNAME is already associated with that\n   name, then it is
      replaced with the new DNAME.  Otherwise, add the\n   DNAME.  If a CNAME is added
      with a given owner name, but a DNAME is\n   associated with that name, then
      the CNAME MUST be ignored.  Similar\n   behavior occurs for dynamic updates
      to an owner name of a CNAME RR\n   [RFC2136].\n"
    title: 5.2.  Dynamic Update and DNAME
  - contents:
    - "5.3.  DNSSEC and DNAME\n   The following subsections specify the behavior of
      implementations\n   that understand both DNSSEC and DNAME (synthesis).\n"
    - contents:
      - "5.3.1.  Signed DNAME, Unsigned Synthesized CNAME\n   In any response, a signed
        DNAME RR indicates a non-terminal\n   redirection of the query.  There might
        or might not be a server-\n   synthesized CNAME in the answer section; if
        there is, the CNAME will\n   never be signed.  For a DNSSEC validator, verification
        of the DNAME\n   RR and then that the CNAME was properly synthesized is sufficient\n
        \  proof.\n"
      title: 5.3.1.  Signed DNAME, Unsigned Synthesized CNAME
    - contents:
      - "5.3.2.  DNAME Bit in NSEC Type Map\n   In any negative response, the NSEC
        or NSEC3 [RFC5155] record type\n   bitmap SHOULD be checked to see that there
        was no DNAME that could\n   have been applied.  If the DNAME bit in the type
        bitmap is set and\n   the query name is a subdomain of the closest encloser
        that is\n   asserted, then DNAME substitution should have been done, but the\n
        \  substitution has not been done as specified.\n"
      title: 5.3.2.  DNAME Bit in NSEC Type Map
    - contents:
      - "5.3.3.  DNAME Chains as Strong as the Weakest Link\n   A response can contain
        a chain of DNAME and CNAME redirections.  That\n   chain can end in a positive
        answer or a negative reply (no name error\n   or no data error).  Each step
        in that chain results in resource\n   records being added to the answer or
        authority section of the\n   response.  Only if all steps are secure can the
        AD (Authentic Data)\n   bit be set for the response.  If one of the steps
        is bogus, the\n   result is bogus.\n"
      title: 5.3.3.  DNAME Chains as Strong as the Weakest Link
    - contents:
      - "5.3.4.  Validators Must Understand DNAME\n   Below are examples of why DNSSEC
        validators MUST understand DNAME.\n   In the examples, SOA records, wildcard
        denial NSECs, and other\n   material not under discussion have been omitted
        or shortened.\n"
      - contents:
        - "5.3.4.1.  Invalid Name Error Response Caused by DNAME in Bitmap\n   ;;
          Header: QR AA RCODE=3(NXDOMAIN)\n   ;; OPT PSEUDOSECTION:\n   ; EDNS: version:
          0, flags: do; udp: 4096\n   ;; Question\n   foo.bar.example.com. IN A\n
          \  ;; Authority\n   bar.example.com. NSEC dub.example.com. A DNAME\n   bar.example.com.
          RRSIG NSEC [valid signature]\n   If this is the received response, then
          only by understanding that the\n   DNAME bit in the NSEC bitmap means that
          foo.bar.example.com needed to\n   have been redirected by the DNAME, the
          validator can see that it is a\n   BOGUS reply from an attacker that collated
          existing records from the\n   DNS to create a confusing reply.\n   If the
          DNAME bit had not been set in the NSEC record above, then the\n   answer
          would have validated as a correct name error response.\n"
        title: 5.3.4.1.  Invalid Name Error Response Caused by DNAME in Bitmap
      - contents:
        - "5.3.4.2.  Valid Name Error Response Involving DNAME in Bitmap\n   ;; Header:
          QR AA RCODE=3(NXDOMAIN)\n   ;; OPT PSEUDOSECTION:\n   ; EDNS: version: 0,
          flags: do; udp: 4096\n   ;; Question\n   cee.example.com. IN A\n   ;; Authority\n
          \  bar.example.com. NSEC dub.example.com. A DNAME\n   bar.example.com. RRSIG
          NSEC [valid signature]\n   This response has the same NSEC records as the
          example above, but\n   with this query name (cee.example.com), the answer
          is validated,\n   because 'cee' does not get redirected by the DNAME at
          'bar'.\n"
        title: 5.3.4.2.  Valid Name Error Response Involving DNAME in Bitmap
      - contents:
        - "5.3.4.3.  Response with Synthesized CNAME\n   ;; Header: QR AA RCODE=0(NOERROR)\n
          \  ;; OPT PSEUDOSECTION:\n   ; EDNS: version: 0, flags: do; udp: 4096\n
          \  ;; Question\n   foo.bar.example.com. IN A\n   ;; Answer\n   bar.example.com.
          DNAME bar.example.net.\n   bar.example.com. RRSIG DNAME [valid signature]\n
          \  foo.bar.example.com. CNAME foo.bar.example.net.\n   The response shown
          above has the synthesized CNAME included.\n   However, the CNAME has no
          signature, since the server does not sign\n   online.  So this response
          cannot be trusted.  It could be altered by\n   an attacker to be foo.bar.example.com
          CNAME bla.bla.example.  The\n   DNAME record does have its signature included,
          since it does not\n   change.  The validator must verify the DNAME signature
          and then\n   recursively resolve further in order to query for the\n   foo.bar.example.net
          A record.\n"
        title: 5.3.4.3.  Response with Synthesized CNAME
      title: 5.3.4.  Validators Must Understand DNAME
    title: 5.3.  DNSSEC and DNAME
  title: 5.  Other Issues with DNAME
- contents:
  - "6.  Examples of DNAME Use in a Zone\n   Below are some examples of the use of
    DNAME in a zone.  These\n   examples are by no means exhaustive.\n"
  - contents:
    - "6.1.  Organizational Renaming\n   If an organization with domain name FROBOZZ.EXAMPLE.NET
      became part\n   of an organization with domain name ACME.EXAMPLE.COM, it might
      ease\n   transition by placing information such as this in its old zone.\n       frobozz.example.net.
      \ DNAME    frobozz-division.acme.example.com.\n                             MX
      \      10       mailhub.acme.example.com.\n   The response to an extended recursive
      query for\n   www.frobozz.example.net would contain, in the answer section,
      the\n   DNAME record shown above and the relevant RRs for www.frobozz-\n   division.acme.example.com.\n
      \  If an organization wants to have aliases for names, for a different\n   spelling
      or language, the same example applies.  Note that the MX RR\n   at the zone
      apex is not redirected and has to be repeated in the\n   target zone.  Also
      note that the services at mailhub or www.frobozz-\n   division.acme.example.com.
      have to recognize and handle the aliases.\n"
    title: 6.1.  Organizational Renaming
  - contents:
    - "6.2.  Classless Delegation of Shorter Prefixes\n   The classless scheme for
      in-addr.arpa delegation [RFC2317] can be\n   extended to prefixes shorter than
      24 bits by use of the DNAME record.\n   For example, the prefix 192.0.8.0/22
      can be delegated by the\n   following records.\n       $ORIGIN 0.192.in-addr.arpa.\n
      \      8/22    NS       ns.slash-22-holder.example.com.\n       8       DNAME
      \   8.8/22\n       9       DNAME    9.8/22\n       10      DNAME    10.8/22\n
      \      11      DNAME    11.8/22\n   A typical entry in the resulting reverse
      zone for some host with\n   address 192.0.9.33 might be as follows:\n        $ORIGIN
      8/22.0.192.in-addr.arpa.\n        33.9    PTR     somehost.slash-22-holder.example.com.\n
      \  The advisory remarks in [RFC2317] concerning the choice of the \"/\"\n   character
      apply here as well.\n"
    title: 6.2.  Classless Delegation of Shorter Prefixes
  - contents:
    - "6.3.  Network Renumbering Support\n   If IPv4 network renumbering were common,
      maintenance of address space\n   delegation could be simplified by using DNAME
      records instead of NS\n   records to delegate.\n       $ORIGIN new-style.in-addr.arpa.\n
      \      189.190           DNAME    in-addr.example.net.\n       $ORIGIN in-addr.example.net.\n
      \      188               DNAME    in-addr.customer.example.com.\n       $ORIGIN
      in-addr.customer.example.\n       1                 PTR      www.customer.example.com\n
      \      2                 PTR      mailhub.customer.example.com.\n       ; etc
      ...\n   This would allow the address space 190.189.0.0/16 assigned to the ISP\n
      \  \"example.net\" to be changed without having to alter the zone data\n   describing
      the use of that space by the ISP and its customers.\n   Renumbering IPv4 networks
      is currently so arduous a task that\n   updating the DNS is only a small part
      of the labor, so this scheme\n   may have a low value.  But it is hoped that
      in IPv6 the renumbering\n   task will be quite different, and the DNAME mechanism
      may play a\n   useful part.\n"
    title: 6.3.  Network Renumbering Support
  title: 6.  Examples of DNAME Use in a Zone
- contents:
  - "7.  IANA Considerations\n   The DNAME resource record type code 39 (decimal)
    originally was\n   registered by [RFC2672] in the DNS Resource Record (RR) Types\n
    \  registry table at http://www.iana.org/assignments/dns-parameters.\n   IANA
    has updated the DNS resource record registry to point to this\n   document for
    RR type 39.\n"
  title: 7.  IANA Considerations
- contents:
  - "8.  Security Considerations\n   DNAME redirects queries elsewhere, which may
    impact security based on\n   policy and the security status of the zone with the
    DNAME and the\n   redirection zone's security status.  For validating resolvers,
    the\n   lowest security status of the links in the chain of CNAME and DNAME\n
    \  redirections is applied to the result.\n   If a validating resolver accepts
    wildcarded DNAMEs, this creates\n   security issues.  Since the processing of
    a wildcarded DNAME is non-\n   deterministic and the CNAME that was substituted
    by the server has no\n   signature, the resolver may choose a different result
    than what the\n   server meant, and consequently end up at the wrong destination.
    \ Use\n   of wildcarded DNAMEs is discouraged in any case [RFC4592].\n   A validating
    resolver MUST understand DNAME, according to [RFC4034].\n   The examples in Section
    5.3.4 illustrate this need.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  Acknowledgments\n   The authors of this document would like to acknowledge
    Matt Larson\n   for beginning this effort to address the issues related to the
    DNAME\n   RR type.  The authors would also like to acknowledge Paul Vixie, Ed\n
    \  Lewis, Mark Andrews, Mike StJohns, Niall O'Reilly, Sam Weiler, Alfred\n   Hoenes,
    and Kevin Darcy for their reviews and comments on this\n   document.\n"
  title: 9.  Acknowledgments
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names
      - concepts and facilities\",\n              STD 13, RFC 1034, November 1987.\n
      \  [RFC1035]  Mockapetris, P., \"Domain names - implementation and\n              specification\",
      STD 13, RFC 1035, November 1987.\n   [RFC2119]  Bradner, S., \"Key words for
      use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC2136]  Vixie, P., Thomson, S., Rekhter, Y., and J. Bound,\n
      \             \"Dynamic Updates in the Domain Name System (DNS UPDATE)\",\n
      \             RFC 2136, April 1997.\n   [RFC2181]  Elz, R. and R. Bush, \"Clarifications
      to the DNS\n              Specification\", RFC 2181, July 1997.\n   [RFC2317]
      \ Eidnes, H., de Groot, G., and P. Vixie, \"Classless IN-\n              ADDR.ARPA
      delegation\", BCP 20, RFC 2317, March 1998.\n   [RFC2782]  Gulbrandsen, A.,
      Vixie, P., and L. Esibov, \"A DNS RR for\n              specifying the location
      of services (DNS SRV)\", RFC 2782,\n              February 2000.\n   [RFC3597]
      \ Gustafsson, A., \"Handling of Unknown DNS Resource Record\n              (RR)
      Types\", RFC 3597, September 2003.\n   [RFC4033]  Arends, R., Austein, R., Larson,
      M., Massey, D., and S.\n              Rose, \"DNS Security Introduction and
      Requirements\",\n              RFC 4033, March 2005.\n   [RFC4034]  Arends,
      R., Austein, R., Larson, M., Massey, D., and S.\n              Rose, \"Resource
      Records for the DNS Security Extensions\",\n              RFC 4034, March 2005.\n
      \  [RFC4035]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,
      \"Protocol Modifications for the DNS Security\n              Extensions\", RFC
      4035, March 2005.\n   [RFC4592]  Lewis, E., \"The Role of Wildcards in the Domain
      Name\n              System\", RFC 4592, July 2006.\n   [RFC5155]  Laurie, B.,
      Sisson, G., Arends, R., and D. Blacka, \"DNS\n              Security (DNSSEC)
      Hashed Authenticated Denial of\n              Existence\", RFC 5155, March 2008.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [RFC1912]  Barr, D., \"Common DNS Operational
      and Configuration\n              Errors\", RFC 1912, February 1996.\n   [RFC2672]
      \ Crawford, M., \"Non-Terminal DNS Name Redirection\",\n              RFC 2672,
      August 1999.\n   [RFC3363]  Bush, R., Durand, A., Fink, B., Gudmundsson, O.,
      and T.\n              Hain, \"Representing Internet Protocol version 6 (IPv6)\n
      \             Addresses in the Domain Name System (DNS)\", RFC 3363,\n              August
      2002.\n   [RFC3492]  Costello, A., \"Punycode: A Bootstring encoding of Unicode\n
      \             for Internationalized Domain Names in Applications\n              (IDNA)\",
      RFC 3492, March 2003.\n   [RFC6434]  Jankiewicz, E., Loughney, J., and T. Narten,
      \"IPv6 Node\n              Requirements\", RFC 6434, December 2011.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - 'Appendix A.  Changes from RFC 2672

    '
  - contents:
    - "A.1.  Changes to Server Behavior\n   Major changes to server behavior from
      the original DNAME\n   specification are summarized below:\n   o  The rules
      for DNAME substitution have been clarified in\n      Section 2.2.\n   o  The
      EDNS option to signal DNAME understanding and compression has\n      never been
      specified, and this document clarifies that there is no\n      signaling method
      (Section 2.5).\n   o  The TTL for synthesized CNAME RRs is now set to the TTL
      of the\n      DNAME, not zero (Section 3.1).\n   o  Recursive caching servers
      MUST perform CNAME synthesis on behalf\n      of clients (Section 3.4).\n   o
      \ The revised server algorithm is detailed in Section 3.2.\n   o  Rules for
      dynamic update messages adding a DNAME or CNAME RR to a\n      zone where a
      CNAME or DNAME already exists are detailed in\n      Section 5.2.\n"
    title: A.1.  Changes to Server Behavior
  - contents:
    - "A.2.  Changes to Client Behavior\n   Major changes to client behavior from
      the original DNAME\n   specification are summarized below:\n   o  Clients MUST
      be able to accept synthesized CNAME RR's with a TTL\n      of either zero or
      the TTL of the DNAME RR that accompanies the\n      CNAME RR.\n   o  DNSSEC-aware
      clients SHOULD cache DNAME RRs and MAY cache\n      synthesized CNAME RRs they
      receive in the same response.  DNSSEC-\n      aware clients SHOULD also check
      the NSEC/NSEC3 type bitmap to\n      verify that DNAME redirection is to be
      done.  DNSSEC validators\n      MUST understand DNAME (Section 5.3).\n   o  The
      revised client algorithm is detailed in Section 3.4.1.\n"
    title: A.2.  Changes to Client Behavior
  title: Appendix A.  Changes from RFC 2672
- contents:
  - "Authors' Addresses\n   Scott Rose\n   NIST\n   100 Bureau Dr.\n   Gaithersburg,
    MD  20899\n   USA\n   Phone: +1-301-975-8439\n   Fax:   +1-301-975-6238\n   EMail:
    scott.rose@nist.gov\n   Wouter Wijngaards\n   NLnet Labs\n   Science Park 140\n
    \  Amsterdam  1098 XH\n   The Netherlands\n   Phone: +31-20-888-4551\n   EMail:
    wouter@nlnetlabs.nl\n"
  title: Authors' Addresses
