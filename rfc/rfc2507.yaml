- title: __initial_text__
  contents:
  - "                        Lulea University of Technology/Telia Research AB\n  \
    \                       IP Header Compression\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes how to compress multiple IP headers and\
    \ TCP\n   and UDP headers per hop over point to point links. The methods can be\n\
    \   applied to of IPv6 base and extension headers, IPv4 headers, TCP and\n   UDP\
    \ headers, and encapsulated IPv6 and IPv4 headers.\n   Headers of typical UDP\
    \ or TCP packets can be compressed down to 4-7\n   octets including the 2 octet\
    \ UDP or TCP checksum. This largely\n   removes the negative impact of large IP\
    \ headers and allows efficient\n   use of bandwidth on low and medium speed links.\n\
    \   The compression algorithms are specifically designed to work well\n   over\
    \ links with nontrivial packet-loss rates. Several wireless and\n   modem technologies\
    \ result in such links.\n"
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n   1.  Introduction..............................................3\n\
    \   2.  Terminology...............................................5\n   3.  Compression\
    \ method........................................7\n        3.1.  Packet types.......................................8\n\
    \        3.2.  Lost packets in TCP packet streams.................9\n        3.3.\
    \  Lost packets in UDP and non-TCP packet streams....10\n   4.  Grouping packets\
    \ into packet streams.....................14\n        4.1.  Guidelines for grouping\
    \ packets...................15\n   5.  Size Issues..............................................16\n\
    \        5.1.  Context identifiers...............................16\n        5.2.\
    \  Size of the context...............................17\n        5.3.  Size of\
    \ full headers..............................18\n           5.3.1.  Length fields\
    \ in full TCP headers............19\n           5.3.2.  Length fields in full\
    \ non-TCP headers........19\n   6.  Compressed Header Formats................................20\n\
    \   7.  Compression of subheaders................................22\n        7.1.\
    \  IPv6 Header.......................................24\n        7.2.  IPv6 Extension\
    \ Headers............................25\n        7.3.  Options...........................................25\n\
    \        7.4.  Hop-by-hop Options Header.........................26\n        7.5.\
    \  Routing Header....................................26\n        7.6.  Fragment\
    \ Header...................................27\n        7.7.  Destination Options\
    \ Header........................28\n        7.8.  No Next Header....................................29\n\
    \        7.9.  Authentication Header.............................29\n        7.10.\
    \ Encapsulating Security Payload Header.............29\n        7.11. UDP Header........................................30\n\
    \        7.12. TCP Header........................................30\n        7.13.\
    \ IPv4 Header.......................................33\n        7.14  Minimal\
    \ Encapsulation header......................34\n   8.  Changing context identifiers.............................35\n\
    \   9.  Rules for dropping or temporarily storing packets........35\n   10. Low-loss\
    \ header compression for TCP .....................36\n        10.1.  The \"twice\"\
    \ algorithm............................37\n        10.2.  Header Requests..................................37\n\
    \   11. Links that reorder packets...............................38\n        11.1.\
    \  Reordering in non-TCP packet streams.............39\n        11.2.  Reordering\
    \ in TCP packet streams.................39\n   12. Hooks for additional header\
    \ compression..................40\n   13. Demultiplexing...........................................41\n\
    \   14. Configuration Parameters.................................42\n   15. Implementation\
    \ Status....................................43\n   16. Acknowledgments..........................................44\n\
    \   17. Security Considerations..................................44\n   18. Authors'\
    \ Addresses.......................................45\n   19. References...............................................46\n\
    \   20. Full Copyright Statement.................................47\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   There are several reasons to do header compression on low-\
    \ or\n   medium-speed links. Header compression can\n   *  Improve interactive\
    \ response time\n      For very low-speed links, echoing of characters may take\
    \ longer\n      than 100-200 ms because of the time required to transmit large\n\
    \      headers. 100-200 ms is the maximum time people can tolerate\n      without\
    \ feeling that the system is sluggish.\n   * Allow using small packets for bulk\
    \ data with good line efficiency\n      This is important when interactive (for\
    \ example Telnet) and bulk\n      traffic (for example FTP) is mixed because the\
    \ bulk data should be\n      carried in small packets to decrease the waiting\
    \ time when a\n      packet with interactive data is caught behind a bulk data\
    \ packet.\n      Using small packet sizes for the FTP traffic in this case is\
    \ a\n      global solution to a local problem. It will increase the load on\n\
    \      the network as it has to deal with many small packets. A better\n     \
    \ solution might be to locally fragment the large packets over the\n      slow\
    \ link.\n   * Allow using small packets for delay sensitive low data-rate traffic\n\
    \      For such applications, for example voice, the time to fill a\n      packet\
    \ with data is significant if packets are large.  To get low\n      end-to-end\
    \ delay small packets are preferred.  Without header\n      compression, the smallest\
    \ possible IPv6/UDP headers (48 octets)\n      consume 19.2 kbit/s with a packet\
    \ rate of 50 packets/s.  50\n      packets/s is equivalent to having 20 ms worth\
    \ of voice samples in\n      each packet. IPv4/UDP headers consumes 11.2 kbit/s\
    \ at 50\n      packets/s.  Tunneling or routing headers, for example to support\n\
    \      mobility, will increase the bandwidth consumed by headers by 10-20\n  \
    \    kbit/s.  This should be compared with the bandwidth required for\n      the\
    \ actual sound samples, for example 13 kbit/s with GSM encoding.\n      Header\
    \ compression can reduce the bandwidth needed for headers\n      significantly,\
    \ in the example to about 1.7 kbit/s. This enables\n      higher quality voice\
    \ transmission over 14.4 and 28.8 kbit/s\n      modems.\n   *  Decrease header\
    \ overhead.\n      A common size of TCP segments for bulk transfers over medium-speed\n\
    \      links is 512 octets today. When TCP segments are tunneled, for\n      example\
    \ because Mobile IP is used, the IPv6/IPv6/TCP header is 100\n      octets.  Header\
    \ compression will decrease the header overhead for\n      IPv6/TCP from 19.5\
    \ per cent to less than 1 per cent, and for\n      tunneled IPv4/TCP from 11.7\
    \ to less than 1 per cent. This is a\n      significant gain for line-speeds as\
    \ high as a few Mbit/s.\n      The IPv6 specification prescribes path MTU discovery,\
    \ so with IPv6\n      bulk TCP transfers should use segments larger than 512 octets\
    \ when\n      possible.  Still, with 1400 octet segments (RFC 894 Ethernet\n \
    \     encapsulation allows 1500 octet payloads, of which 100 octets are\n    \
    \  used for IP headers), header compression reduces IPv6 header\n      overhead\
    \ from 7.1% to 0.4%.\n   *  Reduce packet loss rate over lossy links.\n      Because\
    \ fewer bits are sent per packet, the packet loss rate will\n      be lower for\
    \ a given bit-error rate. This results in higher\n      throughput for TCP as\
    \ the sending window can open up more between\n      losses, and in fewer lost\
    \ packets for UDP.\n   The mechanisms described here are intended for a point-to-point\
    \ link.\n   However, care has been taken to allow extensions for multi-access\n\
    \   links and multicast.\n   Headers that can be compressed include TCP, UDP,\
    \ IPv4, and IPv6 base\n   and extension headers.  For TCP packets, the mechanisms\
    \ of Van\n   Jacobson [RFC-1144] are used to recover from loss. Two additional\n\
    \   mechanisms that increase the efficiency of VJ header compression over\n  \
    \ lossy links are also described.  For non-TCP packets, compression\n   slow-start\
    \ and periodic header refreshes allow minimal periods of\n   packet discard after\
    \ loss of a header that changes the context. There\n   are hooks for adding header\
    \ compression schemes on top of UDP, for\n   example compression of RTP headers.\n\
    \   Header compression relies on many fields being constant or changing\n   seldomly\
    \ in consecutive packets belonging to the same packet stream.\n   Fields that\
    \ do not change between packets need not be transmitted at\n   all.  Fields that\
    \ change often with small and/or predictable values,\n   e.g., TCP sequence numbers,\
    \ can be encoded incrementally so that the\n   number of bits needed for these\
    \ fields decrease significantly.  Only\n   fields that change often and randomly,\
    \ e.g., checksums or\n   authentication data, need to be transmitted in every\
    \ header.\n   The general principle of header compression is to occasionally send\
    \ a\n   packet with a full header; subsequent compressed headers refer to the\n\
    \   context established by the full header and may contain incremental\n   changes\
    \ to the context.\n   This header compression scheme does not require that all\
    \ packets in\n   the same stream passes over the compressed link. However, for\
    \ TCP\n   streams the difference between subsequent headers can become more\n\
    \   irregular and the compression rate can decrease. Neither is it\n   required\
    \ that corresponding TCP data and acknowledgment packets\n   traverse the link\
    \ in opposite directions.\n   This header compression scheme is useful on first-hop\
    \ or last-hop\n   links as well as links in the middle of the network. When many\
    \ packet\n   streams (several hundred) traverse the link, a phenomenon that could\n\
    \   be called CID thrashing could occur, where headers seldom can be\n   matched\
    \ with an existing context and have to be sent uncompressed or\n   as full headers.\
    \ It is up to an implementation to use techniques such\n   as hysteresis to ensure\
    \ that the packet streams that give the highest\n   compression rates keep their\
    \ context.  Such techniques are more\n   likely to be needed in the middle of\
    \ the network.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This section explains some terms used in this document.\n\
    \   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\"\
    ,\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in\
    \ this\n   document are to be interpreted as described in RFC 2119.\n   Subheader\n\
    \      An IPv6 base header, an IPv6 extension header, an IPv4 header, a\n    \
    \  UDP header, or a TCP header.\n   Header\n      A chain of subheaders.\n   Compress\n\
    \      The act of reducing the size of a header by removing header fields\n  \
    \    or reducing the size of header fields. This is done in a way such\n     \
    \ that a decompressor can reconstruct the header if its context\n      state is\
    \ identical to the context state used when compressing the\n      header.\n  \
    \ Decompress\n      The act of reconstructing a compressed header.\n   Context\
    \ identifier (CID)\n      A small unique number identifying the context that should\
    \ be used\n      to decompress a compressed header.  Carried in full headers and\n\
    \      compressed headers.\n   Context\n      The state which the compressor uses\
    \ to compress a header and the\n      decompressor uses to decompress a header.\
    \  The context is the\n      uncompressed version of the last header sent (compressor)\
    \ or\n      received (decompressor) over the link, except for fields in the\n\
    \      header that are included \"as-is\" in compressed headers or can be\n  \
    \    inferred from, e.g., the size of the link-level frame.\n      The context\
    \ for a packet stream is associated with a context\n      identifier.  The context\
    \ for non-TCP packet streams is also\n      associated with a generation.\n  \
    \ Generation\n      For non-TCP packet streams, each new version of the context\
    \ for a\n      given CID is associated with a generation: a small number that\
    \ is\n      incremented whenever the context associated with that CID changes.\n\
    \      Carried by full and compressed non-TCP headers.\n   Packet stream\n   \
    \   A sequence of packets whose headers are similar and share context.\n     \
    \ For example, headers in a TCP packet stream have the same source\n      and\
    \ final destination address, and the same port numbers in the\n      TCP header.\
    \  Similarly, headers in a UDP packet stream have the\n      same source and destination\
    \ address, and the same port numbers in\n      the UDP header.\n   Full header\
    \ (header refresh)\n      An uncompressed header that updates or refreshes the\
    \ context for a\n      packet stream. It carries a CID that will be used to identify\
    \ the\n      context.\n      Full headers for non-TCP packet streams also carry\
    \ the generation\n      of the context they update or refresh.\n   Regular header\n\
    \      A normal, uncompressed, header.  Does not carry CID or generation\n   \
    \   association.\n   Incorrect decompression\n      When a compressed and then\
    \ decompressed header is different from\n      the uncompressed header. Usually\
    \ due to mismatching context\n      between the compressor and decompressor or\
    \ bit errors during\n      transmission of the compressed header.\n   Differential\
    \ coding\n      A compression technique where the compressed value of a header\n\
    \      field is the difference between the current value of the field and\n  \
    \    the value of the same field in the previous header belonging to\n      the\
    \ same packet stream. A decompressor can thus obtain the value\n      of the field\
    \ by adding the value in the compressed header to its\n      context.  This technique\
    \ is used for TCP streams but not for non-\n      TCP streams.\n"
- title: 3.  Compression method
  contents:
  - "3.  Compression method\n   Much of the header information stays the same over\
    \ the life-time of a\n   packet stream. For non-TCP packet streams almost all\
    \ fields of the\n   headers are constant. For TCP many fields are constant and\
    \ others\n   change with small and predictable values.\n   To initiate compression\
    \ of the headers of a packet stream, a full\n   header carrying a context identifier,\
    \ CID, is transmitted over the\n   link.  The compressor and decompressor store\
    \ most fields of this full\n   header as context.  The context consists of the\
    \ fields of the header\n   whose values are constant and thus need not be sent\
    \ over the link at\n   all, or change little between consecutive headers so that\
    \ it uses\n   fewer bits to send the difference from the previous value compared\
    \ to\n   sending the absolute value.\n   Any change in fields that are expected\
    \ to be constant in a packet\n   stream will cause the compressor to send a full\
    \ header again to\n   update the context at the decompressor. As long as the context\
    \ is the\n   same at compressor and decompressor, headers can be decompressed\
    \ to\n   be exactly as they were before compression. However, if a full header\n\
    \   or compressed header is lost during transmission, the context of the\n   decompressor\
    \ may become obsolete as it is not updated properly.\n   Compressed headers will\
    \ then be decompressed incorrectly.\n   IPv6 is not meant to be used over links\
    \ that can deliver a\n   significant fraction of damaged packets to the IPv6 module.\
    \  This\n   means that links must have a very low bit-error rate or that link-\n\
    \   level frames must be protected by strong checksums, forward error\n   correction\
    \ or something of that nature.  Header compression SHOULD\n   not be used for\
    \ IPv4 without strong link-level checksums.  Damaged\n   frames will thus be discarded\
    \ by the link layer.  The link layer\n   implementation might indicate to the\
    \ header compression module that a\n   frame was damaged, but it cannot say what\
    \ packet stream it belonged\n   to as it might be the CID that is damaged.  Moreover,\
    \ frames may\n   disappear without the link layer implementation's knowledge,\
    \ for\n   example if the link is a multi-hop link where frames can be dropped\n\
    \   due to congestion at each hop.  The kind of link errors that a header\n  \
    \ compression module should deal with and protect against will thus be\n   packet\
    \ loss.\n   So a header compression scheme needs mechanisms to update the context\n\
    \   at the decompressor and to detect or avoid incorrect decompression.\n   These\
    \ mechanisms are very different for TCP and non-TCP streams, and\n   are described\
    \ in sections 3.2 and 3.3.\n   The compression mechanisms in this document assume\
    \ that packets are\n   not reordered between the compressor and decompressor.\
    \  If the link\n   does reorder, section 11 describes mechanisms for ordering\
    \ the\n   packets before decompression.  It is also assumed that the link-layer\n\
    \   implementation can provide the length of packets, and that there is\n   no\
    \ padding in UDP packets or tunneled packets.\n"
- title: 3.1.  Packet types
  contents:
  - "3.1.  Packet types\n   This compression method uses four packet types in addition\
    \ to the\n   IPv4 and IPv6 packet types.  The combination of link-level packet\n\
    \   type and the value of the first four bits of the packet uniquely\n   determines\
    \ the packet type.  Details on how these packet types are\n   represented are\
    \ in section 13.\n       FULL_HEADER - indicates a packet with an uncompressed\
    \ header,\n       including a CID and, if not a TCP packet, a generation.  It\n\
    \       establishes or refreshes the context for the packet stream\n       identified\
    \ by the CID.\n       COMPRESSED_NON_TCP - indicates a non-TCP packet with a compressed\n\
    \       header. The compressed header consists of a CID identifying what\n   \
    \    context to use for decompression, a generation to detect an\n       inconsistent\
    \ context and the randomly changing fields of the\n       header.\n       COMPRESSED_TCP\
    \ - indicates a packet with a compressed TCP header,\n       containing a CID,\
    \ a flag octet indentifying what fields have\n       changed, and the changed\
    \ fields encoded as the difference from\n       the previous value.\n       COMPRESSED_TCP_NODELTA\
    \ - indicates a packet with a compressed TCP\n       header where all fields that\
    \ are normally sent as the difference\n       to the previous value are instead\
    \ sent as-is.  This packet type\n       is only sent as the response to a header\
    \ request from the\n       decompressor. It must not be sent as the result of\
    \ a\n       retransmission.\n   In addition to the packet types used for compression,\
    \ regular IPv4\n   and IPv6 packets are used whenever a compressor decides to\
    \ not\n   compress a packet.  An additional packet type may be used to speed up\n\
    \   repair of TCP streams over links where the decompressor can send\n   packets\
    \ to the compressor.\n       CONTEXT_STATE - indicates a special packet sent from\
    \ the\n       decompressor to the compressor to communicate a list of (TCP)\n\
    \       CIDs for which synchronization has been lost. This packet is only\n  \
    \     sent over a single link so it requires no IP header. The format\n      \
    \ is shown in section 10.2.\n"
- title: 3.2.  Lost packets in TCP packet streams
  contents:
  - "3.2.  Lost packets in TCP packet streams\n   Since TCP headers are compressed\
    \ using the difference from the\n   previous TCP header, loss of a packet with\
    \ a compressed or full\n   header will cause subsequent compressed headers to\
    \ be decompressed\n   incorrectly because the context used for decompression was\
    \ not\n   incremented properly.\n   Loss of a compressed TCP header will cause\
    \ the TCP sequence numbers\n   of subsequently decompressed TCP headers to be\
    \ off by k, where k is\n   the size of the lost segment.  Such incorrectly decompressed\
    \ TCP\n   headers will be discarded by the TCP receiver as the TCP checksum\n\
    \   reliably catches \"off-by-k\" errors in the sequence numbers for\n   plausible\
    \ k.\n   TCP's repair mechanisms will eventually retransmit the discarded\n  \
    \ segment and the compressor peeks into the TCP headers to detect when\n   TCP\
    \ retransmits.  When this happens, the compressor sends a full\n   header on the\
    \ assumption that the retransmission was due to\n   mismatching compression state\
    \ at the decompressor.  [RFC-1144] has a\n   good explanation of this mechanism.\n\
    \   The mechanisms of section 10 should be used to speed up the repair of\n  \
    \ the context.  This is important over medium speed links with high\n   packet\
    \ loss rates, for example wireless.  Losing a timeout's worth of\n   packets due\
    \ to inconsistent context after each packet lost over the\n   link is not acceptable,\
    \ especially when the TCP connection is over\n   the wide area.\n"
- title: 3.3.  Lost packets in UDP and other non-TCP packet streams
  contents:
  - "3.3.  Lost packets in UDP and other non-TCP packet streams\n   Incorrectly decompressed\
    \ headers of UDP packets and other non-TCP\n   packets are not so well-protected\
    \ by checksums as TCP packets.  There\n   are no sequence numbers that become\
    \ \"off-by-k\" and virtually\n   guarantees a failed checksum as there are for\
    \ TCP. The UDP checksum\n   only covers payload, UDP header, and pseudo header.\
    \  The pseudo\n   header includes the source and destination addresses, the transport\n\
    \   protocol type and the length of the transport packet.  Except for\n   those\
    \ fields, large parts of the IPv6 header are not covered by the\n   UDP checksum.\
    \  Moreover, other non-TCP headers lack checksums\n   altogether, for example\
    \ fragments.\n   In order to safely avoid incorrect decompression of non-TCP headers,\n\
    \   each version of the context for non-TCP packet streams is identified\n   by\
    \ a generation, a small number that is carried by the full headers\n   that establish\
    \ and refresh the context.  Compressed headers carry the\n   generation value\
    \ of the context that were used to compress them.\n   When a decompressor sees\
    \ that a compressed header carries a\n   generation value other than the generation\
    \ of its context for that\n   packet stream, the context is not up to date and\
    \ the packet must be\n   discarded or stored until a full header establishes correct\
    \ context.\n   Differential coding is not used for non-TCP streams, so compressed\n\
    \   non-TCP headers do not change the context.  Thus, loss of a\n   compressed\
    \ header does not invalidate subsequent packets with\n   compressed headers. Moreover,\
    \ the generation changes only when the\n   context of a full header is different\
    \ from the context of the\n   previous full header. This means that losing a full\
    \ header will make\n   the context of the decompressor obsolete only when the\
    \ full header\n   would actually have changed the context.\n   The generation\
    \ field is 6 bits long so the generation value repeats\n   itself after 64 changes\
    \ to the context. To avoid incorrect\n   decompression after error bursts or other\
    \ temporary disruptions, the\n   compressor must not reuse the same generation\
    \ value after a shorter\n   time than MIN_WRAP seconds. A decompressor which has\
    \ been\n   disconnected MIN_WRAP seconds or more must wait for the next full\n\
    \   header before decompressing. A compressor must wait at least MIN_WRAP\n  \
    \ seconds after booting before compressing non-TCP headers. Instead of\n   reusing\
    \ a generation value too soon, a compressor may switch to\n   another CID or send\
    \ regular headers until MIN_WRAP seconds have\n   passed.  The value of MIN_WRAP\
    \ is found in section 14.\n"
- title: 3.3.1.  Compression Slow-Start
  contents:
  - "3.3.1.  Compression Slow-Start\n   To allow the decompressor to recover quickly\
    \ from loss of a full\n   header that would have changed the context, full headers\
    \ are sent\n   periodically with an exponentially increasing period after a change\n\
    \   in the context. This technique avoids an exchange of messages between\n  \
    \ compressor and decompressor used by other compression schemes, such\n   as in\
    \ [RFC-1553]. Such exchanges can be costly for wireless mobiles\n   as more power\
    \ is consumed by the transmitter and delay can be\n   introduced by switching\
    \ between sending and receiving.  Moreover,\n   techniques that require an exchange\
    \ of messages cannot be used over\n   simplex links, such as direct-broadcast\
    \ satellite channels or cable\n   TV systems, and are hard to adapt to multicast\
    \ over multi-access\n   links.\n    |.|..|....|........|................|..............................\n\
    \    ^\n    Change   Sent packets: | with full header, . with compressed header\n\
    \   The picture shows how packets are sent after change.  The compressor\n   keeps\
    \ a variable for each non-TCP packet stream, F_PERIOD, that keeps\n   track of\
    \ how many compressed headers may be sent between full\n   headers.  When the\
    \ headers of a non-TCP packet stream change so that\n   its context changes, a\
    \ full header is sent and F_PERIOD is set to\n   one. After sending F_PERIOD compressed\
    \ headers, a full header is\n   sent.  F_PERIOD is doubled each time a full header\
    \ is sent during\n   compression slow-start.\n"
- title: 3.3.2.  Periodic Header Refreshes
  contents:
  - "3.3.2.  Periodic Header Refreshes\n   To avoid losing too many packets if a receiver\
    \ has lost its context,\n   there is an upper limit, F_MAX_PERIOD, on the number\
    \ of non-TCP\n   packets with compressed headers that may be sent between header\n\
    \   refreshes. If a packet is to be sent and F_MAX_PERIOD compressed\n   headers\
    \ have been sent since the last full header for this packet\n   stream was sent,\
    \ a full header must be sent.\n   To avoid long periods of disconnection for low\
    \ data rate packet\n   streams, there is also an upper bound, F_MAX_TIME, on the\
    \ time\n   between full headers in a non-TCP packet stream. If a packet is to\
    \ be\n   sent and more than F_MAX_TIME seconds have passed since the last full\n\
    \   header was sent for this packet stream, a full header must be sent.\n   The\
    \ values of F_MAX_PERIOD and F_MAX_TIME are found in section 14.\n"
- title: 3.3.3. Rules for sending Full Headers
  contents:
  - "3.3.3. Rules for sending Full Headers\n   The following pseudo code can be used\
    \ by the compressor to determine\n   when to send a full header for a non-TCP\
    \ packet stream.  The code\n   maintains two variables:\n         C_NUM      \
    \ -- a count of the number of compressed headers sent\n                      \
    \  since the last full header was sent.\n         F_LAST      -- the time of sending\
    \ the last full header.\n   and uses the functions\n         current_time()  \
    \     return the current time\n         min(a,b)             return the smallest\
    \ of a and b\n      the procedures send_full_header(), increment_generation_value(),\n\
    \      and send_compressed_header()\n      do the obvious thing.\n         if\
    \ ( <this header changes the context> )\n             C_NUM := 0;\n          \
    \   F_LAST := current_time();\n             F_PERIOD := 1;\n             increment_generation_value();\n\
    \             send_full_header();\n         elseif ( C_NUM >= F_PERIOD )\n   \
    \          C_NUM := 0;\n             F_LAST := current_time();\n             F_PERIOD\
    \ := min(2 * F_PERIOD, F_MAX_PERIOD);\n             send_full_header();\n    \
    \     elseif ( current_time() > F_LAST + F_MAX_TIME )\n             C_NUM := 0;\n\
    \             F_LAST := current_time();\n             send_full_header();\n  \
    \       else\n             C_NUM := C_NUM + 1\n             send_compressed_header();\n\
    \         endif\n"
- title: 3.3.4.  Cost of sending Header Refreshes
  contents:
  - "3.3.4.  Cost of sending Header Refreshes\n   If every f'th packet carries a full\
    \ header, H is the size of a full\n   header, and C is the size of a compressed\
    \ header, the average header\n   size is\n                 (H-C)/f + C\n   For\
    \ f > 1, the average header size is (H-C)/f larger than a\n   compressed header.\n\
    \   In a diagram where the average header size is plotted for various f\n   values,\
    \ there is a distinct knee in the curve, i.e., there is a limit\n   beyond which\
    \ further increasing f gives diminishing returns.\n   F_MAX_PERIOD should be chosen\
    \ to be a frequency well to the right of\n   the knee of the curve.  For typical\
    \ sizes of H and C, say 48 octets\n   for the full header (IPv6/UDP) and 4 octets\
    \ for the compressed\n   header, setting F_MAX_PERIOD > 44 means that full headers\
    \ will\n   contribute less than an octet to the average header size. With a\n\
    \   four-address routing header, F_MAX_PERIOD > 115 will have the same\n   effect.\n\
    \   The default F_MAX_PERIOD value of 256 (section 14) puts the full\n   header\
    \ frequency well to the right of the knee and means that full\n   headers will\
    \ typically contribute considerably less than an octet to\n   the average header\
    \ size.  For H = 48 and C = 4, full headers\n   contribute about 1.4 bits to the\
    \ average header size after reaching\n   the steady-state header refresh frequency\
    \ determined by the default\n   F_MAX_PERIOD. 1.4 bits is a very small overhead.\n\
    \   After a change in the context, the exponential backoff scheme will\n   initially\
    \ send full headers frequently.  The default F_MAX_PERIOD\n   will be reached\
    \ after nine full headers and 255 compressed headers\n   have been sent.  This\
    \ is equivalent to a little over 5 seconds for a\n   typical voice stream with\
    \ 20 ms worth of voice samples per packet.\n   During the whole backoff period,\
    \ full headers contribute 1.5 octets\n   to the average header size when H = 48\
    \ and C = 4.  For 20 ms voice\n   samples, it takes less than 1.3 seconds until\
    \ full headers contribute\n   less than one octet to the average header size,\
    \ and during these\n   initial 1.3 seconds full headers add less than 4 octets\
    \ to the\n   average header size.  The cost of the exponential backoff is not\n\
    \   great and as the headers of non-TCP packet streams are expected to\n   change\
    \ seldomly, it will be amortized over a long time.\n   The cost of header refreshes\
    \ in terms of bandwidth are higher than\n   similar costs for hard state schemes\
    \ like [RFC-1553] where full\n   headers must be acknowledged by the decompressor\
    \ before compressed\n   headers may be sent. Such schemes typically send one full\
    \ header plus\n   a few control messages when the context changes.  Hard state\
    \ schemes\n   require more types of protocol messages and an exchange of messages\n\
    \   is necessary.  Hard state schemes also need to deal explicitly with\n   various\
    \ error conditions that soft state handles automatically, for\n   instance the\
    \ case of one party disappearing unexpectedly, a common\n   situation on wireless\
    \ links where mobiles may go out of range of the\n   base station.\n   The major\
    \ advantage of the soft state scheme is that no handshakes\n   are needed between\
    \ compressor and decompressor, so the scheme can be\n   used over simplex links.\
    \  The costs in terms of bandwidth are higher\n   than for hard state schemes,\
    \ but the simplicity of the decompressor,\n   the simplicity of the protocol,\
    \ and the lack of handshakes between\n   compressor and decompressor justifies\
    \ this small cost. Moreover, soft\n   state schemes are more easily extended to\
    \ multicast over multi-access\n   links, for example radio links.\n"
- title: 4.  Grouping packets into packet streams
  contents:
  - "4.  Grouping packets into packet streams\n   This section explains how packets\
    \ MAY be grouped together into packet\n   streams for compression.  To achieve\
    \ the best compression rates,\n   packets SHOULD be grouped together such that\
    \ packets in the same\n   packet stream have similar headers. If this grouping\
    \ fails, header\n   compression performance will be bad, since the compression\
    \ algorithm\n   can rarely utilize the existing context for the packet stream\
    \ and\n   full headers must be sent frequently.\n   Grouping is done by the compressor.\
    \ A compressor may use whatever\n   criterion it finds appropriate to group packets\
    \ into packet streams.\n   To determine what packet stream a packet belongs to,\
    \ a compressor MAY\n   a) examine the compressible chain of subheaders (see section\
    \ 7),\n   b) examine the contents of an upper layer protocol header that\n   \
    \   follows the compressible chain of subheaders, for example ICMP\n      headers,\
    \ DVMRP headers, or tunneled IPX headers,\n   c) use information obtained from\
    \ a resource manager, for example if a\n      resource manager requests compression\
    \ for a particular packet\n      stream and provides a way to identify packets\
    \ belonging to that\n      packet stream,\n   d) use any other relevant information,\
    \ for example if routes flap and\n      the hop limit (TTL) field in a packet\
    \ stream changes frequently\n      between n and n+k, a compressor may choose\
    \ to group the packets\n      into two different packet streams.\n   A compressor\
    \ is also free not to group packets into packet streams\n   for compression, letting\
    \ some packets keep their regular headers and\n   passing them through unmodified.\n\
    \   As long as the rules for when to send full headers for a non-TCP\n   packet\
    \ stream are followed and subheaders are compressed as specified\n   in this document,\
    \ the decompressor is able to reconstruct a\n   compressed header correctly regardless\
    \ of how packets are grouped\n   into packet streams.\n"
- title: 4.1  Guidelines for grouping packets
  contents:
  - "4.1  Guidelines for grouping packets\n   In this section we give OPTIONAL guidelines\
    \ for how a compressor may\n   group packets into packet streams for compression.\n\
    \   Defining fields\n      The defining fields of a header should be present and\
    \ identical in\n      all packets belonging to the same packet stream.  These\
    \ fields are\n      marked DEF in section 7. The defining fields include the flow\n\
    \      label, source and destination addresses of IP headers, final\n      destination\
    \ address in routing headers, the next header fields\n      (for IPv6), the protocol\
    \ field (IPv4), port numbers (UDP and TCP),\n      and the SPI in authentication\
    \ and encryption headers.\n   Fragmented packets\n      Fragmented and unfragmented\
    \ packets should never be grouped\n      together in the same packet stream. The\
    \ Identification field of\n      the Fragment header or IPv4 header should not\
    \ be used to identify\n      the packet stream. If it was, the first fragment\
    \ of a new packet\n      would cause a compression slow-start.\n      No field\
    \ after a Fragment Header, or an IPv4 header for a\n      fragment, should be\
    \ used for grouping purposes.\n   Upper protocol identification\n      The first\
    \ next header field identifying a header not described in\n      section 7 should\
    \ be used for identifying packet streams, i.e., all\n      packets with the same\
    \ DEF fields and the same upper protocol\n      should be grouped together.\n\
    \   TTL field (Hop Limit field)\n      A sophisticated implementation might monitor\
    \ the TTL (Hop Limit)\n      field and if it changes frequently use it as a DEF\
    \ field. This can\n      occur when there are frequent route flaps so that packets\
    \ traverse\n      different paths through the internet.\n   Traffic Class field\
    \ (IPv6), Type of Service field (IPv4)\n      It is possible that the Traffic\
    \ Class field of the IPv6 header and\n      the Type of Service of the IPv4 header\
    \ will change frequently\n      between packets with otherwise identical DEF fields.\
    \  A\n      sophisticated implementation should watch out for this and be\n  \
    \    prepared to use these fields as defining fields.\n   When IP packets are\
    \ tunneled they are encapsulated with an additional\n   IP header at the tunnel\
    \ entry point and then sent to the tunnel\n   endpoint. To group such packets\
    \ into packet streams, the inner\n   headers should also be examined to determine\
    \ the packet stream.  If\n   this is not done, full headers will be sent each\
    \ time the headers of\n   the inner IP packet changes.  So when a packet is tunneled,\
    \ the\n   identifying fields of the inner subheaders should be considered in\n\
    \   addition to the identifying fields of the initial IP header.\n   An implementation\
    \ can use other fields for identification than the\n   ones described here. If\
    \ too many fields are used for identification,\n   performance might suffer because\
    \ more CIDs will be used and the wrong\n   CIDs might be reused when new flows\
    \ need CIDs. If too few fields are\n   used for identification, performance might\
    \ suffer because there are\n   too frequent changes to the context.\n   We stress\
    \ that these guidelines are educated guesses. When IPv6 is\n   widely deployed\
    \ and IPv6 traffic can be analyzed, we might find that\n   other grouping algorithms\
    \ perform better. We also stress that if the\n   grouping fails, the result will\
    \ be bad performance but not incorrect\n   decompression. The decompressor can\
    \ do its task regardless of how the\n   grouping algorithm works.\n"
- title: 5.  Size Issues
  contents:
  - '5.  Size Issues

    '
- title: 5.1.  Context Identifiers
  contents:
  - "5.1.  Context Identifiers\n   Context identifiers can be 8 or 16 bits long. \
    \ Their size is not\n   relevant for finding the context.  An 8-bit CID with value\
    \ two and a\n   16-bit CID with value two are equivalent.\n   The CID spaces for\
    \ TCP and non-TCP are separate, so a TCP CID and a\n   non-TCP CID never identify\
    \ the same context.  Even if they have the\n   same value. This doubles the available\
    \ CID space while using the same\n   number of bits for CIDs.  It is always possible\
    \ to tell whether a\n   full or compressed header is for a TCP or non-TCP packet,\
    \ so no\n   mixups can occur.\n   Non-TCP compressed headers encode the size of\
    \ the CID using one bit\n   in the second octet of the compressed header. The\
    \ 8-bit CID allows a\n   minimum compressed header size of 2 octets for non-TCP\
    \ packets, the\n   CID uses the first octet and the size bit and the 6-bit Generation\n\
    \   value fit in the second octet.\n   For TCP the only available CID size is\
    \ 8 bits as in [RFC-1144].  8\n   bits is probably sufficient as TCP connections\
    \ are always point-to-\n   point.\n   The 16 bit CID size may not be needed for\
    \ point-to-point links; it is\n   intended for use on multi-access links where\
    \ a larger CID space may\n   be needed for efficient selection of CIDs.\n   The\
    \ major difficulty with multi-access links is that several\n   compressors share\
    \ the CID space of a decompressor.  CIDs can no\n   longer be selected independently\
    \ by the compressors as collisions may\n   occur.  This problem may be resolved\
    \ by letting the decompressors\n   have a separate CID space for each compressor.\
    \  Having separate CID\n   spaces requires that decompressors can identify which\
    \ compressor sent\n   the compressed packet, perhaps by utilizing link-layer information\
    \ as\n   to who sent the link-layer frame.  If such information is not\n   available,\
    \ all compressors on the multi-access link may be\n   enumerated, automatically\
    \ or otherwise, and supply their number as\n   part of the CID. This latter method\
    \ requires a large CID space.\n"
- title: 5.2.  Size of the context
  contents:
  - "5.2.  Size of the context\n   The size of the context SHOULD be limited to simplify\
    \ implementation\n   of compressor and decompressor, and put a limit on their\
    \ memory\n   requirements.  However, there is no upper limit on the size of an\n\
    \   IPv6 header as the chain of extension headers can be arbitrarily\n   long.\
    \  This is a problem as the context is essentially a stored\n   header.\n   The\
    \ configurable parameter MAX_HEADER (see section 14) represents the\n   maximum\
    \ size of the context, expressed as the maximum sized header\n   that can be stored\
    \ as context. When a header is larger than\n   MAX_HEADER, only part of it is\
    \ stored as context.  An implementation\n   MUST NOT compress more than the initial\
    \ MAX_HEADER octets of a\n   header.  An implementation MUST NOT partially compress\
    \ a subheader.\n   Thus, the part of the header that is stored as context and\
    \ is\n   compressed is the longest initial sequence of entire subheaders that\n\
    \   is not larger than MAX_HEADER octets.\n"
- title: 5.3.  Size of full headers
  contents:
  - "5.3.  Size of full headers\n   It is desirable to avoid increasing the size of\
    \ packets with full\n   headers beyond their original size, as their size may\
    \ be optimized\n   for the MTU of the link. Since we assume that the link layer\n\
    \   implementation provides the length of packets, we can use the length\n   fields\
    \ in full headers to pass the values of the CID and the\n   generation to the\
    \ decompressor.\n   This requires that the link-layer must not add padding to\
    \ the\n   payload, at least not padding that can be delivered to the\n   destination\
    \ link user. It is also required that no extra padding is\n   added after UDP\
    \ data or in tunneled packets. This allows values of\n   length fields to be calculated\
    \ from the length of headers and the\n   length of the link-layer frame.\n   The\
    \ generation requires one octet and the CID may require up to 2\n   octets.  There\
    \ are length fields of 2 octets in the IPv6 Base Header,\n   the IPv4 header,\
    \ and the UDP header.\n   A full TCP header will thus have at least 2 octets available\
    \ in the\n   IP header to pass the 8 bit CID, which is sufficient. There will\
    \ be\n   more than two octets available if there is more than one IP header.\n\
    \   [RFC-1144] uses the 8 bit Protocol field of the IPv4 header to pass\n   the\
    \ CID. We cannot use the corresponding method as the sequence of\n   IPv6 extension\
    \ headers is not fixed and CID values are not disjoint\n   from the legal values\
    \ of Next Header fields.\n   An IPv6/UDP or IPv4/UDP packet will have 4 octets\
    \ available to pass\n   the generation and the CID, so all CID sizes may be used.\
    \ Fragmented\n   or encrypted packet streams may have only 2 octets available\
    \ to pass\n   the generation and CID.  Thus, 8-bit CIDs may be the only CID sizes\n\
    \   that can be used for such packet streams.  When IPv6/IPv4 or\n   IPv4/IPv6\
    \ tunneling is used, there will be at least 4 octets\n   available, and both CID\
    \ sizes may be used.\n   The generation value is passed in the higher order octet\
    \ of the first\n   length field in the full header. When only one length field\
    \ is\n   available, the 8-bit CID is passed in the low order octet.  When two\n\
    \   length fields are available, the lowest two octets of the CID are\n   passed\
    \ in the second length field and the low order octet of the\n   first length field\
    \ carries the highest octet of the CID.\n"
- title: 5.3.1.  Use of length fields in full TCP headers
  contents:
  - "5.3.1.  Use of length fields in full TCP headers\n   Use of first length field:\n\
    \                                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \                      Length field   | LSB of pkt nr |      CID      |\n    \
    \                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Use\
    \ of second length field if available:\n                                     \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  Second length field  |\
    \ MSB of pkt nr |       0       |\n                                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Pkt nr is short for packet sequence number, described in section\n   11.2.\n"
- title: 5.3.2.  Use of length fields in full non-TCP headers
  contents:
  - "5.3.2.  Use of length fields in full non-TCP headers\n   Full non-TCP headers\
    \ with 8-bit CID:\n                                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  First length field   |0|D| Generation|      CID      |\n  \
    \                                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Second\
    \ length field (if avail.) |       0       | Data (if D=1) |\n               \
    \                        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Full non-TCP headers\
    \ with 16-bit CID:\n                                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  First length field   |1|D| Generation| Data (if D=1) |\n  \
    \                                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \            Second length field  |              CID              |\n        \
    \                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The first\
    \ bit in the first length field indicates the length of the\n   CID.  The Data\
    \ field is zero if D is zero. The use of the D bit and\n   Data field is explained\
    \ in section 12.\n"
- title: 6.  Compressed Header Formats
  contents:
  - "6.  Compressed Header Formats\n   This section uses some terminology (DELTA,\
    \ RANDOM) defined in section\n   7.\n      a) COMPRESSED_TCP format (similar to\
    \ [RFC 1144]):\n            +-+-+-+-+-+-+-+-+\n            |      CID      |\n\
    \            +-+-+-+-+-+-+-+-+\n            |R O I P S A W U|\n            +-+-+-+-+-+-+-+-+\n\
    \            |               |\n            +  TCP Checksum +\n            | \
    \              |\n            +-+-+-+-+-+-+-+-+\n            | RANDOM fields,\
    \ if any (see section 7)   (implied)\n             - - - - - - - -\n         \
    \   | R-octet       |                         (if R=1)\n             - - - - -\
    \ - - -\n            | Urgent Pointer Value                    (if U=1)\n    \
    \         - - - - - - - -\n            | Window Delta                        \
    \    (if W=1)\n             - - - - - - - -\n            | Acknowledgment Number\
    \ Delta             (if A=1)\n             - - - - - - - -\n            | Sequence\
    \ Number Delta                   (if S=1)\n             - - - - - - - -\n    \
    \        | IPv4 Identification Delta               (if I=1)\n             - -\
    \ - - - - - -\n            |  Options                                (if O=1)\n\
    \             - - - - - - - -\n   The latter flags in the second octet (IPSAWU)\
    \ have the same meaning\n   as in [RFC-1144], regardless of whether the TCP segments\
    \ are carried\n   by IPv6 or IPv4. The C bit has been eliminated because the CID\
    \ is\n   always present. The context associated with the CID keeps track of\n\
    \   the IP version and what RANDOM fields are present.  The order between\n  \
    \ delta fields specified here is exactly as in [RFC-1144]. An\n   implementation\
    \ will typically scan the context from the beginning and\n   insert the RANDOM\
    \ fields in order. The RANDOM fields are thus placed\n   before the DELTA fields\
    \ of the TCP header in the same order as they\n   occur in the original uncompressed\
    \ header.\n   The I flag is zero unless an IPv4 header immediately precedes the\
    \ TCP\n   header. The combined IPv4/TCP header is then compressed as a unit as\n\
    \   described in [RFC-1144]. Identification fields in IPv4 headers that\n   are\
    \ not immediately followed by a TCP header are RANDOM.\n   If the O flag is set,\
    \ the Options of the TCP header were not the same\n   as in the previous header.\
    \ The entire Option field are placed last in\n   the compressed TCP header.\n\
    \   If the R flag is set, there were differences between the context and\n   the\
    \ Reserved field (6 bits) in the TCP header or bit 6 or 7 of the\n   TOS octet\
    \ (Traffic Class octet) in a IPv4 header (IPv6 header) that\n   immediately precedes\
    \ the TCP header.  An octet with the actual values\n   of the Reserved field and\
    \ bit 6 and 7 of the TOS or Traffic Class\n   field is then placed immediately\
    \ after the RANDOM fields.  Bits 0-5\n   of the passed octet is the actual value\
    \ of the Reserved field, and\n   bits 6 and 7 are the actual values of bits 6\
    \ and 7 in the TOS or\n   Traffic Class field. If there is no preceding IP header,\
    \ bits 6 and 7\n   are 0.  The octet passed with the R flag MUST NOT update the\
    \ context.\n   NOTE: The R-octet does not update the context because if it did,\
    \ the\n   nTCP checksum would not guard the receiving TCP from erroneously\n \
    \  decompressed headers. Bits 6 and 7 of the TOS octet or Traffic Class\n   octet\
    \ is expected to change frequently due to Explicit Congestion\n   Notification.\n\
    \   See section 7.12 and [RFC-1144] for further information on how to\n   compress\
    \ TCP headers.\n      b) COMPRESSED_TCP_NODELTA header format\n          +-+-+-+-+-+-+-+-+\n\
    \          |      CID      |\n          +-+-+-+-+-+-+-+-+\n          |  RANDOM\
    \ fields, if any (see section 7)   (implied)\n          +-+-+-+-+-+-+-+-+\n  \
    \        |  Whole TCP header except for Port Numbers\n          +-+-+-+-+-+-+-+-+\n\
    \      c) Compressed non-TCP header, 8 bit CID:\n           0             7\n\
    \          +-+-+-+-+-+-+-+-+\n          |      CID      |\n          +-+-+-+-+-+-+-+-+\n\
    \          |0|D| Generation|\n          +-+-+-+-+-+-+-+-+\n          |      data\
    \     |                      (if D=1)\n           - - - - - - - -\n          |\
    \ RANDOM fields, if any (section 7)    (implied)\n           - - - - - - - -\n\
    \      d) Compressed non-TCP header, 16 bit CID:\n           0             7\n\
    \          +-+-+-+-+-+-+-+-+\n          |  msb of CID   |\n          +-+-+-+-+-+-+-+-+\n\
    \          |1|D| Generation|\n          +-+-+-+-+-+-+-+-+\n          |  lsb of\
    \ CID   |\n          +-+-+-+-+-+-+-+-+\n          |      data     |          \
    \            (if D=1)\n           - - - - - - - -\n          | RANDOM fields,\
    \ if any (section 7)    (implied)\n           - - - - - - - -\n   The generation,\
    \ CID and optional one octet data are followed by\n   relevant RANDOM fields (see\
    \ section 7) as implied by the compression\n   state, placed in the same order\
    \ as they occur in the original\n   uncompressed header, followed by the payload.\n"
- title: 7.  Compression of subheaders
  contents:
  - "7.  Compression of subheaders\n   This section gives rules for how the compressible\
    \ chain of subheaders\n   is compressed. These rules MUST be followed.  Subheaders\
    \ that may be\n   compressed include IPv6 base and extension headers, TCP headers,\
    \ UDP\n   headers, and IPv4 headers.  The compressible chain of subheaders\n \
    \  extends from the beginning of the header\n   a) up to but not including the\
    \ first header that is not an IPv4\n      header, an IPv6 base or extension header,\
    \ a TCP header, or a UDP\n      header, or\n   b) up to and including the first\
    \ TCP header, UDP header, Fragment\n      Header, Encapsulating Security Payload\
    \ Header, or IPv4 header for\n      a fragment,\n   whichever gives the shorter\
    \ chain. For example, rules a) and b) both\n   fit a chain of subheaders that\
    \ contain a Fragment Header and ends at\n   a tunneled IPX packet. Since rule\
    \ b) gives a shorter chain, the\n   compressible chain of subheaders stops at\
    \ the Fragment Header.\n   The following subsections are a systematic classification\
    \ of how all\n   fields in subheaders are expected to change.\n   NOCHANGE   \
    \ The field is not expected to change. Any change means\n               that a\
    \ full header MUST be sent to update the context.\n   DELTA       The field may\
    \ change often but usually the difference\n               from the field in the\
    \ previous header is small, so that\n               it is cheaper to send the\
    \ change from the previous value\n               rather than the current value.\
    \  This type of compression\n               is only used for TCP packet streams.\n\
    \   RANDOM      The field must be included \"as-is\" in compressed headers,\n\
    \               usually because it changes unpredictably.\n   INFERRED    The\
    \ field contains a value that can be inferred from\n               other values,\
    \ for example the size of the frame carrying\n               the packet, and thus\
    \ must not be included in the\n               compressed header.\n   The classification\
    \ implies how a compressed header is constructed. No\n   field that is NOCHANGE\
    \ or INFERRED is present in a compressed header.\n   A compressor obtains the\
    \ values of NOCHANGE fields from the context\n   identified by the compression\
    \ identifier, and obtains the values of\n   INFERRED fields from the link-layer\
    \ implementation, e.g., from the\n   size of the link-layer frame, or from other\
    \ fields, e.g., by\n   recalculating the IPv4 header checksum.  DELTA fields are\
    \ encoded as\n   the difference to the value in the previous packet in the same\
    \ packet\n   stream.  The decompressor must update the context by adding the value\n\
    \   in the compressed header to the value in its context. The result is\n   the\
    \ proper value of the field.  RANDOM fields must be sent \"as-is\" in\n   the\
    \ compressed header.  RANDOM fields must occur in the same order in\n   the compressed\
    \ header as they occur in the full header.\n   Fields that may optionally be used\
    \ to identify what packet stream a\n   packet belongs to according to section\
    \ 4.1 are marked with the word\n   DEF.  To a compressor using the optional guidelines\
    \ from section 4.1,\n   any difference in corresponding DEF fields between two\
    \ packets\n   implies that they belong to different packet streams. Moreover,\
    \ if a\n   DEF field is present in one packet but not in another, the packets\n\
    \   belong to different packet streams.\n"
- title: 7.1.  IPv6 Header [IPv6, section 3]
  contents:
  - "7.1.  IPv6 Header [IPv6, section 3]\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |Version| Traffic Class |               Flow Label              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \         Payload Length        |  Next Header  |   Hop Limit   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   +                                                               +\n      |\
    \                                                               |\n      +   \
    \                      Source Address                        +\n      |      \
    \                                                         |\n      +         \
    \                                                      +\n      |            \
    \                                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   +                                                               +\n      |\
    \                                                               |\n      +   \
    \                   Destination Address                      +\n      |      \
    \                                                         |\n      +         \
    \                                                      +\n      |            \
    \                                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Version                   NOCHANGE (DEF)\n         Traffic Class   \
    \          NOCHANGE (might be DEF, see sect 4.1)\n                           \
    \                 (see also sect 6 a)\n         Flow Label                NOCHANGE\
    \ (DEF)\n         Payload Length            INFERRED\n         Next Header   \
    \            NOCHANGE\n         Hop Limit                 NOCHANGE (might be DEF,\
    \ see sect 4.1)\n         Source Address            NOCHANGE (DEF)\n         Destination\
    \ Address       NOCHANGE (DEF)\n   The Payload Length field of encapsulated headers\
    \ must correspond to\n   the length value of the encapsulating header. If not,\
    \ the header\n   chain MUST NOT be compressed.\n   NOTE: If this the IP header\
    \ closest to a TCP header, bit 7 of the\n   Traffic Class field can be passed\
    \ using the R-flag of the compressed\n   TCP header. See section 6 a).\n   This\
    \ classification implies that the entire IPv6 base header will be\n   compressed\
    \ away.\n"
- title: 7.2.  IPv6 Extension Headers [IPv6, section 4]
  contents:
  - "7.2.  IPv6 Extension Headers [IPv6, section 4]\n   What extension headers are\
    \ present and the relative order of them is\n   not expected to change in a packet\
    \ stream.  Whenever there is a\n   change, a full packet header must be sent.\
    \  All Next Header fields in\n   IPv6 base header and IPv6 extension headers are\
    \ NOCHANGE.\n"
- title: 7.3.  Options [IPv6, section 4.2]
  contents:
  - "7.3.  Options [IPv6, section 4.2]\n   The contents of Hop-by-hop Options and\
    \ Destination Options extension\n   headers are encoded with TLV \"options\" (see\
    \ [IPv6]):\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -\n \
    \           |  Option Type  |  Opt Data Len |  Option Data\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ - - - - - - - -\n   Option Type and Opt Data Len fields are assumed to be fixed\
    \ for a\n   given packet stream, so they are classified as NOCHANGE.  The Option\n\
    \   data is RANDOM unless specified otherwise below.\n   Padding\n       Pad1\
    \ option\n            +-+-+-+-+-+-+-+-+\n            |       0       |\n     \
    \       +-+-+-+-+-+-+-+-+\n          Entire option is NOCHANGE.\n       PadN option\n\
    \            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -\n            |\
    \       1       |  Opt Data Len |  Option Data\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ - - - - - - - -\n          All fields are NOCHANGE.\n"
- title: 7.4.  Hop-by-Hop Options Header [IPv6, section 4.3]
  contents:
  - "7.4.  Hop-by-Hop Options Header [IPv6, section 4.3]\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  Next Header  |  Hdr Ext Len  |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    |                                     \
    \                          |\n    .                                          \
    \                     .\n    .                            Options            \
    \                .\n    .                                                    \
    \           .\n    |                                                         \
    \      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       Next Header          NOCHANGE\n       Hdr Ext Len          NOCHANGE\n\
    \       Options              TLV coded values and padding.\n                 \
    \           Classified according to 7.3 above, unless\n                      \
    \      being a Jumbo Payload option (see below).\n   Jumbo Payload option\n  \
    \                                  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       \
    \                             |      194      |Opt Data Len=4 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                     Jumbo Payload Length                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   First two fields are NOCHANGE and Jumbo Payload Length INFERRED.\n   (frame\
    \ length must be supplied by link layer implementation).\n        NOTE: It is\
    \ silly to compress the headers of a packet carrying a\n        Jumbo Payload\
    \ Option since the relative header overhead is\n        negligible. Moreover,\
    \ it is usually a bad idea to send such\n        large packets over low- and medium-speed\
    \ links.\n"
- title: 7.5.  Routing Header [IPv6, section 4.4]
  contents:
  - "7.5.  Routing Header [IPv6, section 4.4]\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  Next Header  |  Hdr Ext Len  |  Routing Type | Segments Left |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    .\
    \                                                               .\n    .     \
    \                  type-specific data                      .\n    .          \
    \                                                     .\n    |               \
    \                                                |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   All fields of the Routing Header are NOCHANGE.\n   If the Routing Type is\
    \ not recognized, it is impossible to determine\n   the final Destination Address\
    \ unless the Segments Left field has the\n   value zero, in which case the Destination\
    \ Address is the final\n   Destination Address in the basic IPv6 header.\n   In\
    \ the Type 0 Routing Header, the last address is DEF if (Segments\n   Left > 0).\n\
    \   Routing Headers are compressed away completely.  This is a big win as\n  \
    \ the maximum size of the Routing Header is 392 octets.  Moreover, Type\n   0\
    \ Routing Headers with one address, size 24 octets, are used by\n   Mobile IP.\n"
- title: 7.6.  Fragment Header [IPv6, section 4.5]
  contents:
  - "7.6.  Fragment Header [IPv6, section 4.5]\n   The first fragment of a packet\
    \ has Fragment Offset = 0 and the chain\n   of subheaders extends beyond its Fragment\
    \ Header. If a fragment is\n   not the first (Fragment Offset not 0), there are\
    \ no subsequent\n   subheaders (unless the chain of subheaders in the first fragment\n\
    \   didn't fit entirely in the first fragment).\n   Since packets may be reordered\
    \ before reaching the compression point,\n   and some fragments may follow other\
    \ routes through the network, a\n   compressor cannot rely on seeing the first\
    \ fragment before other\n   fragments. This implies that information in subheaders\
    \ following the\n   Fragment Header of the first fragment cannot be examined to\
    \ determine\n   the proper packet stream for other fragments.\n   It is possible\
    \ to design compression schemes that can compress\n   subheaders after the Fragment\
    \ Header, at least in the first fragment,\n   but to avoid complicating the rules\
    \ for sending full headers and the\n   rules for compression and decompression,\
    \ the chain of subheaders that\n   follow a Fragment Header MUST NOT be compressed.\n\
    \   The fields of the Fragment Header are classified as follows.\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  Next Header  |   Reserved    |      Fragment Offset    |Res|M|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                         Identification                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Next Header          NOCHANGE\n          Reserved             NOCHANGE\n\
    \          Res                  RANDOM\n          M flag               RANDOM\n\
    \          Fragment Offset      RANDOM\n          Identification       RANDOM\n\
    \   This classification implies that a Fragment Header is compressed down\n  \
    \ to 6 octets. The minimum IPv6 MTU is 1280 octets so most fragments\n   will\
    \ be at least 1280 octets. Since the 6 octet overhead of the\n   compressed fragment\
    \ header is amortized over a fairly large packet,\n   the additional complexity\
    \ of more sophisticated compression schemes\n   is not justifiable.\n        \
    \  NOTE: The Identification field is RANDOM instead of NOCHANGE\n          to\
    \ avoid one compression slow-start per original packet.\n   Grouping of fragments\
    \ according to the optional guidelines in\n   section4.1:\n       Fragments and\
    \ unfragmented packets should not be grouped\n       together.\n       Port numbers\
    \ cannot be used to identify the packet stream because\n       port numbers are\
    \ not present in every fragment.  To adhere to the\n       uniqueness rules for\
    \ the Identification value, a fragmented\n       packet stream is identified by\
    \ the combination of Source Address\n       and (final) Destination Address.\n\
    \          NOTE: The Identification value is NOT used to identify the\n      \
    \    packet stream. This avoids using a new CID for each packet and\n        \
    \  saves the cost of the associated compression slow-start.  We\n          expect\
    \ that the unfragmentable part of the headers will not\n          change too frequently,\
    \ if it does thrashing may occur.\n"
- title: 7.7.  Destination Options Header [IPv6, section 4.6]
  contents:
  - "7.7.  Destination Options Header [IPv6, section 4.6]\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  Next Header  |  Hdr Ext Len  |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    |                                     \
    \                          |\n    .                                          \
    \                     .\n    .                            Options            \
    \                .\n    .                                                    \
    \           .\n    |                                                         \
    \      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    Next Header          NOCHANGE\n    Hdr Ext Len          NOCHANGE\n    Options\
    \              TLV coded values and padding.\n                           Compressed\
    \ according to 7.3 above.\n   The only Destination Options defined in [IPv6] are\
    \ the padding\n   options.\n"
- title: 7.8.  No Next Header [IPv6, section 4.7]
  contents:
  - "7.8.  No Next Header [IPv6, section 4.7]\n   Covered by rules for IPv6 Header\
    \ Extensions (7.2).\n"
- title: 7.9.  Authentication Header [RFC-2402, section 3.2]
  contents:
  - "7.9.  Authentication Header [RFC-2402, section 3.2]\n     1 2 3 4 5 6 7 8 1 2\
    \ 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8\n    +---------------+---------------+---------------+---------------+\n\
    \    | Next Header   | Length        |           RESERVED            |\n    +---------------+---------------+---------------+---------------+\n\
    \    |                Security Parameters Index (SPI)                |\n    +---------------+---------------+---------------+---------------+\n\
    \    |                                                               |\n    +\
    \     Authentication Data (variable number of 32-bit words)     |\n    |     \
    \                                                          |\n    +---------------+---------------+---------------+---------------+\n\
    \    Next Header          NOCHANGE\n    Length               NOCHANGE\n    Reserved\
    \             NOCHANGE\n    SPI                  NOCHANGE (DEF)\n    Authentication\
    \ Data  RANDOM\n   [RFC-1828] specifies how to do authentication with keyed MD5,\
    \ the\n   authentication method all IPv6 implementations must support.  For\n\
    \   this method, the Authentication Data is 16 octets.\n"
- title: 7.10.  Encapsulating Security Payload Header [RFC-2406, section 3.1]
  contents:
  - "7.10.  Encapsulating Security Payload Header [RFC-2406, section 3.1]\n   This\
    \ header implies that the subsequent parts of the packet are\n   encrypted. Thus,\
    \ no further header compression is possible on\n   subsequent headers as encryption\
    \ is typically already performed when\n   the compressor sees the packet.\n  \
    \ However, when the ESP Header is used in tunnel mode an entire IP\n   packet\
    \ is encrypted, and the headers of that packet MAY be compressed\n   before the\
    \ packet is encrypted at the entry point of the tunnel.\n   This means that it\
    \ must be possible to feed an IP packet and its\n   length to the decompressor,\
    \ as if it came from the link-layer. The\n   mechanisms for dealing with reordering\
    \ described in section 11 MUST\n   also be used, as packets can be reordered in\
    \ a tunnel.\n    +---------------+---------------+---------------+---------------+\n\
    \    |        Security Association Identifier (SPI), 32 bits         |\n    +===============+===============+===============+===============+\n\
    \    |            Opaque Transform Data, variable length             |\n    +---------------+---------------+---------------+---------------+\n\
    \    SPI                          NOCHANGE (DEF)\n    Opaque Transform Data  \
    \      RANDOM\n   Everything after the SPI is encrypted and is not compressed.\n"
- title: 7.11.  UDP Header
  contents:
  - "7.11.  UDP Header\n   The UDP header is described in [RFC-768].\n   The Next\
    \ Header field (IPv6) or Protocol field (IPv4) in the\n   preceding subheader\
    \ is DEF.\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          Source Port          |       Destination Port        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |            Length             |           Checksum            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    Source Port          NOCHANGE (DEF)\n    Destination Port     NOCHANGE (DEF)\n\
    \    Length               INFERRED\n    Checksum             RANDOM, unless it\
    \ is zero,\n                           in which case it is NOCHANGE.\n   The Length\
    \ field of the UDP header MUST match the Length field(s) of\n   preceding subheaders,\
    \ i.e, there must not be any padding after the\n   UDP payload that is covered\
    \ by the IP Length.\n   The UDP header is typically compressed down to 2 octets,\
    \ the UDP\n   checksum.  When the UDP checksum is zero (which it cannot be with\n\
    \   IPv6), it is likely to be so for all packets in the flow and is\n   defined\
    \ to be NOCHANGE. This saves 2 octets in the compressed header.\n"
- title: 7.12.  TCP Header
  contents:
  - "7.12.  TCP Header\n   The TCP header is described in [RFC-793].\n   The Next\
    \ Header field (IPv6) or Protocol field (IPv4) in the\n   preceding subheader\
    \ is DEF.\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          Source Port          |       Destination Port        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                        Sequence Number                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    Acknowledgment Number                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | Offset| Reserved  |U|A|P|R|S|F|            Window             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |           Checksum            |         Urgent Pointer        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    Options                    |    Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    U, A, P, R, S, and F stands for Urg, Ack, Psh, Rst, Syn, and Fin.\n   There\
    \ are two ways to compress the TCP header.\n"
- title: 7.12.1. Compressed with differential encoding
  contents:
  - "7.12.1. Compressed with differential encoding\n   Source Port           NOCHANGE\
    \  (DEF)\n   Destination Port      NOCHANGE  (DEF)\n   Sequence Number       DELTA\n\
    \   Acknowledgment Number DELTA\n   Offset                NOCHANGE\n   Reserved\
    \              DELTA               (if differs from context,\n               \
    \                               set R-flag in flag octet\n                   \
    \                           and send absolute value\n                        \
    \                      as described in 6 a.)\n   Urg,Psh               RANDOM\
    \              (placed in flag octet)\n   Ack                   INFERRED to be\
    \ 1\n   Rst,Syn,Fin           INFERRED to be 0\n   Window                DELTA\
    \               (if change in Window,\n                                      \
    \        set W-flag in flag octet\n                                          \
    \    and send difference)\n   Checksum              RANDOM\n   Urgent Pointer\
    \        DELTA               (if Urg is set, send\n                          \
    \                    absolute value)\n   Options, Padding      DELTA         \
    \      (if change in Options,\n                                              set\
    \ O-flag and send\n                                              whole Options,\
    \ Padding)\n   A packet with a TCP header compressed according to the above must\
    \ be\n   indicated to be of type COMPRESSED_TCP.  The compressed header is\n \
    \  described in section 6.\n   This method is essentially the differential encoding\
    \ techniques of\n   Jacobson, described in [RFC-1144], the differences being the\
    \ placement\n   of the compressed TCP header fields (see section 6), the use of\
    \ the\n   O-flag, the use of the R-flag, and elimination of the C-flag.  The\n\
    \   O-flag allows compression of the TCP header when the Timestamp option\n  \
    \ is used and the Options fields changes with each header.\n   DELTA values (except\
    \ for Reserved field and Options, Padding) MUST be\n   coded as in [RFC-1144].\
    \  A Reserved field value passed with the R-flag\n   MUST NOT update the context\
    \ at compressor or decompressor.\n"
- title: 7.12.2. Without differential encoding
  contents:
  - "7.12.2. Without differential encoding\n       Source Port           NOCHANGE\
    \  (DEF)\n       Destination Port      NOCHANGE  (DEF)\n       (all the rest)\
    \        RANDOM\n   The Identification field in a preceding IPv4 header is RANDOM.\n\
    \   A packet with a TCP header compressed according to the above must be\n   indicated\
    \ to be of type COMPRESSED_TCP_NODELTA.  It uses the same CID\n   space as COMPRESSED_TCP\
    \ packets, and the header MUST be saved as\n   context. The compressed header\
    \ is described in section 6.\n   This packet type can be sent as the response\
    \ to a header request\n   instead of sending a full header, can be used over links\
    \ that reorder\n   packets, and can be sent instead of a full header when there\
    \ are\n   changes that cannot be represented by a compressed header. A\n   sophisticated\
    \ compressor can switch to sending only\n   COMPRESSED_TCP_NODELTA headers when\
    \ the packet loss frequency is high.\n"
- title: 7.13.  IPv4 header [RFC-791, section 3.1]
  contents:
  - "7.13.  IPv4 header [RFC-791, section 3.1]\n     0                   1       \
    \            2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |Version|  IHL  |Type of Service|          Total Length         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |         Identification        |Flags|      Fragment Offset    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  Time to Live |    Protocol   |         Header Checksum       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                       Source Address                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    Destination Address                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    Options                    |    Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   There are two ways to compress the IPv4 header\n   a) If the IPv4 header is\
    \ not for a fragment (MF flag is not set and\n      Fragment Offset is zero) and\
    \ there are no options (IHL is 5), it\n      is classified as follows\n      \
    \ Version              NOCHANGE   (DEF)\n       IHL                  NOCHANGE\
    \   (DEF, must be 5)\n       Type of Service      NOCHANGE   (might be DEF, see\
    \ sect 4.1)\n                                       (see also 6 a)\n       Total\
    \ Length         INFERRED   (from link-layer implementation\n                \
    \                        or encapsulating IP header)\n       Identification  \
    \     DELTA/     (If the Protocol field has the\n                            \
    \           (value corresponding to TCP)\n                            RANDOM \
    \    (otherwise)\n       Flags                NOCHANGE   (MF flag must not be\
    \ set)\n       Fragment Offset      NOCHANGE   (must be zero)\n       Time to\
    \ Live         NOCHANGE   (might be DEF, see sect 4.1)\n       Protocol      \
    \       NOCHANGE\n       Header Checksum      INFERRED   (calculated from other\
    \ fields)\n       Source Address       NOCHANGE   (DEF)\n       Destination Address\
    \  NOCHANGE   (DEF)\n       Options, Padding                (not present)\n  \
    \     Note: When a TCP header immediately follows, the IPv4 and TCP\n       header\
    \ MUST be compressed as a unit as described in section 6.\n       Bits 6 and 7\
    \ of the Type of Service field (bits 14 and 15 of the\n       first word) can\
    \ then be passed using the R-flag (see section 6\n       a).\n   b) If the IPv4\
    \ header is for a fragment (MF bit set or Fragment\n       Offset nonzero), or\
    \ there are options (IHL > 5), all fields are\n       RANDOM (i.e., if the header\
    \ is compressed all fields are sent\n       as-is and not compressed). This classification\
    \ allows compression\n       of the tunnel header, but not the fragment header,\
    \ when fragments\n       are tunneled. If the IPv4 header is for a fragment it\
    \ ends the\n       compressible chain of subheaders, i.e., it must be the last\n\
    \       subheader to be compressed.  If the IPv4 header has options but\n    \
    \   is not for a fragment it does not end the compressible chain of\n       subheaders,\
    \ so subsequent subheaders can be compressed.\n   A compressor that follows the\
    \ optional guidelines of section 4.1 will\n   in case a) use the Version, Source\
    \ Address and Destination Address to\n   define the packet stream, together with\
    \ the fact that there are no\n   IPv4 options and that this is not a fragment.\n\
    \   Case b) can define two kinds of packet streams depending on whether\n   the\
    \ IPv4 header is for a fragment or not.\n   If the IPv4 header in case b) is for\
    \ a fragment, a compressor\n   following the optional guidelines will use that\
    \ fact together with\n   the Version, Source Address, and Destination Address\
    \ to determine the\n   packet stream.\n   If the IPv4 header in case b) is not\
    \ for a fragment, it must have\n   options. A compressor following the optional\
    \ guidelines will use that\n   fact, but not the size of the options, together\
    \ with the Version,\n   Source Address, and Destination Address to determine the\
    \ packet\n   stream.\n"
- title: 7.14.  Minimal Encapsulation header [RFC-2004, section 3.1]
  contents:
  - "7.14.  Minimal Encapsulation header [RFC-2004, section 3.1]\n     0         \
    \          1                   2                   3\n     0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |   Protocol    |S|  reserved   |        Header Checksum        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                 Original Destination Address                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    :            (if present) Original Source Address               :\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    Protocol                             NOCHANGE\n    Original Source Address\
    \ Present (S)  NOCHANGE\n    reserved                             NOCHANGE\n \
    \   Header Checksum                      INFERRED (calculated from\n         \
    \                                  other values)\n    Original Destination Address\
    \         NOCHANGE\n    Original Source Address              NOCHANGE (present\
    \ only\n                                                   if S=1)\n   This header\
    \ is likely to be used by Mobile IP.\n"
- title: 8.  Changing context identifiers
  contents:
  - "8.  Changing context identifiers\n   On a point-to-point link, the compressor\
    \ has total knowledge of what\n   CIDs are in use at the decompressor and may\
    \ change what CID a packet\n   stream uses or reuse CIDs at will.\n   Each non-TCP\
    \ CID is associated with a context with a generation\n   value. To avoid too rapid\
    \ generation wrap-around and potential\n   incorrect decompression, an implementation\
    \ MUST avoid wrap-around of\n   the generation value in less than MIN_WRAP seconds\
    \ (see section 14).\n   To aid in avoiding wrap-around, the generation value associated\
    \ with\n   a CID MUST NOT be reset when changing to a new packet stream.\n   Instead,\
    \ a compressor MUST increment the generation value by one when\n   using the CID\
    \ for a new non-TCP packet stream.\n"
- title: 9.  Rules for dropping or temporarily storing packets
  contents:
  - "9.  Rules for dropping or temporarily storing packets\n   When a decompressor\
    \ receives a packet with a compressed TCP header\n   with CID C, it MUST be discarded\
    \ when the context for C has not been\n   initialized by a full header.\n   When\
    \ a decompressor receives a packet with a compressed non-TCP\n   header with CID\
    \ C and generation G, the header must not be\n   decompressed using the current\
    \ context when\n      a) the decompressor has been disconnected from the compressor\
    \ for\n          more than MIN_WRAP seconds, because the context might be\n  \
    \        obsolete even if it has generation G.\n      b) the context for C has\
    \ a generation other than G.\n   In case a) and b) the packet may either be\n\
    \      i)  discarded immediately, or else\n      ii) stored temporarily until\
    \ the context is updated by a packet\n          with a full non-TCP header with\
    \ CID C and generation G, after\n          which the header can be decompressed.\n\
    \          Packets stored in this manner MUST be discarded when\n            *)\
    \  receiving full or compressed non-TCP headers with CID C\n                and\
    \ a generation other than G,\n            *)  the decompressor has not received\
    \ packets with CID C in\n                the last MIN_WRAP seconds.\n   When full\
    \ headers are lost, a decompressor can receive compressed\n   non-TCP headers\
    \ with a generation value other than the generation of\n   its context.  Rule\
    \ ii) allows the decompressor to store such headers\n   until they can be decompressed\
    \ using the correct context.\n"
- title: 10. Low-loss header compression for TCP
  contents:
  - "10. Low-loss header compression for TCP\n   Since fewer bits are transmitted\
    \ per packet with header compression,\n   the packet loss rate is lower with header\
    \ compression than without,\n   for a fixed bit-error rate.  This is beneficial\
    \ for links with high\n   bit-error rates such as wireless links.\n   However,\
    \ since TCP headers are compressed using differential\n   encoding, a single lost\
    \ TCP segment can ruin an entire TCP sending\n   window because the context is\
    \ not incremented properly at the\n   decompressor.  Subsequent headers will therefore\
    \ be decompressed to\n   be different than before compression and discarded by\
    \ the TCP\n   receiver because the TCP checksum fails.\n   A TCP connection in\
    \ the wide area where the last hop is over a\n   medium-speed lossy link, for\
    \ example a wireless LAN, will then have\n   poor performance with traditional\
    \ header compression because the\n   delay-bandwidth product is relatively large\
    \ and the bit-error rate\n   relatively high. For a 2 Mbit/s wireless LAN and\
    \ an end-to-end RTT of\n   200 ms, the delay-bandwidth product is 50 kbyte.  That\
    \ is equivalent\n   to about 97 512-octet segments with compressed headers.  Each\
    \ loss\n   can thus be multiplied by a factor of 100.\n   This section describes\
    \ two simple mechanisms for quick repair of the\n   context. With these mechanisms\
    \ header compression will improve TCP\n   throughput over lossy links as well\
    \ as links with low bit-error\n   rates.\n"
- title: 10.1.  The "twice" algorithm
  contents:
  - "10.1.  The \"twice\" algorithm\n   The decompressor may compute the TCP checksum\
    \ to determine if its\n   context is not updated properly. If the checksum fails,\
    \ the error is\n   assumed to be caused by a lost segment that did not update\
    \ the\n   context properly. The delta of the current segment is then added to\n\
    \   the context again on the assumption that the lost segment contained\n   the\
    \ same delta as the current. By decompressing and computing the TCP\n   checksum\
    \ again, the decompressor checks if the repair succeeded or if\n   the delta should\
    \ be applied once more.\n   Analysis of traces of various TCP bulk transfers show\
    \ that applying\n   the delta of the current segment one or two times will repair\
    \ the\n   context for between 83 and 99 per cent of all single-segment losses\n\
    \   in the data stream. For the acknowledgment stream, the success rate\n   is\
    \ smaller due to the delayed ack mechanism of TCP. The \"twice\"\n   mechanism\
    \ repairs the context for 53 to 99 per cent of the losses in\n   the acknowledgment\
    \ stream.  A sophisticated implementation of this\n   idea would determine whether\
    \ the TCP stream is an acknowledgment or\n   data stream and determine the segment\
    \ size by observing the stream of\n   full and compressed headers.  Trying deltas\
    \ that are small multiples\n   of the segment size will result in even higher\
    \ rates of successful\n   repairs for acknowledgment streams.\n"
- title: 10.2.  Header Requests
  contents:
  - "10.2.  Header Requests\n   The relatively low success rate for the \"twice\"\
    \ algorithm for TCP\n   acknowledgment streams calls for an additional mechanism\
    \ for\n   repairing the context at the decompressor. When the decompressor\n \
    \  fails to repair the context after a loss, the decompressor may\n   optionally\
    \ request a full header from the compressor.  This is\n   possible on links where\
    \ the decompressor can identify the compressor\n   and send packets to it.\n \
    \  On such links, a decompressor may send a CONTEXT_STATE packet back to\n   the\
    \ compressor to indicate that one or more contexts are invalid.  A\n   decompressor\
    \ SHOULD NOT transmit a CONTEXT_STATE packet every time a\n   compressed packet\
    \ refers to an invalid context, but instead should\n   limit the rate of transmission\
    \ of CONTEXT_STATE packets to avoid\n   flooding the reverse channel. A CONTEXT_STATE\
    \ packet can indicate\n   that several contexts are out of date, this technique\
    \ SHOULD be used\n   instead of sending several separate packets. The following\
    \ diagram\n   shows the format of a CONTEXT_STATE packet.\n                  \
    \         0   1   2   3   4   5   6   7\n                        +---+---+---+---+---+---+---+---+\n\
    \                        |     TCP header request = 3    |\n                 \
    \       +---+---+---+---+---+---+---+---+\n                        |         \
    \  CID count           |\n                        +---+---+---+---+---+---+---+---+\n\
    \                        |              CID              |\n                 \
    \       +---+---+---+---+---+---+---+---+\n                        |         \
    \     CID              |\n                        +---+---+---+---+---+---+---+---+\n\
    \                                               ...\n                        +---+---+---+---+---+---+---+---+\n\
    \                        |              CID              |\n                 \
    \       +---+---+---+---+---+---+---+---+\n   The first octet is a type code to\
    \ allow the CONTEXT_STATE packet type\n   to be shared for other compression protocols\
    \ that are (see [CRTP]) or\n   may be defined in parallel with this one. When\
    \ used for TCP header\n   requests the type code has the value 3, and the remainder\
    \ of the\n   packet is a sequence of CIDs preceded by a one-octet count of the\n\
    \   number of CIDs.\n   On receipt of a CONTEXT_STATE packet, the compressor MUST\
    \ mark the\n   CIDs invalid to ensure that the next packet emitted in those packet\n\
    \   streams are FULL_HEADER or COMPRESSED_TCP_NODELTA packets.\n   Header requests\
    \ are an optimization, so loss of a CONTEXT_STATE\n   packet does not affect the\
    \ correct operation of TCP header\n   compression.  When a CONTEXT_STATE packet\
    \ is lost, eventually a new\n   one will be transmitted or TCP will timeout and\
    \ retransmit.  The big\n   advantage of using header requests is that TCP acknowledgment\
    \ streams\n   can be repaired after a roundtrip-time over the lossy link.  This\n\
    \   will typically avoid a TCP timeout and unnecessary retransmissions.\n   The\
    \ lower packet loss rate due to smaller packets will then result in\n   higher\
    \ throughput because the TCP window can grow larger between\n   losses.\n"
- title: 11.  Links that reorder packets
  contents:
  - "11.  Links that reorder packets\n   Some links reorder packets, for example multi-hop\
    \ radio links that\n   use deflection routing to route around congested nodes.\
    \  Packets\n   routed different ways can then arrive at the destination in a\n\
    \   different order than they were sent.\n"
- title: 11.1.  Reordering in non-TCP packet streams
  contents:
  - "11.1.  Reordering in non-TCP packet streams\n   Compressed non-TCP headers do\
    \ not change the context, and neither do\n   full headers that refresh it.  There\
    \ can be problems only when a full\n   header that changes the context arrives\
    \ out of order.  There are two\n   cases:\n       - A packet with a full header\
    \ with generation G arrives *after*\n         a packet with a compressed header\
    \ with generation G.  This case\n         is covered by rule b) ii) in section\
    \ 9.\n       - A packet with a full header with generation G arrives *before*\n\
    \         a packet with a compressed header with generation G-1 (modulo\n    \
    \     64).  The decompressor MAY then keep both versions of the\n         context\
    \ around for a while to be able to decompress subsequent\n         compressed\
    \ headers with generation G-1 (modulo 64).  The old\n         context MUST be\
    \ discarded after MIN_WRAP seconds.\n"
- title: 11.2.  Reordering in TCP packet streams
  contents:
  - "11.2.  Reordering in TCP packet streams\n   A compressor may avoid sending COMPRESSED_TCP\
    \ headers and only send\n   COMPRESSED_TCP_NODELTA headers when there is reordering\
    \ over the\n   link.  Compressed headers will typically be 17 octets with that\n\
    \   method, significantly larger than the usual 4-7 octets.\n   To achieve better\
    \ compression rates the following method, adding only\n   two octets to the compressed\
    \ header for a total of 6-9 octets, may be\n   used.  A packet sequence number,\
    \ incremented by one for every packet\n   in the TCP stream, is then associated\
    \ with each compressed and full\n   header.  This allows the decompressor to place\
    \ the packets in the\n   correct sequence and apply their deltas to the context\
    \ in the correct\n   order.  A simple sliding window scheme is used to place the\
    \ packets\n   in the correct order.\n   Two octets are needed for the packet sequence\
    \ numbers.  One octet\n   gives only 256 sequence numbers.  In a sliding window\
    \ scheme the\n   window should be no larger than half of the sequence number space,\
    \ so\n   packets can not arrive more than 127 positions out-of-sequence. This\n\
    \   is equivalent to a delay of 260 ms on 2 Mbit/s links with 512 octet\n   segments.\
    \  Delays of that order are not uncommon over wide-area\n   Internet connections.\
    \  However, two octets giving 2^16 = 65536 values\n   should be sufficient.\n\
    \   Full TCP/IP headers will only have space for one octet of sequence\n   number\
    \ when there is no tunneling. It is not feasible to increase the\n   size of full\
    \ headers since the packet size might be optimized for the\n   MTU of the link.\
    \ Therefore only the least significant octet of the\n   packet sequence number\
    \ can be placed in such full headers. We believe\n   that such full headers can\
    \ be positioned correctly frequently enough\n   with only the least significant\
    \ octet of the packet sequence number\n   available.\n   The packet sequence number\
    \ zero MUST be skipped over.  Avoiding zero\n   takes care of a problem that can\
    \ occur when the TCP window scale\n   option is used to enlarge the TCP window.\
    \ When exactly 2^16 octets of\n   TCP data is lost, a compressed header will be\
    \ decompressed\n   incorrectly without being detected by the TCP checksum. TCP\
    \ segment\n   sizes are often a power of two.  So by using a packet sequence number\n\
    \   space that is not a power of two either the TCP sequence number or\n   the\
    \ packet sequence number will differ when 2^16 octets are lost.\n   Whenever a\
    \ compressor sees the window scale option on a SYN segment,\n   it MUST use packet\
    \ sequence numbers when subsequently compressing\n   that packet stream.\n   In\
    \ compressed TCP headers the two octet packet sequence number MUST\n   be placed\
    \ immediately after the TCP Checksum.  See section 5.3 for\n   placement of packet\
    \ sequence numbers in full headers.\n"
- title: 12.  Hooks for additional header compression
  contents:
  - "12.  Hooks for additional header compression\n   The following hook is supplied\
    \ to allow additional header compression\n   schemes for headers on top of UDP.\
    \ The initial chain of subheaders is\n   then compressed as described here, and\
    \ the other header compression\n   scheme is applied to the header above the UDP\
    \ header. An example of\n   such additional header compression is Compressed RTP\
    \ by Casner and\n   Jacobson [CRTP]. To allow some error detection, such schemes\n\
    \   typically need a sequence number that may need to be passed in full\n   headers\
    \ as well as compressed UDP headers.\n   The D-bit and Data octet (see section\
    \ 6) provides the necessary\n   mechanism. When a sequence number, say, needs\
    \ to be passed in a\n   FULL_HEADER or COMPRESSED_NON_TCP header, the D-bit is\
    \ set and the\n   sequence number is placed in the Data field. The decompressor\
    \ must\n   then extract and make the Data field available to the additional\n\
    \   header compression scheme.\n   Use of additional header compression schemes\
    \ like CRTP must be\n   negotiated. The D-bit and Data octet mechanism must automatically\
    \ be\n   enabled whenever use of additional header compression schemes has\n \
    \  been negotiated.\n"
- title: 13.  Demultiplexing
  contents:
  - "13.  Demultiplexing\n   For each link layer, there must be a document specifying\
    \ how the\n   various packet types used by IP header compression is indicated.\n\
    \   Such a document exists for PPP [PPP-HC].  This section gives OPTIONAL\n  \
    \ guidelines on how packet types may be indicated by a specific link-\n   layer.\n\
    \   It is necessary to distinguish packets with regular IPv4 headers,\n   regular\
    \ IPv6 headers, full IPv6 packets, full IPv4 packets,\n   compressed TCP packets,\
    \ compressed non-TCP packets, and CONTEXT_STATE\n   packets.\n   The decision\
    \ to use a distinct ethertype (or equivalent) for IPv6 has\n   already been taken,\
    \ which means that link-layers must be able to\n   indicate that a packet is an\
    \ IPv6 packet.\n   IP header compression requires that the link-layer implementation\
    \ can\n   indicate four kinds of packets: COMPRESSED_TCP for format a) in\n  \
    \ section 6, COMPRESSED_TCP_NODELTA for format b), COMPRESSED_NON_TCP\n   for\
    \ formats c) and d), and CONTEXT_STATE as described in section\n   11.2.  It is\
    \ also desirable to indicate FULL_HEADERS at the link\n   layer.\n   Full headers\
    \ can be indicated by setting the first bit of the Version\n   field in a packet\
    \ indicated to be an IPv6 packet.  In addition, one\n   bit of the Version field\
    \ is used to indicate if the first subheader\n   is an IPv6 or an IPv4 header,\
    \ and one bit is used to indicate if this\n   full header carries a TCP CID or\
    \ a non-TCP CID. The first four bits\n   are encoded as follows:\n      Version\
    \  Meaning\n      -------  -------\n      0110     regular IPv6 header\n     \
    \ 1T*0     T=1 indicates a TCP header, T=0 indicates a non-TCP header\n      1*V0\
    \     V=1 indicates a IPv6 header, V=0 indicates a IPv4 header\n   If a link-layer\
    \ cannot indicate the packet types for the compressed\n   headers or CONTEXT_STATE,\
    \ packet types that cannot be indicated could\n   start with an octet indicating\
    \ the packet type, followed by the\n   header.\n       First octet  Type of compressed\
    \ header\n       -----------   -------------------------\n           0       \
    \ COMPRESSED_TCP\n           1        COMPRESSED_TCP_NODELTA\n           2   \
    \     COMPRESSED_NON_TCP\n           3        CONTEXT_STATE\n   The currently\
    \ assigned CONTEXT_STATE type values are\n       Value   Type                \
    \       Reference\n       -----   -----                      ----------\n    \
    \     0     Reserved                   -\n         1     IP/UDP/RTP w. 8-bit CID\
    \    [CRTP]\n         2     IP/UDP/RTP w. 16-bit CID   [CRTP]\n         3    \
    \ TCP header request         Section 10.2\n"
- title: 14.  Configuration Parameters
  contents:
  - "14.  Configuration Parameters\n   Header compression parameters are negotiated\
    \ in a way specific to the\n   link-layer implementation. Such procedures for\
    \ link-layer xxx needs\n   to be specified in a document \"IP header compression\
    \ over xxx\". Such\n   a document exists for PPP [PPP-HC].\n   The following parameter\
    \ is fixed for all implementations of this\n   header compression scheme.\n  \
    \   MIN_WRAP     - minimum time of generation value wrap around\n          3 seconds.\n\
    \   The following parameters can be negotiated between the compressor and\n  \
    \ decompressor. If not negotiated their values must be as specified by\n   DEFAULT.\n\
    \     F_MAX_PERIOD - Largest number of compressed non-TCP headers that\n     \
    \               may be sent without sending a full header.\n          DEFAULT\
    \ is 256\n          F_MAX_PERIOD must be at least 1 and at most 65535.\n     F_MAX_TIME\
    \   - Compressed headers may not be sent more than\n                    F_MAX_TIME\
    \ seconds after sending last full header.\n          DEFAULT is 5\n          F_MAX_TIME\
    \ must be at least 1 and at most 255.\n          NOTE:  F_MAX_PERIOD and F_MAX_TIME\
    \ should be lower when it is\n                 likely that a decompressor loses\
    \ its state.\n     MAX_HEADER   - The largest header size in octets that may\n\
    \                    be compressed.\n          DEFAULT is 168 octets, which covers\n\
    \                          - Two IPv6 base headers\n                         \
    \ - A Keyed MD5 Authentication Header\n                          - A maximum-sized\
    \ TCP header\n          MAX_HEADER must be at least 60 octets and\n          \
    \        at most 65535 octets.\n     TCP_SPACE    - Maximum CID value for TCP.\n\
    \          DEFAULT is 15   (which gives 16 CID values)\n          TCP_SPACE must\
    \ be at least 3 and at most 255.\n     NON_TCP_SPACE    - Maximum CID value for\
    \ non-TCP.\n          DEFAULT is 15   (which gives 16 CID values)\n          NON_TCP_SPACE\
    \ must be at least 3 and at most 65535.\n     EXPECT_REORDERING       - The mechanisms\
    \ in section 11 are used.\n          DEFAULT no.\n"
- title: 15. Implementation Status
  contents:
  - "15. Implementation Status\n   A prototype using UDP as the link layer has been\
    \ operational since\n   March 1996. A NetBSD implementation for PPP has been operational\n\
    \   since October 1996.\n"
- title: 16.  Acknowledgments
  contents:
  - "16.  Acknowledgments\n   This protocol uses many ideas originated by Van Jacobson\
    \ in the\n   design of header compression for TCP/IP over slow-speed links [RFC-\n\
    \   1144]. It has benefited from discussions with Stephen Casner and\n   Carsten\
    \ Bormann.\n   We thank Craig Partridge for pointing out a problem that can occur\n\
    \   when the TCP window scale option is used.  A solution to this problem\n  \
    \ relying on the packet sequence numbers used for reordering is\n   described\
    \ in section 11.2.\n"
- title: 17.  Security Considerations
  contents:
  - "17.  Security Considerations\n   The compression protocols in this document run\
    \ on top of a link-layer\n   protocol. The compression protocols themselves introduce\
    \ no new\n   additional vulnerabilities beyond those associated with the specific\n\
    \   link-layer technology being used.\n   Denial-of-service attacks are possible\
    \ if an intruder can introduce\n   (for example) bogus Full Header packets onto\
    \ the link.  However, an\n   intruder having the ability to inject arbitrary packets\
    \ at the link-\n   layer in this manner raises additional security issues that\
    \ dwarf\n   those related to the use of header compression.\n   We advise implementors\
    \ against identifying packet streams with the\n   aid of information that is encrypted,\
    \ even if such information\n   happens to be available to the compressor. Doing\
    \ so may expose\n   traffic patterns.\n"
- title: 18.  Authors' Addresses
  contents:
  - "18.  Authors' Addresses\n   Mikael Degermark\n   Department of Computer Science\
    \ and Electrical Engineering\n   Lulea University of Technology\n   SE-971 87\
    \ Lulea, Sweden\n   Phone: +46 920 91188\n   Fax: +46 920 72831\n   Mobile: +46\
    \ 70 833 8933\n   EMail: micke@sm.luth.se\n   Bjorn Nordgren\n   CDT/Telia Research\
    \ AB\n   Aurorum 6\n   S-977 75 Lulea, Sweden\n   Phone: +46 920 75400\n   Fax:\
    \ +46 920 75490\n   EMail: bcn@lulea.trab.se, bcn@cdt.luth.se\n   Stephen Pink\n\
    \   Department of Computer Science and Electrical Engineering\n   Lulea University\
    \ of Technology\n   SE-971 87 Lulea, Sweden\n   Phone: +46 920 752 29\n   Fax:\
    \ +46 920 728 31\n   Mobile: +46 70 532 0007\n   EMail: steve@sm.luth.se\n"
- title: 19.  References
  contents:
  - "19.  References\n   [RFC-768]       Postel, J., \"User Datagram Protocol\", STD\
    \ 6, RFC 768,\n                   August 1980.\n   [RFC-791]       Postel, J.,\
    \ \"Internet Protocol\", STD 5, RFC 791,\n                   September 1981.\n\
    \   [RFC-793]       Postel, J., \"Transmission Control Protocol\", STD 7,\n  \
    \                 RFC 793, September 1981.\n   [RFC-1144]      Jacobson, V., \"\
    Compressing TCP/IP Headers for Low-\n                   Speed Serial Links\",\
    \ RFC 1144, February 1990.\n   [RFC-1553]      Mathur, A. and M. Lewis, \"Compressing\
    \ IPX Headers\n                   Over WAN Media (CIPX)\", RFC 1553, December\
    \ 1993.\n   [RFC-1700]      Reynolds, J. and J. Postel, \"Assigned Numbers\",\
    \ STD\n                   2, RFC 1700, October 1994.  See also:\n            \
    \       http://www.iana.org/numbers.html\n   [RFC-2402]      Kent, S. and R. Atkinson,\
    \ \"IP Authentication Header\",\n                   RFC 2402, November 1998.\n\
    \   [RFC-2406]      Kent, S. and R. Atkinson, \"IP Encapsulating Security\n  \
    \                 Protocol (ESP)\", RFC 2406, November 1998.\n   [RFC-1828]  \
    \    Metzger, W., \"IP Authentication using Keyed MD5\", RFC\n               \
    \    1828, August 1995.\n   [IPv6]          Deering, S. and R. Hinden, \"Internet\
    \ Protocol,\n                   Version 6 (IPv6) Specification\", RFC 2460, December\n\
    \                   1998.\n   [ICMPv6]        Conta, A. and S. Deering, \"Internet\
    \ Control Message\n                   Protocol (ICMPv6) for the Internet Protocol\
    \ Version 6\n                   (IPv6) Specification.\", RFC 2463, December 1998.\n\
    \   [RFC-2004]      Perkins, C., \"Minimal Encapsulation within IP\", RFC\n  \
    \                 2004, October 1996.\n   [CRTP]          Casner, S. and V. Jacobson,\
    \ \"Compressing IP/UDP/RTP\n                   Headers for Low-Speed Serial Links\"\
    , RFC 2508,\n                   February 1999.\n   [PPP-HC]        Engan, M.,\
    \ Casner, S. and C. Bormann, \"IP Header\n                   Compression for PPP\"\
    , RFC 2509, February 1999.\n"
- title: 20.  Full Copyright Statement
  contents:
  - "20.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.  .fi\n"
