- title: __initial_text__
  contents:
  - "                       RPC: Remote Procedure Call\n                         Protocol\
    \ Specification\n                               Version 2\n"
- title: STATUS OF THIS MEMO
  contents:
  - "STATUS OF THIS MEMO\n   This RFC describes a standard that Sun Microsystems and\
    \ others are\n   using, and is one we wish to propose for the Internet's\n   consideration.\
    \  This memo is not an Internet standard at this time.\n   Distribution of this\
    \ memo is unlimited.\n"
- title: 1. INTRODUCTION
  contents:
  - "1. INTRODUCTION\n   This document specifies version two of the message protocol\
    \ used in\n   Sun's Remote Procedure Call (RPC) package.  The message protocol\
    \ is\n   specified with the eXternal Data Representation (XDR) language [9].\n\
    \   This document assumes that the reader is familiar with XDR.  It does\n   not\
    \ attempt to justify remote procedure calls systems or describe\n   their use.\
    \  The paper by Birrell and Nelson [1] is recommended as an\n   excellent background\
    \ for the remote procedure call concept.\n"
- title: 2. TERMINOLOGY
  contents:
  - "2. TERMINOLOGY\n   This document discusses clients, calls, servers, replies,\
    \ services,\n   programs, procedures, and versions.  Each remote procedure call\
    \ has\n   two sides: an active client side that sends the call to a server,\n\
    \   which sends back a reply.  A network service is a collection of one\n   or\
    \ more remote programs.  A remote program implements one or more\n   remote procedures;\
    \ the procedures, their parameters, and results are\n   documented in the specific\
    \ program's protocol specification (see\n   Appendix A for an example).  A server\
    \ may support more than one\n   version of a remote program in order to be compatible\
    \ with changing\n   protocols.\n   For example, a network file service may be\
    \ composed of two programs.\n   One program may deal with high-level applications\
    \ such as file system\n   access control and locking.  The other may deal with\
    \ low-level file\n   input and output and have procedures like \"read\" and \"\
    write\".  A\n   client of the network file service would call the procedures\n\
    \   associated with the two programs of the service on behalf of the\n   client.\n\
    \   The terms client and server only apply to a particular transaction; a\n  \
    \ particular hardware entity (host) or software entity (process or\n   program)\
    \ could operate in both roles at different times.  For\n   example, a program\
    \ that supplies remote execution service could also\n   be a client of a network\
    \ file service.  On the other hand, it may\n   simplify software to separate client\
    \ and server functionality into\n   separate libraries or programs.\n"
- title: 3. THE RPC MODEL
  contents:
  - "3. THE RPC MODEL\n   The Sun RPC protocol is based on the remote procedure call\
    \ model,\n   which is similar to the local procedure call model.  In the local\n\
    \   case, the caller places arguments to a procedure in some well-\n   specified\
    \ location (such as a register window).  It then transfers\n   control to the\
    \ procedure, and eventually regains control.  At that\n   point, the results of\
    \ the procedure are extracted from the well-\n   specified location, and the caller\
    \ continues execution.\n   The remote procedure call model is similar.  One thread\
    \ of control\n   logically winds through two processes: the caller's process,\
    \ and a\n   server's process.  The caller process first sends a call message to\n\
    \   the server process and waits (blocks) for a reply message.  The call\n   message\
    \ includes the procedure's parameters, and the reply message\n   includes the\
    \ procedure's results.  Once the reply message is\n   received, the results of\
    \ the procedure are extracted, and caller's\n   execution is resumed.\n   On the\
    \ server side, a process is dormant awaiting the arrival of a\n   call message.\
    \  When one arrives, the server process extracts the\n   procedure's parameters,\
    \ computes the results, sends a reply message,\n   and then awaits the next call\
    \ message.\n   In this model, only one of the two processes is active at any given\n\
    \   time.  However, this model is only given as an example.  The Sun RPC\n   protocol\
    \ makes no restrictions on the concurrency model implemented,\n   and others are\
    \ possible.  For example, an implementation may choose\n   to have RPC calls be\
    \ asynchronous, so that the client may do useful\n   work while waiting for the\
    \ reply from the server.  Another\n   possibility is to have the server create\
    \ a separate task to process\n   an incoming call, so that the original server\
    \ can be free to receive\n   other requests.\n   There are a few important ways\
    \ in which remote procedure calls differ\n   from local procedure calls:\n   1.\
    \ Error handling: failures of the remote server or network must be\n   handled\
    \ when using remote procedure calls.\n   2. Global variables and side-effects:\
    \ since the server does not have\n   access to the client's address space, hidden\
    \ arguments cannot be\n   passed as global variables or returned as side effects.\n\
    \   3. Performance:  remote procedures usually operate one or more orders\n  \
    \ of magnitude slower than local procedure calls.\n   4. Authentication: since\
    \ remote procedure calls can be transported\n   over insecure networks, authentication\
    \ may be necessary.\n   The conclusion is that even though there are tools to\
    \ automatically\n   generate client and server libraries for a given service,\
    \ protocols\n   must still be designed carefully.\n"
- title: 4. TRANSPORTS AND SEMANTICS
  contents:
  - "4. TRANSPORTS AND SEMANTICS\n   The RPC protocol can be implemented on several\
    \ different transport\n   protocols.  The RPC protocol does not care how a message\
    \ is passed\n   from one process to another, but only with specification and\n\
    \   interpretation of messages.  On the other hand, the application may\n   wish\
    \ to obtain information about (and perhaps control over) the\n   transport layer\
    \ through an interface not specified in this document.\n   For example, the transport\
    \ protocol may impose a restriction on the\n   maximum size of RPC messages, or\
    \ it may be stream-oriented like TCP\n   with no size limit.  The client and server\
    \ must agree on their\n   transport protocol choices, through a mechanism such\
    \ as the one\n   described in Appendix A.\n   It is important to point out that\
    \ RPC does not try to implement any\n   kind of reliability and that the application\
    \ may need to be aware of\n   the type of transport protocol underneath RPC. \
    \ If it knows it is\n   running on top of a reliable transport such as TCP [6],\
    \ then most of\n   the work is already done for it.  On the other hand, if it\
    \ is running\n   on top of an unreliable transport such as UDP [7], it must implement\n\
    \   its own time-out, retransmission, and duplicate detection policies as\n  \
    \ the RPC layer does not provide these services.\n   Because of transport independence,\
    \ the RPC protocol does not attach\n   specific semantics to the remote procedures\
    \ or their execution\n   requirements.  Semantics can be inferred from (but should\
    \ be\n   explicitly specified by) the underlying transport protocol.  For\n  \
    \ example, consider RPC running on top of an unreliable transport such\n   as\
    \ UDP.  If an application retransmits RPC call messages after time-\n   outs,\
    \ and does not receive a reply, it cannot infer anything about\n   the number\
    \ of times the procedure was executed.  If it does receive a\n   reply, then it\
    \ can infer that the procedure was executed at least\n   once.\n   A server may\
    \ wish to remember previously granted requests from a\n   client and not regrant\
    \ them in order to insure some degree of\n   execute-at-most-once semantics. \
    \ A server can do this by taking\n   advantage of the transaction ID that is packaged\
    \ with every RPC\n   message.  The main use of this transaction is by the client\
    \ RPC layer\n   in matching replies to calls.  However, a client application may\n\
    \   choose to reuse its previous transaction ID when retransmitting a\n   call.\
    \  The server may choose to remember this ID after executing a\n   call and not\
    \ execute calls with the same ID in order to achieve some\n   degree of execute-at-most-once\
    \ semantics.  The server is not allowed\n   to examine this ID in any other way\
    \ except as a test for equality.\n   On the other hand, if using a \"reliable\"\
    \ transport such as TCP, the\n   application can infer from a reply message that\
    \ the procedure was\n   executed exactly once, but if it receives no reply message,\
    \ it cannot\n   assume the remote procedure was not executed.  Note that even\
    \ if a\n   connection-oriented protocol like TCP is used, an application still\n\
    \   needs time-outs and reconnection to handle server crashes.\n   There are other\
    \ possibilities for transports besides datagram- or\n   connection-oriented protocols.\
    \  For example, a request-reply protocol\n   such as VMTP [2] is perhaps a natural\
    \ transport for RPC.  The Sun RPC\n   package currently uses both TCP and UDP\
    \ transport protocols, with\n   experimentation underway on others such as ISO\
    \ TP4 and TP0.\n"
- title: 5. BINDING AND RENDEZVOUS INDEPENDENCE
  contents:
  - "5. BINDING AND RENDEZVOUS INDEPENDENCE\n   The act of binding a particular client\
    \ to a particular service and\n   transport parameters is NOT part of this RPC\
    \ protocol specification.\n   This important and necessary function is left up\
    \ to some higher-level\n   software.  (The software may use RPC itself; see Appendix\
    \ A.)\n   Implementors could think of the RPC protocol as the jump-subroutine\n\
    \   instruction (\"JSR\") of a network; the loader (binder) makes JSR\n   useful,\
    \ and the loader itself uses JSR to accomplish its task.\n   Likewise, the binding\
    \ software makes RPC useful, possibly using RPC\n   to accomplish this task.\n"
- title: 6. AUTHENTICATION
  contents:
  - "6. AUTHENTICATION\n   The RPC protocol provides the fields necessary for a client\
    \ to\n   identify itself to a service, and vice-versa, in each call and reply\n\
    \   message.  Security and access control mechanisms can be built on top\n   of\
    \ this message authentication.  Several different authentication\n   protocols\
    \ can be supported.  A field in the RPC header indicates\n   which protocol is\
    \ being used. More information on specific\n   authentication protocols is in\
    \ section 9: \"Authentication Protocols\".\n"
- title: 7. RPC PROTOCOL REQUIREMENTS
  contents:
  - "7. RPC PROTOCOL REQUIREMENTS\n   The RPC protocol must provide for the following:\n\
    \   (1) Unique specification of a procedure to be called.\n   (2) Provisions for\
    \ matching response messages to request messages.\n   (3) Provisions for authenticating\
    \ the caller to service and vice-\n       versa.\n   Besides these requirements,\
    \ features that detect the following are\n   worth supporting because of protocol\
    \ roll-over errors, implementation\n   bugs, user error, and network administration:\n\
    \   (1) RPC protocol mismatches.\n   (2) Remote program protocol version mismatches.\n\
    \   (3) Protocol errors (such as misspecification of a procedure's\n       parameters).\n\
    \   (4) Reasons why remote authentication failed.\n   (5) Any other reasons why\
    \ the desired procedure was not called.\n"
- title: 7.1 RPC Programs and Procedures
  contents:
  - "7.1 RPC Programs and Procedures\n   The RPC call message has three unsigned integer\
    \ fields -- remote\n   program number, remote program version number, and remote\
    \ procedure\n   number -- which uniquely identify the procedure to be called.\n\
    \   Program numbers are administered by some central authority (like\n   Sun).\
    \  Once implementors have a program number, they can implement\n   their remote\
    \ program; the first implementation would most likely have\n   the version number\
    \ 1.  Because most new protocols evolve, a version\n   field of the call message\
    \ identifies which version of the protocol\n   the caller is using.  Version numbers\
    \ make speaking old and new\n   protocols through the same server process possible.\n\
    \   The procedure number identifies the procedure to be called.  These\n   numbers\
    \ are documented in the specific program's protocol\n   specification.  For example,\
    \ a file service's protocol specification\n   may state that its procedure number\
    \ 5 is \"read\" and procedure number\n   12 is \"write\".\n   Just as remote program\
    \ protocols may change over several versions,\n   the actual RPC message protocol\
    \ could also change.  Therefore, the\n   call message also has in it the RPC version\
    \ number, which is always\n   equal to two for the version of RPC described here.\n\
    \   The reply message to a request message has enough information to\n   distinguish\
    \ the following error conditions:\n   (1) The remote implementation of RPC does\
    \ not speak protocol version\n   2. The lowest and highest supported RPC version\
    \ numbers are returned.\n   (2) The remote program is not available on the remote\
    \ system.\n   (3) The remote program does not support the requested version number.\n\
    \   The lowest and highest supported remote program version numbers are\n   returned.\n\
    \   (4) The requested procedure number does not exist.  (This is usually\n   a\
    \ client side protocol or programming error.)\n   (5) The parameters to the remote\
    \ procedure appear to be garbage from\n   the server's point of view.  (Again,\
    \ this is usually caused by a\n   disagreement about the protocol between client\
    \ and service.)\n"
- title: 7.2 Authentication
  contents:
  - "7.2 Authentication\n   Provisions for authentication of caller to service and\
    \ vice-versa are\n   provided as a part of the RPC protocol.  The call message\
    \ has two\n   authentication fields, the credentials and verifier.  The reply\n\
    \   message has one authentication field, the response verifier.  The RPC\n  \
    \ protocol specification defines all three fields to be the following\n   opaque\
    \ type (in the eXternal Data Representation (XDR) language [9]):\n         enum\
    \ auth_flavor {\n            AUTH_NULL       = 0,\n            AUTH_UNIX     \
    \  = 1,\n            AUTH_SHORT      = 2,\n            AUTH_DES        = 3\n \
    \           /* and more to be defined */\n         };\n         struct opaque_auth\
    \ {\n            auth_flavor flavor;\n            opaque body<400>;\n        \
    \ };\n   In other words, any \"opaque_auth\" structure is an \"auth_flavor\"\n\
    \   enumeration followed by bytes which are opaque to (uninterpreted by)\n   the\
    \ RPC protocol implementation.\n   The interpretation and semantics of the data\
    \ contained within the\n   authentication fields is specified by individual, independent\n\
    \   authentication protocol specifications.  (Section 9 defines the\n   various\
    \ authentication protocols.)\n   If authentication parameters were rejected, the\
    \ reply message\n   contains information stating why they were rejected.\n"
- title: 7.3 Program Number Assignment
  contents:
  - "7.3 Program Number Assignment\n   Program numbers are given out in groups of\
    \ hexadecimal 20000000\n   (decimal 536870912) according to the following chart:\n\
    \                 0 - 1fffffff   defined by Sun\n          20000000 - 3fffffff\
    \   defined by user\n          40000000 - 5fffffff   transient\n          60000000\
    \ - 7fffffff   reserved\n          80000000 - 9fffffff   reserved\n          a0000000\
    \ - bfffffff   reserved\n          c0000000 - dfffffff   reserved\n          e0000000\
    \ - ffffffff   reserved\n   The first group is a range of numbers administered\
    \ by Sun\n   Microsystems and should be identical for all sites.  The second range\n\
    \   is for applications peculiar to a particular site.  This range is\n   intended\
    \ primarily for debugging new programs.  When a site develops\n   an application\
    \ that might be of general interest, that application\n   should be given an assigned\
    \ number in the first range.  The third\n   group is for applications that generate\
    \ program numbers dynamically.\n   The final groups are reserved for future use,\
    \ and should not be used.\n"
- title: 7.4 Other Uses of the RPC Protocol
  contents:
  - "7.4 Other Uses of the RPC Protocol\n   The intended use of this protocol is for\
    \ calling remote procedures.\n   Normally, each call message is matched with a\
    \ reply message.\n   However, the protocol itself is a message-passing protocol\
    \ with which\n   other (non-procedure call) protocols can be implemented.  Sun\n\
    \   currently uses, or perhaps abuses, the RPC message protocol for the\n   batching\
    \ (or pipelining) and broadcast remote procedure calls.\n"
- title: 7.4.1 Batching
  contents:
  - "7.4.1 Batching\n   Batching is useful when a client wishes to send an arbitrarily\
    \ large\n   sequence of call messages to a server.  Batching typically uses\n\
    \   reliable byte stream protocols (like TCP) for its transport.  In the\n   case\
    \ of batching, the client never waits for a reply from the server,\n   and the\
    \ server does not send replies to batch calls.  A sequence of\n   batch calls\
    \ is usually terminated by a legitimate remote procedure\n   call operation in\
    \ order to flush the pipeline and get positive\n   acknowledgement.\n"
- title: 7.4.2 Broadcast Remote Procedure Calls
  contents:
  - "7.4.2 Broadcast Remote Procedure Calls\n   In broadcast protocols, the client\
    \ sends a broadcast call to the\n   network and waits for numerous replies.  This\
    \ requires the use of\n   packet-based protocols (like UDP) as its transport protocol.\
    \  Servers\n   that support broadcast protocols only respond when the call is\n\
    \   successfully processed, and are silent in the face of errors.\n   Broadcast\
    \ calls use the Port Mapper RPC service to achieve their\n   semantics.  See Appendix\
    \ A for more information.\n"
- title: 8. THE RPC MESSAGE PROTOCOL
  contents:
  - "8. THE RPC MESSAGE PROTOCOL\n   This section defines the RPC message protocol\
    \ in the XDR data\n   description language [9].\n         enum msg_type {\n  \
    \          CALL  = 0,\n            REPLY = 1\n         };\n   A reply to a call\
    \ message can take on two forms: The message was\n   either accepted or rejected.\n\
    \         enum reply_stat {\n            MSG_ACCEPTED = 0,\n            MSG_DENIED\
    \   = 1\n         };\n   Given that a call message was accepted, the following\
    \ is the status\n   of an attempt to call a remote procedure.\n         enum accept_stat\
    \ {\n            SUCCESS       = 0, /* RPC executed successfully       */\n  \
    \          PROG_UNAVAIL  = 1, /* remote hasn't exported program  */\n        \
    \    PROG_MISMATCH = 2, /* remote can't support version #  */\n            PROC_UNAVAIL\
    \  = 3, /* program can't support procedure */\n            GARBAGE_ARGS  = 4 \
    \ /* procedure can't decode params   */\n         };\n   Reasons why a call message\
    \ was rejected:\n         enum reject_stat {\n            RPC_MISMATCH = 0, /*\
    \ RPC version number != 2          */\n            AUTH_ERROR = 1    /* remote\
    \ can't authenticate caller */\n         };\n   Why authentication failed:\n \
    \        enum auth_stat {\n            AUTH_BADCRED      = 1,  /* bad credentials\
    \ (seal broken) */\n            AUTH_REJECTEDCRED = 2,  /* client must begin new\
    \ session */\n            AUTH_BADVERF      = 3,  /* bad verifier (seal broken)\
    \    */\n            AUTH_REJECTEDVERF = 4,  /* verifier expired or replayed \
    \ */\n            AUTH_TOOWEAK      = 5   /* rejected for security reasons */\n\
    \         };\n   The RPC message:\n   All messages start with a transaction identifier,\
    \ xid, followed by a\n   two-armed discriminated union.  The union's discriminant\
    \ is a\n   msg_type which switches to one of the two types of the message.  The\n\
    \   xid of a REPLY message always matches that of the initiating CALL\n   message.\
    \  NB: The xid field is only used for clients matching reply\n   messages with\
    \ call messages or for servers detecting retransmissions;\n   the service side\
    \ cannot treat this id as any type of sequence number.\n         struct rpc_msg\
    \ {\n            unsigned int xid;\n            union switch (msg_type mtype)\
    \ {\n            case CALL:\n               call_body cbody;\n            case\
    \ REPLY:\n               reply_body rbody;\n            } body;\n         };\n\
    \   Body of an RPC call:\n   In version 2 of the RPC protocol specification, rpcvers\
    \ must be equal\n   to 2.  The fields prog, vers, and proc specify the remote\
    \ program,\n   its version number, and the procedure within the remote program\
    \ to be\n   called.  After these fields are two authentication parameters:  cred\n\
    \   (authentication credentials) and verf (authentication verifier).  The\n  \
    \ two authentication parameters are followed by the parameters to the\n   remote\
    \ procedure, which are specified by the specific program\n   protocol.\n     \
    \    struct call_body {\n            unsigned int rpcvers;       /* must be equal\
    \ to two (2) */\n            unsigned int prog;\n            unsigned int vers;\n\
    \            unsigned int proc;\n            opaque_auth cred;\n            opaque_auth\
    \ verf;\n            /* procedure specific parameters start here */\n        \
    \ };\n   Body of a reply to an RPC call:\n         union reply_body switch (reply_stat\
    \ stat) {\n         case MSG_ACCEPTED:\n            accepted_reply areply;\n \
    \        case MSG_DENIED:\n            rejected_reply rreply;\n         } reply;\n\
    \   Reply to an RPC call that was accepted by the server:\n   There could be an\
    \ error even though the call was accepted.  The first\n   field is an authentication\
    \ verifier that the server generates in\n   order to validate itself to the client.\
    \  It is followed by a union\n   whose discriminant is an enum accept_stat.  The\
    \ SUCCESS arm of the\n   union is protocol specific.  The PROG_UNAVAIL, PROC_UNAVAIL,\
    \ and\n   GARBAGE_ARGS arms of the union are void.  The PROG_MISMATCH arm\n  \
    \ specifies the lowest and highest version numbers of the remote\n   program supported\
    \ by the server.\n         struct accepted_reply {\n            opaque_auth verf;\n\
    \            union switch (accept_stat stat) {\n            case SUCCESS:\n  \
    \             opaque results[0];\n               /*\n                * procedure-specific\
    \ results start here\n                */\n             case PROG_MISMATCH:\n \
    \               struct {\n                   unsigned int low;\n             \
    \      unsigned int high;\n                } mismatch_info;\n             default:\n\
    \                /*\n                 * Void.  Cases include PROG_UNAVAIL, PROC_UNAVAIL,\n\
    \                 * and GARBAGE_ARGS.\n                 */\n                void;\n\
    \             } reply_data;\n         };\n   Reply to an RPC call that was rejected\
    \ by the server:\n   The call can be rejected for two reasons: either the server\
    \ is not\n   running a compatible version of the RPC protocol (RPC_MISMATCH),\
    \ or\n   the server refuses to authenticate the caller (AUTH_ERROR). In case\n\
    \   of an RPC version mismatch, the server returns the lowest and highest\n  \
    \ supported RPC version numbers.  In case of refused authentication,\n   failure\
    \ status is returned.\n         union rejected_reply switch (reject_stat stat)\
    \ {\n         case RPC_MISMATCH:\n            struct {\n               unsigned\
    \ int low;\n               unsigned int high;\n            } mismatch_info;\n\
    \         case AUTH_ERROR:\n            auth_stat stat;\n         };\n"
- title: 9. AUTHENTICATION PROTOCOLS
  contents:
  - "9. AUTHENTICATION PROTOCOLS\n   As previously stated, authentication parameters\
    \ are opaque, but\n   open-ended to the rest of the RPC protocol.  This section\
    \ defines\n   some \"flavors\" of authentication implemented at (and supported\
    \ by)\n   Sun.  Other sites are free to invent new authentication types, with\n\
    \   the same rules of flavor number assignment as there is for program\n   number\
    \ assignment.\n"
- title: 9.1 Null Authentication
  contents:
  - "9.1 Null Authentication\n   Often calls must be made where the client does not\
    \ know its identity\n   or the server does not care who the client is.  In this\
    \ case, the\n   flavor value (the discriminant of the opaque_auth's union) of\
    \ the RPC\n   message's credentials, verifier, and reply verifier is \"AUTH_NULL\"\
    .\n   The bytes of the opaque_auth's body are undefined.  It is recommended\n\
    \   that the opaque length be zero.\n"
- title: 9.2 UNIX Authentication
  contents:
  - "9.2 UNIX Authentication\n   The client may wish to identify itself as it is identified\
    \ on a\n   UNIX(tm) system.  The value of the credential's discriminant of an\n\
    \   RPC call message is \"AUTH_UNIX\".  The bytes of the credential's\n   opaque\
    \ body encode the the following structure:\n         struct auth_unix {\n    \
    \        unsigned int stamp;\n            string machinename<255>;\n         \
    \   unsigned int uid;\n            unsigned int gid;\n            unsigned int\
    \ gids<16>;\n         };\n   The \"stamp\" is an arbitrary ID which the caller\
    \ machine may generate.\n   The \"machinename\" is the name of the caller's machine\
    \ (like\n   \"krypton\").  The \"uid\" is the caller's effective user ID.  The\
    \ \"gid\"\n   is the caller's effective group ID.  The \"gids\" is a counted array\
    \ of\n   groups which contain the caller as a member.  The verifier\n   accompanying\
    \ the credentials should be of \"AUTH_NULL\" (defined\n   above).  Note these\
    \ credentials are only unique within a particular\n   domain of machine names,\
    \ uids, and gids.  Inter-domain naming is\n   beyond the scope of this document.\n\
    \   The value of the discriminant of the reply verifier received in the\n   reply\
    \ message from the server may be \"AUTH_NULL\" or \"AUTH_SHORT\".  In\n   the\
    \ case of \"AUTH_SHORT\", the bytes of the reply verifier's string\n   encode\
    \ an opaque structure.  This new opaque structure may now be\n   passed to the\
    \ server instead of the original \"AUTH_UNIX\" flavor\n   credentials.  The server\
    \ may keep a cache which maps shorthand opaque\n   structures (passed back by\
    \ way of an \"AUTH_SHORT\" style reply\n   verifier) to the original credentials\
    \ of the caller.  The caller can\n   save network bandwidth and server cpu cycles\
    \ by using the new\n   credentials.\n   The server may flush the shorthand opaque\
    \ structure at any time.  If\n   this happens, the remote procedure call message\
    \ will be rejected due\n   to an authentication error.  The reason for the failure\
    \ will be\n   \"AUTH_REJECTEDCRED\".  At this point, the client may wish to try\
    \ the\n   original \"AUTH_UNIX\" style of credentials.\n"
- title: 9.3 DES Authentication
  contents:
  - "9.3 DES Authentication\n   UNIX authentication suffers from three major problems:\n\
    \   (1) The naming is too UNIX oriented.\n   (2) There is no universal name, uid,\
    \ and gid space.\n   (3) There is no verifier, so credentials can easily be faked.\n\
    \   DES authentication attempts to address these problems.\n"
- title: 9.3.1 Naming
  contents:
  - "9.3.1 Naming\n   The first problem is handled by addressing the client by a simple\n\
    \   string of characters instead of by an operating system specific\n   integer.\
    \  This string of characters is known as the \"netname\" or\n   network name of\
    \ the client. The server is not allowed to interpret\n   the contents of the client's\
    \ name in any other way except to identify\n   the client.  Thus, netnames should\
    \ be unique for every client in the\n   Internet.\n   It is up to each operating\
    \ system's implementation of DES\n   authentication to generate netnames for its\
    \ users that insure this\n   uniqueness when they call upon remote servers.  Operating\
    \ systems\n   already know how to distinguish users local to their systems. It\
    \ is\n   usually a simple matter to extend this mechanism to the network.  For\n\
    \   example, a UNIX user at Sun with a user ID of 515 might be assigned\n   the\
    \ following netname: \"unix.515@sun.com\".  This netname contains\n   three items\
    \ that serve to insure it is unique.  Going backwards,\n   there is only one naming\
    \ domain called \"sun.com\" in the Internet.\n   Within this domain, there is\
    \ only one UNIX user with user ID 515.\n   However, there may be another user\
    \ on another operating system, for\n   example VMS, within the same naming domain\
    \ that, by coincidence,\n   happens to have the same user ID. To insure that these\
    \ two users can\n   be distinguished we add the operating system name. So one\
    \ user is\n   \"unix.515@sun.com\" and the other is \"vms.515@sun.com\".\n   The\
    \ first field is actually a naming method rather than an operating\n   system\
    \ name.  It happens that today there is almost a one-to-one\n   correspondence\
    \ between naming methods and operating systems.  If the\n   world could agree\
    \ on a naming standard, the first field could be the\n   name of that standard,\
    \ instead of an operating system name.\n"
- title: 9.3.2 DES Authentication Verifiers
  contents:
  - "9.3.2 DES Authentication Verifiers\n   Unlike UNIX authentication, DES authentication\
    \ does have a verifier\n   so the server can validate the client's credential\
    \ (and vice-versa).\n   The contents of this verifier is primarily an encrypted\
    \ timestamp.\n   The server can decrypt this timestamp, and if it is close to\
    \ the real\n   time, then the client must have encrypted it correctly.  The only\
    \ way\n   the client could encrypt it correctly is to know the \"conversation\n\
    \   key\" of the RPC session. And if the client knows the conversation\n   key,\
    \ then it must be the real client.\n   The conversation key is a DES [5] key which\
    \ the client generates and\n   passes to the server in its first RPC call.  The\
    \ conversation key is\n   encrypted using a public key scheme in this first transaction.\
    \  The\n   particular public key scheme used in DES authentication is Diffie-\n\
    \   Hellman [3] with 192-bit keys.  The details of this encryption method\n  \
    \ are described later.\n   The client and the server need the same notion of the\
    \ current time in\n   order for all of this to work, perhaps by using the Network\
    \ Time\n   Protocol [4].  If network time synchronization cannot be guaranteed,\n\
    \   then the client can determine the server's time before beginning the\n   conversation\
    \ using a simpler time request protocol.\n   The way a server determines if a\
    \ client timestamp is valid is\n   somewhat complicated. For any other transaction\
    \ but the first, the\n   server just checks for two things:\n   (1) the timestamp\
    \ is greater than the one  previously seen from the\n   same client.\n   (2) the\
    \ timestamp has not expired.\n   A timestamp is expired if the server's time is\
    \ later than the sum of\n   the client's timestamp plus what is known as the client's\
    \ \"window\".\n   The \"window\" is a number the client passes (encrypted) to\
    \ the server\n   in its first transaction.  You can think of it as a lifetime\
    \ for the\n   credential.\n   This explains everything but the first transaction.\
    \  In the first\n   transaction, the server checks only that the timestamp has\
    \ not\n   expired.  If this was all that was done though, then it would be\n \
    \  quite easy for the client to send random data in place of the\n   timestamp\
    \ with a fairly good chance of succeeding.  As an added\n   check, the client\
    \ sends an encrypted item in the first transaction\n   known as the \"window verifier\"\
    \ which must be equal to the window\n   minus 1, or the server will reject the\
    \ credential.\n   The client too must check the verifier returned from the server\
    \ to be\n   sure it is legitimate.  The server sends back to the client the\n\
    \   encrypted timestamp it received from the client, minus one second.\n   If\
    \ the client gets anything different than this, it will reject it.\n"
- title: 9.3.3 Nicknames and Clock Synchronization
  contents:
  - "9.3.3 Nicknames and Clock Synchronization\n   After the first transaction, the\
    \ server's DES authentication\n   subsystem returns in its verifier to the client\
    \ an integer \"nickname\"\n   which the client may use in its further transactions\
    \ instead of\n   passing its netname, encrypted DES key and window every time.\
    \ The\n   nickname is most likely an index into a table on the server which\n\
    \   stores for each client its netname, decrypted DES key and window.\n   Though\
    \ they originally were synchronized, the client's and server's\n   clocks can\
    \ get out of sync again.  When this happens the client RPC\n   subsystem most\
    \ likely will get back \"RPC_AUTHERROR\" at which point it\n   should resynchronize.\n\
    \   A client may still get the \"RPC_AUTHERROR\" error even though it is\n   synchronized\
    \ with the server.  The reason is that the server's\n   nickname table is a limited\
    \ size, and it may flush entries whenever\n   it wants.  A client should resend\
    \ its original credential in this\n   case and the server will give it a new nickname.\
    \  If a server\n   crashes, the entire nickname table gets flushed, and all clients\
    \ will\n   have to resend their original credentials.\n"
- title: 9.3.4 DES Authentication Protocol Specification
  contents:
  - "9.3.4 DES Authentication Protocol Specification\n   There are two kinds of credentials:\
    \ one in which the client uses its\n   full network name, and one in which it\
    \ uses its \"nickname\" (just an\n   unsigned integer) given to it by the server.\
    \  The client must use its\n   fullname in its first transaction with the server,\
    \ in which the\n   server will return to the client its nickname.  The client\
    \ may use\n   its nickname in all further transactions with the server. There\
    \ is no\n   requirement to use the nickname, but it is wise to use it for\n  \
    \ performance reasons.\n      enum authdes_namekind {\n         ADN_FULLNAME =\
    \ 0,\n         ADN_NICKNAME = 1\n      };\n   A 64-bit block of encrypted DES\
    \ data:\n   typedef opaque des_block[8];\n   Maximum length of a network user's\
    \ name:\n   const MAXNETNAMELEN = 255;\n   A fullname contains the network name\
    \ of the client, an encrypted\n   conversation key and the window. The window\
    \ is actually a lifetime\n   for the credential.  If the time indicated in the\
    \ verifier timestamp\n   plus the window has past, then the server should expire\
    \ the request\n   and not grant it.  To insure that requests are not replayed,\
    \ the\n   server should insist that timestamps are greater than the previous\n\
    \   one seen, unless it is the first transaction.  In the first\n   transaction,\
    \ the server checks instead that the window verifier is\n   one less than the\
    \ window.\n   struct authdes_fullname {\n      string name<MAXNETNAMELEN>;  /*\
    \ name of client                */\n      des_block key;               /* PK encrypted\
    \ conversation key */\n      opaque window[4];            /* encrypted window\
    \              */\n   };\n   A credential is either a fullname or a nickname:\n\
    \   union authdes_cred switch (authdes_namekind adc_namekind) {\n   case ADN_FULLNAME:\n\
    \      authdes_fullname adc_fullname;\n   case ADN_NICKNAME:\n      int adc_nickname;\n\
    \   };\n   A timestamp encodes the time since midnight,   March 1, 1970.\n   struct\
    \ timestamp {\n      unsigned int seconds;    /* seconds          */\n      unsigned\
    \ int useconds;   /* and microseconds */\n   };\n   Verifier: client variety.\n\
    \   The window verifier is only used in the first transaction.  In\n   conjunction\
    \ with a fullname credential, these items are packed into\n   the following structure\
    \ before being encrypted:\n   struct {\n       adv_timestamp;        -- one DES\
    \ block\n       adc_fullname.window;  -- one half DES block\n       adv_winverf;\
    \          -- one half DES block\n   }\n   This structure is encrypted using CBC\
    \ mode encryption with an input\n   vector of zero.  All other encryptions of\
    \ timestamps use ECB mode\n   encryption.\n   struct authdes_verf_clnt {\n   \
    \   des_block adv_timestamp;    /* encrypted timestamp       */\n      opaque\
    \ adv_winverf[4];      /* encrypted window verifier */\n   };\n      Verifier:\
    \ server variety.\n   The server returns (encrypted) the same timestamp the client\
    \ gave it\n   minus one second.  It also tells the client its nickname to be used\n\
    \   in future transactions (unencrypted).\n   struct authdes_verf_svr {\n    \
    \  des_block adv_timeverf;     /* encrypted verifier      */\n      int adv_nickname;\
    \      /* new nickname for client */\n   };\n"
- title: 9.3.5 Diffie-Hellman Encryption
  contents:
  - "9.3.5 Diffie-Hellman Encryption\n   In this scheme, there are two constants \"\
    BASE\" and \"MODULUS\" [3].\n   The particular values Sun has chosen for these\
    \ for the DES\n   authentication protocol are:\n   const BASE = 3;\n   const MODULUS\
    \ = \"d4a0ba0250b6fd2ec626e7efd637df76c716e22d0944b88b\"\n   The way this scheme\
    \ works is best explained by an example.  Suppose\n   there are two people \"\
    A\" and \"B\" who want to send encrypted messages\n   to each other.  So, A and\
    \ B both generate \"secret\" keys at random\n   which they do not reveal to anyone.\
    \  Let these keys be represented as\n   SK(A) and SK(B).  They also publish in\
    \ a public directory their\n   \"public\" keys. These keys are computed as follows:\n\
    \         PK(A) = ( BASE ** SK(A) ) mod MODULUS\n         PK(B) = ( BASE ** SK(B)\
    \ ) mod MODULUS\n   The \"**\" notation is used here to represent exponentiation.\
    \ Now, both\n   A and B can arrive at the \"common\" key between them, represented\
    \ here\n   as CK(A, B), without revealing their secret keys.\n   A computes:\n\
    \      CK(A, B) = ( PK(B) ** SK(A)) mod MODULUS\n   while B computes:\n      CK(A,\
    \ B) = ( PK(A) ** SK(B)) mod MODULUS\n   These two can be shown to be equivalent:\n\
    \      (PK(B) ** SK(A)) mod MODULUS = (PK(A) ** SK(B)) mod MODULUS\n   We drop\
    \ the \"mod MODULUS\" parts and assume modulo arithmetic to\n   simplify things:\n\
    \      PK(B) ** SK(A) = PK(A) ** SK(B)\n   Then, replace PK(B) by what B computed\
    \ earlier and likewise for PK(A).\n      ((BASE ** SK(B)) ** SK(A) = (BASE **\
    \ SK(A)) ** SK(B)\n   which leads to:\n      BASE ** (SK(A) * SK(B)) = BASE **\
    \ (SK(A) * SK(B))\n   This common key CK(A, B) is not used to encrypt the timestamps\
    \ used\n   in the protocol. Rather, it is used only to encrypt a conversation\n\
    \   key which is then used to encrypt the timestamps.  The reason for\n   doing\
    \ this is to use the common key as little as possible, for fear\n   that it could\
    \ be broken.  Breaking the conversation key is a far less\n   serious offense,\
    \ since conversations are relatively short-lived.\n   The conversation key is\
    \ encrypted using 56-bit DES keys, yet the\n   common key is 192 bits.  To reduce\
    \ the number of bits, 56 bits are\n   selected from the common key as follows.\
    \ The middle-most 8-bytes are\n   selected from the common key, and then parity\
    \ is added to the lower\n   order bit of each byte, producing a 56-bit key with\
    \ 8 bits of parity.\n"
- title: 10. RECORD MARKING STANDARD
  contents:
  - "10. RECORD MARKING STANDARD\n   When RPC messages are passed on top of a byte\
    \ stream transport\n   protocol (like TCP), it is necessary to delimit one message\
    \ from\n   another in order to detect and possibly recover from protocol errors.\n\
    \   This is called record marking (RM).  Sun uses this RM/TCP/IP\n   transport\
    \ for passing RPC messages on TCP streams.  One RPC message\n   fits into one\
    \ RM record.\n   A record is composed of one or more record fragments.  A record\n\
    \   fragment is a four-byte header followed by 0 to (2**31) - 1 bytes of\n   fragment\
    \ data.  The bytes encode an unsigned binary number; as with\n   XDR integers,\
    \ the byte order is from highest to lowest.  The number\n   encodes two values\
    \ -- a boolean which indicates whether the fragment\n   is the last fragment of\
    \ the record (bit value 1 implies the fragment\n   is the last fragment) and a\
    \ 31-bit unsigned binary value which is the\n   length in bytes of the fragment's\
    \ data.  The boolean value is the\n   highest-order bit of the header; the length\
    \ is the 31 low-order bits.\n   (Note that this record specification is NOT in\
    \ XDR standard form!)\n"
- title: 11. THE RPC LANGUAGE
  contents:
  - "11. THE RPC LANGUAGE\n   Just as there was a need to describe the XDR data-types\
    \ in a formal\n   language, there is also need to describe the procedures that\
    \ operate\n   on these XDR data-types in a formal language as well.  The RPC\n\
    \   Language is an extension to the XDR language, with the addition of\n   \"\
    program\", \"procedure\", and \"version\" declarations.  The following\n   example\
    \ is used to describe the essence of the language.\n"
- title: 11.1 An Example Service Described in the RPC Language
  contents:
  - "11.1 An Example Service Described in the RPC Language\n   Here is an example\
    \ of the specification of a simple ping program.\n      program PING_PROG {\n\
    \            /*\n             * Latest and greatest version\n             */\n\
    \            version PING_VERS_PINGBACK {\n               void\n             \
    \  PINGPROC_NULL(void) = 0;\n               /*\n                * Ping the client,\
    \ return the round-trip time\n                * (in microseconds). Returns -1\
    \ if the operation\n                * timed out.\n                */\n       \
    \        int\n               PINGPROC_PINGBACK(void) = 1;\n            } = 2;\n\
    \            /*\n             * Original version\n             */\n          \
    \  version PING_VERS_ORIG {\n               void\n               PINGPROC_NULL(void)\
    \ = 0;\n            } = 1;\n         } = 1;\n         const PING_VERS = 2;   \
    \   /* latest version */\n   The first version described is PING_VERS_PINGBACK\
    \ with two\n   procedures, PINGPROC_NULL and PINGPROC_PINGBACK.  PINGPROC_NULL\
    \ takes\n   no arguments and returns no results, but it is useful for computing\n\
    \   round-trip times from the client to the server and back again.  By\n   convention,\
    \ procedure 0 of any RPC protocol should have the same\n   semantics, and never\
    \ require any kind of authentication.  The second\n   procedure is used for the\
    \ client to have the server do a reverse ping\n   operation back to the client,\
    \ and it returns the amount of time (in\n   microseconds) that the operation used.\
    \  The next version,\n   PING_VERS_ORIG, is the original version of the protocol\
    \ and it does\n   not contain PINGPROC_PINGBACK procedure. It is useful for\n\
    \   compatibility with old client programs, and as this program matures\n   it\
    \ may be dropped from the protocol entirely.\n"
- title: 11.2 The RPC Language Specification
  contents:
  - "11.2 The RPC Language Specification\n   The RPC language is identical to the\
    \ XDR language defined in RFC\n   1014, except for the added definition of a \"\
    program-def\" described\n   below.\n   program-def:\n      \"program\" identifier\
    \ \"{\"\n         version-def\n         version-def *\n      \"}\" \"=\" constant\
    \ \";\"\n   version-def:\n      \"version\" identifier \"{\"\n          procedure-def\n\
    \          procedure-def *\n      \"}\" \"=\" constant \";\"\n   procedure-def:\n\
    \      type-specifier identifier \"(\" type-specifier\n        (\",\" type-specifier\
    \ )* \")\" \"=\" constant \";\"\n"
- title: 11.3 Syntax Notes
  contents:
  - "11.3 Syntax Notes\n   (1) The following keywords are added and cannot be used\
    \ as\n   identifiers: \"program\" and \"version\";\n   (2) A version name cannot\
    \ occur more than once within the scope of a\n   program definition. Nor can a\
    \ version number occur more than once\n   within the scope of a program definition.\n\
    \   (3) A procedure name cannot occur more than once within the scope of\n   a\
    \ version definition. Nor can a procedure number occur more than once\n   within\
    \ the scope of version definition.\n   (4) Program identifiers are in the same\
    \ name space as constant and\n   type identifiers.\n   (5) Only unsigned constants\
    \ can be assigned to programs, versions and\n   procedures.\n"
- title: 'APPENDIX A: PORT MAPPER PROGRAM PROTOCOL'
  contents:
  - "APPENDIX A: PORT MAPPER PROGRAM PROTOCOL\n   The port mapper program maps RPC\
    \ program and version numbers to\n   transport-specific port numbers.  This program\
    \ makes dynamic binding\n   of remote programs possible.\n   This is desirable\
    \ because the range of reserved port numbers is very\n   small and the number\
    \ of potential remote programs is very large.  By\n   running only the port mapper\
    \ on a reserved port, the port numbers of\n   other remote programs can be ascertained\
    \ by querying the port mapper.\n   The port mapper also aids in broadcast RPC.\
    \  A given RPC program will\n   usually have different port number bindings on\
    \ different machines, so\n   there is no way to directly broadcast to all of these\
    \ programs. The\n   port mapper, however, does have a fixed port number.  So,\
    \ to\n   broadcast to a given program, the client actually sends its message\n\
    \   to the port mapper located at the broadcast address. Each port mapper\n  \
    \ that picks up the broadcast then calls the local service specified by\n   the\
    \ client.  When the port mapper gets the reply from the local\n   service, it\
    \ sends the reply on back to the client.\n"
- title: A.1 Port Mapper Protocol Specification (in RPC Language)
  contents:
  - "A.1 Port Mapper Protocol Specification (in RPC Language)\n         const PMAP_PORT\
    \ = 111;      /* portmapper port number */\n   A mapping of (program, version,\
    \ protocol) to port number:\n         struct mapping {\n            unsigned int\
    \ prog;\n            unsigned int vers;\n            unsigned int prot;\n    \
    \        unsigned int port;\n         };\n   Supported values for the \"prot\"\
    \ field:\n         const IPPROTO_TCP = 6;      /* protocol number for TCP/IP */\n\
    \         const IPPROTO_UDP = 17;     /* protocol number for UDP/IP */\n   A list\
    \ of mappings:\n         struct *pmaplist {\n            mapping map;\n      \
    \      pmaplist next;\n         };\n   Arguments to callit:\n         struct call_args\
    \ {\n            unsigned int prog;\n            unsigned int vers;\n        \
    \    unsigned int proc;\n            opaque args<>;\n         };\n   Results of\
    \ callit:\n         struct call_result {\n            unsigned int port;\n   \
    \         opaque res<>;\n         };\n   Port mapper procedures:\n         program\
    \ PMAP_PROG {\n            version PMAP_VERS {\n               void\n        \
    \       PMAPPROC_NULL(void)         = 0;\n               bool\n              \
    \ PMAPPROC_SET(mapping)       = 1;\n               bool\n               PMAPPROC_UNSET(mapping)\
    \     = 2;\n               unsigned int\n               PMAPPROC_GETPORT(mapping)\
    \   = 3;\n               pmaplist\n               PMAPPROC_DUMP(void)        \
    \ = 4;\n               call_result\n               PMAPPROC_CALLIT(call_args)\
    \  = 5;\n            } = 2;\n         } = 100000;\n"
- title: A.2 Port Mapper Operation
  contents:
  - "A.2 Port Mapper Operation\n   The portmapper program currently supports two protocols\
    \ (UDP and\n   TCP).  The portmapper is contacted by talking to it on assigned\
    \ port\n   number 111 (SUNRPC) on either of these protocols.\n   The following\
    \ is a description of each of the portmapper procedures:\n   PMAPPROC_NULL:\n\
    \   This procedure does no work.  By convention, procedure zero of any\n   protocol\
    \ takes no parameters and returns no results.\n   PMAPPROC_SET:\n   When a program\
    \ first becomes available on a machine, it registers\n   itself with the port\
    \ mapper program on the same machine.  The program\n   passes its program number\
    \ \"prog\", version number \"vers\", transport\n   protocol number \"prot\", and\
    \ the port \"port\" on which it awaits\n   service request.  The procedure returns\
    \ a boolean reply whose value\n   is \"TRUE\" if the procedure successfully established\
    \ the mapping and\n   \"FALSE\" otherwise.  The procedure refuses to establish\
    \ a mapping if\n   one already exists for the tuple \"(prog, vers, prot)\".\n\
    \   PMAPPROC_UNSET:\n   When a program becomes unavailable, it should unregister\
    \ itself with\n   the port mapper program on the same machine.  The parameters\
    \ and\n   results have meanings identical to those of \"PMAPPROC_SET\".  The\n\
    \   protocol and port number fields of the argument are ignored.\n   PMAPPROC_GETPORT:\n\
    \   Given a program number \"prog\", version number \"vers\", and transport\n\
    \   protocol number \"prot\", this procedure returns the port number on\n   which\
    \ the program is awaiting call requests.  A port value of zeros\n   means the\
    \ program has not been registered.  The \"port\" field of the\n   argument is\
    \ ignored.\n   PMAPPROC_DUMP:\n   This procedure enumerates all entries in the\
    \ port mapper's database.\n   The procedure takes no parameters and returns a\
    \ list of program,\n   version, protocol, and port values.\n   PMAPPROC_CALLIT:\n\
    \   This procedure allows a client to call another remote procedure on\n   the\
    \ same machine without knowing the remote procedure's port number.\n   It is intended\
    \ for supporting broadcasts to arbitrary remote programs\n   via the well-known\
    \ port mapper's port.  The parameters \"prog\",\n   \"vers\", \"proc\", and the\
    \ bytes of \"args\" are the program number,\n   version number, procedure number,\
    \ and parameters of the remote\n   procedure.  Note:\n   (1) This procedure only\
    \ sends a reply if the procedure was\n   successfully executed and is silent (no\
    \ reply) otherwise.\n   (2) The port mapper communicates with the remote program\
    \ using UDP\n   only.\n   The procedure returns the remote program's port number,\
    \ and the reply\n   is the reply of the remote procedure.\n"
- title: REFERENCES
  contents:
  - "REFERENCES\n   [1] Birrell, A. D.  & Nelson, B. J., \"Implementing Remote Procedure\n\
    \       Calls\", XEROX CSL-83-7, October 1983.\n   [2] Cheriton, D., \"VMTP: Versatile\
    \ Message Transaction Protocol\",\n       Preliminary Version 0.3, Stanford University,\
    \ January 1987.\n   [3] Diffie & Hellman, \"New Directions in Cryptography\",\
    \ IEEE\n       Transactions on Information Theory IT-22, November 1976.\n   [4]\
    \ Mills, D., \"Network Time Protocol\", RFC-958, M/A-COM Linkabit,\n       September\
    \ 1985.\n   [5] National Bureau of Standards, \"Data Encryption Standard\", Federal\n\
    \       Information Processing Standards Publication 46, January 1977.\n   [6]\
    \ Postel, J., \"Transmission Control Protocol - DARPA Internet\n       Program\
    \ Protocol Specification\", RFC-793, Information Sciences\n       Institute, September\
    \ 1981.\n   [7] Postel, J., \"User Datagram Protocol\", RFC-768, Information\n\
    \       Sciences Institute, August 1980.\n   [8] Reynolds, J., and Postel, J.,\
    \ \"Assigned Numbers\", RFC-1010,\n       Information Sciences Institute, May\
    \ 1987.\n   [9] Sun Microsystems, \"XDR: External Data Representation Standard\"\
    ,\n       RFC-1014, June 1987.\n"
