- title: __initial_text__
  contents:
  - "            Mobile Ad Hoc Network (MANET) Extension of OSPF\n             Using\
    \ Connected Dominating Set (CDS) Flooding\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies an extension of OSPFv3 to support mobile\
    \ ad\n   hoc networks (MANETs).  The extension, called OSPF-MDR, is designed\n\
    \   as a new OSPF interface type for MANETs.  OSPF-MDR is based on the\n   selection\
    \ of a subset of MANET routers, consisting of MANET\n   Designated Routers (MDRs)\
    \ and Backup MDRs.  The MDRs form a connected\n   dominating set (CDS), and the\
    \ MDRs and Backup MDRs together form a\n   biconnected CDS for robustness.  This\
    \ CDS is exploited in two ways.\n   First, to reduce flooding overhead, an optimized\
    \ flooding procedure\n   is used in which only (Backup) MDRs flood new link state\n\
    \   advertisements (LSAs) back out the receiving interface; reliable\n   flooding\
    \ is ensured by retransmitting LSAs along adjacencies.\n   Second, adjacencies\
    \ are formed only between (Backup) MDRs and a\n   subset of their neighbors, allowing\
    \ for much better scaling in dense\n   networks.  The CDS is constructed using\
    \ 2-hop neighbor information\n   provided in a Hello protocol extension.  The\
    \ Hello protocol is\n   further optimized by allowing differential Hellos that\
    \ report only\n   changes in neighbor states.  Options are specified for originating\n\
    \   router-LSAs that provide full or partial topology information,\n   allowing\
    \ overhead to be reduced by advertising less topology\n   information.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\
    \ in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n\
    \   Please review these documents carefully, as they describe your rights\n  \
    \ and restrictions with respect to this document.\n   This document may contain\
    \ material from IETF Documents or IETF\n   Contributions published or made publicly\
    \ available before November\n   10, 2008.  The person(s) controlling the copyright\
    \ in some of this\n   material may not have granted the IETF Trust the right to\
    \ allow\n   modifications of such material outside the IETF Standards Process.\n\
    \   Without obtaining an adequate license from the person(s) controlling\n   the\
    \ copyright in such materials, this document may not be modified\n   outside the\
    \ IETF Standards Process, and derivative works of it may\n   not be created outside\
    \ the IETF Standards Process, except to format\n   it for publication as an RFC\
    \ or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Terminology ................................................5\n  \
    \ 2. Overview ........................................................7\n    \
    \  2.1. Selection of MDRs, BMDRs, Parents, and Adjacencies .........8\n      2.2.\
    \ Flooding Procedure .........................................9\n      2.3. Link\
    \ State Acknowledgments ................................10\n      2.4. Routable\
    \ Neighbors ........................................10\n      2.5. Partial and\
    \ Full Topology LSAs ............................11\n      2.6. Hello Protocol\
    \ ............................................12\n   3. Interface and Neighbor\
    \ Data Structures .........................12\n      3.1. Changes to Interface\
    \ Data Structure .......................12\n      3.2. New Configurable Interface\
    \ Parameters .....................13\n      3.3. Changes to Neighbor Data Structure\
    \ ........................15\n   4. Hello Protocol .................................................17\n\
    \      4.1. Sending Hello Packets .....................................17\n  \
    \    4.2. Receiving Hello Packets ...................................20\n    \
    \  4.3. Neighbor Acceptance Condition .............................24\n   5. MDR\
    \ Selection Algorithm ........................................25\n      5.1. Phase\
    \ 1: Creating the Neighbor Connectivity Matrix ........27\n      5.2. Phase 2:\
    \ MDR Selection ....................................27\n      5.3. Phase 3: Backup\
    \ MDR Selection .............................29\n      5.4. Phase 4: Parent Selection\
    \ .................................29\n      5.5. Phase 5: Optional Selection\
    \ of Non-Flooding MDRs ..........30\n   6. Interface State Machine ........................................31\n\
    \      6.1. Interface States ..........................................31\n  \
    \    6.2. Events that Cause Interface State Changes .................31\n    \
    \  6.3. Changes to Interface State Machine ........................32\n   7. Adjacency\
    \ Maintenance ..........................................32\n      7.1. Changes\
    \ to Neighbor State Machine .........................33\n      7.2. Whether to\
    \ Become Adjacent ................................34\n      7.3. Whether to Eliminate\
    \ an Adjacency .........................35\n      7.4. Sending Database Description\
    \ Packets ......................35\n      7.5. Receiving Database Description\
    \ Packets ....................36\n   8. Flooding Procedure .............................................37\n\
    \      8.1. LSA Forwarding Procedure ..................................38\n  \
    \    8.2. Sending Link State Acknowledgments ........................41\n    \
    \  8.3. Retransmitting LSAs .......................................42\n      8.4.\
    \ Receiving Link State Acknowledgments ......................42\n   9. Router-LSAs\
    \ ....................................................43\n      9.1. Routable\
    \ Neighbors ........................................44\n      9.2. Backbone Neighbors\
    \ ........................................45\n      9.3. Selected Advertised Neighbors\
    \ .............................45\n      9.4. Originating Router-LSAs ...................................46\n\
    \   10. Calculating the Routing Table .................................47\n  \
    \ 11. Security Considerations .......................................49\n   12.\
    \ IANA Considerations ...........................................50\n   13. Acknowledgments\
    \ ...............................................51\n   14. Normative References\
    \ ..........................................51\n   15. Informative References\
    \ ........................................51\n   Appendix A.  Packet Formats .......................................52\n\
    \      A.1.  Options Field ............................................52\n  \
    \    A.2.  Link-Local Signaling .....................................52\n    \
    \  A.3.  Hello Packet DR and Backup DR Fields .....................57\n      A.4.\
    \  LSA Formats and Examples .................................57\n   Appendix B.\
    \  Detailed Algorithms for MDR/BMDR Selection ...........62\n      B.1.  Detailed\
    \ Algorithm for Step 2.4 (MDR Selection) ..........62\n      B.2.  Detailed Algorithm\
    \ for Step 3.2 (BMDR Selection) .........63\n   Appendix C.  Min-Cost LSA Algorithm\
    \ ...............................65\n   Appendix D.  Non-Ackable LSAs for Periodic\
    \ Flooding ...............68\n   Appendix E.  Simulation Results ...................................69\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies an extension of OSPFv3 [RFC5340]\
    \ to support a\n   new interface type for mobile ad hoc networks (MANETs), i.e.,\
    \ for\n   broadcast-capable, multihop wireless networks in which routers and\n\
    \   hosts can be mobile.  Note that OSPFv3 is specified by describing the\n  \
    \ modifications to OSPFv2 [RFC2328].  This MANET extension of OSPFv3 is\n   also\
    \ applicable to non-mobile mesh networks using layer-3 routing.\n   This extension\
    \ does not preclude the use of any existing OSPF\n   interface types, and is fully\
    \ compatible with legacy OSPFv3\n   implementations.\n   Existing OSPF interface\
    \ types do not perform adequately in MANETs,\n   due to scaling issues regarding\
    \ the flooding protocol operation,\n   inability of the Designated Router election\
    \ protocol to converge in\n   all scenarios, and large numbers of adjacencies\
    \ when using a point-\n   to-multipoint interface type.\n   The approach taken\
    \ is to generalize the concept of an OSPF Designated\n   Router (DR) and Backup\
    \ DR to multihop wireless networks, in order to\n   reduce overhead by reducing\
    \ the number of routers that must flood new\n   LSAs and reducing the number of\
    \ adjacencies.  The generalized\n   (Backup) Designated Routers are called (Backup)\
    \ MANET Designated\n   Routers (MDRs).  The MDRs form a connected dominating set\
    \ (CDS), and\n   the MDRs and Backup MDRs together form a biconnected CDS for\n\
    \   robustness (if the network itself is biconnected).  By definition,\n   each\
    \ router in the MANET either belongs to the CDS or is one hop away\n   from it.\
    \  A distributed algorithm is used to select and dynamically\n   maintain the\
    \ biconnected CDS.  Adjacencies are established only\n   between (Backup) MDRs\
    \ and a subset of their neighbors, thus resulting\n   in a dramatic reduction\
    \ in the number of adjacencies in dense\n   networks, compared to the approach\
    \ of forming adjacencies between all\n   neighbor pairs.  The OSPF extension is\
    \ called OSPF-MDR.\n   Hello packets are modified, using OSPF link-local signaling\
    \ (LLS; see\n   [RFC5613]), for two purposes: to provide neighbors with 2-hop\n\
    \   neighbor information that is required by the MDR selection algorithm,\n  \
    \ and to allow differential Hellos that report only changes in neighbor\n   states.\
    \  Differential Hellos can be sent more frequently without a\n   significant increase\
    \ in overhead, in order to respond more quickly to\n   topology changes.\n   Each\
    \ MANET router advertises a subset of its MANET neighbors as\n   point-to-point\
    \ links in its router-LSA.  The choice of which\n   neighbors to advertise is\
    \ flexible, allowing overhead to be reduced\n   by advertising less topology information.\
    \  Options are specified for\n   originating router-LSAs that provide full or\
    \ partial topology\n   information.\n   This document is organized as follows.\
    \  Section 2 presents an\n   overview of OSPF-MDR, Section 3 presents the new\
    \ interface and\n   neighbor data items that are required for the extension, Section\
    \ 4\n   describes the Hello protocol, including procedures for maintaining\n \
    \  the 2-hop neighbor information, Section 5 describes the MDR selection\n   algorithm,\
    \ Section 6 describes changes to the Interface state\n   machine, Section 7 describes\
    \ the procedures for forming adjacencies\n   and deciding which neighbors should\
    \ become adjacent, Section 8\n   describes the flooding procedure, Section 9 specifies\
    \ the\n   requirements and options for the contents of router-LSAs, and Section\n\
    \   10 describes changes in the calculation of the routing table.\n   The appendices\
    \ specify packet formats, detailed algorithms for the\n   MDR selection algorithm,\
    \ an algorithm for the selection of a subset\n   of neighbors to advertise in\
    \ the router-LSA to provide shortest-path\n   routing, a proposed option that\
    \ uses non-ackable LSAs to provide\n   periodic flooding without the overhead\
    \ of Link State Acknowledgments,\n   and simulation results that predict the performance\
    \ of OSPF-MDR in\n   mobile networks with up to 200 nodes.  Additional information\
    \ and\n   resources for OSPF-MDR can be found at http://www.manet-routing.org.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ [RFC2119].\n   In addition, this document uses the following terms:\n   MANET\
    \ Interface\n      A MANET Interface is a new OSPF interface type that supports\n\
    \      broadcast-capable, multihop wireless networks.  Two neighboring\n     \
    \ routers on a MANET interface may not be able to communicate\n      directly\
    \ with each other.  A neighboring router on a MANET\n      interface is called\
    \ a MANET neighbor.  MANET neighbors are\n      discovered dynamically using a\
    \ modification of OSPF's Hello\n      protocol.\n   MANET Router\n      A MANET\
    \ Router is an OSPF router that has at least one MANET\n      interface.\n   Differential\
    \ Hello\n      A Differential Hello is a Hello packet that reduces the overhead\n\
    \      of sending full Hellos, by including only the Router IDs of\n      neighbors\
    \ whose state changed recently.\n   2-Hop Neighbor Information\n      This information\
    \ specifies the bidirectional neighbors of each\n      neighbor.  The modified\
    \ Hello protocol provides each MANET router\n      with 2-hop neighbor information,\
    \ which is used for selecting MDRs\n      and Backup MDRs.\n   MANET Designated\
    \ Router (MDR)\n      A MANET Designated Router is one of a set of routers responsible\n\
    \      for flooding new LSAs, and for determining the set of adjacencies\n   \
    \   that must be formed.  The set of MDRs forms a connected dominating\n     \
    \ set and is a generalization of the DR found in broadcast networks.\n      Each\
    \ router runs the MDR selection algorithm for each MANET\n      interface, to\
    \ decide whether the router is an MDR, Backup MDR, or\n      neither for that\
    \ interface.\n   Backup MANET Designated Router (Backup MDR or BMDR)\n      A\
    \ Backup MANET Designated Router is one of a set of routers\n      responsible\
    \ for providing backup flooding when neighboring MDRs\n      fail.  The set of\
    \ MDRs and Backup MDRs forms a biconnected\n      dominating set.  The Backup\
    \ MDR is a generalization of the Backup\n      DR found in broadcast networks.\n\
    \   MDR Other\n      A router is an MDR Other for a particular MANET interface\
    \ if it is\n      neither an MDR nor a Backup MDR for that interface.\n   Parent\n\
    \      Each router selects a Parent for each MANET interface.  The Parent\n  \
    \    of a non-MDR router will be a neighboring MDR if one exists.  The\n     \
    \ Parent of an MDR is always the router itself.  Each non-MDR router\n      becomes\
    \ adjacent with its Parent.  The Router ID of the Parent is\n      advertised\
    \ in the DR field of each Hello sent on the interface.\n   Backup Parent\n   \
    \   If the option of biconnected adjacencies is chosen, then each MDR\n      Other\
    \ selects a Backup Parent, which will be a neighboring MDR or\n      BMDR if one\
    \ exists that is not the Parent.  The Backup Parent of a\n      BMDR is always\
    \ the router itself.  Each MDR Other becomes adjacent\n      with its Backup Parent\
    \ if it exists.  The Router ID of the Backup\n      Parent is advertised in the\
    \ Backup DR field of each Hello sent on\n      the interface.\n   Bidirectional\
    \ Neighbor\n      A bidirectional neighbor is a neighboring router whose neighbor\n\
    \      state is 2-Way or greater.\n   Routable Neighbor\n      A bidirectional\
    \ MANET neighbor becomes routable if the SPF\n      calculation has produced a\
    \ route to the neighbor and the neighbor\n      satisfies a quality condition.\
    \  Once a neighbor becomes routable,\n      it remains routable as long as it\
    \ remains bidirectional.  Only\n      routable and Full neighbors can be used\
    \ as next hops in the SPF\n      calculation, and can be included in the router-LSA\
    \ originated by\n      the router.\n   Non-Flooding MDR\n      A non-flooding\
    \ MDR is an MDR that does not automatically flood\n      received LSAs back out\
    \ the receiving interface, but performs\n      backup flooding like a BMDR.  Some\
    \ MDRs may declare themselves\n      non-flooding in order to reduce flooding\
    \ overhead.\n"
- title: 2.  Overview
  contents:
  - "2.  Overview\n   This section provides an overview of OSPF-MDR, including motivation\n\
    \   and rationale for some of the design choices.\n   OSPF-MDR was motivated by\
    \ the desire to extend OSPF to support\n   MANETs, while keeping the same design\
    \ philosophy as OSPF and using\n   techniques that are similar to those of OSPF.\
    \  For example, OSPF\n   reduces overhead in a broadcast network by electing a\
    \ Designated\n   Router (DR) and Backup DR, and by having two neighboring routers\
    \ form\n   an adjacency only if one of them is the DR or Backup DR.  This idea\n\
    \   can be generalized to a multihop wireless network by forming a\n   spanning\
    \ tree, with the edges of the tree being the adjacencies and\n   the interior\
    \ (non-leaf) nodes of the tree being the generalized DRs,\n   called MANET Designated\
    \ Routers (MDRs).\n   To provide better robustness and fast response to topology\
    \ changes,\n   it was decided that a router should decide whether it is an MDR\
    \ based\n   only on local information that can be obtained from neighbors'\n \
    \  Hellos.  The resulting set of adjacencies therefore does not always\n   form\
    \ a tree globally, but appears to be a tree locally.  Similarly,\n   the Backup\
    \ DR can be generalized to Backup MDRs (BMDRs), to provide\n   robustness through\
    \ biconnected redundancy.  The set of MDRs forms a\n   connected dominating set\
    \ (CDS), and the set of MDRs and BMDRs forms a\n   biconnected dominating set\
    \ (if the network itself is biconnected).\n   The following subsections provide\
    \ an overview of each of the main\n   features of OSPF-MDR, starting with a summary\
    \ of how MDRs, BMDRs, and\n   adjacencies are selected.\n"
- title: 2.1.  Selection of MDRs, BMDRs, Parents, and Adjacencies
  contents:
  - "2.1.  Selection of MDRs, BMDRs, Parents, and Adjacencies\n   The MDR selection\
    \ algorithm is distributed; each router selects\n   itself as an MDR, BMDR, or\
    \ other router (called an \"MDR Other\") based\n   on information about its one-hop\
    \ neighborhood, which is obtained from\n   Hello packets received from neighbors.\
    \  Routers are ordered\n   lexicographically based on the tuple (RtrPri, MDR Level,\
    \ RID), where\n   RtrPri is the Router Priority, MDR Level represents the current\
    \ state\n   of the router (2 for an MDR, 1 for a BMDR, and 0 for an MDR Other),\n\
    \   and RID is the Router ID.  Routers with lexicographically larger\n   values\
    \ of (RtrPri, MDR Level, RID) are given preference for becoming\n   MDRs.\n  \
    \ The MDR selection algorithm can be summarized as follows.  If the\n   router\
    \ itself has a larger value of (RtrPri, MDR Level, RID) than all\n   of its neighbors,\
    \ it selects itself as an MDR.  Otherwise, let Rmax\n   denote the neighbor with\
    \ the largest value of (RtrPri, MDR Level,\n   RID).  The router then selects\
    \ itself as an MDR unless each neighbor\n   can be reached from Rmax in at most\
    \ k hops via neighbors that have a\n   larger value of (RtrPri, MDR Level, RID)\
    \ than the router itself,\n   where k is the parameter MDRConstraint, whose default\
    \ value is 3.\n   This parameter serves to control the density of the MDR set,\
    \ since\n   the MDR set need not be strictly minimal.\n   Similarly, a router\
    \ that does not select itself as an MDR will select\n   itself as a BMDR unless\
    \ each neighbor can be reached from Rmax via\n   two node-disjoint paths, using\
    \ as intermediate hops only neighbors\n   that have a larger value of (RtrPri,\
    \ MDR Level, RID) than the router\n   itself.\n   When a router selects itself\
    \ as an MDR, it also decides which MDR\n   neighbors it should become adjacent\
    \ with, to ensure that the set of\n   MDRs and the adjacencies between them form\
    \ a connected backbone.\n   Each non-MDR router selects and becomes adjacent with\
    \ an MDR neighbor\n   called its Parent, thus ensuring that all routers are connected\
    \ to\n   the MDR backbone.\n   If the option of biconnected adjacencies is chosen\
    \ (AdjConnectivity =\n   2), then additional adjacencies are selected to ensure\
    \ that the set\n   of MDRs and BMDRs, and the adjacencies between them, form a\n\
    \   biconnected backbone.  In this case, each MDR Other selects and\n   becomes\
    \ adjacent with an MDR/BMDR neighbor called its Backup Parent,\n   in addition\
    \ to its Parent.\n   OSPF-MDR also provides the option of full-topology adjacencies\n\
    \   (AdjConnectivity = 0).  If this option is selected, then each router\n   forms\
    \ an adjacency with each bidirectional neighbor.  Although BMDR\n   selection\
    \ is optional if AdjConnectivity is 0 or 1, it is recommended\n   since BMDRs\
    \ improve robustness by providing backup flooding.\n   Prioritizing routers according\
    \ to (RtrPri, MDR Level, RID) allows\n   neighboring routers to agree on which\
    \ routers should become an MDR,\n   and gives higher priority to existing MDRs,\
    \ which increases the\n   lifetime of MDRs and the adjacencies between them. \
    \ In addition,\n   Parents are selected to be existing adjacent neighbors whenever\n\
    \   possible, to avoid forming new adjacencies unless necessary.  Once a\n   neighbor\
    \ becomes adjacent, it remains adjacent as long as the\n   neighbor is bidirectional\
    \ and either the neighbor or the router\n   itself is an MDR or BMDR (similar\
    \ to OSPF).  The above rules reduce\n   the rate at which new adjacencies are\
    \ formed, which is important\n   since database exchange must be performed whenever\
    \ a new adjacency is\n   formed.\n"
- title: 2.2.  Flooding Procedure
  contents:
  - "2.2.  Flooding Procedure\n   When an MDR receives a new link state advertisement\
    \ (LSA) on a MANET\n   interface, it floods the LSA back out the receiving interface\
    \ unless\n   it can be determined that such flooding is unnecessary (as specified\n\
    \   in Section 8.1).  The router MAY delay the flooding of the LSA by a\n   small\
    \ random amount of time (e.g., less than 100 ms).  The delayed\n   flooding is\
    \ useful for coalescing multiple LSAs in the same Link\n   State Update packet,\
    \ and it can reduce the possibility of a collision\n   in case multiple MDRs received\
    \ the same LSA at the same time.\n   However, such collisions are usually avoided\
    \ with wireless MAC\n   protocols.\n   When a Backup MDR receives a new LSA on\
    \ a MANET interface, it waits a\n   short interval (BackupWaitInterval), and then\
    \ floods the LSA only if\n   it has a neighbor that did not flood or acknowledge\
    \ the LSA and is\n   not known to be a neighbor of another neighbor (of the Backup\
    \ MDR)\n   that flooded the LSA.\n   MDR Other routers never flood LSAs back out\
    \ the receiving interface.\n   To exploit the broadcast nature of MANETs, a new\
    \ LSA is processed\n   (and possibly forwarded) if it is received from any neighbor\
    \ in state\n   2-Way or greater.  The flooding procedure also avoids redundant\n\
    \   forwarding of LSAs when multiple interfaces exist.\n"
- title: 2.3.  Link State Acknowledgments
  contents:
  - "2.3.  Link State Acknowledgments\n   All Link State Acknowledgment packets are\
    \ multicast.  An LSA is\n   acknowledged if it is a new LSA, or if it is a duplicate\
    \ LSA received\n   as a unicast.  (A duplicate LSA received as multicast is not\n\
    \   acknowledged.)  An LSA that is flooded back out the same interface is\n  \
    \ treated as an implicit acknowledgment.  Link State Acknowledgments\n   may be\
    \ delayed to allow coalescing multiple acknowledgments in the\n   same packet.\
    \  The only exception is that (Backup) MDRs send a\n   multicast Link State Acknowledgment\
    \ immediately when a duplicate LSA\n   is received as a unicast, in order to prevent\
    \ additional\n   retransmissions.  Only Link State Acknowledgments from adjacent\n\
    \   neighbors are processed, and retransmitted LSAs are sent (via\n   unicast)\
    \ only to adjacent neighbors.\n"
- title: 2.4.  Routable Neighbors
  contents:
  - "2.4.  Routable Neighbors\n   In OSPF, a neighbor must typically be fully adjacent\
    \ (in state Full)\n   for it to be used in the SPF calculation.  An exception\
    \ exists for an\n   OSPF broadcast network, to avoid requiring all pairs of routers\
    \ in\n   such a network to form adjacencies, which would generate a large\n  \
    \ amount of overhead.  In such a network, a router can use a non-\n   adjacent\
    \ neighbor as a next hop as long as both routers are fully\n   adjacent with the\
    \ Designated Router.  We define this neighbor\n   relationship as a \"routable\
    \ neighbor\" and extend its usage to the\n   MANET interface type.\n   A MANET\
    \ neighbor becomes routable if it is bidirectional and the SPF\n   calculation\
    \ has produced a route to the neighbor.  (A flexible\n   quality condition may\
    \ also be required.)  Only routable and Full\n   neighbors can be used as next\
    \ hops in the SPF calculation, and can be\n   included in the router-LSA originated\
    \ by the router.  The idea is\n   that if the SPF calculation has produced a route\
    \ to the neighbor,\n   then it makes sense to take a \"shortcut\" and forward\
    \ packets directly\n   to the neighbor.\n   The routability condition is a generalization\
    \ of the way that\n   neighbors on broadcast networks are treated in the SPF calculation.\n\
    \   The network-LSA of an OSPF broadcast network implies that a router\n   can\
    \ use a non-adjacent neighbor as a next hop.  But a network-LSA\n   cannot describe\
    \ the general topology of a MANET, making it necessary\n   to explicitly include\
    \ non-adjacent neighbors in the router-LSA.\n   Allowing only adjacent neighbors\
    \ in LSAs would either result in\n   suboptimal routes or require a large number\
    \ of adjacencies.\n"
- title: 2.5.  Partial and Full Topology LSAs
  contents:
  - "2.5.  Partial and Full Topology LSAs\n   OSPF-MDR allows routers to originate\
    \ both full-topology LSAs, which\n   advertise links to all routable and Full\
    \ neighbors, and partial-\n   topology LSAs, which advertise only a subset of\
    \ such links.  In a\n   dense network, partial-topology LSAs are typically much\
    \ smaller than\n   full-topology LSAs, thus achieving better scalability.\n  \
    \ Each router advertises a subset of its neighbors as point-to-point\n   links\
    \ in its router-LSA.  The choice of which neighbors to advertise\n   is flexible.\
    \  As a minimum requirement, each router must advertise a\n   minimum set of \"\
    backbone\" neighbors in its router-LSA.  An LSA that\n   includes only this minimum\
    \ set of neighbors is called a minimal LSA\n   and corresponds to LSAFullness\
    \ = 0.  This choice results in the\n   minimum amount of LSA flooding overhead,\
    \ but does not ensure routing\n   along shortest paths.  However, it is useful\
    \ for achieving\n   scalability to networks with a large number of nodes.\n  \
    \ At the other extreme, if LSAFullness = 4, then the router originates\n   a full-topology\
    \ LSA, which includes all routable and Full neighbors.\n   Setting LSAFullness\
    \ to 1 results in min-cost LSAs, which provide\n   routing along shortest (minimum-cost)\
    \ paths.  Each router decides\n   which neighbors to include in its router-LSA\
    \ based on 2-hop neighbor\n   information obtained from its neighbors' Hellos.\
    \  Each router\n   includes in its LSA the minimum set of neighbors necessary\
    \ to provide\n   a shortest path between each pair of its neighbors.\n   Setting\
    \ LSAFullness to 2 also provides shortest-path routing, but\n   allows the router\
    \ to advertise additional neighbors to provide\n   redundant routes.\n   Setting\
    \ LSAFullness to 3 results in MDR full LSAs, causing each MDR\n   to originate\
    \ a full-topology LSA while other routers originate\n   minimal LSAs.  This choice\
    \ does not provide routing along shortest\n   paths, but simulations have shown\
    \ that it provides routing along\n   nearly shortest paths with relatively low\
    \ overhead.\n   The above LSA options are interoperable with each other, because\
    \ they\n   all require the router-LSA to include a minimum set of neighbors, and\n\
    \   because the construction of the router-LSA (described in Section 9.4)\n  \
    \ ensures that the router-LSAs originated by different routers are\n   consistent.\
    \  Routing along shortest paths is provided if and only if\n   every router selects\
    \ LSAFullness to be 1, 2, or 4.\n"
- title: 2.6.  Hello Protocol
  contents:
  - "2.6.  Hello Protocol\n   OSPF-MDR uses the same Hello format as OSPFv3, but appends\
    \ additional\n   information to Hello packets using link-local signaling (LLS),\
    \ in\n   order to indicate the set of bidirectional neighbors and other\n   information\
    \ that is used by the MDR selection algorithm and the min-\n   cost LSA algorithm.\
    \  In addition to full Hellos, which include the\n   same set of neighbor IDs\
    \ as OSPFv3 Hellos, OSPF-MDR allows the use of\n   differential Hellos, which\
    \ include only the IDs of neighbors whose\n   state (or other information) has\
    \ recently changed (within the last\n   HelloRepeatCount Hellos).\n   Hellos are\
    \ sent every HelloInterval seconds.  Full Hellos are sent\n   every 2HopRefresh\
    \ Hellos, and differential Hellos are sent at all\n   other times.  For example,\
    \ if 2HopRefresh is equal to 3, then every\n   third Hello is a full Hello.  The\
    \ default value of 2HopRefresh is 1;\n   i.e., the default is to send only full\
    \ Hellos.  The default value for\n   HelloInterval is 2 seconds.  Differential\
    \ Hellos are used to reduce\n   overhead and to allow Hellos to be sent more frequently,\
    \ for faster\n   reaction to topology changes.\n"
- title: 3.  Interface and Neighbor Data Structures
  contents:
  - '3.  Interface and Neighbor Data Structures

    '
- title: 3.1.  Changes to Interface Data Structure
  contents:
  - "3.1.  Changes to Interface Data Structure\n   The following modified or new data\
    \ items are required for the\n   Interface Data Structure of a MANET interface:\n\
    \   Type\n      A router that implements this extension can have one or more\n\
    \      interfaces of type MANET, in addition to the OSPF interface types\n   \
    \   defined in [RFC2328].\n   State\n      The possible states for a MANET interface\
    \ are the same as for a\n      broadcast interface.  However, the DR and Backup\
    \ states now imply\n      that the router is an MDR or Backup MDR, respectively.\n\
    \   MDR Level\n      The MDR Level is equal to MDR (value 2) if the router is\
    \ an MDR,\n      Backup MDR (value 1) if the router is a Backup MDR, and MDR Other\n\
    \      (value 0) otherwise.  The MDR Level is used by the MDR selection\n    \
    \  algorithm.\n   Parent\n      The Parent replaces the Designated Router (DR)\
    \ data item of OSPF.\n      Each router selects a Parent as described in Section\
    \ 5.4.  The\n      Parent of an MDR is the router itself, and the Parent of a\
    \ non-MDR\n      router will be a neighboring MDR, if one exists.  The Parent\
    \ is\n      initialized to 0.0.0.0, indicating the lack of a Parent.  Each\n \
    \     router advertises the Router ID of its Parent in the DR field of\n     \
    \ each Hello sent on the interface.\n   Backup Parent\n      The Backup Parent\
    \ replaces the Backup Designated Router data item\n      of OSPF.  The Backup\
    \ Parent of a BMDR is the router itself.  If\n      the option of biconnected\
    \ adjacencies is chosen, then each MDR\n      Other selects a Backup Parent, which\
    \ will be a neighboring\n      MDR/BMDR if one exists that is not the Parent.\
    \  The Backup Parent\n      is initialized to 0.0.0.0, indicating the lack of\
    \ a Backup Parent.\n      Each router advertises the Router ID of its Backup Parent\
    \ in the\n      Backup DR field of each Hello sent on the interface.\n   Router\
    \ Priority\n      An 8-bit unsigned integer.  A router with a larger Router Priority\n\
    \      is more likely to be selected as an MDR.  The Router Priority for\n   \
    \   a MANET interface can be changed dynamically based on any\n      criteria,\
    \ including bandwidth capacity, willingness to be a relay\n      (which can depend\
    \ on battery life, for example), number of\n      neighbors (degree), and neighbor\
    \ stability.  A router that has\n      been a (Backup) MDR for a certain amount\
    \ of time can reduce its\n      Router Priority so that the burden of being a\
    \ (Backup) MDR can be\n      shared among all routers.  If the Router Priority\
    \ for a MANET\n      interface is changed, then the interface variable\n     \
    \ MDRNeighborChange must be set.\n   Hello Sequence Number (HSN)\n      The 16-bit\
    \ sequence number carried by the MDR-Hello TLV.  The HSN\n      is incremented\
    \ by 1 (modulo 2^16) every time a Hello packet is\n      sent on the interface.\n\
    \   MDRNeighborChange\n      A single-bit variable set to 1 if a neighbor change\
    \ has occurred\n      that requires the MDR selection algorithm to be executed.\n"
- title: 3.2.  New Configurable Interface Parameters
  contents:
  - "3.2.  New Configurable Interface Parameters\n   The following new configurable\
    \ interface parameters are required for\n   a MANET interface.  The default values\
    \ for HelloInterval,\n   RouterDeadInterval, and RxmtInterval for a MANET interface\
    \ are 2, 6,\n   and 7 seconds, respectively.\n   The default configuration for\
    \ OSPF-MDR uses uniconnected adjacencies\n   (AdjConnectivity = 1) and partial-topology\
    \ LSAs that provide\n   shortest-path routing (LSAFullness = 1).  This is the\
    \ most scalable\n   configuration that provides shortest-path routing.  Other\n\
    \   configurations may be preferable in special circumstances.  For\n   example,\
    \ setting LSAFullness to 4 provides full-topology LSAs, and\n   setting LSAFullness\
    \ to 0 provides minimal LSAs that minimize overhead\n   but do not ensure shortest-path\
    \ routing.  Setting AdjConnectivity to\n   2 may improve robustness by providing\
    \ a biconnected adjacency\n   subgraph, and setting AdjConnectivity to 0 results\
    \ in full-topology\n   adjacencies.\n   All possible configurations of the new\
    \ interface parameters are\n   functional, except that if AdjConnectivity is 0\
    \ (full-topology\n   adjacencies), then LSAFullness must be 1, 2, or 4 (see Section\
    \ 9.3).\n   Differential Hellos should be used to reduce the size of Hello\n \
    \  packets when the average number of neighbors is large (e.g., greater\n   than\
    \ 50).  Differential Hellos are obtained by setting the parameter\n   2HopRefresh\
    \ to an integer greater than 1, with the recommended value\n   being 3.  Good\
    \ performance in simulated mobile networks with up to\n   160 nodes has been obtained\
    \ using the default configuration with\n   differential Hellos.  Good performance\
    \ in simulated mobile networks\n   with up to 200 nodes has been obtained using\
    \ the same configuration\n   except with minimal LSAs (LSAFullness = 0).  Simulation\
    \ results are\n   presented in Appendix E.\n   Although all routers should preferably\
    \ choose the same values for the\n   new configurable interface parameters, this\
    \ is not required.  OSPF-\n   MDR was carefully designed so that correct interoperation\
    \ is achieved\n   even if each router sets these parameters independently of the\
    \ other\n   routers.\n   AdjConnectivity\n      If equal to the default value\
    \ of 1, then the set of adjacencies\n      forms a (uni)connected graph.  If equal\
    \ to the optional value of\n      2, then the set of adjacencies forms a biconnected\
    \ graph.  If\n      AdjConnectivity is 0, then adjacency reduction is not used;\
    \ i.e.,\n      the router becomes adjacent with all of its neighbors.\n   MDRConstraint\n\
    \      A parameter of the MDR selection algorithm, which affects the\n      number\
    \ of MDRs selected and must be an integer greater than or\n      equal to 2. \
    \ The default value of 3 results in nearly the minimum\n      number of MDRs.\
    \  Values larger than 3 result in slightly fewer\n      MDRs, and the value 2\
    \ results in a larger number of MDRs.\n   BackupWaitInterval\n      The number\
    \ of seconds that a Backup MDR must wait after receiving\n      a new LSA before\
    \ it decides whether to flood the LSA.  The default\n      value is 0.5 second.\n\
    \   AckInterval\n      The interval between Link State Acknowledgment packets\
    \ when only\n      delayed acknowledgments need to be sent.  AckInterval MUST\
    \ be less\n      than RxmtInterval, and SHOULD NOT be larger than 1 second.  The\n\
    \      default value is 1 second.\n   LSAFullness\n      Determines which neighbors\
    \ a router should advertise in its\n      router-LSA.  The value 0 results in\
    \ minimal LSAs that include only\n      \"backbone\" neighbors.  The values 1\
    \ and 2 result in partial-\n      topology LSAs that provide shortest-path routing,\
    \ with the value 2\n      providing redundant routes.  The value 3 results in\
    \ MDRs\n      originating full-topology LSAs and other routers originating\n \
    \     minimal LSAs.  The value 4 results in all routers originating\n      full-topology\
    \ LSAs.  The default value is 1.\n   2HopRefresh\n      One out of every 2HopRefresh\
    \ Hellos sent on the interface must be\n      a full Hello.  All other Hellos\
    \ are differential.  The default\n      value is 1; i.e., the default is to send\
    \ only full Hellos.  If\n      differential Hellos are used, the recommended value\
    \ of 2HopRefresh\n      is 3.\n   HelloRepeatCount\n      The number of consecutive\
    \ Hellos in which a neighbor must be\n      included when its state changes, if\
    \ differential Hellos are used.\n      This parameter must be set to 3.\n"
- title: 3.3.  Changes to Neighbor Data Structure
  contents:
  - "3.3.  Changes to Neighbor Data Structure\n   The neighbor states are the same\
    \ as for OSPF.  However, the data for\n   a MANET neighbor that has transitioned\
    \ to the Down state must be\n   maintained for at least HelloInterval * HelloRepeatCount\
    \ seconds, to\n   allow the state change to be reported in differential Hellos.\
    \  The\n   following new data items are required for the Neighbor Data Structure\n\
    \   of a neighbor on a MANET interface.\n   Neighbor Hello Sequence Number (NHSN)\n\
    \      The Hello sequence number contained in the last Hello received\n      from\
    \ the neighbor.\n   A-bit\n      The A-bit copied from the MDR-Hello TLV of the\
    \ last Hello received\n      from the neighbor.  This bit is 1 if the neighbor\
    \ is using full-\n      topology adjacencies, i.e., is not using adjacency reduction.\n\
    \   FullHelloRcvd\n      A single-bit variable equal to 1 if a full Hello has\
    \ been received\n      from the neighbor.\n   Neighbor's MDR Level\n      The\
    \ MDR Level of the neighbor, based on the DR and Backup DR\n      fields of the\
    \ last Hello packet received from the neighbor or from\n      the MDR-DD TLV in\
    \ a Database Description (DD) packet received from\n      the neighbor.\n   Neighbor's\
    \ Parent\n      The neighbor's choice for Parent, obtained from the DR field of\n\
    \      the last Hello packet received from the neighbor or from the MDR-\n   \
    \   DD TLV in a DD packet received from the neighbor.\n   Neighbor's Backup Parent\n\
    \      The neighbor's choice for Backup Parent, obtained from the Backup\n   \
    \   DR field of the last Hello packet received from the neighbor or\n      from\
    \ the MDR-DD TLV in a DD packet received from the neighbor.\n   Child\n      A\
    \ single-bit variable equal to 1 if the neighbor is a child, i.e.,\n      if the\
    \ neighbor has selected the router as a (Backup) Parent.\n   Dependent Neighbor\n\
    \      A single-bit variable equal to 1 if the neighbor is a Dependent\n     \
    \ Neighbor, which is decided by the MDR selection algorithm.  Each\n      MDR/BMDR\
    \ router becomes adjacent with its Dependent Neighbors\n      (which are also\
    \ MDR/BMDR routers) to form a connected backbone.\n      The set of all Dependent\
    \ Neighbors on a MANET interface is called\n      the Dependent Neighbor Set (DNS)\
    \ for the interface.\n   Dependent Selector\n      A single-bit variable equal\
    \ to 1 if the neighbor has selected the\n      router to be dependent.\n   Selected\
    \ Advertised Neighbor (SAN)\n      A single-bit variable equal to 1 if the neighbor\
    \ is a Selected\n      Advertised Neighbor.  Selected Advertised Neighbors are\
    \ neighbors\n      that the router has selected to be included in the router-LSA,\n\
    \      along with other neighbors that are required to be included.  The\n   \
    \   set of all Selected Advertised Neighbors on a MANET interface is\n      called\
    \ the Selected Advertised Neighbor Set (SANS) for the\n      interface.\n   Routable\n\
    \      A single-bit variable equal to 1 if the neighbor is routable.\n   Neighbor's\
    \ Bidirectional Neighbor Set (BNS)\n      The neighbor's set of bidirectional\
    \ neighbors, which is updated\n      when a Hello is received from the neighbor.\n\
    \   Neighbor's Dependent Neighbor Set (DNS)\n      The neighbor's set of Dependent\
    \ Neighbors, which is updated when a\n      Hello is received from the neighbor.\n\
    \   Neighbor's Selected Advertised Neighbor Set (SANS)\n      The neighbor's set\
    \ of Selected Advertised Neighbors, which is\n      updated when a Hello is received\
    \ from the neighbor.\n   Neighbor's Link Metrics\n      The link metric for each\
    \ of the neighbor's bidirectional\n      neighbors, obtained from the Metric TLV\
    \ appended to Hello packets.\n"
- title: 4.  Hello Protocol
  contents:
  - "4.  Hello Protocol\n   The MANET interface utilizes Hellos for neighbor discovery\
    \ and for\n   enabling neighbors to learn 2-hop neighbor information.  The protocol\n\
    \   is flexible because it allows the use of full or differential Hellos.\n  \
    \ Full Hellos list all neighbors on the interface that are in state\n   Init or\
    \ greater, as in OSPFv3, whereas differential Hellos list only\n   neighbors whose\
    \ status as a bidirectional neighbor, Dependent\n   Neighbor, or Selected Advertised\
    \ Neighbor has recently changed.\n   Differential Hellos are used to reduce overhead,\
    \ and they allow\n   Hellos to be sent more frequently (for faster reaction to\
    \ topology\n   changes).  If differential Hellos are used, full Hellos are sent\
    \ less\n   frequently to ensure that all neighbors have current 2-hop neighbor\n\
    \   information.\n"
- title: 4.1.  Sending Hello Packets
  contents:
  - "4.1.  Sending Hello Packets\n   Hello packets are sent according to [RFC5340],\
    \ Section 4.2.1.1, and\n   [RFC2328], Section 9.5, with the following MANET-specific\n\
    \   specifications beginning after paragraph 3 of Section 9.5.  The Hello\n  \
    \ packet format is defined in [RFC5340], Section A.3.2, except for the\n   ordering\
    \ of the Neighbor IDs and the meaning of the DR and Backup DR\n   fields as described\
    \ below.\n   Similar to [RFC2328], the DR and Backup DR fields indicate whether\n\
    \   the router is an MDR or Backup MDR.  If the router is an MDR, then\n   the\
    \ DR field is the router's own Router ID, and if the router is a\n   Backup MDR,\
    \ then the Backup DR field is the router's own Router ID.\n   These fields are\
    \ also used to advertise the router's Parent and\n   Backup Parent, as specified\
    \ in Section A.3 and Section 5.4.\n   Hellos are sent every HelloInterval seconds.\
    \  Full Hellos are sent\n   every 2HopRefresh Hellos, and differential Hellos\
    \ are sent at all\n   other times.  For example, if 2HopRefresh is equal to 3,\
    \ then every\n   third Hello is a full Hello.  If 2HopRefresh is set to 1, then\
    \ all\n   Hellos are full (the default).\n   The neighbor IDs included in the\
    \ body of each Hello are divided into\n   the following five disjoint lists of\
    \ neighbors (some of which may be\n   empty), and must appear in the following\
    \ order:\n   List 1. Neighbors whose state recently changed to Down (included\
    \ only\n           in differential Hellos).\n   List 2. Neighbors in state Init.\n\
    \   List 3. Dependent Neighbors.\n   List 4. Selected Advertised Neighbors.\n\
    \   List 5. Unselected bidirectional neighbors, defined as bidirectional\n   \
    \        neighbors that are neither Dependent nor Selected Advertised\n      \
    \     Neighbors.\n   Note that all neighbors in Lists 3 through 5 are bidirectional\n\
    \   neighbors.  These lists are used to update the neighbor's\n   Bidirectional\
    \ Neighbor Set (BNS), Dependent Neighbor Set (DNS), and\n   Selected Advertised\
    \ Neighbor Set (SANS) when a Hello is received.\n   Note that the above five lists\
    \ are disjoint, so each neighbor can\n   appear in at most one list.  Also note\
    \ that some or all of the five\n   lists can be empty.\n   Link-local signaling\
    \ (LLS) is used to append up to two TLVs to each\n   MANET Hello packet.  The\
    \ format for LLS is given in Section A.2.  The\n   MDR-Hello TLV is appended to\
    \ each (full or differential) MANET Hello\n   packet.  It indicates whether the\
    \ Hello is full or differential, and\n   gives the Hello Sequence Number (HSN)\
    \ and the number of neighbor IDs\n   in each of Lists 1 through 4 defined above.\
    \  The size of List 5 is\n   then implied by the packet length field of the Hello.\
    \  The format of\n   the MDR-Hello TLV is given in Section A.2.3.\n   In both\
    \ full and differential Hellos, the appended MDR-Hello TLV is\n   built as follows.\n\
    \   o  The Sequence Number field is set to the current HSN for the\n      interface;\
    \ the HSN is then incremented (modulo 2^16).\n   o  The D-bit of the MDR-Hello\
    \ TLV is set to 1 for a differential\n      Hello and 0 for a full Hello.\n  \
    \ o  The A-bit of the MDR-Hello TLV is set to 1 if AdjConnectivity is 0\n    \
    \  (the router is using full-topology adjacencies); otherwise, it is\n      set\
    \ to 0.\n   o  The N1, N2, N3, and N4 fields are set to the number of neighbor\n\
    \      IDs in the body of the Hello that are in List 1, List 2, List 3,\n    \
    \  and List 4, respectively.  (N1 is always zero in a full Hello.)\n   The MDR-Metric\
    \ TLV (or Metric TLV) advertises the link cost to each\n   bidirectional neighbor\
    \ on the interface, to allow the selection of\n   neighbors to include in partial-topology\
    \ LSAs.  If LSAFullness is 1\n   or 2, a Metric TLV must be appended to each MANET\
    \ Hello packet unless\n   all link costs are 1.  The format of the Metric TLV\
    \ is given in\n   Section A.2.5.  The I bit of the Metric TLV can be set to 0\
    \ or 1.  If\n   the I bit is set to 0, then the Metric TLV does not contain neighbor\n\
    \   IDs, and contains the metric for each bidirectional neighbor listed\n   in\
    \ the (full or differential) Hello, in the same order.  If the I bit\n   is set\
    \ to 1, then the Metric TLV includes the neighbor ID and metric\n   for each bidirectional\
    \ neighbor listed in the Hello whose metric is\n   not equal to the Default Metric\
    \ field of the TLV.\n   The I bit should be chosen to minimize the size of the\
    \ Metric TLV.\n   This can be achieved by choosing the I bit to be 1 if and only\
    \ if the\n   number of bidirectional neighbors listed in the Hello whose metric\n\
    \   differs from the Default Metric field is less than 1/3 of the total\n   number\
    \ of bidirectional neighbors listed in the Hello.\n   For example, if all neighbors\
    \ have the same metric, then the I bit\n   should be set to 1, with the Default\
    \ Metric equal to this metric,\n   avoiding the need to include neighbor IDs and\
    \ corresponding metrics\n   in the TLV.  At the other extreme, if all neighbors\
    \ have different\n   metrics, then the I bit should be set to 0 to avoid listing\
    \ the same\n   neighbor IDs in both the body of the Hello and the Metric TLV.\n\
    \   In both full and differential Hello packets, the L bit is set in the\n   Hello's\
    \ option field to indicate LLS.\n"
- title: 4.1.1.  Full Hello Packet
  contents:
  - "4.1.1.  Full Hello Packet\n   In a full Hello, the neighbor ID list includes\
    \ all neighbors on the\n   interface that are in state Init or greater, in the\
    \ order described\n   above.  The MDR-Hello TLV is built as described above. \
    \ If a Metric\n   TLV is appended, it is built as specified in Section A.2.5.\n"
- title: 4.1.2.  Differential Hello Packet
  contents:
  - "4.1.2.  Differential Hello Packet\n   In a differential Hello, the five neighbor\
    \ ID lists defined in\n   Section 4.1 are populated as follows:\n   List 1 includes\
    \ each neighbor in state Down that has not yet been\n   included in HelloRepeatCount\
    \ Hellos since transitioning to this\n   state.\n   List 2 includes each neighbor\
    \ in state Init that has not yet been\n   included in HelloRepeatCount Hellos\
    \ since transitioning to this\n   state.\n   List 3 includes each Dependent Neighbor\
    \ that has not yet been\n   included in HelloRepeatCount Hellos since becoming\
    \ a Dependent\n   Neighbor.\n   List 4 includes each Selected Advertised Neighbor\
    \ that has not yet\n   been included in HelloRepeatCount Hellos since becoming\
    \ a Selected\n   Advertised Neighbor.\n   List 5 includes each unselected bidirectional\
    \ neighbor (defined in\n   Section 4.1) that has not yet been included in HelloRepeatCount\n\
    \   Hellos since becoming an unselected bidirectional neighbor.\n   In addition,\
    \ a bidirectional neighbor must be included (in the\n   appropriate list) if the\
    \ neighbor's BNS does not include the router\n   (indicating that the neighbor\
    \ does not consider the router to be\n   bidirectional).\n   If a Metric TLV is\
    \ appended to the Hello, then a bidirectional\n   neighbor must be included (in\
    \ the appropriate list) if it has not yet\n   been included in HelloRepeatCount\
    \ Hellos since its metric last\n   changed.\n"
- title: 4.2.  Receiving Hello Packets
  contents:
  - "4.2.  Receiving Hello Packets\n   A Hello packet received on a MANET interface\
    \ is processed as\n   described in [RFC5340], Section 4.2.2.1, and the first two\
    \ paragraphs\n   of [RFC2328], Section 10.5, followed by the processing specified\n\
    \   below.\n   The source of a received Hello packet is identified by the Router\
    \ ID\n   found in the Hello's OSPF packet header.  If a matching neighbor\n  \
    \ cannot be found in the interface's data structure, one is created\n   with the\
    \ Neighbor ID set to the Router ID found in the OSPF packet\n   header, the state\
    \ initialized to Down, all MANET-specific neighbor\n   variables (specified in\
    \ Section 3.3) initialized to zero, and the\n   neighbor's DNS, SANS, and BNS\
    \ initialized to empty sets.\n   The neighbor structure's Router Priority is set\
    \ to the value of the\n   corresponding field in the received Hello packet.  The\
    \ Neighbor's\n   Parent is set to the value of the DR field, and the Neighbor's\
    \ Backup\n   Parent is set to the value of the Backup DR field.\n   Now the rest\
    \ of the Hello Packet is examined, generating events to be\n   given to the neighbor\
    \ and interface state machines.  These state\n   machines are specified to be\
    \ either executed or scheduled (see\n   [RFC2328], Section 4.4, \"Tasking support\"\
    ).  For example, by\n   specifying below that the neighbor state machine be executed\
    \ in line,\n   several neighbor state transitions may be affected by a single\n\
    \   received Hello.\n   o  If the L bit in the options field is not set, then\
    \ an error has\n      occurred and the Hello is discarded.\n   o  If the LLS contains\
    \ an MDR-Hello TLV, the neighbor state machine\n      is executed with the event\
    \ HelloReceived.  Otherwise, an error has\n      occurred and the Hello is discarded.\n\
    \   o  The Hello Sequence Number and the A-bit in the MDR-Hello TLV are\n    \
    \  copied to the neighbor's data structure.\n   o  The DR and Backup DR fields\
    \ are processed as follows.\n      (1) If the DR field is equal to the neighbor's\
    \ Router ID, set the\n          neighbor's MDR Level to MDR.\n      (2) Else if\
    \ the Backup DR field is equal to the neighbor's Router\n          ID, set the\
    \ neighbor's MDR Level to Backup MDR.\n      (3) Else, set the neighbor's MDR\
    \ Level to MDR Other and set the\n          neighbor's Dependent Neighbor variable\
    \ to 0.  (Only MDR/BMDR\n          neighbors can be Dependent.)\n      (4) If\
    \ the DR or Backup DR field is equal to the router's own\n          Router ID,\
    \ set the neighbor's Child variable to 1; otherwise,\n          set it to 0.\n\
    \   The neighbor ID list of the Hello is divided as follows into the five\n  \
    \ lists defined in Section 4.1, where N1, N2, N3, and N4 are obtained\n   from\
    \ the corresponding fields of the MDR-Hello TLV.  List 1 is\n   defined to be\
    \ the first N1 neighbor IDs, List 2 is defined to be the\n   next N2 neighbor\
    \ IDs, List 3 is defined to be the next N3 neighbor\n   IDs, List 4 is defined\
    \ to be the next N4 neighbor IDs, and List 5 is\n   defined to be the remaining\
    \ neighbor IDs in the Hello.\n   Further processing of the Hello depends on whether\
    \ it is full or\n   differential, which is indicated by the value of the D-bit\
    \ of the\n   MDR-Hello TLV.\n"
- title: 4.2.1.  Full Hello Packet
  contents:
  - "4.2.1.  Full Hello Packet\n   If the received Hello is full (the D-bit of the\
    \ MDR-Hello TLV is 0),\n   the following steps are performed:\n   o  If the N1\
    \ field of the MDR-Hello TLV is not zero, then an error\n      has occurred and\
    \ the Hello is discarded.  Otherwise, set\n      FullHelloRcvd to 1.\n   o  In\
    \ the neighbor structure, modify the neighbor's DNS to equal the\n      set of\
    \ neighbor IDs in the Hello's List 3, modify the neighbor's\n      SANS to equal\
    \ the set of neighbor IDs in the Hello's List 4, and\n      modify the neighbor's\
    \ BNS to equal the set of neighbor IDs in the\n      union of Lists 3, 4, and\
    \ 5.\n   o  If the router itself appears in the Hello's neighbor ID list, the\n\
    \      neighbor state machine is executed with the event 2-WayReceived\n     \
    \ after the Hello is processed.  Otherwise, the neighbor state\n      machine\
    \ is executed with the event 1-WayReceived after the Hello\n      is processed.\n"
- title: 4.2.2.  Differential Hello Packet
  contents:
  - "4.2.2.  Differential Hello Packet\n   If the received Hello is differential (the\
    \ D-bit of the MDR-Hello TLV\n   is 1), the following steps are performed:\n \
    \  (1) For each neighbor ID in List 1 or List 2 of the Hello:\n       o  Remove\
    \ the neighbor ID from the neighbor's DNS, SANS, and BNS,\n          if it belongs\
    \ to the neighbor set.\n   (2) For each neighbor ID in List 3 of the Hello:\n\
    \       o  Add the neighbor ID to the neighbor's DNS and BNS, if it does\n   \
    \       not belong to the neighbor set.\n       o  Remove the neighbor ID from\
    \ the neighbor's SANS, if it belongs\n          to the neighbor set.\n   (3) For\
    \ each neighbor ID in List 4 of the Hello:\n       o  Add the neighbor ID to the\
    \ neighbor's SANS and BNS, if it does\n          not belong to the neighbor set.\n\
    \       o  Remove the neighbor ID from the neighbor's DNS, if it belongs\n   \
    \       to the neighbor set.\n   (4) For each neighbor ID in List 5 of the Hello:\n\
    \       o  Add the neighbor ID to the neighbor's BNS, if it does not\n       \
    \   belong to the neighbor set.\n       o  Remove the neighbor ID from the neighbor's\
    \ DNS and SANS, if it\n          belongs to the neighbor set.\n   (5) If the router's\
    \ own RID appears in List 1, execute the neighbor\n       state machine with the\
    \ event 1-WayReceived after the Hello is\n       processed.\n   (6) If the router's\
    \ own RID appears in List 2, 3, 4, or 5, execute\n       the neighbor state machine\
    \ with the event 2-WayReceived after the\n       Hello is processed.\n   (7) If\
    \ the router's own RID does not appear in the Hello's neighbor\n       ID list,\
    \ and the neighbor state is 2-Way or greater, and the\n       Hello Sequence Number\
    \ is less than or equal to the previous\n       sequence number plus HelloRepeatCount,\
    \ then the neighbor state\n       machine is executed with the event 2-WayReceived\
    \ after the Hello\n       is processed (the state does not change).\n   (8) If\
    \ 2-WayReceived is not executed, then 1-WayReceived is executed\n       after\
    \ the Hello is processed.\n"
- title: 4.2.3.  Additional Processing for Both Hello Types
  contents:
  - "4.2.3.  Additional Processing for Both Hello Types\n   The following applies\
    \ to both full and differential Hellos.\n   If the router itself belongs to the\
    \ neighbor's DNS, the neighbor's\n   Dependent Selector variable is set to 1;\
    \ otherwise, it is set to 0.\n   The receiving interface's MDRNeighborChange variable\
    \ is set to 1 if\n   any of the following changes occurred as a result of processing\
    \ the\n   Hello:\n   o  The neighbor's state changed from less than 2-Way to 2-Way\
    \ or\n      greater, or vice versa.\n   o  The neighbor is bidirectional and any\
    \ of the following neighbor\n      variables has changed: MDR Level, Router Priority,\
    \ FullHelloRcvd,\n      and Bidirectional Neighbor Set (BNS).\n   The neighbor\
    \ state machine is scheduled with the event AdjOK?  if any\n   of the following\
    \ changes occurred as a result of processing the\n   Hello:\n   o  The neighbor's\
    \ state changed from less than 2-Way to 2-Way or\n      greater.\n   o  The neighbor\
    \ is bidirectional and its MDR Level has changed, or\n      its Child variable\
    \ or Dependent Selector variable has changed from\n      0 to 1.\n   If the LLS\
    \ contains a Metric TLV, it is processed by updating the\n   neighbor's link metrics\
    \ according to the format of the Metric TLV\n   specified in Section A.2.5.  If\
    \ the LLS does not contain a Metric TLV\n   and LSAFullness is 1 or 2, the metric\
    \ for each of the neighbor's\n   links is set to 1.\n"
- title: 4.3.  Neighbor Acceptance Condition
  contents:
  - "4.3.  Neighbor Acceptance Condition\n   In wireless networks, a single Hello\
    \ can be received from a neighbor\n   with which a poor connection exists, e.g.,\
    \ because the neighbor is\n   almost out of range.  To avoid accepting poor-quality\
    \ neighbors, and\n   to employ hysteresis, a router may require that a stricter\
    \ condition\n   be satisfied before changing the state of a MANET neighbor from\
    \ Down\n   to Init or greater.  This condition is called the \"neighbor\n   acceptance\
    \ condition\", which by default is the reception of a single\n   Hello or DD packet.\
    \  For example, the neighbor acceptance condition\n   may require that 2 consecutive\
    \ Hellos be received from a neighbor\n   before changing the neighbor's state\
    \ from Down to Init.  Other\n   possible conditions include the reception of 3\
    \ consecutive Hellos, or\n   the reception of 2 of the last 3 Hellos.  The neighbor\
    \ acceptance\n   condition may also impose thresholds on other measurements such\
    \ as\n   received signal strength.\n   The neighbor state transition for state\
    \ Down and event HelloReceived\n   is thus modified (see Section 7.1) to depend\
    \ on the neighbor\n   acceptance condition.\n"
- title: 5.  MDR Selection Algorithm
  contents:
  - "5.  MDR Selection Algorithm\n   This section describes the MDR selection algorithm,\
    \ which is run for\n   each MANET interface to determine whether the router is\
    \ an MDR,\n   Backup MDR, or MDR Other for that interface.  The algorithm also\n\
    \   selects the Dependent Neighbors and the (Backup) Parent, which are\n   used\
    \ to decide which neighbors should become adjacent (see Section\n   7.2).\n  \
    \ The MDR selection algorithm must be executed just before sending a\n   Hello\
    \ if the MDRNeighborChange bit is set for the interface.  The\n   algorithm SHOULD\
    \ also be executed whenever a bidirectional neighbor\n   transitions to less than\
    \ 2-Way, and MAY be executed at other times\n   when the MDRNeighborChange bit\
    \ is set.  The bit is cleared after the\n   algorithm is executed.\n   To simplify\
    \ the implementation, the MDR selection algorithm MAY be\n   executed periodically\
    \ just before sending each Hello, to avoid having\n   to determine when the MDRNeighborChange\
    \ bit should be set.  After\n   running the MDR selection algorithm, the AdjOK?\
    \ event may be invoked\n   for some or all neighbors as specified in Section 7.\n\
    \   The purpose of the MDRs is to provide a minimal set of relays for\n   flooding\
    \ LSAs, and the purpose of the Backup MDRs is to provide\n   backup relays to\
    \ flood LSAs when flooding by MDRs does not succeed.\n   The set of MDRs forms\
    \ a CDS, and the set of MDRs and Backup MDRs\n   forms a biconnected CDS (if the\
    \ network itself is biconnected).\n   Each MDR selects and becomes adjacent with\
    \ a subset of its MDR\n   neighbors, called Dependent Neighbors, forming a connected\
    \ backbone.\n   Each non-MDR router connects to this backbone by selecting and\n\
    \   becoming adjacent with an MDR neighbor called its Parent.  Each MDR\n   selects\
    \ itself as Parent, to inform neighbors that it is an MDR.\n   If AdjConnectivity\
    \ = 2, then each (Backup) MDR selects and becomes\n   adjacent with additional\
    \ (Backup) MDR neighbors to form a biconnected\n   backbone, and each MDR Other\
    \ selects and becomes adjacent with a\n   second (Backup) MDR neighbor called\
    \ its Backup Parent, thus becoming\n   connected to the backbone via two adjacencies.\
    \  Each BMDR selects\n   itself as Backup Parent, to inform neighbors that it\
    \ is a BMDR.\n   The MDR selection algorithm is a distributed CDS algorithm that\
    \ uses\n   2-hop neighbor information obtained from Hellos.  More specifically,\n\
    \   it uses as inputs the set of bidirectional neighbors (in state 2-Way\n   or\
    \ greater), the triplet (Router Priority, MDR Level, Router ID) for\n   each such\
    \ neighbor and for the router itself, and the neighbor\n   variables Bidirectional\
    \ Neighbor Set (BNS) and FullHelloRcvd for each\n   such neighbor.  The MDR selection\
    \ algorithm can be implemented in\n   O(d^2) time, where d is the number of neighbors.\n\
    \   The above triplet will be abbreviated as (RtrPri, MDR Level, RID).\n   The\
    \ triplet (RtrPri, MDR Level, RID) is said to be larger for Router\n   A than\
    \ for Router B if the triplet for Router A is lexicographically\n   greater than\
    \ the triplet for Router B.  Routers that have larger\n   values of this triplet\
    \ are preferred for selection as an MDR.  The\n   algorithm therefore prefers\
    \ routers that are already MDRs, resulting\n   in a longer average MDR lifetime.\n\
    \   The MDR selection algorithm consists of five phases, the last of\n   which\
    \ is optional.  Phase 1 creates the neighbor connectivity matrix\n   for the interface,\
    \ which determines which pairs of neighbors are\n   neighbors of each other. \
    \ Phase 2 decides whether the calculating\n   router is an MDR, and which MDR\
    \ neighbors are Dependent.  Phase 3\n   decides whether the calculating router\
    \ is a Backup MDR and, if\n   AdjConnectivity = 2, which additional MDR/BMDR neighbors\
    \ are\n   Dependent.  Phase 4 selects the Parent and Backup Parent.\n   The algorithm\
    \ simplifies considerably if AdjConnectivity is 0 (full-\n   topology adjacencies).\
    \  In this case, the set of Dependent Neighbors\n   is empty and MDR Other routers\
    \ need not select Parents.  Also, Phase\n   3 (BMDR selection) is not required\
    \ if AdjConnectivity is 0 or 1.\n   However, Phase 3 MUST be executed if AdjConnectivity\
    \ is 2, and SHOULD\n   be executed if AdjConnectivity is 0 or 1, since BMDRs improve\n\
    \   robustness by providing backup flooding.\n   A router that has selected itself\
    \ as an MDR in Phase 2 MAY execute\n   Phase 5 to possibly declare itself a non-flooding\
    \ MDR.  A non-\n   flooding MDR is the same as a flooding MDR except that it does\
    \ not\n   automatically flood received LSAs back out the receiving interface,\n\
    \   because it has determined that neighboring MDRs are sufficient to\n   flood\
    \ the LSA to all neighbors.  Instead, a non-flooding MDR performs\n   backup flooding\
    \ just like a BMDR.  A non-flooding MDR maintains its\n   MDR level (rather than\
    \ being demoted to a BMDR) in order to maximize\n   the stability of adjacencies.\
    \  (The decision to form an adjacency\n   does not depend on whether an MDR is\
    \ non-flooding.)  By having MDRs\n   declare themselves to be non-flooding when\
    \ possible, flooding\n   overhead is reduced.  The resulting reduction in flooding\
    \ overhead\n   can be dramatic for certain regular topologies, but has been found\
    \ to\n   be less than 15% for random topologies.\n   The following subsections\
    \ describe the MDR selection algorithm, which\n   is applied independently to\
    \ each MANET interface.  For convenience,\n   the term \"bi-neighbor\" will be\
    \ used as an abbreviation for\n   \"bidirectional neighbor\".\n"
- title: '5.1.  Phase 1: Creating the Neighbor Connectivity Matrix'
  contents:
  - "5.1.  Phase 1: Creating the Neighbor Connectivity Matrix\n   Phase 1 creates\
    \ the neighbor connectivity matrix (NCM) for the\n   interface.  The NCM is a\
    \ symmetric matrix that defines a topology\n   graph for the set of bi-neighbors\
    \ on the interface.  The NCM assigns\n   a value of 0 or 1 for each pair of bi-neighbors;\
    \ a value of 1\n   indicates that the neighbors are assumed to be bi-neighbors\
    \ of each\n   other in the MDR selection algorithm.  Letting i denote the router\n\
    \   itself, NCM(i,j) and NCM(j,i) are set to 1 for each bi-neighbor j.\n   The\
    \ value of the matrix is set as follows for each pair of bi-\n   neighbors j and\
    \ k on the interface.\n   (1.1) If FullHelloRcvd is 1 for both neighbors j and\
    \ k: NCM(j,k) =\n         NCM(k,j) is 1 only if j belongs to the BNS of neighbor\
    \ k and k\n         belongs to the BNS of neighbor j.\n   (1.2) If FullHelloRcvd\
    \ is 1 for neighbor j and is 0 for neighbor k:\n         NCM(j,k) = NCM(k,j) is\
    \ 1 only if k belongs to the BNS of\n         neighbor j.\n   (1.3) If FullHelloRcvd\
    \ is 0 for both neighbors j and k: NCM(j,k) =\n         NCM(k,j) = 0.\n   In Step\
    \ 1.1 above, two neighbors are considered to be bi-neighbors of\n   each other\
    \ only if they both agree that the other router is a bi-\n   neighbor.  This provides\
    \ faster response to the failure of a link\n   between two neighbors, since it\
    \ is likely that one router will detect\n   the failure before the other router.\
    \  In Step 1.2 above, only\n   neighbor j has reported its full BNS, so neighbor\
    \ j is believed in\n   deciding whether j and k are bi-neighbors of each other.\
    \  As Step 1.3\n   indicates, two neighbors are assumed not to be bi-neighbors\
    \ of each\n   other if neither neighbor has reported its full BNS.\n"
- title: '5.2.  Phase 2: MDR Selection'
  contents:
  - "5.2.  Phase 2: MDR Selection\n   Phase 2 depends on the parameter MDRConstraint,\
    \ which affects the\n   number of MDRs selected.  The default value of 3 results\
    \ in nearly\n   the minimum number of MDRs, while the value 2 results in a larger\n\
    \   number of MDRs.  If AdjConnectivity = 0 (full-topology adjacencies),\n   then\
    \ the following steps are modified in that Dependent Neighbors are\n   not selected.\n\
    \   (2.1) The set of Dependent Neighbors is initialized to be empty.\n   (2.2)\
    \ If the router has a larger value of (RtrPri, MDR Level, RID)\n         than\
    \ all of its bi-neighbors, the router selects itself as an\n         MDR; selects\
    \ all of its MDR bi-neighbors as Dependent\n         Neighbors; if AdjConnectivity\
    \ = 2, selects all of its BMDR bi-\n         neighbors as Dependent Neighbors;\
    \ then proceeds to Phase 4.\n   (2.3) Let Rmax be the bi-neighbor with the largest\
    \ value of (RtrPri,\n         MDR Level, RID).\n   (2.4) Using NCM to determine\
    \ the connectivity of bi-neighbors,\n         compute the minimum number of hops,\
    \ denoted hops(u), from Rmax\n         to each other bi-neighbor u, using only\
    \ intermediate nodes that\n         are bi-neighbors with a larger value of (RtrPri,\
    \ MDR Level,\n         RID) than the router itself.  If no such path from Rmax\
    \ to u\n         exists, then hops(u) equals infinity. (See Appendix B for a\n\
    \         detailed algorithm using breadth-first search.)\n   (2.5) If hops(u)\
    \ is at most MDRConstraint for each bi-neighbor u, the\n         router selects\
    \ no Dependent Neighbors, and sets its MDR Level\n         as follows: If the\
    \ MDR Level is currently MDR, then it is\n         changed to BMDR if Phase 3\
    \ will be executed and to MDR Other if\n         Phase 3 will not be executed.\
    \  Otherwise, the MDR Level is not\n         changed.\n   (2.6) Else, the router\
    \ sets its MDR Level to MDR and selects the\n         following neighbors as Dependent\
    \ Neighbors: Rmax if it is an\n         MDR or BMDR; each MDR bi-neighbor u such\
    \ that hops(u) is\n         greater than MDRConstraint; and if AdjConnectivity\
    \ = 2, each\n         BMDR bi-neighbor u such that hops(u) is greater than\n \
    \        MDRConstraint.\n   (2.7) If steps 2.1 through 2.6 resulted in the MDR\
    \ Level changing to\n         BMDR, or to MDR with AdjConnectivity equal to 1\
    \ or 2, then\n         execute steps 2.1 through 2.6 again.  (This is necessary\n\
    \         because the change in MDR Level can cause the set of Dependent\n   \
    \      Neighbors and the BFS tree to change.)  This step is not\n         required\
    \ if the MDR selection algorithm is executed\n         periodically.\n   Step\
    \ 2.4 can be implemented using a breadth-first search (BFS)\n   algorithm to compute\
    \ min-hop paths from Rmax to all other bi-\n   neighbors, modified to allow a\
    \ bi-neighbor to be an intermediate node\n   only if its value of (RtrPri, MDR\
    \ Level, RID) is larger than that of\n   the router itself.  A detailed description\
    \ of this algorithm, which\n   runs in O(d^2) time, is given in Appendix B.\n"
- title: '5.3.  Phase 3: Backup MDR Selection'
  contents:
  - "5.3.  Phase 3: Backup MDR Selection\n   (3.1) If the MDR Level is MDR (after\
    \ running Phase 2) and\n         AdjConnectivity is not 2, then proceed to Phase\
    \ 4.  (If the MDR\n         Level is MDR and AdjConnectivity = 2, then Phase 3\
    \ may select\n         additional Dependent Neighbors to create a biconnected\n\
    \         backbone.)\n   (3.2) Using NCM to determine the connectivity of bi-neighbors,\n\
    \         determine whether or not there exist two node-disjoint paths\n     \
    \    from Rmax to each other bi-neighbor u, using only intermediate\n        \
    \ nodes that are bi-neighbors with a larger value of (RtrPri, MDR\n         Level,\
    \ RID) than the router itself.  (See Appendix B for a\n         detailed algorithm.)\n\
    \   (3.3) If there exist two such node-disjoint paths from Rmax to each\n    \
    \     other bi-neighbor u, then the router selects no additional\n         Dependent\
    \ Neighbors and sets its MDR Level to MDR Other.\n   (3.4) Else, the router sets\
    \ its MDR Level to Backup MDR unless it\n         already selected itself as an\
    \ MDR in Phase 2, and if\n         AdjConnectivity = 2, adds each of the following\
    \ neighbors to\n         the set of Dependent Neighbors: Rmax if it is an MDR\
    \ or BMDR,\n         and each MDR/BMDR bi-neighbor u such that Step 3.2 did not\
    \ find\n         two node-disjoint paths from Rmax to u.\n   (3.5) If steps 3.1\
    \ through 3.4 resulted in the MDR Level changing\n         from MDR Other to BMDR,\
    \ then run Phases 2 and 3 again.  (This\n         is necessary because running\
    \ Phase 2 again can cause the MDR\n         Level to change to MDR.)  This step\
    \ is not required if the MDR\n         selection algorithm is executed periodically.\n\
    \   Step 3.2 can be implemented in O(d^2) time using the algorithm given\n   in\
    \ Appendix B.  A simplified version of the algorithm is also\n   specified, which\
    \ results in a larger number of BMDRs.\n"
- title: '5.4.  Phase 4: Parent Selection'
  contents:
  - "5.4.  Phase 4: Parent Selection\n   Each router selects a Parent for each MANET\
    \ interface.  The Parent of\n   a non-MDR router will be a neighboring MDR if\
    \ one exists.  If the\n   option of biconnected adjacencies is chosen, then each\
    \ MDR Other\n   selects a Backup Parent, which will be a neighboring MDR/BMDR\
    \ if one\n   exists that is not the Parent.  The Parent of an MDR is always the\n\
    \   router itself, and the Backup Parent of a BMDR is always the router\n   itself.\n\
    \   The (Backup) Parent is advertised in the (Backup) DR field of each\n   Hello\
    \ sent on the interface.  As specified in Section 7.2, each\n   router forms an\
    \ adjacency with its Parent and Backup Parent if it\n   exists and is a neighboring\
    \ MDR/BMDR.\n   For a given MANET interface, let Rmax denote the router with the\n\
    \   largest value of (RtrPri, MDR Level, RID) among all bidirectional\n   neighbors,\
    \ if such a neighbor exists that has a larger value of\n   (RtrPri, MDR Level,\
    \ RID) than the router itself.  Otherwise, Rmax is\n   null.\n   If the calculating\
    \ router has selected itself as an MDR, then the\n   Parent is equal to the router\
    \ itself, and the Backup Parent is Rmax.\n   (The latter design choice was made\
    \ because it results in slightly\n   better performance than choosing no Backup\
    \ Parent.)  If the router\n   has selected itself as a BMDR, then the Backup Parent\
    \ is equal to the\n   router itself.\n   If the calculating router is a BMDR or\
    \ MDR Other, the Parent is\n   selected to be any adjacent neighbor that is an\
    \ MDR, if such a\n   neighbor exists.  If no adjacent MDR neighbor exists, then\
    \ the Parent\n   is selected to be Rmax.  By giving preference to neighbors that\
    \ are\n   already adjacent, the formation of a new adjacency is avoided when\n\
    \   possible.  Note that the Parent can be a non-MDR neighbor temporarily\n  \
    \ when no MDR neighbor exists.  (This design choice was also made for\n   performance\
    \ reasons.)\n   If AdjConnectivity = 2 and the calculating router is an MDR Other,\n\
    \   then the Backup Parent is selected to be any adjacent neighbor that\n   is\
    \ an MDR or BMDR, other than the Parent selected in the previous\n   paragraph,\
    \ if such a neighbor exists.  If no such adjacent neighbor\n   exists, then the\
    \ Backup Parent is selected to be the bidirectional\n   neighbor, excluding the\
    \ selected Parent, with the largest value of\n   (RtrPri, MDR Level, RID), if\
    \ such a neighbor exists.  Otherwise, the\n   Backup Parent is null.\n"
- title: '5.5.  Phase 5: Optional Selection of Non-Flooding MDRs'
  contents:
  - "5.5.  Phase 5: Optional Selection of Non-Flooding MDRs\n   A router that has\
    \ selected itself as an MDR MAY execute the following\n   steps to possibly declare\
    \ itself a non-flooding MDR.  An MDR that\n   does not execute the following steps\
    \ is by default a flooding MDR.\n   (5.1) If the router has a larger value of\
    \ (RtrPri, MDR Level, RID)\n         than all of its bi-neighbors, the router\
    \ is a flooding MDR.\n         Else, proceed to Step 5.2.\n   (5.2) Let Rmax be\
    \ the bi-neighbor that has the largest value of\n         (RtrPri, MDR Level,\
    \ RID).\n   (5.3) Using NCM to determine the connectivity of bi-neighbors,\n \
    \        compute the minimum number of hops, denoted hops(u), from Rmax\n    \
    \     to each other bi-neighbor u, using only intermediate nodes that\n      \
    \   are MDR bi-neighbors with a smaller value of (RtrPri, RID) than\n        \
    \ the router itself. (This can be done using BFS as in Step 2.4).\n   (5.4) If\
    \ hops(u) is at most MDRConstraint for each bi-neighbor u,\n         then the\
    \ router is a non-flooding MDR.  Else, it is a flooding\n         MDR.\n"
- title: 6.  Interface State Machine
  contents:
  - '6.  Interface State Machine

    '
- title: 6.1.  Interface States
  contents:
  - "6.1.  Interface States\n   No new states are defined for a MANET interface. \
    \ However, the DR and\n   Backup states now imply that the router is an MDR or\
    \ Backup MDR,\n   respectively.  The following modified definitions apply to MANET\n\
    \   interfaces:\n   Waiting\n      In this state, the router learns neighbor information\
    \ from the\n      Hello packets it receives, but is not allowed to run the MDR\n\
    \      selection algorithm until it transitions out of the Waiting state\n   \
    \   (when the Wait Timer expires).  This prevents unnecessary changes\n      in\
    \ the MDR selection resulting from incomplete neighbor\n      information.  The\
    \ length of the Wait Timer is 2HopRefresh *\n      HelloInterval seconds (the\
    \ interval between full Hellos).\n   DR Other\n      The router has run the MDR\
    \ selection algorithm and determined that\n      it is not an MDR or a Backup\
    \ MDR.\n   Backup\n      The router has selected itself as a Backup MDR.\n   DR\n\
    \      The router has selected itself as an MDR.\n"
- title: 6.2.  Events that Cause Interface State Changes
  contents:
  - "6.2.  Events that Cause Interface State Changes\n   All interface events defined\
    \ in [RFC2328], Section 9.2, apply to\n   MANET interfaces, except for BackupSeen\
    \ and NeighborChange.\n   BackupSeen is never invoked for a MANET interface (since\
    \ seeing a\n   Backup MDR does not imply that the router itself cannot also be\
    \ an\n   MDR or Backup MDR).\n   The event NeighborChange is replaced with the\
    \ new interface variable\n   MDRNeighborChange, which indicates that the MDR selection\
    \ algorithm\n   must be executed due to a change in neighbor information (see\
    \ Section\n   4.2.3).\n"
- title: 6.3.  Changes to Interface State Machine
  contents:
  - "6.3.  Changes to Interface State Machine\n   This section describes the changes\
    \ to the interface state machine for\n   a MANET interface.  The two state transitions\
    \ specified below are for\n   state-event pairs that are described in [RFC2328],\
    \ but have modified\n   action descriptions because MDRs are selected instead\
    \ of DRs.  The\n   state transition in [RFC2328] for the event NeighborChange\
    \ is\n   omitted; instead, the new interface variable MDRNeighborChange is\n \
    \  used to indicate when the MDR selection algorithm needs to be\n   executed.\
    \  The state transition for the event BackupSeen does not\n   apply to MANET interfaces,\
    \ since this event is never invoked for a\n   MANET interface.  The interface\
    \ state transitions for the events\n   Loopback and UnloopInd are unchanged from\
    \ [RFC2328].\n       State:  Down\n       Event:  InterfaceUp\n   New state: \
    \ Depends on action routine.\n      Action:  Start the interval Hello Timer, enabling\
    \ the periodic\n               sending of Hello packets out the interface.  The\
    \ state\n               transitions to Waiting and the single shot Wait Timer\n\
    \               is started.\n       State:  Waiting\n       Event:  WaitTimer\n\
    \   New state:  Depends on action routine.\n      Action:  Run the MDR selection\
    \ algorithm, which may result in a\n               change to the router's MDR\
    \ Level, Dependent Neighbors,\n               and (Backup) Parent.  As a result\
    \ of this calculation,\n               the new interface state will be DR Other,\
    \ Backup, or DR.\n               As a result of these changes, the AdjOK? neighbor\
    \ event\n               may be invoked for some or all neighbors.  (See\n    \
    \           Section 7.)\n"
- title: 7.  Adjacency Maintenance
  contents:
  - "7.  Adjacency Maintenance\n   Adjacency forming and eliminating on non-MANET\
    \ interfaces remain\n   unchanged.  Adjacency maintenance on a MANET interface\
    \ requires\n   changes to transitions in the neighbor state machine ([RFC2328],\n\
    \   Section 10.3), to deciding whether to become adjacent ([RFC2328],\n   Section\
    \ 10.4), sending of DD packets ([RFC2328], Section 10.8), and\n   receiving of\
    \ DD packets ([RFC2328], Section 10.6).  The specification\n   below relates to\
    \ the MANET interface only.\n   If full-topology adjacencies are used (AdjConnectivity\
    \ = 0), the\n   router forms an adjacency with each bidirectional neighbor.  If\n\
    \   adjacency reduction is used (AdjConnectivity is 1 or 2), the router\n   forms\
    \ adjacencies with a subset of its neighbors, according to the\n   rules specified\
    \ in Section 7.2.\n   An adjacency maintenance decision is made when any of the\
    \ following\n   four events occur between a router and its neighbor.  The decision\
    \ is\n   made by executing the neighbor event AdjOK?.\n      (1) The neighbor\
    \ state changes from Init to 2-Way.\n      (2) The MDR Level changes for the neighbor\
    \ or for the router\n          itself.\n      (3) The neighbor is selected to\
    \ be the (Backup) Parent.\n      (4) The neighbor selects the router to be its\
    \ (Backup) Parent.\n"
- title: 7.1.  Changes to Neighbor State Machine
  contents:
  - "7.1.  Changes to Neighbor State Machine\n   The following specifies new transitions\
    \ in the neighbor state\n   machine.\n    State(s):  Down\n       Event:  HelloReceived\n\
    \   New state:  Depends on action routine.\n      Action:  If the neighbor acceptance\
    \ condition is satisfied (see\n               Section 4.3), the neighbor state\
    \ transitions to Init and\n               the Inactivity Timer is started.  Otherwise,\
    \ the neighbor\n               remains in the Down state.\n    State(s):  Init\n\
    \       Event:  2-WayReceived\n   New state:  2-Way\n      Action:  Transition\
    \ to neighbor state 2-Way.\n    State(s):  2-Way\n       Event:  AdjOK?\n   New\
    \ state:  Depends on action routine.\n      Action:  Determine whether an adjacency\
    \ should be formed with the\n               neighboring router (see Section 7.2).\
    \  If not, the\n               neighbor state remains at 2-Way and no further\
    \ action is\n               taken.\n               Otherwise, the neighbor state\
    \ changes to ExStart, and the\n               following actions are performed.\
    \  If the neighbor has a\n               larger Router ID than the router's own\
    \ ID, and the\n               received packet is a DD packet with the initialize\
    \ (I),\n               more (M), and master (MS) bits set, then execute the\n\
    \               event NegotiationDone, which causes the state to\n           \
    \    transition to Exchange.\n               Otherwise (negotiation is not complete),\
    \ the router\n               increments the DD sequence number in the neighbor\
    \ data\n               structure.  If this is the first time that an adjacency\n\
    \               has been attempted, the DD sequence number should be\n       \
    \        assigned a unique value (like the time of day clock).  It\n         \
    \      then declares itself master (sets the master/slave bit to\n           \
    \    master), and starts sending Database Description packets,\n             \
    \  with the initialize (I), more (M), and master (MS) bits\n               set,\
    \ the MDR-DD TLV included in an LLS, and the L bit\n               set.  This\
    \ Database Description packet should be\n               otherwise empty.  This\
    \ Database Description packet should\n               be retransmitted at intervals\
    \ of RxmtInterval until the\n               next state is entered (see [RFC2328],\
    \ Section 10.8).\n    State(s):  ExStart or greater\n       Event:  AdjOK?\n \
    \  New state:  Depends on action routine.\n      Action:  Determine whether the\
    \ neighboring router should still be\n               adjacent (see Section 7.3).\
    \  If yes, there is no state\n               change and no further action is necessary.\
    \  Otherwise,\n               the (possibly partially formed) adjacency must be\n\
    \               destroyed.  The neighbor state transitions to 2-Way.  The\n  \
    \             Link state retransmission list, Database summary list,\n       \
    \        and Link state request list are cleared of LSAs.\n"
- title: 7.2.  Whether to Become Adjacent
  contents:
  - "7.2.  Whether to Become Adjacent\n   The following defines the method to determine\
    \ if an adjacency should\n   be formed between neighbors in state 2-Way.  The\
    \ following procedure\n   does not depend on whether AdjConnectivity is 1 or 2,\
    \ but the\n   selection of Dependent Neighbors (by the MDR selection algorithm)\n\
    \   depends on AdjConnectivity.\n   If adjacency reduction is not used (AdjConnectivity\
    \ = 0), then an\n   adjacency is formed with each neighbor in state 2-Way.  Otherwise,\
    \ an\n   adjacency is formed with a neighbor in state 2-Way if any of the\n  \
    \ following conditions is true:\n   (1) The router is a (Backup) MDR and the neighbor\
    \ is a (Backup) MDR\n       and is either a Dependent Neighbor or a Dependent\
    \ Selector.\n   (2) The neighbor is a (Backup) MDR and is the router's (Backup)\n\
    \       Parent.\n   (3) The router is a (Backup) MDR and the neighbor is a child.\n\
    \   (4) The neighbor's A-bit is 1, indicating that the neighbor is using\n   \
    \    full-topology adjacencies.\n   Otherwise, an adjacency is not established\
    \ and the neighbor remains\n   in state 2-Way.\n"
- title: 7.3.  Whether to Eliminate an Adjacency
  contents:
  - "7.3.  Whether to Eliminate an Adjacency\n   The following defines the method\
    \ to determine if an existing\n   adjacency should be eliminated.  An existing\
    \ adjacency is maintained\n   if any of the following is true:\n   (1) The router\
    \ is an MDR or Backup MDR.\n   (2) The neighbor is an MDR or Backup MDR.\n   (3)\
    \ The neighbor's A-bit is 1, indicating that the neighbor is using\n       full-topology\
    \ adjacencies.\n   Otherwise, the adjacency MAY be eliminated.\n"
- title: 7.4.  Sending Database Description Packets
  contents:
  - "7.4.  Sending Database Description Packets\n   Sending a DD packet on a MANET\
    \ interface is the same as [RFC5340],\n   Section 4.2.1.2, and [RFC2328], Section\
    \ 10.8, with the following\n   additions to paragraph 3 of Section 10.8.\n   If\
    \ the neighbor state is ExStart, the standard initialization packet\n   is sent\
    \ with an MDR-DD TLV appended using LLS, and the L bit is set\n   in the DD packet's\
    \ option field.  The format for the MDR-DD TLV is\n   specified in Section A.2.4.\
    \  The DR and Backup DR fields of the MDR-\n   DD TLV are set exactly the same\
    \ as the DR and Backup DR fields of a\n   Hello sent on the same interface.\n"
- title: 7.5.  Receiving Database Description Packets
  contents:
  - "7.5.  Receiving Database Description Packets\n   Processing a DD packet received\
    \ on a MANET interface is the same as\n   [RFC2328], Section 10.6, except for\
    \ the changes described in this\n   section.  The following additional steps are\
    \ performed before\n   processing the packet based on neighbor state in paragraph\
    \ 3 of\n   Section 10.6.\n   o  If the DD packet's L bit is set in the options\
    \ field and an MDR-DD\n      TLV is appended, then the MDR-DD TLV is processed\
    \ as follows.\n      (1) If the DR field is equal to the neighbor's Router ID:\n\
    \          (a) Set the MDR Level of the neighbor to MDR.\n          (b) Set the\
    \ neighbor's Dependent Selector variable to 1.\n      (2) Else if the Backup DR\
    \ field is equal to the neighbor's Router\n          ID:\n          (a) Set the\
    \ MDR Level of the neighbor to Backup MDR.\n          (b) Set the neighbor's Dependent\
    \ Selector variable to 1.\n      (3) Else:\n          (a) Set the MDR Level of\
    \ the neighbor to MDR Other.\n          (b) Set the neighbor's Dependent Neighbor\
    \ variable to 0.\n      (4) If the DR or Backup DR field is equal to the router's\
    \ own\n          Router ID, set the neighbor's Child variable to 1; otherwise,\n\
    \          set it to 0.\n   o  If the neighbor state is Init, the neighbor event\
    \ 2-WayReceived is\n      executed.\n   o  If the MDR Level of the neighbor changed,\
    \ the neighbor state\n      machine is scheduled with the event AdjOK?.\n   o\
    \  If the neighbor's Child status has changed from 0 to 1, the\n      neighbor\
    \ state machine is scheduled with the event AdjOK?.\n   o  If the neighbor's neighbor\
    \ state changed from less than 2-Way to\n      2-Way or greater, the neighbor\
    \ state machine is scheduled with the\n      event AdjOK?.\n   In addition, the\
    \ Database Exchange optimization described in\n   [RFC5243] SHOULD be performed\
    \ as follows.  If the router accepts a\n   received DD packet as the next in sequence,\
    \ the following additional\n   step should be performed for each LSA listed in\
    \ the DD packet\n   (whether the router is master or slave).  If the Database\
    \ summary\n   list contains an instance of the LSA that is the same as or less\n\
    \   recent than the listed LSA, the LSA is removed from the Database\n   summary\
    \ list.  This avoids listing the LSA in a DD packet sent to the\n   neighbor,\
    \ when the neighbor already has an instance of the LSA that\n   is the same or\
    \ more recent.  This optimization reduces overhead due\n   to DD packets by approximately\
    \ 50% in large networks.\n"
- title: 8.  Flooding Procedure
  contents:
  - "8.  Flooding Procedure\n   This section specifies the changes to [RFC2328], Section\
    \ 13, for\n   routers that support OSPF-MDR.  The first part of Section 13 (before\n\
    \   Section 13.1) is the same except for the following three changes.\n   o  To\
    \ exploit the broadcast nature of MANETs, if the Link State\n      Update (LSU)\
    \ packet was received on a MANET interface, then the\n      packet is dropped\
    \ without further processing only if the sending\n      neighbor is in a lesser\
    \ state than 2-Way.  Otherwise, the LSU\n      packet is processed as described\
    \ in this section.\n   o  If the received LSA is the same instance as the database\
    \ copy, the\n      following actions are performed in addition to Step 7.  For\
    \ each\n      MANET interface for which a BackupWait Neighbor List exists for\n\
    \      the LSA (see Section 8.1):\n      (a) Remove the sending neighbor from\
    \ the BackupWait Neighbor List\n          if it belongs to the list.\n      (b)\
    \ For each neighbor on the receiving interface that belongs to\n          the\
    \ BNS for the sending neighbor, remove the neighbor from the\n          BackupWait\
    \ Neighbor List if it belongs to the list.\n   o  Step 8, which handles the case\
    \ in which the database copy of the\n      LSA is more recent than the received\
    \ LSA, is modified as follows.\n      If the sending neighbor is in a lesser state\
    \ than Exchange, then\n      the router does not send the LSA back to the sending\
    \ neighbor.\n   There are no changes to Sections 13.1, 13.2, or 13.4.  The following\n\
    \   subsections describe the changes to Sections 13.3 (Next step in the\n   flooding\
    \ procedure), 13.5 (Sending Link State Acknowledgments), 13.6\n   (Retransmitting\
    \ LSAs), and 13.7 (Receiving Link State\n   Acknowledgments) of [RFC2328].\n"
- title: 8.1.  LSA Forwarding Procedure
  contents:
  - "8.1.  LSA Forwarding Procedure\n   When a new LSA is received, Steps 1 through\
    \ 5 of [RFC2328], Section\n   13.3, are performed without modification for each\
    \ eligible (outgoing)\n   interface that is not of type MANET.  This section specifies\
    \ the\n   modified steps that must be performed for each eligible MANET\n   interface.\
    \  The eligible interfaces depend on the LSA's flooding\n   scope as described\
    \ in [RFC5340], Section 4.5.2.  Whenever an LSA is\n   flooded out a MANET interface,\
    \ it is included in an LSU packet that\n   is sent to the multicast address AllSPFRouters.\
    \  (Retransmitted LSAs\n   are always unicast, as specified in Section 8.3.)\n\
    \   Step 1 of [RFC2328], Section 13.3, is performed for each eligible\n   MANET\
    \ interface with the following modification, so that the new LSA\n   is placed\
    \ on the Link State retransmission list for each appropriate\n   adjacent neighbor.\
    \  Step 1c is replaced with the following action, so\n   that the LSA is not placed\
    \ on the retransmission list for a neighbor\n   that has already acknowledged\
    \ the LSA.\n   o  If the new LSA was received from this neighbor, or a Link State\n\
    \      Acknowledgment (LS Ack) for the new LSA has already been received\n   \
    \   from this neighbor, examine the next neighbor.\n   To determine whether an\
    \ Ack for the new LSA has been received from\n   the neighbor, the router maintains\
    \ an Acked LSA List for each\n   adjacent neighbor, as described in Section 8.4.\
    \  When a new LSA is\n   received, the Acked LSA List for each neighbor, on each\
    \ MANET\n   interface, should be updated by removing any LS Ack that is for an\n\
    \   older instance of the LSA than the one received.\n   The following description\
    \ will use the notion of a \"covered\"\n   neighbor.  A neighbor k is defined\
    \ to be covered if the LSA was sent\n   as a multicast by a MANET neighbor j,\
    \ and neighbor k belongs to the\n   Bidirectional Neighbor Set (BNS) for neighbor\
    \ j.  A neighbor k is\n   also defined to be covered if the LSA was sent to the\
    \ multicast\n   address AllSPFRouters by a neighbor j on a broadcast interface\
    \ on\n   which both j and k are neighbors.  (Note that j must be the DR or\n \
    \  Backup DR for the broadcast network, since only these routers may\n   send\
    \ LSAs to AllSPFRouters on a broadcast network.)\n   The following steps must\
    \ be performed for each eligible MANET\n   interface, to determine whether the\
    \ new LSA should be forwarded on\n   the interface.\n   (2) If every bidirectional\
    \ neighbor on the interface satisfies at\n       least one of the following three\
    \ conditions, examine the next\n       interface (the LSA is not flooded out this\
    \ interface).\n      (a) The LSA was received from the neighbor.\n      (b) The\
    \ LSA was received on a MANET or broadcast interface and the\n          neighbor\
    \ is covered (defined above).\n      (c) An Ack for the LSA has been received\
    \ from the neighbor.\n          Condition (c) MAY be omitted (thus ignoring Acks)\
    \ in order to\n          simplify this step.  Note that the above conditions do\
    \ not\n          assume the outgoing interface is the same as the receiving\n\
    \          interface.\n   (3) If the LSA was received on this interface, and the\
    \ router is an\n       MDR Other for this interface, examine the next interface\
    \ (the LSA\n       is not flooded out this interface).\n   (4) If the LSA was\
    \ received on this interface, and the router is a\n       Backup MDR or a non-flooding\
    \ MDR for this interface, then the\n       router waits BackupWaitInterval before\
    \ deciding whether to flood\n       the LSA.  To accomplish this, the router creates\
    \ a BackupWait\n       Neighbor List for the LSA, which initially includes every\n\
    \       bidirectional neighbor on this interface that does not satisfy\n     \
    \  any of the conditions in Step 2.  A single-shot BackupWait Timer\n       associated\
    \ with the LSA is started, which is set to expire after\n       BackupWaitInterval\
    \ seconds plus a small amount of random jitter.\n       (The actions performed\
    \ when the BackupWait Timer expires are\n       described below in Section 8.1.2.)\
    \  Examine the next interface\n       (the LSA is not yet flooded out this interface).\n\
    \   (5) If the router is a flooding MDR for this interface, or if the LSA\n  \
    \     was originated by the router itself, then the LSA is flooded out\n     \
    \  the interface (whether or not the LSA was received on this\n       interface)\
    \ and the next interface is examined.\n   (6) If the LSA was received on a MANET\
    \ or broadcast interface that is\n       different from this (outgoing) interface,\
    \ then the following two\n       steps SHOULD be performed to avoid redundant\
    \ flooding.\n      (a) If the router has a larger value of (RtrPri, MDR Level,\
    \ RID)\n          on the outgoing interface than every covered neighbor (defined\n\
    \          above) that is a neighbor on BOTH the receiving and outgoing\n    \
    \      interfaces (or if no such neighbor exists), then the LSA is\n         \
    \ flooded out the interface and the next interface is examined.\n      (b) Else,\
    \ the router waits BackupWaitInterval before deciding\n          whether to flood\
    \ the LSA on the interface, by performing the\n          actions in Step 4 for\
    \ a Backup MDR (whether or not the router\n          is a Backup MDR on this interface).\
    \  A separate BackupWait\n          Neighbor List is created for each MANET interface,\
    \ but only\n          one BackupWait Timer is associated with the LSA.  Examine\
    \ the\n          next interface (the LSA is not yet flooded out this\n       \
    \   interface).\n   (7) If this step is reached, the LSA is flooded out the interface.\n"
- title: 8.1.1.  Note on Step 6 of LSA Forwarding Procedure
  contents:
  - "8.1.1.  Note on Step 6 of LSA Forwarding Procedure\n   Performing the optional\
    \ Step 6 can greatly reduce flooding overhead\n   if the LSA was received on a\
    \ MANET or broadcast interface.  For\n   example, assume that the LSA was received\
    \ from the DR of a broadcast\n   network that includes 100 routers, and 50 of\
    \ the routers (not\n   including the DR) are also attached to a MANET.  Assume\
    \ that these 50\n   routers are neighbors of each other in the MANET and that\
    \ each has a\n   neighbor in the MANET that is not attached to the broadcast network\n\
    \   (and is therefore not covered).  Then by performing Step 6 of the LSA\n  \
    \ forwarding procedure, the number of routers that forward the LSA from\n   the\
    \ broadcast network to the MANET is reduced from 50 to just 1\n   (assuming that\
    \ at most 1 of the 50 routers is an MDR).\n"
- title: 8.1.2.  BackupWait Timer Expiration
  contents:
  - "8.1.2.  BackupWait Timer Expiration\n   If the BackupWait Timer for an LSA expires,\
    \ then the following steps\n   are performed for each (MANET) interface for which\
    \ a BackupWait\n   Neighbor List exists for the LSA.\n   (1) If the BackupWait\
    \ Neighbor List for the interface contains at\n       least one router that is\
    \ currently a bidirectional neighbor, the\n       following actions are performed.\n\
    \      (a) The LSA is flooded out the interface.\n      (b) If the LSA is on the\
    \ Ack List for the interface (i.e., is\n          scheduled to be included in\
    \ a delayed Link State\n          Acknowledgment packet), then the router SHOULD\
    \ remove the LSA\n          from the Ack List, since the flooded LSA will be treated\
    \ as an\n          implicit Ack.\n      (c) If the LSA is on the Link State retransmission\
    \ list for any\n          neighbor, the retransmission SHOULD be rescheduled to\
    \ occur\n          after RxmtInterval seconds.\n   (2) The BackupWait Neighbor\
    \ List is then deleted (whether or not the\n       LSA is flooded).\n"
- title: 8.2.  Sending Link State Acknowledgments
  contents:
  - "8.2.  Sending Link State Acknowledgments\n   This section describes the procedure\
    \ for sending Link State\n   Acknowledgments (LS Acks) on MANET interfaces.  Section\
    \ 13.5 of\n   [RFC2328] remains unchanged for non-MANET interfaces, but does not\n\
    \   apply to MANET interfaces.  To minimize overhead due to LS Acks, and\n   to\
    \ take advantage of the broadcast nature of MANETs, all LS Ack\n   packets sent\
    \ on a MANET interface are multicast using the IP address\n   AllSPFRouters. \
    \ In addition, duplicate LSAs received as a multicast\n   are not acknowledged.\n\
    \   When a router receives an LSA, it must decide whether to send a\n   delayed\
    \ Ack, an immediate Ack, or no Ack.  The interface parameter\n   AckInterval is\
    \ the interval between LS Ack packets when only delayed\n   Acks need to be sent.\
    \  A delayed Ack SHOULD be delayed by at least\n   (RxmtInterval - AckInterval\
    \ - 0.5) seconds and at most (RxmtInterval\n   - 0.5) seconds after the LSA instance\
    \ being acknowledged was first\n   received.  If AckInterval and RxmtInterval\
    \ are equal to their default\n   values of 1 and 7 seconds, respectively, this\
    \ reduces Ack traffic by\n   increasing the chance that a new instance of the\
    \ LSA will be received\n   before the delayed Ack is sent.  An immediate Ack is\
    \ sent immediately\n   in a multicast LS Ack packet, which may also include delayed\
    \ Acks\n   that were scheduled to be sent.\n   The decision whether to send a\
    \ delayed or immediate Ack depends on\n   whether the received LSA is new (i.e.,\
    \ is more recent than the\n   database copy) or a duplicate (the same instance\
    \ as the database\n   copy), and on whether the LSA was received as a multicast\
    \ or a\n   unicast (which indicates a retransmitted LSA).  The following rules\n\
    \   are used to make this decision.\n   (1) If the received LSA is new, a delayed\
    \ Ack is sent on each MANET\n       interface associated with the area, unless\
    \ the LSA is flooded out\n       the interface.\n   (2) If the LSA is a duplicate\
    \ and was received as a multicast, the\n       LSA is not acknowledged.\n   (3)\
    \ If the LSA is a duplicate and was received as a unicast:\n       (a) If the\
    \ router is an MDR, or AdjConnectivity = 2 and the\n           router is a Backup\
    \ MDR, or AdjConnectivity = 0, then an\n           immediate Ack is sent out the\
    \ receiving interface.\n       (b) Otherwise, a delayed Ack is sent out the receiving\
    \ interface.\n   The reason that (Backup) MDRs send an immediate Ack when a\n\
    \   retransmitted LSA is received is to try to prevent other adjacent\n   neighbors\
    \ from retransmitting the LSA, since (Backup) MDRs usually\n   have a large number\
    \ of adjacent neighbors.  MDR Other routers do not\n   send an immediate Ack (unless\
    \ AdjConnectivity = 0) because they have\n   fewer adjacent neighbors, and so\
    \ the potential benefit does not\n   justify the additional overhead resulting\
    \ from sending immediate\n   Acks.\n"
- title: 8.3.  Retransmitting LSAs
  contents:
  - "8.3.  Retransmitting LSAs\n   LSAs are retransmitted according to Section 13.6\
    \ of [RFC2328].  Thus,\n   LSAs are retransmitted only to adjacent routers.  Therefore,\
    \ since\n   OSPF-MDR does not allow an adjacency to be formed between two MDR\n\
    \   Other routers, an MDR Other never retransmits an LSA to another MDR\n   Other,\
    \ only to its Parents, which are (Backup) MDRs.\n   Retransmitted LSAs are included\
    \ in LSU packets that are unicast\n   directly to an adjacent neighbor that did\
    \ not acknowledge the LSA\n   (explicitly or implicitly).  The length of time\
    \ between\n   retransmissions is given by the configurable interface parameter\n\
    \   RxmtInterval, whose default is 7 seconds for a MANET interface.  To\n   reduce\
    \ overhead, several retransmitted LSAs should be included in a\n   single LSU\
    \ packet whenever possible.\n"
- title: 8.4.  Receiving Link State Acknowledgments
  contents:
  - "8.4.  Receiving Link State Acknowledgments\n   A Link State Acknowledgment (LS\
    \ Ack) packet that is received from an\n   adjacent neighbor (in state Exchange\
    \ or greater) is processed as\n   described in Section 13.7 of [RFC2328], with\
    \ the additional steps\n   described in this section.  An LS Ack packet that is\
    \ received from a\n   neighbor in a lesser state than Exchange is discarded.\n\
    \   Each router maintains an Acked LSA List for each adjacent neighbor,\n   to\
    \ keep track of any LSA instances the neighbor has acknowledged but\n   that the\
    \ router itself has NOT yet received.  This is necessary\n   because (unlike [RFC2328])\
    \ each router acknowledges an LSA only the\n   first time it is received as a\
    \ multicast.\n   If the neighbor from which the LS Ack packet was received is\
    \ in state\n   Exchange or greater, then the following steps are performed for\
    \ each\n   LS Ack in the received LS Ack packet:\n   (1) If the router does not\
    \ have a database copy of the LSA being\n       acknowledged, or has a database\
    \ copy that is less recent than the\n       one being acknowledged, the LS Ack\
    \ is added to the Acked LSA List\n       for the sending neighbor.\n   (2) If\
    \ the router has a database copy of the LSA being acknowledged,\n       which\
    \ is the same as the instance being acknowledged, then the\n       following action\
    \ is performed.  For each MANET interface for\n       which a BackupWait Neighbor\
    \ List exists for the LSA (see Section\n       8.1), remove the sending neighbor\
    \ from the BackupWait Neighbor\n       List if it belongs to the list.\n"
- title: 9.  Router-LSAs
  contents:
  - "9.  Router-LSAs\n   Unlike the DR of an OSPF broadcast network, an MDR does not\
    \ originate\n   a network-LSA, since a network-LSA cannot be used to describe\
    \ the\n   general topology of a MANET.  Instead, each router advertises a\n  \
    \ subset of its MANET neighbors as point-to-point links in its router-\n   LSA.\
    \  The choice of which MANET neighbors to include in the router-\n   LSA is flexible.\
    \  Whether or not adjacency reduction is used, the\n   router can originate either\
    \ partial-topology or full-topology LSAs.\n   If adjacency reduction is used (AdjConnectivity\
    \ is 1 or 2), then as a\n   minimum requirement each router must advertise a minimum\
    \ set of\n   \"backbone\" neighbors in its router-LSA.  This minimum choice\n\
    \   corresponds to LSAFullness = 0, and results in the minimum amount of\n   LSA\
    \ flooding overhead, but does not provide routing along shortest\n   paths.\n\
    \   Therefore, to allow routers to calculate shortest paths, without\n   requiring\
    \ every pair of neighboring routers along the shortest paths\n   to be adjacent\
    \ (which would be inefficient due to requiring a large\n   number of adjacencies),\
    \ a router-LSA may also advertise non-adjacent\n   neighbors that satisfy a synchronization\
    \ condition described below.\n   To motivate this, we note that OSPF already allows\
    \ a non-adjacent\n   neighbor to be a next hop, if both the router and the neighbor\
    \ belong\n   to the same broadcast network (and are both adjacent to the DR).\
    \  A\n   network-LSA for a broadcast network (which includes all routers\n   attached\
    \ to the network) implies that any router attached to the\n   network can forward\
    \ packets directly to any other router attached to\n   the network (which is why\
    \ the distance from the network to all\n   attached routers is zero in the graph\
    \ representing the link-state\n   database).\n   Since a network-LSA cannot be\
    \ used to describe the general topology\n   of a MANET, the only way to advertise\
    \ non-adjacent neighbors that can\n   be used as next hops is to include them\
    \ in the router-LSA.  However,\n   to ensure that such neighbors are sufficiently\
    \ synchronized, only\n   \"routable\" neighbors are allowed to be included in\
    \ LSAs, and to be\n   used as next hops in the SPF calculation.\n"
- title: 9.1.  Routable Neighbors
  contents:
  - "9.1.  Routable Neighbors\n   If adjacency reduction is used, a bidirectional\
    \ MANET neighbor\n   becomes routable if the SPF calculation has found a route\
    \ to the\n   neighbor and the neighbor satisfies the routable neighbor quality\n\
    \   condition (defined below).  Since only routable and Full neighbors\n   are\
    \ advertised in router-LSAs, and since adjacencies are selected to\n   form a\
    \ connected spanning subgraph, this definition implies that\n   there exists,\
    \ or recently existed, a path of full adjacencies from\n   the router to the routable\
    \ neighbor.  The idea is that, since a\n   routable neighbor can be reached through\
    \ an acceptable path, it makes\n   sense to take a \"shortcut\" and forward packets\
    \ directly to the\n   routable neighbor.\n   This requirement does not guarantee\
    \ perfect synchronization, but\n   simulations have shown that it performs well\
    \ in mobile networks.\n   This requirement avoids, for example, forwarding packets\
    \ to a new\n   neighbor that is poorly synchronized because it was not reachable\n\
    \   before it became a neighbor.\n   To avoid selecting poor-quality neighbors\
    \ as routable neighbors, a\n   neighbor that is selected as a routable neighbor\
    \ must satisfy the\n   routable neighbor quality condition.  By default, this\
    \ condition is\n   that the neighbor's BNS must include the router itself (indicating\n\
    \   that the neighbor agrees the connection is bidirectional).\n   Optionally,\
    \ a router may impose a stricter condition.  For example, a\n   router may require\
    \ that two Hellos have been received from the\n   neighbor that (explicitly or\
    \ implicitly) indicate that the neighbor's\n   BNS includes the router itself.\n\
    \   The single-bit neighbor variable Routable indicates whether the\n   neighbor\
    \ is routable, and is initially set to 0.  If adjacency\n   reduction is used,\
    \ Routable is updated as follows when the state of\n   the neighbor changes, or\
    \ the SPF calculation finds a route to the\n   neighbor, or a Hello is received\
    \ that affects the routable neighbor\n   quality condition.\n   (1) If Routable\
    \ is 0 for the neighbor, the state of the neighbor is\n       2-Way or greater,\
    \ there exists a route to the neighbor, and the\n       routable neighbor quality\
    \ condition (defined above) is satisfied,\n       then Routable is set to 1 for\
    \ the neighbor.\n   (2) If Routable is 1 for the neighbor and the state of the\
    \ neighbor\n       is less than 2-Way, Routable is set to 0 for the neighbor.\n\
    \   If adjacency reduction is not used (AdjConnectivity = 0), then\n   routable\
    \ neighbors are not computed and the set of routable neighbors\n   remains empty.\n"
- title: 9.2.  Backbone Neighbors
  contents:
  - "9.2.  Backbone Neighbors\n   The flexible choice for the router-LSA is made possible\
    \ by defining\n   two types of neighbors that are included in the router-LSA:\
    \ backbone\n   neighbors and Selected Advertised Neighbors.\n   If adjacency reduction\
    \ is used, a bidirectional neighbor is defined\n   to be a backbone neighbor if\
    \ and only if it satisfies the condition\n   for becoming adjacent (see Section\
    \ 7.2).  If adjacency reduction is\n   not used (AdjConnectivity = 0), a bidirectional\
    \ neighbor is a\n   backbone neighbor if and only if the neighbor's A-bit is 0\n\
    \   (indicating that the neighbor is using adjacency reduction).  This\n   definition\
    \ allows the interoperation between routers that use\n   adjacency reduction and\
    \ routers that do not.\n   If adjacency reduction is used, then a router MUST\
    \ include in its\n   router-LSA all Full neighbors and all routable backbone neighbors.\
    \  A\n   minimal LSA, corresponding to LSAFullness = 0, includes only these\n\
    \   neighbors.  This choice guarantees connectivity, but does not ensure\n   shortest\
    \ paths.  However, this choice is useful in large networks to\n   achieve maximum\
    \ scalability.\n"
- title: 9.3.  Selected Advertised Neighbors
  contents:
  - "9.3.  Selected Advertised Neighbors\n   To allow flexibility while ensuring that\
    \ router-LSAs are symmetric\n   (i.e., router i advertises a link to router j\
    \ if and only if router j\n   advertises a link to router i), each router maintains\
    \ a Selected\n   Advertised Neighbor set (SANS), which consists of MANET neighbors\n\
    \   that the router has selected to advertise in its router-LSA, not\n   including\
    \ backbone neighbors.  Since the SANS does not include\n   backbone neighbors\
    \ (and thus Dependent Neighbors), the SANS and DNS\n   are disjoint.  Both of\
    \ these neighbor sets are advertised in Hellos.\n   If LSAFullness is 0 (minimal\
    \ LSAs), then the SANS is empty.  At the\n   other extreme, if LSAFullness is\
    \ 4 (full-topology LSAs), the SANS\n   includes all bidirectional MANET neighbors\
    \ except backbone neighbors.\n   In between these two extremes, a router that\
    \ is using adjacency\n   reduction may select any subset of bidirectional non-backbone\n\
    \   neighbors as its SANS.  The resulting router-LSA is constructed as\n   specified\
    \ in Section 9.4.\n   Since a router that is not using adjacency reduction typically\
    \ has no\n   backbone neighbors (unless it has neighbors that are using adjacency\n\
    \   reduction), to ensure connectivity, such a router must choose its\n   SANS\
    \ to contain the SANS corresponding to LSAFullness = 1.  Thus, if\n   AdjConnectivity\
    \ is 0 (no adjacency reduction), then LSAFullness must\n   be 1, 2, or 4.\n  \
    \ If LSAFullness is 1, the router originates min-cost LSAs, which are\n   partial-topology\
    \ LSAs that (when flooded) provide each router with\n   sufficient information\
    \ to calculate a shortest (minimum-cost) path to\n   each destination.  Appendix\
    \ C describes the algorithm for selecting\n   the neighbors to include in the\
    \ SANS that results in min-cost LSAs.\n   The input to this algorithm includes\
    \ information obtained from Hellos\n   received from each MANET neighbor, including\
    \ the neighbor's\n   Bidirectional Neighbor Set (BNS), Dependent Neighbor Set\
    \ (DNS),\n   Selected Advertised Neighbor Set (SANS), and the Metric TLV.  The\n\
    \   Metric TLV, specified in Section A.2.5, is appended to each Hello\n   (unless\
    \ all link costs are 1) to advertise the link cost to each\n   bidirectional neighbor.\n\
    \   If LSAFullness is 2, the SANS must be selected to be a superset of\n   the\
    \ SANS corresponding to LSAFullness = 1.  This choice provides\n   shortest-path\
    \ routing while allowing the router to advertise\n   additional neighbors to provide\
    \ redundant routes.\n   If LSAFullness is 3, each MDR originates a full-topology\
    \ LSA (which\n   includes all Full and routable neighbors), while each non-MDR\
    \ router\n   originates a minimal LSA.  If the router has multiple MANET\n   interfaces,\
    \ the router-LSA includes all Full and routable neighbors\n   on each interface\
    \ for which it is an MDR, and advertises only Full\n   neighbors and routable\
    \ backbone neighbors on its other interfaces.\n   This choice provides routing\
    \ along nearly shortest paths with\n   relatively low overhead.\n   Although this\
    \ document specifies a few choices of the SANS, which\n   correspond to different\
    \ values of LSAFullness, it is important to\n   note that other choices are possible.\
    \  In addition, it is not\n   necessary for different routers to choose the same\
    \ value of\n   LSAFullness.  The different choices are interoperable because they\n\
    \   all require the router-LSA to include a minimum set of neighbors, and\n  \
    \ because the construction of the router-LSA (described below) ensures\n   that\
    \ the router-LSAs originated by different routers are consistent.\n"
- title: 9.4.  Originating Router-LSAs
  contents:
  - "9.4.  Originating Router-LSAs\n   When a new router-LSA is originated, it includes\
    \ a point-to-point\n   (type 1) link for each MANET neighbor that is advertised.\
    \  The set of\n   neighbors to be advertised is determined as follows.  If adjacency\n\
    \   reduction is used, the router advertises all Full neighbors, and\n   advertises\
    \ each routable neighbor j that satisfies any of the\n   following three conditions.\
    \  If adjacency reduction is not used\n   (AdjConnectivity = 0), the router advertises\
    \ each Full neighbor j\n   that satisfies any of the following three conditions.\n\
    \   (1) The router's SANS (for any interface) includes j.\n   (2) Neighbor j's\
    \ SANS includes the router (to ensure symmetry).\n   (3) Neighbor j is a backbone\
    \ neighbor.\n   Note that backbone neighbors and neighbors in the SANS need not\
    \ be\n   routable or Full, but only routable and Full neighbors may be\n   included\
    \ in the router-LSA.  This is done so that the SANS, which is\n   advertised in\
    \ Hellos, does not depend on routability.\n   The events that cause a new router-LSA\
    \ to be originated are the same\n   as in [RFC2328] and [RFC5340] except that\
    \ a MANET neighbor changing\n   to/from the Full state does not always cause a\
    \ new router-LSA to be\n   originated.  Instead, a new router-LSA is originated\
    \ whenever a\n   change occurs that causes any of the following three conditions\
    \ to\n   occur:\n   o  There exists a MANET neighbor j that satisfies the above\n\
    \      conditions for inclusion in the router-LSA, but is not included in\n  \
    \    the current router-LSA.\n   o  The current router-LSA includes a MANET neighbor\
    \ that is no longer\n      bidirectional.\n   o  The link metric has changed for\
    \ a MANET neighbor that is included\n      in the current router-LSA.\n   The\
    \ above conditions may be checked periodically just before sending\n   each Hello,\
    \ instead of checking them every time one of the neighbor\n   sets changes.  The\
    \ following implementation was found to work well.\n   Just before sending each\
    \ Hello, and whenever a bidirectional neighbor\n   transitions to less than 2-Way,\
    \ the router runs the MDR selection\n   algorithm; updates its adjacencies, routable\
    \ neighbors, and Selected\n   Advertised Neighbors; then checks the above conditions\
    \ to see if a\n   new router-LSA should be originated.  In addition, if a neighbor\n\
    \   becomes bidirectional or Full, the router updates its routable\n   neighbors\
    \ and checks the above conditions.\n"
- title: 10.  Calculating the Routing Table
  contents:
  - "10.  Calculating the Routing Table\n   The routing table calculation is the same\
    \ as specified in [RFC2328],\n   except for the following changes to Section 16.1\
    \ (Calculating the\n   shortest-path tree for an area).  If full-topology adjacencies\
    \ and\n   full-topology LSAs are used (AdjConnectivity = 0 and LSAFullness =\n\
    \   4), there is no change to Section 16.1.\n   If adjacency reduction is used\
    \ (AdjConnectivity is 1 or 2), then\n   Section 16.1 is modified as follows. \
    \ Recall from Section 9 that a\n   router can use any routable neighbor as a next\
    \ hop to a destination,\n   whether or not the neighbor is advertised in the router-LSA.\
    \  This is\n   accomplished by modifying Step 2 so that the router-LSA associated\n\
    \   with the root vertex is replaced with a dummy router-LSA that\n   includes\
    \ links to all Full neighbors and all routable MANET\n   neighbors.  In addition,\
    \ Step 2b (checking for a link from W back to\n   V) MUST be skipped when V is\
    \ the root vertex and W is a routable\n   MANET neighbor.  However, Step 2b must\
    \ still be executed when V is\n   not the root vertex, to ensure compatibility\
    \ with OSPFv3.\n   If LSAFullness is 0 (minimal LSAs), then the calculated paths\
    \ need\n   not be shortest paths.  In this case, the path actually taken by a\n\
    \   packet can be shorter than the calculated path, since intermediate\n   routers\
    \ may have routable neighbors that are not advertised in any\n   router-LSA.\n\
    \   If full-topology adjacencies and partial-topology LSAs are used, then\n  \
    \ Section 16.1 is modified as follows.  Step 2 is modified so that the\n   router-LSA\
    \ associated with the root vertex is replaced with a dummy\n   router-LSA that\
    \ includes links to all Full neighbors.  In addition,\n   Step 2b MUST be skipped\
    \ when V is the root vertex and W is a Full\n   MANET neighbor.  (This is necessary\
    \ since the neighbor's router-LSA\n   need not contain a link back to the router.)\n\
    \   If adjacency reduction is used with partial-topology LSAs, then the\n   set\
    \ of routable neighbors can change without causing the contents of\n   the router-LSA\
    \ to change.  This could happen, for example, if a\n   routable neighbor that\
    \ was not included in the router-LSA transitions\n   to the Down or Init state.\
    \  Therefore, if the set of routable\n   neighbors changes, the shortest-path\
    \ tree must be recalculated, even\n   if the router-LSA does not change.\n   After\
    \ the shortest-path tree and routing table are calculated, the\n   set of routable\
    \ neighbors must be updated, since a route to a non-\n   routable neighbor may\
    \ have been discovered.  If the set of routable\n   neighbors changes, then the\
    \ shortest-path tree and routing table must\n   be calculated a second time. \
    \ The second calculation will not change\n   the set of routable neighbors again,\
    \ so two calculations are\n   sufficient.  If the set of routable neighbors is\
    \ updated periodically\n   every HelloInterval seconds, then it is not necessary\
    \ to update the\n   set of routable neighbors immediately after the routing table\
    \ is\n   updated.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   As with OSPFv3 [RFC5340], OSPF-MDR can use the\
    \ IPv6 Authentication\n   Header (AH) [RFC4302] and/or the IPv6 Encapsulation\
    \ Security Payload\n   (ESP) [RFC4303] to provide authentication, integrity, and/or\n\
    \   confidentiality.  The use of AH and ESP for OSPFv3 is described in\n   [RFC4552].\n\
    \   Generic threats to routing protocols are described and categorized in\n  \
    \ [RFC4593].  The mechanisms described in [RFC4552] provide protection\n   against\
    \ many of these threats, but not all of them.  In particular,\n   as mentioned\
    \ in [RFC5340], these mechanisms do not provide protection\n   against compromised,\
    \ malfunctioning, or misconfigured routers (also\n   called Byzantine routers);\
    \ this is true for both OSPFv3 and OSPF-MDR.\n   The extension of OSPFv3 to include\
    \ MANET routers does not introduce\n   any new security threats.  However, the\
    \ use of a wireless medium and\n   lack of infrastructure, inherent with MANET\
    \ routers, may render some\n   of the attacks described in [RFC4593] easier to\
    \ mount.  Depending on\n   the network context, these increased vulnerabilities\
    \ may increase the\n   need to provide authentication, integrity, and/or confidentiality,\
    \ as\n   well as anti-replay service.\n   For example, sniffing of routing information\
    \ and traffic analysis are\n   easier tasks with wireless routers than with wired\
    \ routers, since the\n   attacker only needs to be within the radio range of a\
    \ router.  The\n   use of confidentiality (encryption) provides protection against\n\
    \   sniffing but not traffic analysis.\n   Similarly, interference attacks are\
    \ also easier to mount against\n   MANET routers due to their wireless nature.\
    \  Such attacks can be\n   mounted even if OSPF packets are protected by authentication\
    \ and\n   confidentiality, e.g., by transmitting noise or replaying outdated\n\
    \   OSPF packets.  As discussed below, an anti-replay service (provided\n   by\
    \ both ESP and AH) can be used to protect against the latter attack.\n   The following\
    \ threat actions are also easier with MANET routers:\n   spoofing (assuming the\
    \ identify of a legitimate router),\n   falsification (sending false routing information),\
    \ and overloading\n   (sending or triggering an excessive amount of routing updates).\n\
    \   These attacks are only possible if authentication is not used, or the\n  \
    \ attacker takes control of a router or is able to forge legitimacy\n   (e.g.,\
    \ by discovering the cryptographic key).\n   [RFC4552] mandates the use of manual\
    \ keying when current IPsec\n   protocols are used with OSPFv3.  Routers are required\
    \ to use manually\n   configured keys with the same security association (SA)\
    \ parameters\n   for both inbound and outbound traffic.  For MANET routers, this\n\
    \   implies that all routers attached to the same MANET must use the same\n  \
    \ key for multicasting packets.  This is required in order to achieve\n   scalability\
    \ and feasibility, as explained in [RFC4552].  Future\n   specifications can explore\
    \ the use of automated key management\n   protocols that may be suitable for MANETs.\n\
    \   As discussed in [RFC4552], the use of manual keys can increase\n   vulnerability.\
    \  For example, manual keys are usually long lived, thus\n   giving an attacker\
    \ more time to discover the keys.  In addition, the\n   use of the same key on\
    \ all routers attached to the same MANET leaves\n   all routers insecure against\
    \ impersonation attacks if any one of the\n   routers is compromised.\n   Although\
    \ [RFC4302] and [RFC4303] state that implementations of AH and\n   ESP SHOULD\
    \ NOT provide anti-replay service in conjunction with SAs\n   that are manually\
    \ keyed, it is important to note that such service is\n   allowed if the sequence\
    \ number counter at the sender is correctly\n   maintained across local reboots\
    \ until the key is replaced.\n   Therefore, it may be possible for MANET routers\
    \ to make use of the\n   anti-replay service provided by AH and ESP.\n   When\
    \ an OSPF routing domain includes both MANET networks and fixed\n   networks,\
    \ the frequency of OSPF updates either due to actual topology\n   changes or malfeasance\
    \ could result in instability in the fixed\n   networks.  In situations where\
    \ this is a concern, it is recommended\n   that the border routers segregate the\
    \ MANET networks from the fixed\n   networks with either separate OSPF areas or,\
    \ in cases where legacy\n   routers are very sensitive to OSPF update frequency,\
    \ separate OSPF\n   instances.  With separate OSPF areas, the 5-second MinLSInterval\
    \ will\n   dampen the frequency of changes originated in the MANET networks.\n\
    \   Additionally, OSPF ranges can be configured to aggregate prefixes for\n  \
    \ the areas supporting MANET networks.  With separate OSPF instances,\n   more\
    \ conservative local policies can be employed to limit the volume\n   of updates\
    \ emanating from the MANET networks.\n"
- title: 12.  IANA Considerations
  contents:
  - "12.  IANA Considerations\n   This document defines three new LLS TLV types: MDR-Hello\
    \ TLV (14),\n   MDR-Metric TLV (16), and MDR-DD TLV (15) (see Section A.2).\n"
- title: 13.  Acknowledgments
  contents:
  - "13.  Acknowledgments\n   Thanks to Aniket Desai for helpful discussions and comments,\n\
    \   including the suggestion that Router Priority should come before MDR\n   Level\
    \ in the lexicographical comparison of (RtrPri, MDR Level, RID)\n   when selecting\
    \ MDRs and BMDRs, and that the MDR calculation should be\n   repeated if it causes\
    \ the MDR Level to change.  Thanks also to Tom\n   Henderson, Acee Lindem, and\
    \ Emmanuel Baccelli for helpful discussions\n   and comments.\n"
- title: 14.  Normative References
  contents:
  - "14.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC2328]   Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, April 1998.\n\
    \   [RFC4302]   Kent, S., \"IP Authentication Header\", RFC 4302, December\n \
    \              2005.\n   [RFC4303]   Kent, S., \"IP Encapsulating Security Payload\
    \ (ESP)\", RFC\n               4303, December 2005.\n   [RFC4552]   Gupta, M.\
    \ and N. Melam, \"Authentication/Confidentiality\n               for OSPFv3\"\
    , RFC 4552, June 2006.\n   [RFC5243]   Ogier, R., \"OSPF Database Exchange Summary\
    \ List\n               Optimization\", RFC 5243, May 2008.\n   [RFC5340]   Coltun,\
    \ R., Ferguson, D., Moy, J., and A. Lindem, \"OSPF\n               for IPv6\"\
    , RFC 5340, July 2008.\n   [RFC5613]   Zinin, A., Roy, A.,  Nguyen, L., Friedman,\
    \ B., and D.\n               Yeung, \"OSPF Link-Local Signaling\", RFC 5613, August\n\
    \               2009.\n"
- title: 15.  Informative References
  contents:
  - "15.  Informative References\n   [Lawler]    Lawler, E., \"Combinatorial Optimization:\
    \ Networks and\n               Matroids\", Holt, Rinehart, and Winston, New York,\
    \ 1976.\n   [Suurballe] Suurballe, J.W. and R.E. Tarjan, \"A Quick Method for\n\
    \               Finding Shortest Pairs of Disjoint Paths\", Networks, Vol.\n \
    \              14, pp. 325-336, 1984.\n   [RFC4593]   Barbir, A., Murphy, S.,\
    \ and Y. Yang, \"Generic Threats to\n               Routing Protocols\", RFC 4593,\
    \ October 2006.\n"
- title: Appendix A.  Packet Formats
  contents:
  - 'Appendix A.  Packet Formats

    '
- title: A.1.  Options Field
  contents:
  - "A.1.  Options Field\n   The L bit of the OSPF options field is used for link-local\
    \ signaling,\n   as described in [RFC5613].  Routers set the L bit in Hello and\
    \ DD\n   packets to indicate that the packet contains an LLS data block.\n   Routers\
    \ set the L bit in a self-originated router-LSA to indicate\n   that the LSA is\
    \ non-ackable.\n"
- title: A.2.  Link-Local Signaling
  contents:
  - "A.2.  Link-Local Signaling\n   OSPF-MDR uses link-local signaling [RFC5613] to\
    \ append the MDR-Hello\n   TLV and MDR-Metric TLV to Hello packets, and to append\
    \ the MDR-DD TLV\n   to Database Description packets.  Link-local signaling is\
    \ an\n   extension of OSPFv2 and OSPFv3 that allows the exchange of arbitrary\n\
    \   data using existing OSPF packet types.  Here we use LLS for OSPFv3,\n   which\
    \ is accomplished by adding an LLS data block at the end of the\n   OSPFv3 packet.\
    \  The OSPF packet length field does not include the\n   length of the LLS data\
    \ block, but the IPv6 packet length does include\n   this length.\n"
- title: A.2.1.  LLS Data Block
  contents:
  - "A.2.1.  LLS Data Block\n   The data block used for link-local signaling is formatted\
    \ as\n   described below in Figure A.1.\n        0                   1       \
    \            2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |       LLS Data Length         |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                                                               |\n      \
    \ |                           LLS TLVs                            |\n       .\
    \                                                               .\n       .  \
    \                                                             .\n       .    \
    \                                                           .\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure A.1: Format of LLS Data Block\n   The Checksum field\
    \ contains the standard IP checksum of the entire\n   contents of the LLS block.\n\
    \   The 16-bit LLS Data Length field contains the length (in 32-bit\n   words)\
    \ of the LLS block including the header and payload.\n   Implementations should\
    \ not use the Length field in the IPv6 packet\n   header to determine the length\
    \ of the LLS data block.\n   The rest of the block contains a set of Type/Length/Value\
    \ (TLV)\n   triplets as described in the following section.  All TLVs must be\n\
    \   32-bit aligned (with padding if necessary).\n"
- title: A.2.2.  LLS TLV Format
  contents:
  - "A.2.2.  LLS TLV Format\n   The contents of the LLS data block are constructed\
    \ using TLVs.  See\n   Figure A.2 for the TLV format.\n   The Type field contains\
    \ the TLV ID, which is unique for each type of\n   TLV.  The Length field contains\
    \ the length of the Value field (in\n   bytes) that is variable and contains arbitrary\
    \ data.\n        0                   1                   2                   3\n\
    \        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   \
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     \
    \  |            Type               |           Length              |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                                                               |\n  \
    \     .                                                               .\n    \
    \   .                             Value                             .\n      \
    \ .                                                               .\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        Figure A.2: Format of LLS TLVs\n   Note that TLVs are\
    \ always padded to a 32-bit boundary, but padding\n   bytes are not included in\
    \ the TLV Length field (though they are\n   included in the LLS Data Length field\
    \ of the LLS block header).  All\n   unknown TLVs MUST be silently ignored.\n"
- title: A.2.3.  MDR-Hello TLV
  contents:
  - "A.2.3.  MDR-Hello TLV\n   The MDR-Hello TLV is appended to each MANET Hello using\
    \ LLS.  It\n   includes the current Hello sequence number (HSN) for the transmitting\n\
    \   interface and the number of neighbors of each type that are listed in\n  \
    \ the body of the Hello (see Section 4.1).  It also indicates whether\n   the\
    \ Hello is differential (via the D-bit), and whether the router is\n   using full-topology\
    \ adjacencies (via the A-bit).\n       0                   1                 \
    \  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |            Type               |           Length              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \    Hello Sequence Number      |          Reserved         |A|D|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |      N1       |      N2       |      N3       |      N4       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   o  Type:\
    \ Set to 14.\n   o  Length: Set to 8.\n   o  Hello Sequence Number: A circular\
    \ two-octet unsigned integer\n      indicating the current HSN for the transmitting\
    \ interface.  The\n      HSN for the interface is incremented by 1 (modulo 2^16)\
    \ every time\n      a (differential or full) Hello is sent on the interface.\n\
    \   o  Reserved: Set to 0.  Reserved for future use.\n   o  A (1 bit): Set to\
    \ 1 if AdjConnectivity is 0; otherwise, set to 0.\n   o  D (1 bit): Set to 1 for\
    \ a differential Hello and 0 for a full\n      Hello.\n   o  N1 (8 bits): The\
    \ number of neighbors listed in the Hello that are\n      in state Down.  N1 is\
    \ zero if the Hello is not differential.\n   o  N2 (8 bits): The number of neighbors\
    \ listed in the Hello that are\n      in state Init.\n   o  N3 (8 bits): The number\
    \ of neighbors listed in the Hello that are\n      Dependent.\n   o  N4 (8 bits):\
    \ The number of neighbors listed in the Hello that are\n      Selected Advertised\
    \ Neighbors.\n"
- title: A.2.4.  MDR-DD TLV
  contents:
  - "A.2.4.  MDR-DD TLV\n   When a Database Description packet is sent to a neighbor\
    \ in state\n   ExStart, an MDR-DD TLV is appended to the packet using LLS.  It\n\
    \   includes the same two Router IDs that are included in the DR and\n   Backup\
    \ DR fields of a Hello sent by the router, and is used to\n   indicate the router's\
    \ MDR Level and Parent(s).\n       0                   1                   2 \
    \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |            Type               |           Length              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                               DR                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           Backup DR                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+\n   o  Type:\
    \ Set to 15.\n   o  Length: Set to 8.\n   o  DR: The same Router ID that is included\
    \ in the DR field of a Hello\n      sent by the router (see Section A.3).\n  \
    \ o  Backup DR: The same Router ID that is included in the Backup DR\n      field\
    \ of a Hello sent by the router (see Section A.3).\n"
- title: A.2.5.  MDR-Metric TLV
  contents:
  - "A.2.5.  MDR-Metric TLV\n   If LSAFullness is 1 or 2, an MDR-Metric TLV must be\
    \ appended to each\n   MANET Hello packet using LLS, unless all link metrics are\
    \ 1.  This\n   TLV advertises the link metric for each bidirectional neighbor\
    \ listed\n   in the body of the Hello.  At a minimum, this TLV advertises a single\n\
    \   default metric.  If the I bit is set, the Router ID and link metric\n   are\
    \ included for each bidirectional neighbor listed in the body of\n   the Hello\
    \ whose link metric is not equal to the default metric.  This\n   option reduces\
    \ overhead when all neighbors have the same link metric,\n   or only a few neighbors\
    \ have a link metric that differs from the\n   default metric.  If the I bit is\
    \ zero, the link metric is included\n   for each bidirectional neighbor that is\
    \ listed in the body of the\n   Hello and the neighbor RIDs are omitted from the\
    \ TLV.\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \            Type               |           Length              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |      Default Metric           |        Reserved             |I|\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                        Neighbor ID (1)                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        Neighbor ID (2)                        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                             ...                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |         Metric (1)            |        Metric (2)             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \           ...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o  Type: Set to 16.\n   o  Length: Set to 4 + 6*N if the I bit is 1, and to\
    \ 4 + 2*N if the I\n      bit is 0, where N is the number of neighbors included\
    \ in the TLV.\n   o  Default Metric: If the I bit is 1, this is the link metric\
    \ that\n      applies to every bidirectional neighbor listed in the body of the\n\
    \      Hello whose RID is not listed in the Metric TLV.\n   o  Neighbor ID: If\
    \ the I bit is 1, the RID is listed for each\n      bidirectional neighbor (Lists\
    \ 3 through 5 as defined in Section\n      4.1) in the body of the Hello whose\
    \ link metric is not equal to\n      the default metric.  Omitted if the I bit\
    \ is 0.\n   o  Metric: Link metric for each bidirectional neighbor, listed in\
    \ the\n      same order as the Neighbor IDs in the TLV if the I bit is 1, and\n\
    \      in the same order as the Neighbor IDs of bidirectional neighbors\n    \
    \  (Lists 3 through 5 as defined in Section 4.1) in the body of the\n      Hello\
    \ if the I bit is 0.\n"
- title: A.3.  Hello Packet DR and Backup DR Fields
  contents:
  - "A.3.  Hello Packet DR and Backup DR Fields\n   The Designated Router (DR) and\
    \ Backup DR fields of a Hello packet are\n   set as follows:\n   o  DR:  This\
    \ field is the router's Parent, or is 0.0.0.0 if the\n      Parent is null.  The\
    \ Parent of an MDR is always the router's own\n      RID.\n   o  Backup DR:  This\
    \ field is the router's Backup Parent, or is\n      0.0.0.0 if the Backup Parent\
    \ is null.  The Backup Parent of a BMDR\n      is always the router's own RID.\n"
- title: A.4.  LSA Formats and Examples
  contents:
  - "A.4.  LSA Formats and Examples\n   LSA formats are specified in [RFC5340], Section\
    \ 4.4.  Figure A.3\n   below gives an example network map for a MANET in a single\
    \ area.\n   o  Four MANET routers RT1, RT2, RT3, and RT4 are in area 1.\n   o\
    \  RT1's MANET interface has links to RT2 and RT3's MANET interfaces.\n   o  RT2's\
    \ MANET interface has links to RT1 and RT3's MANET interfaces.\n   o  RT3's MANET\
    \ interface has links to RT1, RT2, and RT3's MANET\n      interfaces.\n   o  RT4's\
    \ MANET interface has a link to RT3's MANET interface.\n   o  RT1 and RT2 have\
    \ stub networks attached on broadcast interfaces.\n   o  RT3 has a transit network\
    \ attached on a broadcast interface.\n       ..........................................\n\
    \       .                                  Area 1.\n       .     +           \
    \                       .\n       .     |                                  .\n\
    \       .     |  2+---+1                      1+---+\n       .  N1 |---|RT1|----+\
    \               +---|RT4|----\n       .     |   +---+    |\\             /   \
    \ +---+\n       .     |            | \\           /       .\n       .     +  \
    \          |  \\   N3    /        .\n       .                  |   \\       /\
    \         .\n       .     +            |    \\     /          .\n       .    \
    \ |            |     \\   /           .\n       .     |  2+---+1   |      \\ /\
    \            .\n       .  N2 |---|RT2|----+-------+             .\n       .  \
    \   |   +---+            |1            .\n       .     |                  +---+\
    \           .\n       .     |                  |RT3|----------------\n       .\
    \     +                  +---+           .\n       .                         \
    \ |2            .\n       .                   +------------+       .\n       .\
    \                      |1   N4           .\n       .                    +---+\
    \               .\n       .                    |RT5|               .\n       .\
    \                    +---+               .\n       ..........................................\n\
    \       Figure A.3: Area 1 with IP Addresses Shown\n      Network   IPv6 prefix\n\
    \      -----------------------------------\n      N1        5f00:0000:c001:0200::/56\n\
    \      N2        5f00:0000:c001:0300::/56\n      N4        5f00:0000:c001:0400::/56\n\
    \      Table 1: IPv6 link prefixes for sample network\n      Router     interface\
    \   Interface ID  IPv6 global unicast prefix\n      -----------------------------------------------------------\n\
    \      RT1      LOOPBACK      0             5f00:0001::/64\n               to\
    \ N3         1             n/a\n               to N1         2             5f00:0000:c001:0200::RT1/56\n\
    \      RT2      LOOPBACK      0             5f00:0002::/64\n               to\
    \ N3         1             n/a\n               to N2         2             5f00:0000:c001:0300::RT2/56\n\
    \      RT3      LOOPBACK      0             5f00:0003::/64\n               to\
    \ N3         1             n/a\n               to N4         2             5f00:0000:c001:0400::RT3/56\n\
    \      RT4      LOOPBACK      0             5f00:0004::/64\n               to\
    \ N3         1             n/a\n      RT5      to N4         1             5f00:0000:c001:0400::RT5/56\n\
    \      Table 2: IPv6 link prefixes for sample network\n      Router   interface\
    \   Interface ID   link-local address\n      -------------------------------------------------------\n\
    \      RT1      LOOPBACK    0              n/a\n               to N1       1 \
    \             fe80:0001::RT1\n               to N3       2              fe80:0002::RT1\n\
    \      RT2      LOOPBACK    0              n/a\n               to N2       1 \
    \             fe80:0001::RT2\n               to N3       2              fe80:0002::RT2\n\
    \      RT3      LOOPBACK    0              n/a\n               to N3       1 \
    \             fe80:0001::RT3\n               to N4       2              fe80:0002::RT3\n\
    \      RT4      LOOPBACK    0              n/a\n               to N3       1 \
    \             fe80:0001::RT4\n      RT5      to N4       1              fe80:0002::RT5\n\
    \      Table 3: OSPF interface IDs and link-local addresses\n"
- title: A.4.1.  Router-LSAs
  contents:
  - "A.4.1.  Router-LSAs\n   As an example, consider the router-LSA that node RT3\
    \ would originate.\n   The node consists of one MANET, one broadcast, and one\
    \ loopback\n   interface.\n   RT3's router-LSA\n   LS age = DoNotAge+0       \
    \       ;newly originated\n   LS type = 0x2001                 ;router-LSA\n \
    \  Link State ID = 0                ;first fragment\n   Advertising Router = 192.1.1.3\
    \   ;RT3's Router ID\n   bit E = 0                        ;not an AS boundary\
    \ router\n   bit B = 1                        ;area border router\n   Options\
    \ = (V6-bit|E-bit|R-bit)\n     Type = 1                        ;p2p link to RT1\n\
    \     Metric = 1                      ;cost to RT1\n     Interface ID = 1    \
    \            ;Interface ID\n     Neighbor Interface ID = 1       ;Interface ID\n\
    \     Neighbor Router ID = 192.1.1.1  ;RT1's Router ID\n     Type = 1        \
    \                ;p2p link to RT2\n     Metric = 1                      ;cost\
    \ to RT2\n     Interface ID = 1                ;Interface ID\n     Neighbor Interface\
    \ ID = 1       ;Interface ID\n     Neighbor Router ID = 192.1.1.2  ;RT2's Router\
    \ ID\n     Type = 1                        ;p2p link to RT4\n     Metric = 1 \
    \                     ;cost to RT4\n     Interface ID = 1                ;Interface\
    \ ID\n     Neighbor Interface ID = 1       ;Interface ID\n     Neighbor Router\
    \ ID = 192.1.1.4  ;RT4's Router ID\n     Type = 2                        ;connects\
    \ to N4\n     Metric = 1                      ;cost to N4\n     Interface ID =\
    \ 2                ;RT3's Interface ID\n     Neighbor Interface ID = 1       ;RT5's\
    \ Interface ID (elected DR)\n     Neighbor Router ID = 192.1.1.5  ;RT5's Router\
    \ ID  (elected DR)\n"
- title: A.4.2.  Link-LSAs
  contents:
  - "A.4.2.  Link-LSAs\n   Consider the link-LSA that RT3 would originate for its\
    \ MANET\n   interface.\n   RT3's link-LSA for its MANET interface\n   LS age =\
    \ DoNotAge+0              ;newly originated\n   LS type = 0x0008             \
    \    ;Link-LSA\n   Link State ID = 1                ;Interface ID\n   Advertising\
    \ Router = 192.1.1.3   ;RT3's Router ID\n   RtrPri = 1                       ;default\
    \ priority\n   Options = (V6-bit|E-bit|R-bit)\n   Link-local Interface Address\
    \ = fe80:0001::RT3\n   # prefixes = 0                   ;no global unicast address\n"
- title: A.4.3.  Intra-Area-Prefix-LSAs
  contents:
  - "A.4.3.  Intra-Area-Prefix-LSAs\n   A MANET node originates an intra-area-prefix-LSA\
    \ to advertise its own\n   prefixes, and those of its attached networks or stub\
    \ links.  As an\n   example, consider the intra-area-prefix-LSA that RT3 will\
    \ build.\n   RT2's intra-area-prefix-LSA for its own prefixes\n   LS age = DoNotAge+0\
    \              ;newly originated\n   LS type = 0x2009                 ;intra-area-prefix-LSA\n\
    \   Link State ID = 177              ;or something\n   Advertising Router = 192.1.1.3\
    \   ;RT3's Router ID\n   # prefixes = 2\n   Referenced LS type = 0x2001      ;router-LSA\
    \ reference\n   Referenced Link State ID = 0     ;always 0 for router-LSA reference\n\
    \   Referenced Advertising Router = 192.1.1.3 ;RT2's Router ID\n     PrefixLength\
    \ = 64               ;prefix on RT3's LOOPBACK\n     PrefixOptions = 0\n     Metric\
    \ = 0                      ;cost of RT3's LOOPBACK\n     Address Prefix = 5f00:0003::/64\n\
    \     PrefixLength = 56               ;prefix on RT3's interface 2\n     PrefixOptions\
    \ = 0\n     Metric = 1                      ;cost of RT3's interface 2\n     Address\
    \ Prefix = 5f00:0000:c001:0400::RT3/56    ;pad\n"
- title: Appendix B.  Detailed Algorithms for MDR/BMDR Selection
  contents:
  - "Appendix B.  Detailed Algorithms for MDR/BMDR Selection\n   This section provides\
    \ detailed algorithms for Step 2.4 of Phase 2\n   (MDR selection) and Step 3.2\
    \ of Phase 3 (BMDR selection) of the MDR\n   selection algorithm described in\
    \ Section 5.  Step 2.4 uses a breadth-\n   first search (BFS) algorithm, and Step\
    \ 3.2 uses an efficient\n   algorithm for finding pairs of node-disjoint paths\
    \ from Rmax to all\n   other neighbors.  Both algorithms run in O(d^2) time, where\
    \ d is the\n   number of neighbors.\n   For convenience, in the following description,\
    \ the term \"bi-neighbor\"\n   will be used as an abbreviation for \"bidirectional\
    \ neighbor\".  Also,\n   node i denotes the router performing the calculation.\n"
- title: B.1.  Detailed Algorithm for Step 2.4 (MDR Selection)
  contents:
  - "B.1.  Detailed Algorithm for Step 2.4 (MDR Selection)\n   The following algorithm\
    \ performs Step 2.4 of the MDR selection\n   algorithm, and assumes that Phase\
    \ 1 and Steps 2.1 through 2.3 have\n   been performed, so that the neighbor connectivity\
    \ matrix NCM has been\n   computed and Rmax is the bi-neighbor with the (lexicographically)\n\
    \   largest value of (RtrPri, MDR Level, RID).  The BFS algorithm uses a\n   FIFO\
    \ queue so that all nodes 1 hop from node Rmax are processed\n   first, then 2\
    \ hops, etc.  When the BFS algorithm terminates, hops(u),\n   for each bi-neighbor\
    \ node u of node i, will be equal to the minimum\n   number of hops from node\
    \ Rmax to node u, using only intermediate\n   nodes that are bi-neighbors of node\
    \ i and that have a larger value of\n   (RtrPri, MDR Level, RID) than node i.\
    \  The algorithm also computes,\n   for each node u, the tree parent p(u) and\
    \ the second node r(u) on the\n   tree path from Rmax to u, which will be used\
    \ in Step 3.2.\n   (a)  Compute a matrix of link costs c(u,v) for each pair of\
    \ bi-\n        neighbors u and v as follows: If node u has a larger value of\n\
    \        (RtrPri, MDR Level, RID) than node i, and NCM(u,v) = 1, then set\n  \
    \      c(u,v) to 1.  Otherwise, set c(u,v) to infinity.  (Note that the\n    \
    \    matrix NCM(u,v) is symmetric, but the matrix c(u,v) is not.)\n   (b)  Set\
    \ hops(u) = infinity for all bi-neighbors u other than Rmax,\n        and set\
    \ hops(Rmax) = 0.  Initially, p(u) is undefined for each\n        neighbor u.\
    \  For each bi-neighbor u such that c(Rmax,u) = 1, set\n        r(u) = u; for\
    \ all other u, r(u) is initially undefined.  Add\n        node Rmax to the FIFO\
    \ queue.\n   (c)  While the FIFO queue is nonempty:  Remove the node at the head\n\
    \        of the queue; call it node u.  For each bi-neighbor v of node i\n   \
    \     such that c(u,v) = 1:\n          If hops(v) > hops(u) + 1, then set hops(v)\
    \ = hops(u) + 1, set\n          p(v) = u, set r(v) = r(u) if hops(v) > 1, and\
    \ add node v to\n          the tail of the queue.\n"
- title: B.2.  Detailed Algorithm for Step 3.2 (BMDR Selection)
  contents:
  - "B.2.  Detailed Algorithm for Step 3.2 (BMDR Selection)\n   Step 3.2 of the MDR\
    \ selection algorithm requires the router to\n   determine whether there exist\
    \ two node-disjoint paths from Rmax to\n   each other bi-neighbor u, via bi-neighbors\
    \ that have a larger value\n   of (RtrPri, MDR Level, RID) than the router itself.\
    \  This information\n   is needed to determine whether the router should select\
    \ itself as a\n   BMDR.\n   It is possible to determine separately for each bi-neighbor\
    \ u whether\n   there exist two node-disjoint paths from Rmax to u, using the\
    \ well-\n   known augmenting path algorithm [Lawler] that runs in O(n^2) time,\n\
    \   but this must be done for all bi-neighbors u, thus requiring a total\n   run\
    \ time of O(n^3).  The algorithm described below makes the same\n   determination\
    \ simultaneously for all bi-neighbors u, achieving a much\n   faster total run\
    \ time of O(n^2).  The algorithm is a simplified\n   variation of the Suurballe-Tarjan\
    \ algorithm [Suurballe] for finding\n   pairs of disjoint paths.\n   The algorithm\
    \ described below uses the following output of Phase 2:\n   the tree parent p(u)\
    \ of each node (which defines the BFS tree\n   computed in Phase 2), and the second\
    \ node r(u) on the tree path from\n   Rmax to u.\n   The algorithm uses the following\
    \ concepts.  For any node u on the BFS\n   tree other than Rmax, we define g(u)\
    \ to be the first labeled node on\n   the reverse tree path from u to Rmax, if\
    \ such a labeled node exists\n   other than Rmax.  (The reverse tree path consists\
    \ of u, p(u),\n   p(p(u)), ..., Rmax.)  If no such labeled node exists, then g(u)\
    \ is\n   defined to be r(u).  In particular, if u is labeled then g(u) = u.\n\
    \   Note that g(u) either must be labeled or must be a neighbor of Rmax.\n   For\
    \ any node k that either is labeled or is a neighbor of Rmax, we\n   define the\
    \ unlabeled subtree rooted at k, denoted S(k), to be the set\n   of nodes u such\
    \ that g(u) = k.  Thus, S(k) includes node k itself and\n   the set of unlabeled\
    \ nodes downstream of k on the BFS tree that can\n   be reached without going\
    \ through any labeled nodes.  This set can be\n   obtained in linear time using\
    \ a depth-first search starting at node\n   k, and using labeled nodes to indicate\
    \ the boundaries of the search.\n   Note that g(u) and S(k) are not maintained\
    \ as variables in the\n   algorithm given below, but simply refer to the definitions\
    \ given\n   above.\n   The BMDR algorithm maintains a set B, which is initially\
    \ empty.  A\n   node u is added to B when it is known that two node-disjoint paths\n\
    \   exist from Rmax to u via nodes that have a larger value of (RtrPri,\n   MDR\
    \ Level, RID) than the router itself.  When the algorithm\n   terminates, B consists\
    \ of all nodes that have this property.\n   The algorithm consists of the following\
    \ two steps.\n   (a) Mark Rmax as labeled.  For each pair of nodes u, v on the\
    \ BFS\n       tree other than Rmax such that r(u) is not equal to r(v) (i.e.,\
    \ u\n       and v have different second nodes), NCM(u,v) = 1, and node u has\n\
    \       a greater value of (RtrPri, MDR level, RID) than the router\n       itself,\
    \ add v to B.  (Clearly there are two disjoint paths from\n       Rmax to v.)\n\
    \   (b) While there exists a node in B that is not labeled, do the\n       following.\
    \  Choose any node k in B that is not labeled, and let j\n       = g(k).  Now\
    \ mark k as labeled. (This creates a new unlabeled\n       subtree S(k), and makes\
    \ S(j) smaller by removing S(k) from it.)\n       For each pair of nodes u, v\
    \ such that u is in S(k), v is in S(j),\n       and NCM(u,v) = 1:\n       o  If\
    \ u has a larger value of (RtrPri, MDR level, RID) than the\n          router\
    \ itself, and v is not in B, then add v to B.\n       o  If v has a larger value\
    \ of (RtrPri, MDR level, RID) than the\n          router itself, and u is not\
    \ in B, then add u to B.\n   A simplified version of the algorithm MAY be performed\
    \ by omitting\n   step (b).  However, the simplified algorithm will result in\
    \ more\n   BMDRs, and is not recommended if AdjConnectivity = 2 since it will\n\
    \   result in more adjacencies.\n   The above algorithm can be executed in O(n^2)\
    \ time, where n is the\n   number of neighbors.  Step (a) clearly requires O(n^2)\
    \ time since it\n   considers all pairs of nodes u and v.  Step (b) also requires\
    \ O(n^2)\n   time because each pair of nodes is considered at most once.  This\
    \ is\n   because labeling nodes divides unlabeled subtrees into smaller\n   unlabeled\
    \ subtrees, and a given pair u, v is considered only the\n   first time u and\
    \ v belong to different unlabeled subtrees.\n"
- title: Appendix C.  Min-Cost LSA Algorithm
  contents:
  - "Appendix C.  Min-Cost LSA Algorithm\n   This section describes the algorithm\
    \ for determining which MANET\n   neighbors to include in the router-LSA when\
    \ LSAFullness is 1.  The\n   min-cost LSA algorithm ensures that the link-state\
    \ database provides\n   sufficient information to calculate at least one shortest\
    \ (minimum-\n   cost) path to each destination.  The algorithm assumes that a\
    \ router\n   may have multiple interfaces, at least one of which is a MANET\n\
    \   interface.  The algorithm becomes significantly simpler if the router\n  \
    \ has only a single (MANET) interface.\n   The input to this algorithm includes\
    \ information obtained from Hellos\n   received from each neighbor on each MANET\
    \ interface, including the\n   neighbor's Bidirectional Neighbor Set (BNS), Dependent\
    \ Neighbor Set\n   (DNS), Selected Advertised Neighbor Set (SANS), and link metrics.\n\
    \   The input also includes the link-state database if the router has a\n   non-MANET\
    \ interface.\n   The output of the algorithm is the router's SANS for each MANET\n\
    \   interface.  The SANS is used to construct the router-LSA as described\n  \
    \ in Section 9.4.  The min-cost LSA algorithm must be run to update the\n   SANS\
    \ (and possibly originate a new router-LSA) either periodically\n   just before\
    \ sending each Hello, or whenever any of the following\n   events occurs:\n  \
    \ o  The state or routability of a neighbor changes.\n   o  A Hello received from\
    \ a neighbor indicates a change in its MDR\n      Level, Router Priority, FullHelloRcvd,\
    \ BNS, DNS, SANS, Parent(s),\n      or link metrics.\n   o  An LSA originated\
    \ by a non-MANET neighbor is received.\n   Although the algorithm described below\
    \ runs in O(d^3) time, where d\n   is the number of neighbors, an incremental\
    \ version for a single\n   topology change runs in O(d^2) time, as discussed following\
    \ the\n   algorithm description.\n   For convenience, in the following description,\
    \ the term \"bi-neighbor\"\n   will be used as an abbreviation for \"bidirectional\
    \ neighbor\".  Also,\n   router i will denote the router doing the calculation.\
    \  To perform\n   the min-cost LSA algorithm, the following steps are performed.\n\
    \   (1) Create the neighbor connectivity matrix (NCM) for each MANET\n       interface,\
    \ as described in Section 5.1.  Create the multiple-\n       interface neighbor\
    \ connectivity matrix MNCM as follows.  For each\n       bi-neighbor j, set MNCM(i,j)\
    \ = MNCM(j,i) = 1.  For each pair j, k\n       of MANET bi-neighbors, set MNCM(j,k)\
    \ = 1 if NCM(j,k) equals 1 for\n       any MANET interface.  For each pair j,\
    \ k of non-MANET bi-\n       neighbors, set MNCM(j,k) = 1 if the link-state database\
    \ indicates\n       that a direct link exists between j and k.  Otherwise, set\n\
    \       MNCM(j,k) = 0.  (Note that a given router can be a neighbor on\n     \
    \  both a MANET interface and a non-MANET interface.)\n   (2) Create the inter-neighbor\
    \ cost matrix (COST) as follows.  For\n       each pair j, k of routers such that\
    \ each of j and k is a bi-\n       neighbor or router i itself:\n       (a) If\
    \ MNCM(j,k) = 1, set COST(j,k) to the metric of the link\n           from j to\
    \ k obtained from j's Hellos (for a MANET interface),\n           or from the\
    \ link-state database (for a non-MANET interface).\n           If there are multiple\
    \ links from j to k (via multiple\n           interfaces), COST(j,k) is set to\
    \ the minimum cost of these\n           links.\n       (b) Otherwise, set COST(j,k)\
    \ to LSInfinity.\n   (3) Create the backbone neighbor matrix (BNM) as follows.\
    \  BNM\n       indicates which pairs of MANET bi-neighbors are backbone\n    \
    \   neighbors of each other, as defined in Section 9.2.1.  If\n       adjacency\
    \ reduction is not used (AdjConnectivity = 0), set all\n       entries of BNM\
    \ to zero and proceed to Step 4.\n       In the following, if a link exists from\
    \ router j to router k on\n       more than one interface, we consider only interfaces\
    \ for which\n       the cost from j to k equals COST(j,k); such interfaces will\
    \ be\n       called \"candidate\" interfaces.\n       For each pair j, k of MANET\
    \ bi-neighbors, BNM(j,k) is set to 1 if\n       j and k are backbone neighbors\
    \ of each other on a candidate MANET\n       interface.  That is, BNM(j,k) is\
    \ set to 1 if, for any candidate\n       MANET interface, NCM(j,k) = 1 and either\
    \ of the following\n       conditions is satisfied:\n       (a) Router k is included\
    \ in j's DNS or router j is included in\n           k's DNS.\n       (b) Router\
    \ j is the (Backup) Parent of router k or router k is\n           the (Backup)\
    \ Parent of router j.\n       Otherwise, BNM(j,k) is set to 0.\n   (4) Create\
    \ the Selected Advertised Neighbor Matrix (SANM) as follows.\n       For each\
    \ pair j, k of routers such that each of j and k is a bi-\n       neighbor or\
    \ router i itself, SANM(j,k) is set to 1 if, for any\n       candidate MANET interface,\
    \ NCM(j,k) = 1 and k is included in j's\n       SANS.  Otherwise, SANM(j,k) is\
    \ set to 0.  Note that SANM(i,k) is\n       set to 1 if k is currently a Selected\
    \ Advertised Neighbor.\n   (5) Compute the new set of Selected Advertised Neighbors\
    \ as follows.\n       For each MANET bi-neighbor j, initialize the bit variable\n\
    \       new_sel_adv(j) to 0. (This bit will be set to 1 if j is\n       selected.)\
    \  For each MANET bi-neighbor j:\n       (a) If j is a bi-neighbor on more than\
    \ one interface, consider\n           only candidate interfaces (for which the\
    \ cost to j is\n           minimum).  If one of the candidate interfaces is a\
    \ non-MANET\n           interface, examine the next neighbor (j is not selected\
    \ since\n           it will be advertised anyway).\n       (b) If adjacency reduction\
    \ is used, and one of the candidate\n           interfaces is a MANET interface\
    \ on which j is a backbone\n           neighbor (see Section 9.2), examine the\
    \ next neighbor (j is\n           not selected since it will be advertised anyway).\n\
    \       (c) Otherwise, if there is more than one candidate MANET\n           interface,\
    \ select the \"preferred\" interface by using the\n           following preference\
    \ rules in the given order: an interface\n           is preferred if (1) router\
    \ i's SANS for that interface\n           already includes j, (2) router i's Router\
    \ Priority is larger\n           on that interface, and (3) router i's MDR Level\
    \ is larger on\n           that interface.\n       (d) For each bi-neighbor k\
    \ (on any interface) such that COST(k,j)\n           > COST(k,i) + COST(i,j),\
    \ determine whether there exists\n           another bi-neighbor u such that either\
    \ COST(k,u) + COST(u,j)\n           < COST(k,i) + COST(i,j), or COST(k,u) + COST(u,j)\
    \ = COST(k,i)\n           + COST(i,j) and either of the following conditions is\
    \ true:\n           o  BNM(u,j) = 1, or\n           o  (SANM(j,u), SANM(u,j),\
    \ RtrPri(u), RID(u)) is\n              lexicographically greater than (SANM(j,i),\
    \ SANM(i,j),\n              RtrPri(i), RID(i)).\n       If for some such bi-neighbor\
    \ k, there does not exist such a bi-\n       neighbor u, then set new_sel_adv(j)\
    \ = 1.\n   (6) For each MANET interface I, update the SANS to equal the set of\n\
    \       all bi-neighbors j such that new_sel_adv(j) = 1 and I is the\n       preferred\
    \ interface for j.\n   (7) With the SANS updated, a new router-LSA may need to\
    \ be originated\n       as described in Section 9.4.\n   The lexicographical comparison\
    \ of Step 5d gives preference to links\n   that are already advertised, in order\
    \ to improve LSA stability.\n   The above algorithm can be run in O(d^2) time\
    \ if a single link change\n   occurs.  For example, if link (x,y) fails where\
    \ x and y are neighbors\n   of router i, and either SANS(x,y) = 1 or BNM(x,y)\
    \ = 1, then Step 5\n   need only be performed for pairs j, k such that either\
    \ j or k is\n   equal to x or y.\n"
- title: Appendix D.  Non-Ackable LSAs for Periodic Flooding
  contents:
  - "Appendix D.  Non-Ackable LSAs for Periodic Flooding\n   In a highly mobile network,\
    \ it is possible that a router almost\n   always originates a new router-LSA every\
    \ MinLSInterval seconds.  In\n   this case, it should not be necessary to send\
    \ Acks for such an LSA,\n   or to retransmit such an LSA as a unicast, or to describe\
    \ such an LSA\n   in a DD packet.  In this case, the originator of an LSA MAY\
    \ indicate\n   that the router-LSA is \"non-ackable\" by setting the L bit in\
    \ the\n   options field of the LSA (see Section A.1).  For example, a router\n\
    \   can originate non-ackable LSAs if it determines (e.g., based on an\n   exponential\
    \ moving average) that a new LSA is originated every\n   MinLSInterval seconds\
    \ at least 90 percent of the time. (Simulations\n   can be used to determine the\
    \ best threshold.)\n   A non-ackable LSA is never acknowledged, nor is it ever\
    \ retransmitted\n   as a unicast or described in a DD packet, thus saving substantial\n\
    \   overhead.  However, the originating router must periodically\n   retransmit\
    \ the current instance of its router-LSA as a multicast\n   (until it originates\
    \ a new LSA, which will usually happen before the\n   previous instance is retransmitted),\
    \ and each MDR must periodically\n   retransmit each non-ackable LSA as a multicast\
    \ (until it receives a\n   new instance of the LSA, which will usually happen\
    \ before the\n   previous instance is retransmitted).  For this option to work,\n\
    \   RxmtInterval must be larger than MinLSInterval so that a new instance\n  \
    \ of the LSA is usually received before the previous one is\n   retransmitted.\
    \  Note that the reception of a retransmitted\n   (duplicate) LSA does not result\
    \ in immediate forwarding of the LSA;\n   only a new LSA (with a larger sequence\
    \ number) may be forwarded\n   immediately, according to the flooding procedure\
    \ of Section 8.\n"
- title: Appendix E.  Simulation Results
  contents:
  - "Appendix E.  Simulation Results\n   This section presents simulation results\
    \ that predict the performance\n   of OSPF-MDR for up to 160 nodes with min-cost\
    \ LSAs and up to 200\n   nodes with minimal LSAs.  The results were obtained using\
    \ the GTNetS\n   simulator with OSPF-MDR version 1.01, available at\n   http://hipserver.mct.phantomworks.org/ietf/ospf.\n\
    \   The following scenario parameter values were used: radio range = 200\n   m\
    \ and 250 m, grid length = 500 m, wireless alpha = 0.5, (maximum)\n   velocity\
    \ = 10 m/s, pause time = 0, packet rate = 10 pkts/s, packet\n   size = 40 bytes,\
    \ random seed = 8, start time (for gathering\n   statistics) = 1800 s.  The stop\
    \ time was 3600 s for up to 80 nodes\n   and 2700 s for more than 80 nodes.  The\
    \ source and destination are\n   selected randomly for each generated UDP packet.\
    \  The simulated MAC\n   protocol is 802.11b.\n   Tables 4 and 6 show the results\
    \ for the default configuration of\n   OSPF-MDR, except that differential Hellos\
    \ were used (2HopRefresh = 3)\n   since they are recommended when the number of\
    \ neighbors is large.\n   Tables 5 and 7 show the results for the same configuration\
    \ except\n   that minimal LSAs were used instead of min-cost LSAs.  The tables\n\
    \   show the results for total OSPF overhead in kb/s, the total number of\n  \
    \ OSPF packets per second, the delivery ratio for UDP packets, and the\n   average\
    \ number of hops traveled by UDP packets that reach their\n   destination.\n \
    \  Tables 5 and 7 for minimal LSAs also show the following statistics:\n   the\
    \ average number of bidirectional neighbors per node, the average\n   number of\
    \ fully adjacent neighbors per node, the number of changes in\n   the set of bidirectional\
    \ neighbors per node per second, and the\n   number of changes in the set of fully\
    \ adjacent neighbors per node per\n   second.  These statistics do not change\
    \ significantly when min-cost\n   LSAs are used instead of minimal LSAs.\n   The\
    \ results show that OSPF-MDR achieves good performance for up to at\n   least\
    \ 160 nodes when min-cost LSAs are used, and up to at least 200\n   nodes when\
    \ minimal LSAs are used.  Also, the results for the number\n   of hops show that\
    \ the routes obtained with minimal LSAs are only 2.3%\n   to 4.5% longer than\
    \ with min-cost LSAs when the range is 250 m, and\n   3.5% to 7.4% longer when\
    \ the range is 200 m.\n   The results also show that the number of adjacencies\
    \ per node and the\n   number of adjacency changes per node per second do not\
    \ increase as\n   the number of nodes increases, and are dramatically smaller\
    \ than the\n   number of neighbors per node and the number of neighbor changes\
    \ per\n   node per second, respectively.  These factors contribute to the low\n\
    \   overhead achieved by OSPF-MDR.  For example, the results in Table 5\n   imply\
    \ that with 200 nodes and range 250 m, there are 2.136/.039 = 55\n   times as\
    \ many adjacency formations with full-topology adjacencies as\n   with uniconnected\
    \ adjacencies.  Additional simulation results for\n   OSPF-MDR can be found at\
    \ http://www.manet-routing.org.\n                                      Number\
    \ of nodes\n                        20     40     60     80    100    120    160\n\
    \   ------------------------------------------------------------------\n   OSPF\
    \ kb/s           27.1   74.2  175.3  248.6  354.6  479.2  795.7\n   OSPF pkts/s\
    \         29.9   69.2  122.9  163.7  210.3  257.2  357.7\n   Delivery ratio  \
    \    .970   .968   .954   .958   .957   .956   .953\n   Avg no. hops       1.433\
    \  1.348  1.389  1.368  1.411  1.361  1.386\n   Table 4: Results for range 250\
    \ m with min-cost LSAs\n                                      Number of nodes\n\
    \                        20     40     60     80    120    160    200\n   ------------------------------------------------------------------\n\
    \   OSPF kb/s           15.5   41.6   91.0  132.9  246.3  419.0  637.4\n   OSPF\
    \ pkts/sec       18.8   42.5   78.6  102.8  166.8  245.6  321.0\n   Delivery ratio\
    \      .968   .968   .951   .953   .962   .956   .951\n   Avg no. hops       1.466\
    \  1.387  1.433  1.412  1.407  1.430  1.411\n   Avg no. nbrs/node  11.38  25.82\
    \  36.30  50.13  75.87  98.65 125.59\n   Avg no. adjs/node   2.60   2.32   2.38\
    \   2.26   2.25   2.32   2.13\n   Nbr changes/node/s  .173   .372   .575   .752\
    \  1.223  1.654  2.136\n   Adj changes/node/s  .035   .036   .046   .040   .032\
    \   .035   .039\n   Table 5: Results for range 250 m with minimal LSAs\n     \
    \                                 Number of nodes\n                        20\
    \     40     60     80    100    120    160\n   ------------------------------------------------------------------\n\
    \   OSPF kb/s           40.5  123.4  286.5  415.7  597.5  788.9 1309.8\n   OSPF\
    \ pkts/s         37.6   83.9  135.1  168.6  205.4  247.7  352.3\n   Delivery ratio\
    \      .926   .919   .897   .900   .898   .895   .892\n   Avg no. hops       1.790\
    \  1.628  1.666  1.632  1.683  1.608  1.641\n   Table 6: Results for range 200\
    \ m with min-cost LSAs\n                                      Number of nodes\n\
    \                        20     40     60     80    120    160    200\n   ------------------------------------------------------------------\n\
    \   OSPF kb/s           24.0   63.6  140.6  195.2  346.9  573.2  824.6\n   OSPF\
    \ pkts/sec       26.4   58.8  108.3  138.8  215.2  311.3  401.3\n   Delivery ratio\
    \      .930   .927   .897   .907   .907   .904   .902\n   Avg no. hops       1.853\
    \  1.714  1.771  1.743  1.727  1.758  1.747\n   Avg no. nbrs/node   7.64  18.12\
    \  25.27  35.29  52.99  68.13  86.74\n   Avg no. adjs/node   2.78   2.60   2.70\
    \   2.50   2.39   2.36   2.24\n   Nbr changes/node/s  .199   .482   .702   .959\
    \  1.525  2.017  2.611\n   Adj changes/node/s  .068   .069   .081   .068   .055\
    \   .058   .057\n   Table 7: Results for range 200 m with minimal LSAs\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Richard G. Ogier\n   SRI International\n   EMail: rich.ogier@earthlink.net\
    \ or rich.ogier@gmail.com\n   Phil Spagnolo\n   Boeing Phantom Works\n   EMail:\
    \ phillipspagnolo@gmail.com\n"
