- title: __initial_text__
  contents:
  - '             Hierarchical Service Function Chaining (hSFC)

    '
- title: Abstract
  contents:
  - "Abstract\n   Hierarchical Service Function Chaining (hSFC) is a network\n   architecture\
    \ allowing an organization to decompose a large-scale\n   network into multiple\
    \ domains of administration.\n   The goals of hSFC are to make a large-scale network\
    \ easier to design,\n   simpler to control, and supportive of independent functional\
    \ groups\n   within large network operators.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are candidates\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 7841.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8459.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Experiment Goals  . . . . . . . . . . . . . . . .\
    \ . . . .   5\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   6\n   3.  Hierarchical Service Function Chaining (hSFC) . . . . . .\
    \ . .   6\n     3.1.  Upper Level . . . . . . . . . . . . . . . . . . . . . .\
    \ .   6\n     3.2.  Lower Levels  . . . . . . . . . . . . . . . . . . . . . .\
    \   8\n   4.  Internal Boundary Node (IBN)  . . . . . . . . . . . . . . . .  10\n\
    \     4.1.  IBN Path Configuration  . . . . . . . . . . . . . . . . .  10\n  \
    \     4.1.1.  Flow-Stateful IBN . . . . . . . . . . . . . . . . . .  11\n    \
    \   4.1.2.  Encoding Upper-Level Paths in Metadata  . . . . . . .  12\n      \
    \ 4.1.3.  Using Unique Paths per Upper-Level Path . . . . . . .  13\n       4.1.4.\
    \  Nesting Upper-Level NSH within Lower-Level NSH  . . .  13\n       4.1.5.  Stateful/Metadata\
    \ Hybrid  . . . . . . . . . . . . . .  14\n     4.2.  Gluing Levels Together \
    \ . . . . . . . . . . . . . . . . .  16\n     4.3.  Decrementing Service Index\
    \  . . . . . . . . . . . . . . .  16\n     4.4.  Managing TTL  . . . . . . . .\
    \ . . . . . . . . . . . . . .  16\n   5.  Subdomain Classifier  . . . . . . .\
    \ . . . . . . . . . . . . .  17\n   6.  Control Plane Elements  . . . . . . .\
    \ . . . . . . . . . . . .  18\n   7.  Extension for Adapting to NSH-Unaware Service\
    \ Functions . . .  18\n     7.1.  Purpose . . . . . . . . . . . . . . . . . .\
    \ . . . . . . .  19\n     7.2.  Requirements for an IBN . . . . . . . . . . .\
    \ . . . . . .  20\n   8.  IANA Considerations . . . . . . . . . . . . . . . .\
    \ . . . . .  21\n   9.  Security Considerations . . . . . . . . . . . . . . .\
    \ . . . .  21\n     9.1.  Control Plane . . . . . . . . . . . . . . . . . . .\
    \ . . .  21\n     9.2.  Infinite Forwarding Loops . . . . . . . . . . . . . .\
    \ . .  22\n   10. References  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  22\n     10.1.  Normative References . . . . . . . . . . . . . . . . . .\
    \  22\n     10.2.  Informative References . . . . . . . . . . . . . . . . .  22\n\
    \   Appendix A.  Examples of Hierarchical Service Function Chaining .  24\n  \
    \   A.1.  Reducing the Number of Service Function Paths . . . . . .  24\n    \
    \ A.2.  Managing a Distributed DC Network . . . . . . . . . . . .  26\n   Acknowledgements\
    \  . . . . . . . . . . . . . . . . . . . . . . . .  28\n   Authors' Addresses\
    \  . . . . . . . . . . . . . . . . . . . . . . .  29\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Service Function Chaining (SFC) is a technique for prescribing\n\
    \   differentiated traffic-forwarding policies within an SFC-enabled\n   domain.\
    \  The SFC architecture is described in detail in [RFC7665] and\n   is not repeated\
    \ here.\n   This document focuses on the difficult problem of implementing SFC\n\
    \   across a large, geographically dispersed network, potentially\n   comprised\
    \ of millions of hosts and thousands of network-forwarding\n   elements and which\
    \ may involve multiple operational teams (with\n   varying functional responsibilities).\
    \  We recognize that some\n   stateful Service Functions (SFs) require bidirectional\
    \ traffic for\n   transport-layer sessions (e.g., NATs, firewalls).  We assume\
    \ that\n   some Service Function Paths (SFPs) need to be selected on the basis\n\
    \   of transport-layer coordinate (typically, the 5-tuple of source IP\n   address,\
    \ source port number, destination IP address, destination port\n   number, and\
    \ transport protocol) stickiness to specific stateful SF\n   instances.\n   Difficult\
    \ problems are often made easier by decomposing them in a\n   hierarchical (nested)\
    \ manner.  So, instead of considering a single\n   SFC control plane that can\
    \ manage (create, withdraw, supervise, etc.)\n   complete SFPs from one end of\
    \ the network to the other, we decompose\n   the network into smaller domains\
    \ operated by as many SFC control\n   plane components (under the same administrative\
    \ entity).\n   Coordination between such components is further discussed in this\n\
    \   document.\n   Each subdomain may support a subset of the network applications\
    \ or a\n   subset of the users.  Decomposing a network should be done with care\n\
    \   to ease monitoring and troubleshooting of the network and services as\n  \
    \ a whole.  The criteria for decomposing a domain into multiple SFC-\n   enabled\
    \ subdomains are beyond the scope of this document.  These\n   criteria are deployment\
    \ specific.\n   An example of simplifying a network by using multiple SFC-enabled\n\
    \   domains is further discussed in [USE-CASES].\n   We assume the SFC-aware nodes\
    \ use the Network Service Header (NSH)\n   [RFC8300] or a similar labeling mechanism.\
    \  Examples are described in\n   Appendix A.\n   The SFC-enabled domains discussed\
    \ in this document are assumed to be\n   under the control of a single organization\
    \ (an operator, typically),\n   such that there is a strong trust relationship\
    \ between the domains.\n   The intention of creating multiple domains is to improve\
    \ the ability\n   to operate a network.  It is outside of the scope of this document\
    \ to\n   consider domains operated by different organizations or dwell on\n  \
    \ interoperator considerations.\n   We introduce the concept of an Internal Boundary\
    \ Node (IBN) that acts\n   as a gateway between the levels of the hierarchy. \
    \ We also discuss\n   options for realizing this function.\n"
- title: 1.1.  Experiment Goals
  contents:
  - "1.1.  Experiment Goals\n   This document defines an architecture that aims to\
    \ solve\n   complications that may be encountered when deploying SFC in large\n\
    \   networks.  A single network is therefore decomposed into multiple\n   subdomains,\
    \ each treated as an SFC-enabled domain.  Levels of\n   hierarchy are defined,\
    \ together with SFC operations that are specific\n   to each level.  In order\
    \ to ensure consistent SFC operations when\n   multiple subdomains are involved,\
    \ this document identifies and\n   analyzes various options for IBNs to glue the\
    \ layers together\n   (Section 4.1).\n   Because it does not make any assumptions\
    \ about (1) how subdomains are\n   defined, (2) whether one or multiple IBNs are\
    \ enabled per subdomain,\n   (3) whether the same IBN is solicited at both the\
    \ ingress and egress\n   of a subdomain for the same flow, (4) the nature of the\
    \ internal\n   paths to reach SFs within a subdomain, or (5) the lack of deployment\n\
    \   feedback, this document does not call for a recommended option to\n   glue\
    \ the SFC layers together.\n   Further experiments are required to test and evaluate\
    \ the different\n   options.  A recommendation for hSFC might be documented in\
    \ a future\n   specification when the results of implementation and deployment\
    \ of\n   the aforementioned options are available.\n   It is not expected that\
    \ all the options discussed in this document\n   will be implemented and deployed.\
    \  The lack of an implementation\n   might be seen as a signal to recommend against\
    \ a given option.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This document makes use of the terms defined in Section 1.4\
    \ of\n   [RFC7665] and Section 1.3 of [RFC8300].\n   The following terms are defined:\n\
    \   o  Upper-level domain: the entire network domain to be managed.\n   o  Lower-level\
    \ domain: a portion of the network (called a subdomain).\n   o  Internal Boundary\
    \ Node (IBN): is responsible for bridging packets\n      between upper and lower\
    \ levels of SFC-enabled domains.\n"
- title: 3.  Hierarchical Service Function Chaining (hSFC)
  contents:
  - "3.  Hierarchical Service Function Chaining (hSFC)\n   A hierarchy has multiple\
    \ levels: the topmost level encompasses the\n   entire network domain to be managed,\
    \ and lower levels encompass\n   portions of the network.  These levels are discussed\
    \ in the following\n   subsections.\n"
- title: 3.1.  Upper Level
  contents:
  - "3.1.  Upper Level\n   Considering the example depicted in Figure 1, a top-level\
    \ network\n   domain includes SFC data plane components distributed over a wide\n\
    \   area, including:\n   o  Classifiers (CFs)\n   o  Service Function Forwarders\
    \ (SFFs)\n   o  Subdomains\n                    +------------+\n             \
    \       |Subdomain#1 |\n                    |  in DC1    |\n                 \
    \   +----+-------+\n                         |\n                 .---- SFF1 ------.\
    \   +----+\n       +----+   /     /  |         \\--|CF#4|\n   --->|CF#1|--/---->'\
    \   |          \\ +----+\n       +----+ /  SC#1    |           \\\n          \
    \    |          |            |\n              |          V    .------>|--->\n\
    \              |         /    /        |\n               \\         |   /    \
    \    /\n        +----+  \\        |  /        /  +----+\n        |CF#2|---\\ \
    \      | /        /---|CF#3|\n        +----+    '---- SFF2 ------'    +----+\n\
    \                         |\n                    +----+-------+\n            \
    \        |Subdomain#2 |\n                    |   in DC2   |\n                \
    \    +------------+\n       Legend:\n         SC#1: Service Chain 1\n        \
    \   DC: Data Center\n     Figure 1: Network-Wide View of Upper Level of Hierarchy\n\
    \   One path is shown from edge classifier (CF#1) to SFF1 to Subdomain#1\n   (residing\
    \ in Data Center 1) to SFF1 to SFF2 (residing in Data Center\n   2) to Subdomain#2\
    \ to SFF2 to network egress.\n   For the sake of clarity, components of the underlay\
    \ network are not\n   shown; an underlay network is assumed to provide connectivity\
    \ between\n   SFC data plane components.\n   Top-level SFPs carry packets from\
    \ classifiers through a set of SFFs\n   and subdomains, with the operations within\
    \ subdomains being opaque to\n   the upper levels.\n   We expect the system to\
    \ include a top-level control plane having\n   responsibility for configuring\
    \ forwarding policies and traffic-\n   classification rules.\n   The top-level\
    \ Service Chaining control plane manages end-to-end\n   service chains and associated\
    \ service function paths from network\n   edge points to subdomains.  It also\
    \ configures top-level classifiers\n   at a coarse level (e.g., based on source\
    \ or destination host) to\n   forward traffic along paths that will transit across\
    \ appropriate\n   subdomains.\n   Figure 1 shows one possible service chain passing\
    \ from the edge\n   through two subdomains to network egress.  The top-level control\n\
    \   plane does not configure traffic-classification rules or forwarding\n   policies\
    \ within the subdomains.\n   At this network-wide level, the number of SFPs required\
    \ is a linear\n   function of the number of ways in which a packet is required\
    \ to\n   traverse different subdomains and egress the network.  Note that the\n\
    \   various paths that may be followed within a subdomain are not\n   represented\
    \ by distinct network-wide SFPs; specific policies at the\n   ingress nodes of\
    \ each subdomain bind flows to subdomain paths.\n   Packets are classified at\
    \ the edge of the network to select the paths\n   by which subdomains are to be\
    \ traversed.  At the ingress of each\n   subdomain, packets are reclassified to\
    \ paths directing them to the\n   required SFs of the subdomain.  At the egress\
    \ of each subdomain,\n   packets are returned to the top-level paths.  Contrast\
    \ this with an\n   approach requiring the top-level classifier to select paths\
    \ to\n   specify all of the SFs in each subdomain.\n   It should be assumed that\
    \ some SFs require bidirectional symmetry of\n   paths (see more in Section 5).\
    \  Therefore, the classifiers at the top\n   level must be configured with policies\
    \ ensuring outgoing packets take\n   the reverse path of incoming packets through\
    \ subdomains.\n"
- title: 3.2.  Lower Levels
  contents:
  - "3.2.  Lower Levels\n   Each of the subdomains in Figure 1 is an SFC-enabled domain.\n\
    \   Figure 2 shows a subdomain interfaced with an upper-level domain by\n   means\
    \ of an Internal Boundary Node (IBN).  An IBN acts as an SFC-\n   aware SF in\
    \ the upper-level domain and as a classifier in the lower-\n   level domain. \
    \ As such, data packets entering the subdomain are\n   already SFC encapsulated.\
    \  Also, it is the purpose of the IBN to\n   apply classification rules and direct\
    \ the packets to the selected\n   local SFPs terminating at an egress IBN.  Finally,\
    \ the egress IBN\n   restores packets to the original SFC shim and hands them\
    \ off to SFFs.\n   Each subdomain intersects a subset of the total paths that\
    \ are\n   possible in the upper-level domain.  An IBN is concerned with upper-\n\
    \   level paths, but only those traversing its subdomain.\n   Each subdomain is\
    \ likely to have a control plane that can operate\n   independently of the top-level\
    \ control plane, managing\n   classification, forwarding paths, etc., within the\
    \ level of the\n   subdomain, with the details being opaque to the upper-level\
    \ control\n   elements.  Section 4 provides more details about the behavior of\
    \ an\n   IBN.\n   The subdomain control plane configures the classification rules\
    \ in\n   the IBN, where SFC encapsulation of the top-level domain is converted\n\
    \   to/from SFC encapsulation of the lower-level domain.  The subdomain\n   control\
    \ plane also configures the forwarding rules in the SFFs of the\n   subdomain.\n\
    \     +----+    +-----+  +----------------------+   +-----+\n     |    |    |\
    \ SFF |  |   IBN 1  (in DC 1)   |   | SFF |\n     |    |SC#1|     |  |  +----------------+\
    \  |   |     |\n   ->|    |===============>|      SFF       |================>\n\
    \     |    |    +-----+  |  +----------------+  |   +-----+\n     | CF |     \
    \        |   |              ^   |\n     |    |             |   v             \
    \ |   |\n     |    |             |+--------------------+|   Upper domain\n   \
    \  |    |             ||CF, fwd/rev mapping ||\n     |    |    * * * * *||  and\
    \ \"glue\"        || * * * * *\n     |    |    *        |+--------------------+|\
    \         *\n     +----+    *        | | |              | | |    Sub  *\n    \
    \           *        +-o-o--------------o-o-+   domain*\n               *    \
    \ SC#2 | |SC#1          ^ ^       #1  *\n               *    +-----+ |       \
    \       | |           *\n               *    |       V              | |      \
    \     *\n               *    |     +---+  +------+  | |           *\n        \
    \       *    |     |SFF|->|SF#1.1|--+ |           *\n               *    |   \
    \  +---+  +------+    |           *\n               *    V                   \
    \     |           *\n               *  +---+  +------+  +---+  +------+      \
    \ *\n               *  |SFF|->|SF#2.1|->|SFF|->|SF#2.2|       *\n            \
    \   *  +---+  +------+  +---+  +------+       *\n               * * * * * * *\
    \ * * * * * * * * * * * * * * *\n   Legend:\n        *** Subdomain boundary\n\
    \        === upper-level chain\n        --- lower-level chain\n       Figure 2:\
    \ Example of a Subdomain within an Upper-Level Domain\n   If desired, the pattern\
    \ can be applied recursively.  For example,\n   SF#1.1 in Figure 2 could be a\
    \ subdomain of the subdomain.\n"
- title: 4.  Internal Boundary Node (IBN)
  contents:
  - "4.  Internal Boundary Node (IBN)\n   As mentioned in the previous section, a\
    \ network element termed an\n   \"Internal Boundary Node\" (or IBN) is responsible\
    \ for bridging packets\n   between upper and lower layers of SFC-enabled domains.\
    \  It behaves as\n   an SF to the upper level (Section 3.1) and looks like a classifier\n\
    \   and end of chain to the lower level (Section 3.2).\n   To achieve the benefits\
    \ of hierarchy, the IBN should be applying\n   fine-grained traffic-classification\
    \ rules at a lower level than the\n   traffic passed to it.  This means that the\
    \ number of SFPs within the\n   lower level is greater than the number of SFPs\
    \ arriving to the IBN.\n   The IBN is also the termination of lower-level SFPs.\
    \  This is because\n   the packets exiting lower-level SFPs must be returned to\
    \ the upper-\n   level SFPs and forwarded to the next hop in the upper-level domain.\n\
    \   When different metadata schemes are used at different levels, the IBN\n  \
    \ has further responsibilities: when packets enter the subdomain, the\n   IBN\
    \ translates upper-level metadata into lower-level metadata; and\n   when packets\
    \ leave the subdomain at the termination of lower-level\n   SFPs, the IBN translates\
    \ lower-level metadata into upper-level\n   metadata.\n   Appropriately configuring\
    \ IBNs is key to ensuring the consistency of\n   the overall SFC operation within\
    \ a given domain that enables hSFC.\n   Classification rules (or lack thereof)\
    \ in the IBN classifier can, of\n   course, impact upper levels.\n"
- title: 4.1.  IBN Path Configuration
  contents:
  - "4.1.  IBN Path Configuration\n   The lower-level domain may be provisioned with\
    \ valid upper-level\n   paths or allow any upper-level paths.\n   When packets\
    \ enter the subdomain, the Service Path Identifier (SPI)\n   and Service Index\
    \ (SI) are re-marked according to the path selected\n   by the (subdomain) classifier.\n\
    \   At the termination of an SFP in the subdomain, packets can be\n   restored\
    \ to an original upper-level SFP by implementing one of these\n   methods:\n \
    \  1.  Saving the SPI and SI in transport-layer flow state\n       (Section 4.1.1).\n\
    \   2.  Pushing the SPI and SI into a metadata header (Section 4.1.2).\n   3.\
    \  Using unique lower-level paths per upper-level path coordinates\n       (Section\
    \ 4.1.3).\n   4.  Nesting NSH headers, encapsulating the upper-level NSH headers\n\
    \       within the lower-level NSH headers (Section 4.1.4).\n   5.  Saving the\
    \ upper level with a flow identifier (ID) and placing an\n       hSFC Flow ID\
    \ into a metadata header (Section 4.1.5).\n"
- title: 4.1.1.  Flow-Stateful IBN
  contents:
  - "4.1.1.  Flow-Stateful IBN\n   An IBN can be flow aware, returning packets to\
    \ the correct upper-\n   level SFP on the basis, for example, of the transport-layer\n\
    \   coordinates (typically, a 5-tuple) of packets exiting the lower-level\n  \
    \ SFPs.\n   When packets are received by the IBN on an upper-level path, the\n\
    \   classifier parses encapsulated packets for IP and transport-layer\n   (TCP,\
    \ UDP, etc.) coordinates.  State is created, indexed by some or\n   all transport\
    \ coordinates (typically, {source-IP, destination-IP,\n   source-port, destination-port,\
    \ and transport protocol}).  The state\n   contains, at minimum, the critical\
    \ fields of the encapsulating SFC\n   header (SPI, SI, MD Type, flags); additional\
    \ information carried in\n   the packet (metadata, TTL) may also be extracted\
    \ and saved as state.\n   Note that some fields of a packet may be altered by\
    \ an SF of the\n   subdomain (e.g., source IP address).\n   Note that this state\
    \ is only accessed by the classifier and\n   terminator functions of the subdomain.\
    \  Neither the SFFs nor SFs have\n   knowledge of this state; in fact they may\
    \ be agnostic about being in\n   a subdomain.\n   One approach is to ensure that\
    \ packets are terminated at the end of\n   the chain at the same IBN that classified\
    \ the packet at the start of\n   the chain.  If the packet is returned to a different\
    \ egress IBN,\n   state must be synchronized between the IBNs.\n   When a packet\
    \ returns to the IBN at the end of a chain (which is the\n   SFP-terminating node\
    \ of the lower-level chain), the SFC header is\n   removed, the packet is parsed\
    \ for flow-identifying information, and\n   state is retrieved from within the\
    \ IBN using the flow-identifying\n   information as index.\n   State cannot be\
    \ created by packets arriving from the lower-level\n   chain; when state cannot\
    \ be found for such packets, they must be\n   dropped.\n   This stateful approach\
    \ is limited to use with SFs that retain the\n   transport coordinates of the\
    \ packet.  This approach cannot be used\n   with SFs that modify those coordinates\
    \ (e.g., NATs) or otherwise\n   create packets for new coordinates other than\
    \ those received (e.g.,\n   as an HTTP cache might do to retrieve content on behalf\
    \ of the\n   original flow).  In both cases, the fundamental problem is the\n\
    \   inability to forward packets when state cannot be found for the\n   packet\
    \ transport-layer coordinates.\n   In the stateful approach, there are issues\
    \ caused by having state,\n   such as how long the state should be maintained\
    \ as well as whether\n   the state needs to be replicated to other devices to\
    \ create a highly\n   available network.\n   It is valid to consider the state\
    \ to be disposable after failure,\n   since it can be recreated by each new packet\
    \ arriving from the upper-\n   level domain.  For example, if an IBN loses all\
    \ flow state, the state\n   is recreated by an endpoint retransmitting a TCP packet.\n\
    \   If an SFC domain handles multiple network regions (e.g., multiple\n   private\
    \ networks), the coordinates may be augmented with additional\n   parameters,\
    \ perhaps using some metadata to identify the network\n   region.\n   In this\
    \ stateful approach, it is not necessary for the subdomain's\n   control plane\
    \ to modify paths when upper-level paths are changed.\n   The complexity of the\
    \ upper-level domain does not cause complexity in\n   the lower-level domain.\n\
    \   Since it doesn't depend on NSH in the lower-level domain, this flow-\n   stateful\
    \ approach can be applied to translation methods of converting\n   NSH to other\
    \ forwarding techniques (refer to Section 7).\n"
- title: 4.1.2.  Encoding Upper-Level Paths in Metadata
  contents:
  - "4.1.2.  Encoding Upper-Level Paths in Metadata\n   An IBN can push the upper-level\
    \ SPI and SI (or encoding thereof) into\n   a metadata field of the lower-level\
    \ encapsulation (e.g., placing\n   upper-level path information into a metadata\
    \ field of the NSH).  When\n   packets exit the lower-level path, the upper-level\
    \ SPI and SI can be\n   restored from the metadata retrieved from the packet.\n\
    \   This approach requires the SFs in the path to be capable of\n   forwarding\
    \ the metadata and appropriately attaching metadata to any\n   packets injected\
    \ for a flow.\n   Using a new metadata header may inflate packet size when variable-\n\
    \   length metadata (NSH MD Type 0x2) is used.\n   It is conceivable that the\
    \ MD Type 0x1 Fixed-Length Context Header\n   field of the NSH is not all relevant\
    \ to the lower-level domain.  In\n   this case, 32 bits of the Fixed-Length Context\
    \ Header field could be\n   repurposed within the lower-level domain and restored\
    \ when leaving.\n   If flags or TTL (see Section 4.4) from the original header\
    \ also need\n   to be saved, more metadata space will be consumed.\n   In this\
    \ metadata approach, it is not necessary for the subdomain's\n   control element\
    \ to modify paths when upper-level paths are changed.\n   The complexity of the\
    \ upper-level domain does not increase complexity\n   in the lower-level domain.\n"
- title: 4.1.3.  Using Unique Paths per Upper-Level Path
  contents:
  - "4.1.3.  Using Unique Paths per Upper-Level Path\n   This approach assumes that\
    \ paths within the subdomain are constrained\n   so that an SPI (of the subdomain)\
    \ unambiguously indicates the egress\n   SPI and SI (of the upper domain).  This\
    \ allows the original path\n   information to be restored at subdomain egress\
    \ from a look-up table\n   using the subdomain SPI.\n   Whenever the upper-level\
    \ domain provisions a path via the lower-level\n   domain, the lower-level domain\
    \ control plane must provision\n   corresponding paths to traverse the lower-level\
    \ domain.\n   A downside of this approach is that the number of paths in the lower-\n\
    \   level domain is multiplied by the number of paths in the upper-level\n   domain\
    \ that traverse the lower-level domain.  That is, a subpath must\n   be created\
    \ for each combination of upper SPI/SI and lower chain.  The\n   number of paths\
    \ required for lower-level domains will increase\n   exponentially as hierarchy\
    \ becomes deep.\n   A further downside of this approach is that it requires upper\
    \ and\n   lower levels to utilize the same metadata configuration.\n   Furthermore,\
    \ this approach does not allow any information to be\n   stashed away in state\
    \ or embedded in metadata.  For example, the TTL\n   modifications by the lower\
    \ level cannot be hidden from the upper\n   level.\n"
- title: 4.1.4.  Nesting Upper-Level NSH within Lower-Level NSH
  contents:
  - "4.1.4.  Nesting Upper-Level NSH within Lower-Level NSH\n   When packets arrive\
    \ at an IBN in the top-level domain, the classifier\n   in the IBN determines\
    \ the path for the lower-level domain and pushes\n   the new NSH header in front\
    \ of the original NSH header.\n   As shown in Figure 3, the Lower-NSH header used\
    \ to forward packets in\n   the lower-level domain precedes the Upper-NSH header\
    \ from the top-\n   level domain.\n                    +---------------------------------+\n\
    \                    |  Outer-Transport Encapsulation  |\n                   \
    \ +---------------------------------+\n                    |        Lower-NSH\
    \ Header         |\n                    +---------------------------------+\n\
    \                    |        Upper-NSH Header         |\n                   \
    \ +---------------------------------+\n                    |          Original\
    \ Packet        |\n                    +---------------------------------+\n \
    \                Figure 3: Encapsulation of NSH within NSH\n   The traffic with\
    \ this stack of two NSH headers is to be forwarded\n   according to the Lower-NSH\
    \ header in the lower-level SFC domain.  The\n   Upper-NSH header is preserved\
    \ in the packets but not used for\n   forwarding.  At the last SFF of the chain\
    \ of the lower-level domain\n   (which resides in the IBN), the Lower-NSH header\
    \ is removed from the\n   packet, and then the packet is forwarded by the IBN\
    \ to an SFF of the\n   upper-level domain.  The packet will be forwarded in the\
    \ top-level\n   domain according to the Upper-NSH header.\n   With such encapsulation,\
    \ Upper-NSH information is carried along the\n   extent of the lower-level chain\
    \ without modification.\n   A benefit of this approach is that it does not require\
    \ state in the\n   IBN or configuration to encode fields in metadata.  All header\n\
    \   fields, including flags and TTL, are easily restored when the chains\n   of\
    \ the subdomain terminate.\n   However, the downside is that it does require SFC-aware\
    \ SFs in the\n   lower-level domain to be able to parse multiple NSH layers. \
    \ If an\n   SFC-aware SF injects packets, it must also be able to deal with\n\
    \   adding appropriate multiple layers of headers to injected packets.\n   By\
    \ increasing packet overhead, nesting may lead to fragmentation or\n   decreased\
    \ MTU in some networks.\n"
- title: 4.1.5.  Stateful/Metadata Hybrid
  contents:
  - "4.1.5.  Stateful/Metadata Hybrid\n   The basic idea of this approach is for the\
    \ IBN to save upper domain\n   encapsulation information such that it can be retrieved\
    \ by a unique\n   identifier, termed an \"hSFC Flow ID\".\n   The hSFC Flow ID\
    \ is placed, for example, in the NSH Fixed-Length\n   Context Header field of\
    \ the packet in the lower-level domain, as\n   shown in Figure 4.  Likewise, hSFC\
    \ Flow ID may be encoded as a\n   Variable-Length Context Header field when MD\
    \ Type 0x2 is used.\n   When packets exit the lower-level domain, the IBN uses\
    \ the hSFC Flow\n   ID to retrieve the appropriate NSH encapsulation for returning\
    \ the\n   packet to the upper domain.  The hSFC Flow ID Context Header is then\n\
    \   stripped by the IBN.\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \        Service Path Identifier              | Service Index |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                      hSFC Flow ID                             |\n    \
    \ |              Zero Padding or other fields                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 4: Storing hSFC Flow ID in Lower-Level NSH\n        Fixed-Length\
    \ Context Header Field ([RFC8300], Section 2.4)\n   Advantages of this approach\
    \ include:\n   o  It does not require state to be based on a 5-tuple, so it works\n\
    \      with SFs that change the IP addresses or port numbers of a packet,\n  \
    \    such as NATs.\n   o  It does not require all domains to have the same metadata\
    \ scheme.\n   o  It can be used to restore any upper-domain information, including\n\
    \      metadata, flags, and TTL, not just the service path.\n   o  The lower-level\
    \ domain only requires a single item of metadata\n      regardless of the number\
    \ of items of metadata used in the upper\n      domain.\n   o  The SFC-related\
    \ functionality required by this approach in an SFC-\n      aware SF is able to\
    \ preserve and apply metadata, which is a\n      requirement that was already\
    \ present in [RFC8300].\n   Disadvantages include those of other stateful approaches,\
    \ including\n   state timeout and synchronization, mentioned in Section 4.1.1.\n\
    \   There may be a large number of unique NSH encapsulations to be\n   stored,\
    \ given that the hSFC Flow ID must represent all of the bits in\n   the upper-level\
    \ encapsulation.  This might consume a lot of memory or\n   create out-of-memory\
    \ situations in which hSFC Flow IDs cannot be\n   created or old hSFC Flow IDs\
    \ are discarded while still in use.\n"
- title: 4.2.  Gluing Levels Together
  contents:
  - "4.2.  Gluing Levels Together\n   The SPI or metadata included in a packet received\
    \ by the IBN may be\n   used as input to reclassification and path selection within\
    \ a lower-\n   level domain.\n   In some cases, the meanings of the various path\
    \ IDs and metadata must\n   be coordinated between domains for the sake of proper\
    \ end-to-end SFC\n   operation.\n   One approach is to use well-known identifier\
    \ values in metadata,\n   maintained in a global registry.\n   Another approach\
    \ is to use well-known labels for chain identifiers or\n   metadata, as an indirection\
    \ to the actual identifiers.  The actual\n   identifiers can be assigned by control-plane\
    \ systems.  For example, a\n   subdomain classifier could have a policy, \"if\
    \ pathID = classA then\n   chain packet to path 1234\"; the upper-level controller\
    \ would be\n   expected to configure the concrete upper-level \"pathID\" for \"\
    classA\".\n"
- title: 4.3.  Decrementing Service Index
  contents:
  - "4.3.  Decrementing Service Index\n   Because the IBN acts as an SFC-aware SF\
    \ to the upper-level domain, it\n   must decrement the Service Index in the NSH\
    \ headers of the upper-\n   level path.  This operation should be undertaken when\
    \ the packet is\n   first received by the IBN, before applying any of the strategies\
    \ of\n   Section 4.1, immediately prior to classification.\n"
- title: 4.4.  Managing TTL
  contents:
  - "4.4.  Managing TTL\n   The NSH base header contains a TTL field [RFC8300].  There\
    \ is a\n   choice:\n      a subdomain may appear as a pure service function, which\
    \ should\n      not decrement the TTL from the perspective of the upper-level\n\
    \      domain, or\n      all of the TTL changes within the subdomain may be visible\
    \ to the\n      upper-level domain.\n   Some readers may recognize this as a choice\
    \ between \"pipe\" and\n   \"uniform\" models, respectively [RFC3443].\n   The\
    \ network operator should be given control of this behavior,\n   choosing whether\
    \ to expose the lower-level topology to the upper\n   layer.  An implementation\
    \ may support per-packet policy, allowing\n   some users to perform a layer-transcending\
    \ trace route, for example.\n   The choice affects whether the methods of restoring\
    \ the paths in\n   Section 4.1 restore a saved version of the TTL or propagate\
    \ it with\n   the packet.  The method of Section 4.1.3 does not permit topology\n\
    \   hiding.  The other methods of Sections 4.1.1, 4.1.2, 4.1.4, and 4.1.5\n  \
    \ have unique methods for restoring saved versions of the TTL.\n"
- title: 5.  Subdomain Classifier
  contents:
  - "5.  Subdomain Classifier\n   Within the subdomain (referring to Figure 2), as\
    \ the classifier\n   receives incoming packets, the upper-level encapsulation\
    \ is treated\n   according to one of the methods described in Section 4.1 to either\n\
    \   statefully store, encode, or nest header information.  The classifier\n  \
    \ then selects the path and metadata for the packet within the\n   subdomain.\n\
    \   One of the goals of the hierarchical approach is to make it easy to\n   have\
    \ transport-flow-aware service chaining with bidirectional paths.\n   For example,\
    \ it is desired that for each TCP flow, the client-to-\n   server packets traverse\
    \ the same SF instances as the server-to-client\n   packets, but in the opposite\
    \ sequence.  We call this \"bidirectional\n   symmetry\".  If bidirectional symmetry\
    \ is required, it is the\n   responsibility of the control plane to be aware of\
    \ symmetric paths\n   and configure the classifier to chain the traffic in a symmetric\n\
    \   manner.\n   Another goal of the hierarchical approach is to simplify the\n\
    \   mechanisms of scaling SFs in and out.  All of the complexities of\n   load-balancing\
    \ among multiple SFs can be handled within a subdomain,\n   under control of the\
    \ classifier, allowing the upper-level domain to\n   be oblivious to the existence\
    \ of multiple SF instances.\n   Considering the requirements of bidirectional\
    \ symmetry and load-\n   balancing, it is useful to have all packets entering\
    \ a subdomain be\n   received by the same classifier or a coordinated cluster\
    \ of\n   classifiers.  There are both stateful and stateless approaches to\n \
    \  ensuring bidirectional symmetry.\n"
- title: 6.  Control Plane Elements
  contents:
  - "6.  Control Plane Elements\n   Although SFC control protocols have not yet been\
    \ standardized (as of\n   2018), from the point of view of hierarchical service\
    \ function\n   chaining, we have these expectations:\n   o  Each control-plane\
    \ instance manages a single level of the\n      hierarchy of a single domain.\n\
    \   o  Each control plane is agnostic about other levels of the\n      hierarchy.\
    \  This aspect allows humans to reason about the system\n      within a single\
    \ domain and control-plane algorithms to use only\n      domain-local inputs.\
    \  Top-level control does not need visibility\n      to subdomain policies, nor\
    \ does subdomain control need visibility\n      to upper-level policies.  (Top-level\
    \ control considers a subdomain\n      as though it were an SF.)\n   o  Subdomain\
    \ control planes are agnostic about the control planes of\n      other subdomains.\
    \  This allows both humans and machines to\n      manipulate subdomain policy\
    \ without considering policies of other\n      domains.\n   Recall that the IBN\
    \ acts as an SFC-aware SF in the upper-level domain\n   (receiving SF instructions\
    \ from the upper-level control plane) and as\n   a classifier in the lower-level\
    \ domain (receiving classification\n   rules from the subdomain control plane).\
    \  In this view, it is the IBN\n   that glues the layers together.\n   These expectations\
    \ are not intended to prohibit network-wide control.\n   A control hierarchy can\
    \ be envisaged to distribute information and\n   instructions to multiple domains\
    \ and subdomains.  Control hierarchy\n   is outside the scope of this document.\n"
- title: 7.  Extension for Adapting to NSH-Unaware Service Functions
  contents:
  - "7.  Extension for Adapting to NSH-Unaware Service Functions\n   The hierarchical\
    \ approach can be used for dividing networks into NSH-\n   aware and NSH-unaware\
    \ domains by converting NSH encapsulation to\n   other forwarding techniques (e.g.,\
    \ 5-tuple-based forwarding with\n   OpenFlow), as shown in Figure 5.\n       \
    \             * * * * * * * * * * * * * * * * * *\n                  *   NSH-aware\
    \ domain                 *\n                  *       +-------+       +-------+\
    \    *\n                  *       | SF#1  |       | SF#5  |    *\n           \
    \       *       +-o---o-+       +-o---o-+    *\n                  *         ^\
    \   |           ^   |      *\n                  *       +-|---|-+       +-|---|-+\
    \    *\n                  *       | |SFF| |       | |SFF| |    *\n           \
    \       *       +-|---|-+       +-|---|-+    *\n                  *         .\
    \   |           |   .      *\n                  * +--+   /    |           |  \
    \  \\     *\n                 -->|CF|--'     |           |     '------->\n   \
    \               * +--+        v           |          *\n                  *  \
    \       +---o-----------o---+      *\n                   .*.*.*.*.|  / |   IBN\
    \   | \\  |*.*.*.\n                  .         +-o--o---------o--o-+      .\n\
    \                  .           |  |         ^  ^        .\n                  .\
    \           |  +-+     +-+  |        .\n                  .       +---+    v \
    \    |    +---+    .\n                  .       |      +-o-----o-+      |    .\n\
    \                  .       |      |  SF#2   |      |    .\n                  .\
    \       |      +---------+      |    .\n                  .       +--+       \
    \          +--+    .\n                  .          |   +---------+   |       .\n\
    \                  .          v   |         v   |       .\n                  .\
    \        +-o---o-+     +-o---o-+     .\n                  .        | SF#3  | \
    \    | SF#4  |     .\n                  .        +-------+     +-------+     .\n\
    \                  .   NSH-unaware domain               .\n                  \
    \ . . . . . . . . . . . . . . . . . .\n   SF#1 and SF#5 are NSH aware; SF#2, SF#3,\
    \ and SF#4 are NSH unaware.\n   In the NSH-unaware domain, packets are conveyed\
    \ in a format supported\n   by SFs that are deployed there.\n           Figure\
    \ 5: Dividing NSH-Aware and NSH-Unaware Domains\n"
- title: 7.1.  Purpose
  contents:
  - "7.1.  Purpose\n   This approach is expected to facilitate service chaining in\
    \ networks\n   in which NSH-aware and NSH-unaware SFs coexist.  Some examples\
    \ of\n   such situations are:\n   o  In a period of transition from legacy SFs\
    \ to NSH-aware SFs\n   o  Supporting multitenancy\n"
- title: 7.2.  Requirements for an IBN
  contents:
  - "7.2.  Requirements for an IBN\n   In this usage, an IBN classifier is required\
    \ to have an NSH\n   conversion table for applying packets to appropriate lower-level\n\
    \   paths and returning packets to the correct upper-level paths.  For\n   example,\
    \ the following methods would be used for saving/restoring\n   upper-level path\
    \ information:\n   o  Saving SPI and SI in transport-layer flow state (refer to\n\
    \      Section 4.1.1)\n   o  Using unique lower-level paths per upper-level NSH\
    \ coordinates\n      (refer to Section 4.1.3)\n   Using the unique paths approach\
    \ would be especially good for\n   translating NSH to a different forwarding technique\
    \ in the lower\n   level.  A single path in the upper level may be branched to\
    \ multiple\n   paths in the lower level such that any lower-level path is only\
    \ used\n   by one upper-level path.  This allows unambiguous restoration to the\n\
    \   upper-level path.\n   In addition, an IBN might be required to convert metadata\
    \ contained\n   in the NSH to the format appropriate to the packet in the lower-level\n\
    \   path.  For example, some legacy SFs identify subscribers based on\n   information\
    \ about the network topology, such as the VLAN ID (VID),\n   and the IBN would\
    \ be required to create a VLAN to packets from\n   metadata if the subscriber\
    \ identifier is conveyed as metadata in\n   upper-level domains.\n   Other fundamental\
    \ functions required for an IBN (e.g., maintaining\n   metadata of upper level\
    \ or decrementing Service Index) are the same\n   as in normal usage.\n   It is\
    \ useful to permit metadata to be transferred between levels of a\n   hierarchy.\
    \  Metadata from an upper level may be useful within a\n   subdomain, and a subdomain\
    \ may augment metadata for consumption in an\n   upper domain.  However, allowing\
    \ uncontrolled metadata between\n   domains may lead to forwarding failures.\n\
    \      In order to prevent SFs of lower-level SFC-enabled domains from\n     \
    \ supplying (illegitimate) metadata, IBNs may be instructed to only\n      permit\
    \ specific metadata types to exit the subdomain.  Such\n      control over the\
    \ metadata in the upper level is the responsibility\n      of the upper-level\
    \ control plane.\n      To limit unintentional metadata reaching SFs of lower-level\
    \ SFC-\n      enabled subdomains, IBNs may be instructed to only permit specific\n\
    \      metadata types into the subdomain.  Such control of metadata in\n     \
    \ the lower-level domain is the responsibility of the lower-level\n      control\
    \ plane.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   hSFC makes use of service chaining architecture;\
    \ hence, it inherits\n   the security considerations described in the architecture\
    \ document\n   [RFC7665].\n   Furthermore, hSFC inherits the security considerations\
    \ of the data-\n   plane protocols (e.g., NSH) and control-plane protocols used\
    \ to\n   realize the solution.\n   This document describes systems that may be\
    \ managed by distinct teams\n   that all belong to the same administrative entity.\
    \  Subdomains must\n   have consistent configurations in order to properly forward\
    \ traffic.\n   Any protocol designed to distribute the configurations must be\
    \ secure\n   from tampering.  The means of preventing attacks from within a\n\
    \   network must be enforced.  For example, continuously monitoring the\n   network\
    \ may allow detecting such misbehaviors. hSFC adheres to the\n   same security\
    \ considerations as [RFC8300].  Those considerations must\n   be taken into account.\n\
    \   The options in Sections 4.1.2 and 4.1.5 assume the use of a dedicated\n  \
    \ context header to store information to bind a flow to its upper-level\n   SFP.\
    \  Such a context header is stripped by the IBN of a subdomain\n   before exiting\
    \ a subdomain.  Additional guards to prevent leaking\n   unwanted context information\
    \ when entering/exiting a subdomain are\n   discussed in Section 7.2.\n   All\
    \ of the systems and protocols must be secure from modification by\n   untrusted\
    \ agents.\n"
- title: 9.1.  Control Plane
  contents:
  - "9.1.  Control Plane\n   Security considerations related to the control plane\
    \ are discussed in\n   the corresponding control specification documents (e.g.,\n\
    \   [BGP-CONTROL], [PCEP-EXTENSIONS], or [RADIUS]).\n"
- title: 9.2.  Infinite Forwarding Loops
  contents:
  - "9.2.  Infinite Forwarding Loops\n   Distributing policies among multiple domains\
    \ may lead to forwarding\n   loops.  NSH supports the ability to detect loops\
    \ (as described in\n   Sections 4.3 and 4.4 of [RFC8300]), but the means of ensuring\
    \ the\n   consistency of the policies should be enabled at all levels of a\n \
    \  domain.  Within the context of hSFC, it is the responsibility of the\n   Control\
    \ Elements at all levels to prevent such (unwanted) loops.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC7665]  Halpern, J., Ed. and C. Pignataro,\
    \ Ed., \"Service Function\n              Chaining (SFC) Architecture\", RFC 7665,\n\
    \              DOI 10.17487/RFC7665, October 2015,\n              <https://www.rfc-editor.org/info/rfc7665>.\n\
    \   [RFC8300]  Quinn, P., Ed., Elzur, U., Ed., and C. Pignataro, Ed.,\n      \
    \        \"Network Service Header (NSH)\", RFC 8300,\n              DOI 10.17487/RFC8300,\
    \ January 2018,\n              <https://www.rfc-editor.org/info/rfc8300>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [BGP-CONTROL]\n              Farrel, A., Drake,\
    \ J., Rosen, E., Uttaro, J., and L.\n              Jalil, \"BGP Control Plane\
    \ for NSH SFC\", Work in Progress,\n              draft-ietf-bess-nsh-bgp-control-plane-04,\
    \ July 2018.\n   [PCEP-EXTENSIONS]\n              Wu, Q., Dhody, D., Boucadair,\
    \ M., Jacquenet, C., and J.\n              Tantsura, \"PCEP Extensions for Service\
    \ Function Chaining\n              (SFC)\", Work in Progress,\n              draft-wu-pce-traffic-steering-sfc-12,\
    \ June 2017.\n   [RADIUS]   Maglione, R., Trueba, G., and C. Pignataro, \"RADIUS\n\
    \              Attributes for NSH\", Work in Progress,\n              draft-maglione-sfc-nsh-radius-01,\
    \ October 2016.\n   [RFC3443]  Agarwal, P. and B. Akyol, \"Time To Live (TTL)\
    \ Processing\n              in Multi-Protocol Label Switching (MPLS) Networks\"\
    ,\n              RFC 3443, DOI 10.17487/RFC3443, January 2003,\n             \
    \ <https://www.rfc-editor.org/info/rfc3443>.\n   [USE-CASES]\n              Kumar,\
    \ S., Tufail, M., Majee, S., Captari, C., and S.\n              Homma, \"Service\
    \ Function Chaining Use Cases In Data\n              Centers\", Work in Progress,\n\
    \              draft-ietf-sfc-dc-use-cases-06, February 2017.\n"
- title: Appendix A.  Examples of Hierarchical Service Function Chaining
  contents:
  - "Appendix A.  Examples of Hierarchical Service Function Chaining\n   The advantage\
    \ of hSFC compared with normal or flat service function\n   chaining is that it\
    \ can reduce the management complexity\n   significantly.  This section discusses\
    \ examples that show those\n   advantages.\n"
- title: A.1.  Reducing the Number of Service Function Paths
  contents:
  - "A.1.  Reducing the Number of Service Function Paths\n   In this case, hSFC is\
    \ used to simplify service function chaining\n   management by reducing the number\
    \ of SFPs.\n   As shown in Figure 6, there are two domains, each with different\n\
    \   concerns: a Security Domain that selects SFs based on network\n   conditions\
    \ and an Optimization Domain that selects SFs based on\n   traffic protocol.\n\
    \   In this example, there are five security functions deployed in the\n   Security\
    \ Domain.  The Security Domain operator wants to enforce the\n   five different\
    \ security policies, and the Optimization Domain\n   operator wants to apply different\
    \ optimizations (either cache or\n   video optimization) to each of these two\
    \ types of traffic.  If we use\n   flat SFC (normal branching), 10 SFPs are needed\
    \ in each domain.  In\n   contrast, if we use hSFC, only five SFPs in Security\
    \ Domain and two\n   SFPs in Optimization Domain will be required, as shown in\
    \ Figure 7.\n   In the flat model, the number of SFPs is the product of the number\
    \ of\n   SFs in all of the domains.  In the hSFC model, the number of SFPs is\n\
    \   the sum of the number of SFs.  For example, adding a \"bypass\" path in\n\
    \   the Optimization Domain would cause the flat model to require 15\n   paths\
    \ (five more) but cause the hSFC model to require one more path\n   in the Optimization\
    \ Domain.\n              . . . . . . . . . . . .   . . . . . . . . . . . . .\n\
    \              . Security Domain     .   .  Optimization Domain  .\n         \
    \     .                     .   .                       .\n              .   \
    \ +-1---[     ]----------------->[Cache  ]------->\n              .    |     [\
    \ WAF ]    .   .                       .\n              .    +-2-->[     ]----------------->[Video\
    \ Opt.]---->\n              .    |                .   .                      \
    \ .\n              .    +-3---[Anti ]----------------->[Cache  ]------->\n   \
    \           .    |     [Virus]    .   .                       .\n            \
    \  .    +-4-->[     ]----------------->[Video Opt.]---->\n              .    |\
    \                .   .                       .\n              .    +-5-->[   \
    \  ]----------------->[Cache  ]------->\n   [DPI]--->[CF]---|     [ IPS ]    .\
    \   .                       .\n              .    +-6-->[     ]----------------->[Video\
    \ Opt.]---->\n              .    |                .   .                      \
    \ .\n              .    +-7-->[     ]----------------->[Cache  ]------->\n   \
    \           .    |     [ IDS ]    .   .                       .\n            \
    \  .    +-8-->[     ]----------------->[Video Opt.]---->\n              .    |\
    \                .   .                       .\n              .    +-9-->[Traffic]--------------->[Cache\
    \  ]------->\n              .    |     [Monitor]  .   .                      \
    \ .\n              .    +-10->[       ]--------------->[Video Opt.]---->\n   \
    \           . . . . . . . . . . . .   . . . . . . . . . . . . .\n   Legend:\n\
    \      IDS: Intrusion Detection System\n      IPS: Intrusion Prevention System\n\
    \      WAF: Web Application Firewall\n      DPI: Deep Packet Inspection\n   The\
    \ classifier must select paths that determine the combination of\n   Security\
    \ and Optimization concerns. 1:WAF+Cache, 2:WAF+VideoOpt,\n   3:AntiVirus+Cache,\
    \ 4:AntiVirus+VideoOpt, 5:IPS+Cache, 6:IPS+VideoOpt,\n   7:IDS+Cache, 8:IDS+VideoOpt,\
    \ 9:TrafficMonitor+Cache,\n   10:TrafficMonitor+VideoOpt\n                   Figure\
    \ 6: Flat SFC (Normal Branching)\n        . . . . . . . . . . . . . . .    . .\
    \ . . . . . . . . . . . . .\n        .     Security Domain       .    .   Optimization\
    \ Domain     .\n        .                           .    .                   \
    \        .\n   [CF]---->[  [CF]    IBN      ]---------->[  [CF]   IBN        \
    \ ]---->\n        .    |                  ^   .    .  |                     ^\
    \  .\n        .    +----->[ WAF ]-----+   .    .  +-->[ Cache ]---------+  .\n\
    \        .    |                  |   .    .  |                     |  .\n    \
    \    .    +-->[Anti-Virus]---+   .    .  +-->[Video Opt]-------+  .\n        .\
    \    |                  |   .    .                           .\n        .    +----->[\
    \ IPS ]-----+   .    . . . . . . . . . . . . . . .\n        .    |           \
    \       |   .\n        .    +----->[ IDS ]-----+   .\n        .    |         \
    \         |   .\n        .    +-->[ Traffic ]----+   .\n        .        [ Monitor\
    \ ]        .\n        . . . . . . . . . . . . . . .\n              Figure 7: Simplified\
    \ Path Management with hSFC\n"
- title: A.2.  Managing a Distributed DC Network
  contents:
  - "A.2.  Managing a Distributed DC Network\n   Hierarchical service function chaining\
    \ can be used to simplify inter-\n   DC SFC management.  In the example of Figure\
    \ 8, there is a central\n   data center (Central DC) and multiple local data centers\
    \ (Local DC#1,\n   #2, #3) that are deployed in a geographically distributed manner.\n\
    \   All of the data centers are under a single administrative domain.\n   The\
    \ central DC may have some service functions that the local DC\n   needs, such\
    \ that the local DC needs to chain traffic via the central\n   DC.  This could\
    \ be because:\n   o  Some SFs are deployed as dedicated hardware appliances, and\
    \ there\n      is a desire to lower the cost (both CAPEX and OPEX) of deploying\n\
    \      such SFs in all data centers.\n   o  Some SFs are being trialed or introduced,\
    \ or they otherwise handle\n      a relatively small amount of traffic.  It may\
    \ be cheaper to manage\n      these SFs in a single central data center and steer\
    \ packets to the\n      central data center than to manage these SFs in all data\
    \ centers.\n                   +-----------+\n                   |Central DC |\n\
    \                   +-----------+\n                      ^  ^   ^\n          \
    \            |  |   |\n                  .---|--|---|----.\n                 /\
    \   /   |   |      \\\n                /   /    |    \\      \\\n     +-----+\
    \   /   /     |     \\      \\    +-----+\n     |Local|  |   /      |      \\\
    \     |    |Local|\n     |DC#1 |--|--.       |       .----|----|DC#3 |\n     +-----+\
    \  |          |            |    +-----+\n               \\         |         \
    \   /\n                \\        |           /\n                 \\       |  \
    \        /\n                  '----------------'\n                         |\n\
    \                      +-----+\n                      |Local|\n              \
    \        |DC#2 |\n                      +-----+\n                Figure 8: Simplify\
    \ Inter-DC SFC Management\n   For large DC operators, one local DC may have tens\
    \ of thousands of\n   servers and hundreds of thousands of virtual machines. \
    \ SFC can be\n   used to manage user traffic.  For example, SFC can be used to\n\
    \   classify user traffic based on service type, DDoS state, etc.\n   In such\
    \ a large-scale DC, using flat SFC is very complex, requiring a\n   super controller\
    \ to configure all DCs.  For example, any changes to\n   SFs or SFPs in the central\
    \ DC (e.g., deploying a new SF) would\n   require updates to all of the SFPs in\
    \ the local DCs accordingly.\n   Furthermore, requirements for symmetric paths\
    \ add additional\n   complexity when flat SFC is used in this scenario.\n   Conversely,\
    \ if using hierarchical SFC, each DC can be managed\n   independently to significantly\
    \ reduce management complexity.  SFPs\n   between DCs can represent abstract notions\
    \ without regard to details\n   within DCs.  Independent controllers can be used\
    \ for the top level\n   (getting packets to pass the correct DCs) and local levels\
    \ (getting\n   packets to specific SF instances).\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The concept of Hierarchical Service Path Domains was introduced\
    \ in\n   \"Analysis on Forwarding Methods for Service Chaining\" (August 2016)\n\
    \   as a means of improving scalability of service chaining in large\n   networks.\n\
    \   The concept of nesting NSH headers within lower-level NSH was\n   contributed\
    \ by Ting Ao.  The concept originally appeared in\n   \"Hierarchical SFC for DC\
    \ Interconnection\" (April 2016) as a means of\n   creating hierarchical SFC in\
    \ a data center.\n   We thank Dapeng Liu for contributing the DC examples in the\
    \ Appendix.\n   The Stateful/Metadata Hybrid section was contributed by Victor\
    \ Wu.\n   The authors would also like to thank the following individuals for\n\
    \   providing valuable feedback:\n      Ron Parker\n      Christian Jacquenet\n\
    \      Jie Cao\n      Kyle Larose\n   Thanks to Ines Robles, Sean Turner, Vijay\
    \ Gurbani, Ben Campbell, and\n   Benjamin Kaduk for their review.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   David Dolson\n   Sandvine\n   Waterloo, ON\n   Canada\n\
    \   Email: ddolson@acm.org\n   Shunsuke Homma\n   NTT\n   3-9-11, Midori-cho\n\
    \   Musashino-shi, Tokyo  180-8585\n   Japan\n   Email: homma.shunsuke@lab.ntt.co.jp\n\
    \   Diego R. Lopez\n   Telefonica I+D\n   Don Ramon de la Cruz, 82\n   Madrid\
    \  28006\n   Spain\n   Phone: +34 913 129 041\n   Email: diego.r.lopez@telefonica.com\n\
    \   Mohamed Boucadair\n   Orange\n   Rennes  35000\n   France\n   Email: mohamed.boucadair@orange.com\n"
