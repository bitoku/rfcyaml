- title: __initial_text__
  contents:
  - "                 Generic Security Service Algorithm for\n        Secret Key Transaction\
    \ Authentication for DNS (GSS-TSIG)\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Secret Key Transaction Authentication for DNS (TSIG) protocol\n\
    \   provides transaction level authentication for DNS.  TSIG is\n   extensible\
    \ through the definition of new algorithms.  This document\n   specifies an algorithm\
    \ based on the Generic Security Service\n   Application Program Interface (GSS-API)\
    \ (RFC2743).  This document\n   updates RFC 2845.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  Algorithm Overview . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n       2.1.  GSS Details. . . . . . . . . . . . . . . . . . .\
    \ . . . .  4\n       2.2.  Modifications to the TSIG protocol (RFC 2845). . .\
    \ . . .  4\n   3.  Client Protocol Details. . . . . . . . . . . . . . . . . .\
    \ . .  5\n       3.1.  Negotiating Context. . . . . . . . . . . . . . . . . .\
    \ .  5\n           3.1.1.  Call GSS_Init_sec_context. . . . . . . . . . . . .\
    \  6\n           3.1.2.  Send TKEY Query to Server. . . . . . . . . . . . .  8\n\
    \           3.1.3.  Receive TKEY Query-Response from Server. . . . . .  8\n  \
    \     3.2.  Context Established. . . . . . . . . . . . . . . . . . . 11\n    \
    \       3.2.1.  Terminating a Context. . . . . . . . . . . . . . . 11\n   4. \
    \ Server Protocol Details. . . . . . . . . . . . . . . . . . . . 12\n       4.1.\
    \  Negotiating Context. . . . . . . . . . . . . . . . . . . 12\n           4.1.1.\
    \  Receive TKEY Query from Client . . . . . . . . . . 12\n           4.1.2.  Call\
    \ GSS_Accept_sec_context. . . . . . . . . . . . 12\n           4.1.3.  Send TKEY\
    \ Query-Response to Client . . . . . . . . 13\n       4.2.  Context Established.\
    \ . . . . . . . . . . . . . . . . . . 15\n           4.2.1.  Terminating a Context.\
    \ . . . . . . . . . . . . . . 15\n   5.  Sending and Verifying Signed Messages.\
    \ . . . . . . . . . . . . 15\n       5.1.  Sending a Signed Message - Call GSS_GetMIC\
    \ . . . . . . . 15\n       5.2.  Verifying a Signed Message - Call GSS_VerifyMIC.\
    \ . . . . 16\n   6.  Example usage of GSS-TSIG algorithm. . . . . . . . . . .\
    \ . . . 18\n   7.  Security Considerations. . . . . . . . . . . . . . . . . .\
    \ . . 22\n   8.  IANA Considerations. . . . . . . . . . . . . . . . . . . . .\
    \ . 22\n   9.  Conformance. . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 22\n   10. Intellectual Property Statement. . . . . . . . . . . . . . . . 23\n\
    \   11. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 23\n  \
    \ 12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n    \
    \   12.1.  Normative References. . . . . . . . . . . . . . . . . . 24\n      \
    \ 12.2.  Informative References. . . . . . . . . . . . . . . . . 24\n   13. Authors'\
    \ Addresses . . . . . . . . . . . . . . . . . . . . . . 25\n   14. Full Copyright\
    \ Statement . . . . . . . . . . . . . . . . . . . 26\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Secret Key Transaction Authentication for DNS (TSIG)\
    \ [RFC2845]\n   protocol was developed to provide a lightweight authentication\
    \ and\n   integrity of messages between two DNS entities, such as client and\n\
    \   server or server and server.  TSIG can be used to protect dynamic\n   update\
    \ messages, authenticate regular message or to off-load\n   complicated DNSSEC\
    \ [RFC2535] processing from a client to a server and\n   still allow the client\
    \ to be assured of the integrity of the answers.\n   The TSIG protocol [RFC2845]\
    \ is extensible through the definition of\n   new algorithms.  This document specifies\
    \ an algorithm based on the\n   Generic Security Service Application Program Interface\
    \ (GSS-API)\n   [RFC2743].  GSS-API is a framework that provides an abstraction\
    \ of\n   security to the application protocol developer.  The security\n   services\
    \ offered can include authentication, integrity, and\n   confidentiality.\n  \
    \ The GSS-API framework has several benefits:\n   *  Mechanism and protocol independence.\
    \  The underlying mechanisms\n      that realize the security services can be\
    \ negotiated on the fly\n      and varied over time.  For example, a client and\
    \ server MAY use\n      Kerberos [RFC1964] for one transaction, whereas that same\
    \ server\n      MAY use SPKM [RFC2025] with a different client.\n   *  The protocol\
    \ developer is removed from the responsibility of\n      creating and managing\
    \ a security infrastructure.  For example, the\n      developer does not need\
    \ to create new key distribution or key\n      management systems.  Instead the\
    \ developer relies on the security\n      service mechanism to manage this on\
    \ its behalf.\n   The scope of this document is limited to the description of\
    \ an\n   authentication mechanism only.  It does not discuss and/or propose an\n\
    \   authorization mechanism.  Readers that are unfamiliar with GSS-API\n   concepts\
    \ are encouraged to read the characteristics and concepts\n   section of [RFC2743]\
    \ before examining this protocol in detail.  It is\n   also assumed that the reader\
    \ is familiar with [RFC2845], [RFC2930],\n   [RFC1034] and [RFC1035].\n   The\
    \ key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\",\n\
    \   \"RECOMMENDED\", and \"MAY\" in this document are to be interpreted as\n \
    \  described in BCP 14, RFC 2119 [RFC2119].\n"
- title: 2.  Algorithm Overview
  contents:
  - "2.  Algorithm Overview\n   In GSS, client and server interact to create a \"\
    security context\".\n   The security context can be used to create and verify\
    \ transaction\n   signatures on messages between the two parties.  A unique security\n\
    \   context is required for each unique connection between client and\n   server.\n\
    \   Creating a security context involves a negotiation between client and\n  \
    \ server.  Once a context has been established, it has a finite\n   lifetime for\
    \ which it can be used to secure messages.  Thus there are\n   three states of\
    \ a context associated with a connection:\n                              +----------+\n\
    \                              |          |\n                              V \
    \         |\n                      +---------------+  |\n                    \
    \  | Uninitialized |  |\n                      |               |  |\n        \
    \              +---------------+  |\n                              |         \
    \ |\n                              V          |\n                      +---------------+\
    \  |\n                      | Negotiating   |  |\n                      | Context\
    \       |  |\n                      +---------------+  |\n                   \
    \           |          |\n                              V          |\n       \
    \               +---------------+  |\n                      | Context       |\
    \  |\n                      | Established   |  |\n                      +---------------+\
    \  |\n                              |          |\n                           \
    \   +----------+\n   Every connection begins in the uninitialized state.\n"
- title: 2.1.  GSS Details
  contents:
  - "2.1.  GSS Details\n   Client and server MUST be locally authenticated and have\
    \ acquired\n   default credentials before using this protocol as specified in\n\
    \   Section 1.1.1 \"Credentials\" in RFC 2743 [RFC2743].\n   The GSS-TSIG algorithm\
    \ consists of two stages:\n   I.  Establish security context.  The Client and\
    \ Server use the\n       GSS_Init_sec_context and GSS_Accept_sec_context APIs\
    \ to generate\n       the tokens that they pass to each other using [RFC2930]\
    \ as a\n       transport mechanism.\n   II. Once the security context is established\
    \ it is used to generate\n       and verify signatures using GSS_GetMIC and GSS_VerifyMIC\
    \ APIs.\n       These signatures are exchanged by the Client and Server as a part\n\
    \       of the TSIG records exchanged in DNS messages sent between the\n     \
    \  Client and Server, as described in [RFC2845].\n"
- title: 2.2.  Modifications to the TSIG protocol (RFC 2845)
  contents:
  - "2.2.  Modifications to the TSIG protocol (RFC 2845)\n   Modification to RFC 2845\
    \ allows use of TSIG through signing server's\n   response in an explicitly specified\
    \ place in multi message exchange\n   between two DNS entities even if client's\
    \ request wasn't signed.\n   Specifically, Section 4.2 of RFC 2845 MUST be modified\
    \ as follows:\n   Replace:\n      \"The server MUST not generate a signed response\
    \ to an unsigned\n      request.\"\n   With:\n      \"The server MUST not generate\
    \ a signed response to an unsigned\n      request, except in case of response\
    \ to client's unsigned TKEY\n      query if secret key is established on server\
    \ side after server\n      processed client's query.  Signing responses to unsigned\
    \ TKEY\n      queries MUST be explicitly specified in the description of an\n\
    \      individual secret key establishment algorithm.\"\n"
- title: 3.  Client Protocol Details
  contents:
  - "3.  Client Protocol Details\n   A unique context is required for each server\
    \ to which the client\n   sends secure messages.  A context is identified by a\
    \ context handle.\n   A client maintains a mapping of servers to handles:\n  \
    \    (target_name, key_name, context_handle)\n   The value key_name also identifies\
    \ a context handle.  The key_name is\n   the owner name of the TKEY and TSIG records\
    \ sent between a client and\n   a server to indicate to each other which context\
    \ MUST be used to\n   process the current request.\n   DNS client and server MAY\
    \ use various underlying security mechanisms\n   to establish security context\
    \ as described in sections 3 and 4.  At\n   the same time, in order to guarantee\
    \ interoperability between DNS\n   clients and servers that support GSS-TSIG it\
    \ is REQUIRED that\n   security mechanism used by client enables use of Kerberos\
    \ v5 (see\n   Section 9 for more information).\n"
- title: 3.1.  Negotiating Context
  contents:
  - "3.1.  Negotiating Context\n   In GSS, establishing a security context involves\
    \ the passing of\n   opaque tokens between the client and the server.  The client\n\
    \   generates the initial token and sends it to the server.  The server\n   processes\
    \ the token and if necessary, returns a subsequent token to\n   the client.  The\
    \ client processes this token, and so on, until the\n   negotiation is complete.\
    \  The number of times the client and server\n   exchange tokens depends on the\
    \ underlying security mechanism.  A\n   completed negotiation results in a context\
    \ handle.\n   The TKEY resource record [RFC2930] is used as the vehicle to transfer\n\
    \   tokens between client and server.  The TKEY record is a general\n   mechanism\
    \ for establishing secret keys for use with TSIG.  For more\n   information, see\
    \ [RFC2930].\n"
- title: 3.1.1.  Call GSS_Init_sec_context
  contents:
  - "3.1.1.  Call GSS_Init_sec_context\n   To obtain the first token to be sent to\
    \ a server, a client MUST call\n   GSS_Init_sec_context API.\n   The following\
    \ input parameters MUST be used.  The outcome of the call\n   is indicated with\
    \ the output values below.  Consult Sections 2.2.1,\n   \"GSS_Init_sec_context\
    \ call\", of [RFC2743] for syntax definitions.\n   INPUTS\n     CREDENTIAL HANDLE\
    \ claimant_cred_handle = NULL (NULL specifies \"use\n         default\").  Client\
    \ MAY instead specify some other valid\n         handle to its credentials.\n\
    \     CONTEXT HANDLE input_context_handle  = 0\n     INTERNAL NAME  targ_name\
    \             = \"DNS@<target_server_name>\"\n     OBJECT IDENTIFIER mech_type\
    \          = Underlying security\n         mechanism chosen by implementers. \
    \ To guarantee\n         interoperability of the implementations of the GSS-TSIG\n\
    \         mechanism client MUST specify a valid underlying security\n        \
    \ mechanism that enables use of Kerberos v5 (see Section 9 for\n         more\
    \ information).\n     OCTET STRING   input_token           = NULL\n     BOOLEAN\
    \        replay_det_req_flag   = TRUE\n     BOOLEAN        mutual_req_flag   \
    \    = TRUE\n     BOOLEAN        deleg_req_flag        = TRUE\n     BOOLEAN  \
    \      sequence_req_flag     = TRUE\n     BOOLEAN        anon_req_flag       \
    \  = FALSE\n     BOOLEAN        integ_req_flag        = TRUE\n     INTEGER   \
    \     lifetime_req          = 0 (0 requests a default\n         value).  Client\
    \ MAY instead specify another upper bound for the\n         lifetime of the context\
    \ to be established in seconds.\n     OCTET STRING   chan_bindings         = Any\
    \ valid channel bindings\n         as specified in Section 1.1.6 \"Channel Bindings\"\
    \ in [RFC2743]\n   OUTPUTS\n     INTEGER        major_status\n     CONTEXT HANDLE\
    \ output_context_handle\n     OCTET STRING   output_token\n     BOOLEAN      \
    \  replay_det_state\n     BOOLEAN        mutual_state\n     INTEGER        minor_status\n\
    \     OBJECT IDENTIFIER mech_type\n     BOOLEAN        deleg_state\n     BOOLEAN\
    \        sequence_state\n     BOOLEAN        anon_state\n     BOOLEAN        trans_state\n\
    \     BOOLEAN        prot_ready_state\n     BOOLEAN        conf_avail\n     BOOLEAN\
    \        integ_avail\n     INTEGER        lifetime_rec\n   If returned major_status\
    \ is set to one of the following errors:\n     GSS_S_DEFECTIVE_TOKEN\n     GSS_S_DEFECTIVE_CREDENTIAL\n\
    \     GSS_S_BAD_SIG (GSS_S_BAD_MIC)\n     GSS_S_NO_CRED\n     GSS_S_CREDENTIALS_EXPIRED\n\
    \     GSS_S_BAD_BINDINGS\n     GSS_S_OLD_TOKEN\n     GSS_S_DUPLICATE_TOKEN\n \
    \    GSS_S_NO_CONTEXT\n     GSS_S_BAD_NAMETYPE\n     GSS_S_BAD_NAME\n     GSS_S_BAD_MECH\n\
    \     GSS_S_FAILURE\n   then the client MUST abandon the algorithm and MUST NOT\
    \ use the GSS-\n   TSIG algorithm to establish this security context.  This document\n\
    \   does not prescribe which other mechanism could be used to establish a\n  \
    \ security context.  Next time when this client needs to establish\n   security\
    \ context, the client MAY use GSS-TSIG algorithm.\n   Success values of major_status\
    \ are GSS_S_CONTINUE_NEEDED and\n   GSS_S_COMPLETE.  The exact success code is\
    \ important during later\n   processing.\n   The values of replay_det_state and\
    \ mutual_state indicate if the\n   security package provides replay detection\
    \ and mutual authentication,\n   respectively.  If returned major_status is GSS_S_COMPLETE\
    \ AND one or\n   both of these values are FALSE, the client MUST abandon this\n\
    \   algorithm.\n   Client's behavior MAY depend on other OUTPUT parameters according\
    \ to\n   the policy local to the client.\n   The handle output_context_handle\
    \ is unique to this negotiation and is\n   stored in the client's mapping table\
    \ as the context_handle that maps\n   to target_name.\n"
- title: 3.1.2.  Send TKEY Query to Server
  contents:
  - "3.1.2.  Send TKEY Query to Server\n   An opaque output_token returned by GSS_Init_sec_context\
    \ is\n   transmitted to the server in a query request with QTYPE=TKEY.  The\n\
    \   token itself will be placed in a Key Data field of the RDATA field in\n  \
    \ the TKEY resource record in the additional records section of the\n   query.\
    \  The owner name of the TKEY resource record set queried for\n   and the owner\
    \ name of the supplied TKEY resource record in the\n   additional records section\
    \ MUST be the same.  This name uniquely\n   identifies the security context to\
    \ both the client and server, and\n   thus the client SHOULD use a value which\
    \ is globally unique as\n   described in [RFC2930].  To achieve global uniqueness,\
    \ the name MAY\n   contain a UUID/GUID [ISO11578].\n      TKEY Record\n      \
    \  NAME = client-generated globally unique domain name string\n              \
    \ (as described in [RFC2930])\n        RDATA\n           Algorithm Name      =\
    \ gss-tsig\n           Mode                = 3 (GSS-API negotiation - per [RFC2930])\n\
    \           Key Size            = size of output_token in octets\n           Key\
    \ Data            = output_token\n   The remaining fields in the TKEY RDATA, i.e.,\
    \ Inception, Expiration,\n   Error, Other Size and Data Fields, MUST be set according\
    \ to\n   [RFC2930].\n   The query is transmitted to the server.\n   Note: if the\
    \ original client call to GSS_Init_sec_context returned\n   any major_status other\
    \ than GSS_S_CONTINUE_NEEDED or GSS_S_COMPLETE,\n   then the client MUST NOT send\
    \ TKEY query.  Client's behavior in this\n   case is described above in Section\
    \ 3.1.1.\n"
- title: 3.1.3.  Receive TKEY Query-Response from Server
  contents:
  - "3.1.3.  Receive TKEY Query-Response from Server\n   Upon the reception of the\
    \ TKEY query the DNS server MUST respond\n   according to the description in Section\
    \ 4.  This section specifies\n   the behavior of the client after it receives\
    \ the matching response to\n   its query.\n   The next processing step depends\
    \ on the value of major_status from\n   the most recent call that client performed\
    \ to GSS_Init_sec_context:\n   either GSS_S_COMPLETE or GSS_S_CONTINUE.\n"
- title: 3.1.3.1.  Value of major_status == GSS_S_COMPLETE
  contents:
  - "3.1.3.1.  Value of major_status == GSS_S_COMPLETE\n   If the last call to GSS_Init_sec_context\
    \ yielded a major_status value\n   of GSS_S_COMPLETE and a non-NULL output_token\
    \ was sent to the server,\n   then the client side component of the negotiation\
    \ is complete and the\n   client is awaiting confirmation from the server.\n \
    \  Confirmation is in the form of a query response with RCODE=NOERROR\n   and\
    \ with the last client supplied TKEY record in the answer section\n   of the query.\
    \  The response MUST be signed with a TSIG record.  Note\n   that the server is\
    \ allowed to sign a response to unsigned client's\n   query due to modification\
    \ to the RFC 2845 specified in Section 2.2\n   above.  The signature in the TSIG\
    \ record MUST be verified using the\n   procedure detailed in section 5, Sending\
    \ and Verifying Signed\n   Messages.  If the response is not signed, OR if the\
    \ response is\n   signed but the signature is invalid, then an attacker has tampered\n\
    \   with the message in transit or has attempted to send the client a\n   false\
    \ response.  In this case, the client MAY continue waiting for a\n   response\
    \ to its last TKEY query until the time period since the\n   client sent last\
    \ TKEY query expires.  Such a time period is specified\n   by the policy local\
    \ to the client.  This is a new option that allows\n   the DNS client to accept\
    \ multiple answers for one query ID and select\n   one (not necessarily the first\
    \ one) based on some criteria.\n   If the signature is verified, the context state\
    \ is advanced to\n   Context Established.  Proceed to section 3.2 for usage of\
    \ the\n   security context.\n"
- title: 3.1.3.2.  Value of major_status == GSS_S_CONTINUE_NEEDED
  contents:
  - "3.1.3.2.  Value of major_status == GSS_S_CONTINUE_NEEDED\n   If the last call\
    \ to GSS_Init_sec_context yielded a major_status value\n   of GSS_S_CONTINUE_NEEDED,\
    \ then the negotiation is not yet complete.\n   The server will return to the\
    \ client a query response with a TKEY\n   record in the Answer section.  If the\
    \ DNS message error is not\n   NO_ERROR or error field in the TKEY record is not\
    \ 0 (i.e., no error),\n   then the client MUST abandon this negotiation sequence.\
    \  The client\n   MUST delete an active context by calling GSS_Delete_sec_context\n\
    \   providing the associated context_handle.  The client MAY repeat the\n   negotiation\
    \ sequence starting with the uninitialized state as\n   described in section 3.1.\
    \  To prevent infinite looping the number of\n   attempts to establish a security\
    \ context MUST be limited to ten or\n   less.\n   If the DNS message error is\
    \ NO_ERROR and the error field in the TKEY\n   record is 0 (i.e., no error), then\
    \ the client MUST pass a token\n   specified in the Key Data field in the TKEY\
    \ resource record to\n   GSS_Init_sec_context using the same parameters values\
    \ as in previous\n   call except values for CONTEXT HANDLE input_context_handle\
    \ and OCTET\n   STRING input_token as described below:\n   INPUTS\n     CONTEXT\
    \ HANDLE input_context_handle  = context_handle (this is the\n          context_handle\
    \ corresponding to the key_name which is the\n          owner name of the TKEY\
    \ record in the answer section in the\n          TKEY query response)\n     OCTET\
    \ STRING   input_token           = token from Key field of\n                 \
    \                           TKEY record\n   Depending on the following OUTPUT\
    \ values of GSS_Init_sec_context\n        INTEGER        major_status\n      \
    \  OCTET STRING   output_token\n   the client MUST take one of the following actions:\n\
    \   If OUTPUT major_status is set to one of the following values:\n        GSS_S_DEFECTIVE_TOKEN\n\
    \        GSS_S_DEFECTIVE_CREDENTIAL\n        GSS_S_BAD_SIG (GSS_S_BAD_MIC)\n \
    \       GSS_S_NO_CRED\n        GSS_S_CREDENTIALS_EXPIRED\n        GSS_S_BAD_BINDINGS\n\
    \        GSS_S_OLD_TOKEN\n        GSS_S_DUPLICATE_TOKEN\n        GSS_S_NO_CONTEXT\n\
    \        GSS_S_BAD_NAMETYPE\n        GSS_S_BAD_NAME\n        GSS_S_BAD_MECH\n\
    \        GSS_S_FAILURE\n   the client MUST abandon this negotiation sequence.\
    \  This means that\n   the client MUST delete an active context by calling\n \
    \  GSS_Delete_sec_context providing the associated context_handle.  The\n   client\
    \ MAY repeat the negotiation sequence starting with the\n   uninitialized state\
    \ as described in section 3.1.  To prevent infinite\n   looping the number of\
    \ attempts to establish a security context MUST\n   be limited to ten or less.\n\
    \   If OUTPUT major_status is GSS_S_CONTINUE_NEEDED OR GSS_S_COMPLETE\n   then\
    \ client MUST act as described below.\n   If the response from the server was\
    \ signed, and the OUTPUT\n   major_status is GSS_S_COMPLETE,then the signature\
    \ in the TSIG record\n   MUST be verified using the procedure detailed in section\
    \ 5, Sending\n   and Verifying Signed Messages.  If the signature is invalid,\
    \ then the\n   client MUST abandon this negotiation sequence.  This means that\
    \ the\n   client MUST delete an active context by calling\n   GSS_Delete_sec_context\
    \ providing the associated context_handle.  The\n   client MAY repeat the negotiation\
    \ sequence starting with the\n   uninitialized state as described in section 3.1.\
    \  To prevent infinite\n   looping the number of attempts to establish a security\
    \ context MUST\n   be limited to ten or less.\n   If major_status is GSS_S_CONTINUE_NEEDED\
    \ the negotiation is not yet\n   finished.  The token output_token MUST be passed\
    \ to the server in a\n   TKEY record by repeating the negotiation sequence beginning\
    \ with\n   section 3.1.2.  The client MUST place a limit on the number of\n  \
    \ continuations in a context negotiation to prevent endless looping.\n   Such\
    \ limit SHOULD NOT exceed value of 10.\n   If major_status is GSS_S_COMPLETE and\
    \ output_token is non-NULL, the\n   client-side component of the negotiation is\
    \ complete but the token\n   output_token MUST be passed to the server by repeating\
    \ the\n   negotiation sequence beginning with section 3.1.2.\n   If major_status\
    \ is GSS_S_COMPLETE and output_token is NULL, context\n   negotiation is complete.\
    \  The context state is advanced to Context\n   Established.  Proceed to section\
    \ 3.2 for usage of the security\n   context.\n"
- title: 3.2.  Context Established
  contents:
  - "3.2.  Context Established\n   When context negotiation is complete, the handle\
    \ context_handle MUST\n   be used for the generation and verification of transaction\n\
    \   signatures.\n   The procedures for sending and receiving signed messages are\n\
    \   described in section 5, Sending and Verifying Signed Messages.\n"
- title: 3.2.1.  Terminating a Context
  contents:
  - "3.2.1.  Terminating a Context\n   When the client is not intended to continue\
    \ using the established\n   security context, the client SHOULD delete an active\
    \ context by\n   calling GSS_Delete_sec_context providing the associated\n   context_handle,\
    \ AND client SHOULD delete the established context on\n   the DNS server by using\
    \ TKEY RR with the Mode field set to 5, i.e.,\n   \"key deletion\" [RFC2930].\n"
- title: 4.  Server Protocol Details
  contents:
  - "4.  Server Protocol Details\n   As on the client-side, the result of a successful\
    \ context negotiation\n   is a context handle used in future generation and verification\
    \ of the\n   transaction signatures.\n   A server MAY be managing several contexts\
    \ with several clients.\n   Clients identify their contexts by providing a key\
    \ name in their\n   request.  The server maintains a mapping of key names to handles:\n\
    \      (key_name, context_handle)\n"
- title: 4.1.  Negotiating Context
  contents:
  - "4.1.  Negotiating Context\n   A server MUST recognize TKEY queries as security\
    \ context negotiation\n   messages.\n"
- title: 4.1.1.  Receive TKEY Query from Client
  contents:
  - "4.1.1.  Receive TKEY Query from Client\n   Upon receiving a query with QTYPE\
    \ = TKEY, the server MUST examine\n   whether the Mode and Algorithm Name fields\
    \ of the TKEY record in the\n   additional records section of the message contain\
    \ values of 3 and\n   gss-tsig, respectively.  If they do, then the (key_name,\n\
    \   context_handle) mapping table is searched for the key_name matching\n   the\
    \ owner name of the TKEY record in the additional records section\n   of the query.\
    \  If the name is found in the table and the security\n   context for this name\
    \ is established and not expired, then the server\n   MUST respond to the query\
    \ with BADNAME error in the TKEY error field.\n   If the name is found in the\
    \ table and the security context is not\n   established, the corresponding context_handle\
    \ is used in subsequent\n   GSS operations.  If the name is found but the security\
    \ context is\n   expired, then the server deletes this security context, as described\n\
    \   in Section 4.2.1, and interprets this query as a start of new\n   security\
    \ context negotiation and performs operations described in\n   Section 4.1.2 and\
    \ 4.1.3.  If the name is not found, then the server\n   interprets this query\
    \ as a start of new security context negotiation\n   and performs operations described\
    \ in Section 4.1.2 and 4.1.3.\n"
- title: 4.1.2.  Call GSS_Accept_sec_context
  contents:
  - "4.1.2.  Call GSS_Accept_sec_context\n   The server performs its side of a context\
    \ negotiation by calling\n   GSS_Accept_sec_context.  The following input parameters\
    \ MUST be used.\n   The outcome of the call is indicated with the output values\
    \ below.\n   Consult Sections 2.2.2 \"GSS_Accept_sec_context call\" of the RFC\
    \ 2743\n   [RFC2743] for syntax definitions.\n   INPUTS\n     CONTEXT HANDLE input_context_handle\
    \  = 0 if new negotiation,\n                                            context_handle\
    \ matching\n                                         key_name if ongoing negotiation\n\
    \     OCTET STRING   input_token           = token specified in the Key\n    \
    \       field from TKEY RR (from Additional records Section of\n           the\
    \ client's query)\n     CREDENTIAL HANDLE acceptor_cred_handle = NULL (NULL specifies\
    \ \"use\n           default\").  Server MAY instead specify some other valid\n\
    \           handle to its credentials.\n     OCTET STRING   chan_bindings    \
    \      = Any valid channel bindings\n           as specified in Section 1.1.6\
    \ \"Channel Bindings\" in [RFC2743]\n   OUTPUTS\n     INTEGER        major_status\n\
    \     CONTEXT_HANDLE output_context_handle\n     OCTET STRING   output_token\n\
    \     INTEGER        minor_status\n     INTERNAL NAME  src_name\n     OBJECT IDENTIFIER\
    \  mech_type\n     BOOLEAN        deleg_state\n     BOOLEAN        mutual_state\n\
    \     BOOLEAN        replay_det_state\n     BOOLEAN        sequence_state\n  \
    \   BOOLEAN        anon_state\n     BOOLEAN        trans_state\n     BOOLEAN \
    \       prot_ready_state\n     BOOLEAN        conf_avail\n     BOOLEAN       \
    \ integ_avail\n     INTEGER        lifetime_rec\n     CONTEXT_HANDLE delegated_cred_handle\n\
    \   If this is the first call to GSS_Accept_sec_context in a new\n   negotiation,\
    \ then output_context_handle is stored in the server's\n   key-mapping table as\
    \ the context_handle that maps to the name of the\n   TKEY record.\n"
- title: 4.1.3.  Send TKEY Query-Response to Client
  contents:
  - "4.1.3.  Send TKEY Query-Response to Client\n   The server MUST respond to the\
    \ client with a TKEY query response with\n   RCODE = NOERROR, that contains a\
    \ TKEY record in the answer section.\n   If OUTPUT major_status is one of the\
    \ following errors the error field\n   in the TKEY record set to BADKEY.\n   \
    \     GSS_S_DEFECTIVE_TOKEN\n        GSS_S_DEFECTIVE_CREDENTIAL\n        GSS_S_BAD_SIG\
    \ (GSS_S_BAD_MIC)\n        GSS_S_DUPLICATE_TOKEN\n        GSS_S_OLD_TOKEN\n  \
    \      GSS_S_NO_CRED\n        GSS_S_CREDENTIALS_EXPIRED\n        GSS_S_BAD_BINDINGS\n\
    \        GSS_S_NO_CONTEXT\n        GSS_S_BAD_MECH\n        GSS_S_FAILURE\n   If\
    \ OUTPUT major_status is set to  GSS_S_COMPLETE or\n   GSS_S_CONTINUE_NEEDED then\
    \ server MUST act as described below.\n   If major_status is GSS_S_COMPLETE the\
    \ server component of the\n   negotiation is finished.  If output_token is non-NULL,\
    \ then it MUST\n   be returned to the client in a Key Data field of the RDATA\
    \ in TKEY.\n   The error field in the TKEY record is set to NOERROR.  The message\n\
    \   MUST be signed with a TSIG record as described in section 5, Sending\n   and\
    \ Verifying Signed Messages.  Note that server is allowed to sign a\n   response\
    \ to unsigned client's query due to modification to the RFC\n   2845 specified\
    \ in Section 2.2 above.  The context state is advanced\n   to Context Established.\
    \  Section 4.2 discusses the usage of the\n   security context.\n   If major_status\
    \ is GSS_S_COMPLETE and output_token is NULL, then the\n   TKEY record received\
    \ from the client MUST be returned in the Answer\n   section of the response.\
    \  The message MUST be signed with a TSIG\n   record as described in section 5,\
    \ Sending and Verifying Signed\n   Messages.  Note that server is allowed to sign\
    \ a response to unsigned\n   client's query due to modification to the RFC 2845\
    \ specified in\n   section 2.2 above.  The context state is advanced to Context\n\
    \   Established.  Section 4.2 discusses the usage of the security\n   context.\n\
    \   If major_status is GSS_S_CONTINUE_NEEDED, the server component of the\n  \
    \ negotiation is not yet finished.  The server responds to the TKEY\n   query\
    \ with a standard query response, placing in the answer section a\n   TKEY record\
    \ containing output_token in the Key Data RDATA field.  The\n   error field in\
    \ the TKEY record is set to NOERROR.  The server MUST\n   limit the number of\
    \ times that a given context is allowed to repeat,\n   to prevent endless looping.\
    \  Such limit SHOULD NOT exceed value of\n   10.\n   In all cases, except if major_status\
    \ is GSS_S_COMPLETE and\n   output_token is NULL, other TKEY record fields MUST\
    \ contain the\n   following values:\n        NAME = key_name\n        RDATA\n\
    \           Algorithm Name      = gss-tsig\n           Mode                = 3\
    \ (GSS-API negotiation - per [RFC2930])\n           Key Size            = size\
    \ of output_token in octets\n   The remaining fields in the TKEY RDATA, i.e.,\
    \ Inception, Expiration,\n   Error, Other Size and Data Fields, MUST be set according\
    \ to\n   [RFC2930].\n"
- title: 4.2.  Context Established
  contents:
  - "4.2.  Context Established\n   When context negotiation is complete, the handle\
    \ context_handle is\n   used for the generation and verification of transaction\
    \ signatures.\n   The handle is valid for a finite amount of time determined by\
    \ the\n   underlying security mechanism.  A server MAY unilaterally terminate\
    \ a\n   context at any time (see section 4.2.1).\n   Server SHOULD limit the amount\
    \ of memory used to cache established\n   contexts.\n   The procedures for sending\
    \ and receiving signed messages are given in\n   section 5, Sending and Verifying\
    \ Signed Messages.\n"
- title: 4.2.1.  Terminating a Context
  contents:
  - "4.2.1.  Terminating a Context\n   A server can terminate any established context\
    \ at any time.  The\n   server MAY hint to the client that the context is being\
    \ deleted by\n   including a TKEY RR in a response with the Mode field set to\
    \ 5, i.e.,\n   \"key deletion\" [RFC2930].  An active context is deleted by calling\n\
    \   GSS_Delete_sec_context providing the associated context_handle.\n"
- title: 5.  Sending and Verifying Signed Messages
  contents:
  - '5.  Sending and Verifying Signed Messages

    '
- title: 5.1.  Sending a Signed Message - Call GSS_GetMIC
  contents:
  - "5.1.  Sending a Signed Message - Call GSS_GetMIC\n   The procedure for sending\
    \ a signature-protected message is specified\n   in [RFC2845].  The data to be\
    \ passed to the signature routine\n   includes the whole DNS message with specific\
    \ TSIG variables appended.\n   For the exact format, see [RFC2845].  For this\
    \ protocol, use the\n   following TSIG variable values:\n      TSIG Record\n \
    \       NAME = key_name that identifies this context\n        RDATA\n        \
    \   Algorithm Name = gss-tsig\n   Assign the remaining fields in the TSIG RDATA\
    \ appropriate values as\n   described in [RFC2845].\n   The signature is generated\
    \ by calling GSS_GetMIC.  The following\n   input parameters MUST be used.  The\
    \ outcome of the call is indicated\n   with the output values specified below.\
    \  Consult Sections 2.3.1\n   \"GSS_GetMIC call\" of the RFC 2743[RFC2743] for\
    \ syntax definitions.\n   INPUTS\n     CONTEXT HANDLE context_handle = context_handle\
    \ for key_name\n     OCTET STRING   message        = outgoing message plus TSIG\n\
    \                                     variables (per [RFC2845])\n     INTEGER\
    \ qop_req               = 0 (0 requests a default\n         value).  Caller MAY\
    \ instead specify other valid value (for\n         details see Section 1.2.4 in\
    \ [RFC2743])\n   OUTPUTS\n     INTEGER        major_status\n     INTEGER     \
    \   minor_status\n     OCTET STRING   per_msg_token\n   If major_status is GSS_S_COMPLETE,\
    \ then signature generation\n   succeeded.  The signature in per_msg_token is\
    \ inserted into the\n   Signature field of the TSIG RR and the message is transmitted.\n\
    \   If major_status is GSS_S_CONTEXT_EXPIRED, GSS_S_CREDENTIALS_EXPIRED\n   or\
    \ GSS_S_FAILURE the caller MUST delete the security context, return\n   to the\
    \ uninitialized state and SHOULD negotiate a new security\n   context, as described\
    \ above in Section 3.1\n   If major_status is GSS_S_NO_CONTEXT, the caller MUST\
    \ remove the entry\n   for key_name from the (target_ name, key_name, context_handle)\n\
    \   mapping table, return to the uninitialized state and SHOULD negotiate\n  \
    \ a new security context, as described above in Section 3.1\n   If major_status\
    \ is GSS_S_BAD_QOP, the caller SHOULD repeat the\n   GSS_GetMIC call with allowed\
    \ QOP value.  The number of such\n   repetitions MUST be limited to prevent infinite\
    \ loops.\n"
- title: 5.2.  Verifying a Signed Message - Call GSS_VerifyMIC
  contents:
  - "5.2.  Verifying a Signed Message - Call GSS_VerifyMIC\n   The procedure for verifying\
    \ a signature-protected message is\n   specified in [RFC2845].\n   The NAME of\
    \ the TSIG record determines which context_handle maps to\n   the context that\
    \ MUST be used to verify the signature.  If the NAME\n   does not map to an established\
    \ context, the server MUST send a\n   standard TSIG error response to the client\
    \ indicating BADKEY in the\n   TSIG error field (as described in [RFC2845]).\n\
    \   For the GSS algorithm, a signature is verified by using\n   GSS_VerifyMIC:\n\
    \   INPUTS\n     CONTEXT HANDLE context_handle = context_handle for key_name\n\
    \     OCTET STRING   message        = incoming message plus TSIG\n           \
    \                          variables (per [RFC2845])\n     OCTET STRING   per_msg_token\
    \  = Signature field from TSIG RR\n   OUTPUTS\n     INTEGER        major_status\n\
    \     INTEGER        minor_status\n     INTEGER        qop_state\n   If major_status\
    \ is GSS_S_COMPLETE, the signature is authentic and the\n   message was delivered\
    \ intact.  Per [RFC2845], the timer values of the\n   TSIG record MUST also be\
    \ valid before considering the message to be\n   authentic.  The caller MUST not\
    \ act on the request or response in the\n   message until these checks are verified.\n\
    \   When a server is processing a client request, the server MUST send a\n   standard\
    \ TSIG error response to the client indicating BADKEY in the\n   TSIG error field\
    \ as described in [RFC2845], if major_status is set to\n   one of the following\
    \ values\n        GSS_S_DEFECTIVE_TOKEN\n        GSS_S_BAD_SIG (GSS_S_BAD_MIC)\n\
    \        GSS_S_DUPLICATE_TOKEN\n        GSS_S_OLD_TOKEN\n        GSS_S_UNSEQ_TOKEN\n\
    \        GSS_S_GAP_TOKEN\n        GSS_S_CONTEXT_EXPIRED\n        GSS_S_NO_CONTEXT\n\
    \        GSS_S_FAILURE\n   If the timer values of the TSIG record are invalid,\
    \ the message MUST\n   NOT be considered authentic.  If this error checking fails\
    \ when a\n   server is processing a client request, the appropriate error response\n\
    \   MUST be sent to the client according to [RFC2845].\n"
- title: 6.  Example usage of GSS-TSIG algorithm
  contents:
  - "6.  Example usage of GSS-TSIG algorithm\n   This Section describes an example\
    \ where a Client, client.example.com,\n   and a Server, server.example.com, establish\
    \ a security context\n   according to the algorithm described above.\n  I.  Client\
    \ initializes security context negotiation\n  To establish a security context\
    \ with a server, server.example.com, the\n  Client calls GSS_Init_sec_context\
    \ with the following parameters.\n  (Note that some INPUT and OUTPUT parameters\
    \ not critical for this\n  algorithm are not described in this example.)\n   \
    \  CONTEXT HANDLE input_context_handle  = 0\n     INTERNAL NAME  targ_name   \
    \          = \"DNS@server.example.com\"\n     OCTET STRING   input_token     \
    \      = NULL\n     BOOLEAN        replay_det_req_flag   = TRUE\n     BOOLEAN\
    \        mutual_req_flag       = TRUE\n  The OUTPUTS parameters returned by GSS_Init_sec_context\
    \ include\n     INTEGER        major_status = GSS_S_CONTINUE_NEEDED\n     CONTEXT\
    \ HANDLE output_context_handle context_handle\n     OCTET STRING   output_token\
    \ output_token\n     BOOLEAN        replay_det_state = TRUE\n     BOOLEAN    \
    \    mutual_state = TRUE\n  Client verifies that replay_det_state and mutual_state\
    \ values are\n  TRUE.  Since the major_status is GSS_S_CONTINUE_NEEDED, which\
    \ is a\n  success OUTPUT major_status value, client stores context_handle that\n\
    \  maps to \"DNS@server.example.com\" and proceeds to the next step.\n  II.  Client\
    \ sends a query with QTYPE = TKEY to server\n  Client sends a query with QTYPE\
    \ = TKEY for a client-generated globally\n  unique domain name string, 789.client.example.com.server.example.com.\n\
    \  Query contains a TKEY record in its Additional records section with\n  the\
    \ following fields.  (Note that some fields not specific to this\n  algorithm\
    \ are not specified.)\n     NAME = 789.client.example.com.server.example.com.\n\
    \     RDATA\n        Algorithm Name      = gss-tsig\n        Mode            \
    \    = 3 (GSS-API negotiation - per [RFC2930])\n        Key Size            =\
    \ size of output_token in octets\n        Key Data            = output_token\n\
    \  After the key_name 789.client.example.com.server.example.com.\n  is generated\
    \ it is stored in the client's (target_name, key_name,\n  context_handle) mapping\
    \ table.\n  III.  Server receives a query with QTYPE = TKEY\n  When server receives\
    \ a query with QTYPE = TKEY, the server verifies\n  that Mode and Algorithm fields\
    \ in the TKEY record in the Additional\n  records section of the query are set\
    \ to 3 and \"gss-tsig\" respectively.\n  It finds that the key_name 789.client.example.com.server.example.com.\n\
    \  is not listed in its (key_name, context_handle) mapping table.\n  IV.  Server\
    \ calls GSS_Accept_sec_context\n  To continue security context negotiation server\
    \ calls\n  GSS_Accept_sec_context with the following parameters.  (Note that\n\
    \  some INPUT and OUTPUT parameters not critical for this algorithm\n  are not\
    \ described in this example.)\n   INPUTS\n     CONTEXT HANDLE input_context_handle\
    \  = 0\n     OCTET STRING   input_token           = token specified in the Key\n\
    \                              field from TKEY RR (from Additional\n         \
    \                     records section of the client's query)\n  The OUTPUTS parameters\
    \ returned by GSS_Accept_sec_context include\n     INTEGER        major_status\
    \ = GSS_S_CONTINUE_NEEDED\n     CONTEXT_HANDLE output_context_handle context_handle\n\
    \     OCTET STRING   output_token output_token\n  Server stores the mapping of\
    \ the\n  789.client.example.com.server.example.com. to OUTPUT context_handle\n\
    \  in its (key_name, context_handle) mapping table.\n  V.  Server responds to\
    \ the TKEY query\n  Since the major_status = GSS_S_CONTINUE_NEEDED in the last\
    \ server's\n  call to GSS_Accept_sec_context, the server responds to the TKEY\
    \ query\n  placing in the answer section a TKEY record containing output_token\
    \ in\n  the Key Data RDATA field.  The error field in the TKEY record is set\n\
    \  to 0.  The RCODE in the query response is set to NOERROR.\n  VI.  Client processes\
    \ token returned by server\n  When the client receives the TKEY query response\
    \ from the server, the\n  client calls GSS_Init_sec_context with the following\
    \ parameters.\n  (Note that some INPUT and OUTPUT parameters not critical for\
    \ this\n  algorithm are not described in this example.)\n     CONTEXT HANDLE input_context_handle\
    \  = the context_handle stored\n          in the client's mapping table entry\
    \ (DNS@server.example.com.,\n          789.client.example.com.server.example.com.,\
    \ context_handle)\n     INTERNAL NAME  targ_name             = \"DNS@server.example.com\"\
    \n     OCTET STRING   input_token           = token from Key field of TKEY\n \
    \         record from the Answer section of the server's response\n     BOOLEAN\
    \        replay_det_req_flag   = TRUE\n     BOOLEAN        mutual_req_flag   \
    \    = TRUE\n  The OUTPUTS parameters returned by GSS_Init_sec_context include\n\
    \     INTEGER        major_status = GSS_S_COMPLETE\n     CONTEXT HANDLE output_context_handle\
    \ = context_handle\n     OCTET STRING   output_token = output_token\n     BOOLEAN\
    \        replay_det_state = TRUE\n     BOOLEAN        mutual_state = TRUE\n  Since\
    \ the major_status is set to GSS_S_COMPLETE the client side\n  security context\
    \ is established, but since the output_token is not\n  NULL client MUST send a\
    \ TKEY query to the server as described below.\n  VII.  Client sends a query with\
    \ QTYPE = TKEY to server\n  Client sends to the server a TKEY query for the\n\
    \  789.client.example.com.server.example.com. name.  Query contains a\n  TKEY\
    \ record in its Additional records section with the following\n  fields.  (Note\
    \ that some INPUT and OUTPUT parameters not critical to\n  this algorithm are\
    \ not described in this example.)\n     NAME = 789.client.example.com.server.example.com.\n\
    \     RDATA\n        Algorithm Name      = gss-tsig\n        Mode            \
    \    = 3 (GSS-API negotiation - per [RFC2930])\n        Key Size            =\
    \ size of output_token in octets\n        Key Data            = output_token\n\
    \  VIII.  Server receives a TKEY query\n  When the server receives a TKEY query,\
    \ the server verifies that Mode\n  and Algorithm fields in the TKEY record in\
    \ the Additional records\n  section of the query are set to 3 and gss-tsig, respectively.\
    \  It\n  finds that the key_name 789.client.example.com.server.example.com. is\n\
    \  listed in its (key_name, context_handle) mapping table.\n  IX.  Server calls\
    \ GSS_Accept_sec_context\n  To continue security context negotiation server calls\n\
    \  GSS_Accept_sec_context with the following parameters (Note that some\n  INPUT\
    \ and OUTPUT parameters not critical for this algorithm are not\n  described in\
    \ this example)\n   INPUTS\n     CONTEXT HANDLE input_context_handle  = context_handle\
    \ from the\n           (789.client.example.com.server.example.com., context_handle)\n\
    \           entry in the server's mapping table\n     OCTET STRING   input_token\
    \           = token specified in the Key\n           field of TKEY RR (from Additional\
    \ records Section of\n           the client's query)\n  The OUTPUTS parameters\
    \ returned by GSS_Accept_sec_context include\n     INTEGER        major_status\
    \ = GSS_S_COMPLETE\n     CONTEXT_HANDLE output_context_handle = context_handle\n\
    \     OCTET STRING   output_token = NULL\n  Since major_status = GSS_S_COMPLETE,\
    \ the security context on the\n  server side is established, but the server still\
    \ needs to respond to\n  the client's TKEY query, as described below.  The security\
    \ context\n  state is advanced to Context Established.\n  X.  Server responds\
    \ to the TKEY query\n  Since the major_status = GSS_S_COMPLETE in the last server's\
    \ call to\n  GSS_Accept_sec_context and the output_token is NULL, the server\n\
    \  responds to the TKEY query placing in the answer section a TKEY record\n  that\
    \ was sent by the client in the Additional records section of the\n  client's\
    \ latest TKEY query.  In addition, this server places a\n  TSIG record in additional\
    \ records section of its response.  Server\n  calls GSS_GetMIC to generate a signature\
    \ to include it in the TSIG\n  record.  The server specifies the following GSS_GetMIC\
    \ INPUT\n  parameters:\n     CONTEXT HANDLE context_handle = context_handle from\
    \ the\n           (789.client.example.com.server.example.com., context_handle)\n\
    \           entry in the server's mapping table\n     OCTET STRING   message \
    \       = outgoing message plus TSIG\n                                   variables\
    \ (as described in [RFC2845])\n  The OUTPUTS parameters returned by GSS_GetMIC\
    \ include\n     INTEGER        major_status = GSS_S_COMPLETE\n     OCTET STRING\
    \   per_msg_token\n  Signature field in the TSIG record is set to per_msg_token.\n\
    \  XI.  Client processes token returned by server\n  Client receives the TKEY\
    \ query response from the server.  Since the\n  major_status was GSS_S_COMPLETE\
    \ in the last client's call to\n  GSS_Init_sec_context, the client verifies that\
    \ the server's response\n  is signed.  To validate the signature, the client calls\n\
    \  GSS_VerifyMIC with the following parameters:\n   INPUTS\n     CONTEXT HANDLE\
    \ context_handle = context_handle for\n                  789.client.example.com.server.example.com.\
    \ key_name\n     OCTET STRING   message        = incoming message plus TSIG\n\
    \                                  variables (as described in [RFC2845])\n   \
    \  OCTET STRING   per_msg_token  = Signature field from TSIG RR\n            \
    \      included in the server's query response\n  Since the OUTPUTS parameter\
    \ major_status = GSS_S_COMPLETE, the\n  signature is validated, security negotiation\
    \ is complete and the\n  security context state is advanced to Context Established.\
    \  These\n  client and server will use the established security context to sign\n\
    \  and validate the signatures when they exchange packets with each\n  other until\
    \ the context expires.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This document describes a protocol for DNS security\
    \ using GSS-API.\n   The security provided by this protocol is only as effective\
    \ as the\n   security provided by the underlying GSS mechanisms.\n   All the security\
    \ considerations from RFC 2845, RFC 2930 and RFC 2743\n   apply to the protocol\
    \ described in this document.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   The IANA has reserved the TSIG Algorithm name gss-tsig\
    \ for the use in\n   the Algorithm fields of TKEY and TSIG resource records. \
    \ This\n   Algorithm name refers to the algorithm described in this document.\n\
    \   The requirement to have this name registered with IANA is specified\n   in\
    \ RFC 2845.\n"
- title: 9.  Conformance
  contents:
  - "9.  Conformance\n   The GSS API using SPNEGO [RFC2478] provides maximum flexibility\
    \ to\n   choose the underlying security mechanisms that enables security\n   context\
    \ negotiation.  GSS API using SPNEGO [RFC2478] enables client\n   and server to\
    \ negotiate and choose such underlying security\n   mechanisms on the fly.  To\
    \ support such flexibility, DNS clients and\n   servers SHOULD specify SPNEGO\
    \ mech_type in their GSS API calls.  At\n   the same time, in order to guarantee\
    \ interoperability between DNS\n   clients and servers that support GSS-TSIG it\
    \ is required that\n   -  DNS servers specify SPNEGO mech_type\n   -  GSS APIs\
    \ called by DNS client support Kerberos v5\n   -  GSS APIs called by DNS server\
    \ support SPNEGO [RFC2478] and\n      Kerberos v5.\n   In addition to these, GSS\
    \ APIs used by DNS client and server MAY also\n   support other underlying security\
    \ mechanisms.\n"
- title: 10.  Intellectual Property Statement
  contents:
  - "10.  Intellectual Property Statement\n   The IETF takes no position regarding\
    \ the validity or scope of any\n   intellectual property or other rights that\
    \ might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP-11.  Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n   The IETF invites\
    \ any interested party to bring to its attention any\n   copyrights, patents or\
    \ patent applications, or other proprietary\n   rights which may cover technology\
    \ that may be required to practice\n   this standard.  Please address the information\
    \ to the IETF Executive\n   Director.\n"
- title: 11.  Acknowledgements
  contents:
  - "11.  Acknowledgements\n   The authors of this document would like to thank the\
    \ following people\n   for their contribution to this specification:  Chuck Chan,\
    \ Mike\n   Swift, Ram Viswanathan, Olafur Gudmundsson, Donald E. Eastlake, 3rd\n\
    \   and Erik Nordmark.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [RFC2119] Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n             Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC2478] Baize, E. and D. Pinkas, \"The Simple and Protected GSS-API\n\
    \             Negotiation Mechanism\", RFC 2478, December 1998.\n   [RFC2743]\
    \ Linn, J., \"Generic Security Service Application Program\n             Interface,\
    \ Version 2 , Update 1\", RFC 2743, January 2000.\n   [RFC2845] Vixie, P., Gudmundsson,\
    \ O., Eastlake 3rd, D. and B.\n             Wellington, \"Secret Key Transaction\
    \ Authentication for DNS\n             (TSIG)\", RFC 2845, May 2000.\n   [RFC2930]\
    \ Eastlake 3rd, D., \"Secret Key Establishment for DNS (TKEY\n             RR)\"\
    , RFC 2930, September 2000.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [ISO11578] \"Information technology\", \"Open\
    \ Systems Interconnection\",\n              \"Remote Procedure Call\", ISO/IEC\
    \ 11578:1996,\n              http://www.iso.ch/cate/d2229.html.\n   [RFC1034]\
    \ Mockapetris, P., \"Domain Names - Concepts and Facilities\",\n             STD\
    \ 13, RFC 1034, November 1987.\n   [RFC1035] Mockapetris, P., \"Domain Names -\
    \ Implementation and\n             Specification\", STD 13, RFC 1034, November\
    \ 1987.\n   [RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\",\
    \ RFC\n             1964, June 1996.\n   [RFC2025] Adams, C., \"The Simple Public-Key\
    \ GSS-API Mechanism\n             (SPKM)\", RFC 2025, October 1996.\n   [RFC2137]\
    \ Eastlake 3rd, D., \"Secure Domain Name System Dynamic\n             Update\"\
    , RFC 2137, April 1997.\n   [RFC2535] Eastlake 3rd, D., \"Domain Name System Security\
    \ Extensions\",\n             RFC 2535, March 1999.\n"
- title: 13.  Authors' Addresses
  contents:
  - "13.  Authors' Addresses\n   Stuart Kwan\n   Microsoft Corporation\n   One Microsoft\
    \ Way\n   Redmond, WA  98052\n   USA\n   EMail: skwan@microsoft.com\n   Praerit\
    \ Garg\n   Microsoft Corporation\n   One Microsoft Way\n   Redmond, WA  98052\n\
    \   USA\n   EMail: praeritg@microsoft.com\n   James Gilroy\n   Microsoft Corporation\n\
    \   One Microsoft Way\n   Redmond, WA  98052\n   USA\n   EMail: jamesg@microsoft.com\n\
    \   Levon Esibov\n   Microsoft Corporation\n   One Microsoft Way\n   Redmond,\
    \ WA  98052\n   USA\n   EMail: levone@microsoft.com\n   Randy Hall\n   Lucent\
    \ Technologies\n   400 Lapp Road\n   Malvern PA 19355\n   USA\n   EMail: randyhall@lucent.com\n\
    \   Jeff Westhead\n   Microsoft Corporation\n   One Microsoft Way\n   Redmond,\
    \ WA  98052\n   USA\n   EMail: jwesth@microsoft.com\n"
- title: 14.  Full Copyright Statement
  contents:
  - "14.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assignees.\n\
    \   This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
