- title: __initial_text__
  contents:
  - '            Security Architecture for the Internet Protocol

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes an updated version of the \"Security\n \
    \  Architecture for IP\", which is designed to provide security services\n   for\
    \ traffic at the IP layer.  This document obsoletes RFC 2401\n   (November 1998).\n"
- title: Dedication
  contents:
  - "Dedication\n   This document is dedicated to the memory of Charlie Lynn, a long-time\n\
    \   senior colleague at BBN, who made very significant contributions to\n   the\
    \ IPsec documents.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Summary of Contents of Document ............................4\n  \
    \    1.2. Audience ...................................................4\n    \
    \  1.3. Related Documents ..........................................5\n   2. Design\
    \ Objectives ...............................................5\n      2.1. Goals/Objectives/Requirements/Problem\
    \ Description ..........5\n      2.2. Caveats and Assumptions ....................................6\n\
    \   3. System Overview .................................................7\n  \
    \    3.1. What IPsec Does ............................................7\n    \
    \  3.2. How IPsec Works ............................................9\n      3.3.\
    \ Where IPsec Can Be Implemented ............................10\n   4. Security\
    \ Associations ..........................................11\n      4.1. Definition\
    \ and Scope ......................................12\n      4.2. SA Functionality\
    \ ..........................................16\n      4.3. Combining SAs .............................................17\n\
    \      4.4. Major IPsec Databases .....................................18\n  \
    \         4.4.1. The Security Policy Database (SPD) .................19\n    \
    \              4.4.1.1. Selectors .................................26\n      \
    \            4.4.1.2. Structure of an SPD Entry .................30\n        \
    \          4.4.1.3. More Regarding Fields Associated\n                       \
    \    with Next Layer Protocols .................32\n           4.4.2. Security\
    \ Association Database (SAD) ................34\n                  4.4.2.1. Data\
    \ Items in the SAD .....................36\n                  4.4.2.2. Relationship\
    \ between SPD, PFP\n                           flag, packet, and SAD .....................38\n\
    \           4.4.3. Peer Authorization Database (PAD) ..................43\n  \
    \                4.4.3.1. PAD Entry IDs and Matching Rules ..........44\n    \
    \              4.4.3.2. IKE Peer Authentication Data ..............45\n      \
    \            4.4.3.3. Child SA Authorization Data ...............46\n        \
    \          4.4.3.4. How the PAD Is Used .......................46\n      4.5.\
    \ SA and Key Management .....................................47\n           4.5.1.\
    \ Manual Techniques ..................................48\n           4.5.2. Automated\
    \ SA and Key Management ....................48\n           4.5.3. Locating a Security\
    \ Gateway ........................49\n      4.6. SAs and Multicast .........................................50\n\
    \   5. IP Traffic Processing ..........................................50\n  \
    \    5.1. Outbound IP Traffic Processing\n           (protected-to-unprotected)\
    \ ................................52\n           5.1.1. Handling an Outbound Packet\
    \ That Must Be\n                  Discarded ..........................................54\n\
    \           5.1.2. Header Construction for Tunnel Mode ................55\n  \
    \                5.1.2.1. IPv4: Header Construction for\n                    \
    \       Tunnel Mode ...............................57\n                  5.1.2.2.\
    \ IPv6: Header Construction for\n                           Tunnel Mode ...............................59\n\
    \      5.2. Processing Inbound IP Traffic (unprotected-to-protected) ..59\n  \
    \ 6. ICMP Processing ................................................63\n    \
    \  6.1. Processing ICMP Error Messages Directed to an\n           IPsec Implementation\
    \ ......................................63\n           6.1.1. ICMP Error Messages\
    \ Received on the\n                  Unprotected Side of the Boundary ...................63\n\
    \           6.1.2. ICMP Error Messages Received on the\n                  Protected\
    \ Side of the Boundary .....................64\n      6.2. Processing Protected,\
    \ Transit ICMP Error Messages .........64\n   7. Handling Fragments (on the protected\
    \ side of the IPsec\n      boundary) ......................................................66\n\
    \      7.1. Tunnel Mode SAs that Carry Initial and Non-Initial\n           Fragments\
    \ .................................................67\n      7.2. Separate Tunnel\
    \ Mode SAs for Non-Initial Fragments ........67\n      7.3. Stateful Fragment\
    \ Checking ................................68\n      7.4. BYPASS/DISCARD Traffic\
    \ ....................................69\n   8. Path MTU/DF Processing .........................................69\n\
    \      8.1. DF Bit ....................................................69\n  \
    \    8.2. Path MTU (PMTU) Discovery .................................70\n    \
    \       8.2.1. Propagation of PMTU ................................70\n      \
    \     8.2.2. PMTU Aging .........................................71\n   9. Auditing\
    \ .......................................................71\n   10. Conformance\
    \ Requirements ......................................71\n   11. Security Considerations\
    \ .......................................72\n   12. IANA Considerations ...........................................72\n\
    \   13. Differences from RFC 2401 .....................................72\n  \
    \ 14. Acknowledgements ..............................................75\n   Appendix\
    \ A: Glossary ..............................................76\n   Appendix B:\
    \ Decorrelation .........................................79\n      B.1. Decorrelation\
    \ Algorithm ...................................79\n   Appendix C: ASN.1 for an\
    \ SPD Entry ................................82\n   Appendix D: Fragment Handling\
    \ Rationale ...........................88\n      D.1. Transport Mode and Fragments\
    \ ..............................88\n      D.2. Tunnel Mode and Fragments .................................89\n\
    \      D.3. The Problem of Non-Initial Fragments ......................90\n  \
    \    D.4. BYPASS/DISCARD Traffic ....................................93\n    \
    \  D.5. Just say no to ports? .....................................94\n      D.6.\
    \ Other Suggested Solutions..................................94\n      D.7. Consistency................................................95\n\
    \      D.8. Conclusions................................................95\n  \
    \ Appendix E: Example of Supporting Nested SAs via SPD and\n               Forwarding\
    \ Table Entries...............................96\n   References.........................................................98\n\
    \      Normative References............................................98\n  \
    \    Informative References..........................................99\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Summary of Contents of Document
  contents:
  - "1.1.  Summary of Contents of Document\n   This document specifies the base architecture\
    \ for IPsec-compliant\n   systems.  It describes how to provide a set of security\
    \ services for\n   traffic at the IP layer, in both the IPv4 [Pos81a] and IPv6\
    \ [DH98]\n   environments.  This document describes the requirements for systems\n\
    \   that implement IPsec, the fundamental elements of such systems, and\n   how\
    \ the elements fit together and fit into the IP environment.  It\n   also describes\
    \ the security services offered by the IPsec protocols,\n   and how these services\
    \ can be employed in the IP environment.  This\n   document does not address all\
    \ aspects of the IPsec architecture.\n   Other documents address additional architectural\
    \ details in\n   specialized environments, e.g., use of IPsec in Network Address\n\
    \   Translation (NAT) environments and more comprehensive support for IP\n   multicast.\
    \  The fundamental components of the IPsec security\n   architecture are discussed\
    \ in terms of their underlying, required\n   functionality.  Additional RFCs (see\
    \ Section 1.3 for pointers to\n   other documents) define the protocols in (a),\
    \ (c), and (d).\n        a. Security Protocols -- Authentication Header (AH) and\n\
    \           Encapsulating Security Payload (ESP)\n        b. Security Associations\
    \ -- what they are and how they work,\n           how they are managed, associated\
    \ processing\n        c. Key Management -- manual and automated (The Internet\
    \ Key\n           Exchange (IKE))\n        d. Cryptographic algorithms for authentication\
    \ and encryption\n   This document is not a Security Architecture for the Internet;\
    \ it\n   addresses security only at the IP layer, provided through the use of\n\
    \   a combination of cryptographic and protocol security mechanisms.\n   The spelling\
    \ \"IPsec\" is preferred and used throughout this and all\n   related IPsec standards.\
    \  All other capitalizations of IPsec (e.g.,\n   IPSEC, IPSec, ipsec) are deprecated.\
    \  However, any capitalization of\n   the sequence of letters \"IPsec\" should\
    \ be understood to refer to the\n   IPsec protocols.\n   The keywords MUST, MUST\
    \ NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,\n   SHOULD NOT, RECOMMENDED, MAY, and\
    \ OPTIONAL, when they appear in this\n   document, are to be interpreted as described\
    \ in RFC 2119 [Bra97].\n"
- title: 1.2.  Audience
  contents:
  - "1.2.  Audience\n   The target audience for this document is primarily individuals\
    \ who\n   implement this IP security technology or who architect systems that\n\
    \   will use this technology.  Technically adept users of this technology\n  \
    \ (end users or system administrators) also are part of the target\n   audience.\
    \  A glossary is provided in Appendix A to help fill in gaps\n   in background/vocabulary.\
    \  This document assumes that the reader is\n   familiar with the Internet Protocol\
    \ (IP), related networking\n   technology, and general information system security\
    \ terms and\n   concepts.\n"
- title: 1.3.  Related Documents
  contents:
  - "1.3.  Related Documents\n   As mentioned above, other documents provide detailed\
    \ definitions of\n   some of the components of IPsec and of their interrelationship.\
    \  They\n   include RFCs on the following topics:\n        a. security protocols\
    \ -- RFCs describing the Authentication\n           Header (AH) [Ken05b] and Encapsulating\
    \ Security Payload\n           (ESP) [Ken05a] protocols.\n        b. cryptographic\
    \ algorithms for integrity and encryption -- one\n           RFC that defines\
    \ the mandatory, default algorithms for use\n           with AH and ESP [Eas05],\
    \ a similar RFC that defines the\n           mandatory algorithms for use with\
    \ IKEv2 [Sch05] plus a\n           separate RFC for each cryptographic algorithm.\n\
    \        c. automatic key management -- RFCs on \"The Internet Key\n         \
    \  Exchange (IKEv2) Protocol\" [Kau05] and \"Cryptographic\n           Algorithms\
    \ for Use in the Internet Key Exchange Version 2\n           (IKEv2)\" [Sch05].\n"
- title: 2.  Design Objectives
  contents:
  - '2.  Design Objectives

    '
- title: 2.1.  Goals/Objectives/Requirements/Problem Description
  contents:
  - "2.1.  Goals/Objectives/Requirements/Problem Description\n   IPsec is designed\
    \ to provide interoperable, high quality,\n   cryptographically-based security\
    \ for IPv4 and IPv6.  The set of\n   security services offered includes access\
    \ control, connectionless\n   integrity, data origin authentication, detection\
    \ and rejection of\n   replays (a form of partial sequence integrity), confidentiality\
    \ (via\n   encryption), and limited traffic flow confidentiality.  These\n   services\
    \ are provided at the IP layer, offering protection in a\n   standard fashion\
    \ for all protocols that may be carried over IP\n   (including IP itself).\n \
    \  IPsec includes a specification for minimal firewall functionality,\n   since\
    \ that is an essential aspect of access control at the IP layer.\n   Implementations\
    \ are free to provide more sophisticated firewall\n   mechanisms, and to implement\
    \ the IPsec-mandated functionality using\n   those more sophisticated mechanisms.\
    \ (Note that interoperability may\n   suffer if additional firewall constraints\
    \ on traffic flows are\n   imposed by an IPsec implementation but cannot be negotiated\
    \ based on\n   the traffic selector features defined in this document and negotiated\n\
    \   via IKEv2.)  The IPsec firewall function makes use of the\n   cryptographically-enforced\
    \ authentication and integrity provided for\n   all IPsec traffic to offer better\
    \ access control than could be\n   obtained through use of a firewall (one not\
    \ privy to IPsec internal\n   parameters) plus separate cryptographic protection.\n\
    \   Most of the security services are provided through use of two traffic\n  \
    \ security protocols, the Authentication Header (AH) and the\n   Encapsulating\
    \ Security Payload (ESP), and through the use of\n   cryptographic key management\
    \ procedures and protocols.  The set of\n   IPsec protocols employed in a context,\
    \ and the ways in which they are\n   employed, will be determined by the users/administrators\
    \ in that\n   context.  It is the goal of the IPsec architecture to ensure that\n\
    \   compliant implementations include the services and management\n   interfaces\
    \ needed to meet the security requirements of a broad user\n   population.\n \
    \  When IPsec is correctly implemented and deployed, it ought not\n   adversely\
    \ affect users, hosts, and other Internet components that do\n   not employ IPsec\
    \ for traffic protection.  IPsec security protocols\n   (AH and ESP, and to a\
    \ lesser extent, IKE) are designed to be\n   cryptographic algorithm independent.\
    \  This modularity permits\n   selection of different sets of cryptographic algorithms\
    \ as\n   appropriate, without affecting the other parts of the implementation.\n\
    \   For example, different user communities may select different sets of\n   cryptographic\
    \ algorithms (creating cryptographically-enforced\n   cliques) if required.\n\
    \   To facilitate interoperability in the global Internet, a set of\n   default\
    \ cryptographic algorithms for use with AH and ESP is specified\n   in [Eas05]\
    \ and a set of mandatory-to-implement algorithms for IKEv2\n   is specified in\
    \ [Sch05].  [Eas05] and [Sch05] will be periodically\n   updated to keep pace\
    \ with computational and cryptologic advances.  By\n   specifying these algorithms\
    \ in documents that are separate from the\n   AH, ESP, and IKEv2 specifications,\
    \ these algorithms can be updated or\n   replaced without affecting the standardization\
    \ progress of the rest\n   of the IPsec document suite.  The use of these cryptographic\n\
    \   algorithms, in conjunction with IPsec traffic protection and key\n   management\
    \ protocols, is intended to permit system and application\n   developers to deploy\
    \ high quality, Internet-layer, cryptographic\n   security technology.\n"
- title: 2.2.  Caveats and Assumptions
  contents:
  - "2.2.  Caveats and Assumptions\n   The suite of IPsec protocols and associated\
    \ default cryptographic\n   algorithms are designed to provide high quality security\
    \ for Internet\n   traffic.  However, the security offered by use of these protocols\n\
    \   ultimately depends on the quality of their implementation, which is\n   outside\
    \ the scope of this set of standards.  Moreover, the security\n   of a computer\
    \ system or network is a function of many factors,\n   including personnel, physical,\
    \ procedural, compromising emanations,\n   and computer security practices.  Thus,\
    \ IPsec is only one part of an\n   overall system security architecture.\n   Finally,\
    \ the security afforded by the use of IPsec is critically\n   dependent on many\
    \ aspects of the operating environment in which the\n   IPsec implementation executes.\
    \  For example, defects in OS security,\n   poor quality of random number sources,\
    \ sloppy system management\n   protocols and practices, etc., can all degrade\
    \ the security provided\n   by IPsec.  As above, none of these environmental attributes\
    \ are\n   within the scope of this or other IPsec standards.\n"
- title: 3.  System Overview
  contents:
  - "3.  System Overview\n   This section provides a high level description of how\
    \ IPsec works,\n   the components of the system, and how they fit together to\
    \ provide\n   the security services noted above.  The goal of this description\
    \ is\n   to enable the reader to \"picture\" the overall process/system, see how\n\
    \   it fits into the IP environment, and to provide context for later\n   sections\
    \ of this document, which describe each of the components in\n   more detail.\n\
    \   An IPsec implementation operates in a host, as a security gateway\n   (SG),\
    \ or as an independent device, affording protection to IP\n   traffic. (A security\
    \ gateway is an intermediate system implementing\n   IPsec, e.g., a firewall or\
    \ router that has been IPsec-enabled.) More\n   detail on these classes of implementations\
    \ is provided later, in\n   Section 3.3. The protection offered by IPsec is based\
    \ on requirements\n   defined by a Security Policy Database (SPD) established\
    \ and\n   maintained by a user or system administrator, or by an application\n\
    \   operating within constraints established by either of the above.  In\n   general,\
    \ packets are selected for one of three processing actions\n   based on IP and\
    \ next layer header information (\"Selectors\", Section\n   4.4.1.1) matched against\
    \ entries in the SPD.  Each packet is either\n   PROTECTed using IPsec security\
    \ services, DISCARDed, or allowed to\n   BYPASS IPsec protection, based on the\
    \ applicable SPD policies\n   identified by the Selectors.\n"
- title: 3.1.  What IPsec Does
  contents:
  - "3.1.  What IPsec Does\n   IPsec creates a boundary between unprotected and protected\n\
    \   interfaces, for a host or a network (see Figure 1 below).  Traffic\n   traversing\
    \ the boundary is subject to the access controls specified\n   by the user or\
    \ administrator responsible for the IPsec configuration.\n   These controls indicate\
    \ whether packets cross the boundary unimpeded,\n   are afforded security services\
    \ via AH or ESP, or are discarded.\n   IPsec security services are offered at\
    \ the IP layer through selection\n   of appropriate security protocols, cryptographic\
    \ algorithms, and\n   cryptographic keys.  IPsec can be used to protect one or\
    \ more \"paths\"\n   (a) between a pair of hosts, (b) between a pair of security\
    \ gateways,\n   or (c) between a security gateway and a host.  A compliant host\n\
    \   implementation MUST support (a) and (c) and a compliant security\n   gateway\
    \ must support all three of these forms of connectivity, since\n   under certain\
    \ circumstances a security gateway acts as a host.\n                        Unprotected\n\
    \                         ^       ^\n                         |       |\n    \
    \       +-------------|-------|-------+\n           | +-------+   |       |  \
    \     |\n           | |Discard|<--|       V       |\n           | +-------+  \
    \ |B  +--------+  |\n         ................|y..| AH/ESP |..... IPsec Boundary\n\
    \           |   +---+     |p  +--------+  |\n           |   |IKE|<----|a     \
    \ ^       |\n           |   +---+     |s      |       |\n           | +-------+\
    \   |s      |       |\n           | |Discard|<--|       |       |\n          \
    \ | +-------+   |       |       |\n           +-------------|-------|-------+\n\
    \                         |       |\n                         V       V\n    \
    \                     Protected\n            Figure 1.  Top Level IPsec Processing\
    \ Model\n   In this diagram, \"unprotected\" refers to an interface that might\
    \ also\n   be described as \"black\" or \"ciphertext\".  Here, \"protected\" refers\
    \ to\n   an interface that might also be described as \"red\" or \"plaintext\"\
    .\n   The protected interface noted above may be internal, e.g., in a host\n \
    \  implementation of IPsec, the protected interface may link to a socket\n   layer\
    \ interface presented by the OS.  In this document, the term\n   \"inbound\" refers\
    \ to traffic entering an IPsec implementation via the\n   unprotected interface\
    \ or emitted by the implementation on the\n   unprotected side of the boundary\
    \ and directed towards the protected\n   interface.  The term \"outbound\" refers\
    \ to traffic entering the\n   implementation via the protected interface, or emitted\
    \ by the\n   implementation on the protected side of the boundary and directed\n\
    \   toward the unprotected interface.  An IPsec implementation may\n   support\
    \ more than one interface on either or both sides of the\n   boundary.\n   Note\
    \ the facilities for discarding traffic on either side of the\n   IPsec boundary,\
    \ the BYPASS facility that allows traffic to transit\n   the boundary without\
    \ cryptographic protection, and the reference to\n   IKE as a protected-side key\
    \ and security management function.\n   IPsec optionally supports negotiation\
    \ of IP compression [SMPT01],\n   motivated in part by the observation that when\
    \ encryption is employed\n   within IPsec, it prevents effective compression by\
    \ lower protocol\n   layers.\n"
- title: 3.2.  How IPsec Works
  contents:
  - "3.2.  How IPsec Works\n   IPsec uses two protocols to provide traffic security\
    \ services --\n   Authentication Header (AH) and Encapsulating Security Payload\
    \ (ESP).\n   Both protocols are described in detail in their respective RFCs\n\
    \   [Ken05b, Ken05a].  IPsec implementations MUST support ESP and MAY\n   support\
    \ AH. (Support for AH has been downgraded to MAY because\n   experience has shown\
    \ that there are very few contexts in which ESP\n   cannot provide the requisite\
    \ security services.  Note that ESP can be\n   used to provide only integrity,\
    \ without confidentiality, making it\n   comparable to AH in most contexts.)\n\
    \    o The IP Authentication Header (AH) [Ken05b] offers integrity and\n     \
    \ data origin authentication, with optional (at the discretion of\n      the receiver)\
    \ anti-replay features.\n    o The Encapsulating Security Payload (ESP) protocol\
    \ [Ken05a] offers\n      the same set of services, and also offers confidentiality.\
    \  Use of\n      ESP to provide confidentiality without integrity is NOT\n   \
    \   RECOMMENDED.  When ESP is used with confidentiality enabled, there\n     \
    \ are provisions for limited traffic flow confidentiality, i.e.,\n      provisions\
    \ for concealing packet length, and for facilitating\n      efficient generation\
    \ and discard of dummy packets.  This\n      capability is likely to be effective\
    \ primarily in virtual private\n      network (VPN) and overlay network contexts.\n\
    \    o Both AH and ESP offer access control, enforced through the\n      distribution\
    \ of cryptographic keys and the management of traffic\n      flows as dictated\
    \ by the Security Policy Database (SPD, Section\n      4.4.1).\n   These protocols\
    \ may be applied individually or in combination with\n   each other to provide\
    \ IPv4 and IPv6 security services.  However, most\n   security requirements can\
    \ be met through the use of ESP by itself.\n   Each protocol supports two modes\
    \ of use: transport mode and tunnel\n   mode.  In transport mode, AH and ESP provide\
    \ protection primarily for\n   next layer protocols; in tunnel mode, AH and ESP\
    \ are applied to\n   tunneled IP packets.  The differences between the two modes\
    \ are\n   discussed in Section 4.1.\n   IPsec allows the user (or system administrator)\
    \ to control the\n   granularity at which a security service is offered.  For\
    \ example, one\n   can create a single encrypted tunnel to carry all the traffic\
    \ between\n   two security gateways, or a separate encrypted tunnel can be created\n\
    \   for each TCP connection between each pair of hosts communicating\n   across\
    \ these gateways.  IPsec, through the SPD management paradigm,\n   incorporates\
    \ facilities for specifying:\n    o which security protocol (AH or ESP) to employ,\
    \ the mode (transport\n      or tunnel), security service options, what cryptographic\n\
    \      algorithms to use, and in what combinations to use the specified\n    \
    \  protocols and services, and\n    o the granularity at which protection should\
    \ be applied.\n   Because most of the security services provided by IPsec require\
    \ the\n   use of cryptographic keys, IPsec relies on a separate set of\n   mechanisms\
    \ for putting these keys in place.  This document requires\n   support for both\
    \ manual and automated distribution of keys.  It\n   specifies a specific public-key\
    \ based approach (IKEv2 [Kau05]) for\n   automated key management, but other automated\
    \ key distribution\n   techniques MAY be used.\n   Note: This document mandates\
    \ support for several features for which\n   support is available in IKEv2 but\
    \ not in IKEv1, e.g., negotiation of\n   an SA representing ranges of local and\
    \ remote ports or negotiation of\n   multiple SAs with the same selectors.  Therefore,\
    \ this document\n   assumes use of IKEv2 or a key and security association management\n\
    \   system with comparable features.\n"
- title: 3.3.  Where IPsec Can Be Implemented
  contents:
  - "3.3.  Where IPsec Can Be Implemented\n   There are many ways in which IPsec may\
    \ be implemented in a host, or\n   in conjunction with a router or firewall to\
    \ create a security\n   gateway, or as an independent security device.\n   a.\
    \ IPsec may be integrated into the native IP stack.  This requires\n      access\
    \ to the IP source code and is applicable to both hosts and\n      security gateways,\
    \ although native host implementations benefit\n      the most from this strategy,\
    \ as explained later (Section 4.4.1,\n      paragraph 6; Section 4.4.1.1, last\
    \ paragraph).\n   b. In a \"bump-in-the-stack\" (BITS) implementation, IPsec is\n\
    \      implemented \"underneath\" an existing implementation of an IP\n      protocol\
    \ stack, between the native IP and the local network\n      drivers.  Source code\
    \ access for the IP stack is not required in\n      this context, making this\
    \ implementation approach appropriate for\n      use with legacy systems.  This\
    \ approach, when it is adopted, is\n      usually employed in hosts.\n   c. The\
    \ use of a dedicated, inline security protocol processor is a\n      common design\
    \ feature of systems used by the military, and of some\n      commercial systems\
    \ as well.  It is sometimes referred to as a\n      \"bump-in-the-wire\" (BITW)\
    \ implementation.  Such implementations\n      may be designed to serve either\
    \ a host or a gateway.  Usually, the\n      BITW device is itself IP addressable.\
    \  When supporting a single\n      host, it may be quite analogous to a BITS implementation,\
    \ but in\n      supporting a router or firewall, it must operate like a security\n\
    \      gateway.\n   This document often talks in terms of use of IPsec by a host\
    \ or a\n   security gateway, without regard to whether the implementation is\n\
    \   native, BITS, or BITW.  When the distinctions among these\n   implementation\
    \ options are significant, the document makes reference\n   to specific implementation\
    \ approaches.\n   A host implementation of IPsec may appear in devices that might\
    \ not\n   be viewed as \"hosts\".  For example, a router might employ IPsec to\n\
    \   protect routing protocols (e.g., BGP) and management functions (e.g.,\n  \
    \ Telnet), without affecting subscriber traffic traversing the router.\n   A security\
    \ gateway might employ separate IPsec implementations to\n   protect its management\
    \ traffic and subscriber traffic.  The\n   architecture described in this document\
    \ is very flexible.  For\n   example, a computer with a full-featured, compliant,\
    \ native OS IPsec\n   implementation should be capable of being configured to\
    \ protect\n   resident (host) applications and to provide security gateway\n \
    \  protection for traffic traversing the computer.  Such configuration\n   would\
    \ make use of the forwarding tables and the SPD selection\n   function described\
    \ in Sections 5.1 and 5.2.\n"
- title: 4.  Security Associations
  contents:
  - "4.  Security Associations\n   This section defines Security Association management\
    \ requirements for\n   all IPv6 implementations and for those IPv4 implementations\
    \ that\n   implement AH, ESP, or both AH and ESP.  The concept of a \"Security\n\
    \   Association\" (SA) is fundamental to IPsec.  Both AH and ESP make use\n  \
    \ of SAs, and a major function of IKE is the establishment and\n   maintenance\
    \ of SAs.  All implementations of AH or ESP MUST support\n   the concept of an\
    \ SA as described below.  The remainder of this\n   section describes various\
    \ aspects of SA management, defining required\n   characteristics for SA policy\
    \ management and SA management\n   techniques.\n"
- title: 4.1.  Definition and Scope
  contents:
  - "4.1.  Definition and Scope\n   An SA is a simplex \"connection\" that affords\
    \ security services to the\n   traffic carried by it.  Security services are afforded\
    \ to an SA by\n   the use of AH, or ESP, but not both.  If both AH and ESP protection\n\
    \   are applied to a traffic stream, then two SAs must be created and\n   coordinated\
    \ to effect protection through iterated application of the\n   security protocols.\
    \  To secure typical, bi-directional communication\n   between two IPsec-enabled\
    \ systems, a pair of SAs (one in each\n   direction) is required.  IKE explicitly\
    \ creates SA pairs in\n   recognition of this common usage requirement.\n   For\
    \ an SA used to carry unicast traffic, the Security Parameters\n   Index (SPI)\
    \ by itself suffices to specify an SA.  (For information on\n   the SPI, see Appendix\
    \ A and the AH and ESP specifications [Ken05b,\n   Ken05a].)  However, as a local\
    \ matter, an implementation may choose\n   to use the SPI in conjunction with\
    \ the IPsec protocol type (AH or\n   ESP) for SA identification.  If an IPsec\
    \ implementation supports\n   multicast, then it MUST support multicast SAs using\
    \ the algorithm\n   below for mapping inbound IPsec datagrams to SAs.  Implementations\n\
    \   that support only unicast traffic need not implement this de-\n   multiplexing\
    \ algorithm.\n   In many secure multicast architectures, e.g., [RFC3740], a central\n\
    \   Group Controller/Key Server unilaterally assigns the Group Security\n   Association's\
    \ (GSA's) SPI.  This SPI assignment is not negotiated or\n   coordinated with\
    \ the key management (e.g., IKE) subsystems that\n   reside in the individual\
    \ end systems that constitute the group.\n   Consequently, it is possible that\
    \ a GSA and a unicast SA can\n   simultaneously use the same SPI.  A multicast-capable\
    \ IPsec\n   implementation MUST correctly de-multiplex inbound traffic even in\n\
    \   the context of SPI collisions.\n   Each entry in the SA Database (SAD) (Section\
    \ 4.4.2) must indicate\n   whether the SA lookup makes use of the destination\
    \ IP address, or the\n   destination and source IP addresses, in addition to the\
    \ SPI.  For\n   multicast SAs, the protocol field is not employed for SA lookups.\n\
    \   For each inbound, IPsec-protected packet, an implementation must\n   conduct\
    \ its search of the SAD such that it finds the entry that\n   matches the \"longest\"\
    \ SA identifier.  In this context, if two or more\n   SAD entries match based\
    \ on the SPI value, then the entry that also\n   matches based on destination\
    \ address, or destination and source\n   address (as indicated in the SAD entry)\
    \ is the \"longest\" match.  This\n   implies a logical ordering of the SAD search\
    \ as follows:\n      1. Search the SAD for a match on the combination of SPI,\n\
    \         destination address, and source address.  If an SAD entry\n        \
    \ matches, then process the inbound packet with that\n         matching SAD entry.\
    \  Otherwise, proceed to step 2.\n      2. Search the SAD for a match on both\
    \ SPI and destination address.\n         If the SAD entry matches, then process\
    \ the inbound packet\n         with that matching SAD entry.  Otherwise, proceed\
    \ to step 3.\n      3. Search the SAD for a match on only SPI if the receiver\
    \ has\n         chosen to maintain a single SPI space for AH and ESP, and on\n\
    \         both SPI and protocol, otherwise.  If an SAD entry matches,\n      \
    \   then process the inbound packet with that matching SAD entry.\n         Otherwise,\
    \ discard the packet and log an auditable event.\n   In practice, an implementation\
    \ may choose any method (or none at all)\n   to accelerate this search, although\
    \ its externally visible behavior\n   MUST be functionally equivalent to having\
    \ searched the SAD in the\n   above order.  For example, a software-based implementation\
    \ could\n   index into a hash table by the SPI.  The SAD entries in each hash\n\
    \   table bucket's linked list could be kept sorted to have those SAD\n   entries\
    \ with the longest SA identifiers first in that linked list.\n   Those SAD entries\
    \ having the shortest SA identifiers could be sorted\n   so that they are the\
    \ last entries in the linked list.  A\n   hardware-based implementation may be\
    \ able to effect the longest match\n   search intrinsically, using commonly available\
    \ Ternary\n   Content-Addressable Memory (TCAM) features.\n   The indication of\
    \ whether source and destination address matching is\n   required to map inbound\
    \ IPsec traffic to SAs MUST be set either as a\n   side effect of manual SA configuration\
    \ or via negotiation using an SA\n   management protocol, e.g., IKE or Group Domain\
    \ of Interpretation\n   (GDOI) [RFC3547].  Typically, Source-Specific Multicast\
    \ (SSM) [HC03]\n   groups use a 3-tuple SA identifier composed of an SPI, a destination\n\
    \   multicast address, and source address.  An Any-Source Multicast group\n  \
    \ SA requires only an SPI and a destination multicast address as an\n   identifier.\n\
    \   If different classes of traffic (distinguished by Differentiated\n   Services\
    \ Code Point (DSCP) bits [NiBlBaBL98], [Gro02]) are sent on\n   the same SA, and\
    \ if the receiver is employing the optional\n   anti-replay feature available\
    \ in both AH and ESP, this could result\n   in inappropriate discarding of lower\
    \ priority packets due to the\n   windowing mechanism used by this feature.  Therefore,\
    \ a sender SHOULD\n   put traffic of different classes, but with the same selector\
    \ values,\n   on different SAs to support Quality of Service (QoS) appropriately.\n\
    \   To permit this, the IPsec implementation MUST permit establishment\n   and\
    \ maintenance of multiple SAs between a given sender and receiver,\n   with the\
    \ same selectors.  Distribution of traffic among these\n   parallel SAs to support\
    \ QoS is locally determined by the sender and\n   is not negotiated by IKE.  The\
    \ receiver MUST process the packets from\n   the different SAs without prejudice.\
    \  These requirements apply to\n   both transport and tunnel mode SAs.  In the\
    \ case of tunnel mode SAs,\n   the DSCP values in question appear in the inner\
    \ IP header.  In\n   transport mode, the DSCP value might change en route, but\
    \ this should\n   not cause problems with respect to IPsec processing since the\
    \ value\n   is not employed for SA selection and MUST NOT be checked as part of\n\
    \   SA/packet validation.  However, if significant re-ordering of packets\n  \
    \ occurs in an SA, e.g., as a result of changes to DSCP values en\n   route, this\
    \ may trigger packet discarding by a receiver due to\n   application of the anti-replay\
    \ mechanism.\n   DISCUSSION: Although the DSCP [NiBlBaBL98, Gro02] and Explicit\n\
    \   Congestion Notification (ECN) [RaFlBl01] fields are not \"selectors\",\n \
    \  as that term in used in this architecture, the sender will need a\n   mechanism\
    \ to direct packets with a given (set of) DSCP values to the\n   appropriate SA.\
    \  This mechanism might be termed a \"classifier\".\n   As noted above, two types\
    \ of SAs are defined: transport mode and\n   tunnel mode.  IKE creates pairs of\
    \ SAs, so for simplicity, we choose\n   to require that both SAs in a pair be\
    \ of the same mode, transport or\n   tunnel.\n   A transport mode SA is an SA\
    \ typically employed between a pair of\n   hosts to provide end-to-end security\
    \ services.  When security is\n   desired between two intermediate systems along\
    \ a path (vs. end-to-end\n   use of IPsec), transport mode MAY be used between\
    \ security gateways\n   or between a security gateway and a host.  In the case\
    \ where\n   transport mode is used between security gateways or between a\n  \
    \ security gateway and a host, transport mode may be used to support\n   in-IP\
    \ tunneling (e.g., IP-in-IP [Per96] or Generic Routing\n   Encapsulation (GRE)\
    \ tunneling [FaLiHaMeTr00] or dynamic routing\n   [ToEgWa04]) over transport mode\
    \ SAs.  To clarify, the use of\n   transport mode by an intermediate system (e.g.,\
    \ a security gateway)\n   is permitted only when applied to packets whose source\
    \ address (for\n   outbound packets) or destination address (for inbound packets)\
    \ is an\n   address belonging to the intermediate system itself.  The access\n\
    \   control functions that are an important part of IPsec are\n   significantly\
    \ limited in this context, as they cannot be applied to\n   the end-to-end headers\
    \ of the packets that traverse a transport mode\n   SA used in this fashion. \
    \ Thus, this way of using transport mode\n   should be evaluated carefully before\
    \ being employed in a specific\n   context.\n   In IPv4, a transport mode security\
    \ protocol header appears\n   immediately after the IP header and any options,\
    \ and before any next\n   layer protocols (e.g., TCP or UDP).  In IPv6, the security\
    \ protocol\n   header appears after the base IP header and selected extension\n\
    \   headers, but may appear before or after destination options; it MUST\n   appear\
    \ before next layer protocols (e.g., TCP, UDP, Stream Control\n   Transmission\
    \ Protocol (SCTP)).  In the case of ESP, a transport mode\n   SA provides security\
    \ services only for these next layer protocols,\n   not for the IP header or any\
    \ extension headers preceding the ESP\n   header.  In the case of AH, the protection\
    \ is also extended to\n   selected portions of the IP header preceding it, selected\
    \ portions of\n   extension headers, and selected options (contained in the IPv4\n\
    \   header, IPv6 Hop-by-Hop extension header, or IPv6 Destination\n   extension\
    \ headers).  For more details on the coverage afforded by AH,\n   see the AH specification\
    \ [Ken05b].\n   A tunnel mode SA is essentially an SA applied to an IP tunnel,\
    \ with\n   the access controls applied to the headers of the traffic inside the\n\
    \   tunnel.  Two hosts MAY establish a tunnel mode SA between themselves.\n  \
    \ Aside from the two exceptions below, whenever either end of a\n   security association\
    \ is a security gateway, the SA MUST be tunnel\n   mode.  Thus, an SA between\
    \ two security gateways is typically a\n   tunnel mode SA, as is an SA between\
    \ a host and a security gateway.\n   The two exceptions are as follows.\n    o\
    \ Where traffic is destined for a security gateway, e.g., Simple\n      Network\
    \ Management Protocol (SNMP) commands, the security gateway\n      is acting as\
    \ a host and transport mode is allowed.  In this case,\n      the SA terminates\
    \ at a host (management) function within a\n      security gateway and thus merits\
    \ different treatment.\n    o As noted above, security gateways MAY support a\
    \ transport mode SA\n      to provide security for IP traffic between two intermediate\n\
    \      systems along a path, e.g., between a host and a security gateway\n   \
    \   or between two security gateways.\n   Several concerns motivate the use of\
    \ tunnel mode for an SA involving\n   a security gateway.  For example, if there\
    \ are multiple paths (e.g.,\n   via different security gateways) to the same destination\
    \ behind a\n   security gateway, it is important that an IPsec packet be sent\
    \ to the\n   security gateway with which the SA was negotiated.  Similarly, a\n\
    \   packet that might be fragmented en route must have all the fragments\n   delivered\
    \ to the same IPsec instance for reassembly prior to\n   cryptographic processing.\
    \  Also, when a fragment is processed by\n   IPsec and transmitted, then fragmented\
    \ en route, it is critical that\n   there be inner and outer headers to retain\
    \ the fragmentation state\n   data for the pre- and post-IPsec packet formats.\
    \  Hence there are\n   several reasons for employing tunnel mode when either end\
    \ of an SA is\n   a security gateway. (Use of an IP-in-IP tunnel in conjunction\
    \ with\n   transport mode can also address these fragmentation issues.  However,\n\
    \   this configuration limits the ability of IPsec to enforce access\n   control\
    \ policies on traffic.)\n   Note: AH and ESP cannot be applied using transport\
    \ mode to IPv4\n   packets that are fragments.  Only tunnel mode can be employed\
    \ in such\n   cases.  For IPv6, it would be feasible to carry a plaintext fragment\n\
    \   on a transport mode SA; however, for simplicity, this restriction\n   also\
    \ applies to IPv6 packets.  See Section 7 for more details on\n   handling plaintext\
    \ fragments on the protected side of the IPsec\n   barrier.\n   For a tunnel mode\
    \ SA, there is an \"outer\" IP header that specifies\n   the IPsec processing\
    \ source and destination, plus an \"inner\" IP\n   header that specifies the (apparently)\
    \ ultimate source and\n   destination for the packet.  The security protocol header\
    \ appears\n   after the outer IP header, and before the inner IP header.  If AH\
    \ is\n   employed in tunnel mode, portions of the outer IP header are afforded\n\
    \   protection (as above), as well as all of the tunneled IP packet\n   (i.e.,\
    \ all of the inner IP header is protected, as well as next layer\n   protocols).\
    \  If ESP is employed, the protection is afforded only to\n   the tunneled packet,\
    \ not to the outer header.\n   In summary,\n   a) A host implementation of IPsec\
    \ MUST support both transport and\n      tunnel mode.  This is true for native,\
    \ BITS, and BITW\n      implementations for hosts.\n   b) A security gateway MUST\
    \ support tunnel mode and MAY support\n      transport mode.  If it supports transport\
    \ mode, that should be\n      used only when the security gateway is acting as\
    \ a host, e.g., for\n      network management, or to provide security between\
    \ two\n      intermediate systems along a path.\n"
- title: 4.2.  SA Functionality
  contents:
  - "4.2.  SA Functionality\n   The set of security services offered by an SA depends\
    \ on the security\n   protocol selected, the SA mode, the endpoints of the SA,\
    \ and the\n   election of optional services within the protocol.\n   For example,\
    \ both AH and ESP offer integrity and authentication\n   services, but the coverage\
    \ differs for each protocol and differs for\n   transport vs. tunnel mode.  If\
    \ the integrity of an IPv4 option or\n   IPv6 extension header must be protected\
    \ en route between sender and\n   receiver, AH can provide this service, except\
    \ for IP or extension\n   headers that may change in a fashion not predictable\
    \ by the sender.\n   However, the same security may be achieved in some contexts\
    \ by\n   applying ESP to a tunnel carrying a packet.\n   The granularity of access\
    \ control provided is determined by the\n   choice of the selectors that define\
    \ each SA.  Moreover, the\n   authentication means employed by IPsec peers, e.g.,\
    \ during creation\n   of an IKE (vs. child) SA also affects the granularity of\
    \ the access\n   control afforded.\n   If confidentiality is selected, then an\
    \ ESP (tunnel mode) SA between\n   two security gateways can offer partial traffic\
    \ flow confidentiality.\n   The use of tunnel mode allows the inner IP headers\
    \ to be encrypted,\n   concealing the identities of the (ultimate) traffic source\
    \ and\n   destination.  Moreover, ESP payload padding also can be invoked to\n\
    \   hide the size of the packets, further concealing the external\n   characteristics\
    \ of the traffic.  Similar traffic flow confidentiality\n   services may be offered\
    \ when a mobile user is assigned a dynamic IP\n   address in a dialup context,\
    \ and establishes a (tunnel mode) ESP SA\n   to a corporate firewall (acting as\
    \ a security gateway).  Note that\n   fine-granularity SAs generally are more\
    \ vulnerable to traffic\n   analysis than coarse-granularity ones that are carrying\
    \ traffic from\n   many subscribers.\n   Note: A compliant implementation MUST\
    \ NOT allow instantiation of an\n   ESP SA that employs both NULL encryption and\
    \ no integrity algorithm.\n   An attempt to negotiate such an SA is an auditable\
    \ event by both\n   initiator and responder.  The audit log entry for this event\
    \ SHOULD\n   include the current date/time, local IKE IP address, and remote IKE\n\
    \   IP address.  The initiator SHOULD record the relevant SPD entry.\n"
- title: 4.3.  Combining SAs
  contents:
  - "4.3.  Combining SAs\n   This document does not require support for nested security\n\
    \   associations or for what RFC 2401 [RFC2401] called \"SA bundles\".\n   These\
    \ features still can be effected by appropriate configuration of\n   both the\
    \ SPD and the local forwarding functions (for inbound and\n   outbound traffic),\
    \ but this capability is outside of the IPsec module\n   and thus the scope of\
    \ this specification.  As a result, management of\n   nested/bundled SAs is potentially\
    \ more complex and less assured than\n   under the model implied by RFC 2401 [RFC2401].\
    \  An implementation\n   that provides support for nested SAs SHOULD provide a\
    \ management\n   interface that enables a user or administrator to express the\
    \ nesting\n   requirement, and then create the appropriate SPD entries and\n \
    \  forwarding table entries to effect the requisite processing. (See\n   Appendix\
    \ E for an example of how to configure nested SAs.)\n"
- title: 4.4.  Major IPsec Databases
  contents:
  - "4.4.  Major IPsec Databases\n   Many of the details associated with processing\
    \ IP traffic in an IPsec\n   implementation are largely a local matter, not subject\
    \ to\n   standardization.  However, some external aspects of the processing\n\
    \   must be standardized to ensure interoperability and to provide a\n   minimum\
    \ management capability that is essential for productive use of\n   IPsec.  This\
    \ section describes a general model for processing IP\n   traffic relative to\
    \ IPsec functionality, in support of these\n   interoperability and functionality\
    \ goals.  The model described below\n   is nominal; implementations need not match\
    \ details of this model as\n   presented, but the external behavior of implementations\
    \ MUST\n   correspond to the externally observable characteristics of this model\n\
    \   in order to be compliant.\n   There are three nominal databases in this model:\
    \ the Security Policy\n   Database (SPD), the Security Association Database (SAD),\
    \ and the Peer\n   Authorization Database (PAD).  The first specifies the policies\
    \ that\n   determine the disposition of all IP traffic inbound or outbound from\n\
    \   a host or security gateway (Section 4.4.1).  The second database\n   contains\
    \ parameters that are associated with each established (keyed)\n   SA (Section\
    \ 4.4.2).  The third database, the PAD, provides a link\n   between an SA management\
    \ protocol (such as IKE) and the SPD (Section\n   4.4.3).\n   Multiple Separate\
    \ IPsec Contexts\n      If an IPsec implementation acts as a security gateway\
    \ for multiple\n      subscribers, it MAY implement multiple separate IPsec contexts.\n\
    \      Each context MAY have and MAY use completely independent\n      identities,\
    \ policies, key management SAs, and/or IPsec SAs.  This\n      is for the most\
    \ part a local implementation matter.  However, a\n      means for associating\
    \ inbound (SA) proposals with local contexts\n      is required.  To this end,\
    \ if supported by the key management\n      protocol in use, context identifiers\
    \ MAY be conveyed from\n      initiator to responder in the signaling messages,\
    \ with the result\n      that IPsec SAs are created with a binding to a particular\
    \ context.\n      For example, a security gateway that provides VPN service to\n\
    \      multiple customers will be able to associate each customer's\n      traffic\
    \ with the correct VPN.\n   Forwarding vs Security Decisions\n      The IPsec\
    \ model described here embodies a clear separation between\n      forwarding (routing)\
    \ and security decisions, to accommodate a wide\n      range of contexts where\
    \ IPsec may be employed.  Forwarding may be\n      trivial, in the case where\
    \ there are only two interfaces, or it\n      may be complex, e.g., if the context\
    \ in which IPsec is implemented\n      employs a sophisticated forwarding function.\
    \  IPsec assumes only\n      that outbound and inbound traffic that has passed\
    \ through IPsec\n      processing is forwarded in a fashion consistent with the\
    \ context\n      in which IPsec is implemented.  Support for nested SAs is\n \
    \     optional; if required, it requires coordination between forwarding\n   \
    \   tables and SPD entries to cause a packet to traverse the IPsec\n      boundary\
    \ more than once.\n   \"Local\" vs \"Remote\"\n      In this document, with respect\
    \ to IP addresses and ports, the\n      terms \"Local\" and \"Remote\" are used\
    \ for policy rules.  \"Local\"\n      refers to the entity being protected by\
    \ an IPsec implementation,\n      i.e., the \"source\" address/port of outbound\
    \ packets or the\n      \"destination\" address/port of inbound packets. \"Remote\"\
    \ refers to\n      a peer entity or peer entities.  The terms \"source\" and\n\
    \      \"destination\" are used for packet header fields.\n   \"Non-initial\"\
    \ vs \"Initial\" Fragments\n      Throughout this document, the phrase \"non-initial\
    \ fragments\" is\n      used to mean fragments that do not contain all of the\
    \ selector\n      values that may be needed for access control (e.g., they might\
    \ not\n      contain Next Layer Protocol, source and destination ports, ICMP\n\
    \      message type/code, Mobility Header type).  And the phrase \"initial\n \
    \     fragment\" is used to mean a fragment that contains all the\n      selector\
    \ values needed for access control.  However, it should be\n      noted that for\
    \ IPv6, which fragment contains the Next Layer\n      Protocol and ports (or ICMP\
    \ message type/code or Mobility Header\n      type [Mobip]) will depend on the\
    \ kind and number of extension\n      headers present.  The \"initial fragment\"\
    \ might not be the first\n      fragment, in this context.\n"
- title: 4.4.1.  The Security Policy Database (SPD)
  contents:
  - "4.4.1.  The Security Policy Database (SPD)\n   An SA is a management construct\
    \ used to enforce security policy for\n   traffic crossing the IPsec boundary.\
    \  Thus, an essential element of\n   SA processing is an underlying Security Policy\
    \ Database (SPD) that\n   specifies what services are to be offered to IP datagrams\
    \ and in what\n   fashion.  The form of the database and its interface are outside\
    \ the\n   scope of this specification.  However, this section specifies minimum\n\
    \   management functionality that must be provided, to allow a user or\n   system\
    \ administrator to control whether and how IPsec is applied to\n   traffic transmitted\
    \ or received by a host or transiting a security\n   gateway.  The SPD, or relevant\
    \ caches, must be consulted during the\n   processing of all traffic (inbound\
    \ and outbound), including traffic\n   not protected by IPsec, that traverses\
    \ the IPsec boundary.  This\n   includes IPsec management traffic such as IKE.\
    \  An IPsec\n   implementation MUST have at least one SPD, and it MAY support\n\
    \   multiple SPDs, if appropriate for the context in which the IPsec\n   implementation\
    \ operates.  There is no requirement to maintain SPDs on\n   a per-interface basis,\
    \ as was specified in RFC 2401 [RFC2401].\n   However, if an implementation supports\
    \ multiple SPDs, then it MUST\n   include an explicit SPD selection function that\
    \ is invoked to select\n   the appropriate SPD for outbound traffic processing.\
    \  The inputs to\n   this function are the outbound packet and any local metadata\
    \ (e.g.,\n   the interface via which the packet arrived) required to effect the\n\
    \   SPD selection function.  The output of the function is an SPD\n   identifier\
    \ (SPD-ID).\n   The SPD is an ordered database, consistent with the use of Access\n\
    \   Control Lists (ACLs) or packet filters in firewalls, routers, etc.\n   The\
    \ ordering requirement arises because entries often will overlap\n   due to the\
    \ presence of (non-trivial) ranges as values for selectors.\n   Thus, a user or\
    \ administrator MUST be able to order the entries to\n   express a desired access\
    \ control policy.  There is no way to impose a\n   general, canonical order on\
    \ SPD entries, because of the allowed use\n   of wildcards for selector values\
    \ and because the different types of\n   selectors are not hierarchically related.\n\
    \   Processing Choices:  DISCARD, BYPASS, PROTECT\n      An SPD must discriminate\
    \ among traffic that is afforded IPsec\n      protection and traffic that is allowed\
    \ to bypass IPsec.  This\n      applies to the IPsec protection to be applied\
    \ by a sender and to\n      the IPsec protection that must be present at the receiver.\
    \  For\n      any outbound or inbound datagram, three processing choices are\n\
    \      possible: DISCARD, BYPASS IPsec, or PROTECT using IPsec.  The\n      first\
    \ choice refers to traffic that is not allowed to traverse the\n      IPsec boundary\
    \ (in the specified direction).  The second choice\n      refers to traffic that\
    \ is allowed to cross the IPsec boundary\n      without IPsec protection.  The\
    \ third choice refers to traffic that\n      is afforded IPsec protection, and\
    \ for such traffic the SPD must\n      specify the security protocols to be employed,\
    \ their mode,\n      security service options, and the cryptographic algorithms\
    \ to be\n      used.\n   SPD-S, SPD-I, SPD-O\n      An SPD is logically divided\
    \ into three pieces.  The SPD-S (secure\n      traffic) contains entries for all\
    \ traffic subject to IPsec\n      protection.  SPD-O (outbound) contains entries\
    \ for all outbound\n      traffic that is to be bypassed or discarded.  SPD-I\
    \ (inbound) is\n      applied to inbound traffic that will be bypassed or discarded.\n\
    \      All three of these can be decorrelated (with the exception noted\n    \
    \  above for native host implementations) to facilitate caching.  If\n      an\
    \ IPsec implementation supports only one SPD, then the SPD\n      consists of\
    \ all three parts.  If multiple SPDs are supported, some\n      of them may be\
    \ partial, e.g., some SPDs might contain only SPD-I\n      entries, to control\
    \ inbound bypassed traffic on a per-interface\n      basis.  The split allows\
    \ SPD-I to be consulted without having to\n      consult SPD-S, for such traffic.\
    \  Since the SPD-I is just a part\n      of the SPD, if a packet that is looked\
    \ up in the SPD-I cannot be\n      matched to an entry there, then the packet\
    \ MUST be discarded.\n      Note that for outbound traffic, if a match is not\
    \ found in SPD-S,\n      then SPD-O must be checked to see if the traffic should\
    \ be\n      bypassed.  Similarly, if SPD-O is checked first and no match is\n\
    \      found, then SPD-S must be checked.  In an ordered,\n      non-decorrelated\
    \ SPD, the entries for the SPD-S, SPD-I, and SPD-O\n      are interleaved.  So\
    \ there is one lookup in the SPD.\n   SPD Entries\n      Each SPD entry specifies\
    \ packet disposition as BYPASS, DISCARD, or\n      PROTECT.  The entry is keyed\
    \ by a list of one or more selectors.\n      The SPD contains an ordered list\
    \ of these entries.  The required\n      selector types are defined in Section\
    \ 4.4.1.1. These selectors are\n      used to define the granularity of the SAs\
    \ that are created in\n      response to an outbound packet or in response to\
    \ a proposal from a\n      peer.  The detailed structure of an SPD entry is described\
    \ in\n      Section 4.4.1.2. Every SPD SHOULD have a nominal, final entry that\n\
    \      matches anything that is otherwise unmatched, and discards it.\n      The\
    \ SPD MUST permit a user or administrator to specify policy\n      entries as\
    \ follows:\n       - SPD-I: For inbound traffic that is to be bypassed or discarded,\n\
    \         the entry consists of the values of the selectors that apply to\n  \
    \       the traffic to be bypassed or discarded.\n       - SPD-O: For outbound\
    \ traffic that is to be bypassed or\n         discarded, the entry consists of\
    \ the values of the selectors\n         that apply to the traffic to be bypassed\
    \ or discarded.\n       - SPD-S: For traffic that is to be protected using IPsec,\
    \ the\n         entry consists of the values of the selectors that apply to the\n\
    \         traffic to be protected via AH or ESP, controls on how to\n        \
    \ create SAs based on these selectors, and the parameters needed\n         to\
    \ effect this protection (e.g., algorithms, modes, etc.). Note\n         that\
    \ an SPD-S entry also contains information such as \"populate\n         from packet\"\
    \ (PFP) flag (see paragraphs below on \"How To Derive\n         the Values for\
    \ an SAD entry\") and bits indicating whether the\n         SA lookup makes use\
    \ of the local and remote IP addresses in\n         addition to the SPI (see AH\
    \ [Ken05b] or ESP [Ken05a]\n         specifications).\n   Representing Directionality\
    \ in an SPD Entry\n      For traffic protected by IPsec, the Local and Remote\
    \ address and\n      ports in an SPD entry are swapped to represent directionality,\n\
    \      consistent with IKE conventions.  In general, the protocols that\n    \
    \  IPsec deals with have the property of requiring symmetric SAs with\n      flipped\
    \ Local/Remote IP addresses.  However, for ICMP, there is\n      often no such\
    \ bi-directional authorization requirement.\n      Nonetheless, for the sake of\
    \ uniformity and simplicity, SPD\n      entries for ICMP are specified in the\
    \ same way as for other\n      protocols.  Note also that for ICMP, Mobility Header,\
    \ and\n      non-initial fragments, there are no port fields in these packets.\n\
    \      ICMP has message type and code and Mobility Header has mobility\n     \
    \ header type.  Thus, SPD entries have provisions for expressing\n      access\
    \ controls appropriate for these protocols, in lieu of the\n      normal port\
    \ field controls.  For bypassed or discarded traffic,\n      separate inbound\
    \ and outbound entries are supported, e.g., to\n      permit unidirectional flows\
    \ if required.\n   OPAQUE and ANY\n      For each selector in an SPD entry, in\
    \ addition to the literal\n      values that define a match, there are two special\
    \ values: ANY and\n      OPAQUE.  ANY is a wildcard that matches any value in\
    \ the\n      corresponding field of the packet, or that matches packets where\n\
    \      that field is not present or is obscured.  OPAQUE indicates that\n    \
    \  the corresponding selector field is not available for examination\n      because\
    \ it may not be present in a fragment, it does not exist for\n      the given\
    \ Next Layer Protocol, or prior application of IPsec may\n      have encrypted\
    \ the value.  The ANY value encompasses the OPAQUE\n      value.  Thus, OPAQUE\
    \ need be used only when it is necessary to\n      distinguish between the case\
    \ of any allowed value for a field, vs.\n      the absence or unavailability (e.g.,\
    \ due to encryption) of the\n      field.\n   How to Derive the Values for an\
    \ SAD Entry\n      For each selector in an SPD entry, the entry specifies how\
    \ to\n      derive the corresponding values for a new SA Database (SAD, see\n\
    \      Section 4.4.2) entry from those in the SPD and the packet.  The\n     \
    \ goal is to allow an SAD entry and an SPD cache entry to be created\n      based\
    \ on specific selector values from the packet, or from the\n      matching SPD\
    \ entry.  For outbound traffic, there are SPD-S cache\n      entries and SPD-O\
    \ cache entries.  For inbound traffic not\n      protected by IPsec, there are\
    \ SPD-I cache entries and there is the\n      SAD, which represents the cache\
    \ for inbound IPsec-protected\n      traffic (see Section 4.4.2).  If IPsec processing\
    \ is specified for\n      an entry, a \"populate from packet\" (PFP) flag may\
    \ be asserted for\n      one or more of the selectors in the SPD entry (Local\
    \ IP address;\n      Remote IP address; Next Layer Protocol; and, depending on\
    \ Next\n      Layer Protocol, Local port and Remote port, or ICMP type/code, or\n\
    \      Mobility Header type).  If asserted for a given selector X, the\n     \
    \ flag indicates that the SA to be created should take its value for\n      X\
    \ from the value in the packet.  Otherwise, the SA should take its\n      value(s)\
    \ for X from the value(s) in the SPD entry.  Note: In the\n      non-PFP case,\
    \ the selector values negotiated by the SA management\n      protocol (e.g., IKEv2)\
    \ may be a subset of those in the SPD entry,\n      depending on the SPD policy\
    \ of the peer.  Also, whether a single\n      flag is used for, e.g., source port,\
    \ ICMP type/code, and Mobility\n      Header (MH) type, or a separate flag is\
    \ used for each, is a local\n      matter.\n      The following example illustrates\
    \ the use of the PFP flag in the\n      context of a security gateway or a BITS/BITW\
    \ implementation.\n      Consider an SPD entry where the allowed value for Remote\
    \ address\n      is a range of IPv4 addresses: 192.0.2.1 to 192.0.2.10.  Suppose\
    \ an\n      outbound packet arrives with a destination address of 192.0.2.3,\n\
    \      and there is no extant SA to carry this packet.  The value used\n     \
    \ for the SA created to transmit this packet could be either of the\n      two\
    \ values shown below, depending on what the SPD entry for this\n      selector\
    \ says is the source of the selector value:\n          PFP flag value  example\
    \ of new\n          for the Remote  SAD dest. address\n          addr. selector\
    \  selector value\n          --------------- ------------\n          a. PFP TRUE\
    \     192.0.2.3 (one host)\n          b. PFP FALSE    192.0.2.1 to 192.0.2.10\
    \ (range of hosts)\n      Note that if the SPD entry above had a value of ANY\
    \ for the Remote\n      address, then the SAD selector value would have to be\
    \ ANY for case\n      (b), but would still be as illustrated for case (a).  Thus,\
    \ the\n      PFP flag can be used to prohibit sharing of an SA, even among\n \
    \     packets that match the same SPD entry.\n   Management Interface\n      For\
    \ every IPsec implementation, there MUST be a management\n      interface that\
    \ allows a user or system administrator to manage the\n      SPD.  The interface\
    \ must allow the user (or administrator) to\n      specify the security processing\
    \ to be applied to every packet that\n      traverses the IPsec boundary. (In\
    \ a native host IPsec\n      implementation making use of a socket interface,\
    \ the SPD may not\n      need to be consulted on a per-packet basis, as noted\
    \ at the end of\n      Section 4.4.1.1 and in Section 5.)  The management interface\
    \ for\n      the SPD MUST allow creation of entries consistent with the\n    \
    \  selectors defined in Section 4.4.1.1, and MUST support (total)\n      ordering\
    \ of these entries, as seen via this interface.  The SPD\n      entries' selectors\
    \ are analogous to the ACL or packet filters\n      commonly found in a stateless\
    \ firewall or packet filtering router\n      and which are currently managed this\
    \ way.\n      In host systems, applications MAY be allowed to create SPD\n   \
    \   entries.  (The means of signaling such requests to the IPsec\n      implementation\
    \ are outside the scope of this standard.)  However,\n      the system administrator\
    \ MUST be able to specify whether or not a\n      user or application can override\
    \ (default) system policies.  The\n      form of the management interface is not\
    \ specified by this document\n      and may differ for hosts vs. security gateways,\
    \ and within hosts\n      the interface may differ for socket-based vs. BITS\n\
    \      implementations.  However, this document does specify a standard\n    \
    \  set of SPD elements that all IPsec implementations MUST support.\n   Decorrelation\n\
    \      The processing model described in this document assumes the\n      ability\
    \ to decorrelate overlapping SPD entries to permit caching,\n      which enables\
    \ more efficient processing of outbound traffic in\n      security gateways and\
    \ BITS/BITW implementations.  Decorrelation\n      [CoSa04] is only a means of\
    \ improving performance and simplifying\n      the processing description.  This\
    \ RFC does not require a compliant\n      implementation to make use of decorrelation.\
    \  For example, native\n      host implementations typically make use of caching\
    \ implicitly\n      because they bind SAs to socket interfaces, and thus there\
    \ is no\n      requirement to be able to decorrelate SPD entries in these\n  \
    \    implementations.\n      Note:  Unless otherwise qualified, the use of \"\
    SPD\" refers to the\n      body of policy information in both ordered or decorrelated\n\
    \      (unordered) state.  Appendix B provides an algorithm that can be\n    \
    \  used to decorrelate SPD entries, but any algorithm that produces\n      equivalent\
    \ output may be used.  Note that when an SPD entry is\n      decorrelated all\
    \ the resulting entries MUST be linked together, so\n      that all members of\
    \ the group derived from an individual, SPD\n      entry (prior to decorrelation)\
    \ can all be placed into caches and\n      into the SAD at the same time.  For\
    \ example, suppose one starts\n      with an entry A (from an ordered SPD) that\
    \ when decorrelated,\n      yields entries A1, A2, and A3.  When a packet comes\
    \ along that\n      matches, say A2, and triggers the creation of an SA, the SA\n\
    \      management protocol (e.g., IKEv2) negotiates A.  And all 3\n      decorrelated\
    \ entries, A1, A2, and A3, are placed in the\n      appropriate SPD-S cache and\
    \ linked to the SA.  The intent is that\n      use of a decorrelated SPD ought\
    \ not to create more SAs than would\n      have resulted from use of a not-decorrelated\
    \ SPD.\n      If a decorrelated SPD is employed, there are three options for\n\
    \      what an initiator sends to a peer via an SA management protocol\n     \
    \ (e.g., IKE).  By sending the complete set of linked, decorrelated\n      entries\
    \ that were selected from the SPD, a peer is given the best\n      possible information\
    \ to enable selection of the appropriate SPD\n      entry at its end, especially\
    \ if the peer has also decorrelated its\n      SPD.  However, if a large number\
    \ of decorrelated entries are\n      linked, this may create large packets for\
    \ SA negotiation, and\n      hence fragmentation problems for the SA management\
    \ protocol.\n      Alternatively, the original entry from the (correlated) SPD\
    \ may be\n      retained and passed to the SA management protocol.  Passing the\n\
    \      correlated SPD entry keeps the use of a decorrelated SPD a local\n    \
    \  matter, not visible to peers, and avoids possible fragmentation\n      concerns,\
    \ although it provides less precise information to a\n      responder for matching\
    \ against the responder's SPD.\n      An intermediate approach is to send a subset\
    \ of the complete set\n      of linked, decorrelated SPD entries.  This approach\
    \ can avoid the\n      fragmentation problems cited above yet provide better information\n\
    \      than the original, correlated entry.  The major shortcoming of\n      this\
    \ approach is that it may cause additional SAs to be created\n      later, since\
    \ only a subset of the linked, decorrelated entries are\n      sent to a peer.\
    \  Implementers are free to employ any of the\n      approaches cited above.\n\
    \      A responder uses the traffic selector proposals it receives via an\n  \
    \    SA management protocol to select an appropriate entry in its SPD.\n     \
    \ The intent of the matching is to select an SPD entry and create an\n      SA\
    \ that most closely matches the intent of the initiator, so that\n      traffic\
    \ traversing the resulting SA will be accepted at both ends.\n      If the responder\
    \ employs a decorrelated SPD, it SHOULD use the\n      decorrelated SPD entries\
    \ for matching, as this will generally\n      result in creation of SAs that are\
    \ more likely to match the intent\n      of both peers.  If the responder has\
    \ a correlated SPD, then it\n      SHOULD match the proposals against the correlated\
    \ entries.  For\n      IKEv2, use of a decorrelated SPD offers the best opportunity\
    \ for a\n      responder to generate a \"narrowed\" response.\n      In all cases,\
    \ when a decorrelated SPD is available, the\n      decorrelated entries are used\
    \ to populate the SPD-S cache.  If the\n      SPD is not decorrelated, caching\
    \ is not allowed and an ordered\n      search of SPD MUST be performed to verify\
    \ that inbound traffic\n      arriving on an SA is consistent with the access\
    \ control policy\n      expressed in the SPD.\n   Handling Changes to the SPD\
    \ While the System Is Running\n      If a change is made to the SPD while the\
    \ system is running, a\n      check SHOULD be made of the effect of this change\
    \ on extant SAs.\n      An implementation SHOULD check the impact of an SPD change\
    \ on\n      extant SAs and SHOULD provide a user/administrator with a\n      mechanism\
    \ for configuring what actions to take, e.g., delete an\n      affected SA, allow\
    \ an affected SA to continue unchanged, etc.\n"
- title: 4.4.1.1.   Selectors
  contents:
  - "4.4.1.1.   Selectors\n   An SA may be fine-grained or coarse-grained, depending\
    \ on the\n   selectors used to define the set of traffic for the SA.  For example,\n\
    \   all traffic between two hosts may be carried via a single SA, and\n   afforded\
    \ a uniform set of security services.  Alternatively, traffic\n   between a pair\
    \ of hosts might be spread over multiple SAs, depending\n   on the applications\
    \ being used (as defined by the Next Layer Protocol\n   and related fields, e.g.,\
    \ ports), with different security services\n   offered by different SAs.  Similarly,\
    \ all traffic between a pair of\n   security gateways could be carried on a single\
    \ SA, or one SA could be\n   assigned for each communicating host pair.  The following\
    \ selector\n   parameters MUST be supported by all IPsec implementations to\n\
    \   facilitate control of SA granularity.  Note that both Local and\n   Remote\
    \ addresses should either be IPv4 or IPv6, but not a mix of\n   address types.\
    \  Also, note that the Local/Remote port selectors (and\n   ICMP message type\
    \ and code, and Mobility Header type) may be labeled\n   as OPAQUE to accommodate\
    \ situations where these fields are\n   inaccessible due to packet fragmentation.\n\
    \      - Remote IP Address(es) (IPv4 or IPv6): This is a list of ranges\n    \
    \    of IP addresses (unicast, broadcast (IPv4 only)).  This\n        structure\
    \ allows expression of a single IP address (via a\n        trivial range), or\
    \ a list of addresses (each a trivial range),\n        or a range of addresses\
    \ (low and high values, inclusive), as\n        well as the most generic form\
    \ of a list of ranges.  Address\n        ranges are used to support more than\
    \ one remote system sharing\n        the same SA, e.g., behind a security gateway.\n\
    \      - Local IP Address(es) (IPv4 or IPv6): This is a list of ranges of\n  \
    \      IP addresses (unicast, broadcast (IPv4 only)).  This structure\n      \
    \  allows expression of a single IP address (via a trivial range),\n        or\
    \ a list of addresses (each a trivial range), or a range of\n        addresses\
    \ (low and high values, inclusive), as well as the most\n        generic form\
    \ of a list of ranges.  Address ranges are used to\n        support more than\
    \ one source system sharing the same SA, e.g.,\n        behind a security gateway.\
    \  Local refers to the address(es)\n        being protected by this implementation\
    \ (or policy entry).\n        Note: The SPD does not include support for multicast\
    \ address\n        entries.  To support multicast SAs, an implementation should\n\
    \        make use of a Group SPD (GSPD) as defined in [RFC3740].  GSPD\n     \
    \   entries require a different structure, i.e., one cannot use the\n        symmetric\
    \ relationship associated with local and remote address\n        values for unicast\
    \ SAs in a multicast context.  Specifically,\n        outbound traffic directed\
    \ to a multicast address on an SA would\n        not be received on a companion,\
    \ inbound SA with the multicast\n        address as the source.\n      - Next\
    \ Layer Protocol: Obtained from the IPv4 \"Protocol\" or the\n        IPv6 \"\
    Next Header\" fields.  This is an individual protocol\n        number, ANY, or\
    \ for IPv6 only, OPAQUE.  The Next Layer Protocol\n        is whatever comes after\
    \ any IP extension headers that are\n        present.  To simplify locating the\
    \ Next Layer Protocol, there\n        SHOULD be a mechanism for configuring which\
    \ IPv6 extension\n        headers to skip.  The default configuration for which\
    \ protocols\n        to skip SHOULD include the following protocols: 0 (Hop-by-hop\n\
    \        options), 43 (Routing Header), 44 (Fragmentation Header), and 60\n  \
    \      (Destination Options).  Note: The default list does NOT include\n     \
    \   51 (AH) or 50 (ESP).  From a selector lookup point of view,\n        IPsec\
    \ treats AH and ESP as Next Layer Protocols.\n        Several additional selectors\
    \ depend on the Next Layer Protocol\n        value:\n         * If the Next Layer\
    \ Protocol uses two ports (as do TCP, UDP,\n           SCTP, and others), then\
    \ there are selectors for Local and\n           Remote Ports.  Each of these selectors\
    \ has a list of ranges\n           of values.  Note that the Local and Remote\
    \ ports may not be\n           available in the case of receipt of a fragmented\
    \ packet or if\n           the port fields have been protected by IPsec (encrypted);\n\
    \           thus, a value of OPAQUE also MUST be supported.  Note: In a\n    \
    \       non-initial fragment, port values will not be available.  If\n       \
    \    a port selector specifies a value other than ANY or OPAQUE,\n           it\
    \ cannot match packets that are non-initial fragments.  If\n           the SA\
    \ requires a port value other than ANY or OPAQUE, an\n           arriving fragment\
    \ without ports MUST be discarded. (See\n           Section 7, \"Handling Fragments\"\
    .)\n         * If the Next Layer Protocol is a Mobility Header, then there\n \
    \          is a selector for IPv6 Mobility Header message type (MH type)\n   \
    \        [Mobip].  This is an 8-bit value that identifies a particular\n     \
    \      mobility message.  Note that the MH type may not be available\n       \
    \    in the case of receipt of a fragmented packet. (See Section\n           7,\
    \ \"Handling Fragments\".) For IKE, the IPv6 Mobility Header\n           message\
    \ type (MH type) is placed in the most significant\n           eight bits of the\
    \ 16-bit local \"port\" selector.\n         * If the Next Layer Protocol value\
    \ is ICMP, then there is a\n           16-bit selector for the ICMP message type\
    \ and code.  The\n           message type is a single 8-bit value, which defines\
    \ the type\n           of an ICMP message, or ANY.  The ICMP code is a single\
    \ 8-bit\n           value that defines a specific subtype for an ICMP message.\n\
    \           For IKE, the message type is placed in the most significant 8\n  \
    \         bits of the 16-bit selector and the code is placed in the\n        \
    \   least significant 8 bits.  This 16-bit selector can contain a\n          \
    \ single type and a range of codes, a single type and ANY code,\n           and\
    \ ANY type and ANY code.  Given a policy entry with a range\n           of Types\
    \ (T-start to T-end) and a range of Codes (C-start to\n           C-end), and\
    \ an ICMP packet with Type t and Code c, an\n           implementation MUST test\
    \ for a match using\n               (T-start*256) + C-start <= (t*256) + c <=\
    \ (T-end*256) +\n               C-end\n           Note that the ICMP message type\
    \ and code may not be available\n           in the case of receipt of a fragmented\
    \ packet. (See Section\n           7, \"Handling Fragments\".)\n      - Name:\
    \  This is not a selector like the others above.  It is not\n        acquired\
    \ from a packet.  A name may be used as a symbolic\n        identifier for an\
    \ IPsec Local or Remote address.  Named SPD\n        entries are used in two ways:\n\
    \         1. A named SPD entry is used by a responder (not an initiator)\n   \
    \         in support of access control when an IP address would not be\n     \
    \       appropriate for the Remote IP address selector, e.g., for\n          \
    \  \"road warriors\".  The name used to match this field is\n            communicated\
    \ during the IKE negotiation in the ID payload.\n            In this context,\
    \ the initiator's Source IP address (inner IP\n            header in tunnel mode)\
    \ is bound to the Remote IP address in\n            the SAD entry created by the\
    \ IKE negotiation.  This address\n            overrides the Remote IP address\
    \ value in the SPD, when the\n            SPD entry is selected in this fashion.\
    \  All IPsec\n            implementations MUST support this use of names.\n  \
    \       2. A named SPD entry may be used by an initiator to identify a\n     \
    \       user for whom an IPsec SA will be created (or for whom\n            traffic\
    \ may be bypassed).  The initiator's IP source address\n            (from inner\
    \ IP header in tunnel mode) is used to replace the\n            following if and\
    \ when they are created:\n                    - local address in the SPD cache\
    \ entry\n                    - local address in the outbound SAD entry\n     \
    \               - remote address in the inbound SAD entry\n            Support\
    \ for this use is optional for multi-user, native host\n            implementations\
    \ and not applicable to other implementations.\n            Note that this name\
    \ is used only locally; it is not\n            communicated by the key management\
    \ protocol.  Also, name\n            forms other than those used for case 1 above\
    \ (responder) are\n            applicable in the initiator context (see below).\n\
    \         An SPD entry can contain both a name (or a list of names) and\n    \
    \     also values for the Local or Remote IP address.\n         For case 1, responder,\
    \ the identifiers employed in named SPD\n         entries are one of the following\
    \ four types:\n                 a. a fully qualified user name string (email),\
    \ e.g.,\n                    mozart@foo.example.com\n                    (this\
    \ corresponds to ID_RFC822_ADDR in IKEv2)\n                 b. a fully qualified\
    \ DNS name, e.g.,\n                    foo.example.com\n                    (this\
    \ corresponds to ID_FQDN in IKEv2)\n                 c. X.500 distinguished name,\
    \ e.g., [WaKiHo97],\n                    CN = Stephen T. Kent, O = BBN Technologies,\n\
    \                    SP = MA, C = US\n                    (this corresponds to\
    \ ID_DER_ASN1_DN in IKEv2, after\n                    decoding)\n            \
    \     d. a byte string\n                    (this corresponds to Key_ID in IKEv2)\n\
    \         For case 2, initiator, the identifiers employed in named SPD\n     \
    \    entries are of type byte string.  They are likely to be Unix\n         UIDs,\
    \ Windows security IDs, or something similar, but could\n         also be a user\
    \ name or account name.  In all cases, this\n         identifier is only of local\
    \ concern and is not transmitted.\n   The IPsec implementation context determines\
    \ how selectors are used.\n   For example, a native host implementation typically\
    \ makes use of a\n   socket interface.  When a new connection is established,\
    \ the SPD can\n   be consulted and an SA bound to the socket.  Thus, traffic sent\
    \ via\n   that socket need not result in additional lookups to the SPD (SPD-O\n\
    \   and SPD-S) cache.  In contrast, a BITS, BITW, or security gateway\n   implementation\
    \ needs to look at each packet and perform an\n   SPD-O/SPD-S cache lookup based\
    \ on the selectors.\n"
- title: 4.4.1.2.  Structure of an SPD Entry
  contents:
  - "4.4.1.2.  Structure of an SPD Entry\n   This section contains a prose description\
    \ of an SPD entry.  Also,\n   Appendix C provides an example of an ASN.1 definition\
    \ of an SPD\n   entry.\n   This text describes the SPD in a fashion that is intended\
    \ to map\n   directly into IKE payloads to ensure that the policy required by\
    \ SPD\n   entries can be negotiated through IKE.  Unfortunately, the semantics\n\
    \   of the version of IKEv2 published concurrently with this document\n   [Kau05]\
    \ do not align precisely with those defined for the SPD.\n   Specifically, IKEv2\
    \ does not enable negotiation of a single SA that\n   binds multiple pairs of\
    \ local and remote addresses and ports to a\n   single SA.  Instead, when multiple\
    \ local and remote addresses and\n   ports are negotiated for an SA, IKEv2 treats\
    \ these not as pairs, but\n   as (unordered) sets of local and remote values that\
    \ can be\n   arbitrarily paired.  Until IKE provides a facility that conveys the\n\
    \   semantics that are expressed in the SPD via selector sets (as\n   described\
    \ below), users MUST NOT include multiple selector sets in a\n   single SPD entry\
    \ unless the access control intent aligns with the IKE\n   \"mix and match\" semantics.\
    \  An implementation MAY warn users, to\n   alert them to this problem if users\
    \ create SPD entries with multiple\n   selector sets, the syntax of which indicates\
    \ possible conflicts with\n   current IKE semantics.\n   The management GUI can\
    \ offer the user other forms of data entry and\n   display, e.g., the option of\
    \ using address prefixes as well as\n   ranges, and symbolic names for protocols,\
    \ ports, etc. (Do not confuse\n   the use of symbolic names in a management interface\
    \ with the SPD\n   selector \"Name\".) Note that Remote/Local apply only to IP\
    \ addresses\n   and ports, not to ICMP message type/code or Mobility Header type.\n\
    \   Also, if the reserved, symbolic selector value OPAQUE or ANY is\n   employed\
    \ for a given selector type, only that value may appear in the\n   list for that\
    \ selector, and it must appear only once in the list for\n   that selector.  Note\
    \ that ANY and OPAQUE are local syntax conventions\n   -- IKEv2 negotiates these\
    \ values via the ranges indicated below:\n          ANY:     start = 0       \
    \ end = <max>\n          OPAQUE:  start = <max>    end = 0\n   An SPD is an ordered\
    \ list of entries each of which contains the\n   following fields.\n         \
    \  o Name -- a list of IDs.  This quasi-selector is optional.\n             The\
    \ forms that MUST be supported are described above in\n             Section 4.4.1.1\
    \ under \"Name\".\n           o PFP flags -- one per traffic selector.  A given\
    \ flag, e.g.,\n             for Next Layer Protocol, applies to the relevant selector\n\
    \             across all \"selector sets\" (see below) contained in an SPD\n \
    \            entry.  When creating an SA, each flag specifies for the\n      \
    \       corresponding traffic selector whether to instantiate the\n          \
    \   selector from the corresponding field in the packet that\n             triggered\
    \ the creation of the SA or from the value(s) in\n             the corresponding\
    \ SPD entry (see Section 4.4.1, \"How to\n             Derive the Values for an\
    \ SAD Entry\").  Whether a single\n             flag is used for, e.g., source\
    \ port, ICMP type/code, and\n             MH type, or a separate flag is used\
    \ for each, is a local\n             matter.  There are PFP flags for:\n     \
    \           - Local Address\n                - Remote Address\n              \
    \  - Next Layer Protocol\n                - Local Port, or ICMP message type/code\
    \ or Mobility\n                  Header type (depending on the next layer protocol)\n\
    \                - Remote Port, or ICMP message type/code or Mobility\n      \
    \            Header type (depending on the next layer protocol)\n           o\
    \ One to N selector sets that correspond to the \"condition\"\n             for\
    \ applying a particular IPsec action.  Each selector set\n             contains:\n\
    \                - Local Address\n                - Remote Address\n         \
    \       - Next Layer Protocol\n                - Local Port, or ICMP message type/code\
    \ or Mobility\n                  Header type (depending on the next layer protocol)\n\
    \                - Remote Port, or ICMP message type/code or Mobility\n      \
    \            Header type (depending on the next layer protocol)\n            \
    \ Note: The \"next protocol\" selector is an individual value\n             (unlike\
    \ the local and remote IP addresses) in a selector\n             set entry.  This\
    \ is consistent with how IKEv2 negotiates\n             the Traffic Selector (TS)\
    \ values for an SA.  It also makes\n             sense because one may need to\
    \ associate different port\n             fields with different protocols.  It\
    \ is possible to\n             associate multiple protocols (and ports) with a\
    \ single SA\n             by specifying multiple selector sets for that SA.\n\
    \           o Processing info -- which action is required -- PROTECT,\n      \
    \       BYPASS, or DISCARD.  There is just one action that goes\n            \
    \ with all the selector sets, not a separate action for each\n             set.\
    \  If the required processing is PROTECT, the entry\n             contains the\
    \ following information.\n                - IPsec mode -- tunnel or transport\n\
    \                - (if tunnel mode) local tunnel address -- For a\n          \
    \        non-mobile host, if there is just one interface, this\n             \
    \     is straightforward; if there are multiple\n                  interfaces,\
    \ this must be statically configured.  For a\n                  mobile host, the\
    \ specification of the local address\n                  is handled externally\
    \ to IPsec.\n                - (if tunnel mode) remote tunnel address -- There\
    \ is no\n                  standard way to determine this.  See 4.5.3, \"Locating\n\
    \                  a Security Gateway\".\n                - Extended Sequence\
    \ Number -- Is this SA using extended\n                  sequence numbers?\n \
    \               - stateful fragment checking -- Is this SA using\n           \
    \       stateful fragment checking?  (See Section 7 for more\n               \
    \   details.)\n                - Bypass DF bit (T/F) -- applicable to tunnel mode\
    \ SAs\n                - Bypass DSCP (T/F) or map to unprotected DSCP values\n\
    \                  (array) if needed to restrict bypass of DSCP values --\n  \
    \                applicable to tunnel mode SAs\n                - IPsec protocol\
    \ -- AH or ESP\n                - algorithms -- which ones to use for AH, which\
    \ ones to\n                  use for ESP, which ones to use for combined mode,\n\
    \                  ordered by decreasing priority\n   It is a local matter as\
    \ to what information is kept with regard to\n   handling extant SAs when the\
    \ SPD is changed.\n"
- title: 4.4.1.3.  More Regarding Fields Associated with Next Layer Protocols
  contents:
  - "4.4.1.3.  More Regarding Fields Associated with Next Layer Protocols\n   Additional\
    \ selectors are often associated with fields in the Next\n   Layer Protocol header.\
    \  A particular Next Layer Protocol can have\n   zero, one, or two selectors.\
    \  There may be situations where there\n   aren't both local and remote selectors\
    \ for the fields that are\n   dependent on the Next Layer Protocol.  The IPv6\
    \ Mobility Header has\n   only a Mobility Header message type.  AH and ESP have\
    \ no further\n   selector fields.  A system may be willing to send an ICMP message\n\
    \   type and code that it does not want to receive.  In the descriptions\n   below,\
    \ \"port\" is used to mean a field that is dependent on the Next\n   Layer Protocol.\n\
    \        A. If a Next Layer Protocol has no \"port\" selectors, then\n       \
    \    the Local and Remote \"port\" selectors are set to OPAQUE in\n          \
    \ the relevant SPD entry, e.g.,\n           Local's\n             next layer protocol\
    \ = AH\n             \"port\" selector     = OPAQUE\n           Remote's\n   \
    \          next layer protocol = AH\n             \"port\" selector     = OPAQUE\n\
    \        B. Even if a Next Layer Protocol has only one selector, e.g.,\n     \
    \      Mobility Header type, then the Local and Remote \"port\"\n           selectors\
    \ are used to indicate whether a system is\n           willing to send and/or\
    \ receive traffic with the specified\n          \"port\" values. For example,\
    \ if Mobility Headers of a\n           specified type are allowed to be sent and\
    \ received via an\n           SA, then the relevant SPD entry would be set as\
    \ follows:\n           Local's\n             next layer protocol = Mobility Header\n\
    \             \"port\" selector     = Mobility Header message type\n         \
    \  Remote's\n             next layer protocol = Mobility Header\n            \
    \ \"port\" selector     = Mobility Header message type\n           If Mobility\
    \ Headers of a specified type are allowed to be\n           sent but NOT received\
    \ via an SA, then the relevant SPD\n           entry would be set as follows:\n\
    \           Local's\n             next layer protocol = Mobility Header\n    \
    \         \"port\" selector     = Mobility Header message type\n           Remote's\n\
    \             next layer protocol = Mobility Header\n             \"port\" selector\
    \     = OPAQUE\n           If Mobility Headers of a specified type are allowed\
    \ to be\n           received but NOT sent via an SA, then the relevant SPD\n \
    \          entry would be set as follows:\n           Local's\n             next\
    \ layer protocol = Mobility Header\n             \"port\" selector     = OPAQUE\n\
    \           Remote's\n             next layer protocol = Mobility Header\n   \
    \          \"port\" selector     = Mobility Header message type\n        C. If\
    \ a system is willing to send traffic with a particular\n           \"port\" value\
    \ but NOT receive traffic with that kind of\n           port value, the system's\
    \ traffic selectors are set as\n           follows in the relevant SPD entry:\n\
    \           Local's\n             next layer protocol = ICMP\n             \"\
    port\" selector     = <specific ICMP type & code>\n           Remote's\n     \
    \        next layer protocol = ICMP\n             \"port\" selector     = OPAQUE\n\
    \        D. To indicate that a system is willing to receive traffic\n        \
    \   with a particular \"port\" value but NOT send that kind of\n           traffic,\
    \ the system's traffic selectors are set as follows\n           in the relevant\
    \ SPD entry:\n           Local's\n             next layer protocol = ICMP\n  \
    \           \"port\" selector     = OPAQUE\n           Remote's\n            \
    \ next layer protocol = ICMP\n             \"port\" selector     = <specific ICMP\
    \ type & code>\n           For example, if a security gateway is willing to allow\n\
    \           systems behind it to send ICMP traceroutes, but is not\n         \
    \  willing to let outside systems run ICMP traceroutes to\n           systems\
    \ behind it, then the security gateway's traffic\n           selectors are set\
    \ as follows in the relevant SPD entry:\n           Local's\n             next\
    \ layer protocol = 1 (ICMPv4)\n             \"port\" selector     = 30 (traceroute)\n\
    \           Remote's\n             next layer protocol = 1 (ICMPv4)\n        \
    \     \"port\" selector     = OPAQUE\n"
- title: 4.4.2.  Security Association Database (SAD)
  contents:
  - "4.4.2.  Security Association Database (SAD)\n   In each IPsec implementation,\
    \ there is a nominal Security Association\n   Database (SAD), in which each entry\
    \ defines the parameters associated\n   with one SA.  Each SA has an entry in\
    \ the SAD.  For outbound\n   processing, each SAD entry is pointed to by entries\
    \ in the SPD-S part\n   of the SPD cache.  For inbound processing, for unicast\
    \ SAs, the SPI\n   is used either alone to look up an SA or in conjunction with\
    \ the\n   IPsec protocol type.  If an IPsec implementation supports multicast,\n\
    \   the SPI plus destination address, or SPI plus destination and source\n   addresses\
    \ are used to look up the SA. (See Section 4.1 for details on\n   the algorithm\
    \ that MUST be used for mapping inbound IPsec datagrams\n   to SAs.) The following\
    \ parameters are associated with each entry in\n   the SAD.  They should all be\
    \ present except where otherwise noted,\n   e.g., AH Authentication algorithm.\
    \  This description does not purport\n   to be a MIB, only a specification of\
    \ the minimal data items required\n   to support an SA in an IPsec implementation.\n\
    \   For each of the selectors defined in Section 4.4.1.1, the entry for\n   an\
    \ inbound SA in the SAD MUST be initially populated with the value\n   or values\
    \ negotiated at the time the SA was created. (See the\n   paragraph in Section\
    \ 4.4.1 under \"Handling Changes to the SPD while\n   the System is Running\"\
    \ for guidance on the effect of SPD changes on\n   extant SAs.) For a receiver,\
    \ these values are used to check that the\n   header fields of an inbound packet\
    \ (after IPsec processing) match the\n   selector values negotiated for the SA.\
    \  Thus, the SAD acts as a cache\n   for checking the selectors of inbound traffic\
    \ arriving on SAs.  For\n   the receiver, this is part of verifying that a packet\
    \ arriving on an\n   SA is consistent with the policy for the SA. (See Section\
    \ 6 for rules\n   for ICMP messages.)  These fields can have the form of specific\n\
    \   values, ranges, ANY, or OPAQUE, as described in Section 4.4.1.1,\n   \"Selectors\"\
    .  Note also that there are a couple of situations in\n   which the SAD can have\
    \ entries for SAs that do not have corresponding\n   entries in the SPD.  Since\
    \ this document does not mandate that the\n   SAD be selectively cleared when\
    \ the SPD is changed, SAD entries can\n   remain when the SPD entries that created\
    \ them are changed or deleted.\n   Also, if a manually keyed SA is created, there\
    \ could be an SAD entry\n   for this SA that does not correspond to any SPD entry.\n\
    \   Note: The SAD can support multicast SAs, if manually configured.  An\n   outbound\
    \ multicast SA has the same structure as a unicast SA.  The\n   source address\
    \ is that of the sender, and the destination address is\n   the multicast group\
    \ address.  An inbound, multicast SA must be\n   configured with the source addresses\
    \ of each peer authorized to\n   transmit to the multicast SA in question.  The\
    \ SPI value for a\n   multicast SA is provided by a multicast group controller,\
    \ not by the\n   receiver, as for a unicast SA.  Because an SAD entry may be required\n\
    \   to accommodate multiple, individual IP source addresses that were\n   part\
    \ of an SPD entry (for unicast SAs), the required facility for\n   inbound, multicast\
    \ SAs is a feature already present in an IPsec\n   implementation.  However, because\
    \ the SPD has no provisions for\n   accommodating multicast entries, this document\
    \ does not specify an\n   automated way to create an SAD entry for a multicast,\
    \ inbound SA.\n   Only manually configured SAD entries can be created to accommodate\n\
    \   inbound, multicast traffic.\n   Implementation Guidance: This document does\
    \ not specify how an SPD-S\n   entry refers to the corresponding SAD entry, as\
    \ this is an\n   implementation-specific detail.  However, some implementations\
    \ (based\n   on experience from RFC 2401) are known to have problems in this\n\
    \   regard.  In particular, simply storing the (remote tunnel header IP\n   address,\
    \ remote SPI) pair in the SPD cache is not sufficient, since\n   the pair does\
    \ not always uniquely identify a single SAD entry.  For\n   instance, two hosts\
    \ behind the same NAT could choose the same SPI\n   value.  The situation also\
    \ may arise if a host is assigned an IP\n   address (e.g., via DHCP) previously\
    \ used by some other host, and the\n   SAs associated with the old host have not\
    \ yet been deleted via dead\n   peer detection mechanisms.  This may lead to packets\
    \ being sent over\n   the wrong SA or, if key management ensures the pair is unique,\n\
    \   denying the creation of otherwise valid SAs.  Thus, implementors\n   should\
    \ implement links between the SPD cache and the SAD in a way\n   that does not\
    \ engender such problems.\n"
- title: 4.4.2.1.  Data Items in the SAD
  contents:
  - "4.4.2.1.  Data Items in the SAD\n   The following data items MUST be in the SAD:\n\
    \    o Security Parameter Index (SPI): a 32-bit value selected by the\n      receiving\
    \ end of an SA to uniquely identify the SA.  In an SAD\n      entry for an outbound\
    \ SA, the SPI is used to construct the\n      packet's AH or ESP header.  In an\
    \ SAD entry for an inbound SA, the\n      SPI is used to map traffic to the appropriate\
    \ SA (see text on\n      unicast/multicast in Section 4.1).\n    o Sequence Number\
    \ Counter: a 64-bit counter used to generate the\n      Sequence Number field\
    \ in AH or ESP headers. 64-bit sequence\n      numbers are the default, but 32-bit\
    \ sequence numbers are also\n      supported if negotiated.\n    o Sequence Counter\
    \ Overflow: a flag indicating whether overflow of\n      the sequence number counter\
    \ should generate an auditable event and\n      prevent transmission of additional\
    \ packets on the SA, or whether\n      rollover is permitted.  The audit log entry\
    \ for this event SHOULD\n      include the SPI value, current date/time, Local\
    \ Address, Remote\n      Address, and the selectors from the relevant SAD entry.\n\
    \    o Anti-Replay Window: a 64-bit counter and a bit-map (or equivalent)\n  \
    \    used to determine whether an inbound AH or ESP packet is a replay.\n    \
    \  Note: If anti-replay has been disabled by the receiver for an SA,\n      e.g.,\
    \ in the case of a manually keyed SA, then the Anti-Replay\n      Window is ignored\
    \ for the SA in question. 64-bit sequence numbers\n      are the default, but\
    \ this counter size accommodates 32-bit\n      sequence numbers as well.\n   \
    \ o AH Authentication algorithm, key, etc.  This is required only if\n      AH\
    \ is supported.\n    o ESP Encryption algorithm, key, mode, IV, etc.  If a combined\
    \ mode\n      algorithm is used, these fields will not be applicable.\n    o ESP\
    \ integrity algorithm, keys, etc.  If the integrity service is\n      not selected,\
    \ these fields will not be applicable.  If a combined\n      mode algorithm is\
    \ used, these fields will not be applicable.\n    o ESP combined mode algorithms,\
    \ key(s), etc.  This data is used when\n      a combined mode (encryption and\
    \ integrity) algorithm is used with\n      ESP.  If a combined mode algorithm\
    \ is not used, these fields are\n      not applicable.\n    o Lifetime of this\
    \ SA: a time interval after which an SA must be\n      replaced with a new SA\
    \ (and new SPI) or terminated, plus an\n      indication of which of these actions\
    \ should occur.  This may be\n      expressed as a time or byte count, or a simultaneous\
    \ use of both\n      with the first lifetime to expire taking precedence.  A compliant\n\
    \      implementation MUST support both types of lifetimes, and MUST\n      support\
    \ a simultaneous use of both.  If time is employed, and if\n      IKE employs\
    \ X.509 certificates for SA establishment, the SA\n      lifetime must be constrained\
    \ by the validity intervals of the\n      certificates, and the NextIssueDate\
    \ of the Certificate Revocation\n      Lists (CRLs) used in the IKE exchange for\
    \ the SA.  Both initiator\n      and responder are responsible for constraining\
    \ the SA lifetime in\n      this fashion.  Note: The details of how to handle\
    \ the refreshing\n      of keys when SAs expire is a local matter.  However, one\n\
    \      reasonable approach is:\n     (a) If byte count is used, then the implementation\
    \ SHOULD count the\n         number of bytes to which the IPsec cryptographic\
    \ algorithm is\n         applied.  For ESP, this is the encryption algorithm (including\n\
    \         Null encryption) and for AH, this is the authentication\n         algorithm.\
    \  This includes pad bytes, etc.  Note that\n         implementations MUST be\
    \ able to handle having the counters at\n         the ends of an SA get out of\
    \ synch, e.g., because of packet\n         loss or because the implementations\
    \ at each end of the SA\n         aren't doing things the same way.\n     (b)\
    \ There SHOULD be two kinds of lifetime -- a soft lifetime that\n         warns\
    \ the implementation to initiate action such as setting up\n         a replacement\
    \ SA, and a hard lifetime when the current SA ends\n         and is destroyed.\n\
    \     (c) If the entire packet does not get delivered during the SA's\n      \
    \   lifetime, the packet SHOULD be discarded.\n    o IPsec protocol mode: tunnel\
    \ or transport.  Indicates which mode of\n      AH or ESP is applied to traffic\
    \ on this SA.\n    o Stateful fragment checking flag.  Indicates whether or not\n\
    \      stateful fragment checking applies to this SA.\n    o Bypass DF bit (T/F)\
    \ -- applicable to tunnel mode SAs where both\n      inner and outer headers are\
    \ IPv4.\n    o DSCP values -- the set of DSCP values allowed for packets carried\n\
    \      over this SA.  If no values are specified, no DSCP-specific\n      filtering\
    \ is applied.  If one or more values are specified, these\n      are used to select\
    \ one SA among several that match the traffic\n      selectors for an outbound\
    \ packet.  Note that these values are NOT\n      checked against inbound traffic\
    \ arriving on the SA.\n    o Bypass DSCP (T/F) or map to unprotected DSCP values\
    \ (array) if\n      needed to restrict bypass of DSCP values -- applicable to\
    \ tunnel\n      mode SAs.  This feature maps DSCP values from an inner header\
    \ to\n      values in an outer header, e.g., to address covert channel\n     \
    \ signaling concerns.\n    o Path MTU: any observed path MTU and aging variables.\n\
    \    o Tunnel header IP source and destination address -- both addresses\n   \
    \   must be either IPv4 or IPv6 addresses.  The version implies the\n      type\
    \ of IP header to be used.  Only used when the IPsec protocol\n      mode is tunnel.\n"
- title: 4.4.2.2.  Relationship between SPD, PFP flag, packet, and SAD
  contents:
  - "4.4.2.2.  Relationship between SPD, PFP flag, packet, and SAD\n      For each\
    \ selector, the following tables show the relationship\n      between the value\
    \ in the SPD, the PFP flag, the value in the\n      triggering packet, and the\
    \ resulting value in the SAD.  Note that\n      the administrative interface for\
    \ IPsec can use various syntactic\n      options to make it easier for the administrator\
    \ to enter rules.\n      For example, although a list of ranges is what IKEv2\
    \ sends, it\n      might be clearer and less error prone for the user to enter\
    \ a\n      single IP address or IP address prefix.\n                         \
    \               Value in\n                                        Triggering \
    \  Resulting SAD\n         Selector  SPD Entry        PFP Packet       Entry\n\
    \         --------  ---------------- --- ------------ --------------\n       \
    \  loc addr  list of ranges    0  IP addr \"S\"  list of ranges\n            \
    \       ANY               0  IP addr \"S\"  ANY\n                   list of ranges\
    \    1  IP addr \"S\"  \"S\"\n                   ANY               1  IP addr\
    \ \"S\"  \"S\"\n         rem addr  list of ranges    0  IP addr \"D\"  list of\
    \ ranges\n                   ANY               0  IP addr \"D\"  ANY\n       \
    \            list of ranges    1  IP addr \"D\"  \"D\"\n                   ANY\
    \               1  IP addr \"D\"  \"D\"\n         protocol  list of prot's*  \
    \ 0  prot. \"P\"    list of prot's*\n                   ANY**             0  prot.\
    \ \"P\"    ANY\n                   OPAQUE****        0  prot. \"P\"    OPAQUE\n\
    \                   list of prot's*   0  not avail.   discard packet\n       \
    \            ANY**             0  not avail.   ANY\n                   OPAQUE****\
    \        0  not avail.   OPAQUE\n                   list of prot's*   1  prot.\
    \ \"P\"    \"P\"\n                   ANY**             1  prot. \"P\"    \"P\"\
    \n                   OPAQUE****        1  prot. \"P\"    ***\n               \
    \    list of prot's*   1  not avail.   discard packet\n                   ANY**\
    \             1  not avail.   discard packet\n                   OPAQUE****  \
    \      1  not avail.   ***\n      If the protocol is one that has two ports, then\
    \ there will be\n      selectors for both Local and Remote ports.\n          \
    \                              Value in\n                                    \
    \    Triggering   Resulting SAD\n         Selector  SPD Entry        PFP Packet\
    \       Entry\n         --------  ---------------- --- ------------ --------------\n\
    \         loc port  list of ranges    0  src port \"s\" list of ranges\n     \
    \              ANY               0  src port \"s\" ANY\n                   OPAQUE\
    \            0  src port \"s\" OPAQUE\n                   list of ranges    0\
    \  not avail.   discard packet\n                   ANY               0  not avail.\
    \   ANY\n                   OPAQUE            0  not avail.   OPAQUE\n       \
    \            list of ranges    1  src port \"s\" \"s\"\n                   ANY\
    \               1  src port \"s\" \"s\"\n                   OPAQUE           \
    \ 1  src port \"s\" ***\n                   list of ranges    1  not avail.  \
    \ discard packet\n                   ANY               1  not avail.   discard\
    \ packet\n                   OPAQUE            1  not avail.   ***\n         rem\
    \ port  list of ranges    0  dst port \"d\" list of ranges\n                 \
    \  ANY               0  dst port \"d\" ANY\n                   OPAQUE        \
    \    0  dst port \"d\" OPAQUE\n                   list of ranges    0  not avail.\
    \   discard packet\n                   ANY               0  not avail.   ANY\n\
    \                   OPAQUE            0  not avail.   OPAQUE\n               \
    \    list of ranges    1  dst port \"d\" \"d\"\n                   ANY       \
    \        1  dst port \"d\" \"d\"\n                   OPAQUE            1  dst\
    \ port \"d\" ***\n                   list of ranges    1  not avail.   discard\
    \ packet\n                   ANY               1  not avail.   discard packet\n\
    \                   OPAQUE            1  not avail.   ***\n      If the protocol\
    \ is mobility header, then there will be a selector\n      for mh type.\n    \
    \                                    Value in\n                              \
    \          Triggering   Resulting SAD\n         Selector  SPD Entry        PFP\
    \ Packet       Entry\n         --------  ---------------- --- ------------ --------------\n\
    \         mh type   list of ranges    0  mh type \"T\"  list of ranges\n     \
    \              ANY               0  mh type \"T\"  ANY\n                   OPAQUE\
    \            0  mh type \"T\"  OPAQUE\n                   list of ranges    0\
    \  not avail.   discard packet\n                   ANY               0  not avail.\
    \   ANY\n                   OPAQUE            0  not avail.   OPAQUE\n       \
    \            list of ranges    1  mh type \"T\"  \"T\"\n                   ANY\
    \               1  mh type \"T\"  \"T\"\n                   OPAQUE           \
    \ 1  mh type \"T\"  ***\n                   list of ranges    1  not avail.  \
    \ discard packet\n                   ANY               1  not avail.   discard\
    \ packet\n                   OPAQUE            1  not avail.   ***\n      If the\
    \ protocol is ICMP, then there will be a 16-bit selector for\n      ICMP type\
    \ and ICMP code.  Note that the type and code are bound to\n      each other,\
    \ i.e., the codes apply to the particular type.  This\n      16-bit selector can\
    \ contain a single type and a range of codes, a\n      single type and ANY code,\
    \ and ANY type and ANY code.\n                                         Value in\n\
    \                                         Triggering   Resulting SAD\n       \
    \  Selector   SPD Entry        PFP Packet       Entry\n         ---------  ----------------\
    \ --- ------------ --------------\n         ICMP type  a single type &   0  type\
    \ \"t\" &   single type &\n         and code    range of codes        code \"\
    c\"    range of codes\n                    a single type &   0  type \"t\" & \
    \  single type &\n                     ANY code              code \"c\"    ANY\
    \ code\n                    ANY type & ANY    0  type \"t\" &   ANY type &\n \
    \                    code                  code \"c\"    ANY code\n          \
    \          OPAQUE            0  type \"t\" &   OPAQUE\n                      \
    \                     code \"c\"\n                    a single type &   0  not\
    \ avail.   discard packet\n                     range of codes\n             \
    \       a single type &   0  not avail.   discard packet\n                   \
    \  ANY code\n                    ANY type &        0  not avail.   ANY type &\n\
    \                     ANY code                          ANY code\n           \
    \         OPAQUE            0  not avail.   OPAQUE\n                    a single\
    \ type &   1  type \"t\" &   \"t\" and \"c\"\n                     range of codes\
    \        code \"c\"\n                    a single type &   1  type \"t\" &   \"\
    t\" and \"c\"\n                     ANY code              code \"c\"\n       \
    \             ANY type &        1  type \"t\" &   \"t\" and \"c\"\n          \
    \           ANY code              code \"c\"\n                    OPAQUE     \
    \       1  type \"t\" &   ***\n                                           code\
    \ \"c\"\n                    a single type &   1  not avail.   discard packet\n\
    \                     range of codes\n                    a single type &   1\
    \  not avail.   discard packet\n                     ANY code\n              \
    \      ANY type &        1  not avail.   discard packet\n                    \
    \ ANY code\n                    OPAQUE            1  not avail.   ***\n      If\
    \ the name selector is used:\n                                         Value in\n\
    \                                         Triggering   Resulting SAD\n       \
    \  Selector   SPD Entry        PFP Packet       Entry\n         ---------  ----------------\
    \ --- ------------ --------------\n         name       list of user or  N/A  \
    \   N/A           N/A\n                    system names\n            * \"List\
    \ of protocols\" is the information, not the way\n              that the SPD or\
    \ SAD or IKEv2 have to represent this\n              information.\n          \
    \ ** 0 (zero) is used by IKE to indicate ANY for\n              protocol.\n  \
    \        *** Use of PFP=1 with an OPAQUE value is an error and\n             \
    \ SHOULD be prohibited by an IPsec implementation.\n         **** The protocol\
    \ field cannot be OPAQUE in IPv4.  This\n              table entry applies only\
    \ to IPv6.\n"
- title: 4.4.3.  Peer Authorization Database (PAD)
  contents:
  - "4.4.3.  Peer Authorization Database (PAD)\n   The Peer Authorization Database\
    \ (PAD) provides the link between the\n   SPD and a security association management\
    \ protocol such as IKE.  It\n   embodies several critical functions:\n       \
    \ o identifies the peers or groups of peers that are authorized\n          to\
    \ communicate with this IPsec entity\n        o specifies the protocol and method\
    \ used to authenticate each\n          peer\n        o provides the authentication\
    \ data for each peer\n        o constrains the types and values of IDs that can\
    \ be asserted\n          by a peer with regard to child SA creation, to ensure\
    \ that the\n          peer does not assert identities for lookup in the SPD that\
    \ it\n          is not authorized to represent, when child SAs are created\n \
    \       o peer gateway location info, e.g., IP address(es) or DNS names,\n   \
    \       MAY be included for peers that are known to be \"behind\" a\n        \
    \  security gateway\n   The PAD provides these functions for an IKE peer when\
    \ the peer acts\n   as either the initiator or the responder.\n   To perform these\
    \ functions, the PAD contains an entry for each peer\n   or group of peers with\
    \ which the IPsec entity will communicate.  An\n   entry names an individual peer\
    \ (a user, end system or security\n   gateway) or specifies a group of peers (using\
    \ ID matching rules\n   defined below).  The entry specifies the authentication\
    \ protocol\n   (e.g., IKEv1, IKEv2, KINK) method used (e.g., certificates or pre-\n\
    \   shared secrets) and the authentication data (e.g., the pre-shared\n   secret\
    \ or the trust anchor relative to which the peer's certificate\n   will be validated).\
    \  For certificate-based authentication, the entry\n   also may provide information\
    \ to assist in verifying the revocation\n   status of the peer, e.g., a pointer\
    \ to a CRL repository or the name\n   of an Online Certificate Status Protocol\
    \ (OCSP) server associated\n   with the peer or with the trust anchor associated\
    \ with the peer.\n   Each entry also specifies whether the IKE ID payload will\
    \ be used as\n   a symbolic name for SPD lookup, or whether the remote IP address\n\
    \   provided in traffic selector payloads will be used for SPD lookups\n   when\
    \ child SAs are created.\n   Note that the PAD information MAY be used to support\
    \ creation of more\n   than one tunnel mode SA at a time between two peers, e.g.,\
    \ two\n   tunnels to protect the same addresses/hosts, but with different\n  \
    \ tunnel endpoints.\n"
- title: 4.4.3.1.  PAD Entry IDs and Matching Rules
  contents:
  - "4.4.3.1.  PAD Entry IDs and Matching Rules\n   The PAD is an ordered database,\
    \ where the order is defined by an\n   administrator (or a user in the case of\
    \ a single-user end system).\n   Usually, the same administrator will be responsible\
    \ for both the PAD\n   and SPD, since the two databases must be coordinated. \
    \ The ordering\n   requirement for the PAD arises for the same reason as for the\
    \ SPD,\n   i.e., because use of \"star name\" entries allows for overlaps in the\n\
    \   set of IKE IDs that could match a specific entry.\n   Six types of IDs are\
    \ supported for entries in the PAD, consistent\n   with the symbolic name types\
    \ and IP addresses used to identify SPD\n   entries.  The ID for each entry acts\
    \ as the index for the PAD, i.e.,\n   it is the value used to select an entry.\
    \  All of these ID types can\n   be used to match IKE ID payload types.  The six\
    \ types are:\n           o DNS name (specific or partial)\n           o Distinguished\
    \ Name (complete or sub-tree constrained)\n           o RFC 822 email address\
    \ (complete or partially qualified)\n           o IPv4 address (range)\n     \
    \      o IPv6 address (range)\n           o Key ID (exact match only)\n   The\
    \ first three name types can accommodate sub-tree matching as well\n   as exact\
    \ matches.  A DNS name may be fully qualified and thus match\n   exactly one name,\
    \ e.g., foo.example.com.  Alternatively, the name may\n   encompass a group of\
    \ peers by being partially specified, e.g., the\n   string \".example.com\" could\
    \ be used to match any DNS name ending in\n   these two domain name components.\n\
    \   Similarly, a Distinguished Name may specify a complete Distinguished\n   Name\
    \ to match exactly one entry, e.g., CN = Stephen, O = BBN\n   Technologies, SP\
    \ = MA, C = US.  Alternatively, an entry may encompass\n   a group of peers by\
    \ specifying a sub-tree, e.g., an entry of the form\n   \"C = US, SP = MA\" might\
    \ be used to match all DNs that contain these\n   two attributes as the top two\
    \ Relative Distinguished Names (RDNs).\n   For an RFC 822 e-mail addresses, the\
    \ same options exist.  A complete\n   address such as foo@example.com matches\
    \ one entity, but a sub-tree\n   name such as \"@example.com\" could be used to\
    \ match all the entities\n   with names ending in those two domain names to the\
    \ right of the @.\n   The specific syntax used by an implementation to accommodate\
    \ sub-tree\n   matching for distinguished names, domain names or RFC 822 e-mail\n\
    \   addresses is a local matter.  But, at a minimum, sub-tree matching of\n  \
    \ the sort described above MUST be supported. (Substring matching\n   within a\
    \ DN, DNS name, or RFC 822 address MAY be supported, but is\n   not required.)\n\
    \   For IPv4 and IPv6 addresses, the same address range syntax used for\n   SPD\
    \ entries MUST be supported.  This allows specification of an\n   individual address\
    \ (via a trivial range), an address prefix (by\n   choosing a range that adheres\
    \ to Classless Inter-Domain Routing\n   (CIDR)-style prefixes), or an arbitrary\
    \ address range.\n   The Key ID field is defined as an OCTET string in IKE.  For\
    \ this name\n   type, only exact-match syntax MUST be supported (since there is\
    \ no\n   explicit structure for this ID type).  Additional matching functions\n\
    \   MAY be supported for this ID type.\n"
- title: 4.4.3.2.  IKE Peer Authentication Data
  contents:
  - "4.4.3.2.  IKE Peer Authentication Data\n   Once an entry is located based on\
    \ an ordered search of the PAD based\n   on ID field matching, it is necessary\
    \ to verify the asserted\n   identity, i.e., to authenticate the asserted ID.\
    \  For each PAD entry,\n   there is an indication of the type of authentication\
    \ to be performed.\n   This document requires support for two required authentication\
    \ data\n   types:\n        - X.509 certificate\n        - pre-shared secret\n\
    \   For authentication based on an X.509 certificate, the PAD entry\n   contains\
    \ a trust anchor via which the end entity (EE) certificate for\n   the peer must\
    \ be verifiable, either directly or via a certificate\n   path.  See RFC 3280\
    \ for the definition of a trust anchor.  An entry\n   used with certificate-based\
    \ authentication MAY include additional\n   data to facilitate certificate revocation\
    \ status, e.g., a list of\n   appropriate OCSP responders or CRL repositories,\
    \ and associated\n   authentication data.  For authentication based on a pre-shared\n\
    \   secret, the PAD contains the pre-shared secret to be used by IKE.\n   This\
    \ document does not require that the IKE ID asserted by a peer be\n   syntactically\
    \ related to a specific field in an end entity\n   certificate that is employed\
    \ to authenticate the identity of that\n   peer.  However, it often will be appropriate\
    \ to impose such a\n   requirement, e.g., when a single entry represents a set\
    \ of peers each\n   of whom may have a distinct SPD entry.  Thus, implementations\
    \ MUST\n   provide a means for an administrator to require a match between an\n\
    \   asserted IKE ID and the subject name or subject alt name in a\n   certificate.\
    \  The former is applicable to IKE IDs expressed as\n   distinguished names; the\
    \ latter is appropriate for DNS names, RFC 822\n   e-mail addresses, and IP addresses.\
    \  Since KEY ID is intended for\n   identifying a peer authenticated via a pre-shared\
    \ secret, there is no\n   requirement to match this ID type to a certificate field.\n\
    \   See IKEv1 [HarCar98] and IKEv2 [Kau05] for details of how IKE\n   performs\
    \ peer authentication using certificates or pre-shared\n   secrets.\n   This document\
    \ does not mandate support for any other authentication\n   methods, although\
    \ such methods MAY be employed.\n"
- title: 4.4.3.3.  Child SA Authorization Data
  contents:
  - "4.4.3.3.  Child SA Authorization Data\n   Once an IKE peer is authenticated,\
    \ child SAs may be created.  Each\n   PAD entry contains data to constrain the\
    \ set of IDs that can be\n   asserted by an IKE peer, for matching against the\
    \ SPD.  Each PAD\n   entry indicates whether the IKE ID is to be used as a symbolic\
    \ name\n   for SPD matching, or whether an IP address asserted in a traffic\n\
    \   selector payload is to be used.\n   If the entry indicates that the IKE ID\
    \ is to be used, then the PAD\n   entry ID field defines the authorized set of\
    \ IDs.  If the entry\n   indicates that child SAs traffic selectors are to be\
    \ used, then an\n   additional data element is required, in the form of IPv4 and/or\
    \ IPv6\n   address ranges. (A peer may be authorized for both address types, so\n\
    \   there MUST be provision for both a v4 and a v6 address range.)\n"
- title: 4.4.3.4.  How the PAD Is Used
  contents:
  - "4.4.3.4.  How the PAD Is Used\n   During the initial IKE exchange, the initiator\
    \ and responder each\n   assert their identity via the IKE ID payload and send\
    \ an AUTH payload\n   to verify the asserted identity.  One or more CERT payloads\
    \ may be\n   transmitted to facilitate the verification of each asserted identity.\n\
    \   When an IKE entity receives an IKE ID payload, it uses the asserted\n   ID\
    \ to locate an entry in the PAD, using the matching rules described\n   above.\
    \  The PAD entry specifies the authentication method to be\n   employed for the\
    \ identified peer.  This ensures that the right method\n   is used for each peer\
    \ and that different methods can be used for\n   different peers.  The entry also\
    \ specifies the authentication data\n   that will be used to verify the asserted\
    \ identity.  This data is\n   employed in conjunction with the specified method\
    \ to authenticate the\n   peer, before any CHILD SAs are created.\n   Child SAs\
    \ are created based on the exchange of traffic selector\n   payloads, either at\
    \ the end of the initial IKE exchange or in\n   subsequent CREATE_CHILD_SA exchanges.\
    \  The PAD entry for the (now\n   authenticated) IKE peer is used to constrain\
    \ creation of child SAs;\n   specifically, the PAD entry specifies how the SPD\
    \ is searched using a\n   traffic selector proposal from a peer.  There are two\
    \ choices: either\n   the IKE ID asserted by the peer is used to find an SPD entry\
    \ via its\n   symbolic name, or peer IP addresses asserted in traffic selector\n\
    \   payloads are used for SPD lookups based on the remote IP address\n   field\
    \ portion of an SPD entry.  It is necessary to impose these\n   constraints on\
    \ creation of child SAs to prevent an authenticated peer\n   from spoofing IDs\
    \ associated with other, legitimate peers.\n   Note that because the PAD is checked\
    \ before searching for an SPD\n   entry, this safeguard protects an initiator\
    \ against spoofing attacks.\n   For example, assume that IKE A receives an outbound\
    \ packet destined\n   for IP address X, a host served by a security gateway. \
    \ RFC 2401\n   [RFC2401] and this document do not specify how A determines the\n\
    \   address of the IKE peer serving X.  However, any peer contacted by A\n   as\
    \ the presumed representative for X must be registered in the PAD in\n   order\
    \ to allow the IKE exchange to be authenticated.  Moreover, when\n   the authenticated\
    \ peer asserts that it represents X in its traffic\n   selector exchange, the\
    \ PAD will be consulted to determine if the peer\n   in question is authorized\
    \ to represent X.  Thus, the PAD provides a\n   binding of address ranges (or\
    \ name sub-spaces) to peers, to counter\n   such attacks.\n"
- title: 4.5.  SA and Key Management
  contents:
  - "4.5.  SA and Key Management\n   All IPsec implementations MUST support both manual\
    \ and automated SA\n   and cryptographic key management.  The IPsec protocols,\
    \ AH and ESP,\n   are largely independent of the associated SA management techniques,\n\
    \   although the techniques involved do affect some of the security\n   services\
    \ offered by the protocols.  For example, the optional\n   anti-replay service\
    \ available for AH and ESP requires automated SA\n   management.  Moreover, the\
    \ granularity of key distribution employed\n   with IPsec determines the granularity\
    \ of authentication provided.  In\n   general, data origin authentication in AH\
    \ and ESP is limited by the\n   extent to which secrets used with the integrity\
    \ algorithm (or with a\n   key management protocol that creates such secrets)\
    \ are shared among\n   multiple possible sources.\n   The following text describes\
    \ the minimum requirements for both types\n   of SA management.\n"
- title: 4.5.1.  Manual Techniques
  contents:
  - "4.5.1.  Manual Techniques\n   The simplest form of management is manual management,\
    \ in which a\n   person manually configures each system with keying material and\
    \ SA\n   management data relevant to secure communication with other systems.\n\
    \   Manual techniques are practical in small, static environments but\n   they\
    \ do not scale well.  For example, a company could create a\n   virtual private\
    \ network (VPN) using IPsec in security gateways at\n   several sites.  If the\
    \ number of sites is small, and since all the\n   sites come under the purview\
    \ of a single administrative domain, this\n   might be a feasible context for\
    \ manual management techniques.  In\n   this case, the security gateway might\
    \ selectively protect traffic to\n   and from other sites within the organization\
    \ using a manually\n   configured key, while not protecting traffic for other\
    \ destinations.\n   It also might be appropriate when only selected communications\
    \ need\n   to be secured.  A similar argument might apply to use of IPsec\n  \
    \ entirely within an organization for a small number of hosts and/or\n   gateways.\
    \  Manual management techniques often employ statically\n   configured, symmetric\
    \ keys, though other options also exist.\n"
- title: 4.5.2.  Automated SA and Key Management
  contents:
  - "4.5.2.  Automated SA and Key Management\n   Widespread deployment and use of\
    \ IPsec requires an Internet-standard,\n   scalable, automated, SA management\
    \ protocol.  Such support is\n   required to facilitate use of the anti-replay\
    \ features of AH and ESP,\n   and to accommodate on-demand creation of SAs, e.g.,\
    \ for user- and\n   session-oriented keying.  (Note that the notion of \"rekeying\"\
    \ an SA\n   actually implies creation of a new SA with a new SPI, a process that\n\
    \   generally implies use of an automated SA/key management protocol.)\n   The\
    \ default automated key management protocol selected for use with\n   IPsec is\
    \ IKEv2 [Kau05].  This document assumes the availability of\n   certain functions\
    \ from the key management protocol that are not\n   supported by IKEv1.  Other\
    \ automated SA management protocols MAY be\n   employed.\n   When an automated\
    \ SA/key management protocol is employed, the output\n   from this protocol is\
    \ used to generate multiple keys for a single SA.\n   This also occurs because\
    \ distinct keys are used for each of the two\n   SAs created by IKE.  If both\
    \ integrity and confidentiality are\n   employed, then a minimum of four keys\
    \ are required.  Additionally,\n   some cryptographic algorithms may require multiple\
    \ keys, e.g., 3DES.\n   The Key Management System may provide a separate string\
    \ of bits for\n   each key or it may generate one string of bits from which all\
    \ keys\n   are extracted.  If a single string of bits is provided, care needs\
    \ to\n   be taken to ensure that the parts of the system that map the string\n\
    \   of bits to the required keys do so in the same fashion at both ends\n   of\
    \ the SA.  To ensure that the IPsec implementations at each end of\n   the SA\
    \ use the same bits for the same keys, and irrespective of which\n   part of the\
    \ system divides the string of bits into individual keys,\n   the encryption keys\
    \ MUST be taken from the first (left-most,\n   high-order) bits and the integrity\
    \ keys MUST be taken from the\n   remaining bits.  The number of bits for each\
    \ key is defined in the\n   relevant cryptographic algorithm specification RFC.\
    \  In the case of\n   multiple encryption keys or multiple integrity keys, the\n\
    \   specification for the cryptographic algorithm must specify the order\n   in\
    \ which they are to be selected from a single string of bits\n   provided to the\
    \ cryptographic algorithm.\n"
- title: 4.5.3.  Locating a Security Gateway
  contents:
  - "4.5.3.  Locating a Security Gateway\n   This section discusses issues relating\
    \ to how a host learns about the\n   existence of relevant security gateways and,\
    \ once a host has\n   contacted these security gateways, how it knows that these\
    \ are the\n   correct security gateways.  The details of where the required\n\
    \   information is stored is a local matter, but the Peer Authorization\n   Database\
    \ (PAD) described in Section 4.4 is the most likely candidate.\n   (Note: S* indicates\
    \ a system that is running IPsec, e.g., SH1 and SG2\n   below.)\n   Consider a\
    \ situation in which a remote host (SH1) is using the\n   Internet to gain access\
    \ to a server or other machine (H2) and there\n   is a security gateway (SG2),\
    \ e.g., a firewall, through which H1's\n   traffic must pass.  An example of this\
    \ situation would be a mobile\n   host crossing the Internet to his home organization's\
    \ firewall (SG2).\n   This situation raises several issues:\n   1. How does SH1\
    \ know/learn about the existence of the security\n      gateway SG2?\n   2. How\
    \ does it authenticate SG2, and once it has authenticated SG2,\n      how does\
    \ it confirm that SG2 has been authorized to represent H2?\n   3. How does SG2\
    \ authenticate SH1 and verify that SH1 is authorized to\n      contact H2?\n \
    \  4. How does SH1 know/learn about any additional gateways that provide\n   \
    \   alternate paths to H2?\n   To address these problems, an IPsec-supporting\
    \ host or security\n   gateway MUST have an administrative interface that allows\
    \ the\n   user/administrator to configure the address of one or more security\n\
    \   gateways for ranges of destination addresses that require its use.\n   This\
    \ includes the ability to configure information for locating and\n   authenticating\
    \ one or more security gateways and verifying the\n   authorization of these gateways\
    \ to represent the destination host.\n   (The authorization function is implied\
    \ in the PAD.) This document\n   does not address the issue of how to automate\
    \ the\n   discovery/verification of security gateways.\n"
- title: 4.6.  SAs and Multicast
  contents:
  - "4.6.  SAs and Multicast\n   The receiver-orientation of the SA implies that,\
    \ in the case of\n   unicast traffic, the destination system will select the SPI\
    \ value.\n   By having the destination select the SPI value, there is no potential\n\
    \   for manually configured SAs to conflict with automatically configured\n  \
    \ (e.g., via a key management protocol) SAs or for SAs from multiple\n   sources\
    \ to conflict with each other.  For multicast traffic, there\n   are multiple\
    \ destination systems associated with a single SA.  So\n   some system or person\
    \ will need to coordinate among all multicast\n   groups to select an SPI or SPIs\
    \ on behalf of each multicast group and\n   then communicate the group's IPsec\
    \ information to all of the\n   legitimate members of that multicast group via\
    \ mechanisms not defined\n   here.\n   Multiple senders to a multicast group SHOULD\
    \ use a single Security\n   Association (and hence SPI) for all traffic to that\
    \ group when a\n   symmetric key encryption or integrity algorithm is employed.\
    \  In such\n   circumstances, the receiver knows only that the message came from\
    \ a\n   system possessing the key for that multicast group.  In such\n   circumstances,\
    \ a receiver generally will not be able to authenticate\n   which system sent\
    \ the multicast traffic.  Specifications for other,\n   more general multicast\
    \ approaches are deferred to the IETF Multicast\n   Security Working Group.\n"
- title: 5.  IP Traffic Processing
  contents:
  - "5.  IP Traffic Processing\n   As mentioned in Section 4.4.1, \"The Security Policy\
    \ Database (SPD)\",\n   the SPD (or associated caches) MUST be consulted during\
    \ the\n   processing of all traffic that crosses the IPsec protection boundary,\n\
    \   including IPsec management traffic.  If no policy is found in the SPD\n  \
    \ that matches a packet (for either inbound or outbound traffic), the\n   packet\
    \ MUST be discarded.  To simplify processing, and to allow for\n   very fast SA\
    \ lookups (for SG/BITS/BITW), this document introduces the\n   notion of an SPD\
    \ cache for all outbound traffic (SPD-O plus SPD-S),\n   and a cache for inbound,\
    \ non-IPsec-protected traffic (SPD-I).  (As\n   mentioned earlier, the SAD acts\
    \ as a cache for checking the selectors\n   of inbound IPsec-protected traffic\
    \ arriving on SAs.) There is\n   nominally one cache per SPD.  For the purposes\
    \ of this specification,\n   it is assumed that each cached entry will map to\
    \ exactly one SA.\n   Note, however, exceptions arise when one uses multiple SAs\
    \ to carry\n   traffic of different priorities (e.g., as indicated by distinct\
    \ DSCP\n   values) but the same selectors.  Note also, that there are a couple\n\
    \   of situations in which the SAD can have entries for SAs that do not\n   have\
    \ corresponding entries in the SPD.  Since this document does not\n   mandate\
    \ that the SAD be selectively cleared when the SPD is changed,\n   SAD entries\
    \ can remain when the SPD entries that created them are\n   changed or deleted.\
    \  Also, if a manually keyed SA is created, there\n   could be an SAD entry for\
    \ this SA that does not correspond to any SPD\n   entry.\n   Since SPD entries\
    \ may overlap, one cannot safely cache these entries\n   in general.  Simple caching\
    \ might result in a match against a cache\n   entry, whereas an ordered search\
    \ of the SPD would have resulted in a\n   match against a different entry.  But,\
    \ if the SPD entries are first\n   decorrelated, then the resulting entries can\
    \ safely be cached.  Each\n   cached entry will indicate that matching traffic\
    \ should be bypassed\n   or discarded, appropriately. (Note: The original SPD\
    \ entry might\n   result in multiple SAs, e.g., because of PFP.) Unless otherwise\n\
    \   noted, all references below to the \"SPD\" or \"SPD cache\" or \"cache\"\n\
    \   are to a decorrelated SPD (SPD-I, SPD-O, SPD-S) or the SPD cache\n   containing\
    \ entries from the decorrelated SPD.\n   Note: In a host IPsec implementation\
    \ based on sockets, the SPD will\n   be consulted whenever a new socket is created\
    \ to determine what, if\n   any, IPsec processing will be applied to the traffic\
    \ that will flow\n   on that socket.  This provides an implicit caching mechanism,\
    \ and the\n   portions of the preceding discussion that address caching can be\n\
    \   ignored in such implementations.\n   Note: It is assumed that one starts with\
    \ a correlated SPD because\n   that is how users and administrators are accustomed\
    \ to managing these\n   sorts of access control lists or firewall filter rules.\
    \  Then the\n   decorrelation algorithm is applied to build a list of cache-able\
    \ SPD\n   entries.  The decorrelation is invisible at the management interface.\n\
    \   For inbound IPsec traffic, the SAD entry selected by the SPI serves\n   as\
    \ the cache for the selectors to be matched against arriving IPsec\n   packets,\
    \ after AH or ESP processing has been performed.\n"
- title: 5.1.  Outbound IP Traffic Processing (protected-to-unprotected)
  contents:
  - "5.1.  Outbound IP Traffic Processing (protected-to-unprotected)\n   First consider\
    \ the path for traffic entering the implementation via a\n   protected interface\
    \ and exiting via an unprotected interface.\n                          Unprotected\
    \ Interface\n                                   ^\n                          \
    \         |\n            (nested SAs)      +----------+\n           -------------------|Forwarding|<-----+\n\
    \           |                  +----------+      |\n           |             \
    \           ^           |\n           |                        | BYPASS    |\n\
    \           V                     +-----+        |\n       +-------+         \
    \        | SPD |     +--------+\n    ...| SPD-I |.................|Cache|.....|PROCESS\
    \ |...IPsec\n       |  (*)  |                 | (*) |---->|(AH/ESP)|   boundary\n\
    \       +-------+                 +-----+     +--------+\n           |       \
    \ +-------+     /  ^\n           |        |DISCARD| <--/   |\n           |   \
    \     +-------+        |\n           |                         |\n           |\
    \                 +-------------+\n           |---------------->|SPD Selection|\n\
    \                             +-------------+\n                              \
    \      ^\n                                    |     +------+\n               \
    \                     |  -->| ICMP |\n                                    | /\
    \   +------+\n                                    |/\n                       \
    \             |\n                                    |\n                     \
    \       Protected Interface\n         Figure 2.  Processing Model for Outbound\
    \ Traffic\n                    (*) = The SPD caches are shown here.  If there\n\
    \                          is a cache miss, then the SPD is checked.\n       \
    \                   There is no requirement that an\n                        \
    \  implementation buffer the packet if\n                          there is a cache\
    \ miss.\n   IPsec MUST perform the following steps when processing outbound\n\
    \   packets:\n   1.  When a packet arrives from the subscriber (protected) interface,\n\
    \       invoke the SPD selection function to obtain the SPD-ID needed to\n   \
    \    choose the appropriate SPD. (If the implementation uses only one\n      \
    \ SPD, this step is a no-op.)\n   2.  Match the packet headers against the cache\
    \ for the SPD specified\n       by the SPD-ID from step 1.  Note that this cache\
    \ contains entries\n       from SPD-O and SPD-S.\n   3a. If there is a match,\
    \ then process the packet as specified by the\n       matching cache entry, i.e.,\
    \ BYPASS, DISCARD, or PROTECT using AH\n       or ESP.  If IPsec processing is\
    \ applied, there is a link from the\n       SPD cache entry to the relevant SAD\
    \ entry (specifying the mode,\n       cryptographic algorithms, keys, SPI, PMTU,\
    \ etc.).  IPsec\n       processing is as previously defined, for tunnel or transport\n\
    \       modes and for AH or ESP, as specified in their respective RFCs\n     \
    \  [Ken05b, Ken05a].  Note that the SA PMTU value, plus the value of\n       the\
    \ stateful fragment checking flag (and the DF bit in the IP\n       header of\
    \ the outbound packet) determine whether the packet can\n       (must) be fragmented\
    \ prior to or after IPsec processing, or if it\n       must be discarded and an\
    \ ICMP PMTU message is sent.\n   3b. If no match is found in the cache, search\
    \ the SPD (SPD-S and\n       SPD-O parts) specified by SPD-ID.  If the SPD entry\
    \ calls for\n       BYPASS or DISCARD, create one or more new outbound SPD cache\n\
    \       entries and if BYPASS, create one or more new inbound SPD cache\n    \
    \   entries. (More than one cache entry may be created since a\n       decorrelated\
    \ SPD entry may be linked to other such entries that\n       were created as a\
    \ side effect of the decorrelation process.) If\n       the SPD entry calls for\
    \ PROTECT, i.e., creation of an SA, the key\n       management mechanism (e.g.,\
    \ IKEv2) is invoked to create the SA.\n       If SA creation succeeds, a new outbound\
    \ (SPD-S) cache entry is\n       created, along with outbound and inbound SAD\
    \ entries, otherwise\n       the packet is discarded. (A packet that triggers\
    \ an SPD lookup\n       MAY be discarded by the implementation, or it MAY be processed\n\
    \       against the newly created cache entry, if one is created.)  Since\n  \
    \     SAs are created in pairs, an SAD entry for the corresponding\n       inbound\
    \ SA also is created, and it contains the selector values\n       derived from\
    \ the SPD entry (and packet, if any PFP flags were\n       \"true\") used to create\
    \ the inbound SA, for use in checking\n       inbound traffic delivered via the\
    \ SA.\n   4.  The packet is passed to the outbound forwarding function\n     \
    \  (operating outside of the IPsec implementation), to select the\n       interface\
    \ to which the packet will be directed.  This function\n       may cause the packet\
    \ to be passed back across the IPsec boundary,\n       for additional IPsec processing,\
    \ e.g., in support of nested SAs.\n       If so, there MUST be an entry in SPD-I\
    \ database that permits\n       inbound bypassing of the packet, otherwise the\
    \ packet will be\n       discarded.  If necessary, i.e., if there is more than\
    \ one SPD-I,\n       the traffic being looped back MAY be tagged as coming from\
    \ this\n       internal interface.  This would allow the use of a different\n\
    \       SPD-I for \"real\" external traffic vs. looped traffic, if needed.\n \
    \  Note: With the exception of IPv4 and IPv6 transport mode, an SG,\n   BITS,\
    \ or BITW implementation MAY fragment packets before applying\n   IPsec. (This\
    \ applies only to IPv4.  For IPv6 packets, only the\n   originator is allowed\
    \ to fragment them.) The device SHOULD have a\n   configuration setting to disable\
    \ this.  The resulting fragments are\n   evaluated against the SPD in the normal\
    \ manner.  Thus, fragments not\n   containing port numbers (or ICMP message type\
    \ and code, or Mobility\n   Header type) will only match rules having port (or\
    \ ICMP message type\n   and code, or MH type) selectors of OPAQUE or ANY. (See\
    \ Section 7 for\n   more details.)\n   Note: With regard to determining and enforcing\
    \ the PMTU of an SA, the\n   IPsec system MUST follow the steps described in Section\
    \ 8.2.\n"
- title: 5.1.1.  Handling an Outbound Packet That Must Be Discarded
  contents:
  - "5.1.1.  Handling an Outbound Packet That Must Be Discarded\n   If an IPsec system\
    \ receives an outbound packet that it finds it must\n   discard, it SHOULD be\
    \ capable of generating and sending an ICMP\n   message to indicate to the sender\
    \ of the outbound packet that the\n   packet was discarded.  The type and code\
    \ of the ICMP message will\n   depend on the reason for discarding the packet,\
    \ as specified below.\n   The reason SHOULD be recorded in the audit log.  The\
    \ audit log entry\n   for this event SHOULD include the reason, current date/time,\
    \ and the\n   selector values from the packet.\n   a.  The selectors of the packet\
    \ matched an SPD entry requiring the\n       packet to be discarded.\n       \
    \    IPv4 Type = 3 (destination unreachable) Code = 13\n                (Communication\
    \ Administratively Prohibited)\n           IPv6 Type = 1 (destination unreachable)\
    \ Code = 1\n                (Communication with destination administratively\n\
    \                prohibited)\n   b1. The IPsec system successfully reached the\
    \ remote peer but was\n       unable to negotiate the SA required by the SPD entry\
    \ matching the\n       packet because, for example, the remote peer is administratively\n\
    \       prohibited from communicating with the initiator, the initiating\n   \
    \    peer was unable to authenticate itself to the remote peer, the\n       remote\
    \ peer was unable to authenticate itself to the initiating\n       peer, or the\
    \ SPD at the remote peer did not have a suitable\n       entry.\n           IPv4\
    \ Type = 3 (destination unreachable) Code = 13\n                (Communication\
    \ Administratively Prohibited)\n           IPv6 Type = 1 (destination unreachable)\
    \ Code = 1\n                (Communication with destination administratively\n\
    \                prohibited)\n   b2. The IPsec system was unable to set up the\
    \ SA required by the SPD\n       entry matching the packet because the IPsec peer\
    \ at the other end\n       of the exchange could not be contacted.\n         \
    \  IPv4 Type = 3 (destination unreachable) Code = 1 (host\n                unreachable)\n\
    \           IPv6 Type = 1 (destination unreachable) Code = 3 (address\n      \
    \          unreachable)\n   Note that an attacker behind a security gateway could\
    \ send packets\n   with a spoofed source address, W.X.Y.Z, to an IPsec entity\
    \ causing it\n   to send ICMP messages to W.X.Y.Z.  This creates an opportunity\
    \ for a\n   denial of service (DoS) attack among hosts behind a security gateway.\n\
    \   To address this, a security gateway SHOULD include a management\n   control\
    \ to allow an administrator to configure an IPsec\n   implementation to send or\
    \ not send the ICMP messages under these\n   circumstances, and if this facility\
    \ is selected, to rate limit the\n   transmission of such ICMP responses.\n"
- title: 5.1.2.  Header Construction for Tunnel Mode
  contents:
  - "5.1.2.  Header Construction for Tunnel Mode\n   This section describes the handling\
    \ of the inner and outer IP\n   headers, extension headers, and options for AH\
    \ and ESP tunnels, with\n   regard to outbound traffic processing.  This includes\
    \ how to\n   construct the encapsulating (outer) IP header, how to process fields\n\
    \   in the inner IP header, and what other actions should be taken for\n   outbound,\
    \ tunnel mode traffic.  The general processing described here\n   is modeled after\
    \ RFC 2003, \"IP Encapsulation within IP\" [Per96]:\n    o The outer IP header\
    \ Source Address and Destination Address\n      identify the \"endpoints\" of\
    \ the tunnel (the encapsulator and\n      decapsulator).  The inner IP header\
    \ Source Address and Destination\n      Addresses identify the original sender\
    \ and recipient of the\n      datagram (from the perspective of this tunnel),\
    \ respectively.\n      (See footnote 3 after the table in 5.1.2.1 for more details\
    \ on the\n      encapsulating source IP address.)\n    o The inner IP header is\
    \ not changed except as noted below for TTL\n      (or Hop Limit) and the DS/ECN\
    \ Fields.  The inner IP header\n      otherwise remains unchanged during its delivery\
    \ to the tunnel exit\n      point.\n    o No change to IP options or extension\
    \ headers in the inner header\n      occurs during delivery of the encapsulated\
    \ datagram through the\n      tunnel.\n   Note: IPsec tunnel mode is different\
    \ from IP-in-IP tunneling (RFC\n   2003 [Per96]) in several ways:\n    o IPsec\
    \ offers certain controls to a security administrator to\n      manage covert\
    \ channels (which would not normally be a concern for\n      tunneling) and to\
    \ ensure that the receiver examines the right\n      portions of the received\
    \ packet with respect to application of\n      access controls.  An IPsec implementation\
    \ MAY be configurable with\n      regard to how it processes the outer DS field\
    \ for tunnel mode for\n      transmitted packets.  For outbound traffic, one configuration\n\
    \      setting for the outer DS field will operate as described in the\n     \
    \ following sections on IPv4 and IPv6 header processing for IPsec\n      tunnels.\
    \  Another will allow the outer DS field to be mapped to a\n      fixed value,\
    \ which MAY be configured on a per-SA basis. (The value\n      might really be\
    \ fixed for all traffic outbound from a device, but\n      per-SA granularity\
    \ allows that as well.) This configuration option\n      allows a local administrator\
    \ to decide whether the covert channel\n      provided by copying these bits outweighs\
    \ the benefits of copying.\n    o IPsec describes how to handle ECN or DS and\
    \ provides the ability\n      to control propagation of changes in these fields\
    \ between\n      unprotected and protected domains.  In general, propagation from\
    \ a\n      protected to an unprotected domain is a covert channel and thus\n \
    \     controls are provided to manage the bandwidth of this channel.\n      Propagation\
    \ of ECN values in the other direction are controlled so\n      that only legitimate\
    \ ECN changes (indicating occurrence of\n      congestion between the tunnel endpoints)\
    \ are propagated.  By\n      default, DS propagation from an unprotected domain\
    \ to a protected\n      domain is not permitted.  However, if the sender and receiver\
    \ do\n      not share the same DS code space, and the receiver has no way of\n\
    \      learning how to map between the two spaces, then it may be\n      appropriate\
    \ to deviate from the default.  Specifically, an IPsec\n      implementation MAY\
    \ be configurable in terms of how it processes\n      the outer DS field for tunnel\
    \ mode for received packets.  It may\n      be configured to either discard the\
    \ outer DS value (the default)\n      OR to overwrite the inner DS field with\
    \ the outer DS field.  If\n      offered, the discard vs. overwrite behavior MAY\
    \ be configured on a\n      per-SA basis.  This configuration option allows a\
    \ local\n      administrator to decide whether the vulnerabilities created by\n\
    \      copying these bits outweigh the benefits of copying.  See\n      [RFC2983]\
    \ for further information on when each of these behaviors\n      may be useful,\
    \ and also for the possible need for diffserv traffic\n      conditioning prior\
    \ or subsequent to IPsec processing (including\n      tunnel decapsulation).\n\
    \    o IPsec allows the IP version of the encapsulating header to be\n      different\
    \ from that of the inner header.\n   The tables in the following sub-sections\
    \ show the handling for the\n   different header/option fields (\"constructed\"\
    \ means that the value in\n   the outer field is constructed independently of\
    \ the value in the\n   inner).\n"
- title: '5.1.2.1.  IPv4: Header Construction for Tunnel Mode'
  contents:
  - "5.1.2.1.  IPv4: Header Construction for Tunnel Mode\n                       \
    \  <-- How Outer Hdr Relates to Inner Hdr -->\n                         Outer\
    \ Hdr at                 Inner Hdr at\n    IPv4                 Encapsulator \
    \                Decapsulator\n      Header fields:     -------------------- \
    \        ------------\n        version          4 (1)                        no\
    \ change\n        header length    constructed                  no change\n  \
    \      DS Field         copied from inner hdr (5)    no change\n        ECN Field\
    \        copied from inner hdr        constructed (6)\n        total length  \
    \   constructed                  no change\n        ID               constructed\
    \                  no change\n        flags (DF,MF)    constructed, DF (4)   \
    \       no change\n        fragment offset  constructed                  no change\n\
    \        TTL              constructed (2)              decrement (2)\n       \
    \ protocol         AH, ESP                      no change\n        checksum  \
    \       constructed                  constructed (2)(6)\n        src address \
    \     constructed (3)              no change\n        dest address     constructed\
    \ (3)              no change\n      Options            never copied          \
    \       no change\n    Notes:\n      (1) The IP version in the encapsulating header\
    \ can be different\n          from the value in the inner header.\n      (2) The\
    \ TTL in the inner header is decremented by the encapsulator\n          prior\
    \ to forwarding and by the decapsulator if it forwards the\n          packet.\
    \  (The IPv4 checksum changes when the TTL changes.)\n          Note: Decrementing\
    \ the TTL value is a normal part of\n          forwarding a packet.  Thus, a packet\
    \ originating from the same\n          node as the encapsulator does not have\
    \ its TTL decremented,\n          since the sending node is originating the packet\
    \ rather than\n          forwarding it.  This applies to BITS and native IPsec\n\
    \          implementations in hosts and routers.  However, the IPsec\n       \
    \   processing model includes an external forwarding capability.\n          TTL\
    \ processing can be used to prevent looping of packets,\n          e.g., due to\
    \ configuration errors, within the context of this\n          processing model.\n\
    \      (3) Local and Remote addresses depend on the SA, which is used to\n   \
    \       determine the Remote address, which in turn determines which\n       \
    \   Local address (net interface) is used to forward the packet.\n          Note:\
    \ For multicast traffic, the destination address, or\n          source and destination\
    \ addresses, may be required for\n          demuxing.  In that case, it is important\
    \ to ensure consistency\n          over the lifetime of the SA by ensuring that\
    \ the source\n          address that appears in the encapsulating tunnel header\
    \ is the\n          same as the one that was negotiated during the SA\n      \
    \    establishment process.  There is an exception to this general\n         \
    \ rule, i.e., a mobile IPsec implementation will update its\n          source\
    \ address as it moves.\n      (4) Configuration determines whether to copy from\
    \ the inner header\n          (IPv4 only), clear, or set the DF.\n      (5) If\
    \ the packet will immediately enter a domain for which the\n          DSCP value\
    \ in the outer header is not appropriate, that value\n          MUST be mapped\
    \ to an appropriate value for the domain\n          [NiBlBaBL98].  See RFC 2475\
    \ [BBCDWW98] for further\n          information.\n      (6) If the ECN field in\
    \ the inner header is set to ECT(0) or\n          ECT(1), where ECT is ECN-Capable\
    \ Transport (ECT), and if the\n          ECN field in the outer header is set\
    \ to Congestion Experienced\n          (CE), then set the ECN field in the inner\
    \ header to CE;\n          otherwise, make no change to the ECN field in the inner\n\
    \          header.  (The IPv4 checksum changes when the ECN changes.)\n   Note:\
    \ IPsec does not copy the options from the inner header into the\n   outer header,\
    \ nor does IPsec construct the options in the outer\n   header.  However, post-IPsec\
    \ code MAY insert/construct options for\n   the outer header.\n"
- title: '5.1.2.2.  IPv6: Header Construction for Tunnel Mode'
  contents:
  - "5.1.2.2.  IPv6: Header Construction for Tunnel Mode\n                       \
    \  <-- How Outer Hdr  Relates Inner Hdr --->\n                         Outer Hdr\
    \ at                 Inner Hdr at\n    IPv6                 Encapsulator     \
    \            Decapsulator\n      Header fields:     --------------------     \
    \    ------------\n        version          6 (1)                        no change\n\
    \        DS Field         copied from inner hdr (5)    no change (9)\n       \
    \ ECN Field        copied from inner hdr        constructed (6)\n        flow\
    \ label       copied or configured (8)     no change\n        payload length \
    \  constructed                  no change\n        next header      AH,ESP,routing\
    \ hdr           no change\n        hop limit        constructed (2)          \
    \    decrement (2)\n        src address      constructed (3)              no change\n\
    \        dest address     constructed (3)              no change\n      Extension\
    \ headers  never copied (7)             no change\n    Notes:\n      (1) - (6)\
    \ See Section 5.1.2.1.\n      (7) IPsec does not copy the extension headers from\
    \ the inner\n          packet into outer headers, nor does IPsec construct extension\n\
    \          headers in the outer header.  However, post-IPsec code MAY\n      \
    \    insert/construct extension headers for the outer header.\n      (8) See [RaCoCaDe04].\
    \  Copying is acceptable only for end systems,\n          not SGs.  If an SG copied\
    \ flow labels from the inner header to\n          the outer header, collisions\
    \ might result.\n      (9) An implementation MAY choose to provide a facility\
    \ to pass the\n          DS value from the outer header to the inner header, on\
    \ a per-\n          SA basis, for received tunnel mode packets.  The motivation\n\
    \          for providing this feature is to accommodate situations in\n      \
    \    which the DS code space at the receiver is different from that\n        \
    \  of the sender and the receiver has no way of knowing how to\n          translate\
    \ from the sender's space.  There is a danger in\n          copying this value\
    \ from the outer header to the inner header,\n          since it enables an attacker\
    \ to modify the outer DSCP value in\n          a fashion that may adversely affect\
    \ other traffic at the\n          receiver.  Hence the default behavior for IPsec\n\
    \          implementations is NOT to permit such copying.\n"
- title: 5.2.  Processing Inbound IP Traffic (unprotected-to-protected)
  contents:
  - "5.2.  Processing Inbound IP Traffic (unprotected-to-protected)\n   Inbound processing\
    \ is somewhat different from outbound processing,\n   because of the use of SPIs\
    \ to map IPsec-protected traffic to SAs.\n   The inbound SPD cache (SPD-I) is\
    \ applied only to bypassed or\n   discarded traffic.  If an arriving packet appears\
    \ to be an IPsec\n   fragment from an unprotected interface, reassembly is performed\
    \ prior\n   to IPsec processing.  The intent for any SPD cache is that a packet\n\
    \   that fails to match any entry is then referred to the corresponding\n   SPD.\
    \  Every SPD SHOULD have a nominal, final entry that catches\n   anything that\
    \ is otherwise unmatched, and discards it.  This ensures\n   that non-IPsec-protected\
    \ traffic that arrives and does not match any\n   SPD-I entry will be discarded.\n\
    \                      Unprotected Interface\n                               \
    \ |\n                                V\n                             +-----+ \
    \  IPsec protected\n         ------------------->|Demux|-------------------+\n\
    \         |                   +-----+                   |\n         |        \
    \              |                      |\n         |            Not IPsec |   \
    \                   |\n         |                      |                     \
    \ |\n         |                      V                      |\n         |    \
    \ +-------+    +---------+                |\n         |     |DISCARD|<---|SPD-I\
    \ (*)|                |\n         |     +-------+    +---------+             \
    \   |\n         |                   |                         |\n         |  \
    \                 |-----+                   |\n         |                   |\
    \     |                   |\n         |                   |     V            \
    \       |\n         |                   |  +------+               |\n        \
    \ |                   |  | ICMP |               |\n         |                \
    \   |  +------+               |\n         |                   |              \
    \           V\n      +---------+            |                   +-----------+\n\
    \  ....|SPD-O (*)|............|...................|PROCESS(**)|...IPsec\n    \
    \  +---------+            |                   | (AH/ESP)  | Boundary\n       \
    \  ^                   |                   +-----------+\n         |         \
    \          |       +---+             |\n         |            BYPASS |   +-->|IKE|\
    \             |\n         |                   |   |   +---+             |\n  \
    \       |                   V   |                     V\n         |          \
    \     +----------+          +---------+   +----+\n         |--------<------|Forwarding|<---------|SAD\
    \ Check|-->|ICMP|\n           nested SAs    +----------+          | (***)   |\
    \   +----+\n                               |               +---------+\n     \
    \                          V\n                       Protected Interface\n   \
    \         Figure 3.  Processing Model for Inbound Traffic\n                  \
    \     (*) = The caches are shown here.  If there is\n                        \
    \     a cache miss, then the SPD is checked.\n                             There\
    \ is no requirement that an\n                             implementation buffer\
    \ the packet if\n                             there is a cache miss.\n       \
    \               (**) = This processing includes using the\n                  \
    \           packet's SPI, etc., to look up the SA\n                          \
    \   in the SAD, which forms a cache of the\n                             SPD for\
    \ inbound packets (except for\n                             cases noted in Sections\
    \ 4.4.2 and 5).\n                             See step 3a below.\n           \
    \          (***) = This SAD check refers to step 4 below.\n   Prior to performing\
    \ AH or ESP processing, any IP fragments that\n   arrive via the unprotected interface\
    \ are reassembled (by IP).  Each\n   inbound IP datagram to which IPsec processing\
    \ will be applied is\n   identified by the appearance of the AH or ESP values\
    \ in the IP Next\n   Protocol field (or of AH or ESP as a next layer protocol\
    \ in the IPv6\n   context).\n   IPsec MUST perform the following steps:\n   1.\
    \  When a packet arrives, it may be tagged with the ID of the\n       interface\
    \ (physical or virtual) via which it arrived, if\n       necessary, to support\
    \ multiple SPDs and associated SPD-I caches.\n       (The interface ID is mapped\
    \ to a corresponding SPD-ID.)\n   2.  The packet is examined and demuxed into\
    \ one of two categories:\n       - If the packet appears to be IPsec protected\
    \ and it is addressed\n         to this device, an attempt is made to map it to\
    \ an active SA\n         via the SAD.  Note that the device may have multiple\
    \ IP\n         addresses that may be used in the SAD lookup, e.g., in the case\n\
    \         of protocols such as SCTP.\n       - Traffic not addressed to this device,\
    \ or addressed to this\n         device and not AH or ESP, is directed to SPD-I\
    \ lookup. (This\n         implies that IKE traffic MUST have an explicit BYPASS\
    \ entry in\n         the SPD.) If multiple SPDs are employed, the tag assigned\
    \ to\n         the packet in step 1 is used to select the appropriate SPD-I\n\
    \         (and cache) to search.  SPD-I lookup determines whether the\n      \
    \   action is DISCARD or BYPASS.\n   3a. If the packet is addressed to the IPsec\
    \ device and AH or ESP is\n       specified as the protocol, the packet is looked\
    \ up in the SAD.\n       For unicast traffic, use only the SPI (or SPI plus protocol).\n\
    \       For multicast traffic, use the SPI plus the destination or SPI\n     \
    \  plus destination and source addresses, as specified in Section\n       4.1.\
    \ In either case (unicast or multicast), if there is no match,\n       discard\
    \ the traffic.  This is an auditable event.  The audit log\n       entry for this\
    \ event SHOULD include the current date/time, SPI,\n       source and destination\
    \ of the packet, IPsec protocol, and any\n       other selector values of the\
    \ packet that are available.  If the\n       packet is found in the SAD, process\
    \ it accordingly (see step 4).\n   3b. If the packet is not addressed to the device\
    \ or is addressed to\n       this device and is not AH or ESP, look up the packet\
    \ header in\n       the (appropriate) SPD-I cache.  If there is a match and the\n\
    \       packet is to be discarded or bypassed, do so.  If there is no\n      \
    \ cache match, look up the packet in the corresponding SPD-I and\n       create\
    \ a cache entry as appropriate. (No SAs are created in\n       response to receipt\
    \ of a packet that requires IPsec protection;\n       only BYPASS or DISCARD cache\
    \ entries can be created this way.) If\n       there is no match, discard the\
    \ traffic.  This is an auditable\n       event.  The audit log entry for this\
    \ event SHOULD include the\n       current date/time, SPI if available, IPsec\
    \ protocol if available,\n       source and destination of the packet, and any\
    \ other selector\n       values of the packet that are available.\n   3c. Processing\
    \ of ICMP messages is assumed to take place on the\n       unprotected side of\
    \ the IPsec boundary.  Unprotected ICMP\n       messages are examined and local\
    \ policy is applied to determine\n       whether to accept or reject these messages\
    \ and, if accepted, what\n       action to take as a result.  For example, if\
    \ an ICMP unreachable\n       message is received, the implementation must decide\
    \ whether to\n       act on it, reject it, or act on it with constraints. (See\
    \ Section\n       6.)\n   4.  Apply AH or ESP processing as specified, using the\
    \ SAD entry\n       selected in step 3a above.  Then match the packet against\
    \ the\n       inbound selectors identified by the SAD entry to verify that the\n\
    \       received packet is appropriate for the SA via which it was\n       received.\n\
    \   5.  If an IPsec system receives an inbound packet on an SA and the\n     \
    \  packet's header fields are not consistent with the selectors for\n       the\
    \ SA, it MUST discard the packet.  This is an auditable event.\n       The audit\
    \ log entry for this event SHOULD include the current\n       date/time, SPI,\
    \ IPsec protocol(s), source and destination of the\n       packet, any other selector\
    \ values of the packet that are\n       available, and the selector values from\
    \ the relevant SAD entry.\n       The system SHOULD also be capable of generating\
    \ and sending an\n       IKE notification of INVALID_SELECTORS to the sender (IPsec\
    \ peer),\n       indicating that the received packet was discarded because of\n\
    \       failure to pass selector checks.\n   To minimize the impact of a DoS attack,\
    \ or a mis-configured peer, the\n   IPsec system SHOULD include a management control\
    \ to allow an\n   administrator to configure the IPsec implementation to send\
    \ or not\n   send this IKE notification, and if this facility is selected, to\
    \ rate\n   limit the transmission of such notifications.\n   After traffic is\
    \ bypassed or processed through IPsec, it is handed to\n   the inbound forwarding\
    \ function for disposition.  This function may\n   cause the packet to be sent\
    \ (outbound) across the IPsec boundary for\n   additional inbound IPsec processing,\
    \ e.g., in support of nested SAs.\n   If so, then as with ALL outbound traffic\
    \ that is to be bypassed, the\n   packet MUST be matched against an SPD-O entry.\
    \  Ultimately, the\n   packet should be forwarded to the destination host or process\
    \ for\n   disposition.\n"
- title: 6.  ICMP Processing
  contents:
  - "6.  ICMP Processing\n   This section describes IPsec handling of ICMP traffic.\
    \  There are two\n   categories of ICMP traffic: error messages (e.g., type =\
    \ destination\n   unreachable) and non-error messages (e.g., type = echo).  This\n\
    \   section applies exclusively to error messages.  Disposition of\n   non-error,\
    \ ICMP messages (that are not addressed to the IPsec\n   implementation itself)\
    \ MUST be explicitly accounted for using SPD\n   entries.\n   The discussion in\
    \ this section applies to ICMPv6 as well as to\n   ICMPv4.  Also, a mechanism\
    \ SHOULD be provided to allow an\n   administrator to cause ICMP error messages\
    \ (selected, all, or none)\n   to be logged as an aid to problem diagnosis.\n"
- title: 6.1.  Processing ICMP Error Messages Directed to an IPsec Implementation
  contents:
  - '6.1.  Processing ICMP Error Messages Directed to an IPsec Implementation

    '
- title: 6.1.1.  ICMP Error Messages Received on the Unprotected Side of the
  contents:
  - "6.1.1.  ICMP Error Messages Received on the Unprotected Side of the\n       \
    \ Boundary\n   Figure 3 in Section 5.2 shows a distinct ICMP processing module\
    \ on\n   the unprotected side of the IPsec boundary, for processing ICMP\n   messages\
    \ (error or otherwise) that are addressed to the IPsec device\n   and that are\
    \ not protected via AH or ESP.  An ICMP message of this\n   sort is unauthenticated,\
    \ and its processing may result in denial or\n   degradation of service.  This\
    \ suggests that, in general, it would be\n   desirable to ignore such messages.\
    \  However, many ICMP messages will\n   be received by hosts or security gateways\
    \ from unauthenticated\n   sources, e.g., routers in the public Internet.  Ignoring\
    \ these ICMP\n   messages can degrade service, e.g., because of a failure to process\n\
    \   PMTU message and redirection messages.  Thus, there is also a\n   motivation\
    \ for accepting and acting upon unauthenticated ICMP\n   messages.\n   To accommodate\
    \ both ends of this spectrum, a compliant IPsec\n   implementation MUST permit\
    \ a local administrator to configure an\n   IPsec implementation to accept or\
    \ reject unauthenticated ICMP\n   traffic.  This control MUST be at the granularity\
    \ of ICMP type and\n   MAY be at the granularity of ICMP type and code.  Additionally,\
    \ an\n   implementation SHOULD incorporate mechanisms and parameters for\n   dealing\
    \ with such traffic.  For example, there could be the ability\n   to establish\
    \ a minimum PMTU for traffic (on a per destination basis),\n   to prevent receipt\
    \ of an unauthenticated ICMP from setting the PMTU\n   to a trivial size.\n  \
    \ If an ICMP PMTU message passes the checks above and the system is\n   configured\
    \ to accept it, then there are two possibilities.  If the\n   implementation applies\
    \ fragmentation on the ciphertext side of the\n   boundary, then the accepted\
    \ PMTU information is passed to the\n   forwarding module (outside of the IPsec\
    \ implementation), which uses\n   it to manage outbound packet fragmentation.\
    \  If the implementation is\n   configured to effect plaintext side fragmentation,\
    \ then the PMTU\n   information is passed to the plaintext side and processed\
    \ as\n   described in Section 8.2.\n"
- title: 6.1.2.  ICMP Error Messages Received on the Protected Side of the
  contents:
  - "6.1.2.  ICMP Error Messages Received on the Protected Side of the\n        Boundary\n\
    \   These ICMP messages are not authenticated, but they do come from\n   sources\
    \ on the protected side of the IPsec boundary.  Thus, these\n   messages generally\
    \ are viewed as more \"trustworthy\" than their\n   counterparts arriving from\
    \ sources on the unprotected side of the\n   boundary.  The major security concern\
    \ here is that a compromised host\n   or router might emit erroneous ICMP error\
    \ messages that could degrade\n   service for other devices \"behind\" the security\
    \ gateway, or that\n   could even result in violations of confidentiality.  For\
    \ example, if\n   a bogus ICMP redirect were consumed by a security gateway, it\
    \ could\n   cause the forwarding table on the protected side of the boundary to\n\
    \   be modified so as to deliver traffic to an inappropriate destination\n   \"\
    behind\" the gateway.  Thus, implementers MUST provide controls to\n   allow local\
    \ administrators to constrain the processing of ICMP error\n   messages received\
    \ on the protected side of the boundary, and directed\n   to the IPsec implementation.\
    \  These controls are of the same type as\n   those employed on the unprotected\
    \ side, described above in Section\n   6.1.1.\n"
- title: 6.2.  Processing Protected, Transit ICMP Error Messages
  contents:
  - "6.2.  Processing Protected, Transit ICMP Error Messages\n   When an ICMP error\
    \ message is transmitted via an SA to a device\n   \"behind\" an IPsec implementation,\
    \ both the payload and the header of\n   the ICMP message require checking from\
    \ an access control perspective.\n   If one of these messages is forwarded to\
    \ a host behind a security\n   gateway, the receiving host IP implementation will\
    \ make decisions\n   based on the payload, i.e., the header of the packet that\
    \ purportedly\n   triggered the error response.  Thus, an IPsec implementation\
    \ MUST be\n   configurable to check that this payload header information is\n\
    \   consistent with the SA via which it arrives. (This means that the\n   payload\
    \ header, with source and destination address and port fields\n   reversed, matches\
    \ the traffic selectors for the SA.) If this sort of\n   check is not performed,\
    \ then, for example, anyone with whom the\n   receiving IPsec system (A) has an\
    \ active SA could send an ICMP\n   Destination Unreachable message that refers\
    \ to any host/net with\n   which A is currently communicating, and thus effect\
    \ a highly\n   efficient DoS attack regarding communication with other peers of\
    \ A.\n   Normal IPsec receiver processing of traffic is not sufficient to\n  \
    \ protect against such attacks.  However, not all contexts may require\n   such\
    \ checks, so it is also necessary to allow a local administrator\n   to configure\
    \ an implementation to NOT perform such checks.\n   To accommodate both policies,\
    \ the following convention is adopted.\n   If an administrator wants to allow\
    \ ICMP error messages to be carried\n   by an SA without inspection of the payload,\
    \ then configure an SPD\n   entry that explicitly allows for carriage of such\
    \ traffic.  If an\n   administrator wants IPsec to check the payload of ICMP error\
    \ messages\n   for consistency, then do not create any SPD entries that accommodate\n\
    \   carriage of such traffic based on the ICMP packet header.  This\n   convention\
    \ motivates the following processing description.\n   IPsec senders and receivers\
    \ MUST support the following processing for\n   ICMP error messages that are sent\
    \ and received via SAs.\n   If an SA exists that accommodates an outbound ICMP\
    \ error message,\n   then the message is mapped to the SA and only the IP and\
    \ ICMP headers\n   are checked upon receipt, just as would be the case for other\n\
    \   traffic.  If no SA exists that matches the traffic selectors\n   associated\
    \ with an ICMP error message, then the SPD is searched to\n   determine if such\
    \ an SA can be created.  If so, the SA is created and\n   the ICMP error message\
    \ is transmitted via that SA.  Upon receipt,\n   this message is subject to the\
    \ usual traffic selector checks at the\n   receiver.  This processing is exactly\
    \ what would happen for traffic\n   in general, and thus does not represent any\
    \ special processing for\n   ICMP error messages.\n   If no SA exists that would\
    \ carry the outbound ICMP message in\n   question, and if no SPD entry would allow\
    \ carriage of this outbound\n   ICMP error message, then an IPsec implementation\
    \ MUST map the message\n   to the SA that would carry the return traffic associated\
    \ with the\n   packet that triggered the ICMP error message.  This requires an\
    \ IPsec\n   implementation to detect outbound ICMP error messages that map to\
    \ no\n   extant SA or SPD entry, and treat them specially with regard to SA\n\
    \   creation and lookup.  The implementation extracts the header for the\n   packet\
    \ that triggered the error (from the ICMP message payload),\n   reverses the source\
    \ and destination IP address fields, extracts the\n   protocol field, and reverses\
    \ the port fields (if accessible).  It\n   then uses this extracted information\
    \ to locate an appropriate, active\n   outbound SA, and transmits the error message\
    \ via this SA.  If no such\n   SA exists, no SA will be created, and this is an\
    \ auditable event.\n   If an IPsec implementation receives an inbound ICMP error\
    \ message on\n   an SA, and the IP and ICMP headers of the message do not match\
    \ the\n   traffic selectors for the SA, the receiver MUST process the received\n\
    \   message in a special fashion.  Specifically, the receiver must\n   extract\
    \ the header of the triggering packet from the ICMP payload,\n   and reverse fields\
    \ as described above to determine if the packet is\n   consistent with the selectors\
    \ for the SA via which the ICMP error\n   message was received.  If the packet\
    \ fails this check, the IPsec\n   implementation MUST NOT forwarded the ICMP message\
    \ to the\n   destination.  This is an auditable event.\n"
- title: 7.  Handling Fragments (on the protected side of the IPsec boundary)
  contents:
  - "7.  Handling Fragments (on the protected side of the IPsec boundary)\n   Earlier\
    \ sections of this document describe mechanisms for (a)\n   fragmenting an outbound\
    \ packet after IPsec processing has been\n   applied and reassembling it at the\
    \ receiver before IPsec processing\n   and (b) handling inbound fragments received\
    \ from the unprotected side\n   of the IPsec boundary.  This section describes\
    \ how an implementation\n   should handle the processing of outbound plaintext\
    \ fragments on the\n   protected side of the IPsec boundary. (See Appendix D,\
    \ \"Fragment\n   Handling Rationale\".) In particular, it addresses:\n       \
    \ o mapping an outbound non-initial fragment to the right SA\n          (or finding\
    \ the right SPD entry)\n        o verifying that a received non-initial fragment\
    \ is\n          authorized for the SA via which it was received\n        o mapping\
    \ outbound and inbound non-initial fragments to the\n          right SPD-O/SPD-I\
    \ entry or the relevant cache entry, for\n          BYPASS/DISCARD traffic\n \
    \  Note: In Section 4.1, transport mode SAs have been defined to not\n   carry\
    \ fragments (IPv4 or IPv6).  Note also that in Section 4.4.1, two\n   special\
    \ values, ANY and OPAQUE, were defined for selectors and that\n   ANY includes\
    \ OPAQUE.  The term \"non-trivial\" is used to mean that the\n   selector has\
    \ a value other than OPAQUE or ANY.\n   Note: The term \"non-initial fragment\"\
    \ is used here to indicate a\n   fragment that does not contain all the selector\
    \ values that may be\n   needed for access control.  As observed in Section 4.4.1,\
    \ depending\n   on the Next Layer Protocol, in addition to Ports, the ICMP message\n\
    \   type/code or Mobility Header type could be missing from non-initial\n   fragments.\
    \  Also, for IPv6, even the first fragment might NOT contain\n   the Next Layer\
    \ Protocol or Ports (or ICMP message type/code, or\n   Mobility Header type) depending\
    \ on the kind and number of extension\n   headers present.  If a non-initial fragment\
    \ contains the Port (or\n   ICMP type and code or Mobility Header type) but not\
    \ the Next Layer\n   Protocol, then unless there is an SPD entry for the relevant\n\
    \   Local/Remote addresses with ANY for Next Layer Protocol and Port (or\n   ICMP\
    \ type and code or Mobility Header type), the fragment would not\n   contain all\
    \ the selector information needed for access control.\n   To address the above\
    \ issues, three approaches have been defined:\n       o Tunnel mode SAs that carry\
    \ initial and non-initial fragments\n         (See Section 7.1.)\n       o Separate\
    \ tunnel mode SAs for non-initial fragments (See\n         Section 7.2.)\n   \
    \    o Stateful fragment checking (See Section 7.3.)\n"
- title: 7.1.  Tunnel Mode SAs that Carry Initial and Non-Initial Fragments
  contents:
  - "7.1.  Tunnel Mode SAs that Carry Initial and Non-Initial Fragments\n   All implementations\
    \ MUST support tunnel mode SAs that are configured\n   to pass traffic without\
    \ regard to port field (or ICMP type/code or\n   Mobility Header type) values.\
    \  If the SA will carry traffic for\n   specified protocols, the selector set\
    \ for the SA MUST specify the\n   port fields (or ICMP type/code or Mobility Header\
    \ type) as ANY.  An\n   SA defined in this fashion will carry all traffic including\
    \ initial\n   and non-initial fragments for the indicated Local/Remote addresses\n\
    \   and specified Next Layer protocol(s).  If the SA will carry traffic\n   without\
    \ regard to a specific protocol value (i.e., ANY is specified\n   as the (Next\
    \ Layer) protocol selector value), then the port field\n   values are undefined\
    \ and MUST be set to ANY as well. (As noted in\n   4.4.1, ANY includes OPAQUE\
    \ as well as all specific values.)\n"
- title: 7.2.  Separate Tunnel Mode SAs for Non-Initial Fragments
  contents:
  - "7.2.  Separate Tunnel Mode SAs for Non-Initial Fragments\n   An implementation\
    \ MAY support tunnel mode SAs that will carry only\n   non-initial fragments,\
    \ separate from non-fragmented packets and\n   initial fragments.  The OPAQUE\
    \ value will be used to specify port (or\n   ICMP type/code or Mobility Header\
    \ type) field selectors for an SA to\n   carry such fragments.  Receivers MUST\
    \ perform a minimum offset check\n   on IPv4 (non-initial) fragments to protect\
    \ against overlapping\n   fragment attacks when SAs of this type are employed.\
    \  Because such\n   checks cannot be performed on IPv6 non-initial fragments,\
    \ users and\n   administrators are advised that carriage of such fragments may\
    \ be\n   dangerous, and implementers may choose to NOT support such SAs for\n\
    \   IPv6 traffic.  Also, an SA of this sort will carry all non-initial\n   fragments\
    \ that match a specified Local/Remote address pair and\n   protocol value, i.e.,\
    \ the fragments carried on this SA belong to\n   packets that if not fragmented,\
    \ might have gone on separate SAs of\n   differing security.  Therefore, users\
    \ and administrators are advised\n   to protect such traffic using ESP (with integrity)\
    \ and the\n   \"strongest\" integrity and encryption algorithms in use between\
    \ both\n   peers.  (Determination of the \"strongest\" algorithms requires\n \
    \  imposing an ordering of the available algorithms, a local\n   determination\
    \ at the discretion of the initiator of the SA.)\n   Specific port (or ICMP type/code\
    \ or Mobility Header type) selector\n   values will be used to define SAs to carry\
    \ initial fragments and\n   non-fragmented packets.  This approach can be used\
    \ if a user or\n   administrator wants to create one or more tunnel mode SAs between\
    \ the\n   same Local/Remote addresses that discriminate based on port (or ICMP\n\
    \   type/code or Mobility Header type) fields.  These SAs MUST have\n   non-trivial\
    \ protocol selector values, otherwise approach #1 above\n   MUST be used.\n  \
    \ Note: In general, for the approach described in this section, one\n   needs\
    \ only a single SA between two implementations to carry all\n   non-initial fragments.\
    \  However, if one chooses to have multiple SAs\n   between the two implementations\
    \ for QoS differentiation, then one\n   might also want multiple SAs to carry\
    \ fragments-without-ports, one\n   for each supported QoS class.  Since support\
    \ for QoS via distinct SAs\n   is a local matter, not mandated by this document,\
    \ the choice to have\n   multiple SAs to carry non-initial fragments should also\
    \ be local.\n"
- title: 7.3.  Stateful Fragment Checking
  contents:
  - "7.3.  Stateful Fragment Checking\n   An implementation MAY support some form\
    \ of stateful fragment checking\n   for a tunnel mode SA with non-trivial port\
    \ (or ICMP type/code or MH\n   type) field values (not ANY or OPAQUE).  Implementations\
    \ that will\n   transmit non-initial fragments on a tunnel mode SA that makes\
    \ use of\n   non-trivial port (or ICMP type/code or MH type) selectors MUST notify\n\
    \   a peer via the IKE NOTIFY NON_FIRST_FRAGMENTS_ALSO payload.\n   The peer MUST\
    \ reject this proposal if it will not accept non-initial\n   fragments in this\
    \ context.  If an implementation does not\n   successfully negotiate transmission\
    \ of non-initial fragments for such\n   an SA, it MUST NOT send such fragments\
    \ over the SA.  This standard\n   does not specify how peers will deal with such\
    \ fragments, e.g., via\n   reassembly or other means, at either sender or receiver.\
    \  However, a\n   receiver MUST discard non-initial fragments that arrive on an\
    \ SA with\n   non-trivial port (or ICMP type/code or MH type) selector values\n\
    \   unless this feature has been negotiated.  Also, the receiver MUST\n   discard\
    \ non-initial fragments that do not comply with the security\n   policy applied\
    \ to the overall packet.  Discarding such packets is an\n   auditable event. \
    \ Note that in network configurations where fragments\n   of a packet might be\
    \ sent or received via different security gateways\n   or BITW implementations,\
    \ stateful strategies for tracking fragments\n   may fail.\n"
- title: 7.4.  BYPASS/DISCARD Traffic
  contents:
  - "7.4.  BYPASS/DISCARD Traffic\n   All implementations MUST support DISCARDing\
    \ of fragments using the\n   normal SPD packet classification mechanisms.  All\
    \ implementations\n   MUST support stateful fragment checking to accommodate BYPASS\
    \ traffic\n   for which a non-trivial port range is specified.  The concern is\
    \ that\n   BYPASS of a cleartext, non-initial fragment arriving at an IPsec\n\
    \   implementation could undermine the security afforded IPsec-protected\n   traffic\
    \ directed to the same destination.  For example, consider an\n   IPsec implementation\
    \ configured with an SPD entry that calls for\n   IPsec protection of traffic\
    \ between a specific source/destination\n   address pair, and for a specific protocol\
    \ and destination port, e.g.,\n   TCP traffic on port 23 (Telnet).  Assume that\
    \ the implementation also\n   allows BYPASS of traffic from the same source/destination\
    \ address\n   pair and protocol, but for a different destination port, e.g., port\n\
    \   119 (NNTP).  An attacker could send a non-initial fragment (with a\n   forged\
    \ source address) that, if bypassed, could overlap with\n   IPsec-protected traffic\
    \ from the same source and thus violate the\n   integrity of the IPsec-protected\
    \ traffic.  Requiring stateful\n   fragment checking for BYPASS entries with non-trivial\
    \ port ranges\n   prevents attacks of this sort.  As noted above, in network\n\
    \   configurations where fragments of a packet might be sent or received\n   via\
    \ different security gateways or BITW implementations, stateful\n   strategies\
    \ for tracking fragments may fail.\n"
- title: 8.  Path MTU/DF Processing
  contents:
  - "8.  Path MTU/DF Processing\n   The application of AH or ESP to an outbound packet\
    \ increases the size\n   of a packet and thus may cause a packet to exceed the\
    \ PMTU for the SA\n   via which the packet will travel.  An IPsec implementation\
    \ also may\n   receive an unprotected ICMP PMTU message and, if it chooses to\
    \ act\n   upon the message, the result will affect outbound traffic processing.\n\
    \   This section describes the processing required of an IPsec\n   implementation\
    \ to deal with these two PMTU issues.\n"
- title: 8.1.  DF Bit
  contents:
  - "8.1.  DF Bit\n   All IPsec implementations MUST support the option of copying\
    \ the DF\n   bit from an outbound packet to the tunnel mode header that it emits,\n\
    \   when traffic is carried via a tunnel mode SA.  This means that it\n   MUST\
    \ be possible to configure the implementation's treatment of the\n   DF bit (set,\
    \ clear, copy from inner header) for each SA.  This\n   applies to SAs where both\
    \ inner and outer headers are IPv4.\n"
- title: 8.2.  Path MTU (PMTU) Discovery
  contents:
  - "8.2.  Path MTU (PMTU) Discovery\n   This section discusses IPsec handling for\
    \ unprotected Path MTU\n   Discovery messages.  ICMP PMTU is used here to refer\
    \ to an ICMP\n   message for:\n           IPv4 (RFC 792 [Pos81b]):\n         \
    \          - Type = 3 (Destination Unreachable)\n                   - Code = 4\
    \ (Fragmentation needed and DF set)\n                   - Next-Hop MTU in the\
    \ low-order 16 bits of the\n                     second word of the ICMP header\
    \ (labeled \"unused\"\n                     in RFC 792), with high-order 16 bits\
    \ set to zero)\n           IPv6 (RFC 2463 [CD98]):\n                   - Type\
    \ = 2 (Packet Too Big)\n                   - Code = 0 (Fragmentation needed)\n\
    \                   - Next-Hop MTU in the 32-bit MTU field of the ICMP6\n    \
    \                 message\n"
- title: 8.2.1.  Propagation of PMTU
  contents:
  - "8.2.1.  Propagation of PMTU\n   When an IPsec implementation receives an unauthenticated\
    \ PMTU\n   message, and it is configured to process (vs. ignore) such messages,\n\
    \   it maps the message to the SA to which it corresponds.  This mapping\n   is\
    \ effected by extracting the header information from the payload of\n   the PMTU\
    \ message and applying the procedure described in Section 5.2.\n   The PMTU determined\
    \ by this message is used to update the SAD PMTU\n   field, taking into account\
    \ the size of the AH or ESP header that will\n   be applied, any crypto synchronization\
    \ data, and the overhead imposed\n   by an additional IP header, in the case of\
    \ a tunnel mode SA.\n   In a native host implementation, it is possible to maintain\
    \ PMTU data\n   at the same granularity as for unprotected communication, so there\
    \ is\n   no loss of functionality.  Signaling of the PMTU information is\n   internal\
    \ to the host.  For all other IPsec implementation options,\n   the PMTU data\
    \ must be propagated via a synthesized ICMP PMTU.  In\n   these cases, the IPsec\
    \ implementation SHOULD wait for outbound\n   traffic to be mapped to the SAD\
    \ entry.  When such traffic arrives, if\n   the traffic would exceed the updated\
    \ PMTU value the traffic MUST be\n   handled as follows:\n       Case 1: Original\
    \ (cleartext) packet is IPv4 and has the DF\n               bit set.  The implementation\
    \ SHOULD discard the packet\n               and send a PMTU ICMP message.\n  \
    \     Case 2: Original (cleartext) packet is IPv4 and has the DF\n           \
    \    bit clear.  The implementation SHOULD fragment (before or\n             \
    \  after encryption per its configuration) and then forward\n               the\
    \ fragments.  It SHOULD NOT send a PMTU ICMP message.\n       Case 3: Original\
    \ (cleartext) packet is IPv6.  The implementation\n               SHOULD discard\
    \ the packet and send a PMTU ICMP message.\n"
- title: 8.2.2.  PMTU Aging
  contents:
  - "8.2.2.  PMTU Aging\n   In all IPsec implementations, the PMTU associated with\
    \ an SA MUST be\n   \"aged\" and some mechanism is required to update the PMTU\
    \ in a timely\n   manner, especially for discovering if the PMTU is smaller than\n\
    \   required by current network conditions.  A given PMTU has to remain\n   in\
    \ place long enough for a packet to get from the source of the SA to\n   the peer,\
    \ and to propagate an ICMP error message if the current PMTU\n   is too big.\n\
    \   Implementations SHOULD use the approach described in the Path MTU\n   Discovery\
    \ document (RFC 1191 [MD90], Section 6.3), which suggests\n   periodically resetting\
    \ the PMTU to the first-hop data-link MTU and\n   then letting the normal PMTU\
    \ Discovery processes update the PMTU as\n   necessary.  The period SHOULD be\
    \ configurable.\n"
- title: 9.  Auditing
  contents:
  - "9.  Auditing\n   IPsec implementations are not required to support auditing.\
    \  For the\n   most part, the granularity of auditing is a local matter.  However,\n\
    \   several auditable events are identified in this document, and for\n   each\
    \ of these events a minimum set of information that SHOULD be\n   included in\
    \ an audit log is defined.  Additional information also MAY\n   be included in\
    \ the audit log for each of these events, and additional\n   events, not explicitly\
    \ called out in this specification, also MAY\n   result in audit log entries.\
    \  There is no requirement for the\n   receiver to transmit any message to the\
    \ purported transmitter in\n   response to the detection of an auditable event,\
    \ because of the\n   potential to induce denial of service via such action.\n"
- title: 10.  Conformance Requirements
  contents:
  - "10.  Conformance Requirements\n   All IPv4 IPsec implementations MUST comply\
    \ with all requirements of\n   this document.  All IPv6 implementations MUST comply\
    \ with all\n   requirements of this document.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   The focus of this document is security; hence\
    \ security considerations\n   permeate this specification.\n   IPsec imposes stringent\
    \ constraints on bypass of IP header data in\n   both directions, across the IPsec\
    \ barrier, especially when tunnel\n   mode SAs are employed.  Some constraints\
    \ are absolute, while others\n   are subject to local administrative controls,\
    \ often on a per-SA\n   basis.  For outbound traffic, these constraints are designed\
    \ to limit\n   covert channel bandwidth.  For inbound traffic, the constraints\
    \ are\n   designed to prevent an adversary who has the ability to tamper with\n\
    \   one data stream (on the unprotected side of the IPsec barrier) from\n   adversely\
    \ affecting other data streams (on the protected side of the\n   barrier).  The\
    \ discussion in Section 5 dealing with processing DSCP\n   values for tunnel mode\
    \ SAs illustrates this concern.\n   If an IPsec implementation is configured to\
    \ pass ICMP error messages\n   over SAs based on the ICMP header values, without\
    \ checking the header\n   information from the ICMP message payload, serious vulnerabilities\n\
    \   may arise.  Consider a scenario in which several sites (A, B, and C)\n   are\
    \ connected to one another via ESP-protected tunnels: A-B, A-C, and\n   B-C. \
    \ Also assume that the traffic selectors for each tunnel specify\n   ANY for protocol\
    \ and port fields and IP source/destination address\n   ranges that encompass\
    \ the address range for the systems behind the\n   security gateways serving each\
    \ site.  This would allow a host at site\n   B to send an ICMP Destination Unreachable\
    \ message to any host at site\n   A, that declares all hosts on the net at site\
    \ C to be unreachable.\n   This is a very efficient DoS attack that could have\
    \ been prevented if\n   the ICMP error messages were subjected to the checks that\
    \ IPsec\n   provides, if the SPD is suitably configured, as described in Section\n\
    \   6.2.\n"
- title: 12.  IANA Considerations
  contents:
  - "12.  IANA Considerations\n   The IANA has assigned the value (3) for the asn1-modules\
    \ registry and\n   has assigned the object identifier 1.3.6.1.5.8.3.1 for the\
    \ SPD\n   module.  See Appendix C, \"ASN.1 for an SPD Entry\".\n"
- title: 13.  Differences from RFC 2401
  contents:
  - "13.  Differences from RFC 2401\n   This architecture document differs substantially\
    \ from RFC 2401\n   [RFC2401] in detail and in organization, but the fundamental\
    \ notions\n   are unchanged.\n   o The processing model has been revised to address\
    \ new IPsec\n     scenarios, improve performance, and simplify implementation.\
    \  This\n     includes a separation between forwarding (routing) and SPD\n   \
    \  selection, several SPD changes, and the addition of an outbound SPD\n     cache\
    \ and an inbound SPD cache for bypassed or discarded traffic.\n     There is also\
    \ a new database, the Peer Authorization Database\n     (PAD).  This provides\
    \ a link between an SA management protocol\n     (such as IKE) and the SPD.\n\
    \   o There is no longer a requirement to support nested SAs or \"SA\n     bundles\"\
    .  Instead this functionality can be achieved through SPD\n     and forwarding\
    \ table configuration.  An example of a configuration\n     has been added in\
    \ Appendix E.\n   o SPD entries were redefined to provide more flexibility.  Each\
    \ SPD\n     entry now consists of 1 to N sets of selectors, where each selector\n\
    \     set contains one protocol and a \"list of ranges\" can now be\n     specified\
    \ for the Local IP address, Remote IP address, and whatever\n     fields (if any)\
    \ are associated with the Next Layer Protocol (Local\n     Port, Remote Port,\
    \ ICMP message type and code, and Mobility Header\n     type).  An individual\
    \ value for a selector is represented via a\n     trivial range and ANY is represented\
    \ via a range than spans all\n     values for the selector.  An example of an\
    \ ASN.1 description is\n     included in Appendix C.\n   o TOS (IPv4) and Traffic\
    \ Class (IPv6) have been replaced by DSCP and\n     ECN.  The tunnel section has\
    \ been updated to explain how to handle\n     DSCP and ECN bits.\n   o For tunnel\
    \ mode SAs, an SG, BITS, or BITW implementation is now\n     allowed to fragment\
    \ packets before applying IPsec.  This applies\n     only to IPv4.  For IPv6 packets,\
    \ only the originator is allowed to\n     fragment them.\n   o When security is\
    \ desired between two intermediate systems along a\n     path or between an intermediate\
    \ system and an end system, transport\n     mode may now be used between security\
    \ gateways and between a\n     security gateway and a host.\n   o This document\
    \ clarifies that for all traffic that crosses the IPsec\n     boundary, including\
    \ IPsec management traffic, the SPD or associated\n     caches must be consulted.\n\
    \   o This document defines how to handle the situation of a security\n     gateway\
    \ with multiple subscribers requiring separate IPsec\n     contexts.\n   o A definition\
    \ of reserved SPIs has been added.\n   o Text has been added explaining why ALL\
    \ IP packets must be checked\n     -- IPsec includes minimal firewall functionality\
    \ to support access\n     control at the IP layer.\n   o The tunnel section has\
    \ been updated to clarify how to handle the IP\n     options field and IPv6 extension\
    \ headers when constructing the\n     outer header.\n   o SA mapping for inbound\
    \ traffic has been updated to be consistent\n     with the changes made in AH\
    \ and ESP for support of unicast and\n     multicast SAs.\n   o Guidance has been\
    \ added regarding how to handle the covert channel\n     created in tunnel mode\
    \ by copying the DSCP value to outer header.\n   o Support for AH in both IPv4\
    \ and IPv6 is no longer required.\n   o PMTU handling has been updated.  The appendix\
    \ on\n     PMTU/DF/Fragmentation has been deleted.\n   o Three approaches have\
    \ been added for handling plaintext fragments\n     on the protected side of the\
    \ IPsec boundary.  Appendix D documents\n     the rationale behind them.\n   o\
    \ Added revised text describing how to derive selector values for SAs\n     (from\
    \ the SPD entry or from the packet, etc.)\n   o Added a new table describing the\
    \ relationship between selector\n     values in an SPD entry, the PFP flag, and\
    \ resulting selector values\n     in the corresponding SAD entry.\n   o Added\
    \ Appendix B to describe decorrelation.\n   o Added text describing how to handle\
    \ an outbound packet that must be\n     discarded.\n   o Added text describing\
    \ how to handle a DISCARDED inbound packet,\n     i.e., one that does not match\
    \ the SA upon which it arrived.\n   o IPv6 mobility header has been added as a\
    \ possible Next Layer\n     Protocol.  IPv6 Mobility Header message type has been\
    \ added as a\n     selector.\n   o ICMP message type and code have been added\
    \ as selectors.\n   o The selector \"data sensitivity level\" has been removed\
    \ to simplify\n     things.\n   o Updated text describing handling ICMP error\
    \ messages.  The appendix\n     on \"Categorization of ICMP Messages\" has been\
    \ deleted.\n   o The text for the selector name has been updated and clarified.\n\
    \   o The \"Next Layer Protocol\" has been further explained and a default\n \
    \    list of protocols to skip when looking for the Next Layer Protocol\n    \
    \ has been added.\n   o The text has been amended to say that this document assumes\
    \ use of\n     IKEv2 or an SA management protocol with comparable features.\n\
    \   o Text has been added clarifying the algorithm for mapping inbound\n     IPsec\
    \ datagrams to SAs in the presence of multicast SAs.\n   o The appendix \"Sequence\
    \ Space Window Code Example\" has been removed.\n   o With respect to IP addresses\
    \ and ports, the terms \"Local\" and\n     \"Remote\" are used for policy rules\
    \ (replacing source and\n     destination).  \"Local\" refers to the entity being\
    \ protected by an\n     IPsec implementation, i.e., the \"source\" address/port\
    \ of outbound\n     packets or the \"destination\" address/port of inbound packets.\n\
    \     \"Remote\" refers to a peer entity or peer entities.  The terms\n     \"\
    source\" and \"destination\" are still used for packet header fields.\n"
- title: 14.  Acknowledgements
  contents:
  - "14.  Acknowledgements\n   The authors would like to acknowledge the contributions\
    \ of Ran\n   Atkinson, who played a critical role in initial IPsec activities,\
    \ and\n   who authored the first series of IPsec standards: RFCs 1825-1827; and\n\
    \   Charlie Lynn, who made significant contributions to the second series\n  \
    \ of IPsec standards (RFCs 2401, 2402, and 2406) and to the current\n   versions,\
    \ especially with regard to IPv6 issues.  The authors also\n   would like to thank\
    \ the members of the IPsec and MSEC working groups\n   who have contributed to\
    \ the development of this protocol\n   specification.\n"
- title: 'Appendix A: Glossary'
  contents:
  - "Appendix A: Glossary\n   This section provides definitions for several key terms\
    \ that are\n   employed in this document.  Other documents provide additional\n\
    \   definitions and background information relevant to this technology,\n   e.g.,\
    \ [Shi00], [VK83], and [HA94].  Included in this glossary are\n   generic security\
    \ service and security mechanism terms, plus\n   IPsec-specific terms.\n   Access\
    \ Control\n      A security service that prevents unauthorized use of a resource,\n\
    \      including the prevention of use of a resource in an unauthorized\n    \
    \  manner.  In the IPsec context, the resource to which access is\n      being\
    \ controlled is often:\n               o for a host, computing cycles or data\n\
    \               o for a security gateway, a network behind the gateway\n     \
    \            or bandwidth on that network.\n   Anti-replay\n      See \"Integrity\"\
    \ below.\n   Authentication\n      Used informally to refer to the combination\
    \ of two nominally\n      distinct security services, data origin authentication\
    \ and\n      connectionless integrity.  See the definitions below for each of\n\
    \      these services.\n   Availability\n      When viewed as a security service,\
    \ addresses the security concerns\n      engendered by attacks against networks\
    \ that deny or degrade\n      service.  For example, in the IPsec context, the\
    \ use of\n      anti-replay mechanisms in AH and ESP support availability.\n \
    \  Confidentiality\n      The security service that protects data from unauthorized\n\
    \      disclosure.  The primary confidentiality concern in most instances\n  \
    \    is unauthorized disclosure of application-level data, but\n      disclosure\
    \ of the external characteristics of communication also\n      can be a concern\
    \ in some circumstances.  Traffic flow\n      confidentiality is the service that\
    \ addresses this latter concern\n      by concealing source and destination addresses,\
    \ message length, or\n      frequency of communication.  In the IPsec context,\
    \ using ESP in\n      tunnel mode, especially at a security gateway, can provide\
    \ some\n      level of traffic flow confidentiality. (See also \"Traffic\n   \
    \   Analysis\" below.)\n   Data Origin Authentication\n      A security service\
    \ that verifies the identity of the claimed\n      source of data.  This service\
    \ is usually bundled with\n      connectionless integrity service.\n   Encryption\n\
    \      A security mechanism used to transform data from an intelligible\n    \
    \  form (plaintext) into an unintelligible form (ciphertext), to\n      provide\
    \ confidentiality.  The inverse transformation process is\n      designated \"\
    decryption\".  Often the term \"encryption\" is used to\n      generically refer\
    \ to both processes.\n   Integrity\n      A security service that ensures that\
    \ modifications to data are\n      detectable.  Integrity comes in various flavors\
    \ to match\n      application requirements.  IPsec supports two forms of integrity:\n\
    \      connectionless and a form of partial sequence integrity.\n      Connectionless\
    \ integrity is a service that detects modification of\n      an individual IP\
    \ datagram, without regard to the ordering of the\n      datagram in a stream\
    \ of traffic.  The form of partial sequence\n      integrity offered in IPsec\
    \ is referred to as anti-replay\n      integrity, and it detects arrival of duplicate\
    \ IP datagrams\n      (within a constrained window).  This is in contrast to\n\
    \      connection-oriented integrity, which imposes more stringent\n      sequencing\
    \ requirements on traffic, e.g., to be able to detect\n      lost or re-ordered\
    \ messages.  Although authentication and\n      integrity services often are cited\
    \ separately, in practice they\n      are intimately connected and almost always\
    \ offered in tandem.\n   Protected vs. Unprotected\n      \"Protected\" refers\
    \ to the systems or interfaces that are inside\n      the IPsec protection boundary,\
    \ and \"unprotected\" refers to the\n      systems or interfaces that are outside\
    \ the IPsec protection\n      boundary.  IPsec provides a boundary through which\
    \ traffic passes.\n      There is an asymmetry to this barrier, which is reflected\
    \ in the\n      processing model.  Outbound data, if not discarded or bypassed,\
    \ is\n      protected via the application of AH or ESP and the addition of the\n\
    \      corresponding headers.  Inbound data, if not discarded or\n      bypassed,\
    \ is processed via the removal of AH or ESP headers.  In\n      this document,\
    \ inbound traffic enters an IPsec implementation from\n      the \"unprotected\"\
    \ interface.  Outbound traffic enters the\n      implementation via the \"protected\"\
    \ interface, or is internally\n      generated by the implementation on the \"\
    protected\" side of the\n      boundary and directed toward the \"unprotected\"\
    \ interface.  An\n      IPsec implementation may support more than one interface\
    \ on either\n      or both sides of the boundary.  The protected interface may\
    \ be\n      internal, e.g., in a host implementation of IPsec.  The protected\n\
    \      interface may link to a socket layer interface presented by the\n     \
    \ OS.\n   Security Association (SA)\n      A simplex (uni-directional) logical\
    \ connection, created for\n      security purposes.  All traffic traversing an\
    \ SA is provided the\n      same security processing.  In IPsec, an SA is an Internet-layer\n\
    \      abstraction implemented through the use of AH or ESP.  State data\n   \
    \   associated with an SA is represented in the SA Database (SAD).\n   Security\
    \ Gateway\n      An intermediate system that acts as the communications interface\n\
    \      between two networks.  The set of hosts (and networks) on the\n      external\
    \ side of the security gateway is termed unprotected (they\n      are generally\
    \ at least less protected than those \"behind\" the SG),\n      while the networks\
    \ and hosts on the internal side are viewed as\n      protected.  The internal\
    \ subnets and hosts served by a security\n      gateway are presumed to be trusted\
    \ by virtue of sharing a common,\n      local, security administration.  In the\
    \ IPsec context, a security\n      gateway is a point at which AH and/or ESP is\
    \ implemented in order\n      to serve a set of internal hosts, providing security\
    \ services for\n      these hosts when they communicate with external hosts also\n\
    \      employing IPsec (either directly or via another security gateway).\n  \
    \ Security Parameters Index (SPI)\n      An arbitrary 32-bit value that is used\
    \ by a receiver to identify\n      the SA to which an incoming packet should be\
    \ bound.  For a unicast\n      SA, the SPI can be used by itself to specify an\
    \ SA, or it may be\n      used in conjunction with the IPsec protocol type.  Additional\
    \ IP\n      address information is used to identify multicast SAs.  The SPI is\n\
    \      carried in AH and ESP protocols to enable the receiving system to\n   \
    \   select the SA under which a received packet will be processed.  An\n     \
    \ SPI has only local significance, as defined by the creator of the\n      SA\
    \ (usually the receiver of the packet carrying the SPI); thus an\n      SPI is\
    \ generally viewed as an opaque bit string.  However, the\n      creator of an\
    \ SA may choose to interpret the bits in an SPI to\n      facilitate local processing.\n\
    \   Traffic Analysis\n      The analysis of network traffic flow for the purpose\
    \ of deducing\n      information that is useful to an adversary.  Examples of\
    \ such\n      information are frequency of transmission, the identities of the\n\
    \      conversing parties, sizes of packets, and flow identifiers\n      [Sch94].\n"
- title: 'Appendix B: Decorrelation'
  contents:
  - "Appendix B: Decorrelation\n   This appendix is based on work done for caching\
    \ of policies in the IP\n   Security Policy Working Group by Luis Sanchez, Matt\
    \ Condell, and John\n   Zao.\n   Two SPD entries are correlated if there is a\
    \ non-null intersection\n   between the values of corresponding selectors in each\
    \ entry.  Caching\n   correlated SPD entries can lead to incorrect policy enforcement.\
    \  A\n   solution to this problem, which still allows for caching, is to\n   remove\
    \ the ambiguities by decorrelating the entries.  That is, the\n   SPD entries\
    \ must be rewritten so that for every pair of entries there\n   exists a selector\
    \ for which there is a null intersection between the\n   values in both of the\
    \ entries.  Once the entries are decorrelated,\n   there is no longer any ordering\
    \ requirement on them, since only one\n   entry will match any lookup.  The next\
    \ section describes\n   decorrelation in more detail and presents an algorithm\
    \ that may be\n   used to implement decorrelation.\n"
- title: B.1.  Decorrelation Algorithm
  contents:
  - "B.1.  Decorrelation Algorithm\n   The basic decorrelation algorithm takes each\
    \ entry in a correlated\n   SPD and divides it into a set of entries using a tree\
    \ structure.\n   The nodes of the tree are the selectors that may overlap between\
    \ the\n   policies.  At each node, the algorithm creates a branch for each of\n\
    \   the values of the selector.  It also creates one branch for the\n   complement\
    \ of the union of all selector values.  Policies are then\n   formed by traversing\
    \ the tree from the root to each leaf.  The\n   policies at the leaves are compared\
    \ to the set of already\n   decorrelated policy rules.  Each policy at a leaf\
    \ is either\n   completely overridden by a policy in the already decorrelated\
    \ set and\n   is discarded or is decorrelated with all the policies in the\n \
    \  decorrelated set and is added to it.\n   The basic algorithm does not guarantee\
    \ an optimal set of decorrelated\n   entries.  That is, the entries may be broken\
    \ up into smaller sets\n   than is necessary, though they will still provide all\
    \ the necessary\n   policy information.  Some extensions to the basic algorithm\
    \ are\n   described later to improve this and improve the performance of the\n\
    \   algorithm.\n           C   A set of ordered, correlated entries (a correlated\
    \ SPD).\n           Ci  The ith entry in C.\n           U   The set of decorrelated\
    \ entries being built from C.\n           Ui  The ith entry in U.\n          \
    \ Sik The kth selection for policy Ci.\n           Ai  The action for policy Ci.\n\
    \   A policy (SPD entry) P may be expressed as a sequence of selector\n   values\
    \ and an action (BYPASS, DISCARD, or PROTECT):\n           Ci = Si1 x Si2 x ...\
    \ x Sik -> Ai\n   1) Put C1 in set U as U1\n   For each policy Cj (j > 1) in C\n\
    \   2) If Cj is decorrelated with every entry in U, then add it to U.\n   3) If\
    \ Cj is correlated with one or more entries in U, create a tree\n   rooted at\
    \ the policy Cj that partitions Cj into a set of decorrelated\n   entries.  The\
    \ algorithm starts with a root node where no selectors\n   have yet been chosen.\n\
    \     A) Choose a selector in Cj, Sjn, that has not yet been chosen when\n   \
    \     traversing the tree from the root to this node.  If there are no\n     \
    \   selectors not yet used, continue to the next unfinished branch\n        until\
    \ all branches have been completed.  When the tree is\n        completed, go to\
    \ step D.\n        T is the set of entries in U that are correlated with the entry\n\
    \        at this node.\n        The entry at this node is the entry formed by\
    \ the selector\n        values of each of the branches between the root and this\
    \ node.\n        Any selector values that are not yet represented by branches\n\
    \        assume the corresponding selector value in Cj, since the values\n   \
    \     in Cj represent the maximum value for each selector.\n     B) Add a branch\
    \ to the tree for each value of the selector Sjn that\n        appears in any\
    \ of the entries in T.  (If the value is a superset\n        of the value of Sjn\
    \ in Cj, then use the value in Cj, since that\n        value represents the universal\
    \ set.)  Also add a branch for the\n        complement of the union of all the\
    \ values of the selector Sjn\n        in T.  When taking the complement, remember\
    \ that the universal\n        set is the value of Sjn in Cj.  A branch need not\
    \ be created\n        for the null set.\n     C) Repeat A and B until the tree\
    \ is completed.\n     D) The entry to each leaf now represents an entry that is\
    \ a subset\n        of Cj.  The entries at the leaves completely partition Cj\
    \ in\n        such a way that each entry is either completely overridden by\n\
    \        an entry in U, or is decorrelated with the entries in U.\n        Add\
    \ all the decorrelated entries at the leaves of the tree to U.\n   4) Get next\
    \ Cj and go to 2.\n   5) When all entries in C have been processed, then U will\
    \ contain an\n   decorrelated version of C.\n   There are several optimizations\
    \ that can be made to this algorithm.\n   A few of them are presented here.\n\
    \   It is possible to optimize, or at least improve, the amount of\n   branching\
    \ that occurs by carefully choosing the order of the\n   selectors used for the\
    \ next branch.  For example, if a selector Sjn\n   can be chosen so that all the\
    \ values for that selector in T are equal\n   to or a superset of the value of\
    \ Sjn in Cj, then only a single branch\n   needs to be created (since the complement\
    \ will be null).\n   Branches of the tree do not have to proceed with the entire\n\
    \   decorrelation algorithm.  For example, if a node represents an entry\n   that\
    \ is decorrelated with all the entries in U, then there is no\n   reason to continue\
    \ decorrelating that branch.  Also, if a branch is\n   completely overridden by\
    \ an entry in U, then there is no reason to\n   continue decorrelating the branch.\n\
    \   An additional optimization is to check to see if a branch is\n   overridden\
    \ by one of the CORRELATED entries in set C that has already\n   been decorrelated.\
    \  That is, if the branch is part of decorrelating\n   Cj, then check to see if\
    \ it was overridden by an entry Cm, m < j.\n   This is a valid check, since all\
    \ the entries Cm are already expressed\n   in U.\n   Along with checking if an\
    \ entry is already decorrelated in step 2,\n   check if Cj is overridden by any\
    \ entry in U.  If it is, skip it since\n   it is not relevant.  An entry x is\
    \ overridden by another entry y if\n   every selector in x is equal to or a subset\
    \ of the corresponding\n   selector in entry y.\n"
- title: 'Appendix C: ASN.1 for an SPD Entry'
  contents:
  - "Appendix C: ASN.1 for an SPD Entry\n   This appendix is included as an additional\
    \ way to describe SPD\n   entries, as defined in Section 4.4.1.  It uses ASN.1\
    \ syntax that has\n   been successfully compiled.  This syntax is merely illustrative\
    \ and\n   need not be employed in an implementation to achieve compliance.  The\n\
    \   SPD description in Section 4.4.1 is normative.\n   SPDModule\n    {iso(1)\
    \ org (3) dod (6) internet (1) security (5) mechanisms (5)\n     ipsec (8) asn1-modules\
    \ (3) spd-module (1) }\n       DEFINITIONS IMPLICIT TAGS ::=\n       BEGIN\n \
    \      IMPORTS\n           RDNSequence FROM PKIX1Explicit88\n             { iso(1)\
    \ identified-organization(3)\n               dod(6) internet(1) security(5) mechanisms(5)\
    \ pkix(7)\n               id-mod(0) id-pkix1-explicit(18) } ;\n       -- An SPD\
    \ is a list of policies in decreasing order of preference\n       SPD ::= SEQUENCE\
    \ OF SPDEntry\n       SPDEntry ::= CHOICE {\n           iPsecEntry       IPsecEntry,\
    \               -- PROTECT traffic\n           bypassOrDiscard  [0] BypassOrDiscardEntry\
    \ } -- DISCARD/BYPASS\n       IPsecEntry ::= SEQUENCE {       -- Each entry consists\
    \ of\n           name        NameSets OPTIONAL,\n           pFPs        PacketFlags,\
    \    -- Populate from packet flags\n                              -- Applies to\
    \ ALL of the corresponding\n                              -- traffic selectors\
    \ in the SelectorLists\n           condition   SelectorLists,  -- Policy \"condition\"\
    \n           processing  Processing      -- Policy \"action\"\n           }\n\
    \       BypassOrDiscardEntry ::= SEQUENCE {\n           bypass      BOOLEAN, \
    \       -- TRUE BYPASS, FALSE DISCARD\n           condition   InOutBound }\n \
    \      InOutBound ::= CHOICE {\n           outbound    [0] SelectorLists,\n  \
    \         inbound     [1] SelectorLists,\n           bothways    [2] BothWays\
    \ }\n       BothWays ::= SEQUENCE {\n           inbound     SelectorLists,\n \
    \          outbound    SelectorLists }\n       NameSets ::= SEQUENCE {\n     \
    \      passed      SET OF Names-R,  -- Matched to IKE ID by\n                \
    \                        -- responder\n           local       SET OF Names-I }\
    \ -- Used internally by IKE\n                                        -- initiator\n\
    \       Names-R ::= CHOICE {                   -- IKEv2 IDs\n           dName\
    \       RDNSequence,           -- ID_DER_ASN1_DN\n           fqdn        FQDN,\
    \                  -- ID_FQDN\n           rfc822      [0] RFC822Name,        --\
    \ ID_RFC822_ADDR\n           keyID       OCTET STRING }         -- KEY_ID\n  \
    \     Names-I ::= OCTET STRING       -- Used internally by IKE\n             \
    \                         -- initiator\n       FQDN ::= IA5String\n       RFC822Name\
    \ ::= IA5String\n       PacketFlags ::= BIT STRING {\n                   -- if\
    \ set, take selector value from packet\n                   -- establishing SA\n\
    \                   -- else use value in SPD entry\n           localAddr  (0),\n\
    \           remoteAddr (1),\n           protocol   (2),\n           localPort\
    \  (3),\n           remotePort (4)  }\n       SelectorLists ::= SET OF SelectorList\n\
    \       SelectorList ::= SEQUENCE {\n           localAddr   AddrList,\n      \
    \     remoteAddr  AddrList,\n           protocol    ProtocolChoice }\n       Processing\
    \ ::= SEQUENCE {\n           extSeqNum   BOOLEAN, -- TRUE 64 bit counter, FALSE\
    \ 32 bit\n           seqOverflow BOOLEAN, -- TRUE rekey, FALSE terminate & audit\n\
    \           fragCheck   BOOLEAN, -- TRUE stateful fragment checking,\n       \
    \                         -- FALSE no stateful fragment checking\n           lifetime\
    \    SALifetime,\n           spi         ManualSPI,\n           algorithms  ProcessingAlgs,\n\
    \           tunnel      TunnelOptions OPTIONAL } -- if absent, use\n         \
    \                                       -- transport mode\n       SALifetime ::=\
    \ SEQUENCE {\n           seconds   [0] INTEGER OPTIONAL,\n           bytes   \
    \  [1] INTEGER OPTIONAL }\n       ManualSPI ::= SEQUENCE {\n           spi   \
    \  INTEGER,\n           keys    KeyIDs }\n       KeyIDs ::= SEQUENCE OF OCTET\
    \ STRING\n       ProcessingAlgs ::= CHOICE {\n           ah          [0] IntegrityAlgs,\
    \  -- AH\n           esp         [1] ESPAlgs}        -- ESP\n       ESPAlgs ::=\
    \ CHOICE {\n           integrity       [0] IntegrityAlgs,       -- integrity only\n\
    \           confidentiality [1] ConfidentialityAlgs, -- confidentiality\n    \
    \                                                -- only\n           both    \
    \        [2] IntegrityConfidentialityAlgs,\n           combined        [3] CombinedModeAlgs\
    \ }\n       IntegrityConfidentialityAlgs ::= SEQUENCE {\n           integrity\
    \       IntegrityAlgs,\n           confidentiality ConfidentialityAlgs }\n   \
    \    -- Integrity Algorithms, ordered by decreasing preference\n       IntegrityAlgs\
    \ ::= SEQUENCE OF IntegrityAlg\n       -- Confidentiality Algorithms, ordered\
    \ by decreasing preference\n       ConfidentialityAlgs ::= SEQUENCE OF ConfidentialityAlg\n\
    \       -- Integrity Algorithms\n       IntegrityAlg ::= SEQUENCE {\n        \
    \   algorithm   IntegrityAlgType,\n           parameters  ANY -- DEFINED BY algorithm\
    \ -- OPTIONAL }\n       IntegrityAlgType ::= INTEGER {\n           none      \
    \        (0),\n           auth-HMAC-MD5-96  (1),\n           auth-HMAC-SHA1-96\
    \ (2),\n           auth-DES-MAC      (3),\n           auth-KPDK-MD5     (4),\n\
    \           auth-AES-XCBC-96  (5)\n       --  tbd (6..65535)\n           }\n \
    \      -- Confidentiality Algorithms\n       ConfidentialityAlg ::= SEQUENCE {\n\
    \           algorithm   ConfidentialityAlgType,\n           parameters  ANY --\
    \ DEFINED BY algorithm -- OPTIONAL }\n       ConfidentialityAlgType ::= INTEGER\
    \ {\n           encr-DES-IV64   (1),\n           encr-DES        (2),\n      \
    \     encr-3DES       (3),\n           encr-RC5        (4),\n           encr-IDEA\
    \       (5),\n           encr-CAST       (6),\n           encr-BLOWFISH   (7),\n\
    \           encr-3IDEA      (8),\n           encr-DES-IV32   (9),\n          \
    \ encr-RC4       (10),\n           encr-NULL      (11),\n           encr-AES-CBC\
    \   (12),\n           encr-AES-CTR   (13)\n       --  tbd (14..65535)\n      \
    \     }\n       CombinedModeAlgs ::= SEQUENCE OF CombinedModeAlg\n       CombinedModeAlg\
    \ ::= SEQUENCE {\n           algorithm   CombinedModeType,\n           parameters\
    \  ANY -- DEFINED BY algorithm} -- defined outside\n                         \
    \           -- of this document for AES modes.\n       CombinedModeType ::= INTEGER\
    \ {\n           comb-AES-CCM    (1),\n           comb-AES-GCM    (2)\n       --\
    \  tbd (3..65535)\n           }\n       TunnelOptions ::= SEQUENCE {\n       \
    \    dscp        DSCP,\n           ecn         BOOLEAN,    -- TRUE Copy CE to\
    \ inner header\n           df          DF,\n           addresses   TunnelAddresses\
    \ }\n       TunnelAddresses ::= CHOICE {\n           ipv4        IPv4Pair,\n \
    \          ipv6        [0] IPv6Pair }\n       IPv4Pair ::= SEQUENCE {\n      \
    \     local       OCTET STRING (SIZE(4)),\n           remote      OCTET STRING\
    \ (SIZE(4)) }\n       IPv6Pair ::= SEQUENCE {\n           local       OCTET STRING\
    \ (SIZE(16)),\n           remote      OCTET STRING (SIZE(16)) }\n       DSCP ::=\
    \ SEQUENCE {\n           copy      BOOLEAN, -- TRUE copy from inner header\n \
    \                             -- FALSE do not copy\n           mapping   OCTET\
    \ STRING OPTIONAL} -- points to table\n                                      \
    \      -- if no copy\n       DF ::= INTEGER {\n           clear   (0),\n     \
    \      set     (1),\n           copy    (2) }\n       ProtocolChoice::= CHOICE\
    \ {\n           anyProt  AnyProtocol,              -- for ANY protocol\n     \
    \      noNext   [0] NoNextLayerProtocol,  -- has no next layer\n             \
    \                                 -- items\n           oneNext  [1] OneNextLayerProtocol,\
    \ -- has one next layer\n                                              -- item\n\
    \           twoNext  [2] TwoNextLayerProtocol, -- has two next layer\n       \
    \                                       -- items\n           fragment FragmentNoNext\
    \ }          -- has no next layer\n                                          \
    \    -- info\n       AnyProtocol ::= SEQUENCE {\n           id          INTEGER\
    \ (0),    -- ANY protocol\n           nextLayer   AnyNextLayers }\n       AnyNextLayers\
    \ ::= SEQUENCE {      -- with either\n           first       AnyNextLayer,   \
    \  -- ANY next layer selector\n           second      AnyNextLayer }    -- ANY\
    \ next layer selector\n       NoNextLayerProtocol ::= INTEGER (2..254)\n     \
    \  FragmentNoNext ::= INTEGER (44)   -- Fragment identifier\n       OneNextLayerProtocol\
    \ ::= SEQUENCE {\n           id          INTEGER (1..254),   -- ICMP, MH, ICMPv6\n\
    \           nextLayer   NextLayerChoice }   -- ICMP Type*256+Code\n          \
    \                                 -- MH   Type*256\n       TwoNextLayerProtocol\
    \ ::= SEQUENCE {\n           id          INTEGER (2..254),   -- Protocol\n   \
    \        local       NextLayerChoice,    -- Local and\n           remote     \
    \ NextLayerChoice }   -- Remote ports\n       NextLayerChoice ::= CHOICE {\n \
    \          any         AnyNextLayer,\n           opaque      [0] OpaqueNextLayer,\n\
    \           range       [1] NextLayerRange }\n       -- Representation of ANY\
    \ in next layer field\n       AnyNextLayer ::= SEQUENCE {\n           start  \
    \     INTEGER (0),\n           end         INTEGER (65535) }\n       -- Representation\
    \ of OPAQUE in next layer field.\n       -- Matches IKE convention\n       OpaqueNextLayer\
    \ ::= SEQUENCE {\n           start       INTEGER (65535),\n           end    \
    \     INTEGER (0) }\n       -- Range for a next layer field\n       NextLayerRange\
    \ ::= SEQUENCE {\n           start       INTEGER (0..65535),\n           end \
    \        INTEGER (0..65535) }\n       -- List of IP addresses\n       AddrList\
    \ ::= SEQUENCE {\n           v4List      IPv4List OPTIONAL,\n           v6List\
    \      [0] IPv6List OPTIONAL }\n       -- IPv4 address representations\n     \
    \  IPv4List ::= SEQUENCE OF IPv4Range\n       IPv4Range ::= SEQUENCE {    -- close,\
    \ but not quite right ...\n           ipv4Start   OCTET STRING (SIZE (4)),\n \
    \          ipv4End     OCTET STRING (SIZE (4)) }\n       -- IPv6 address representations\n\
    \       IPv6List ::= SEQUENCE OF IPv6Range\n       IPv6Range ::= SEQUENCE {  \
    \  -- close, but not quite right ...\n           ipv6Start   OCTET STRING (SIZE\
    \ (16)),\n           ipv6End     OCTET STRING (SIZE (16)) }\n       END\n"
- title: 'Appendix D: Fragment Handling Rationale'
  contents:
  - "Appendix D: Fragment Handling Rationale\n   There are three issues that must\
    \ be resolved regarding processing of\n   (plaintext) fragments in IPsec:\n  \
    \      - mapping a non-initial, outbound fragment to the right SA\n          (or\
    \ finding the right SPD entry)\n        - verifying that a received, non-initial\
    \ fragment is authorized\n          for the SA via which it is received\n    \
    \    - mapping outbound and inbound non-initial fragments to the\n          right\
    \ SPD/cache entry, for BYPASS/DISCARD traffic\n   The first and third issues arise\
    \ because we need a deterministic\n   algorithm for mapping traffic to SAs (and\
    \ SPD/cache entries).  All\n   three issues are important because we want to make\
    \ sure that\n   non-initial fragments that cross the IPsec boundary do not cause\
    \ the\n   access control policies in place at the receiver (or transmitter) to\n\
    \   be violated.\n"
- title: D.1.  Transport Mode and Fragments
  contents:
  - "D.1.  Transport Mode and Fragments\n   First, we note that transport mode SAs\
    \ have been defined to not carry\n   fragments.  This is a carryover from RFC\
    \ 2401, where transport mode\n   SAs always terminated at endpoints.  This is\
    \ a fundamental\n   requirement because, in the worst case, an IPv4 fragment to\
    \ which\n   IPsec was applied might then be fragmented (as a ciphertext packet),\n\
    \   en route to the destination.  IP fragment reassembly procedures at\n   the\
    \ IPsec receiver would not be able to distinguish between pre-IPsec\n   fragments\
    \ and fragments created after IPsec processing.\n   For IPv6, only the sender\
    \ is allowed to fragment a packet.  As for\n   IPv4, an IPsec implementation is\
    \ allowed to fragment tunnel mode\n   packets after IPsec processing, because\
    \ it is the sender relative to\n   the (outer) tunnel header.  However, unlike\
    \ IPv4, it would be\n   feasible to carry a plaintext fragment on a transport\
    \ mode SA,\n   because the fragment header in IPv6 would appear after the AH or\
    \ ESP\n   header, and thus would not cause confusion at the receiver with\n  \
    \ respect to reassembly.  Specifically, the receiver would not attempt\n   reassembly\
    \ for the fragment until after IPsec processing.  To keep\n   things simple, this\
    \ specification prohibits carriage of fragments on\n   transport mode SAs for\
    \ IPv6 traffic.\n   When only end systems used transport mode SAs, the prohibition\
    \ on\n   carriage of fragments was not a problem, since we assumed that the\n\
    \   end system could be configured to not offer a fragment to IPsec.  For\n  \
    \ a native host implementation, this seems reasonable, and, as someone\n   already\
    \ noted, RFC 2401 warned that a BITS implementation might have\n   to reassemble\
    \ fragments before performing an SA lookup.  (It would\n   then apply AH or ESP\
    \ and could re-fragment the packet after IPsec\n   processing.) Because a BITS\
    \ implementation is assumed to be able to\n   have access to all traffic emanating\
    \ from its host, even if the host\n   has multiple interfaces, this was deemed\
    \ a reasonable mandate.\n   In this specification, it is acceptable to use transport\
    \ mode in\n   cases where the IPsec implementation is not the ultimate destination,\n\
    \   e.g., between two SGs.  In principle, this creates a new opportunity\n   for\
    \ outbound, plaintext fragments to be mapped to a transport mode SA\n   for IPsec\
    \ processing.  However, in these new contexts in which a\n   transport mode SA\
    \ is now approved for use, it seems likely that we\n   can continue to prohibit\
    \ transmission of fragments, as seen by IPsec,\n   i.e., packets that have an\
    \ \"outer header\" with a non-zero fragment\n   offset field.  For example, in\
    \ an IP overlay network, packets being\n   sent over transport mode SAs are IP-in-IP\
    \ tunneled and thus have the\n   necessary inner header to accommodate fragmentation\
    \ prior to IPsec\n   processing.  When carried via a transport mode SA, IPsec\
    \ would not\n   examine the inner IP header for such traffic, and thus would not\n\
    \   consider the packet to be a fragment.\n"
- title: D.2.  Tunnel Mode and Fragments
  contents:
  - "D.2.  Tunnel Mode and Fragments\n   For tunnel mode SAs, it has always been the\
    \ case that outbound\n   fragments might arrive for processing at an IPsec implementation.\n\
    \   The need to accommodate fragmented outbound packets can pose a\n   problem\
    \ because a non-initial fragment generally will not contain the\n   port fields\
    \ associated with a next layer protocol such as TCP, UDP,\n   or SCTP.  Thus,\
    \ depending on the SPD configuration for a given IPsec\n   implementation, plaintext\
    \ fragments might or might not pose a\n   problem.\n   For example, if the SPD\
    \ requires that all traffic between two address\n   ranges is offered IPsec protection\
    \ (no BYPASS or DISCARD SPD entries\n   apply to this address range), then it\
    \ should be easy to carry\n   non-initial fragments on the SA defined for this\
    \ address range, since\n   the SPD entry implies an intent to carry ALL traffic\
    \ between the\n   address ranges.  But, if there are multiple SPD entries that\
    \ could\n   match a fragment, and if these entries reference different subsets\
    \ of\n   port fields (vs. ANY), then it is not possible to map an outbound\n \
    \  non-initial fragment to the right entry, unambiguously. (If we choose\n   to\
    \ allow carriage of fragments on transport mode SAs for IPv6, the\n   problems\
    \ arises in that context as well.)\n   This problem largely, though not exclusively,\
    \ motivated the\n   definition of OPAQUE as a selector value for port fields in\
    \ RFC 2401.\n   The other motivation for OPAQUE is the observation that port fields\n\
    \   might not be accessible due to the prior application of IPsec.  For\n   example,\
    \ if a host applied IPsec to its traffic and that traffic\n   arrived at an SG,\
    \ these fields would be encrypted.  The algorithm\n   specified for locating the\
    \ \"next layer protocol\" described in RFC\n   2401 also motivated use of OPAQUE\
    \ to accommodate an encrypted next\n   layer protocol field in such circumstances.\
    \  Nonetheless, the primary\n   use of the OPAQUE value was to match traffic selector\
    \ fields in\n   packets that did not contain port fields (non-initial fragments),\
    \ or\n   packets in which the port fields were already encrypted (as a result\n\
    \   of nested application of IPsec).  RFC 2401 was ambiguous in\n   discussing\
    \ the use of OPAQUE vs. ANY, suggesting in some places that\n   ANY might be an\
    \ alternative to OPAQUE.\n   We gain additional access control capability by defining\
    \ both ANY and\n   OPAQUE values.  OPAQUE can be defined to match only fields\
    \ that are\n   not accessible.  We could define ANY as the complement of OPAQUE,\n\
    \   i.e., it would match all values but only for accessible port fields.\n   We\
    \ have therefore simplified the procedure employed to locate the\n   next layer\
    \ protocol in this document, so that we treat ESP and AH as\n   next layer protocols.\
    \  As a result, the notion of an encrypted next\n   layer protocol field has vanished,\
    \ and there is also no need to worry\n   about encrypted port fields either. \
    \ And accordingly, OPAQUE will be\n   applicable only to non-initial fragments.\n\
    \   Since we have adopted the definitions above for ANY and OPAQUE, we\n   need\
    \ to clarify how these values work when the specified protocol\n   does not have\
    \ port fields, and when ANY is used for the protocol\n   selector.  Accordingly,\
    \ if a specific protocol value is used as a\n   selector, and if that protocol\
    \ has no port fields, then the port\n   field selectors are to be ignored and\
    \ ANY MUST be specified as the\n   value for the port fields. (In this context,\
    \ ICMP TYPE and CODE\n   values are lumped together as a single port field (for\
    \ IKEv2\n   negotiation), as is the IPv6 Mobility Header TYPE value.) If the\n\
    \   protocol selector is ANY, then this should be treated as equivalent\n   to\
    \ specifying a protocol for which no port fields are defined, and\n   thus the\
    \ port selectors should be ignored, and MUST be set to ANY.\n"
- title: D.3.  The Problem of Non-Initial Fragments
  contents:
  - "D.3.  The Problem of Non-Initial Fragments\n   For an SG implementation, it is\
    \ obvious that fragments might arrive\n   from end systems behind the SG.  A BITW\
    \ implementation also may\n   encounter fragments from a host or gateway behind\
    \ it. (As noted\n   earlier, native host implementations and BITS implementations\n\
    \   probably can avoid the problems described below.) In the worst case,\n   fragments\
    \ from a packet might arrive at distinct BITW or SG\n   instantiations and thus\
    \ preclude reassembly as a solution option.\n   Hence, in RFC 2401 we adopted\
    \ a general requirement that fragments\n   must be accommodated in tunnel mode\
    \ for all implementations. However,\n   RFC 2401 did not provide a perfect solution.\
    \  The use of OPAQUE as a\n   selector value for port fields (a SHOULD in RFC\
    \ 2401) allowed an SA\n   to carry non-initial fragments.\n   Using the features\
    \ defined in RFC 2401, if one defined an SA between\n   two IPsec (SG or BITW)\
    \ implementations using the OPAQUE value for\n   both port fields, then all non-initial\
    \ fragments matching the\n   source/destination (S/D) address and protocol values\
    \ for the SA would\n   be mapped to that SA.  Initial fragments would NOT map\
    \ to this SA, if\n   we adopt a strict definition of OPAQUE.  However, RFC 2401\
    \ did not\n   provide detailed guidance on this and thus it may not have been\n\
    \   apparent that use of this feature would essentially create a\n   \"non-initial\
    \ fragment only\" SA.\n   In the course of discussing the \"fragment-only\" SA\
    \ approach, it was\n   noted that some subtle problems, problems not considered\
    \ in RFC 2401,\n   would have to be avoided.  For example, an SA of this sort\
    \ must be\n   configured to offer the \"highest quality\" security services for\
    \ any\n   traffic between the indicated S/D addresses (for the specified\n   protocol).\
    \  This is necessary to ensure that any traffic captured by\n   the fragment-only\
    \ SA is not offered degraded security relative to\n   what it would have been\
    \ offered if the packet were not fragmented.  A\n   possible problem here is that\
    \ we may not be able to identify the\n   \"highest quality\" security services\
    \ defined for use between two IPsec\n   implementation, since the choice of security\
    \ protocols, options, and\n   algorithms is a lattice, not a totally ordered set.\
    \ (We might safely\n   say that BYPASS < AH < ESP w/integrity, but it gets complicated\
    \ if we\n   have multiple ESP encryption or integrity algorithm options.) So,\
    \ one\n   has to impose a total ordering on these security parameters to make\n\
    \   this work, but this can be done locally.\n   However, this conservative strategy\
    \ has a possible performance\n   downside.  If most traffic traversing an IPsec\
    \ implementation for a\n   given S/D address pair (and specified protocol) is\
    \ bypassed, then a\n   fragment-only SA for that address pair might cause a dramatic\n\
    \   increase in the volume of traffic afforded crypto processing.  If the\n  \
    \ crypto implementation cannot support high traffic rates, this could\n   cause\
    \ problems. (An IPsec implementation that is capable of line rate\n   or near\
    \ line rate crypto performance would not be adversely affected\n   by this SA\
    \ configuration approach.  Nonetheless, the performance\n   impact is a potential\
    \ concern, specific to implementation\n   capabilities.)\n   Another concern is\
    \ that non-initial fragments sent over a dedicated\n   SA might be used to effect\
    \ overlapping reassembly attacks, when\n   combined with an apparently acceptable\
    \ initial fragment. (This sort\n   of attack assumes creation of bogus fragments\
    \ and is not a side\n   effect of normal fragmentation.) This concern is easily\
    \ addressed in\n   IPv4, by checking the fragment offset value to ensure that\
    \ no\n   non-initial fragments have a small enough offset to overlap port\n  \
    \ fields that should be contained in the initial fragment.  Recall that\n   the\
    \ IPv4 MTU minimum is 576 bytes, and the max IP header length is 60\n   bytes,\
    \ so any ports should be present in the initial fragment.  If we\n   require all\
    \ non-initial fragments to have an offset of, say, 128 or\n   greater, just to\
    \ be on the safe side, this should prevent successful\n   attacks of this sort.\
    \  If the intent is only to protect against this\n   sort of reassembly attack,\
    \ this check need be implemented only by a\n   receiver.\n   IPv6 also has a fragment\
    \ offset, carried in the fragmentation\n   extension header.  However, IPv6 extension\
    \ headers are variable in\n   length and there is no analogous max header length\
    \ value that we can\n   use to check non-initial fragments, to reject ones that\
    \ might be used\n   for an attack of the sort noted above.  A receiver would need\
    \ to\n   maintain state analogous to reassembly state, to provide equivalent\n\
    \   protection.  So, only for IPv4 is it feasible to impose a fragment\n   offset\
    \ check that would reject attacks designed to circumvent port\n   field checks\
    \ by IPsec (or firewalls) when passing non-initial\n   fragments.\n   Another\
    \ possible concern is that in some topologies and SPD\n   configurations this\
    \ approach might result in an access control\n   surprise.  The notion is that\
    \ if we create an SA to carry ALL\n   (non-initial) fragments, then that SA would\
    \ carry some traffic that\n   might otherwise arrive as plaintext via a separate\
    \ path, e.g., a path\n   monitored by a proxy firewall.  But, this concern arises\
    \ only if the\n   other path allows initial fragments to traverse it without requiring\n\
    \   reassembly, presumably a bad idea for a proxy firewall.  Nonetheless,\n  \
    \ this does represent a potential problem in some topologies and under\n   certain\
    \ assumptions with respect to SPD and (other) firewall rule\n   sets, and administrators\
    \ need to be warned of this possibility.\n   A less serious concern is that non-initial\
    \ fragments sent over a\n   non-initial fragment-only SA might represent a DoS\
    \ opportunity, in\n   that they could be sent when no valid, initial fragment\
    \ will ever\n   arrive.  This might be used to attack hosts behind an SG or BITW\n\
    \   device.  However, the incremental risk posed by this sort of attack,\n   which\
    \ can be mounted only by hosts behind an SG or BITW device, seems\n   small.\n\
    \   If we interpret the ANY selector value as encompassing OPAQUE, then a\n  \
    \ single SA with ANY values for both port fields would be able to\n   accommodate\
    \ all traffic matching the S/D address and protocol traffic\n   selectors, an\
    \ alternative to using the OPAQUE value.  But, using ANY\n   here precludes multiple,\
    \ distinct SAs between the same IPsec\n   implementations for the same address\
    \ pairs and protocol.  So, it is\n   not an exactly equivalent alternative.\n\
    \   Fundamentally, fragment handling problems arise only when more than\n   one\
    \ SA is defined with the same S/D address and protocol selector\n   values, but\
    \ with different port field selector values.\n"
- title: D.4.  BYPASS/DISCARD Traffic
  contents:
  - "D.4.  BYPASS/DISCARD Traffic\n   We also have to address the non-initial fragment\
    \ processing issue for\n   BYPASS/DISCARD entries, independent of SA processing.\
    \  This is\n   largely a local matter for two reasons:\n           1) We have\
    \ no means for coordinating SPD entries for such\n              traffic between\
    \ IPsec implementations since IKE is not\n              invoked.\n           2)\
    \ Many of these entries refer to traffic that is NOT\n              directed to\
    \ or received from a location that is using\n              IPsec.  So there is\
    \ no peer IPsec implementation with\n              which to coordinate via any\
    \ means.\n   However, this document should provide guidance here, consistent with\n\
    \   our goal of offering a well-defined, access control function for all\n   traffic,\
    \ relative to the IPsec boundary.  To that end, this document\n   says that implementations\
    \ MUST support fragment reassembly for\n   BYPASS/DISCARD traffic when port fields\
    \ are specified.  An\n   implementation also MUST permit a user or administrator\
    \ to accept\n   such traffic or reject such traffic using the SPD conventions\n\
    \   described in Section 4.4.1.  The concern is that BYPASS of a\n   cleartext,\
    \ non-initial fragment arriving at an IPsec implementation\n   could undermine\
    \ the security afforded IPsec-protected traffic\n   directed to the same destination.\
    \  For example, consider an IPsec\n   implementation configured with an SPD entry\
    \ that calls for\n   IPsec-protection of traffic between a specific source/destination\n\
    \   address pair, and for a specific protocol and destination port, e.g.,\n  \
    \ TCP traffic on port 23 (Telnet).  Assume that the implementation also\n   allows\
    \ BYPASS of traffic from the same source/destination address\n   pair and protocol,\
    \ but for a different destination port, e.g., port\n   119 (NNTP).  An attacker\
    \ could send a non-initial fragment (with a\n   forged source address) that, if\
    \ bypassed, could overlap with\n   IPsec-protected traffic from the same source\
    \ and thus violate the\n   integrity of the IPsec-protected traffic.  Requiring\
    \ stateful\n   fragment checking for BYPASS entries with non-trivial port ranges\n\
    \   prevents attacks of this sort.\n"
- title: D.5.  Just say no to ports?
  contents:
  - "D.5.  Just say no to ports?\n   It has been suggested that we could avoid the\
    \ problems described\n   above by not allowing port field selectors to be used\
    \ in tunnel mode.\n   But the discussion above shows this to be an unnecessarily\
    \ stringent\n   approach, i.e., since no problems arise for the native OS and\
    \ BITS\n   implementations.  Moreover, some WG members have described scenarios\n\
    \   where use of tunnel mode SAs with (non-trivial) port field selectors\n   is\
    \ appropriate.  So the challenge is defining a strategy that can\n   deal with\
    \ this problem in BITW and SG contexts.  Also note that\n   BYPASS/DISCARD entries\
    \ in the SPD that make use of ports pose the\n   same problems, irrespective of\
    \ tunnel vs. transport mode notions.\n   Some folks have suggested that a firewall\
    \ behind an SG or BITW should\n   be left to enforce port-level access controls\
    \ and the effects of\n   fragmentation.  However, this seems to be an incongruous\
    \ suggestion\n   in that elsewhere in IPsec (e.g., in IKE payloads) we are concerned\n\
    \   about firewalls that always discard fragments.  If many firewalls\n   don't\
    \ pass fragments in general, why should we expect them to deal\n   with fragments\
    \ in this case? So, this analysis rejects the suggestion\n   of disallowing use\
    \ of port field selectors with tunnel mode SAs.\n"
- title: D.6.  Other Suggested Solutions
  contents:
  - "D.6.  Other Suggested Solutions\n   One suggestion is to reassemble fragments\
    \ at the sending IPsec\n   implementation, and thus avoid the problem entirely.\
    \  This approach\n   is invisible to a receiver and thus could be adopted as a\
    \ purely\n   local implementation option.\n   A more sophisticated version of\
    \ this suggestion calls for\n   establishing and maintaining minimal state from\
    \ each initial fragment\n   encountered, to allow non-initial fragments to be\
    \ matched to the\n   right SAs or SPD/cache entries.  This implies an extension\
    \ to the\n   current processing model (and the old one).  The IPsec implementation\n\
    \   would intercept all fragments; capture Source/Destination IP\n   addresses,\
    \ protocol, packet ID, and port fields from initial\n   fragments; and then use\
    \ this data to map non-initial fragments to SAs\n   that require port fields.\
    \  If this approach is employed, the receiver\n   needs to employ an equivalent\
    \ scheme, as it too must verify that\n   received fragments are consistent with\
    \ SA selector values.  A\n   non-initial fragment that arrives prior to an initial\
    \ fragment could\n   be cached or discarded, awaiting arrival of the corresponding\
    \ initial\n   fragment.\n   A downside of both approaches noted above is that\
    \ they will not\n   always work.  When a BITW device or SG is configured in a\
    \ topology\n   that might allow some fragments for a packet to be processed at\n\
    \   different SGs or BITW devices, then there is no guarantee that all\n   fragments\
    \ will ever arrive at the same IPsec device.  This approach\n   also raises possible\
    \ processing problems.  If the sender caches\n   non-initial fragments until the\
    \ corresponding initial fragment\n   arrives, buffering problems might arise,\
    \ especially at high speeds.\n   If the non-initial fragments are discarded rather\
    \ than cached, there\n   is no guarantee that traffic will ever pass, e.g., retransmission\n\
    \   will result in different packet IDs that cannot be matched with prior\n  \
    \ transmissions.  In any case, housekeeping procedures will be needed\n   to decide\
    \ when to delete the fragment state data, adding some\n   complexity to the system.\
    \  Nonetheless, this is a viable solution in\n   some topologies, and these are\
    \ likely to be common topologies.\n   The Working Group rejected an earlier version\
    \ of the convention of\n   creating an SA to carry only non-initial fragments,\
    \ something that\n   was supported implicitly under the RFC 2401 model via use\
    \ of OPAQUE\n   port fields, but never clearly articulated in RFC 2401.  The\n\
    \   (rejected) text called for each non-initial fragment to be treated as\n  \
    \ protocol 44 (the IPv6 fragment header protocol ID) by the sender and\n   receiver.\
    \  This approach has the potential to make IPv4 and IPv6\n   fragment handling\
    \ more uniform, but it does not fundamentally change\n   the problem, nor does\
    \ it address the issue of fragment handling for\n   BYPASS/DISCARD traffic.  Given\
    \ the fragment overlap attack problem\n   that IPv6 poses, it does not seem that\
    \ it is worth the effort to\n   adopt this strategy.\n"
- title: D.7.  Consistency
  contents:
  - "D.7.  Consistency\n   Earlier, the WG agreed to allow an IPsec BITS, BITW, or\
    \ SG to perform\n   fragmentation prior to IPsec processing.  If this fragmentation\
    \ is\n   performed after SA lookup at the sender, there is no \"mapping to the\n\
    \   right SA\" problem.  But, the receiver still needs to be able to\n   verify\
    \ that the non-initial fragments are consistent with the SA via\n   which they\
    \ are received.  Since the initial fragment might be lost en\n   route, the receiver\
    \ encounters all of the potential problems noted\n   above.  Thus, if we are to\
    \ be consistent in our decisions, we need to\n   say how a receiver will deal\
    \ with the non-initial fragments that\n   arrive.\n"
- title: D.8.  Conclusions
  contents:
  - "D.8.  Conclusions\n   There is no simple, uniform way to handle fragments in\
    \ all contexts.\n   Different approaches work better in different contexts.  Thus,\
    \ this\n   document offers 3 choices -- one MUST and two MAYs.  At some point\
    \ in\n   the future, if the community gains experience with the two MAYs, they\n\
    \   may become SHOULDs or MUSTs or other approaches may be proposed.\n"
- title: 'Appendix E: Example of Supporting Nested SAs via SPD and Forwarding'
  contents:
  - "Appendix E: Example of Supporting Nested SAs via SPD and Forwarding\n       \
    \     Table Entries\n   This appendix provides an example of how to configure\
    \ the SPD and\n   forwarding tables to support a nested pair of SAs, consistent\
    \ with\n   the new processing model.  For simplicity, this example assumes just\n\
    \   one SPD-I.\n   The goal in this example is to support a transport mode SA\
    \ from A to\n   C, carried over a tunnel mode SA from A to B.  For example, A\
    \ might\n   be a laptop connected to the public Internet, B might be a firewall\n\
    \   that protects a corporate network, and C might be a server on the\n   corporate\
    \ network that demands end-to-end authentication of A's\n   traffic.\n       \
    \  +---+     +---+  +---+\n         | A |=====| B |  | C |\n         |   |------------|\
    \   |\n         |   |=====|   |  |   |\n         +---+     +---+  +---+\n   A's\
    \ SPD contains entries of the form:\n                        Next Layer\n    \
    \  Rule Local Remote Protocol   Action\n      ---- ----- ------ ---------- -----------------------\n\
    \       1     C     A     ESP       BYPASS\n       2     A     C     ICMP,ESP\
    \  PROTECT(ESP,tunnel,integr+conf)\n       3     A     C     ANY       PROTECT(ESP,transport,integr-only)\n\
    \       4     A     B     ICMP,IKE  BYPASS\n   A's unprotected-side forwarding\
    \ table is set so that outbound packets\n   destined for C are looped back to\
    \ the protected side.  A's\n   protected-side forwarding table is set so that\
    \ inbound ESP packets\n   are looped back to the unprotected side.  A's forwarding\
    \ tables\n   contain entries of the form:\n      Unprotected-side forwarding table\n\
    \        Rule Local Remote Protocol Action\n        ---- ----- ------ --------\
    \ ---------------------------\n         1     A     C       ANY   loop back to\
    \ protected side\n         2     A     B       ANY   forward to B\n      Protected-side\
    \ forwarding table\n        Rule Local Remote Protocol Action\n        ---- -----\
    \ ------ -------- -----------------------------\n         1     A     C      \
    \ ESP   loop back to unprotected side\n   An outbound TCP packet from A to C would\
    \ match SPD rule 3 and have\n   transport mode ESP applied to it.  The unprotected-side\
    \ forwarding\n   table would then loop back the packet.  The packet is compared\n\
    \   against SPD-I (see Figure 2), matches SPD rule 1, and so it is\n   BYPASSed.\
    \  The packet is treated as an outbound packet and compared\n   against the SPD\
    \ for a third time.  This time it matches SPD rule 2,\n   so ESP is applied in\
    \ tunnel mode.  This time the forwarding table\n   doesn't loop back the packet,\
    \ because the outer destination address\n   is B, so the packet goes out onto\
    \ the wire.\n   An inbound TCP packet from C to A is wrapped in two ESP headers;\
    \ the\n   outer header (ESP in tunnel mode) shows B as the source, whereas the\n\
    \   inner header (ESP transport mode) shows C as the source.  Upon\n   arrival\
    \ at A, the packet would be mapped to an SA based on the SPI,\n   have the outer\
    \ header removed, and be decrypted and\n   integrity-checked.  Then it would be\
    \ matched against the SAD\n   selectors for this SA, which would specify C as\
    \ the source and A as\n   the destination, derived from SPD rule 2.  The protected-side\n\
    \   forwarding function would then send it back to the unprotected side\n   based\
    \ on the addresses and the next layer protocol (ESP), indicative\n   of nesting.\
    \  It is compared against SPD-O (see Figure 3) and found to\n   match SPD rule\
    \ 1, so it is BYPASSed.  The packet is mapped to an SA\n   based on the SPI, integrity-checked,\
    \ and compared against the SAD\n   selectors derived from SPD rule 3.  The forwarding\
    \ function then\n   passes it up to the next layer, because it isn't an ESP packet.\n"
- title: References
  contents:
  - 'References

    '
- title: Normative References
  contents:
  - "Normative References\n   [BBCDWW98]     Blake, S., Black, D., Carlson, M., Davies,\
    \ E., Wang,\n                  Z., and W. Weiss, \"An Architecture for Differentiated\n\
    \                  Service\", RFC 2475, December 1998.\n   [Bra97]        Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n                  Requirement Level\"\
    , BCP 14, RFC 2119, March 1997.\n   [CD98]         Conta, A. and S. Deering, \"\
    Internet Control Message\n                  Protocol (ICMPv6) for the Internet\
    \ Protocol Version 6\n                  (IPv6) Specification\", RFC 2463, December\
    \ 1998.\n   [DH98]         Deering, S., and R. Hinden, \"Internet Protocol,\n\
    \                  Version 6 (IPv6) Specification\", RFC 2460, December\n    \
    \              1998.\n   [Eas05]        3rd Eastlake, D., \"Cryptographic Algorithm\n\
    \                  Implementation Requirements For Encapsulating Security\n  \
    \                Payload (ESP) and Authentication Header (AH)\", RFC\n       \
    \           4305, December 2005.\n   [HarCar98]     Harkins, D. and D. Carrel,\
    \ \"The Internet Key Exchange\n                  (IKE)\", RFC 2409, November 1998.\n\
    \   [Kau05]        Kaufman, C., Ed., \"The Internet Key Exchange (IKEv2)\n   \
    \               Protocol\", RFC 4306, December 2005.\n   [Ken05a]       Kent,\
    \ S., \"IP Encapsulating Security Payload (ESP)\",\n                  RFC 4303,\
    \ December 2005.\n   [Ken05b]       Kent, S., \"IP Authentication Header\", RFC\
    \ 4302,\n                  December 2005.\n   [MD90]         Mogul, J. and S.\
    \ Deering, \"Path MTU discovery\", RFC\n                  1191, November 1990.\n\
    \   [Mobip]        Johnson, D., Perkins, C., and J. Arkko, \"Mobility\n      \
    \            Support in IPv6\", RFC 3775, June 2004.\n   [Pos81a]       Postel,\
    \ J., \"Internet Protocol\", STD 5, RFC 791,\n                  September 1981.\n\
    \   [Pos81b]       Postel, J., \"Internet Control Message Protocol\", RFC\n  \
    \                792, September 1981.\n   [Sch05]        Schiller, J., \"Cryptographic\
    \ Algorithms for use in the\n                  Internet Key Exchange Version 2\
    \ (IKEv2)\", RFC 4307,\n                  December 2005.\n   [WaKiHo97]     Wahl,\
    \ M., Kille, S., and T. Howes, \"Lightweight\n                  Directory Access\
    \ Protocol (v3): UTF-8 String\n                  Representation of Distinguished\
    \ Names\", RFC 2253,\n                  December 1997.\n"
- title: Informative References
  contents:
  - "Informative References\n   [CoSa04]       Condell, M., and L. Sanchez, \"On the\
    \ Deterministic\n                  Enforcement of Un-ordered Security Policies\"\
    , BBN\n                  Technical Memo 1346, March 2004.\n   [FaLiHaMeTr00] Farinacci,\
    \ D., Li, T., Hanks, S., Meyer, D., and P.\n                  Traina, \"Generic\
    \ Routing Encapsulation (GRE)\", RFC\n                  2784, March 2000.\n  \
    \ [Gro02]        Grossman, D., \"New Terminology and Clarifications for\n    \
    \              Diffserv\", RFC 3260, April 2002.\n   [HC03]         Holbrook,\
    \ H. and B. Cain, \"Source Specific Multicast\n                  for IP\", Work\
    \ in Progress, November 3, 2002.\n   [HA94]         Haller, N. and R. Atkinson,\
    \ \"On Internet\n                  Authentication\", RFC 1704, October 1994.\n\
    \   [NiBlBaBL98]   Nichols, K., Blake, S., Baker, F., and D. Black,\n        \
    \          \"Definition of the Differentiated Services Field (DS\n           \
    \       Field) in the IPv4 and IPv6 Headers\", RFC 2474,\n                  December\
    \ 1998.\n   [Per96]        Perkins, C., \"IP Encapsulation within IP\", RFC 2003,\n\
    \                  October 1996.\n   [RaFlBl01]     Ramakrishnan, K., Floyd, S.,\
    \ and D. Black, \"The\n                  Addition of Explicit Congestion Notification\
    \ (ECN) to\n                  IP\", RFC 3168, September 2001.\n   [RFC2401]  \
    \    Kent, S. and R. Atkinson, \"Security Architecture for\n                 \
    \ the Internet Protocol\", RFC 2401, November 1998.\n   [RFC2983]      Black,\
    \ D., \"Differentiated Services and Tunnels\", RFC\n                  2983, October\
    \ 2000.\n   [RFC3547]      Baugher, M., Weis, B., Hardjono, T., and H. Harney,\n\
    \                  \"The Group Domain of Interpretation\", RFC 3547, July\n  \
    \                2003.\n   [RFC3740]      Hardjono, T. and B.  Weis, \"The Multicast\
    \ Group\n                  Security Architecture\", RFC 3740, March 2004.\n  \
    \ [RaCoCaDe04]   Rajahalme, J., Conta, A., Carpenter, B., and S.\n           \
    \       Deering, \"IPv6 Flow Label Specification\", RFC 3697,\n              \
    \    March 2004.\n   [Sch94]        Schneier, B.,  Applied Cryptography, Section\
    \ 8.6, John\n                  Wiley & Sons, New York, NY, 1994.\n   [Shi00] \
    \       Shirey, R., \"Internet Security Glossary\", RFC 2828,\n              \
    \    May 2000.\n   [SMPT01]       Shacham, A., Monsour, B., Pereira, R., and M.\
    \ Thomas,\n                  \"IP Payload Compression Protocol (IPComp)\", RFC\
    \ 3173,\n                  September 2001.\n   [ToEgWa04]     Touch, J., Eggert,\
    \ L., and Y. Wang, \"Use of IPsec\n                  Transport Mode for Dynamic\
    \ Routing\", RFC 3884,\n                  September 2004.\n   [VK83]         V.L.\
    \ Voydock & S.T. Kent, \"Security Mechanisms in\n                  High-level\
    \ Networks\", ACM Computing Surveys, Vol. 15,\n                  No. 2, June 1983.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Stephen Kent\n   BBN Technologies\n   10 Moulton Street\n\
    \   Cambridge, MA  02138\n   USA\n   Phone: +1 (617) 873-3988\n   EMail: kent@bbn.com\n\
    \   Karen Seo\n   BBN Technologies\n   10 Moulton Street\n   Cambridge, MA  02138\n\
    \   USA\n   Phone: +1 (617) 873-3152\n   EMail: kseo@bbn.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
