- contents:
  - '              SMTP MTA Strict Transport Security (MTA-STS)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   SMTP MTA Strict Transport Security (MTA-STS) is a mechanism enabling\n
    \  mail service providers (SPs) to declare their ability to receive\n   Transport
    Layer Security (TLS) secure SMTP connections and to specify\n   whether sending
    SMTP servers should refuse to deliver to MX hosts\n   that do not offer TLS with
    a trusted server certificate.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8461.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n     1.1.  Terminology . . . . . . . . . . . . . . . . . . . .
    . . .   4\n   2.  Related Technologies  . . . . . . . . . . . . . . . . . . .
    .   5\n   3.  Policy Discovery  . . . . . . . . . . . . . . . . . . . . . .   5\n
    \    3.1.  MTA-STS TXT Records . . . . . . . . . . . . . . . . . . .   6\n     3.2.
    \ MTA-STS Policies  . . . . . . . . . . . . . . . . . . . .   7\n     3.3.  HTTPS
    Policy Fetching . . . . . . . . . . . . . . . . . .  10\n     3.4.  Policy Selection
    for Smart Hosts and Subdomains . . . . .  11\n   4.  Policy Validation . . . .
    . . . . . . . . . . . . . . . . . .  11\n     4.1.  MX Host Validation  . . .
    . . . . . . . . . . . . . . . .  12\n     4.2.  Recipient MTA Certificate Validation
    \ . . . . . . . . . .  12\n   5.  Policy Application  . . . . . . . . . . . .
    . . . . . . . . .  12\n     5.1.  Policy Application Control Flow . . . . . .
    . . . . . . .  13\n   6.  Reporting Failures  . . . . . . . . . . . . . . . .
    . . . . .  13\n   7.  Interoperability Considerations . . . . . . . . . . . .
    . . .  14\n     7.1.  SNI Support . . . . . . . . . . . . . . . . . . . . . .
    .  14\n     7.2.  Minimum TLS Version Support . . . . . . . . . . . . . . .  14\n
    \  8.  Operational Considerations  . . . . . . . . . . . . . . . . .  15\n     8.1.
    \ Policy Updates  . . . . . . . . . . . . . . . . . . . . .  15\n     8.2.  Policy
    Delegation . . . . . . . . . . . . . . . . . . . .  15\n     8.3.  Removing MTA-STS
    \ . . . . . . . . . . . . . . . . . . . .  16\n     8.4.  Preserving MX Candidate
    Traversal . . . . . . . . . . . .  17\n   9.  IANA Considerations . . . . . .
    . . . . . . . . . . . . . . .  17\n     9.1.  Well-Known URIs Registry  . . .
    . . . . . . . . . . . . .  17\n     9.2.  MTA-STS TXT Record Fields . . . . .
    . . . . . . . . . . .  17\n     9.3.  MTA-STS Policy Fields . . . . . . . . .
    . . . . . . . . .  18\n   10. Security Considerations . . . . . . . . . . . .
    . . . . . . .  18\n     10.1.  Obtaining a Signed Certificate . . . . . . . .
    . . . . .  18\n     10.2.  Preventing Policy Discovery  . . . . . . . . . . .
    . . .  19\n     10.3.  Denial of Service  . . . . . . . . . . . . . . . . . .
    .  19\n     10.4.  Weak Policy Constraints  . . . . . . . . . . . . . . . .  20\n
    \    10.5.  Compromise of the Web PKI System . . . . . . . . . . . .  20\n   11.
    References  . . . . . . . . . . . . . . . . . . . . . . . . .  21\n     11.1.
    \ Normative References . . . . . . . . . . . . . . . . . .  21\n     11.2.  Informative
    References . . . . . . . . . . . . . . . . .  23\n   Appendix A.  MTA-STS Example
    Record and Policy  . . . . . . . . .  25\n   Appendix B.  Message Delivery Pseudocode
    \ . . . . . . . . . . . .  25\n   Contributors  . . . . . . . . . . . . . . .
    . . . . . . . . . . .  28\n   Authors' Addresses  . . . . . . . . . . . . . .
    . . . . . . . . .  29\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The STARTTLS extension to SMTP [RFC3207] allows SMTP clients
    and\n   hosts to negotiate the use of a TLS channel for encrypted mail\n   transmission.\n
    \  While this opportunistic encryption protocol by itself provides a\n   high
    barrier against passive man-in-the-middle traffic interception,\n   any attacker
    who can delete parts of the SMTP session (such as the\n   \"250 STARTTLS\" response)
    or who can redirect the entire SMTP session\n   (perhaps by overwriting the resolved
    MX record of the delivery\n   domain) can perform downgrade or interception attacks.\n
    \  This document defines a mechanism for recipient domains to publish\n   policies,
    via a combination of DNS and HTTPS, specifying:\n   o  whether MTAs sending mail
    to this domain can expect PKIX-\n      authenticated TLS support\n   o  what a
    conforming client should do with messages when TLS cannot\n      be successfully
    negotiated\n"
  - contents:
    - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
      \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
      in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n
      \  capitals, as shown here.\n   We also define the following terms for further
      use in this document:\n   o  MTA-STS Policy: A commitment by the Policy Domain
      to support TLS\n      authenticated with PKIX [RFC5280] for the specified MX
      hosts.\n   o  Policy Domain: The domain for which an MTA-STS Policy is defined.\n
      \     This is the next-hop domain; when sending mail to\n      \"alice@example.com\",
      this would ordinarily be \"example.com\", but\n      this may be overridden
      by explicit routing rules (as described in\n      Section 3.4, \"Policy Selection
      for Smart Hosts and Subdomains\").\n   o  Policy Host: The HTTPS host that serves
      the MTA-STS Policy for a\n      Policy Domain.  Rules for constructing the hostname
      are described\n      in Section 3.2, \"MTA-STS Policies\".\n   o  Sender or
      Sending MTA: The SMTP MTA sending an email message.\n   o  ABNF: Augmented Backus-Naur
      Form, a syntax for formally specifying\n      syntax, defined in [RFC5234] and
      [RFC7405].\n"
    title: 1.1.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Related Technologies\n   The DNS-Based Authentication of a Named Entities
    (DANE) TLSA record\n   [RFC7672] is similar, in that DANE is also designed to
    upgrade\n   unauthenticated encryption or plaintext transmission into\n   authenticated,
    downgrade-resistant encrypted transmission.  DANE\n   requires DNSSEC [RFC4033]
    for authentication; the mechanism described\n   here instead relies on certification
    authorities (CAs) and does not\n   require DNSSEC, at a cost of risking malicious
    downgrades.  For a\n   thorough discussion of this trade-off, see Section 10,
    \"Security\n   Considerations\".\n   In addition, MTA-STS provides an optional
    testing-only mode, enabling\n   soft deployments to detect policy failures; partial
    deployments can\n   be achieved in DANE by deploying TLSA records only for some
    of a\n   domain's MXes, but such a mechanism is not possible for the per-\n   domain
    policies used by MTA-STS.\n   The primary motivation of MTA-STS is to provide
    a mechanism for\n   domains to ensure transport security even when deploying DNSSEC
    is\n   undesirable or impractical.  However, MTA-STS is designed not to\n   interfere
    with DANE deployments when the two overlap; in particular,\n   senders who implement
    MTA-STS validation MUST NOT allow MTA-STS\n   Policy validation to override a
    failing DANE validation.\n"
  title: 2.  Related Technologies
- contents:
  - "3.  Policy Discovery\n   MTA-STS policies are distributed via HTTPS from a \"well-known\"\n
    \  [RFC5785] path served within the Policy Domain, and their presence\n   and
    current version are indicated by a TXT record at the Policy\n   Domain.  These
    TXT records additionally contain a policy \"id\" field,\n   allowing Sending MTAs
    to check that a cached policy is still current\n   without performing an HTTPS
    request.\n   To discover if a recipient domain implements MTA-STS, a sender need\n
    \  only resolve a single TXT record.  To see if an updated policy is\n   available
    for a domain for which the sender has a previously cached\n   policy, the sender
    need only check the TXT record's version \"id\"\n   against the cached value.\n"
  - contents:
    - "3.1.  MTA-STS TXT Records\n   The MTA-STS TXT record is a TXT record with the
      name \"_mta-sts\" at\n   the Policy Domain.  For the domain \"example.com\",
      this record would\n   be \"_mta-sts.example.com\".  MTA-STS TXT records MUST
      be US-ASCII,\n   semicolon-separated key/value pairs containing the following
      fields:\n   o  \"v\" (plaintext, required): Currently, only \"STSv1\" is supported.\n
      \  o  \"id\" (plaintext, required): A short string used to track policy\n      updates.
      \ This string MUST uniquely identify a given instance of a\n      policy, such
      that senders can determine when the policy has been\n      updated by comparing
      to the \"id\" of a previously seen policy.\n      There is no implied ordering
      of \"id\" fields between revisions.\n   An example TXT record is as below:\n
      \  _mta-sts.example.com.  IN TXT \"v=STSv1; id=20160831085700Z;\"\n   The formal
      definition of the \"_mta-sts\" TXT record, defined using\n   ABNF [RFC7405],
      is as follows:\n   sts-text-record = sts-version 1*(sts-field-delim sts-field)\n
      \                    [sts-field-delim]\n   sts-field       = sts-id /                 ;
      Note that sts-id record\n                     sts-extension            ; is
      required.\n   sts-field-delim = *WSP \";\" *WSP\n   sts-version     = %s\"v=STSv1\"\n
      \  sts-id          = %s\"id=\" 1*32(ALPHA / DIGIT)     ; id=...\n   sts-extension
      \  = sts-ext-name \"=\" sts-ext-value  ; name=value\n   sts-ext-name    = (ALPHA
      / DIGIT)\n                     *31(ALPHA / DIGIT / \"_\" / \"-\" / \".\")\n
      \  sts-ext-value   = 1*(%x21-3A / %x3C / %x3E-7E)\n                     ; chars
      excluding \"=\", \";\", SP, and CTLs\n   The TXT record MUST begin with the
      sts-version field; the order of\n   other fields is not significant.  If multiple
      TXT records for\n   \"_mta-sts\" are returned by the resolver, records that
      do not begin\n   with \"v=STSv1;\" are discarded.  If the number of resulting
      records is\n   not one, or if the resulting record is syntactically invalid,
      senders\n   MUST assume the recipient domain does not have an available MTA-STS\n
      \  Policy and skip the remaining steps of policy discovery.  (Note that\n   the
      absence of a usable TXT record is not by itself sufficient to\n   remove a sender's
      previously cached policy for the Policy Domain, as\n   discussed in Section
      5.1, \"Policy Application Control Flow\".)  If the\n   resulting TXT record
      contains multiple strings, then the record MUST\n   be treated as if those strings
      are concatenated without adding\n   spaces.\n   The \"_mta-sts\" record MAY
      return a CNAME that points (directly or via\n   other CNAMEs) to a TXT record,
      in which case senders MUST follow the\n   CNAME pointers.  This can be used
      for policy delegation, as described\n   in Section 8.2.\n"
    title: 3.1.  MTA-STS TXT Records
  - contents:
    - "3.2.  MTA-STS Policies\n   The policy itself is a set of key/value pairs (similar
      to header\n   fields in [RFC5322]) served via the HTTPS GET method from the
      fixed\n   \"well-known\" [RFC5785] path of \".well-known/mta-sts.txt\" served
      by\n   the Policy Host.  The Policy Host DNS name is constructed by\n   prepending
      \"mta-sts\" to the Policy Domain.\n   Thus, for a Policy Domain of \"example.com\",
      the full URL is\n   \"https://mta-sts.example.com/.well-known/mta-sts.txt\".\n
      \  When fetching a policy, senders SHOULD validate that the media type\n   is
      \"text/plain\" to guard against cases where web servers allow\n   untrusted
      users to host non-text content (typically, HTML or images)\n   at a user-defined
      path.  All parameters other than charset=utf-8 or\n   charset=us-ascii are ignored.
      \ Additional \"Content-Type\" parameters\n   are also ignored.\n   This resource
      contains the following CRLF-separated key/value pairs:\n   o  \"version\": Currently,
      only \"STSv1\" is supported.\n   o  \"mode\": One of \"enforce\", \"testing\",
      or \"none\", indicating the\n      expected behavior of a Sending MTA in the
      case of a policy\n      validation failure.  See Section 5, \"Policy Application\",
      for more\n      details about the three modes.\n   o  \"max_age\": Max lifetime
      of the policy (plaintext non-negative\n      integer seconds, maximum value
      of 31557600).  Well-behaved clients\n      SHOULD cache a policy for up to this
      value from the last policy\n      fetch time.  To mitigate the risks of attacks
      at policy refresh\n      time, it is expected that this value typically be in
      the range of\n      weeks or greater.\n   o  \"mx\": Allowed MX patterns.  One
      or more patterns matching allowed\n      MX hosts for the Policy Domain.  As
      an example,\n                        mx: mail.example.com <CRLF>\n                        mx:
      *.example.net\n   indicates that mail for this domain might be handled by MX\n
      \  \"mail.example.com\" or any MX at \"example.net\".  Valid patterns can be\n
      \  either fully specified names (\"example.com\") or suffixes prefixed by\n
      \  a wildcard (\"*.example.net\").  If a policy specifies more than one\n   MX,
      each MX MUST have its own \"mx:\" key, and each MX key/value pair\n   MUST be
      on its own line in the policy file.  In the case of\n   Internationalized Domain
      Names [RFC5891], the \"mx\" value MUST specify\n   the Punycode-encoded A-label
      [RFC3492] to match against, and not the\n   Unicode-encoded U-label.  The full
      semantics of certificate\n   validation (including the use of wildcard patterns)
      are described in\n   Section 4.1, \"MX Host Validation\".\n   An example policy
      is as below:\n                         version: STSv1\n                         mode:
      enforce\n                         mx: mail.example.com\n                         mx:
      *.example.net\n                         mx: backupmx.example.com\n                         max_age:
      604800\n   The formal definition of the policy resource, defined using ABNF\n
      \  [RFC7405], is as follows:\n"
    - "sts-policy-record        = sts-policy-field *WSP\n                           *(sts-policy-term
      sts-policy-field *WSP)\n                           [sts-policy-term]\n"
    - "sts-policy-field         = sts-policy-version /      ; required once\n                           sts-policy-mode
      \   /      ; required once\n                           sts-policy-max-age /
      \     ; required once\n                           sts-policy-mx /\n                           ;
      required at least once, except when\n                           ; mode is \"none\"\n
      \                          sts-policy-extension      ; other fields\n"
    - 'sts-policy-field-delim   = ":" *WSP

      '
    - "sts-policy-version     = sts-policy-version-field sts-policy-field-delim\n
      \                        sts-policy-version-value\n"
    - 'sts-policy-version-field = %s"version"

      '
    - 'sts-policy-version-value = %s"STSv1"

      '
    - "sts-policy-mode          = sts-policy-mode-field sts-policy-field-delim\n                           sts-policy-mode-value\n"
    - 'sts-policy-mode-field    = %s"mode"

      '
    - 'sts-policy-mode-value    =  %s"testing" / %s"enforce" / %s"none"

      '
    - "sts-policy-mx            = sts-policy-mx-field sts-policy-field-delim\n                           sts-policy-mx-value\n"
    - 'sts-policy-mx-field      = %s"mx"

      '
    - 'sts-policy-mx-value      = ["*."] Domain

      '
    - "sts-policy-max-age     = sts-policy-max-age-field sts-policy-field-delim\n
      \                        sts-policy-max-age-value\n"
    - 'sts-policy-max-age-field = %s"max_age"

      '
    - 'sts-policy-max-age-value = 1*10(DIGIT)

      '
    - "sts-policy-extension     = sts-policy-ext-name    ; additional\n                           sts-policy-field-delim
      ; extension\n                           sts-policy-ext-value   ; fields\n"
    - "sts-policy-ext-name      = (sts-policy-alphanum)\n                           *31(sta-policy-alphanum
      / \"_\" / \"-\" / \".\")\n"
    - 'sts-policy-term          = LF / CRLF

      '
    - "sts-policy-ext-value     = sts-policy-vchar\n                           [*(%x20
      / sts-policy-vchar)\n                           sts-policy-vchar]\n                           ;
      chars, including UTF-8 [RFC3629],\n                           ; excluding CTLs
      and no\n                           ; leading/trailing spaces\n"
    - 'sts-policy-alphanum     = ALPHA / DIGIT

      '
    - 'sts-policy-vchar        = %x21-7E / UTF8-2 / UTF8-3 / UTF8-4

      '
    - 'UTF8-2          =   <Defined in Section 4 of [RFC3629]>

      '
    - 'UTF8-3          =   <Defined in Section 4 of [RFC3629]>

      '
    - 'UTF8-4          =   <Defined in Section 4 of [RFC3629]>

      '
    - "Domain          =   <Defined in Section 4.1.2 of [RFC5321]>\n   Parsers MUST
      accept TXT records and policy files that are\n   syntactically valid (i.e.,
      valid key/value pairs separated by\n   semicolons for TXT records), possibly
      containing additional key/value\n   pairs not specified in this document, in
      which case unknown fields\n   SHALL be ignored.  If any non-repeated field --
      i.e., all fields\n   excepting \"mx\" -- is duplicated, all entries except for
      the first\n   SHALL be ignored.\n"
    title: 3.2.  MTA-STS Policies
  - contents:
    - "3.3.  HTTPS Policy Fetching\n   Policy bodies are, as described above, retrieved
      by Sending MTAs via\n   HTTPS [RFC2818].  During the TLS handshake initiated
      to fetch a new\n   or updated policy from the Policy Host, the Policy Host HTTPS
      server\n   MUST present an X.509 certificate that is valid for the \"mta-sts\"\n
      \  DNS-ID [RFC6125] (e.g., \"mta-sts.example.com\") as described below,\n   chain
      to a root CA that is trusted by the Sending MTA, and be non-\n   expired.  It
      is expected that Sending MTAs use a set of trusted CAs\n   similar to those
      in widely deployed web browsers and operating\n   systems.  See [RFC5280] for
      more details about certificate\n   verification.\n   The certificate is valid
      for the Policy Host (i.e., \"mta-sts\"\n   prepended to the Policy Domain) with
      respect to the rules described\n   in [RFC6125], with the following application-specific
      considerations:\n   o  Matching is performed only against the DNS-ID identifiers.\n
      \  o  DNS domain names in server certificates MAY contain the wildcard\n      character
      '*' as the complete left-most label within the\n      identifier.\n   The certificate
      MAY be checked for revocation via the Online\n   Certificate Status Protocol
      (OCSP) [RFC6960], certificate revocation\n   lists (CRLs), or some other mechanism.\n
      \  Policies fetched via HTTPS are only valid if the HTTP response code\n   is
      200 (OK).  HTTP 3xx redirects MUST NOT be followed, and HTTP\n   caching (as
      specified in [RFC7234]) MUST NOT be used.\n   Senders may wish to rate-limit
      the frequency of attempts to fetch the\n   HTTPS endpoint even if a valid TXT
      record for the recipient domain\n   exists.  In the case where the HTTPS GET
      fails, implementers SHOULD\n   limit further attempts to a period of five minutes
      or longer per\n   version ID, to avoid overwhelming resource-constrained recipients\n
      \  with cascading failures.\n   Senders MAY impose a timeout on the HTTPS GET
      and/or a limit on the\n   maximum size of the response body to avoid long delays
      or resource\n   exhaustion during attempted policy updates.  A suggested timeout
      is\n   one minute, and a suggested maximum policy size is 64 kilobytes;\n   Policy
      Hosts SHOULD respond to requests with a complete policy body\n   within that
      timeout and size limit.\n   If a valid TXT record is found but no policy can
      be fetched via HTTPS\n   (for any reason), and there is no valid (non-expired)
      previously\n   cached policy, senders MUST continue with delivery as though
      the\n   domain has not implemented MTA-STS.\n   Conversely, if no \"live\" policy
      can be discovered via DNS or fetched\n   via HTTPS, but a valid (non-expired)
      policy exists in the sender's\n   cache, the sender MUST apply that cached policy.\n
      \  Finally, to mitigate the risk of persistent interference with policy\n   refresh,
      as discussed in-depth in Section 10, MTAs SHOULD proactively\n   refresh cached
      policies before they expire; a suggested refresh\n   frequency is once per day.
      \ To enable administrators to discover\n   problems with policy refresh, MTAs
      SHOULD alert administrators\n   (through the use of logs or similar) when such
      attempts fail, unless\n   the cached policy mode is \"none\".\n"
    title: 3.3.  HTTPS Policy Fetching
  - contents:
    - "3.4.  Policy Selection for Smart Hosts and Subdomains\n   When sending mail
      via a \"smart host\" -- an administratively\n   configured intermediate SMTP
      relay, which is different from the\n   message recipient's server as determined
      from DNS -- compliant\n   senders MUST treat the smart host domain as the Policy
      Domain for the\n   purposes of policy discovery and application.  This specification\n
      \  does not provide a means of associating policies with email addresses\n   that
      employ Address Literals [RFC5321].\n   When sending mail to a mailbox at a subdomain,
      compliant senders MUST\n   NOT attempt to fetch a policy from the parent zone.
      \ Thus, for mail\n   sent to \"user@mail.example.com\", the policy can be fetched
      only from\n   \"mail.example.com\", not \"example.com\".\n"
    title: 3.4.  Policy Selection for Smart Hosts and Subdomains
  title: 3.  Policy Discovery
- contents:
  - "4.  Policy Validation\n   When sending to an MX at a domain for which the sender
    has a valid\n   and non-expired MTA-STS Policy, a Sending MTA honoring MTA-STS
    MUST\n   check whether:\n   1.  At least one of the policy's \"mx\" patterns matches
    the selected\n       MX host, as described in Section 4.1, \"MX Host Validation\".\n
    \  2.  The recipient mail server supports STARTTLS and offers a PKIX-\n       based
    TLS certificate, during TLS handshake, which is valid for\n       that host, as
    described in Section 4.2, \"Recipient MTA\n       Certificate Validation\".\n
    \  When these conditions are not met, a policy is said to fail to\n   validate.
    \ This section does not dictate the behavior of Sending MTAs\n   when the above
    conditions are not met; see Section 5, \"Policy\n   Application\", for a description
    of Sending MTA behavior when policy\n   validation fails.\n"
  - contents:
    - "4.1.  MX Host Validation\n   A receiving candidate MX host is valid according
      to an applied MTA-\n   STS Policy if the MX record name matches one or more
      of the \"mx\"\n   fields in the applied policy.  Matching is identical to the
      rules\n   given in [RFC6125], with the restriction that the wildcard character\n
      \  '*' may only be used to match the entire left-most label in the\n   presented
      identifier.  Thus, the mx pattern \"*.example.com\" matches\n   \"mail.example.com\"
      but not \"example.com\" or \"foo.bar.example.com\".\n"
    title: 4.1.  MX Host Validation
  - contents:
    - "4.2.  Recipient MTA Certificate Validation\n   The certificate presented by
      the receiving MTA MUST not be expired\n   and MUST chain to a root CA that is
      trusted by the Sending MTA.  The\n   certificate MUST have a subject alternative
      name (SAN) [RFC5280] with\n   a DNS-ID [RFC6125] matching the hostname, per
      the rules given in\n   [RFC6125].  The MX's certificate MAY also be checked
      for revocation\n   via OCSP [RFC6960], CRLs [RFC6818], or some other mechanism.\n"
    title: 4.2.  Recipient MTA Certificate Validation
  title: 4.  Policy Validation
- contents:
  - "5.  Policy Application\n   When sending to an MX at a domain for which the sender
    has a valid,\n   non-expired MTA-STS Policy, a Sending MTA honoring MTA-STS applies\n
    \  the result of a policy validation failure in one of two ways,\n   depending
    on the value of the policy \"mode\" field:\n   1.  \"enforce\": In this mode,
    Sending MTAs MUST NOT deliver the\n       message to hosts that fail MX matching
    or certificate validation\n       or that do not support STARTTLS.\n   2.  \"testing\":
    In this mode, Sending MTAs that also implement the\n       TLSRPT (TLS Reporting)
    specification [RFC8460] send a report\n       indicating policy application failures
    (as long as TLSRPT is also\n       implemented by the recipient domain); in any
    case, messages may\n       be delivered as though there were no MTA-STS validation
    failure.\n   3.  \"none\": In this mode, Sending MTAs should treat the Policy
    Domain\n       as though it does not have any active policy; see Section 8.3,\n
    \      \"Removing MTA-STS\", for use of this mode value.\n   When a message fails
    to deliver due to an \"enforce\" policy, a\n   compliant MTA MUST NOT permanently
    fail to deliver messages before\n   checking, via DNS, for the presence of an
    updated policy at the\n   Policy Domain.  (In all cases, MTAs SHOULD treat such
    failures as\n   transient errors and retry delivery later.)  This allows implementing\n
    \  domains to update long-lived policies on the fly.\n"
  - contents:
    - "5.1.  Policy Application Control Flow\n   An example control flow for a compliant
      sender consists of the\n   following steps:\n   1.  Check for a cached policy
      whose time-since-fetch has not exceeded\n       its \"max_age\".  If none exists,
      attempt to fetch a new policy\n       (perhaps asynchronously, so as not to
      block message delivery).\n       Optionally, Sending MTAs may unconditionally
      check for a new\n       policy at this step.\n   2.  For each candidate MX,
      in order of MX priority, attempt to\n       deliver the message.  If a policy
      is present with an \"enforce\"\n       mode, when attempting to deliver to each
      candidate MX, ensure\n       STARTTLS support and host identity validity as
      described in\n       Section 4, \"Policy Validation\".  If a candidate fails
      validation,\n       continue to the next candidate (if there is one).\n   3.
      \ A message delivery attempt MUST NOT be permanently failed until\n       the
      sender has first checked for the presence of a new policy (as\n       indicated
      by the \"id\" field in the \"_mta-sts\" TXT record).  If a\n       new policy
      is not found, existing rules for the case of temporary\n       message delivery
      failures apply (as discussed in [RFC5321],\n       Section 4.5.4.1).\n"
    title: 5.1.  Policy Application Control Flow
  title: 5.  Policy Application
- contents:
  - "6.  Reporting Failures\n   MTA-STS is intended to be used along with TLSRPT [RFC8460]
    in order\n   to ensure that implementing domains can detect cases of both benign\n
    \  and malicious failures and to ensure that failures that indicate an\n   active
    attack are discoverable.  As such, senders that also implement\n   TLSRPT SHOULD
    treat the following events as reportable failures:\n   o  HTTPS policy fetch failures
    when a valid TXT record is present.\n   o  Policy fetch failures of any kind when
    a valid policy exists in\n      the policy cache, except if that policy's mode
    is \"none\".\n   o  Delivery attempts in which a contacted MX does not support\n
    \     STARTTLS or does not present a certificate that validates\n      according
    to the applied policy, except if that policy's mode is\n      \"none\".\n"
  title: 6.  Reporting Failures
- contents:
  - '7.  Interoperability Considerations

    '
  - contents:
    - "7.1.  SNI Support\n   To ensure that the server sends the right certificate
      chain, the SMTP\n   client MUST have support for the TLS Server Name Indication
      (SNI)\n   extension [RFC6066].  When connecting to an HTTP server to retrieve\n
      \  the MTA-STS Policy, the SNI extension MUST contain the name of the\n   Policy
      Host (e.g., \"mta-sts.example.com\").  When connecting to an\n   SMTP server,
      the SNI extension MUST contain the MX hostname.\n   HTTP servers used to deliver
      MTA-STS policies MAY rely on SNI to\n   determine which certificate chain to
      present to the client.  HTTP\n   servers MUST respond with a certificate chain
      that matches the policy\n   hostname or abort the TLS handshake if unable to
      do so.  Clients that\n   do not send SNI information may not see the expected
      certificate\n   chain.\n   SMTP servers MAY rely on SNI to determine which certificate
      chain to\n   present to the client.  However, servers that have one identity
      and a\n   single matching certificate do not require SNI support.  Servers MUST\n
      \  NOT enforce the use of SNI by clients, as the client may be using\n   unauthenticated
      opportunistic TLS and may not expect any particular\n   certificate from the
      server.  If the client sends no SNI extension or\n   sends an SNI extension
      for an unsupported server name, the server\n   MUST simply send a fallback certificate
      chain of its choice.  The\n   reason for not enforcing strict matching of the
      requested SNI\n   hostname is that MTA-STS TLS clients may be typically willing
      to\n   accept multiple server names but can only send one name in the SNI\n
      \  extension.  The server's fallback certificate may match a different\n   name
      that is acceptable to the client, e.g., the original next-hop\n   domain.\n"
    title: 7.1.  SNI Support
  - contents:
    - "7.2.  Minimum TLS Version Support\n   MTAs supporting MTA-STS MUST have support
      for TLS 1.2 [RFC5246] or\n   TLS 1.3 [RFC8446] or higher.  The general TLS usage
      guidance in\n   [RFC7525] SHOULD be followed.\n"
    title: 7.2.  Minimum TLS Version Support
  title: 7.  Interoperability Considerations
- contents:
  - '8.  Operational Considerations

    '
  - contents:
    - "8.1.  Policy Updates\n   Updating the policy requires that the owner make changes
      in two\n   places: the \"_mta-sts\" TXT record in the Policy Domain's DNS zone
      and\n   at the corresponding HTTPS endpoint.  As a result, recipients should\n
      \  expect that a policy will continue to be used by senders until both\n   the
      HTTPS and TXT endpoints are updated and the TXT record's TTL has\n   passed.\n
      \  In other words, a sender who is unable to successfully deliver a\n   message
      while applying a cache of the recipient's now-outdated policy\n   may be unable
      to discover that a new policy exists until the DNS TTL\n   has passed.  Recipients
      SHOULD therefore ensure that old policies\n   continue to work for message delivery
      during this period of time, or\n   risk message delays.\n   Recipients SHOULD
      also update the HTTPS policy body before updating\n   the TXT record; this ordering
      avoids the risk that senders, seeing a\n   new TXT record, mistakenly cache
      the old policy from HTTPS.\n"
    title: 8.1.  Policy Updates
  - contents:
    - "8.2.  Policy Delegation\n   Domain owners commonly delegate SMTP hosting to
      a different\n   organization, such as an ISP or a web host.  In such a case,
      they may\n   wish to also delegate the MTA-STS Policy to the same organization,\n
      \  which can be accomplished with two changes.\n   First, the Policy Domain
      must point the \"_mta-sts\" record, via CNAME,\n   to the \"_mta-sts\" record
      maintained by the provider.  This allows the\n   provider to control update
      signaling.\n   Second, the Policy Domain must point the \"well-known\" policy
      location\n   to the provider.  This can be done either by setting the \"mta-sts\"\n
      \  record to an IP address or CNAME specified by the provider and by\n   giving
      the provider a TLS certificate that is valid for that host or\n   by setting
      up a \"reverse proxy\" (also known as a \"gateway\") server\n   for the Policy
      Domain's Policy Host, configured to serve proxied\n   responses from the Policy
      Host of the provider.\n   For example, given a user domain \"user.example\"
      hosted by a mail\n   provider \"provider.example\", the following configuration
      would allow\n   policy delegation:\n   DNS:\n        _mta-sts.user.example.
      \ IN CNAME _mta-sts.provider.example.\n   Policy:\n         > GET /.well-known/mta-sts.txt
      Host: mta-sts.user.example\n         < HTTP/1.1 200 OK  # Response proxies content
      from\n                            # https://mta-sts.provider.example\n   Note
      that in all such cases, the policy endpoint\n   (\"https://mta-sts.user.example/.well-known/mta-sts.txt\"
      in this\n   example) must still present a certificate valid for the Policy Host\n
      \  (\"mta-sts.user.example\"), and not for that host at the provider's\n   domain
      (\"mta-sts.provider.example\").\n   Note that while Sending MTAs MUST NOT use
      HTTP caching when fetching\n   policies via HTTPS, such caching may nonetheless
      be useful to a\n   reverse proxy configured as described in this section.  An
      HTTPS\n   policy endpoint expecting to be proxied for multiple hosted domains\n
      \  -- as with a large mail hosting provider or similar -- may wish to\n   indicate
      an HTTP Cache-Control \"max-age\" response directive (as\n   specified in [RFC7234])
      of 60 seconds as a reasonable value to save\n   reverse proxies an unnecessarily
      high-rate of proxied policy\n   fetching.\n"
    title: 8.2.  Policy Delegation
  - contents:
    - "8.3.  Removing MTA-STS\n   In order to facilitate clean opt-out of MTA-STS
      by implementing\n   Policy Domains, and to distinguish clearly between failures
      that\n   indicate attacks and those that indicate such opt-outs, MTA-STS\n   implements
      the \"none\" mode, which allows validated policies to\n   indicate authoritatively
      that the Policy Domain wishes to no longer\n   implement MTA-STS and may, in
      the future, remove the MTA-STS TXT and\n   policy endpoints entirely.\n   A
      suggested workflow to implement such an opt out is as follows:\n   1.  Publish
      a new policy with \"mode\" equal to \"none\" and a small\n       \"max_age\"
      (e.g., one day).\n   2.  Publish a new TXT record to trigger fetching of the
      new policy.\n   3.  When all previously served policies have expired -- normally
      this\n       is the time the previously published policy was last served plus\n
      \      that policy's \"max_age\", but note that policies older than the\n       previously
      published policy may have been served with a greater\n       \"max_age\" than
      the previously published policy, allowing\n       overlapping policy caches
      -- safely remove the TXT record and\n       HTTPS endpoint.\n"
    title: 8.3.  Removing MTA-STS
  - contents:
    - "8.4.  Preserving MX Candidate Traversal\n   Implementers of send-time MTA-STS
      validation in mail transfer agents\n   should take note of the risks of modifying
      the logic of traversing MX\n   candidate lists.  Because an MTA-STS Policy can
      be used to prefilter\n   invalid MX candidates from the MX candidate list, it
      is tempting to\n   implement a \"two-pass\" model, where MX candidates are first
      filtered\n   for possible validity according to the MTA-STS Policy, and then
      the\n   remaining candidates are attempted in order as without an MTA-STS\n
      \  Policy.  This may lead to incorrect implementations, such as message\n   loops;
      instead, it is recommended that implementers traverse the MX\n   candidate list
      as usual, and treat invalid candidates as though they\n   were unreachable (i.e.,
      as though there were some transient error\n   when trying to deliver to that
      candidate).\n   One consequence of validating MX hosts in order of ordinary
      candidate\n   traversal is that in the event a higher-priority MX is MTA-STS
      valid\n   and a lower-priority MX is not, senders may never encounter the\n
      \  lower-priority MX, leading to a risk that policy misconfigurations\n   that
      apply only to \"backup\" MXes may only be discovered in the case\n   of primary
      MX failure.\n"
    title: 8.4.  Preserving MX Candidate Traversal
  title: 8.  Operational Considerations
- contents:
  - '9.  IANA Considerations

    '
  - contents:
    - "9.1.  Well-Known URIs Registry\n   A new \"well-known\" URI as described in
      Section 3 has been registered\n   in the \"Well-Known URIs\" registry as described
      below:\n   URI Suffix: mta-sts.txt\n   Change Controller: IETF\n"
    title: 9.1.  Well-Known URIs Registry
  - contents:
    - "9.2.  MTA-STS TXT Record Fields\n   IANA has created a new registry titled
      \"MTA-STS TXT Record Fields\".\n   The initial entries in the registry are:\n
      \      +------------+--------------------+-------------------------+\n       |
      Field Name | Description        | Reference               |\n       +------------+--------------------+-------------------------+\n
      \      | v          | Record version     | Section 3.1 of RFC 8461 |\n       |
      id         | Policy instance ID | Section 3.1 of RFC 8461 |\n       +------------+--------------------+-------------------------+\n
      \  New fields are added to this registry using IANA's \"Expert Review\"\n   policy
      [RFC8126].\n"
    title: 9.2.  MTA-STS TXT Record Fields
  - contents:
    - "9.3.  MTA-STS Policy Fields\n   IANA has created a new registry titled \"MTA-STS
      Policy Fields\".  The\n   initial entries in the registry are:\n      +------------+----------------------+-------------------------+\n
      \     | Field Name | Description          | Reference               |\n      +------------+----------------------+-------------------------+\n
      \     | version    | Policy version       | Section 3.2 of RFC 8461 |\n      |
      mode       | Enforcement behavior | Section 3.2 of RFC 8461 |\n      | max_age
      \   | Policy lifetime      | Section 3.2 of RFC 8461 |\n      | mx         |
      MX identities        | Section 3.2 of RFC 8461 |\n      +------------+----------------------+-------------------------+\n
      \  New fields are added to this registry using IANA's \"Expert Review\"\n   policy.\n"
    title: 9.3.  MTA-STS Policy Fields
  title: 9.  IANA Considerations
- contents:
  - "10.  Security Considerations\n   SMTP MTA-STS attempts to protect against an
    active attacker trying to\n   intercept or tamper with mail between hosts that
    support STARTTLS.\n   There are two classes of attacks considered:\n   o  Foiling
    TLS negotiation (for example, by deleting the \"250\n      STARTTLS\" response
    from a server or altering TLS session\n      negotiation).  This would result
    in the SMTP session occurring\n      over plaintext, despite both parties supporting
    TLS.\n   o  Impersonating the destination mail server, whereby the sender\n      might
    deliver the message to an impostor, who could then monitor\n      and/or modify
    messages despite opportunistic TLS.  This\n      impersonation could be accomplished
    by spoofing the DNS MX record\n      for the recipient domain or by redirecting
    client connections\n      intended for the legitimate recipient server (for example,
    by\n      altering BGP routing tables).\n   MTA-STS can thwart such attacks only
    if the sender is able to\n   previously obtain and cache a policy for the recipient
    domain, and\n   only if the attacker is unable to obtain a valid certificate that\n
    \  complies with that policy.  Below, we consider specific attacks on\n   this
    model.\n"
  - contents:
    - "10.1.  Obtaining a Signed Certificate\n   SMTP MTA-STS relies on certificate
      validation via PKIX-based TLS\n   identity checking [RFC6125].  Attackers who
      are able to obtain a\n   valid certificate for the targeted recipient mail service
      (e.g., by\n   compromising a CA) are thus able to circumvent STS authentication.\n"
    title: 10.1.  Obtaining a Signed Certificate
  - contents:
    - "10.2.  Preventing Policy Discovery\n   Since MTA-STS uses DNS TXT records for
      policy discovery, an attacker\n   who is able to block DNS responses can suppress
      the discovery of an\n   MTA-STS Policy, making the Policy Domain appear not
      to have an MTA-\n   STS Policy.  The sender policy cache is designed to resist
      this\n   attack by decreasing the frequency of policy discovery and thus\n   reducing
      the window of vulnerability; it is nonetheless a risk that\n   attackers who
      can predict or induce policy discovery -- for example,\n   by inducing a sending
      domain to send mail to a never-before-contacted\n   recipient while carrying
      out a man-in-the-middle attack -- may be\n   able to foil policy discovery and
      effectively downgrade the security\n   of the message delivery.\n   Since this
      attack depends upon intercepting initial policy discovery,\n   implementers
      SHOULD prefer policy \"max_age\" values to be as long as\n   is practical.\n
      \  Because this attack is also possible upon refresh of a cached policy,\n   implementers
      SHOULD NOT wait until a cached policy has expired before\n   checking for an
      update; if senders attempt to refresh the cache\n   regularly (for example,
      by fetching the current live policy in a\n   background task that runs daily
      or weekly, regardless of the state of\n   the \"_mta-sts\" TXT record, and updating
      their cache's \"max age\"\n   accordingly), an attacker would have to foil policy
      discovery\n   consistently over the lifetime of a cached policy to prevent a\n
      \  successful refresh.\n   Additionally, MTAs SHOULD alert administrators to
      repeated policy\n   refresh failures long before cached policies expire (through
      warning\n   logs or similar applicable mechanisms), allowing administrators
      to\n   detect such a persistent attack on policy refresh.  (However, they\n
      \  should not implement such alerts if the cached policy has a \"none\"\n   mode,
      to allow clean MTA-STS removal, as described in Section 8.3.)\n   Resistance
      to downgrade attacks of this nature -- due to the ability\n   to authoritatively
      determine \"lack of a record\" even for non-\n   participating recipients --
      is a feature of DANE, due to its use of\n   DNSSEC for policy discovery.\n"
    title: 10.2.  Preventing Policy Discovery
  - contents:
    - "10.3.  Denial of Service\n   We additionally consider the Denial-of-Service
      risk posed by an\n   attacker who can modify the DNS records for a recipient
      domain.\n   Absent MTA-STS, such an attacker can cause a Sending MTA to cache\n
      \  invalid MX records, but only for however long the sending resolver\n   caches
      those records.  With MTA-STS, the attacker can additionally\n   advertise a
      new, long \"max_age\" MTA-STS Policy with \"mx\" constraints\n   that validate
      the malicious MX record, causing senders to cache the\n   policy and refuse
      to deliver messages once the victim has resecured\n   the MX records.\n   This
      attack is mitigated in part by the ability of a victim domain to\n   (at any
      time) publish a new policy updating the cached, malicious\n   policy, though
      this does require the victim domain to both obtain a\n   valid CA-signed certificate
      and to understand and properly configure\n   MTA-STS.\n   Similarly, we consider
      the possibility of domains that deliberately\n   allow untrusted users to serve
      untrusted content on user-specified\n   subdomains.  In some cases (e.g., the
      service \"tumblr.com\"), this\n   takes the form of providing HTTPS hosting
      of user-registered\n   subdomains; in other cases (e.g. dynamic DNS providers),
      this takes\n   the form of allowing untrusted users to register custom DNS records\n
      \  at the provider's domain.\n   In these cases, there is a risk that untrusted
      users would be able to\n   serve custom content at the \"mta-sts\" host, including
      serving an\n   illegitimate MTA-STS Policy.  We believe this attack is rendered
      more\n   difficult by the need for the attacker to also serve the \"_mta-sts\"\n
      \  TXT record on the same domain -- something not, to our knowledge,\n   widely
      provided to untrusted users.  This attack is additionally\n   mitigated by the
      aforementioned ability for a victim domain to update\n   an invalid policy at
      any future date.\n"
    title: 10.3.  Denial of Service
  - contents:
    - "10.4.  Weak Policy Constraints\n   Even if an attacker cannot modify a served
      policy, the potential\n   exists for configurations that allow attackers on
      the same domain to\n   receive mail for that domain.  For example, an easy configuration\n
      \  option when authoring an MTA-STS Policy for \"example.com\" is to set\n   the
      \"mx\" equal to \"*.example.com\"; in this case, recipient domains\n   must
      consider the risk that any user possessing a valid hostname and\n   CA-signed
      certificate (for example, \"dhcp-123.example.com\") will,\n   from the perspective
      of MTA-STS Policy validation, be a valid MX host\n   for that domain.\n"
    title: 10.4.  Weak Policy Constraints
  - contents:
    - "10.5.  Compromise of the Web PKI System\n   A number of risks apply to the
      PKI system that is used for\n   certificate authentication, both of the \"mta-sts\"
      HTTPS host's\n   certificate and the SMTP servers' certificates.  These risks
      are\n   broadly applicable within the Web PKI ecosystem and are not specific\n
      \  to MTA-STS; nonetheless, they deserve some consideration in this\n   context.\n
      \  Broadly speaking, attackers may compromise the system by obtaining\n   certificates
      under fraudulent circumstances (i.e., by impersonating\n   the legitimate owner
      of the victim domain), by compromising a CA or\n   Delegate Authority's private
      keys, by obtaining a legitimate\n   certificate issued to the victim domain,
      and similar.\n   One approach commonly employed by web browsers to help mitigate\n
      \  against some of these attacks is to allow for revocation of\n   compromised
      or fraudulent certificates via OCSP [RFC6960] or CRLs\n   [RFC6818].  Such mechanisms
      themselves represent trade-offs and are\n   not universally implemented; we
      nonetheless recommend implementers of\n   MTA-STS to implement revocation mechanisms
      that are most applicable\n   to their implementations.\n"
    title: 10.5.  Compromise of the Web PKI System
  title: 10.  Security Considerations
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818,\n              DOI
      10.17487/RFC2818, May 2000,\n              <https://www.rfc-editor.org/info/rfc2818>.\n
      \  [RFC3207]  Hoffman, P., \"SMTP Service Extension for Secure SMTP over\n              Transport
      Layer Security\", RFC 3207, DOI 10.17487/RFC3207,\n              February 2002,
      <https://www.rfc-editor.org/info/rfc3207>.\n   [RFC3492]  Costello, A., \"Punycode:
      A Bootstring encoding of Unicode\n              for Internationalized Domain
      Names in Applications\n              (IDNA)\", RFC 3492, DOI 10.17487/RFC3492,
      March 2003,\n              <https://www.rfc-editor.org/info/rfc3492>.\n   [RFC3629]
      \ Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\",
      STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n              2003, <https://www.rfc-editor.org/info/rfc3629>.\n
      \  [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n
      \             Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,
      January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n   [RFC5246]
      \ Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5280]
      \ Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate
      and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, DOI
      10.17487/RFC5280, May 2008,\n              <https://www.rfc-editor.org/info/rfc5280>.\n
      \  [RFC5321]  Klensin, J., \"Simple Mail Transfer Protocol\", RFC 5321,\n              DOI
      10.17487/RFC5321, October 2008,\n              <https://www.rfc-editor.org/info/rfc5321>.\n
      \  [RFC5785]  Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known\n              Uniform
      Resource Identifiers (URIs)\", RFC 5785,\n              DOI 10.17487/RFC5785,
      April 2010,\n              <https://www.rfc-editor.org/info/rfc5785>.\n   [RFC6066]
      \ Eastlake 3rd, D., \"Transport Layer Security (TLS)\n              Extensions:
      Extension Definitions\", RFC 6066,\n              DOI 10.17487/RFC6066, January
      2011,\n              <https://www.rfc-editor.org/info/rfc6066>.\n   [RFC6125]
      \ Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification
      of Domain-Based Application Service Identity\n              within Internet
      Public Key Infrastructure Using X.509\n              (PKIX) Certificates in
      the Context of Transport Layer\n              Security (TLS)\", RFC 6125, DOI
      10.17487/RFC6125, March\n              2011, <https://www.rfc-editor.org/info/rfc6125>.\n
      \  [RFC7405]  Kyzivat, P., \"Case-Sensitive String Support in ABNF\",\n              RFC
      7405, DOI 10.17487/RFC7405, December 2014,\n              <https://www.rfc-editor.org/info/rfc7405>.\n
      \  [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations
      for Secure Use of Transport Layer\n              Security (TLS) and Datagram
      Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,
      May\n              2015, <https://www.rfc-editor.org/info/rfc7525>.\n   [RFC8174]
      \ Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8446]  Rescorla, E., \"The
      Transport Layer Security (TLS) Protocol\n              Version 1.3\", RFC 8446,
      DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n
      \  [RFC8460]  Margolis, D., Brotman, A., Ramakrishnan, B., Jones, J.,\n              and
      M. Risher, \"SMTP TLS Reporting\", RFC 8460,\n              DOI 10.17487/RFC8460,
      September 2018,\n              <https://www.rfc-editor.org/info/rfc8460>.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [RFC4033]  Arends, R., Austein, R., Larson,
      M., Massey, D., and S.\n              Rose, \"DNS Security Introduction and
      Requirements\",\n              RFC 4033, DOI 10.17487/RFC4033, March 2005,\n
      \             <https://www.rfc-editor.org/info/rfc4033>.\n   [RFC5322]  Resnick,
      P., Ed., \"Internet Message Format\", RFC 5322,\n              DOI 10.17487/RFC5322,
      October 2008,\n              <https://www.rfc-editor.org/info/rfc5322>.\n   [RFC5891]
      \ Klensin, J., \"Internationalized Domain Names in\n              Applications
      (IDNA): Protocol\", RFC 5891,\n              DOI 10.17487/RFC5891, August 2010,\n
      \             <https://www.rfc-editor.org/info/rfc5891>.\n   [RFC6818]  Yee,
      P., \"Updates to the Internet X.509 Public Key\n              Infrastructure
      Certificate and Certificate Revocation List\n              (CRL) Profile\",
      RFC 6818, DOI 10.17487/RFC6818, January\n              2013, <https://www.rfc-editor.org/info/rfc6818>.\n
      \  [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,\n              Galperin,
      S., and C. Adams, \"X.509 Internet Public Key\n              Infrastructure
      Online Certificate Status Protocol - OCSP\",\n              RFC 6960, DOI 10.17487/RFC6960,
      June 2013,\n              <https://www.rfc-editor.org/info/rfc6960>.\n   [RFC7234]
      \ Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n              Ed.,
      \"Hypertext Transfer Protocol (HTTP/1.1): Caching\",\n              RFC 7234,
      DOI 10.17487/RFC7234, June 2014,\n              <https://www.rfc-editor.org/info/rfc7234>.\n
      \  [RFC7672]  Dukhovni, V. and W. Hardaker, \"SMTP Security via\n              Opportunistic
      DNS-Based Authentication of Named Entities\n              (DANE) Transport Layer
      Security (TLS)\", RFC 7672,\n              DOI 10.17487/RFC7672, October 2015,\n
      \             <https://www.rfc-editor.org/info/rfc7672>.\n   [RFC8126]  Cotton,
      M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing an IANA
      Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI 10.17487/RFC8126,
      June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Appendix A.  MTA-STS Example Record and Policy\n   The owner of \"example.com\"
    wishes to begin using MTA-STS with a\n   policy that will solicit reports from
    senders without affecting how\n   the messages are processed, in order to verify
    the identity of MXes\n   that handle mail for \"example.com\", confirm that TLS
    is correctly\n   used, and ensure that certificates presented by the recipient
    MX\n   validate.\n   MTA-STS Policy indicator TXT RR:\n       _mta-sts.example.com.
    \ IN TXT \"v=STSv1; id=20160831085700Z;\"\n   MTA-STS Policy file served as the
    response body at\n   \"https://mta-sts.example.com/.well-known/mta-sts.txt\":\n
    \                        version: STSv1\n                         mode: testing\n
    \                        mx: mx1.example.com\n                         mx: mx2.example.com\n
    \                        mx: mx.backup-example.com\n                         max_age:
    1296000\n"
  title: Appendix A.  MTA-STS Example Record and Policy
- contents:
  - "Appendix B.  Message Delivery Pseudocode\n   Below is pseudocode demonstrating
    the logic of a compliant Sending\n   MTA.\n   While this pseudocode implementation
    suggests synchronous policy\n   retrieval in the delivery path, that may be undesirable
    in a working\n   implementation, and we expect some implementers to instead prefer
    a\n   background fetch that does not block delivery when no cached policy\n   is
    present.\n   func isEnforce(policy) {\n     // Return true if the policy mode
    is \"enforce\".\n   }\n   func isNonExpired(policy) {\n     // Return true if
    the policy is not expired.\n   }\n   func tryStartTls(connection) {\n     // Attempt
    to open an SMTP STARTTLS connection with the MX.\n   }\n   func certMatches(connection,
    host) {\n     // Assume a handy function to return if the server\n     // certificate
    presented in \"connection\" is valid for \"host\".\n   }\n   func policyMatches(candidate,
    policy) {\n     for mx in policy.mx {\n       // Literal match.\n       if mx
    == candidate {\n         return true\n       }\n       // Wildcard matches only
    the leftmost label.\n       // Wildcards must always be followed by a '.'.\n       if
    mx[0] == '*' {\n         parts = SplitN(candidate, '.', 2)  // Split on the first
    '.'.\n         if len(parts) > 1 && parts[1] == mx[2:] {\n           return true\n
    \        }\n       }\n     }\n     return false\n   }\n   func tryDeliverMail(connection,
    message) {\n     // Attempt to deliver \"message\" via \"connection\".\n   }\n
    \  func tryGetNewPolicy(domain) {\n     // Check for an MTA-STS TXT record for
    \"domain\" in DNS, and return\n     // the indicated policy.\n   }\n   func cachePolicy(domain,
    policy) {\n     // Store \"policy\" as the cached policy for \"domain\".\n   }\n
    \  func tryGetCachedPolicy(domain) {\n     // Return a cached policy for \"domain\".\n
    \  }\n   func reportError(error) {\n     // Report an error via TLSRPT.\n   }\n
    \  func tryMxAccordingTo(message, mx, policy) {\n     connection := connect(mx)\n
    \    if !connection {\n       return false  // Can't connect to the MX, so it's
    not an MTA-STS\n                     // error.\n     }\n     secure := true\n
    \    if !policyMatches(mx, policy) {\n       secure = false\n       reportError(E_HOST_MISMATCH)\n
    \    } else if !tryStartTls(connection) {\n       secure = false\n       reportError(E_NO_VALID_TLS)\n
    \    } else if !certMatches(connection, policy) {\n       secure = false\n       reportError(E_CERT_MISMATCH)\n
    \    }\n     if secure || !isEnforce(policy) {\n       return tryDeliverMail(connection,
    message)\n     }\n     return false\n   }\n   func tryWithPolicy(message, domain,
    policy) {\n     mxes := getMxForDomain(domain)\n     for mx in mxes {\n       if
    tryMxAccordingTo(message, mx, policy) {\n         return true\n       }\n     }\n
    \    return false\n   }\n   func handleMessage(message) {\n     domain := ...
    // domain part after '@' from recipient\n     policy := tryGetNewPolicy(domain)\n
    \    if policy {\n       cachePolicy(domain, policy)\n     } else {\n       policy
    = tryGetCachedPolicy(domain)\n     }\n     if policy {\n       return tryWithPolicy(message,
    domain, policy)\n     }\n     // Try to deliver the message normally (i.e., without
    MTA-STS).\n   }\n"
  title: Appendix B.  Message Delivery Pseudocode
- contents:
  - "Contributors\n   Wei Chuang\n   Google, Inc.\n   weihaw@google.com\n   Viktor
    Dukhovni\n   ietf-dane@dukhovni.de\n   Markus Laber\n   1&1 Mail & Media Development
    & Technology GmbH\n   markus.laber@1und1.de\n   Nicolas Lidzborski\n   Google,
    Inc.\n   nlidz@google.com\n   Brandon Long\n   Google, Inc.\n   blong@google.com\n
    \  Franck Martin\n   LinkedIn, Inc.\n   fmartin@linkedin.com\n   Klaus Umbach\n
    \  1&1 Mail & Media Development & Technology GmbH\n   klaus.umbach@1und1.de\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Daniel Margolis\n   Google, Inc.\n   Email: dmargolis@google.com\n
    \  Mark Risher\n   Google, Inc.\n   Email: risher@google.com\n   Binu Ramakrishnan\n
    \  Oath, Inc.\n   Email: prbinu@yahoo.com\n   Alexander Brotman\n   Comcast, Inc.\n
    \  Email: alex_brotman@comcast.com\n   Janet Jones\n   Microsoft, Inc.\n   Email:
    janet.jones@microsoft.com\n"
  title: Authors' Addresses
