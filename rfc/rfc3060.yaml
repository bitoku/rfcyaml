- contents:
  - '        Policy Core Information Model -- Version 1 Specification

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document presents the object-oriented information model for\n
    \  representing policy information developed jointly in the IETF Policy\n   Framework
    WG and as extensions to the Common Information Model (CIM)\n   activity in the
    Distributed Management Task Force (DMTF).  This model\n   defines two hierarchies
    of object classes:  structural classes\n   representing policy information and
    control of policies, and\n   association classes that indicate how instances of
    the structural\n   classes are related to each other. Subsequent documents will
    define\n   mappings of this information model to various concrete\n   implementations,
    for example, to a directory that uses LDAPv3 as its\n   access protocol.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction....................................................
    4\n   2. Modeling Policies............................................... 5\n
    \     2.1. Policy Scope............................................... 8\n      2.2.
    Declarative versus Procedural Model........................ 8\n   3. Overview
    of the Policy Core Information Model.................. 10\n   4. Inheritance Hierarchies
    for the Policy Core Information Model.. 13\n      4.1. Implications of CIM Inheritance...........................
    15\n   5. Details of the Model........................................... 15\n
    \     5.1. Reusable versus Rule-Specific Conditions and Actions...... 15\n      5.2.
    Roles..................................................... 17\n      5.2.1. Roles
    and Role Combinations............................. 17\n      5.2.2. The PolicyRoles
    Property................................ 21\n      5.3. Local Time and UTC Time
    in PolicyTimePeriodConditions..... 21\n      5.4. CIM Data Types............................................
    23\n      5.5. Comparison between CIM and LDAP Class Specifications...... 24\n
    \  6. Class Definitions.............................................. 25\n      6.1.
    The Abstract Class \"Policy\"............................... 25\n      6.1.1.
    The Property \"CommonName (CN)\".......................... 26\n      6.1.2. The
    Multi-valued Property \"PolicyKeywords\".............. 26\n      6.1.3. The Property
    \"Caption\" (Inherited from ManagedElement).. 27\n      6.1.4. The Property \"Description\"
    (Inherited from\n             ManagedElement).........................................
    27\n      6.2. The Class \"PolicyGroup\"................................... 27\n
    \     6.3. The Class \"PolicyRule\".................................... 29\n      6.3.1.
    The Property \"Enabled\".................................. 31\n      6.3.2. The
    Property \"ConditionListType\"........................ 31\n      6.3.3. The Property
    \"RuleUsage\"................................ 31\n      6.3.4. The Property \"Priority\".................................
    32\n      6.3.5. The Property \"Mandatory\"................................ 32\n
    \     6.3.6. The Property \"SequencedActions\"......................... 33\n      6.3.7.
    The Multi-valued Property \"PolicyRoles\"................. 33\n      6.4. The
    Abstract Class \"PolicyCondition\"...................... 34\n      6.5. The Class
    \"PolicyTimePeriodCondition\"..................... 36\n      6.5.1. The Property
    \"TimePeriod\"............................... 38\n      6.5.2. The Property \"MonthOfYearMask\"..........................
    39\n      6.5.3. The Property \"DayOfMonthMask\"........................... 39\n
    \     6.5.4. The Property \"DayOfWeekMask\"............................ 40\n      6.5.5.
    The Property \"TimeOfDayMask\"............................ 41\n      6.5.6. The
    Property \"LocalOrUtcTime\"........................... 42\n      6.6. The Class
    \"VendorPolicyCondition\"......................... 42\n      6.6.1. The Multi-valued
    Property \"Constraint\".................. 43\n      6.6.2. The Property \"ConstraintEncoding\".......................
    43\n      6.7. The Abstract Class \"PolicyAction\"......................... 44\n
    \     6.8. The Class \"VendorPolicyAction\"............................ 45\n      6.8.1.
    The Multi-valued Property \"ActionData\".................. 45\n      6.8.2. The
    Property \"ActionEncoding\"........................... 46\n      6.9. The Class
    \"PolicyRepository\".............................. 46\n   7. Association and Aggregation
    Definitions........................ 46\n      7.1. Associations..............................................
    47\n      7.2. Aggregations.............................................. 47\n
    \     7.3. The Abstract Aggregation \"PolicyComponent................. 47\n      7.4.
    The Aggregation \"PolicyGroupInPolicyGroup\"................ 47\n      7.4.1.
    The Reference \"GroupComponent\".......................... 48\n      7.4.2. The
    Reference \"PartComponent\"........................... 48\n      7.5. The Aggregation
    \"PolicyRuleInPolicyGroup\"................. 48\n      7.5.1. The Reference \"GroupComponent\"..........................
    49\n      7.5.2. The Reference \"PartComponent\"........................... 49\n
    \     7.6. The Aggregation \"PolicyConditionInPolicyRule\"............. 49\n      7.6.1.
    The Reference \"GroupComponent\".......................... 50\n      7.6.2. The
    Reference \"PartComponent\"........................... 50\n      7.6.3. The Property
    \"GroupNumber\".............................. 50\n      7.6.4. The Property \"ConditionNegated\".........................
    51\n      7.7. The Aggregation \"PolicyRuleValidityPeriod\"................ 51\n
    \     7.7.1. The Reference \"GroupComponent\".......................... 52\n      7.7.2.
    The Reference \"PartComponent\"........................... 52\n      7.8. The
    Aggregation \"PolicyActionInPolicyRule\"................ 52\n      7.8.1. The
    Reference \"GroupComponent\".......................... 53\n      7.8.2. The Reference
    \"PartComponent\"........................... 53\n      7.8.3. The Property \"ActionOrder\"..............................
    53\n      7.9. The Abstract Association \"PolicyInSystem\"................. 54\n
    \     7.10. The Weak Association \"PolicyGroupInSystem\"............... 55\n      7.10.1.
    The Reference \"Antecedent\"............................. 55\n      7.10.2. The
    Reference \"Dependent\".............................. 55\n      7.11. The Weak
    Association \"PolicyRuleInSystem\"................ 56\n      7.11.1. The Reference
    \"Antecedent\"............................. 56\n      7.11.2. The Reference \"Dependent\"..............................
    56\n      7.12. The Association \"PolicyConditionInPolicyRepository\"...... 56\n
    \     7.12.1. The Reference \"Antecedent\"............................. 57\n      7.12.2.
    The Reference \"Dependent\".............................. 57\n      7.13. The
    Association \"PolicyActionInPolicyRepository\"......... 57\n      7.13.1. The
    Reference \"Antecedent\"............................. 58\n      7.13.2. The Reference
    \"Dependent\".............................. 58\n      7.14. The Aggregation \"PolicyRepositoryInPolicyRepository\".....
    58\n      7.14.1. The Reference \"GroupComponent\"......................... 58\n
    \     7.14.2. The Reference \"PartComponent\".......................... 59\n   8.
    Intellectual Property.......................................... 59\n   9. Acknowledgements...............................................
    59\n   10. Security Considerations....................................... 60\n
    \  11. References.................................................... 62\n   12.
    Authors' Addresses............................................ 64\n   13. Appendix
    A:  Class Identification in a Native CIM\n       Implementation................................................
    65\n      13.1. Naming Instances of PolicyGroup and PolicyRule........... 65\n
    \     13.1.1. PolicyGroup's CIM Keys................................. 65\n      13.1.2.
    PolicyRule's CIM Keys.................................. 66\n      13.2. Naming
    Instances of PolicyCondition and Its Subclasses... 67\n      13.2.1. PolicyCondition's
    CIM Keys............................. 69\n      13.3. Naming Instances of PolicyAction
    and Its Subclasses...... 71\n      13.4. Naming Instances of PolicyRepository.....................
    72\n      13.5. Role of the CreationClassName Property in Naming......... 73\n
    \     13.6. Object References........................................ 73\n   14.
    Appendix B:  The Core Policy MOF.............................. 75\n   15. Full
    Copyright Statement..................................... 100\n"
  title: Table of Contents
- contents:
  - "1. Introduction\n   This document presents the object-oriented information model
    for\n   representing policy information currently under joint development in\n
    \  the IETF Policy Framework WG and as extensions to the Common\n   Information
    Model (CIM) activity in the Distributed Management Task\n   Force (DMTF).  This
    model defines two hierarchies of object classes:\n   structural classes representing
    policy information and control of\n   policies, and association classes that indicate
    how instances of the\n   structural classes are related to each other.  Subsequent
    documents\n   will define mappings of this information model to various concrete\n
    \  implementations, for example, to a directory that uses LDAPv3 as its\n   access
    protocol.  The components of the CIM schema are available via\n   the following
    URL: http://www.dmtf.org/spec/cims.html [1].\n   The policy classes and associations
    defined in this model are\n   sufficiently generic to allow them to represent
    policies related to\n   anything.  However, it is expected that their initial
    application in\n   the IETF will be for representing policies related to QoS (DiffServ\n
    \  and IntServ) and to IPSec.  Policy models for application-specific\n   areas
    such as these may extend the Core Model in several ways.  The\n   preferred way
    is to use the PolicyGroup, PolicyRule, and\n   PolicyTimePeriodCondition classes
    directly, as a foundation for\n   representing and communicating policy information.
    \ Then, specific\n   subclasses derived from PolicyCondition and PolicyAction
    can capture\n   application-specific definitions of conditions and actions of\n
    \  policies.\n   Two subclasses, VendorPolicyCondition and VendorPolicyAction,
    are\n   also included in this document, to provide a standard extension\n   mechanism
    for vendor-specific extensions to the Policy Core\n   Information Model.\n   This
    document fits into the overall framework for representing,\n   deploying, and
    managing policies being developed by the Policy\n   Framework Working Group.  It
    traces its origins to work that was\n   originally done for the Directory-enabled
    Networks (DEN)\n   specification, reference [5].  Work on the DEN specification
    by the\n   DEN Ad-Hoc Working Group itself has been completed.  Further work to\n
    \  standardize the models contained in it will be the responsibility of\n   selected
    working groups of the CIM effort in the Distributed\n   Management Task Force
    (DMTF).  DMTF standardization of the core\n   policy model is the responsibility
    of the SLA Policy working group in\n   the DMTF.\n   This document is organized
    in the following manner:\n   o  Section 2 provides a general overview of policies
    and how they are\n      modeled.\n   o  Section 3 presents a high-level overview
    of the classes and\n      associations comprising the Policy Core Information
    Model.\n   o  The remainder of the document presents the detailed specifications\n
    \     for each of the classes and associations.\n   o  Appendix A overviews naming
    for native CIM implementations.  Other\n      mappings, such as LDAPv3, will have
    their own naming mechanisms.\n   o  Appendix B reproduces the DMTF's Core Policy
    MOF specification.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119, reference\n
    \  [3].\n"
  title: 1. Introduction
- contents:
  - "2. Modeling Policies\n   The classes comprising the Policy Core Information Model
    are intended\n   to serve as an extensible class hierarchy (through specialization)\n
    \  for defining policy objects that enable application developers,\n   network
    administrators, and policy administrators to represent\n   policies of different
    types.\n   One way to think of a policy-controlled network is to first model the\n
    \  network as a state machine and then use policy to control which state\n   a
    policy-controlled device should be in or is allowed to be in at any\n   given
    time.  Given this approach, policy is applied using a set of\n   policy rules.
    \ Each policy rule consists of a set of conditions and a\n   set of actions.  Policy
    rules may be aggregated into policy groups.\n   These groups may be nested, to
    represent a hierarchy of policies.\n   The set of conditions associated with a
    policy rule specifies when\n   the policy rule is applicable.  The set of conditions
    can be\n   expressed as either an ORed set of ANDed sets of condition statements\n
    \  or an ANDed set of ORed sets of statements.  Individual condition\n   statements
    can also be negated.  These combinations are termed,\n   respectively, Disjunctive
    Normal Form (DNF) and Conjunctive Normal\n   Form (CNF) for the conditions.\n
    \  If the set of conditions associated with a policy rule evaluates to\n   TRUE,
    then a set of actions that either maintain the current state of\n   the object
    or transition the object to a new state may be executed.\n   For the set of actions
    associated with a policy rule, it is possible\n   to specify an order of execution,
    as well as an indication of whether\n   the order is required or merely recommended.
    \ It is also possible to\n   indicate that the order in which the actions are
    executed does not\n   matter.\n   Policy rules themselves can be prioritized.
    \ One common reason for\n   doing this is to express an overall policy that has
    a general case\n   with a few specific exceptions.\n   For example, a general
    QoS policy rule might specify that traffic\n   originating from members of the
    engineering group is to get Bronze\n   Service.  A second policy rule might express
    an exception: traffic\n   originating from John, a specific member of the engineering
    group, is\n   to get Gold Service.  Since traffic originating from John satisfies\n
    \  the conditions of both policy rules, and since the actions associated\n   with
    the two rules are incompatible, a priority needs to be\n   established.  By giving
    the second rule (the exception) a higher\n   priority than the first rule (the
    general case), a policy\n   administrator can get the desired effect: traffic
    originating from\n   John gets Gold Service, and traffic originating from all
    the other\n   members of the engineering group gets Bronze Service.\n   Policies
    can either be used in a stand-alone fashion or aggregated\n   into policy groups
    to perform more elaborate functions.  Stand-alone\n   policies are called policy
    rules.  Policy groups are aggregations of\n   policy rules, or aggregations of
    policy groups, but not both.  Policy\n   groups can model intricate interactions
    between objects that have\n   complex interdependencies.  Examples of this include
    a sophisticated\n   user logon policy that sets up application access, security,
    and\n   reconfigures network connections based on a combination of user\n   identity,
    network location, logon method and time of day.  A policy\n   group represents
    a unit of reusability and manageability in that its\n   management is handled
    by an identifiable group of administrators and\n   its policy rules would be consistently
    applied\n   Stand-alone policies are those that can be expressed in a simple\n
    \  statement.  They can be represented effectively in schemata or MIBs.\n   Examples
    of this are VLAN assignments, simple YES/NO QoS requests,\n   and IP address allocations.
    \ A specific design goal of this model is\n   to support both stand-alone and
    aggregated policies.\n   Policy groups and rules can be classified by their purpose
    and\n   intent.  This classification is useful in querying or grouping policy\n
    \  rules.  It indicates whether the policy is used to motivate when or\n   how
    an action occurs, or to characterize services (that can then be\n   used, for
    example, to bind clients to network services).  Describing\n   each of these concepts
    in more detail,\n   o  Motivational Policies are solely targeted at whether or
    how a\n      policy's goal is accomplished.  Configuration and Usage Policies\n
    \     are specific kinds of Motivational Policies.  Another example is\n      the
    scheduling of file backup based on disk write activity from\n      8am to 3pm,
    M-F.\n   o  Configuration Policies define the default (or generic) setup of a\n
    \     managed entity (for example, a network service).  Examples of\n      Configuration
    Policies are the setup of a network forwarding\n      service or a network-hosted
    print queue.\n   o  Installation Policies define what can and cannot be put on
    a\n      system or component, as well as the configuration of the\n      mechanisms
    that perform the install.  Installation policies\n      typically represent specific
    administrative permissions, and can\n      also represent dependencies between
    different components (e.g., to\n      complete the installation of component A,
    components B and C must\n      be previously successfully installed or uninstalled).\n
    \  o  Error and Event Policies.  For example, if a device fails between\n      8am
    and 9pm, call the system administrator, otherwise call the\n      Help Desk.\n
    \  o  Usage Policies control the selection and configuration of entities\n      based
    on specific \"usage\" data.  Configuration Policies can be\n      modified or
    simply re-applied by Usage Policies.  Examples of\n      Usage Policies include
    upgrading network forwarding services after\n      a user is verified to be a
    member of a \"gold\" service group, or\n      reconfiguring a printer to be able
    to handle the next job in its\n      queue.\n   o  Security Policies deal with
    verifying that the client is actually\n      who the client purports to be, permitting
    or denying access to\n      resources, selecting and applying appropriate authentication\n
    \     mechanisms, and performing accounting and auditing of resources.\n   o  Service
    Policies characterize network and other services (not use\n      them).  For example,
    all wide-area backbone interfaces shall use a\n      specific type of queuing.\n
    \     Service policies describe services available in the network.\n      Usage
    policies describe the particular binding of a client of the\n      network to
    services available in the network.\n   These categories are represented in the
    Policy Core Information Model\n   by special values defined for the PolicyKeywords
    property of the\n   abstract class Policy.\n"
  - contents:
    - "2.1. Policy Scope\n   Policies represent business goals and objectives.  A
      translation must\n   be made between these goals and objectives and their realization
      in\n   the network.  An example of this could be a Service Level Agreement\n
      \  (SLA), and its objectives and metrics (Service Level Objectives, or\n   SLOs),
      that are used to specify services that the network will\n   provide for a given
      client.  The SLA will usually be written in\n   high-level business terminology.
      \ SLOs address more specific metrics\n   in support of the SLA.  These high-level
      descriptions of network\n   services and metrics must be translated into lower-level,
      but also\n   vendor-and device-independent specifications.  The Policy Core\n
      \  Information Model classes are intended to serve as the foundation for\n   these
      lower-level, vendor- and device-independent specifications.\n   It is envisioned
      that the definition of the Policy Core Informational\n   Model in this document
      is generic in nature and is applicable to\n   Quality of Service (QoS), to non-QoS
      networking applications (e.g.,\n   DHCP and IPSec), and to non-networking applications
      (e.g., backup\n   policies, auditing access, etc.).\n"
    title: 2.1. Policy Scope
  - contents:
    - "2.2. Declarative versus Procedural Model\n   The design of the Policy Core
      Information Model is influenced by a\n   declarative, not procedural, approach.
      \ More formally, a declarative\n   language is used to describe relational and
      functional languages.\n   Declarative languages describe relationships between
      variables in\n   terms of functions or inference rules, to which the interpreter
      or\n   compiler can apply a fixed algorithm in order to produce a result.\n
      \  An imperative (or procedural) language specifies an explicit sequence\n   of
      steps to follow in order to produce a result.\n   It is important to note that
      this information model does not rule out\n   the use of procedural languages.
      \ Rather, it recognizes that both\n   declarative as well as procedural languages
      can be used to implement\n   policy.  This information model is better viewed
      as being declarative\n   because the sequence of steps for doing the processing
      of declarative\n   statements tends to be left to the implementer.  However,
      we have\n   provided the option of expressing the desired order of action\n
      \  execution in this policy information model, and for expressing\n   whether
      the order is mandatory or not.  In addition, rather than\n   trying to define
      algorithms or sets of instructions or steps that\n   must be followed by a policy
      rule, we instead define a set of modular\n   building blocks and relationships
      that can be used in a declarative\n   or procedural fashion to define policies.\n
      \  Compare this to a strictly procedural model.  Taking such an approach\n   would
      require that we specify the condition testing sequence, and the\n   action execution
      sequence, in the policy repository itself.  This\n   would, indeed, constrain
      the implementer.  This is why the policy\n   model is characterized as a declarative
      one.  That is, the\n   information model defines a set of attributes, and a
      set of entities\n   that contain these attributes.  However, it does NOT define
      either\n   the algorithm to produce a result using the attributes or an explicit\n
      \  sequence of steps to produce a result.\n   There are several design considerations
      and trade-offs to make in\n   this respect.\n   1. On the one hand, we would
      like a policy definition language to be\n      reasonably human-friendly for
      ease of definitions and diagnostics.\n      On the other hand, given the diversity
      of devices (in terms of\n      their processing capabilities) which could act
      as policy decision\n      points, we would like to keep the language somewhat
      machine-\n      friendly.  That is, it should be relatively simple to automate
      the\n      parsing and processing of the language in network elements.  The\n
      \     approach taken is to provide a set of classes and attributes that\n      can
      be combined in either a declarative or procedural approach to\n      express
      policies that manage network elements and services.  The\n      key point is
      to avoid trying to standardize rules or sets of steps\n      to be followed
      in defining a policy.  These must be left up to an\n      implementation.  Interoperability
      is achieved by standardizing the\n      building blocks that are used to represent
      policy data and\n      information.\n   2. An important decision to make is
      the semantic style of the\n      representation of the information.\n      The
      declarative approach that we are describing falls short of\n      being a \"true\"
      declarative model.  Such a model would also specify\n      the algorithms used
      to combine the information and policy rules to\n      achieve particular behavior.
      \ We avoid specifying algorithms for\n      the same reason that we avoid specifying
      sets of steps to be\n      followed in a policy rule.  However, the design of
      the information\n      model more closely follows that of a declarative language,
      and may\n      be easier to understand if such a conceptual model is used.  This\n
      \     leads to our third point, acknowledging a lack of \"completeness\"\n      and
      instead relying on presenting information that the policy\n      processing
      entity will work with.\n   3. It is important to control the complexity of the
      specification,\n      trading off richness of expression of data in the core
      information\n      model for ease of implementation and use.  It is important
      to\n      acknowledge the collective lack of experience in the field\n      regarding
      policies to control and manage network services and\n      hence avoid the temptation
      of aiming for \"completeness\".  We\n      should instead strive to facilitate
      definition of a set of common\n      policies that customers require today (e.g.,
      VPN and QoS) and\n      allow migration paths towards supporting complex policies
      as\n      customer needs and our understanding of these policies evolve with\n
      \     experience.  Specifically, in the context of the declarative style\n      language
      discussed above, it is important to avoid having full\n      blown predicate
      calculus as the language, as it would render many\n      important problems
      such as consistency checking and policy\n      decision point algorithms intractable.
      \ It is useful to consider a\n      reasonably constrained language from these
      perspectives.\n   The Policy Core Information Model strikes a balance between\n
      \  complexity and lack of power by using the well understood logical\n   concepts
      of Disjunctive Normal Form and Conjunctive Normal Form for\n   combining simple
      policy conditions into more complex ones.\n"
    title: 2.2. Declarative versus Procedural Model
  title: 2. Modeling Policies
- contents:
  - "3. Overview of the Policy Core Information Model\n   The following diagram provides
    an overview of the five central\n   classes comprising the Policy Core Information
    Model, their\n   associations to each other, and their associations to other classes\n
    \  in the overall CIM model.  Note that the abstract class Policy and\n   the
    two extension classes VendorPolicyCondition and\n   VendorPolicyAction are not
    shown.\n   NOTE:  For cardinalities, \"*\" is an abbreviation for \"0..n\".\n
    \                              +-----------+\n                               |
    \ System   |\n            .....              +--^-----^--+       .....\n            .
    \  .                1.    1.          .   .\n           *.(a).*                .(b)
    \ .(c)      *.(d).*\n         +--v---v---------+       .     .        +-v---v------------+\n
    \        |  PolicyGroup   <........     .        | PolicyRepository |\n         |
    \               | w *         .        |                  |\n         +------^---------+
    \            .        +-----^---------^--+\n               *.                       .
    \        0..1 .    0..1 .\n                .(e)                    .              .(f)
    \     .(g)\n               *.                       .              .         .\n
    \        +------v------+ w *            .              .         .\n         |
    \            <.................              .         .\n         | PolicyRule
    \ |                               .         .\n         |             |                               .
    \        .\n         |             |                               .         .\n
    \        |             <........................       .         .\n         |
    \            |*      (h)             .       .         .\n         |             |
    \                      .       .         .\n         |             |                       .
    \      .         .\n         |             |                       .       .         .\n
    \        |             |                       .       .         .\n         |
    \            |                       .       .         .\n         |             |
    \                      .       .         .\n         |             |                       .*
    \     .*        .\n         |             |             +---------v-------v--+
    \     .\n         |             |             |  PolicyCondition   |      .\n
    \        |             |            *+--------------------+      .\n         |
    \            |       (i)             ^                 .\n         |             <..............
    \        I                 .\n         |             |*            .         I
    \                .\n         |             |             .*        ^                 .\n
    \        |             |        +----v----------------------+    .\n         |
    \            |        | PolicyTimePeriodCondition |    .\n         |             |
    \       +---------------------------+    .\n         |             |       (j)
    \                              .\n         |             <.........................
    \               .\n         |             |*                       .                .\n
    \        |             |                        .*               .\n         |
    \            |             +----------v---------+*     .\n         |             |
    \            | PolicyAction       <.......\n         +-------------+             +--------------------+\n
    \  Figure 1.    Overview of the Core Policy Classes and Relationships\n   In this
    figure the boxes represent the classes, and the dotted arrows\n   represent the
    associations.  The following associations appear:\n   (a)     PolicyGroupInPolicyGroup\n
    \  (b)     PolicyGroupInSystem\n   (c)     PolicyRuleInSystem\n   (d)     PolicyRepositoryInPolicyRepository\n
    \  (e)     PolicyRuleInPolicyGroup\n   (f)     PolicyConditionInPolicyRepository\n
    \  (g)     PolicyActionInPolicyRepository\n   (h)     PolicyConditionInPolicyRule\n
    \  (i)     PolicyRuleValidityPeriod\n   (j)     PolicyActionInPolicyRule\n   An
    association always connects two classes.  The \"two\" classes may,\n   however,
    be the same class, as is the case with the\n   PolicyGroupInPolicyGroup association,
    which represents the recursive\n   containment of PolicyGroups in other PolicyGroups.
    \ The\n   PolicyRepositoryInPolicyRepository association is recursive in the\n
    \  same way.\n   An association includes cardinalities for each of the related\n
    \  classes.  These cardinalities indicate how many instances of each\n   class
    may be related to an instance of the other class.  For example,\n   the PolicyRuleInPolicyGroup
    association has the cardinality range \"*'\n   (that is, \"0..n\") for both the
    PolicyGroup and PolicyRule classes.\n   These ranges are interpreted as follows:\n
    \  o  The \"*\" written next to PolicyGroup indicates that a PolicyRule\n      may
    be related to no PolicyGroups, to one PolicyGroup, or to more\n      than one
    PolicyGroup via the PolicyRuleInPolicyGroup association.\n      In other words,
    a PolicyRule may be contained in no PolicyGroups,\n      in one PolicyGroups,
    or in more than one PolicyGroup.\n   o  The \"*\" written next to PolicyRule indicates
    that a PolicyGroup\n      may be related to no PolicyRules, to one PolicyRule,
    or to more\n      than one PolicyRule via the PolicyRuleInPolicyGroup association.\n
    \     In other words, a PolicyGroup may contain no PolicyRules, one\n      PolicyRule,
    or more than one PolicyRule.\n   The \"w\" written next to the PolicyGroupInSystem
    and\n   PolicyRuleInSystem indicates that these are what CIM terms\n   \"aggregations
    with weak references\", or more briefly, \"weak\n   aggregations\".  A weak aggregation
    is simply an indication of a\n   naming scope.  Thus these two aggregations indicate
    that an instance\n   of a PolicyGroup or PolicyRule is named within the scope
    of a System\n   object.  A weak aggregation implicitly has the cardinality 1..1
    at\n   the end opposite the 'w'.\n   The associations shown in Figure 1 are discussed
    in more detail in\n   Section 7.\n"
  title: 3. Overview of the Policy Core Information Model
- contents:
  - "4. Inheritance Hierarchies for the Policy Core Information Model\n   The following
    diagram illustrates the inheritance hierarchy for the\n   core policy classes:\n
    \     ManagedElement (abstract)\n       |\n       +--Policy (abstract)\n       |
    \ |\n       |  +---PolicyGroup\n       |  |\n       |  +---PolicyRule\n       |
    \ |\n       |  +---PolicyCondition (abstract)\n       |  |          |\n       |
    \ |          +---PolicyTimePeriodCondition\n       |  |          |\n       |  |
    \         +---VendorPolicyCondition\n       |  |\n       |  +---PolicyAction (abstract)\n
    \      |             |\n       |             +---VendorPolicyAction\n       |\n
    \      +--ManagedSystemElement (abstract)\n          |\n          +--LogicalElement
    (abstract)\n             |\n             +--System (abstract)\n                |\n
    \               +--AdminDomain (abstract)\n                   |\n                   +---PolicyRepository\n
    \  Figure 2.    Inheritance Hierarchy for the Core Policy Classes\n   ManagedElement,
    ManagedSystemElement, LogicalElement, System, and\n   AdminDomain are defined
    in the CIM schema [1].  These classes are not\n   discussed in detail in this
    document.\n   In CIM, associations are also modeled as classes.  For the Policy\n
    \  Core Information Model, the inheritance hierarchy for the\n   associations
    is as follows:\n      [unrooted]\n       |\n       +---PolicyComponent (abstract)\n
    \      |   |\n       |   +---PolicyGroupInPolicyGroup\n       |   |\n       |
    \  +---PolicyRuleInPolicyGroup\n       |   |\n       |   +---PolicyConditionInPolicyRule\n
    \      |   |\n       |   +---PolicyRuleValidityPeriod\n       |   |\n       |
    \  +---PolicyActionInPolicyRule\n       |\n       +---Dependency (abstract)\n
    \      |   |\n       |   +---PolicyInSystem (abstract)\n       |       |\n       |
    \      +---PolicyGroupInSystem\n       |       |\n       |       +---PolicyRuleInSystem\n
    \      |       |\n       |       +---PolicyConditionInPolicyRepository\n       |
    \      |\n       |       +---PolicyActionInPolicyRepository\n       |\n       +---Component
    (abstract)\n           |\n           +---SystemComponent\n               |\n               +---PolicyRepositoryInPolicyRepository\n
    \  Figure 3.    Inheritance Hierarchy for the Core Policy Associations\n   The
    Dependency, Component, and SystemComponent associations are\n   defined in the
    CIM schema [1], and are not discussed further in this\n   document.\n"
  - contents:
    - "4.1. Implications of CIM Inheritance\n   From the CIM schema, both properties
      and associations are inherited\n   to the Policy classes.  For example, the
      class ManagedElement is\n   referenced in the associations Dependency, Statistics
      and\n   MemberOfCollection.  And, the Dependency association is in turn\n   referenced
      in the DependencyContext association.  At this very\n   abstract and high level
      in the inheritance hierarchy, the number of\n   these associations is very small
      and their semantics are quite\n   general.\n   Many of these inherited associations
      convey additional semantics that\n   are not needed in understanding the Policy
      Core Information Model.\n   In fact, they are defined as OPTIONAL in the CIM
      Schema - since their\n   cardinality is \"0..n\" on all references.  The PCIM
      document\n   specifically discusses what is necessary to support and instantiate.\n
      \  For example, through subclassing of the Dependency association, the\n   exact
      Dependency semantics in PCIM are described.\n   So, one may wonder what to do
      with these other inherited\n   associations.  The answer is \"ignore them unless
      you need them\".  You\n   would need them to describe additional information
      and semantics for\n   policy data.  For example, it may be necessary to capture
      statistical\n   data for a PolicyRule (either for the rule in a repository or
      for\n   when it is executing in a policy system).  Some examples of\n   statistical
      data for a rule are the number of times it was\n   downloaded, the number of
      times its conditions were evaluated, and\n   the number of times its actions
      were executed.  (These types of data\n   would be described in a subclass of
      CIM_StatisticalInformation.)  In\n   these cases, the Statistics association
      inherited from ManagedElement\n   to PolicyRule may be used to describe the
      tie between an instance of\n   a PolicyRule and the set of statistics for it.\n"
    title: 4.1. Implications of CIM Inheritance
  title: 4. Inheritance Hierarchies for the Policy Core Information Model
- contents:
  - "5. Details of the Model\n   The following subsections discuss several specific
    issues related to\n   the Policy Core Information Model.\n"
  - contents:
    - "5.1. Reusable versus Rule-Specific Conditions and Actions\n   Policy conditions
      and policy actions can be partitioned into two\n   groups:  ones associated
      with a single policy rule, and ones that are\n   reusable, in the sense that
      they may be associated with more than one\n   policy rule.  Conditions and actions
      in the first group are termed\n   \"rule-specific\" conditions and actions;
      those in the second group are\n   characterized as \"reusable\".\n   It is important
      to understand that the difference between a rule-\n   specific condition or
      action and a reusable one is based on the\n   intent of the policy administrator
      for the condition or action,\n   rather than on the current associations in
      which the condition or\n   action participates.  Thus a reusable condition or
      action (that is,\n   one that a policy administrator has created to be reusable)
      may at\n   some point in time be associated with exactly one policy rule,\n
      \  without thereby becoming rule-specific.\n   There is no inherent difference
      between a rule-specific condition or\n   action and a reusable one.  There are,
      however, differences in how\n   they are treated in a policy repository.  For
      example, it's natural\n   to make the access permissions for a rule-specific
      condition or\n   action identical to those for the rule itself.  It's also natural
      for\n   a rule-specific condition or action to be removed from the policy\n
      \  repository at the same time the rule is.  With reusable conditions\n   and
      actions, on the other hand, access permissions and existence\n   criteria must
      be expressible without reference to a policy rule.\n   The preceding paragraph
      does not contain an exhaustive list of the\n   ways in which reusable and rule-specific
      conditions should be treated\n   differently.  Its purpose is merely to justify
      making a semantic\n   distinction between rule-specific and reusable, and then
      reflecting\n   this distinction in the policy model itself.\n   An issue is
      highlighted by reusable and rule-specific policy\n   conditions and policy actions:
      \ the lack of a programmatic capability\n   for expressing complex constraints
      involving multiple associations.\n   Taking PolicyCondition as an example, there
      are two aggregations to\n   look at.  PolicyConditionInPolicyRule has the cardinality
      * at both\n   ends, and PolicyConditionInPolicyRepository has the cardinality
      * at\n   the PolicyCondition end, and [0..1] at the PolicyRepository end.\n
      \  Globally, these cardinalities are correct.  However, there's more to\n   the
      story, which only becomes clear if we examine the cardinalities\n   separately
      for the two cases of a rule-specific PolicyCondition and a\n   reusable one.\n
      \  For a rule-specific PolicyCondition, the cardinality of\n   PolicyConditionInPolicyRule
      at the PolicyRule end is [1..1], rather\n   than [0..n] (recall that * is an
      abbreviation for [0..n]), since the\n   condition is unique to one policy rule.
      \ And the cardinality of\n   PolicyConditionInPolicyRepository at the PolicyRepository
      end is\n   [0..0], since the condition is not in the \"re-usable\" repository.\n
      \  This is OK, since these are both subsets of the specified\n   cardinalities.\n
      \  For a reusable PolicyCondition, however, the cardinality of\n   PolicyConditionInPolicyRepository
      at the PolicyRepository end is\n   [1..1], since the condition must be in the
      repository.  And, the\n   cardinality of PolicyConditionInPolicyRule at the
      PolicyRule end is\n   [0..n].  This last point is important:  a reusable PolicyCondition\n
      \  may be associated with 0, 1, or more than 1 PolicyRules, via exactly\n   the
      same association PolicyConditionInPolicyRule that binds a rule-\n   specific
      condition to its PolicyRule.\n   Currently the only way to document constraints
      of this type is\n   textually.  More formal methods for documenting complex
      constraints\n   are needed.\n"
    title: 5.1. Reusable versus Rule-Specific Conditions and Actions
  - contents:
    - '5.2. Roles

      '
    - contents:
      - "5.2.1. Roles and Role Combinations\n   The concept of role is central to
        the design of the entire Policy\n   Framework.  The idea behind roles is a
        simple one.  Rather than\n   configuring, and then later having to update
        the configuration of,\n   hundreds or thousands (or more) of resources in
        a network, a policy\n   administrator assigns each resource to one or more
        roles, and then\n   specifies the policies for each of these roles.  The Policy
        Framework\n   is then responsible for configuring each of the resources associated\n
        \  with a role in such a way that it behaves according to the policies\n   specified
        for that role.  When network behavior must be changed, the\n   policy administrator
        can perform a single update to the policy for a\n   role, and the Policy Framework
        will ensure that the necessary\n   configuration updates are performed on
        all the resources playing that\n   role.\n   A more formal definition of a
        role is as follows:\n      A role is a type of attribute that is used to select
        one or more\n      policies for a set of entities and/or components from among
        a much\n      larger set of available policies.\n   Roles can be combined
        together.  Here is a formal definition of a\n   \"role- combination\":\n      A
        role-combination is a set of attributes that are used to select\n      one
        or more policies for a set of entities and/or components from\n      among
        a much larger set of available policies.  As the examples\n      below illustrate,
        the selection process for a role combination\n      chooses policies associated
        with the combination itself, policies\n      associated with each of its sub-combinations,
        and policies\n      associated with each of the individual roles in the role-\n
        \     combination.\n   It is important to note that a role is more than an
        attribute.  A\n   role defines a particular function of an entity or component
        that can\n   be used to identify particular behavior associated with that
        entity\n   or component.  This difference is critical, and is most easily\n
        \  understood by thinking of a role as a selector.  When used in this\n   manner,
        one role (or role-combination) selects a different set of\n   policies than
        a different role (or role-combination) does.\n   Roles and role-combinations
        are especially useful in selecting which\n   policies are applicable to a
        particular set of entities or components\n   when the policy repository can
        store thousands or hundreds of\n   thousands of policies.  This use emphasizes
        the ability of the role\n   (or role- combination) to select the small subset
        of policies that\n   are applicable from a huge set of policies that are available.\n
        \  An example will illustrate how role-combinations actually work.\n   Suppose
        an installation has three roles defined for interfaces:\n   \"Ethernet\",
        \"Campus\", and \"WAN\".  In the Policy Repository, some\n   policy rules
        could be associated with the role \"Ethernet\"; these\n   rules would apply
        to all Ethernet interfaces, regardless of whether\n   they were on the campus
        side or the WAN side.  Other rules could be\n   associated with the role-combination
        \"Campus\"+\"Ethernet\"; these rules\n   would apply to the campus-side Ethernet
        interfaces, but not to those\n   on the WAN side.  Finally, a third set of
        rules could be associated\n   with the role-combination \"Ethernet\"+\"WAN\";
        these rules would apply\n   to the WAN-side Ethernet interfaces, but not to
        those on the campus\n   side.  (The roles in a role-combination appear in
        alphabetical order\n   in these examples, because that is how they appear
        in the information\n   model.)\n   If we have a specific interface A that's
        associated with the role-\n   combination \"Ethernet\"+\"WAN\", we see that
        it should have three\n   categories of policy rules applied to it:  those
        for the \"Ethernet\"\n   role, those for the \"WAN\" role, and those for the
        role-combination\n   \"Ethernet\"+\"WAN\".  Going one step further, if interface
        B is\n   associated with the role- combination \"branch-\n   office\"+\"Ethernet\"+\"WAN\",
        then B should have seven categories of\n   policy rules applied to it - those
        associated with the following\n   role-combinations:\n      o \"branch-office\"\n
        \     o \"Ethernet\"\n      o \"WAN\"\n      o \"branch-office\"+\"Ethernet\"\n
        \     o \"branch-office\"+\"WAN\"\n      o \"Ethernet\"+\"WAN\"\n      o \"branch-office\"+\"Ethernet\"+\"WAN\".\n
        \  In order to get all of the right policy rules for a resource like\n   interface
        B, a PDP must expand the single role-combination it\n   receives for B into
        this list of seven role-combinations, and then\n   retrieve from the Policy
        Repository the corresponding seven sets of\n   policy rules.  Of course this
        example is unusually complicated:  the\n   normal case will involve expanding
        a two-role combination into three\n   values identifying three sets of policy
        rules.\n   Role-combinations also help to simplify somewhat the problem of\n
        \  identifying conflicts between policy rules.  With role-combinations,\n
        \  it is possible for a policy administrator to specify one set of\n   policy
        rules for campus-side Ethernet interfaces, and a second set of\n   policy
        rules for WAN-side Ethernet interfaces, without having to\n   worry about
        conflicts between the two sets of rules.  The policy\n   administrator simply
        \"turns off\" conflict detection for these two\n   sets of rules, by telling
        the policy management system that the roles\n   \"Campus\" and \"WAN\" are
        incompatible with each other.  This indicates\n   that the role combination
        will never occur, and therefore conflicts\n   will never occur.  In some cases
        the technology itself might identify\n   incompatible roles:  \"Ethernet\"
        and \"FrameRelay\", for example.  But\n   for less precise terms like \"Campus\"
        and \"WAN\", the policy\n   administrator must say whether they identify incompatible
        roles.\n   When the policy administrator does this, there are three effects:\n
        \  1. If an interface has assigned to it a role-combination involving\n      both
        \"Campus\" and \"WAN\", then the policy management system can\n      flag
        it as an error.\n   2. If a policy rule is associated with a role-combination
        involving\n      both \"Campus\" and \"WAN\", then the policy management system
        can\n      flag it as an error.\n   3. If the policy management system sees
        two policy rules, where one\n      is tied to the role \"Campus\" (or to a
        role-combination that\n      includes the role \"Campus\") and the other is
        tied to the role\n      \"WAN\" (or to a role- combination that includes the
        role \"WAN\"),\n      then the system does not need to look for conflicts
        between the\n      two policy rules:  because of the incompatible roles, the
        two\n      rules cannot possibly conflict.\n                        +-------------------+\n
        \                       | Policy Repository |\n                        +-------------------+\n
        \                                 V\n                                  V retrieval
        of policy\n                                  V\n                             +---------+\n
        \                            | PDP/PEP |\n                             +---------+\n
        \                                 v\n                                  v application
        of policy\n                                  v\n                          +----------------+\n
        \                         | Network Entity |\n                          +----------------+\n
        \            Figure 4.    Retrieval and Application of a Policy\n      Figure
        4, which is introduced only as an example of how the Policy\n      Framework
        might be implemented by a collection of network\n      components, illustrates
        how roles operate within the Policy\n      Framework.  Because the distinction
        between them is not important\n      to this discussion, the PDP and the PEP
        are combined in one box.\n      The points illustrated here apply equally
        well, though, to an\n      environment where the PDP and the PEP are implemented
        separately.\n      A role represents a functional characteristic or capability
        of a\n      resource to which policies are applied.  Examples of roles include\n
        \     Backbone interface, Frame Relay interface, BGP-capable router, web\n
        \     server, firewall, etc.  The multiple roles assigned to a single\n      resource
        are combined to form that resource's role combination.\n      Role combinations
        are represented in the PCIM by values of the\n      PolicyRoles property in
        the PolicyRule class.  A PDP uses policy\n      roles as follows to identify
        the policies it needs to be aware of:\n      1. The PDP learns in some way
        the list of roles that its PEPs\n         play.  This information might be
        configured at the PDP, the\n         PEPs might supply it to the PDP, or the
        PDP might retrieve it\n         from a repository.\n      2. Using repository-specific
        means, the PDP determines where to\n         look for policy rules that might
        apply to it.\n      3. Using the roles and role-combinations it received from
        its PEPs\n         as indicated in the examples above, the PDP is able to
        locate\n         and retrieve the policy rules that are relevant to it.\n"
      title: 5.2.1. Roles and Role Combinations
    - contents:
      - "5.2.2. The PolicyRoles Property\n   As indicated earlier, PolicyRoles is
        a property associated with a\n   policy rule.  It is an array holding \"role
        combinations\" for the\n   policy rule, and correlates with the roles defined
        for a network\n   resource.  Using the PolicyRoles property, it is possible
        to mark a\n   policy rule as applying, for example, to a Frame Relay interface
        or\n   to a backbone ATM interface.  The PolicyRoles property take strings\n
        \  of the form:\n      <RoleName>[&&<RoleName>]*\n   Each value of this property
        represents a role combination, including\n   the special case of a \"combination\"
        containing only one role.  As the\n   format indicates, the role names in
        a role combination are ANDed\n   together to form a single selector.  The
        multiple values of the\n   PolicyRoles property are logically ORed, to make
        it possible for a\n   policy rule to have multiple selectors.\n   The individual
        role names in a role combination must appear in\n   alphabetical order (according
        to the collating sequence for UCS-2\n   characters), to make the string matches
        work correctly.  The role\n   names used in an environment are specified by
        the policy\n   administrator.\n"
      title: 5.2.2. The PolicyRoles Property
    title: 5.2. Roles
  - contents:
    - "5.3. Local Time and UTC Time in PolicyTimePeriodConditions\n   An instance
      of PolicyTimePeriodCondition has up to five properties\n   that represent times:
      \ TimePeriod, MonthOfYearMask, DayOfMonthMask,\n   DayOfWeekMask, and TimeOfDayMask.
      \ All of the time-related properties\n   in an instance of PolicyTimePeriodCondition
      represent one of two\n   types of times:  local time at the place where a policy
      rule is\n   applied, or UTC time.  The property LocalOrUtcTime indicates which\n
      \  time representation applies to an instance of\n   PolicyTimePeriodCondition.\n
      \  Since the PCIM provides only for local time and UTC time, a Policy\n   Management
      Tool that provides for other time representations (for\n   example, a fixed
      time at a particular location) will need to map from\n   these other representations
      to either local time or UTC time.  An\n   example will illustrate the nature
      of this mapping.\n   Suppose a policy rule is tied to the hours of operation
      for a Help\n   Desk:  0800 to 2000 Monday through Friday [US] Eastern Time.
      \ In\n   order to express these times in PolicyTimePeriodCondition, a\n   management
      tool must convert them to UTC times.  (They are not local\n   times, because
      they refer to a single time interval worldwide, not to\n   intervals tied to
      the local clocks at the locations where the\n   PolicyRule is being applied.)
      \ As reference [10] points out, mapping\n   from [US] Eastern Time to UTC time
      is not simply a matter of applying\n   an offset:  the offset between [US] Eastern
      Time and UTC time\n   switches between -0500 and -0400 depending on whether
      Daylight\n   Savings Time is in effect in the US.\n   Suppose the policy administrator's
      goal is to have a policy rule be\n   valid from 0800 until 1200 [US] Eastern
      Time on every Monday, within\n   the overall time period from the beginning
      of 2000 until the end of\n   2001.  The Policy Management Tool could either
      be configured with the\n   definition of what [US] Eastern Time means, or it
      could be configured\n   with knowledge of where to go to get this information.
      \ Reference\n   [10] contains further discussion of time zone definitions and
      where\n   they might reside.\n   Armed with knowledge about [US] Eastern Time,
      the Policy Management\n   Tool would create however many instances of PolicyTimePeriodCondition\n
      \  it needed to represent the desired intervals.  Note that while there\n   is
      an increased number of PolicyTimePeriodCondition instances, there\n   is still
      just one PolicyRule, which is tied to all the\n   PolicyTimePeriodCondition
      instances via the aggregation\n   PolicyRuleValidityPeriod.  Here are the first
      two of these instances:\n         1. TimePeriod:  20000101T050000/20000402T070000\n
      \           DayOfWeekMask:  { Monday }\n            TimeOfDayMask:  T130000/T170000\n
      \           LocalOrUtcTime:  UTC\n         2. TimePeriod:  20000402T070000/20001029T070000\n
      \           DayOfWeekMask:  { Monday }\n            TimeOfDayMask:  T120000/T160000\n
      \           LocalOrUtcTime:  UTC\n   There would be three more similar instances,
      for winter 2000-2001,\n   summer 2001, and winter 2001 up through December 31.\n
      \  Had the example been chosen differently, there could have been even\n   more
      instances of PolicyTimePeriodCondition.  If, for example, the\n   time interval
      had been from 0800 - 2200 [US] Eastern Time on Mondays,\n   instance 1 above
      would have split into two instances:  one with a UTC\n   time interval of T130000/T240000
      on Mondays, and another with a UTC\n   time interval of T000000/T030000 on Tuesdays.
      \ So the end result\n   would have been ten instances of PolicyTimePeriodCondition,
      not five.\n   By restricting PolicyTimePeriodCondition to local time and UTC
      time,\n   the PCIM places the difficult and expensive task of mapping from\n
      \  \"human\" time representations to machine-friendly ones in the Policy\n   Management
      Tool.  Another approach would have been to place in\n   PolicyTimePeriodCondition
      a means of representing a named time zone,\n   such as [US] Eastern Time.  This,
      however, would have passed the\n   difficult mapping responsibility down to
      the PDPs and PEPs.  It is\n   better to have a mapping such as the one described
      above done once in\n   a Policy Management Tool, rather than having it done
      over and over in\n   each of the PDPs (and possibly PEPs) that need to apply
      a PolicyRule.\n"
    title: 5.3. Local Time and UTC Time in PolicyTimePeriodConditions
  - contents:
    - "5.4. CIM Data Types\n   Since PCIM extends the CIM Schema, a correspondence
      between data\n   types used in both CIM and PCIM is needed.  The following CIM
      data\n   types are used in the class definitions that follow in Sections 6 and\n
      \  7:\n   o uint8               unsigned 8-bit integer\n   o uint16              unsigned
      16-bit integer\n   o boolean             Boolean\n   o string              UCS-2
      string.\n   Strings in CIM are stored as UCS-2 characters, where each character\n
      \  is encoded in two octets.  Thus string values may need to be\n   converted
      when moving between a CIM environment and one that uses a\n   different string
      encoding.  For example, in an LDAP-accessible\n   directory, attributes of type
      DirectoryString are stored in UTF-8\n   format.  RFC 2279 [7] explains how to
      convert between these two\n   formats.\n   When it is applied to a CIM string,
      a MaxLen value refers to the\n   maximum number of characters in the string,
      rather than to the\n   maximum number of octets.\n   In addition to the CIM
      data types listed above, the association\n   classes in Section 7 use the following
      type:\n   o <classname> ref     strongly typed reference.\n   There is one obvious
      omission from this list of CIM data types:\n   octet strings.  This is because
      CIM treats octet strings as a derived\n   data type.  There are two forms of
      octet strings in CIM - an ordered\n   uint8 array for single-valued strings,
      and a string array for multi-\n   valued properties.  Both are described by
      adding an \"OctetString\"\n   qualifier (meta-data) to the property.  This qualifier
      functions\n   exactly like an SMIv2 (SNMP) Textual Convention, refining the
      syntax\n   and semantics of the existing CIM data type.\n   The first four numeric
      elements of both of the \"OctetString\"\n   representations are a length field.
      \ (The reason that the \"numeric\"\n   adjective is added to the previous sentence
      is that the string\n   property also includes '0' and 'x', as its first characters.)
      \ In\n   both cases, these 4 numeric elements (octets) are included in\n   calculating
      the length.  For example, a single-valued octet string\n   property having the
      value X'7C' would be represented by the uint8\n   array, X'00 00 00 05 7C'.\n
      \  The strings representing the individual values of a multi-valued\n   property
      qualified with the \"OctetString\" qualifier are constructed\n   similarly:\n
      \  1. Take a value to be encoded as an octet string (we'll use X'7C' as\n      above),
      and prepend to it a four-octet length.  The result is the\n      same, X'00
      00 00 05 7C'.\n   2. Convert this to a character string by introducing '0' and
      'x' at\n      the front, and removing all white space.  Thus we have the 12-\n
      \     character string \"0x000000057C\".  This string is the value of one\n
      \     of the array elements in the CIM string array.  Since CIM uses the\n      UCS-2
      character set, it will require 24 octets to encode this 12-\n      character
      string.\n   Mappings of the PCIM to particular data models are not required
      to\n   follow this CIM technique of representing multi-valued octet strings\n
      \  as length- prefixed character strings.  In an LDAP mapping, for\n   example,
      it would be much more natural to simply use the Octet String\n   syntax, and
      omit the prepended length octets.\n"
    title: 5.4. CIM Data Types
  - contents:
    - "5.5. Comparison between CIM and LDAP Class Specifications\n   There are a number
      of differences between CIM and LDAP class\n   specifications.  The ones that
      are relevant to the abbreviated class\n   specifications in this document are
      listed below.  These items are\n   included here to help introduce the IETF
      community, which is already\n   familiar with LDAP, to CIM modeling, and by
      extension, to information\n   modeling in general.\n   o  Instead of LDAP's
      three class types (abstract, auxiliary,\n      structural), CIM has only two:
      \ abstract and instantiable.  The\n      type of a CIM class is indicated by
      the Boolean qualifier\n      ABSTRACT.\n   o  CIM uses the term \"property\"
      for what LDAP terms an \"attribute\".\n   o  CIM uses the array notation \"[
      ]\" to indicate that a property is\n      multi-valued.  CIM defines three types
      of arrays: bags (contents\n      are unordered, duplicates allowed), ordered
      bags (contents are\n      ordered but duplicates are allowed) and indexed arrays
      (contents\n      are ordered and no duplicates are allowed).\n   o  CIM classes
      and properties are identified by name, not by OID.\n   o  CIM classes use a
      different naming scheme for native\n      implementations, than LDAP.  The CIM
      naming scheme is documented\n      in Appendix A since it is not critical to
      understanding the\n      information model, and only applies when communicating
      with a\n      native CIM implementation.\n   o  In LDAP, attribute definitions
      are global, and the same attribute\n      may appear in multiple classes.  In
      CIM, a property is defined\n      within the scope of a single class definition.
      \ The property may\n      be inherited into subclasses of the class in which
      it is defined,\n      but otherwise it cannot appear in other classes.  One
      side effect\n      of this difference is that CIM property names tend to be
      much\n      shorter than LDAP attribute names, since they are implicitly\n      scoped
      by the name of the class in which they are defined.\n   There is also a notational
      convention that this document follows, to\n   improve readability.  In CIM,
      all class and property names are\n   prefixed with the characters \"CIM_\".
      \ These prefixes have been\n   omitted throughout this document, with one exception
      regarding\n   naming, documented in Appendix A.\n   For the complete definition
      of the CIM specification language, see\n   reference [2].\n"
    title: 5.5. Comparison between CIM and LDAP Class Specifications
  title: 5. Details of the Model
- contents:
  - "6. Class Definitions\n   The following sections contain the definitions of the
    PCIM classes.\n"
  - contents:
    - "6.1. The Abstract Class \"Policy\"\n   The abstract class Policy collects several
      properties that may be\n   included in instances of any of the Core Policy classes
      (or their\n   subclasses).  For convenience, the two properties that Policy\n
      \  inherits from ManagedElement in the CIM schema are shown here as\n   well.\n
      \  The class definition is as follows:\n      NAME             Policy\n      DESCRIPTION
      \     An abstract class with four properties for\n                       describing
      a policy-related instance.\n      DERIVED FROM     ManagedElement\n      ABSTRACT
      \        TRUE\n      PROPERTIES       CommonName (CN)\n                       PolicyKeywords[
      ]\n                              // Caption (inherited)\n                              //
      Description (inherited)\n"
    - contents:
      - "6.1.1. The Property \"CommonName (CN)\"\n   The CN, or CommonName, property
        corresponds to the X.500 attribute\n   commonName (cn).  In X.500 this property
        specifies one or more user-\n   friendly names (typically only one name) by
        which an object is\n   commonly known, names that conform to the naming conventions
        of the\n   country or culture with which the object is associated.  In the
        CIM\n   model, however, the CommonName property is single-valued.\n      NAME
        \            CN\n      DESCRIPTION      A user-friendly name of a policy-related
        object.\n      SYNTAX           string\n"
      title: 6.1.1. The Property "CommonName (CN)"
    - contents:
      - "6.1.2. The Multi-valued Property \"PolicyKeywords\"\n   This property provides
        a set of one or more keywords that a policy\n   administrator may use to assist
        in characterizing or categorizing a\n   policy object.  Keywords are of one
        of two types:\n   o  Keywords defined in this document, or in documents that
        define\n      subclasses of the classes defined in this document.  These\n
        \     keywords provide a vendor-independent, installation-independent\n      way
        of characterizing policy objects.\n   o  Installation-dependent keywords for
        characterizing policy objects.\n      Examples include \"Engineering\", \"Billing\",
        and \"Review in December\n      2000\".\n   This document defines the following
        keywords:  \"UNKNOWN\",\n   \"CONFIGURATION\", \"USAGE\", \"SECURITY\", \"SERVICE\",
        \"MOTIVATIONAL\",\n   \"INSTALLATION\", and \"EVENT\".  These concepts were
        defined earlier in\n   Section 2.\n   One additional keyword is defined:  \"POLICY\".
        \ The role of this\n   keyword is to identify policy-related instances that
        would not\n   otherwise be identifiable as being related to policy.  It may
        be\n   needed in some repository implementations.\n   Documents that define
        subclasses of the Policy Core Information Model\n   classes SHOULD define
        additional keywords to characterize instances\n   of these subclasses.  By
        convention, keywords defined in conjunction\n   with class definitions are
        in uppercase.  Installation-defined\n   keywords can be in any case.\n   The
        property definition is as follows:\n   NAME             PolicyKeywords\n   DESCRIPTION
        \     A set of keywords for characterizing /categorizing\n                    policy
        objects.\n   SYNTAX           string\n"
      title: 6.1.2. The Multi-valued Property "PolicyKeywords"
    - contents:
      - "6.1.3. The Property \"Caption\" (Inherited from ManagedElement)\n   This
        property provides a one-line description of a policy-related\n   object.\n
        \  NAME             Caption\n   DESCRIPTION      A one-line description of
        this policy-related object.\n   SYNTAX           string\n"
      title: 6.1.3. The Property "Caption" (Inherited from ManagedElement)
    - contents:
      - "6.1.4. The Property \"Description\" (Inherited from ManagedElement)\n   This
        property provides a longer description than that provided by the\n   caption
        property.\n   NAME             Description\n   DESCRIPTION      A long description
        of this policy-related object.\n   SYNTAX           string\n"
      title: 6.1.4. The Property "Description" (Inherited from ManagedElement)
    title: 6.1. The Abstract Class "Policy"
  - contents:
    - "6.2. The Class \"PolicyGroup\"\n   This class is a generalized aggregation
      container.  It enables either\n   PolicyRules or PolicyGroups to be aggregated
      in a single container.\n   Loops, including the degenerate case of a PolicyGroup
      that contains\n   itself, are not allowed when PolicyGroups contain other PolicyGroups.\n
      \  PolicyGroups and their nesting capabilities are shown in Figure 5\n   below.
      \ Note that a PolicyGroup can nest other PolicyGroups, and\n   there is no restriction
      on the depth of the nesting in sibling\n   PolicyGroups.\n         +---------------------------------------------------+\n
      \        |                    PolicyGroup                    |\n         |                                                   |\n
      \        | +--------------------+       +-----------------+  |\n         | |
      \   PolicyGroup A   |       |  PolicyGroup X  |  |\n         | |                    |
      \      |                 |  |\n         | | +----------------+ |  ooo  |                 |
      \ |\n         | | | PolicyGroup A1 | |       |                 |  |\n         |
      | +----------------+ |       |                 |  |\n         | +--------------------+
      \      +-----------------+  |\n         +---------------------------------------------------+\n
      \           Figure 5.    Overview of the PolicyGroup class\n   As a simple example,
      think of the highest level PolicyGroup shown in\n   Figure 5 above as a logon
      policy for US employees of a company.  This\n   PolicyGroup may be called USEmployeeLogonPolicy,
      and may aggregate\n   several PolicyGroups that provide specialized rules per
      location.\n   Hence, PolicyGroup A in Figure 5 above may define logon rules
      for\n   employees on the West Coast, while another PolicyGroup might define\n
      \  logon rules for the Midwest (e.g., PolicyGroup X), and so forth.\n   Note
      also that the depth of each PolicyGroup does not need to be the\n   same.  Thus,
      the WestCoast PolicyGroup might have several additional\n   layers of PolicyGroups
      defined for any of several reasons (different\n   locales, number of subnets,
      etc..).  The PolicyRules are therefore\n   contained at n levels from the USEmployeeLogonPolicyGroup.
      \ Compare\n   this to the Midwest PolicyGroup (PolicyGroup X), which might directly\n
      \  contain PolicyRules.\n   The class definition for PolicyGroup is as follows:\n
      \     NAME             PolicyGroup\n      DESCRIPTION      A container for either
      a set of related\n                       PolicyRules or a set of related PolicyGroups.\n
      \     DERIVED FROM     Policy\n      ABSTRACT         FALSE\n      PROPERTIES
      \      NONE\n   No properties are defined for this class since it inherits all
      its\n   properties from Policy.  The class exists to aggregate PolicyRules or\n
      \  other PolicyGroups.  It is directly instantiable.  In an\n   implementation,
      various key/identification properties MUST be\n   defined.  The keys for a native
      CIM implementation are defined in\n   Appendix A, Section 13.1.1.  Keys for
      an LDAP implementation will be\n   defined in the LDAP mapping of this information
      model [11].\n"
    title: 6.2. The Class "PolicyGroup"
  - contents:
    - "6.3. The Class \"PolicyRule\"\n   This class represents the \"If Condition
      then Action\" semantics\n   associated with a policy.  A PolicyRule condition,
      in the most\n   general sense, is represented as either an ORed set of ANDed\n
      \  conditions (Disjunctive Normal Form, or DNF) or an ANDed set of ORed\n   conditions
      (Conjunctive Normal Form, or CNF).  Individual conditions\n   may either be
      negated (NOT C) or unnegated (C).  The actions\n   specified by a PolicyRule
      are to be performed if and only if the\n   PolicyRule condition (whether it
      is represented in DNF or CNF)\n   evaluates to TRUE.\n   The conditions and
      actions associated with a policy rule are modeled,\n   respectively, with subclasses
      of the classes PolicyCondition and\n   PolicyAction.  These condition and action
      objects are tied to\n   instances of PolicyRule by the PolicyConditionInPolicyRule
      and\n   PolicyActionInPolicyRule aggregations.\n   As illustrated above in Section
      3, a policy rule may also be\n   associated with one or more policy time periods,
      indicating the\n   schedule according to which the policy rule is active and
      inactive.\n   In this case it is the PolicyRuleValidityPeriod aggregation that\n
      \  provides the linkage.\n   A policy rule is illustrated conceptually in Figure
      6. below.\n            +------------------------------------------------+\n
      \           |                    PolicyRule                  |\n            |
      \                                               |\n            | +--------------------+
      \    +-----------------+ |\n            | | PolicyCondition(s) |     | PolicyAction(s)
      | |\n            | +--------------------+     +-----------------+ |\n            |
      \                                               |\n            |        +------------------------------+
      \       |\n            |        | PolicyTimePeriodCondition(s) |        |\n
      \           |        +------------------------------+        |\n            +------------------------------------------------+\n
      \             Figure 6.    Overview of the PolicyRule Class\n   The PolicyRule
      class uses the property ConditionListType, to indicate\n   whether the conditions
      for the rule are in DNF or CNF.  The\n   PolicyConditionInPolicyRule aggregation
      contains two additional\n   properties to complete the representation of the
      rule's conditional\n   expression.  The first of these properties is an integer
      to partition\n   the referenced conditions into one or more groups, and the
      second is\n   a Boolean to indicate whether a referenced condition is negated.
      \ An\n   example shows how ConditionListType and these two additional\n   properties
      provide a unique representation of a set of conditions in\n   either DNF or
      CNF.\n   Suppose we have a PolicyRule that aggregates five PolicyConditions
      C1\n   through C5, with the following values in the properties of the five\n
      \  PolicyConditionInPolicyRule associations:\n      C1:  GroupNumber = 1, ConditionNegated
      = FALSE\n      C2:  GroupNumber = 1, ConditionNegated = TRUE\n      C3:  GroupNumber
      = 1, ConditionNegated = FALSE\n      C4:  GroupNumber = 2, ConditionNegated
      = FALSE\n      C5:  GroupNumber = 2, ConditionNegated = FALSE\n   If ConditionListType
      = DNF, then the overall condition for the\n   PolicyRule is:\n      (C1 AND
      (NOT C2) AND C3) OR (C4 AND C5)\n   On the other hand, if ConditionListType
      = CNF, then the overall\n   condition for the PolicyRule is:\n      (C1 OR (NOT
      C2) OR C3) AND (C4 OR C5)\n   In both cases, there is an unambiguous specification
      of the overall\n   condition that is tested to determine whether to perform
      the actions\n   associated with the PolicyRule.\n   The class definition is
      as follows:\n   NAME             PolicyRule\n   DESCRIPTION      The central
      class for representing the \"If Condition\n                    then Action\"
      semantics associated with a policy rule.\n   DERIVED FROM     Policy\n   ABSTRACT
      \        FALSE\n   PROPERTIES       Enabled\n                    ConditionListType\n
      \                   RuleUsage\n                    Priority\n                    Mandatory\n
      \                   SequencedActions\n                    PolicyRoles\n   The
      PolicyRule class is directly instantiable.  In an implementation,\n   various
      key/identification properties MUST be defined.  The keys for\n   a native CIM
      implementation are defined in Appendix A, Section\n   13.1.2.  Keys for an LDAP
      implementation will be defined in the LDAP\n   mapping of this information model
      [11].\n"
    - contents:
      - "6.3.1. The Property \"Enabled\"\n   This property indicates whether a policy
        rule is currently enabled,\n   from an administrative point of view.  Its
        purpose is to allow a\n   policy administrator to enable or disable a policy
        rule without\n   having to add it to, or remove it from, the policy repository.\n
        \  The property also supports the value 'enabledForDebug'.  When the\n   property
        has this value, the entity evaluating the policy\n   condition(s) is being
        told to evaluate the conditions for the policy\n   rule, but not to perform
        the actions if the conditions evaluate to\n   TRUE.  This value serves as
        a debug vehicle when attempting to\n   determine what policies would execute
        in a particular scenario,\n   without taking any actions to change state during
        the debugging.\n   The property definition is as follows:\n   NAME             Enabled\n
        \  DESCRIPTION      An enumeration indicating whether a policy rule is\n                    administratively
        enabled, administratively disabled,\n                    or enabled for debug
        mode.\n   SYNTAX           uint16\n   VALUES           enabled(1), disabled(2),
        enabledForDebug(3)\n   DEFAULT VALUE    enabled(1)\n"
      title: 6.3.1. The Property "Enabled"
    - contents:
      - "6.3.2. The Property \"ConditionListType\"\n   This property is used to specify
        whether the list of policy\n   conditions associated with this policy rule
        is in disjunctive normal\n   form (DNF) or conjunctive normal form (CNF).
        \ If this property is not\n   present, the list type defaults to DNF.  The
        property definition is\n   as follows:\n   NAME             ConditionListType\n
        \  DESCRIPTION      Indicates whether the list of policy conditions\n                    associated
        with this policy rule is in disjunctive\n                    normal form (DNF)
        or conjunctive normal form (CNF).\n   SYNTAX           uint16\n   VALUES           DNF(1),
        CNF(2)\n   DEFAULT VALUE    DNF(1)\n"
      title: 6.3.2. The Property "ConditionListType"
    - contents:
      - "6.3.3. The Property \"RuleUsage\"\n   This property is a free-form string
        that recommends how this policy\n   should be used.  The property definition
        is as follows:\n      NAME             RuleUsage\n      DESCRIPTION      This
        property is used to provide guidelines on\n                       how this
        policy should be used.\n      SYNTAX           string\n"
      title: 6.3.3. The Property "RuleUsage"
    - contents:
      - "6.3.4. The Property \"Priority\"\n   This property provides a non-negative
        integer for prioritizing policy\n   rules relative to each other.  Larger
        integer values indicate higher\n   priority.  Since one purpose of this property
        is to allow specific,\n   ad hoc policy rules to temporarily override established
        policy rules,\n   an instance that has this property set has a higher priority
        than all\n   instances that use or set the default value of zero.\n   Prioritization
        among policy rules provides a basic mechanism for\n   resolving policy conflicts.\n
        \  The property definition is as follows:\n   NAME             Priority\n
        \  DESCRIPTION      A non-negative integer for prioritizing this\n                    PolicyRule
        relative to other PolicyRules.  A larger\n                    value indicates
        a higher priority.\n   SYNTAX           uint16\n   DEFAULT VALUE    0\n"
      title: 6.3.4. The Property "Priority"
    - contents:
      - "6.3.5. The Property \"Mandatory\"\n   This property indicates whether evaluation
        (and possibly action\n   execution) of a PolicyRule is mandatory or not.  Its
        concept is\n   similar to the ability to mark packets for delivery or possible\n
        \  discard, based on network traffic and device load.\n   The evaluation of
        a PolicyRule MUST be attempted if the Mandatory\n   property value is TRUE.
        \ If the Mandatory property value of a\n   PolicyRule is FALSE, then the evaluation
        of the rule is \"best effort\"\n   and MAY be ignored.\n   The property definition
        is as follows:\n      NAME             Mandatory\n      DESCRIPTION      A
        flag indicating that the evaluation of the\n                       PolicyConditions
        and execution of PolicyActions\n                       (if the condition list
        evaluates to TRUE) is\n                       required.\n      SYNTAX           boolean\n
        \     DEFAULT VALUE    TRUE\n"
      title: 6.3.5. The Property "Mandatory"
    - contents:
      - "6.3.6. The Property \"SequencedActions\"\n   This property gives a policy
        administrator a way of specifying how\n   the ordering of the policy actions
        associated with this PolicyRule is\n   to be interpreted.  Three values are
        supported:\n   o  mandatory(1):   Do the actions in the indicated order, or
        don't do\n      them at all.\n   o  recommended(2): Do the actions in the
        indicated order if you can,\n      but if you can't do them in this order,
        do them in another order\n      if you can.\n   o  dontCare(3):    Do them
        -- I don't care about the order.\n   When error / event reporting is addressed
        for the Policy Framework,\n   suitable codes will be defined for reporting
        that a set of actions\n   could not be performed in an order specified as
        mandatory (and thus\n   were not performed at all), that a set of actions
        could not be\n   performed in a recommended order (and moreover could not
        be performed\n   in any order), or that a set of actions could not be performed
        in a\n   recommended order (but were performed in a different order).  The\n
        \  property definition is as follows:\n      NAME             SequencedActions\n
        \     DESCRIPTION      An enumeration indicating how to interpret the\n                       action
        ordering indicated via the\n                       PolicyActionInPolicyRule
        aggregation.\n      SYNTAX           uint16\n      VALUES           mandatory(1),
        recommended(2), dontCare(3)\n      DEFAULT VALUE    dontCare(3)\n"
      title: 6.3.6. The Property "SequencedActions"
    - contents:
      - "6.3.7. The Multi-valued Property \"PolicyRoles\"\n   This property represents
        the roles and role combinations associated\n   with a policy rule.  Each value
        represents one role combination.\n   Since this is a multi-valued property,
        more than one role combination\n   can be associated with a single policy
        rule.  Each value is a string\n   of the form\n      <RoleName>[&&<RoleName>]*\n
        \  where the individual role names appear in alphabetical order\n   (according
        to the collating sequence for UCS-2).  The property\n   definition is as follows:\n
        \     NAME             PolicyRoles\n      DESCRIPTION      A set of strings
        representing the roles and role\n                       combinations associated
        with a policy rule.  Each\n                       value represents one role
        combination.\n      SYNTAX           string\n"
      title: 6.3.7. The Multi-valued Property "PolicyRoles"
    title: 6.3. The Class "PolicyRule"
  - contents:
    - "6.4. The Abstract Class \"PolicyCondition\"\n   The purpose of a policy condition
      is to determine whether or not the\n   set of actions (aggregated in the PolicyRule
      that the condition\n   applies to) should be executed or not.  For the purposes
      of the\n   Policy  Core Information Model, all that matters about an individual\n
      \  PolicyCondition is that it evaluates to TRUE or FALSE.  (The\n   individual
      PolicyConditions associated with a PolicyRule are combined\n   to form a compound
      expression in either DNF or CNF, but this is\n   accomplished via the ConditionListType
      property, discussed above, and\n   by the properties of the PolicyConditionInPolicyRule
      aggregation,\n   introduced above and discussed further in Section 7.6 below.)
      \ A\n   logical structure within an individual PolicyCondition may also be\n
      \  introduced, but this would have to be done in a subclass of\n   PolicyCondition.\n
      \  Because it is general, the PolicyCondition class does not itself\n   contain
      any \"real\" conditions.  These will be represented by\n   properties of the
      domain-specific subclasses of PolicyCondition.\n      +---------------------------------------------------------------+\n
      \     |                    Policy Conditions in DNF                   |\n      |
      +-------------------------+         +-----------------------+ |\n      | |       AND
      list          |         |      AND list         | |\n      | |  +-------------------+
      \ |         |  +-----------------+  | |\n      | |  |  PolicyCondition  |  |
      \        |  | PolicyCondition |  | |\n      | |  +-------------------+  |         |
      \ +-----------------+  | |\n      | |  +-------------------+  |         |  +-----------------+
      \ | |\n      | |  |  PolicyCondition  |  |   ...   |  | PolicyCondition |  |
      |\n      | |  +-------------------+  |   ORed  |  +-----------------+  | |\n
      \     | |          ...            |         |         ...           | |\n      |
      |         ANDed           |         |        ANDed          | |\n      | |  +-------------------+
      \ |         |  +-----------------+  | |\n      | |  |  PolicyCondition  |  |
      \        |  | PolicyCondition |  | |\n      | |  +-------------------+  |         |
      \ +-----------------+  | |\n      | +-------------------------+         +-----------------------+
      |\n      +---------------------------------------------------------------+\n
      \            Figure 7.    Overview of Policy Conditions in DNF\n   This figure
      illustrates that when policy conditions are in DNF, there\n   are one or more
      sets of conditions that are ANDed together to form\n   AND lists.  An AND list
      evaluates to TRUE if and only if all of its\n   constituent conditions evaluate
      to TRUE.  The overall condition then\n   evaluates to TRUE if and only if at
      least one of its constituent AND\n   lists evaluates to TRUE.\n      +---------------------------------------------------------------+\n
      \     |                    Policy Conditions in CNF                   |\n      |
      +-------------------------+         +-----------------------+ |\n      | |        OR
      list          |         |       OR list         | |\n      | |  +-------------------+
      \ |         |  +-----------------+  | |\n      | |  |  PolicyCondition  |  |
      \        |  | PolicyCondition |  | |\n      | |  +-------------------+  |         |
      \ +-----------------+  | |\n      | |  +-------------------+  |         |  +-----------------+
      \ | |\n      | |  |  PolicyCondition  |  |   ...   |  | PolicyCondition |  |
      |\n      | |  +-------------------+  |  ANDed  |  +-----------------+  | |\n
      \     | |          ...            |         |         ...           | |\n      |
      |         ORed            |         |         ORed          | |\n      | |  +-------------------+
      \ |         |  +-----------------+  | |\n      | |  |  PolicyCondition  |  |
      \        |  | PolicyCondition |  | |\n      | |  +-------------------+  |         |
      \ +-----------------+  | |\n      | +-------------------------+         +-----------------------+
      |\n      +---------------------------------------------------------------+\n
      \            Figure 8.    Overview of Policy Conditions in CNF\n   In this figure,
      the policy conditions are in CNF.  Consequently,\n   there are one or more OR
      lists, each of which evaluates to TRUE if\n   and only if at least one of its
      constituent conditions evaluates to\n   TRUE.  The overall condition then evaluates
      to TRUE if and only if\n   ALL of its constituent OR lists evaluate to TRUE.\n
      \  The class definition of PolicyCondition is as follows:\n      NAME             PolicyCondition\n
      \     DESCRIPTION      A class representing a rule-specific or reusable\n                       policy
      condition to be evaluated in conjunction\n                       with a policy
      rule.\n      DERIVED FROM     Policy\n      ABSTRACT         TRUE\n      PROPERTIES
      \      NONE\n   No properties are defined for this class since it inherits all
      its\n   properties from Policy.  The class exists as an abstract superclass\n
      \  for domain-specific policy conditions, defined in subclasses.  In an\n   implementation,
      various key/identification properties MUST be defined\n   for the class or its
      instantiable subclasses.  The keys for a native\n   CIM implementation are defined
      in Appendix A, Section 13.2.  Keys for\n   an LDAP implementation will be defined
      in the LDAP mapping of this\n   information model [11].\n   When identifying
      and using the PolicyCondition class, it is necessary\n   to remember that a
      condition can be rule-specific or reusable.  This\n   was discussed above in
      Section 5.1.  The distinction between the two\n   types of policy conditions
      lies in the associations in which an\n   instance can participate, and in how
      the different instances are\n   named.  Conceptually, a reusable policy condition
      resides in a policy\n   repository, and is named within the scope of that repository.
      \ On the\n   other hand, a rule-specific policy condition is, as the name\n
      \  suggests, named within the scope of the single policy rule to which\n   it
      is related.\n   The distinction between rule-specific and reusable PolicyConditions\n
      \  affects the CIM naming, defined in Appendix A, and the LDAP mapping\n   [11].\n"
    title: 6.4. The Abstract Class "PolicyCondition"
  - contents:
    - "6.5. The Class \"PolicyTimePeriodCondition\"\n   This class provides a means
      of representing the time periods during\n   which a policy rule is valid, i.e.,
      active.  At all times that fall\n   outside these time periods, the policy rule
      has no effect.  A policy\n   rule is treated as valid at all times if it does
      not specify a\n   PolicyTimePeriodCondition.\n   In some cases a PDP may need
      to perform certain setup / cleanup\n   actions when a policy rule becomes active
      / inactive.  For example,\n   sessions that were established while a policy
      rule was active might\n   need to be taken down when the rule becomes inactive.
      \ In other\n   cases, however, such sessions might be left up:  in this case,
      the\n   effect of deactivating the policy rule would just be to prevent the\n
      \  establishment of new sessions.  Setup / cleanup behaviors on validity\n   period
      transitions are not currently addressed by the PCIM, and must\n   be specified
      in 'guideline' documents, or via subclasses of\n   PolicyRule, PolicyTimePeriodCondition
      or other concrete subclasses of\n   Policy.  If such behaviors need to be under
      the control of the policy\n   administrator, then a mechanism to allow this
      control must also be\n   specified in the subclass.\n   PolicyTimePeriodCondition
      is defined as a subclass of\n   PolicyCondition.  This is to allow the inclusion
      of time-based\n   criteria in the AND/OR condition definitions for a PolicyRule.\n
      \  Instances of this class may have up to five properties identifying\n   time
      periods at different levels.  The values of all the properties\n   present in
      an instance are ANDed together to determine the validity\n   period(s) for the
      instance.  For example, an instance with an overall\n   validity range of January
      1, 2000 through December 31, 2000; a month\n   mask that selects March and April;
      a day-of-the-week mask that\n   selects Fridays; and a time of day range of
      0800 through 1600 would\n   represent the following time periods:\n      Friday,
      March  5, 2000, from 0800 through 1600;\n      Friday, March 12, 2000, from
      0800 through 1600;\n      Friday, March 19, 2000, from 0800 through 1600;\n
      \     Friday, March 26, 2000, from 0800 through 1600;\n      Friday, April  2,
      2000, from 0800 through 1600;\n      Friday, April  9, 2000, from 0800 through
      1600;\n      Friday, April 16, 2000, from 0800 through 1600;\n      Friday,
      April 23, 2000, from 0800 through 1600;\n      Friday, April 30, 2000, from
      0800 through 1600.\n   Properties not present in an instance of PolicyTimePeriodCondition\n
      \  are implicitly treated as having their value \"always enabled\".  Thus,\n
      \  in the example above, the day-of-the-month mask is not present, and\n   so
      the validity period for the instance implicitly includes a day-\n   of-the-month
      mask that selects all days of the month.  If we apply\n   this \"missing property\"
      rule to its fullest, we see that there is a\n   second way to indicate that
      a policy rule is always enabled: have it\n   point to an instance of PolicyTimePeriodCondition
      whose only\n   properties are its naming properties.\n   The property LocalOrUtcTime
      indicates whether the times represented\n   in the other five time-related properties
      of an instance of\n   PolicyTimePeriodCondition are to be interpreted as local
      times for\n   the location where a policy rule is being applied, or as UTC times.\n
      \  The class definition is as follows.\n   NAME             PolicyTimePeriodCondition\n
      \  DESCRIPTION      A class that provides the capability of enabling /\n                    disabling
      a policy rule according to a\n                    pre-determined schedule.\n
      \  DERIVED FROM     PolicyCondition\n   ABSTRACT         FALSE\n   PROPERTIES
      \      TimePeriod\n                    MonthOfYearMask\n                    DayOfMonthMask\n
      \                   DayOfWeekMask\n                    TimeOfDayMask\n                    LocalOrUtcTime\n"
    - contents:
      - "6.5.1. The Property \"TimePeriod\"\n   This property identifies an overall
        range of calendar dates and times\n   over which a policy rule is valid.  It
        reuses the format for an\n   explicit time period defined in RFC 2445 (reference
        [10]): a string\n   representing a starting date and time, in which the character
        'T'\n   indicates the beginning of the time portion, followed by the solidus\n
        \  character '/', followed by a similar string representing an end date\n
        \  and time.  The first date indicates the beginning of the range, while\n
        \  the second date indicates the end.  Thus, the second date and time\n   must
        be later than the first.  Date/times are expressed as substrings\n   of the
        form \"yyyymmddThhmmss\".  For example:\n      20000101T080000/20000131T120000\n
        \        January 1, 2000, 0800 through January 31, 2000, noon\n   There are
        also two special cases in which one of the date/time\n   strings is replaced
        with a special string defined in RFC 2445.\n   o  If the first date/time is
        replaced with the string \"THISANDPRIOR\",\n      then the property indicates
        that a policy rule is valid [from now]\n      until the date/time that appears
        after the '/'.\n   o  If the second date/time is replaced with the string\n
        \     \"THISANDFUTURE\", then the property indicates that a policy rule\n
        \     becomes valid on the date/time that appears before the '/', and\n      remains
        valid from that point on.\n   Note that RFC 2445 does not use these two strings
        in connection with\n   explicit time periods.  Thus the PCIM is combining
        two elements from\n   RFC 2445 that are not combined in the RFC itself.\n
        \  The property definition is as follows:\n      NAME             TimePeriod\n
        \     DESCRIPTION      The range of calendar dates on which a policy\n                       rule
        is valid.\n      SYNTAX           string\n      FORMAT           yyyymmddThhmmss/yyyymmddThhmmss,
        where the first\n                       date/time may be replaced with the
        string\n                       \"THISANDPRIOR\" or the second date/time may
        be\n                       replaced with the string \"THISANDFUTURE\"\n"
      title: 6.5.1. The Property "TimePeriod"
    - contents:
      - "6.5.2. The Property \"MonthOfYearMask\"\n   The purpose of this property
        is to refine the definition of the valid\n   time period that is defined by
        the TimePeriod property, by explicitly\n   specifying the months when the
        policy is valid.  These properties\n   work together, with the TimePeriod
        used to specify the overall time\n   period during which the policy might
        be valid, and the\n   MonthOfYearMask used to pick out the specific months
        within that time\n   period when the policy is valid.\n   This property is
        formatted as an octet string of size 2, consisting\n   of 12 bits identifying
        the 12 months of the year, beginning with\n   January and ending with December,
        followed by 4 bits that are always\n   set to '0'.  For each month, the value
        '1' indicates that the policy\n   is valid for that month, and the value '0'
        indicates that it is not\n   valid.  The value X'08 30', for example, indicates
        that a policy rule\n   is valid only in the months May, November, and December.\n
        \  See section 5.4 for details of how CIM represents a single-valued\n   octet
        string property such as this one.  (Basically, CIM prepends a\n   4-octet
        length to the octet string.)\n   If this property is omitted, then the policy
        rule is treated as valid\n   for all twelve months.  The property definition
        is as follows:\n      NAME             MonthOfYearMask\n      DESCRIPTION
        \     A mask identifying the months of the year in\n                       which
        a policy rule is valid.\n      SYNTAX           octet string\n      FORMAT
        \          X'hh h0'\n"
      title: 6.5.2. The Property "MonthOfYearMask"
    - contents:
      - "6.5.3. The Property \"DayOfMonthMask\"\n   The purpose of this property is
        to refine the definition of the valid\n   time period that is defined by the
        TimePeriod property, by explicitly\n   specifying the days of the month when
        the policy is valid.  These\n   properties work together, with the TimePeriod
        used to specify the\n   overall time period during which the policy might
        be valid, and the\n   DayOfMonthMask used to pick out the specific days of
        the month within\n   that time period when the policy is valid.\n   This property
        is formatted as an octet string of size 8, consisting\n   of 31 bits identifying
        the days of the month counting from the\n   beginning, followed by 31 more
        bits identifying the days of the month\n   counting from the end, followed
        by 2 bits that are always set to '0'.\n   For each day, the value '1' indicates
        that the policy is valid for\n   that day, and the value '0' indicates that
        it is not valid.\n   The value X'80 00 00 01 00 00 00 00', for example, indicates
        that a\n   policy rule is valid on the first and last days of the month.\n
        \  For months with fewer than 31 days, the digits corresponding to days\n
        \  that the months do not have (counting in both directions) are\n   ignored.\n
        \  The encoding of the 62 significant bits in the octet string matches\n   that
        used for the schedDay object in the DISMAN-SCHEDULE-MIB.  See\n   reference
        [8] for more details on this object.\n   See section 5.4 for details of how
        CIM represents a single-valued\n   octet string property such as this one.
        \ (Basically, CIM prepends a\n   4-octet length to the octet string.)\n   The
        property definition is as follows:\n      NAME             DayOfMonthMask\n
        \     DESCRIPTION      A mask identifying the days of the month on\n                       which
        a policy rule is valid.\n      SYNTAX           octet string\n      FORMAT
        \          X'hh hh hh hh hh hh hh hh'\n"
      title: 6.5.3. The Property "DayOfMonthMask"
    - contents:
      - "6.5.4. The Property \"DayOfWeekMask\"\n   The purpose of this property is
        to refine the definition of the valid\n   time period that is defined by the
        TimePeriod property by explicitly\n   specifying the days of the week when
        the policy is valid.  These\n   properties work together, with the TimePeriod
        used to specify the\n   overall time period when the policy might be valid,
        and the\n   DayOfWeekMask used to pick out the specific days of the week in
        that\n   time period when the policy is valid.\n   This property is formatted
        as an octet string of size 1, consisting\n   of 7 bits identifying the 7 days
        of the week, beginning with Sunday\n   and ending with Saturday, followed
        by 1 bit that is always set to\n   '0'.  For each day of the week, the value
        '1' indicates that the\n   policy is valid for that day, and the value '0'
        indicates that it is\n   not valid.\n   The value X'7C', for example, indicates
        that a policy rule is valid\n   Monday through Friday.\n   See section 5.4
        for details of how CIM represents a single-valued\n   octet string property
        such as this one.  (Basically, CIM prepends a\n   4-octet length to the octet
        string.)\n   The property definition is as follows:\n      NAME             DayOfWeekMask\n
        \     DESCRIPTION      A mask identifying the days of the week on which\n
        \                      a policy rule is valid.\n      SYNTAX           octet
        string\n      FORMAT           B'bbbb bbb0'\n"
      title: 6.5.4. The Property "DayOfWeekMask"
    - contents:
      - "6.5.5. The Property \"TimeOfDayMask\"\n   The purpose of this property is
        to refine the definition of the valid\n   time period that is defined by the
        TimePeriod property by explicitly\n   specifying a range of times in a day
        the policy is valid for.  These\n   properties work together, with the TimePeriod
        used to specify the\n   overall time period that the policy is valid for,
        and the\n   TimeOfDayMask used to pick out which range of time periods in
        a given\n   day of that time period the policy is valid for.\n   This property
        is formatted in the style of RFC 2445 [10]:  a time\n   string beginning with
        the character 'T', followed by the solidus\n   character '/', followed by
        a second time string.  The first time\n   indicates the beginning of the range,
        while the second time indicates\n   the end.  Times are expressed as substrings
        of the form \"Thhmmss\".\n   The second substring always identifies a later
        time than the first\n   substring.  To allow for ranges that span midnight,
        however, the\n   value of the second string may be smaller than the value
        of the first\n   substring.  Thus, \"T080000/T210000\" identifies the range
        from 0800\n   until 2100, while \"T210000/T080000\" identifies the range from
        2100\n   until 0800 of the following day.\n   When a range spans midnight,
        it by definition includes parts of two\n   successive days.  When one of these
        days is also selected by either\n   the MonthOfYearMask, DayOfMonthMask, and/or
        DayOfWeekMask, but the\n   other day is not, then the policy is active only
        during the portion\n   of the range that falls on the selected day.  For example,
        if the\n   range extends from 2100 until 0800, and the day of week mask selects\n
        \  Monday and Tuesday, then the policy is active during the following\n   three
        intervals:\n      From midnight Sunday until 0800 Monday;\n      From 2100
        Monday until 0800 Tuesday;\n      From 2100 Tuesday until 23:59:59 Tuesday.\n
        \  The property definition is as follows:\n      NAME             TimeOfDayMask\n
        \     DESCRIPTION      The range of times at which a policy rule is\n                       valid.
        \ If the second time is earlier than the\n                       first, then
        the interval spans midnight.\n      SYNTAX           string\n      FORMAT
        \          Thhmmss/Thhmmss\n"
      title: 6.5.5. The Property "TimeOfDayMask"
    - contents:
      - "6.5.6. The Property \"LocalOrUtcTime\"\n   This property indicates whether
        the times represented in the\n   TimePeriod property and in the various Mask
        properties represent\n   local times or UTC times.  There is no provision
        for mixing of local\n   times and UTC times:  the value of this property applies
        to all of\n   the other time-related properties.\n   The property definition
        is as follows:\n      NAME             LocalOrUtcTime\n      DESCRIPTION      An
        indication of whether the other times in this\n                       instance
        represent local times or UTC times.\n      SYNTAX           uint16\n      VALUES
        \          localTime(1), utcTime(2)\n      DEFAULT VALUE    utcTime(2)\n"
      title: 6.5.6. The Property "LocalOrUtcTime"
    title: 6.5. The Class "PolicyTimePeriodCondition"
  - contents:
    - "6.6. The Class \"VendorPolicyCondition\"\n   The purpose of this class is to
      provide a general extension mechanism\n   for representing policy conditions
      that have not been modeled with\n   specific properties.  Instead, the two properties
      Constraint and\n   ConstraintEncoding are used to define the content and format
      of the\n   condition, as explained below.\n   As its name suggests, this class
      is intended for vendor-specific\n   extensions to the Policy Core Information
      Model.  Standardized\n   extensions are not expected to use this class.\n   The
      class definition is as follows:\n      NAME             VendorPolicyCondition\n
      \     DESCRIPTION      A class that defines a registered means to\n                       describe
      a policy condition.\n      DERIVED FROM     PolicyCondition\n      ABSTRACT
      \        FALSE\n      PROPERTIES       Constraint[ ]\n                       ConstraintEncoding\n"
    - contents:
      - "6.6.1. The Multi-valued Property \"Constraint\"\n   This property provides
        a general extension mechanism for representing\n   policy conditions that
        have not been modeled with specific\n   properties.  The format of the octet
        strings in the array is left\n   unspecified in this definition.  It is determined
        by the OID value\n   stored in the property ConstraintEncoding.  Since ConstraintEncoding\n
        \  is single-valued, all the values of Constraint share the same format\n
        \  and semantics.\n   See Section 5.4 for a description of how CIM encodes
        an array of\n   octet strings like this one.\n   A policy decision point can
        readily determine whether it supports the\n   values stored in an instance
        of Constraint by checking the OID value\n   from ConstraintEncoding against
        the set of OIDs it recognizes.  The\n   action for the policy decision point
        to take in case it does not\n   recognize the format of this data could itself
        be modeled as a policy\n   rule, governing the behavior of the policy decision
        point.\n   The property is defined as follows:\n      NAME             Constraint\n
        \     DESCRIPTION      Extension mechanism for representing constraints\n
        \                      that have not been modeled as specific\n                       properties.
        \ The format of the values is\n                       identified by the OID
        stored in the property\n                       ConstraintEncoding.\n      SYNTAX
        \          octet string\n"
      title: 6.6.1. The Multi-valued Property "Constraint"
    - contents:
      - "6.6.2. The Property \"ConstraintEncoding\"\n   This property identifies the
        encoding and semantics of the Constraint\n   property values in this instance.
        \ The value of this property is a\n   single string, representing a single
        OID.\n   The property is defined as follows:\n      NAME             ConstraintEncoding\n
        \     DESCRIPTION      An OID encoded as a string, identifying the format\n
        \                      and semantics for this instance's Constraint\n                       property.
        \ The value is a dotted sequence of\n                       decimal digits
        (for example, \"1.2.100.200\")\n                       representing the arcs
        of the OID.  The characters\n                       in the string are the
        UCS-2 characters\n                       corresponding to the US ASCII encodings
        of the\n                       numeric characters and the period.\n      SYNTAX
        \          string\n"
      title: 6.6.2. The Property "ConstraintEncoding"
    title: 6.6. The Class "VendorPolicyCondition"
  - contents:
    - "6.7. The Abstract Class \"PolicyAction\"\n   The purpose of a policy action
      is to execute one or more operations\n   that will affect network traffic and/or
      systems, devices, etc., in\n   order to achieve a desired state.  This (new)
      state provides one or\n   more (new) behaviors.  A policy action ordinarily
      changes the\n   configuration of one or more elements.\n   A PolicyRule contains
      one or more policy actions.  A policy\n   administrator can assign an order
      to the actions associated with a\n   PolicyRule, complete with an indication
      of whether the indicated\n   order is mandatory, recommended, or of no significance.
      \ Ordering of\n   the actions associated with a PolicyRule is accomplished via
      a\n   property in the PolicyActionInPolicyRule aggregation.\n   The actions
      associated with a PolicyRule are executed if and only if\n   the overall condition(s)
      of the PolicyRule evaluates to TRUE.\n   The class definition of PolicyAction
      is as follows:\n      NAME             PolicyAction\n      DESCRIPTION      A
      class representing a rule-specific or reusable\n                       policy
      action to be performed if the condition for\n                       a policy
      rule evaluates to TRUE.\n      DERIVED FROM     Policy\n      ABSTRACT         TRUE\n
      \     PROPERTIES       NONE\n   No properties are defined for this class since
      it inherits all its\n   properties from Policy.  The class exists as an abstract
      superclass\n   for domain-specific policy actions, defined in subclasses.  In
      an\n   implementation, various key/identification properties MUST be defined\n
      \  for the class or its instantiable subclasses.  The keys for a native\n   CIM
      implementation are defined in Appendix A, Section 13.3.  Keys for\n   an LDAP
      implementation will be defined in the LDAP mapping of this\n   information model
      [11].\n   When identifying and using the PolicyAction class, it is necessary
      to\n   remember that an action can be rule-specific or reusable.  This was\n
      \  discussed above in Section 5.1.  The distinction between the two\n   types
      of policy actions lies in the associations in which an instance\n   can participate,
      and in how the different instances are named.\n   Conceptually, a reusable policy
      action resides in a policy\n   repository, and is named within the scope of
      that repository.  On the\n   other hand, a rule-specific policy action is named
      within the scope\n   of the single policy rule to which it is related.\n   The
      distinction between rule-specific and reusable PolicyActions\n   affects the
      CIM naming, defined in Appendix A, and the LDAP mapping\n   [11].\n"
    title: 6.7. The Abstract Class "PolicyAction"
  - contents:
    - "6.8. The Class \"VendorPolicyAction\"\n   The purpose of this class is to provide
      a general extension mechanism\n   for representing policy actions that have
      not been modeled with\n   specific properties.  Instead, the two properties
      ActionData and\n   ActionEncoding are used to define the content and format
      of the\n   action, as explained below.\n   As its name suggests, this class
      is intended for vendor-specific\n   extensions to the Policy Core Information
      Model.  Standardized\n   extensions are not expected to use this class.\n   The
      class definition is as follows:\n      NAME             VendorPolicyAction\n
      \     DESCRIPTION      A class that defines a registered means to\n                       describe
      a policy action.\n      DERIVED FROM     PolicyAction\n      ABSTRACT         FALSE\n
      \     PROPERTIES       ActionData[ ]\n                       ActionEncoding\n"
    - contents:
      - "6.8.1. The Multi-valued Property \"ActionData\"\n   This property provides
        a general extension mechanism for representing\n   policy actions that have
        not been modeled with specific properties.\n   The format of the octet strings
        in the array is left unspecified in\n   this definition.  It is determined
        by the OID value stored in the\n   property ActionEncoding.  Since ActionEncoding
        is single-valued, all\n   the values of ActionData share the same format and
        semantics.  See\n   Section 5.4 for a discussion of how CIM encodes an array
        of octet\n   strings like this one.\n   A policy decision point can readily
        determine whether it supports the\n   values stored in an instance of ActionData
        by checking the OID value\n   from ActionEncoding against the set of OIDs
        it recognizes.  The\n   action for the policy decision point to take in case
        it does not\n   recognize the format of this data could itself be modeled
        as a policy\n   rule, governing the behavior of the policy decision point.\n
        \  The property is defined as follows:\n      NAME             ActionData\n
        \     DESCRIPTION      Extension mechanism for representing actions that\n
        \                      have not been modeled as specific properties.  The\n
        \                      format of the values is identified by the OID\n                       stored
        in the property ActionEncoding.\n      SYNTAX           octet string\n"
      title: 6.8.1. The Multi-valued Property "ActionData"
    - contents:
      - "6.8.2. The Property \"ActionEncoding\"\n   This property identifies the encoding
        and semantics of the ActionData\n   property values in this instance.  The
        value of this property is a\n   single string, representing a single OID.\n
        \  The property is defined as follows:\n      NAME             ActionEncoding\n
        \     DESCRIPTION      An OID encoded as a string, identifying the format\n
        \                      and semantics for this instance's ActionData\n                       property.
        \ The value is a dotted sequence of\n                       decimal digits
        (for example, \"1.2.100.200\")\n                       representing the arcs
        of the OID.  The characters\n                       in the string are the
        UCS-2 characters\n                       corresponding to the US ASCII encodings
        of the\n                       numeric characters and the period.\n      SYNTAX
        \          string\n"
      title: 6.8.2. The Property "ActionEncoding"
    title: 6.8. The Class "VendorPolicyAction"
  - contents:
    - "6.9. The Class \"PolicyRepository\"\n   The class definition of PolicyRepository
      is as follows:\n      NAME             PolicyRepository\n      DESCRIPTION      A
      class representing an administratively defined\n                       container
      for reusable policy-related\n                       information.  This class
      does not introduce any\n                       additional properties beyond
      those in its\n                       superclass AdminDomain.  It does, however,\n
      \                      participate in a number of unique associations.\n      DERIVED
      FROM     AdminDomain\n      ABSTRACT         FALSE\n"
    title: 6.9. The Class "PolicyRepository"
  title: 6. Class Definitions
- contents:
  - "7. Association and Aggregation Definitions\n   The first two subsections of this
    section introduce associations and\n   aggregations as they are used in CIM.  The
    remaining subsections\n   present the class definitions for the associations and
    aggregations\n   that are part of the Policy Core Information Model.\n"
  - contents:
    - "7.1. Associations\n   An association is a CIM construct representing a relationship
      between\n   two (or theoretically more) objects.  It is modeled as a class\n
      \  containing typically two object references.  Associations can be\n   defined
      between classes without affecting any of the related classes.\n   That is, addition
      of an association does not affect the interface of\n   the related classes.\n"
    title: 7.1. Associations
  - contents:
    - "7.2. Aggregations\n   An aggregation is a strong form of an association, which
      usually\n   represents a \"whole-part\" or a \"collection\" relationship.  For\n
      \  example, CIM uses an aggregation to represent the containment\n   relationship
      between a system and the components that make up the\n   system.  Aggregation
      as a \"whole-part\" relationship often implies,\n   but does not require, that
      the aggregated objects have mutual\n   dependencies.\n"
    title: 7.2. Aggregations
  - contents:
    - "7.3. The Abstract Aggregation \"PolicyComponent\n   This abstract aggregation
      defines two object references that will be\n   overridden in each of five subclasses,
      to become references to the\n   concrete policy classes PolicyGroup, PolicyRule,
      PolicyCondition,\n   PolicyAction, and PolicyTimePeriodCondition.  The value
      of the\n   abstract superclass is to convey that all five subclasses have the\n
      \  same \"whole- part\" semantics, and for ease of query to locate all\n   \"components\"
      of a PolicyGroup or PolicyRule.\n   The class definition for the aggregation
      is as follows:\n      NAME             PolicyComponent\n      DESCRIPTION      A
      generic aggregation used to establish 'part of'\n                       relationships
      between the subclasses of\n                       Policy.  For example, the\n
      \                      PolicyConditionInPolicyRule aggregation defines\n                       that
      PolicyConditions are part of a PolicyRule.\n      ABSTRACT         TRUE\n      PROPERTIES
      \      GroupComponent[ref Policy[0..n]]\n                       PartComponent[ref
      Policy[0..n]]\n"
    title: 7.3. The Abstract Aggregation "PolicyComponent
  - contents:
    - "7.4. The Aggregation \"PolicyGroupInPolicyGroup\"\n   The PolicyGroupInPolicyGroup
      aggregation enables policy groups to be\n   nested.  This is critical for scalability
      and manageability, as it\n   enables complex policies to be constructed from
      multiple simpler\n   policies for administrative convenience.  For example,
      a policy group\n   representing policies for the US might have nested within
      it policy\n   groups for the Eastern and Western US.\n   A PolicyGroup may aggregate
      other PolicyGroups via this aggregation,\n   or it may aggregate PolicyRules
      via the PolicyRuleInPolicyGroup\n   aggregation.  Note that it is assumed that
      this aggregation is used\n   to form directed acyclic graphs and NOT ring structures.The
      class\n   definition for the aggregation is as follows:\n      NAME             PolicyGroupInPolicyGroup\n
      \     DESCRIPTION      A class representing the aggregation of\n                       PolicyGroups
      by a higher-level PolicyGroup.\n      DERIVED FROM     PolicyComponent\n      ABSTRACT
      \        FALSE\n      PROPERTIES       GroupComponent[ref PolicyGroup[0..n]]\n
      \                      PartComponent[ref PolicyGroup[0..n]]\n"
    - contents:
      - "7.4.1. The Reference \"GroupComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyGroup
        that contains one or more\n   other PolicyGroups.  Note that for any single
        instance of the\n   aggregation class PolicyGroupInPolicyGroup, this property
        (like all\n   Reference properties) is single-valued.  The [0..n] cardinality\n
        \  indicates that there may be 0, 1, or more than one PolicyGroups that\n
        \  contain any given PolicyGroup.\n"
      title: 7.4.1. The Reference "GroupComponent"
    - contents:
      - "7.4.2. The Reference \"PartComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyGroup
        contained by one or more\n   other PolicyGroups.  Note that for any single
        instance of the\n   aggregation class PolicyGroupInPolicyGroup, this property
        (like all\n   Reference properties) is single-valued.  The [0..n] cardinality\n
        \  indicates that a given PolicyGroup may contain 0, 1, or more than one\n
        \  other PolicyGroups.\n"
      title: 7.4.2. The Reference "PartComponent"
    title: 7.4. The Aggregation "PolicyGroupInPolicyGroup"
  - contents:
    - "7.5. The Aggregation \"PolicyRuleInPolicyGroup\"\n   A policy group may aggregate
      one or more policy rules, via the\n   PolicyRuleInPolicyGroup aggregation.  Grouping
      of policy rules into a\n   policy group is again for administrative convenience;
      a policy rule\n   may also be used by itself, without belonging to a policy
      group.\n   A PolicyGroup may aggregate PolicyRules via this aggregation, or
      it\n   may aggregate other PolicyGroups via the PolicyGroupInPolicyGroup\n   aggregation.\n
      \  The class definition for the aggregation is as follows:\n      NAME             PolicyRuleInPolicyGroup\n
      \     DESCRIPTION      A class representing the aggregation of\n                       PolicyRules
      by a PolicyGroup.\n      DERIVED FROM     PolicyComponent\n      ABSTRACT         FALSE\n
      \     PROPERTIES       GroupComponent[ref PolicyGroup[0..n]]\n                       PartComponent[ref
      PolicyRule[0..n]]\n"
    - contents:
      - "7.5.1. The Reference \"GroupComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyGroup
        that contains one or more\n   PolicyRules.  Note that for any single instance
        of the aggregation\n   class PolicyRuleInPolicyGroup, this property (like
        all Reference\n   properties) is single-valued.  The [0..n] cardinality indicates
        that\n   there may be 0, 1, or more than one PolicyGroups that contain any\n
        \  given PolicyRule.\n"
      title: 7.5.1. The Reference "GroupComponent"
    - contents:
      - "7.5.2. The Reference \"PartComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyRule
        contained by one or more\n   PolicyGroups.  Note that for any single instance
        of the aggregation\n   class PolicyRuleInPolicyGroup, this property (like
        all Reference\n   properties) is single-valued.  The [0..n] cardinality indicates
        that\n   a given PolicyGroup may contain 0, 1, or more than one PolicyRules.\n"
      title: 7.5.2. The Reference "PartComponent"
    title: 7.5. The Aggregation "PolicyRuleInPolicyGroup"
  - contents:
    - "7.6. The Aggregation \"PolicyConditionInPolicyRule\"\n   A policy rule aggregates
      zero or more instances of the\n   PolicyCondition class, via the PolicyConditionInPolicyRule\n
      \  association.  A policy rule that aggregates zero policy conditions\n   must
      indicate in its class definition what \"triggers\" the performance\n   of its
      actions.  In short, it must describe its implicit\n   PolicyConditions, since
      none are explicitly associated.  For example,\n   there might be a subclass
      of PolicyRule named \"HttpPolicyRule\", where\n   the class definition assumes
      that the condition, \"If HTTP traffic,\"\n   is true before the rule's actions
      would be performed.  There is no\n   need to formalize and instantiate this
      condition, since it is obvious\n   in the semantics of the PolicyRule.\n   The
      conditions aggregated by a policy rule are grouped into two\n   levels of lists:
      either an ORed set of ANDed sets of conditions (DNF,\n   the default) or an
      ANDed set of ORed sets of conditions (CNF).\n   Individual conditions in these
      lists may be negated.  The property\n   ConditionListType (in PolicyRule) specifies
      which of these two\n   grouping schemes applies to a particular PolicyRule.
      \ The conditions\n   are used to determine whether to perform the actions associated
      with\n   the PolicyRule.\n   One or more policy time periods may be among the
      conditions\n   associated with a policy rule via the PolicyConditionInPolicyRule\n
      \  association.  In this case, the time periods are simply additional\n   conditions
      to be evaluated along with any other conditions specified\n   for the rule.\n
      \  The class definition for the aggregation is as follows:\n      NAME             PolicyConditionInPolicyRule\n
      \     DESCRIPTION      A class representing the aggregation of\n                       PolicyConditions
      by a PolicyRule.\n      DERIVED FROM     PolicyComponent\n      ABSTRACT         FALSE\n
      \     PROPERTIES       GroupComponent[ref PolicyRule[0..n]]\n                       PartComponent[ref
      PolicyCondition[0..n]]\n                       GroupNumber\n                       ConditionNegated\n"
    - contents:
      - "7.6.1. The Reference \"GroupComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyRule
        that contains one or more\n   PolicyConditions.  Note that for any single
        instance of the\n   aggregation class PolicyConditionInPolicyRule, this property
        (like\n   all Reference properties) is single-valued.  The [0..n] cardinality\n
        \  indicates that there may be 0, 1, or more than one PolicyRules that\n   contain
        any given PolicyCondition.\n"
      title: 7.6.1. The Reference "GroupComponent"
    - contents:
      - "7.6.2. The Reference \"PartComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyCondition
        contained by one or\n   more PolicyRules.  Note that for any single instance
        of the\n   aggregation class PolicyConditionInPolicyRule, this property (like\n
        \  all Reference properties) is single-valued.  The [0..n] cardinality\n   indicates
        that a given PolicyRule may contain 0, 1, or more than one\n   PolicyConditions.\n"
      title: 7.6.2. The Reference "PartComponent"
    - contents:
      - "7.6.3. The Property \"GroupNumber\"\n   This property contains an integer
        identifying the group to which the\n   condition referenced by the PartComponent
        property is assigned in\n   forming the overall conditional expression for
        the policy rule\n   identified by the GroupComponent reference.\n   The property
        is defined as follows:\n      NAME             GroupNumber\n      DESCRIPTION
        \     Unsigned integer indicating the group to which\n                       the
        condition identified by the PartComponent\n                       property
        is to be assigned.\n      SYNTAX           uint16\n      DEFAULT          0\n"
      title: 7.6.3. The Property "GroupNumber"
    - contents:
      - "7.6.4. The Property \"ConditionNegated\"\n   This property is a boolean,
        indicating whether the condition\n   referenced by the PartComponent property
        is negated in forming the\n   overall conditional expression for the policy
        rule identified by the\n   GroupComponent reference.\n   The property is defined
        as follows:\n      NAME             ConditionNegated\n      DESCRIPTION      Indication
        of whether the condition identified by\n                       the PartComponent
        property is negated.  (TRUE\n                       indicates that the condition
        is negated, FALSE\n                       indicates that it is not negated.)\n
        \     SYNTAX           boolean\n      DEFAULT          FALSE\n"
      title: 7.6.4. The Property "ConditionNegated"
    title: 7.6. The Aggregation "PolicyConditionInPolicyRule"
  - contents:
    - "7.7. The Aggregation \"PolicyRuleValidityPeriod\"\n   A different relationship
      between a policy rule and a policy time\n   period (than PolicyConditionInPolicyRule)
      is represented by the\n   PolicyRuleValidityPeriod aggregation.  The latter
      describes scheduled\n   activation and deactivation of the policy rule.\n   If
      a policy rule is associated with multiple policy time periods via\n   this association,
      then the rule is active if at least one of the time\n   periods indicates that
      it is active.  (In other words, the time\n   periods are ORed to determine whether
      the rule is active.)  A policy\n   time period may be aggregated by multiple
      policy rules.  A rule that\n   does not point to a policy time period via this
      aggregation is, from\n   the point of view of scheduling, always active.  It
      may, however, be\n   inactive for other reasons.\n   Time periods are a general
      concept that can be used in other\n   applications.  However, they are mentioned
      explicitly here in this\n   specification since they are frequently used in
      policy applications.\n   The class definition for the aggregation is as follows:\n
      \     NAME             PolicyRuleValidityPeriod\n      DESCRIPTION      A class
      representing the aggregation of\n                       PolicyTimePeriodConditions
      by a PolicyRule.\n      DERIVED FROM     PolicyComponent\n      ABSTRACT         FALSE\n
      \     PROPERTIES       GroupComponent[ref PolicyRule[0..n]]\n                       PartComponent[ref
      PolicyTimePeriodCondition[0..n]]\n"
    - contents:
      - "7.7.1. The Reference \"GroupComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyRule
        that contains one or more\n   PolicyTimePeriodConditions.  Note that for any
        single instance of the\n   aggregation class PolicyRuleValidityPeriod, this
        property (like all\n   Reference properties) is single-valued.  The [0..n]
        cardinality\n   indicates that there may be 0, 1, or more than one PolicyRules
        that\n   contain any given PolicyTimePeriodCondition.\n"
      title: 7.7.1. The Reference "GroupComponent"
    - contents:
      - "7.7.2. The Reference \"PartComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyTimePeriodCondition
        contained\n   by one or more PolicyRules.  Note that for any single instance
        of the\n   aggregation class PolicyRuleValidityPeriod, this property (like
        all\n   Reference properties) is single-valued.  The [0..n] cardinality\n
        \  indicates that a given PolicyRule may contain 0, 1, or more than one\n
        \  PolicyTimePeriodConditions.\n"
      title: 7.7.2. The Reference "PartComponent"
    title: 7.7. The Aggregation "PolicyRuleValidityPeriod"
  - contents:
    - "7.8. The Aggregation \"PolicyActionInPolicyRule\"\n   A policy rule may aggregate
      zero or more policy actions.  A policy\n   rule that aggregates zero policy
      actions must indicate in its class\n   definition what actions are taken when
      the rule's conditions evaluate\n   to TRUE.  In short, it must describe its
      implicit PolicyActions,\n   since none are explicitly associated.  For example,
      there might be a\n   subclass of PolicyRule representing a Diffserv absolute
      dropper,\n   where the subclass itself indicates the action to be taken.  There
      is\n   no need to formalize and instantiate this action, since it is obvious\n
      \  in the semantics of the PolicyRule.\n   The actions associated with a PolicyRule
      may be given a required\n   order, a recommended order, or no order at all.
      \ For actions\n   represented as separate objects, the PolicyActionInPolicyRule\n
      \  aggregation can be used to express an order.\n   This aggregation does not
      indicate whether a specified action order\n   is required, recommended, or of
      no significance; the property\n   SequencedActions in the aggregating instance
      of PolicyRule provides\n   this indication.\n   The class definition for the
      aggregation is as follows:\n      NAME             PolicyActionInPolicyRule\n
      \     DESCRIPTION      A class representing the aggregation of\n                       PolicyActions
      by a PolicyCondition.\n      DERIVED FROM     PolicyComponent\n      ABSTRACT
      \        FALSE\n      PROPERTIES       GroupComponent[ref PolicyRule[0..n]]\n
      \                      PartComponent[ref PolicyAction[0..n]]\n                       ActionOrder\n"
    - contents:
      - "7.8.1. The Reference \"GroupComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyRule
        that contains one or more\n   PolicyActions.  Note that for any single instance
        of the aggregation\n   class PolicyActionInPolicyRule, this property (like
        all Reference\n   properties) is single-valued.  The [0..n] cardinality indicates
        that\n   there may be 0, 1, or more than one PolicyRules that contain any\n
        \  given PolicyAction.\n"
      title: 7.8.1. The Reference "GroupComponent"
    - contents:
      - "7.8.2. The Reference \"PartComponent\"\n   This property is inherited from
        PolicyComponent, and overridden to\n   become an object reference to a PolicyAction
        contained by one or more\n   PolicyRules.  Note that for any single instance
        of the aggregation\n   class PolicyActionInPolicyRule, this property (like
        all Reference\n   properties) is single-valued.  The [0..n] cardinality indicates
        that\n   a given PolicyRule may contain 0, 1, or more than one  PolicyActions.\n"
      title: 7.8.2. The Reference "PartComponent"
    - contents:
      - "7.8.3. The Property \"ActionOrder\"\n   This property provides an unsigned
        integer 'n' that indicates the\n   relative position of an action in the sequence
        of actions associated\n   with a policy rule.  When 'n' is a positive integer,
        it indicates a\n   place in the sequence of actions to be performed, with
        smaller\n   integers indicating earlier positions in the sequence.  The special\n
        \  value '0' indicates \"don't care\".  If two or more actions have the\n
        \  same non-zero sequence number, they may be performed in any order,\n   but
        they must all be performed at the appropriate place in the\n   overall action
        sequence.\n   A series of examples will make ordering of actions clearer:\n
        \  o  If all actions have the same sequence number, regardless of\n      whether
        it is '0' or non-zero, any order is acceptable.\n   o  The values\n      1:ACTION
        A\n      2:ACTION B\n      1:ACTION C\n      3:ACTION D\n      indicate two
        acceptable orders:  A,C,B,D or C,A,B,D, since A and C\n      can be performed
        in either order, but only at the '1' position.\n   o  The values\n      0:ACTION
        A\n      2:ACTION B\n      3:ACTION C\n      3:ACTION D\n      require that
        B,C, and D occur either as B,C,D or as B,D,C.  Action\n      A may appear
        at any point relative to B,C, and D.  Thus the\n      complete set of acceptable
        orders is:  A,B,C,D; B,A,C,D; B,C,A,D;\n      B,C,D,A; A,B,D,C; B,A,D,C; B,D,A,C;
        B,D,C,A.\n      Note that the non-zero sequence numbers need not start with
        '1',\n      and they need not be consecutive.  All that matters is their\n
        \     relative magnitude.\n      The property is defined as follows:\n      NAME
        \            ActionOrder\n      DESCRIPTION      Unsigned integer indicating
        the relative position\n                       of an action in the sequence
        of actions aggregated\n                       by a policy rule.\n      SYNTAX
        \          uint16\n"
      title: 7.8.3. The Property "ActionOrder"
    title: 7.8. The Aggregation "PolicyActionInPolicyRule"
  - contents:
    - "7.9. The Abstract Association \"PolicyInSystem\"\n   This abstract association
      inherits two object references from a\n   higher- level CIM association class,
      Dependency.  It overrides these\n   object references to make them references
      to instances of the classes\n   System and Policy.  Subclasses of PolicyInSystem
      then override these\n   object references again, to make them references to
      concrete policy\n   classes.\n   The value of the abstract superclass is to
      convey that all subclasses\n   have the same \"dependency\" semantics, and for
      ease of query to locate\n   all policy \"dependencies\" on a System.  These
      dependencies are\n   related to scoping or hosting of the Policy.\n   The class
      definition for the association is as follows:\n      NAME             PolicyInSystem\n
      \     DESCRIPTION      A generic association used to establish\n                       dependency
      relationships between Policies and the\n                       Systems that
      host them.\n      DERIVED FROM     Dependency\n      ABSTRACT         TRUE\n
      \     PROPERTIES       Antecedent[ref System[0..1]]\n                       Dependent[ref
      Policy[0..n]]\n"
    title: 7.9. The Abstract Association "PolicyInSystem"
  - contents:
    - "7.10. The Weak Association \"PolicyGroupInSystem\"\n   This association links
      a PolicyGroup to the System in whose scope the\n   PolicyGroup is defined.\n
      \  The class definition for the association is as follows:\n      NAME             PolicyGroupInSystem\n
      \     DESCRIPTION      A class representing the fact that a PolicyGroup\n                       is
      defined within the scope of a System.\n      DERIVED FROM     PolicyInSystem\n
      \     ABSTRACT         FALSE\n      PROPERTIES       Antecedent[ref System[1..1]]\n
      \                      Dependent[ref PolicyGroup[weak]]\n"
    - contents:
      - "7.10.1. The Reference \"Antecedent\"\n   This property is inherited from
        PolicyInSystem, and overridden to\n   restrict its cardinality to [1..1].
        \ It serves as an object reference\n   to a System that provides a scope for
        one or more PolicyGroups.\n   Since this is a weak association, the cardinality
        for this object\n   reference is always 1, that is, a PolicyGroup is always
        defined\n   within the scope of exactly one System.\n"
      title: 7.10.1. The Reference "Antecedent"
    - contents:
      - "7.10.2. The Reference \"Dependent\"\n   This property is inherited from PolicyInSystem,
        and overridden to\n   become an object reference to a PolicyGroup defined
        within the scope\n   of a System.  Note that for any single instance of the
        association\n   class PolicyGroupInSystem, this property (like all Reference\n
        \  properties) is single-valued.  The [0..n] cardinality indicates that\n
        \  a given System may have 0, 1, or more than one PolicyGroups defined\n   within
        its scope.\n"
      title: 7.10.2. The Reference "Dependent"
    title: 7.10. The Weak Association "PolicyGroupInSystem"
  - contents:
    - "7.11. The Weak Association \"PolicyRuleInSystem\"\n   Regardless of whether
      it belongs to a PolicyGroup (or to multiple\n   PolicyGroups), a PolicyRule
      is itself defined within the scope of a\n   System.  This association links
      a PolicyRule to the System in whose\n   scope the PolicyRule is defined.\n   The
      class definition for the association is as follows:\n      NAME             PolicyRuleInSystem\n
      \     DESCRIPTION      A class representing the fact that a PolicyRule\n                       is
      defined within the scope of a System.\n      DERIVED FROM     PolicyInSystem\n
      \     ABSTRACT         FALSE\n      PROPERTIES       Antecedent[ref System[1..1]]\n
      \                      Dependent[ref PolicyRule[weak]]\n"
    - contents:
      - "7.11.1. The Reference \"Antecedent\"\n   This property is inherited from
        PolicyInSystem, and overridden to\n   restrict its cardinality to [1..1].
        \ It serves as an object reference\n   to a System that provides a scope for
        one or more PolicyRules.  Since\n   this is a weak association, the cardinality
        for this object reference\n   is always 1, that is, a PolicyRule is always
        defined within the scope\n   of exactly one System.\n"
      title: 7.11.1. The Reference "Antecedent"
    - contents:
      - "7.11.2. The Reference \"Dependent\"\n   This property is inherited from PolicyInSystem,
        and overridden to\n   become an object reference to a PolicyRule defined within
        the scope\n   of a System.  Note that for any single instance of the association\n
        \  class PolicyRuleInSystem, this property (like all Reference\n   properties)
        is single-valued.  The [0..n] cardinality indicates that\n   a given System
        may have 0, 1, or more than one PolicyRules defined\n   within its scope.\n"
      title: 7.11.2. The Reference "Dependent"
    title: 7.11. The Weak Association "PolicyRuleInSystem"
  - contents:
    - "7.12. The Association \"PolicyConditionInPolicyRepository\"\n   A reusable
      policy condition is always related to a single\n   PolicyRepository, via the
      PolicyConditionInPolicyRepository\n   association.  This is not true for all
      PolicyConditions, however.  An\n   instance of PolicyCondition that represents
      a rule-specific condition\n   is not related to any policy repository via this
      association.\n   The class definition for the association is as follows:\n      NAME
      \            PolicyConditionInPolicyRepository\n      DESCRIPTION      A class
      representing the inclusion of a reusable\n                       PolicyCondition
      in a PolicyRepository.\n      DERIVED FROM     PolicyInSystem\n      ABSTRACT
      \        FALSE\n      PROPERTIES       Antecedent[ref PolicyRepository[0..1]]\n
      \                      Dependent[ref PolicyCondition[0..n]]\n"
    - contents:
      - "7.12.1. The Reference \"Antecedent\"\n   This property is inherited from
        PolicyInSystem, and overridden to\n   become an object reference to a PolicyRepository
        containing one or\n   more PolicyConditions.  A reusable PolicyCondition is
        always related\n   to exactly one PolicyRepository via the\n   PolicyConditionInPolicyRepository
        association.  The [0..1]\n   cardinality for this property covers the two
        types of\n   PolicyConditions:  0 for a rule-specific PolicyCondition, 1 for
        a\n   reusable one.\n"
      title: 7.12.1. The Reference "Antecedent"
    - contents:
      - "7.12.2. The Reference \"Dependent\"\n   This property is inherited from PolicyInSystem,
        and overridden to\n   become an object reference to a PolicyCondition included
        in a\n   PolicyRepository.  Note that for any single instance of the\n   association
        class PolicyConditionInPolicyRepository, this property\n   (like all Reference
        properties) is single-valued.  The [0..n]\n   cardinality indicates that a
        given PolicyRepository may contain 0, 1,\n   or more than one PolicyConditions.\n"
      title: 7.12.2. The Reference "Dependent"
    title: 7.12. The Association "PolicyConditionInPolicyRepository"
  - contents:
    - "7.13. The Association \"PolicyActionInPolicyRepository\"\n   A reusable policy
      action is always related to a single\n   PolicyRepository, via the PolicyActionInPolicyRepository
      association.\n   This is not true for all PolicyActions, however.  An instance
      of\n   PolicyAction that represents a rule-specific action is not related to\n
      \  any policy repository via this association.\n   The class definition for
      the association is as follows:\n      NAME             PolicyActionInPolicyRepository\n
      \     DESCRIPTION      A class representing the inclusion of a reusable\n                       PolicyAction
      in a PolicyRepository.\n      DERIVED FROM     PolicyInSystem\n      ABSTRACT
      \        FALSE\n      PROPERTIES       Antecedent[ref PolicyRepository[0..1]]\n
      \                      Dependent[ref PolicyAction[0..n]]\n"
    - contents:
      - "7.13.1. The Reference \"Antecedent\"\n   This property is inherited from
        PolicyInSystem, and overridden to\n   become an object reference to a PolicyRepository
        containing one or\n   more PolicyActions.  A reusable PolicyAction is always
        related to\n   exactly one PolicyRepository via the PolicyActionInPolicyRepository\n
        \  association.  The [0..1] cardinality for this property covers the two\n
        \  types of PolicyActions:  0 for a rule-specific PolicyAction, 1 for a\n
        \  reusable one.\n"
      title: 7.13.1. The Reference "Antecedent"
    - contents:
      - "7.13.2. The Reference \"Dependent\"\n   This property is inherited from PolicyInSystem,
        and overridden to\n   become an object reference to a PolicyAction included
        in a\n   PolicyRepository.  Note that for any single instance of the\n   association
        class PolicyActionInPolicyRepository, this property (like\n   all Reference
        properties) is single-valued.  The [0..n] cardinality\n   indicates that a
        given PolicyRepository may contain 0, 1, or more\n   than one PolicyActions.\n"
      title: 7.13.2. The Reference "Dependent"
    title: 7.13. The Association "PolicyActionInPolicyRepository"
  - contents:
    - "7.14. The Aggregation \"PolicyRepositoryInPolicyRepository\"\n   The PolicyRepositoryInPolicyRepository
      aggregation enables policy\n   repositories to be nested.  This derives from
      the higher level CIM\n   association, CIM_SystemComponent, describing that Systems
      contain\n   other ManagedSystemElements.  This superclass could not be used
      for\n   the other Policy aggregations, since Policies are not\n   ManagedSystemElements,
      but ManagedElements.  Note that it is assumed\n   that this aggregation is used
      to form directed acyclic graphs and NOT\n   ring structures.\n   The class definition
      for the aggregation is as follows:\n      NAME             PolicyRepositoryInPolicyRepository\n
      \     DESCRIPTION      A class representing the aggregation of\n                       PolicyRepositories
      by a higher-level\n                       PolicyRepository.\n      DERIVED FROM
      \    SystemComponent\n      ABSTRACT         FALSE\n      PROPERTIES       GroupComponent[ref
      PolicyRepository[0..n]]\n                         PartComponent[ref PolicyRepository[0..n]]\n"
    - contents:
      - "7.14.1. The Reference \"GroupComponent\"\n   This property is inherited from
        the CIM class SystemComponent, and\n   overridden to become an object reference
        to a PolicyRepository that\n   contains one or more other PolicyRepositories.
        \ Note that for any\n   single instance of the aggregation class\n   PolicyRepositoryInPolicyRepository,
        this property (like all Reference\n   properties) is single-valued.  The [0..n]
        cardinality indicates that\n   there may be 0, 1, or more than one PolicyRepositories
        that contain\n   any given PolicyRepository.\n"
      title: 7.14.1. The Reference "GroupComponent"
    - contents:
      - "7.14.2. The Reference \"PartComponent\"\n   This property is inherited from
        the CIM class SystemComponent, and\n   overridden to become an object reference
        to a PolicyRepository\n   contained by one or more other PolicyRepositories.
        \ Note that for any\n   single instance of the aggregation class\n   PolicyRepositoryInPolicyRepository,
        this property (like all Reference\n   properties) is single-valued.  The [0..n]
        cardinality indicates that\n   a given PolicyRepository may contain 0, 1,
        or more than one other\n   PolicyRepositories.\n"
      title: 7.14.2. The Reference "PartComponent"
    title: 7.14. The Aggregation "PolicyRepositoryInPolicyRepository"
  title: 7. Association and Aggregation Definitions
- contents:
  - "8. Intellectual Property\n   The IETF takes no position regarding the validity
    or scope of any\n   intellectual property or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; neither does it represent that it\n   has made any effort to
    identify any such rights.  Information on the\n   IETF's procedures with respect
    to rights in standards-track and\n   standards-related documentation can be found
    in BCP-11.\n   Copies of claims of rights made available for publication and any\n
    \  assurances of licenses to be made available, or the result of an\n   attempt
    made to obtain a general license or permission for the use of\n   such proprietary
    rights by implementers or users of this\n   specification can be obtained from
    the IETF Secretariat.\n   The IETF invites any interested party to bring to its
    attention any\n   copyrights, patents or patent applications, or other proprietary\n
    \  rights which may cover technology that may be required to practice\n   this
    standard.  Please address the information to the IETF Executive\n   Director.\n"
  title: 8. Intellectual Property
- contents:
  - "9. Acknowledgements\n   The Policy Core Information Model in this document is
    closely based\n   on the work of the DMTF's Service Level Agreements working group,
    so\n   thanks are due to the members of that working group.  Several of the\n
    \  policy classes in this model first appeared in early drafts on IPSec\n   policy
    and QoS policy.  The authors of these drafts were Partha\n   Bhattacharya, Rob
    Adams, William Dixon, Roy Pereira, Raju Rajan,\n   Jean-Christophe Martin, Sanjay
    Kamat, Michael See, Rajiv Chaudhury,\n   Dinesh Verma, George Powers, and Raj
    Yavatkar.  Some other elements\n   of the model originated in work done by Yoram
    Snir, Yoram Ramberg,\n   and Ron Cohen.  In addition, we would like to thank Harald
    Alvestrand\n   for conducting a thorough review of this document and providing
    many\n   helpful suggestions, and Luis Sanchez and Russ Mundy for their help\n
    \  with the document's Security Considerations.\n"
  title: 9. Acknowledgements
- contents:
  - "10. Security Considerations\n   The Policy Core Information Model (PCIM) presented
    in this document\n   provides an object-oriented model for describing policy information.\n
    \  It provides a basic framework for describing the structure of policy\n   information,
    in a form independent of any specific repository or\n   access protocol, for use
    by an operational system.  PCIM is not\n   intended to represent any particular
    system design or implementation,\n   nor does it define a protocol, and as such
    it does not have any\n   specific security requirements.\n   However, it should
    also be noted that certain derivative documents,\n   which use PCIM as a base,
    will need to convey more specific security\n   considerations.  In order to communicate
    the nature of what will be\n   expected in these follow-on derivative documents,
    it is necessary to\n   review the reasons that PCIM, as defined in this document,
    is neither\n   implementable, nor representative of any real-world system, as
    well\n   as the nature of the expected follow-on extensions and mappings.\n   There
    are three independent reasons that PCIM, as defined here, is\n   neither implementable
    nor representative of any real-world system:\n      1. Its classes are independent
    of any specific repository that\n         uses any specific access protocol.  Therefore,
    its classes are\n         designed not to be implemented directly.  PCIM should
    instead\n         be viewed as a schematic that directs how information should
    be\n         represented, independent of any specific model implementation\n         constraints.\n
    \     2. Its classes were designed to be independent of any specific\n         policy
    domain.  For example, DiffServ and IPSec represent two\n         different policy
    domains.  Each document which extends PCIM to\n         one of these domains will
    derive subclasses from the classes\n         and relationships defined in PCIM,
    in order to represent\n         extensions of a generic model to cover specific
    technical\n         domains.\n      3. It's an information model, which must be
    mapped to a specific\n         data model (native CIM schema, LDAP schema, MIB,
    whatever)\n         before it can be implemented.  Derivative documents will map\n
    \        the extended information models noted in item 2, above, to\n         specific
    types of data model implementations.\n   Even though specific security requirements
    are not appropriate for\n   PCIM, specific security requirements MUST be defined
    for each\n   operational real- world application of PCIM.  Just as there will
    be a\n   wide range of operational, real-world systems using PCIM, there will\n
    \  also be a wide range of security requirements for these systems.\n   Some operational,
    real-world systems that are deployed using PCIM may\n   have extensive security
    requirements that impact nearly all classes\n   and subclasses utilized by such
    a system, while other systems'\n   security requirements might have very little
    impact.\n   The derivative documents, discussed above, will create the context\n
    \  for applying operational, real-world, system-level security\n   requirements
    against the various models which derive from PCIM.\n   For example, in some real-world
    scenarios, the values associated with\n   certain properties, within certain instantiated
    classes, may\n   represent information associated with scarce, and/or costly (and\n
    \  therefore valuable) resources.  It may be the case that these values\n   must
    not be disclosed to, or manipulated by, unauthorized parties.\n   As long as the
    derived model remains an information model (as opposed\n   to a data model), it
    is not possible to discuss the data model-\n   specific tools and mechanisms that
    are available for achieving the\n   authentication and authorization implicit
    in a requirement that\n   restricts read and/or read- write access to these values.
    \ Therefore,\n   these mechanisms will need to be discussed in each of the data
    models\n   to which the derived information models are mapped.  If there are any\n
    \  general security requirements that can be identified and can be\n   applied
    across multiple types of data models, it would be appropriate\n   to discuss those
    at the information model level, rather than the data\n   model level.  In any
    case, any identified security requirements that\n   are not dealt with in the
    information model document, MUST be dealt\n   with in the derivative data model
    documents.\n   We can illustrate these points by extending the example from Section\n
    \  2.  A real-world system that provides QoS Gold Service to John would\n   likely
    need to provide at least the following security-related\n   capabilities and mechanisms
    (see [12] for definitions of security\n   related terms):\n   o  Data integrity
    for the information (e.g., property values and\n      instantiated relationships)
    that specify that John gets QoS Gold\n      Service, from the point(s) that the
    information is entered into\n      the system to the point(s) where network components
    actually\n      provide that Service.\n   o  Authentication and Authorization
    methods to ensure that only\n      system administrators (and not John or other
    engineers) can\n      remotely administer components of the system.\n   o  An
    Authentication method to insure that John receives Gold\n      Service, and the
    other members of the engineering group receive\n      Bronze Service.\n   These
    are one possible set of requirements associated with an example\n   real-world
    system which delivers Gold Service, and the appropriate\n   place to document
    these would be in some combination of the\n   information model and the derivative
    data models for QoS Policy.\n   Each of the data models would also need to discuss
    how these\n   requirements are satisfied, using the mechanisms typically available\n
    \  to such a data model, given the particular technology or set of\n   technologies
    which it may employ.\n"
  title: 10. Security Considerations
- contents:
  - "11. References\n   [1]  Distributed Management Task Force, Inc., \"DMTF Technologies:
    CIM\n        Standards << CIM Schema: Version 2.4\", available via links on\n
    \       the following DMTF web page:\n        http://www.dmtf.org/spec/cim_schema_v24.html.\n
    \  [2]  Distributed Management Task Force, Inc., \"Common Information\n        Model
    (CIM) Specification, version 2.2, June 1999.  This\n        document is available
    on the following DMTF web page:\n        http://www.dmtf.org/spec/cims.html.\n
    \  [3]  Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n        Levels\",
    BCP 14, RFC 2119, March 1997.\n   [4]  Hovey, R. and S. Bradner, \"The Organizations
    Involved in the\n        IETF Standards Process\", BCP 11, RFC 2028, October 1996.\n
    \  [5]  J. Strassner and S. Judd, \"Directory-Enabled Networks\", version\n        3.0c5
    (August 1998).  A PDF file is available at\n        http://www.murchiso.com/den/#denspec.\n
    \  [6]  J. Strassner, policy architecture BOF presentation, 42nd IETF\n        Meeting,
    Chicago, Illinois, October, 1998.  Minutes of this BOF\n        are available
    at the following location:\n        http://www.ietf.org/proceedings/98aug/index.html.\n
    \  [7]  Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC\n        2279,
    January 1998.\n   [8]  Levi, D. and J. Schoenwaelder, \"Definitions of Managed
    Objects\n        for Scheduling Management Operations\", RFC 2591, May 1999.\n
    \  [9]  Yavatkar, R., Pendarakis, D. and R. Guerin, \"A Framework for\n        Policy-based
    Admission Control\", RFC 2753, January 2000.\n   [10] Dawson, F. and D. Stenerson,
    \"Internet Calendaring and\n        Scheduling Core Object Specification (iCalendar)\",
    RFC 2445,\n        November 1998.\n   [11] Strassner, J., and E. Ellesson, B.
    Moore, R. Moats, \"Policy Core\n        LDAP Schema\", Work in Progress.\n   [12]
    Shirey, R., \"Internet Security Glossary\", FYI 36, RFC 2828, May\n        2000.\n
    \  Note: the CIM 2.4 Schema specification is defined by the following\n   set
    of MOF files, available from the following URL:\n      http://www.dmtf.org/spec/CIM_Schema24/CIM_Schema24.zip\n"
  title: 11. References
- contents:
  - "12. Authors' Addresses\n   Ed Ellesson\n   LongBoard, Inc.\n   2505 Meridian
    Pkwy, #100\n   Durham, NC 27713\n   Phone:   +1 919-361-3230\n   Fax:     +1 919-361-3299\n
    \  EMail:  eellesson@lboard.com\n   Bob Moore\n   IBM Corporation, BRQA/502\n
    \  4205 S. Miami Blvd.\n   Research Triangle Park, NC 27709\n   Phone:   +1 919-254-4436\n
    \  Fax:     +1 919-254-6243\n   EMail:  remoore@us.ibm.com\n   John Strassner\n
    \  Cisco Systems, Bldg 15\n   170 West Tasman Drive\n   San Jose, CA 95134\n   Phone:
    \  +1 408-527-1069\n   Fax:     +1 408-527-6351\n   EMail:  johns@cisco.com\n
    \  Andrea Westerinen\n   Cisco Systems\n   170 West Tasman Drive\n   San Jose,
    CA 95134\n   Phone:   +1 408-853-8294\n   Fax:     +1 408-527-6351\n   EMail:
    \ andreaw@cisco.com\n"
  title: 12. Authors' Addresses
- contents:
  - "13. Appendix A:  Class Identification in a Native CIM Implementation\n   While
    the CommonName property is present in the abstract superclass\n   Policy, and
    is thus available in all of its instantiable subclasses,\n   CIM does not use
    this property for naming instances.  The following\n   subsections discuss how
    naming is handled in a native CIM\n   implementation for each of the instantiable
    classes in the Policy\n   Core Information Model.\n   Two things should be noted
    regarding CIM naming:\n   o  When a CIM association is specified as \"weak\",
    this is a statement\n      about naming scopes:  an instance of the class at the
    weak end of\n      the association is named within the scope of an instance of
    the\n      class at the other end of the association.  This is accomplished\n
    \     by propagation of keys from the instance of the scoping class to\n      the
    instance of the weak class.  Thus the weak class has, via key\n      propagation,
    all the keys from the scoping class, and it also has\n      one or more additional
    keys for distinguishing instances of the\n      weak class, within the context
    of the scoping class.\n   o  All class names in CIM are limited to alphabetic
    and numeric\n      characters plus the underscore, with the restriction that the\n
    \     first character cannot be numeric.  Refer to Appendix F \"Unicode\n      Usage\"
    in reference [2] for an exact specification of how CIM\n      class names are
    encoded in CIM strings.\n"
  - contents:
    - "13.1. Naming Instances of PolicyGroup and PolicyRule\n   A policy group always
      exists in the context of a system.  In the\n   Policy Core Information Model,
      this is captured by the weak\n   aggregation PolicyGroupInSystem between a PolicyGroup
      and a System.\n   Note that System serves as the base class for describing network\n
      \  devices and administrative domains.\n   A policy rule also exists in the
      context of a system.  In the Policy\n   Core Information Model, this is captured
      by the weak association\n   PolicyRuleInSystem between a PolicyRule and a System.\n
      \  The following sections define the CIM keys for PolicyGroup and\n   PolicyRule.\n"
    - contents:
      - "13.1.1. PolicyGroup's CIM Keys\n   The CIM keys of the PolicyGroup class
        are:\n   o  SystemCreationClassName (A CIM_System key, propagated due to the\n
        \     weak association, PolicyGroupInSystem)\n   o  SystemName (A CIM_System
        key, propagated due to  the weak\n      association, PolicyGroupInSystem)\n
        \  o  CreationClassName\n   o  PolicyGroupName\n   They are defined in Reference
        [1] as follows:\n   NAME             SystemCreationClassName\n   DESCRIPTION
        \     SystemCreationClassName represents the class name of\n                    the
        CIM System object providing the naming scope for\n                    the
        instance of PolicyGroup.\n   SYNTAX           string [MaxLen 256]\n   QUALIFIER
        \       key\n   NAME             SystemName\n   DESCRIPTION      SystemName
        represent the individual name of the\n                    particular System
        object, providing the naming scope\n                    for the instance of
        PolicyGroup.\n   SYNTAX           string [MaxLen 256]\n   QUALIFIER        key\n
        \  NAME             CreationClassName\n   DESCRIPTION      This property is
        set to \"CIM_PolicyGroup\", if the\n                    PolicyGroup object
        is directly instantiated.  Or, it\n                    is equal to the class
        name of the PolicyGroup\n                    subclass that is instantiated.\n
        \  SYNTAX           string [MaxLen 256]\n   QUALIFIER        key\n   NAME
        \            PolicyGroupName\n   DESCRIPTION      The identifying name of
        this policy group.\n   SYNTAX           string [MaxLen 256]\n   QUALIFIER
        \       key\n"
      title: 13.1.1. PolicyGroup's CIM Keys
    - contents:
      - "13.1.2. PolicyRule's CIM Keys\n   The CIM keys of the PolicyRule class are:\n
        \  o  SystemCreationClassName (A CIM_System key, propagated due to the\n      weak
        association PolicyRuleInSystem)\n   o  SystemName (A CIM_System key, propagated
        due to the weak\n      association PolicyRuleInSystem)\n   o  CreationClassName\n
        \  o  PolicyRuleName\n   SystemCreationClassName and SystemName work the same
        as defined for\n   the class PolicyGroup.  See Section 13.1.1 for details.\n
        \  The other two properties are defined in Reference [1] as follows:\n      NAME
        \            CreationClassName\n      DESCRIPTION      This property is set
        to \"CIM_PolicyRule\", if the\n                       PolicyRule object is
        directly instantiated.  Or,\n                       it is equal to the class
        name of the PolicyRule\n                       subclass that is instantiated.\n
        \     SYNTAX           string [MaxLen 256]\n      QUALIFIER        key\n      NAME
        \            PolicyRuleName\n      DESCRIPTION      The identifying name of
        this policy rule.\n      SYNTAX           string [MaxLen 256]\n      QUALIFIER
        \       key\n"
      title: 13.1.2. PolicyRule's CIM Keys
    title: 13.1. Naming Instances of PolicyGroup and PolicyRule
  - contents:
    - "13.2. Naming Instances of PolicyCondition and Its Subclasses\n   The CIM keys
      of the PolicyCondition class are:\n      o  SystemCreationClassName\n      o
      \ SystemName\n      o  PolicyRuleCreationClassName\n      o  PolicyRuleName\n
      \     o  CreationClassName\n      o  PolicyConditionName\n   Note that none
      of the keys are defined as propagated, although they\n   appear to fit this
      convention.  The reason for this difference is\n   because (as indicated in
      Sections 5.1 and 6.4) the PolicyCondition\n   class is used to represent both
      reusable and rule-specific\n   conditions.  This, in turn, affects what associations
      are valid for\n   an instance of PolicyCondition, and how that instance is named.\n
      \  In an ideal world, an instance of the PolicyCondition class would be\n   scoped
      either by its PolicyRepository (for a reusable condition) or\n   by its PolicyRule
      (for a rule-specific condition).  However, CIM has\n   the restriction that
      a given class can only be \"weak\" to one other\n   class (i.e., defined by
      one weak association).\n   To work within the restrictions of CIM naming, it
      is necessary to\n   \"simulate\" weak associations between PolicyCondition and
      PolicyRule,\n   and between PolicyCondition and PolicyRepository, through a
      technique\n   we'll call manual key propagation.  Strictly speaking, manual
      key\n   propagation isn't key propagation at all.  But it has the same effect\n
      \  as (true) key propagation, so the name fits.\n   Figure 9 illustrates how
      manual propagation works in the case of\n   PolicyCondition.  (Note that only
      the key properties are shown for\n   each of the classes.)  In the figure, the
      line composed of 'I's\n   indicates class inheritance, the one composed of 'P's
      indicates\n   (true) key propagation via the weak aggregation PolicyRuleInSystem,\n
      \  and the ones composed of 'M's indicate manual key propagation.\n      +------------------+\n
      \     |      System      |\n      +------------------+\n      |CreationClassName
      |\n      |Name              |\n      +------------------+\n                ^
      \    P\n                I     PPPPPPPPPPPPPPPPPPPPPPPPPPPP\n                I
      \                               P\n      +------------------+       +---------------v--------------+\n
      \     |    AdminDomain   |       |         PolicyRule           |\n      +------------------+
      \      +------------------------------+\n      |CreationClassName |       |
      System.CreationClassName     |\n      |Name              |       | System.Name
      \                 |\n      +------------------+       | CreationClassName            |\n
      \               ^                | PolicyRuleName               |\n                I
      \               +------------------------------+\n                I                         M\n
      \               I                         M\n      +------------------+                M\n
      \     | PolicyRepository |                M\n      +------------------+                M\n
      \     |CreationClassName |                M\n      |Name              |                M\n
      \     +------------------+                M\n                      M                   M\n
      \                     M                   M\n                      M                   M\n
      \                +----v-------------------v----+\n                 |       PolicyCondition
      \      |\n                 +-----------------------------+\n                 |
      SystemCreationClassName     |\n                 | SystemName                  |\n
      \                | PolicyRuleCreationClassName |\n                 | PolicyRuleName
      \             |\n                 | CreationClassName           |\n                 |
      PolicyConditionName         |\n                 +-----------------------------+\n
      \     Figure 9. Manual Key Propagation for Naming PolicyConditions\n   Looking
      at Figure 9, we see that two key properties,\n   CreationClassName and Name,
      are defined in the System class, and\n   inherited by its subclasses AdminDomain
      and PolicyRepository.  Since\n   PolicyRule is weak to System, these two keys
      are propagated to it; it\n   also has its own keys CreationClassName and PolicyRuleName.\n
      \  A similar approach, though not automatic, is used in \"manual key\n   propagation\".
      \ Here is the approach for rule-specific and reusable\n   PolicyConditions:\n
      \  o  The manual propagation of keys from PolicyRule to PolicyCondition\n      involves
      copying the values of PolicyRule's four key properties\n      into four similarly
      named key properties in PolicyCondition.  From\n      the point of view of the
      CIM specification language, the property\n      SystemName in PolicyCondition
      is a completely new key property.\n      However, the relationship to the Name
      property in System is\n      defined in the description of SystemName.\n   o
      \ The manual propagation of keys from PolicyRepository to\n      PolicyCondition
      works in exactly the same way for the first two\n      key properties.  However,
      since PolicyRepository doesn't include\n      PolicyRule properties, the PolicyRuleCreationClassName
      and\n      PolicyRuleName have no values.  A special value, \"No Rule\", is\n
      \     assigned to both of these properties in this case, indicating that\n      this
      instance of PolicyCondition is not named within the scope of\n      any particular
      policy rule.\n   The following section defines the specific CIM keys for\n   PolicyCondition.\n"
    - contents:
      - "13.2.1. PolicyCondition's CIM Keys\n   PolicyCondition's key properties are
        defined in Reference [1] as\n   follows:\n   NAME             SystemCreationClassName\n
        \  DESCRIPTION      SystemCreationClassName represents the class\n                    name
        of the CIM System object providing the\n                    naming scope for
        the instance of PolicyCondition.\n                    For a rule-specific
        policy condition, this is the\n                    type of system (e.g., the
        name of the class that\n                    created this instance) in whose
        context the policy\n                    rule is defined.  For a reusable policy
        condition,\n                    this is set to \"CIM_PolicyRepository\", if
        the\n                    PolicyRepository object is directly instantiated.\n
        \                   Or, it is equal to the class name of the\n                    PolicyRepository
        subclass that is instantiated.\n   SYNTAX           string [MaxLen 256]\n
        \  QUALIFIER        key\n   NAME             SystemName\n   DESCRIPTION      The
        name of the System object in whose scope this\n                    policy
        condition is defined.  This property\n                    completes the identification
        of the System object.\n                    For a rule-specific policy condition,
        this is the\n                    name of the instance of the system in whose\n
        \                   context the policy rule is defined.  For a\n                    reusable
        policy condition, this is name of the\n                    instance of PolicyRepository
        that holds the policy\n                    condition.\n   SYNTAX           string
        [MaxLen 256]\n   QUALIFIER        key\n   NAME             PolicyRuleCreationClassName\n
        \  DESCRIPTION      For a rule-specific policy condition, this\n                    property
        identifies the class name of the policy\n                    rule instance,
        in whose scope this instance of\n                    PolicyCondition exists.
        \ For a reusable policy\n                    condition, this property is set
        to a special\n                    value, \"No Rule\", indicating that this
        instance\n                    of PolicyCondition is not unique to one policy\n
        \                   rule.\n   SYNTAX           string [MaxLen 256]\n   QUALIFIER
        \       key\n   NAME             PolicyRuleName\n   DESCRIPTION      For a
        rule-specific policy condition,\n                    PolicyRuleName completes
        the identification of\n                    the PolicyRule object with which
        this condition\n                    is associated.  For a reusable policy
        condition,\n                    a special value, \"No Rule\", is used to indicate\n
        \                   that this condition is reusable.\n   SYNTAX           string
        [MaxLen 256]\n   QUALIFIER        key\n   NAME             CreationClassName\n
        \  DESCRIPTION      The class name of the PolicyCondition subclass\n                    that
        is instantiated.\n   SYNTAX           string [MaxLen 256]\n   QUALIFIER        key\n
        \  NAME             PolicyConditionName\n   DESCRIPTION      The identifying
        name of this policy condition.\n   SYNTAX           string [MaxLen 256]\n
        \  QUALIFIER        key\n"
      title: 13.2.1. PolicyCondition's CIM Keys
    title: 13.2. Naming Instances of PolicyCondition and Its Subclasses
  - contents:
    - "13.3. Naming Instances of PolicyAction and Its Subclasses\n   From the point
      of view of naming, the PolicyAction class and its\n   subclasses work exactly
      like the PolicyCondition class and its\n   subclasses.  See Section 13.2 and
      13.2.1 for details.\n   Specifically, the CIM keys of PolicyAction are:\n      o
      \ SystemCreationClassName\n      o  SystemName\n      o  PolicyRuleCreationClassName\n
      \     o  PolicyRuleName\n      o  CreationClassName\n      o  PolicyActionName\n
      \  They are defined in Reference [1] as follows:\n   NAME             SystemCreationClassName\n
      \  DESCRIPTION      SystemCreationClassName represents the class name\n                    of
      the CIM System object providing the naming\n                    scope for the
      instance of PolicyAction.  For a\n                    rule-specific policy action,
      this is the type of\n                    system (e.g., the name of the class
      that created\n                    this instance) in whose context the policy
      rule\n                    is defined.  For a reusable policy action, this\n
      \                   is set to \"CIM_PolicyRepository\", if the\n                    PolicyRepository
      object is directly instantiated.\n                    Or, it is equal to the
      class name of the\n                    PolicyRepository subclass that is instantiated.\n
      \  SYNTAX           string [MaxLen 256]\n   QUALIFIER        key\n   NAME             SystemName\n
      \  DESCRIPTION      The name of the System object in whose scope this\n                    policy
      action is defined.  This property completes\n                    the identification
      of the System object.  For a\n                    rule-specific policy action,
      this is the name of\n                    the instance of the system in whose
      context the\n                    policy rule is defined.  For a reusable policy\n
      \                   action, this is name of the instance of\n                    PolicyRepository
      that holds the policy action.\n   SYNTAX           string [MaxLen 256]\n   QUALIFIER
      \       key\n   NAME             PolicyRuleCreationClassName\n   DESCRIPTION
      \     For a rule-specific policy action, this property\n                    identifies
      the class name of the policy rule\n                    instance, in whose scope
      this instance of\n                    PolicyAction exists.  For a reusable policy\n
      \                   action, this property is set to a special value,\n                    \"No
      Rule\", indicating that this instance of\n                    PolicyAction is
      not unique to one policy rule.\n   SYNTAX           string [MaxLen 256]\n   QUALIFIER
      \       key\n   NAME             PolicyRuleName\n   DESCRIPTION      For a rule-specific
      policy action, PolicyRuleName\n                    completes the identification
      of the PolicyRule\n                    object with which this action is associated.
      \ For\n                    a reusable policy action, a special value, \"No\n
      \                   Rule\", is used to indicate that this action is\n                    reusable.\n
      \  SYNTAX           string [MaxLen 256]\n   QUALIFIER        key\n   NAME             CreationClassName\n
      \  DESCRIPTION      The class name of the PolicyAction subclass that is\n                    instantiated.\n
      \  SYNTAX           string [MaxLen 256]\n   QUALIFIER        key\n   NAME             PolicyActionName\n
      \  DESCRIPTION      The identifying name of this policy action.\n   SYNTAX           string
      [MaxLen 256]\n   QUALIFIER        key\n"
    title: 13.3. Naming Instances of PolicyAction and Its Subclasses
  - contents:
    - "13.4. Naming Instances of PolicyRepository\n   An instance of PolicyRepository
      is named by the two key properties\n   CreationClassName and Name that it inherits
      from its superclass\n   AdminDomain.  These properties are actually defined
      in  AdminDomain's\n   superclass, System, and then inherited by AdminDomain.\n
      \  For instances of PolicyRepository itself, the value of\n   CreationClassName
      must be \"CIM_PolicyRepository\".  (Recall that for\n   readability the prefix
      \"CIM_\" has been omitted from all class names\n   in this document).  If a
      subclass of PolicyRepository (perhaps\n   QosPolicyRepository) is defined and
      instantiated, then the class name\n   \"CIM_QosPolicyRepository\" is used in
      CreationClassName.\n   The Name property simply completes the identification
      of the instance\n   of PolicyRepository.\n"
    title: 13.4. Naming Instances of PolicyRepository
  - contents:
    - "13.5. Role of the CreationClassName Property in Naming\n   To provide for more
      flexibility in instance naming, CIM makes use of\n   a property called CreationClassName.
      \ The idea of CreationClassName\n   is to provide another dimension that can
      be used to avoid naming\n   collisions, in the specific case of instances belonging
      to two\n   different subclasses of a common  superclass.  An example will\n
      \  illustrate how CreationClassName works.\n   Suppose we have instances of
      two different subclasses of\n   PolicyCondition, FrameRelayPolicyCondition and
      BgpPolicyCondition,\n   and that these instances apply to the same context.
      \ If we had only\n   the single key property PolicyConditionName available for\n
      \  distinguishing the two instances, then a collision would result from\n   naming
      both of the instances with the key value PCName = \"PC-1\".\n   Thus policy
      administrators from widely different disciplines would\n   have to coordinate
      their naming of PolicyConditions for this context.\n   With CreationClassName,
      collisions of this type can be eliminated,\n   without requiring coordination
      among the policy administrators.  The\n   two instances can be distinguished
      by giving their CreationClassNames\n   different values.  One instance is now
      identified with the two keys\n   CreationClassName = \"FrameRelayPolicyCondition\"
      + PCName = \"PC-1\",\n   while the other is identified with\n   CreationClassName
      = \"BgpPolicyCondition\" + PCName = \"PC-1\".\n   Each of the instantiable classes
      in the Core Model includes the\n   CreationClassName property as a key in addition
      to its own class-\n   specific key property.\n"
    title: 13.5. Role of the CreationClassName Property in Naming
  - contents:
    - "13.6. Object References\n   Today, all CIM associations involve two object
      references.  CIM\n   decomposes an object reference into two parts:  a high-order
      part\n   that identifies an object manager and namespace, and a model path\n
      \  that identifies an object instance within a namespace.  The model\n   path,
      in turn, can be decomposed into an object class identifier and\n   a set of
      key values needed to identify an instance of that class.\n   Because the object
      class identifier is part of the model path, a CIM\n   object reference is strongly
      typed.  The GroupComponent object\n   reference in the PolicyGroupInPolicyGroup
      association, for example,\n   can only point to an instance of PolicyGroup,
      or to an instance of a\n   subclass of PolicyGroup.  Contrast this with LDAP,
      where a DN pointer\n   is completely untyped:  it identifies (by DN) an entry,
      but places no\n   restriction on that entry's object class(es).\n   An important
      difference between CIM property definitions and LDAP\n   attribute type definitions
      was identified earlier in Section 6:\n   while an LDAP attribute type definition
      has global scope, a CIM\n   property definition applies only to the class in
      which it is defined.\n   Thus properties having the same name in two different
      classes are\n   free to have different data types.  CIM takes advantage of this\n
      \  flexibility by allowing the data type of an object reference to be\n   overridden
      in a subclass of the association class in which it was\n   initially defined.\n
      \  For example, the object reference GroupComponent is defined in the\n   abstract
      aggregation class PolicyComponent to be a reference to an\n   instance of the
      class Policy.  This data type for GroupComponent is\n   then overridden in subclasses
      of PolicyComponent.  In\n   PolicyGroupInPolicyGroup, for example, GroupComponent
      becomes a\n   reference to an instance of PolicyGroup.  But in\n   PolicyConditionInPolicyRule
      it becomes a reference to an instance of\n   PolicyRule.  Of course there is
      not total freedom in this overriding\n   of object references.  In order to
      remain consistent with its\n   abstract superclass, a subclass of PolicyComponent
      can only override\n   GroupComponent to be a reference to a subclass of Policy.
      \ A Policy\n   class is the generic context for the GroupComponent reference
      in\n   PolicyComponent.\n"
    title: 13.6. Object References
  title: '13. Appendix A:  Class Identification in a Native CIM Implementation'
- contents:
  - '14. Appendix B:  The Core Policy MOF

    '
  - '// ==================================================================

    '
  - '// Title:     Core Policy MOF Specification 2.4

    '
  - '// Filename:  CIM_Policy24.MOF

    '
  - '// Version:   2.4

    '
  - '// Release:   0

    '
  - '// Description: The object classes below are listed in an order that

    '
  - '//              avoids forward references.  Required objects, defined

    '
  - '//        by other working groups, are omitted.

    '
  - '// Date: 06/27/2000

    '
  - '//     CIMCR516a - Rooted the model associations under Policy

    '
  - '//        Component or PolicyInSystem.  Corrected PolicyCondition/

    '
  - '//        PolicyActionInPolicyRepository to subclass from

    '
  - '//        PolicyInSystem (similar to Groups and Roles ''InSystem'')

    '
  - '// ==================================================================

    '
  - '// Author:    DMTF SLA (Service Level Agreement) Working Group

    '
  - '// ==================================================================

    '
  - '// Pragmas

    '
  - '// ==================================================================

    '
  - '#pragma Locale ("en-US")

    '
  - '// ==================================================================

    '
  - '// Policy

    '
  - "// ==================================================================\n   [Abstract,
    Description (\n         \"An abstract class describing common properties of all
    \"\n         \"policy rule-related subclasses, such as PolicyGroup, Policy\"\n
    \        \"Rule and PolicyCondition. All instances of policy rule-\"\n         \"related
    entities will be created from subclasses of CIM_\"\n         \"Policy.  The exception
    to this statement is PolicyRepository \"\n         \"which is a type of CIM_System.\")\n
    \  ]\n"
  - 'class CIM_Policy : CIM_ManagedElement

    '
  - "{\n      [Description (\n         \"A user-friendly name of this policy-related
    object.\")\n      ]\n   string CommonName;\n      [Description (\n         \"An
    array of keywords for characterizing / categorizing \"\n         \"policy objects.
    \ Keywords are of one of two types: \\n\"\n         \"  o Keywords defined in
    this and other MOFs, or in DMTF \"\n         \"    white papers.  These keywords
    provide a vendor-\"\n         \"    independent, installation-independent way
    of \"\n         \"    characterizing policy objects. \\n\"\n         \"  o Installation-dependent
    keywords for characterizing \"\n         \"    policy objects.  Examples include
    'Engineering', \"\n         \"    'Billing', and 'Review in December 2000'.  \\n\"\n
    \        \"This MOF defines the following keywords:  'UNKNOWN', \"\n         \"'CONFIGURATION',
    'USAGE', 'SECURITY', 'SERVICE', \"\n         \"'MOTIVATIONAL', 'INSTALLATION',
    and 'EVENT'.  These \"\n         \"concepts are self-explanatory and are further
    discussed \"\n         \"in the SLA/Policy White Paper.  One additional keyword
    \"\n         \"is defined: 'POLICY'.  The role of this keyword is to \"\n         \"identify
    policy-related instances that may not be otherwise \"\n         \"identifiable,
    in some implementations.  The keyword 'POLICY' \"\n         \"is NOT mutually
    exclusive of the other keywords \"\n         \"specified above.\")\n      ]\n
    \  string PolicyKeywords [];\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyComponent

    '
  - "// ==================================================================\n   [Association,
    Abstract, Aggregation, Description (\n         \"CIM_PolicyComponent is a generic
    association used to \"\n         \"establish 'part of' relationships between the
    subclasses of \"\n         \"CIM_Policy.  For example, the PolicyConditionInPolicyRule
    \"\n         \"association defines that PolicyConditions are part of a \"\n         \"PolicyRule.\")\n
    \  ]\n"
  - 'class CIM_PolicyComponent

    '
  - "{\n       [Aggregate, Key, Description (\n         \"The parent Policy in the
    association.\")\n       ]\n    CIM_Policy REF GroupComponent;\n       [Key, Description
    (\n         \"The child/part Policy in the association.\")\n       ]\n    CIM_Policy
    REF PartComponent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyInSystem

    '
  - "// ==================================================================\n   [Association,
    Abstract, Description (\n         \"  CIM_PolicyInSystem is a generic association
    used to \"\n         \"establish dependency relationships between Policies and
    the \"\n         \"Systems that host them.  These Systems may be ComputerSystems
    \"\n         \"where Policies are 'running' or they may be Policy\"\n         \"Repositories
    where Policies are stored.  This relationship \"\n         \"is similar to the
    concept of CIM_Services being dependent \"\n         \"on CIM_Systems as defined
    by the HostedService \"\n         \"association.  \\n\"\n         \"  Cardinality
    is Max(1) for the Antecedent/System \"\n         \"reference since Policies can
    only be hosted in at most one \"\n         \"System context.  Some subclasses
    of the association will \"\n         \"further refine this definition to make
    the Policies Weak \"\n         \"to Systems.  Other subclasses of PolicyInSystem
    will \"\n         \"define an optional hosting relationship.  Examples of each
    \"\n         \"of these are the PolicyRuleInSystem and PolicyConditionIn\"\n         \"PolicyRepository
    associations, respectively.\")\n   ]\n"
  - 'class CIM_PolicyInSystem : CIM_Dependency

    '
  - "{\n       [Override (\"Antecedent\"), Max (1), Description (\n         \"The
    hosting System.\")\n       ]\n    CIM_System REF Antecedent;\n       [Override
    (\"Dependent\"), Description (\n         \"The hosted Policy.\")\n       ]\n    CIM_Policy
    REF Dependent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '// PolicyGroup

    '
  - "// ==================================================================\n   [Description
    (\n         \"A container for either a set of related PolicyGroups \"\n         \"or
    a set of related PolicyRules, but not both.  Policy\"\n         \"Groups are defined
    and named relative to the CIM_System \"\n         \"which provides their context.\")\n
    \  ]\n"
  - 'class CIM_PolicyGroup : CIM_Policy

    '
  - "{\n      [Propagated(\"CIM_System.CreationClassName\"),\n         Key, MaxLen
    (256),\n         Description (\"The scoping System's CreationClassName.\")\n      ]\n
    \  string SystemCreationClassName;\n      [Propagated(\"CIM_System.Name\"),\n
    \        Key, MaxLen (256),\n         Description (\"The scoping System's Name.\")\n
    \     ]\n   string SystemName;\n      [Key, MaxLen (256), Description (\n         \"CreationClassName
    indicates the name of the class or the \"\n         \"subclass used in the creation
    of an instance.  When used \"\n         \"with the other key properties of this
    class, this property \"\n         \"allows all instances of this class and its
    subclasses to \"\n         \"be uniquely identified.\") ]\n   string CreationClassName;\n
    \     [Key, MaxLen (256), Description (\n         \"A user-friendly name of this
    PolicyGroup.\")\n      ]\n   string PolicyGroupName;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyGroupInPolicyGroup

    '
  - "// ==================================================================\n   [Association,
    Aggregation, Description (\n         \"A relationship that aggregates one or more
    lower-level \"\n         \"PolicyGroups into a higher-level Group.  A Policy\"\n
    \        \"Group may aggregate either PolicyRules or other Policy\"\n         \"Groups,
    but not both.\")\n   ]\n"
  - 'class CIM_PolicyGroupInPolicyGroup : CIM_PolicyComponent

    '
  - "{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"A
    PolicyGroup that aggregates other Groups.\")\n        ]\n    CIM_PolicyGroup REF
    GroupComponent;\n        [Override (\"PartComponent\"), Description (\n         \"A
    PolicyGroup aggregated by another Group.\")\n        ]\n    CIM_PolicyGroup REF
    PartComponent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyGroupInSystem

    '
  - "// ==================================================================\n   [Association,
    Description (\n         \"An association that links a PolicyGroup to the System
    \"\n         \"in whose scope the Group is defined.\")\n   ]\n"
  - 'class CIM_PolicyGroupInSystem : CIM_PolicyInSystem

    '
  - "{\n        [Override (\"Antecedent\"), Min(1), Max(1), Description (\n         \"The
    System in whose scope a PolicyGroup is defined.\")\n        ]\n    CIM_System
    REF Antecedent;\n        [Override (\"Dependent\"), Weak, Description (\n         \"A
    PolicyGroup named within the scope of a System.\")\n        ]\n    CIM_PolicyGroup
    REF Dependent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '// PolicyRule

    '
  - "// ==================================================================\n   [Description
    (\n        \"  The central class for representing the 'If Condition then \"\n
    \        \"Action' semantics associated with a policy rule. \"\n         \"A PolicyRule
    condition, in the most general sense, is \"\n         \"represented as either
    an ORed set of ANDed conditions \"\n         \"(Disjunctive Normal Form, or DNF)
    or an ANDed set of ORed \"\n         \"conditions (Conjunctive Normal Form, or
    CNF). Individual \"\n         \"conditions may either be negated (NOT C) or unnegated
    (C). \"\n         \"The actions specified by a PolicyRule are to be performed
    \"\n         \"if and only if the PolicyRule condition (whether it is \"\n         \"represented
    in DNF or CNF) evaluates to TRUE.\\n\\n\"\n         \"  \"\n         \"The conditions
    and actions associated with a PolicyRule \"\n         \"are modeled, respectively,
    with subclasses of Policy\"\n         \"Condition and PolicyAction.  These condition
    and action \"\n         \"objects are tied to instances of PolicyRule by the Policy\"\n
    \        \"ConditionInPolicyRule and PolicyActionInPolicyRule \"\n         \"aggregations.\\n\\n\"\n
    \        \"  \"\n         \"A PolicyRule may also be associated with one or more
    policy \"\n         \"time periods, indicating the schedule according to which
    the \"\n         \"policy rule is active and inactive.  In this case it is the
    \"\n         \"PolicyRuleValidityPeriod aggregation that provides this \"\n         \"linkage.\\n\\n\"\n
    \        \"  \"\n         \"The PolicyRule class uses the property ConditionListType,
    to \"\n         \"indicate whether the conditions for the rule are in DNF or \"\n
    \        \"CNF.  The PolicyConditionInPolicyRule aggregation contains \"\n         \"two
    additional properties to complete the representation of \"\n         \"the Rule's
    conditional expression.  The first of these \"\n         \"properties is an integer
    to partition the referenced \"\n         \"PolicyConditions into one or more groups,
    and the second is a \"\n         \"Boolean to indicate whether a referenced Condition
    is \"\n         \"negated.  An example shows how ConditionListType and these \"\n
    \        \"two additional properties provide a unique representation \"\n         \"of
    a set of PolicyConditions in either DNF or CNF.\\n\\n\"\n         \"  \"\n         \"Suppose
    we have a PolicyRule that aggregates five \"\n         \"PolicyConditions C1  through
    C5, with the following values \"\n         \"in the properties of the five PolicyConditionInPolicyRule
    \"\n         \"associations:\\n\"\n         \"    C1:  GroupNumber = 1, ConditionNegated
    = FALSE\\n \"\n         \"    C2:  GroupNumber = 1, ConditionNegated = TRUE\\n
    \ \"\n         \"    C3:  GroupNumber = 1, ConditionNegated = FALSE\\n \"\n         \"
    \   C4:  GroupNumber = 2, ConditionNegated = FALSE\\n \"\n         \"    C5:  GroupNumber
    = 2, ConditionNegated = FALSE\\n\\n \"\n         \"  \"\n         \"If ConditionListType
    = DNF, then the overall condition for \"\n         \"the PolicyRule is:\\n\"\n
    \        \"        (C1 AND (NOT C2) AND C3) OR (C4 AND C5)\\n\\n\"\n         \"
    \ \"\n         \"On the other hand, if ConditionListType = CNF, then the \"\n
    \        \"overall condition for the PolicyRule is:\\n\"\n         \"        (C1
    OR (NOT C2) OR C3) AND (C4 OR C5)\\n\\n\"\n         \"  \"\n         \"In both
    cases, there is an unambiguous specification of \"\n         \"the overall condition
    that is tested to determine whether \"\n         \"to perform the PolicyActions
    associated with the PolicyRule.\")\n   ]\n"
  - 'class CIM_PolicyRule : CIM_Policy

    '
  - "{\n        [Propagated(\"CIM_System.CreationClassName\"),\n         Key, MaxLen
    (256),\n         Description (\"The scoping System's CreationClassName.\")\n        ]\n
    \   string SystemCreationClassName;\n        [Propagated(\"CIM_System.Name\"),\n
    \        Key, MaxLen (256),\n         Description (\"The scoping System's Name.\")\n
    \       ]\n    string SystemName;\n        [Key, MaxLen (256), Description (\n
    \          \"CreationClassName indicates the name of the class or the \"\n           \"subclass
    used in the creation of an instance.  When used \"\n           \"with the other
    key properties of this class, this property \"\n           \"allows all instances
    of this class and its subclasses to \"\n           \"be uniquely identified.\")
    ]\n    string CreationClassName;\n        [Key, MaxLen (256), Description (\n
    \          \"A user-friendly name of this PolicyRule.\")\n        ]\n    string
    PolicyRuleName;\n        [Description (\n           \"Indicates whether this PolicyRule
    is administratively \"\n           \"enabled, administratively disabled, or enabled
    for \"\n           \"debug.  When the property has the value 3 (\\\"enabledFor\"\n
    \          \"Debug\\\"), the entity evaluating the PolicyConditions is \"\n           \"instructed
    to evaluate the conditions for the Rule, but not \"\n           \"to perform the
    actions if the PolicyConditions evaluate to \"\n           \"TRUE.  This serves
    as a debug vehicle when attempting to \"\n           \"determine what policies
    would execute in a particular \"\n           \"scenario, without taking any actions
    to change state \"\n           \"during the debugging.  The default value is 1\n"
  - "(\\\"enabled\\\").\"),\n         ValueMap { \"1\", \"2\", \"3\" },\n         Values
    { \"enabled\", \"disabled\", \"enabledForDebug\" }\n        ]\n    uint16 Enabled;\n
    \       [Description (\n           \"Indicates whether the list of PolicyConditions
    \"\n           \"associated with this PolicyRule is in disjunctive \"\n           \"normal
    form (DNF) or conjunctive normal form (CNF).\"\n           \"The default value
    is 1 (\\\"DNF\\\").\"),\n         ValueMap { \"1\", \"2\" },\n         Values
    { \"DNF\", \"CNF\" }\n        ]\n    uint16 ConditionListType;\n        [Description
    (\n           \"A free-form string that can be used to provide \"\n           \"guidelines
    on how this PolicyRule should be used.\")\n        ]\n    string RuleUsage;\n
    \       [Description (\n           \"A non-negative integer for prioritizing this
    Policy\"\n           \"Rule relative to other Rules.  A larger value \"\n           \"indicates
    a higher priority.  The default value is 0.\")\n        ]\n    uint16 Priority;\n
    \       [Description (\n           \"A flag indicating that the evaluation of
    the Policy\"\n           \"Conditions and execution of PolicyActions (if the \"\n
    \          \"Conditions evaluate to TRUE) is required.  The \"\n           \"evaluation
    of a PolicyRule MUST be attempted if the \"\n           \"Mandatory property value
    is TRUE.  If the Mandatory \"\n           \"property is FALSE, then the evaluation
    of the Rule \"\n           \"is 'best effort' and MAY be ignored.\")\n        ]\n
    \   boolean Mandatory;\n        [Description (\n           \"This property gives
    a policy administrator a way \"\n           \"of specifying how the ordering of
    the PolicyActions \"\n           \"associated with this PolicyRule is to be interpreted.
    \"\n           \"Three values are supported:\\n\"\n           \"  o mandatory(1):
    Do the actions in the indicated \"\n           \"    order, or don't do them at
    all.\\n\"\n           \"  o recommended(2): Do the actions in the indicated \"\n
    \          \"    order if you can, but if you can't do them in this \"\n           \"
    \   order, do them in another order if you can.\\n\"\n           \"  o dontCare(3):
    Do them -- I don't care about the \"\n           \"    order.\\n\"\n           \"The
    default value is 3 (\\\"dontCare\\\").\"),\n         ValueMap { \"1\", \"2\",
    \"3\" },\n         Values { \"mandatory\", \"recommended\", \"dontCare\" }\n        ]\n
    \   uint16 SequencedActions;\n        [Description (\n         \"This property
    represents the roles and role combinations \"\n         \"associated with a PolicyRule.
    \ Each value represents one \"\n         \"role or role combination.  Since this
    is a multi-valued \"\n         \"property, more than one role or combination can
    be associated \"\n         \"with a single policy rule.  Each value is a string
    of the \"\n         \"form:\\n\"\n         \"  <RoleName>[&&<RoleName>]*\\n\"\n
    \        \"where the individual role names appear in alphabetical order \"\n         \"(according
    to the collating sequence for UCS-2).\")\n        ]\n    string PolicyRoles [];\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyRuleInPolicyGroup

    '
  - "// ==================================================================\n   [Association,
    Aggregation, Description (\n         \"A relationship that aggregates one or more
    PolicyRules \"\n         \"into a PolicyGroup.  A PolicyGroup may aggregate either
    \"\n         \"PolicyRules or other PolicyGroups, but not both.\")\n   ]\n"
  - 'class CIM_PolicyRuleInPolicyGroup : CIM_PolicyComponent

    '
  - "{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"A
    PolicyGroup that aggregates one or more PolicyRules.\")\n        ]\n    CIM_PolicyGroup
    REF GroupComponent;\n        [Override (\"PartComponent\"), Description (\n         \"A
    PolicyRule aggregated by a PolicyGroup.\")\n        ]\n    CIM_PolicyRule REF
    PartComponent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyRuleInSystem

    '
  - "// ==================================================================\n   [Association,
    Description (\n         \"An association that links a PolicyRule to the System
    \"\n         \"in whose scope the Rule is defined.\")\n   ]\n"
  - 'class CIM_PolicyRuleInSystem : CIM_PolicyInSystem

    '
  - "{\n        [Override (\"Antecedent\"), Min(1), Max(1), Description (\n         \"The
    System in whose scope a PolicyRule is defined.\")\n        ]\n    CIM_System REF
    Antecedent;\n        [Override (\"Dependent\"), Weak, Description (\n         \"A
    PolicyRule named within the scope of a System.\")\n        ]\n    CIM_PolicyRule
    REF Dependent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '// PolicyRepository

    '
  - "// ==================================================================\n   [Description
    (\n         \"A class representing an administratively defined \"\n         \"container
    for reusable policy-related information. \"\n         \"This class does not introduce
    any additional \"\n         \"properties beyond those in its superclass \"\n         \"AdminDomain.
    \ It does, however, participate in a \"\n         \"number of unique associations.\"\n
    \        \"\\n\\n\"\n         \"An instance of this class uses the NameFormat
    value\"\n         \"\\\"PolicyRepository\\\", which is defined in the AdminDomain\"\n
    \        \"class.\")\n   ]\n"
  - 'class CIM_PolicyRepository : CIM_AdminDomain

    '
  - '{

    '
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyRepositoryInPolicyRepository

    '
  - "// ==================================================================\n   [Association,
    Aggregation, Description (\n         \"A relationship that aggregates one or more
    lower-level \"\n         \"PolicyRepositories into a higher-level Repository.\")\n
    \  ]\n"
  - 'class CIM_PolicyRepositoryInPolicyRepository : CIM_SystemComponent

    '
  - "{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"A
    PolicyRepository that aggregates other Repositories.\")\n        ]\n    CIM_PolicyRepository
    REF GroupComponent;\n        [Override (\"PartComponent\"), Description (\n         \"A
    PolicyRepository aggregated by another Repository.\")\n        ]\n    CIM_PolicyRepository
    REF PartComponent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '// PolicyCondition

    '
  - "// ==================================================================\n   [Abstract,
    Description (\n         \"A class representing a rule-specific or reusable policy
    \"\n         \"condition to be evaluated in conjunction with a Policy\"\n         \"Rule.
    \ Since all operational details of a PolicyCondition \"\n         \"are provided
    in subclasses of this object, this class is \"\n         \"abstract.\")\n   ]\n"
  - 'class CIM_PolicyCondition : CIM_Policy

    '
  - "{\n        [Key, MaxLen (256), Description (\n          \"  The name of the class
    or the subclass used in the \"\n          \"creation of the System object in whose
    scope this \"\n          \"PolicyCondition is defined.\\n\\n\"\n          \"  \"\n
    \         \"This property helps to identify the System object in \"\n          \"whose
    scope this instance of PolicyCondition exists. \"\n          \"For a rule-specific
    PolicyCondition, this is the System \"\n          \"in whose context the PolicyRule
    is defined.  For a \"\n          \"reusable PolicyCondition, this is the instance
    of \"\n          \"PolicyRepository (which is a subclass of System) that \"\n
    \         \"holds the Condition.\\n\\n\"\n          \"  \"\n          \"Note that
    this property, and the analogous property \"\n          \"SystemName, do not represent
    propagated keys from an \"\n          \"instance of the class System.  Instead,
    they are \"\n          \"properties defined in the context of this class, which
    \"\n          \"repeat the values from the instance of System to which \"\n          \"this
    PolicyCondition is related, either directly via the \"\n          \"PolicyConditionInPolicyRepository
    aggregation or indirectly \"\n          \"via the PolicyConditionInPolicyRule
    aggregation.\")\n        ]\n    string SystemCreationClassName;\n        [Key,
    MaxLen (256), Description (\n         \"  The name of the System object in whose
    scope this \"\n         \"PolicyCondition is defined.\\n\\n\"\n         \"  \"\n
    \        \"This property completes the identification of the System \"\n         \"object
    in whose scope this instance of PolicyCondition \"\n         \"exists.  For a
    rule-specific PolicyCondition, this is the \"\n         \"System in whose context
    the PolicyRule is defined.  For a \"\n         \"reusable PolicyCondition, this
    is the instance of \"\n         \"PolicyRepository (which is a subclass of System)
    that \"\n         \"holds the Condition.\")\n        ]\n    string SystemName;\n
    \       [Key, MaxLen (256), Description (\n         \"For a rule-specific PolicyCondition,
    the \"\n         \"CreationClassName of the PolicyRule object with which \"\n
    \        \"this Condition is associated.  For a reusable Policy\"\n         \"Condition,
    a special value, 'NO RULE', should be used to \"\n         \"indicate that this
    Condition is reusable and not \"\n         \"associated with a single PolicyRule.\")\n
    \       ]\n    string PolicyRuleCreationClassName;\n        [Key, MaxLen (256),
    Description (\n         \"For a rule-specific PolicyCondition, the name of \"\n
    \        \"the PolicyRule object with which this Condition is \"\n         \"associated.
    \ For a reusable PolicyCondition, a \"\n         \"special value, 'NO RULE', should
    be used to indicate \"\n         \"that this Condition is reusable and not associated
    \"\n         \"with a single PolicyRule.\")\n        ]\n    string PolicyRuleName;\n
    \       [Key, MaxLen (256), Description (\n           \"CreationClassName indicates
    the name of the class or the \"\n           \"subclass used in the creation of
    an instance.  When used \"\n           \"with the other key properties of this
    class, this property \"\n           \"allows all instances of this class and its
    subclasses to \"\n           \"be uniquely identified.\") ]\n    string CreationClassName;\n
    \       [Key, MaxLen (256), Description (\n           \"A user-friendly name of
    this PolicyCondition.\")\n        ]\n    string PolicyConditionName;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyConditionInPolicyRule

    '
  - "// ==================================================================\n   [Association,
    Aggregation, Description (\n        \"  A PolicyRule aggregates zero or more instances
    of the \"\n        \"PolicyCondition class, via the PolicyConditionInPolicyRule
    \"\n        \"association.  A Rule that aggregates zero Conditions is not \"\n
    \       \"valid -- it may, however, be in the process of being entered \"\n        \"into
    a PolicyRepository or being defined for a System.  Note \"\n        \"that a PolicyRule
    should have no effect until it is valid.\\n\\n\"\n        \"  \"\n        \"The
    Conditions aggregated by a PolicyRule are grouped into \"\n        \"two levels
    of lists: either an ORed set of ANDed sets of \"\n        \"conditions (DNF, the
    default) or an ANDed set of ORed sets \"\n        \"of conditions (CNF).  Individual
    PolicyConditions in these \"\n        \"lists may be negated.  The property ConditionListType
    \"\n        \"specifies which of these two grouping schemes applies to a \"\n
    \       \"particular PolicyRule.\\n\\n\"\n        \"  \"\n        \"In either
    case, PolicyConditions are used to determine whether \"\n        \"to perform
    the PolicyActions associated with the\n"
  - "PolicyRule.\\n\\n\"\n        \"  \"\n        \"One or more PolicyTimePeriodConditions
    may be among the \"\n        \"conditions associated with a PolicyRule via the
    Policy\"\n        \"ConditionInPolicyRule association.  In this case, the time
    \"\n        \"periods are simply additional Conditions to be evaluated \"\n        \"along
    with any others that are specified for the Rule. \")\n   ]\n"
  - 'class CIM_PolicyConditionInPolicyRule : CIM_PolicyComponent

    '
  - "{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"This
    property represents the PolicyRule that \"\n         \"contains one or more PolicyConditions.\")\n
    \       ]\n    CIM_PolicyRule REF GroupComponent;\n        [Override (\"PartComponent\"),
    Description (\n         \"This property holds the name of a PolicyCondition \"\n
    \        \"contained by one or more PolicyRules.\")\n        ]\n    CIM_PolicyCondition
    REF PartComponent;\n        [Description (\n         \"Unsigned integer indicating
    the group to which the \"\n         \"PolicyCondition identified by the ContainedCondition
    \"\n         \"property belongs.  This integer segments the Conditions \"\n         \"into
    the ANDed sets (when the ConditionListType is \"\n         \"\\\"DNF\\\") or similarly
    the ORed sets (when the Condition\"\n         \"ListType is \\\"CNF\\\") that
    are then evaluated.\")\n        ]\n    uint16 GroupNumber;\n        [Description
    (\n         \"Indication of whether the Condition identified by \"\n         \"the
    ContainedCondition property is negated.  TRUE \"\n         \"indicates that the
    PolicyCondition IS negated, FALSE \"\n         \"indicates that it IS NOT negated.\")\n
    \       ]\n    boolean ConditionNegated;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyConditionInPolicyRepository

    '
  - "// ==================================================================\n   [Association,
    Description (\n         \"  A class representing the hosting of reusable \"\n
    \        \"PolicyConditions by a PolicyRepository.  A reusable Policy\"\n         \"Condition
    is always related to a single PolicyRepository, \"\n         \"via this aggregation.\\n\\n\"\n
    \        \"  \"\n         \"Note, that an instance of PolicyCondition can be either
    \"\n         \"reusable or rule-specific.  When the Condition is rule-\"\n         \"specific,
    it shall not be related to any \"\n         \"PolicyRepository via the PolicyConditionInPolicyRepository
    \"\n         \"aggregation.\")\n   ]\n"
  - 'class CIM_PolicyConditionInPolicyRepository : CIM_PolicyInSystem

    '
  - "{\n        [Override (\"Antecedent\"), Max(1), Description (\n         \"This
    property identifies a PolicyRepository \"\n         \"hosting one or more PolicyConditions.
    \ A reusable \"\n         \"PolicyCondition is always related to exactly one \"\n
    \        \"PolicyRepository via the PolicyConditionInPolicyRepository \"\n         \"aggregation.
    \ The [0..1] cardinality for this property \"\n         \"covers the two types
    of PolicyConditions:  0 for a \"\n         \"rule-specific PolicyCondition, 1
    for a reusable one.\")\n        ]\n    CIM_PolicyRepository REF Antecedent;\n
    \       [Override (\"Dependent\"), Description (\n         \"This property holds
    the name of a PolicyCondition\"\n         \"hosted in the PolicyRepository. \")\n
    \       ]\n    CIM_PolicyCondition REF Dependent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '// PolicyTimePeriodCondition

    '
  - "// ==================================================================\n   [Description
    (\n         \"  This class provides a means of representing the time \"\n         \"periods
    during which a PolicyRule is valid, i.e., active. \"\n         \"At all times
    that fall outside these time periods, the \"\n         \"PolicyRule has no effect.
    \ A Rule is treated as valid \"\n         \"at ALL times, if it does not specify
    a \"\n         \"PolicyTimePeriodCondition.\\n\\n\"\n         \"  \"\n         \"In
    some cases a Policy Consumer may need to perform \"\n         \"certain setup
    / cleanup actions when a PolicyRule becomes \"\n         \"active / inactive.
    \ For example, sessions that were \"\n         \"established while a Rule was
    active might need to \"\n         \"be taken down when the Rule becomes inactive.
    \ In other \"\n         \"cases, however, such sessions might be left up.  In
    this \"\n         \"case, the effect of deactivating the PolicyRule would \"\n
    \        \"just be to prevent the establishment of new sessions. \\n\\n\"\n         \"
    \ \"\n         \"Setup / cleanup behaviors on validity period \"\n         \"transitions
    are not currently addressed by the Policy \"\n         \"Model, and must be specified
    in 'guideline' documents or \"\n         \"via subclasses of CIM_PolicyRule, CIM_PolicyTimePeriod\"\n
    \        \"Condition or other concrete subclasses of CIM_Policy.  If \"\n         \"such
    behaviors need to be under the control of the policy \"\n         \"administrator,
    then a mechanism to allow this control \"\n         \"must also be specified in
    the subclasses.\\n\\n\"\n         \"  \"\n         \"PolicyTimePeriodCondition
    is defined as a subclass of \"\n         \"PolicyCondition.  This is to allow
    the inclusion of \"\n         \"time-based criteria in the AND/OR condition definitions
    \"\n         \"for a PolicyRule.\\n\\n\"\n         \"  \"\n         \"Instances
    of this class may have up to five properties \"\n         \"identifying time periods
    at different levels.  The values \"\n         \"of all the properties present
    in an instance are ANDed \"\n         \"together to determine the validity period(s)
    for the \"\n         \"instance.  For example, an instance with an overall \"\n
    \        \"validity range of January 1, 2000 through December 31, \"\n         \"2000;
    a month mask that selects March and April; a \"\n         \"day-of-the-week mask
    that selects Fridays; and a time \"\n         \"of day range of 0800 through 1600
    would be represented \"\n         \"using the following time periods:\\n\"\n         \"
    \  Friday, March  5, 2000, from 0800 through 1600;\\n \"\n         \"   Friday,
    March 12, 2000, from 0800 through 1600;\\n \"\n         \"   Friday, March 19,
    2000, from 0800 through 1600;\\n \"\n         \"   Friday, March 26, 2000, from
    0800 through 1600;\\n \"\n         \"   Friday, April  2, 2000, from 0800 through
    1600;\\n \"\n         \"   Friday, April  9, 2000, from 0800 through 1600;\\n
    \"\n         \"   Friday, April 16, 2000, from 0800 through 1600;\\n \"\n         \"
    \  Friday, April 23, 2000, from 0800 through 1600;\\n \"\n         \"   Friday,
    April 30, 2000, from 0800 through 1600.\\n\\n\"\n         \"  \"\n         \"Properties
    not present in an instance of \"\n         \"PolicyTimePeriodCondition are implicitly
    treated as having \"\n         \"their value 'always enabled'.  Thus, in the example
    above, \"\n         \"the day-of-the-month mask is not present, and so the \"\n
    \        \"validity period for the instance implicitly includes a \"\n         \"day-of-the-month
    mask that selects all days of the month. \"\n         \"If this 'missing property'
    rule is applied to its fullest, we \"\n         \"see that there is a second way
    to indicate that a Policy\"\n         \"Rule is always enabled: associate with
    it an instance of \"\n         \"PolicyTimePeriodCondition whose only properties
    with \"\n         \"specific values are its key properties.\")\n   ]\n"
  - 'class CIM_PolicyTimePeriodCondition : CIM_PolicyCondition

    '
  - "{\n        [Description (\n         \"  This property identifies an overall range
    of calendar \"\n         \"dates and times over which a PolicyRule is valid.  It
    is \"\n         \"formatted as a string representing a start date and time, \"\n
    \        \"in which the character 'T' indicates the beginning of the \"\n         \"time
    portion, followed by the solidus character '/', \"\n         \"followed by a similar
    string representing an end date and \"\n         \"time.  The first date indicates
    the beginning of the range, \"\n         \"while the second date indicates the
    end.  Thus, the second \"\n         \"date and time must be later than the first.
    \ Date/times are \"\n         \"expressed as substrings of the form yyyymmddThhmmss.
    \ For \"\n         \"example: \\n\"\n         \"   20000101T080000/20000131T120000
    defines \\n\"\n         \"   January 1, 2000, 0800 through January 31, 2000, noon\\n\\n\"\n
    \        \"  \"\n         \"There are also two special cases in which one of the
    \"\n         \"date/time strings is replaced with a special string defined \"\n
    \        \"in RFC 2445.\\n \"\n         \"   o If the first date/time is replaced
    with the string \"\n         \"     'THISANDPRIOR', then the property indicates
    that a \"\n         \"     PolicyRule is valid [from now] until the date/time
    \"\n         \"     that appears after the '/'.\\n\"\n         \"   o If the second
    date/time is replaced with the string \"\n         \"     'THISANDFUTURE', then
    the property indicates that a \"\n         \"     PolicyRule becomes valid on
    the date/time that \"\n         \"     appears before the '/', and remains valid
    from that \"\n         \"     point on. \"),\n         ModelCorrespondence {\n
    \       \"CIM_PolicyTimePeriodCondition.MonthOfYearMask\",\n        \"CIM_PolicyTimePeriodCondition.DayOfMonthMask\",\n
    \       \"CIM_PolicyTimePeriodCondition.DayOfWeekMask\",\n        \"CIM_PolicyTimePeriodCondition.TimeOfDayMask\",\n
    \       \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"}\n        ]\n    string
    TimePeriod;\n        [Octetstring, Description (\n         \"  The purpose of
    this property is to refine the valid time \"\n         \"period that is defined
    by the TimePeriod property, by \"\n         \"explicitly specifying in which months
    the PolicyRule is \"\n         \"valid.  These properties work together, with
    the \"\n         \"TimePeriod used to specify the overall time period in \"\n
    \        \"which the PolicyRule is valid, and the MonthOfYearMask used \"\n         \"to
    pick out the months during which the Rule is valid.\\n\\n\"\n         \"  \"\n
    \        \"This property is formatted as an octet string, structured \"\n         \"as
    follows:\\n\"\n         \"   o a 4-octet length field, indicating the length of
    the \"\n         \"    entire octet string; this field is always set to \"\n         \"
    \   0x00000006 for this property;\\n\"\n         \"   o a 2-octet field consisting
    of 12 bits identifying the \"\n         \"     12 months of the year, beginning
    with January and \"\n         \"     ending with December, followed by 4 bits
    that are \"\n         \"     always set to '0'.  For each month, the value '1'
    \"\n         \"     indicates that the policy is valid for that month, \"\n         \"
    \    and the value '0' indicates that it is not valid.\\n\\n\"\n         \"  \"\n
    \        \"The value 0x000000060830, for example, indicates that a \"\n         \"PolicyRule
    is valid only in the months May, November, \"\n         \"and December.\\n\\n\"\n
    \        \"  \"\n         \"If a value for this property is not provided, then
    the \"\n         \"PolicyRule is treated as valid for all twelve months, and \"\n
    \        \"only restricted by its TimePeriod property value and the \"\n         \"other
    Mask properties.\"),\n        ModelCorrespondence {\n        \"CIM_PolicyTimePeriodCondition.TimePeriod\",\n
    \       \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"}\n        ]\n    uint8
    MonthOfYearMask[];\n        [Octetstring, Description (\n         \"  The purpose
    of this property is to refine the valid time \"\n         \"period that is defined
    by the TimePeriod property, by \"\n         \"explicitly specifying in which days
    of the month the Policy\"\n         \"Rule is valid.  These properties work together,
    \"\n         \"with the TimePeriod used to specify the overall time period \"\n
    \        \"in which the PolicyRule is valid, and the DayOfMonthMask used \"\n
    \        \"to pick out the days of the month during which the Rule \"\n         \"is
    valid.\\n\\n \"\n         \"  \"\n         \"This property is formatted as an
    octet string, structured \"\n         \"as follows:\\n\"\n         \"   o a 4-octet
    length field, indicating the length of the \"\n         \"     entire octet string;
    this field is always set to \"\n         \"     0x0000000C for this property;
    \\n\"\n         \"   o an 8-octet field consisting of 31 bits identifying \"\n
    \        \"     the days of the month counting from the beginning, \"\n         \"
    \    followed by 31 more bits identifying the days of the \"\n         \"     month
    counting from the end, followed by 2 bits that \"\n         \"     are always
    set to '0'.  For each day, the value '1' \"\n         \"     indicates that the
    policy is valid for that day, and \"\n         \"     the value '0' indicates
    that it is not valid. \\n\\n\"\n         \"  \"\n         \"The value 0x0000000C8000000100000000,
    for example, \"\n         \"indicates that a PolicyRule is valid on the first
    and \"\n         \"last days of the month.\\n\\n \"\n         \"  \"\n         \"For
    months with fewer than 31 days, the digits corresponding \"\n         \"to days
    that the months do not have (counting in both \"\n         \"directions) are ignored.\\n\\n\"\n
    \        \"  \"\n         \"If a value for this property is not provided, then
    the \"\n         \"PolicyRule is treated as valid for all days of the month, and
    \"\n         \"only restricted by its TimePeriod property value and the \"\n         \"other
    Mask properties.\"),\n        ModelCorrespondence {\n        \"CIM_PolicyTimePeriodCondition.TimePeriod\",\n
    \       \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"}\n        ]\n    uint8
    DayOfMonthMask[];\n        [Octetstring, Description (\n         \"  The purpose
    of this property is to refine the valid time \"\n         \"period that is defined
    by the TimePeriod property, by \"\n         \"explicitly specifying in which days
    of the month the Policy\"\n         \"Rule is valid.  These properties work together,
    \"\n         \"with the TimePeriod used to specify the overall time period \"\n
    \        \"in which the PolicyRule is valid, and the DayOfWeekMask used \"\n         \"to
    pick out the days of the week during which the Rule \"\n         \"is valid.\\n\\n
    \"\n         \"  \"\n         \"This property is formatted as an octet string,
    structured \"\n         \"as follows:\\n \"\n         \"  o a 4-octet length field,
    indicating the length of the \"\n         \"    entire octet string; this field
    is always set to \"\n         \"    0x00000005 for this property;\\n\"\n         \"
    \ o a 1-octet field consisting of 7 bits identifying the 7 \"\n         \"    days
    of the week, beginning with Sunday and ending with \"\n         \"    Saturday,
    followed by 1 bit that is always set to '0'. \"\n         \"    For each day of
    the week, the value '1' indicates that \"\n         \"    the policy is valid
    for that day, and the value '0' \"\n         \"    indicates that it is not valid.
    \\n\\n\"\n         \"  \"\n         \"The value 0x000000057C, for example, indicates
    that a \"\n         \"PolicyRule is valid Monday through Friday.\\n\\n\"\n         \"
    \ \"\n         \"If a value for this property is not provided, then the \"\n         \"PolicyRule
    is treated as valid for all days of the week, \"\n         \"and only restricted
    by its TimePeriod property value and \"\n         \"the other Mask properties.\"),\n
    \       ModelCorrespondence {\n        \"CIM_PolicyTimePeriodCondition.TimePeriod\",\n
    \       \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"}\n        ]\n    uint8
    DayOfWeekMask[];\n        [Description (\n         \"  The purpose of this property
    is to refine the valid time \"\n         \"period that is defined by the TimePeriod
    property, by \"\n         \"explicitly specifying a range of times in a day during
    which \"\n         \"the PolicyRule is valid.  These properties work \"\n         \"together,
    with the TimePeriod used to specify the overall \"\n         \"time period in
    which the PolicyRule is valid, and the \"\n         \"TimeOfDayMask used to pick
    out the range of time periods \"\n         \"in a given day of during which the
    Rule is valid. \\n\\n\"\n         \"  \"\n         \"This property is formatted
    in the style of RFC 2445:  a \"\n         \"time string beginning with the character
    'T', followed by \"\n         \"the solidus character '/', followed by a second
    time string. \"\n         \"The first time indicates the beginning of the range,
    while \"\n         \"the second time indicates the end.  Times are expressed as
    \"\n         \"substrings of the form 'Thhmmss'. \\n\\n\"\n         \"  \"\n         \"The
    second substring always identifies a later time than \"\n         \"the first
    substring.  To allow for ranges that span \"\n         \"midnight, however, the
    value of the second string may be \"\n         \"smaller than the value of the
    first substring.  Thus, \"\n         \"'T080000/T210000' identifies the range
    from 0800 until 2100, \"\n         \"while 'T210000/T080000' identifies the range
    from 2100 until \"\n         \"0800 of the following day. \\n\\n\"\n         \"
    \ \"\n         \"When a range spans midnight, it by definition includes \"\n         \"parts
    of two successive days.  When one of these days is \"\n         \"also selected
    by either the MonthOfYearMask, \"\n         \"DayOfMonthMask, and/or DayOfWeekMask,
    but the other day is \"\n         \"not, then the policy is active only during
    the portion of \"\n         \"the range that falls on the selected day.  For example,
    if \"\n         \"the range extends from 2100 until 0800, and the day of \"\n
    \        \"week mask selects Monday and Tuesday, then the policy is \"\n         \"active
    during the following three intervals:\\n\"\n         \"    From midnight Sunday
    until 0800 Monday; \\n\"\n         \"    From 2100 Monday until 0800 Tuesday;
    \\n\"\n         \"    From 2100 Tuesday until 23:59:59 Tuesday. \\n\\n\"\n         \"
    \ \"\n         \"If a value for this property is not provided, then the \"\n         \"PolicyRule
    is treated as valid for all hours of the day, \"\n         \"and only restricted
    by its TimePeriod property value and \"\n         \"the other Mask properties.\"),\n
    \       ModelCorrespondence {\n        \"CIM_PolicyTimePeriodCondition.TimePeriod\",\n
    \       \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"}\n        ]\n    string
    TimeOfDayMask;\n        [Description (\n         \"  This property indicates whether
    the times represented \"\n         \"in the TimePeriod property and in the various
    Mask \"\n         \"properties represent local times or UTC times.  There is \"\n
    \        \"no provision for mixing of local times and UTC times:  the \"\n         \"value
    of this property applies to all of the other \"\n         \"time-related properties.\"),\n
    \        ValueMap { \"1\", \"2\" },\n         Values { \"localTime\", \"utcTime\"
    },\n         ModelCorrespondence {\n         \"CIM_PolicyTimePeriodCondition.TimePeriod\",\n
    \        \"CIM_PolicyTimePeriodCondition.MonthOfYearMask\",\n         \"CIM_PolicyTimePeriodCondition.DayOfMonthMask\",\n
    \        \"CIM_PolicyTimePeriodCondition.DayOfWeekMask\",\n         \"CIM_PolicyTimePeriodCondition.TimeOfDayMask\"}\n
    \       ]\n    uint16 LocalOrUtcTime;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyRuleValidityPeriod

    '
  - "// ==================================================================\n   [Association,
    Aggregation, Description (\n         \"The PolicyRuleValidityPeriod aggregation
    represents \"\n         \"scheduled activation and deactivation of a PolicyRule.
    \"\n         \"If a PolicyRule is associated with multiple policy time \"\n         \"periods
    via this association, then the Rule is active if \"\n         \"at least one of
    the time periods indicates that it is \"\n         \"active.  (In other words,
    the PolicyTimePeriodConditions \"\n         \"are ORed to determine whether the
    Rule is active.)  A Time\"\n         \"Period may be aggregated by multiple PolicyRules.
    \ A Rule \"\n         \"that does not point to a PolicyTimePeriodCondition via
    this \"\n         \"association is, from the point of view of scheduling, \"\n
    \        \"always active.  It may, however, be inactive for other \"\n         \"reasons.
    \ For example, the Rule's Enabled property may \"\n         \"be set to \\\"disabled\\\"
    (value=2).\")\n   ]\n"
  - 'class CIM_PolicyRuleValidityPeriod : CIM_PolicyComponent

    '
  - "{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"This
    property contains the name of a PolicyRule that \"\n         \"contains one or
    more PolicyTimePeriodConditions.\")\n        ]\n    CIM_PolicyRule REF GroupComponent;\n
    \       [Override (\"PartComponent\"), Description (\n         \"This property
    contains the name of a \"\n         \"PolicyTimePeriodCondition defining the valid
    time periods \"\n         \"for one or more PolicyRules.\")\n        ]\n    CIM_PolicyTimePeriodCondition
    REF PartComponent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '// VendorPolicyCondition

    '
  - "// ==================================================================\n   [Description
    (\n         \"  A class that provides a general extension mechanism for \"\n         \"representing
    PolicyConditions that have not been modeled \"\n         \"with specific properties.
    \ Instead, the two properties \"\n         \"Constraint and ConstraintEncoding
    are used to define the \"\n         \"content and format of the Condition, as
    explained below.\\n\\n\"\n         \"  \"\n         \"As its name suggests, VendorPolicyCondition
    is intended for \"\n         \"vendor-specific extensions to the Policy Core Information
    \"\n         \"Model.  Standardized extensions are not expected to use \"\n         \"this
    class.\")\n   ]\n"
  - 'class CIM_VendorPolicyCondition : CIM_PolicyCondition

    '
  - "{\n        [Octetstring, Description (\n         \"This property provides a general
    extension mechanism for \"\n         \"representing PolicyConditions that have
    not been \"\n         \"modeled with specific properties.  The format of the \"\n
    \        \"octet strings in the array is left unspecified in \"\n         \"this
    definition.  It is determined by the OID value \"\n         \"stored in the property
    ConstraintEncoding.  Since \"\n         \"ConstraintEncoding is single-valued,
    all the values of \"\n         \"Constraint share the same format and semantics.\"),\n
    \        ModelCorrespondence {\n            \"CIM_VendorPolicyCondition.ConstraintEncoding\"}\n
    \       ]\n    string Constraint [];\n        [Description (\n         \"An OID
    encoded as a string, identifying the format \"\n         \"and semantics for this
    instance's Constraint property.\"),\n         ModelCorrespondence {\n            \"CIM_VendorPolicyCondition.Constraint\"}\n
    \       ]\n    string ConstraintEncoding;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '// PolicyAction

    '
  - "// ==================================================================\n   [Abstract,
    Description (\n         \"A class representing a rule-specific or reusable policy
    \"\n         \"action to be performed if the PolicyConditions for a Policy\"\n
    \        \"Rule evaluate to TRUE.  Since all operational details of a \"\n         \"PolicyAction
    are provided in subclasses of this object, \"\n         \"this class is abstract.\")\n
    \  ]\n"
  - 'class CIM_PolicyAction : CIM_Policy

    '
  - "{\n        [Key, MaxLen (256), Description (\n         \"  The name of the class
    or the subclass used in the \"\n         \"creation of the System object in whose
    scope this \"\n         \"PolicyAction is defined. \\n\\n\"\n         \"  \"\n
    \        \"This property helps to identify the System object in \"\n         \"whose
    scope this instance of PolicyAction exists. \"\n         \"For a rule-specific
    PolicyAction, this is the System \"\n         \"in whose context the PolicyRule
    is defined.  For a \"\n         \"reusable PolicyAction, this is the instance
    of \"\n         \"PolicyRepository (which is a subclass of System) that \"\n         \"holds
    the Action. \\n\\n\"\n         \"  \"\n         \"Note that this property, and
    the analogous property \"\n         \"SystemName, do not represent propagated
    keys from an \"\n         \"instance of the class System.  Instead, they are \"\n
    \        \"properties defined in the context of this class, which \"\n         \"repeat
    the values from the instance of System to which \"\n         \"this PolicyAction
    is related, either directly via the \"\n         \"PolicyActionInPolicyRepository
    aggregation or indirectly \"\n         \"via the PolicyActionInPolicyRule aggregation.\")\n
    \       ]\n    string SystemCreationClassName;\n        [Key, MaxLen (256), Description
    (\n         \"  The name of the System object in whose scope this \"\n         \"PolicyAction
    is defined. \\n\\n\"\n         \"  \"\n         \"This property completes the
    identification of the System \"\n         \"object in whose scope this instance
    of PolicyAction \"\n         \"exists.  For a rule-specific PolicyAction, this
    is the \"\n         \"System in whose context the PolicyRule is defined.  For
    \"\n         \"a reusable PolicyAction, this is the instance of \"\n         \"PolicyRepository
    (which is a subclass of System) that \"\n         \"holds the Action.\")\n        ]\n
    \   string SystemName;\n        [Key, MaxLen (256), Description (\n         \"For
    a rule-specific PolicyAction, the CreationClassName \"\n         \"of the PolicyRule
    object with which this Action is \"\n         \"associated.  For a reusable PolicyAction,
    a \"\n         \"special value, 'NO RULE', should be used to \"\n         \"indicate
    that this Action is reusable and not \"\n         \"associated with a single PolicyRule.\")\n
    \       ]\n    string PolicyRuleCreationClassName;\n        [Key, MaxLen (256),
    Description (\n         \"For a rule-specific PolicyAction, the name of \"\n         \"the
    PolicyRule object with which this Action is \"\n         \"associated.  For a
    reusable PolicyAction, a \"\n         \"special value, 'NO RULE', should be used
    to \"\n         \"indicate that this Action is reusable and not \"\n         \"associated
    with a single PolicyRule.\")\n        ]\n    string PolicyRuleName;\n        [Key,
    MaxLen (256), Description (\n           \"CreationClassName indicates the name
    of the class or the \"\n           \"subclass used in the creation of an instance.
    \ When used \"\n           \"with the other key properties of this class, this
    property \"\n           \"allows all instances of this class and its subclasses
    to \"\n           \"be uniquely identified.\") ]\n    string CreationClassName;\n
    \       [Key, MaxLen (256), Description (\n         \"A user-friendly name of
    this PolicyAction.\")\n        ]\n    string PolicyActionName;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyActionInPolicyRepository

    '
  - "// ==================================================================\n   [Association,
    Description (\n         \"  A class representing the hosting of reusable \"\n
    \        \"PolicyActions by a PolicyRepository.  A reusable Policy\"\n         \"Action
    is always related to a single PolicyRepository, \"\n         \"via this aggregation.\\n\\n\"\n
    \        \"  \"\n         \"Note, that an instance of PolicyAction can be either
    \"\n         \"reusable or rule-specific.  When the Action is rule-\"\n         \"specific,
    it shall not be related to any \"\n         \"PolicyRepository via the PolicyActionInPolicyRepository
    \"\n         \"aggregation.\")\n   ]\n"
  - 'class CIM_PolicyActionInPolicyRepository : CIM_PolicyInSystem

    '
  - "{\n        [Override (\"Antecedent\"), Max(1), Description (\n         \"This
    property represents a PolicyRepository \"\n         \"hosting one or more PolicyActions.
    \ A reusable \"\n         \"PolicyAction is always related to exactly one \"\n
    \        \"PolicyRepository via the PolicyActionInPolicyRepository \"\n         \"aggregation.
    \ The [0..1] cardinality for this property \"\n         \"covers the two types
    of PolicyActions:  0 for a \"\n         \"rule-specific PolicyAction, 1 for a
    reusable one.\")\n        ]\n    CIM_PolicyRepository REF Antecedent;\n        [Override
    (\"Dependent\"), Description (\n         \"This property holds the name of a PolicyAction\"\n
    \        \"hosted in the PolicyRepository. \")\n        ]\n    CIM_PolicyAction
    REF Dependent;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '//    PolicyActionInPolicyRule

    '
  - "// ==================================================================\n   [Association,
    Aggregation, Description (\n        \"  A PolicyRule aggregates zero or more instances
    of the \"\n        \"PolicyAction class, via the PolicyActionInPolicyRule \"\n
    \       \"association.  A Rule that aggregates zero Actions is not \"\n        \"valid
    -- it may, however, be in the process of being entered \"\n        \"into a PolicyRepository
    or being defined for a System. \"\n        \"Alternately, the actions of the policy
    may be explicit in \"\n        \"the definition of the PolicyRule.  Note that
    a PolicyRule \"\n        \"should have no effect until it is valid.\\n\\n\"\n
    \       \"  \"\n        \"The Actions associated with a PolicyRule may be given
    a \"\n        \"required order, a recommended order, or no order at all.  For
    \"\n        \"Actions represented as separate objects, the PolicyActionIn\"\n
    \       \"PolicyRule aggregation can be used to express an order. \\n\\n\"\n        \"
    \ \"\n        \"This aggregation does not indicate whether a specified \"\n        \"action
    order is required, recommended, or of no significance; \"\n        \"the property
    SequencedActions in the aggregating instance of \"\n        \"PolicyRule provides
    this indication.\")\n   ]\n"
  - 'class CIM_PolicyActionInPolicyRule : CIM_PolicyComponent

    '
  - "{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"This
    property represents the PolicyRule that \"\n         \"contains one or more PolicyActions.\")\n
    \       ]\n    CIM_PolicyRule REF GroupComponent;\n        [Override (\"PartComponent\"),
    Description (\n         \"This property holds the name of a PolicyAction \"\n
    \        \"contained by one or more PolicyRules.\")\n        ]\n    CIM_PolicyAction
    REF PartComponent;\n        [Description (\n         \"  This property provides
    an unsigned integer 'n' that\"\n         \"indicates the relative position of
    a PolicyAction in the \"\n         \"sequence of actions associated with a PolicyRule.
    \"\n         \"When 'n' is a positive integer, it indicates a place \"\n         \"in
    the sequence of actions to be performed, with \"\n         \"smaller integers
    indicating earlier positions in the \"\n         \"sequence.  The special value
    '0' indicates 'don't care'. \"\n         \"If two or more PolicyActions have the
    same non-zero \"\n         \"sequence number, they may be performed in any order,
    but \"\n         \"they must all be performed at the appropriate place in the
    \"\n         \"overall action sequence. \\n\\n\"\n         \"  \"\n         \"A
    series of examples will make ordering of PolicyActions \"\n         \"clearer:
    \\n\"\n         \"   o If all actions have the same sequence number, \"\n         \"
    \    regardless of whether it is '0' or non-zero, any \"\n         \"     order
    is acceptable.\\n \"\n         \"   o The values: \\n\"\n         \"         1:ACTION
    A \\n\"\n         \"         2:ACTION B \\n\"\n         \"         1:ACTION C
    \\n\"\n         \"         3:ACTION D \\n\"\n         \"     indicate two acceptable
    orders: A,C,B,D or C,A,B,D, \"\n         \"     since A and C can be performed
    in either order, but \"\n         \"     only at the '1' position. \\n\"\n         \"
    \  o The values: \\n\"\n         \"         0:ACTION A \\n\"\n         \"         2:ACTION
    B \\n\"\n         \"         3:ACTION C \\n\"\n         \"         3:ACTION D
    \\n\"\n         \"     require that B,C, and D occur either as B,C,D or as \"\n
    \        \"     B,D,C.  Action A may appear at any point relative to \"\n         \"
    \    B, C, and D.  Thus the complete set of acceptable \"\n         \"     orders
    is:  A,B,C,D; B,A,C,D; B,C,A,D; B,C,D,A; \"\n         \"     A,B,D,C; B,A,D,C;
    B,D,A,C; B,D,C,A. \\n\\n\"\n         \"  \"\n         \"Note that the non-zero
    sequence numbers need not start \"\n         \"with '1', and they need not be
    consecutive.  All that \"\n         \"matters is their relative magnitude.\")\n
    \       ]\n    uint16 ActionOrder;\n"
  - '};

    '
  - '// ==================================================================

    '
  - '// VendorPolicyAction

    '
  - "// ==================================================================\n   [Description
    (\n         \"  A class that provides a general extension mechanism for \"\n         \"representing
    PolicyActions that have not been modeled \"\n         \"with specific properties.
    \ Instead, the two properties \"\n         \"ActionData and ActionEncoding are
    used to define the \"\n         \"content and format of the Action, as explained
    below.\\n\\n\"\n         \"  \"\n         \"As its name suggests, VendorPolicyAction
    is intended for \"\n         \"vendor-specific extensions to the Policy Core Information
    \"\n         \"Model.  Standardized extensions are not expected to use \"\n         \"this
    class.\")  ]\n"
  - 'class CIM_VendorPolicyAction : CIM_PolicyAction

    '
  - "{\n        [Octetstring, Description (\n         \"This property provides a general
    extension mechanism for \"\n         \"representing PolicyActions that have not
    been \"\n         \"modeled with specific properties.  The format of the \"\n
    \        \"octet strings in the array is left unspecified in \"\n         \"this
    definition.  It is determined by the OID value \"\n         \"stored in the property
    ActionEncoding.  Since \"\n         \"ActionEncoding is single-valued, all the
    values of \"\n         \"ActionData share the same format and semantics.\"),\n
    \        ModelCorrespondence {\n            \"CIM_VendorPolicyAction.ActionEncoding\"}\n
    \       ]\n    string ActionData [];\n        [Description (\n         \"An OID
    encoded as a string, identifying the format \"\n         \"and semantics for this
    instance's ActionData property.\"),\n         ModelCorrespondence {\n            \"CIM_VendorPolicyAction.ActionData\"}\n
    \       ]\n    string ActionEncoding;\n"
  - '};

    '
  - '// ===================================================================

    '
  - '// end of file

    '
  - '// ===================================================================

    '
  title: '14. Appendix B:  The Core Policy MOF'
- contents:
  - "15.  Full Copyright Statement\n   Copyright (C) The Internet Society (2001).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 15.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
