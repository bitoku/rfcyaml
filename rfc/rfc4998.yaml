- title: __initial_text__
  contents:
  - '                      Evidence Record Syntax (ERS)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   In many scenarios, users must be able prove the existence and\n\
    \   integrity of data, including digitally signed data, in a common and\n   reproducible\
    \ way over a long and possibly undetermined period of\n   time.  This document\
    \ specifies the syntax and processing of an\n   Evidence Record, a structure designed\
    \ to support long-term non-\n   repudiation of existence of data.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  Motivation . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n     1.2.  General Overview and Requirements  . . . . . . . .\
    \ . . . .  4\n     1.3.  Terminology  . . . . . . . . . . . . . . . . . . . .\
    \ . . .  5\n     1.4.  Conventions Used in This Document  . . . . . . . . . .\
    \ . .  6\n   2.  Identification and References  . . . . . . . . . . . . . . .\
    \ .  7\n     2.1.  ASN.1 Module Definition  . . . . . . . . . . . . . . . . .\
    \  7\n       2.1.1.  ASN.1 Module Definition for 1988 ASN.1 Syntax  . . . .  7\n\
    \       2.1.2.  ASN.1 Module Definition for 1997-ASN.1 Syntax  . . . .  7\n  \
    \   2.2.  ASN.1 Imports and Exports  . . . . . . . . . . . . . . . .  7\n    \
    \   2.2.1.  Imports and Exports Conform with 1988 ASN.1  . . . . .  8\n      \
    \ 2.2.2.  Imports and Exports Conform with 1997-ASN.1  . . . . .  8\n     2.3.\
    \  LTANS Identification . . . . . . . . . . . . . . . . . . .  9\n   3.  Evidence\
    \ Record  . . . . . . . . . . . . . . . . . . . . . . .  9\n     3.1.  Syntax\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . .  9\n     3.2.  Generation\
    \ . . . . . . . . . . . . . . . . . . . . . . . . 10\n     3.3.  Verification\
    \ . . . . . . . . . . . . . . . . . . . . . . . 11\n   4.  Archive Timestamp \
    \ . . . . . . . . . . . . . . . . . . . . . . 11\n     4.1.  Syntax . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . 11\n     4.2.  Generation . . . .\
    \ . . . . . . . . . . . . . . . . . . . . 12\n     4.3.  Verification . . . .\
    \ . . . . . . . . . . . . . . . . . . . 15\n   5.  Archive Timestamp Chain and\
    \ Archive Timestamp Sequence . . . . 16\n     5.1.  Syntax . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . 17\n     5.2.  Generation . . . . . . . . .\
    \ . . . . . . . . . . . . . . . 17\n     5.3.  Verification . . . . . . . . .\
    \ . . . . . . . . . . . . . . 19\n   6.  Encryption . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . 20\n     6.1.  Syntax . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . 21\n       6.1.1.  EncryptionInfo in 1988 ASN.1 . .\
    \ . . . . . . . . . . . 21\n       6.1.2.  EncryptionInfo in 1997-ASN.1 . . .\
    \ . . . . . . . . . . 22\n   7.  Security Considerations  . . . . . . . . . .\
    \ . . . . . . . . . 22\n   8.  References . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 23\n     8.1.  Normative References . . . . . . . . . . . .\
    \ . . . . . . . 23\n     8.2.  Informative References . . . . . . . . . . . .\
    \ . . . . . . 24\n   Appendix A.  Evidence Record Using CMS . . . . . . . . .\
    \ . . . . . 26\n   Appendix B.  ASN.1-Module with 1988 Syntax . . . . . . . .\
    \ . . . . 27\n   Appendix C.  ASN.1-Module with 1997 Syntax . . . . . . . . .\
    \ . . . 29\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Motivation
  contents:
  - "1.1.  Motivation\n   In many application areas of electronic data exchange, a\
    \ non-\n   repudiable proof of the existence of digital data must be possible.\n\
    \   In some cases, this proof must survive the passage of long periods of\n  \
    \ time.  An important example is digitally signed data.  Digital\n   signatures\
    \ can be used to demonstrate data integrity and to perform\n   source authentication.\
    \  In some cases, digitally signed data must be\n   archived for 30 years or more.\
    \  However, the reliability of digital\n   signatures over long periods is not\
    \ absolute.  During the archival\n   period, hash algorithms and public key algorithms\
    \ can become weak or\n   certificates can become invalid.  These events complicate\
    \ the\n   reliance on digitally signed data after many years by increasing the\n\
    \   likelihood that forgeries can be created.  To avoid losing the\n   desired\
    \ security properties derived from digital signatures, it is\n   necessary to\
    \ prove that the digitally signed data already existed\n   before such a critical\
    \ event.  This can be accomplished using a\n   timestamp.  However, some timestamps\
    \ rely upon mechanisms that will\n   be subject to the same problems.  To counter\
    \ this problem, timestamps\n   are renewed by simply obtaining a new timestamp\
    \ that covers the\n   original data and its timestamps prior to the compromise\
    \ of\n   mechanisms used to generate the timestamps.  This document provides a\n\
    \   syntax to support the periodic renewal of timestamps.\n   It is necessary\
    \ to standardize the data formats and processing\n   procedures for such timestamps\
    \ in order to be able to verify and\n   communicate preservation evidence.  A\
    \ first approach was made by IETF\n   within [RFC3126], where an optional Archive\
    \ Timestamp Attribute was\n   specified for integration in signatures according\
    \ to the\n   Cryptographic Messages Syntax (CMS) [RFC3852].\n   Evidence Record\
    \ Syntax (ERS) broadens and generalizes this approach\n   for data of any format\
    \ and takes long-term archive service\n   requirements [RFC4810] into account\
    \ -- in particular, the handling of\n   large sets of data objects.  ERS specifies\
    \ a syntax for an\n   EvidenceRecord, which contains a set of Archive Timestamps\
    \ and some\n   additional data.  This Evidence Record can be stored separately\
    \ from\n   the archived data, as a file, or integrated into the archived data,\n\
    \   i.e., as an attribute.  ERS also specifies processes for generation\n   and\
    \ verification of Evidence Records.  Appendix A describes the\n   integration\
    \ and use of an EvidenceRecord in context of signed and\n   enveloped messages\
    \ according to the Cryptographic Message Syntax\n   (CMS).  ERS does not specify\
    \ a protocol for interacting with a long-\n   term archive system.  The Long-term\
    \ Archive Protocol specification\n   being developed by the IETF LTANS WG addresses\
    \ this interface.\n"
- title: 1.2.  General Overview and Requirements
  contents:
  - "1.2.  General Overview and Requirements\n   ERS is designed to meet the requirements\
    \ for data structures set\n   forth in [RFC4810].\n   The basis of the ERS are\
    \ Archive Timestamps, which can cover a single\n   data object (as an RFC3161\
    \ compliant timestamp does) or can cover a\n   group of data objects.  Groups\
    \ of data objects are addressed using\n   hash trees, first described by Merkle\
    \ [MER1980], combined with a\n   timestamp.  The leaves of the hash tree are hash\
    \ values of the data\n   objects in a group.  A timestamp is requested only for\
    \ the root hash\n   of the hash tree.  The deletion of a data object in the tree\
    \ does not\n   influence the provability of others.  For any particular data object,\n\
    \   the hash tree can be reduced to a few sets of hash values, which are\n   sufficient\
    \ to prove the existence of a single data object.\n   Similarly, the hash tree\
    \ can be reduced to prove existence of a data\n   group, provided all members\
    \ of the data group have the same parent\n   node in the hash tree.  Archive Timestamps\
    \ are comprised of an\n   optional reduced hash tree and a timestamp.\n   An EvidenceRecord\
    \ may contain many Archive Timestamps.  For the\n   generation of the initial\
    \ Archive Timestamp, the data objects to be\n   timestamped have to be determined.\
    \  Depending on the context, this\n   could be a file or a data object group consisting\
    \ of multiple files,\n   such as a document and its associated digital signature.\n\
    \   Before the cryptographic algorithms used within the Archive Timestamp\n  \
    \ become weak or timestamp certificates become invalid, Archive\n   Timestamps\
    \ have to be renewed by generating a new Archive Timestamp.\n   (Note: Information\
    \ about the weakening of the security properties of\n   public key and hash algorithms,\
    \ as well as the risk of compromise of\n   private keys of Time Stamping Units,\
    \ has to be closely watched by the\n   Long-Term Archive provider or the owner\
    \ of the data objects himself.\n   This information should be gathered by \"out-of-band\"\
    \ means and is out\n   of scope of this document.)  ERS distinguishes two ways\
    \ for renewal\n   of an Archive Timestamp: Timestamp Renewal and Hash-Tree Renewal.\n\
    \   Depending on the conditions, the respective type of renewal is\n   required:\
    \ The timestamp renewal is necessary if the private key of a\n   Timestamping\
    \ Unit has been compromised, or if an asymmetric algorithm\n   or a hash algorithm\
    \ used for the generation of the timestamps is no\n   longer secure for the given\
    \ key size.  If the hash algorithm used to\n   build the hash trees in the Archive\
    \ Timestamp loses its security\n   properties, the Hash-Tree Renewal is required.\n\
    \   In the case of Timestamp Renewal, the timestamp of an Archive\n   Timestamp\
    \ has to be hashed and timestamped by a new Archive\n   Timestamp.  This mode\
    \ of renewal can only be used when it is not\n   necessary to access the archived\
    \ data objects covered by the\n   timestamp.  For example, this simple form of\
    \ renewal is sufficient if\n   the public key algorithm of the timestamp is going\
    \ to lose its\n   security or the timestamp authority certificate is about to\
    \ expire.\n   This is very efficient, in particular, if Archive Timestamping is\n\
    \   done by an archiving system or service, which implements a central\n   management\
    \ of Archive Timestamps.\n   Timestamp renewal is not sufficient if the hash algorithm\
    \ used to\n   build the hash tree of an Archive Timestamp becomes insecure.  In\
    \ the\n   case of Hash-Tree Renewal, all evidence data must be accessed and\n\
    \   timestamped.  This includes not only the timestamps but also the\n   complete\
    \ Archive Timestamps and the archived data objects covered by\n   the timestamps,\
    \ which must be hashed and timestamped again by a new\n   Archive Timestamp.\n"
- title: 1.3.  Terminology
  contents:
  - "1.3.  Terminology\n   Archived data object: A data unit that is archived and\
    \ has to be\n   preserved for a long time by the Long-term Archive Service.\n\
    \   Archived data object group: A set of two or more of data objects,\n   which\
    \ for some reason belong together.  For example, a document file\n   and a signature\
    \ file could be an archived data object group, which\n   represent signed data.\n\
    \   Archive Timestamp: A timestamp and typically lists of hash values,\n   which\
    \ allow the verification of the existence of several data objects\n   at a certain\
    \ time.  (In its most simple variant, when it covers only\n   one object, it may\
    \ only consist of the timestamp.)\n   Archive Timestamp Chain: Part of an Archive\
    \ Timestamp Sequence, it is\n   a time-ordered sequence of Archive Timestamps,\
    \ where each Archive\n   Timestamp preserves non-repudiation of the previous Archive\n\
    \   Timestamp, even after the previous Archive Timestamp becomes invalid.\n  \
    \ Overall non-repudiation is maintained until the new Archive Timestamp\n   itself\
    \ becomes invalid.  The process of generating such an Archive\n   Timestamp Chain\
    \ is called Timestamp Renewal.\n   Archive Timestamp Sequence: Part of the Evidence\
    \ Record, it is a\n   sequence of Archive Timestamp Chains, where each Archive\
    \ Timestamp\n   Chain preserves non-repudiation of the previous Archive Timestamp\n\
    \   Chains, even after the hash algorithm used within the previous\n   Archive\
    \ Timestamp's hash tree became weak.  Non-repudiation is\n   preserved until the\
    \ last Archive Timestamp of the last chain becomes\n   invalid.  The process of\
    \ generating such an Archive Timestamp\n   Sequence is called Hash-Tree Renewal.\n\
    \   Evidence: Information that may be used to resolve a dispute about\n   various\
    \ aspects of authenticity of archived data objects.\n   Evidence record: Collection\
    \ of evidence compiled for one or more\n   given archived data objects over time.\
    \  An evidence record includes\n   all Archive Timestamps (within structures of\
    \ Archive Timestamp Chains\n   and Archive Timestamp Sequences) and additional\
    \ verification data,\n   like certificates, revocation information, trust anchors,\
    \ policy\n   details, role information, etc.\n   Long-term Archive (LTA) Service:\
    \ A service responsible for preserving\n   data for long periods of time, including\
    \ generation and collection of\n   evidence, storage of archived data objects\
    \ and evidence, etc.\n   Reduced hash tree: The process of reducing a Merkle hash\
    \ tree\n   [MER1980] to a list of lists of hash values.  This is the basis of\n\
    \   storing the evidence for a single data object.\n   Timestamp: A cryptographically\
    \ secure confirmation generated by a\n   Time Stamping Authority (TSA).  [RFC3161]\
    \ specifies a structure for\n   timestamps and a protocol for communicating with\
    \ a TSA.  Besides\n   this, other data structures and protocols may also be appropriate,\n\
    \   e.g., such as defined in [ISO-18014-1.2002], [ISO-18014-2.2002],\n   [ISO-18014-3.2004],\
    \ and [ANSI.X9-95.2005].\n   An Archive Timestamp relates to a data object, if\
    \ the hash value of\n   this data object is part of the first hash value list\
    \ of the Archive\n   Timestamp.  An Archive Timestamp relates to a data object\
    \ group, if\n   it relates to every data object of the group and no other data\n\
    \   objects.  An Archive Timestamp Chain relates to a data object / data\n   object\
    \ group, if its first Archive Timestamp relates to this data\n   object/data object\
    \ group.  An Archive Timestamp Sequence relates to a\n   data object / data object\
    \ group, if its first Archive Timestamp Chain\n   relates to this data object/data\
    \ object group.\n"
- title: 1.4.  Conventions Used in This Document
  contents:
  - "1.4.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  Identification and References
  contents:
  - '2.  Identification and References

    '
- title: 2.1.  ASN.1 Module Definition
  contents:
  - "2.1.  ASN.1 Module Definition\n   As many open ASN.1 compilers still support\
    \ the 1988 syntax, this\n   standard offers to support two versions of ASN.1 1997-ASN.1\
    \ and 1988-\n   ASN.1.  (For specification of ASN.1 refer to [CCITT.X208.1988],\n\
    \   [CCITT.X209.1988], [CCITT.X680.2002] and [CCITT.X690.2002].)  This\n   specification\
    \ defines the two ASN.1 modules, one for 1988 conform\n   ASN.1 and another in\
    \ 1997-ASN.1 syntax.  Depending on the syntax\n   version of your compiler implementation,\
    \ you can use the imports for\n   the 1988 conformant ASN.1 syntax or the imports\
    \ for the 1997-ASN.1\n   syntax.  The appendix of this document lists the two\
    \ complete\n   alternative ASN.1 modules.  If there is a conflict between both\n\
    \   modules, the 1988-ASN.1 module precedes.\n"
- title: 2.1.1.  ASN.1 Module Definition for 1988 ASN.1 Syntax
  contents:
  - "2.1.1.  ASN.1 Module Definition for 1988 ASN.1 Syntax\n   1988 ASN.1 Module start\n\
    \   ERS {iso(1) identified-organization(3) dod(6)\n         internet(1) security(5)\
    \ mechanisms(5)\n         ltans(11) id-mod(0) id-mod-ers88(2) id-mod-ers88-v1(1)\
    \ }\n   DEFINITIONS IMPLICIT TAGS ::=\n   BEGIN\n"
- title: 2.1.2.  ASN.1 Module Definition for 1997-ASN.1 Syntax
  contents:
  - "2.1.2.  ASN.1 Module Definition for 1997-ASN.1 Syntax\n   ASN.1 Module start\n\
    \   ERS {iso(1) identified-organization(3) dod(6)\n         internet(1) security(5)\
    \ mechanisms(5)\n         ltans(11) id-mod(0) id-mod-ers(1) id-mod-ers-v1(1) }\n\
    \   DEFINITIONS IMPLICIT TAGS ::=\n   BEGIN\n"
- title: 2.2.  ASN.1 Imports and Exports
  contents:
  - "2.2.  ASN.1 Imports and Exports\n   The specification exports all definitions\
    \ and imports various\n   definitions.  Depending on the ASN.1 syntax version\
    \ of your\n   implementation, you can use the imports for the 1988 conform ASN.1\n\
    \   syntax below or the imports for the 1997-ASN.1 syntax in\n   Section 2.2.2.\n"
- title: 2.2.1.  Imports and Exports Conform with 1988 ASN.1
  contents:
  - "2.2.1.  Imports and Exports Conform with 1988 ASN.1\n   -- EXPORTS ALL --\n \
    \  IMPORTS\n    -- Imports from RFC 3852 Cryptographic Message Syntax\n   ContentInfo,\
    \ Attribute\n       FROM CryptographicMessageSyntax2004 -- FROM [RFC3852]\n  \
    \      { iso(1) member-body(2) us(840) rsadsi(113549)\n          pkcs(1) pkcs-9(9)\
    \ smime(16) modules(0) cms-2004(24) }\n     -- Imports from RFC 3280 [RFC3280],\
    \ Appendix A.1\n   AlgorithmIdentifier\n       FROM PKIX1Explicit88\n        \
    \   { iso(1) identified-organization(3) dod(6)\n           internet(1) security(5)\
    \ mechanisms(5) pkix(7)\n           mod(0) pkix1-explicit(18) }\n   ;\n"
- title: 2.2.2.  Imports and Exports Conform with 1997-ASN.1
  contents:
  - "2.2.2.  Imports and Exports Conform with 1997-ASN.1\n   -- EXPORTS ALL --\n \
    \  IMPORTS\n    -- Imports from PKCS-7\n   ContentInfo\n       FROM PKCS7\n  \
    \         {iso(1) member-body(2) us(840) rsadsi(113549)\n           pkcs(1) pkcs-7(7)\
    \ modules(0)}\n     -- Imports from AuthenticationFramework\n   AlgorithmIdentifier\n\
    \       FROM AuthenticationFramework\n           {joint-iso-itu-t ds(5) module(1)\n\
    \           authenticationFramework(7) 4}\n    -- Imports from InformationFramework\n\
    \   Attribute\n       FROM InformationFramework\n           {joint-iso-itu-t ds(5)\
    \ module(1)\n           informationFramework(1) 4}\n   ;\n"
- title: 2.3.  LTANS Identification
  contents:
  - "2.3.  LTANS Identification\n   This document defines the LTANS object identifier\
    \ tree root.\n   LTANS Object Identifier tree root\n   ltans OBJECT IDENTIFIER\
    \ ::=\n            { iso(1) identified-organization(3) dod(6) internet(1)\n  \
    \            security(5) mechanisms(5) ltans(11) }\n"
- title: 3.  Evidence Record
  contents:
  - "3.  Evidence Record\n   An Evidence Record is a unit of data, which can be used\
    \ to prove the\n   existence of an archived data object or an archived data object\
    \ group\n   at a certain time.  The Evidence Record contains Archive Timestamps,\n\
    \   generated during a long archival period and possibly useful data for\n   validation.\
    \  It is possible to store this Evidence Record separately\n   from the archived\
    \ data objects or to integrate it into the data\n   itself.  For data types, signed\
    \ data and enveloped data of the CMS\n   integration are specified in Appendix\
    \ A.\n"
- title: 3.1.  Syntax
  contents:
  - "3.1.  Syntax\n   Evidence Record has the following ASN.1 Syntax:\n   ASN.1 Evidence\
    \ Record\n   EvidenceRecord ::= SEQUENCE {\n      version                   INTEGER\
    \ { v1(1) } ,\n      digestAlgorithms          SEQUENCE OF AlgorithmIdentifier,\n\
    \      cryptoInfos               [0] CryptoInfos OPTIONAL,\n      encryptionInfo\
    \            [1] EncryptionInfo OPTIONAL,\n      archiveTimeStampSequence  ArchiveTimeStampSequence\n\
    \      }\n   CryptoInfos ::= SEQUENCE SIZE (1..MAX) OF Attribute\n   The fields\
    \ have the following meanings:\n   The 'version' field indicates the syntax version,\
    \ for compatibility\n   with future revisions of this specification and to distinguish\
    \ it\n   from earlier non-conformant or proprietary versions of the ERS.  The\n\
    \   value 1 indicates this specification.  Lower values indicate an\n   earlier\
    \ version of the ERS has been used.  An implementation\n   conforming to this\
    \ specification SHOULD reject a version value below\n   1.\n   digestAlgorithms\
    \ is a sequence of all the hash algorithms used to\n   hash the data object over\
    \ the archival period.  It is the union of\n   all digestAlgorithm values from\
    \ the ArchiveTimestamps contained in\n   the EvidenceRecord.  The ordering of\
    \ the values is not relevant.\n   cryptoInfos allows the storage of data useful\
    \ in the validation of\n   the archiveTimeStampSequence.  This could include possible\
    \ Trust\n   Anchors, certificates, revocation information, or the current\n  \
    \ definition of the suitability of cryptographic algorithms, past and\n   present\
    \ (e.g., RSA 768-bit valid until 1998, RSA 1024-bit valid until\n   2008, SHA1\
    \ valid until 2010).  These items may be added based on the\n   policy used. \
    \ Since this data is not protected within any timestamp,\n   the data should be\
    \ verifiable through other mechanisms.  Such\n   verification is out of scope\
    \ of this document.\n   encryptionInfo contains the necessary information to support\n\
    \   encrypted content to be handled.  For discussion of syntax, please\n   refer\
    \ to Section 6.1.\n   ArchiveTimeStampSequence is a sequence of ArchiveTimeStampChain,\n\
    \   described in Section 5.\n   If the archive data objects were encrypted before\
    \ generating Archive\n   Timestamps but a non-repudiation proof is needed for\
    \ unencrypted data\n   objects, the optional encryptionInfos field contains data\
    \ necessary\n   to unambiguously re-encrypt data objects.  If omitted, it means\
    \ that\n   data objects are not encrypted or that a non-repudiation proof for\n\
    \   the unencrypted data is not required.  For further details, see\n   Section\
    \ 6.\n"
- title: 3.2.  Generation
  contents:
  - "3.2.  Generation\n   The generation of an EvidenceRecord can be described as\
    \ follows:\n   1.  Select a data object or group of data objects to archive.\n\
    \   2.  Create the initial Archive Timestamp (see Section 4, \"Archive\n     \
    \  Timestamp\").\n   3.  Refresh the Archive Timestamp when necessary, by Timestamp\n\
    \       Renewal or Hash-Tree Renewal (see Section 5).\n   The process of generation\
    \ depends on whether the Archive Timestamps\n   are generated, stored, and managed\
    \ by a centralized instance.  In the\n   case of central management, it is possible\
    \ to collect many data\n   objects, build hash trees, store them, and reduce them\
    \ later.  In\n   case of local generation, it might be easier to generate a simple\n\
    \   Archive Timestamp without building hash trees.  This can be\n   accomplished\
    \ by omitting the reducedHashtree field from the\n   ArchiveTimestamp.  In this\
    \ case, the ArchiveTimestamp covers a single\n   data object.  Using this approach,\
    \ it is possible to \"convert\"\n   existing timestamps into ArchiveTimestamps\
    \ for renewal.\n"
- title: 3.3.  Verification
  contents:
  - "3.3.  Verification\n   The Verification of an EvidenceRecord overall can be described\
    \ as\n   follows:\n   1.  Select an archived data object or group of data objects\n\
    \   2.  Re-encrypt data object/data object group, if encryption field is\n   \
    \    used (for details, see Section 6).\n   3.  Verify Archive Timestamp Sequence\
    \ (details in Section 4 and\n       Section 5).\n"
- title: 4.  Archive Timestamp
  contents:
  - "4.  Archive Timestamp\n   An Archive Timestamp is a timestamp and a set of lists\
    \ of hash\n   values.  The lists of hash values are generated by reduction of\
    \ an\n   ordered Merkle hash tree [MER1980].  The leaves of this hash tree are\n\
    \   the hash values of the data objects to be timestamped.  Every inner\n   node\
    \ of the tree contains one hash value, which is generated by\n   hashing the concatenation\
    \ of the children nodes.  The root hash\n   value, which represents unambiguously\
    \ all data objects, is\n   timestamped.\n"
- title: 4.1.  Syntax
  contents:
  - "4.1.  Syntax\n   An Archive Timestamp has the following ASN.1 Syntax:\n   ASN.1\
    \ Archive Timestamp\n   ArchiveTimeStamp ::= SEQUENCE {\n     digestAlgorithm\
    \ [0] AlgorithmIdentifier OPTIONAL,\n     attributes      [1] Attributes OPTIONAL,\n\
    \     reducedHashtree [2] SEQUENCE OF PartialHashtree OPTIONAL,\n     timeStamp\
    \       ContentInfo}\n   PartialHashtree ::= SEQUENCE OF OCTET STRING\n   Attributes\
    \ ::= SET SIZE (1..MAX) OF Attribute\n   The fields of type ArchiveTimeStamp have\
    \ the following meanings:\n   digestAlgorithm identifies the digest algorithm\
    \ and any associated\n   parameters used within the reduced hash tree.  If the\
    \ optional field\n   digestAlgorithm is not present, the digest algorithm of the\
    \ timestamp\n   MUST be used.  Which means, if timestamps according to [RFC3161]\
    \ are\n   used in this case, the content of this field is identical to\n   hashAlgorithm\
    \ of messageImprint field of TSTInfo.\n   attributes contains information an LTA\
    \ might want to provide to\n   document individual renewal steps and the creation\
    \ of the individual\n   ArchiveTimeStamps, e.g., applied policies.  As the structure\
    \ of the\n   ArchiveTimeStamp may be protected by hash and timestamps, the\n \
    \  ordering is relevant, which is why a SET is used instead of a\n   SEQUENCE.\n\
    \   reducedHashtree contains lists of hash values, organized in\n   PartialHashtrees\
    \ for easier understanding.  They can be derived by\n   reducing a hash tree to\
    \ the nodes necessary to verify a single data\n   object.  Hash values are represented\
    \ as octet strings.  If the\n   optional field reducedHashtree is not present,\
    \ the ArchiveTimestamp\n   simply contains an ordinary timestamp.\n   timeStamp\
    \ should contain the timestamp as defined in Section 1.3.\n   (e.g., as defined\
    \ with TimeStampToken in [RFC3161]).  Other types of\n   timestamp MAY be used,\
    \ if they contain time data, timestamped data,\n   and a cryptographically secure\
    \ confirmation from the TSA of these\n   data.\n"
- title: 4.2.  Generation
  contents:
  - "4.2.  Generation\n   The lists of hash values of an Archive Timestamp can be\
    \ generated by\n   building and reducing a Merkle hash tree [MER1980].\n   Such\
    \ a hash tree can be built as follows:\n   1.  Collect data objects to be timestamped.\n\
    \   2.  Choose a secure hash algorithm H and generate hash values for the\n  \
    \     data objects.  These values will be the leaves of the hash tree.\n   3.\
    \  For each data group containing more than one document, its\n       respective\
    \ document hashes are binary sorted in ascending order,\n       concatenated,\
    \ and hashed.  The hash values are the complete\n       output from the hash algorithm,\
    \ i.e., leading zeros are not\n       removed, with the most significant bit first.\n\
    \   4.  If there is more than one hash value, place them in groups and\n     \
    \  sort each group in binary ascending order.  Concatenate these\n       values\
    \ and generate new hash values, which are inner nodes of\n       this tree.  (If\
    \ additional hash values are needed, e.g., so that\n       all nodes have the\
    \ same number of children, any data may be\n       hashed using H and used.) \
    \ Repeat this step until there is only\n       one hash value, which is the root\
    \ node of the hash tree.\n   5.  Obtain a timestamp for this root hash value.\
    \  The hash algorithm\n       in the timestamp request MUST be the same as the\
    \ hash algorithm\n       of the hash tree, or the digestAlgorithm field of the\n\
    \       ArchiveTimeStamp MUST be present and specify the hash algorithm\n    \
    \   of the hash tree.\n   An example of a constructed hash tree for 3 data groups,\
    \ where data\n   groups 1 and 3 only contain one document, and data group 2 contains\
    \ 3\n   documents:\n                 +------+\n                 | h123 |\n   \
    \              +------+\n               /         \\\n              /        \
    \   \\\n           +----+      +----+\n           | h12|      | h3 |\n       \
    \    +----+      +----+\n           /     \\\n          /       \\\n       +----+\
    \  +-------+\n       | h1 |  | h2abc |\n       +----+  +-------+\n           \
    \    /   |   \\\n              /    |    \\\n             /     |     \\\n   \
    \         /      |      \\\n        +----+  +----+  +----+\n        | h2a|  |\
    \ h2b|  | h2c|\n        +----+  +----+  +----+\n   Figure 1: Hash tree\n     h1\
    \ = H(d1) where d1 is the only data object in data group 1\n     h3 = H(d3) where\
    \ d3 is the only data object in data group 3\n     h12 = H( binary sorted and\
    \ concatenated (h1, h2abc))\n     h123 = H( binary sorted and concatenated (h12,\
    \ h3))\n     h2a = H(first data object of data object group 2)\n     h2b = H(second\
    \ data object of data object group 2)\n     h2c = H(third data object of data\
    \ object group 2)\n     h2abc = H( binary sorted and concatenated (h2a, h2b, h2c))\n\
    \   The hash tree can be reduced to lists of hash values, necessary to\n   have\
    \ a proof of existence for a single data object:\n   1.  Generate hash value h\
    \ of the data object, using hash algorithm H\n       of the hash tree.\n   2.\
    \  Select all hash values, which have the same father node as h.\n       Generate\
    \ the first list of hash values by arranging these hashes,\n       in binary ascending\
    \ order.  This will be stored in the structure\n       of the PartialHashtree.\
    \  Repeat this step for the father node of\n       all hashes until the root hash\
    \ is reached.  The father nodes\n       themselves are not saved in the hash lists\
    \ -- they are\n       computable.\n   3.  The list of all partialHashtrees finally\
    \ is the reducedHashtree.\n       (All of the specified hash values under the\
    \ same father node,\n       except the father node of the nodes below, are grouped\
    \ in a\n       PartialHashtree.  The sequence list of all Partialhashtrees is\n\
    \       the reducedHashtree.)\n   4.  Finally, add the timestamp and the info\
    \ about the hash algorithm\n       to get an Archive Timestamp.\n   Assuming that\
    \ the sorted binary ordering of the hashes in Figure 1\n   is: h2abc < h1, then\
    \ the reduced hash tree for data group 1 (d1) is:\n       +--------------------------------+\n\
    \       | +-----------------+ +--------+ |\n       | | +------+ +----+ | | +----+\
    \ | |\n       | | | h2abc| | h1 | | | | h3 | | |\n       | | +------+ +----+ |\
    \ | +----+ | |\n       | +-----------------+ +--------+ |\n       +--------------------------------+\n\
    \   Figure 2: Reduced hash tree for data group 1\n      The pseudo ASN1 for this\
    \ reduced hash tree rht1 would look like:\n        rht1 = SEQ(pht1, pht2)\n  \
    \    with the PartialHashtrees pht1 and pht2\n        pht1 = SEQ (h2abc, h1)\n\
    \        pht2 = SEQ (h3)\n   Assuming the same hash tree as in Figure 1, the reduced\
    \ hash tree for\n   all data objects in data group 2 is identical.\n    +-------------------------------------------------+\n\
    \    | +----------------------+  +--------+ +--------+ |\n    | | +----+ +----+\
    \ +----+ |  | +----+ | | +----+ | |\n    | | | h2b| | h2c| | h2a| |  | | h1 |\
    \ | | | h3 | | |\n    | | +----+ +----+ +----+ |  | +----+ | | +----+ | |\n  \
    \  | +----------------------+  +--------+ +--------+ |\n    +-------------------------------------------------+\n\
    \   Figure 3: Reduced hash tree for data object group 2\n      The pseudo ASN1\
    \ for this reduced hash tree would look like:\n        rht2 = SEQ(pht3, pht4,\
    \ pht5)\n      with the PartialHashtrees pht3, pht4, and pht5\n       pht3 = SEQ\
    \ (h2b, h2c, h2a)\n       pht4 = SEQ (h1)\n       pht5 = SEQ (h3)\n   Note there\
    \ are no restrictions on the quantity or length of hash-\n   value lists.  Also\
    \ note that it is profitable but not required to\n   build hash trees and reduce\
    \ them.  An Archive Timestamp may consist\n   only of one list of hash-values\
    \ and a timestamp or only a timestamp\n   with no hash value lists.\n   The data\
    \ (e.g. certificates, Certificate Revocation Lists (CRLs), or\n   Online Certificate\
    \ Status Protocol (OCSP) responses) needed to verify\n   the timestamp MUST be\
    \ preserved, and SHOULD be stored in the\n   timestamp itself unless this causes\
    \ unnecessary duplication.  A\n   timestamp according to [RFC3161] is a CMS object\
    \ in which\n   certificates can be stored in the certificates field and CRLs can\
    \ be\n   stored in the crls field of signed data.  OCSP responses can be\n   stored\
    \ as unsigned attributes [RFC3126].  Note [ANSI.X9-95.2005],\n   [ISO-18014-2.2002],\
    \ and [ISO-18014-3.2004], which specify verifiable\n   timestamps that do not\
    \ depend on certificates, CRLs, or OCSP\n   responses.\n"
- title: 4.3.  Verification
  contents:
  - "4.3.  Verification\n   An Archive Timestamp shall prove that a data object existed\
    \ at a\n   certain time, given by timestamp.  This can be verified as follows:\n\
    \   1.  Calculate hash value h of the data object with hash algorithm H\n    \
    \   given in field digestAlgorithm of the Archive Timestamp.\n   2.  Search for\
    \ hash value h in the first list (partialHashtree) of\n       reducedHashtree.\
    \  If not present, terminate verification process\n       with negative result.\n\
    \   3.  Concatenate the hash values of the actual list (partialHashtree)\n   \
    \    of hash values in binary ascending order and calculate the hash\n       value\
    \ h' with algorithm H.  This hash value h' MUST become a\n       member of the\
    \ next higher list of hash values (from the next\n       partialHashtree).  Continue\
    \ step 3 until a root hash value is\n       calculated.\n   4.  Check timestamp.\
    \  In case of a timestamp according to [RFC3161],\n       the root hash value\
    \ must correspond to hashedMessage, and\n       digestAlgorithm must correspond\
    \ to hashAlgorithm field, both in\n       messageImprint field of timeStampToken.\
    \  In case of other\n       timestamp formats, the hash value and digestAlgorithm\
    \ must also\n       correspond to their equivalent fields if they exist.\n   If\
    \ a proof is necessary for more than one data object, steps 1 and 2\n   have to\
    \ be done for all data objects to be proved.  If an additional\n   proof is necessary\
    \ that the Archive Timestamp relates to a data\n   object group (e.g., a document\
    \ and all its signatures), it can be\n   verified additionally, that only the\
    \ hash values of the given data\n   objects are in the first hash-value list.\n"
- title: 5.  Archive Timestamp Chain and Archive Timestamp Sequence
  contents:
  - "5.  Archive Timestamp Chain and Archive Timestamp Sequence\n   An Archive Timestamp\
    \ proves the existence of single data objects or\n   data object group at a certain\
    \ time.  However, this first Archive\n   Timestamp in the first ArchiveTimeStampChain\
    \ can become invalid, if\n   hash algorithms or public key algorithms used in\
    \ its hash tree or\n   timestamp become weak or if the validity period of the\
    \ timestamp\n   authority certificate expires or is revoked.\n   Prior to such\
    \ an event, the existence of the Archive Timestamp or\n   archive timestamped\
    \ data has to be reassured.  This can be done by\n   creating a new Archive Timestamp.\
    \  Depending on whether the timestamp\n   becomes invalid or the hash algorithm\
    \ of the hash tree becomes weak,\n   two kinds of Archive Timestamp renewal are\
    \ possible:\n   o  Timestamp Renewal: A new Archive Timestamp is generated, which\n\
    \      covers the timestamp of the old one.  One or more Archive\n      Timestamps\
    \ generated by Timestamp Renewal yield an Archive\n      Timestamp Chain for a\
    \ data object or data object group.\n   o  Hash-Tree Renewal: A new Archive Timestamp\
    \ is generated, which\n      covers all the old Archive Timestamps as well as\
    \ the data objects.\n      A new Archive Timestamp Chain is started.  One or more\
    \ Archive\n      Timestamp Chains for a data object or data object group yield\
    \ an\n      Archive Timestamp Sequence.\n   After the renewal, always only the\
    \ last (i.e., most recent)\n   ArchiveTimeStamp and the algorithms and timestamps\
    \ used by it must be\n   watched regarding expiration and loss of security.\n"
- title: 5.1.  Syntax
  contents:
  - "5.1.  Syntax\n   ArchiveTimeStampChain and ArchiveTimeStampSequence have the\
    \ following\n   ASN.1 Syntax:\n   ASN.1 ArchiveTimeStampChain and ArchiveTimeStampSequence\n\
    \   ArchiveTimeStampChain    ::= SEQUENCE OF ArchiveTimeStamp\n   ArchiveTimeStampSequence\
    \ ::= SEQUENCE OF\n                                ArchiveTimeStampChain\n   ArchiveTimeStampChain\
    \ and ArchiveTimeStampSequence MUST be ordered\n   ascending by time of timestamp.\
    \  Within an ArchiveTimeStampChain, all\n   reducedHashtrees of the contained\
    \ ArchiveTimeStamps MUST use the same\n   Hash-Algorithm.\n"
- title: 5.2.  Generation
  contents:
  - "5.2.  Generation\n   The initial Archive Timestamp relates to a data object or\
    \ a data\n   object group.  Before cryptographic algorithms that are used within\n\
    \   the most recent Archive Timestamp (which is, at the beginning, the\n   initial\
    \ one) become weak or their timestamp certificates become\n   invalid, Archive\
    \ Timestamps have to be renewed by generating a new\n   Archive Timestamp.\n \
    \  In the case of Timestamp Renewal, the content of the timeStamp field\n   of\
    \ the old Archive Timestamp has to be hashed and timestamped by a\n   new Archive\
    \ Timestamp.  The new Archive Timestamp MAY not contain a\n   reducedHashtree\
    \ field, if the timestamp only simply covers the\n   previous timestamp.  However,\
    \ generally one can collect a number of\n   old Archive Timestamps and build the\
    \ new hash tree with the hash\n   values of the content of their timeStamp fields.\n\
    \   The new Archive Timestamp MUST be added to the ArchiveTimestampChain.\n  \
    \ This hash tree of the new Archive Timestamp MUST use the same hash\n   algorithm\
    \ as the old one, which is specified in the digestAlgorithm\n   field of the Archive\
    \ Timestamp or, if this value is not set (as it is\n   optional), within the timestamp\
    \ itself.\n   In the case of Hash-Tree Renewal, the Archive Timestamp and the\n\
    \   archived data objects covered by the Archive Timestamp must be hashed\n  \
    \ and timestamped again, as described below:\n   1.  Select a secure hash algorithm\
    \ H.\n   2.  Select data objects d(i) referred to by initial Archive Timestamp\n\
    \       (objects that are still present and not deleted).  Generate hash\n   \
    \    values h(i) = H((d(i)).  If data groups with more than one\n       document\
    \ are present, then one will have more than one hash for a\n       group, i.e.,\
    \ h(i_a), h(i_b).., h(i_n)\n   3.  atsc(i) is the encoded ArchiveTimeStampSequence,\
    \ the\n       concatenation of all previous Archive Timestamp Chains (in\n   \
    \    chronological order) related to data object d(i).  Generate hash\n      \
    \ value ha(i) = H(atsc(i)).\n       Note: The ArchiveTimeStampChains used are\
    \ DER encoded, i.e., they\n       contain sequence and length tags.\n   4.  Concatenate\
    \ each h(i) with ha(i) and generate hash values\n       h(i)' = H (h(i)+ ha(i)).\
    \  For multi-document groups, this is:\n       h(i_a)' = H (h(i_a)+ ha(i))\n \
    \      h(i_b)' = H (h(i_b)+ ha(i)), etc.\n   5.  Build a new Archive Time Stamp\
    \ for each h(i)'.  (Hash-tree\n       generation and reduction is defined in Section\
    \ 4.2; note that\n       each h(i)' will be treated in Section 4.2 as the document\
    \ hash.\n       The first hash value list in the reduced hash tree should only\n\
    \       contain h(i)'.  For a multi-document group, the first hash value\n   \
    \    list will contain the new hashes for all the documents in this\n       group,\
    \ i.e., h(i_a)', h(i_b)'.., h(i_n)')\n   6.  Create new ArchiveTimeStampChain\
    \ containing the new Archive\n       Timestamp and append this ArchiveTimeStampChain\
    \ to the\n       ArchiveTimeStampSequence.\n                 +-------+\n     \
    \            | h123' |\n                 +-------+\n               /         \\\
    \n              /           \\\n           +-----+      +----+\n           | h12'|\
    \      | h3'|\n           +-----+      +----+\n           /     \\\n         \
    \ /       \\\n       +----+  +--------+\n       | h1'|  | h2abc' |\n       +----+\
    \  +--------+\n               /   |   \\\n              /    |    \\\n       \
    \      /     |     \\\n            /      |      \\\n        +----+  +----+  +----+\n\
    \        |h2a'|  |h2b'|  |h2c'|\n        +----+  +----+  +----+\n   Figure 4:\
    \ Hash tree from Hash-Tree Renewal\n     Let H be the new secure hash algorithm\n\
    \     ha(1), ha(2), ha(3) are as defined in step 4 above\n     h1' = H( binary\
    \ sorted and concatenated (H(d1), ha(1)))\n       d1 is the original document\
    \ from data group 1\n     h3' = H( binary sorted and concatenated (H(d3), ha(3)))\n\
    \       d3 is the original document from data group 3\n     h2a = H(first data\
    \ object of data object group 2)\n      ...\n     h2c = H(third data object of\
    \ data object group 2)\n     h2a' = H( binary sorted and concatenated (h2a, ha(2)))\n\
    \      ...\n     h2c' = H( binary sorted and concatenated (h2c, ha(2)))\n    \
    \ h2abc = H( binary sorted and concatenated (h2a', h2b', h2c'))\n   ArchiveTimeStamps\
    \ that are not necessary for verification should not\n   be added to an ArchiveTimeStampChain\
    \ or ArchiveTimeStampSequence.\n"
- title: 5.3.  Verification
  contents:
  - "5.3.  Verification\n   To get a non-repudiation proof that a data object existed\
    \ at a\n   certain time, the Archive Timestamp Chains and their relations to\n\
    \   each other and to the data objects have to be proved:\n   1.  Verify that\
    \ the first Archive Timestamp of the first\n       ArchiveTimestampChain (the\
    \ initial Archive Timestamp) contains\n       the hash value of the data object.\n\
    \   2.  Verify each ArchiveTimestampChain.  The first hash value list of\n   \
    \    each ArchiveTimeStamp MUST contain the hash value of the\n       timestamp\
    \ of the Archive Timestamp before.  Each Archive\n       Timestamp MUST be valid\
    \ relative to the time of the following\n       Archive Timestamp.  All Archive\
    \ Timestamps within a chain MUST\n       use the same hash algorithm and this\
    \ algorithm MUST be secure at\n       the time of the first Archive Timestamp\
    \ of the following\n       ArchiveTimeStampChain.\n   3.  Verify that the first\
    \ hash value list (partialHashtree) of the\n       first Archive Timestamp of\
    \ all other ArchiveTimeStampChains\n       contains a hash value of the concatenation\
    \ of the data object\n       hash and the hash value of all older ArchiveTimeStampChain.\n\
    \       Verify that this Archive Timestamp was generated before the last\n   \
    \    Archive Timestamp of the ArchiveTimeStampChain became invalid.\n   In order\
    \ to complete the non-repudiation proof for the data objects,\n   the last Archive\
    \ Timestamp has to be valid at the time the\n   verification is performed.\n \
    \  If the proof is necessary for more than one data object, steps 1 and\n   3\
    \ have to be done for all these data objects.  To prove the Archive\n   Timestamp\
    \ Sequence relates to a data object group, verify that each\n   first Archive\
    \ Timestamp of the first ArchiveTimeStampChain of the\n   ArchiveTimeStampSequence\
    \ of each data object does not contain other\n   hash values in its first hash\
    \ value list (than the hash values of the\n   other data objects).\n"
- title: 6.  Encryption
  contents:
  - "6.  Encryption\n   If service providers are used to archive data and generate\
    \ Archive\n   Timestamps, it might be desirable or required that clients only\
    \ send\n   encrypted data to be archived.  However, this means that evidence\n\
    \   records refer to encrypted data objects.  ERS directly protects the\n   integrity\
    \ of the bit-stream and this freezes the bit structure at the\n   time of archiving.\
    \  This precludes changing of the encryption scheme\n   during the archival period,\
    \ e.g., if the encryption scheme is no\n   longer secure, a change is not possible\
    \ without losing the integrity\n   proof of the EvidenceRecord.  In such cases,\
    \ the services of a data\n   transformation (and by this also possible re-encryption)\
    \ done by a\n   notary service might be a possible solution.  To avoid problems\
    \ when\n   using the evidence records in the future, additional special\n   precautions\
    \ have to be taken:\n   o  Evidence generated to prove the existence of encrypted\
    \ data cannot\n      always be relied upon to prove the existence of unencrypted\
    \ data.\n      It may be possible to choose an algorithm or a key for decryption\n\
    \      that is not the algorithm or key used for encryption.  In this\n      case,\
    \ the evidence record would not be a non-repudiation proof for\n      the unencrypted\
    \ data.  Therefore, only encryption methods should\n      be used that make it\
    \ possible to prove that archive-timestamped\n      encrypted data objects unambiguously\
    \ represent unencrypted data\n      objects.  All data necessary to prove unambiguous\
    \ representation\n      should be included in the archived data objects.  (Note:\
    \ In\n      addition, the long-term security of the encryption schemes should\n\
    \      be analyzed to determine if it could be used to create collision\n    \
    \  attacks.)\n   o  When a relying party uses an evidence record to prove the\n\
    \      existence of encrypted data objects, it may be desirable for\n      clients\
    \ to only store the unencrypted data objects and to delete\n      the encrypted\
    \ copy.  In order to use the evidence record, it must\n      then be possible\
    \ to unambiguously re-encrypt the unencrypted data\n      to get exactly the data\
    \ that was originally archived.  Therefore,\n      additional data necessary to\
    \ re-encrypt data objects should be\n      inserted into the evidence record by\
    \ the client, i.e., the LTA\n      never sees these values.\n   An extensible\
    \ structure is defined to store the necessary parameters\n   of the encryption\
    \ methods.  The use of the specified\n   encryptionInfoType and encryptionInfoValue\
    \ may be heavily dependent\n   on the mechanisms and has to be defined in other\
    \ specifications.\n"
- title: 6.1.  Syntax
  contents:
  - "6.1.  Syntax\n   The EncryptionInfo field in EvidenceRecord has the following\
    \ syntax\n   depending on the version of ASN.1.\n"
- title: 6.1.1.  EncryptionInfo in 1988 ASN.1
  contents:
  - "6.1.1.  EncryptionInfo in 1988 ASN.1\n   1988 ASN.1 EncryptionInfo\n   EncryptionInfo\
    \       ::=     SEQUENCE {\n       encryptionInfoType     OBJECT IDENTIFIER,\n\
    \       encryptionInfoValue    ANY DEFINED BY encryptionInfoType\n   }\n"
- title: 6.1.2.  EncryptionInfo in 1997-ASN.1
  contents:
  - "6.1.2.  EncryptionInfo in 1997-ASN.1\n   1997-ASN.1 EncryptionInfo\n   EncryptionInfo\
    \       ::=     SEQUENCE {\n       encryptionInfoType   ENCINFO-TYPE.&id\n   \
    \                                   ({SupportedEncryptionAlgorithms}),\n     \
    \  encryptionInfoValue  ENCINFO-TYPE.&Type\n                  ({SupportedEncryptionAlgorithms}{@encryptionInfoType})\n\
    \   }\n   ENCINFO-TYPE ::= TYPE-IDENTIFIER\n   SupportedEncryptionAlgorithms ENCINFO-TYPE\
    \ ::= {...}\n   encryptionInfo contains information necessary for the unambiguous\n\
    \   re-encryption of unencrypted content so that it exactly matches with\n   the\
    \ encrypted data objects protected by the EvidenceRecord.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Secure Algorithms\n   Cryptographic algorithms\
    \ and parameters that are used within Archive\n   Timestamps must be secure at\
    \ the time of generation.  This concerns\n   the hash algorithm used in the hash\
    \ lists of Archive Timestamp as\n   well as hash algorithms and public key algorithms\
    \ of the timestamps.\n   Publications regarding security suitability of cryptographic\n\
    \   algorithms ([NIST.800-57-Part1.2006] and [ETSI-TS102176-1-2005]) have\n  \
    \ to be considered by verifying components.  A generic solution for\n   automatic\
    \ interpretation of security suitability policies in\n   electronic form is desirable\
    \ but not the subject of this\n   specification.\n   Redundancy\n   Retrospectively,\
    \ certain parts of an Archive Timestamp may turn out\n   to have lost their security\
    \ suitability before this has been publicly\n   known.  For example, retrospectively,\
    \ it may turn out that algorithms\n   have lost their security suitability, and\
    \ that even TSAs are\n   untrustworthy.  This can result in Archive Timestamps\
    \ using those\n   losing their probative force.  Many TSAs are using the same\
    \ signature\n   algorithms.  While the compromise of a private key will only affect\n\
    \   the security of one specific TSA, the retrospective loss of security\n   of\
    \ a signature algorithm will have impact on a potentially large\n   number of\
    \ TSAs at once.  To counter such risks, it is recommended to\n   generate and\
    \ manage at least two redundant Evidence Records with\n   ArchiveTimeStampSequences\
    \ using different hash algorithms and\n   different TSAs using different signature\
    \ algorithms.\n   To best achieve and manage this redundancy, it is recommended\
    \ to\n   manage the Archive Timestamps in a central LTA.\n   Secure Timestamps\n\
    \   Archive Timestamping depends upon the security of normal time\n   stamping.\
    \  Security requirements for Time Stamping Authorities stated\n   in security\
    \ policies have to be met.  Renewed Archive Timestamps\n   should have the same\
    \ or higher quality as the initial Archive\n   Timestamp.  Archive Timestamps\
    \ used for signature renewal of signed\n   data, should have the same or higher\
    \ quality than the maximum quality\n   of the signatures.\n   Secure Encryption\n\
    \   For non-repudiation proof, it does not matter whether encryption has\n   been\
    \ broken or not.  Nevertheless, users should keep secret their\n   private keys\
    \ and randoms used for encryption and disclose them only\n   if needed, e.g.,\
    \ in a lawsuit to a judge or expert.  They should use\n   encryption algorithms\
    \ and parameters that are prospected to be\n   unbreakable as long as confidentiality\
    \ of the archived data is\n   important.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [CCITT.X208.1988]\n              International\
    \ Telephone and Telegraph Consultative\n              Committee, \"Specification\
    \ of Abstract Syntax Notation One\n              (ASN.1)\", CCITT Recommendation\
    \ X.208, November 1988.\n   [CCITT.X209.1988]\n              International Telephone\
    \ and Telegraph Consultative\n              Committee, \"Specification of Basic\
    \ Encoding Rules for\n              Abstract Syntax Notation One (ASN.1)\",\n\
    \              CCITT Recommendation X.209, 1988.\n   [RFC2119]  Bradner, S., \"\
    Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP\
    \ 14, RFC 2119, March 1997.\n   [RFC3161]  Adams, C., Cain, P., Pinkas, D., and\
    \ R. Zuccherato,\n              \"Internet X.509 Public Key Infrastructure Time-Stamp\n\
    \              Protocol (TSP)\", RFC 3161, August 2001.\n   [RFC3280]  Housley,\
    \ R., Polk, W., Ford, W., and D. Solo, \"Internet\n              X.509 Public\
    \ Key Infrastructure Certificate and\n              Certificate Revocation List\
    \ (CRL) Profile\", RFC 3280,\n              April 2002.\n   [RFC3852]  Housley,\
    \ R., \"Cryptographic Message Syntax (CMS)\",\n              RFC 3852, July 2004.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [ANSI.X9-95.2005]\n              American National\
    \ Standard for Financial Services,\n              \"Trusted Timestamp Management\
    \ and Security\", ANSI X9.95,\n              June 2005.\n   [CCITT.X680.2002]\n\
    \              International Telephone and Telegraph Consultative\n          \
    \    Committee, \"Abstract Syntax Notation One (ASN.1):\n              Specification\
    \ of basic notation\", CCITT Recommendation\n              X.680, July 2002.\n\
    \   [CCITT.X690.2002]\n              International Telephone and Telegraph Consultative\n\
    \              Committee, \"ASN.1 encoding rules:  Specification of basic\n  \
    \            encoding Rules (BER), Canonical encoding rules (CER) and\n      \
    \        Distinguished encoding rules (DER)\", CCITT Recommendation\n        \
    \      X.690, July 2002.\n   [ETSI-TS102176-1-2005]\n              European Telecommunication\
    \ Standards Institute (ETSI),\n              Electronic Signatures and Infrastructures\
    \ (ESI);,\n              \"Algorithms and Parameters for Secure Electronic\n \
    \             Signatures; Part 1: Hash functions and asymmetric\n            \
    \  algorithms\", ETSI  TS 102 176-1 V1.2.1, July 2005.\n   [ISO-18014-1.2002]\n\
    \              ISO/IEC JTC 1/SC 27, \"Time stamping services - Part 1:\n     \
    \         Framework\", ISO ISO-18014-1, February 2002.\n   [ISO-18014-2.2002]\n\
    \              ISO/IEC JTC 1/SC 27, \"Time stamping services - Part 2:\n     \
    \         Mechanisms producing independent tokens\", ISO ISO-18014-2,\n      \
    \        December 2002.\n   [ISO-18014-3.2004]\n              ISO/IEC JTC 1/SC\
    \ 27, \"Time stamping services - Part 3:\n              Mechanisms producing linked\
    \ tokens\", ISO ISO-18014-3,\n              February 2004.\n   [MER1980]  Merkle,\
    \ R., \"Protocols for Public Key Cryptosystems,\n              Proceedings of\
    \ the 1980 IEEE Symposium on Security and\n              Privacy (Oakland, CA,\
    \ USA)\", pages 122-134, April 1980.\n   [NIST.800-57-Part1.2006]\n          \
    \    National Institute of Standards and Technology,\n              \"Recommendation\
    \ for Key Management - Part 1: General\n              (Revised)\", NIST 800-57\
    \ Part1, May 2006.\n   [RFC3126]  Pinkas, D., Ross, J., and N. Pope, \"Electronic\
    \ Signature\n              Formats for long term electronic signatures\", RFC\
    \ 3126,\n              September 2001.\n   [RFC4810]  Wallace, C., Pordesch, U.,\
    \ and R. Brandner, \"Long-Term\n              Archive Service Requirements\",\
    \ RFC 4810, March 2007.\n"
- title: Appendix A.  Evidence Record Using CMS
  contents:
  - "Appendix A.  Evidence Record Using CMS\n   An Evidence Record can be added to\
    \ signed data or enveloped data in\n   order to transfer them in a conclusive\
    \ way.  For CMS, a sensible\n   place to store such an Evidence Record is an unsigned\
    \ attribute\n   (signed message) or an unprotected attribute (enveloped message).\n\
    \   One advantage of storing the Evidence Record within the CMS structure\n  \
    \ is that all data can be transferred in one conclusive file and is\n   directly\
    \ connected.  The documents, the signatures, and their\n   Evidence Records can\
    \ be bundled and managed together.  The\n   description in the appendix contains\
    \ the normative specification of\n   how to integrate ERS in CMS structures.\n\
    \   The Evidence Record also contains information about the selection\n   method\
    \ that was used for the generation of the data objects to be\n   timestamped.\
    \  In the case of CMS, two selection methods can be\n   distinguished:\n   1.\
    \  The CMS Object as a whole including contentInfo is selected as\n       data\
    \ object and archive timestamped.  This means that a hash\n       value of the\
    \ CMS object MUST be located in the first list of hash\n       values of Archive\
    \ Timestamps.\n   2.  The CMS Object and the signed or encrypted content are included\n\
    \       in the Archive Timestamp as separated objects.  In this case, the\n  \
    \     hash value of the CMS Object as well as the hash value of the\n       content\
    \ have to be stored in the first list of hash values as a\n       group of data\
    \ objects.\n   However, other selection methods could also be applied, for instance,\n\
    \   as in [RFC3126].\n   In the case of the two selection methods defined above,\
    \ the Evidence\n   Record has to be added to the first signature of the CMS Object\
    \ of\n   signed data.  Depending on the selection method, the following Object\n\
    \   Identifiers are defined for the Evidence Record:\n   ASN.1 Internal EvidenceRecord\
    \ Attribute\n   id-aa-er-internal  OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n\
    \      us(840) rsadsi(113549) pkcs(1) pkcs9(9) smime(16) id-aa(2) 49 }\n   ASN.1\
    \ External EvidenceRecord Attribute\n   id-aa-er-external  OBJECT IDENTIFIER ::=\
    \ { iso(1) member-body(2)\n      us(840) rsadsi(113549) pkcs(1) pkcs9(9) smime(16)\
    \ id-aa(2) 50 }\n   The attributes SHOULD only occur once.  If they appear several\
    \ times,\n   they have to be stored within the first signature in chronological\n\
    \   order.\n   If the CMS object doesn't have the EvidenceRecord Attributes --\
    \ which\n   indicates that the EvidenceRecord has been provided externally --\
    \ the\n   archive timestamped data object has to be generated over the complete\n\
    \   CMS object within the existing coding.\n   In case of verification, if only\
    \ one EvidenceRecord is contained in\n   the CMS object, the hash value must be\
    \ generated over the CMS object\n   without the one EvidenceRecord.  This means\
    \ that the attribute has to\n   be removed before verification.  The length of\
    \ fields containing tags\n   has to be adapted.  Apart from that, the existing\
    \ coding must not be\n   modified.\n   If several Archive Timestamps occur, the\
    \ data object has to be\n   generated as follows:\n   o  During verification of\
    \ the first (in chronological order)\n      EvidenceRecord, all EvidenceRecord\
    \ have to be removed in order to\n      generate the data object.\n   o  During\
    \ verification of the nth one EvidenceRecord, the first n-1\n      attributes\
    \ should remain within the CMS object.\n   o  The verification of the nth one\
    \ EvidenceRecord must result in a\n      point of time when the document must\
    \ have existed with the first n\n      attributes.  The verification of the n+1th\
    \ attribute must prove\n      that this requirement has been met.\n"
- title: Appendix B.  ASN.1-Module with 1988 Syntax
  contents:
  - "Appendix B.  ASN.1-Module with 1988 Syntax\n   ASN.1-Module\n   ERS {iso(1) identified-organization(3)\
    \ dod(6)\n         internet(1) security(5) mechanisms(5)\n         ltans(11) id-mod(0)\
    \ id-mod-ers88(2) id-mod-ers88-v1(1) }\n   DEFINITIONS IMPLICIT TAGS ::=\n   BEGIN\n\
    \   -- EXPORTS ALL --\n   IMPORTS\n    -- Imports from RFC 3852 Cryptographic\
    \ Message Syntax\n   ContentInfo, Attribute\n       FROM CryptographicMessageSyntax2004\
    \ -- FROM [RFC3852]\n        { iso(1) member-body(2) us(840) rsadsi(113549)\n\
    \          pkcs(1) pkcs-9(9) smime(16) modules(0) cms-2004(24) }\n     -- Imports\
    \ from RFC 3280 [RFC3280], Appendix A.1\n   AlgorithmIdentifier\n       FROM PKIX1Explicit88\n\
    \           { iso(1) identified-organization(3) dod(6)\n           internet(1)\
    \ security(5) mechanisms(5) pkix(7)\n           mod(0) pkix1-explicit(18) }\n\
    \   ;\n   ltans OBJECT IDENTIFIER ::=\n            { iso(1) identified-organization(3)\
    \ dod(6) internet(1)\n              security(5) mechanisms(5) ltans(11) }\n  \
    \ EvidenceRecord ::= SEQUENCE {\n      version                   INTEGER { v1(1)\
    \ } ,\n      digestAlgorithms          SEQUENCE OF AlgorithmIdentifier,\n    \
    \  cryptoInfos               [0] CryptoInfos OPTIONAL,\n      encryptionInfo \
    \           [1] EncryptionInfo OPTIONAL,\n      archiveTimeStampSequence  ArchiveTimeStampSequence\n\
    \      }\n   CryptoInfos ::= SEQUENCE SIZE (1..MAX) OF Attribute\n   ArchiveTimeStamp\
    \ ::= SEQUENCE {\n     digestAlgorithm [0] AlgorithmIdentifier OPTIONAL,\n   \
    \  attributes      [1] Attributes OPTIONAL,\n     reducedHashtree [2] SEQUENCE\
    \ OF PartialHashtree OPTIONAL,\n     timeStamp       ContentInfo}\n   PartialHashtree\
    \ ::= SEQUENCE OF OCTET STRING\n   Attributes ::= SET SIZE (1..MAX) OF Attribute\n\
    \   ArchiveTimeStampChain    ::= SEQUENCE OF ArchiveTimeStamp\n   ArchiveTimeStampSequence\
    \ ::= SEQUENCE OF\n                                ArchiveTimeStampChain\n   EncryptionInfo\
    \       ::=     SEQUENCE {\n       encryptionInfoType     OBJECT IDENTIFIER,\n\
    \       encryptionInfoValue    ANY DEFINED BY encryptionInfoType}\n   id-aa-er-internal\
    \  OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n      us(840) rsadsi(113549)\
    \ pkcs(1) pkcs9(9) smime(16) id-aa(2) 49 }\n   id-aa-er-external  OBJECT IDENTIFIER\
    \ ::= { iso(1) member-body(2)\n      us(840) rsadsi(113549) pkcs(1) pkcs9(9) smime(16)\
    \ id-aa(2) 50 }\n   END\n"
- title: Appendix C.  ASN.1-Module with 1997 Syntax
  contents:
  - "Appendix C.  ASN.1-Module with 1997 Syntax\n   ASN.1-Module\n   ERS {iso(1) identified-organization(3)\
    \ dod(6)\n         internet(1) security(5) mechanisms(5)\n         ltans(11) id-mod(0)\
    \ id-mod-ers(1) id-mod-ers-v1(1) }\n   DEFINITIONS IMPLICIT TAGS ::=\n   BEGIN\n\
    \   -- EXPORTS ALL --\n   IMPORTS\n    -- Imports from PKCS-7\n   ContentInfo\n\
    \       FROM PKCS7\n           {iso(1) member-body(2) us(840) rsadsi(113549)\n\
    \           pkcs(1) pkcs-7(7) modules(0)}\n     -- Imports from AuthenticationFramework\n\
    \   AlgorithmIdentifier\n       FROM AuthenticationFramework\n           {joint-iso-itu-t\
    \ ds(5) module(1)\n           authenticationFramework(7) 4}\n    -- Imports from\
    \ InformationFramework\n   Attribute\n       FROM InformationFramework\n     \
    \      {joint-iso-itu-t ds(5) module(1)\n           informationFramework(1) 4}\n\
    \   ;\n   ltans OBJECT IDENTIFIER ::=\n            { iso(1) identified-organization(3)\
    \ dod(6) internet(1)\n              security(5) mechanisms(5) ltans(11) }\n  \
    \ EvidenceRecord ::= SEQUENCE {\n      version                   INTEGER { v1(1)\
    \ } ,\n      digestAlgorithms          SEQUENCE OF AlgorithmIdentifier,\n    \
    \  cryptoInfos               [0] CryptoInfos OPTIONAL,\n      encryptionInfo \
    \           [1] EncryptionInfo OPTIONAL,\n      archiveTimeStampSequence  ArchiveTimeStampSequence\n\
    \      }\n   CryptoInfos ::= SEQUENCE SIZE (1..MAX) OF Attribute\n           (WITH\
    \ COMPONENTS {\n              ...,\n              valuesWithContext   ABSENT\n\
    \            })\n   ArchiveTimeStamp ::= SEQUENCE {\n     digestAlgorithm [0]\
    \ AlgorithmIdentifier OPTIONAL,\n     attributes      [1] Attributes OPTIONAL,\n\
    \     reducedHashtree [2] SEQUENCE OF PartialHashtree OPTIONAL,\n     timeStamp\
    \       ContentInfo}\n   PartialHashtree ::= SEQUENCE OF OCTET STRING\n   Attributes\
    \ ::= SET SIZE (1..MAX) OF Attribute\n           (WITH COMPONENTS {\n        \
    \      ...,\n              valuesWithContext   ABSENT\n            })\n   ArchiveTimeStampChain\
    \    ::= SEQUENCE OF ArchiveTimeStamp\n   ArchiveTimeStampSequence ::= SEQUENCE\
    \ OF\n                                ArchiveTimeStampChain\n   EncryptionInfo\
    \       ::=     SEQUENCE {\n       encryptionInfoType   ENCINFO-TYPE.&id\n   \
    \                                   ({SupportedEncryptionAlgorithms}),\n     \
    \  encryptionInfoValue  ENCINFO-TYPE.&Type\n                  ({SupportedEncryptionAlgorithms}{@encryptionInfoType})\n\
    \   }\n   ENCINFO-TYPE ::= TYPE-IDENTIFIER\n   SupportedEncryptionAlgorithms ENCINFO-TYPE\
    \ ::= {...}\n   id-aa-er-internal  OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n\
    \      us(840) rsadsi(113549) pkcs(1) pkcs9(9) smime(16) id-aa(2) 49 }\n   id-aa-er-external\
    \  OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n      us(840) rsadsi(113549)\
    \ pkcs(1) pkcs9(9) smime(16) id-aa(2) 50 }\n   END\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Tobias Gondrom\n   Open Text Corporation\n   Werner-von-Siemens-Ring\
    \ 20\n   Grasbrunn, Munich  D-85630\n   Germany\n   Phone: +49 (0) 89 4629-1816\n\
    \   Fax:   +49 (0) 89 4629-33-1816\n   EMail: tobias.gondrom@opentext.com\n  \
    \ Ralf Brandner\n   InterComponentWare AG\n   Industriestra?e 41\n   Walldorf\
    \  D-69119\n   Germany\n   EMail: ralf.brandner@intercomponentware.com\n   Ulrich\
    \ Pordesch\n   Fraunhofer Gesellschaft\n   Rheinstra?e 75\n   Darmstadt  D-64295\n\
    \   Germany\n   EMail: ulrich.pordesch@zv.fraunhofer.de\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
