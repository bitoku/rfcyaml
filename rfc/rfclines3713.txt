Abstract This document describes the Camellia encryption algorithm.
Camellia is a block cipher with 128 bit block size and 128 , 192 , and 256 bit keys.
The algorithm description is presented together with key scheduling part and data randomizing part.
Camellia Camellia was jointly developed by Nippon Telegraph and Telephone Corporation and Mitsubishi Electric Corporation in 2000 [CamelliaSpec].
Camellia specifies the 128 bit block size and 128 , 192 , and 256 bit key sizes, the same interface as the Advanced Encryption Standard (AES).
Camellia is characterized by its suitability for both software and hardware implementations as well as its high level of security.
From a practical viewpoint, it is designed to enable flexibility in software and hardware implementations on 32 bit processors widely used over the Internet and many applications, 8 bit processors used in smart cards, cryptographic hardware, embedded systems, and so on [CamelliaTech].
Moreover, its key setup time is excellent, and its key agility is superior to that of AES.
Camellia has been scrutinized by the wide cryptographic community during several projects for evaluating crypto algorithms.
In particular, Camellia was selected as a recommended cryptographic primitive by the EU NESSIE (
New European Schemes for Signatures, Integrity and Encryption) project [NESSIE] and also included in the list of cryptographic techniques for Japanese e Government systems which were selected by the Japan CRYPTREC (Cryptography Research and Evaluation Committees)
Algorithm Description Camellia can be divided into "key scheduling part" and "data randomizing part".
The following operators are used in this document to describe the algorithm.
~y   bitwise complement of y. 0x   hexadecimal representation.
Note that the logical left shift operation is done with the infinite data width.
The constant values of MASK8, MASK32, MASK64, and MASK128 are defined as follows.
In the key schedule part of Camellia, the 128 bit variables of KL and KR are defined as follows.
For 128 bit keys, the 128 bit key K is used as KL and KR is 0.
For 192 bit keys, the leftmost 128 bits of key K are used as KL and the concatenation of the rightmost 64 bits of K and the complement of the rightmost 64 bits of K are used as KR.
For 256 bit keys, the leftmost 128 bits of key K are used as KL and the rightmost 128 bits of K are used as KR.
Note that KB is used only if the length of the secret key is 192 or 256 bits.
D1 and D2 are 64 bit temporary variables.
F  function is described in Section 2.4.
D2   (KL ^ KR) & MASK64; D2   D2 ^ F(D1,
(KL >> 64); D2   D2
(KL & MASK64); D2   D2 ^ F(D1, Sigma3); D1   D1
F(D2, Sigma4); KA   (D1 << 64)   D2; D1
(KA ^ KR) & MASK64;
These constant values are, in hexadecimal notation, as follows.
; Sigma2   0xB67AE8584CAA73B2; Sigma3   0xC6EF372FE94F82BE; Sigma4   0x54FF53A5F1D36F1C; Sigma5   0x10E527FADE682D1D; Sigma6   0xB05688C2B3E6C1FD; 64 bit subkeys are generated by rotating KL, KR, KA, and KB and taking the left  or right half of them.
64; D2   M & MASK64
; Encryption is performed using an 18 round Feistel structure with FL  and FLINV functions inserted every 6 rounds.
F function, FL function, and FLINV function are described in Section 2.4.
^ kw4; 128 bit ciphertext C is constructed from D1 and D2 as follows.
C   (D2 << 64)   D1; 2.3.2.
Encryption for 192  and 256 bit keys 128 bit plaintext
M is divided into the left 64 bit D1 and the right 64 bit D2.
64; D2   M & MASK64
; Encryption is performed using a 24 round Feistel structure with FL  and FLINV functions inserted every 6 rounds.
F function, FL function, and FLINV function are described in Section 2.4.
^ kw4; 128 bit ciphertext C is constructed from D1 and D2 as follows.
C   (D2 << 64)   D1; 2.3.3.
The decryption procedure of Camellia can be done in the same way as the encryption procedure by reversing the order of the subkeys.
That is to say: 128 bit key:
ke3 192  or 256 bit key:
F function F function takes two parameters.
One is 64 bit input data F IN.
The other is 64 bit subkey KE.
F function returns 64 bit data F OUT.
F(F IN, KE) begin var x
as 64 bit unsigned integer; var t1, t2, t3, t4, t5, t6, t7, t8 as 8 bit unsigned integer; var y1, y2, y3, y4, y5, y6, y7, y8 as 8 bit unsigned integer;
t2   (x >> 48) & MASK8; t3
> 40) & MASK8; t4
> 32) & MASK8; t5
> 24) & MASK8; t6   (
> 16) & MASK8; t7
t7 ^ t8; y2   t1
t7 ^ t8; y3   t1 ^ t2 ^ t3 ^ t5 ^ t6 ^ t8; y4   t2 ^ t3 ^ t4 ^ t5 ^ t6 ^ t7; y5   t1 ^ t2 ^ t6 ^ t7 ^ t8; y6   t2 ^ t3 ^ t5 ^ t7 ^ t8; y7   t3 ^ t4 ^ t5 ^ t6 ^ t8; y8   t1 ^ t4 ^ t5 ^ t6 ^ t7; F OUT
; return FO OUT; end.
SBOX1, SBOX2, SBOX3, and SBOX4 are lookup tables with 8 bit input/ output data.
SBOX2, SBOX3, and SBOX4 are defined using SBOX1 as follows:
; SBOX1 is defined by the following table.
For example, SBOX1[0x3d] equals 86.
12 174  65 10:  35 239 107 147
134 184 175 143 124 235  31 206  62  48 220  95  94 197  11  26 30: 166 225  57 202 213  71  93  61 217
252 105  80 80: 170 208 160
224 255 100 210 90:  16 196   0
233 121 167 140 159 110 188 142  41 245 249 182  47 253 180
238 172  10  54  73
56 241 164 f0:  64
40 211 123 187 201
FL function takes two parameters.
One is 64 bit input data FL IN.
The other is 64 bit subkey KE.
FL function returns 64 bit data FL OUT.
FL(FL IN, KE) begin var x1, x2 as 32 bit unsigned integer; var k1, k2 as 32 bit unsigned integer; x1   FL IN >
; x2   FL IN & MASK32; k1   KE >> 32; k2   KE & MASK32; x2   x2
<<< 1); x1   x1 ^ (x2   k2)
; FL OUT   (x1 << 32)   x2; end.
FLINV function is the inverse function of the FL function.
IN, KE) begin var y1, y2 as 32 bit unsigned integer; var k1, k2 as 32 bit unsigned integer; y1   FLINV IN >> 32; y2   FLINV IN & MASK32; k1   KE >
The Object Identifier for Camellia with 128 bit key in Cipher Block Chaining (CBC) mode is as follows:
} The Object Identifier for Camellia with 192 bit key in Cipher Block Chaining (CBC) mode is as follows:
symmetric encryption algorithm(1) camellia192 cbc(3)
} The Object Identifier for Camellia with 256 bit key in Cipher Block Chaining (CBC) mode is as follows:
symmetric encryption algorithm(1) camellia256 cbc(4)
} The above algorithms need Initialization Vector (IV).
To determine the value of IV, the above algorithms take parameters as follows:
When these object identifiers are used, plaintext is padded before encryption according to RFC2315 [RFC2315].
The recent advances in cryptanalytic techniques are remarkable.
A quantitative evaluation of security against powerful cryptanalytic techniques such as differential cryptanalysis and linear cryptanalysis is considered to be essential in designing any new block cipher.
We evaluated the security of Camellia by utilizing state of the art cryptanalytic techniques.
We confirmed that Camellia has no differential and linear characteristics that hold with probability more than 2^( 128), which means that it is extremely unlikely that differential and linear attacks will succeed against the full 18 round Camellia.
Moreover, Camellia was designed to offer security against other advanced cryptanalytic attacks including higher order differential attacks, interpolation attacks, related key attacks, truncated differential attacks, and so on [Camellia].
Appendix A.  Example Data of Camellia
Here are test data for Camellia in hexadecimal form.
23 45 67 89 ab cd
32 10 Plaintext : 01
23 45 67 89 ab cd
98 76 54 32 10 Ciphertext:
67 67 31 38 54 96 69 73 08 57 06 56 48 ea be 43 192 bit key Key
: 01 23 45 67 89 ab cd
98 76 54 32 10 : 00
33 44 55 66 77
23 45 67 89 ab cd
98 76 54 32 10
b4 99 34 01 b3 e9 96 f8
4e e5 ce e7 d7 9b 09 b9 256
23 45 67 89 ab cd
98 76 54 32 10 : 00
33 44 55 66 77
23 45 67 89 ab cd
98 76 54 32 10
23 7d ff 16 d7 6c 20
ef 7c 91 9e 3a
