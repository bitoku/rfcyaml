- contents:
  - '                Extensible Authentication Protocol (EAP)

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document defines the Extensible Authentication Protocol (EAP),\n
    \  an authentication framework which supports multiple authentication\n   methods.
    \ EAP typically runs directly over data link layers such as\n   Point-to-Point
    Protocol (PPP) or IEEE 802, without requiring IP.  EAP\n   provides its own support
    for duplicate elimination and\n   retransmission, but is reliant on lower layer
    ordering guarantees.\n   Fragmentation is not supported within EAP itself; however,
    individual\n   EAP methods may support this.\n   This document obsoletes RFC 2284.
    \ A summary of the changes between\n   this document and RFC 2284 is available
    in Appendix A.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.   Introduction. . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n        1.1.  Specification of Requirements . . . . . . . . .
    . . . .  4\n        1.2.  Terminology . . . . . . . . . . . . . . . . . . . .
    . .  4\n        1.3.  Applicability . . . . . . . . . . . . . . . . . . . . .
    \ 6\n   2.   Extensible Authentication Protocol (EAP). . . . . . . . . . .  7\n
    \       2.1.  Support for Sequences . . . . . . . . . . . . . . . . .  9\n        2.2.
    \ EAP Multiplexing Model. . . . . . . . . . . . . . . . . 10\n        2.3.  Pass-Through
    Behavior . . . . . . . . . . . . . . . . . 12\n        2.4.  Peer-to-Peer Operation.
    . . . . . . . . . . . . . . . . 14\n   3.   Lower Layer Behavior. . . . . . .
    . . . . . . . . . . . . . . 15\n        3.1.  Lower Layer Requirements. . . .
    . . . . . . . . . . . . 15\n        3.2.  EAP Usage Within PPP. . . . . . . .
    . . . . . . . . . . 18\n              3.2.1. PPP Configuration Option Format.
    . . . . . . . . 18\n        3.3.  EAP Usage Within IEEE 802 . . . . . . . . .
    . . . . . . 19\n        3.4.  Lower Layer Indications . . . . . . . . . . . .
    . . . . 19\n   4.   EAP Packet Format . . . . . . . . . . . . . . . . . . . .
    . . 20\n        4.1.  Request and Response. . . . . . . . . . . . . . . . . .
    21\n        4.2.  Success and Failure . . . . . . . . . . . . . . . . . . 23\n
    \       4.3.  Retransmission Behavior . . . . . . . . . . . . . . . . 26\n   5.
    \  Initial EAP Request/Response Types. . . . . . . . . . . . . . 27\n        5.1.
    \ Identity. . . . . . . . . . . . . . . . . . . . . . . . 28\n        5.2.  Notification.
    . . . . . . . . . . . . . . . . . . . . . 29\n        5.3.  Nak . . . . . . .
    . . . . . . . . . . . . . . . . . . . 31\n              5.3.1. Legacy Nak . .
    . . . . . . . . . . . . . . . . . 31\n              5.3.2. Expanded Nak . . .
    . . . . . . . . . . . . . . . 32\n        5.4.  MD5-Challenge . . . . . . . .
    . . . . . . . . . . . . . 35\n        5.5.  One-Time Password (OTP) . . . . .
    . . . . . . . . . . . 36\n        5.6.  Generic Token Card (GTC). . . . . . .
    . . . . . . . . . 37\n        5.7.  Expanded Types. . . . . . . . . . . . . .
    . . . . . . . 38\n        5.8.  Experimental. . . . . . . . . . . . . . . . .
    . . . . . 40\n   6.   IANA Considerations . . . . . . . . . . . . . . . . . .
    . . . 40\n        6.1.  Packet Codes. . . . . . . . . . . . . . . . . . . . .
    . 41\n        6.2.  Method Types. . . . . . . . . . . . . . . . . . . . . . 41\n
    \  7.   Security Considerations . . . . . . . . . . . . . . . . . . . 42\n        7.1.
    \ Threat Model. . . . . . . . . . . . . . . . . . . . . . 42\n        7.2.  Security
    Claims . . . . . . . . . . . . . . . . . . . . 43\n              7.2.1. Security
    Claims Terminology for EAP Methods. . . 44\n        7.3.  Identity Protection
    . . . . . . . . . . . . . . . . . . 46\n        7.4.  Man-in-the-Middle Attacks
    . . . . . . . . . . . . . . . 47\n        7.5.  Packet Modification Attacks .
    . . . . . . . . . . . . . 48\n        7.6.  Dictionary Attacks. . . . . . . .
    . . . . . . . . . . . 49\n        7.7.  Connection to an Untrusted Network. .
    . . . . . . . . . 49\n        7.8.  Negotiation Attacks . . . . . . . . . . .
    . . . . . . . 50\n        7.9.  Implementation Idiosyncrasies . . . . . . . .
    . . . . . 50\n        7.10. Key Derivation. . . . . . . . . . . . . . . . . .
    . . . 51\n        7.11. Weak Ciphersuites . . . . . . . . . . . . . . . . . .
    . 53\n        7.12. Link Layer. . . . . . . . . . . . . . . . . . . . . . . 53\n
    \       7.13. Separation of Authenticator and Backend Authentication\n              Server.
    . . . . . . . . . . . . . . . . . . . . . . . . 54\n        7.14. Cleartext Passwords
    . . . . . . . . . . . . . . . . . . 55\n        7.15. Channel Binding . . . .
    . . . . . . . . . . . . . . . . 55\n        7.16. Protected Result Indications.
    . . . . . . . . . . . . . 56\n   8.   Acknowledgements. . . . . . . . . . . .
    . . . . . . . . . . . 58\n   9.   References. . . . . . . . . . . . . . . . .
    . . . . . . . . . 59\n        9.1.  Normative References. . . . . . . . . . .
    . . . . . . . 59\n        9.2.  Informative References. . . . . . . . . . . .
    . . . . . 60\n   Appendix A. Changes from RFC 2284. . . . . . . . . . . . . .
    . . . 64\n   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . .
    . 66\n   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 67\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document defines the Extensible Authentication Protocol
    (EAP),\n   an authentication framework which supports multiple authentication\n
    \  methods.  EAP typically runs directly over data link layers such as\n   Point-to-Point
    Protocol (PPP) or IEEE 802, without requiring IP.  EAP\n   provides its own support
    for duplicate elimination and\n   retransmission, but is reliant on lower layer
    ordering guarantees.\n   Fragmentation is not supported within EAP itself; however,
    individual\n   EAP methods may support this.\n   EAP may be used on dedicated
    links, as well as switched circuits, and\n   wired as well as wireless links.
    \ To date, EAP has been implemented\n   with hosts and routers that connect via
    switched circuits or dial-up\n   lines using PPP [RFC1661].  It has also been
    implemented with\n   switches and access points using IEEE 802 [IEEE-802].  EAP\n
    \  encapsulation on IEEE 802 wired media is described in [IEEE-802.1X],\n   and
    encapsulation on IEEE wireless LANs in [IEEE-802.11i].\n   One of the advantages
    of the EAP architecture is its flexibility.\n   EAP is used to select a specific
    authentication mechanism, typically\n   after the authenticator requests more
    information in order to\n   determine the specific authentication method to be
    used.  Rather than\n   requiring the authenticator to be updated to support each
    new\n   authentication method, EAP permits the use of a backend\n   authentication
    server, which may implement some or all authentication\n   methods, with the authenticator
    acting as a pass-through for some or\n   all methods and peers.\n   Within this
    document, authenticator requirements apply regardless of\n   whether the authenticator
    is operating as a pass-through or not.\n   Where the requirement is meant to apply
    to either the authenticator\n   or backend authentication server, depending on
    where the EAP\n   authentication is terminated, the term \"EAP server\" will be
    used.\n"
  - contents:
    - "1.1.  Specification of Requirements\n   In this document, several words are
      used to signify the requirements\n   of the specification.  The key words \"MUST\",
      \"MUST NOT\", \"REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD
      NOT\", \"RECOMMENDED\", \"MAY\",\n   and \"OPTIONAL\" in this document are to
      be interpreted as described in\n   [RFC2119].\n"
    title: 1.1.  Specification of Requirements
  - contents:
    - "1.2.  Terminology\n   This document frequently uses the following terms:\n
      \  authenticator\n      The end of the link initiating EAP authentication.  The
      term\n      authenticator is used in [IEEE-802.1X], and has the same meaning\n
      \     in this document.\n   peer\n      The end of the link that responds to
      the authenticator.  In\n      [IEEE-802.1X], this end is known as the Supplicant.\n
      \  Supplicant\n      The end of the link that responds to the authenticator
      in [IEEE-\n      802.1X].  In this document, this end of the link is called
      the\n      peer.\n   backend authentication server\n      A backend authentication
      server is an entity that provides an\n      authentication service to an authenticator.
      \ When used, this\n      server typically executes EAP methods for the authenticator.
      \ This\n      terminology is also used in [IEEE-802.1X].\n   AAA\n      Authentication,
      Authorization, and Accounting.  AAA protocols with\n      EAP support include
      RADIUS [RFC3579] and Diameter [DIAM-EAP].  In\n      this document, the terms
      \"AAA server\" and \"backend authentication\n      server\" are used interchangeably.\n
      \  Displayable Message\n      This is interpreted to be a human readable string
      of characters.\n      The message encoding MUST follow the UTF-8 transformation
      format\n      [RFC2279].\n   EAP server\n      The entity that terminates the
      EAP authentication method with the\n      peer.  In the case where no backend
      authentication server is used,\n      the EAP server is part of the authenticator.
      \ In the case where\n      the authenticator operates in pass-through mode,
      the EAP server is\n      located on the backend authentication server.\n   Silently
      Discard\n      This means the implementation discards the packet without further\n
      \     processing.  The implementation SHOULD provide the capability of\n      logging
      the event, including the contents of the silently\n      discarded packet, and
      SHOULD record the event in a statistics\n      counter.\n   Successful Authentication\n
      \     In the context of this document, \"successful authentication\" is an\n
      \     exchange of EAP messages, as a result of which the authenticator\n      decides
      to allow access by the peer, and the peer decides to use\n      this access.
      \ The authenticator's decision typically involves both\n      authentication
      and authorization aspects; the peer may\n      successfully authenticate to
      the authenticator, but access may be\n      denied by the authenticator due
      to policy reasons.\n   Message Integrity Check (MIC)\n      A keyed hash function
      used for authentication and integrity\n      protection of data.  This is usually
      called a Message\n      Authentication Code (MAC), but IEEE 802 specifications
      (and this\n      document) use the acronym MIC to avoid confusion with Medium\n
      \     Access Control.\n   Cryptographic Separation\n      Two keys (x and y)
      are \"cryptographically separate\" if an\n      adversary that knows all messages
      exchanged in the protocol cannot\n      compute x from y or y from x without
      \"breaking\" some cryptographic\n      assumption.  In particular, this definition
      allows that the\n      adversary has the knowledge of all nonces sent in cleartext,
      as\n      well as all predictable counter values used in the protocol.\n      Breaking
      a cryptographic assumption would typically require\n      inverting a one-way
      function or predicting the outcome of a\n      cryptographic pseudo-random number
      generator without knowledge of\n      the secret state.  In other words, if
      the keys are\n      cryptographically separate, there is no shortcut to compute
      x from\n      y or y from x, but the work an adversary must do to perform this\n
      \     computation is equivalent to performing an exhaustive search for\n      the
      secret state value.\n   Master Session Key (MSK)\n      Keying material that
      is derived between the EAP peer and server\n      and exported by the EAP method.
      \ The MSK is at least 64 octets in\n      length.  In existing implementations,
      a AAA server acting as an\n      EAP server transports the MSK to the authenticator.\n
      \  Extended Master Session Key (EMSK)\n      Additional keying material derived
      between the EAP client and\n      server that is exported by the EAP method.
      \ The EMSK is at least\n      64 octets in length.  The EMSK is not shared with
      the\n      authenticator or any other third party.  The EMSK is reserved for\n
      \     future uses that are not defined yet.\n   Result indications\n      A
      method provides result indications if after the method's last\n      message
      is sent and received:\n      1) The peer is aware of whether it has authenticated
      the server,\n         as well as whether the server has authenticated it.\n
      \     2) The server is aware of whether it has authenticated the peer,\n         as
      well as whether the peer has authenticated it.\n   In the case where successful
      authentication is sufficient to\n   authorize access, then the peer and authenticator
      will also know if\n   the other party is willing to provide or accept access.
      \ This may not\n   always be the case.  An authenticated peer may be denied
      access due\n   to lack of authorization (e.g., session limit) or other reasons.\n
      \  Since the EAP exchange is run between the peer and the server, other\n   nodes
      (such as AAA proxies) may also affect the authorization\n   decision.  This
      is discussed in more detail in Section 7.16.\n"
    title: 1.2.  Terminology
  - contents:
    - "1.3.  Applicability\n   EAP was designed for use in network access authentication,
      where IP\n   layer connectivity may not be available.  Use of EAP for other\n
      \  purposes, such as bulk data transport, is NOT RECOMMENDED.\n   Since EAP
      does not require IP connectivity, it provides just enough\n   support for the
      reliable transport of authentication protocols, and\n   no more.\n   EAP is
      a lock-step protocol which only supports a single packet in\n   flight.  As
      a result, EAP cannot efficiently transport bulk data,\n   unlike transport protocols
      such as TCP [RFC793] or SCTP [RFC2960].\n   While EAP provides support for retransmission,
      it assumes ordering\n   guarantees provided by the lower layer, so out of order
      reception is\n   not supported.\n   Since EAP does not support fragmentation
      and reassembly, EAP\n   authentication methods generating payloads larger than
      the minimum\n   EAP MTU need to provide fragmentation support.\n   While authentication
      methods such as EAP-TLS [RFC2716] provide\n   support for fragmentation and
      reassembly, the EAP methods defined in\n   this document do not.  As a result,
      if the EAP packet size exceeds\n   the EAP MTU of the link, these methods will
      encounter difficulties.\n   EAP authentication is initiated by the server (authenticator),\n
      \  whereas many authentication protocols are initiated by the client\n   (peer).
      \ As a result, it may be necessary for an authentication\n   algorithm to add
      one or two additional messages (at most one\n   roundtrip) in order to run over
      EAP.\n   Where certificate-based authentication is supported, the number of\n
      \  additional roundtrips may be much larger due to fragmentation of\n   certificate
      chains.  In general, a fragmented EAP packet will require\n   as many round-trips
      to send as there are fragments.  For example, a\n   certificate chain 14960
      octets in size would require ten round-trips\n   to send with a 1496 octet EAP
      MTU.\n   Where EAP runs over a lower layer in which significant packet loss
      is\n   experienced, or where the connection between the authenticator and\n
      \  authentication server experiences significant packet loss, EAP\n   methods
      requiring many round-trips can experience difficulties.  In\n   these situations,
      use of EAP methods with fewer roundtrips is\n   advisable.\n"
    title: 1.3.  Applicability
  title: 1.  Introduction
- contents:
  - "2.  Extensible Authentication Protocol (EAP)\n   The EAP authentication exchange
    proceeds as follows:\n   [1] The authenticator sends a Request to authenticate
    the peer.  The\n       Request has a Type field to indicate what is being requested.\n
    \      Examples of Request Types include Identity, MD5-challenge, etc.\n       The
    MD5-challenge Type corresponds closely to the CHAP\n       authentication protocol
    [RFC1994].  Typically, the authenticator\n       will send an initial Identity
    Request; however, an initial\n       Identity Request is not required, and MAY
    be bypassed.  For\n       example, the identity may not be required where it is
    determined\n       by the port to which the peer has connected (leased lines,\n
    \      dedicated switch or dial-up ports), or where the identity is\n       obtained
    in another fashion (via calling station identity or MAC\n       address, in the
    Name field of the MD5-Challenge Response, etc.).\n   [2] The peer sends a Response
    packet in reply to a valid Request.  As\n       with the Request packet, the Response
    packet contains a Type\n       field, which corresponds to the Type field of the
    Request.\n   [3] The authenticator sends an additional Request packet, and the\n
    \      peer replies with a Response.  The sequence of Requests and\n       Responses
    continues as long as needed.  EAP is a 'lock step'\n       protocol, so that other
    than the initial Request, a new Request\n       cannot be sent prior to receiving
    a valid Response.  The\n       authenticator is responsible for retransmitting
    requests as\n       described in Section 4.1.  After a suitable number of\n       retransmissions,
    the authenticator SHOULD end the EAP\n       conversation.  The authenticator
    MUST NOT send a Success or\n       Failure packet when retransmitting or when
    it fails to get a\n       response from the peer.\n   [4] The conversation continues
    until the authenticator cannot\n       authenticate the peer (unacceptable Responses
    to one or more\n       Requests), in which case the authenticator implementation
    MUST\n       transmit an EAP Failure (Code 4).  Alternatively, the\n       authentication
    conversation can continue until the authenticator\n       determines that successful
    authentication has occurred, in which\n       case the authenticator MUST transmit
    an EAP Success (Code 3).\n   Advantages:\n   o  The EAP protocol can support multiple
    authentication mechanisms\n      without having to pre-negotiate a particular
    one.\n   o  Network Access Server (NAS) devices (e.g., a switch or access\n      point)
    do not have to understand each authentication method and\n      MAY act as a pass-through
    agent for a backend authentication\n      server.  Support for pass-through is
    optional.  An authenticator\n      MAY authenticate local peers, while at the
    same time acting as a\n      pass-through for non-local peers and authentication
    methods it\n      does not implement locally.\n   o  Separation of the authenticator
    from the backend authentication\n      server simplifies credentials management
    and policy decision\n      making.\n   Disadvantages:\n   o  For use in PPP, EAP
    requires the addition of a new authentication\n      Type to PPP LCP and thus
    PPP implementations will need to be\n      modified to use it.  It also strays
    from the previous PPP\n      authentication model of negotiating a specific authentication\n
    \     mechanism during LCP.  Similarly, switch or access point\n      implementations
    need to support [IEEE-802.1X] in order to use EAP.\n   o  Where the authenticator
    is separate from the backend\n      authentication server, this complicates the
    security analysis and,\n      if needed, key distribution.\n"
  - contents:
    - "2.1.  Support for Sequences\n   An EAP conversation MAY utilize a sequence
      of methods.  A common\n   example of this is an Identity request followed by
      a single EAP\n   authentication method such as an MD5-Challenge.  However, the
      peer\n   and authenticator MUST utilize only one authentication method (Type
      4\n   or greater) within an EAP conversation, after which the authenticator\n
      \  MUST send a Success or Failure packet.\n   Once a peer has sent a Response
      of the same Type as the initial\n   Request, an authenticator MUST NOT send
      a Request of a different Type\n   prior to completion of the final round of
      a given method (with the\n   exception of a Notification-Request) and MUST NOT
      send a Request for\n   an additional method of any Type after completion of
      the initial\n   authentication method; a peer receiving such Requests MUST treat
      them\n   as invalid, and silently discard them.  As a result, Identity Requery\n
      \  is not supported.\n   A peer MUST NOT send a Nak (legacy or expanded) in
      reply to a Request\n   after an initial non-Nak Response has been sent.  Since
      spoofed EAP\n   Request packets may be sent by an attacker, an authenticator\n
      \  receiving an unexpected Nak SHOULD discard it and log the event.\n   Multiple
      authentication methods within an EAP conversation are not\n   supported due
      to their vulnerability to man-in-the-middle attacks\n   (see Section 7.4) and
      incompatibility with existing implementations.\n   Where a single EAP authentication
      method is utilized, but other\n   methods are run within it (a \"tunneled\"
      method), the prohibition\n   against multiple authentication methods does not
      apply.  Such\n   \"tunneled\" methods appear as a single authentication method
      to EAP.\n   Backward compatibility can be provided, since a peer not supporting
      a\n   \"tunneled\" method can reply to the initial EAP-Request with a Nak\n
      \  (legacy or expanded).  To address security vulnerabilities,\n   \"tunneled\"
      methods MUST support protection against man-in-the-middle\n   attacks.\n"
    title: 2.1.  Support for Sequences
  - contents:
    - "2.2.  EAP Multiplexing Model\n   Conceptually, EAP implementations consist
      of the following\n   components:\n   [a] Lower layer.  The lower layer is responsible
      for transmitting and\n       receiving EAP frames between the peer and authenticator.
      \ EAP has\n       been run over a variety of lower layers including PPP, wired
      IEEE\n       802 LANs [IEEE-802.1X], IEEE 802.11 wireless LANs [IEEE-802.11],\n
      \      UDP (L2TP [RFC2661] and IKEv2 [IKEv2]), and TCP [PIC].  Lower\n       layer
      behavior is discussed in Section 3.\n   [b] EAP layer.  The EAP layer receives
      and transmits EAP packets via\n       the lower layer, implements duplicate
      detection and\n       retransmission, and delivers and receives EAP messages
      to and\n       from the EAP peer and authenticator layers.\n   [c] EAP peer
      and authenticator layers.  Based on the Code field, the\n       EAP layer demultiplexes
      incoming EAP packets to the EAP peer and\n       authenticator layers.  Typically,
      an EAP implementation on a\n       given host will support either peer or authenticator\n
      \      functionality, but it is possible for a host to act as both an\n       EAP
      peer and authenticator.  In such an implementation both EAP\n       peer and
      authenticator layers will be present.\n   [d] EAP method layers.  EAP methods
      implement the authentication\n       algorithms and receive and transmit EAP
      messages via the EAP peer\n       and authenticator layers.  Since fragmentation
      support is not\n       provided by EAP itself, this is the responsibility of
      EAP\n       methods, which are discussed in Section 5.\n   The EAP multiplexing
      model is illustrated in Figure 1 below.  Note\n   that there is no requirement
      that an implementation conform to this\n   model, as long as the on-the-wire
      behavior is consistent with it.\n         +-+-+-+-+-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+-+-+-+-+\n
      \        |           |           |  |           |           |\n         | EAP
      method| EAP method|  | EAP method| EAP method|\n         | Type = X  | Type
      = Y  |  | Type = X  | Type = Y  |\n         |       V   |           |  |       ^
      \  |           |\n         +-+-+-+-!-+-+-+-+-+-+-+-+  +-+-+-+-!-+-+-+-+-+-+-+-+\n
      \        |       !               |  |       !               |\n         |  EAP
      \ ! Peer layer    |  |  EAP  ! Auth. layer   |\n         |       !               |
      \ |       !               |\n         +-+-+-+-!-+-+-+-+-+-+-+-+  +-+-+-+-!-+-+-+-+-+-+-+-+\n
      \        |       !               |  |       !               |\n         |  EAP
      \ ! layer         |  |  EAP  ! layer         |\n         |       !               |
      \ |       !               |\n         +-+-+-+-!-+-+-+-+-+-+-+-+  +-+-+-+-!-+-+-+-+-+-+-+-+\n
      \        |       !               |  |       !               |\n         | Lower
      ! layer         |  | Lower ! layer         |\n         |       !               |
      \ |       !               |\n         +-+-+-+-!-+-+-+-+-+-+-+-+  +-+-+-+-!-+-+-+-+-+-+-+-+\n
      \                !                          !\n                 !   Peer                   !
      Authenticator\n                 +------------>-------------+\n                     Figure
      1: EAP Multiplexing Model\n   Within EAP, the Code field functions much like
      a protocol number in\n   IP.  It is assumed that the EAP layer demultiplexes
      incoming EAP\n   packets according to the Code field.  Received EAP packets
      with\n   Code=1 (Request), 3 (Success), and 4 (Failure) are delivered by the\n
      \  EAP layer to the EAP peer layer, if implemented.  EAP packets with\n   Code=2
      (Response) are delivered to the EAP authenticator layer, if\n   implemented.\n
      \  Within EAP, the Type field functions much like a port number in UDP\n   or
      TCP.  It is assumed that the EAP peer and authenticator layers\n   demultiplex
      incoming EAP packets according to their Type, and deliver\n   them only to the
      EAP method corresponding to that Type.  An EAP\n   method implementation on
      a host may register to receive packets from\n   the peer or authenticator layers,
      or both, depending on which role(s)\n   it supports.\n   Since EAP authentication
      methods may wish to access the Identity,\n   implementations SHOULD make the
      Identity Request and Response\n   accessible to authentication methods (Types
      4 or greater), in\n   addition to the Identity method.  The Identity Type is
      discussed in\n   Section 5.1.\n   A Notification Response is only used as confirmation
      that the peer\n   received the Notification Request, not that it has processed
      it, or\n   displayed the message to the user.  It cannot be assumed that the\n
      \  contents of the Notification Request or Response are available to\n   another
      method.  The Notification Type is discussed in Section 5.2.\n   Nak (Type 3)
      or Expanded Nak (Type 254) are utilized for the purposes\n   of method negotiation.
      \ Peers respond to an initial EAP Request for\n   an unacceptable Type with
      a Nak Response (Type 3) or Expanded Nak\n   Response (Type 254).  It cannot
      be assumed that the contents of the\n   Nak Response(s) are available to another
      method.  The Nak Type(s) are\n   discussed in Section 5.3.\n   EAP packets with
      Codes of Success or Failure do not include a Type\n   field, and are not delivered
      to an EAP method.  Success and Failure\n   are discussed in Section 4.2.\n   Given
      these considerations, the Success, Failure, Nak Response(s),\n   and Notification
      Request/Response messages MUST NOT be used to carry\n   data destined for delivery
      to other EAP methods.\n"
    title: 2.2.  EAP Multiplexing Model
  - contents:
    - "2.3.  Pass-Through Behavior\n   When operating as a \"pass-through authenticator\",
      an authenticator\n   performs checks on the Code, Identifier, and Length fields
      as\n   described in Section 4.1.  It forwards EAP packets received from the\n
      \  peer and destined to its authenticator layer to the backend\n   authentication
      server; packets received from the backend\n   authentication server destined
      to the peer are forwarded to it.\n   A host receiving an EAP packet may only
      do one of three things with\n   it: act on it, drop it, or forward it.  The
      forwarding decision is\n   typically based only on examination of the Code,
      Identifier, and\n   Length fields.  A pass-through authenticator implementation
      MUST be\n   capable of forwarding EAP packets received from the peer with Code=2\n
      \  (Response) to the backend authentication server. It also MUST be\n   capable
      of receiving EAP packets from the backend authentication\n   server and forwarding
      EAP packets of Code=1 (Request), Code=3\n   (Success), and Code=4 (Failure)
      to the peer.\n   Unless the authenticator implements one or more authentication\n
      \  methods locally which support the authenticator role, the EAP method\n   layer
      header fields (Type, Type-Data) are not examined as part of the\n   forwarding
      decision.  Where the authenticator supports local\n   authentication methods,
      it MAY examine the Type field to determine\n   whether to act on the packet
      itself or forward it.  Compliant pass-\n   through authenticator implementations
      MUST by default forward EAP\n   packets of any Type.\n   EAP packets received
      with Code=1 (Request), Code=3 (Success), and\n   Code=4 (Failure) are demultiplexed
      by the EAP layer and delivered to\n   the peer layer.  Therefore, unless a host
      implements an EAP peer\n   layer, these packets will be silently discarded.
      \ Similarly, EAP\n   packets received with Code=2 (Response) are demultiplexed
      by the EAP\n   layer and delivered to the authenticator layer.  Therefore, unless
      a\n   host implements an EAP authenticator layer, these packets will be\n   silently
      discarded.  The behavior of a \"pass-through peer\" is\n   undefined within
      this specification, and is unsupported by AAA\n   protocols such as RADIUS [RFC3579]
      and Diameter [DIAM-EAP].\n   The forwarding model is illustrated in Figure 2.\n
      \       Peer         Pass-through Authenticator   Authentication\n                                                      Server\n
      \  +-+-+-+-+-+-+                                   +-+-+-+-+-+-+\n   |           |
      \                                  |           |\n   |EAP method |                                   |EAP
      method |\n   |     V     |                                   |     ^     |\n
      \  +-+-+-!-+-+-+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+   +-+-+-!-+-+-+\n   |     !
      \    |   |EAP  |  EAP  |             |   |     !     |\n   |     !     |   |Peer
      |  Auth.| EAP Auth.   |   |     !     |\n   |EAP  ! peer|   |     | +-----------+
      \      |   |EAP  !Auth.|\n   |     !     |   |     | !     |     !       |   |
      \    !     |\n   +-+-+-!-+-+-+   +-+-+-+-!-+-+-+-+-+-!-+-+-+-+   +-+-+-!-+-+-+\n
      \  |     !     |   |       !     |     !       |   |     !     |\n   |EAP  !layer|
      \  |   EAP !layer| EAP !layer  |   |EAP  !layer|\n   |     !     |   |       !
      \    |     !       |   |     !     |\n   +-+-+-!-+-+-+   +-+-+-+-!-+-+-+-+-+-!-+-+-+-+
      \  +-+-+-!-+-+-+\n   |     !     |   |       !     |     !       |   |     !
      \    |\n   |Lower!layer|   |  Lower!layer| AAA ! /IP   |   | AAA ! /IP |\n   |
      \    !     |   |       !     |     !       |   |     !     |\n   +-+-+-!-+-+-+
      \  +-+-+-+-!-+-+-+-+-+-!-+-+-+-+   +-+-+-!-+-+-+\n         !                 !
      \          !                 !\n         !                 !           !                 !\n
      \        +-------->--------+           +--------->-------+\n                   Figure
      2: Pass-through Authenticator\n   For sessions in which the authenticator acts
      as a pass-through, it\n   MUST determine the outcome of the authentication solely
      based on the\n   Accept/Reject indication sent by the backend authentication
      server;\n   the outcome MUST NOT be determined by the contents of an EAP packet\n
      \  sent along with the Accept/Reject indication, or the absence of such\n   an
      encapsulated EAP packet.\n"
    title: 2.3.  Pass-Through Behavior
  - contents:
    - "2.4.  Peer-to-Peer Operation\n   Since EAP is a peer-to-peer protocol, an independent
      and simultaneous\n   authentication may take place in the reverse direction
      (depending on\n   the capabilities of the lower layer).  Both ends of the link
      may act\n   as authenticators and peers at the same time.  In this case, it
      is\n   necessary for both ends to implement EAP authenticator and peer\n   layers.
      \ In addition, the EAP method implementations on both peers\n   must support
      both authenticator and peer functionality.\n   Although EAP supports peer-to-peer
      operation, some EAP\n   implementations, methods, AAA protocols, and link layers
      may not\n   support this.  Some EAP methods may support asymmetric\n   authentication,
      with one type of credential being required for the\n   peer and another type
      for the authenticator.  Hosts supporting peer-\n   to-peer operation with such
      a method would need to be provisioned\n   with both types of credentials.\n
      \  For example, EAP-TLS [RFC2716] is a client-server protocol in which\n   distinct
      certificate profiles are typically utilized for the client\n   and server.  This
      implies that a host supporting peer-to-peer\n   authentication with EAP-TLS
      would need to implement both the EAP peer\n   and authenticator layers, support
      both peer and authenticator roles\n   in the EAP-TLS implementation, and provision
      certificates appropriate\n   for each role.\n   AAA protocols such as RADIUS/EAP
      [RFC3579] and Diameter EAP [DIAM-\n   EAP] only support \"pass-through authenticator\"
      operation.  As noted\n   in [RFC3579] Section 2.6.2, a RADIUS server responds
      to an Access-\n   Request encapsulating an EAP-Request, Success, or Failure
      packet with\n   an Access-Reject.  There is therefore no support for \"pass-through\n
      \  peer\" operation.\n   Even where a method is used which supports mutual authentication
      and\n   result indications, several considerations may dictate that two EAP\n
      \  authentications (one in each direction) are required.  These include:\n   [1]
      Support for bi-directional session key derivation in the lower\n       layer.
      \ Lower layers such as IEEE 802.11 may only support uni-\n       directional
      derivation and transport of transient session keys.\n       For example, the
      group-key handshake defined in [IEEE-802.11i] is\n       uni-directional, since
      in IEEE 802.11 infrastructure mode, only\n       the Access Point (AP) sends
      multicast/broadcast traffic.  In IEEE\n       802.11 ad hoc mode, where either
      peer may send\n       multicast/broadcast traffic, two uni-directional group-key\n
      \      exchanges are required.  Due to limitations of the design, this\n       also
      implies the need for unicast key derivations and EAP method\n       exchanges
      to occur in each direction.\n   [2] Support for tie-breaking in the lower layer.
      \ Lower layers such\n       as IEEE 802.11 ad hoc do not support \"tie breaking\"
      wherein two\n       hosts initiating authentication with each other will only
      go\n       forward with a single authentication.  This implies that even if\n
      \      802.11 were to support a bi-directional group-key handshake, then\n       two
      authentications, one in each direction, might still occur.\n   [3] Peer policy
      satisfaction.  EAP methods may support result\n       indications, enabling
      the peer to indicate to the EAP server\n       within the method that it successfully
      authenticated the EAP\n       server, as well as for the server to indicate
      that it has\n       authenticated the peer.  However, a pass-through authenticator\n
      \      will not be aware that the peer has accepted the credentials\n       offered
      by the EAP server, unless this information is provided to\n       the authenticator
      via the AAA protocol.  The authenticator SHOULD\n       interpret the receipt
      of a key attribute within an Accept packet\n       as an indication that the
      peer has successfully authenticated the\n       server.\n   However, it is possible
      that the EAP peer's access policy was not\n   satisfied during the initial EAP
      exchange, even though mutual\n   authentication occurred.  For example, the
      EAP authenticator may not\n   have demonstrated authorization to act in both
      peer and authenticator\n   roles.  As a result, the peer may require an additional\n
      \  authentication in the reverse direction, even if the peer provided an\n   indication
      that the EAP server had successfully authenticated to it.\n"
    title: 2.4.  Peer-to-Peer Operation
  title: 2.  Extensible Authentication Protocol (EAP)
- contents:
  - '3.  Lower Layer Behavior

    '
  - contents:
    - "3.1.  Lower Layer Requirements\n   EAP makes the following assumptions about
      lower layers:\n   [1] Unreliable transport.  In EAP, the authenticator retransmits\n
      \      Requests that have not yet received Responses so that EAP does\n       not
      assume that lower layers are reliable.  Since EAP defines its\n       own retransmission
      behavior, it is possible (though undesirable)\n       for retransmission to
      occur both in the lower layer and the EAP\n       layer when EAP is run over
      a reliable lower layer.\n   Note that EAP Success and Failure packets are not
      retransmitted.\n   Without a reliable lower layer, and with a non-negligible
      error rate,\n   these packets can be lost, resulting in timeouts.  It is therefore\n
      \  desirable for implementations to improve their resilience to loss of\n   EAP
      Success or Failure packets, as described in Section 4.2.\n   [2] Lower layer
      error detection.  While EAP does not assume that the\n       lower layer is
      reliable, it does rely on lower layer error\n       detection (e.g., CRC, Checksum,
      MIC, etc.).  EAP methods may not\n       include a MIC, or if they do, it may
      not be computed over all the\n       fields in the EAP packet, such as the Code,
      Identifier, Length,\n       or Type fields.  As a result, without lower layer
      error\n       detection, undetected errors could creep into the EAP layer or\n
      \      EAP method layer header fields, resulting in authentication\n       failures.\n
      \      For example, EAP TLS [RFC2716], which computes its MIC over the\n       Type-Data
      field only, regards MIC validation failures as a fatal\n       error.  Without
      lower layer error detection, this method, and\n       others like it, will not
      perform reliably.\n   [3] Lower layer security.  EAP does not require lower
      layers to\n       provide security services such as per-packet confidentiality,\n
      \      authentication, integrity, and replay protection.  However, where\n       these
      security services are available, EAP methods supporting Key\n       Derivation
      (see Section 7.2.1) can be used to provide dynamic\n       keying material.
      \ This makes it possible to bind the EAP\n       authentication to subsequent
      data and protect against data\n       modification, spoofing, or replay.  See
      Section 7.1 for details.\n   [4] Minimum MTU.  EAP is capable of functioning
      on lower layers that\n       provide an EAP MTU size of 1020 octets or greater.\n
      \      EAP does not support path MTU discovery, and fragmentation and\n       reassembly
      is not supported by EAP, nor by the methods defined in\n       this specification:
      Identity (1), Notification (2), Nak Response\n       (3), MD5-Challenge (4),
      One Time Password (5), Generic Token Card\n       (6), and expanded Nak Response
      (254) Types.\n       Typically, the EAP peer obtains information on the EAP
      MTU from\n       the lower layers and sets the EAP frame size to an appropriate\n
      \      value.  Where the authenticator operates in pass-through mode,\n       the
      authentication server does not have a direct way of\n       determining the
      EAP MTU, and therefore relies on the\n       authenticator to provide it with
      this information, such as via\n       the Framed-MTU attribute, as described
      in [RFC3579], Section 2.4.\n       While methods such as EAP-TLS [RFC2716] support
      fragmentation and\n       reassembly, EAP methods originally designed for use
      within PPP\n       where a 1500 octet MTU is guaranteed for control frames (see\n
      \      [RFC1661], Section 6.1) may lack fragmentation and reassembly\n       features.\n
      \      EAP methods can assume a minimum EAP MTU of 1020 octets in the\n       absence
      of other information.  EAP methods SHOULD include support\n       for fragmentation
      and reassembly if their payloads can be larger\n       than this minimum EAP
      MTU.\n       EAP is a lock-step protocol, which implies a certain inefficiency\n
      \      when handling fragmentation and reassembly.  Therefore, if the\n       lower
      layer supports fragmentation and reassembly (such as where\n       EAP is transported
      over IP), it may be preferable for\n       fragmentation and reassembly to occur
      in the lower layer rather\n       than in EAP.  This can be accomplished by
      providing an\n       artificially large EAP MTU to EAP, causing fragmentation
      and\n       reassembly to be handled within the lower layer.\n   [5] Possible
      duplication.  Where the lower layer is reliable, it will\n       provide the
      EAP layer with a non-duplicated stream of packets.\n       However,  while it
      is desirable that lower layers provide for\n       non-duplication, this is
      not a requirement.  The Identifier field\n       provides both the peer and
      authenticator with the ability to\n       detect duplicates.\n   [6] Ordering
      guarantees.  EAP does not require the Identifier to be\n       monotonically
      increasing, and so is reliant on lower layer\n       ordering guarantees for
      correct operation.  EAP was originally\n       defined to run on PPP, and [RFC1661]
      Section 1 has an ordering\n       requirement:\n           \"The Point-to-Point
      Protocol is designed for simple links\n           which transport packets between
      two peers.  These links\n           provide full-duplex simultaneous bi-directional
      operation,\n           and are assumed to deliver packets in order.\"\n       Lower
      layer transports for EAP MUST preserve ordering between a\n       source and
      destination at a given priority level (the ordering\n       guarantee provided
      by [IEEE-802]).\n       Reordering, if it occurs, will typically result in an
      EAP\n       authentication failure, causing EAP authentication to be re-run.\n
      \      In an environment in which reordering is likely, it is therefore\n       expected
      that EAP authentication failures will be common.  It is\n       RECOMMENDED
      that EAP only be run over lower layers that provide\n       ordering guarantees;
      running EAP over raw IP or UDP transport is\n       NOT RECOMMENDED.  Encapsulation
      of EAP within RADIUS [RFC3579]\n       satisfies ordering requirements, since
      RADIUS is a \"lockstep\"\n       protocol that delivers packets in order.\n"
    title: 3.1.  Lower Layer Requirements
  - contents:
    - "3.2.  EAP Usage Within PPP\n   In order to establish communications over a
      point-to-point link, each\n   end of the PPP link first sends LCP packets to
      configure the data\n   link during the Link Establishment phase.  After the
      link has been\n   established, PPP provides for an optional Authentication phase
      before\n   proceeding to the Network-Layer Protocol phase.\n   By default, authentication
      is not mandatory.  If authentication of\n   the link is desired, an implementation
      MUST specify the\n   Authentication Protocol Configuration Option during the
      Link\n   Establishment phase.\n   If the identity of the peer has been established
      in the\n   Authentication phase, the server can use that identity in the\n   selection
      of options for the following network layer negotiations.\n   When implemented
      within PPP, EAP does not select a specific\n   authentication mechanism at the
      PPP Link Control Phase, but rather\n   postpones this until the Authentication
      Phase.  This allows the\n   authenticator to request more information before
      determining the\n   specific authentication mechanism.  This also permits the
      use of a\n   \"backend\" server which actually implements the various mechanisms\n
      \  while the PPP authenticator merely passes through the authentication\n   exchange.
      \ The PPP Link Establishment and Authentication phases, and\n   the Authentication
      Protocol Configuration Option, are defined in The\n   Point-to-Point Protocol
      (PPP) [RFC1661].\n"
    - contents:
      - "3.2.1.  PPP Configuration Option Format\n   A summary of the PPP Authentication
        Protocol Configuration Option\n   format to negotiate EAP follows.  The fields
        are transmitted from\n   left to right.\n   Exactly one EAP packet is encapsulated
        in the Information field of a\n   PPP Data Link Layer frame where the protocol
        field indicates type hex\n   C227 (PPP EAP).\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |     Type      |    Length     |     Authentication Protocol   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type\n      3\n   Length\n      4\n   Authentication Protocol\n      C227
        (Hex) for Extensible Authentication Protocol (EAP)\n"
      title: 3.2.1.  PPP Configuration Option Format
    title: 3.2.  EAP Usage Within PPP
  - contents:
    - "3.3.  EAP Usage Within IEEE 802\n   The encapsulation of EAP over IEEE 802
      is defined in [IEEE-802.1X].\n   The IEEE 802 encapsulation of EAP does not
      involve PPP, and IEEE\n   802.1X does not include support for link or network
      layer\n   negotiations.  As a result, within IEEE 802.1X, it is not possible
      to\n   negotiate non-EAP authentication mechanisms, such as PAP or CHAP\n   [RFC1994].\n"
    title: 3.3.  EAP Usage Within IEEE 802
  - contents:
    - "3.4.  Lower Layer Indications\n   The reliability and security of lower layer
      indications is dependent\n   on the lower layer.  Since EAP is media independent,
      the presence or\n   absence of lower layer security is not taken into account
      in the\n   processing of EAP messages.\n   To improve reliability, if a peer
      receives a lower layer success\n   indication as defined in Section 7.2, it
      MAY conclude that a Success\n   packet has been lost, and behave as if it had
      actually received a\n   Success packet.  This includes choosing to ignore the
      Success in some\n   circumstances as described in Section 4.2.\n   A discussion
      of some reliability and security issues with lower layer\n   indications in
      PPP, IEEE 802 wired networks, and IEEE 802.11 wireless\n   LANs can be found
      in the Security Considerations, Section 7.12.\n   After EAP authentication is
      complete, the peer will typically\n   transmit and receive data via the authenticator.
      \ It is desirable to\n   provide assurance that the entities transmitting data
      are the same\n   ones that successfully completed EAP authentication.  To accomplish\n
      \  this, it is necessary for the lower layer to provide per-packet\n   integrity,
      authentication and replay protection, and to bind these\n   per-packet services
      to the keys derived during EAP authentication.\n   Otherwise, it is possible
      for subsequent data traffic to be modified,\n   spoofed, or replayed.\n   Where
      keying material for the lower layer ciphersuite is itself\n   provided by EAP,
      ciphersuite negotiation and key activation are\n   controlled by the lower layer.
      \ In PPP, ciphersuites are negotiated\n   within ECP so that it is not possible
      to use keys derived from EAP\n   authentication until the completion of ECP.
      \ Therefore, an initial\n   EAP exchange cannot be protected by a PPP ciphersuite,
      although EAP\n   re-authentication can be protected.\n   In IEEE 802 media,
      initial key activation also typically occurs after\n   completion of EAP authentication.
      \ Therefore an initial EAP exchange\n   typically cannot be protected by the
      lower layer ciphersuite,\n   although an EAP re-authentication or pre-authentication
      exchange can\n   be protected.\n"
    title: 3.4.  Lower Layer Indications
  title: 3.  Lower Layer Behavior
- contents:
  - "4.  EAP Packet Format\n   A summary of the EAP packet format is shown below.
    \ The fields are\n   transmitted from left to right.\n    0                   1
    \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
    6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |     Code      |  Identifier   |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |    Data ...\n   +-+-+-+-+\n   Code\n      The Code field is one octet and
    identifies the Type of EAP packet.\n      EAP Codes are assigned as follows:\n
    \        1       Request\n         2       Response\n         3       Success\n
    \        4       Failure\n      Since EAP only defines Codes 1-4, EAP packets
    with other codes\n      MUST be silently discarded by both authenticators and
    peers.\n   Identifier\n      The Identifier field is one octet and aids in matching
    Responses\n      with Requests.\n   Length\n      The Length field is two octets
    and indicates the length, in\n      octets, of the EAP packet including the Code,
    Identifier, Length,\n      and Data fields.  Octets outside the range of the Length
    field\n      should be treated as Data Link Layer padding and MUST be ignored\n
    \     upon reception.  A message with the Length field set to a value\n      larger
    than the number of received octets MUST be silently\n      discarded.\n   Data\n
    \     The Data field is zero or more octets.  The format of the Data\n      field
    is determined by the Code field.\n"
  - contents:
    - "4.1.  Request and Response\n   Description\n      The Request packet (Code
      field set to 1) is sent by the\n      authenticator to the peer.  Each Request
      has a Type field which\n      serves to indicate what is being requested.  Additional
      Request\n      packets MUST be sent until a valid Response packet is received,
      an\n      optional retry counter expires, or a lower layer failure\n      indication
      is received.\n      Retransmitted Requests MUST be sent with the same Identifier
      value\n      in order to distinguish them from new Requests.  The content of\n
      \     the data field is dependent on the Request Type.  The peer MUST\n      send
      a Response packet in reply to a valid Request packet.\n      Responses MUST
      only be sent in reply to a valid Request and never\n      be retransmitted on
      a timer.\n      If a peer receives a valid duplicate Request for which it has\n
      \     already sent a Response, it MUST resend its original Response\n      without
      reprocessing the Request.  Requests MUST be processed in\n      the order that
      they are received, and MUST be processed to their\n      completion before inspecting
      the next Request.\n   A summary of the Request and Response packet format follows.
      \ The\n   fields are transmitted from left to right.\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Code      |  Identifier   |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |  Type-Data ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n
      \  Code\n      1 for Request\n      2 for Response\n   Identifier\n      The
      Identifier field is one octet.  The Identifier field MUST be\n      the same
      if a Request packet is retransmitted due to a timeout\n      while waiting for
      a Response.  Any new (non-retransmission)\n      Requests MUST modify the Identifier
      field.\n      The Identifier field of the Response MUST match that of the\n
      \     currently outstanding Request.  An authenticator receiving a\n      Response
      whose Identifier value does not match that of the\n      currently outstanding
      Request MUST silently discard the Response.\n      In order to avoid confusion
      between new Requests and\n      retransmissions, the Identifier value chosen
      for each new Request\n      need only be different from the previous Request,
      but need not be\n      unique within the conversation.  One way to achieve this
      is to\n      start the Identifier at an initial value and increment it for each\n
      \     new Request.  Initializing the first Identifier with a random\n      number
      rather than starting from zero is recommended, since it\n      makes sequence
      attacks somewhat more difficult.\n      Since the Identifier space is unique
      to each session,\n      authenticators are not restricted to only 256 simultaneous\n
      \     authentication conversations.  Similarly, with re-authentication,\n      an
      EAP conversation might continue over a long period of time, and\n      is not
      limited to only 256 roundtrips.\n   Implementation Note: The authenticator is
      responsible for\n   retransmitting Request messages.  If the Request message
      is obtained\n   from elsewhere (such as from a backend authentication server),
      then\n   the authenticator will need to save a copy of the Request in order
      to\n   accomplish this.  The peer is responsible for detecting and handling\n
      \  duplicate Request messages before processing them in any way,\n   including
      passing them on to an outside party.  The authenticator is\n   also responsible
      for discarding Response messages with a non-matching\n   Identifier value before
      acting on them in any way, including passing\n   them on to the backend authentication
      server for verification.  Since\n   the authenticator can retransmit before
      receiving a Response from the\n   peer, the authenticator can receive multiple
      Responses, each with a\n   matching Identifier.  Until a new Request is received
      by the\n   authenticator, the Identifier value is not updated, so that the\n
      \  authenticator forwards Responses to the backend authentication\n   server,
      one at a time.\n   Length\n      The Length field is two octets and indicates
      the length of the EAP\n      packet including the Code, Identifier, Length,
      Type, and Type-Data\n      fields.  Octets outside the range of the Length field
      should be\n      treated as Data Link Layer padding and MUST be ignored upon\n
      \     reception.  A message with the Length field set to a value larger\n      than
      the number of received octets MUST be silently discarded.\n   Type\n      The
      Type field is one octet.  This field indicates the Type of\n      Request or
      Response.  A single Type MUST be specified for each EAP\n      Request or Response.
      \ An initial specification of Types follows in\n      Section 5 of this document.\n
      \     The Type field of a Response MUST either match that of the\n      Request,
      or correspond to a legacy or Expanded Nak (see Section\n      5.3) indicating
      that a Request Type is unacceptable to the peer.\n      A peer MUST NOT send
      a Nak (legacy or expanded) in response to a\n      Request, after an initial
      non-Nak Response has been sent.  An EAP\n      server receiving a Response not
      meeting these requirements MUST\n      silently discard it.\n   Type-Data\n
      \     The Type-Data field varies with the Type of Request and the\n      associated
      Response.\n"
    title: 4.1.  Request and Response
  - contents:
    - "4.2.  Success and Failure\n   The Success packet is sent by the authenticator
      to the peer after\n   completion of an EAP authentication method (Type 4 or
      greater) to\n   indicate that the peer has authenticated successfully to the\n
      \  authenticator.  The authenticator MUST transmit an EAP packet with\n   the
      Code field set to 3 (Success).  If the authenticator cannot\n   authenticate
      the peer (unacceptable Responses to one or more\n   Requests), then after unsuccessful
      completion of the EAP method in\n   progress, the implementation MUST transmit
      an EAP packet with the\n   Code field set to 4 (Failure).  An authenticator
      MAY wish to issue\n   multiple Requests before sending a Failure response in
      order to allow\n   for human typing mistakes.  Success and Failure packets MUST
      NOT\n   contain additional data.\n   Success and Failure packets MUST NOT be
      sent by an EAP authenticator\n   if the specification of the given method does
      not explicitly permit\n   the method to finish at that point.  A peer EAP implementation\n
      \  receiving a Success or Failure packet where sending one is not\n   explicitly
      permitted MUST silently discard it.  By default, an EAP\n   peer MUST silently
      discard a \"canned\" Success packet (a Success\n   packet sent immediately upon
      connection).  This ensures that a rogue\n   authenticator will not be able to
      bypass mutual authentication by\n   sending a Success packet prior to conclusion
      of the EAP method\n   conversation.\n   Implementation Note: Because the Success
      and Failure packets are not\n   acknowledged, they are not retransmitted by
      the authenticator, and\n   may be potentially lost.  A peer MUST allow for this
      circumstance as\n   described in this note.  See also Section 3.4 for guidance
      on the\n   processing of lower layer success and failure indications.\n   As
      described in Section 2.1, only a single EAP authentication method\n   is allowed
      within an EAP conversation.  EAP methods may implement\n   result indications.
      \ After the authenticator sends a failure result\n   indication to the peer,
      regardless of the response from the peer, it\n   MUST subsequently send a Failure
      packet.  After the authenticator\n   sends a success result indication to the
      peer and receives a success\n   result indication from the peer, it MUST subsequently
      send a Success\n   packet.\n   On the peer, once the method completes unsuccessfully
      (that is,\n   either the authenticator sends a failure result indication, or
      the\n   peer decides that it does not want to continue the conversation,\n   possibly
      after sending a failure result indication), the peer MUST\n   terminate the
      conversation and indicate failure to the lower layer.\n   The peer MUST silently
      discard Success packets and MAY silently\n   discard Failure packets.  As a
      result, loss of a Failure packet need\n   not result in a timeout.\n   On the
      peer, after success result indications have been exchanged by\n   both sides,
      a Failure packet MUST be silently discarded.  The peer\n   MAY, in the event
      that an EAP Success is not received, conclude that\n   the EAP Success packet
      was lost and that authentication concluded\n   successfully.\n   If the authenticator
      has not sent a result indication, and the peer\n   is willing to continue the
      conversation, the peer waits for a Success\n   or Failure packet once the method
      completes, and MUST NOT silently\n   discard either of them.  In the event that
      neither a Success nor\n   Failure packet is received, the peer SHOULD terminate
      the\n   conversation to avoid lengthy timeouts in case the lost packet was an\n
      \  EAP Failure.\n   If the peer attempts to authenticate to the authenticator
      and fails\n   to do so, the authenticator MUST send a Failure packet and MUST
      NOT\n   grant access by sending a Success packet.  However, an authenticator\n
      \  MAY omit having the peer authenticate to it in situations where\n   limited
      access is offered (e.g., guest access).  In this case, the\n   authenticator
      MUST send a Success packet.\n   Where the peer authenticates successfully to
      the authenticator, but\n   the authenticator does not send a result indication,
      the\n   authenticator MAY deny access by sending a Failure packet where the\n
      \  peer is not currently authorized for network access.\n   A summary of the
      Success and Failure packet format is shown below.\n   The fields are transmitted
      from left to right.\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Code      |  Identifier   |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Code\n      3 for Success\n      4 for Failure\n   Identifier\n      The
      Identifier field is one octet and aids in matching replies to\n      Responses.
      \ The Identifier field MUST match the Identifier field\n      of the Response
      packet that it is sent in response to.\n   Length\n      4\n"
    title: 4.2.  Success and Failure
  - contents:
    - "4.3.  Retransmission Behavior\n   Because the authentication process will often
      involve user input,\n   some care must be taken when deciding upon retransmission
      strategies\n   and authentication timeouts.  By default, where EAP is run over
      an\n   unreliable lower layer, the EAP retransmission timer SHOULD be\n   dynamically
      estimated.  A maximum of 3-5 retransmissions is\n   suggested.\n   When run
      over a reliable lower layer (e.g., EAP over ISAKMP/TCP, as\n   within [PIC]),
      the authenticator retransmission timer SHOULD be set\n   to an infinite value,
      so that retransmissions do not occur at the EAP\n   layer.  The peer may still
      maintain a timeout value so as to avoid\n   waiting indefinitely for a Request.\n
      \  Where the authentication process requires user input, the measured\n   round
      trip times may be determined by user responsiveness rather than\n   network
      characteristics, so that dynamic RTO estimation may not be\n   helpful.  Instead,
      the retransmission timer SHOULD be set so as to\n   provide sufficient time
      for the user to respond, with longer timeouts\n   required in certain cases,
      such as where Token Cards (see Section\n   5.6) are involved.\n   In order to
      provide the EAP authenticator with guidance as to the\n   appropriate timeout
      value, a hint can be communicated to the\n   authenticator by the backend authentication
      server (such as via the\n   RADIUS Session-Timeout attribute).\n   In order
      to dynamically estimate the EAP retransmission timer, the\n   algorithms for
      the estimation of SRTT, RTTVAR, and RTO described in\n   [RFC2988] are RECOMMENDED,
      including use of Karn's algorithm, with\n   the following potential modifications:\n
      \  [a] In order to avoid synchronization behaviors that can occur with\n       fixed
      timers among distributed systems, the retransmission timer\n       is calculated
      with a jitter by using the RTO value and randomly\n       adding a value drawn
      between -RTOmin/2 and RTOmin/2.  Alternative\n       calculations to create
      jitter MAY be used.  These MUST be\n       pseudo-random.  For a discussion
      of pseudo-random number\n       generation, see [RFC1750].\n   [b] When EAP
      is transported over a single link (as opposed to over\n       the Internet),
      smaller values of RTOinitial, RTOmin, and RTOmax\n       MAY be used.  Recommended
      values are RTOinitial=1 second,\n       RTOmin=200ms, and RTOmax=20 seconds.\n
      \  [c] When EAP is transported over a single link (as opposed to over\n       the
      Internet), estimates MAY be done on a per-authenticator\n       basis, rather
      than a per-session basis.  This enables the\n       retransmission estimate
      to make the most use of information on\n       link-layer behavior.\n   [d]
      An EAP implementation MAY clear SRTT and RTTVAR after backing off\n       the
      timer multiple times, as it is likely that the current SRTT\n       and RTTVAR
      are bogus in this situation.  Once SRTT and RTTVAR are\n       cleared, they
      should be initialized with the next RTT sample\n       taken as described in
      [RFC2988] equation 2.2.\n"
    title: 4.3.  Retransmission Behavior
  title: 4.  EAP Packet Format
- contents:
  - "5.  Initial EAP Request/Response Types\n   This section defines the initial set
    of EAP Types used in Request/\n   Response exchanges.  More Types may be defined
    in future documents.\n   The Type field is one octet and identifies the structure
    of an EAP\n   Request or Response packet.  The first 3 Types are considered special\n
    \  case Types.\n   The remaining Types define authentication exchanges.  Nak (Type
    3) or\n   Expanded Nak (Type 254) are valid only for Response packets, they\n
    \  MUST NOT be sent in a Request.\n   All EAP implementations MUST support Types
    1-4, which are defined in\n   this document, and SHOULD support Type 254.  Implementations
    MAY\n   support other Types defined here or in future RFCs.\n             1       Identity\n
    \            2       Notification\n             3       Nak (Response only)\n
    \            4       MD5-Challenge\n             5       One Time Password (OTP)\n
    \            6       Generic Token Card (GTC)\n           254       Expanded Types\n
    \          255       Experimental use\n   EAP methods MAY support authentication
    based on shared secrets.  If\n   the shared secret is a passphrase entered by
    the user,\n   implementations MAY support entering passphrases with non-ASCII\n
    \  characters.  In this case, the input should be processed using an\n   appropriate
    stringprep [RFC3454] profile, and encoded in octets using\n   UTF-8 encoding [RFC2279].
    \ A preliminary version of a possible\n   stringprep profile is described in [SASLPREP].\n"
  - contents:
    - "5.1.  Identity\n   Description\n      The Identity Type is used to query the
      identity of the peer.\n      Generally, the authenticator will issue this as
      the initial\n      Request.  An optional displayable message MAY be included
      to\n      prompt the peer in the case where there is an expectation of\n      interaction
      with a user.  A Response of Type 1 (Identity) SHOULD\n      be sent in Response
      to a Request with a Type of 1 (Identity).\n      Some EAP implementations piggy-back
      various options into the\n      Identity Request after a NUL-character.  By
      default, an EAP\n      implementation SHOULD NOT assume that an Identity Request
      or\n      Response can be larger than 1020 octets.\n      It is RECOMMENDED
      that the Identity Response be used primarily for\n      routing purposes and
      selecting which EAP method to use.  EAP\n      Methods SHOULD include a method-specific
      mechanism for obtaining\n      the identity, so that they do not have to rely
      on the Identity\n      Response.  Identity Requests and Responses are sent in
      cleartext,\n      so an attacker may snoop on the identity, or even modify or
      spoof\n      identity exchanges.  To address these threats, it is preferable\n
      \     for an EAP method to include an identity exchange that supports\n      per-packet
      authentication, integrity and replay protection, and\n      confidentiality.
      \ The Identity Response may not be the appropriate\n      identity for the method;
      it may have been truncated or obfuscated\n      so as to provide privacy, or
      it may have been decorated for\n      routing purposes.  Where the peer is configured
      to only accept\n      authentication methods supporting protected identity exchanges,\n
      \     the peer MAY provide an abbreviated Identity Response (such as\n      omitting
      the peer-name portion of the NAI [RFC2486]).  For further\n      discussion
      of identity protection, see Section 7.3.\n   Implementation Note: The peer MAY
      obtain the Identity via user input.\n   It is suggested that the authenticator
      retry the Identity Request in\n   the case of an invalid Identity or authentication
      failure to allow\n   for potential typos on the part of the user.  It is suggested
      that\n   the Identity Request be retried a minimum of 3 times before\n   terminating
      the authentication.  The Notification Request MAY be used\n   to indicate an
      invalid authentication attempt prior to transmitting a\n   new Identity Request
      (optionally, the failure MAY be indicated within\n   the message of the new
      Identity Request itself).\n   Type\n      1\n   Type-Data\n      This field
      MAY contain a displayable message in the Request,\n      containing UTF-8 encoded
      ISO 10646 characters [RFC2279].  Where\n      the Request contains a null, only
      the portion of the field prior\n      to the null is displayed.  If the Identity
      is unknown, the\n      Identity Response field should be zero bytes in length.
      \ The\n      Identity Response field MUST NOT be null terminated.  In all\n
      \     cases, the length of the Type-Data field is derived from the\n      Length
      field of the Request/Response packet.\n   Security Claims (see Section 7.2):\n
      \     Auth. mechanism:           None\n      Ciphersuite negotiation:   No\n
      \     Mutual authentication:     No\n      Integrity protection:      No\n      Replay
      protection:         No\n      Confidentiality:           No\n      Key derivation:
      \           No\n      Key strength:              N/A\n      Dictionary attack
      prot.:   N/A\n      Fast reconnect:            No\n      Crypt. binding:            N/A\n
      \     Session independence:      N/A\n      Fragmentation:             No\n
      \     Channel binding:           No\n"
    title: 5.1.  Identity
  - contents:
    - "5.2.  Notification\n   Description\n      The Notification Type is optionally
      used to convey a displayable\n      message from the authenticator to the peer.
      \ An authenticator MAY\n      send a Notification Request to the peer at any
      time when there is\n      no outstanding Request, prior to completion of an
      EAP\n      authentication method.  The peer MUST respond to a Notification\n
      \     Request with a Notification Response unless the EAP authentication\n      method
      specification prohibits the use of Notification messages.\n      In any case,
      a Nak Response MUST NOT be sent in response to a\n      Notification Request.
      \ Note that the default maximum length of a\n      Notification Request is 1020
      octets.  By default, this leaves at\n      most 1015 octets for the human readable
      message.\n      An EAP method MAY indicate within its specification that\n      Notification
      messages must not be sent during that method.  In\n      this case, the peer
      MUST silently discard Notification Requests\n      from the point where an initial
      Request for that Type is answered\n      with a Response of the same Type.\n
      \     The peer SHOULD display this message to the user or log it if it\n      cannot
      be displayed.  The Notification Type is intended to provide\n      an acknowledged
      notification of some imperative nature, but it is\n      not an error indication,
      and therefore does not change the state\n      of the peer.  Examples include
      a password with an expiration time\n      that is about to expire, an OTP sequence
      integer which is nearing\n      0, an authentication failure warning, etc.  In
      most circumstances,\n      Notification should not be required.\n   Type\n      2\n
      \  Type-Data\n      The Type-Data field in the Request contains a displayable
      message\n      greater than zero octets in length, containing UTF-8 encoded
      ISO\n      10646 characters [RFC2279].  The length of the message is\n      determined
      by the Length field of the Request packet.  The message\n      MUST NOT be null
      terminated.  A Response MUST be sent in reply to\n      the Request with a Type
      field of 2 (Notification).  The Type-Data\n      field of the Response is zero
      octets in length.  The Response\n      should be sent immediately (independent
      of how the message is\n      displayed or logged).\n   Security Claims (see
      Section 7.2):\n      Auth. mechanism:           None\n      Ciphersuite negotiation:
      \  No\n      Mutual authentication:     No\n      Integrity protection:      No\n
      \     Replay protection:         No\n      Confidentiality:           No\n      Key
      derivation:            No\n      Key strength:              N/A\n      Dictionary
      attack prot.:   N/A\n      Fast reconnect:            No\n      Crypt. binding:
      \           N/A\n      Session independence:      N/A\n      Fragmentation:
      \            No\n      Channel binding:           No\n"
    title: 5.2.  Notification
  - contents:
    - '5.3.  Nak

      '
    - contents:
      - "5.3.1.  Legacy Nak\n   Description\n      The legacy Nak Type is valid only
        in Response messages.  It is\n      sent in reply to a Request where the desired
        authentication Type\n      is unacceptable.  Authentication Types are numbered
        4 and above.\n      The Response contains one or more authentication Types
        desired by\n      the Peer.  Type zero (0) is used to indicate that the sender
        has\n      no viable alternatives, and therefore the authenticator SHOULD
        NOT\n      send another Request after receiving a Nak Response containing
        a\n      zero value.\n      Since the legacy Nak Type is valid only in Responses
        and has very\n      limited functionality, it MUST NOT be used as a general
        purpose\n      error indication, such as for communication of error messages,
        or\n      negotiation of parameters specific to a particular EAP method.\n
        \  Code\n      2 for Response.\n   Identifier\n      The Identifier field
        is one octet and aids in matching Responses\n      with Requests.  The Identifier
        field of a legacy Nak Response MUST\n      match the Identifier field of the
        Request packet that it is sent\n      in response to.\n   Length\n      >=6\n
        \  Type\n      3\n   Type-Data\n      Where a peer receives a Request for
        an unacceptable authentication\n      Type (4-253,255), or a peer lacking
        support for Expanded Types\n      receives a Request for Type 254, a Nak Response
        (Type 3) MUST be\n      sent.  The Type-Data field of the Nak Response (Type
        3) MUST\n      contain one or more octets indicating the desired authentication\n
        \     Type(s), one octet per Type, or the value zero (0) to indicate no\n
        \     proposed alternative.  A peer supporting Expanded Types that\n      receives
        a Request for an unacceptable authentication Type (4-253,\n      255) MAY
        include the value 254 in the Nak Response (Type 3) to\n      indicate the
        desire for an Expanded authentication Type. If the\n      authenticator can
        accommodate this preference, it will respond\n      with an Expanded Type
        Request (Type 254).\n   Security Claims (see Section 7.2):\n      Auth. mechanism:
        \          None\n      Ciphersuite negotiation:   No\n      Mutual authentication:
        \    No\n      Integrity protection:      No\n      Replay protection:         No\n
        \     Confidentiality:           No\n      Key derivation:            No\n
        \     Key strength:              N/A\n      Dictionary attack prot.:   N/A\n
        \     Fast reconnect:            No\n      Crypt. binding:            N/A\n
        \     Session independence:      N/A\n      Fragmentation:             No\n
        \     Channel binding:           No\n"
      title: 5.3.1.  Legacy Nak
    - contents:
      - "5.3.2.  Expanded Nak\n   Description\n      The Expanded Nak Type is valid
        only in Response messages.  It MUST\n      be sent only in reply to a Request
        of Type 254 (Expanded Type)\n      where the authentication Type is unacceptable.
        \ The Expanded Nak\n      Type uses the Expanded Type format itself, and the
        Response\n      contains one or more authentication Types desired by the peer,
        all\n      in Expanded Type format.  Type zero (0) is used to indicate that\n
        \     the sender has no viable alternatives.  The general format of the\n
        \     Expanded Type is described in Section 5.7.\n      Since the Expanded
        Nak Type is valid only in Responses and has\n      very limited functionality,
        it MUST NOT be used as a general\n      purpose error indication, such as
        for communication of error\n      messages, or negotiation of parameters specific
        to a particular\n      EAP method.\n   Code\n      2 for Response.\n   Identifier\n
        \     The Identifier field is one octet and aids in matching Responses\n      with
        Requests.  The Identifier field of an Expanded Nak Response\n      MUST match
        the Identifier field of the Request packet that it is\n      sent in response
        to.\n   Length\n      >=20\n   Type\n      254\n   Vendor-Id\n      0 (IETF)\n
        \  Vendor-Type\n      3 (Nak)\n   Vendor-Data\n      The Expanded Nak Type
        is only sent when the Request contains an\n      Expanded Type (254) as defined
        in Section 5.7.  The Vendor-Data\n      field of the Nak Response MUST contain
        one or more authentication\n      Types (4 or greater), all in expanded format,
        8 octets per Type,\n      or the value zero (0), also in Expanded Type format,
        to indicate\n      no proposed alternative.  The desired authentication Types
        may\n      include a mixture of Vendor-Specific and IETF Types.  For example,\n
        \     an Expanded Nak Response indicating a preference for OTP (Type 5),\n
        \     and an MIT (Vendor-Id=20) Expanded Type of 6 would appear as\n      follows:\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |     2         |  Identifier   |           Length=28           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Type=254    |                0 (IETF)                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                3 (Nak)                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Type=254    |                0 (IETF)                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                5 (OTP)                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Type=254    |                20 (MIT)                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                6                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  An Expanded Nak Response indicating a no desired alternative would\n   appear
        as follows:\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |     2         |  Identifier   |           Length=20           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Type=254    |                0 (IETF)                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                3 (Nak)                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Type=254    |                0 (IETF)                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                0 (No alternative)             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Security Claims (see Section 7.2):\n      Auth. mechanism:           None\n
        \     Ciphersuite negotiation:   No\n      Mutual authentication:     No\n
        \     Integrity protection:      No\n      Replay protection:         No\n
        \     Confidentiality:           No\n      Key derivation:            No\n
        \     Key strength:              N/A\n      Dictionary attack prot.:   N/A\n
        \     Fast reconnect:            No\n      Crypt. binding:            N/A\n
        \     Session independence:      N/A\n      Fragmentation:             No\n
        \     Channel binding:           No\n"
      title: 5.3.2.  Expanded Nak
    title: 5.3.  Nak
  - contents:
    - "5.4.  MD5-Challenge\n   Description\n      The MD5-Challenge Type is analogous
      to the PPP CHAP protocol\n      [RFC1994] (with MD5 as the specified algorithm).
      \ The Request\n      contains a \"challenge\" message to the peer.  A Response
      MUST be\n      sent in reply to the Request.  The Response MAY be either of
      Type\n      4 (MD5-Challenge), Nak (Type 3), or Expanded Nak (Type 254).  The\n
      \     Nak reply indicates the peer's desired authentication Type(s).\n      EAP
      peer and EAP server implementations MUST support the MD5-\n      Challenge mechanism.
      \ An authenticator that supports only pass-\n      through MUST allow communication
      with a backend authentication\n      server that is capable of supporting MD5-Challenge,
      although the\n      EAP authenticator implementation need not support MD5-Challenge\n
      \     itself.  However, if the EAP authenticator can be configured to\n      authenticate
      peers locally (e.g., not operate in pass-through),\n      then the requirement
      for support of the MD5-Challenge mechanism\n      applies.\n      Note that
      the use of the Identifier field in the MD5-Challenge\n      Type is different
      from that described in [RFC1994].  EAP allows\n      for retransmission of MD5-Challenge
      Request packets, while\n      [RFC1994] states that both the Identifier and
      Challenge fields\n      MUST change each time a Challenge (the CHAP equivalent
      of the\n      MD5-Challenge Request packet) is sent.\n      Note: [RFC1994]
      treats the shared secret as an octet string, and\n      does not specify how
      it is entered into the system (or if it is\n      handled by the user at all).
      \ EAP MD5-Challenge implementations\n      MAY support entering passphrases
      with non-ASCII characters.  See\n      Section 5 for instructions how the input
      should be processed and\n      encoded into octets.\n   Type\n      4\n   Type-Data\n
      \     The contents of the Type-Data field is summarized below.  For\n      reference
      on the use of these fields, see the PPP Challenge\n      Handshake Authentication
      Protocol [RFC1994].\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Value-Size   |  Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Name ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Security Claims (see
      Section 7.2):\n      Auth. mechanism:           Password or pre-shared key.\n
      \     Ciphersuite negotiation:   No\n      Mutual authentication:     No\n      Integrity
      protection:      No\n      Replay protection:         No\n      Confidentiality:
      \          No\n      Key derivation:            No\n      Key strength:              N/A\n
      \     Dictionary attack prot.:   No\n      Fast reconnect:            No\n      Crypt.
      binding:            N/A\n      Session independence:      N/A\n      Fragmentation:
      \            No\n      Channel binding:           No\n"
    title: 5.4.  MD5-Challenge
  - contents:
    - "5.5.  One-Time Password (OTP)\n   Description\n      The One-Time Password
      system is defined in \"A One-Time Password\n      System\" [RFC2289] and \"OTP
      Extended Responses\" [RFC2243].  The\n      Request contains an OTP challenge
      in the format described in\n      [RFC2289].  A Response MUST be sent in reply
      to the Request.  The\n      Response MUST be of Type 5 (OTP), Nak (Type 3),
      or Expanded Nak\n      (Type 254).  The Nak Response indicates the peer's desired\n
      \     authentication Type(s).  The EAP OTP method is intended for use\n      with
      the One-Time Password system only, and MUST NOT be used to\n      provide support
      for cleartext passwords.\n   Type\n      5\n   Type-Data\n      The Type-Data
      field contains the OTP \"challenge\" as a displayable\n      message in the
      Request.  In the Response, this field is used for\n      the 6 words from the
      OTP dictionary [RFC2289].  The messages MUST\n      NOT be null terminated.
      \ The length of the field is derived from\n      the Length field of the Request/Reply
      packet.\n      Note: [RFC2289] does not specify how the secret pass-phrase is\n
      \     entered by the user, or how the pass-phrase is converted into\n      octets.
      \ EAP OTP implementations MAY support entering passphrases\n      with non-ASCII
      characters.  See Section 5 for instructions on how\n      the input should be
      processed and encoded into octets.\n   Security Claims (see Section 7.2):\n
      \     Auth. mechanism:           One-Time Password\n      Ciphersuite negotiation:
      \  No\n      Mutual authentication:     No\n      Integrity protection:      No\n
      \     Replay protection:         Yes\n      Confidentiality:           No\n
      \     Key derivation:            No\n      Key strength:              N/A\n
      \     Dictionary attack prot.:   No\n      Fast reconnect:            No\n      Crypt.
      binding:            N/A\n      Session independence:      N/A\n      Fragmentation:
      \            No\n      Channel binding:           No\n"
    title: 5.5.  One-Time Password (OTP)
  - contents:
    - "5.6.  Generic Token Card (GTC)\n   Description\n      The Generic Token Card
      Type is defined for use with various Token\n      Card implementations which
      require user input.  The Request\n      contains a displayable message and the
      Response contains the Token\n      Card information necessary for authentication.
      \ Typically, this\n      would be information read by a user from the Token
      card device and\n      entered as ASCII text.  A Response MUST be sent in reply
      to the\n      Request.  The Response MUST be of Type 6 (GTC), Nak (Type 3),
      or\n      Expanded Nak (Type 254).  The Nak Response indicates the peer's\n
      \     desired authentication Type(s).  The EAP GTC method is intended\n      for
      use with the Token Cards supporting challenge/response\n      authentication
      and MUST NOT be used to provide support for\n      cleartext passwords in the
      absence of a protected tunnel with\n      server authentication.\n   Type\n
      \     6\n   Type-Data\n      The Type-Data field in the Request contains a displayable
      message\n      greater than zero octets in length.  The length of the message
      is\n      determined by the Length field of the Request packet.  The message\n
      \     MUST NOT be null terminated.  A Response MUST be sent in reply to\n      the
      Request with a Type field of 6 (Generic Token Card).  The\n      Response contains
      data from the Token Card required for\n      authentication.  The length of
      the data is determined by the\n      Length field of the Response packet.\n
      \     EAP GTC implementations MAY support entering a response with non-\n      ASCII
      characters.  See Section 5 for instructions how the input\n      should be processed
      and encoded into octets.\n   Security Claims (see Section 7.2):\n      Auth.
      mechanism:           Hardware token.\n      Ciphersuite negotiation:   No\n
      \     Mutual authentication:     No\n      Integrity protection:      No\n      Replay
      protection:         No\n      Confidentiality:           No\n      Key derivation:
      \           No\n      Key strength:              N/A\n      Dictionary attack
      prot.:   No\n      Fast reconnect:            No\n      Crypt. binding:            N/A\n
      \     Session independence:      N/A\n      Fragmentation:             No\n
      \     Channel binding:           No\n"
    title: 5.6.  Generic Token Card (GTC)
  - contents:
    - "5.7.  Expanded Types\n   Description\n      Since many of the existing uses
      of EAP are vendor-specific, the\n      Expanded method Type is available to
      allow vendors to support\n      their own Expanded Types not suitable for general
      usage.\n      The Expanded Type is also used to expand the global Method Type\n
      \     space beyond the original 255 values.  A Vendor-Id of 0 maps the\n      original
      255 possible Types onto a space of 2^32-1 possible Types.\n      (Type 0 is
      only used in a Nak Response to indicate no acceptable\n      alternative).\n
      \     An implementation that supports the Expanded attribute MUST treat\n      EAP
      Types that are less than 256 equivalently, whether they appear\n      as a single
      octet or as the 32-bit Vendor-Type within an Expanded\n      Type where Vendor-Id
      is 0.  Peers not equipped to interpret the\n      Expanded Type MUST send a
      Nak as described in Section 5.3.1, and\n      negotiate a more suitable authentication
      method.\n      A summary of the Expanded Type format is shown below.  The fields\n
      \     are transmitted from left to right.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |               Vendor-Id                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                          Vendor-Type                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |              Vendor data...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type\n      254 for Expanded Type\n   Vendor-Id\n      The Vendor-Id is 3
      octets and represents the SMI Network\n      Management Private Enterprise Code
      of the Vendor in network byte\n      order, as allocated by IANA.  A Vendor-Id
      of zero is reserved for\n      use by the IETF in providing an expanded global
      EAP Type space.\n   Vendor-Type\n      The Vendor-Type field is four octets
      and represents the vendor-\n      specific method Type.\n      If the Vendor-Id
      is zero, the Vendor-Type field is an extension\n      and superset of the existing
      namespace for EAP Types.  The first\n      256 Types are reserved for compatibility
      with single-octet EAP\n      Types that have already been assigned or may be
      assigned in the\n      future.  Thus, EAP Types from 0 through 255 are semantically\n
      \     identical, whether they appear as single octet EAP Types or as\n      Vendor-Types
      when Vendor-Id is zero.  There is one exception to\n      this rule: Expanded
      Nak and Legacy Nak packets share the same\n      Type, but must be treated differently
      because they have a\n      different format.\n   Vendor-Data\n      The Vendor-Data
      field is defined by the vendor.  Where a Vendor-Id\n      of zero is present,
      the Vendor-Data field will be used for\n      transporting the contents of EAP
      methods of Types defined by the\n      IETF.\n"
    title: 5.7.  Expanded Types
  - contents:
    - "5.8.  Experimental\n   Description\n      The Experimental Type has no fixed
      format or content.  It is\n      intended for use when experimenting with new
      EAP Types.  This Type\n      is intended for experimental and testing purposes.
      \ No guarantee\n      is made for interoperability between peers using this
      Type, as\n      outlined in [RFC3692].\n   Type\n      255\n   Type-Data\n      Undefined\n"
    title: 5.8.  Experimental
  title: 5.  Initial EAP Request/Response Types
- contents:
  - "6.  IANA Considerations\n   This section provides guidance to the Internet Assigned
    Numbers\n   Authority (IANA) regarding registration of values related to the EAP\n
    \  protocol, in accordance with BCP 26, [RFC2434].\n   There are two name spaces
    in EAP that require registration: Packet\n   Codes and method Types.\n   EAP is
    not intended as a general-purpose protocol, and allocations\n   SHOULD NOT be
    made for purposes unrelated to authentication.\n   The following terms are used
    here with the meanings defined in BCP\n   26: \"name space\", \"assigned value\",
    \"registration\".\n   The following policies are used here with the meanings defined
    in BCP\n   26: \"Private Use\", \"First Come First Served\", \"Expert Review\",\n
    \  \"Specification Required\", \"IETF Consensus\", \"Standards Action\".\n   For
    registration requests where a Designated Expert should be\n   consulted, the responsible
    IESG area director should appoint the\n   Designated Expert.  The intention is
    that any allocation will be\n   accompanied by a published RFC.  But in order
    to allow for the\n   allocation of values prior to the RFC being approved for
    publication,\n   the Designated Expert can approve allocations once it seems clear\n
    \  that an RFC will be published.  The Designated expert will post a\n   request
    to the EAP WG mailing list (or a successor designated by the\n   Area Director)
    for comment and review, including an Internet-Draft.\n   Before a period of 30
    days has passed, the Designated Expert will\n   either approve or deny the registration
    request and publish a notice\n   of the decision to the EAP WG mailing list or
    its successor, as well\n   as informing IANA.  A denial notice must be justified
    by an\n   explanation, and in the cases where it is possible, concrete\n   suggestions
    on how the request can be modified so as to become\n   acceptable should be provided.\n"
  - contents:
    - "6.1.  Packet Codes\n   Packet Codes have a range from 1 to 255, of which 1-4
      have been\n   allocated.  Because a new Packet Code has considerable impact
      on\n   interoperability, a new Packet Code requires Standards Action, and\n
      \  should be allocated starting at 5.\n"
    title: 6.1.  Packet Codes
  - contents:
    - "6.2.  Method Types\n   The original EAP method Type space has a range from
      1 to 255, and is\n   the scarcest resource in EAP, and thus must be allocated
      with care.\n   Method Types 1-45 have been allocated, with 20 available for
      re-use.\n   Method Types 20 and 46-191 may be allocated on the advice of a\n
      \  Designated Expert, with Specification Required.\n   Allocation of blocks
      of method Types (more than one for a given\n   purpose) should require IETF
      Consensus.  EAP Type Values 192-253 are\n   reserved and allocation requires
      Standards Action.\n   Method Type 254 is allocated for the Expanded Type.  Where
      the\n   Vendor-Id field is non-zero, the Expanded Type is used for functions\n
      \  specific only to one vendor's implementation of EAP, where no\n   interoperability
      is deemed useful.  When used with a Vendor-Id of\n   zero, method Type 254 can
      also be used to provide for an expanded\n   IETF method Type space.  Method
      Type values 256-4294967295 may be\n   allocated after Type values 1-191 have
      been allocated, on the advice\n   of a Designated Expert, with Specification
      Required.\n   Method Type 255 is allocated for Experimental use, such as testing
      of\n   new EAP methods before a permanent Type is allocated.\n"
    title: 6.2.  Method Types
  title: 6.  IANA Considerations
- contents:
  - "7.  Security Considerations\n   This section defines a generic threat model as
    well as the EAP method\n   security claims mitigating those threats.\n   It is
    expected that the generic threat model and corresponding\n   security claims will
    used to define EAP method requirements for use\n   in specific environments.  An
    example of such a requirements analysis\n   is provided in [IEEE-802.11i-req].
    \ A security claims section is\n   required in EAP method specifications, so that
    EAP methods can be\n   evaluated against the requirements.\n"
  - contents:
    - "7.1.  Threat Model\n   EAP was developed for use with PPP [RFC1661] and was
      later adapted\n   for use in wired IEEE 802 networks [IEEE-802] in [IEEE-802.1X].\n
      \  Subsequently, EAP has been proposed for use on wireless LAN networks\n   and
      over the Internet.  In all these situations, it is possible for\n   an attacker
      to gain access to links over which EAP packets are\n   transmitted.  For example,
      attacks on telephone infrastructure are\n   documented in [DECEPTION].\n   An
      attacker with access to the link may carry out a number of\n   attacks, including:\n
      \  [1]  An attacker may try to discover user identities by snooping\n        authentication
      traffic.\n   [2]  An attacker may try to modify or spoof EAP packets.\n   [3]
      \ An attacker may launch denial of service attacks by spoofing\n        lower
      layer indications or Success/Failure packets, by replaying\n        EAP packets,
      or by generating packets with overlapping\n        Identifiers.\n   [4]  An
      attacker may attempt to recover the pass-phrase by mounting\n        an offline
      dictionary attack.\n   [5]  An attacker may attempt to convince the peer to
      connect to an\n        untrusted network by mounting a man-in-the-middle attack.\n
      \  [6]  An attacker may attempt to disrupt the EAP negotiation in order\n        cause
      a weak authentication method to be selected.\n   [7]  An attacker may attempt
      to recover keys by taking advantage of\n        weak key derivation techniques
      used within EAP methods.\n   [8]  An attacker may attempt to take advantage
      of weak ciphersuites\n        subsequently used after the EAP conversation is
      complete.\n   [9]  An attacker may attempt to perform downgrading attacks on
      lower\n        layer ciphersuite negotiation in order to ensure that a weaker\n
      \       ciphersuite is used subsequently to EAP authentication.\n   [10] An
      attacker acting as an authenticator may provide incorrect\n        information
      to the EAP peer and/or server via out-of-band\n        mechanisms (such as via
      a AAA or lower layer protocol).  This\n        includes impersonating another
      authenticator, or providing\n        inconsistent information to the peer and
      EAP server.\n   Depending on the lower layer, these attacks may be carried out\n
      \  without requiring physical proximity.  Where EAP is used over\n   wireless
      networks, EAP packets may be forwarded by authenticators\n   (e.g., pre-authentication)
      so that the attacker need not be within\n   the coverage area of an authenticator
      in order to carry out an attack\n   on it or its peers.  Where EAP is used over
      the Internet, attacks may\n   be carried out at an even greater distance.\n"
    title: 7.1.  Threat Model
  - contents:
    - "7.2.  Security Claims\n   In order to clearly articulate the security provided
      by an EAP\n   method, EAP method specifications MUST include a Security Claims\n
      \  section, including the following declarations:\n   [a] Mechanism.  This is
      a statement of the authentication technology:\n       certificates, pre-shared
      keys, passwords, token cards, etc.\n   [b] Security claims.  This is a statement
      of the claimed security\n       properties of the method, using terms defined
      in Section 7.2.1:\n       mutual authentication, integrity protection, replay
      protection,\n       confidentiality, key derivation, dictionary attack resistance,\n
      \      fast reconnect, cryptographic binding.  The Security Claims\n       section
      of an EAP method specification SHOULD provide\n       justification for the
      claims that are made.  This can be\n       accomplished by including a proof
      in an Appendix, or including a\n       reference to a proof.\n   [c] Key strength.
      \ If the method derives keys, then the effective key\n       strength MUST be
      estimated.  This estimate is meant for potential\n       users of the method
      to determine if the keys produced are strong\n       enough for the intended
      application.\n       The effective key strength SHOULD be stated as a number
      of bits,\n       defined as follows: If the effective key strength is N bits,
      the\n       best currently known methods to recover the key (with non-\n       negligible
      probability) require, on average, an effort comparable\n       to 2^(N-1) operations
      of a typical block cipher.  The statement\n       SHOULD be accompanied by a
      short rationale, explaining how this\n       number was derived.  This explanation
      SHOULD include the\n       parameters required to achieve the stated key strength
      based on\n       current knowledge of the algorithms.\n       (Note: Although
      it is difficult to define what \"comparable\n       effort\" and \"typical block
      cipher\" exactly mean, reasonable\n       approximations are sufficient here.
      \ Refer to e.g. [SILVERMAN]\n       for more discussion.)\n       The key strength
      depends on the methods used to derive the keys.\n       For instance, if keys
      are derived from a shared secret (such as a\n       password or a long-term
      secret), and possibly some public\n       information such as nonces, the effective
      key strength is limited\n       by the strength of the long-term secret (assuming
      that the\n       derivation procedure is computationally simple).  To take another\n
      \      example, when using public key algorithms, the strength of the\n       symmetric
      key depends on the strength of the public keys used.\n   [d] Description of
      key hierarchy.  EAP methods deriving keys MUST\n       either provide a reference
      to a key hierarchy specification, or\n       describe how Master Session Keys
      (MSKs) and Extended Master\n       Session Keys (EMSKs) are to be derived.\n
      \  [e] Indication of vulnerabilities.  In addition to the security\n       claims
      that are made, the specification MUST indicate which of\n       the security
      claims detailed in Section 7.2.1 are NOT being made.\n"
    - contents:
      - "7.2.1.  Security Claims Terminology for EAP Methods\n   These terms are used
        to describe the security properties of EAP\n   methods:\n   Protected ciphersuite
        negotiation\n      This refers to the ability of an EAP method to negotiate
        the\n      ciphersuite used to protect the EAP conversation, as well as to\n
        \     integrity protect the negotiation.  It does not refer to the\n      ability
        to negotiate the ciphersuite used to protect data.\n   Mutual authentication\n
        \     This refers to an EAP method in which, within an interlocked\n      exchange,
        the authenticator authenticates the peer and the peer\n      authenticates
        the authenticator.  Two independent one-way methods,\n      running in opposite
        directions do not provide mutual\n      authentication as defined here.\n
        \  Integrity protection\n      This refers to providing data origin authentication
        and protection\n      against unauthorized modification of information for
        EAP packets\n      (including EAP Requests and Responses).  When making this
        claim, a\n      method specification MUST describe the EAP packets and fields\n
        \     within the EAP packet that are protected.\n   Replay protection\n      This
        refers to protection against replay of an EAP method or its\n      messages,
        including success and failure result indications.\n   Confidentiality\n      This
        refers to encryption of EAP messages, including EAP Requests\n      and Responses,
        and success and failure result indications.  A\n      method making this claim
        MUST support identity protection (see\n      Section 7.3).\n   Key derivation\n
        \     This refers to the ability of the EAP method to derive exportable\n
        \     keying material, such as the Master Session Key (MSK), and\n      Extended
        Master Session Key (EMSK).  The MSK is used only for\n      further key derivation,
        not directly for protection of the EAP\n      conversation or subsequent data.
        \ Use of the EMSK is reserved.\n   Key strength\n      If the effective key
        strength is N bits, the best currently known\n      methods to recover the
        key (with non-negligible probability)\n      require, on average, an effort
        comparable to 2^(N-1) operations of\n      a typical block cipher.\n   Dictionary
        attack resistance\n      Where password authentication is used, passwords
        are commonly\n      selected from a small set (as compared to a set of N-bit
        keys),\n      which raises a concern about dictionary attacks.  A method may
        be\n      said to provide protection against dictionary attacks if, when it\n
        \     uses a password as a secret, the method does not allow an offline\n
        \     attack that has a work factor based on the number of passwords in\n
        \     an attacker's dictionary.\n   Fast reconnect\n      The ability, in
        the case where a security association has been\n      previously established,
        to create a new or refreshed security\n      association more efficiently
        or in a smaller number of round-\n      trips.\n   Cryptographic binding\n
        \     The demonstration of the EAP peer to the EAP server that a single\n
        \     entity has acted as the EAP peer for all methods executed within a\n
        \     tunnel method.  Binding MAY also imply that the EAP server\n      demonstrates
        to the peer that a single entity has acted as the EAP\n      server for all
        methods executed within a tunnel method.  If\n      executed correctly, binding
        serves to mitigate man-in-the-middle\n      vulnerabilities.\n   Session independence\n
        \     The demonstration that passive attacks (such as capture of the EAP\n
        \     conversation) or active attacks (including compromise of the MSK\n      or
        EMSK) does not enable compromise of subsequent or prior MSKs or\n      EMSKs.\n
        \  Fragmentation\n      This refers to whether an EAP method supports fragmentation
        and\n      reassembly.  As noted in Section 3.1, EAP methods should support\n
        \     fragmentation and reassembly if EAP packets can exceed the minimum\n
        \     MTU of 1020 octets.\n   Channel binding\n      The communication within
        an EAP method of integrity-protected\n      channel properties such as endpoint
        identifiers which can be\n      compared to values communicated via out of
        band mechanisms (such\n      as via a AAA or lower layer protocol).\n   Note:
        This list of security claims is not exhaustive.  Additional\n   properties,
        such as additional denial-of-service protection, may be\n   relevant as well.\n"
      title: 7.2.1.  Security Claims Terminology for EAP Methods
    title: 7.2.  Security Claims
  - contents:
    - "7.3.  Identity Protection\n   An Identity exchange is optional within the EAP
      conversation.\n   Therefore, it is possible to omit the Identity exchange entirely,
      or\n   to use a method-specific identity exchange once a protected channel\n
      \  has been established.\n   However, where roaming is supported as described
      in [RFC2607], it may\n   be necessary to locate the appropriate backend authentication
      server\n   before the authentication conversation can proceed.  The realm\n
      \  portion of the Network Access Identifier (NAI) [RFC2486] is typically\n   included
      within the EAP-Response/Identity in order to enable the\n   authentication exchange
      to be routed to the appropriate backend\n   authentication server.  Therefore,
      while the peer-name portion of the\n   NAI may be omitted in the EAP-Response/Identity
      where proxies or\n   relays are present, the realm portion may be required.\n
      \  It is possible for the identity in the identity response to be\n   different
      from the identity authenticated by the EAP method.  This\n   may be intentional
      in the case of identity privacy.  An EAP method\n   SHOULD use the authenticated
      identity when making access control\n   decisions.\n"
    title: 7.3.  Identity Protection
  - contents:
    - "7.4.  Man-in-the-Middle Attacks\n   Where EAP is tunneled within another protocol
      that omits peer\n   authentication, there exists a potential vulnerability to
      a man-in-\n   the-middle attack.  For details, see [BINDING] and [MITM].\n   As
      noted in Section 2.1, EAP does not permit untunneled sequences of\n   authentication
      methods.  Were a sequence of EAP authentication\n   methods to be permitted,
      the peer might not have proof that a single\n   entity has acted as the authenticator
      for all EAP methods within the\n   sequence.  For example, an authenticator
      might terminate one EAP\n   method, then forward the next method in the sequence
      to another party\n   without the peer's knowledge or consent.  Similarly, the\n
      \  authenticator might not have proof that a single entity has acted as\n   the
      peer for all EAP methods within the sequence.\n   Tunneling EAP within another
      protocol enables an attack by a rogue\n   EAP authenticator tunneling EAP to
      a legitimate server.  Where the\n   tunneling protocol is used for key establishment
      but does not require\n   peer authentication, an attacker convincing a legitimate
      peer to\n   connect to it will be able to tunnel EAP packets to a legitimate\n
      \  server, successfully authenticating and obtaining the key.  This\n   allows
      the attacker to successfully establish itself as a man-in-\n   the-middle, gaining
      access to the network, as well as the ability to\n   decrypt data traffic between
      the legitimate peer and server.\n   This attack may be mitigated by the following
      measures:\n   [a] Requiring mutual authentication within EAP tunneling mechanisms.\n
      \  [b] Requiring cryptographic binding between the EAP tunneling\n       protocol
      and the tunneled EAP methods.  Where cryptographic\n       binding is supported,
      a mechanism is also needed to protect\n       against downgrade attacks that
      would bypass it.  For further\n       details on cryptographic binding, see
      [BINDING].\n   [c] Limiting the EAP methods authorized for use without protection,\n
      \      based on peer and authenticator policy.\n   [d] Avoiding the use of tunnels
      when a single, strong method is\n       available.\n"
    title: 7.4.  Man-in-the-Middle Attacks
  - contents:
    - "7.5.  Packet Modification Attacks\n   While EAP methods may support per-packet
      data origin authentication,\n   integrity, and replay protection, support is
      not provided within the\n   EAP layer.\n   Since the Identifier is only a single
      octet, it is easy to guess,\n   allowing an attacker to successfully inject
      or replay EAP packets.\n   An attacker may also modify EAP headers (Code, Identifier,
      Length,\n   Type) within EAP packets where the header is unprotected.  This
      could\n   cause packets to be inappropriately discarded or misinterpreted.\n
      \  To protect EAP packets against modification, spoofing, or replay,\n   methods
      supporting protected ciphersuite negotiation, mutual\n   authentication, and
      key derivation, as well as integrity and replay\n   protection, are recommended.
      \ See Section 7.2.1 for definitions of\n   these security claims.\n   Method-specific
      MICs may be used to provide protection.  If a per-\n   packet MIC is employed
      within an EAP method, then peers,\n   authentication servers, and authenticators
      not operating in pass-\n   through mode MUST validate the MIC.  MIC validation
      failures SHOULD\n   be logged.  Whether a MIC validation failure is considered
      a fatal\n   error or not is determined by the EAP method specification.\n   It
      is RECOMMENDED that methods providing integrity protection of EAP\n   packets
      include coverage of all the EAP header fields, including the\n   Code, Identifier,
      Length, Type, and Type-Data fields.\n   Since EAP messages of Types Identity,
      Notification, and Nak do not\n   include their own MIC, it may be desirable
      for the EAP method MIC to\n   cover information contained within these messages,
      as well as the\n   header of each EAP message.\n   To provide protection, EAP
      also may be encapsulated within a\n   protected channel created by protocols
      such as ISAKMP [RFC2408], as\n   is done in [IKEv2] or within TLS [RFC2246].
      \ However, as noted in\n   Section 7.4, EAP tunneling may result in a man-in-the-middle\n
      \  vulnerability.\n   Existing EAP methods define message integrity checks (MICs)
      that\n   cover more than one EAP packet.  For example, EAP-TLS [RFC2716]\n   defines
      a MIC over a TLS record that could be split into multiple\n   fragments; within
      the FINISHED message, the MIC is computed over\n   previous messages.  Where
      the MIC covers more than one EAP packet, a\n   MIC validation failure is typically
      considered a fatal error.\n   Within EAP-TLS [RFC2716], a MIC validation failure
      is treated as a\n   fatal error, since that is what is specified in TLS [RFC2246].\n
      \  However, it is also possible to develop EAP methods that support\n   per-packet
      MICs, and respond to verification failures by silently\n   discarding the offending
      packet.\n   In this document, descriptions of EAP message handling assume that\n
      \  per-packet MIC validation, where it occurs, is effectively performed\n   as
      though it occurs before sending any responses or changing the\n   state of the
      host which received the packet.\n"
    title: 7.5.  Packet Modification Attacks
  - contents:
    - "7.6.  Dictionary Attacks\n   Password authentication algorithms such as EAP-MD5,
      MS-CHAPv1\n   [RFC2433], and Kerberos V [RFC1510] are known to be vulnerable
      to\n   dictionary attacks.  MS-CHAPv1 vulnerabilities are documented in\n   [PPTPv1];
      MS-CHAPv2 vulnerabilities are documented in [PPTPv2];\n   Kerberos vulnerabilities
      are described in [KRBATTACK], [KRBLIM], and\n   [KERB4WEAK].\n   In order to
      protect against dictionary attacks, authentication\n   methods resistant to
      dictionary attacks (as defined in Section 7.2.1)\n   are recommended.\n   If
      an authentication algorithm is used that is known to be vulnerable\n   to dictionary
      attacks, then the conversation may be tunneled within a\n   protected channel
      in order to provide additional protection.\n   However, as noted in Section
      7.4, EAP tunneling may result in a man-\n   in-the-middle vulnerability, and
      therefore dictionary attack\n   resistant methods are preferred.\n"
    title: 7.6.  Dictionary Attacks
  - contents:
    - "7.7.  Connection to an Untrusted Network\n   With EAP methods supporting one-way
      authentication, such as EAP-MD5,\n   the peer does not authenticate the authenticator,
      making the peer\n   vulnerable to attack by a rogue authenticator.  Methods
      supporting\n   mutual authentication (as defined in Section 7.2.1) address this\n
      \  vulnerability.\n   In EAP there is no requirement that authentication be
      full duplex or\n   that the same protocol be used in both directions.  It is
      perfectly\n   acceptable for different protocols to be used in each direction.\n
      \  This will, of course, depend on the specific protocols negotiated.\n   However,
      in general, completing a single unitary mutual\n   authentication is preferable
      to two one-way authentications, one in\n   each direction.  This is because
      separate authentications that are\n   not bound cryptographically so as to demonstrate
      they are part of the\n   same session are subject to man-in-the-middle attacks,
      as discussed\n   in Section 7.4.\n"
    title: 7.7.  Connection to an Untrusted Network
  - contents:
    - "7.8.  Negotiation Attacks\n   In a negotiation attack, the attacker attempts
      to convince the peer\n   and authenticator to negotiate a less secure EAP method.
      \ EAP does\n   not provide protection for Nak Response packets, although it
      is\n   possible for a method to include coverage of Nak Responses within a\n
      \  method-specific MIC.\n   Within or associated with each authenticator, it
      is not anticipated\n   that a particular named peer will support a choice of
      methods.  This\n   would make the peer vulnerable to attacks that negotiate
      the least\n   secure method from among a set.  Instead, for each named peer,
      there\n   SHOULD be an indication of exactly one method used to authenticate\n
      \  that peer name.  If a peer needs to make use of different\n   authentication
      methods under different circumstances, then distinct\n   identities SHOULD be
      employed, each of which identifies exactly one\n   authentication method.\n"
    title: 7.8.  Negotiation Attacks
  - contents:
    - "7.9.  Implementation Idiosyncrasies\n   The interaction of EAP with lower layers
      such as PPP and IEEE 802 are\n   highly implementation dependent.\n   For example,
      upon failure of authentication, some PPP implementations\n   do not terminate
      the link, instead limiting traffic in Network-Layer\n   Protocols to a filtered
      subset, which in turn allows the peer the\n   opportunity to update secrets
      or send mail to the network\n   administrator indicating a problem.  Similarly,
      while an\n   authentication failure will result in denied access to the controlled\n
      \  port in [IEEE-802.1X], limited traffic may be permitted on the\n   uncontrolled
      port.\n   In EAP there is no provision for retries of failed authentication.\n
      \  However, in PPP the LCP state machine can renegotiate the\n   authentication
      protocol at any time, thus allowing a new attempt.\n   Similarly, in IEEE 802.1X
      the Supplicant or Authenticator can re-\n   authenticate at any time.  It is
      recommended that any counters used\n   for authentication failure not be reset
      until after successful\n   authentication, or subsequent termination of the
      failed link.\n"
    title: 7.9.  Implementation Idiosyncrasies
  - contents:
    - "7.10.  Key Derivation\n   It is possible for the peer and EAP server to mutually
      authenticate\n   and derive keys.  In order to provide keying material for use
      in a\n   subsequently negotiated ciphersuite, an EAP method supporting key\n
      \  derivation MUST export a Master Session Key (MSK) of at least 64\n   octets,
      and an Extended Master Session Key (EMSK) of at least 64\n   octets.  EAP Methods
      deriving keys MUST provide for mutual\n   authentication between the EAP peer
      and the EAP Server.\n   The MSK and EMSK MUST NOT be used directly to protect
      data; however,\n   they are of sufficient size to enable derivation of a AAA-Key\n
      \  subsequently used to derive Transient Session Keys (TSKs) for use\n   with
      the selected ciphersuite.  Each ciphersuite is responsible for\n   specifying
      how to derive the TSKs from the AAA-Key.\n   The AAA-Key is derived from the
      keying material exported by the EAP\n   method (MSK and EMSK).  This derivation
      occurs on the AAA server.  In\n   many existing protocols that use EAP, the
      AAA-Key and MSK are\n   equivalent, but more complicated mechanisms are possible
      (see\n   [KEYFRAME] for details).\n   EAP methods SHOULD ensure the freshness
      of the MSK and EMSK, even in\n   cases where one party may not have a high quality
      random number\n   generator.  A RECOMMENDED method is for each party to provide
      a nonce\n   of at least 128 bits, used in the derivation of the MSK and EMSK.\n
      \  EAP methods export the MSK and EMSK, but not Transient Session Keys\n   so
      as to allow EAP methods to be ciphersuite and media independent.\n   Keying
      material exported by EAP methods MUST be independent of the\n   ciphersuite
      negotiated to protect data.\n   Depending on the lower layer, EAP methods may
      run before or after\n   ciphersuite negotiation, so that the selected ciphersuite
      may not be\n   known to the EAP method.  By providing keying material usable
      with\n   any ciphersuite, EAP methods can used with a wide range of\n   ciphersuites
      and media.\n   In order to preserve algorithm independence, EAP methods deriving\n
      \  keys SHOULD support (and document) the protected negotiation of the\n   ciphersuite
      used to protect the EAP conversation between the peer and\n   server.  This
      is distinct from the ciphersuite negotiated between the\n   peer and authenticator,
      used to protect data.\n   The strength of Transient Session Keys (TSKs) used
      to protect data is\n   ultimately dependent on the strength of keys generated
      by the EAP\n   method.  If an EAP method cannot produce keying material of\n
      \  sufficient strength, then the TSKs may be subject to a brute force\n   attack.
      \ In order to enable deployments requiring strong keys, EAP\n   methods supporting
      key derivation SHOULD be capable of generating an\n   MSK and EMSK, each with
      an effective key strength of at least 128\n   bits.\n   Methods supporting key
      derivation MUST demonstrate cryptographic\n   separation between the MSK and
      EMSK branches of the EAP key\n   hierarchy.  Without violating a fundamental
      cryptographic assumption\n   (such as the non-invertibility of a one-way function),
      an attacker\n   recovering the MSK or EMSK MUST NOT be able to recover the other\n
      \  quantity with a level of effort less than brute force.\n   Non-overlapping
      substrings of the MSK MUST be cryptographically\n   separate from each other,
      as defined in Section 7.2.1.  That is,\n   knowledge of one substring MUST NOT
      help in recovering some other\n   substring without breaking some hard cryptographic
      assumption.  This\n   is required because some existing ciphersuites form TSKs
      by simply\n   splitting the AAA-Key to pieces of appropriate length.  Likewise,\n
      \  non-overlapping substrings of the EMSK MUST be cryptographically\n   separate
      from each other, and from substrings of the MSK.\n   The EMSK is reserved for
      future use and MUST remain on the EAP peer\n   and EAP server where it is derived;
      it MUST NOT be transported to, or\n   shared with, additional parties, or used
      to derive any other keys.\n   (This restriction will be relaxed in a future
      document that specifies\n   how the EMSK can be used.)\n   Since EAP does not
      provide for explicit key lifetime negotiation, EAP\n   peers, authenticators,
      and authentication servers MUST be prepared\n   for situations in which one
      of the parties discards the key state,\n   which remains valid on another party.\n
      \  This specification does not provide detailed guidance on how EAP\n   methods
      derive the MSK and EMSK, how the AAA-Key is derived from the\n   MSK and/or
      EMSK, or how the TSKs are derived from the AAA-Key.\n   The development and
      validation of key derivation algorithms is\n   difficult, and as a result, EAP
      methods SHOULD re-use well\n   established and analyzed mechanisms for key derivation
      (such as those\n   specified in IKE [RFC2409] or TLS [RFC2246]), rather than
      inventing\n   new ones. EAP methods SHOULD also utilize well established and\n
      \  analyzed mechanisms for MSK and EMSK derivation.  Further details on\n   EAP
      Key Derivation are provided within [KEYFRAME].\n"
    title: 7.10.  Key Derivation
  - contents:
    - "7.11.  Weak Ciphersuites\n   If after the initial EAP authentication, data
      packets are sent\n   without per-packet authentication, integrity, and replay
      protection,\n   an attacker with access to the media can inject packets, \"flip
      bits\"\n   within existing packets, replay packets, or even hijack the session\n
      \  completely.  Without per-packet confidentiality, it is possible to\n   snoop
      data packets.\n   To protect against data modification, spoofing, or snooping,
      it is\n   recommended that EAP methods supporting mutual authentication and
      key\n   derivation (as defined by Section 7.2.1) be used, along with lower\n
      \  layers providing per-packet confidentiality, authentication,\n   integrity,
      and replay protection.\n   Additionally, if the lower layer performs ciphersuite
      negotiation, it\n   should be understood that EAP does not provide by itself
      integrity\n   protection of that negotiation.  Therefore, in order to avoid\n
      \  downgrading attacks which would lead to weaker ciphersuites being\n   used,
      clients implementing lower layer ciphersuite negotiation SHOULD\n   protect
      against negotiation downgrading.\n   This can be done by enabling users to configure
      which ciphersuites\n   are acceptable as a matter of security policy, or the
      ciphersuite\n   negotiation MAY be authenticated using keying material derived
      from\n   the EAP authentication and a MIC algorithm agreed upon in advance by\n
      \  lower-layer peers.\n"
    title: 7.11.  Weak Ciphersuites
  - contents:
    - "7.12.  Link Layer\n   There are reliability and security issues with link layer
      indications\n   in PPP, IEEE 802 LANs, and IEEE 802.11 wireless LANs:\n   [a]
      PPP.  In PPP, link layer indications such as LCP-Terminate (a\n       link failure
      indication) and NCP (a link success indication) are\n       not authenticated
      or integrity protected.  They can therefore be\n       spoofed by an attacker
      with access to the link.\n   [b] IEEE 802.  IEEE 802.1X EAPOL-Start and EAPOL-Logoff
      frames are\n       not authenticated or integrity protected.  They can therefore
      be\n       spoofed by an attacker with access to the link.\n   [c] IEEE 802.11.
      \ In IEEE 802.11, link layer indications include\n       Disassociate and Deauthenticate
      frames (link failure\n       indications), and the first message of the 4-way
      handshake (link\n       success indication).  These messages are not authenticated
      or\n       integrity protected, and although they are not forwardable, they\n
      \      are spoofable by an attacker within range.\n   In IEEE 802.11, IEEE 802.1X
      data frames may be sent as Class 3\n   unicast data frames, and are therefore
      forwardable.  This implies\n   that while EAPOL-Start and EAPOL-Logoff messages
      may be authenticated\n   and integrity protected, they can be spoofed by an
      authenticated\n   attacker far from the target when \"pre-authentication\" is
      enabled.\n   In IEEE 802.11, a \"link down\" indication is an unreliable indication\n
      \  of link failure, since wireless signal strength can come and go and\n   may
      be influenced by radio frequency interference generated by an\n   attacker.
      \ To avoid unnecessary resets, it is advisable to damp these\n   indications,
      rather than passing them directly to the EAP.  Since EAP\n   supports retransmission,
      it is robust against transient connectivity\n   losses.\n"
    title: 7.12.  Link Layer
  - contents:
    - "7.13.  Separation of Authenticator and Backend Authentication Server\n   It
      is possible for the EAP peer and EAP server to mutually\n   authenticate and
      derive a AAA-Key for a ciphersuite used to protect\n   subsequent data traffic.
      \ This does not present an issue on the peer,\n   since the peer and EAP client
      reside on the same machine; all that is\n   required is for the client to derive
      the AAA-Key from the MSK and\n   EMSK exported by the EAP method, and to subsequently
      pass a Transient\n   Session Key (TSK) to the ciphersuite module.\n   However,
      in the case where the authenticator and authentication\n   server reside on
      different machines, there are several implications\n   for security.\n   [a]
      Authentication will occur between the peer and the authentication\n       server,
      not between the peer and the authenticator.  This means\n       that it is not
      possible for the peer to validate the identity of\n       the authenticator
      that it is speaking to, using EAP alone.\n   [b] As discussed in [RFC3579],
      the authenticator is dependent on the\n       AAA protocol in order to know
      the outcome of an authentication\n       conversation, and does not look at
      the encapsulated EAP packet\n       (if one is present) to determine the outcome.
      \ In practice, this\n       implies that the AAA protocol spoken between the
      authenticator\n       and authentication server MUST support per-packet authentication,\n
      \      integrity, and replay protection.\n   [c] After completion of the EAP
      conversation, where lower layer\n       security services such as per-packet
      confidentiality,\n       authentication, integrity, and replay protection will
      be enabled,\n       a secure association protocol SHOULD be run between the
      peer and\n       authenticator in order to provide mutual authentication between\n
      \      the peer and authenticator, guarantee liveness of transient\n       session
      keys, provide protected ciphersuite and capabilities\n       negotiation for
      subsequent data, and synchronize key usage.\n   [d] A AAA-Key derived from the
      MSK and/or EMSK negotiated between the\n       peer and authentication server
      MAY be transmitted to the\n       authenticator.  Therefore, a mechanism needs
      to be provided to\n       transmit the AAA-Key from the authentication server
      to the\n       authenticator that needs it.  The specification of the AAA-key\n
      \      derivation, transport, and wrapping mechanisms is outside the\n       scope
      of this document.  Further details on AAA-Key Derivation\n       are provided
      within [KEYFRAME].\n"
    title: 7.13.  Separation of Authenticator and Backend Authentication Server
  - contents:
    - "7.14.  Cleartext Passwords\n   This specification does not define a mechanism
      for cleartext password\n   authentication.  The omission is intentional.  Use
      of cleartext\n   passwords would allow the password to be captured by an attacker
      with\n   access to a link over which EAP packets are transmitted.\n   Since
      protocols encapsulating EAP, such as RADIUS [RFC3579], may not\n   provide confidentiality,
      EAP packets may be subsequently encapsulated\n   for transport over the Internet
      where they may be captured by an\n   attacker.\n   As a result, cleartext passwords
      cannot be securely used within EAP,\n   except where encapsulated within a protected
      tunnel with server\n   authentication.  Some of the same risks apply to EAP
      methods without\n   dictionary attack resistance, as defined in Section 7.2.1.
      \ For\n   details, see Section 7.6.\n"
    title: 7.14.  Cleartext Passwords
  - contents:
    - "7.15.  Channel Binding\n   It is possible for a compromised or poorly implemented
      EAP\n   authenticator to communicate incorrect information to the EAP peer\n
      \  and/or server.  This may enable an authenticator to impersonate\n   another
      authenticator or communicate incorrect information via out-\n   of-band mechanisms
      (such as via a AAA or lower layer protocol).\n   Where EAP is used in pass-through
      mode, the EAP peer typically does\n   not verify the identity of the pass-through
      authenticator, it only\n   verifies that the pass-through authenticator is trusted
      by the EAP\n   server.  This creates a potential security vulnerability.\n   Section
      4.3.7 of [RFC3579] describes how an EAP pass-through\n   authenticator acting
      as a AAA client can be detected if it attempts\n   to impersonate another authenticator
      (such by sending incorrect NAS-\n   Identifier [RFC2865], NAS-IP-Address [RFC2865]
      or NAS-IPv6-Address\n   [RFC3162] attributes via the AAA protocol).  However,
      it is possible\n   for a pass-through authenticator acting as a AAA client to
      provide\n   correct information to the AAA server while communicating misleading\n
      \  information to the EAP peer via a lower layer protocol.\n   For example,
      it is possible for a compromised authenticator to\n   utilize another authenticator's
      Called-Station-Id or NAS-Identifier\n   in communicating with the EAP peer via
      a lower layer protocol, or for\n   a pass-through authenticator acting as a
      AAA client to provide an\n   incorrect peer Calling-Station-Id [RFC2865][RFC3580]
      to the AAA\n   server via the AAA protocol.\n   In order to address this vulnerability,
      EAP methods may support a\n   protected exchange of channel properties such
      as endpoint\n   identifiers, including (but not limited to): Called-Station-Id\n
      \  [RFC2865][RFC3580], Calling-Station-Id [RFC2865][RFC3580], NAS-\n   Identifier
      [RFC2865], NAS-IP-Address [RFC2865], and NAS-IPv6-Address\n   [RFC3162].\n   Using
      such a protected exchange, it is possible to match the channel\n   properties
      provided by the authenticator via out-of-band mechanisms\n   against those exchanged
      within the EAP method.  Where discrepancies\n   are found, these SHOULD be logged;
      additional actions MAY also be\n   taken, such as denying access.\n"
    title: 7.15.  Channel Binding
  - contents:
    - "7.16.  Protected Result Indications\n   Within EAP, Success and Failure packets
      are neither acknowledged nor\n   integrity protected.  Result indications improve
      resilience to loss\n   of Success and Failure packets when EAP is run over lower
      layers\n   which do not support retransmission or synchronization of the\n   authentication
      state.  In media such as IEEE 802.11, which provides\n   for retransmission,
      as well as synchronization of authentication\n   state via the 4-way handshake
      defined in [IEEE-802.11i], additional\n   resilience is typically of marginal
      benefit.\n   Depending on the method and circumstances, result indications can
      be\n   spoofable by an attacker.  A method is said to provide protected\n   result
      indications if it supports result indications, as well as the\n   \"integrity
      protection\" and \"replay protection\" claims.  A method\n   supporting protected
      result indications MUST indicate which result\n   indications are protected,
      and which are not.\n   Protected result indications are not required to protect
      against\n   rogue authenticators.  Within a mutually authenticating method,\n
      \  requiring that the server authenticate to the peer before the peer\n   will
      accept a Success packet prevents an attacker from acting as a\n   rogue authenticator.\n
      \  However, it is possible for an attacker to forge a Success packet\n   after
      the server has authenticated to the peer, but before the peer\n   has authenticated
      to the server.  If the peer were to accept the\n   forged Success packet and
      attempt to access the network when it had\n   not yet successfully authenticated
      to the server, a denial of service\n   attack could be mounted against the peer.
      \ After such an attack, if\n   the lower layer supports failure indications,
      the authenticator can\n   synchronize state with the peer by providing a lower
      layer failure\n   indication.  See Section 7.12 for details.\n   If a server
      were to authenticate the peer and send a Success packet\n   prior to determining
      whether the peer has authenticated the\n   authenticator, an idle timeout can
      occur if the authenticator is not\n   authenticated by the peer.  Where supported
      by the lower layer, an\n   authenticator sensing the absence of the peer can
      free resources.\n   In a method supporting result indications, a peer that has\n
      \  authenticated the server does not consider the authentication\n   successful
      until it receives an indication that the server\n   successfully authenticated
      it.  Similarly, a server that has\n   successfully authenticated the peer does
      not consider the\n   authentication successful until it receives an indication
      that the\n   peer has authenticated the server.\n   In order to avoid synchronization
      problems, prior to sending a\n   success result indication, it is desirable
      for the sender to verify\n   that sufficient authorization exists for granting
      access, though, as\n   discussed below, this is not always possible.\n   While
      result indications may enable synchronization of the\n   authentication result
      between the peer and server, this does not\n   guarantee that the peer and authenticator
      will be synchronized in\n   terms of their authorization or that timeouts will
      not occur.  For\n   example, the EAP server may not be aware of an authorization
      decision\n   made by a AAA proxy; the AAA server may check authorization only\n
      \  after authentication has completed successfully, to discover that\n   authorization
      cannot be granted, or the AAA server may grant access\n   but the authenticator
      may be unable to provide it due to a temporary\n   lack of resources.  In these
      situations, synchronization may only be\n   achieved via lower layer result
      indications.\n   Success indications may be explicit or implicit.  For example,
      where\n   a method supports error messages, an implicit success indication may\n
      \  be defined as the reception of a specific message without a preceding\n   error
      message.  Failures are typically indicated explicitly.  As\n   described in
      Section 4.2, a peer silently discards a Failure packet\n   received at a point
      where the method does not explicitly permit this\n   to be sent.  For example,
      a method providing its own error messages\n   might require the peer to receive
      an error message prior to accepting\n   a Failure packet.\n   Per-packet authentication,
      integrity, and replay protection of result\n   indications protects against
      spoofing.  Since protected result\n   indications require use of a key for per-packet
      authentication and\n   integrity protection, methods supporting protected result
      indications\n   MUST also support the \"key derivation\", \"mutual authentication\",\n
      \  \"integrity protection\", and \"replay protection\" claims.\n   Protected
      result indications address some denial-of-service\n   vulnerabilities due to
      spoofing of Success and Failure packets,\n   though not all.  EAP methods can
      typically provide protected result\n   indications only in some circumstances.
      \ For example, errors can\n   occur prior to key derivation, and so it may not
      be possible to\n   protect all failure indications.  It is also possible that
      result\n   indications may not be supported in both directions or that\n   synchronization
      may not be achieved in all modes of operation.\n   For example, within EAP-TLS
      [RFC2716], in the client authentication\n   handshake, the server authenticates
      the peer, but does not receive a\n   protected indication of whether the peer
      has authenticated it.  In\n   contrast, the peer authenticates the server and
      is aware of whether\n   the server has authenticated it.  In the session resumption\n
      \  handshake, the peer authenticates the server, but does not receive a\n   protected
      indication of whether the server has authenticated it.  In\n   this mode, the
      server authenticates the peer and is aware of whether\n   the peer has authenticated
      it.\n"
    title: 7.16.  Protected Result Indications
  title: 7.  Security Considerations
- contents:
  - "8.  Acknowledgements\n   This protocol derives much of its inspiration from Dave
    Carrel's AHA\n   document, as well as the PPP CHAP protocol [RFC1994].  Valuable\n
    \  feedback was provided by Yoshihiro Ohba of Toshiba America Research,\n   Jari
    Arkko of Ericsson, Sachin Seth of Microsoft, Glen Zorn of Cisco\n   Systems, Jesse
    Walker of Intel, Bill Arbaugh, Nick Petroni and Bryan\n   Payne of the University
    of Maryland, Steve Bellovin of AT&T Research,\n   Paul Funk of Funk Software,
    Pasi Eronen of Nokia, Joseph Salowey of\n   Cisco, Paul Congdon of HP, and members
    of the EAP working group.\n   The use of Security Claims sections for EAP methods,
    as required by\n   Section 7.2 and specified for each EAP method described in
    this\n   document, was inspired by Glen Zorn through [EAP-EVAL].\n"
  title: 8.  Acknowledgements
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC1661]          Simpson, W., \"The Point-to-Point
      Protocol (PPP)\",\n                      STD 51, RFC 1661, July 1994.\n   [RFC1994]
      \         Simpson, W., \"PPP Challenge Handshake\n                      Authentication
      Protocol (CHAP)\", RFC 1994, August\n                      1996.\n   [RFC2119]
      \         Bradner, S., \"Key words for use in RFCs to\n                      Indicate
      Requirement Levels\", BCP 14, RFC 2119,\n                      March 1997.\n
      \  [RFC2243]          Metz, C., \"OTP Extended Responses\", RFC 2243,\n                      November
      1997.\n   [RFC2279]          Yergeau, F., \"UTF-8, a transformation format of\n
      \                     ISO 10646\", RFC 2279, January 1998.\n   [RFC2289]          Haller,
      N., Metz, C., Nesser, P. and M. Straw, \"A\n                      One-Time Password
      System\", RFC 2289, February\n                      1998.\n   [RFC2434]          Narten,
      T. and H. Alvestrand, \"Guidelines for\n                      Writing an IANA
      Considerations Section in RFCs\",\n                      BCP 26, RFC 2434, October
      1998.\n   [RFC2988]          Paxson, V. and M. Allman, \"Computing TCP's\n                      Retransmission
      Timer\", RFC 2988, November 2000.\n   [IEEE-802]         Institute of Electrical
      and Electronics Engineers,\n                      \"Local and Metropolitan Area
      Networks: Overview\n                      and Architecture\", IEEE Standard
      802, 1990.\n   [IEEE-802.1X]      Institute of Electrical and Electronics Engineers,\n
      \                     \"Local and Metropolitan Area Networks: Port-Based\n                      Network
      Access Control\", IEEE Standard 802.1X,\n                      September 2001.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [RFC793]           Postel, J., \"Transmission
      Control Protocol\", STD\n                      7, RFC 793, September 1981.\n
      \  [RFC1510]          Kohl, J. and B. Neuman, \"The Kerberos Network\n                      Authentication
      Service (V5)\", RFC 1510, September\n                      1993.\n   [RFC1750]
      \         Eastlake, D., Crocker, S. and J. Schiller,\n                      \"Randomness
      Recommendations for Security\", RFC\n                      1750, December 1994.\n
      \  [RFC2246]          Dierks, T., Allen, C., Treese, W., Karlton, P.,\n                      Freier,
      A. and P. Kocher, \"The TLS Protocol\n                      Version 1.0\", RFC
      2246, January 1999.\n   [RFC2284]          Blunk, L. and J. Vollbrecht, \"PPP
      Extensible\n                      Authentication Protocol (EAP)\", RFC 2284,
      March\n                      1998.\n   [RFC2486]          Aboba, B. and M. Beadles,
      \"The Network Access\n                      Identifier\", RFC 2486, January
      1999.\n   [RFC2408]          Maughan, D., Schneider, M. and M. Schertler,\n
      \                     \"Internet Security Association and Key Management\n                      Protocol
      (ISAKMP)\", RFC 2408, November 1998.\n   [RFC2409]          Harkins, D. and
      D. Carrel, \"The Internet Key\n                      Exchange (IKE)\", RFC 2409,
      November 1998.\n   [RFC2433]          Zorn, G. and S. Cobb, \"Microsoft PPP
      CHAP\n                      Extensions\", RFC 2433, October 1998.\n   [RFC2607]
      \         Aboba, B. and J. Vollbrecht, \"Proxy Chaining and\n                      Policy
      Implementation in Roaming\", RFC 2607, June\n                      1999.\n   [RFC2661]
      \         Townsley, W., Valencia, A., Rubens, A., Pall, G.,\n                      Zorn,
      G. and B. Palter, \"Layer Two Tunneling\n                      Protocol \"L2TP\"\",
      RFC 2661, August 1999.\n   [RFC2716]          Aboba, B. and D. Simon, \"PPP
      EAP TLS\n                      Authentication Protocol\", RFC 2716, October
      1999.\n   [RFC2865]          Rigney, C., Willens, S., Rubens, A. and W.\n                      Simpson,
      \"Remote Authentication Dial In User\n                      Service (RADIUS)\",
      RFC 2865, June 2000.\n   [RFC2960]          Stewart, R., Xie, Q., Morneault,
      K., Sharp, C.,\n                      Schwarzbauer, H., Taylor, T., Rytina,
      I., Kalla,\n                      M., Zhang, L. and V. Paxson, \"Stream Control\n
      \                     Transmission Protocol\", RFC 2960, October 2000.\n   [RFC3162]
      \         Aboba, B., Zorn, G. and D. Mitton, \"RADIUS and\n                      IPv6\",
      RFC 3162, August 2001.\n   [RFC3454]          Hoffman, P. and M. Blanchet, \"Preparation
      of\n                      Internationalized Strings (\"stringprep\")\", RFC\n
      \                     3454, December 2002.\n   [RFC3579]          Aboba, B.
      and P. Calhoun, \"RADIUS (Remote\n                      Authentication Dial
      In User Service) Support For\n                      Extensible Authentication
      Protocol (EAP)\", RFC\n                      3579, September 2003.\n   [RFC3580]
      \         Congdon, P., Aboba, B., Smith, A., Zorn, G. and J.\n                      Roese,
      \"IEEE 802.1X Remote Authentication Dial In\n                      User Service
      (RADIUS) Usage Guidelines\", RFC 3580,\n                      September 2003.\n
      \  [RFC3692]          Narten, T., \"Assigning Experimental and Testing\n                      Numbers
      Considered Useful\", BCP 82, RFC 3692,\n                      January 2004.\n
      \  [DECEPTION]        Slatalla, M. and J. Quittner, \"Masters of\n                      Deception\",
      Harper-Collins, New York, 1995.\n   [KRBATTACK]        Wu, T., \"A Real-World
      Analysis of Kerberos\n                      Password Security\", Proceedings
      of the 1999 ISOC\n                      Network and Distributed System Security
      Symposium,\n                      http://www.isoc.org/isoc/conferences/ndss/99/\n
      \                     proceedings/papers/wu.pdf.\n   [KRBLIM]           Bellovin,
      S. and M. Merrit, \"Limitations of the\n                      Kerberos authentication
      system\", Proceedings of\n                      the 1991 Winter USENIX Conference,
      pp. 253-267,\n                      1991.\n   [KERB4WEAK]        Dole, B., Lodin,
      S. and E. Spafford, \"Misplaced\n                      trust:  Kerberos 4 session
      keys\", Proceedings of\n                      the Internet Society Network and
      Distributed\n                      System Security Symposium, pp. 60-70, March
      1997.\n   [PIC]              Aboba, B., Krawczyk, H. and Y. Sheffer, \"PIC,
      A\n                      Pre-IKE Credential Provisioning Protocol\", Work in\n
      \                     Progress, October 2002.\n   [IKEv2]            Kaufman,
      C., \"Internet Key Exchange (IKEv2)\n                      Protocol\", Work
      in Progress, January 2004.\n   [PPTPv1]           Schneier, B. and Mudge, \"Cryptanalysis
      of\n                      Microsoft's Point-to- Point Tunneling Protocol\",\n
      \                     Proceedings of the 5th ACM Conference on\n                      Communications
      and Computer Security, ACM Press,\n                      November 1998.\n   [IEEE-802.11]
      \     Institute of Electrical and Electronics Engineers,\n                      \"Wireless
      LAN Medium Access Control (MAC) and\n                      Physical Layer (PHY)
      Specifications\", IEEE\n                      Standard 802.11, 1999.\n   [SILVERMAN]
      \       Silverman, Robert D., \"A Cost-Based Security\n                      Analysis
      of Symmetric and Asymmetric Key Lengths\",\n                      RSA Laboratories
      Bulletin 13, April 2000 (Revised\n                      November 2001),\n                      http://www.rsasecurity.com/rsalabs/bulletins/\n
      \                     bulletin13.html.\n   [KEYFRAME]         Aboba, B., \"EAP
      Key Management Framework\", Work in\n                      Progress, October
      2003.\n   [SASLPREP]         Zeilenga, K., \"SASLprep: Stringprep profile for\n
      \                     user names and passwords\", Work in Progress, March\n
      \                     2004.\n   [IEEE-802.11i]     Institute of Electrical and
      Electronics Engineers,\n                      \"Unapproved Draft Supplement
      to Standard for\n                      Telecommunications and Information Exchange\n
      \                     Between Systems - LAN/MAN Specific Requirements -\n                      Part
      11: Wireless LAN Medium Access Control (MAC)\n                      and Physical
      Layer (PHY) Specifications:\n                      Specification for Enhanced
      Security\", IEEE Draft\n                      802.11i (work in progress), 2003.\n
      \  [DIAM-EAP]         Eronen, P., Hiller, T. and G. Zorn, \"Diameter\n                      Extensible
      Authentication Protocol (EAP)\n                      Application\", Work in
      Progress, February 2004.\n   [EAP-EVAL]         Zorn, G., \"Specifying Security
      Claims for EAP\n                      Authentication Types\", Work in Progress,
      October\n                      2002.\n   [BINDING]          Puthenkulam, J.,
      \"The Compound Authentication\n                      Binding Problem\", Work
      in Progress, October 2003.\n   [MITM]             Asokan, N., Niemi, V. and
      K. Nyberg, \"Man-in-the-\n                      Middle in Tunneled Authentication
      Protocols\", IACR\n                      ePrint Archive Report 2002/163, October
      2002,\n                      <http://eprint.iacr.org/2002/163>.\n   [IEEE-802.11i-req]
      Stanley, D., \"EAP Method Requirements for Wireless\n                      LANs\",
      Work in Progress, February 2004.\n   [PPTPv2]           Schneier, B. and Mudge,
      \"Cryptanalysis of\n                      Microsoft's PPTP Authentication Extensions
      (MS-\n                      CHAPv2)\", CQRE 99, Springer-Verlag, 1999, pp.\n
      \                     192-203.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Appendix A. Changes from RFC 2284\n   This section lists the major changes between
    [RFC2284] and this\n   document.  Minor changes, including style, grammar, spelling,
    and\n   editorial changes are not mentioned here.\n   o  The Terminology section
    (Section 1.2) has been expanded, defining\n      more concepts and giving more
    exact definitions.\n   o  The concepts of Mutual Authentication, Key Derivation,
    and Result\n      Indications are introduced and discussed throughout the document\n
    \     where appropriate.\n   o In Section 2, it is explicitly specified that more
    than one\n      exchange of Request and Response packets may occur as part of
    the\n      EAP authentication exchange.  How this may be used and how it may\n
    \     not be used is specified in detail in Section 2.1.\n   o  Also in Section
    2, some requirements have been made explicit for\n      the authenticator when
    acting in pass-through mode.\n   o  An EAP multiplexing model (Section 2.2) has
    been added to\n      illustrate a typical implementation of EAP.  There is no\n
    \     requirement that an implementation conform to this model, as long\n      as
    the on-the-wire behavior is consistent with it.\n   o  As EAP is now in use with
    a variety of lower layers, not just PPP\n      for which it was first designed,
    Section 3 on lower layer behavior\n      has been added.\n   o  In the description
    of the EAP Request and Response interaction\n      (Section 4.1), both the behavior
    on receiving duplicate requests,\n      and when packets should be silently discarded
    has been more\n      exactly specified.  The implementation notes in this section
    have\n      been substantially expanded.\n   o  In Section 4.2, it has been clarified
    that Success and Failure\n      packets must not contain additional data, and
    the implementation\n      note has been expanded.  A subsection giving requirements
    on\n      processing of success and failure packets has been added.\n   o  Section
    5 on EAP Request/Response Types lists two new Type values:\n      the Expanded
    Type (Section 5.7), which is used to expand the Type\n      value number space,
    and the Experimental Type.  In the Expanded\n      Type number space, the new
    Expanded Nak (Section 5.3.2) Type has\n      been added.  Clarifications have
    been made in the description of\n      most of the existing Types.  Security claims
    summaries have been\n      added for authentication methods.\n   o  In Sections
    5, 5.1, and 5.2, a requirement has been added such\n      that fields with displayable
    messages should contain UTF-8 encoded\n      ISO 10646 characters.\n   o  It is
    now required in Section 5.1 that if the Type-Data field of\n      an Identity
    Request contains a NUL-character, only the part before\n      the null is displayed.
    \ RFC 2284 prohibits the null termination of\n      the Type-Data field of Identity
    messages.  This rule has been\n      relaxed for Identity Request messages and
    the Identity Request\n      Type-Data field may now be null terminated.\n   o
    \ In Section 5.5, support for OTP Extended Responses [RFC2243] has\n      been
    added to EAP OTP.\n   o  An IANA Considerations section (Section 6) has been added,
    giving\n      registration policies for the numbering spaces defined for EAP.\n
    \  o  The Security Considerations (Section 7) have been greatly\n      expanded,
    giving a much more comprehensive coverage of possible\n      threats and other
    security considerations.\n   o  In Section 7.5, text has been added on method-specific
    behavior,\n      providing guidance on how EAP method-specific integrity checks\n
    \     should be processed.  Where possible, it is desirable for a\n      method-specific
    MIC to be computed over the entire EAP packet,\n      including the EAP layer
    header (Code, Identifier, Length) and EAP\n      method layer header (Type, Type-Data).\n
    \  o  In Section 7.14 the security risks involved in use of cleartext\n      passwords
    with EAP are described.\n   o  In Section 7.15 text has been added relating to
    detection of rogue\n      NAS behavior.\n"
  title: Appendix A. Changes from RFC 2284
- contents:
  - "Authors' Addresses\n   Bernard Aboba\n   Microsoft Corporation\n   One Microsoft
    Way\n   Redmond, WA  98052\n   USA\n   Phone: +1 425 706 6605\n   Fax:   +1 425
    936 6605\n   EMail: bernarda@microsoft.com\n   Larry J. Blunk\n   Merit Network,
    Inc\n   4251 Plymouth Rd., Suite 2000\n   Ann Arbor, MI  48105-2785\n   USA\n
    \  Phone: +1 734-647-9563\n   Fax:   +1 734-647-3185\n   EMail: ljb@merit.edu\n
    \  John R. Vollbrecht\n   Vollbrecht Consulting LLC\n   9682 Alice Hill Drive\n
    \  Dexter, MI  48130\n   USA\n   EMail: jrv@umich.edu\n   James Carlson\n   Sun
    Microsystems, Inc\n   1 Network Drive\n   Burlington, MA  01803-2757\n   USA\n
    \  Phone: +1 781 442 2084\n   Fax:   +1 781 442 1677\n   EMail: james.d.carlson@sun.com\n
    \  Henrik Levkowetz\n   ipUnplugged AB\n   Arenavagen 33\n   Stockholm  S-121
    28\n   SWEDEN\n   Phone: +46 708 32 16 08\n   EMail: henrik@levkowetz.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).  This
    document is subject\n   to the rights, licenses and restrictions contained in
    BCP 78, and\n   except as set forth therein, the authors retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
