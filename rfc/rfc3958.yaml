- title: __initial_text__
  contents:
  - "    Domain-Based Application Service Location Using SRV RRs and the\n       \
    \       Dynamic Delegation Discovery Service (DDDS)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo defines a generalized mechanism for application service\n\
    \   naming that allows service location without relying on rigid domain\n   naming\
    \ conventions (so-called name hacks).  The proposal defines a\n   Dynamic Delegation\
    \ Discovery System (DDDS) Application to map domain\n   name, application service\
    \ name, and application protocol dynamically\n   to target server and port.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  Straightforward-NAPTR (S-NAPTR) Specification  . . .\
    \ . . . . .  3\n       2.1.  Key Terms. . . . . . . . . . . . . . . . . . . .\
    \ . . . .  3\n       2.2.  S-NAPTR DDDS Application Usage . . . . . . . . . .\
    \ . . .  4\n             2.2.1.  Ordering and Preference. . . . . . . . . . .\
    \ . .  4\n             2.2.2.  Matching and Non-matching NAPTR Records. . . .\
    \ .  4\n             2.2.3.  Terminal and Non-terminal NAPTR Records. . . . .\
    \  5\n             2.2.4.  S-NAPTR and Successive Resolution. . . . . . . .  5\n\
    \             2.2.5.  Clients Supporting Multiple Protocols. . . . . .  6\n  \
    \ 3.  Guidelines . . . . . . . . . . . . . . . . . . . . . . . . . .  6\n    \
    \   3.1.  Guidelines for Application Protocol Developers . . . . .  6\n      \
    \       3.1.1.  Registration of Application Service and\n                    \
    \ Protocol Tags. . . . . . . . . . . . . . . . . .  7\n             3.1.2.  Definition\
    \ of Conditions for Retry/Failure . . .  7\n             3.1.3.  Server Identification\
    \ and Handshake  . . . . . .  8\n       3.2.  Guidelines for Domain Administrators\
    \ . . . . . . . . . .  8\n       3.3.  Guidelines for Client Software Writers\
    \ . . . . . . . . .  8\n   4.  Illustrations  . . . . . . . . . . . . . . . .\
    \ . . . . . . . .  9\n       4.1.  Use Cases  . . . . . . . . . . . . . . . .\
    \ . . . . . . .  9\n       4.2.  Service Discovery within a Domain  . . . . .\
    \ . . . . . .  9\n       4.3.  Multiple Protocols . . . . . . . . . . . . . .\
    \ . . . . . 10\n       4.4.  Remote Hosting . . . . . . . . . . . . . . . . .\
    \ . . . . 11\n       4.5.  Sets of NAPTR RRs  . . . . . . . . . . . . . . . .\
    \ . . . 12\n       4.6.  Sample Sequence Diagram  . . . . . . . . . . . . . .\
    \ . . 13\n   5.  Motivation and Discussion  . . . . . . . . . . . . . . . . .\
    \ . 14\n       5.1.  So Why Not Just SRV Records? . . . . . . . . . . . . . .\
    \ 15\n       5.2.  So Why Not Just NAPTR Records? . . . . . . . . . . . . . 15\n\
    \   6.  Formal Definition of <Application Service Location>\n       Application\
    \ of DDDS  . . . . . . . . . . . . . . . . . . . . . 16\n       6.1.  Application-Unique\
    \ String  . . . . . . . . . . . . . . . 16\n       6.2.  First Well-Known Rule\
    \  . . . . . . . . . . . . . . . . . 16\n       6.3.  Expected Output  . . . .\
    \ . . . . . . . . . . . . . . . . 16\n       6.4.  Flags  . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . 16\n       6.5.  Service Parameters . . . . .\
    \ . . . . . . . . . . . . . . 17\n             6.5.1.  Application Services .\
    \ . . . . . . . . . . . . . 17\n             6.5.2.  Application Protocols  .\
    \ . . . . . . . . . . . . 17\n       6.6.  Valid Rules  . . . . . . . . . . .\
    \ . . . . . . . . . . . 17\n       6.7.  Valid Databases  . . . . . . . . . .\
    \ . . . . . . . . . . 18\n   7.  IANA Considerations  . . . . . . . . . . . .\
    \ . . . . . . . . . 18\n       7.1.  Application Service Tag IANA Registry  .\
    \ . . . . . . . . 18\n       7.2.  Application Protocol Tag IANA Registry . .\
    \ . . . . . . . 18\n       7.3.  Registration Process . . . . . . . . . . . .\
    \ . . . . . . 19\n   8.  Security Considerations  . . . . . . . . . . . . . .\
    \ . . . . . 19\n   9.  Acknowledgements . . . . . . . . . . . . . . . . . . .\
    \ . . . . 20\n   10. References . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 21\n       10.1. Normative References . . . . . . . . . . . . . . . .\
    \ . . 21\n       10.2. Informative References . . . . . . . . . . . . . . . .\
    \ . 21\n   Appendices . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 22\n       A.  Pseudo-pseudocode for S-NAPTR. . . . . . . . . . . . . . . 22\n\
    \           A.1.  Finding the First (Best) Target. . . . . . . . . . . 22\n  \
    \         A.2.  Finding Subsequent Targets . . . . . . . . . . . . . 23\n    \
    \   B.  Availability of Sample Code. . . . . . . . . . . . . . . . 23\n   Authors'\
    \ Addresses . . . . . . . . . . . . . . . . . . . . . . . . 24\n   Full Copyright\
    \ Statement . . . . . . . . . . . . . . . . . . . . . 25\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memo defines a generalized mechanism for application\
    \ service\n   naming that allows service location without relying on rigid domain\n\
    \   naming conventions (so-called name hacks).  The proposal defines a\n   Dynamic\
    \ Delegation Discovery System (DDDS -- see [4]) Application to\n   map domain\
    \ name, application service name, and application protocol\n   dynamically to\
    \ target server and port.\n   As discussed in section 5, existing approaches to\
    \ using DNS records\n   for dynamically determining the current host for a given\
    \ application\n   service are limited in terms of the use cases supported.  To\
    \ address\n   some of the limitations, this document defines a DDDS Application\
    \ to\n   map service+protocol+domain to specific server addresses by using\n \
    \  both NAPTR [5] and SRV ([3]) DNS resource records.  This can be\n   viewed\
    \ as a more general version of the use of SRV and/or a very\n   restricted application\
    \ of the use of NAPTR resource records.\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in BCP 14, RFC 2119 [1].\n"
- title: 2.  Straightforward-NAPTR (S-NAPTR) Specification
  contents:
  - "2.  Straightforward-NAPTR (S-NAPTR) Specification\n   The precise details of\
    \ the specification of this DDDS application are\n   given in Section 6.  This\
    \ section defines the usage of the DDDS\n   application.\n"
- title: 2.1.  Key Terms
  contents:
  - "2.1.  Key Terms\n   \"Application service\" is a generic term for some type of\
    \ application,\n   independent of the protocol that may be used to offer it. \
    \ Each\n   application service will be associated with an IANA-registered tag.\n\
    \   For example, retrieving mail is a type of application service that\n   can\
    \ be implemented by different application-layer protocols (e.g.,\n   POP3, IMAP4).\
    \  A tag, such as \"RetMail\", could be registered for it.\n   (Note that this\
    \ has not been done, and there are no plans to do so at\n   the time of this writing.)\n\
    \   An \"application protocol\" is used to implement the application\n   service.\
    \  These are also associated with IANA-registered tags.  Using\n   the mail example\
    \ above, \"POP3\" and \"IMAP4\" could be registered as\n   application protocol\
    \ tags.  If multiple transports are available for\n   the application, separate\
    \ tags should be defined for each transport.\n   The intention is that the combination\
    \ of application service and\n   protocol tags should be specific enough that\
    \ finding a known pair\n   (e.g., \"RetMail:POP3\" would be sufficient for a client\
    \ to identify a\n   server with which it can communicate.\n   Some protocols support\
    \ multiple application services.  For example,\n   LDAP is an application protocol\
    \ and can be found supporting various\n   services (e.g., \"whitepages\", \"directory\
    \ enabled networking\".\n"
- title: 2.2.  S-NAPTR DDDS Application Usage
  contents:
  - "2.2.  S-NAPTR DDDS Application Usage\n   As defined in section 6, NAPTR records\
    \ are used to store application\n   service+protocol information for a given domain.\
    \  Following the DDDS\n   standard, these records are looked up, and the rewrite\
    \ rules\n   (contained in the NAPTR records) are used to determine the successive\n\
    \   DNS lookups until a desirable target is found.\n   For the rest of this section,\
    \ refer to the set of NAPTR resource\n   records for example.com, shown in the\
    \ figure below, where \"WP\" is the\n   imagined application service tag for \"\
    white pages\" and \"EM\" is the\n   application service tag for an imagined \"\
    Extensible Messaging\"\n   application service.\n   example.com.\n   ;;      \
    \ order pref flags\n   IN NAPTR 100   10   \"\"    \"WP:whois++\"      ( ; service\n\
    \                             \"\"                  ; regexp\n               \
    \              bunyip.example.     ; replacement\n                           \
    \                    )\n   IN NAPTR 100   20   \"s\"   \"WP:ldap\"         ( ;\
    \ service\n                             \"\"                  ; regexp\n     \
    \                       _ldap._tcp.myldap.example.com. ; replacement\n       \
    \                                        )\n   IN NAPTR 200   10   \"\"    \"\
    EM:protA\"        ( ; service\n                             \"\"             \
    \     ; regexp\n                             someisp.example.    ; replacement\n\
    \                                               )\n   IN NAPTR 200   30   \"a\"\
    \   \"EM:protB\"          ; service\n                             \"\"       \
    \           ; regexp\n                             myprotB.example.com.; replacement\n\
    \                                               )\n"
- title: 2.2.1.  Ordering and Preference
  contents:
  - "2.2.1.  Ordering and Preference\n   A client retrieves all the NAPTR records\
    \ associated with the target\n   domain name (example.com, above).  These are\
    \ to be sorted in terms of\n   increasing ORDER and increasing PREF within each\
    \ ORDER.\n"
- title: 2.2.2.  Matching and Non-Matching NAPTR Records
  contents:
  - "2.2.2.  Matching and Non-Matching NAPTR Records\n   Starting with the first sorted\
    \ NAPTR record, the client examines the\n   SERVICE field to find a match.  In\
    \ the case of the S-NAPTR DDDS\n   application, this means a SERVICE field that\
    \ includes the tags for\n   the desired application service and a supported application\
    \ protocol.\n   If more than one NAPTR record matches, they are processed in\n\
    \   increasing sort order.\n"
- title: 2.2.3.  Terminal and Non-terminal NAPTR Records
  contents:
  - "2.2.3.  Terminal and Non-terminal NAPTR Records\n   A NAPTR record with an empty\
    \ FLAG field is \"non-terminal\" -- that is,\n   more NAPTR RR lookups are to\
    \ be performed.  Thus, to process a NAPTR\n   record with an empty FLAG field\
    \ in S-NAPTR, the REPLACEMENT field is\n   used as the target of the next DNS\
    \ lookup -- for NAPTR RRs.\n   In S-NAPTR, the only terminal flags are \"S\" and\
    \ \"A\".  These are\n   called \"terminal\" NAPTR lookups because they denote\
    \ the end of the\n   DDDS/NAPTR processing rules.  In the case of an \"S\" flag,\
    \ the\n   REPLACEMENT field is used as the target of a DNS query for SRV RRs,\n\
    \   and normal SRV processing is applied.  In the case of an \"A\" flag, an\n\
    \   address record is sought for the REPLACEMENT field target (and the\n   default\
    \ protocol port is assumed).\n"
- title: 2.2.4.  S-NAPTR and Successive Resolution
  contents:
  - "2.2.4.  S-NAPTR and Successive Resolution\n   As shown in the example set above,\
    \ it is possible to have multiple\n   possible targets for a single application\
    \ service+protocol pair.\n   These are to be pursued in order until a server is\
    \ successfully\n   contacted or all possible matching NAPTR records have been\n\
    \   successively pursued through terminal lookup and server contact.\n   That\
    \ is, a client must backtrack and attempt other resolution paths\n   in the case\
    \ of failure.\n   \"Failure\" is declared, and backtracking must be used, when\n\
    \   o  the designated remote server (host and port) fails to provide\n      appropriate\
    \ security credentials for the *originating* domain;\n   o  connection to the\
    \ designated remote server otherwise fails -- the\n      specifics terms of which\
    \ are defined when an application protocol\n      is registered; or\n   o  the\
    \ S-NAPTR-designated DNS lookup fails to yield expected results\n      -- e.g.,\
    \ no A RR for an \"A\" target, no SRV record for an \"S\"\n      target, or no\
    \ NAPTR record with appropriate application service\n      and protocol for a\
    \ NAPTR lookup.  Except in the case of the very\n      first NAPTR lookup, this\
    \ last is a configuration error: the fact\n      that example.com has a NAPTR\
    \ record pointing to \"bunyip.example\"\n      for the \"WP:Whois++\" service\
    \ and protocol means the administrator\n      of example.com believes that service\
    \ exists.  If bunyip.example\n      has no \"WP:Whois++\" NAPTR record, the application\
    \ client MUST\n      backtrack and try the next available \"WP:Whois++\" option\
    \ from\n      example.com.  As there is none, the whole resolution fails.\n  \
    \ An application client first queries for the NAPTR RRs for the domain\n   of\
    \ a named application service.  The first DNS query is for the NAPTR\n   RRs in\
    \ the original target domain (example.com, above).\n"
- title: 2.2.5.  Clients Supporting Multiple Protocols
  contents:
  - "2.2.5.  Clients Supporting Multiple Protocols\n   In the case of an application\
    \ client that supports more than one\n   protocol for a given application service,\
    \ it MUST pursue S-NAPTR\n   resolution completely for one protocol, exploring\
    \ all potential\n   terminal lookups in PREF and ORDER ranking, until the application\n\
    \   connects successfully or there are no more possibilities for that\n   protocol.\n\
    \   That is, the client MUST NOT start looking for one protocol, observe\n   that\
    \ a successive NAPTR RR set supports another of its preferred\n   protocols, and\
    \ continue the S-NAPTR resolution based on that\n   protocol.  For example, even\
    \ if someisp.example offers the \"EM\"\n   service with protocol \"ProtB\", there\
    \ is no reason to believe that it\n   does so on behalf of example.com (as there\
    \ is no such pointer in\n   example.com's NAPTR RR set).\n   It MAY choose which\
    \ protocol to try first based on its own\n   preference, or on the PREF ranking\
    \ in the first set of NAPTR records\n   (i.e., those for the target named domain).\
    \  However, the chosen\n   protocol MUST be listed in that first NAPTR RR set.\n\
    \   It MAY choose to run simultaneous DDDS resolutions for more than one\n   protocol,\
    \ in which case the requirements above apply for each\n   protocol independently.\
    \  That is, do not switch protocols mid-\n   resolution.\n"
- title: 3.  Guidelines
  contents:
  - '3.  Guidelines

    '
- title: 3.1.  Guidelines for Application Protocol Developers
  contents:
  - "3.1.  Guidelines for Application Protocol Developers\n   The purpose of S-NAPTR\
    \ is to provide application standards developers\n   with a more powerful framework\
    \ (than SRV RRs alone) for naming\n   service targets, without requiring each\
    \ application protocol (or\n   service) standard to define a separate DDDS application.\n\
    \   Note that this approach is intended specifically for use when it\n   makes\
    \ sense to associate services with particular domain names (e.g.,\n   e-mail addresses,\
    \ SIP addresses, etc).  A non-goal is having all\n   manner of label mapped into\
    \ domain names in order to use this.\n   This document does not address how to\
    \ select the domain for which the\n   service+protocol is being sought.  Other\
    \ conventions will have to\n   define how this might be used (e.g., new messaging\
    \ standards can\n   define what domain to use from their URIs or how to step down\
    \ from\n   foobar.example.com to example.com, if applicable).\n   Although this\
    \ document proposes a DDDS application that does not use\n   all the features\
    \ of NAPTR resource records, it is not intended to\n   imply that DNS resolvers\
    \ should fail to implement all aspects of the\n   NAPTR RR standard.  A DDDS application\
    \ is a client use convention.\n   The rest of this section outlines the specific\
    \ elements that protocol\n   developers must determine and document to make use\
    \ of S-NAPTR.\n"
- title: 3.1.1.  Registration of Application Service and Protocol Tags
  contents:
  - "3.1.1.  Registration of Application Service and Protocol Tags\n   Application\
    \ protocol developers who wish to make use of S-NAPTR must\n   make provisions\
    \ for registering any relevant application service and\n   application protocol\
    \ tags, as described in section 7.\n"
- title: 3.1.2.  Definition of Conditions for Retry/Failure
  contents:
  - "3.1.2.  Definition of Conditions for Retry/Failure\n   One other important aspect\
    \ that must be defined is the expected\n   behaviour for interacting with the\
    \ servers that are reached via S-\n   NAPTR.  Specifically, under what circumstances\
    \ should the client\n   retry a target that was found via S-NAPTR?  What should\
    \ it consider a\n   failure that causes it to return to the S-NAPTR process to\
    \ determine\n   the next serviceable target, which by definition will have a lower\n\
    \   preference ranking.\n   For example, if the client gets a \"connection refused\"\
    \ message from a\n   server, should it retry for some (protocol-dependent) period\
    \ of time?\n   Or should it try the next-preferred target in the S-NAPTR chain\
    \ of\n   resolution?  Should it only try the next-preferred target if it\n   receives\
    \ a protocol-specific permanent error message?\n   The most important thing is\
    \ to select one expected behaviour and\n   document it as part of the use of S-NAPTR.\n\
    \   As noted earlier, failure to provide appropriate credentials to\n   identify\
    \ the server as being authoritative for the original target\n   domain is always\
    \ considered a failure condition.\n"
- title: 3.1.3.  Server Identification and Handshake
  contents:
  - "3.1.3.  Server Identification and Handshake\n   As noted in section 8, use of\
    \ the DNS for server location increases\n   the importance of using protocol-specific\
    \ handshakes to determine and\n   confirm the identity of the server that is eventually\
    \ reached.\n   Therefore, application protocol developers using S-NAPTR should\n\
    \   identify the mechanics of the expected identification handshake when\n   the\
    \ client connects to a server found through S-NAPTR.\n"
- title: 3.2.  Guidelines for Domain Administrators
  contents:
  - "3.2.  Guidelines for Domain Administrators\n   Although S-NAPTR aims to provide\
    \ a \"straightforward\" application of\n   DDDS and use of NAPTR records, it is\
    \ still possible to create very\n   complex chains and dependencies with the NAPTR\
    \ and SRV records.\n   Therefore, domain administrators are called upon to use\
    \ S-NAPTR with\n   as much restraint as possible while still achieving their service\n\
    \   design goals.\n   The complete set of NAPTR, SRV, and A RRs \"reachable\"\
    \ through the S-\n   NAPTR process for a particular application service can be\
    \ thought of\n   as a \"tree\".  Each NAPTR RR that is retrieved points to more\
    \ NAPTR or\n   SRV records; each SRV record points to several A record lookups.\n\
    \   Even though a particular client can \"prune\" the tree to use only\n   those\
    \ records referring to application protocols supported by the\n   client, the\
    \ tree could be quite deep, and retracing the tree to retry\n   other targets\
    \ can become expensive if the tree has many branches.\n   Therefore,\n   o  fewer\
    \ branches is better: For both NAPTR and SRV records, provide\n      different\
    \ targets with varying preferences where appropriate\n      (e.g., to provide\
    \ backup services) but don't look for reasons to\n      provide more; and\n  \
    \ o  shallower is better: Avoid using NAPTR records to \"rename\"\n      services\
    \ within a zone.  Use NAPTR records to identify services\n      hosted elsewhere\
    \ (i.e., where you cannot reasonably provide the\n      SRV records in your own\
    \ zone).\n"
- title: 3.3.  Guidelines for Client Software Writers
  contents:
  - "3.3.  Guidelines for Client Software Writers\n   To understand DDDS/NAPTR properly,\
    \ an implementor must read [4].\n   However, the most important aspect to keep\
    \ in mind is that if the\n   application cannot successfully connect to one target,\
    \ the\n   application will be expected to continue through the S-NAPTR tree to\n\
    \   try the (less preferred) alternatives.\n"
- title: 4.  Illustrations
  contents:
  - '4.  Illustrations

    '
- title: 4.1.  Use Cases
  contents:
  - "4.1.  Use Cases\n   The basic intended use cases for which S-NAPTR has been developed\
    \ are\n   as follows\n   o  Service discovery within a domain.  For example, this\
    \ can be used\n      to find the \"authoritative\" server for some type of service\
    \ within\n      a domain (see the specific example in section 4.2).\n   o  Multiple\
    \ protocols.  This is already common today as new\n      application services\
    \ are defined, and is increasingly a problem.\n      It includes the case of extensible\
    \ messaging (a hypothetical\n      service), which can be offered with multiple\
    \ protocols (see\n      section 4.3).\n   o  Remote hosting.  Each of the above\
    \ use cases applies within the\n      administration of a single domain.  However,\
    \ one domain operator\n      may elect to engage another organization to provide\
    \ an application\n      service.  See section 4.4 for an example that cannot be\
    \ served by\n      SRV records alone.\n"
- title: 4.2.  Service Discovery within a Domain
  contents:
  - "4.2.  Service Discovery within a Domain\n   There are occasions when it is useful\
    \ to be able to determine the\n   \"authoritative\" server for a given application\
    \ service within a\n   domain.  This is \"discovery\", as there is no a priori\
    \ knowledge as to\n   whether or where the service is offered; it is therefore\
    \ important to\n   determine the location and characteristics of the offered service.\n\
    \   For example, there is growing discussion of having a generic\n   mechanism\
    \ for locating the keys or certificates associated with\n   particular application\
    \ (servers) operated in (or for) a particular\n   domain.  The following is a\
    \ hypothetical case for storing application\n   key or certificate data for a\
    \ given domain: the premise is that a\n   credentials registry (CredReg) service\
    \ has been defined as a leaf\n   node service holding the keys/certs for the servers\
    \ operated by (or\n   for) the domain.  It is assumed that more than one protocol\
    \ is\n   available to provide the service for a particular domain.  This\n   DDDS-based\
    \ approach is used to find the CredReg server that holds the\n   information.\n\
    \   Thus, the set of NAPTR records for thinkingcat.example might look\n   like\
    \ this:\n"
- title: thinkingcat.example.
  contents:
  - 'thinkingcat.example.

    '
- title: ;;       order pref flags
  contents:
  - ';;       order pref flags

    '
- title: IN NAPTR 100   10   ""    "CREDREG:ldap:iris.beep"   ( ; service
  contents:
  - "IN NAPTR 100   10   \"\"    \"CREDREG:ldap:iris.beep\"   ( ; service\n      \
    \                    \"\"                           ; regexp\n               \
    \           theserver.thinkingcat.example. ; replacement\n"
- title: Note that the application service might be offered in another domain
  contents:
  - 'Note that the application service might be offered in another domain

    '
- title: 'using a different set of application protocols:'
  contents:
  - 'using a different set of application protocols:

    '
- title: anotherdomain.example.
  contents:
  - 'anotherdomain.example.

    '
- title: ;;       order pref flags
  contents:
  - ';;       order pref flags

    '
- title: IN NAPTR 100   10   ""    "CREDREG:iris.lwz:iris.beep"  ( ; service
  contents:
  - "IN NAPTR 100   10   \"\"    \"CREDREG:iris.lwz:iris.beep\"  ( ; service\n   \
    \                       \"\"                              ; regexp\n         \
    \                 foo.anotherdomain.example.      ; replacement\n            \
    \                                            )\n"
- title: 4.3.  Multiple Protocols
  contents:
  - "4.3.  Multiple Protocols\n   Extensible messaging, a hypothetical application\
    \ service, will be\n   used for illustrative purposes.  (For an example of a real\n\
    \   application service with multiple protocols, see [9] and [10]).\n   Assuming\
    \ that \"EM\" was registered as an application service, this\n   DDDS application\
    \ could be used to determine the available services\n   for delivery to a target.\n\
    \   Two particular features of this hypothetical extensible messaging\n   should\
    \ be noted:\n   1. Gatewaying is expected to bridge communications across protocols.\n\
    \   2. Extensible messaging servers are likely to be operated out of a\n     \
    \ different domain than that of the extensible messaging address,\n      and servers\
    \ of different protocols may be offered by independent\n      organizations.\n\
    \   For example, \"thinkingcat.example\" may support its own servers for\n   the\
    \ \"ProtA\" extensible messaging protocol but rely on outsourcing\n   from \"\
    example.com\" for \"ProtC\" and \"ProtB\" servers.\n   Using this DDDS-based approach,\
    \ thinkingcat.example can indicate a\n   preference ranking for the different\
    \ types of servers for the\n   extensible messaging service, yet the out-sourcer\
    \ can independently\n   rank the preference and ordering of servers.  This independence\
    \ is\n   not achievable through the use of SRV records alone.\n   Thus, to find\
    \ the EM services for thinkingcat.example, the NAPTR\n   records for thinkingcat.example\
    \ are retrieved:\n"
- title: thinkingcat.example.
  contents:
  - 'thinkingcat.example.

    '
- title: ;;   order pref flags
  contents:
  - ';;   order pref flags

    '
- title: IN NAPTR 100  10   "s"   "EM:ProtA"                  (   ; service
  contents:
  - "IN NAPTR 100  10   \"s\"   \"EM:ProtA\"                  (   ; service\n    \
    \                     \"\"                              ; regexp\n           \
    \             _ProtA._tcp.thinkingcat.example. ; replacement\n               \
    \                                      )\n"
- title: IN NAPTR 100  20   "s"   "EM:ProtB"                  (   ; service
  contents:
  - "IN NAPTR 100  20   \"s\"   \"EM:ProtB\"                  (   ; service\n    \
    \                     \"\"                              ; regexp\n           \
    \              _ProtB._tcp.example.com.        ; replacement\n               \
    \                                      )\n"
- title: IN NAPTR 100  30   "s"   "EM:ProtC"                  (   ; service
  contents:
  - "IN NAPTR 100  30   \"s\"   \"EM:ProtC\"                  (   ; service\n    \
    \                     \"\"                              ; regexp\n           \
    \              _ProtC._tcp.example.com.        ; replacement\n               \
    \                                      )\n   Then the administrators at example.com\
    \ can manage the preference\n   rankings of the servers they use to support the\
    \ ProtB service:\n   _ProtB._tcp.example.com.\n    ;;    Pref Weight Port  Target\n\
    \   IN SRV 10    0     10001 bigiron.example.com.\n   IN SRV 20    0     10001\
    \ backup.em.example.com.\n   IN SRV 30    0     10001 nuclearfallout.australia-isp.example.\n"
- title: 4.4.  Remote Hosting
  contents:
  - "4.4.  Remote Hosting\n   In the Instant Message hosting example in Section 4.3,\
    \ the service\n   owner (thinkingcat.example) had to host pointers to the hosting\n\
    \   service's SRV records in the thinkingcat.example domain.\n   A better approach\
    \ is to have one NAPTR RR in the thinkingcat.example\n   domain point to all the\
    \ hosted services.  The hosting domain has\n   NAPTR records for each service\
    \ to map them to whatever local hosts it\n   chooses (this may change from time\
    \ to time).\n"
- title: thinkingcat.example.
  contents:
  - 'thinkingcat.example.

    '
- title: ;;      order pref flags
  contents:
  - ';;      order pref flags

    '
- title: IN NAPTR 100  10   "s"   "EM:ProtA"                ( ; service
  contents:
  - "IN NAPTR 100  10   \"s\"   \"EM:ProtA\"                ( ; service\n        \
    \                 \"\"                          ; regexp\n                   \
    \     _ProtA._tcp.thinkingcat.example. ; replacement\n                       \
    \                            )\n"
- title: IN NAPTR 100  20   ""    "EM:ProtB:ProtC"          ( ; service
  contents:
  - "IN NAPTR 100  20   \"\"    \"EM:ProtB:ProtC\"          ( ; service\n        \
    \                 \"\"                          ; regexp\n                   \
    \      thinkingcat.example.com.    ; replacement\n                           \
    \                        )\n   Then the administrators at example.com can break\
    \ out the individual\n   application protocols and manage the preference rankings\
    \ of the\n   servers they use to support the ProtB service (as before):\n"
- title: thinkingcat.example.com.
  contents:
  - 'thinkingcat.example.com.

    '
- title: ;;      order pref flags
  contents:
  - ';;      order pref flags

    '
- title: IN NAPTR 100  10   "s"   "EM:ProtC"                ( ; service
  contents:
  - "IN NAPTR 100  10   \"s\"   \"EM:ProtC\"                ( ; service\n        \
    \                 \"\"                          ; regexp\n                   \
    \      _ProtC._tcp.example.com.    ; replacement\n                           \
    \                        )\n"
- title: IN NAPTR 100  20   "s"   "EM:ProtB"                ( ; service
  contents:
  - "IN NAPTR 100  20   \"s\"   \"EM:ProtB\"                ( ; service\n        \
    \                 \"\"                          ; regexp\n                   \
    \      _ProtB._tcp.example.com.    ; replacement\n                           \
    \                        )\n"
- title: _ProtC._tcp.example.com.
  contents:
  - "_ProtC._tcp.example.com.\n ;;    Pref Weight Port  Target\n"
- title: IN SRV 10    0     10001 bigiron.example.com.
  contents:
  - 'IN SRV 10    0     10001 bigiron.example.com.

    '
- title: IN SRV 20    0     10001 backup.em.example.com.
  contents:
  - 'IN SRV 20    0     10001 backup.em.example.com.

    '
- title: IN SRV 30    0     10001 nuclearfallout.australia-isp.example.
  contents:
  - 'IN SRV 30    0     10001 nuclearfallout.australia-isp.example.

    '
- title: 4.5.  Sets of NAPTR RRs
  contents:
  - "4.5.  Sets of NAPTR RRs\n   Note that the above sections assume that there was\
    \ one service\n   available (via S-NAPTR) per domain.  Often, this will not be\
    \ the\n   case.  Assuming that thinkingcat.example had the CredReg service set\n\
    \   up as described in Section 4.2 and had the extensible messaging\n   service\
    \ set up as described in Section 4.4, then a client querying\n   for the NAPTR\
    \ RR set from thinkingcat.com would get the following\n   answer:\n"
- title: thinkingcat.example.
  contents:
  - 'thinkingcat.example.

    '
- title: ;;       order pref flags
  contents:
  - ';;       order pref flags

    '
- title: IN NAPTR 100   10   "s"   "EM:ProtA"               ( ; service
  contents:
  - "IN NAPTR 100   10   \"s\"   \"EM:ProtA\"               ( ; service\n        \
    \                  \"\"                         ; regexp\n                   \
    \       _ProtA._tcp.thinkingcat.example. ; replacement\n                     \
    \                              )\n"
- title: IN NAPTR 100   20   ""    "EM:ProtB:ProtC"         ( ; service
  contents:
  - "IN NAPTR 100   20   \"\"    \"EM:ProtB:ProtC\"         ( ; service\n        \
    \                  \"\"                         ; regexp\n                   \
    \       thinkingcat.example.com.   ; replacement\n                           \
    \                        )\n"
- title: IN NAPTR 200   10   ""    "CREDREG:ldap:iris-beep" ( ; service
  contents:
  - "IN NAPTR 200   10   \"\"    \"CREDREG:ldap:iris-beep\" ( ; service\n        \
    \                  \"\"                         ; regexp\n                   \
    \       bouncer.thinkingcat.example. ; replacement\n                         \
    \                          )\n   Sorting them by increasing \"ORDER\", the client\
    \ would look through the\n   SERVICE strings to determine whether there was a\
    \ NAPTR RR that\n   matched the application service it was looking for, with an\n\
    \   application protocol it could use.  The client would use the first\n   (lowest\
    \ PREF) record that matched to continue.\n"
- title: 4.6.  Sample sequence diagram
  contents:
  - "4.6.  Sample sequence diagram\n   Consider the example in section 4.3.  Visually,\
    \ the sequence of steps\n   required for the client to reach the final server\
    \ for a \"ProtB\"\n   service for EM for the thinkingcat.example domain is as\
    \ follows:\n   Client   NS for                NS for\n            thinkingcat.example\
    \   example.com    backup.em.example.com\n                |                  \
    \   |                  |\n     1 -------->|                     |            \
    \      |\n     2 <--------|                     |                  |\n     3 ------------------------------>|\
    \                  |\n     4 <------------------------------|                \
    \  |\n     5 ------------------------------>|                  |\n     6 <------------------------------|\
    \                  |\n     7 ------------------------------>|                \
    \  |\n     8 <------------------------------|                  |\n     9 ------------------------------------------------->|\n\
    \    10 <-------------------------------------------------|\n    11 ------------------------------------------------->|\n\
    \    12 <-------------------------------------------------|\n   (...)\n   1. \
    \ The name server (NS) for thinkingcat.example is reached with a\n       request\
    \ for all NAPTR records.\n   2.  The server responds with the NAPTR records shown\
    \ in section 4.3.\n   3.  The second NAPTR record matches the desired criteria;\
    \ it has an\n       \"s\" flag and a replacement fields of \"_ProtB._tcp.example.com\"\
    .\n       So the client looks up SRV records for that target, ultimately\n   \
    \    making the request of the NS for example.com.\n   4.  The response includes\
    \ the SRV records listed in Section 4.3.\n   5.  The client attempts to reach\
    \ the server with the lowest PREF in\n       the SRV list -- looking up the A\
    \ record for the SRV record's\n       target (bigiron.example.com).\n   6.  The\
    \ example.com NS responds with an error message -- no such\n       machine!\n\
    \   7.  The client attempts to reach the second server in the SRV list\n     \
    \  and looks up the A record for backup.em.example.com.\n   8.  The client gets\
    \ the A record with the IP address for\n       backup.em.example.com from example.com's\
    \ NS.\n   9.  The client connects to that IP address, on port 10001 (from the\n\
    \       SRV record), by using ProtB over tcp.\n   10. The server responds with\
    \ an \"OK\" message.\n   11. The client uses ProtB to challenge that this server\
    \ has\n       credentials to operate the service for the original domain\n   \
    \    (thinkingcat.example)\n   12. The server responds, and the rest is EM.\n"
- title: 5.  Motivation and Discussion
  contents:
  - "5.  Motivation and Discussion\n   Increasingly, application protocol standards\
    \ use domain names to\n   identify server targets and stipulate that clients should\
    \ look up SRV\n   resource records to determine the host and port providing the\
    \ server.\n   This enables a distinction between naming an application service\n\
    \   target and actually hosting the server.  It also increases\n   flexibility\
    \ in hosting the target service, as follows:\n   o  The server may be operated\
    \ by a completely different organization\n      without having to list the details\
    \ of that organization's DNS\n      setup (SRVs).\n   o  Multiple instances can\
    \ be set up (e.g., for load balancing or\n      secondaries).\n   o  It can be\
    \ moved from time to time without disrupting clients'\n      access, etc.\n  \
    \ This approach is quite useful, but section 5.1 outlines some of its\n   inherent\
    \ limitations.\n   That is, although SRV records can be used to map from a specific\n\
    \   service name and protocol for a specific domain to a specific server,\n  \
    \ SRV records are limited to one layer of indirection and are focused\n   on server\
    \ administration rather than on application naming.\n   Furthermore, although\
    \ the DDDS specification and use of NAPTR allows\n   multiple levels of redirection\
    \ before the target server machine with\n   an SRV record is located, this proposal\
    \ requires only a subset of\n   NAPTR strictly bound to domain names, without\
    \ making use of the\n   REGEXP field of NAPTR.  These restrictions make the client's\n\
    \   resolution process much more predictable and efficient than it would\n   be\
    \ with some potential uses of NAPTR records.  This is dubbed \"S-\n   NAPTR\"\
    \ -- a \"S\"traightforward use of NAPTR records.\n"
- title: 5.1.  So Why Not Just SRV Records?
  contents:
  - "5.1.  So Why Not Just SRV Records?\n   An expected question at this point is:\
    \ this is so similar in\n   structure to SRV records, why are we doing this with\
    \ DDDS/NAPTR?\n   Limitations of SRV include the following:\n   o  SRV provides\
    \ a single layer of indirection; the outcome of an SRV\n      lookup is a new\
    \ domain name for which the A RR is to be found.\n   o  the purpose of SRV is\
    \ to address individual server administration\n      issues, not to provide application\
    \ naming: As stated in [3], \"The\n      SRV RR allows administrators to use several\
    \ servers for a single\n      domain, to move services from host to host with\
    \ little fuss, and\n      to designate some hosts as primary servers for a service\
    \ and\n      others as backups\".\n   o  Target servers by \"service\" (e.g.,\
    \ \"ldap\") and \"protocol\" (e.g.,\n      \"tcp\") in a given domain.  The definition\
    \ of these terms implies\n      specific things (e.g., that protocol should be\
    \ one of UDP or TCP)\n      without being precise.  Restriction to UDP and TCP\
    \ is insufficient\n      for the uses described here.\n   The basic answer is\
    \ that SRV records provide mappings from protocol\n   names to host and port.\
    \  The use cases described herein require an\n   additional layer -- from some\
    \ service label to servers that may in be\n   hosted within different administrative\
    \ domains.  We could tweak SRV\n   to say that the next lookup could be something\
    \ other than an address\n   record, but this is more complex than is necessary\
    \ for most\n   applications of SRV.\n"
- title: 5.2.  So Why Not Just NAPTR Records?
  contents:
  - "5.2.  So Why Not Just NAPTR Records?\n   This is a trick question.  NAPTR records\
    \ cannot appear in the wild;\n   see [4].  They must be part of a DDDS application.\n\
    \   The purpose here is to define a single, common mechanism (the DDDS\n   application)\
    \ to use NAPTR when all that is desired is simple DNS-\n   based location of services.\
    \  This should be easy for applications to\n   use -- a few simple IANA registrations,\
    \ and it's done.\n   Also, NAPTR has very powerful tools for expressing \"rewrite\"\
    \ rules.\n   This power (==complexity) makes some protocol designers and service\n\
    \   administrators nervous.  The concern is that these rewrites can\n   translate\
    \ into unintelligible, noodle-like rule sets that are\n   difficult to test and\
    \ administer.\n   The proposed DDDS application specifically uses a subset of\
    \ NAPTR's\n   abilities.  Only \"replacement\" expressions are allowed, not \"\
    regular\n   expressions\".\n"
- title: 6.  Formal Definition of <Application Service Location> Application of
  contents:
  - "6.  Formal Definition of <Application Service Location> Application of\n    DDDS\n\
    \   This section formally defines the DDDS application, as described in\n   [4].\n"
- title: 6.1.  Application-Unique String
  contents:
  - "6.1.  Application-Unique String\n   The Application Unique String is domain label\
    \ for which an\n   authoritative server for a particular service is sought.\n"
- title: 6.2.  First Well-Known Rule
  contents:
  - "6.2.  First Well-Known Rule\n   The \"First Well-Known Rule\" is identity --\
    \ that is, the output of the\n   rule is the Application-Unique String, the domain\
    \ label for which the\n   authoritative server for a particular service is sought.\n"
- title: 6.3.  Expected Output
  contents:
  - "6.3.  Expected Output\n   The expected output of this Application is the information\
    \ necessary\n   for a client to connect to authoritative server(s) (host, port,\n\
    \   protocol) for a particular application service within a given domain.\n"
- title: 6.4.  Flags
  contents:
  - "6.4.  Flags\n   This DDDS Application uses only 2 of the Flags defined for the\
    \ URI/\n   URN Resolution Application ([6]): \"S\" and \"A\".  No other Flags\
    \ are\n   valid.\n   Both are for terminal lookups.  This means that the Rule\
    \ is the last\n   one and that the flag determines what the next stage should\
    \ be.  The\n   \"S\" flag means that the output of this Rule is a domain label\
    \ for\n   which one or more SRV [3] records exist.  \"A\" means that the output\n\
    \   of the Rule is a domain name and should be used to lookup address\n   records\
    \ for that domain.\n   Consistent with the DDDS algorithm, if the Flag string\
    \ is empty the\n   next lookup is for another NAPTR record (for the replacement\
    \ target).\n"
- title: 6.5.  Service Parameters
  contents:
  - "6.5.  Service Parameters\n   Service Parameters for this Application take the\
    \ form of a string of\n   characters that follow this ABNF ([2]):\n      service-parms\
    \ = [ [app-service] *(\":\" app-protocol)]\n      app-service   = experimental-service\
    \  / iana-registered-service\n      app-protocol  = experimental-protocol / iana-registered-protocol\n\
    \      experimental-service      = \"x-\" 1*30ALPHANUMSYM\n      experimental-protocol\
    \     = \"x-\" 1*30ALPHANUMSYM\n      iana-registered-service   = ALPHA *31ALPHANUMSYM\n\
    \      iana-registered-protocol  = ALPHA *31ALPHANUM\n      ALPHA         =  %x41-5A\
    \ / %x61-7A   ; A-Z / a-z\n      DIGIT         =  %x30-39 ; 0-9\n      SYM   \
    \        =  %x2B / %x2D / %x2E  ; \"+\" / \"-\" / \".\"\n      ALPHANUMSYM   =\
    \  ALPHA / DIGIT / SYM\n      ; The app-service and app-protocol tags are limited\
    \ to 32\n      ; characters and must start with an alphabetic character.\n   \
    \   ; The service-parms are considered case-insensitive.\n   Thus, the Service\
    \ Parameters may consist of an empty string, an app-\n   service, or an app-service\
    \ with one or more app-protocol\n   specifications separated by the \":\" symbol.\n\
    \   Note that this is similar to, but not the same as the syntax used in\n   the\
    \ URI DDDS application ([6]).  The DDDS DNS database requires each\n   DDDS application\
    \ to define the syntax of allowable service strings.\n   The syntax here is expanded\
    \ to allow the characters that are valid in\n   any URI scheme name (see [8]).\
    \  As \"+\" (the separator used in the\n   RFC3404 service parameter string) is\
    \ an allowed character for URI\n   scheme names, \":\" is chosen as the separator\
    \ here.\n"
- title: 6.5.1.  Application Services
  contents:
  - "6.5.1.  Application Services\n   The \"app-service\" must be an IANA-registered\
    \ service; see Section 7\n   for instructions on registering new application service\
    \ tags.\n"
- title: 6.5.2.  Application Protocols
  contents:
  - "6.5.2.  Application Protocols\n   The protocol identifiers valid for the \"app-protocol\"\
    \ production are\n   standard, registered protocols; see section 7 for instructions\
    \ on\n   registering new application protocol tags.\n"
- title: 6.6.  Valid Rules
  contents:
  - "6.6.  Valid Rules\n   Only substitution Rules are permitted for this application.\
    \  That is,\n   no regular expressions are allowed.\n"
- title: 6.7.  Valid Databases
  contents:
  - "6.7.  Valid Databases\n   At present only one DDDS Database is specified for\
    \ this Application.\n   [5] specifies that a DDDS Database using the NAPTR DNS\
    \ resource\n   record contain the rewrite rules.  The Keys for this database are\n\
    \   encoded as domain-names.\n   The First Well-Known Rule produces a domain name,\
    \ and this is the Key\n   used for the first look up.  The NAPTR records for that\
    \ domain are\n   requested.\n   DNS servers MAY interpret Flag values and use\
    \ that information to\n   include appropriate NAPTR, SRV, or A records in the\
    \ Additional\n   Information portion of the DNS packet.  Clients are encouraged\
    \ to\n   check for additional information but are not required to do so.  See\n\
    \   the Additional Information Processing section of [5] for more\n   information\
    \ on NAPTR records and the Additional Information section\n   of a DNS response\
    \ packet.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   This document calls for two IANA registries: one\
    \ for application\n   service tags, and one for application protocol tags.\n"
- title: 7.1.  Application Service Tag IANA Registry
  contents:
  - "7.1.  Application Service Tag IANA Registry\n   IANA has established and will\
    \ maintain a registry for S-NAPTR\n   Application Service Tags, listing at least\
    \ the following information\n   for each such tag:\n   o  Application Service\
    \ Tag: A string conforming with the IANA-\n      registered-service defined in\
    \ section 6.5.\n   o  Defining publication: The RFC used to define the Application\n\
    \      Service Tag, as defined in the registration process, below.\n   An initial\
    \ Application Service Tag registration is contained in [9].\n"
- title: 7.2.  Application Protocol Tag IANA Registry
  contents:
  - "7.2.  Application Protocol Tag IANA Registry\n   IANA has established and will\
    \ maintain a registry for S-NAPTR\n   Application Protocol Tags, listing at least\
    \ the following information\n   for each such tag:\n   o  Application Protocol\
    \ Tag: A string conforming with the iana-\n      registered-protocol defined in\
    \ section 6.5.\n   o  Defining publication: The RFC used to define the Application\n\
    \      Protocol Tag, as defined in the registration process, below.\n   An initial\
    \ Application Protocol Tag registration is defined in [10].\n"
- title: 7.3.  Registration Process
  contents:
  - "7.3.  Registration Process\n   All application service and protocol tags that\
    \ start with \"x-\" are\n   considered experimental, and no provision is made\
    \ to prevent\n   duplicate use of the same string.  Implementors use them at their\
    \ own\n   risk.\n   All other application service and protocol tags are registered\
    \ based\n   on the \"specification required\" option defined in [7], with the\n\
    \   further stipulation that the \"specification\" is an RFC (of any\n   category).\n\
    \   No further restrictions are placed on the tags except that they must\n   conform\
    \ with the syntax defined below (Section 6.5).\n   The defining RFC must clearly\
    \ identify and describe, for each tag\n   being registered,\n   o  application\
    \ protocol or service tag,\n   o  intended usage,\n   o  interoperability considerations,\n\
    \   o  security considerations (see section 8 of this document for\n      further\
    \ discussion of the types of considerations that are\n      applicable), and\n\
    \   o  any relevant related publications.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The security of this approach to application\
    \ service location is only\n   as good as the security of the DNS queries along\
    \ the way.  If any of\n   them is compromised, bogus NAPTR and SRV records could\
    \ be inserted to\n   redirect clients to unintended destinations.  This problem\
    \ is hardly\n   unique to S-NAPTR (or NAPTR in general).  A full discussion of\
    \ the\n   security threats pertaining to DNS can be found in [11].\n   To protect\
    \ against DNS-vectored attacks, secured DNS (DNSSEC) [12]\n   can be used to ensure\
    \ the validity of the DNS records received.\n   Whether or not DNSSEC is used,\
    \ applications should define some form\n   of end-to-end authentication to ensure\
    \ that the correct destination\n   has been reached.  Many application protocols\
    \ such as HTTPS, BEEP,\n   and IMAP define the necessary handshake mechanisms\
    \ to accomplish this\n   task.  Newly defined application protocols should take\
    \ this into\n   consideration and incorporate appropriate mechanisms.\n   The\
    \ basic mechanism works as follows:\n   1. During some portion of the protocol\
    \ handshake, the client sends to\n      the server the original name of the desired\
    \ destination (i.e., no\n      transformations that may have resulted from NAPTR\
    \ replacements,\n      SRV targets, or CNAME changes).  In certain cases where\
    \ the\n      application protocol does not have such a feature but TLS may be\n\
    \      used, it is possible to use the \"server_name\" TLS extension.\n   2. The\
    \ server sends back to the client a credential with the\n      appropriate name.\
    \  For X.509 certificates, the name would be in\n      either the subjectDN or\
    \ the subjectAltName field.  For Kerberos,\n      the name would be a service\
    \ principle name.\n   3. Using the matching semantics defined by the application\
    \ protocol,\n      the client compares the name in the credential with the name\
    \ sent\n      to the server.\n   4. If the names match and the credentials have\
    \ integrity, there is\n      reasonable assurance that the correct end point has\
    \ been reached.\n   5. The client and server establish an integrity-protected\
    \ channel.\n   Note that this document does not define either the handshake\n\
    \   mechanism, the specific credential naming fields, nor the name-\n   matching\
    \ semantics.  Definitions of S-NAPTR for particular\n   application protocols\
    \ MUST define these.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   Many thanks to Dave Blacka, Patrik Faltstrom, Sally\
    \ Floyd, and Ted\n   Hardie for discussion and input that have (hopefully!) provoked\n\
    \   clarifying revisions to this document.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n \
    \  [2]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n        Specifications:\
    \ ABNF\", RFC 2234, November 1997.\n   [3]  Gulbrandsen, A., Vixie, P., and L.\
    \ Esibov, \"A DNS RR for\n        specifying the location of services (DNS SRV)\"\
    , RFC 2782,\n        February 2000.\n   [4]  Mealling, M., \"Dynamic Delegation\
    \ Discovery System (DDDS) Part\n        One: The Comprehensive DDDS\", RFC 3401,\
    \ October 2002.\n   [5]  Mealling, M., \"Dynamic Delegation Discovery System (DDDS)\
    \ Part\n        Three: The Domain Name System (DNS) Database\", RFC 3403, October\n\
    \        2002.\n   [6]  Mealling, M., \"Dynamic Delegation Discovery System (DDDS)\
    \ Part\n        Four: The Uniform Resource Identifiers (URI)\", RFC 3404, October\n\
    \        2002.\n   [7]  Narten, T. and H. Alvestrand, \"Guidelines for Writing\
    \ an IANA\n        Considerations Section in RFCs\", BCP 26, RFC 2434, October\
    \ 1998.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [8]  Berners-Lee, T., Fielding, R., and L.\
    \ Masinter, \"Uniform\n        Resource Identifiers (URI): Generic Syntax\", RFC\
    \ 2396, August\n        1998.\n   [9]  Newton, A. and M. Sanz, \"IRIS:  A Domain\
    \ Registry (dreg) Type\n        for the Internet Registry Information Service\
    \ (IRIS)\", RFC 3982,\n        January 2005.\n   [10] Newton, A. and M. Sanz,\
    \ \"Using the Internet Registry Information\n        Service (IRIS) over the Blocks\
    \ Extensible Exchange Protocol\n        (BEEP)\", RFC 3983, January 2005.\n  \
    \ [11] Atkins, D. and R. Austein, \"Threat Analysis Of The Domain Name\n     \
    \   System\", Work in Progress, April 2004.\n   [12] Arends, R., Larson, M., Austein,\
    \ R., and D. Massey, \"Protocol\n        Modifications for the DNS Security Extensions\"\
    , Work in\n        Progress, May 2004.\n"
- title: Appendix A.  Pseudo-Pseudocode for S-NAPTR
  contents:
  - 'Appendix A.  Pseudo-Pseudocode for S-NAPTR

    '
- title: A.1.  Finding the First (Best) Target
  contents:
  - "A.1.  Finding the First (Best) Target\n   Assuming the client supports 1 protocol\
    \ for a particular application\n   service, the following pseudocode outlines\
    \ the expected process to\n   find the first (best) target for the client, using\
    \ S-NAPTR.\n   target = [initial domain]\n   naptr-done = false\n   while (not\
    \ naptr-done)\n    {\n     NAPTR-RRset = [DNSlookup of NAPTR RRs for target]\n\
    \     [sort NAPTR-RRset by ORDER, and PREF within each ORDER]\n     rr-done =\
    \ false\n     cur-rr = [first NAPTR RR]\n     while (not rr-done)\n        if\
    \ ([SERVICE field of cur-rr contains desired application\n             service\
    \ and application protocol])\n           rr-done = true\n           target= [REPLACEMENT\
    \ target of NAPTR RR]\n        else\n           cur-rr = [next rr in list]\n \
    \       if (not empty [FLAG in cur-rr])\n           naptr-done = true\n    }\n\
    \   port = -1\n   if ([FLAG in cur-rr is \"S\"])\n    {\n     SRV-RRset = [DNSlookup\
    \ of SRV RRs for target]\n     [sort SRV-RRset based on PREF]\n     target = [target\
    \ of first RR of SRV-RRset]\n     port = [port in first RR of SRV-RRset]\n   \
    \ }\n   ; now, whether it was an \"S\" or an \"A\" in the NAPTR, we\n   ; have\
    \ the target for an A record lookup\n   host = [DNSlookup of target]\n   return\
    \ (host, port)\n"
- title: A.2.  Finding Subsequent Targets
  contents:
  - "A.2.  Finding Subsequent Targets\n   The pseudocode in Appendix A is crafted\
    \ to find the first, most\n   preferred host-port pair for a particular application\
    \ service and\n   protocol.  If, for any reason, that host-port pair did not work\n\
    \   (connection refused, application-level error), the client is expected\n  \
    \ to try the next host-port in the S-NAPTR tree.\n   The pseudocode above does\
    \ not permit retries -- once complete, it\n   sheds all context of where in the\
    \ S-NAPTR tree it finished.\n   Therefore, client software writers could\n   o\
    \  entwine the application-specific protocol with the DNS lookup and\n      RRset\
    \ processing described in the pseudocode and continue the S-\n      NAPTR processing\
    \ if the application code fails to connect to a\n      located host-port pair;\n\
    \   o  use callbacks for the S-NAPTR processing; or\n   o  use an S-NAPTR resolution\
    \ routine that finds *all* valid servers\n      for the required application service\
    \ and protocol from the\n      originating domain and that provides them in a\
    \ sorted order for\n      the application to try.\n"
- title: Appendix B.  Availability of Sample Code
  contents:
  - "Appendix B.  Availability of Sample Code\n   Sample Python code for S-NAPTR resolution\
    \ is available from\n   http://www.verisignlabs.com/pysnaptr-0.1.tgz\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Leslie Daigle\n   VeriSign, Inc.\n   21355 Ridgetop Circle\n\
    \   Dulles, VA  20166\n   US\n   EMail: leslie@verisignlabs.com; leslie@thinkingcat.com\n\
    \   Andrew Newton\n   VeriSign, Inc.\n   21355 Ridgetop Circle\n   Dulles, VA\
    \  20166\n   US\n   EMail: anewton@verisignlabs.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ IETF's procedures with respect to rights in IETF Documents can\n   be found\
    \ in BCP 78 and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat\
    \ and any\n   assurances of licenses to be made available, or the result of an\n\
    \   attempt made to obtain a general license or permission for the use of\n  \
    \ such proprietary rights by implementers or users of this\n   specification can\
    \ be obtained from the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n\
    \   The IETF invites any interested party to bring to its attention any\n   copyrights,\
    \ patents or patent applications, or other proprietary\n   rights that may cover\
    \ technology that may be required to implement\n   this standard.  Please address\
    \ the information to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
