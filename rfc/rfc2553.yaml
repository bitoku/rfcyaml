- title: __initial_text__
  contents:
  - '               Basic Socket Interface Extensions for IPv6

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The de facto standard application program interface (API) for TCP/IP\n\
    \   applications is the \"sockets\" interface.  Although this API was\n   developed\
    \ for Unix in the early 1980s it has also been implemented on\n   a wide variety\
    \ of non-Unix systems.  TCP/IP applications written\n   using the sockets API\
    \ have in the past enjoyed a high degree of\n   portability and we would like\
    \ the same portability with IPv6\n   applications.  But changes are required to\
    \ the sockets API to support\n   IPv6 and this memo describes these changes. \
    \ These include a new\n   socket address structure to carry IPv6 addresses, new\
    \ address\n   conversion functions, and some new socket options.  These extensions\n\
    \   are designed to provide access to the basic IPv6 features required by\n  \
    \ TCP and UDP applications, including multicasting, while introducing a\n   minimum\
    \ of change into the system and providing complete\n   compatibility for existing\
    \ IPv4 applications.  Additional extensions\n   for advanced IPv6 features (raw\
    \ sockets and access to the IPv6\n   extension headers) are defined in another\
    \ document [4].\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction.................................................3\n\
    \   2. Design Considerations........................................3\n   2.1\
    \ What Needs to be Changed....................................4\n   2.2 Data Types..................................................5\n\
    \   2.3 Headers.....................................................5\n   2.4\
    \ Structures..................................................5\n   3. Socket\
    \ Interface.............................................6\n   3.1 IPv6 Address\
    \ Family and Protocol Family.....................6\n   3.2 IPv6 Address Structure......................................6\n\
    \   3.3 Socket Address Structure for 4.3BSD-Based Systems...........7\n   3.4\
    \ Socket Address Structure for 4.4BSD-Based Systems...........8\n   3.5 The Socket\
    \ Functions........................................9\n   3.6 Compatibility with\
    \ IPv4 Applications.......................10\n   3.7 Compatibility with IPv4 Nodes..............................10\n\
    \   3.8 IPv6 Wildcard Address......................................11\n   3.9\
    \ IPv6 Loopback Address......................................12\n   3.10 Portability\
    \ Additions.....................................13\n   4. Interface Identification....................................16\n\
    \   4.1 Name-to-Index..............................................16\n   4.2\
    \ Index-to-Name..............................................17\n   4.3 Return\
    \ All Interface Names and Indexes.....................17\n   4.4 Free Memory................................................18\n\
    \   5. Socket Options..............................................18\n   5.1\
    \ Unicast Hop Limit..........................................18\n   5.2 Sending\
    \ and Receiving Multicast Packets....................19\n   6. Library Functions...........................................21\n\
    \   6.1 Nodename-to-Address Translation............................21\n   6.2\
    \ Address-To-Nodename Translation............................24\n   6.3 Freeing\
    \ memory for getipnodebyname and getipnodebyaddr.....26\n   6.4 Protocol-Independent\
    \ Nodename and Service Name Translation.26\n   6.5 Socket Address Structure to\
    \ Nodename and Service Name......29\n   6.6 Address Conversion Functions...............................31\n\
    \   6.7 Address Testing Macros.....................................32\n   7. Summary\
    \ of New Definitions..................................33\n   8. Security Considerations.....................................35\n\
    \   9. Year 2000 Considerations....................................35\n   Changes\
    \ From RFC 2133..........................................35\n   Acknowledgments................................................38\n\
    \   References.....................................................39\n   Authors'\
    \ Addresses.............................................40\n   Full Copyright\
    \ Statement.......................................41\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   While IPv4 addresses are 32 bits long, IPv6 interfaces are\
    \ identified\n   by 128-bit addresses.  The socket interface makes the size of\
    \ an IP\n   address quite visible to an application; virtually all TCP/IP\n  \
    \ applications for BSD-based systems have knowledge of the size of an\n   IP address.\
    \  Those parts of the API that expose the addresses must be\n   changed to accommodate\
    \ the larger IPv6 address size.  IPv6 also\n   introduces new features (e.g.,\
    \ traffic class and flowlabel), some of\n   which must be made visible to applications\
    \ via the API.  This memo\n   defines a set of extensions to the socket interface\
    \ to support the\n   larger address size and new features of IPv6.\n"
- title: 2. Design Considerations
  contents:
  - "2. Design Considerations\n   There are a number of important considerations in\
    \ designing changes\n   to this well-worn API:\n      - The API changes should\
    \ provide both source and binary\n        compatibility for programs written to\
    \ the original API.  That\n        is, existing program binaries should continue\
    \ to operate when\n        run on a system supporting the new API.  In addition,\
    \ existing\n        applications that are re-compiled and run on a system supporting\n\
    \        the new API should continue to operate.  Simply put, the API\n      \
    \  changes for IPv6 should not break existing programs.  An\n        additonal\
    \ mechanism for implementations to verify this is to\n        verify the new symbols\
    \ are protected by Feature Test Macros as\n        described in IEEE Std 1003.1.\
    \  (Such Feature Test Macros are not\n        defined by this RFC.)\n      - The\
    \ changes to the API should be as small as possible in order\n        to simplify\
    \ the task of converting existing IPv4 applications to\n        IPv6.\n      -\
    \ Where possible, applications should be able to use this API to\n        interoperate\
    \ with both IPv6 and IPv4 hosts.  Applications should\n        not need to know\
    \ which type of host they are communicating with.\n      - IPv6 addresses carried\
    \ in data structures should be 64-bit\n        aligned.  This is necessary in\
    \ order to obtain optimum\n        performance on 64-bit machine architectures.\n\
    \   Because of the importance of providing IPv4 compatibility in the API,\n  \
    \ these extensions are explicitly designed to operate on machines that\n   provide\
    \ complete support for both IPv4 and IPv6.  A subset of this\n   API could probably\
    \ be designed for operation on systems that support\n   only IPv6.  However, this\
    \ is not addressed in this memo.\n"
- title: 2.1 What Needs to be Changed
  contents:
  - "2.1 What Needs to be Changed\n   The socket interface API consists of a few distinct\
    \ components:\n      -  Core socket functions.\n      -  Address data structures.\n\
    \      -  Name-to-address translation functions.\n      -  Address conversion\
    \ functions.\n   The core socket functions -- those functions that deal with such\n\
    \   things as setting up and tearing down TCP connections, and sending\n   and\
    \ receiving UDP packets -- were designed to be transport\n   independent.  Where\
    \ protocol addresses are passed as function\n   arguments, they are carried via\
    \ opaque pointers.  A protocol-specific\n   address data structure is defined\
    \ for each protocol that the socket\n   functions support.  Applications must\
    \ cast pointers to these\n   protocol-specific address structures into pointers\
    \ to the generic\n   \"sockaddr\" address structure when using the socket functions.\
    \  These\n   functions need not change for IPv6, but a new IPv6-specific address\n\
    \   data structure is needed.\n   The \"sockaddr_in\" structure is the protocol-specific\
    \ data structure\n   for IPv4.  This data structure actually includes 8-octets\
    \ of unused\n   space, and it is tempting to try to use this space to adapt the\n\
    \   sockaddr_in structure to IPv6.  Unfortunately, the sockaddr_in\n   structure\
    \ is not large enough to hold the 16-octet IPv6 address as\n   well as the other\
    \ information (address family and port number) that\n   is needed.  So a new address\
    \ data structure must be defined for IPv6.\n   IPv6 addresses are scoped [2] so\
    \ they could be link-local, site,\n   organization, global, or other scopes at\
    \ this time undefined.  To\n   support applications that want to be able to identify\
    \ a set of\n   interfaces for a specific scope, the IPv6 sockaddr_in structure\
    \ must\n   support a field that can be used by an implementation to identify a\n\
    \   set of interfaces identifying the scope for an IPv6 address.\n   The name-to-address\
    \ translation functions in the socket interface are\n   gethostbyname() and gethostbyaddr().\
    \  These are left as is and new\n   functions are defined to support IPv4 and\
    \ IPv6.  Additionally, the\n   POSIX 1003.g draft [3] specifies a new nodename-to-address\n\
    \   translation function which is protocol independent.  This function\n   can\
    \ also be used with IPv4 and IPv6.\n   The address conversion functions -- inet_ntoa()\
    \ and inet_addr() --\n   convert IPv4 addresses between binary and printable form.\
    \  These\n   functions are quite specific to 32-bit IPv4 addresses.  We have\n\
    \   designed two analogous functions that convert both IPv4 and IPv6\n   addresses,\
    \ and carry an address type parameter so that they can be\n   extended to other\
    \ protocol families as well.\n   Finally, a few miscellaneous features are needed\
    \ to support IPv6.\n   New interfaces are needed to support the IPv6 traffic class,\
    \ flow\n   label, and hop limit header fields.  New socket options are needed\
    \ to\n   control the sending and receiving of IPv6 multicast packets.\n   The\
    \ socket interface will be enhanced in the future to provide access\n   to other\
    \ IPv6 features.  These extensions are described in [4].\n"
- title: 2.2 Data Types
  contents:
  - "2.2 Data Types\n   The data types of the structure elements given in this memo\
    \ are\n   intended to be examples, not absolute requirements.  Whenever\n   possible,\
    \ data types from Draft 6.6 (March 1997) of POSIX 1003.1g are\n   used: uintN_t\
    \ means an unsigned integer of exactly N bits (e.g.,\n   uint16_t).  We also assume\
    \ the argument data types from 1003.1g when\n   possible (e.g., the final argument\
    \ to setsockopt() is a size_t\n   value).  Whenever buffer sizes are specified,\
    \ the POSIX 1003.1 size_t\n   data type is used (e.g., the two length arguments\
    \ to getnameinfo()).\n"
- title: 2.3 Headers
  contents:
  - "2.3 Headers\n   When function prototypes and structures are shown we show the\
    \ headers\n   that must be #included to cause that item to be defined.\n"
- title: 2.4 Structures
  contents:
  - "2.4 Structures\n   When structures are described the members shown are the ones\
    \ that\n   must appear in an implementation.  Additional, nonstandard members\n\
    \   may also be defined by an implementation.  As an additional\n   precaution\
    \ nonstandard members could be verified by Feature Test\n   Macros as described\
    \ in IEEE Std 1003.1.  (Such Feature Test Macros\n   are not defined by this RFC.)\n\
    \   The ordering shown for the members of a structure is the recommended\n   ordering,\
    \ given alignment considerations of multibyte members, but an\n   implementation\
    \ may order the members differently.\n"
- title: 3. Socket Interface
  contents:
  - "3. Socket Interface\n   This section specifies the socket interface changes for\
    \ IPv6.\n"
- title: 3.1 IPv6 Address Family and Protocol Family
  contents:
  - "3.1 IPv6 Address Family and Protocol Family\n   A new address family name, AF_INET6,\
    \ is defined in <sys/socket.h>.\n   The AF_INET6 definition distinguishes between\
    \ the original\n   sockaddr_in address data structure, and the new sockaddr_in6\
    \ data\n   structure.\n   A new protocol family name, PF_INET6, is defined in\
    \ <sys/socket.h>.\n   Like most of the other protocol family names, this will\
    \ usually be\n   defined to have the same value as the corresponding address family\n\
    \   name:\n      #define PF_INET6        AF_INET6\n   The PF_INET6 is used in\
    \ the first argument to the socket() function\n   to indicate that an IPv6 socket\
    \ is being created.\n"
- title: 3.2 IPv6 Address Structure
  contents:
  - "3.2 IPv6 Address Structure\n   A new in6_addr structure holds a single IPv6 address\
    \ and is defined\n   as a result of including <netinet/in.h>:\n      struct in6_addr\
    \ {\n          uint8_t  s6_addr[16];      /* IPv6 address */\n      };\n   This\
    \ data structure contains an array of sixteen 8-bit elements,\n   which make up\
    \ one 128-bit IPv6 address.  The IPv6 address is stored\n   in network byte order.\n\
    \   The structure in6_addr above is usually implemented with an embedded\n   union\
    \ with extra fields that force the desired alignment level in a\n   manner similar\
    \ to BSD implementations of \"struct in_addr\". Those\n   additional implementation\
    \ details are omitted here for simplicity.\n   An example is as follows:\n   struct\
    \ in6_addr {\n        union {\n            uint8_t  _S6_u8[16];\n            uint32_t\
    \ _S6_u32[4];\n            uint64_t _S6_u64[2];\n        } _S6_un;\n   };\n  \
    \ #define s6_addr _S6_un._S6_u8\n"
- title: 3.3 Socket Address Structure for 4.3BSD-Based Systems
  contents:
  - "3.3 Socket Address Structure for 4.3BSD-Based Systems\n   In the socket interface,\
    \ a different protocol-specific data structure\n   is defined to carry the addresses\
    \ for each protocol suite.  Each\n   protocol- specific data structure is designed\
    \ so it can be cast into a\n   protocol- independent data structure -- the \"\
    sockaddr\" structure.\n   Each has a \"family\" field that overlays the \"sa_family\"\
    \ of the\n   sockaddr data structure.  This field identifies the type of the data\n\
    \   structure.\n   The sockaddr_in structure is the protocol-specific address\
    \ data\n   structure for IPv4.  It is used to pass addresses between applications\n\
    \   and the system in the socket functions.  The following sockaddr_in6\n   structure\
    \ holds IPv6 addresses and is defined as a result of including\n   the <netinet/in.h>\
    \ header:\n"
- title: struct sockaddr_in6 {
  contents:
  - "struct sockaddr_in6 {\n    sa_family_t     sin6_family;    /* AF_INET6 */\n \
    \   in_port_t       sin6_port;      /* transport layer port # */\n    uint32_t\
    \        sin6_flowinfo;  /* IPv6 traffic class & flow info */\n    struct in6_addr\
    \ sin6_addr;      /* IPv6 address */\n    uint32_t        sin6_scope_id;  /* set\
    \ of interfaces for a scope */\n"
- title: '};'
  contents:
  - "};\n   This structure is designed to be compatible with the sockaddr data\n \
    \  structure used in the 4.3BSD release.\n   The sin6_family field identifies\
    \ this as a sockaddr_in6 structure.\n   This field overlays the sa_family field\
    \ when the buffer is cast to a\n   sockaddr data structure.  The value of this\
    \ field must be AF_INET6.\n   The sin6_port field contains the 16-bit UDP or TCP\
    \ port number.  This\n   field is used in the same way as the sin_port field of\
    \ the\n   sockaddr_in structure.  The port number is stored in network byte\n\
    \   order.\n   The sin6_flowinfo field is a 32-bit field that contains two pieces\
    \ of\n   information: the traffic class and the flow label.  The contents and\n\
    \   interpretation of this member is specified in [1].  The sin6_flowinfo\n  \
    \ field SHOULD be set to zero by an implementation prior to using the\n   sockaddr_in6\
    \ structure by an application on receive operations.\n   The sin6_addr field is\
    \ a single in6_addr structure (defined in the\n   previous section).  This field\
    \ holds one 128-bit IPv6 address.  The\n   address is stored in network byte order.\n\
    \   The ordering of elements in this structure is specifically designed\n   so\
    \ that when sin6_addr field is aligned on a 64-bit boundary, the\n   start of\
    \ the structure will also be aligned on a 64-bit boundary.\n   This is done for\
    \ optimum performance on 64-bit architectures.\n   The sin6_scope_id field is\
    \ a 32-bit integer that identifies a set of\n   interfaces as appropriate for\
    \ the scope of the address carried in the\n   sin6_addr field.  For a link scope\
    \ sin6_addr sin6_scope_id would be\n   an interface index.  For a site scope sin6_addr,\
    \ sin6_scope_id would\n   be a site identifier.  The mapping of sin6_scope_id\
    \ to an interface\n   or set of interfaces is left to implementation and future\n\
    \   specifications on the subject of site identifiers.\n   Notice that the sockaddr_in6\
    \ structure will normally be larger than\n   the generic sockaddr structure. \
    \ On many existing implementations the\n   sizeof(struct sockaddr_in) equals sizeof(struct\
    \ sockaddr), with both\n   being 16 bytes.  Any existing code that makes this\
    \ assumption needs\n   to be examined carefully when converting to IPv6.\n"
- title: 3.4 Socket Address Structure for 4.4BSD-Based Systems
  contents:
  - "3.4 Socket Address Structure for 4.4BSD-Based Systems\n   The 4.4BSD release\
    \ includes a small, but incompatible change to the\n   socket interface.  The\
    \ \"sa_family\" field of the sockaddr data\n   structure was changed from a 16-bit\
    \ value to an 8-bit value, and the\n   space saved used to hold a length field,\
    \ named \"sa_len\".  The\n   sockaddr_in6 data structure given in the previous\
    \ section cannot be\n   correctly cast into the newer sockaddr data structure.\
    \  For this\n   reason, the following alternative IPv6 address data structure\
    \ is\n   provided to be used on systems based on 4.4BSD.  It is defined as a\n\
    \   result of including the <netinet/in.h> header.\n"
- title: struct sockaddr_in6 {
  contents:
  - "struct sockaddr_in6 {\n    uint8_t         sin6_len;       /* length of this\
    \ struct */\n    sa_family_t     sin6_family;    /* AF_INET6 */\n    in_port_t\
    \       sin6_port;      /* transport layer port # */\n    uint32_t        sin6_flowinfo;\
    \  /* IPv6 flow information */\n    struct in6_addr sin6_addr;      /* IPv6 address\
    \ */\n    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */\n"
- title: '};'
  contents:
  - "};\n   The only differences between this data structure and the 4.3BSD\n   variant\
    \ are the inclusion of the length field, and the change of the\n   family field\
    \ to a 8-bit data type.  The definitions of all the other\n   fields are identical\
    \ to the structure defined in the previous\n   section.\n   Systems that provide\
    \ this version of the sockaddr_in6 data structure\n   must also declare SIN6_LEN\
    \ as a result of including the\n   <netinet/in.h> header.  This macro allows applications\
    \ to determine\n   whether they are being built on a system that supports the\
    \ 4.3BSD or\n   4.4BSD variants of the data structure.\n"
- title: 3.5 The Socket Functions
  contents:
  - "3.5 The Socket Functions\n   Applications call the socket() function to create\
    \ a socket descriptor\n   that represents a communication endpoint.  The arguments\
    \ to the\n   socket() function tell the system which protocol to use, and what\n\
    \   format address structure will be used in subsequent functions.  For\n   example,\
    \ to create an IPv4/TCP socket, applications make the call:\n      s = socket(PF_INET,\
    \ SOCK_STREAM, 0);\n   To create an IPv4/UDP socket, applications make the call:\n\
    \      s = socket(PF_INET, SOCK_DGRAM, 0);\n   Applications may create IPv6/TCP\
    \ and IPv6/UDP sockets by simply using\n   the constant PF_INET6 instead of PF_INET\
    \ in the first argument.  For\n   example, to create an IPv6/TCP socket, applications\
    \ make the call:\n      s = socket(PF_INET6, SOCK_STREAM, 0);\n   To create an\
    \ IPv6/UDP socket, applications make the call:\n      s = socket(PF_INET6, SOCK_DGRAM,\
    \ 0);\n   Once the application has created a PF_INET6 socket, it must use the\n\
    \   sockaddr_in6 address structure when passing addresses in to the\n   system.\
    \  The functions that the application uses to pass addresses\n   into the system\
    \ are:\n      bind()\n      connect()\n      sendmsg()\n      sendto()\n   The\
    \ system will use the sockaddr_in6 address structure to return\n   addresses to\
    \ applications that are using PF_INET6 sockets.  The\n   functions that return\
    \ an address from the system to an application\n   are:\n      accept()\n    \
    \  recvfrom()\n      recvmsg()\n      getpeername()\n      getsockname()\n   No\
    \ changes to the syntax of the socket functions are needed to\n   support IPv6,\
    \ since all of the \"address carrying\" functions use an\n   opaque address pointer,\
    \ and carry an address length as a function\n   argument.\n"
- title: 3.6 Compatibility with IPv4 Applications
  contents:
  - "3.6 Compatibility with IPv4 Applications\n   In order to support the large base\
    \ of applications using the original\n   API, system implementations must provide\
    \ complete source and binary\n   compatibility with the original API.  This means\
    \ that systems must\n   continue to support PF_INET sockets and the sockaddr_in\
    \ address\n   structure.  Applications must be able to create IPv4/TCP and IPv4/UDP\n\
    \   sockets using the PF_INET constant in the socket() function, as\n   described\
    \ in the previous section.  Applications should be able to\n   hold a combination\
    \ of IPv4/TCP, IPv4/UDP, IPv6/TCP and IPv6/UDP\n   sockets simultaneously within\
    \ the same process.\n   Applications using the original API should continue to\
    \ operate as\n   they did on systems supporting only IPv4.  That is, they should\n\
    \   continue to interoperate with IPv4 nodes.\n"
- title: 3.7 Compatibility with IPv4 Nodes
  contents:
  - "3.7 Compatibility with IPv4 Nodes\n   The API also provides a different type\
    \ of compatibility: the ability\n   for IPv6 applications to interoperate with\
    \ IPv4 applications.  This\n   feature uses the IPv4-mapped IPv6 address format\
    \ defined in the IPv6\n   addressing architecture specification [2].  This address\
    \ format\n   allows the IPv4 address of an IPv4 node to be represented as an IPv6\n\
    \   address.  The IPv4 address is encoded into the low-order 32 bits of\n   the\
    \ IPv6 address, and the high-order 96 bits hold the fixed prefix\n   0:0:0:0:0:FFFF.\
    \  IPv4- mapped addresses are written as follows:\n      ::FFFF:<IPv4-address>\n\
    \   These addresses can be generated automatically by the\n   getipnodebyname()\
    \ function when the specified host has only IPv4\n   addresses (as described in\
    \ Section 6.1).\n   Applications may use PF_INET6 sockets to open TCP connections\
    \ to IPv4\n   nodes, or send UDP packets to IPv4 nodes, by simply encoding the\n\
    \   destination's IPv4 address as an IPv4-mapped IPv6 address, and\n   passing\
    \ that address, within a sockaddr_in6 structure, in the\n   connect() or sendto()\
    \ call.  When applications use PF_INET6 sockets\n   to accept TCP connections\
    \ from IPv4 nodes, or receive UDP packets\n   from IPv4 nodes, the system returns\
    \ the peer's address to the\n   application in the accept(), recvfrom(), or getpeername()\
    \ call using\n   a sockaddr_in6 structure encoded this way.\n   Few applications\
    \ will likely need to know which type of node they are\n   interoperating with.\
    \  However, for those applications that do need to\n   know, the IN6_IS_ADDR_V4MAPPED()\
    \ macro, defined in Section 6.7, is\n   provided.\n"
- title: 3.8 IPv6 Wildcard Address
  contents:
  - "3.8 IPv6 Wildcard Address\n   While the bind() function allows applications to\
    \ select the source IP\n   address of UDP packets and TCP connections, applications\
    \ often want\n   the system to select the source address for them.  With IPv4,\
    \ one\n   specifies the address as the symbolic constant INADDR_ANY (called the\n\
    \   \"wildcard\" address) in the bind() call, or simply omits the bind()\n   entirely.\n\
    \   Since the IPv6 address type is a structure (struct in6_addr), a\n   symbolic\
    \ constant can be used to initialize an IPv6 address variable,\n   but cannot\
    \ be used in an assignment.  Therefore systems provide the\n   IPv6 wildcard address\
    \ in two forms.\n   The first version is a global variable named \"in6addr_any\"\
    \ that is an\n   in6_addr structure.  The extern declaration for this variable\
    \ is\n   defined in <netinet/in.h>:\n      extern const struct in6_addr in6addr_any;\n\
    \   Applications use in6addr_any similarly to the way they use INADDR_ANY\n  \
    \ in IPv4.  For example, to bind a socket to port number 23, but let\n   the system\
    \ select the source address, an application could use the\n   following code:\n\
    \      struct sockaddr_in6 sin6;\n       . . .\n      sin6.sin6_family = AF_INET6;\n\
    \      sin6.sin6_flowinfo = 0;\n      sin6.sin6_port = htons(23);\n      sin6.sin6_addr\
    \ = in6addr_any;  /* structure assignment */\n       . . .\n      if (bind(s,\
    \ (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n              . . .\n   The\
    \ other version is a symbolic constant named IN6ADDR_ANY_INIT and\n   is defined\
    \ in <netinet/in.h>.  This constant can be used to\n   initialize an in6_addr\
    \ structure:\n      struct in6_addr anyaddr = IN6ADDR_ANY_INIT;\n   Note that\
    \ this constant can be used ONLY at declaration time.  It can\n   not be used\
    \ to assign a previously declared in6_addr structure.  For\n   example, the following\
    \ code will not work:\n      /* This is the WRONG way to assign an unspecified\
    \ address */\n      struct sockaddr_in6 sin6;\n       . . .\n      sin6.sin6_addr\
    \ = IN6ADDR_ANY_INIT; /* will NOT compile */\n   Be aware that the IPv4 INADDR_xxx\
    \ constants are all defined in host\n   byte order but the IPv6 IN6ADDR_xxx constants\
    \ and the IPv6\n   in6addr_xxx externals are defined in network byte order.\n"
- title: 3.9 IPv6 Loopback Address
  contents:
  - "3.9 IPv6 Loopback Address\n   Applications may need to send UDP packets to, or\
    \ originate TCP\n   connections to, services residing on the local node.  In IPv4,\
    \ they\n   can do this by using the constant IPv4 address INADDR_LOOPBACK in\n\
    \   their connect(), sendto(), or sendmsg() call.\n   IPv6 also provides a loopback\
    \ address to contact local TCP and UDP\n   services.  Like the unspecified address,\
    \ the IPv6 loopback address is\n   provided in two forms -- a global variable\
    \ and a symbolic constant.\n   The global variable is an in6_addr structure named\n\
    \   \"in6addr_loopback.\"  The extern declaration for this variable is\n   defined\
    \ in <netinet/in.h>:\n      extern const struct in6_addr in6addr_loopback;\n \
    \  Applications use in6addr_loopback as they would use INADDR_LOOPBACK\n   in\
    \ IPv4 applications (but beware of the byte ordering difference\n   mentioned\
    \ at the end of the previous section).  For example, to open\n   a TCP connection\
    \ to the local telnet server, an application could use\n   the following code:\n\
    \      struct sockaddr_in6 sin6;\n       . . .\n      sin6.sin6_family = AF_INET6;\n\
    \      sin6.sin6_flowinfo = 0;\n      sin6.sin6_port = htons(23);\n      sin6.sin6_addr\
    \ = in6addr_loopback;  /* structure assignment */\n       . . .\n      if (connect(s,\
    \ (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n              . . .\n   The\
    \ symbolic constant is named IN6ADDR_LOOPBACK_INIT and is defined\n   in <netinet/in.h>.\
    \  It can be used at declaration time ONLY; for\n   example:\n      struct in6_addr\
    \ loopbackaddr = IN6ADDR_LOOPBACK_INIT;\n   Like IN6ADDR_ANY_INIT, this constant\
    \ cannot be used in an assignment\n   to a previously declared IPv6 address variable.\n"
- title: 3.10 Portability Additions
  contents:
  - "3.10 Portability Additions\n   One simple addition to the sockets API that can\
    \ help application\n   writers is the \"struct sockaddr_storage\". This data structure\
    \ can\n   simplify writing code portable across multiple address families and\n\
    \   platforms.  This data structure is designed with the following goals.\n  \
    \    - It has a large enough implementation specific maximum size to\n       \
    \ store the desired set of protocol specific socket address data\n        structures.\
    \ Specifically, it is at least large enough to\n        accommodate sockaddr_in\
    \ and sockaddr_in6 and possibly other\n        protocol specific socket addresses\
    \ too.\n      - It is aligned at an appropriate boundary so protocol specific\n\
    \        socket address data structure pointers can be cast to it and\n      \
    \  access their fields without alignment problems. (e.g. pointers\n        to\
    \ sockaddr_in6 and/or sockaddr_in can be cast to it and access\n        fields\
    \ without alignment problems).\n      - It has the initial field(s) isomorphic\
    \ to the fields of the\n        \"struct sockaddr\" data structure on that implementation\
    \ which\n        can be used as a discriminants for deriving the protocol in use.\n\
    \        These initial field(s) would on most implementations either be a\n  \
    \      single field of type \"sa_family_t\" (isomorphic to sa_family\n       \
    \ field, 16 bits) or two fields of type uint8_t and sa_family_t\n        respectively,\
    \ (isomorphic to sa_len and sa_family_t, 8 bits\n        each).\n   An example\
    \ implementation design of such a data structure would be as\n   follows.\n"
- title: /*
  contents:
  - "/*\n * Desired design of maximum size and alignment\n */\n"
- title: '#define _SS_MAXSIZE    128  /* Implementation specific max size */'
  contents:
  - '#define _SS_MAXSIZE    128  /* Implementation specific max size */

    '
- title: '#define _SS_ALIGNSIZE  (sizeof (int64_t))'
  contents:
  - "#define _SS_ALIGNSIZE  (sizeof (int64_t))\n                         /* Implementation\
    \ specific desired alignment */\n"
- title: /*
  contents:
  - "/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n"
- title: '#define _SS_PAD1SIZE   (_SS_ALIGNSIZE - sizeof (sa_family_t))'
  contents:
  - '#define _SS_PAD1SIZE   (_SS_ALIGNSIZE - sizeof (sa_family_t))

    '
- title: '#define _SS_PAD2SIZE   (_SS_MAXSIZE - (sizeof (sa_family_t)+'
  contents:
  - "#define _SS_PAD2SIZE   (_SS_MAXSIZE - (sizeof (sa_family_t)+\n              \
    \                _SS_PAD1SIZE + _SS_ALIGNSIZE))\n"
- title: struct sockaddr_storage {
  contents:
  - "struct sockaddr_storage {\n    sa_family_t  __ss_family;     /* address family\
    \ */\n    /* Following fields are implementation specific */\n    char      __ss_pad1[_SS_PAD1SIZE];\n\
    \              /* 6 byte pad, this is to make implementation\n              /*\
    \ specific pad up to alignment field that */\n              /* follows explicit\
    \ in the data structure */\n    int64_t   __ss_align;     /* field to force desired\
    \ structure */\n               /* storage alignment */\n    char      __ss_pad2[_SS_PAD2SIZE];\n\
    \              /* 112 byte pad to achieve desired size, */\n              /* _SS_MAXSIZE\
    \ value minus size of ss_family */\n              /* __ss_pad1, __ss_align fields\
    \ is 112 */\n"
- title: '};'
  contents:
  - "};\n   On implementations where sockaddr data structure includes a \"sa_len\"\
    ,\n   field this data structure would look like this:\n"
- title: /*
  contents:
  - "/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n"
- title: '#define _SS_PAD1SIZE (_SS_ALIGNSIZE -'
  contents:
  - "#define _SS_PAD1SIZE (_SS_ALIGNSIZE -\n                            (sizeof (uint8_t)\
    \ + sizeof (sa_family_t))\n"
- title: '#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof (sa_family_t)+'
  contents:
  - "#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof (sa_family_t)+\n                \
    \              _SS_PAD1SIZE + _SS_ALIGNSIZE))\n"
- title: struct sockaddr_storage {
  contents:
  - "struct sockaddr_storage {\n    uint8_t      __ss_len;        /* address length\
    \ */\n    sa_family_t  __ss_family;     /* address family */\n    /* Following\
    \ fields are implementation specific */\n    char         __ss_pad1[_SS_PAD1SIZE];\n\
    \                  /* 6 byte pad, this is to make implementation\n           \
    \       /* specific pad up to alignment field that */\n                  /* follows\
    \ explicit in the data structure */\n    int64_t      __ss_align;  /* field to\
    \ force desired structure */\n                  /* storage alignment */\n    char\
    \         __ss_pad2[_SS_PAD2SIZE];\n                  /* 112 byte pad to achieve\
    \ desired size, */\n                  /* _SS_MAXSIZE value minus size of ss_len,\
    \ */\n                  /* __ss_family, __ss_pad1, __ss_align fields is 112 */\n"
- title: '};'
  contents:
  - "};\n   The above example implementation illustrates a data structure which\n\
    \   will align on a 64 bit boundary. An implementation specific field\n   \"__ss_align\"\
    \ along \"__ss_pad1\" is used to force a 64-bit alignment\n   which covers proper\
    \ alignment good enough for needs of sockaddr_in6\n   (IPv6), sockaddr_in (IPv4)\
    \ address data structures.  The size of\n   padding fields __ss_pad1 depends on\
    \ the chosen alignment boundary.\n   The size of padding field __ss_pad2 depends\
    \ on the value of overall\n   size chosen for the total size of the structure.\
    \ This size and\n   alignment are represented in the above example by implementation\n\
    \   specific (not required) constants _SS_MAXSIZE (chosen value 128) and\n   _SS_ALIGNMENT\
    \ (with chosen value 8).  Constants _SS_PAD1SIZE (derived\n   value 6) and _SS_PAD2SIZE\
    \ (derived value 112) are also for\n   illustration and not required.  The implementation\
    \ specific\n   definitions and structure field names above start with an underscore\n\
    \   to denote implementation private namespace.  Portable code is not\n   expected\
    \ to access or reference those fields or constants.\n   The sockaddr_storage structure\
    \ solves the problem of declaring\n   storage for automatic variables which is\
    \ large enough and aligned\n   enough for storing socket address data structure\
    \ of any family. For\n   example, code with a file descriptor and without the\
    \ context of the\n   address family can pass a pointer to a variable of this type\
    \ where a\n   pointer to a socket address structure is expected in calls such\
    \ as\n   getpeername() and determine the address family by accessing the\n   received\
    \ content after the call.\n   The sockaddr_storage structure may also be useful\
    \ and applied to\n   certain other interfaces where a generic socket address large\
    \ enough\n   and aligned for use with multiple address families may be needed.\
    \ A\n   discussion of those interfaces is outside the scope of this document.\n\
    \   Also, much existing code assumes that any socket address structure\n   can\
    \ fit in a generic sockaddr structure.  While this has been true\n   for IPv4\
    \ socket address structures, it has always been false for Unix\n   domain socket\
    \ address structures (but in practice this has not been a\n   problem) and it\
    \ is also false for IPv6 socket address structures\n   (which can be a problem).\n\
    \   So now an application can do the following:\n      struct sockaddr_storage\
    \ __ss;\n      struct sockaddr_in6 *sin6;\n      sin6 = (struct sockaddr_in6 *)\
    \ &__ss;\n"
- title: 4. Interface Identification
  contents:
  - "4. Interface Identification\n   This API uses an interface index (a small positive\
    \ integer) to\n   identify the local interface on which a multicast group is joined\n\
    \   (Section 5.3).  Additionally, the advanced API [4] uses these same\n   interface\
    \ indexes to identify the interface on which a datagram is\n   received, or to\
    \ specify the interface on which a datagram is to be\n   sent.\n   Interfaces\
    \ are normally known by names such as \"le0\", \"sl1\", \"ppp2\",\n   and the\
    \ like.  On Berkeley-derived implementations, when an interface\n   is made known\
    \ to the system, the kernel assigns a unique positive\n   integer value (called\
    \ the interface index) to that interface.  These\n   are small positive integers\
    \ that start at 1.  (Note that 0 is never\n   used for an interface index.) There\
    \ may be gaps so that there is no\n   current interface for a particular positive\
    \ interface index.\n   This API defines two functions that map between an interface\
    \ name and\n   index, a third function that returns all the interface names and\n\
    \   indexes, and a fourth function to return the dynamic memory allocated\n  \
    \ by the previous function.  How these functions are implemented is\n   left up\
    \ to the implementation.  4.4BSD implementations can implement\n   these functions\
    \ using the existing sysctl() function with the\n   NET_RT_IFLIST command.  Other\
    \ implementations may wish to use ioctl()\n   for this purpose.\n"
- title: 4.1 Name-to-Index
  contents:
  - "4.1 Name-to-Index\n   The first function maps an interface name into its corresponding\n\
    \   index.\n      #include <net/if.h>\n      unsigned int  if_nametoindex(const\
    \ char *ifname);\n   If the specified interface name does not exist, the return\
    \ value is\n   0, and errno is set to ENXIO.  If there was a system error (such\
    \ as\n   running out of memory), the return value is 0 and errno is set to the\n\
    \   proper value (e.g., ENOMEM).\n"
- title: 4.2 Index-to-Name
  contents:
  - "4.2 Index-to-Name\n   The second function maps an interface index into its corresponding\n\
    \   name.\n      #include <net/if.h>\n      char  *if_indextoname(unsigned int\
    \ ifindex, char *ifname);\n   The ifname argument must point to a buffer of at\
    \ least IF_NAMESIZE\n   bytes into which the interface name corresponding to the\
    \ specified\n   index is returned.  (IF_NAMESIZE is also defined in <net/if.h>\
    \ and\n   its value includes a terminating null byte at the end of the\n   interface\
    \ name.) This pointer is also the return value of the\n   function.  If there\
    \ is no interface corresponding to the specified\n   index, NULL is returned,\
    \ and errno is set to ENXIO, if there was a\n   system error (such as running\
    \ out of memory), if_indextoname returns\n   NULL and errno would be set to the\
    \ proper value (e.g., ENOMEM).\n"
- title: 4.3 Return All Interface Names and Indexes
  contents:
  - "4.3 Return All Interface Names and Indexes\n   The if_nameindex structure holds\
    \ the information about a single\n   interface and is defined as a result of including\
    \ the <net/if.h>\n   header.\n      struct if_nameindex {\n        unsigned int\
    \   if_index;  /* 1, 2, ... */\n        char          *if_name;   /* null terminated\
    \ name: \"le0\", ... */\n      };\n   The final function returns an array of if_nameindex\
    \ structures, one\n   structure per interface.\n      struct if_nameindex  *if_nameindex(void);\n\
    \   The end of the array of structures is indicated by a structure with\n   an\
    \ if_index of 0 and an if_name of NULL.  The function returns a NULL\n   pointer\
    \ upon an error, and would set errno to the appropriate value.\n   The memory\
    \ used for this array of structures along with the interface\n   names pointed\
    \ to by the if_name members is obtained dynamically.\n   This memory is freed\
    \ by the next function.\n"
- title: 4.4 Free Memory
  contents:
  - "4.4 Free Memory\n   The following function frees the dynamic memory that was\
    \ allocated by\n   if_nameindex().\n      #include <net/if.h>\n      void  if_freenameindex(struct\
    \ if_nameindex *ptr);\n   The argument to this function must be a pointer that\
    \ was returned by\n   if_nameindex().\n   Currently net/if.h doesn't have prototype\
    \ definitions for functions\n   and it is recommended that these definitions be\
    \ defined in net/if.h\n   as well and the struct if_nameindex{}.\n"
- title: 5. Socket Options
  contents:
  - "5. Socket Options\n   A number of new socket options are defined for IPv6.  All\
    \ of these\n   new options are at the IPPROTO_IPV6 level.  That is, the \"level\"\
    \n   parameter in the getsockopt() and setsockopt() calls is IPPROTO_IPV6\n  \
    \ when using these options.  The constant name prefix IPV6_ is used in\n   all\
    \ of the new socket options.  This serves to clearly identify these\n   options\
    \ as applying to IPv6.\n   The declaration for IPPROTO_IPV6, the new IPv6 socket\
    \ options, and\n   related constants defined in this section are obtained by including\n\
    \   the header <netinet/in.h>.\n"
- title: 5.1 Unicast Hop Limit
  contents:
  - "5.1 Unicast Hop Limit\n   A new setsockopt() option controls the hop limit used\
    \ in outgoing\n   unicast IPv6 packets.  The name of this option is IPV6_UNICAST_HOPS,\n\
    \   and it is used at the IPPROTO_IPV6 layer.  The following example\n   illustrates\
    \ how it is used:\n      int  hoplimit = 10;\n      if (setsockopt(s, IPPROTO_IPV6,\
    \ IPV6_UNICAST_HOPS,\n                     (char *) &hoplimit, sizeof(hoplimit))\
    \ == -1)\n          perror(\"setsockopt IPV6_UNICAST_HOPS\");\n   When the IPV6_UNICAST_HOPS\
    \ option is set with setsockopt(), the\n   option value given is used as the hop\
    \ limit for all subsequent\n   unicast packets sent via that socket.  If the option\
    \ is not set, the\n   system selects a default value.  The integer hop limit value\
    \ (called\n   x) is interpreted as follows:\n      x < -1:        return an error\
    \ of EINVAL\n      x == -1:       use kernel default\n      0 <= x <= 255: use\
    \ x\n      x >= 256:      return an error of EINVAL\n   The IPV6_UNICAST_HOPS\
    \ option may be used with getsockopt() to\n   determine the hop limit value that\
    \ the system will use for subsequent\n   unicast packets sent via that socket.\
    \  For example:\n      int  hoplimit;\n      size_t  len = sizeof(hoplimit);\n\
    \      if (getsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,\n                  \
    \   (char *) &hoplimit, &len) == -1)\n          perror(\"getsockopt IPV6_UNICAST_HOPS\"\
    );\n      else\n          printf(\"Using %d for hop limit.\\n\", hoplimit);\n"
- title: 5.2 Sending and Receiving Multicast Packets
  contents:
  - "5.2 Sending and Receiving Multicast Packets\n   IPv6 applications may send UDP\
    \ multicast packets by simply specifying\n   an IPv6 multicast address in the\
    \ address argument of the sendto()\n   function.\n   Three socket options at the\
    \ IPPROTO_IPV6 layer control some of the\n   parameters for sending multicast\
    \ packets.  Setting these options is\n   not required: applications may send multicast\
    \ packets without using\n   these options.  The setsockopt() options for controlling\
    \ the sending\n   of multicast packets are summarized below.  These three options\
    \ can\n   also be used with getsockopt().\n      IPV6_MULTICAST_IF\n         Set\
    \ the interface to use for outgoing multicast packets.  The\n         argument\
    \ is the index of the interface to use.\n         Argument type: unsigned int\n\
    \      IPV6_MULTICAST_HOPS\n         Set the hop limit to use for outgoing multicast\
    \ packets.  (Note\n         a separate option - IPV6_UNICAST_HOPS - is provided\
    \ to set the\n         hop limit to use for outgoing unicast packets.)\n     \
    \    The interpretation of the argument is the same as for the\n         IPV6_UNICAST_HOPS\
    \ option:\n           x < -1:        return an error of EINVAL\n           x ==\
    \ -1:       use kernel default\n           0 <= x <= 255: use x\n           x\
    \ >= 256:      return an error of EINVAL\n           If IPV6_MULTICAST_HOPS is\
    \ not set, the default is 1\n           (same as IPv4 today)\n         Argument\
    \ type: int\n      IPV6_MULTICAST_LOOP\n         If a multicast datagram is sent\
    \ to a group to which the sending\n         host itself belongs (on the outgoing\
    \ interface), a copy of the\n         datagram is looped back by the IP layer\
    \ for local delivery if\n         this option is set to 1.  If this option is\
    \ set to 0 a copy\n         is not looped back.  Other option values return an\
    \ error of\n         EINVAL.\n         If IPV6_MULTICAST_LOOP is not set, the\
    \ default is 1 (loopback;\n         same as IPv4 today).\n         Argument type:\
    \ unsigned int\n   The reception of multicast packets is controlled by the two\n\
    \   setsockopt() options summarized below.  An error of EOPNOTSUPP is\n   returned\
    \ if these two options are used with getsockopt().\n      IPV6_JOIN_GROUP\n  \
    \       Join a multicast group on a specified local interface.  If the\n     \
    \    interface index is specified as 0, the kernel chooses the local\n       \
    \  interface.  For example, some kernels look up the multicast\n         group\
    \ in the normal IPv6 routing table and using the resulting\n         interface.\n\
    \         Argument type: struct ipv6_mreq\n      IPV6_LEAVE_GROUP\n         Leave\
    \ a multicast group on a specified interface.\n         Argument type: struct\
    \ ipv6_mreq\n   The argument type of both of these options is the ipv6_mreq structure,\n\
    \   defined as a result of including the <netinet/in.h> header;\n   struct ipv6_mreq\
    \ {\n       struct in6_addr ipv6mr_multiaddr; /* IPv6 multicast addr */\n    \
    \   unsigned int    ipv6mr_interface; /* interface index */\n   };\n   Note that\
    \ to receive multicast datagrams a process must join the\n   multicast group and\
    \ bind the UDP port to which datagrams will be\n   sent.  Some processes also\
    \ bind the multicast group address to the\n   socket, in addition to the port,\
    \ to prevent other datagrams destined\n   to that same port from being delivered\
    \ to the socket.\n"
- title: 6. Library Functions
  contents:
  - "6. Library Functions\n   New library functions are needed to perform a variety\
    \ of operations\n   with IPv6 addresses.  Functions are needed to lookup IPv6\
    \ addresses\n   in the Domain Name System (DNS).  Both forward lookup (nodename-to-\n\
    \   address translation) and reverse lookup (address-to-nodename\n   translation)\
    \ need to be supported.  Functions are also needed to\n   convert IPv6 addresses\
    \ between their binary and textual form.\n   We note that the two existing functions,\
    \ gethostbyname() and\n   gethostbyaddr(), are left as-is.  New functions are\
    \ defined to handle\n   both IPv4 and IPv6 addresses.\n"
- title: 6.1 Nodename-to-Address Translation
  contents:
  - "6.1 Nodename-to-Address Translation\n   The commonly used function gethostbyname()\
    \ is inadequate for many\n   applications, first because it provides no way for\
    \ the caller to\n   specify anything about the types of addresses desired (IPv4\
    \ only,\n   IPv6 only, IPv4-mapped IPv6 are OK, etc.), and second because many\n\
    \   implementations of this function are not thread safe.  RFC 2133\n   defined\
    \ a function named gethostbyname2() but this function was also\n   inadequate,\
    \ first because its use required setting a global option\n   (RES_USE_INET6) when\
    \ IPv6 addresses were required, and second because\n   a flag argument is needed\
    \ to provide the caller with additional\n   control over the types of addresses\
    \ required.\n   The following function is new and must be thread safe:\n   #include\
    \ <sys/socket.h>\n   #include <netdb.h>\n   struct hostent *getipnodebyname(const\
    \ char *name, int af, int flags\n                                       int *error_num);\n\
    \   The name argument can be either a node name or a numeric address\n   string\
    \ (i.e., a dotted-decimal IPv4 address or an IPv6 hex address).\n   The af argument\
    \ specifies the address family, either AF_INET or\n   AF_INET6. The error_num\
    \ value is returned to the caller, via a\n   pointer, with the appropriate error\
    \ code in error_num, to support\n   thread safe error code returns.  error_num\
    \ will be set to one of the\n   following values:\n      HOST_NOT_FOUND\n    \
    \     No such host is known.\n      NO_ADDRESS\n         The server recognised\
    \ the request and the name but no address is\n         available.  Another type\
    \ of request to the name server for the\n         domain might return an answer.\n\
    \      NO_RECOVERY\n         An unexpected server failure occurred which cannot\
    \ be recovered.\n      TRY_AGAIN\n         A temporary and possibly transient\
    \ error occurred, such as a\n         failure of a server to respond.\n   The\
    \ flags argument specifies the types of addresses that are searched\n   for, and\
    \ the types of addresses that are returned.  We note that a\n   special flags\
    \ value of AI_DEFAULT (defined below) should handle most\n   applications.\n \
    \  That is, porting simple applications to use IPv6 replaces the call\n      hptr\
    \ = gethostbyname(name);\n   with\n      hptr = getipnodebyname(name, AF_INET6,\
    \ AI_DEFAULT, &error_num);\n   and changes any subsequent error diagnosis code\
    \ to use error_num\n   instead of externally declared variables, such as h_errno.\n\
    \   Applications desiring finer control over the types of addresses\n   searched\
    \ for and returned, can specify other combinations of the\n   flags argument.\n\
    \   A flags of 0 implies a strict interpretation of the af argument:\n      -\
    \ If flags is 0 and af is AF_INET, then the caller wants only\n        IPv4 addresses.\
    \  A query is made for A records.  If successful,\n        the IPv4 addresses\
    \ are returned and the h_length member of the\n        hostent structure will\
    \ be 4, else the function returns a NULL\n        pointer.\n      -  If flags\
    \ is 0 and if af is AF_INET6, then the caller wants only\n        IPv6 addresses.\
    \  A query is made for AAAA records.  If\n        successful, the IPv6 addresses\
    \ are returned and the h_length\n        member of the hostent structure will\
    \ be 16, else the function\n        returns a NULL pointer.\n   Other constants\
    \ can be logically-ORed into the flags argument, to\n   modify the behavior of\
    \ the function.\n      - If the AI_V4MAPPED flag is specified along with an af\
    \ of\n        AF_INET6, then the caller will accept IPv4-mapped IPv6\n       \
    \ addresses.  That is, if no AAAA records are found then a query\n        is made\
    \ for A records and any found are returned as IPv4-mapped\n        IPv6 addresses\
    \ (h_length will be 16).  The AI_V4MAPPED flag is\n        ignored unless af equals\
    \ AF_INET6.\n      - The AI_ALL flag is used in conjunction with the AI_V4MAPPED\n\
    \        flag, and is only used with the IPv6 address family.  When AI_ALL\n \
    \       is logically or'd with AI_V4MAPPED flag then the caller wants\n      \
    \  all addresses: IPv6 and IPv4-mapped IPv6.  A query is first made\n        for\
    \ AAAA records and if successful, the IPv6 addresses are\n        returned. Another\
    \ query is then made for A records and any found\n        are returned as IPv4-mapped\
    \ IPv6 addresses. h_length will be 16.\n        Only if both queries fail does\
    \ the function return a NULL pointer.\n        This flag is ignored unless af\
    \ equals AF_INET6.\n      - The AI_ADDRCONFIG flag specifies that a query for\
    \ AAAA records\n        should occur only if the node has at least one IPv6 source\n\
    \        address configured and a query for A records should occur only\n    \
    \    if the node has at least one IPv4 source address configured.\n        For\
    \ example, if the node has no IPv6 source addresses\n        configured, and af\
    \ equals AF_INET6, and the node name being\n        looked up has both AAAA and\
    \ A records, then:\n            (a) if only AI_ADDRCONFIG is specified, the function\n\
    \                returns a NULL pointer;\n            (b) if AI_ADDRCONFIG | AI_V4MAPPED\
    \ is specified, the A\n                records are returned as IPv4-mapped IPv6\
    \ addresses;\n   The special flags value of AI_DEFAULT is defined as\n      #define\
    \  AI_DEFAULT  (AI_V4MAPPED | AI_ADDRCONFIG)\n   We noted that the getipnodebyname()\
    \ function must allow the name\n   argument to be either a node name or a literal\
    \ address string (i.e.,\n   a dotted-decimal IPv4 address or an IPv6 hex address).\
    \  This saves\n   applications from having to call inet_pton() to handle literal\n\
    \   address strings.\n   There are four scenarios based on the type of literal\
    \ address string\n   and the value of the af argument.\n   The two simple cases\
    \ are:\n   When name is a dotted-decimal IPv4 address and af equals AF_INET, or\n\
    \   when name is an IPv6 hex address and af equals AF_INET6.  The members\n  \
    \ of the returned hostent structure are: h_name points to a copy of the\n   name\
    \ argument, h_aliases is a NULL pointer, h_addrtype is a copy of\n   the af argument,\
    \ h_length is either 4 (for AF_INET) or 16 (for\n   AF_INET6), h_addr_list[0]\
    \ is a pointer to the 4-byte or 16-byte\n   binary address, and h_addr_list[1]\
    \ is a NULL pointer.\n   When name is a dotted-decimal IPv4 address and af equals\
    \ AF_INET6,\n   and flags equals AI_V4MAPPED, an IPv4-mapped IPv6 address is\n\
    \   returned:  h_name points to an IPv6 hex address containing the IPv4-\n   mapped\
    \ IPv6 address, h_aliases is a NULL pointer, h_addrtype is\n   AF_INET6, h_length\
    \ is 16, h_addr_list[0] is a pointer to the 16-byte\n   binary address, and h_addr_list[1]\
    \ is a NULL pointer.  If AI_V4MAPPED\n   is set (with or without AI_ALL) return\
    \ IPv4-mapped otherwise return\n   NULL.\n   It is an error when name is an IPv6\
    \ hex address and af equals\n   AF_INET.  The function's return value is a NULL\
    \ pointer and error_num\n   equals HOST_NOT_FOUND.\n"
- title: 6.2 Address-To-Nodename Translation
  contents:
  - "6.2 Address-To-Nodename Translation\n   The following function has the same arguments\
    \ as the existing\n   gethostbyaddr() function, but adds an error number.\n  \
    \    #include <sys/socket.h> #include <netdb.h>\n      struct hostent *getipnodebyaddr(const\
    \ void *src, size_t len,\n                                          int af, int\
    \ *error_num);\n   As with getipnodebyname(), getipnodebyaddr() must be thread\
    \ safe.\n   The error_num value is returned to the caller with the appropriate\n\
    \   error code, to support thread safe error code returns.  The following\n  \
    \ error conditions may be returned for error_num:\n      HOST_NOT_FOUND\n    \
    \     No such host is known.\n      NO_ADDRESS\n         The server recognized\
    \ the request and the name but no address\n         is available.  Another type\
    \ of request to the name server for\n         the domain might return an answer.\n\
    \      NO_RECOVERY\n         An unexpected server failure occurred which cannot\
    \ be\n         recovered.\n      TRY_AGAIN\n         A temporary and possibly\
    \ transient error occurred, such as a\n         failure of a server to respond.\n\
    \   One possible source of confusion is the handling of IPv4-mapped IPv6\n   addresses\
    \ and IPv4-compatible IPv6 addresses, but the following logic\n   should apply.\n\
    \      1.  If af is AF_INET6, and if len equals 16, and if the IPv6\n        \
    \  address is an IPv4-mapped IPv6 address or an IPv4-compatible\n          IPv6\
    \ address, then skip over the first 12 bytes of the IPv6\n          address, set\
    \ af to AF_INET, and set len to 4.\n      2.  If af is AF_INET, lookup the name\
    \ for the given IPv4 address\n          (e.g., query for a PTR record in the in-addr.arpa\
    \ domain).\n      3.  If af is AF_INET6, lookup the name for the given IPv6 address\n\
    \          (e.g., query for a PTR record in the ip6.int domain).\n      4.  If\
    \ the function is returning success, then the single address\n          that is\
    \ returned in the hostent structure is a copy of the\n          first argument\
    \ to the function with the same address family\n          that was passed as an\
    \ argument to this function.\n   All four steps listed are performed, in order.\
    \  Also note that the\n   IPv6 hex addresses \"::\" and \"::1\" MUST NOT be treated\
    \ as IPv4-\n   compatible addresses, and if the address is \"::\", HOST_NOT_FOUND\
    \ MUST\n   be returned and a query of the address not performed.\n   Also for\
    \ the macro in section 6.7 IN6_IS_ADDR_V4COMPAT MUST return\n   false for \"::\"\
    \ and \"::1\".\n"
- title: 6.3 Freeing memory for getipnodebyname and getipnodebyaddr
  contents:
  - "6.3 Freeing memory for getipnodebyname and getipnodebyaddr\n   The hostent structure\
    \ does not change from its existing definition.\n   This structure, and the information\
    \ pointed to by this structure, are\n   dynamically allocated by getipnodebyname\
    \ and getipnodebyaddr.  The\n   following function frees this memory:\n      #include\
    \ <netdb.h>\n      void freehostent(struct hostent *ptr);\n"
- title: 6.4 Protocol-Independent Nodename and Service Name Translation
  contents:
  - "6.4 Protocol-Independent Nodename and Service Name Translation\n   Nodename-to-address\
    \ translation is done in a protocol-independent\n   fashion using the getaddrinfo()\
    \ function that is taken from the\n   Institute of Electrical and Electronic Engineers\
    \ (IEEE) POSIX 1003.1g\n   (Protocol Independent Interfaces) draft specification\
    \ [3].\n   The official specification for this function will be the final POSIX\n\
    \   standard, with the following additional requirements:\n      -  getaddrinfo()\
    \ (along with the getnameinfo() function described\n         in the next section)\
    \ must be thread safe.\n      -  The AI_NUMERICHOST is new with this document.\n\
    \      -  All fields in socket address structures returned by\n         getaddrinfo()\
    \ that are not filled in through an explicit\n         argument (e.g., sin6_flowinfo\
    \ and sin_zero) must be set to 0.\n         (This makes it easier to compare socket\
    \ address structures.)\n      -  getaddrinfo() must fill in the length field of\
    \ a socket address\n         structure (e.g., sin6_len) on systems that support\
    \ this field.\n   We are providing this independent description of the function\
    \ because\n   POSIX standards are not freely available (as are IETF documents).\n\
    \      #include <sys/socket.h>\n      #include <netdb.h>\n      int getaddrinfo(const\
    \ char *nodename, const char *servname,\n                      const struct addrinfo\
    \ *hints,\n                      struct addrinfo **res);\n   The addrinfo structure\
    \ is defined as a result of including the\n   <netdb.h> header.\n  struct addrinfo\
    \ {\n    int     ai_flags;     /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */\n\
    \    int     ai_family;    /* PF_xxx */\n    int     ai_socktype;  /* SOCK_xxx\
    \ */\n    int     ai_protocol;  /* 0 or IPPROTO_xxx for IPv4 and IPv6 */\n   \
    \ size_t  ai_addrlen;   /* length of ai_addr */\n    char   *ai_canonname; /*\
    \ canonical name for nodename */\n    struct sockaddr  *ai_addr; /* binary address\
    \ */\n    struct addrinfo  *ai_next; /* next structure in linked list */\n  };\n\
    \   The return value from the function is 0 upon success or a nonzero\n   error\
    \ code.  The following names are the nonzero error codes from\n   getaddrinfo(),\
    \ and are defined in <netdb.h>:\n      EAI_ADDRFAMILY  address family for nodename\
    \ not supported\n      EAI_AGAIN       temporary failure in name resolution\n\
    \      EAI_BADFLAGS    invalid value for ai_flags\n      EAI_FAIL        non-recoverable\
    \ failure in name resolution\n      EAI_FAMILY      ai_family not supported\n\
    \      EAI_MEMORY      memory allocation failure\n      EAI_NODATA      no address\
    \ associated with nodename\n      EAI_NONAME      nodename nor servname provided,\
    \ or not known\n      EAI_SERVICE     servname not supported for ai_socktype\n\
    \      EAI_SOCKTYPE    ai_socktype not supported\n      EAI_SYSTEM      system\
    \ error returned in errno\n   The nodename and servname arguments are pointers\
    \ to null-terminated\n   strings or NULL.  One or both of these two arguments\
    \ must be a non-\n   NULL pointer.  In the normal client scenario, both the nodename\
    \ and\n   servname are specified.  In the normal server scenario, only the\n \
    \  servname is specified.  A non-NULL nodename string can be either a\n   node\
    \ name or a numeric host address string (i.e., a dotted-decimal\n   IPv4 address\
    \ or an IPv6 hex address).  A non-NULL servname string can\n   be either a service\
    \ name or a decimal port number.\n   The caller can optionally pass an addrinfo\
    \ structure, pointed to by\n   the third argument, to provide hints concerning\
    \ the type of socket\n   that the caller supports.  In this hints structure all\
    \ members other\n   than ai_flags, ai_family, ai_socktype, and ai_protocol must\
    \ be zero\n   or a NULL pointer.  A value of PF_UNSPEC for ai_family means the\n\
    \   caller will accept any protocol family.  A value of 0 for ai_socktype\n  \
    \ means the caller will accept any socket type.  A value of 0 for\n   ai_protocol\
    \ means the caller will accept any protocol.  For example,\n   if the caller handles\
    \ only TCP and not UDP, then the ai_socktype\n   member of the hints structure\
    \ should be set to SOCK_STREAM when\n   getaddrinfo() is called.  If the caller\
    \ handles only IPv4 and not\n   IPv6, then the ai_family member of the hints structure\
    \ should be set\n   to PF_INET when getaddrinfo() is called.  If the third argument\
    \ to\n   getaddrinfo() is a NULL pointer, this is the same as if the caller\n\
    \   had filled in an addrinfo structure initialized to zero with\n   ai_family\
    \ set to PF_UNSPEC.\n   Upon successful return a pointer to a linked list of one\
    \ or more\n   addrinfo structures is returned through the final argument.  The\n\
    \   caller can process each addrinfo structure in this list by following\n   the\
    \ ai_next pointer, until a NULL pointer is encountered.  In each\n   returned\
    \ addrinfo structure the three members ai_family, ai_socktype,\n   and ai_protocol\
    \ are the corresponding arguments for a call to the\n   socket() function.  In\
    \ each addrinfo structure the ai_addr member\n   points to a filled-in socket\
    \ address structure whose length is\n   specified by the ai_addrlen member.\n\
    \   If the AI_PASSIVE bit is set in the ai_flags member of the hints\n   structure,\
    \ then the caller plans to use the returned socket address\n   structure in a\
    \ call to bind().  In this case, if the nodename\n   argument is a NULL pointer,\
    \ then the IP address portion of the socket\n   address structure will be set\
    \ to INADDR_ANY for an IPv4 address or\n   IN6ADDR_ANY_INIT for an IPv6 address.\n\
    \   If the AI_PASSIVE bit is not set in the ai_flags member of the hints\n   structure,\
    \ then the returned socket address structure will be ready\n   for a call to connect()\
    \ (for a connection-oriented protocol) or\n   either connect(), sendto(), or sendmsg()\
    \ (for a connectionless\n   protocol).  In this case, if the nodename argument\
    \ is a NULL pointer,\n   then the IP address portion of the socket address structure\
    \ will be\n   set to the loopback address.\n   If the AI_CANONNAME bit is set\
    \ in the ai_flags member of the hints\n   structure, then upon successful return\
    \ the ai_canonname member of the\n   first addrinfo structure in the linked list\
    \ will point to a null-\n   terminated string containing the canonical name of\
    \ the specified\n   nodename.\n   If the AI_NUMERICHOST bit is set in the ai_flags\
    \ member of the hints\n   structure, then a non-NULL nodename string must be a\
    \ numeric host\n   address string.  Otherwise an error of EAI_NONAME is returned.\
    \  This\n   flag prevents any type of name resolution service (e.g., the DNS)\n\
    \   from being called.\n   All of the information returned by getaddrinfo() is\
    \ dynamically\n   allocated: the addrinfo structures, and the socket address structures\n\
    \   and canonical node name strings pointed to by the addrinfo\n   structures.\
    \  To return this information to the system the function\n   freeaddrinfo() is\
    \ called:\n      #include <sys/socket.h> #include <netdb.h>\n      void freeaddrinfo(struct\
    \ addrinfo *ai);\n   The addrinfo structure pointed to by the ai argument is freed,\
    \ along\n   with any dynamic storage pointed to by the structure.  This operation\n\
    \   is repeated until a NULL ai_next pointer is encountered.\n   To aid applications\
    \ in printing error messages based on the EAI_xxx\n   codes returned by getaddrinfo(),\
    \ the following function is defined.\n      #include <sys/socket.h> #include <netdb.h>\n\
    \      char *gai_strerror(int ecode);\n   The argument is one of the EAI_xxx values\
    \ defined earlier and the\n   return value points to a string describing the error.\
    \  If the\n   argument is not one of the EAI_xxx values, the function still returns\n\
    \   a pointer to a string whose contents indicate an unknown error.\n"
- title: 6.5 Socket Address Structure to Nodename and Service Name
  contents:
  - "6.5 Socket Address Structure to Nodename and Service Name\n   The POSIX 1003.1g\
    \ specification includes no function to perform the\n   reverse conversion from\
    \ getaddrinfo(): to look up a nodename and\n   service name, given the binary\
    \ address and port.  Therefore, we\n   define the following function:\n      #include\
    \ <sys/socket.h>\n      #include <netdb.h>\n      int getnameinfo(const struct\
    \ sockaddr *sa, socklen_t salen,\n                      char *host, size_t hostlen,\n\
    \                      char *serv, size_t servlen,\n                      int\
    \ flags);\n   This function looks up an IP address and port number provided by\
    \ the\n   caller in the DNS and system-specific database, and returns text\n \
    \  strings for both in buffers provided by the caller.  The function\n   indicates\
    \ successful completion by a zero return value; a non-zero\n   return value indicates\
    \ failure.\n   The first argument, sa, points to either a sockaddr_in structure\
    \ (for\n   IPv4) or a sockaddr_in6 structure (for IPv6) that holds the IP\n  \
    \ address and port number.  The salen argument gives the length of the\n   sockaddr_in\
    \ or sockaddr_in6 structure.\n   The function returns the nodename associated\
    \ with the IP address in\n   the buffer pointed to by the host argument.  The\
    \ caller provides the\n   size of this buffer via the hostlen argument.  The service\
    \ name\n   associated with the port number is returned in the buffer pointed to\n\
    \   by serv, and the servlen argument gives the length of this buffer.\n   The\
    \ caller specifies not to return either string by providing a zero\n   value for\
    \ the hostlen or servlen arguments.  Otherwise, the caller\n   must provide buffers\
    \ large enough to hold the nodename and the\n   service name, including the terminating\
    \ null characters.\n   Unfortunately most systems do not provide constants that\
    \ specify the\n   maximum size of either a fully-qualified domain name or a service\n\
    \   name.  Therefore to aid the application in allocating buffers for\n   these\
    \ two returned strings the following constants are defined in\n   <netdb.h>:\n\
    \      #define NI_MAXHOST  1025\n      #define NI_MAXSERV    32\n   The first\
    \ value is actually defined as the constant MAXDNAME in recent\n   versions of\
    \ BIND's <arpa/nameser.h> header (older versions of BIND\n   define this constant\
    \ to be 256) and the second is a guess based on the\n   services listed in the\
    \ current Assigned Numbers RFC.\n   The final argument is a flag that changes\
    \ the default actions of this\n   function.  By default the fully-qualified domain\
    \ name (FQDN) for the\n   host is looked up in the DNS and returned.  If the flag\
    \ bit NI_NOFQDN\n   is set, only the nodename portion of the FQDN is returned\
    \ for local\n   hosts.\n   If the flag bit NI_NUMERICHOST is set, or if the host's\
    \ name cannot be\n   located in the DNS, the numeric form of the host's address\
    \ is returned\n   instead of its name (e.g., by calling inet_ntop() instead of\n\
    \   getipnodebyaddr()).  If the flag bit NI_NAMEREQD is set, an error is\n   returned\
    \ if the host's name cannot be located in the DNS.\n   If the flag bit NI_NUMERICSERV\
    \ is set, the numeric form of the service\n   address is returned (e.g., its port\
    \ number) instead of its name.  The\n   two NI_NUMERICxxx flags are required to\
    \ support the \"-n\" flag that\n   many commands provide.\n   A fifth flag bit,\
    \ NI_DGRAM, specifies that the service is a datagram\n   service, and causes getservbyport()\
    \ to be called with a second\n   argument of \"udp\" instead of its default of\
    \ \"tcp\".  This is required\n   for the few ports (e.g. 512-514) that have different\
    \ services for UDP\n   and TCP.\n   These NI_xxx flags are defined in <netdb.h>\
    \ along with the AI_xxx\n   flags already defined for getaddrinfo().\n"
- title: 6.6 Address Conversion Functions
  contents:
  - "6.6 Address Conversion Functions\n   The two functions inet_addr() and inet_ntoa()\
    \ convert an IPv4 address\n   between binary and text form.  IPv6 applications\
    \ need similar\n   functions.  The following two functions convert both IPv6 and\
    \ IPv4\n   addresses:\n      #include <sys/socket.h>\n      #include <arpa/inet.h>\n\
    \      int inet_pton(int af, const char *src, void *dst);\n      const char *inet_ntop(int\
    \ af, const void *src,\n                            char *dst, size_t size);\n\
    \   The inet_pton() function converts an address in its standard text\n   presentation\
    \ form into its numeric binary form.  The af argument\n   specifies the family\
    \ of the address.  Currently the AF_INET and\n   AF_INET6 address families are\
    \ supported.  The src argument points to\n   the string being passed in.  The\
    \ dst argument points to a buffer into\n   which the function stores the numeric\
    \ address.  The address is\n   returned in network byte order.  Inet_pton() returns\
    \ 1 if the\n   conversion succeeds, 0 if the input is not a valid IPv4 dotted-\n\
    \   decimal string or a valid IPv6 address string, or -1 with errno set\n   to\
    \ EAFNOSUPPORT if the af argument is unknown.  The calling\n   application must\
    \ ensure that the buffer referred to by dst is large\n   enough to hold the numeric\
    \ address (e.g., 4 bytes for AF_INET or 16\n   bytes for AF_INET6).\n   If the\
    \ af argument is AF_INET, the function accepts a string in the\n   standard IPv4\
    \ dotted-decimal form:\n      ddd.ddd.ddd.ddd\n   where ddd is a one to three\
    \ digit decimal number between 0 and 255.\n   Note that many implementations of\
    \ the existing inet_addr() and\n   inet_aton() functions accept nonstandard input:\
    \ octal numbers,\n   hexadecimal numbers, and fewer than four numbers.  inet_pton()\
    \ does\n   not accept these formats.\n   If the af argument is AF_INET6, then\
    \ the function accepts a string in\n   one of the standard IPv6 text forms defined\
    \ in Section 2.2 of the\n   addressing architecture specification [2].\n   The\
    \ inet_ntop() function converts a numeric address into a text\n   string suitable\
    \ for presentation.  The af argument specifies the\n   family of the address.\
    \  This can be AF_INET or AF_INET6.  The src\n   argument points to a buffer holding\
    \ an IPv4 address if the af\n   argument is AF_INET, or an IPv6 address if the\
    \ af argument is\n   AF_INET6, the address must be in network byte order.  The\
    \ dst\n   argument points to a buffer where the function will store the\n   resulting\
    \ text string.  The size argument specifies the size of this\n   buffer.  The\
    \ application must specify a non-NULL dst argument.  For\n   IPv6 addresses, the\
    \ buffer must be at least 46-octets.  For IPv4\n   addresses, the buffer must\
    \ be at least 16-octets.  In order to allow\n   applications to easily declare\
    \ buffers of the proper size to store\n   IPv4 and IPv6 addresses in string form,\
    \ the following two constants\n   are defined in <netinet/in.h>:\n      #define\
    \ INET_ADDRSTRLEN    16\n      #define INET6_ADDRSTRLEN   46\n   The inet_ntop()\
    \ function returns a pointer to the buffer containing\n   the text string if the\
    \ conversion succeeds, and NULL otherwise.  Upon\n   failure, errno is set to\
    \ EAFNOSUPPORT if the af argument is invalid or\n   ENOSPC if the size of the\
    \ result buffer is inadequate.\n"
- title: 6.7 Address Testing Macros
  contents:
  - "6.7 Address Testing Macros\n   The following macros can be used to test for special\
    \ IPv6 addresses.\n      #include <netinet/in.h>\n      int  IN6_IS_ADDR_UNSPECIFIED\
    \ (const struct in6_addr *);\n      int  IN6_IS_ADDR_LOOPBACK    (const struct\
    \ in6_addr *);\n      int  IN6_IS_ADDR_MULTICAST   (const struct in6_addr *);\n\
    \      int  IN6_IS_ADDR_LINKLOCAL   (const struct in6_addr *);\n      int  IN6_IS_ADDR_SITELOCAL\
    \   (const struct in6_addr *);\n      int  IN6_IS_ADDR_V4MAPPED    (const struct\
    \ in6_addr *);\n      int  IN6_IS_ADDR_V4COMPAT    (const struct in6_addr *);\n\
    \      int  IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);\n      int  IN6_IS_ADDR_MC_LINKLOCAL(const\
    \ struct in6_addr *);\n      int  IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr\
    \ *);\n      int  IN6_IS_ADDR_MC_ORGLOCAL (const struct in6_addr *);\n      int\
    \  IN6_IS_ADDR_MC_GLOBAL   (const struct in6_addr *);\n   The first seven macros\
    \ return true if the address is of the specified\n   type, or false otherwise.\
    \  The last five test the scope of a\n   multicast address and return true if\
    \ the address is a multicast\n   address of the specified scope or false if the\
    \ address is either not\n   a multicast address or not of the specified scope.\
    \  Note that\n   IN6_IS_ADDR_LINKLOCAL and IN6_IS_ADDR_SITELOCAL return true only\
    \ for\n   the two local-use IPv6 unicast addresses.  These two macros do not\n\
    \   return true for IPv6 multicast addresses of either link-local scope\n   or\
    \ site-local scope.\n"
- title: 7. Summary of New Definitions
  contents:
  - "7. Summary of New Definitions\n   The following list summarizes the constants,\
    \ structure, and extern\n   definitions discussed in this memo, sorted by header.\n\
    \      <net/if.h>      IF_NAMESIZE\n      <net/if.h>      struct if_nameindex{};\n\
    \      <netdb.h>       AI_ADDRCONFIG\n      <netdb.h>       AI_DEFAULT\n     \
    \ <netdb.h>       AI_ALL\n      <netdb.h>       AI_CANONNAME\n      <netdb.h>\
    \       AI_NUMERICHOST\n      <netdb.h>       AI_PASSIVE\n      <netdb.h>    \
    \   AI_V4MAPPED\n      <netdb.h>       EAI_ADDRFAMILY\n      <netdb.h>       EAI_AGAIN\n\
    \      <netdb.h>       EAI_BADFLAGS\n      <netdb.h>       EAI_FAIL\n      <netdb.h>\
    \       EAI_FAMILY\n      <netdb.h>       EAI_MEMORY\n      <netdb.h>       EAI_NODATA\n\
    \      <netdb.h>       EAI_NONAME\n      <netdb.h>       EAI_SERVICE\n      <netdb.h>\
    \       EAI_SOCKTYPE\n      <netdb.h>       EAI_SYSTEM\n      <netdb.h>      \
    \ NI_DGRAM\n      <netdb.h>       NI_MAXHOST\n      <netdb.h>       NI_MAXSERV\n\
    \      <netdb.h>       NI_NAMEREQD\n      <netdb.h>       NI_NOFQDN\n      <netdb.h>\
    \       NI_NUMERICHOST\n      <netdb.h>       NI_NUMERICSERV\n      <netdb.h>\
    \       struct addrinfo{};\n      <netinet/in.h>  IN6ADDR_ANY_INIT\n      <netinet/in.h>\
    \  IN6ADDR_LOOPBACK_INIT\n      <netinet/in.h>  INET6_ADDRSTRLEN\n      <netinet/in.h>\
    \  INET_ADDRSTRLEN\n      <netinet/in.h>  IPPROTO_IPV6\n      <netinet/in.h> \
    \ IPV6_JOIN_GROUP\n      <netinet/in.h>  IPV6_LEAVE_GROUP\n      <netinet/in.h>\
    \  IPV6_MULTICAST_HOPS\n      <netinet/in.h>  IPV6_MULTICAST_IF\n      <netinet/in.h>\
    \  IPV6_MULTICAST_LOOP\n      <netinet/in.h>  IPV6_UNICAST_HOPS\n      <netinet/in.h>\
    \  SIN6_LEN\n      <netinet/in.h>  extern const struct in6_addr in6addr_any;\n\
    \      <netinet/in.h>  extern const struct in6_addr in6addr_loopback;\n      <netinet/in.h>\
    \  struct in6_addr{};\n      <netinet/in.h>  struct ipv6_mreq{};\n      <netinet/in.h>\
    \  struct sockaddr_in6{};\n      <sys/socket.h>  AF_INET6\n      <sys/socket.h>\
    \  PF_INET6\n      <sys/socket.h>  struct sockaddr_storage;\n   The following\
    \ list summarizes the function and macro prototypes\n   discussed in this memo,\
    \ sorted by header.\n"
- title: <arpa/inet.h>   int inet_pton(int, const char *, void *);
  contents:
  - '<arpa/inet.h>   int inet_pton(int, const char *, void *);

    '
- title: <arpa/inet.h>   const char *inet_ntop(int, const void *,
  contents:
  - "<arpa/inet.h>   const char *inet_ntop(int, const void *,\n                  \
    \                    char *, size_t);\n"
- title: <net/if.h>      char *if_indextoname(unsigned int, char *);
  contents:
  - '<net/if.h>      char *if_indextoname(unsigned int, char *);

    '
- title: <net/if.h>      unsigned int if_nametoindex(const char *);
  contents:
  - '<net/if.h>      unsigned int if_nametoindex(const char *);

    '
- title: <net/if.h>      void if_freenameindex(struct if_nameindex *);
  contents:
  - '<net/if.h>      void if_freenameindex(struct if_nameindex *);

    '
- title: <net/if.h>      struct if_nameindex *if_nameindex(void);
  contents:
  - '<net/if.h>      struct if_nameindex *if_nameindex(void);

    '
- title: <netdb.h>       int getaddrinfo(const char *, const char *,
  contents:
  - "<netdb.h>       int getaddrinfo(const char *, const char *,\n               \
    \                 const struct addrinfo *,\n                                struct\
    \ addrinfo **);\n"
- title: <netdb.h>       int getnameinfo(const struct sockaddr *, socklen_t,
  contents:
  - "<netdb.h>       int getnameinfo(const struct sockaddr *, socklen_t,\n       \
    \                         char *, size_t, char *, size_t, int);\n"
- title: <netdb.h>       void freeaddrinfo(struct addrinfo *);
  contents:
  - '<netdb.h>       void freeaddrinfo(struct addrinfo *);

    '
- title: <netdb.h>       char *gai_strerror(int);
  contents:
  - '<netdb.h>       char *gai_strerror(int);

    '
- title: <netdb.h>       struct hostent *getipnodebyname(const char *, int, int,
  contents:
  - "<netdb.h>       struct hostent *getipnodebyname(const char *, int, int,\n   \
    \                                    int *);\n"
- title: <netdb.h>       struct hostent *getipnodebyaddr(const void *, size_t,
  contents:
  - "<netdb.h>       struct hostent *getipnodebyaddr(const void *, size_t,\n     \
    \                                  int, int *);\n"
- title: <netdb.h>       void freehostent(struct hostent *);
  contents:
  - '<netdb.h>       void freehostent(struct hostent *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);

    '
- title: 8. Security Considerations
  contents:
  - "8. Security Considerations\n   IPv6 provides a number of new security mechanisms,\
    \ many of which need\n   to be accessible to applications.  Companion memos detailing\
    \ the\n   extensions to the socket interfaces to support IPv6 security are\n \
    \  being written.\n"
- title: 9. Year 2000 Considerations
  contents:
  - "9. Year 2000 Considerations\n   There are no issues for this memo concerning\
    \ the Year 2000 issue\n   regarding the use of dates.\n"
- title: Changes From RFC 2133
  contents:
  - "Changes From RFC 2133\n   Changes made in the March 1998 Edition (-01 draft):\n\
    \      Changed all \"hostname\" to \"nodename\" for consistency with other\n \
    \     IPv6 documents.\n      Section 3.3: changed comment for sin6_flowinfo to\
    \ be \"traffic\n      class & flow info\" and updated corresponding text description\
    \ to\n      current definition of these two fields.\n      Section 3.10 (\"Portability\
    \ Additions\") is new.\n      Section 6: a new paragraph was added reiterating\
    \ that the existing\n      gethostbyname() and gethostbyaddr() are not changed.\n\
    \      Section 6.1: change gethostbyname3() to getnodebyname().  Add\n      AI_DEFAULT\
    \ to handle majority of applications.  Renamed\n      AI_V6ADDRCONFIG to AI_ADDRCONFIG\
    \ and define it for A records and\n      IPv4 addresses too.  Defined exactly\
    \ what getnodebyname() must\n      return if the name argument is a numeric address\
    \ string.\n      Section 6.2: change gethostbyaddr() to getnodebyaddr().  Reword\n\
    \      items 2 and 3 in the description of how to handle IPv4-mapped and\n   \
    \   IPv4- compatible addresses to \"lookup a name\" for a given address,\n   \
    \   instead of specifying what type of DNS query to issue.\n      Section 6.3:\
    \ added two more requirements to getaddrinfo().\n      Section 7: added the following\
    \ constants to the list for\n      <netdb.h>:  AI_ADDRCONFIG, AI_ALL, and AI_V4MAPPED.\
    \  Add union\n      sockaddr_union and SA_LEN to the lists for <sys/socket.h>.\n\
    \      Updated references.\n   Changes made in the November 1997 Edition (-00\
    \ draft):\n      The data types have been changed to conform with Draft 6.6 of\
    \ the\n      Posix 1003.1g standard.\n      Section 3.2: data type of s6_addr\
    \ changed to \"uint8_t\".\n      Section 3.3: data type of sin6_family changed\
    \ to \"sa_family_t\".\n      data type of sin6_port changed to \"in_port_t\",\
    \ data type of\n      sin6_flowinfo changed to \"uint32_t\".\n      Section 3.4:\
    \ same as Section 3.3, plus data type of sin6_len\n      changed to \"uint8_t\"\
    .\n      Section 6.2: first argument of gethostbyaddr() changed from \"const\n\
    \      char *\" to \"const void *\" and second argument changed from \"int\"\n\
    \      to \"size_t\".\n      Section 6.4: second argument of getnameinfo() changed\
    \ from\n      \"size_t\" to \"socklen_t\".\n      The wording was changed when\
    \ new structures were defined, to be\n      more explicit as to which header must\
    \ be included to define the\n      structure:\n      Section 3.2 (in6_addr{}),\
    \ Section 3.3 (sockaddr_in6{}), Section\n      3.4 (sockaddr_in6{}), Section 4.3\
    \ (if_nameindex{}), Section 5.3\n      (ipv6_mreq{}), and Section 6.3 (addrinfo{}).\n\
    \      Section 4: NET_RT_LIST changed to NET_RT_IFLIST.\n      Section 5.1: The\
    \ IPV6_ADDRFORM socket option was removed.\n      Section 5.3: Added a note that\
    \ an option value other than 0 or 1\n      for IPV6_MULTICAST_LOOP returns an\
    \ error.  Added a note that\n      IPV6_MULTICAST_IF, IPV6_MULTICAST_HOPS, and\
    \ IPV6_MULTICAST_LOOP\n      can also be used with getsockopt(), but IPV6_ADD_MEMBERSHIP\
    \ and\n      IPV6_DROP_MEMBERSHIP cannot be used with getsockopt().\n      Section\
    \ 6.1: Removed the description of gethostbyname2() and its\n      associated RES_USE_INET6\
    \ option, replacing it with\n      gethostbyname3().\n      Section 6.2: Added\
    \ requirement that gethostbyaddr() be thread\n      safe.  Reworded step 4 to\
    \ avoid using the RES_USE_INET6 option.\n      Section 6.3: Added the requirement\
    \ that getaddrinfo() and\n      getnameinfo() be thread safe.  Added the AI_NUMERICHOST\
    \ flag.\n      Section 6.6: Added clarification about IN6_IS_ADDR_LINKLOCAL and\n\
    \      IN6_IS_ADDR_SITELOCAL macros.\n   Changes made to the draft -01 specification\
    \ Sept 98\n      Changed priority to traffic class in the spec.\n      Added the\
    \ need for scope identification in section 2.1.\n      Added sin6_scope_id to\
    \ struct sockaddr_in6 in sections 3.3 and\n      3.4.\n      Changed 3.10 to use\
    \ generic storage structure to support holding\n      IPv6 addresses and removed\
    \ the SA_LEN macro.\n      Distinguished between invalid input parameters and\
    \ system failures\n      for Interface Identification in Section 4.1 and 4.2.\n\
    \      Added defaults for multicast operations in section 5.2 and changed\n  \
    \    the names from ADD to JOIN and DROP to LEAVE to be consistent with\n    \
    \  IPv6 multicast terminology.\n      Changed getnodebyname to getipnodebyname,\
    \ getnodebyaddr to\n      getipnodebyaddr, and added MT safe error code to function\n\
    \      parameters in section 6.\n      Moved freehostent to its own sub-section\
    \ after getipnodebyaddr now\n      6.3 (so this bumps all remaining sections in\
    \ section 6.\n      Clarified the use of AI_ALL and AI_V4MAPPED that these are\n\
    \      dependent on the AF parameter and must be used as a conjunction in\n  \
    \    section 6.1.\n      Removed the restriction that literal addresses cannot\
    \ be used with\n      a flags argument in section 6.1.\n      Added Year 2000\
    \ Section to the draft\n      Deleted Reference to the following because the attached\
    \ is deleted\n      from the ID directory and has expired.  But the logic from\
    \ the\n      aforementioned draft still applies, so that was kept in Section\n\
    \      6.2 bullets after 3rd paragraph.\n      [7]  P. Vixie, \"Reverse Name Lookups\
    \ of Encapsulated IPv4\n           Addresses in IPv6\", Internet-Draft, <draft-vixie-ipng-\n\
    \           ipv4ptr-00.txt>, May 1996.\n      Deleted the following reference\
    \ as it is no longer referenced.\n      And the draft has expired.\n      [3]\
    \  D. McDonald, \"A Simple IP Security API Extension to BSD\n           Sockets\"\
    , Internet-Draft, <draft-mcdonald-simple-ipsec-api-\n           01.txt>, March\
    \ 1997.\n      Deleted the following reference as it is no longer referenced.\n\
    \      [4]  C. Metz, \"Network Security API for Sockets\",\n           Internet-Draft,\
    \ <draft-metz-net-security-api-01.txt>, January\n           1998.\n      Update\
    \ current references to current status.\n      Added alignment notes for in6_addr\
    \ and sin6_addr.\n      Clarified further that AI_V4MAPPED must be used with a\
    \ dotted IPv4\n      literal address for getipnodebyname(), when address family\
    \ is\n      AF_INET6.\n      Added text to clarify \"::\" and \"::1\" when used\
    \ by\n      getipnodebyaddr().\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Thanks to the many people who made suggestions and provided\
    \ feedback\n   to this document, including: Werner Almesberger, Ran Atkinson,\
    \ Fred\n   Baker, Dave Borman, Andrew Cherenson, Alex Conta, Alan Cox, Steve\n\
    \   Deering, Richard Draves, Francis Dupont, Robert Elz, Marc Hasson, Tom\n  \
    \ Herbert, Bob Hinden, Wan-Yen Hsu, Christian Huitema, Koji Imada,\n   Markus\
    \ Jork, Ron Lee, Alan Lloyd, Charles Lynn, Dan McDonald, Dave\n   Mitton, Thomas\
    \ Narten, Josh Osborne, Craig Partridge, Jean-Luc\n   Richier, Erik Scoredos,\
    \ Keith Sklower, Matt Thomas, Harvey Thompson,\n   Dean D. Throop, Karen Tracey,\
    \ Glenn Trewitt, Paul Vixie, David\n   Waitzman, Carl Williams, and Kazu Yamamoto,\n\
    \   The getaddrinfo() and getnameinfo() functions are taken from an\n   earlier\
    \ Internet Draft by Keith Sklower.  As noted in that draft,\n   William Durst,\
    \ Steven Wise, Michael Karels, and Eric Allman provided\n   many useful discussions\
    \ on the subject of protocol-independent name-\n   to-address translation, and\
    \ reviewed early versions of Keith\n   Sklower's original proposal.  Eric Allman\
    \ implemented the first\n   prototype of getaddrinfo().  The observation that\
    \ specifying the pair\n   of name and service would suffice for connecting to\
    \ a service\n   independent of protocol details was made by Marshall Rose in a\n\
    \   proposal to X/Open for a \"Uniform Network Interface\".\n   Craig Metz, Jack\
    \ McCann, Erik Nordmark, Tim Hartrick, and Mukesh\n   Kacker made many contributions\
    \ to this document.  Ramesh Govindan\n   made a number of contributions and co-authored\
    \ an earlier version of\n   this memo.\n"
- title: References
  contents:
  - "References\n   [1]  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\
    \ (IPv6)\n        Specification\", RFC 2460, December 1998.\n   [2]  Hinden, R.\
    \ and S. Deering, \"IP Version 6 Addressing\n        Architecture\", RFC 2373,\
    \ July 1998.\n   [3]  IEEE, \"Protocol Independent Interfaces\", IEEE Std 1003.1g,\
    \ DRAFT\n        6.6, March 1997.\n   [4]  Stevens, W. and M. Thomas, \"Advanced\
    \ Sockets API for IPv6\", RFC\n        2292, February 1998.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Robert E. Gilligan\n   FreeGate Corporation\n   1208 E.\
    \ Arques Ave.\n   Sunnyvale, CA 94086\n   Phone: +1 408 617 1004\n   EMail: gilligan@freegate.com\n\
    \   Susan Thomson\n   Bell Communications Research\n   MRE 2P-343, 445 South Street\n\
    \   Morristown, NJ 07960\n   Phone: +1 201 829 4514\n   EMail: set@thumper.bellcore.com\n\
    \   Jim Bound\n   Compaq Computer Corporation\n   110 Spitbrook Road ZK3-3/U14\n\
    \   Nashua, NH 03062-2698\n   Phone: +1 603 884 0400\n   EMail: bound@zk3.dec.com\n\
    \   W. Richard Stevens\n   1202 E. Paseo del Zorro\n   Tucson, AZ 85718-2826\n\
    \   Phone: +1 520 297 9416\n   EMail: rstevens@kohala.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
