- title: __initial_text__
  contents:
  - '              Signaling Compression (SigComp) Users'' Guide

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document provides an informational guide for users of the\n\
    \   Signaling Compression (SigComp) protocol.  The aim of the document is\n  \
    \ to assist users when making SigComp implementation decisions, for\n   example,\
    \ the choice of compression algorithm and the level of\n   robustness against\
    \ lost or misordered packets.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Overview of the User Guide ......................................3\n  \
    \ 3. UDVM Assembly Language ..........................................4\n    \
    \  3.1. Lexical Level ..............................................4\n      3.2.\
    \ Syntactic Level ............................................5\n           3.2.1.\
    \ Expressions .........................................7\n           3.2.2. Instructions\
    \ ........................................8\n           3.2.3. Directives ..........................................9\n\
    \           3.2.4. Labels .............................................10\n  \
    \    3.3. Uploading the Bytecode to the UDVM ........................11\n   4.\
    \ Compression Algorithms .........................................12\n      4.1.\
    \ Well-known Compression Algorithms .........................12\n           4.1.1.\
    \ LZ77 ...............................................12\n           4.1.2. LZSS\
    \ ...............................................16\n           4.1.3. LZW ................................................18\n\
    \           4.1.4. DEFLATE ............................................21\n  \
    \         4.1.5. LZJH ...............................................24\n    \
    \  4.2. Adapted Algorithms ........................................28\n      \
    \     4.2.1. Modified DEFLATE ...................................28\n   5. Additional\
    \ SigComp Mechanisms ..................................31\n      5.1. Acknowledging\
    \ a State Item ................................32\n      5.2. Static Dictionary\
    \ .........................................33\n      5.3. CRC Checksum ..............................................34\n\
    \      5.4. Announcing Additional Resources ...........................35\n  \
    \    5.5. Shared Compression ........................................37\n   6.\
    \ Security Considerations ........................................38\n   7. Acknowledgements\
    \ ...............................................38\n   8. Intellectual Property\
    \ Right Considerations .....................38\n   9. Informative References .........................................38\n\
    \   Appendix A. UDVM Bytecode for the Compression Algorithms ..........40\n  \
    \    A.1. Well-known Algorithms .....................................40\n    \
    \       A.1.1.  LZ77 ..............................................40\n      \
    \     A.1.2.  LZSS ..............................................40\n        \
    \   A.1.3.  LZW ...............................................40\n          \
    \ A.1.4.  DEFLATE ...........................................40\n           A.1.5.\
    \  LZJH ..............................................41\n      A.2. Adapted Algorithms\
    \ ........................................41\n           A.2.1. Modified DEFLATE\
    \ ...................................41\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document provides an informational guide for users\
    \ of the\n   SigComp protocol, RFC 3320 [2].  The idea behind SigComp is to\n\
    \   standardize a Universal Decompressor Virtual Machine (UDVM) that can\n   be\
    \ programmed to understand the output of many well-known compressors\n   including\
    \ DEFLATE [8] and LZW [7].  The bytecode for the chosen\n   compression algorithm\
    \ is uploaded to the UDVM as part of the\n   compressed data.\n   The basic SigComp\
    \ RFC describes the actions that an endpoint must\n   take upon receiving a SigComp\
    \ message.  However, the entity\n   responsible for generating new SigComp messages\
    \ (the SigComp\n   compressor) is left as an implementation decision; any compressor\
    \ can\n   be used provided that it generates SigComp messages that can be\n  \
    \ successfully decompressed by the receiving endpoint.\n   This document gives\
    \ examples of a number of different compressors\n   that can be used by the SigComp\
    \ protocol.  It also gives examples of\n   how to use some of the mechanisms (such\
    \ as acknowledgements)\n   described in RFC 3321 [3].\n"
- title: 2.  Overview of the User Guide
  contents:
  - "2.  Overview of the User Guide\n   When implementing a SigComp compressor, the\
    \ first step is to choose a\n   compression algorithm that can encode the application\
    \ messages into a\n   (hopefully) smaller form.  Since SigComp can upload bytecode\
    \ for new\n   algorithms to the receiving endpoint, arbitrary compression\n  \
    \ algorithms can be supported provided that suitable bytecode has been\n   written\
    \ for the corresponding decompressor.\n   This document provides example bytecode\
    \ for the following algorithms:\n   1.  LZ77\n   2.  LZSS\n   3.  LZW\n   4. \
    \ DEFLATE\n   5.  LZJH\n   Any of the above algorithms may be useful depending\
    \ on the desired\n   compression ratio, processing and memory requirements, code\
    \ size,\n   implementation complexity, and Intellectual Property (IPR)\n   considerations.\n\
    \   As well as encoding the application messages using the chosen\n   algorithm,\
    \ the SigComp compressor is responsible for ensuring that\n   messages can be\
    \ correctly decompressed even if packets are lost or\n   misordered during transmission.\
    \  The SigComp feedback mechanism can\n   be used to acknowledge successful decompression\
    \ at the remote\n   endpoint.\n   The following robustness techniques and other\
    \ mechanisms specific to\n   the SigComp environment are covered in this document:\n\
    \   1.  Acknowledgements using the SigComp feedback mechanism\n   2.  Static dictionary\n\
    \   3.  Cyclic redundancy code (CRC) checksum\n   4.  Announcing additional resources\n\
    \   5.  Shared compression\n   Any or all of the above mechanisms can be implemented\
    \ in conjunction\n   with the chosen compression algorithm.  An example subroutine\
    \ of UDVM\n   bytecode is provided for each of the mechanisms; these subroutines\n\
    \   can be added to the bytecode for one of the basic compression\n   algorithms.\
    \  (Note: The subroutine or the basic algorithm may require\n   minor modification\
    \ to ensure they work together correctly.)\n"
- title: 3.  UDVM Assembly Language
  contents:
  - "3.  UDVM Assembly Language\n   Writing UDVM programs directly in bytecode would\
    \ be a daunting task,\n   so a simple assembly language is provided to facilitate\
    \ the creation\n   of new decompression algorithms.  The assembly language includes\n\
    \   mnemonic codes for each of the UDVM instructions, as well as simple\n   directives\
    \ for evaluating integer expressions, padding the bytecode,\n   and so forth.\n\
    \   The syntax of the UDVM assembly language uses the customary two-level\n  \
    \ description technique, partitioning the grammar into a lexical and a\n   syntactic\
    \ level.\n"
- title: 3.1.  Lexical Level
  contents:
  - "3.1.  Lexical Level\n   On a lexical level, a string of assembly consists of\
    \ zero or more\n   tokens optionally separated by whitespace.  Each token can\
    \ be a text\n   name, an instruction opcode, a delimiter, or an integer (specified\
    \ as\n   decimal, binary, or hex).\n   The following ABNF description, RFC 4234\
    \ [1], specifies the syntax of\n   a token:\n   token            =     (name /\
    \ opcode / delimiter / dec / bin / hex)\n   name             =     (lowercase\
    \ / \"_\") 0*(lowercase / digit / \"_\")\n   opcode           =     uppercase\
    \ *(uppercase / digit / \"-\")\n   delimiter        =     \".\" / \",\" / \"!\"\
    \ / \"$\" / \":\" / \"(\" / \")\" /\n                          operator\n   dec\
    \              =     1*(digit)\n   bin              =     \"0b\" 1*(\"0\" / \"\
    1\")\n   hex              =     \"0x\" 1*(hex-digit)\n   hex-digit        =  \
    \   digit / %x41-46 / %x61-66\n   digit            =     %x30-39\n   uppercase\
    \        =     %x41-5a\n   lowercase        =     %x61-7a\n   operator       \
    \  =     \"+\" / \"-\" / \"*\" / \"/\" / \"%\" / \"&\" / \"|\" /\n           \
    \               \"^\" / \"~\" / \"<<\" / \">>\"\n   When parsing for tokens, the\
    \ longest match is applied, i.e., a token\n   is the longest string that matches\
    \ the <token> rule specified above.\n   The syntax of whitespace and comments\
    \ is specified by the following\n   ABNF:\n   ws               =     *(%x09 /\
    \ %x0a / %x0d / %x20 / comment)\n   comment          =     \";\" *(%x00-09 / %x0b-0c\
    \ / %x0e-ff)\n                          (%x0a / %x0d)\n   Whitespace that matches\
    \ <ws> is skipped between tokens, but serves to\n   terminate the longest match\
    \ for a token.\n   Comments are specified by the symbol \";\" and are terminated\
    \ by the\n   end of the line, for example:\n   LOAD (temp, 1) ; This is a comment.\n\
    \   Any other input is a syntax error.\n   When parsing on the lexical level,\
    \ the string of assembly should be\n   divided up into a list of successive tokens.\
    \  The whitespace and\n   comments should also be deleted.  The assembly should\
    \ then be parsed\n   on the syntactic level as explained in Section 3.2.\n"
- title: 3.2.  Syntactic Level
  contents:
  - "3.2.  Syntactic Level\n   Once the string of assembly has been divided into tokens\
    \ as per\n   Section 3.1, the next step is to convert the assembly into a string\n\
    \   of UDVM bytecode.\n   On a syntactic level, a string of assembly consists\
    \ of zero or more\n   instructions, directives, or labels, each of which is itself\
    \ built up\n   from one or more lexical tokens.\n   The following ABNF description\
    \ specifies the syntax of the assembly\n   language.  Note that the lexical parsing\
    \ step is assumed to have been\n   carried out; so in particular, the boundaries\
    \ between tokens are\n   already known, and the comments and whitespace have been\
    \ deleted:\n   assembly          =    *(instruction / directive / label)\n   instruction\
    \       =    opcode [\"(\" operand *(\",\" operand) \")\"]\n   operand       \
    \    =    [[\"$\"] expression]\n                              ; Operands can be\
    \ left blank if they can\n                              ; be automatically inferred\
    \ by the\n                              ; compiler, e.g., a literal operand\n\
    \                              ; that specifies the total number of\n        \
    \                      ; operands for the instruction.\n                     \
    \         ; When \"$\" is prepended to an operand,\n                         \
    \     ; the corresponding integer is an\n                              ; address\
    \ rather than the actual operand\n                              ; value.  This\
    \ symbol is mandatory for\n                              ; reference operands,\
    \ optional for\n                              ; multitypes and addresses, and\n\
    \                              ; disallowed for literals.\n   label          \
    \   =    \":\" name\n   directive         =    padding / data / set / readonly\
    \ /\n                          unknown-directive\n   unknown-directive =    name\
    \ [\"(\" expression *(\",\" expression) \")\"]\n                             \
    \ ; The parser can ignore unknown\n                              ; directives.\
    \  The resulting bytecode\n                              ; may or may not generate\
    \ the expected\n                              ; results.\n   padding         \
    \  =    (\"pad\" / \"align\" / \"at\") \"(\" expression \")\"\n   data       \
    \       =    (\"byte\" / \"word\") \"(\" expression *(\",\"\n                \
    \          expression) \")\"\n   readonly          =    \"readonly\" \"(\" \"\
    0\" / \"1\" \")\"\n   set               =    \"set\" \"(\" name \",\" expression\
    \ \")\"\n   expression        =    value / \"(\" expression operator expression\
    \ \")\"\n   value             =    dec / bin / hex / name / \".\" / \"!\"\n  \
    \                            ; \".\" is the location of this\n               \
    \               ; instruction/directive, whereas \"!\" is\n                  \
    \            ; the location of the closest\n                              ; DECOMPRESSION-FAILURE\n\
    \   The following sections define how to convert the instructions, labels\n  \
    \ and directives into UDVM bytecode:\n"
- title: 3.2.1.  Expressions
  contents:
  - "3.2.1.  Expressions\n   The operand values needed by particular instructions\
    \ or directives\n   can be given in the form of expressions.  An expression can\
    \ include\n   one or more values specified as decimal, binary, or hex (binary\n\
    \   values are preceded by \"0b\" and hex values are preceded by \"0x\").\n  \
    \ The expression may also include one or more of the following\n   operators:\n\
    \          \"+\"    Addition\n          \"-\"    Subtraction\n          \"*\"\
    \    Multiplication\n          \"/\"    Integer division\n          \"%\"    Modulo\
    \ arithmetic (a%b := a modulo b)\n          \"&\"    Binary AND\n          \"\
    |\"    Binary OR\n          \"^\"    Binary XOR\n          \"~\"    Binary XNOR\n\
    \          \"<<\"   Binary LSHIFT\n          \">>\"   Binary RSHIFT\n   The operands\
    \ for each operator must always be surrounded by\n   parentheses so that the order\
    \ in which the operators should be\n   evaluated is clear.  For example:\n   ((1\
    \ + (2 * 3)) & (0xabcd - 0b00101010)) gives the result 3.\n   Expressions can\
    \ also include the special values \".\" and \"!\".  When\n   the symbol \".\"\
    \ is encountered, it is replaced by the location in the\n   bytecode of the current\
    \ instruction/directive.  When the symbol \"!\"\n   is encountered it is replaced\
    \ by the location in the bytecode of the\n   closest DECOMPRESSION-FAILURE instruction\
    \ (i.e., the closest zero\n   byte).  This can be useful when writing UDVM instructions\
    \ that call a\n   decompression failure, for example:\n   INPUT-BYTES (1, temp,\
    \ !)\n   The above instruction causes a decompression failure to occur if it\n\
    \   tries to input data from beyond the end of the compressed message.\n   Note:\
    \ When using \"!\" in the assembly language to generate bytecode,\n   care must\
    \ be taken to ensure that the address of the zero used at\n   bytecode generation\
    \ time will still contain zero when the bytecode is\n   run.  The readonly directive\
    \ (see Section 3.2.3) can be used to do\n   this.\n   It is also possible to assign\
    \ integer values to text names: when a\n   text name is encountered in an expression,\
    \ it is replaced by the\n   integer value assigned to it.  Section 3.2.3 explains\
    \ how to assign\n   integer values to text names.\n"
- title: 3.2.2.  Instructions
  contents:
  - "3.2.2.  Instructions\n   A UDVM instruction is specified by the instruction opcode\
    \ followed by\n   zero or more operands.  The instruction operands are enclosed\
    \ in\n   parentheses and separated by commas, for example:\n   ADD ($3, 4)\n \
    \  When generating the bytecode, the parser should replace the\n   instruction\
    \ opcode with the corresponding 1-byte value as per Figure\n   11 of SigComp [2].\n\
    \   Each operand consists of an expression that evaluates to an integer,\n   optionally\
    \ preceded by the symbol \"$\".  This symbol indicates that\n   the supplied integer\
    \ value must be interpreted as the memory address\n   at which the operand value\
    \ can be found, rather than the actual\n   operand value itself.\n   When converting\
    \ each instruction operand to bytecode, the parser\n   first determines whether\
    \ the instruction expects the operand to be a\n   literal, a reference, a multitype,\
    \ or an address.  If the operand is\n   a literal, then, as per Figure 8 of SigComp,\
    \ the parser inserts\n   bytecode (usually the shortest) capable of encoding the\
    \ supplied\n   operand value.\n   Since literal operands are used to indicate\
    \ the total number of\n   operands for an instruction, it is possible to leave\
    \ a literal\n   operand blank and allow its value to be inferred automatically\
    \ by the\n   assembler.  For example:\n   MULTILOAD (64, , 1, 2, 3, 4)\n   The\
    \ missing operand should be given the value 4 because it is\n   followed by a\
    \ total of 4 operands.\n   If the operand is a reference, then, as per Figure\
    \ 9 of SigComp, the\n   parser inserts bytecode (usually the shortest) capable\
    \ of encoding\n   the supplied memory address.  Note that reference operands will\n\
    \   always be preceded by the symbol \"$\" in assembly because they always\n \
    \  encode memory addresses rather than actual operand values.\n   If the operand\
    \ is a multitype, then the parser first checks whether\n   the symbol \"$\" is\
    \ present.  If so, then, as per Figure 10 of SigComp,\n   it inserts bytecode\
    \ (usually the shortest) capable of encoding the\n   supplied integer as a memory\
    \ address.  If not, then, as per Figure 10\n   of SigComp, it inserts bytecode\
    \ (usually the shortest) that encodes\n   the supplied integer as an operand value.\n\
    \   If the operand is an address, then the parser checks whether the\n   symbol\
    \ \"$\" is present.  If so, then the supplied integer is encoded\n   as a memory\
    \ address, just as for the multitype instruction above.  If\n   not, then the\
    \ byte position of the opcode is subtracted from the\n   supplied integer modulo\
    \ 16, and the result is encoded as an operand\n   value as per Figure 10 of SigComp.\n\
    \   The length of the resulting bytecode is dependent on the parser in\n   use.\
    \  There can be several correct and usable representations of the\n   same instruction.\n"
- title: 3.2.3.  Directives
  contents:
  - "3.2.3.  Directives\n   The assembly language provides a number of directives\
    \ for evaluating\n   expressions, moving instructions to a particular memory address,\
    \ etc.\n   The directives \"pad\", \"align\", and \"at\" can be used to add padding\
    \ to\n   the bytecode.\n   The directive \"pad (n)\" appends n consecutive padding\
    \ bytes to the\n   bytecode.  The actual value of the padding bytes is unimportant,\
    \ so\n   when the bytecode is uploaded to the UDVM, the padding bytes can be\n\
    \   set to the initial values contained in the UDVM memory (this helps to\n  \
    \ reduce the size of a SigComp message).\n   The directive \"align (n)\" appends\
    \ the minimum number of padding bytes\n   to the bytecode such that the total\
    \ number of bytes of bytecode\n   generated so far is a multiple of n bytes. \
    \ If the bytecode is\n   already aligned to a multiple of n bytes, then no padding\
    \ bytes are\n   added.\n   The directive \"at (n)\" appends enough padding bytes\
    \ to the bytecode\n   such that the total number of bytes of bytecode generated\
    \ so far is\n   exactly n bytes.  If more than n bytes have already been generated\n\
    \   before the \"at\" directive is encountered then the assembly code\n   contains\
    \ an error.\n   The directives \"byte\" and \"word\" can be used to add specific\
    \ data\n   strings to the bytecode.\n   The directive \"byte (n[0],..., n[k-1])\"\
    \ appends k consecutive bytes\n   to the bytecode.  The byte string is supplied\
    \ as expressions that\n   evaluate to give integers n[0],..., n[k-1] from 0 to\
    \ 255.\n   The directive \"word (n[0],..., n[k-1])\" appends k consecutive 2-byte\n\
    \   words to the bytecode.  The word string is supplied as expressions\n   that\
    \ evaluate to give integers n[0],..., n[k-1] from 0 to 65535.\n   The directive\
    \ \"set (name, n)\" assigns an integer value n to a\n   specified text name. \
    \ The integer value can be supplied in the form\n   of an expression.\n   The\
    \ directive \"readonly (n)\" where n is 0 or 1 can be used to\n   indicate that\
    \ an area of memory could be changed (0) or will not be\n   changed (1) during\
    \ the execution of the UDVM.  This directive could\n   be used, for example, in\
    \ conjunction with \"!\" to ensure that the\n   address of the zero used will\
    \ still contain zero when the bytecode is\n   executed.  If no readonly directive\
    \ is used, then any address\n   containing zero can be used by \"!\" (i.e., by\
    \ default, there is\n   assumed to be a readonly (1) directive at Address 0) and\
    \ it is up to\n   the author of the assembly code to ensure that the address in\n\
    \   question will still contain zero when the bytecode is executed.  If\n   the\
    \ readonly directive is used, then bytes between a readonly (0) and\n   readonly\
    \ (1) pair are NOT to be used by \"!\".  When a readonly\n   directive has been\
    \ used, the bytes obey that directive from that\n   address to either another\
    \ readonly directive or the end of UDVM\n   memory, whichever comes first.\n"
- title: 3.2.4.  Labels
  contents:
  - "3.2.4.  Labels\n   A label is a special directive used to assign memory addresses\
    \ to\n   text names.\n   Labels are specified by a single colon followed by the\
    \ text name to\n   be defined.  The (absolute) position of the byte immediately\n\
    \   following the label is evaluated and assigned to the text name.  For\n   example:\n\
    \   :start\n   LOAD (temp, 1)\n   Since the label \"start\" occurs at the beginning\
    \ of the bytecode, it\n   is assigned the integer value 0.\n   Note that writing\
    \ the label \":name\" has exactly the same behavior as\n   writing the directive\
    \ \"set (name, .)\".\n"
- title: 3.3.  Uploading the Bytecode to the UDVM
  contents:
  - "3.3.  Uploading the Bytecode to the UDVM\n   Once the parser has converted a\
    \ string of assembly into the\n   corresponding bytecode, it must be copied to\
    \ the UDVM memory\n   beginning at Address 0 and then executed, beginning from\
    \ the first\n   UDVM instruction in the bytecode.\n   SigComp provides the following\
    \ message format for uploading bytecode\n   to the UDVM:\n     0   1   2   3 \
    \  4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   1   1   1   1\
    \ | T |   0   |\n   +---+---+---+---+---+---+---+---+\n   |                  \
    \             |\n   :    returned feedback item     :  if T = 1\n   |        \
    \                       |\n   +---+---+---+---+---+---+---+---+\n   |        \
    \   code_len            |\n   +---+---+---+---+---+---+---+---+\n   |   code_len\
    \    |  destination  |\n   +---+---+---+---+---+---+---+---+\n   |           \
    \                    |\n   :    uploaded UDVM bytecode     :\n   |           \
    \                    |\n   +---+---+---+---+---+---+---+---+\n   |           \
    \                    |\n   :   remaining SigComp message   :\n   |           \
    \                    |\n   +---+---+---+---+---+---+---+---+\n   The destination\
    \ field should be set to the memory address of the\n   first UDVM instruction.\
    \  Note that if this address cannot be\n   represented by the destination field,\
    \ then the bytecode cannot be\n   uploaded to the UDVM using the standard SigComp\
    \ header.  In\n   particular, the memory address of the first UDVM instruction\
    \ must\n   always be a multiple of 64 bytes or the standard SigComp header\n \
    \  cannot be used.  Of course, there may be other ways to upload the\n   bytecode\
    \ to the UDVM, such as retrieving the bytecode directly via\n   the INPUT-BYTES\
    \ instruction.\n   Additionally, all memory addresses between Address 0 and Address\
    \ 31\n   inclusive are initialized to endpoint-specific values by the UDVM, so\n\
    \   they must be specified as padding in the bytecode, or the standard\n   SigComp\
    \ header cannot be used.  Memory addresses from Address 32 to\n   Address (destination\
    \ - 1) inclusive are initialized to 0, so they\n   must be specified either as\
    \ padding or as 0s if the bytecode is to be\n   successfully uploaded using the\
    \ standard SigComp header.\n   The code_len field should be set to the smallest\
    \ value such that all\n   memory addresses beginning at Address (destination +\
    \ code_len) are\n   either as initialised by the UDVM (to 0) or as set by the\
    \ bytecode at\n   runtime.\n   The \"uploaded UDVM bytecode\" should be set to\
    \ contain the segment of\n   bytecode that lies between Address (destination)\
    \ and Address\n   (destination + code_len - 1) inclusive.\n"
- title: 4.  Compression Algorithms
  contents:
  - "4.  Compression Algorithms\n   This section describes a number of compression\
    \ algorithms that can be\n   used by a SigComp compressor.  In each case, the\
    \ document provides\n   UDVM bytecode for the corresponding decompression algorithm,\
    \ which\n   can be uploaded to the receiving endpoint as part of a SigComp\n \
    \  message.  Each algorithm (as written in this section) assumes that\n   there\
    \ is a 16K decompression memory size, there are 16 cycles per\n   bit, and there\
    \ is an 8K state memory size.  Decompression will\n   succeed with a smaller value\
    \ for state memory size; however, the full\n   state will not be created.\n  \
    \ Section 4.1.1 covers a simple algorithm in some detail, including the\n   steps\
    \ required to compress and decompress a SigComp message.  The\n   remaining sections\
    \ cover well-known compression algorithms that can\n   be adapted for use in SigComp\
    \ with minimal modification.\n"
- title: 4.1.  Well-known Compression Algorithms
  contents:
  - '4.1.  Well-known Compression Algorithms

    '
- title: 4.1.1.  LZ77
  contents:
  - "4.1.1.  LZ77\n   This section describes how to implement a very simple compression\n\
    \   algorithm based on LZ77 [5].\n   A compressed message generated by the simplified\
    \ LZ77 scheme consists\n   of a sequence of 4-byte characters, where each character\
    \ contains a\n   2-byte position value followed by a 2-byte length value.  Each\
    \ pair\n   of integers identifies a byte string in the UDVM memory; when\n   concatenated,\
    \ these byte strings form the decompressed message.\n   When implementing a bytecode\
    \ decompressor for the simplified LZ77\n   scheme, the UDVM memory is partitioned\
    \ into five distinct areas, as\n   shown below:\n   0             64         \
    \ 128        256          512\n   | scratch-pad | variables | bytecode | dictionary\
    \ | circular buffer |\n   +-------------+-----------+----------+------------+-----------------+\n\
    \    <-----------> <---------> <--------> <----------> <--------------->\n   \
    \    64 bytes     64 bytes   128 bytes   256 bytes      512+ bytes\n   The first\
    \ 128 bytes are used to hold the 2-byte variables needed by\n   the LZ77 decompressor.\
    \  Within this memory, the first 64 bytes are\n   used as a scratch-pad, holding\
    \ the 2-byte variables that can be\n   discarded between SigComp messages.  In\
    \ contrast, the next 64 bytes\n   (and in fact all of the UDVM memory starting\
    \ from Address 64) should\n   be saved after decompressing a SigComp message to\
    \ improve the\n   compression ratio of subsequent messages.\n   The bytecode for\
    \ the LZ77 decompressor is stored beginning at Address\n   128.  A total of 128\
    \ bytes are reserved for the bytecode although the\n   LZ77 decompressor requires\
    \ less; this allows room for adding\n   additional features to the decompressor\
    \ at a later stage.\n   The next 256 bytes are initialized by the bytecode to\
    \ contain the\n   integers 0 to 255 inclusive.  The purpose of this memory area\
    \ is to\n   provide a dictionary of all possible uncompressed characters; this\
    \ is\n   important to ensure that the compressor can always generate a\n   sequence\
    \ of position/length pairs that encode a given message.  For\n   example, a byte\
    \ with value 0x41 (corresponding to the ASCII character\n   \"A\") can be found\
    \ at Address 0x0141 of the UDVM memory, so the\n   compressed character 0x0141\
    \ 0001 will decompress to give this ASCII\n   character.  Note that encoding each\
    \ byte in the application message\n   as a separate 4-byte compressed character\
    \ is not recommended,\n   however, as the resulting \"compressed\" message is\
    \ four times as large\n   as the original uncompressed message.\n   The compression\
    \ ratio of LZ77 is improved by the remaining UDVM\n   memory, which is used to\
    \ store a history buffer containing the\n   previously decompressed messages.\
    \  Compressed characters can point to\n   strings that have previously been decompressed\
    \ and stored in the\n   buffer, so the overall compression ratio of the LZ77 algorithm\n\
    \   improves as the decompressor \"learns\" more text strings and is able\n  \
    \ to encode longer strings using a single compressed character.  The\n   buffer\
    \ is circular, so older messages are overwritten by new data\n   when the buffer\
    \ becomes full.\n   The steps required to implement an LZ77 compressor and decompressor\n\
    \   are similar, although compression is more processor-intensive as it\n   requires\
    \ a searching operation to be performed.  Assembly for the\n   simplified LZ77\
    \ decompressor is given below:\n   ; Variables that do not need to be stored after\
    \ decompressing each\n   ; SigComp message are stored here:\n   at (32)\n   :position_value\
    \                 pad (2)\n   :length_value                   pad (2)\n   at (42)\n\
    \   set (requested_feedback_location, 0)\n   ; The UDVM registers must be stored\
    \ beginning at Address 64:\n   at (64)\n   ; Variables that should be stored after\
    \ decompressing a message are\n   ; stored here.  These variables will form part\
    \ of the SigComp state\n   ; item created by the bytecode:\n   :byte_copy_left\
    \                 pad (2)\n   :byte_copy_right                pad (2)\n   :decompressed_pointer\
    \           pad (2)\n   set (returned_parameters_location, 0)\n   align (64)\n\
    \   :initialize_memory\n   set (udvm_memory_size, 8192)\n   set (state_length,\
    \ (udvm_memory_size - 64))\n   ; The UDVM registers byte_copy_left and byte_copy_right\
    \ are set to\n   ; indicate the bounds of the circular buffer in the UDVM memory.\
    \  A\n   ; variable decompressed_pointer is also created and set pointing to\n\
    \   ; the start of the circular buffer:\n   MULTILOAD (64, 3, circular_buffer,\
    \ udvm_memory_size, circular_buffer)\n   ; The \"dictionary\" area of the UDVM\
    \ memory is initialized to contain\n   ; the values 0 to 255 inclusive:\n   MEMSET\
    \ (static_dictionary, 256, 0, 1)\n   :decompress_sigcomp_message\n   :next_character\n\
    \   ; The next character in the compressed message is read by the UDVM\n   ; and\
    \ the position and length integers are stored in the variables\n   ; position_value\
    \ and length_value, respectively.  If no more\n   ; compressed data is available,\
    \ the decompressor jumps to the\n   ; \"end_of_message\" subroutine:\n   INPUT-BYTES\
    \ (4, position_value, end_of_message)\n   ; The position_value and length_value\
    \ point to a byte string in the\n   ; UDVM memory, which is copied into the circular\
    \ buffer at the\n   ; position specified by decompressed_pointer.  This allows\
    \ the string\n   ; to be referenced by later characters in the compressed message:\n\
    \   COPY-LITERAL ($position_value, $length_value, $decompressed_pointer)\n   ;\
    \ The byte string is also outputted onto the end of the decompressed\n   ; message:\n\
    \   OUTPUT ($position_value, $length_value)\n   ; The decompressor jumps back\
    \ to consider the next character in the\n   ; compressed message:\n   JUMP (next_character)\n\
    \   :end_of_message\n   ; The decompressor saves the UDVM memory and halts:\n\
    \   END-MESSAGE (requested_feedback_location,\n   returned_parameters_location,\
    \ state_length, 64,\n   decompress_sigcomp_message, 6, 0)\n   at (256)\n   ; Memory\
    \ for the dictionary and the circular buffer are reserved by\n   ; the following\
    \ statements:\n   :static_dictionary              pad (256)\n   :circular_buffer\n\
    \   The task of an LZ77 compressor is simply to discover a sequence of\n   4-byte\
    \ compressed characters that the above bytecode will decompress\n   to give the\
    \ desired application message.  As an example, a message\n   compressed using\
    \ the simplified LZ77 algorithm is given below:\n   0x0154 0001 0168 0001 0165\
    \ 0001 0120 0001 0152 0001 0165 0001 0173\n   0x0002 0161 0001 0175 0001 0172\
    \ 0001 0161 0001 016e 0001 0174 0001\n   0x0120 0001 0161 0001 020d 0002 0174\
    \ 0001 0201 0003 0145 0001 016e\n   0x0001 0164 0001 0120 0001 016f 0001 0166\
    \ 0001 0211 0005 0155 0001\n   0x016e 0001 0169 0001 0176 0001 0165 0001 0172\
    \ 0002 0165 0001 010a\n   0x0001\n   The uncompressed message is \"The Restaurant\
    \ at the End of the\n   Universe\\n\".\n   The bytecode for the LZ77 decompressor\
    \ can be uploaded as part of the\n   compressed message, as specified in Section\
    \ 3.3.  However, in order\n   to improve the overall compression ratio, it is\
    \ important to avoid\n   uploading bytecode in every compressed message.  For\
    \ this reason,\n   SigComp allows the UDVM to save an area of its memory as a\
    \ state item\n   between compressed messages.  Once a state item has been created,\
    \ it\n   can be retrieved by sending the corresponding state identifier using\n\
    \   the following SigComp message format:\n     0   1   2   3   4   5   6   7\n\
    \   +---+---+---+---+---+---+---+---+\n   | 1   1   1   1   1 | T |   1   |\n\
    \   +---+---+---+---+---+---+---+---+\n   |                               |\n\
    \   :    returned feedback item     :  if T = 1\n   |                        \
    \       |\n   +---+---+---+---+---+---+---+---+\n   |                        \
    \       |\n   :   partial state identifier    :\n   |                        \
    \       |\n   +---+---+---+---+---+---+---+---+\n   |                        \
    \       |\n   :   remaining SigComp message   :\n   |                        \
    \       |\n   +---+---+---+---+---+---+---+---+\n   The partial_state_identifier\
    \ field must contain the first 6 bytes of\n   the state identifier for the state\
    \ item to be accessed (see [2] for\n   details of how state identifiers are derived).\n\
    \   Note that the partial_state_identifier field could be 9 or 12 bytes\n   and\
    \ that in these cases, bits 6 and 7 of the first byte of the\n   message would\
    \ be 10 or 11, respectively.\n"
- title: 4.1.2.  LZSS
  contents:
  - "4.1.2.  LZSS\n   This section provides UDVM bytecode for the simple but effective\
    \ LZSS\n   compression algorithm [6].\n   The principal improvement offered by\
    \ LZSS over LZ77 is that each\n   compressed character begins with a 1-bit indicator\
    \ flag to specify\n   whether the character is a literal or an offset/length pair.\
    \  A\n   literal value is simply a single uncompressed byte that is appended\n\
    \   directly to the decompressed message.\n   An offset/length pair contains a\
    \ 12-bit offset value from 1 to 4096\n   inclusive, followed by a 4-bit length\
    \ value from 3 to 18 inclusive.\n   Taken together, these values specify one of\
    \ the previously received\n   text strings in the circular buffer, which is then\
    \ appended to the\n   end of the decompressed message.\n   Assembly for an LZSS\
    \ decompressor is given below:\n   at (32)\n   readonly (0)\n   :index       \
    \                   pad (2)\n   :length_value                   pad (2)\n   :old_pointer\
    \                    pad (2)\n   at (42)\n   set (requested_feedback_location,\
    \ 0)\n   at (64)\n   :byte_copy_left                 pad (2)\n   :byte_copy_right\
    \                pad (2)\n   :input_bit_order                pad (2)\n   :decompressed_pointer\
    \           pad (2)\n   set (returned_parameters_location, 0)\n   align (64)\n\
    \   readonly (1)\n   :initialize_memory\n   set (udvm_memory_size, 8192)\n   set\
    \ (state_length, (udvm_memory_size - 64))\n   MULTILOAD (64, 4, circular_buffer,\
    \ udvm_memory_size, 0,\n   circular_buffer)\n   :decompress_sigcomp_message\n\
    \   :next_character\n   INPUT-HUFFMAN (index, end_of_message, 2, 9, 0, 255, 16384,\
    \ 4, 4096,\n   8191, 1)\n   COMPARE ($index, 8192, length, end_of_message, literal)\n\
    \   :literal\n   set (index_lsb, (index + 1))\n   OUTPUT (index_lsb, 1)\n   COPY-LITERAL\
    \ (index_lsb, 1, $decompressed_pointer)\n   JUMP (next_character)\n   :length\n\
    \   INPUT-BITS (4, length_value, !)\n   ADD ($length_value, 3)\n   LOAD (old_pointer,\
    \ $decompressed_pointer)\n   COPY-OFFSET ($index, $length_value, $decompressed_pointer)\n\
    \   OUTPUT ($old_pointer, $length_value)\n   JUMP (next_character)\n   :end_of_message\n\
    \   END-MESSAGE (requested_feedback_location,\n   returned_parameters_location,\
    \ state_length, 64,\n   decompress_sigcomp_message, 6, 0)\n   readonly (0)\n \
    \  :circular_buffer\n   An example of a message compressed using the LZSS algorithm\
    \ is given\n   below:\n   0x279a 0406 e378 b200 6074 1018 4ce6 1349 b842\n   The\
    \ uncompressed message is \"Oh no, not again!\".\n"
- title: 4.1.3.  LZW
  contents:
  - "4.1.3.  LZW\n   This section provides UDVM bytecode for the well-known LZW\n\
    \   compression algorithm LZW [7].  This algorithm is used in a number of\n  \
    \ standards including the GIF image format.\n   LZW compression operates in a\
    \ similar manner to LZ77 in that it\n   maintains a circular buffer of previously\
    \ received decompressed data,\n   and each compressed character references exactly\
    \ one byte string from\n   the circular buffer.  However, LZW also maintains a\
    \ \"codebook\"\n   containing 1024 position/length pairs that point to byte strings\
    \ that\n   LZW believes are most likely to occur in the uncompressed data.\n \
    \  The byte strings stored in the LZW codebook can be referenced by\n   sending\
    \ a single 10-bit value from 0 to 1023 inclusive.  The UDVM\n   extracts the corresponding\
    \ text string from the codebook and appends\n   it to the end of the decompressed\
    \ message.  It then creates a new\n   codebook entry containing the current text\
    \ string and the next\n   character to occur in the decompressed message.\n  \
    \ Assembly for an LZW decompressor is given below:\n   at (32)\n   :length_value\
    \                   pad (2)\n   :position_value                 pad (2)\n   :index\
    \                          pad (2)\n   at (42)\n   set (requested_feedback_location,\
    \ 0)\n   at (64)\n   :byte_copy_left                 pad (2)\n   :byte_copy_right\
    \                pad (2)\n   :input_bit_order                pad (2)\n   :codebook_next\
    \                  pad (2)\n   :current_length                 pad (2)\n   :decompressed_pointer\
    \           pad (2)\n   set (returned_parameters_location, 0)\n   align (64)\n\
    \   :initialize_memory\n   set (udvm_memory_size, 8192)\n   set (state_length,\
    \ (udvm_memory_size - 64))\n   MULTILOAD (64, 6, circular_buffer, udvm_memory_size,\
    \ 0, codebook, 1,\n   static_dictionary)\n   :initialize_codebook\n   ; The following\
    \ instructions are used to initialize the first 256\n   ; entries in the LZW codebook\
    \ with single ASCII characters:\n   set (index_lsb, (index + 1))\n   set (current_length_lsb,\
    \ (current_length + 1))\n   COPY-LITERAL (current_length_lsb, 3, $codebook_next)\n\
    \   COPY-LITERAL (index_lsb, 1, $decompressed_pointer)\n   ADD ($index, 1)\n \
    \  COMPARE ($index, 256, initialize_codebook, next_character, 0)\n   :decompress_sigcomp_message\n\
    \   :next_character\n   ; The following INPUT-BITS instruction extracts 10 bits\
    \ from the\n   ; compressed message:\n   INPUT-BITS (10, index, end_of_message)\n\
    \   ; The following instructions interpret the received bits as an index\n   ;\
    \ into the LZW codebook and extract the corresponding\n   ; position/length pair:\n\
    \   set (length_value_lsb, (length_value + 1))\n   MULTIPLY ($index, 3)\n   ADD\
    \ ($index, codebook)\n   COPY ($index, 3, length_value_lsb)\n   ; The following\
    \ instructions append the selected text string to the\n   ; circular buffer and\
    \ create a new codebook entry pointing to this\n   ; text string:\n   LOAD (current_length,\
    \ 1)\n   ADD ($current_length, $length_value)\n   COPY-LITERAL (current_length_lsb,\
    \ 3, $codebook_next)\n   COPY-LITERAL ($position_value, $length_value, $decompressed_pointer)\n\
    \   ; The following instruction outputs the text string specified by the\n   ;\
    \ position/length pair:\n   OUTPUT ($position_value, $length_value)\n   JUMP (next_character)\n\
    \   :end_of_message\n   END-MESSAGE (requested_feedback_location,\n   returned_parameters_location,\
    \ state_length, 64,\n   decompress_sigcomp_message, 6, 0)\n   :static_dictionary\
    \              pad (256)\n   :circular_buffer\n   at (4492)\n   :codebook\n  \
    \ An example of a message compressed using the LZW algorithm is given\n   below:\n\
    \   0x14c6 f080 6c1b c6e1 9c20 1846 e190 201d 0684 206b 1cc2 0198 6f1c\n   0x9071\
    \ b06c 42c6 8195 111a 4731 a021 02bf f0\n   The uncompressed message is \"So long\
    \ and thanks for all the fish!\\n\".\n"
- title: 4.1.4.  DEFLATE
  contents:
  - "4.1.4.  DEFLATE\n   This section provides UDVM bytecode for the DEFLATE compression\n\
    \   algorithm.  DEFLATE is the algorithm used in the well-known \"gzip\"\n   file\
    \ format.\n   The following bytecode will decompress the DEFLATE compressed data\n\
    \   format [8] with the following modifications:\n   1.  The DEFLATE compressed\
    \ data format separates blocks of compressed\n       data by transmitting 7 consecutive\
    \ zero bits.  Each SigComp\n       message is assumed to contain a separate block\
    \ of compressed\n       data, so the end-of-block bits are implicit and do not\
    \ need to be\n       transmitted at the end of a SigComp message.\n   2.  This\
    \ bytecode supports only DEFLATE block type 01 (data\n       compressed with fixed\
    \ Huffman codes).\n   Assembly for the DEFLATE decompressor is given below:\n\
    \   at (32)\n   readonly (0)\n   :index                          pad (2)\n   :extra_length_bits\
    \              pad (2)\n   :length_value                   pad (2)\n   :extra_distance_bits\
    \            pad (2)\n   :distance_value                 pad (2)\n   at (42)\n\
    \   set (requested_feedback_location, 0)\n   at (64)\n   :byte_copy_left     \
    \            pad (2)\n   :byte_copy_right                pad (2)\n   :input_bit_order\
    \                pad (2)\n   :decompressed_pointer           pad (2)\n   :length_table\
    \                   pad (116)\n   :distance_table                 pad (120)\n\
    \   set (returned_parameters_location, 0)\n   align (64)\n   readonly (1)\n  \
    \ :initialize_memory\n   set (udvm_memory_size, 8192)\n   set (state_length, (udvm_memory_size\
    \ - 64))\n   set (length_table_start, (((length_table - 4) + 65536) / 4))\n  \
    \ set (length_table_mid, (length_table_start + 24))\n   set (distance_table_start,\
    \ (distance_table / 4))\n   MULTILOAD (64, 122, circular_buffer, udvm_memory_size,\
    \ 5,\n   circular_buffer,\n   0,       3,       0,       4,       0,       5,\n\
    \   0,       6,       0,       7,       0,       8,\n   0,       9,       0, \
    \      10,      1,       11,\n   1,       13,      1,       15,      1,      \
    \ 17,\n   2,       19,      2,       23,      2,       27,\n   2,       31,  \
    \    3,       35,      3,       43,\n   3,       51,      3,       59,      4,\
    \       67,\n   4,       83,      4,       99,      4,       115,\n   5,     \
    \  131,     5,       163,     5,       195,\n   5,       227,     0,       258,\n\
    \   0,       1,       0,       2,       0,       3,\n   0,       4,       1, \
    \      5,       1,       7,\n   2,       9,       2,       13,      3,       17,\n\
    \   3,       25,      4,       33,      4,       49,\n   5,       65,      5,\
    \       97,      6,       129,\n   6,       193,     7,       257,     7,    \
    \   385,\n   8,       513,     8,       769,     9,       1025,\n   9,       1537,\
    \    10,      2049,    10,      3073,\n   11,      4097,    11,      6145,   \
    \ 12,      8193,\n   12,      12289,   13,      16385,   13,      24577)\n   :decompress_sigcomp_message\n\
    \   INPUT-BITS (3, extra_length_bits, !)\n   :next_character\n   INPUT-HUFFMAN\
    \ (index, end_of_message, 4,\n       7, 0, 23, length_table_start,\n       1,\
    \ 48, 191, 0,\n       0, 192, 199, length_table_mid,\n       1, 400, 511, 144)\n\
    \   COMPARE ($index, length_table_start, literal, end_of_message,\n   length_distance)\n\
    \   :literal\n   set (index_lsb, (index + 1))\n   OUTPUT (index_lsb, 1)\n   COPY-LITERAL\
    \ (index_lsb, 1, $decompressed_pointer)\n   JUMP (next_character)\n   :length_distance\n\
    \   ; this is the length part\n   MULTIPLY ($index, 4)\n   COPY ($index, 4, extra_length_bits)\n\
    \   INPUT-BITS ($extra_length_bits, extra_length_bits, !)\n   ADD ($length_value,\
    \ $extra_length_bits)\n   ; this is the distance part\n   INPUT-HUFFMAN (index,\
    \ !, 1, 5, 0, 31, distance_table_start)\n   MULTIPLY ($index, 4)\n   COPY ($index,\
    \ 4, extra_distance_bits)\n   INPUT-BITS ($extra_distance_bits, extra_distance_bits,\
    \ !)\n   ADD ($distance_value, $extra_distance_bits)\n   LOAD (index, $decompressed_pointer)\n\
    \   COPY-OFFSET ($distance_value, $length_value, $decompressed_pointer)\n   OUTPUT\
    \ ($index, $length_value)\n   JUMP (next_character)\n   :end_of_message\n   END-MESSAGE\
    \ (requested_feedback_location,\n   returned_parameters_location, state_length,\
    \ 64,\n   decompress_sigcomp_message, 6, 0)\n   readonly (0)\n   :circular_buffer\n\
    \   An example of a message compressed using the DEFLATE algorithm is\n   given\
    \ below:\n   0xf3c9 4c4b d551 28c9 4855 08cd cb2c 4b2d 2a4e 5548 cc4b 5170 0532\n\
    \   0x2b4b 3232 f3d2 b900\n   The uncompressed message is \"Life, the Universe\
    \ and Everything\\n\".\n"
- title: 4.1.5.  LZJH
  contents:
  - "4.1.5.  LZJH\n   This section provides UDVM bytecode for the LZJH compression\n\
    \   algorithm.  LZJH is the algorithm adopted by the International\n   Telecommunication\
    \ Union (ITU-T) Recommendation V.44 [9].\n   Assembly for the LZJH decompressor\
    \ is given below:\n   at (32)\n   readonly (0)\n   ; The following 2-byte variables\
    \ are stored in the scratch-pad memory\n   ; area because they do not need to\
    \ be saved after decompressing a\n   ; SigComp message:\n   :length_value    \
    \               pad (2)\n   :position_value                 pad (2)\n   :index\
    \                          pad (2)\n   :extra_extension_bits           pad (2)\n\
    \   :codebook_old                   pad (2)\n   at (42)\n   set (requested_feedback_location,\
    \ 0)\n   at (64)\n   ; UDVM_registers\n   :byte_copy_left                 pad\
    \ (2)\n   :byte_copy_right                pad (2)\n   :input_bit_order       \
    \         pad (2)\n   ; The following 2-byte variables are saved as state after\n\
    \   ; decompressing a SigComp message:\n   :current_length                 pad\
    \ (2)\n   :decompressed_pointer           pad (2)\n   :ordinal_length        \
    \         pad (2)\n   :codeword_length                pad (2)\n   :codebook_next\
    \                  pad (2)\n   set (returned_parameters_location, 0)\n   align\
    \ (64)\n   readonly (1)\n   :initialize_memory\n   ; The following constants can\
    \ be adjusted to configure the LZJH\n   ; decompressor.  The current settings\
    \ are as recommended in the V.44\n   ; specification (given that a total of 8K\
    \ UDVM memory is available):\n   set (udvm_memory_size, 8192)   ; sets the total\
    \ memory for LZJH\n   set (max_extension_length, 8)  ; sets the maximum string\
    \ extension\n   set (min_ordinal_length, 7)    ; sets the minimum ordinal length\n\
    \   set (min_codeword_length, 6)   ; sets the minimum codeword length\n   set\
    \ (codebook_start, 4492)\n   set (first_codeword, (codebook_start - 12))\n   set\
    \ (state_length, (udvm_memory_size - 64))\n   MULTILOAD (64, 8, circular_buffer,\
    \ udvm_memory_size, 7, 0,\n   circular_buffer, min_ordinal_length, min_codeword_length,\n\
    \   codebook_start)\n   :decompress_sigcomp_message\n   :standard_prefix\n   ;\
    \ The following code decompresses the standard 1-bit LZJH prefix\n   ; that specifies\
    \ whether the next character is an ordinal or a\n   ; codeword/control value:\n\
    \   INPUT-BITS (1, index, end_of_message)\n   COMPARE ($index, 1, ordinal, codeword_control,\
    \ codeword_control)\n   :prefix_after_codeword\n   ; The following code decompresses\
    \ the special LZJH prefix that only\n   ; occurs after a codeword.  It specifies\
    \ whether the next character\n   ; is an ordinal, a codeword/control value, or\
    \ a string extension:\n   INPUT-HUFFMAN (index, end_of_message, 2, 1, 1, 1, 2,\
    \ 1, 0, 1, 0)\n   COMPARE ($index, 1, ordinal, string_extension, codeword_control)\n\
    \   :ordinal\n   ; The following code decompresses an ordinal character and creates\n\
    \   ; a new codebook entry consisting of the ordinal character and the\n   ; next\
    \ character to be decompressed:\n   set (index_lsb, (index + 1))\n   set (current_length_lsb,\
    \ (current_length + 1))\n   INPUT-BITS ($ordinal_length, index, !)\n   OUTPUT\
    \ (index_lsb, 1)\n   LOAD (current_length, 2)\n   COPY-LITERAL (current_length_lsb,\
    \ 3, $codebook_next)\n   COPY-LITERAL (index_lsb, 1, $decompressed_pointer)\n\
    \   JUMP (standard_prefix)\n   :codeword_control\n   ; The following code decompresses\
    \ a codeword/control value:\n   INPUT-BITS ($codeword_length, index, !)\n   COMPARE\
    \ ($index, 3, control_code, initialize_memory, codeword)\n   :codeword\n   ; The\
    \ following code interprets a codeword as an index into the LZJH\n   ; codebook.\
    \  It extracts the position/length pair from the specified\n   ; codebook entry;\
    \ the position/length pair points to a byte string\n   ; in the circular buffer,\
    \ which is then copied to the end of the\n   ; decompressed message.  The code\
    \ also creates a new codebook entry\n   ; consisting of the byte string plus the\
    \ next character to be\n   ; decompressed:\n   set (length_value_lsb, (length_value\
    \ + 1))\n   MULTIPLY ($index, 3)\n   ADD ($index, first_codeword)\n   COPY ($index,\
    \ 3, length_value_lsb)\n   LOAD (current_length, 1)\n   ADD ($current_length,\
    \ $length_value)\n   LOAD (codebook_old, $codebook_next)\n   COPY-LITERAL (current_length_lsb,\
    \ 3, $codebook_next)\n   COPY-LITERAL ($position_value, $length_value, $decompressed_pointer)\n\
    \   OUTPUT ($position_value, $length_value)\n   JUMP (prefix_after_codeword)\n\
    \   :string_extension\n   ; The following code decompresses a Huffman-encoded\
    \ string extension:\n   INPUT-HUFFMAN (index, !, 4, 1, 1, 1, 1, 2, 1, 3, 2, 1,\
    \ 1, 1, 13, 3,\n   0, 7, 5)\n   COMPARE ($index, 13, continue, extra_bits, extra_bits)\n\
    \   :extra_bits\n   INPUT-BITS (max_extension_length, extra_extension_bits, !)\n\
    \   ADD ($index, $extra_extension_bits)\n   :continue\n   ; The following code\
    \ extends the most recently created codebook entry\n   ; by the number of bits\
    \ specified in the string extension:\n   COPY-LITERAL ($position_value, $length_value,\
    \ $position_value)\n   COPY-LITERAL ($position_value, $index, $decompressed_pointer)\n\
    \   OUTPUT ($position_value, $index)\n   ADD ($index, $length_value)\n   COPY\
    \ (index_lsb, 1, $codebook_old)\n   JUMP (standard_prefix)\n   :control_code\n\
    \   ; The code can handle all of the control characters in V.44 except\n   ; for\
    \ ETM (Enter Transparent Mode), which is not required for\n   ; message-based\
    \ protocols such as SigComp.\n   COMPARE ($index, 1, !, flush, stepup)\n   :flush\n\
    \   ; The FLUSH control character jumps to the beginning of the next\n   ; complete\
    \ byte in the compressed message:\n   INPUT-BYTES (0, 0, 0)\n   JUMP (standard_prefix)\n\
    \   :stepup\n   ; The STEPUP control character increases the number of bits used\
    \ to\n   ; encode an ordinal value or a codeword:\n   INPUT-BITS (1, index, !)\n\
    \   COMPARE ($index, 1, stepup_ordinal, stepup_codeword, 0)\n   :stepup_ordinal\n\
    \   ADD ($ordinal_length, 1)\n   JUMP (ordinal)\n   :stepup_codeword\n   ADD ($codeword_length,\
    \ 1)\n   JUMP (codeword_control)\n   :end_of_message\n   END-MESSAGE (requested_feedback_location,\n\
    \   returned_parameters_location, state_length, 64,\n   decompress_sigcomp_message,\
    \ 6, 0)\n   readonly (0)\n   :circular_buffer\n   An example of a message compressed\
    \ using the LZJH algorithm is given\n   below:\n   0x5c09 e6e0 cadc c8d2 dcce\
    \ 40c2 40f2 cac2 e440 c825 c840 ccde 29e8\n   0xc2f0 40e0 eae4 e0de e6ca e65c\
    \ 1403\n   The uncompressed message is \"...spending a year dead for tax\n   purposes.\\\
    n\".\n"
- title: 4.2.  Adapted Algorithms
  contents:
  - '4.2.  Adapted Algorithms

    '
- title: 4.2.1.  Modified DEFLATE
  contents:
  - "4.2.1.  Modified DEFLATE\n   Alternative algorithms can also be used with SigComp.\
    \  This section\n   shows a modified version of the DEFLATE [8] algorithm.  The\
    \ two-stage\n   encoding of DEFLATE is replaced by a single step with a discrete\n\
    \   Huffman code for each symbol.  The literal/length symbol\n   probabilities\
    \ are dependent upon whether the previous symbol was a\n   literal or a match.\
    \  Bit handling is also simpler, in that all bits\n   are input using the INPUT-HUFFMAN\
    \ instruction and the value of the H\n   bit does not change so all bits are input,\
    \ read, and interpreted in\n   the same order.\n   Assembly for the algorithm\
    \ is given below.  String matching rules are\n   the same as for the other LZ-based\
    \ algorithms, with the alternative\n   encoding of the literals and length/distance\
    \ pairs.\n   at (32)\n   readonly (0)\n   :index                          pad\
    \ (2)\n   :distance_value                 pad (2)\n   :old_pointer           \
    \         pad (2)\n   at (42)\n   set (requested_feedback_location, 0)\n   at\
    \ (64)\n   :byte_copy_left                 pad (2)\n   :byte_copy_right      \
    \          pad (2)\n   :input_bit_order                pad (2)\n   :decompressed_pointer\
    \           pad (2)\n   set (returned_parameters_location, 0)\n   at (128)\n \
    \  readonly (1)\n   :initialize_memory\n   set (udvm_memory_size, 8192)\n   set\
    \ (state_length, (udvm_memory_size - 64))\n   MULTILOAD (64, 4, circular_buffer,\
    \ udvm_memory_size, 0,\n   circular_buffer)\n   :decompress_sigcomp_message\n\
    \   :character_after_literal\n   INPUT-HUFFMAN (index, end_of_message, 16,\n \
    \      5, 0, 11, 46,\n       0, 12, 12, 256,\n       1, 26, 32, 257,\n       1,\
    \ 66, 68, 32,\n       0, 69, 94, 97,\n       0, 95, 102, 264,\n       0, 103,\
    \ 103, 511,\n       2, 416, 426, 35,\n       0, 427, 465, 58,\n       0, 466,\
    \ 481, 272,\n       1, 964, 995, 288,\n       3, 7968, 7988, 123,\n       0, 7989,\
    \ 8115, 384,\n       1, 16232, 16263, 0,\n       0, 16264, 16327, 320,\n     \
    \  1, 32656, 32767, 144)\n   COMPARE ($index, 256, literal, distance, distance)\n\
    \   :character_after_match\n   INPUT-HUFFMAN (index, end_of_message, 16,\n   \
    \    4, 0, 0, 511,\n       1, 2, 9, 256,\n       1, 20, 22, 32,\n       0, 23,\
    \ 30, 264,\n       1, 62, 73, 46,\n       0, 74, 89, 272,\n       2, 360, 385,\
    \ 97,\n       0, 386, 417, 288,\n       1, 836, 874, 58,\n       0, 875, 938,\
    \ 320,\n       1, 1878, 1888, 35,\n       0, 1889, 2015, 384,\n       1, 4032,\
    \ 4052, 123,\n       1, 8106, 8137, 0,\n       1, 16276, 16379, 144,\n       1,\
    \ 32760, 32767, 248)\n   COMPARE ($index, 256, literal, distance, distance)\n\
    \   :literal\n   set (index_lsb, (index + 1))\n   OUTPUT (index_lsb, 1)\n   COPY-LITERAL\
    \ (index_lsb, 1, $decompressed_pointer)\n   JUMP (character_after_literal)\n \
    \  :distance\n   SUBTRACT ($index, 253)\n   INPUT-HUFFMAN (distance_value, !,\
    \ 9,\n       9, 0, 7, 9,\n       0, 8, 63, 129,\n       1, 128, 135, 1,\n    \
    \   0, 136, 247, 17,\n       0, 248, 319, 185,\n       1, 640, 1407, 257,\n  \
    \     2, 5632, 6655, 1025,\n       1, 13312, 15359, 2049,\n       2, 61440, 65535,\
    \ 4097)\n   LOAD (old_pointer, $decompressed_pointer)\n   COPY-OFFSET ($distance_value,\
    \ $index, $decompressed_pointer)\n   OUTPUT ($old_pointer, $index)\n   JUMP (character_after_match)\n\
    \   :end_of_message\n   END-MESSAGE (requested_feedback_location,\n   returned_parameters_location,\
    \ state_length, 64,\n   decompress_sigcomp_message, 6, 0)\n   readonly (0)\n \
    \  :circular_buffer\n   An example of a message compressed using the modified\
    \ DEFLATE\n   algorithm is given below:\n   0xd956 b132 cd68 5424 c5a9 6215 8a70\
    \ a64d af0a 5499 3621 509b 3e4c\n   0x28b4 a145 b362 653a d0a6 498b 5a6d 2970\
    \ ac4c 930a a4ca 74a4 c268\n   0x0c\n   The uncompressed message is \"Arthur leapt\
    \ to his feet like an author\n   hearing the phone ring\".\n"
- title: 5.  Additional SigComp Mechanisms
  contents:
  - "5.  Additional SigComp Mechanisms\n   This section covers the additional mechanisms\
    \ that can be employed by\n   SigComp to improve the overall compression ratio,\
    \ including the use\n   of acknowledgements, dictionaries, and sharing state between\
    \ two\n   directions of a compressed message flow.\n   An example of assembly\
    \ code is provided for these mechanisms.\n   Depending on the mechanism and basic\
    \ algorithm in use, the assembly\n   code for either the mechanism or the basic\
    \ algorithm may require\n   modification (e.g., if the algorithm uses 'no more\
    \ input' to jump to\n   end_of_message, following end_of_message with an input\
    \ instruction\n   for CRC will not work).  In any case, these are examples and\
    \ there\n   may be alternative ways to make use of the mechanisms.\n   When each\
    \ of the compression algorithms described in Section 4 has\n   successfully decompressed\
    \ the current SigComp message, the contents\n   of the UDVM memory are saved as\
    \ a SigComp state item.  Subsequent\n   messages can access this state item by\
    \ uploading the correct state\n   identifier to the receiving endpoint, which\
    \ avoids the need to upload\n   the bytecode for the compression algorithm on\
    \ a per-message basis.\n   However, before a state item can be accessed, the compressor\
    \ must\n   first ensure that it is available at the receiving endpoint.\n   For\
    \ each SigComp compartment, the receiving endpoint maintains a list\n   of currently\
    \ available states (where the total amount of state saved\n   does not exceed\
    \ the state_memory_size for the compartment).  The\n   SigComp compressor should\
    \ maintain a similar list containing the\n   states that it has instructed the\
    \ receiving endpoint to save.\n   As well as tracking the list of state items\
    \ that it has saved at the\n   remote endpoint, the compressor also maintains\
    \ a flag for each state\n   item indicating whether or not the state can safely\
    \ be accessed.\n   State items should not be accessed until they have been acknowledged\n\
    \   (e.g., by using the SigComp feedback mechanism as per Section 5.1).\n   State\
    \ items are deleted from the list when adding a new piece of\n   state when the\
    \ total state_memory_size for the compartment is full.\n   The state to be deleted\
    \ is determined according to age and retention\n   priority as discussed in SigComp\
    \ [2].  The SigComp compressor should\n   not attempt to access any state items\
    \ that have been deleted in this\n   manner, as they may no longer be available\
    \ at the receiving endpoint.\n"
- title: 5.1.  Acknowledging a State Item
  contents:
  - "5.1.  Acknowledging a State Item\n   SigComp [2] defines a feedback mechanism\
    \ to allow the compressor to\n   request feedback from the decompressor, to give\
    \ the compressor\n   indication that a message has been received and correctly\n\
    \   decompressed and that state storage has been attempted.  (Note: This\n   mechanism\
    \ cannot convey the success or failure of individual state\n   creation requests.)\
    \  In order to invoke the feedback mechanism, the\n   following fields must be\
    \ reserved in the UDVM memory:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   |     reserved      | Q | S | I |  requested_feedback_location\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1 | requested_feedback_length |  if Q = 1\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   :   requested_feedback_field    :  if\
    \ Q = 1\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \   These fields can be reserved in any of the algorithms of Section 4 by\n  \
    \ replacing the line \"set (requested_feedback_location, 0)\" with the\n   following\
    \ assembly:\n   :requested_feedback_location    pad (1)\n   :requested_feedback_length\
    \      pad (1)\n   :requested_feedback_field       pad (12)\n   :hash_start  \
    \                   pad (8)\n   When a SigComp message is successfully decompressed\
    \ and saved as\n   state, the following bytecode instructs the receiving endpoint\
    \ to\n   return the first 6 bytes of the corresponding state identifier.  The\n\
    \   bytecode can be added to any of the compression algorithms of Section\n  \
    \ 4 immediately following the \":end_of_message\" label:\n   :end_of_message\n\
    \   set (hash_length, (state_length + 8))\n   LOAD (requested_feedback_location,\
    \ 1158)\n   MULTILOAD (hash_start, 4, state_length, 64,\n   decompress_sigcomp_message,\
    \ 6)\n   SHA-1 (hash_start, hash_length, requested_feedback_field)\n   The receiving\
    \ endpoint then returns the state identifier in the\n   \"returned feedback field\"\
    \ of the next SigComp message to be\n   transmitted in the reverse direction.\n\
    \   When the state identifier is returned, the compressor can set the\n   availability\
    \ flag for the corresponding state to 1.\n"
- title: 5.2.  Static Dictionary
  contents:
  - "5.2.  Static Dictionary\n   Certain protocols that can be compressed using SigComp\
    \ offer a fixed,\n   mandatory state item known as a static dictionary.  This\
    \ dictionary\n   contains a number of text strings that commonly occur in messages\n\
    \   generated by the protocol in question.  The overall compression ratio\n  \
    \ can often be improved by accessing the text phrases from this static\n   dictionary\
    \ rather than by uploading them as part of the compressed\n   message.\n   As\
    \ an example, a static dictionary is provided for the protocols SIP\n   and SDP,\
    \ RFC 3485 [4].  This dictionary is designed for use by a wide\n   range of compression\
    \ algorithms including all of the ones covered in\n   Section 4.\n   In any of\
    \ the compression algorithms of Section 4, the static\n   dictionary can be accessed\
    \ by inserting the following instruction\n   immediately after the \":initialize_memory\"\
    \ label:\n   STATE-ACCESS (dictionary_id, 6, 0, 0, 1024, 0)\n   The parameters\
    \ of STATE-ACCESS instruction will depend on the\n   compression algorithm in\
    \ use.\n   The following lines should also be inserted immediately after the\n\
    \   END-MESSAGE instruction:\n   :dictionary_id\n   byte (0xfb, 0xe5, 0x07, 0xdf,\
    \ 0xe5, 0xe6)\n   The text strings contained in the static dictionary can then\
    \ be\n   accessed in exactly the same manner as the text strings from\n   previously\
    \ decompressed messages (see Section 5.1 for further\n   details).\n   Note that\
    \ in some cases it is sufficient to load only part of the\n   static dictionary\
    \ into the UDVM memory.  Further information on the\n   contents of the SIP and\
    \ SDP static dictionary can be found in the\n   relevant document, RFC 3485 [4].\n"
- title: 5.3.  CRC Checksum
  contents:
  - "5.3.  CRC Checksum\n   The acknowledgement scheme of Section 5.1 is designed\
    \ to indicate the\n   successful decompression of a message.  However, it does\
    \ not\n   guarantee that the decompressed message is identical to the original\n\
    \   message, since decompression of a corrupted message could succeed but\n  \
    \ with some characters being incorrect.  This could lead to an\n   incorrect message\
    \ being passed to the application or unexpected\n   contents of state to be stored.\
    \  In order to prevent this happening,\n   a CRC check could be used.\n   If an\
    \ additional CRC check is required, then the following bytecode\n   can be inserted\
    \ after the \":end_of_message\" label:\n   INPUT-BYTES (2, index, !)\n   CRC ($index,\
    \ 64, state_length, !)\n   The bytecode extracts a 2-byte CRC from the end of\
    \ the SigComp\n   message and compares it with a CRC calculated over the UDVM\
    \ memory.\n   Decompression failure occurs if the two CRC values do not match.\n\
    \   A definition of the CRC polynomial used by the CRC instruction can be\n  \
    \ found in SigComp [2].\n"
- title: 5.4.  Announcing Additional Resources
  contents:
  - "5.4.  Announcing Additional Resources\n   If a particular endpoint is able to\
    \ offer more processing or memory\n   resources than the mandatory minimum, the\
    \ SigComp feedback mechanism\n   can be used to announce that these resources\
    \ are available to the\n   remote endpoint.  This may help to improve the overall\
    \ compression\n   ratio between the two endpoints.\n   Additionally, if an endpoint\
    \ has any pieces of state that may be\n   useful for the remote endpoint to reference,\
    \ it can advertise the\n   identifiers for the states.  The remote endpoint can\
    \ then make use of\n   any that it also knows about (i.e., knows the contents\
    \ of), for\n   example, a dictionary or shared mode state (see Section 5.5).\n\
    \   The values of the following SigComp parameters can be announced using\n  \
    \ the SigComp advertisement mechanism:\n      cycles_per_bit\n      decompression_memory_size\n\
    \      state_memory_size\n      SigComp_version\n      state identifiers\n   As\
    \ explained in SigComp, in order to announce the values of these\n   parameters,\
    \ the following fields must be reserved in the UDVM memory:\n     0   1   2  \
    \ 3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   |  cpb  |    dms\
    \    |    sms    |  returned_parameters_location\n   +---+---+---+---+---+---+---+---+\n\
    \   |        SigComp_version        |\n   +---+---+---+---+---+---+---+---+\n\
    \   | length_of_partial_state_ID_1  |\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   :  partial_state_identifier_1   :\n\
    \   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \           :               :\n   +---+---+---+---+---+---+---+---+\n   | length_of_partial_state_ID_n\
    \  |\n   +---+---+---+---+---+---+---+---+\n   |                             \
    \  |\n   :  partial_state_identifier_n   :\n   |                             \
    \  |\n   +---+---+---+---+---+---+---+---+\n   These fields can be reserved in\
    \ any of the algorithms of Section 4 by\n   replacing the line \"set (returned_parameters_location,\
    \ 0)\" with the\n   following piece of assembly:\n   :adverts_len            \
    \        pad (1)\n   :adverts_len_lsb                pad (1)\n   :returned_parameters_location\
    \   pad (1)\n   :returned_sigcomp_version       pad (1)\n   :state_ids       \
    \               pad (x)\n   where x is enough space for the number state identifiers\
    \ that the\n   endpoint wishes to advertise.\n   When a SigComp message is successfully\
    \ decompressed and saved as\n   state, the following bytecode announces to the\
    \ receiving endpoint\n   that additional resources and pieces of state are available\
    \ at the\n   sending endpoint:\n   :end_of_message\n   LOAD (returned_parameters_location,\
    \ N)\n   INPUT-BYTES (1, adverts_len_lsb, done)\n   INPUT-BYTES ($adverts_len,\
    \ state_ids, done)\n   :done\n   Note that the integer value \"N\" should be set\
    \ equal to the amount of\n   resources available at the sending endpoint.  N should\
    \ be expressed\n   as a 2-byte integer with the most significant bits corresponding\
    \ to\n   the cycles_per_bit parameter and the least significant bits\n   corresponding\
    \ to the SigComp_version parameter.\n   The length of the state identifiers followed\
    \ by the state identifiers\n   in the format shown are appended to the end of\
    \ the compressed\n   message.\n"
- title: 5.5.  Shared Compression
  contents:
  - "5.5.  Shared Compression\n   This section provides bytecode for implementing\
    \ the SigComp shared\n   compression mechanism, RFC 3321 [3].  If two endpoints\
    \ A and B are\n   communicating via SigComp, shared compression allows the messages\n\
    \   sent from Endpoint A to Endpoint B to be compressed relative to the\n   messages\
    \ sent from Endpoint B to Endpoint A (and vice versa).  This\n   may improve the\
    \ overall compression ratio by reducing the need to\n   transmit the same information\
    \ in both directions.\n   As described in RFC 3321 [3], two steps must be taken\
    \ to implement\n   shared compression at an endpoint.\n   First, it is necessary\
    \ to announce to the remote endpoint that shared\n   compression is available.\
    \  This is done by announcing the state\n   identifier as an available piece of\
    \ state.  This can be done using\n   the returned_parameters_location announcement\
    \ as in Section 5.4.\n   Second, assuming that such an announcement is received\
    \ from the\n   remote endpoint, then the state created by shared compression needs\n\
    \   to be accessed by the message sent in the opposite direction.  This\n   can\
    \ be done in a similar way to accessing the static dictionary (see\n   Section\
    \ 5.2), but using the appropriate state identifier, for\n   example, by using\
    \ the INPUT-BYTES instruction as below:\n   :shared_state_id        pad (6)\n\
    \   :access_shared_state\n   INPUT-BYTES (6, shared_state_id, !)\n   STATE-ACCESS\
    \ (shared_state_id, 6, 0, 0, $decompressed_start, 0)\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This document describes implementation options\
    \ for the SigComp\n   protocol [2].  Consequently, the security considerations\
    \ for this\n   document match those of SigComp.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   Thanks to Richard Price, Carsten Bormann, Adam Roach,\
    \ Lawrence\n   Conroy, Christian Schmidt, Max Riegel, Lars-Erik Jonsson, Jonathan\n\
    \   Rosenberg, Stefan Forsgren, Krister Svanbro, Miguel Garcia,\n   Christopher\
    \ Clanton, Khiem Le, Ka Cheong Leung, and Zoltan Barczikay\n   for valuable input\
    \ and review.\n   Special thanks to Pekka Pessi and Cristian Constantin, who served\
    \ as\n   committed working group document reviewers.\n"
- title: 8.  Intellectual Property Right Considerations
  contents:
  - "8.  Intellectual Property Right Considerations\n   The IETF has been notified\
    \ of intellectual property rights claimed in\n   regard to some or all of the\
    \ specification contained in this\n   document.  For more information consult\
    \ the online list of claimed\n   rights.\n"
- title: 9.  Normative References
  contents:
  - "9.  Normative References\n   [1]   Crocker, D. and P. Overell, \"Augmented BNF\
    \ for Syntax\n         Specifications: ABNF\", RFC 4234, October 2005.\n   [2]\
    \   Price, R., Bormann, C., Christoffersson, J., Hannu, H., Liu,\n         Z.,\
    \ and J. Rosenberg, \"Signaling Compression (SigComp)\", RFC\n         3320, January\
    \ 2003.\n   [3]   Hannu, H., Christoffersson, J., Forsgren, S., Leung, K.-C.,\n\
    \         Liu, Z., and R. Price, \"Signaling Compression (SigComp) -\n       \
    \  Extended Operations\", RFC 3321, January 2003.\n   [4]   Garcia-Martin, M.,\
    \ Bormann, C., Ott, J., Price, R., and A.B.\n         Roach, \"The Session Initiation\
    \ Protocol (SIP) and Session\n         Description Protocol (SDP) Static Dictionary\
    \ for Signaling\n         Compression (SigComp)\", RFC 3485, February 2003.\n\
    \   [5]   Ziv, J. and A. Lempel, \"A universal algorithm for sequential\n    \
    \     data compression\", IEEE 23:337-343, 1977.\n   [6]   Storer, J., \"Data\
    \ Compression: Methods and Theory\", Computer\n         Science Press ISBN 0-88175-161-8,\
    \ 1998.\n   [7]   Nelson, M., \"LZW Data Compression\", Dr Dobb's Journal,\n \
    \        October 1989.\n   [8]   Deutsch, P., \"DEFLATE Compressed Data Format\
    \ Specification\n         version 1.3\", RFC 1951, May 1996.\n   [9]  \"Data Compression\
    \ Procedures\", ITU-T Recommendation V.44,\n         November 2000.\n"
- title: Appendix A.  UDVM Bytecode for the Compression Algorithms
  contents:
  - "Appendix A.  UDVM Bytecode for the Compression Algorithms\n   The following sections\
    \ list the UDVM bytecode generated for each\n   compression algorithm of Section\
    \ 4.\n   Note that the different assemblers can output different bytecode for\n\
    \   the same piece of assembly code, so a valid assembler can produce\n   results\
    \ different from those presented below.  However, the following\n   bytecode should\
    \ always generate the same decompressed messages on any\n   UDVM.\n"
- title: A.1.  Well-known Algorithms
  contents:
  - 'A.1.  Well-known Algorithms

    '
- title: A.1.1.  LZ77
  contents:
  - "A.1.1.  LZ77\n   0x0f86 0389 8d89 1588 8800 011c 0420 0d13 5051 2222 5051 16f5\
    \ 2300\n   0x00bf c086 a08b 06\n"
- title: A.1.2.  LZSS
  contents:
  - "A.1.2.  LZSS\n   0x0f86 04a0 c48d 00a0 c41e 2031 0209 00a0 ff8e 048c bfff 0117\
    \ 508d\n   0x0f23 0622 2101 1321 0123 16e5 1d04 22e8 0611 030e 2463 1450 5123\n\
    \   0x2252 5116 9fd2 2300 00bf c086 a089 06\n"
- title: A.1.3.  LZW
  contents:
  - "A.1.3.  LZW\n   0x0f86 06a1 ce8d 00b1 8f01 a0ce 13a0 4903 2313 2501 2506 1201\
    \ 1752\n   0x88f4 079f 681d 0a24 2508 1203 0612 b18f 1252 0321 0ea0 4801 0624\n\
    \   0x5013 a049 0323 1351 5025 2251 5016 9fde 2300 00bf c086 a09f 06\n"
- title: A.1.4.  DEFLATE
  contents:
  - "A.1.4.  DEFLATE\n   0x0f86 7aa2 528d 05a2 5200 0300 0400 0500 0600 0700 0800\
    \ 0900 0a01\n   0x0b01 0d01 0f01 1102 1302 1702 1b02 1f03 2303 2b03 3303 3b04\
    \ a043\n   0x04a0 5304 a063 04a0 7305 a083 05a0 a305 a0c3 05a0 e300 a102 0001\n\
    \   0x0002 0003 0004 0105 0107 0209 020d 0311 0319 0421 0431 05a0 4105\n   0xa061\
    \ 06a0 8106 a0c1 07a1 0107 a181 08a2 0108 a301 09a4 0109 a601\n   0x0aa8 010a\
    \ ac01 0bb0 010b b801 0c80 2001 0c80 3001 0d80 4001 0d80\n   0x6001 1d03 229f\
    \ b41e 20a0 6504 0700 1780 4011 0130 a0bf 0000 a0c0\n   0xa0c7 8040 2901 a190\
    \ a1ff a090 1750 8040 1109 a046 1322 2101 1321\n   0x0123 169f d108 1004 1250\
    \ 0422 1d51 229f d706 1251 1e20 9fcf 0105\n   0x001f 2f08 1004 1250 0426 1d53\
    \ 26f6 0614 530e 2063 1454 5223 2250\n   0x5216 9f9e 2300 00bf c086 a1de 06\n"
- title: A.1.5.  LZJH
  contents:
  - "A.1.5.  LZJH\n   0x0f86 08a1 5b8d 0700 a15b 0706 b18f 1d01 24a0 c317 5201 1a31\
    \ 311e\n   0x24a0 b802 0101 0102 0100 0100 1752 0107 a04e 1e1d 6524 f822 2501\n\
    \   0x0ea0 4602 13a0 4703 2713 2501 2416 9fcd 1d66 24e1 1752 03a0 639f\n   0xb808\
    \ 0812 0306 12b1 8312 5203 210e a046 0106 2350 0e28 6713 a047\n   0x0327 1351\
    \ 5024 2251 5016 9fa8 1e24 9fb1 0401 0101 0102 0103 0201\n   0x0101 0d03 0007\
    \ 0517 520d 0d06 061d 0826 f706 1253 1351 5011 1351\n   0x5224 2251 5206 1250\
    \ 1225 0154 169f 6617 5201 9fdb 070f 1c00 009e\n   0xce16 9f57 1d01 24fa 1752\
    \ 0107 0d9e c206 2501 169f 6506 2601 169f\n   0x7623 0000 bfc0 86a0 8e06\n"
- title: A.2.  Adapted Algorithms
  contents:
  - 'A.2.  Adapted Algorithms

    '
- title: A.2.1.  Modified DEFLATE
  contents:
  - "A.2.1.  Modified DEFLATE\n   0x0f86 04a1 d38d 00a1 d31e 20a1 4010 0500 0b2e 000c\
    \ 0c88 011a 20a1\n   0x0101 a042 a044 2000 a045 a05e a061 00a0 5fa0 66a1 0800\
    \ a067 a067\n   0xa1ff 02a1 a0a1 aa23 00a1 aba1 d13a 00a1 d2a1 e1a1 1001 a3c4\
    \ a3e3\n   0xa120 03bf 20bf 34a0 7b00 bf35 bfb3 a180 0180 3f68 803f 8700 0080\n\
    \   0x3f88 803f c7a1 4001 807f 9080 7fff a090 1750 88a0 79a0 83a0 831e\n   0x20a0\
    \ c810 0400 00a1 ff01 0209 8801 1416 2000 171e a108 013e a049\n   0x2e00 a04a\
    \ a059 a110 02a1 68a1 81a0 6100 a182 a1a1 a120 01a3 44a3\n   0x6a3a 00a3 6ba3\
    \ aaa1 4001 a756 a760 2300 a761 a7df a180 01af c0af\n   0xd4a0 7b01 bfaa bfc9\
    \ 0001 803f 9480 3ffb a090 0180 7ff8 807f ffa0\n   0xf817 5088 0610 1022 2101\
    \ 1321 0123 169f 1107 10a0 fd1e 229f d909\n   0x0900 0709 0008 3fa0 8101 87a0\
    \ 8701 00a0 88a0 f711 00a0 f8a1 3fa0\n   0xb901 a280 a57f a101 02b6 00b9 ffa4\
    \ 0101 8034 0080 3bff a801 0290\n   0x00ff b001 0e24 6314 5150 2322 5250 169f\
    \ 3b23 0000 bfc0 86a0 8906\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Abigail Surtees\n   Siemens/Roke Manor Research\n   Roke\
    \ Manor Research Ltd.\n   Romsey, Hants  SO51 0ZN\n   UK\n   Phone: +44 (0)1794\
    \ 833131\n   EMail: abigail.surtees@roke.co.uk\n   URI:   http://www.roke.co.uk\n\
    \   Mark A. West\n   Siemens/Roke Manor Research\n   Roke Manor Research Ltd.\n\
    \   Romsey, Hants  SO51 0ZN\n   UK\n   Phone: +44 (0)1794 833311\n   EMail: mark.a.west@roke.co.uk\n\
    \   URI:   http://www.roke.co.uk\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
