- contents:
  - "  Datagram Transport Layer Security (DTLS) Extension to Establish Keys\n           for
    the Secure Real-time Transport Protocol (SRTP)\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes a Datagram Transport Layer Security (DTLS)\n
    \  extension to establish keys for Secure RTP (SRTP) and Secure RTP\n   Control
    Protocol (SRTCP) flows.  DTLS keying happens on the media\n   path, independent
    of any out-of-band signalling channel present.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5764.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n   2.  Conventions Used In This Document  . . . . . . . . . .
    . . . .  3\n   3.  Overview of DTLS-SRTP Operation  . . . . . . . . . . . . .
    . .  4\n   4.  DTLS Extensions for SRTP Key Establishment . . . . . . . . . .
    \ 5\n     4.1.  The use_srtp Extension . . . . . . . . . . . . . . . . . .  5\n
    \      4.1.1.  use_srtp Extension Definition  . . . . . . . . . . . .  7\n       4.1.2.
    \ SRTP Protection Profiles . . . . . . . . . . . . . . .  8\n       4.1.3.  srtp_mki
    value . . . . . . . . . . . . . . . . . . . .  9\n     4.2.  Key Derivation .
    . . . . . . . . . . . . . . . . . . . . . 10\n     4.3.  Key Scope  . . . . .
    . . . . . . . . . . . . . . . . . . . 12\n     4.4.  Key Usage Limitations  .
    . . . . . . . . . . . . . . . . . 12\n   5.  Use of RTP and RTCP over a DTLS-SRTP
    Channel . . . . . . . . . 13\n     5.1.  Data Protection  . . . . . . . . . .
    . . . . . . . . . . . 13\n       5.1.1.  Transmission . . . . . . . . . . . .
    . . . . . . . . . 13\n       5.1.2.  Reception  . . . . . . . . . . . . . . .
    . . . . . . . 13\n     5.2.  Rehandshake and Rekey  . . . . . . . . . . . . .
    . . . . . 16\n   6.  Multi-Party RTP Sessions . . . . . . . . . . . . . . . .
    . . . 17\n   7.  Security Considerations  . . . . . . . . . . . . . . . . . .
    . 17\n     7.1.  Security of Negotiation  . . . . . . . . . . . . . . . . . 17\n
    \    7.2.  Framing Confusion  . . . . . . . . . . . . . . . . . . . . 17\n     7.3.
    \ Sequence Number Interactions . . . . . . . . . . . . . . . 18\n       7.3.1.
    \ Alerts . . . . . . . . . . . . . . . . . . . . . . . . 18\n       7.3.2.  Renegotiation
    \ . . . . . . . . . . . . . . . . . . . . 18\n     7.4.  Decryption Cost  . .
    . . . . . . . . . . . . . . . . . . . 19\n   8.  Session Description for RTP/SAVP
    over DTLS . . . . . . . . . . 19\n   9.  IANA Considerations  . . . . . . . .
    . . . . . . . . . . . . . 20\n   10. Acknowledgments  . . . . . . . . . . . .
    . . . . . . . . . . . 20\n   11. References . . . . . . . . . . . . . . . . .
    . . . . . . . . . 21\n     11.1. Normative References . . . . . . . . . . . .
    . . . . . . . 21\n     11.2. Informative References . . . . . . . . . . . . .
    . . . . . 21\n   Appendix A.  Overview of DTLS  . . . . . . . . . . . . . . .
    . . . 23\n   Appendix B.  Performance of Multiple DTLS Handshakes . . . . . .
    . 24\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Secure RTP (SRTP) profile [RFC3711] can provide confidentiality,\n
    \  message authentication, and replay protection to RTP data and RTP\n   Control
    (RTCP) traffic.  SRTP does not provide key management\n   functionality, but instead
    depends on external key management to\n   exchange secret master keys, and to
    negotiate the algorithms and\n   parameters for use with those keys.\n   Datagram
    Transport Layer Security (DTLS) [RFC4347] is a channel\n   security protocol that
    offers integrated key management, parameter\n   negotiation, and secure data transfer.
    \ Because DTLS data transfer\n   protocol is generic, it is less highly optimized
    for use with RTP\n   than is SRTP, which has been specifically tuned for that
    purpose.\n   This document describes DTLS-SRTP, a SRTP extension for DTLS that\n
    \  combines the performance and encryption flexibility benefits of SRTP\n   with
    the flexibility and convenience of DTLS-integrated key and\n   association management.
    \ DTLS-SRTP can be viewed in two equivalent\n   ways: as a new key management
    method for SRTP, and a new RTP-specific\n   data format for DTLS.\n   The key
    points of DTLS-SRTP are that:\n   o  application data is protected using SRTP,\n
    \  o  the DTLS handshake is used to establish keying material,\n      algorithms,
    and parameters for SRTP,\n   o  a DTLS extension is used to negotiate SRTP algorithms,
    and\n   o  other DTLS record-layer content types are protected using the\n      ordinary
    DTLS record format.\n   The remainder of this memo is structured as follows.  Section
    2\n   describes conventions used to indicate normative requirements.\n   Section
    3 provides an overview of DTLS-SRTP operation.  Section 4\n   specifies the DTLS
    extensions, while Section 5 discusses how RTP and\n   RTCP are transported over
    a DTLS-SRTP channel.  Section 6 describes\n   use with multi-party sessions.  Section
    7 and Section 9 describe\n   Security and IANA considerations.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions Used In This Document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
    in [RFC2119].\n"
  title: 2.  Conventions Used In This Document
- contents:
  - "3.  Overview of DTLS-SRTP Operation\n   DTLS-SRTP is defined for point-to-point
    media sessions, in which\n   there are exactly two participants.  Each DTLS-SRTP
    session contains\n   a single DTLS association (called a \"connection\" in TLS
    jargon), and\n   either two SRTP contexts (if media traffic is flowing in both\n
    \  directions on the same host/port quartet) or one SRTP context (if\n   media
    traffic is only flowing in one direction).  All SRTP traffic\n   flowing over
    that pair in a given direction uses a single SRTP\n   context.  A single DTLS-SRTP
    session only protects data carried over\n   a single UDP source and destination
    port pair.\n   The general pattern of DTLS-SRTP is as follows.  For each RTP or
    RTCP\n   flow the peers do a DTLS handshake on the same source and destination\n
    \  port pair to establish a DTLS association.  Which side is the DTLS\n   client
    and which side is the DTLS server must be established via some\n   out-of-band
    mechanism such as SDP.  The keying material from that\n   handshake is fed into
    the SRTP stack.  Once that association is\n   established, RTP packets are protected
    (becoming SRTP) using that\n   keying material.\n   RTP and RTCP traffic is usually
    sent on two separate UDP ports.  When\n   symmetric RTP [RFC4961] is used, two
    bidirectional DTLS-SRTP sessions\n   are needed, one for the RTP port, one for
    the RTCP port.  When RTP\n   flows are not symmetric, four unidirectional DTLS-SRTP
    sessions are\n   needed (for inbound and outbound RTP, and inbound and outbound
    RTCP).\n   Symmetric RTP [RFC4961] is the case in which there are two RTP\n   sessions
    that have their source and destination ports and addresses\n   reversed, in a
    manner similar to the way that a TCP connection uses\n   its ports.  Each participant
    has an inbound RTP session and an\n   outbound RTP session.  When symmetric RTP
    is used, a single DTLS-SRTP\n   session can protect both of the RTP sessions.
    \ It is RECOMMENDED that\n   symmetric RTP be used with DTLS-SRTP.\n   RTP and
    RTCP traffic MAY be multiplexed on a single UDP port\n   [RFC5761].  In this case,
    both RTP and RTCP packets may be sent over\n   the same DTLS-SRTP session, halving
    the number of DTLS-SRTP sessions\n   needed.  This improves the cryptographic
    performance of DTLS, but may\n   cause problems when RTCP and RTP are subject
    to different network\n   treatment (e.g., for bandwidth reservation or scheduling
    reasons).\n   Between a single pair of participants, there may be multiple media\n
    \  sessions.  There MUST be a separate DTLS-SRTP session for each\n   distinct
    pair of source and destination ports used by a media session\n   (though the sessions
    can share a single DTLS session and hence\n   amortize the initial public key
    handshake!).\n   A DTLS-SRTP session may be indicated by an external signaling\n
    \  protocol like SIP.  When the signaling exchange is integrity-\n   protected
    (e.g., when SIP Identity protection via digital signatures\n   is used), DTLS-SRTP
    can leverage this integrity guarantee to provide\n   complete security of the
    media stream.  A description of how to\n   indicate DTLS-SRTP sessions in SIP
    and SDP [RFC4566], and how to\n   authenticate the endpoints using fingerprints
    can be found in\n   [RFC5763].\n   In a naive implementation, when there are multiple
    media sessions,\n   there is a new DTLS session establishment (complete with public
    key\n   cryptography) for each media channel.  For example, a videophone may\n
    \  be sending both an audio stream and a video stream, each of which\n   would
    use a separate DTLS session establishment exchange, which would\n   proceed in
    parallel.  As an optimization, the DTLS-SRTP\n   implementation SHOULD use the
    following strategy: a single DTLS\n   association is established, and all other
    DTLS associations wait\n   until that connection is established before proceeding
    with their\n   handshakes.  This strategy allows the later sessions to use DTLS\n
    \  session resumption, which allows the amortization of the expensive\n   public
    key cryptography operations over multiple DTLS handshakes.\n   The SRTP keys used
    to protect packets originated by the client are\n   distinct from the SRTP keys
    used to protect packets originated by the\n   server.  All of the RTP sources
    originating on the client for the\n   same channel use the same SRTP keys, and
    similarly, all of the RTP\n   sources originating on the server for the same channel
    use the same\n   SRTP keys.  The SRTP implementation MUST ensure that all of the\n
    \  synchronization source (SSRC) values for all of the RTP sources\n   originating
    from the same device over the same channel are distinct,\n   in order to avoid
    the \"two-time pad\" problem (as described in Section\n   9.1 of RFC 3711).  Note
    that this is not an issue for separate media\n   streams (on different host/port
    quartets) that use independent keying\n   material even if an SSRC collision occurs.\n"
  title: 3.  Overview of DTLS-SRTP Operation
- contents:
  - '4.  DTLS Extensions for SRTP Key Establishment

    '
  - contents:
    - "4.1.  The use_srtp Extension\n   In order to negotiate the use of SRTP data
      protection, clients\n   include an extension of type \"use_srtp\" in the DTLS
      extended client\n   hello.  This extension MUST only be used when the data being\n
      \  transported is RTP or RTCP [RFC3550].  The \"extension_data\" field of\n
      \  this extension contains the list of acceptable SRTP protection\n   profiles,
      as indicated below.\n   Servers that receive an extended hello containing a
      \"use_srtp\"\n   extension can agree to use SRTP by including an extension of
      type\n   \"use_srtp\", with the chosen protection profile in the extended server\n
      \  hello.  This process is shown below.\n         Client                                               Server\n
      \        ClientHello + use_srtp       -------->\n                                              ServerHello
      + use_srtp\n                                                        Certificate*\n
      \                                                 ServerKeyExchange*\n                                                 CertificateRequest*\n
      \                                     <--------      ServerHelloDone\n         Certificate*\n
      \        ClientKeyExchange\n         CertificateVerify*\n         [ChangeCipherSpec]\n
      \        Finished                     -------->\n                                                  [ChangeCipherSpec]\n
      \                                     <--------             Finished\n         SRTP
      packets                 <------->      SRTP packets\n   Note that '*' indicates
      messages that are not always sent in DTLS.\n   The CertificateRequest, client
      and server Certificates, and\n   CertificateVerify will be sent in DTLS-SRTP.\n
      \  Once the \"use_srtp\" extension is negotiated, the RTP or RTCP\n   application
      data is protected solely using SRTP.  Application data is\n   never sent in
      DTLS record-layer \"application_data\" packets.  Rather,\n   complete RTP or
      RTCP packets are passed to the DTLS stack, which\n   passes them to the SRTP
      stack, which protects them appropriately.\n   Note that if RTP/RTCP multiplexing
      [RFC5761] is in use, this means\n   that RTP and RTCP packets may both be passed
      to the DTLS stack.\n   Because the DTLS layer does not process the packets,
      it does not need\n   to distinguish them.  The SRTP stack can use the procedures
      of\n   [RFC5761] to distinguish RTP from RTCP.\n   When the \"use_srtp\" extension
      is in effect, implementations must not\n   place more than one application data
      \"record\" per datagram.  (This is\n   only meaningful from the perspective
      of DTLS because SRTP is\n   inherently oriented towards one payload per packet,
      but this is\n   stated purely for clarification.)\n   Data other than RTP/RTCP
      (i.e., TLS control messages) MUST use\n   ordinary DTLS framing and MUST be
      placed in separate datagrams from\n   SRTP data.\n   A DTLS-SRTP handshake establishes
      one or more SRTP crypto contexts;\n   however, they all have the same SRTP Protection
      Profile and Master\n   Key Identifier (MKI), if any.  MKIs are used solely to
      distinguish\n   the keying material and protection profiles between distinct\n
      \  handshakes, for instance, due to rekeying.  When an MKI is\n   established
      in a DTLS-SRTP session, it MUST apply for all of the\n   SSRCs within that session
      -- though a single endpoint may negotiate\n   multiple DTLS-SRTP sessions due,
      for instance, to forking.  (Note\n   that RFC 3711 allows packets within the
      same session but with\n   different SSRCs to use MKIs differently; in contrast,
      DTLS-SRTP\n   requires that MKIs and the keys that they are associated with
      have\n   the same meaning and are uniform across the entire SRTP session.)\n"
    - contents:
      - "4.1.1.  use_srtp Extension Definition\n   The client MUST fill the extension_data
        field of the \"use_srtp\"\n   extension with an UseSRTPData value (see Section
        9 for the\n   registration):\n      uint8 SRTPProtectionProfile[2];\n      struct
        {\n         SRTPProtectionProfiles SRTPProtectionProfiles;\n         opaque
        srtp_mki<0..255>;\n      } UseSRTPData;\n      SRTPProtectionProfile SRTPProtectionProfiles<2..2^16-1>;\n
        \  The SRTPProtectionProfiles list indicates the SRTP protection\n   profiles
        that the client is willing to support, listed in descending\n   order of preference.
        \ The srtp_mki value contains the SRTP Master Key\n   Identifier (MKI) value
        (if any) that the client will use for his SRTP\n   packets.  If this field
        is of zero length, then no MKI will be used.\n   Note: for those unfamiliar
        with TLS syntax, \"srtp_mki<0..255>\"\n   indicates a variable-length value
        with a length between 0 and 255\n   (inclusive).  Thus, the MKI may be up
        to 255 bytes long.\n   If the server is willing to accept the use_srtp extension,
        it MUST\n   respond with its own \"use_srtp\" extension in the ExtendedServerHello.\n
        \  The extension_data field MUST contain a UseSRTPData value with a\n   single
        SRTPProtectionProfile value that the server has chosen for use\n   with this
        connection.  The server MUST NOT select a value that the\n   client has not
        offered.  If there is no shared profile, the server\n   SHOULD NOT return
        the use_srtp extension at which point the\n   connection falls back to the
        negotiated DTLS cipher suite.  If that\n   is not acceptable, the server SHOULD
        return an appropriate DTLS\n   alert.\n"
      title: 4.1.1.  use_srtp Extension Definition
    - contents:
      - "4.1.2.  SRTP Protection Profiles\n   A DTLS-SRTP SRTP Protection Profile
        defines the parameters and\n   options that are in effect for the SRTP processing.
        \ This document\n   defines the following SRTP protection profiles.\n      SRTPProtectionProfile
        SRTP_AES128_CM_HMAC_SHA1_80 = {0x00, 0x01};\n      SRTPProtectionProfile SRTP_AES128_CM_HMAC_SHA1_32
        = {0x00, 0x02};\n      SRTPProtectionProfile SRTP_NULL_HMAC_SHA1_80      =
        {0x00, 0x05};\n      SRTPProtectionProfile SRTP_NULL_HMAC_SHA1_32      = {0x00,
        0x06};\n   The following list indicates the SRTP transform parameters for
        each\n   protection profile.  The parameters cipher_key_length,\n   cipher_salt_length,
        auth_key_length, and auth_tag_length express the\n   number of bits in the
        values to which they refer.  The\n   maximum_lifetime parameter indicates
        the maximum number of packets\n   that can be protected with each single set
        of keys when the parameter\n   profile is in use.  All of these parameters
        apply to both RTP and\n   RTCP, unless the RTCP parameters are separately
        specified.\n   All of the crypto algorithms in these profiles are from [RFC3711].\n
        \  SRTP_AES128_CM_HMAC_SHA1_80\n         cipher: AES_128_CM\n         cipher_key_length:
        128\n         cipher_salt_length: 112\n         maximum_lifetime: 2^31\n         auth_function:
        HMAC-SHA1\n         auth_key_length: 160\n         auth_tag_length: 80\n   SRTP_AES128_CM_HMAC_SHA1_32\n
        \        cipher: AES_128_CM\n         cipher_key_length: 128\n         cipher_salt_length:
        112\n         maximum_lifetime: 2^31\n         auth_function: HMAC-SHA1\n
        \        auth_key_length: 160\n         auth_tag_length: 32\n         RTCP
        auth_tag_length: 80\n   SRTP_NULL_HMAC_SHA1_80\n         cipher: NULL\n         cipher_key_length:
        0\n         cipher_salt_length: 0\n         maximum_lifetime: 2^31\n         auth_function:
        HMAC-SHA1\n         auth_key_length: 160\n         auth_tag_length: 80\n   SRTP_NULL_HMAC_SHA1_32\n
        \        cipher: NULL\n         cipher_key_length: 0\n         cipher_salt_length:
        0\n         maximum_lifetime: 2^31\n         auth_function: HMAC-SHA1\n         auth_key_length:
        160\n         auth_tag_length: 32\n         RTCP auth_tag_length: 80\n   With
        all of these SRTP Parameter profiles, the following SRTP options\n   are in
        effect:\n   o  The TLS PseudoRandom Function (PRF) is used to generate keys
        to\n      feed into the SRTP Key Derivation Function (KDF).  When DTLS 1.2\n
        \     [DTLS1.2] is in use, the PRF is the one associated with the cipher\n
        \     suite.  Note that this specification is compatible with DTLS 1.0\n      or
        DTLS 1.2\n   o  The Key Derivation Rate (KDR) is equal to zero.  Thus, keys
        are\n      not re-derived based on the SRTP sequence number.\n   o  The key
        derivation procedures from Section 4.3 with the AES-CM PRF\n      from RFC
        3711 are used.\n   o  For all other parameters (in particular, SRTP replay
        window size\n      and FEC order), the default values are used.\n   If values
        other than the defaults for these parameters are required,\n   they can be
        enabled by writing a separate specification specifying\n   SDP syntax to signal
        them.\n   Applications using DTLS-SRTP SHOULD coordinate the SRTP Protection\n
        \  Profiles between the DTLS-SRTP session that protects an RTP flow and\n
        \  the DTLS-SRTP session that protects the associated RTCP flow (in\n   those
        cases in which the RTP and RTCP are not multiplexed over a\n   common port).
        \ In particular, identical ciphers SHOULD be used.\n   New SRTPProtectionProfile
        values must be defined according to the\n   \"Specification Required\" policy
        as defined by RFC 5226 [RFC5226].\n   See Section 9 for IANA Considerations.\n"
      title: 4.1.2.  SRTP Protection Profiles
    - contents:
      - "4.1.3.  srtp_mki value\n   The srtp_mki value MAY be used to indicate the
        capability and desire\n   to use the SRTP Master Key Identifier (MKI) field
        in the SRTP and\n   SRTCP packets.  The MKI field indicates to an SRTP receiver
        which key\n   was used to protect the packet that contains that field.  The\n
        \  srtp_mki field contains the value of the SRTP MKI which is associated\n
        \  with the SRTP master keys derived from this handshake.  Each SRTP\n   session
        MUST have exactly one master key that is used to protect\n   packets at any
        given time.  The client MUST choose the MKI value so\n   that it is distinct
        from the last MKI value that was used, and it\n   SHOULD make these values
        unique for the duration of the TLS session.\n   Upon receipt of a \"use_srtp\"
        extension containing a \"srtp_mki\" field,\n   the server MUST either (assuming
        it accepts the extension at all):\n   1.  include a matching \"srtp_mki\"
        value in its \"use_srtp\" extension\n       to indicate that it will make
        use of the MKI, or\n   2.  return an empty \"srtp_mki\" value to indicate
        that it cannot make\n       use of the MKI.\n   If the client detects a nonzero-length
        MKI in the server's response\n   that is different than the one the client
        offered, then the client\n   MUST abort the handshake and SHOULD send an invalid_parameter
        alert.\n   If the client and server agree on an MKI, all SRTP packets protected\n
        \  under the new security parameters MUST contain that MKI.\n   Note that
        any given DTLS-SRTP session only has a single active MKI\n   (if any).  Thus,
        at any given time, a set of endpoints will generally\n   only be using one
        MKI (the major exception is during rehandshakes).\n"
      title: 4.1.3.  srtp_mki value
    title: 4.1.  The use_srtp Extension
  - contents:
    - "4.2.  Key Derivation\n   When SRTP mode is in effect, different keys are used
      for ordinary\n   DTLS record protection and SRTP packet protection.  These keys
      are\n   generated using a TLS exporter [RFC5705] to generate\n   2 * (SRTPSecurityParams.master_key_len
      +\n        SRTPSecurityParams.master_salt_len) bytes of data\n   which are assigned
      as shown below.  The per-association context value\n   is empty.\n   client_write_SRTP_master_key[SRTPSecurityParams.master_key_len];\n
      \  server_write_SRTP_master_key[SRTPSecurityParams.master_key_len];\n   client_write_SRTP_master_salt[SRTPSecurityParams.master_salt_len];\n
      \  server_write_SRTP_master_salt[SRTPSecurityParams.master_salt_len];\n   The
      exporter label for this usage is \"EXTRACTOR-dtls_srtp\".  (The\n   \"EXTRACTOR\"
      prefix is for historical compatibility.)\n   The four keying material values
      (the master key and master salt for\n   each direction) are provided as inputs
      to the SRTP key derivation\n   mechanism, as shown in Figure 1 and detailed
      below.  By default, the\n   mechanism defined in Section 4.3 of [RFC3711] is
      used, unless another\n   key derivation mechanism is specified as part of an
      SRTP Protection\n   Profile.\n   The client_write_SRTP_master_key and client_write_SRTP_master_salt\n
      \  are provided to one invocation of the SRTP key derivation function,\n   to
      generate the SRTP keys used to encrypt and authenticate packets\n   sent by
      the client.  The server MUST only use these keys to decrypt\n   and to check
      the authenticity of inbound packets.\n   The server_write_SRTP_master_key and
      server_write_SRTP_master_salt\n   are provided to one invocation of the SRTP
      key derivation function,\n   to generate the SRTP keys used to encrypt and authenticate
      packets\n   sent by the server.  The client MUST only use these keys to decrypt\n
      \  and to check the authenticity of inbound packets.\n   TLS master\n     secret
      \  label\n      |         |\n      v         v\n   +---------------+\n   | TLS
      extractor |\n   +---------------+\n          |                                         +------+
      \  SRTP\n          +-> client_write_SRTP_master_key ----+--->| SRTP |-> client\n
      \         |                                    | +->| KDF  |   write\n          |
      \                                   | |  +------+   keys\n          |                                    |
      |\n          +-> server_write_SRTP_master_key --  | |  +------+   SRTCP\n          |
      \                                 \\ \\--->|SRTCP |-> client\n          |                                   \\
      \ +->| KDF  |   write\n          |                                    | |  +------+
      \  keys\n          +-> client_write_SRTP_master_salt ---|-+\n          |                                    |\n
      \         |                                    |    +------+   SRTP\n          |
      \                                   +--->| SRTP |-> server\n          +-> server_write_SRTP_master_salt
      -+-|--->| KDF  |   write\n                                             | |    +------+
      \  keys\n                                             | |\n                                             |
      |    +------+   SRTCP\n                                             | +--->|SRTCP
      |-> server\n                                             +----->| KDF  |   write\n
      \                                                   +------+   keys\n                Figure
      1: The derivation of the SRTP keys.\n   When both RTCP and RTP use the same
      source and destination ports,\n   then both the SRTP and SRTCP keys are needed.
      \ Otherwise, there are\n   two DTLS-SRTP sessions, one of which protects the
      RTP packets and one\n   of which protects the RTCP packets; each DTLS-SRTP session
      protects\n   the part of an SRTP session that passes over a single source/\n
      \  destination transport address pair, as shown in Figure 2, independent\n   of
      which SSRCs are used on that pair.  When a DTLS-SRTP session is\n   protecting
      RTP, the SRTCP keys derived from the DTLS handshake are\n   not needed and are
      discarded.  When a DTLS-SRTP session is protecting\n   RTCP, the SRTP keys derived
      from the DTLS handshake are not needed\n   and are discarded.\n      Client
      \           Server\n     (Sender)         (Receiver)\n   (1)   <----- DTLS ------>
      \   src/dst = a/b and b/a\n         ------ SRTP ------>    src/dst = a/b, uses
      client write keys\n   (2)   <----- DTLS ------>    src/dst = c/d and d/c\n         ------
      SRTCP ----->    src/dst = c/d, uses client write keys\n         <----- SRTCP
      ------    src/dst = d/c, uses server write keys\n     Figure 2: A DTLS-SRTP
      session protecting RTP (1) and another one\n    protecting RTCP (2), showing
      the transport addresses and keys used.\n"
    title: 4.2.  Key Derivation
  - contents:
    - "4.3.  Key Scope\n   Because of the possibility of packet reordering, DTLS-SRTP\n
      \  implementations SHOULD store multiple SRTP keys sets during a rekey\n   in
      order to avoid the need for receivers to drop packets for which\n   they lack
      a key.\n"
    title: 4.3.  Key Scope
  - contents:
    - "4.4.  Key Usage Limitations\n   The maximum_lifetime parameter in the SRTP
      protection profile\n   indicates the maximum number of packets that can be protected
      with\n   each single encryption and authentication key.  (Note that, since RTP\n
      \  and RTCP are protected with independent keys, those protocols are\n   counted
      separately for the purposes of determining when a key has\n   reached the end
      of its lifetime.)  Each profile defines its own\n   limit.  When this limit
      is reached, a new DTLS session SHOULD be used\n   to establish replacement keys,
      and SRTP implementations MUST NOT use\n   the existing keys for the processing
      of either outbound or inbound\n   traffic.\n"
    title: 4.4.  Key Usage Limitations
  title: 4.  DTLS Extensions for SRTP Key Establishment
- contents:
  - '5.  Use of RTP and RTCP over a DTLS-SRTP Channel

    '
  - contents:
    - "5.1.  Data Protection\n   Once the DTLS handshake has completed, the peers
      can send RTP or RTCP\n   over the newly created channel.  We describe the transmission
      process\n   first followed by the reception process.\n   Within each RTP session,
      SRTP processing MUST NOT take place before\n   the DTLS handshake completes.\n"
    - contents:
      - "5.1.1.  Transmission\n   DTLS and TLS define a number of record content types.
        \ In ordinary\n   TLS/DTLS, all data is protected using the same record encoding
        and\n   mechanisms.  When the mechanism described in this document is in\n
        \  effect, this is modified so that data written by upper-level protocol\n
        \  clients of DTLS is assumed to be RTP/RTP and is encrypted using SRTP\n
        \  rather than the standard TLS record encoding.\n   When a user of DTLS wishes
        to send an RTP packet in SRTP mode, it\n   delivers it to the DTLS implementation
        as an ordinary application\n   data write (e.g., SSL_write()).  The DTLS implementation
        then invokes\n   the processing described in RFC 3711, Sections 3 and 4.  The\n
        \  resulting SRTP packet is then sent directly on the wire as a single\n   datagram
        with no DTLS framing.  This provides an encapsulation of the\n   data that
        conforms to and interoperates with SRTP.  Note that the RTP\n   sequence number
        rather than the DTLS sequence number is used for\n   these packets.\n"
      title: 5.1.1.  Transmission
    - contents:
      - "5.1.2.  Reception\n   When DTLS-SRTP is used to protect an RTP session, the
        RTP receiver\n   needs to demultiplex packets that are arriving on the RTP
        port.\n   Arriving packets may be of types RTP, DTLS, or STUN [RFC5389].  If\n
        \  these are the only types of packets present, the type of a packet can\n
        \  be determined by looking at its first byte.\n   The process for demultiplexing
        a packet is as follows.  The receiver\n   looks at the first byte of the packet.
        \ If the value of this byte is\n   0 or 1, then the packet is STUN.  If the
        value is in between 128 and\n   191 (inclusive), then the packet is RTP (or
        RTCP, if both RTCP and\n   RTP are being multiplexed over the same destination
        port).  If the\n   value is between 20 and 63 (inclusive), the packet is DTLS.
        \ This\n   process is summarized in Figure 3.\n                   +----------------+\n
        \                  | 127 < B < 192 -+--> forward to RTP\n                   |
        \               |\n       packet -->  |  19 < B < 64  -+--> forward to DTLS\n
        \                  |                |\n                   |       B < 2   -+-->
        forward to STUN\n                   +----------------+\n    Figure 3: The
        DTLS-SRTP receiver's packet demultiplexing algorithm.\n         Here the field
        B denotes the leading byte of the packet.\n   If other packet types are to
        be multiplexed as well, implementors\n   and/or designers SHOULD ensure that
        they can be demultiplexed from\n   these three packet types.\n   In some cases,
        there will be multiple DTLS-SRTP associations for a\n   given SRTP endpoint.
        \ For instance, if Alice makes a call that is SIP\n   forked to both Bob and
        Charlie, she will use the same local host/port\n   pair for both of them,
        as shown in Figure 4, where XXX and YYY\n   represent different DTLS-SRTP
        associations.  (The SSRCs shown are the\n   ones for data flowing to Alice.)\n
        \                                         Bob (192.0.2.1:6666)\n                                         /\n
        \                                       /\n                                       /
        SSRC=1\n                                      /  DTLS-SRTP=XXX\n                                     /\n
        \                                   v\n               Alice (192.0.2.0:5555)\n
        \                                   ^\n                                     \\\n
        \                                     \\  SSRC=2\n                                       \\
        DTLS-SRTP=YYY\n                                        \\\n                                         \\\n
        \                                         Charlie (192.0.2.2:6666)\n                 Figure
        4: RTP sessions with SIP forking.\n   Because DTLS operates on the host/port
        quartet, the DTLS association\n   will still complete correctly, with the
        foreign host/port pair being\n   used, to distinguish the associations.  However,
        in RTP the source\n   host/port is not used and sessions are identified by
        the destination\n   host/port and the SSRC.  Thus, some mechanism is needed
        to determine\n   which SSRCs correspond to which DTLS associations.  The following\n
        \  method SHOULD be used.\n   For each local host/port pair, the DTLS-SRTP
        implementation maintains\n   a table listing all the SSRCs it knows about
        and the DTLS-SRTP\n   associations they correspond to.  Initially, this table
        is empty.\n   When an SRTP packet is received for a given RTP endpoint (destination\n
        \  IP/port pair), the following procedure is used:\n   1.  If the SSRC is
        already known for that endpoint, then the\n       corresponding DTLS-SRTP
        association and its keying material is\n       used to decrypt and verify
        the packet.\n   2.  If the SSRC is not known, then the receiver tries to decrypt
        it\n       with the keying material corresponding to each DTLS-SRTP\n       association
        for that endpoint.\n   3.  If the decryption and verification succeeds (the
        authentication\n       tag verifies), then an entry is placed in the table
        mapping the\n       SSRC to that association.\n   4.  If the decryption and
        verification fails, then the packet is\n       silently discarded.\n   5.
        \ When a DTLS-SRTP association is closed (for instance, because the\n       fork
        is abandoned), its entries MUST be removed from the mapping\n       table.\n
        \  The average cost of this algorithm for a single SSRC is the\n   decryption
        and verification time of a single packet times the number\n   of valid DTLS-SRTP
        associations corresponding to a single receiving\n   port on the host.  In
        practice, this means the number of forks; so in\n   the case shown in Figure
        4, that would be two.  This cost is only\n   incurred once for any given SSRC,
        since afterwards that SSRC is\n   placed in the map table and looked up immediately.
        \ As with normal\n   RTP, this algorithm allows new SSRCs to be introduced
        by the source\n   at any time.  They will automatically be mapped to the correct
        DTLS\n   association.\n   Note that this algorithm explicitly allows multiple
        SSRCs to be sent\n   from the same address/port pair.  One way in which this
        can happen is\n   an RTP translator.  This algorithm will automatically assign
        the\n   SSRCs to the correct associations.  Note that because the SRTP\n   packets
        are cryptographically protected, such a translator must\n   either share keying
        material with one endpoint or refrain from\n   modifying the packets in a
        way which would cause the integrity check\n   to fail.  This is a general
        property of SRTP and is not specific to\n   DTLS-SRTP.\n   There are two error
        cases that should be considered.  First, if an\n   SSRC collision occurs,
        then only the packets from the first source\n   will be processed.  When the
        packets from the second source arrive,\n   the DTLS association with the first
        source will be used for\n   decryption and verification, which will fail,
        and the packet will be\n   discarded.  This is consistent with [RFC3550],
        which permits the\n   receiver to keep the packets from one source and discard
        those from\n   the other.  Of course the RFC 3550 SSRC collision detection
        and\n   handling procedures MUST also be followed.\n   Second, there may be
        cases where a malfunctioning source is sending\n   corrupt packets that cannot
        be decrypted and verified.  In this case,\n   the SSRC will never be entered
        into the mapping table because the\n   decryption and verification always
        fails.  Receivers MAY keep records\n   of unmapped SSRCs that consistently
        fail decryption and verification\n   and abandon attempts to process them
        once they reach some limit.\n   That limit MUST be large enough to account
        for the effects of\n   transmission errors.  Entries MUST be pruned from this
        table when the\n   relevant SRTP endpoint is deleted (e.g., the call ends)
        and SHOULD\n   time out faster than that (we do not offer a hard recommendation
        but\n   10 to 30 seconds seems appropriate) in order to allow for the\n   possibility
        that the peer implementation has been corrected.\n"
      title: 5.1.2.  Reception
    title: 5.1.  Data Protection
  - contents:
    - "5.2.  Rehandshake and Rekey\n   Rekeying in DTLS is accomplished by performing
      a new handshake over\n   the existing DTLS channel.  That is, the handshake
      messages are\n   protected by the existing DTLS cipher suite.  This handshake
      can be\n   performed in parallel with data transport, so no interruption of
      the\n   data flow is required.  Once the handshake is finished, the newly\n
      \  derived set of keys is used to protect all outbound packets, both\n   DTLS
      and SRTP.\n   Because of packet reordering, packets protected by the previous
      set\n   of keys can appear on the wire after the handshake has completed.  To\n
      \  compensate for this fact, receivers SHOULD maintain both sets of keys\n   for
      some time in order to be able to decrypt and verify older\n   packets.  The
      keys should be maintained for the duration of the\n   maximum segment lifetime
      (MSL).\n   If an MKI is used, then the receiver should use the corresponding
      set\n   of keys to process an incoming packet.  If no matching MKI is\n   present,
      the packet MUST be rejected.  Otherwise, when a packet\n   arrives after the
      handshake completed, a receiver SHOULD use the\n   newly derived set of keys
      to process that packet unless there is an\n   MKI.  (If the packet was protected
      with the older set of keys, this\n   fact will become apparent to the receiver
      as an authentication\n   failure will occur.)  If the authentication check on
      the packet fails\n   and no MKI is being used, then the receiver MAY process
      the packet\n   with the older set of keys.  If that authentication check indicates\n
      \  that the packet is valid, the packet should be accepted; otherwise,\n   the
      packet MUST be discarded and rejected.\n   Receivers MAY use the SRTP packet
      sequence number to aid in the\n   selection of keys.  After a packet has been
      received and\n   authenticated with the new key set, any packets with sequence
      numbers\n   that are greater will also have been protected with the new key
      set.\n"
    title: 5.2.  Rehandshake and Rekey
  title: 5.  Use of RTP and RTCP over a DTLS-SRTP Channel
- contents:
  - "6.  Multi-Party RTP Sessions\n   Since DTLS is a point-to-point protocol, DTLS-SRTP
    is intended only\n   to protect unicast RTP sessions.  This does not preclude
    its use with\n   RTP mixers.  For example, a conference bridge may use DTLS-SRTP
    to\n   secure the communication to and from each of the participants in a\n   conference.
    \ However, because each flow between an endpoint and a\n   mixer has its own key,
    the mixer has to decrypt and then reencrypt\n   the traffic for each recipient.\n
    \  A future specification may describe methods for sharing a single key\n   between
    multiple DTLS-SRTP associations thus allowing conferencing\n   systems to avoid
    the decrypt/reencrypt stage.  However, any system in\n   which the media is modified
    (e.g., for level balancing or\n   transcoding) will generally need to be performed
    on the plaintext and\n   will certainly break the authentication tag, and therefore
    will\n   require a decrypt/reencrypt stage.\n"
  title: 6.  Multi-Party RTP Sessions
- contents:
  - "7.  Security Considerations\n   The use of multiple data protection framings
    negotiated in the same\n   handshake creates some complexities, which are discussed
    here.\n"
  - contents:
    - "7.1.  Security of Negotiation\n   One concern here is that attackers might
      be able to implement a bid-\n   down attack forcing the peers to use ordinary
      DTLS rather than SRTP.\n   However, because the negotiation of this extension
      is performed in\n   the DTLS handshake, it is protected by the Finished messages.\n
      \  Therefore, any bid-down attack is automatically detected, which\n   reduces
      this to a denial-of-service attack -- which can be mounted by\n   any attacker
      who can control the channel.\n"
    title: 7.1.  Security of Negotiation
  - contents:
    - "7.2.  Framing Confusion\n   Because two different framing formats are used,
      there is concern that\n   an attacker could convince the receiver to treat an
      SRTP-framed RTP\n   packet as a DTLS record (e.g., a handshake message) or vice
      versa.\n   This attack is prevented by using different keys for Message\n   Authentication
      Code (MAC) verification for each type of data.\n   Therefore, this type of attack
      reduces to being able to forge a\n   packet with a valid MAC, which violates
      a basic security invariant of\n   both DTLS and SRTP.\n   As an additional defense
      against injection into the DTLS handshake\n   channel, the DTLS record type
      is included in the MAC.  Therefore, an\n   SRTP record would be treated as an
      unknown type and ignored.  (See\n   Section 6 of [RFC5246].)\n"
    title: 7.2.  Framing Confusion
  - contents:
    - "7.3.  Sequence Number Interactions\n   As described in Section 5.1.1, the SRTP
      and DTLS sequence number\n   spaces are distinct.  This means that it is not
      possible to\n   unambiguously order a given DTLS control record with respect
      to an\n   SRTP packet.  In general, this is relevant in two situations: alerts\n
      \  and rehandshake.\n"
    - contents:
      - "7.3.1.  Alerts\n   Because DTLS handshake and change_cipher_spec messages
        share the same\n   sequence number space as alerts, they can be ordered correctly.\n
        \  Because DTLS alerts are inherently unreliable and SHOULD NOT be\n   generated
        as a response to data packets, reliable sequencing between\n   SRTP packets
        and DTLS alerts is not an important feature.  However,\n   implementations
        that wish to use DTLS alerts to signal problems with\n   the SRTP encoding
        SHOULD simply act on alerts as soon as they are\n   received and assume that
        they refer to the temporally contiguous\n   stream.  Such implementations
        MUST check for alert retransmission and\n   discard retransmitted alerts to
        avoid overreacting to replay attacks.\n"
      title: 7.3.1.  Alerts
    - contents:
      - "7.3.2.  Renegotiation\n   Because the rehandshake transition algorithm specified
        in Section 5.2\n   requires trying multiple sets of keys if no MKI is used,
        it slightly\n   weakens the authentication.  For instance, if an n-bit MAC
        is used\n   and k different sets of keys are present, then the MAC is weakened
        by\n   log_2(k) bits to n - log_2(k).  In practice, since the number of keys\n
        \  used will be very small and the MACs in use are typically strong (the\n
        \  default for SRTP is 80 bits), the decrease in security involved here\n
        \  is minimal.\n   Another concern here is that this algorithm slightly increases
        the\n   work factor on the receiver because it needs to attempt multiple\n
        \  validations.  However, again, the number of potential keys will be\n   very
        small (and the attacker cannot force it to be larger) and this\n   technique
        is already used for rollover counter management, so the\n   authors do not
        consider this to be a serious flaw.\n"
      title: 7.3.2.  Renegotiation
    title: 7.3.  Sequence Number Interactions
  - contents:
    - "7.4.  Decryption Cost\n   An attacker can impose computational costs on the
      receiver by sending\n   superficially valid SRTP packets that do not decrypt
      correctly.  In\n   general, encryption algorithms are so fast that this cost
      is\n   extremely small compared to the bandwidth consumed.  The SSRC-DTLS\n
      \  mapping algorithm described in Section 5.1.2 gives the attacker a\n   slight
      advantage here because he can force the receiver to do more\n   then one decryption
      per packet.  However, this advantage is modest\n   because the number of decryptions
      that the receiver does is limited\n   by the number of associations he has corresponding
      to a given\n   destination host/port, which is typically quite small.  For\n
      \  comparison, a single 1024-bit RSA private key operation (the typical\n   minimum
      cost to establish a DTLS-SRTP association) is hundreds of\n   times as expensive
      as decrypting an SRTP packet.\n   Implementations can detect this form of attack
      by keeping track of\n   the number of SRTP packets that are observed with unknown
      SSRCs and\n   that fail the authentication tag check.  If under such attack,\n
      \  implementations SHOULD prioritize decryption and verification of\n   packets
      that either have known SSRCs or come from source addresses\n   that match those
      of peers with which it has DTLS-SRTP associations.\n"
    title: 7.4.  Decryption Cost
  title: 7.  Security Considerations
- contents:
  - "8.  Session Description for RTP/SAVP over DTLS\n   This specification defines
    new tokens to describe the protocol used\n   in SDP media descriptions (\"m=\"
    lines and their associated\n   parameters).  The new values defined for the proto
    field are:\n   o  When a RTP/SAVP or RTP/SAVPF [RFC5124] stream is transported
    over\n      DTLS with the Datagram Congestion Control Protocol (DCCP), then\n
    \     the token SHALL be DCCP/TLS/RTP/SAVP or DCCP/TLS/RTP/SAVPF\n      respectively.\n
    \  o  When a RTP/SAVP or RTP/SAVPF stream is transported over DTLS with\n      UDP,
    the token SHALL be UDP/TLS/RTP/SAVP or UDP/TLS/RTP/SAVPF\n      respectively.\n
    \  The \"fmt\" parameter SHALL be as defined for RTP/SAVP.\n   See [RFC5763] for
    how to use offer/answer with DTLS-SRTP.\n   This document does not specify how
    to protect RTP data transported\n   over TCP.  Potential approaches include carrying
    the RTP over TLS\n   over TCP (see [SRTP-NOT-MAND]) or using a mechanism similar
    to that\n   in this document over TCP, either via TLS or DTLS, with DTLS being\n
    \  used for consistency between reliable and unreliable transports.  In\n   the
    latter case, it would be necessary to profile DTLS so that\n   fragmentation and
    retransmissions no longer occurred.  In either\n   case, a new document would
    be required.\n"
  title: 8.  Session Description for RTP/SAVP over DTLS
- contents:
  - "9.  IANA Considerations\n   This document adds a new extension for DTLS, in accordance
    with\n   [RFC5246]:\n        enum { use_srtp (14) } ExtensionType;\n   This extension
    MUST only be used with DTLS, and not with TLS\n   [RFC4572], which specifies that
    TLS can be used over TCP but does not\n   address TCP for RTP/SAVP.\n   Section
    4.1.2 requires that all SRTPProtectionProfile values be\n   defined by RFC 5226
    \"Specification Required\".  IANA has created a\n   DTLS SRTPProtectionProfile
    registry initially populated with values\n   from Section 4.1.2 of this document.
    \ Future values MUST be allocated\n   via the \"Specification Required\" profile
    of [RFC5226].\n   This specification updates the \"Session Description Protocol
    (SDP)\n   Parameters\" registry as defined in Section 8.2.2 of [RFC4566].\n   Specifically,
    it adds the following values to the table for the\n   \"proto\" field.\n           Type
    \           SDP Name                     Reference\n           ----            ------------------
    \          ---------\n           proto           UDP/TLS/RTP/SAVP             [RFC5764]\n
    \          proto           DCCP/TLS/RTP/SAVP            [RFC5764]\n           proto
    \          UDP/TLS/RTP/SAVPF            [RFC5764]\n           proto           DCCP/TLS/RTP/SAVPF
    \          [RFC5764]\n   IANA has registered the \"EXTRACTOR-dtls_srtp\" value
    in the TLS\n   Extractor Label Registry to correspond to this specification.\n"
  title: 9.  IANA Considerations
- contents:
  - "10.  Acknowledgments\n   Special thanks to Flemming Andreasen, Francois Audet,
    Pasi Eronen,\n   Roni Even, Jason Fischl, Cullen Jennings, Colin Perkins, Dan
    Wing,\n   and Ben Campbell for input, discussions, and guidance.  Pasi Eronen\n
    \  provided Figure 1.\n"
  title: 10.  Acknowledgments
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [RFC2119]        Bradner, S., \"Key words for
      use in RFCs to Indicate\n                    Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC3711]        Baugher, M., McGrew, D., Naslund, M.,
      Carrara, E.,\n                    and K. Norrman, \"The Secure Real-time Transport\n
      \                   Protocol (SRTP)\", RFC 3711, March 2004.\n   [RFC4347]        Rescorla,
      E. and N. Modadugu, \"Datagram Transport\n                    Layer Security\",
      RFC 4347, April 2006.\n   [RFC4961]        Wing, D., \"Symmetric RTP / RTP Control
      Protocol\n                    (RTCP)\", BCP 131, RFC 4961, July 2007.\n   [RFC5246]
      \       Dierks, T. and E. Rescorla, \"The Transport Layer\n                    Security
      (TLS) Protocol Version 1.2\", RFC 5246,\n                    August 2008.\n
      \  [RFC5705]        Rescorla, E., \"Keying Material Exporters for\n                    Transport
      Layer Security (TLS)\", RFC 5705,\n                    March 2010.\n   [RFC5761]
      \       Perkins, C. and M. Westerlund, \"Multiplexing RTP\n                    Data
      and Control Packets on a Single Port\",\n                    RFC 5761, April
      2010.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [DTLS1.2]        Rescorla, E. and N. Modadugu,
      \"Datagram Transport\n                    Layer Security version 1.2\", Work
      in Progress,\n                    October 2009.\n   [RFC3550]        Schulzrinne,
      H., Casner, S., Frederick, R., and V.\n                    Jacobson, \"RTP:
      A Transport Protocol for Real-Time\n                    Applications\", STD
      64, RFC 3550, July 2003.\n   [RFC4566]        Handley, M., Jacobson, V., and
      C. Perkins, \"SDP:\n                    Session Description Protocol\", RFC
      4566, July 2006.\n   [RFC4572]        Lennox, J., \"Connection-Oriented Media
      Transport\n                    over the Transport Layer Security (TLS) Protocol
      in\n                    the Session Description Protocol (SDP)\", RFC 4572,\n
      \                   July 2006.\n   [RFC5124]        Ott, J. and E. Carrara,
      \"Extended Secure RTP Profile\n                    for Real-time Transport Control
      Protocol (RTCP)-\n                    Based Feedback (RTP/SAVPF)\", RFC 5124,\n
      \                   February 2008.\n   [RFC5226]        Narten, T. and H. Alvestrand,
      \"Guidelines for\n                    Writing an IANA Considerations Section
      in RFCs\",\n                    BCP 26, RFC 5226, May 2008.\n   [RFC5389]        Rosenberg,
      J., Mahy, R., Matthews, P., and D. Wing,\n                    \"Session Traversal
      Utilities for NAT (STUN)\",\n                    RFC 5389, October 2008.\n   [RFC5763]
      \       Fischl, J., Tschofenig, H., and E. Rescorla,\n                    \"Framework
      for Establishing a Secure Real-time\n                    Transport Protocol
      (SRTP) Security Context Using\n                    Datagram Transport Layer
      Security (DTLS)\", RFC 5763,\n                    May 2010.\n   [SRTP-NOT-MAND]
      \ Perkins, C. and M. Westerlund, \"Why RTP Does Not\n                    Mandate
      a Single Security Mechanism\", Work in\n                    Progress, January
      2010.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Appendix A.  Overview of DTLS\n   This section provides a brief overview of Datagram
    TLS (DTLS) for\n   those who are not familiar with it.  DTLS is a channel security\n
    \  protocol based on the well-known Transport Layer Security (TLS)\n   [RFC5246]
    protocol.  Where TLS depends on a reliable transport\n   channel (typically TCP),
    DTLS has been adapted to support unreliable\n   transports such as UDP.  Otherwise,
    DTLS is nearly identical to TLS\n   and generally supports the same cryptographic
    mechanisms.\n   Each DTLS association begins with a handshake exchange (shown
    below)\n   during which the peers authenticate each other and negotiate\n   algorithms,
    modes, and other parameters and establish shared keying\n   material, as shown
    below.  In order to support unreliable transport,\n   each side maintains retransmission
    timers to provide reliable\n   delivery of these messages.  Once the handshake
    is completed,\n   encrypted data may be sent.\n         Client                                               Server\n
    \        ClientHello                  -------->\n                                                         ServerHello\n
    \                                                       Certificate*\n                                                  ServerKeyExchange*\n
    \                                                CertificateRequest*\n                                      <--------
    \     ServerHelloDone\n         Certificate*\n         ClientKeyExchange\n         CertificateVerify*\n
    \        [ChangeCipherSpec]\n         Finished                     -------->\n
    \                                                 [ChangeCipherSpec]\n                                      <--------
    \            Finished\n         Application Data             <------->     Application
    Data\n               '*' indicates messages that are not always sent.\n        Figure
    5: Basic DTLS Handshake Exchange (after [RFC4347]).\n   Application data is protected
    by being sent as a series of DTLS\n   \"records\".  These records are independent
    and can be processed\n   correctly even in the face of loss or reordering.  In
    DTLS-SRTP, this\n   record protocol is replaced with SRTP [RFC3711]\n"
  title: Appendix A.  Overview of DTLS
- contents:
  - "Appendix B.  Performance of Multiple DTLS Handshakes\n   Standard practice for
    security protocols such as TLS, DTLS, and SSH,\n   which do inline key management,
    is to create a separate security\n   association for each underlying network channel
    (TCP connection, UDP\n   host/port quartet, etc.).  This has dual advantages of
    simplicity and\n   independence of the security contexts for each channel.\n   Three
    concerns have been raised about the overhead of this strategy\n   in the context
    of RTP security.  The first concern is the additional\n   performance overhead
    of doing a separate public key operation for\n   each channel.  The conventional
    procedure here (used in TLS and DTLS)\n   is to establish a master context that
    can then be used to derive\n   fresh traffic keys for new associations.  In TLS/DTLS,
    this is called\n   \"session resumption\" and can be transparently negotiated
    between the\n   peers.\n   The second concern is network bandwidth overhead for
    the\n   establishment of subsequent connections and for rehandshake (for\n   rekeying)
    for existing connections.  In particular, there is a\n   concern that the channels
    will have very narrow capacity requirements\n   allocated entirely to media that
    will be overflowed by the\n   rehandshake.  Measurements of the size of the rehandshake
    (with\n   resumption) in TLS indicate that it is about 300-400 bytes if a full\n
    \  selection of cipher suites is offered.  (The size of a full handshake\n   is
    approximately 1-2 kilobytes larger because of the certificate and\n   keying material
    exchange.)\n   The third concern is the additional round-trips associated with\n
    \  establishing the second, third, ... channels.  In TLS/DTLS, these can\n   all
    be done in parallel, but in order to take advantage of session\n   resumption
    they should be done after the first channel is\n   established.  For two channels,
    this provides a ladder diagram\n   something like this (parenthetical numbers
    are media channel numbers)\n   Alice                                   Bob\n   -------------------------------------------\n
    \                     <-       ClientHello (1)\n   ServerHello (1)    ->\n   Certificate
    (1)\n   ServerHelloDone (1)\n                      <- ClientKeyExchange (1)\n
    \                         ChangeCipherSpec (1)\n                                  Finished
    (1)\n   ChangeCipherSpec (1)->\n   Finished         (1)->\n                                                <---
    Channel 1 ready\n                      <-       ClientHello (2)\n   ServerHello
    (2)    ->\n   ChangeCipherSpec(2)->\n   Finished(2)        ->\n                      <-
    \ ChangeCipherSpec (2)\n                                  Finished (2)\n                                                <---
    Channel 2 ready\n                Figure 6: Parallel DTLS-SRTP negotiations.\n
    \  So, there is an additional 1 RTT (round-trip time) after Channel 1 is\n   ready
    before Channel 2 is ready.  If the peers are potentially\n   willing to forego
    resumption, they can interlace the handshakes, like\n   so:\n   Alice                                   Bob\n
    \  -------------------------------------------\n                      <-       ClientHello
    (1)\n   ServerHello (1)    ->\n   Certificate (1)\n   ServerHelloDone (1)\n                      <-
    ClientKeyExchange (1)\n                          ChangeCipherSpec (1)\n                                  Finished
    (1)\n                      <-       ClientHello (2)\n   ChangeCipherSpec (1)->\n
    \  Finished         (1)->\n                                                <---
    Channel 1 ready\n   ServerHello (2)    ->\n   ChangeCipherSpec(2)->\n   Finished(2)
    \       ->\n                      <-  ChangeCipherSpec (2)\n                                  Finished
    (2)\n                                                <--- Channel 2 ready\n               Figure
    7: Interlaced DTLS-SRTP negotiations.\n   In this case, the channels are ready
    contemporaneously, but if a\n   message in handshake (1) is lost, then handshake
    (2) requires either\n   a full rehandshake or that Alice be clever and queue the
    resumption\n   attempt until the first handshake completes.  Note that just dropping\n
    \  the packet works as well, since Bob will retransmit.\n"
  title: Appendix B.  Performance of Multiple DTLS Handshakes
- contents:
  - "Authors' Addresses\n   David McGrew\n   Cisco Systems\n   510 McCarthy Blvd.\n
    \  Milpitas, CA  95305\n   USA\n   EMail: mcgrew@cisco.com\n   Eric Rescorla\n
    \  RTFM, Inc.\n   2064 Edgewood Drive\n   Palo Alto, CA  94303\n   USA\n   EMail:
    ekr@rtfm.com\n"
  title: Authors' Addresses
