- contents:
  - "                      XML Pipelining with Chunks\n             for the Internet
    Registry Information Service\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes a simple TCP transfer protocol for the\n
    \  Internet Registry Information Service (IRIS).  Data is transferred\n   between
    clients and servers using chunks to achieve pipelining.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Document Terminology ............................................3\n   3.
    Request Block (RQB) .............................................4\n   4. Response
    Blocks .................................................4\n      4.1. Response
    Block (RSB) .......................................5\n      4.2. Connection Response
    Block (CRB) ............................5\n   5. Block Header ....................................................6\n
    \  6. Chunks ..........................................................7\n      6.1.
    No Data Types ..............................................9\n      6.2. Version
    Information Types ..................................9\n      6.3. Size Information
    Types .....................................9\n      6.4. Other Information Types
    ...................................10\n      6.5. SASL Types ................................................11\n
    \     6.6. Authentication Success Information Types ..................12\n      6.7.
    Authentication Failure Information Types ..................12\n      6.8. Application
    Data Types ....................................12\n   7. Idle Sessions ..................................................13\n
    \  8. Closing Sessions Due to an Error ...............................13\n   9.
    Use over TLS ...................................................13\n   10. Update
    to RFC 3981 ............................................13\n   11. IRIS Transport
    Mapping Definitions ............................14\n      11.1. URI Scheme ...............................................14\n
    \     11.2. Application Protocol Label ...............................14\n   12.
    Internationalization Considerations ...........................14\n   13. IANA
    Considerations ...........................................14\n      13.1. XPC
    URI Scheme Registration ..............................14\n      13.2. XPCS URI
    Scheme Registration .............................15\n      13.3. S-NAPTR XPC Registration
    .................................15\n      13.4. S-NAPTR XPCS Registration ................................15\n
    \     13.5. Well-Known TCP Port Registration for XPC .................16\n      13.6.
    Well-Known TCP Port Registration for XPCS ................16\n   14. Security
    Considerations .......................................17\n      14.1. Security
    Mechanisms ......................................17\n      14.2. SASL Compliance
    ..........................................18\n   15. References ....................................................19\n
    \     15.1. Normative References .....................................19\n      15.2.
    Informative References ...................................19\n   Appendix A. Examples
    ..............................................20\n   Appendix B. Contributors
    ..........................................28\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Using S-NAPTR [5], IRIS has the ability to define the use
    of multiple\n   application transports (or transfer protocols) for different types
    of\n   registry services, all at the discretion of the server operator.  The\n
    \  TCP transfer protocol defined in this document is completely modular\n   and
    may be used by any registry types.\n   This transfer protocol defines simple framing
    for sending XML in\n   chunks so that XML fragments may be acted upon (or pipelined)
    before\n   the reception of the entire XML instance.  This document calls this\n
    \  XML pipelining with chunks (XPC) and its use with IRIS as IRIS-XPC.\n   XPC
    is for use with simple request and response interactions between\n   clients and
    servers.  Clients send a series of requests to a server\n   in data blocks.  The
    server will respond to each data block\n   individually with a corresponding data
    block, but through the same\n   connection.  Request and response data blocks
    are sent using the TCP\n   SEND function and received using the TCP RECEIVE function.\n
    \  The lifecycle of an XPC session has the following phases:\n   1.  A client
    establishes a TCP connection with a server.\n   2.  The server sends a connection
    response block (CRB).\n   3.  The client sends a request block (RQB).  In this
    request, the\n       client can set a \"keep open\" flag requesting that the server
    keep\n       the XPC session open following the response to this request.\n   4.
    \ The server responds with a response block (RSB).  In this\n       response,
    the server can indicate to the client whether or not\n       the XPC session will
    be closed.\n   5.  If the XPC session is not to be terminated, then the lifecycle\n
    \      repeats from step 3.\n   6.  The TCP connection is closed.\n"
  title: 1.  Introduction
- contents:
  - "2.  Document Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC
    2119 [8].\n   Octet fields with numeric values are given according to the\n   conventions
    in RFC 1166 [12]: the leftmost bit of the whole field is\n   the most significant
    bit; when a multi-octet quantity is transmitted\n   the most significant octet
    is transmitted first.  Bits signifying\n   flags in an octet are numbered according
    to the conventions of RFC\n   1166 [12]: bit 0 is the most significant bit and
    bit 7 is the least\n   significant bit.  When a diagram describes a group of octets,
    the\n   order of transmission for the octets starts from the left.\n"
  title: 2.  Document Terminology
- contents:
  - "3.  Request Block (RQB)\n   The format for the request block (RQB) is as follows:\n
    \        +--------+-----------+-----------+-------------+\n   field | header |
    authority | authority | chunks 1..n |\n         |        |  length   |           |
    \            |\n         +--------+-----------+-----------+-------------+\n   octets
    \   1         1         0..255      variable\n                               Request
    Block\n   These fields have the following meanings:\n   o  header - as described
    in Section 5.\n   o  authority length - the length of the authority field in this\n
    \     request block.\n   o  authority - a string of octets describing the authority
    against\n      which this request is to be executed.  See [1] for the definition\n
    \     and description of an authority.  The number of octets in this\n      string
    MUST be no more and no less than the number specified by\n      the authority
    length.\n   o  chunks 1..n - the request data broken into chunks (Section 6).\n"
  title: 3.  Request Block (RQB)
- contents:
  - "4.  Response Blocks\n   There are two types of blocks used by a server to respond
    to a\n   client.  The first type is a response block (RSB) defined in Section\n
    \  4.1.  It is used by a server to respond to request blocks (RQBs).\n   The second
    type is a specialized version of a response block called a\n   connection response
    block (CRB) defined in Section 4.2.  It is sent\n   by a server to a client when
    a connection is established to initiate\n   protocol negotiation.  Conceptually,
    a CRB is a type of RQB; they\n   share the same format, but a CRB is constrained
    in conveying only\n   specific information and is only sent at the beginning of
    the session\n   lifecycle.\n"
  - contents:
    - "4.1.  Response Block (RSB)\n   The format for the response block (RSB) is as
      follows:\n         +--------+-------------+\n   field | header | chunks 1..n
      |\n         |        |             |\n         +--------+-------------+\n   octets
      \   1       variable\n                              Response Block\n   These
      fields have the following meanings:\n   o  header - as described in Section
      5.\n   o  chunks 1..n - the response data broken into chunks (Section 6).\n
      \  Servers SHOULD NOT send an RSB to a client until they have received\n   the
      entire RQB.  Servers that do begin sending an RSB before the\n   reception of
      the entire RQB must consider that clients will not be\n   expected to start
      processing the RSB until they have fully sent the\n   RQB, and that the RSB
      may fill the client's TCP buffers.\n"
    title: 4.1.  Response Block (RSB)
  - contents:
    - "4.2.  Connection Response Block (CRB)\n   A connection response block (CRB)
      is a response block sent by a\n   server to a client in response to the client
      initiating a session.  A\n   connection response block has the same format as
      a response block\n   (RSB) (Section 4.1).  The only difference is that it is
      constrained\n   in one of two ways:\n   1.  It contains only one chunk (see
      Section 6) containing version\n       information (see Section 6.2) and the
      keep-open (KO) flag in the\n       block header (see Section 5) has a value
      of 1 (meaning the\n       connection is not closing).  Servers MUST use this
      type of CRB to\n       indicate service availability.\n   2.  It contains only
      one chunk (see Section 6) containing a system\n       error (see 'system-error'
      under Section 6.4) and the keep-open\n       (KO) flag in the block header (see
      Section 5) has a value of 0\n       (meaning the server will close the connection
      immediately after\n       sending the CRB).  Servers MUST use this type of CRB
      when they\n       can accept connections but cannot process requests.\n"
    title: 4.2.  Connection Response Block (CRB)
  title: 4.  Response Blocks
- contents:
  - "5.  Block Header\n   Each data block starts with a one-octet header called the
    block\n   header.  This header has the same format for both request and\n   response
    data blocks, though some of the bits in the header only have\n   meaning in one
    type of data block.  The bits are ordered according to\n   the convention given
    in RFC 1166 [12], where bit 0 is the most\n   significant bit and bit 7 is the
    least significant bit.  Each bit in\n   the block header has the following meaning:\n
    \  o  bits 0 and 1 - version (V field) - If 0 (both bits are zero), the\n      protocol
    is the version defined in this document.  Otherwise, the\n      rest of the bits
    in the header and the block may be interpreted as\n      another version.  If
    a server receives a request for a version it\n      does not support, it SHOULD
    follow the behavior described in\n      Section 8.\n   o  bit 2 - keep open (KO
    flag) - This flag is used to request that a\n      connection stay open by a client
    and to indicate that a connection\n      will stay open by a server, depending
    on the type of block.  In a\n      request block (RQB): a value of 1 indicates
    that a client is\n      requesting that the server not close the TCP session,
    and a value\n      of 0 indicates the client will expect their server to close
    the\n      TCP session immediately after sending the corresponding response.\n
    \     In a response block (RSB) or a connection response block (CRB): a\n      value
    of 1 indicates that the server expects the client to keep\n      the TCP session
    open for the server to receive another request,\n      and a value of 0 indicates
    that the server expects the client to\n      close the TCP session immediately
    following this block.\n   o  bits 3, 4, 5, 6, and 7 - reserved - These MUST be
    0.  If a server\n      receives a request in which any of these bits is set to
    1 and the\n      server does not understand the purpose for the value, the server\n
    \     SHOULD follow the behavior described in Section 8.\n         +---------+-----------+----------+\n
    \  field | Version | Keep Open | reserved |\n         |   (V)   |   (KO)    |
    \         |\n         +---------+-----------+----------+\n   bits    0 and 1       2
    \       3 - 7\n                               Block Header\n"
  title: 5.  Block Header
- contents:
  - "6.  Chunks\n   Request and response blocks break down the request and response
    XML\n   data into chunks.  Request and response blocks MUST always have a\n   minimum
    of 1 chunk.  Each chunk has a one-octet descriptor.  The\n   first bit of the
    descriptor determines if the chunk is the last chunk\n   in the block.\n   The
    bits of the chunk descriptor octet are ordered according to the\n   convention
    given in RFC 1166 [12], where bit 0 is the most\n   significant bit and bit 7
    is the least significant bit.  The bits of\n   the chunk descriptor octet have
    the following meaning:\n   o  bit 0 - last chunk (LC flag) - If 1, this chunk
    is the last chunk\n      in the block.\n   o  bit 1 - data complete (DC flag)
    - If 1, the data in this chunk\n      represents the end of the data for the chunk
    type given.  If this\n      bit is never set to 1 in any chunk descriptor for
    chunks of the\n      same type in a block, clients and servers MUST NOT assume
    the data\n      will continue in another block.  If the block transitions from
    one\n      type of chunk to another without signaling completion of the data,\n
    \     clients and servers MUST assume that the remaining data will not\n      be
    sent in a remaining chunk.\n   o  bits 2, 3, and 4 - reserved - These MUST be
    0.\n   o  bits 5, 6, and 7 - chunk type (CT field) - determines the type of\n
    \     data carried in the chunk.  These are the binary values for the\n      chunk
    types:\n      *  000 - no data or 'nd' type (see Section 6.1)\n      *  001 -
    version information or 'vi' type (see Section 6.2)\n      *  010 - size information
    or 'si' type (see Section 6.3)\n      *  011 - other information or 'oi' type
    (see Section 6.4)\n      *  100 - SASL (Simple Authentication and Security Layer)
    data or\n         'sd' type (see Section 6.5)\n      *  101 - authentication success
    information or 'as' type (see\n         Section 6.6)\n      *  110 - authentication
    failure information or 'af' type (see\n         Section 6.7)\n      *  111 - application
    data or 'ad' type (see Section 6.8)\n         +------------+---------------+----------+------------+\n
    \  field | Last Chunk | Data Complete | reserved | Chunk Type |\n         |    (LC)
    \   |     (DC)      |          |    (CT)    |\n         +------------+---------------+----------+------------+\n
    \  bits         0             1          2 - 4       5 - 7\n                             Chunk
    Descriptor\n   A block MAY have multiple types of chunks, but all chunks of the
    same\n   type MUST be contiguous in a block and MUST be ordered in the block\n
    \  in the order in which their data is to be interpreted.  Contiguous\n   chunks
    must be ordered by type within a block in the following way:\n   1.  authentication-related
    chunks - either SASL data chunks (type\n       100), authentication success information
    chunks (type 101), or\n       authentication failure information chunks (type
    110), but not\n       more than one type.  During the setup of security mechanisms\n
    \      using these chunks, clients MUST NOT send subsequent requests\n       until
    they have received either an authentication success or\n       failure chunk.\n
    \  2.  data chunks - either no data chunks (type 000) or application\n       data
    chunks (type 111), but not both.\n   3.  information chunks - either version information
    (type 001) or\n       other information (type 011), but not both.\n   A block
    MUST have at least one type of the above chunks.\n   The format for a chunk is
    as follows:\n         +-----------+------------+--------+\n   field | chunk     |
    chunk data | chunk  |\n         | descriptor| length     | data   |\n         +-----------+------------+--------+\n
    \  octets      1            2      variable\n                                   chunk\n
    \  These fields have the following meanings:\n   o  chunk descriptor - as described
    above.\n   o  chunk data length - the length of the data of the chunk.\n   o  chunk
    data - the data of the chunk.\n"
  - contents:
    - "6.1.  No Data Types\n   Servers and clients MUST ignore data in chunk types
      labeled no data.\n   There is no requirement for these types of chunks to be
      zero length.\n   A client MAY send \"no data\" to a server, and the server MUST
      respond\n   with either a chunk of the same type or other information (Section\n
      \  6.4).\n"
    title: 6.1.  No Data Types
  - contents:
    - "6.2.  Version Information Types\n   Chunks of this type contain XML conformant
      to the schema specified in\n   [9] and MUST have the <versions> element as the
      root element.\n   In the context of IRIS-XPC, the protocol identifiers for these\n
      \  elements are as follows:\n   o  <transferProtocol> - the value \"iris.xpc1\"
      to indicate the\n      protocol specified in this document.\n   o  <application>
      - the XML namespace identifier for IRIS [1].\n   o  <dataModel> - the XML namespace
      identifier for IRIS registries.\n   In the context of IRIS-XPC, the authentication
      mechanism identifiers\n   are the SASL mechanism names found in the IANA SASL
      mechanism\n   registry defined by RFC 4422 [10].\n   This document defines no
      extension identifiers.\n   Clients MAY send a block with this type of chunk
      to a server.  These\n   chunks SHOULD be zero length, and servers MUST ignore
      any data in\n   them.  When a server receives a chunk of this type, it MUST
      respond\n   with a chunk of this type.  This interchange allows a client to
      query\n   the version information of a server.\n   The octet sizes for the 'requestSizeOctets'
      and 'responseSizeOctets'\n   attributes of the <tranferProtocol> element are
      defined in Section\n   6.3.\n"
    title: 6.2.  Version Information Types
  - contents:
    - "6.3.  Size Information Types\n   Chunks of this type contain XML conformant
      to the schema specified in\n   RFC 4991 [9] and MUST have the <size> element
      as the root element.\n   Octet counts provided by this information are defined
      as the sum of\n   the count of all chunk data of a particular chunk type.  For\n
      \  instance, if an XML instance is broken up into chunks of 20, 30, and\n   40
      octets, the octet count would be 90 (20 + 30 + 40).\n   Clients MUST NOT send
      chunks of this type, and servers MAY close down\n   a session using the procedure
      in Section 8 if a chunk of this type is\n   received.\n"
    title: 6.3.  Size Information Types
  - contents:
    - "6.4.  Other Information Types\n   Chunks of this type contain XML conformant
      to the schema specified in\n   RFC 4991 [9] and MUST have the <other> element
      as the root element.\n   The values for the 'type' attribute of <other> are
      as follows:\n      'block-error' - indicates there was an error decoding a block.\n
      \     Servers SHOULD send a block error in the following cases:\n      1.  When
      a request block is received containing a chunk of this\n          type.\n      2.
      \ When a request block is received containing authentication\n          success
      (see Section 6.6) or authentication failure (see\n          Section 6.7) information.\n
      \     3.  When a request block is received containing size information\n          (see
      Section 6.3).\n      4.  When reserved bits in the request block are 1.\n      5.
      \ When a block has not been received in its entirety and the TCP\n          session
      has been idle for a specific period of time (i.e., a\n          data block has
      been received but no terminating chunk for the\n          data block has been
      received).  Two minutes is RECOMMENDED for\n          this timeout value.  Note,
      there is a difference between an\n          idle condition due to the incomplete
      reception of a data block\n          and an idle condition between request/response
      transactions\n          associated with keeping the session open.  For the latter,
      see\n          Section 7.\n      'data-error' - indicates there was an error
      parsing data in chunks\n      containing application or SASL data (e.g., XML
      is not valid in\n      application data).\n      'system-error' - indicates
      that the receiver cannot process the\n      request due to a condition not related
      to this protocol.  Servers\n      SHOULD send a system-error when they are capable
      of responding to\n      requests but not capable of processing requests.\n      'authority-error'
      - indicates that the intended authority\n      specified in the corresponding
      request is not served by the\n      receiver.  Servers SHOULD send an authority
      error when they\n      receive a request directed to an authority other than
      those they\n      serve.\n      'idle-timeout' - indicates that an XPC session
      has been idle for\n      too long.  Usage of this value is defined in Section
      7.  Note,\n      there is a difference between an idle condition due to the\n
      \     incomplete reception of a data block and an idle condition between\n      request/response
      transactions associated with keeping the session\n      open.  For the former,
      see 'block-error' above.\n   Clients MUST NOT send chunks of this type, and
      servers MAY close down\n   a session using the procedure in Section 8 if a chunk
      of this type is\n   received.\n"
    title: 6.4.  Other Information Types
  - contents:
    - "6.5.  SASL Types\n   The SASL chunk type allows clients and servers to exchange
      SASL data.\n   The format for the data of this type of chunk is as follows:\n
      \        +-----------+-----------+-----------+-----------+\n   field | mechanism
      | mechanism | mechanism | mechanism |\n         |   name    |   name    |   data
      \   |   data    |\n         |  length   |           |  length   |           |\n
      \        +-----------+-----------+-----------+-----------+\n   octets     1
      \       variable       2        variable\n                            SASL Authentication\n
      \  These fields have the following meaning:\n   o  mechanism name length - the
      length of the SASL mechanism name.\n   o  mechanism name - the name of the SASL
      mechanism as registered in\n      the IANA SASL mechanism registry defined by
      [10].\n   o  mechanism data length - the length of the SASL data.\n   o  mechanism
      data - the data used for SASL.\n   These fields MUST NOT span multiple chunks.
      \ Therefore, it should be\n   noted that SASL data length exceeding the length
      of the chunk minus\n   the length of SASL profile name minus one is an error.\n
      \  Depending on the nature of the SASL mechanism being used, SASL data\n   is
      sent from clients to servers and from servers to clients and may\n   require
      multiple request/response transactions to complete.  However,\n   once a SASL
      exchange is complete and a server can determine\n   authentication status, the
      server MUST send either authentication\n   success information (see Section
      6.6) or authentication failure\n   information (see Section 6.7).\n   When used
      as an initial challenge response for SASL mechanisms that\n   support such a
      feature, the mechanism data length may be set to a\n   decimal value of 65,535
      to indicate an absent initial response.  A\n   value of 0 indicates an empty
      initial response.\n"
    title: 6.5.  SASL Types
  - contents:
    - "6.6.  Authentication Success Information Types\n   Chunks of this type contain
      XML conformant to the schema specified in\n   RFC 4991 [9] and MUST have the
      <authenticationSuccess> element as the\n   root element.\n   This type of chunk
      is only sent from a server to a client.  If a\n   client sends it to a server,
      this will result in a block error (see\n   'block-error' in Section 6.4).  The
      usage of this chunk type is\n   defined in Section 6.5.  A server MAY close
      down a session due to\n   reception of this type of chunk using the procedure
      in Section 8.\n   SASL mechanisms may use the <data> child element to pass back\n
      \  arbitrary binary data as base 64 binary.  The absence of this element\n   indicates
      the absence of such data, where as the presence of the\n   element with no content
      indicates an empty data set.\n"
    title: 6.6.  Authentication Success Information Types
  - contents:
    - "6.7.  Authentication Failure Information Types\n   Chunks of this type contain
      XML conformant to the schema specified in\n   RFC 4991 [9] and MUST have the
      <authenticationFailure> element as the\n   root element.\n   This type of chunk
      is only sent from a server to a client.  If a\n   client sends it to a server,
      this will result in a block error (see\n   'block-error' in Section 6.4).  The
      usage of this chunk type is\n   defined in Section 6.5.  A server MAY close
      down a session due to\n   reception of this type of chunk using the procedure
      in Section 8.\n"
    title: 6.7.  Authentication Failure Information Types
  - contents:
    - "6.8.  Application Data Types\n   These chunks contain application data.  For
      IRIS, these are IRIS [1]\n   XML instances.\n"
    title: 6.8.  Application Data Types
  title: 6.  Chunks
- contents:
  - "7.  Idle Sessions\n   If a server needs to close a connection due to it being
    idle, it\n   SHOULD do the following:\n   1.  Send an unsolicited response block
    containing an idle timeout\n       error (see 'idle-timeout' in Section 6.4) with
    the keep-open (KO)\n       flag in the block header (Section 5) set to a value
    of 0.\n   2.  Close the TCP connection.\n"
  title: 7.  Idle Sessions
- contents:
  - "8.  Closing Sessions Due to an Error\n   If a server is to close a session due
    to an error, it SHOULD do the\n   following:\n   1.  Send a response block containing
    either a block-error or data-\n       error (see Section 6.4) or version information
    (see Section 6.2)\n       with the keep-open (KO) flag in the block header (Section
    5) set\n       to a value of 0.\n   2.  Close the TCP connection.\n"
  title: 8.  Closing Sessions Due to an Error
- contents:
  - "9.  Use over TLS\n   XPC may be tunneled over TLS [4] by establishing a TLS session\n
    \  immediately after a TCP session is opened and before any blocks are\n   sent.
    \ This type of session is known as XPCS.\n   When using TLS, a convention must
    be established to allow a client to\n   authenticate the validity of a server.
    \ XPCS uses the same convention\n   as described by IRIS-BEEP [2].\n   TLS enables
    authentication and confidentiality.\n   Implementers should note that while XPC
    and XPCS have separate URI\n   scheme names and S-NAPTR application protocol labels,
    both are\n   identified with the same <transferProtocol> value in version\n   information
    chunks (see Section 6.2).\n"
  title: 9.  Use over TLS
- contents:
  - "10.  Update to RFC 3981\n   Section 6.2 of RFC 3981 [1] (IRIS-CORE) states that
    IRIS-BEEP [2] is\n   the default transport for IRIS.  This document revises RFC
    3981 and\n   specifies IRIS-XPC as the default transport for IRIS.  The TCP well-\n
    \  known port registration is specified in Section 13.5.\n"
  title: 10.  Update to RFC 3981
- contents:
  - "11.  IRIS Transport Mapping Definitions\n   This section lists the definitions
    required by IRIS [1] for transport\n   mappings.\n"
  - contents:
    - "11.1.  URI Scheme\n   See Section 13.1 and Section 13.2.\n"
    title: 11.1.  URI Scheme
  - contents:
    - "11.2.  Application Protocol Label\n   See Section 13.3 and Section 13.4.\n"
    title: 11.2.  Application Protocol Label
  title: 11.  IRIS Transport Mapping Definitions
- contents:
  - "12.  Internationalization Considerations\n   XML processors are obliged to recognize
    both UTF-8 and UTF-16 [3]\n   encodings.  Use of the XML defined by [9] MUST NOT
    use any other\n   character encodings other than UTF-8 or UTF-16.\n"
  title: 12.  Internationalization Considerations
- contents:
  - '13.  IANA Considerations

    '
  - contents:
    - "13.1.  XPC URI Scheme Registration\n   URL scheme name: iris.xpc\n   Status:
      permanent\n   URL scheme syntax: defined in [1].\n   Character encoding considerations:
      as defined in RFC 3986 [6].\n   Intended usage: identifies IRIS XML using chunks
      over TCP\n   Applications using this scheme: defined in IRIS [1].\n   Interoperability
      considerations: n/a\n   Security Considerations: defined in Section 14.\n   Relevant
      Publications: IRIS [1].\n   Contact Information: Andrew Newton <andy@hxr.us>\n
      \  Author/Change controller: the IESG\n"
    title: 13.1.  XPC URI Scheme Registration
  - contents:
    - "13.2.  XPCS URI Scheme Registration\n   URL scheme name: iris.xpcs\n   Status:
      permanent\n   URL scheme syntax: defined in [1].\n   Character encoding considerations:
      as defined in RFC 3986 [6].\n   Intended usage: identifies IRIS XML using chunks
      over TLS\n   Applications using this scheme: defined in IRIS [1].\n   Interoperability
      considerations: n/a\n   Security Considerations: defined in Section 14.\n   Relevant
      Publications: IRIS [1].\n   Contact Information: Andrew Newton <andy@hxr.us>\n
      \  Author/Change controller: the IESG\n"
    title: 13.2.  XPCS URI Scheme Registration
  - contents:
    - "13.3.  S-NAPTR XPC Registration\n   Application Protocol Label (see [5]): iris.xpc\n
      \  Intended usage: identifies an IRIS server using XPC\n   Interoperability
      considerations: n/a\n   Security Considerations: defined in Section 14.\n   Relevant
      Publications: IRIS [1].\n   Contact Information: Andrew Newton <andy@hxr.us>\n
      \  Author/Change controller: the IESG\n"
    title: 13.3.  S-NAPTR XPC Registration
  - contents:
    - "13.4.  S-NAPTR XPCS Registration\n   Application Protocol Label (see [5]):
      iris.xpcs\n   Intended usage: identifies an IRIS server using secure XPCS\n
      \  Interoperability considerations: n/a\n   Security Considerations: defined
      in Section 14.\n   Relevant Publications: IRIS [1].\n   Contact Information:
      Andrew Newton <andy@hxr.us>\n   Author/Change controller: the IESG\n"
    title: 13.4.  S-NAPTR XPCS Registration
  - contents:
    - "13.5.  Well-Known TCP Port Registration for XPC\n   Protocol Number: TCP\n
      \  TCP Port Number: 713\n   Message Formats, Types, Opcodes, and Sequences:
      defined in Section\n   4.2, Section 3, and Section 4.1.\n   Functions: defined
      in IRIS [1].\n   Use of Broadcast/Multicast: none\n   Proposed Name: IRIS over
      XPC\n   Short name: iris.xpc\n   Contact Information: Andrew Newton <andy@hxr.us>\n"
    title: 13.5.  Well-Known TCP Port Registration for XPC
  - contents:
    - "13.6.  Well-Known TCP Port Registration for XPCS\n   Protocol Number: TCP\n
      \  TCP Port Number: 714\n   Message Formats, Types, Opcodes, and Sequences:
      defined in Sections\n   9, 4.2, 3, and 4.1.\n   Functions: defined in IRIS [1].\n
      \  Use of Broadcast/Multicast: none\n   Proposed Name: IRIS over XPCS\n   Short
      name: iris.xpcs\n   Contact Information: Andrew Newton <andy@hxr.us>\n"
    title: 13.6.  Well-Known TCP Port Registration for XPCS
  title: 13.  IANA Considerations
- contents:
  - "14.  Security Considerations\n   Implementers should be fully aware of the security
    considerations\n   given by IRIS [1] and TLS [4].  With respect to server authentication\n
    \  with the use of TLS, see Section 6 of IRIS-BEEP [2].\n"
  - contents:
    - "14.1.  Security Mechanisms\n   Clients SHOULD be prepared to use the following
      security mechanisms\n   in the following manner:\n   o  SASL/DIGEST-MD5 - for
      user authentication without the need of\n      session encryption.\n   o  SASL/OTP
      - for user authentication without the need of session\n      encryption.\n   o
      \ TLS using the TLS_RSA_WITH_3DES_EDE_CBC_SHA cipher - for\n      encryption.\n
      \  o  TLS using the TLS_RSA_WITH_3DES_EDE_CBC_SHA cipher with client-\n      side
      certificates - for encryption and user authentication.\n   o  TLS using the
      TLS_RSA_WITH_AES_128_CBC_SHA cipher - for\n      encryption.  See [7].\n   o
      \ TLS using the TLS_RSA_WITH_AES_128_CBC_SHA cipher with client-side\n      certificates
      - for encryption and user authentication.  See [7].\n   o  TLS using the TLS_RSA_WITH_AES_256_CBC_SHA
      cipher - for\n      encryption.  See [7].\n   o  TLS using the TLS_RSA_WITH_AES_256_CBC_SHA
      cipher with client-side\n      certificates - for encryption and user authentication.
      \ See [7].\n      Anonymous client access SHOULD be considered in one of two\n
      \     methods:\n   1.  When no authentication has been used.\n   2.  Using the
      SASL anonymous profile: SASL/ANONYMOUS\n   As specified by SASL/PLAIN, clients
      MUST NOT use the SASL/PLAIN\n   mechanism without first encrypting the TCP session
      (e.g., such as\n   with TLS).  Clients MUST implement SASL/PLAIN and TLS using
      the\n   TLS_RSA_WITH_3DES_EDE_CBC_SHA cipher.\n"
    title: 14.1.  Security Mechanisms
  - contents:
    - "14.2.  SASL Compliance\n   The following list details the compliance of IRIS-XPC
      for use with\n   SASL, as specified by RFC 4422 [10], Section 4.\n   1.  The
      SASL service name to be used by IRIS-XPC is \"iris-xpc\".\n   2.  Section 6.2
      describes the negotiation facility used to determine\n       the available security
      mechanisms.  This facility may be used\n       both before the initiation of
      SASL exchanges and after the\n       installation of security mechanisms.\n
      \  3.\n        a) Section 6.5 describes the mechanism to initiate\n           authentication
      exchanges.\n        b) Section 6.5 describes the mechanism to transfer server\n
      \          challenges and client responses.\n        c) Section 6.6 and Section
      6.7 describe the mechanisms to\n           indicate the outcome of an authentication
      exchange.  Section\n           6.6 describes how additional data may be carried
      with this\n           message.\n   4.  Non-empty authorization identity strings
      used within IRIS-XPC\n       MUST be normalized according to RFC 4013 [11].
      \ The semantics of\n       the non-empty authorization identity strings is server
      dependent,\n       and clients MUST use the values for these strings as given
      by\n       configuration or the user.\n   5.  Clients or servers wishing to
      abort an ongoing authentication\n       exchange MUST close the connection.\n
      \  6.  After new security layers are negotiated, they take effect on the\n       first
      octet following the authentication success (as) (Section\n       6.6) chunk
      sent by the server and on the first octet sent after\n       receipt of the
      authentication success (as) chunk sent by the\n       client.\n   7.  IRIS-XPC
      can be used with both TLS and SASL.  When used in\n       combination, TLS MUST
      always be applied before any SASL\n       mechanism.\n   8.  IRIS-XPC does not
      support multiple SASL authentications.\n       However, if TLS is being used
      in combination with SASL, TLS\n       authentication MUST occur before any SASL
      authentication.\n"
    title: 14.2.  SASL Compliance
  title: 14.  Security Considerations
- contents:
  - '15.  References

    '
  - contents:
    - "15.1.  Normative References\n   [1]   Newton, A. and M. Sanz, \"IRIS: The Internet
      Registry\n         Information Service (IRIS) Core Protocol\", RFC 3981, January\n
      \        2005.\n   [2]   Newton, A. and M. Sanz, \"Using the Internet Registry\n
      \        Information Service over the Blocks Extensible Exchange\n         Protocol\",
      RFC 3983, January 2005.\n   [3]   The Unicode Consortium, \"The Unicode Standard,
      Version  3\",\n         ISBN 0-201-61633-5, 2000, <The Unicode Standard, Version
      3>.\n   [4]   Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS)\n
      \        Protocol Version 1.1\", RFC 4346, April 2006.\n   [5]   Daigle, L.
      and A. Newton, \"Domain-Based Application Service\n         Location Using SRV
      RRs and the Dynamic Delegation Discovery\n         Service  (DDDS)\", RFC 3958,
      January 2005.\n   [6]   Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n
      \        Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986,\n         January
      2005.\n   [7]   Chown, P., \"Advanced Encryption Standard (AES) Ciphersuites
      for\n         Transport Layer Security (TLS)\", RFC 3268, June 2002.\n   [8]
      \  Bradner, S., \"Key words for use in RFCs to  Indicate\n         Requirement
      Levels\", RFC 2119, BCP 14, March 1997.\n   [9]   Newton, A., \"A Common Schema
      for Internet Registry Information\n         Service Transfer Protocols\", RFC
      4991, August 2007.\n   [10]  Melnikov, A. and K. Zeilenga, \"Simple Authentication
      and\n         Security Layer (SASL)\", RFC 4422, June 2006.\n   [11]  Zeilenga,
      K., \"SASLprep: Stringprep Profile for User Names and\n         Passwords\",
      RFC 4013, February 2005.\n"
    title: 15.1.  Normative References
  - contents:
    - "15.2.  Informative References\n   [12]  Kirkpatrick, S., Stahl, M., and M.
      Recker, \"Internet numbers\",\n         RFC 1166, July 1990.\n"
    title: 15.2.  Informative References
  title: 15.  References
- contents:
  - "Appendix A.  Examples\n   This section gives examples of IRIS-XPC sessions.  Lines
    beginning\n   with \"C:\" denote data sent by the client to the server, and lines\n
    \  beginning with \"S:\" denote data sent by the server to the client.\n   Following
    the \"C:\" or \"S:\", the line contains either octet values in\n   hexadecimal
    notation with comments or XML fragments.  No line\n   contains both octet values
    with comments and XML fragments.  Comments\n   are contained within parentheses.\n
    \  It should also be noted that flag values of \"yes\" and \"no\" reflect\n   binary
    values 1 and 0.\n   The following example demonstrates an IRIS client issuing
    two\n   requests in one XPC session.  In the first request, the client is\n   requesting
    status information for \"example.com\".  This request and\n   its response are
    transferred with one chunk.  In the second request,\n   the client is requesting
    status information for \"milo.example.com\",\n   \"felix.example.com\", and \"hobbes.example.com\".
    \ This request and its\n   response are transferred with three chunks.\n   S:
    \          (connection response block)\n   S: 0x20      (block header: V=0,KO=yes)\n
    \  S:           (chunk 1)\n   S: 0xC1      (LC=yes,DC=yes,CT=vi)\n   S: 0x01 0xBF
    (chunk length=447)\n   S:           (Version Information)\n   S: <?xml version=\"1.0\"?>\n
    \  S: <versions xmlns=\"urn:ietf:params:xml:ns:iris-transport\">\n   S:   <transferProtocol
    protocolId=\"iris.xpc1\"\n   S:     authenticationIds=\"PLAIN EXTERNAL\">\n   S:
    \    <application protocolId=\"urn:ietf:params:xml:ns:iris1\"\n   S:       extensionIds=\"http://example.com/SIMPLEBAG\">\n
    \  S:       <dataModel protocolId=\"urn:ietf:params:xml:ns:dchk1\"/>\n   S:       <dataModel
    protocolId=\"urn:ietf:params:xml:ns:dreg1\"/>\n   S:     </application>\n   S:
    \  </transferProtocol>\n   S: </versions>\n   C:           (request block)\n   C:
    0x20      (block header: V=0,KO=yes)\n   C: 0x0B      (authority length=11)\n
    \  C:           (authority=\"example.com\")\n   C: 0x65 0x78 0x61 0x6D 0x70 0x6C
    0x65 0x23 0x63 0x6F 0x6D\n   C:           (chunk 1)\n   C: 0xC7      (LC=yes,DC=yes,CT=ad)\n
    \  C: 0x01 0x53 (chunk length=339)\n   C:           (IRIS XML request)\n   C:
    <request xmlns=\"urn:ietf:params:xml:ns:iris1\"\n   C:   xsi:schemaLocation=\"urn:ietf:params:xml:ns:iris1
    iris.xsd\" >\n   C:   <searchSet>\n   C:     <lookupEntity\n   C:       registryType=\"urn:ietf:params:xml:ns:dchk1\"\n
    \  C:       entityClass=\"domain-name\"\n   C:       entityName=\"example.com\"
    />\n   C:   </searchSet>\n   C: </request>\n   S:           (response block)\n
    \  S: 0x20      (block header: V=0,KO=yes)\n   S:           (chunk 1)\n   S: 0xC7
    \     (LC=yes,DC=yes,CT=ad)\n   S: 0x01 0xE0 (chunk length=480)\n   S:           (IRIS
    XML response)\n   S: <iris:response xmlns:iris=\"urn:ietf:params:xml:ns:iris1\">\n
    \  S:   <iris:resultSet>\n   S:     <iris:answer>\n   S:       <domain authority=\"example.com\"
    registryType=\"dchk1\"\n   S:         entityClass=\"domain-name\" entityName=\"example.com-1\"\n
    \  S:         temporaryReference=\"true\"\n   S:         xmlns=\"urn:ietf:params:xml:ns:dchk1\">\n
    \  S:         <domainName>example.com</domainName>\n   S:         <status>\n   S:
    \          <assignedAndActive/>\n   S:         </status>\n   S:       </domain>\n
    \  S:     </iris:answer>\n   S:   </iris:resultSet>\n   S: </iris:response>\n
    \  C:           (request block)\n   C: 0x00      (block header: V=0,KO=no)\n   C:
    0x0B      (authority length=11)\n   C:           (authority=\"example.com\")\n
    \  C: 0x65 0x78 0x61 0x6D 0x70 0x6C 0x65 0x23 0x63 0x6F 0x6D\n   C:           (chunk
    1)\n   C: 0x07      (LC=no,DC=no,CT=ad)\n   C: 0x01 0x4E (chunk length=339)\n
    \  C:           (IRIS XML request)\n   C: <request xmlns=\"urn:ietf:params:xml:ns:iris1\"\n
    \  C:  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   C:  xsi:schemaLocation=\"urn:ietf:params:xml:ns:iris1
    iris.xsd\" >\n   C:   <searchSet>\n   C:    <lookupEntity\n   C:      registryType=\"urn:ietf:params:xml:ns:dchk1\"\n
    \  C:      entityClass=\"domain-name\"\n   C:      entityName=\"milo.example.com\"
    />\n   C:  </searchSet>\n   C:           (chunk 2)\n   C: 0x07      (LC=no,DC=no,CT=ad)\n
    \  C: 0x00 0xA9 (chunk length=169)\n   C:           (IRIS XML request)\n   C:
    \ <searchSet>\n   C:    <lookupEntity\n   C:      registryType=\"urn:ietf:params:xml:ns:dchk1\"\n
    \  C:      entityClass=\"domain-name\"\n   C:      entityName=\"felix.example.com\"
    />\n   C:  </searchSet>\n   C:           (chunk 3)\n   C: 0xC7      (LC=yes,DC=yes,CT=ad)\n
    \  C: 0x00 0xB5 (chunk length=181)\n   C:           (IRIS XML request)\n   C:
    \ <searchSet>\n   C:    <lookupEntity\n   C:      registryType=\"urn:ietf:params:xml:ns:dchk1\"\n
    \  C:      entityClass=\"domain-name\"\n   C:      entityName=\"hobbes.example.com\"
    />\n   C:  </searchSet>\n   C:</request>\n   S:           (response block)\n   S:
    0x00      (block header: V=0,KO=no)\n   S:           (chunk 1)\n   S: 0x07      (LC=no,DC=no,CT=ad)\n
    \  S: 0x01 0xDA (chunk length=474)\n   S:           (IRIS XML response)\n   S:
    <iris:response xmlns:iris=\"urn:ietf:params:xml:ns:iris1\">\n   S:   <iris:resultSet>\n
    \  S:     <iris:answer>\n   S:       <domain authority=\"example.com\" registryType=\"dchk1\"\n
    \  S:         entityClass=\"domain-name\" entityName=\"milo.example.com-1\"\n
    \  S:         temporaryReference=\"true\"\n   S:         xmlns=\"urn:ietf:params:xml:ns:dchk1\">\n
    \  S:         <domainName>milo.example.com</domainName>\n   S:         <status>\n
    \  S:           <assignedAndActive/>\n   S:         </status>\n   S:       </domain>\n
    \  S:     </iris:answer>\n   S:   </iris:resultSet>\n   S:           (chunk 2)\n
    \  S: 0x07      (LC=no,DC=no,CT=ad)\n   S: 0x01 0xA2 (chunk length=418)\n   S:
    \          (IRIS XML response)\n   S:  <iris:resultSet>\n   S:    <iris:answer>\n
    \  S:      <domain authority=\"example.com\" registryType=\"dchk1\"\n   S:        entityClass=\"domain-name\"
    entityName=\"felix.example.com-1\"\n   S:        temporaryReference=\"true\"\n
    \  S:        xmlns=\"urn:ietf:params:xml:ns:dchk1\">\n   S:        <domainName>felix.example.com</domainName>\n
    \  S:        <status>\n   S:          <assignedAndActive/>\n   S:        </status>\n
    \  S:      </domain>\n   S:    </iris:answer>\n   S:  </iris:resultSet>\n   S:
    \          (chunk 3)\n   S: 0xC7      (LC=yes,DC=yes,CT=ad)\n   S: 0x01 0xB5 (chunk
    length=437)\n   S:           (IRIS XML response)\n   S:  <iris:resultSet>\n   S:
    \    <iris:answer>\n   S:       <domain authority=\"example.com\" registryType=\"dchk1\"\n
    \  S:         entityClass=\"domain-name\"\n   S:  entityName=\"hobbes.example.com-1\"\n
    \  S:         temporaryReference=\"true\"\n   S:         xmlns=\"urn:ietf:params:xml:ns:dchk1\">\n
    \  S:         <domainName>hobbes.example.com</domainName>\n   S:         <status>\n
    \  S:           <assignedAndActive/>\n   S:         </status>\n   S:       </domain>\n
    \  S:     </iris:answer>\n   S:   </iris:resultSet>\n   S: </iris:response>\n
    \                            Example 1\n   In the following example, an IRIS client
    requests domain status\n   information for \"milo.example.com\", \"felix.example.com\",
    and\n   \"hobbes.example.com\" in one request.  The request is sent with one\n
    \  chunk; however, the answer is returned in three chunks.\n   S:           (connection
    response block)\n   S: 0x20      (block header: V=0,KO=yes)\n   S:           (chunk
    1)\n   S: 0xC1      (LC=yes,DC=yes,CT=vi)\n   S: 0x01 0xBF (chunk length=447)\n
    \  S:           (Version Information)\n   S: <?xml version=\"1.0\"?>\n   S: <versions
    xmlns=\"urn:ietf:params:xml:ns:iris-transport\">\n   S:   <transferProtocol protocolId=\"iris.xpc1\"\n
    \  S:     authenticationIds=\"PLAIN EXTERNAL\">\n   S:     <application protocolId=\"urn:ietf:params:xml:ns:iris1\"\n
    \  S:       extensionIds=\"http://example.com/SIMPLEBAG\">\n   S:       <dataModel
    protocolId=\"urn:ietf:params:xml:ns:dchk1\"/>\n   S:       <dataModel protocolId=\"urn:ietf:params:xml:ns:dreg1\"/>\n
    \  S:     </application>\n   S:   </transferProtocol>\n   S: </versions>\n   C:
    \          (request block)\n   C: 0x00      (block header: V=0,KO=no)\n   C: 0x0B
    \     (authority length=11)\n   C:           (authority=\"example.com\")\n   C:
    0x65 0x78 0x61 0x6D 0x70 0x6C 0x65 0x23 0x63 0x6F 0x6D\n   C:           (chunk
    1)\n   C: 0xC7      (LC=yes,DC=yes,CT=ad)\n   C: 0x02 0xAB (chunk length=683)\n
    \  C:           (IRIS XML request)\n   C: <request xmlns=\"urn:ietf:params:xml:ns:iris1\"\n
    \  C:   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   C:   xsi:schemaLocation=\"urn:ietf:params:xml:ns:iris1
    iris.xsd\" >\n   C:    <searchSet>\n   C:     <lookupEntity\n   C:       registryType=\"urn:ietf:params:xml:ns:dchk1\"\n
    \  C:       entityClass=\"domain-name\"\n   C:       entityName=\"milo.example.com\"
    />\n   C:   </searchSet>\n   C:   <searchSet>\n   C:     <lookupEntity\n   C:
    \      registryType=\"urn:ietf:params:xml:ns:dchk1\"\n   C:       entityClass=\"domain-name\"\n
    \  C:       entityName=\"felix.example.com\" />\n   C:   </searchSet>\n   C:   <searchSet>\n
    \  C:     <lookupEntity\n   C:       registryType=\"urn:ietf:params:xml:ns:dchk1\"\n
    \  C:       entityClass=\"domain-name\"\n   C:       entityName=\"hobbes.example.com\"
    />\n   C:   </searchSet>\n   C: </request>\n   S:           (response block)\n
    \  S: 0x00      (block header: V=0,KO=no)\n   S:           (chunk 1)\n   S: 0x07
    \     (LC=no,DC=no,CT=ad)\n   S: 0x01 0xDA (chunk length=474)\n   S:           (IRIS
    XML response)\n   S: <iris:response xmlns:iris=\"urn:ietf:params:xml:ns:iris1\">\n
    \  S:   <iris:resultSet>\n   S:     <iris:answer>\n   S:       <domain authority=\"example.com\"
    registryType=\"dchk1\"\n   S:         entityClass=\"domain-name\" entityName=\"milo.example.com-1\"\n
    \  S:         temporaryReference=\"true\"\n   S:         xmlns=\"urn:ietf:params:xml:ns:dchk1\">\n
    \  S:         <domainName>milo.example.com</domainName>\n   S:         <status>\n
    \  S:           <assignedAndActive/>\n   S:         </status>\n   S:       </domain>\n
    \  S:     </iris:answer>\n   S:   </iris:resultSet>\n   S:           (chunk 2)\n
    \  S: 0x07      (LC=no,DC=no,CT=ad)\n   S: 0x01 0xA2 (chunk length=418)\n   S:
    \          (IRIS XML response)\n   S:  <iris:resultSet>\n   S:    <iris:answer>\n
    \  S:      <domain authority=\"example.com\" registryType=\"dchk1\"\n   S:        entityClass=\"domain-name\"
    entityName=\"felix.example.com-1\"\n   S:        temporaryReference=\"true\"\n
    \  S:        xmlns=\"urn:ietf:params:xml:ns:dchk1\">\n   S:        <domainName>felix.example.com</domainName>\n
    \  S:        <status>\n   S:          <assignedAndActive/>\n   S:        </status>\n
    \  S:      </domain>\n   S:    </iris:answer>\n   S:  </iris:resultSet>\n   S:
    \          (chunk 3)\n   S: 0xC7      (LC=yes,DC=yes,CT=ad)\n   S: 0x01 0xB5 (chunk
    length=437)\n   S:           (IRIS XML response)\n   S:  <iris:resultSet>\n   S:
    \    <iris:answer>\n   S:       <domain authority=\"example.com\" registryType=\"dchk1\"\n
    \  S:         entityClass=\"domain-name\"\n   S:  entityName=\"hobbes.example.com-1\"\n
    \  S:         temporaryReference=\"true\"\n   S:         xmlns=\"urn:ietf:params:xml:ns:dchk1\">\n
    \  S:         <domainName>hobbes.example.com</domainName>\n   S:         <status>\n
    \  S:           <assignedAndActive/>\n   S:         </status>\n   S:       </domain>\n
    \  S:     </iris:answer>\n   S:   </iris:resultSet>\n   S: </iris:response>\n
    \                           Example 2\n   In the following example, an IRIS client
    sends a request containing\n   SASL/PLAIN authentication data and a domain status
    check for\n   \"example.com\".  The server responds with authentication success\n
    \  information and the domain status of \"example.com\".  Note that the\n   client
    requests that the connection stay open for further requests,\n   but the server
    does not honor this request.\n   S:           (connection response block)\n   S:
    0x20      (block header: V=0,KO=yes)\n   S:           (chunk 1)\n   S: 0xC1      (LC=yes,DC=yes,CT=vi)\n
    \  S: 0x01 0xBF (chunk length=447)\n   S:           (Version Information)\n   S:
    <?xml version=\"1.0\"?>\n   S: <versions xmlns=\"urn:ietf:params:xml:ns:iris-transport\">\n
    \  S:   <transferProtocol protocolId=\"iris.xpc1\"\n   S:     authenticationIds=\"PLAIN
    EXTERNAL\">\n   S:     <application protocolId=\"urn:ietf:params:xml:ns:iris1\"\n
    \  S:       extensionIds=\"http://example.com/SIMPLEBAG\">\n   S:       <dataModel
    protocolId=\"urn:ietf:params:xml:ns:dchk1\"/>\n   S:       <dataModel protocolId=\"urn:ietf:params:xml:ns:dreg1\"/>\n
    \  S:     </application>\n   S:   </transferProtocol>\n   S: </versions>\n   C:
    \          (request block)\n   C: 0x00      (block header: V=0,KO=no)\n   C: 0x0B
    \     (authority length=11)\n   C:           (authority=\"example.com\")\n   C:
    0x65 0x78 0x61 0x6D 0x70 0x6C 0x65 0x23 0x63 0x6F 0x6D\n   C:           (chunk
    1)\n   C: 0x44      (LC=no,DC=yes,CT=sd)\n   C: 0x00 0x11 (chunk length=11)\n
    \  C:           (SASL data)\n   C: 0x05      (mechanism length=5)\n   C:           (mechanism
    name=\"PLAIN\")\n   C: 0x50 0x4C 0x41 0x49 0x43\n   C: 0x00 0x0A (sasl PLAIN data
    length=10)\n   C:           (sasl PLAIN data: authcid=\"bob\")\n   C:           (sasl
    PLAIN data: authzid=NULL)\n   C:           (sasl PLAIN data: password=\"kEw1\")\n
    \  C: 0x62 0x6F 0x62 0x20 0x00 0x20 0x6B 0x45 0x77 0x31\n   C:           (chunk
    2)\n   C: 0xC7      (LC=yes,DC=yes,CT=ad)\n   C: 0x01 0x53 (chunk length=339)\n
    \  C:           (IRIS XML request)\n   C: <request xmlns=\"urn:ietf:params:xml:ns:iris1\"\n
    \  C:   xsi:schemaLocation=\"urn:ietf:params:xml:ns:iris1 iris.xsd\" >\n   C:
    \  <searchSet>\n   C:     <lookupEntity\n   C:       registryType=\"urn:ietf:params:xml:ns:dchk1\"\n
    \  C:       entityClass=\"domain-name\"\n   C:       entityName=\"example.com\"
    />\n   C:   </searchSet>\n   C: </request>\n   S:           (response block)\n
    \  S: 0x00      (block header: V=0,KO=no)\n   S:           (chunk 1)\n   S: 0x45
    \     (LC=no,DC=yes,CT=as)\n   S: 0x00 0xD0 (chunk length=208)\n   S:           (authentication
    success response)\n   S: <?xml version=\"1.0\"?>\n   S: <authenticationSuccess\n
    \  S:   xmlns=\"urn:ietf:params:xml:ns:iris-transport\">\n   S:   <description
    language=\"en\">\n   S:     user 'bob' authenticates via password\n   S:   </description>\n
    \  S: </authenticationSuccess>\n   S:           (chunk 2)\n   S: 0xC7      (LC=yes,DC=yes,CT=ad)\n
    \  S: 0x01 0xE0 (chunk length=480)\n   S:           (IRIS XML response)\n   S:
    <iris:response xmlns:iris=\"urn:ietf:params:xml:ns:iris1\">\n   S:   <iris:resultSet>\n
    \  S:     <iris:answer>\n   S:       <domain authority=\"example.com\" registryType=\"dchk1\"\n
    \  S:         entityClass=\"domain-name\" entityName=\"example.com-1\"\n   S:
    \        temporaryReference=\"true\"\n   S:         xmlns=\"urn:ietf:params:xml:ns:dchk1\">\n
    \  S:         <domainName>example.com</domainName>\n   S:         <status>\n   S:
    \          <assignedAndActive/>\n   S:         </status>\n   S:       </domain>\n
    \  S:     </iris:answer>\n   S:   </iris:resultSet>\n   S: </iris:response>\n
    \                           Example 3\n"
  title: Appendix A.  Examples
- contents:
  - "Appendix B.  Contributors\n   Substantive contributions to this document have
    been provided by the\n   members of the IETF's CRISP Working Group, especially
    Robert Martin-\n   Legene, Milena Caires, and David Blacka.\n"
  title: Appendix B.  Contributors
- contents:
  - "Author's Address\n   Andrew L. Newton\n   VeriSign, Inc.\n   21345 Ridgetop Circle\n
    \  Sterling, VA  20166\n   USA\n   Phone: +1 703 948 3382\n   EMail: andy@hxr.us\n
    \  URI:   http://www.verisignlabs.com/\n"
  title: Author's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
