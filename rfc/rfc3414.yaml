- title: __initial_text__
  contents:
  - "          User-based Security Model (USM) for version 3 of the\n            \
    \  Simple Network Management Protocol (SNMPv3)\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the User-based Security Model (USM) for\n\
    \   Simple Network Management Protocol (SNMP) version 3 for use in the\n   SNMP\
    \ architecture.  It defines the Elements of Procedure for\n   providing SNMP message\
    \ level security.  This document also includes a\n   Management Information Base\
    \ (MIB) for remotely monitoring/managing\n   the configuration parameters for\
    \ this Security Model.  This document\n   obsoletes RFC 2574.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.        Introduction..........................................\
    \  4\n   1.1.      Threats...............................................  4\n\
    \   1.2.      Goals and Constraints.................................  6\n   1.3.\
    \      Security Services.....................................  6\n   1.4.    \
    \  Module Organization...................................  7\n   1.4.1.    Timeliness\
    \ Module.....................................  8\n   1.4.2.    Authentication\
    \ Protocol...............................  8\n   1.4.3.    Privacy Protocol......................................\
    \  8\n   1.5.      Protection against Message Replay, Delay\n             and\
    \ Redirection.......................................  9\n   1.5.1.    Authoritative\
    \ SNMP engine.............................  9\n   1.5.2.    Mechanisms............................................\
    \  9\n   1.6.      Abstract Service Interfaces........................... 11\n\
    \   1.6.1.    User-based Security Model Primitives\n             for Authentication....................................\
    \ 11\n   1.6.2.    User-based Security Model Primitives\n             for Privacy...........................................\
    \ 12\n   2.        Elements of the Model................................. 12\n\
    \   2.1.      User-based Security Model Users....................... 12\n   2.2.\
    \      Replay Protection..................................... 13\n   2.2.1.  \
    \  msgAuthoritativeEngineID.............................. 14\n   2.2.2.    msgAuthoritativeEngineBoots\
    \ and\n             msgAuthoritativeEngineTime............................ 14\n\
    \   2.2.3.    Time Window........................................... 15\n   2.3.\
    \      Time Synchronization.................................. 15\n   2.4.    \
    \  SNMP Messages Using this Security Model............... 16\n   2.5.      Services\
    \ provided by the User-based Security Model.... 17\n   2.5.1.    Services for\
    \ Generating an Outgoing SNMP Message...... 17\n   2.5.2.    Services for Processing\
    \ an Incoming SNMP Message...... 20\n   2.6.      Key Localization Algorithm............................\
    \ 22\n   3.        Elements of Procedure................................. 22\n\
    \   3.1.      Generating an Outgoing SNMP Message................... 22\n   3.2.\
    \      Processing an Incoming SNMP Message................... 26\n   4.      \
    \  Discovery............................................. 31\n   5.        Definitions...........................................\
    \ 32\n   6.        HMAC-MD5-96 Authentication Protocol................... 51\n\
    \   6.1.      Mechanisms............................................ 51\n   6.1.1.\
    \    Digest Authentication Mechanism....................... 51\n   6.2.      Elements\
    \ of the Digest Authentication Protocol........ 52\n   6.2.1.    Users.................................................\
    \ 52\n   6.2.2.    msgAuthoritativeEngineID.............................. 53\n\
    \   6.2.3.    SNMP Messages Using this Authentication Protocol...... 53\n   6.2.4.\
    \    Services provided by the HMAC-MD5-96\n             Authentication Module.................................\
    \ 53\n   6.2.4.1.  Services for Generating an Outgoing SNMP Message...... 53\n\
    \   6.2.4.2.  Services for Processing an Incoming SNMP Message...... 54\n   6.3.\
    \      Elements of Procedure................................. 55\n   6.3.1.  \
    \  Processing an Outgoing Message........................ 55\n   6.3.2.    Processing\
    \ an Incoming Message........................ 56\n   7.        HMAC-SHA-96 Authentication\
    \ Protocol................... 57\n   7.1.      Mechanisms............................................\
    \ 57\n   7.1.1.    Digest Authentication Mechanism....................... 57\n\
    \   7.2.      Elements of the HMAC-SHA-96 Authentication Protocol... 58\n   7.2.1.\
    \    Users................................................. 58\n   7.2.2.    msgAuthoritativeEngineID..............................\
    \ 58\n   7.2.3.    SNMP Messages Using this Authentication Protocol...... 59\n\
    \   7.2.4.    Services provided by the HMAC-SHA-96\n             Authentication\
    \ Module................................. 59\n   7.2.4.1.  Services for Generating\
    \ an Outgoing SNMP Message...... 59\n   7.2.4.2.  Services for Processing an Incoming\
    \ SNMP Message...... 60\n   7.3.      Elements of Procedure.................................\
    \ 61\n   7.3.1.    Processing an Outgoing Message........................ 61\n\
    \   7.3.2.    Processing an Incoming Message........................ 61\n   8.\
    \        CBC-DES Symmetric Encryption Protocol................. 63\n   8.1.  \
    \    Mechanisms............................................ 63\n   8.1.1.    Symmetric\
    \ Encryption Protocol......................... 63\n   8.1.1.1.  DES key and Initialization\
    \ Vector..................... 64\n   8.1.1.2.  Data Encryption.......................................\
    \ 65\n   8.1.1.3.  Data Decryption....................................... 65\n\
    \   8.2.      Elements of the DES Privacy Protocol.................. 65\n   8.2.1.\
    \    Users................................................. 65\n   8.2.2.    msgAuthoritativeEngineID..............................\
    \ 66\n   8.2.3.    SNMP Messages Using this Privacy Protocol............. 66\n\
    \   8.2.4.    Services provided by the DES Privacy Module........... 66\n   8.2.4.1.\
    \  Services for Encrypting Outgoing Data................. 66\n   8.2.4.2.  Services\
    \ for Decrypting Incoming Data................. 67\n   8.3.      Elements of Procedure.................................\
    \ 68\n   8.3.1.    Processing an Outgoing Message........................ 68\n\
    \   8.3.2.    Processing an Incoming Message........................ 69\n   9.\
    \        Intellectual Property................................. 69\n   10.   \
    \    Acknowledgements...................................... 70\n   11.       Security\
    \ Considerations............................... 71\n   11.1.     Recommended Practices.................................\
    \ 71\n   11.2.     Defining Users........................................ 73\n\
    \   11.3.     Conformance........................................... 74\n   11.4.\
    \     Use of Reports........................................ 75\n   11.5.    \
    \ Access to the SNMP-USER-BASED-SM-MIB.................. 75\n   12.       References............................................\
    \ 75\n   A.1.      SNMP engine Installation Parameters................... 78\n\
    \   A.2.      Password to Key Algorithm............................. 80\n   A.2.1.\
    \    Password to Key Sample Code for MD5................... 81\n   A.2.2.    Password\
    \ to Key Sample Code for SHA................... 82\n   A.3.      Password to Key\
    \ Sample Results........................ 83\n   A.3.1.    Password to Key Sample\
    \ Results using MD5.............. 83\n   A.3.2.    Password to Key Sample Results\
    \ using SHA.............. 83\n   A.4.      Sample encoding of msgSecurityParameters..............\
    \ 83\n   A.5.      Sample keyChange Results.............................. 84\n\
    \   A.5.1.    Sample keyChange Results using MD5.................... 84\n   A.5.2.\
    \    Sample keyChange Results using SHA.................... 85\n   B.        Change\
    \ Log............................................ 86\n             Editors' Addresses....................................\
    \ 87\n             Full Copyright Statement.............................. 88\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The Architecture for describing Internet Management Frameworks\n\
    \   [RFC3411] describes that an SNMP engine is composed of:\n   1) a Dispatcher,\n\
    \   2) a Message Processing Subsystem,\n   3) a Security Subsystem, and\n   4)\
    \ an Access Control Subsystem.\n   Applications make use of the services of these\
    \ subsystems.\n   It is important to understand the SNMP architecture and the\n\
    \   terminology of the architecture to understand where the Security\n   Model\
    \ described in this document fits into the architecture and\n   interacts with\
    \ other subsystems within the architecture.  The reader\n   is expected to have\
    \ read and understood the description of the SNMP\n   architecture, as defined\
    \ in [RFC3411].\n   This memo describes the User-based Security Model as it is\
    \ used\n   within the SNMP Architecture.  The main idea is that we use the\n \
    \  traditional concept of a user (identified by a userName) with which\n   to\
    \ associate security information.\n   This memo describes the use of HMAC-MD5-96\
    \ and HMAC-SHA-96 as the\n   authentication protocols and the use of CBC-DES as\
    \ the privacy\n   protocol.  The User-based Security Model however allows for\
    \ other\n   such protocols to be used instead of or concurrent with these\n  \
    \ protocols.  Therefore, the description of HMAC-MD5-96, HMAC-SHA-96\n   and CBC-DES\
    \ are in separate sections to reflect their self-contained\n   nature and to indicate\
    \ that they can be replaced or supplemented in\n   the future.\n   The key words\
    \ \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\"\
    , \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document\
    \ are to be interpreted as described in [RFC2119].\n"
- title: 1.1. Threats
  contents:
  - "1.1. Threats\n   Several of the classical threats to network protocols are applicable\n\
    \   to the network management problem and therefore would be applicable\n   to\
    \ any SNMP Security Model.  Other threats are not applicable to the\n   network\
    \ management problem.  This section discusses principal\n   threats, secondary\
    \ threats, and threats which are of lesser\n   importance.\n   The principal threats\
    \ against which this SNMP Security Model should\n   provide protection are:\n\
    \   - Modification of Information The modification threat is the danger\n    \
    \ that some unauthorized entity may alter in-transit SNMP messages\n     generated\
    \ on behalf of an authorized principal in such a way as to\n     effect unauthorized\
    \ management operations, including falsifying the\n     value of an object.\n\
    \   - Masquerade The masquerade threat is the danger that management\n     operations\
    \ not authorized for some user may be attempted by\n     assuming the identity\
    \ of another user that has the appropriate\n     authorizations.\n   Two secondary\
    \ threats are also identified.  The Security Model\n   defined in this memo provides\
    \ limited protection against:\n   - Disclosure The disclosure threat is the danger\
    \ of eavesdropping on\n     the exchanges between managed agents and a management\
    \ station.\n     Protecting against this threat may be required as a matter of\
    \ local\n     policy.\n   - Message Stream Modification The SNMP protocol is typically\
    \ based\n     upon a connection-less transport service which may operate over\
    \ any\n     sub-network service.  The re-ordering, delay or replay of messages\n\
    \     can and does occur through the natural operation of many such sub-\n   \
    \  network services.  The message stream modification threat is the\n     danger\
    \ that messages may be maliciously re-ordered, delayed or\n     replayed to an\
    \ extent which is greater than can occur through the\n     natural operation of\
    \ a sub-network service, in order to effect\n     unauthorized management operations.\n\
    \   There are at least two threats that an SNMP Security Model need not\n   protect\
    \ against.  The security protocols defined in this memo do not\n   provide protection\
    \ against:\n   - Denial of Service This SNMP Security Model does not attempt to\n\
    \     address the broad range of attacks by which service on behalf of\n     authorized\
    \ users is denied.  Indeed, such denial-of-service attacks\n     are in many cases\
    \ indistinguishable from the type of network\n     failures with which any viable\
    \ network management protocol must\n     cope as a matter of course.\n   - Traffic\
    \ Analysis This SNMP Security Model does not attempt to\n     address traffic\
    \ analysis attacks.  Indeed, many traffic patterns\n     are predictable - devices\
    \ may be managed on a regular basis by a\n     relatively small number of management\
    \ applications - and therefore\n     there is no significant advantage afforded\
    \ by protecting against\n     traffic analysis.\n"
- title: 1.2. Goals and Constraints
  contents:
  - "1.2. Goals and Constraints\n   Based on the foregoing account of threats in the\
    \ SNMP network\n   management environment, the goals of this SNMP Security Model\
    \ are as\n   follows.\n   1) Provide for verification that each received SNMP\
    \ message has not\n      been modified during its transmission through the network.\n\
    \   2) Provide for verification of the identity of the user on whose\n      behalf\
    \ a received SNMP message claims to have been generated.\n   3) Provide for detection\
    \ of received SNMP messages, which request or\n      contain management information,\
    \ whose time of generation was not\n      recent.\n   4) Provide, when necessary,\
    \ that the contents of each received SNMP\n      message are protected from disclosure.\n\
    \   In addition to the principal goal of supporting secure network\n   management,\
    \ the design of this SNMP Security Model is also influenced\n   by the following\
    \ constraints:\n   1) When the requirements of effective management in times of\
    \ network\n      stress are inconsistent with those of security, the design of\
    \ USM\n      has given preference to the former.\n   2) Neither the security protocol\
    \ nor its underlying security\n      mechanisms should depend upon the ready availability\
    \ of other\n      network services (e.g., Network Time Protocol (NTP) or key\n\
    \      management protocols).\n   3) A security mechanism should entail no changes\
    \ to the basic SNMP\n      network management philosophy.\n"
- title: 1.3. Security Services
  contents:
  - "1.3. Security Services\n   The security services necessary to support the goals\
    \ of this SNMP\n   Security Model are as follows:\n   - Data Integrity is the\
    \ provision of the property that data has not\n     been altered or destroyed\
    \ in an unauthorized manner, nor have data\n     sequences been altered to an\
    \ extent greater than can occur non-\n     maliciously.\n   - Data Origin Authentication\
    \ is the provision of the property that\n     the claimed identity of the user\
    \ on whose behalf received data was\n     originated is corroborated.\n   - Data\
    \ Confidentiality is the provision of the property that\n     information is not\
    \ made available or disclosed to unauthorized\n     individuals, entities, or\
    \ processes.\n   - Message timeliness and limited replay protection is the provision\n\
    \     of the property that a message whose generation time is outside of\n   \
    \  a specified time window is not accepted.  Note that message\n     reordering\
    \ is not dealt with and can occur in normal conditions\n     too.\n   For the\
    \ protocols specified in this memo, it is not possible to\n   assure the specific\
    \ originator of a received SNMP message; rather, it\n   is the user on whose behalf\
    \ the message was originated that is\n   authenticated.\n   For these protocols,\
    \ it not possible to obtain data integrity without\n   data origin authentication,\
    \ nor is it possible to obtain data origin\n   authentication without data integrity.\
    \  Further, there is no\n   provision for data confidentiality without both data\
    \ integrity and\n   data origin authentication.\n   The security protocols used\
    \ in this memo are considered acceptably\n   secure at the time of writing.  However,\
    \ the procedures allow for new\n   authentication and privacy methods to be specified\
    \ at a future time\n   if the need arises.\n"
- title: 1.4. Module Organization
  contents:
  - "1.4. Module Organization\n   The security protocols defined in this memo are\
    \ split in three\n   different modules and each has its specific responsibilities\
    \ such\n   that together they realize the goals and security services described\n\
    \   above:\n   - The authentication module MUST provide for:\n     - Data Integrity,\n\
    \     - Data Origin Authentication,\n   - The timeliness module MUST provide for:\n\
    \     - Protection against message delay or replay (to an extent greater\n   \
    \    than can occur through normal operation).\n   - The privacy module MUST provide\
    \ for\n     - Protection against disclosure of the message payload.\n   The timeliness\
    \ module is fixed for the User-based Security Model\n   while there is provision\
    \ for multiple authentication and/or privacy\n   modules, each of which implements\
    \ a specific authentication or\n   privacy protocol respectively.\n"
- title: 1.4.1. Timeliness Module
  contents:
  - "1.4.1. Timeliness Module\n   Section 3 (Elements of Procedure) uses the timeliness\
    \ values in an\n   SNMP message to do timeliness checking.  The timeliness check\
    \ is only\n   performed if authentication is applied to the message.  Since the\n\
    \   complete message is checked for integrity, we can assume that the\n   timeliness\
    \ values in a message that passes the authentication module\n   are trustworthy.\n"
- title: 1.4.2. Authentication Protocol
  contents:
  - "1.4.2. Authentication Protocol\n   Section 6 describes the HMAC-MD5-96 authentication\
    \ protocol which is\n   the first authentication protocol that MUST be supported\
    \ with the\n   User-based Security Model.  Section 7 describes the HMAC-SHA-96\n\
    \   authentication protocol which is another authentication protocol that\n  \
    \ SHOULD be supported with the User-based Security Model.  In the\n   future additional\
    \ or replacement authentication protocols may be\n   defined as new needs arise.\n\
    \   The User-based Security Model prescribes that, if authentication is\n   used,\
    \ then the complete message is checked for integrity in the\n   authentication\
    \ module.\n   For a message to be authenticated, it needs to pass authentication\n\
    \   check by the authentication module and the timeliness check which is\n   a\
    \ fixed part of this User-based Security model.\n"
- title: 1.4.3. Privacy Protocol
  contents:
  - "1.4.3. Privacy Protocol\n   Section 8 describes the CBC-DES Symmetric Encryption\
    \ Protocol which\n   is the first privacy protocol to be used with the User-based\
    \ Security\n   Model.  In the future additional or replacement privacy protocols\
    \ may\n   be defined as new needs arise.\n   The User-based Security Model prescribes\
    \ that the scopedPDU is\n   protected from disclosure when a message is sent with\
    \ privacy.\n   The User-based Security Model also prescribes that a message needs\
    \ to\n   be authenticated if privacy is in use.\n"
- title: 1.5. Protection against Message Replay, Delay and Redirection
  contents:
  - '1.5. Protection against Message Replay, Delay and Redirection

    '
- title: 1.5.1. Authoritative SNMP Engine
  contents:
  - "1.5.1. Authoritative SNMP Engine\n   In order to protect against message replay,\
    \ delay and redirection,\n   one of the SNMP engines involved in each communication\
    \ is designated\n   to be the authoritative SNMP engine.  When an SNMP message\
    \ contains a\n   payload which expects a response (those messages that contain\
    \ a\n   Confirmed Class PDU [RFC3411]), then the receiver of such messages is\n\
    \   authoritative.  When an SNMP message contains a payload which does\n   not\
    \ expect a response (those messages that contain an Unconfirmed\n   Class PDU\
    \ [RFC3411]), then the sender of such a message is\n   authoritative.\n"
- title: 1.5.2. Mechanisms
  contents:
  - "1.5.2. Mechanisms\n   The following mechanisms are used:\n   1) To protect against\
    \ the threat of message delay or replay (to an\n      extent greater than can\
    \ occur through normal operation), a set of\n      timeliness indicators (for\
    \ the authoritative SNMP engine) are\n      included in each message generated.\
    \  An SNMP engine evaluates the\n      timeliness indicators to determine if a\
    \ received message is\n      recent.  An SNMP engine may evaluate the timeliness\
    \ indicators to\n      ensure that a received message is at least as recent as\
    \ the last\n      message it received from the same source.  A non-authoritative\n\
    \      SNMP engine uses received authentic messages to advance its notion\n  \
    \    of the timeliness indicators at the remote authoritative source.\n      An\
    \ SNMP engine MUST also use a mechanism to match incoming\n      Responses to\
    \ outstanding Requests and it MUST drop any Responses\n      that do not match\
    \ an outstanding request.  For example, a msgID\n      can be inserted in every\
    \ message to cater for this functionality.\n      These mechanisms provide for\
    \ the detection of authenticated\n      messages whose time of generation was\
    \ not recent.\n      This protection against the threat of message delay or replay\
    \ does\n      not imply nor provide any protection against unauthorized deletion\n\
    \      or suppression of messages.  Also, an SNMP engine may not be able\n   \
    \   to detect message reordering if all the messages involved are sent\n     \
    \ within the Time Window interval.  Other mechanisms defined\n      independently\
    \ of the security protocol can also be used to detect\n      the re-ordering replay,\
    \ deletion, or suppression of messages\n      containing Set operations (e.g.,\
    \ the MIB variable snmpSetSerialNo\n      [RFC3418]).\n   2) Verification that\
    \ a message sent to/from one authoritative SNMP\n      engine cannot be replayed\
    \ to/as-if-from another authoritative SNMP\n      engine.\n      Included in each\
    \ message is an identifier unique to the\n      authoritative SNMP engine associated\
    \ with the sender or intended\n      recipient of the message.\n      A message\
    \ containing an Unconfirmed Class PDU sent by an\n      authoritative SNMP engine\
    \ to one non-authoritative SNMP engine can\n      potentially be replayed to another\
    \ non-authoritative SNMP engine.\n      The latter non-authoritative SNMP engine\
    \ might (if it knows about\n      the same userName with the same secrets at the\
    \ authoritative SNMP\n      engine) as a result update its notion of timeliness\
    \ indicators of\n      the authoritative SNMP engine, but that is not considered\
    \ a\n      threat.  In this case, A Report or Response message will be\n     \
    \ discarded by the Message Processing Model, because there should\n      not be\
    \ an outstanding Request message.  A Trap will possibly be\n      accepted.  Again,\
    \ that is not considered a threat, because the\n      communication was authenticated\
    \ and timely.  It is as if the\n      authoritative SNMP engine was configured\
    \ to start sending Traps to\n      the second SNMP engine, which theoretically\
    \ can happen without the\n      knowledge of the second SNMP engine anyway.  Anyway,\
    \ the second\n      SNMP engine may not expect to receive this Trap, but is allowed\
    \ to\n      see the management information contained in it.\n   3) Detection of\
    \ messages which were not recently generated.\n      A set of time indicators\
    \ are included in the message, indicating\n      the time of generation.  Messages\
    \ without recent time indicators\n      are not considered authentic.  In addition,\
    \ an SNMP engine MUST\n      drop any Responses that do not match an outstanding\
    \ request.  This\n      however is the responsibility of the Message Processing\
    \ Model.\n   This memo allows the same user to be defined on multiple SNMP\n \
    \  engines.  Each SNMP engine maintains a value, snmpEngineID, which\n   uniquely\
    \ identifies the SNMP engine.  This value is included in each\n   message sent\
    \ to/from the SNMP engine that is authoritative (see\n   section 1.5.1).  On receipt\
    \ of a message, an authoritative SNMP\n   engine checks the value to ensure that\
    \ it is the intended recipient,\n   and a non-authoritative SNMP engine uses the\
    \ value to ensure that the\n   message is processed using the correct state information.\n\
    \   Each SNMP engine maintains two values, snmpEngineBoots and\n   snmpEngineTime,\
    \ which taken together provide an indication of time at\n   that SNMP engine.\
    \  Both of these values are included in an\n   authenticated message sent to/received\
    \ from that SNMP engine.  On\n   receipt, the values are checked to ensure that\
    \ the indicated\n   timeliness value is within a Time Window of the current time.\
    \  The\n   Time Window represents an administrative upper bound on acceptable\n\
    \   delivery delay for protocol messages.\n   For an SNMP engine to generate a\
    \ message which an authoritative SNMP\n   engine will accept as authentic, and\
    \ to verify that a message\n   received from that authoritative SNMP engine is\
    \ authentic, such an\n   SNMP engine must first achieve timeliness synchronization\
    \ with the\n   authoritative SNMP engine.  See section 2.3.\n"
- title: 1.6. Abstract Service Interfaces
  contents:
  - "1.6. Abstract Service Interfaces\n   Abstract service interfaces have been defined\
    \ to describe the\n   conceptual interfaces between the various subsystems within\
    \ an SNMP\n   entity.  Similarly a set of abstract service interfaces have been\n\
    \   defined within the User-based Security Model (USM) to describe the\n   conceptual\
    \ interfaces between the generic USM services and the\n   self-contained authentication\
    \ and privacy services.\n   These abstract service interfaces are defined by a\
    \ set of primitives\n   that define the services provided and the abstract data\
    \ elements that\n   must be passed when the services are invoked.  This section\
    \ lists the\n   primitives that have been defined for the User-based Security\
    \ Model.\n"
- title: 1.6.1. User-based Security Model Primitives for Authentication
  contents:
  - "1.6.1. User-based Security Model Primitives for Authentication\n   The User-based\
    \ Security Model provides the following internal\n   primitives to pass data back\
    \ and forth between the Security Model\n   itself and the authentication service:\n\
    \   statusInformation =\n     authenticateOutgoingMsg(\n     IN   authKey    \
    \               -- secret key for authentication\n     IN   wholeMsg         \
    \         -- unauthenticated complete message\n     OUT  authenticatedWholeMsg\
    \     -- complete authenticated message\n          )\n   statusInformation =\n\
    \     authenticateIncomingMsg(\n     IN   authKey                   -- secret\
    \ key for authentication\n     IN   authParameters            -- as received on\
    \ the wire\n     IN   wholeMsg                  -- as received on the wire\n \
    \    OUT  authenticatedWholeMsg     -- complete authenticated message\n      \
    \    )\n"
- title: 1.6.2. User-based Security Model Primitives for Privacy
  contents:
  - "1.6.2. User-based Security Model Primitives for Privacy\n   The User-based Security\
    \ Model provides the following internal\n   primitives to pass data back and forth\
    \ between the Security Model\n   itself and the privacy service:\n   statusInformation\
    \ =\n     encryptData(\n     IN    encryptKey               -- secret key for\
    \ encryption\n     IN    dataToEncrypt            -- data to encrypt (scopedPDU)\n\
    \     OUT   encryptedData            -- encrypted data (encryptedPDU)\n     OUT\
    \   privParameters           -- filled in by service provider\n           )\n\
    \   statusInformation =\n     decryptData(\n     IN    decryptKey            \
    \   -- secret key for decrypting\n     IN    privParameters           -- as received\
    \ on the wire\n     IN    encryptedData            -- encrypted data (encryptedPDU)\n\
    \     OUT   decryptedData            -- decrypted data (scopedPDU)\n         \
    \  )\n"
- title: 2. Elements of the Model
  contents:
  - "2. Elements of the Model\n   This section contains definitions required to realize\
    \ the security\n   model defined by this memo.\n"
- title: 2.1. User-based Security Model Users
  contents:
  - "2.1. User-based Security Model Users\n   Management operations using this Security\
    \ Model make use of a defined\n   set of user identities.  For any user on whose\
    \ behalf management\n   operations are authorized at a particular SNMP engine,\
    \ that SNMP\n   engine must have knowledge of that user.  An SNMP engine that\
    \ wishes\n   to communicate with another SNMP engine must also have knowledge\
    \ of a\n   user known to that engine, including knowledge of the applicable\n\
    \   attributes of that user.\n   A user and its attributes are defined as follows:\n\
    \   userName\n      A string representing the name of the user.\n   securityName\n\
    \      A human-readable string representing the user in a format that is\n   \
    \   Security Model independent.  There is a one-to-one relationship\n      between\
    \ userName and securityName.\n   authProtocol\n      An indication of whether\
    \ messages sent on behalf of this user can\n      be authenticated, and if so,\
    \ the type of authentication protocol\n      which is used.  Two such protocols\
    \ are defined in this memo:\n      - the HMAC-MD5-96 authentication protocol.\n\
    \      - the HMAC-SHA-96 authentication protocol.\n   authKey\n      If messages\
    \ sent on behalf of this user can be authenticated, the\n      (private) authentication\
    \ key for use with the authentication\n      protocol.  Note that a user's authentication\
    \ key will normally be\n      different at different authoritative SNMP engines.\
    \  The authKey is\n      not accessible via SNMP.  The length requirements of\
    \ the authKey\n      are defined by the authProtocol in use.\n   authKeyChange\
    \ and authOwnKeyChange\n      The only way to remotely update the authentication\
    \ key.  Does that\n      in a secure manner, so that the update can be completed\
    \ without\n      the need to employ privacy protection.\n   privProtocol\n   \
    \   An indication of whether messages sent on behalf of this user can\n      be\
    \ protected from disclosure, and if so, the type of privacy\n      protocol which\
    \ is used.  One such protocol is defined in this\n      memo:  the CBC-DES Symmetric\
    \ Encryption Protocol.\n   privKey\n      If messages sent on behalf of this user\
    \ can be en/decrypted, the\n      (private) privacy key for use with the privacy\
    \ protocol.  Note\n      that a user's privacy key will normally be different\
    \ at different\n      authoritative SNMP engines.  The privKey is not accessible\
    \ via\n      SNMP.  The length requirements of the privKey are defined by the\n\
    \      privProtocol in use.\n   privKeyChange and privOwnKeyChange\n      The\
    \ only way to remotely update the encryption key.  Does that in\n      a secure\
    \ manner, so that the update can be completed without the\n      need to employ\
    \ privacy protection.\n"
- title: 2.2. Replay Protection
  contents:
  - "2.2. Replay Protection\n   Each SNMP engine maintains three objects:\n   - snmpEngineID,\
    \ which (at least within an administrative domain)\n     uniquely and unambiguously\
    \ identifies an SNMP engine.\n   - snmpEngineBoots, which is a count of the number\
    \ of times the SNMP\n     engine has re-booted/re-initialized since snmpEngineID\
    \ was last\n     configured; and,\n   - snmpEngineTime, which is the number of\
    \ seconds since the\n     snmpEngineBoots counter was last incremented.\n   Each\
    \ SNMP engine is always authoritative with respect to these\n   objects in its\
    \ own SNMP entity.  It is the responsibility of a non-\n   authoritative SNMP\
    \ engine to synchronize with the authoritative SNMP\n   engine, as appropriate.\n\
    \   An authoritative SNMP engine is required to maintain the values of\n   its\
    \ snmpEngineID and snmpEngineBoots in non-volatile storage.\n"
- title: 2.2.1. msgAuthoritativeEngineID
  contents:
  - "2.2.1. msgAuthoritativeEngineID\n   The msgAuthoritativeEngineID value contained\
    \ in an authenticated\n   message is used to defeat attacks in which messages\
    \ from one SNMP\n   engine to another SNMP engine are replayed to a different\
    \ SNMP\n   engine.  It represents the snmpEngineID at the authoritative SNMP\n\
    \   engine involved in the exchange of the message.\n   When an authoritative\
    \ SNMP engine is first installed, it sets its\n   local value of snmpEngineID\
    \ according to a enterprise-specific\n   algorithm (see the definition of the\
    \ Textual Convention for\n   SnmpEngineID in the SNMP Architecture document [RFC3411]).\n"
- title: 2.2.2. msgAuthoritativeEngineBoots and msgAuthoritativeEngineTime
  contents:
  - "2.2.2. msgAuthoritativeEngineBoots and msgAuthoritativeEngineTime\n   The msgAuthoritativeEngineBoots\
    \ and msgAuthoritativeEngineTime values\n   contained in an authenticated message\
    \ are used to defeat attacks in\n   which messages are replayed when they are\
    \ no longer valid.  They\n   represent the snmpEngineBoots and snmpEngineTime\
    \ values at the\n   authoritative SNMP engine involved in the exchange of the\
    \ message.\n   Through use of snmpEngineBoots and snmpEngineTime, there is no\n\
    \   requirement for an SNMP engine to have a non-volatile clock which\n   ticks\
    \ (i.e., increases with the passage of time) even when the\n   SNMP engine is\
    \ powered off.  Rather, each time an SNMP engine\n   re-boots, it retrieves, increments,\
    \ and then stores snmpEngineBoots\n   in non-volatile storage, and resets snmpEngineTime\
    \ to zero.\n   When an SNMP engine is first installed, it sets its local values\
    \ of\n   snmpEngineBoots and snmpEngineTime to zero.  If snmpEngineTime ever\n\
    \   reaches its maximum value (2147483647), then snmpEngineBoots is\n   incremented\
    \ as if the SNMP engine has re-booted and snmpEngineTime is\n   reset to zero\
    \ and starts incrementing again.\n   Each time an authoritative SNMP engine re-boots,\
    \ any SNMP engines\n   holding that authoritative SNMP engine's values of snmpEngineBoots\n\
    \   and snmpEngineTime need to re-synchronize prior to sending correctly\n   authenticated\
    \ messages to that authoritative SNMP engine (see Section\n   2.3 for (re-)synchronization\
    \ procedures).  Note, however, that the\n   procedures do provide for a notification\
    \ to be accepted as authentic\n   by a receiving SNMP engine, when sent by an\
    \ authoritative SNMP engine\n   which has re-booted since the receiving SNMP engine\
    \ last (re-\n   )synchronized.\n   If an authoritative SNMP engine is ever unable\
    \ to determine its\n   latest snmpEngineBoots value, then it must set its snmpEngineBoots\n\
    \   value to 2147483647.\n   Whenever the local value of snmpEngineBoots has the\
    \ value 2147483647\n   it latches at that value and an authenticated message always\
    \ causes\n   an notInTimeWindow authentication failure.\n   In order to reset\
    \ an SNMP engine whose snmpEngineBoots value has\n   reached the value 2147483647,\
    \ manual intervention is required.  The\n   engine must be physically visited\
    \ and re-configured, either with a\n   new snmpEngineID value, or with new secret\
    \ values for the\n   authentication and privacy protocols of all users known to\
    \ that SNMP\n   engine.  Note that even if an SNMP engine re-boots once a second\
    \ that\n   it would still take approximately 68 years before the max value of\n\
    \   2147483647 would be reached.\n"
- title: 2.2.3. Time Window
  contents:
  - "2.2.3. Time Window\n   The Time Window is a value that specifies the window of\
    \ time in which\n   a message generated on behalf of any user is valid.  This\
    \ memo\n   specifies that the same value of the Time Window, 150 seconds, is\n\
    \   used for all users.\n"
- title: 2.3. Time Synchronization
  contents:
  - "2.3. Time Synchronization\n   Time synchronization, required by a non-authoritative\
    \ SNMP engine\n   in order to proceed with authentic communications, has occurred\n\
    \   when the non-authoritative SNMP engine has obtained a local notion\n   of\
    \ the authoritative SNMP engine's values of snmpEngineBoots and\n   snmpEngineTime\
    \ from the authoritative SNMP engine.  These values\n   must be (and remain) within\
    \ the authoritative SNMP engine's Time\n   Window.  So the local notion of the\
    \ authoritative SNMP engine's\n   values must be kept loosely synchronized with\
    \ the values stored\n   at the authoritative SNMP engine.  In addition to keeping\
    \ a local\n   copy of snmpEngineBoots and snmpEngineTime from the authoritative\n\
    \   SNMP engine, a non-authoritative SNMP engine must also keep one\n   local\
    \ variable, latestReceivedEngineTime.  This value records the\n   highest value\
    \ of snmpEngineTime that was received by the\n   non-authoritative SNMP engine\
    \ from the authoritative SNMP engine\n   and is used to eliminate the possibility\
    \ of replaying messages\n   that would prevent the non-authoritative SNMP engine's\
    \ notion of\n   the snmpEngineTime from advancing.\n   A non-authoritative SNMP\
    \ engine must keep local notions of these\n   values (snmpEngineBoots, snmpEngineTime\
    \ and latestReceivedEngineTime)\n   for each authoritative SNMP engine with which\
    \ it wishes to\n   communicate.  Since each authoritative SNMP engine is uniquely\
    \ and\n   unambiguously identified by its value of snmpEngineID, the\n   non-authoritative\
    \ SNMP engine may use this value as a key in order to\n   cache its local notions\
    \ of these values.\n   Time synchronization occurs as part of the procedures of\
    \ receiving an\n   SNMP message (Section 3.2, step 7b).  As such, no explicit\
    \ time\n   synchronization procedure is required by a non-authoritative SNMP\n\
    \   engine.  Note, that whenever the local value of snmpEngineID is\n   changed\
    \ (e.g., through discovery) or when secure communications are\n   first established\
    \ with an authoritative SNMP engine, the local values\n   of snmpEngineBoots and\
    \ latestReceivedEngineTime should be set to\n   zero.  This will cause the time\
    \ synchronization to occur when the\n   next authentic message is received.\n"
- title: 2.4. SNMP Messages Using this Security Model
  contents:
  - "2.4. SNMP Messages Using this Security Model\n   The syntax of an SNMP message\
    \ using this Security Model adheres to\n   the message format defined in the version-specific\
    \ Message Processing\n   Model document (for example [RFC3412]).\n   The field\
    \ msgSecurityParameters in SNMPv3 messages has a data type of\n   OCTET STRING.\
    \  Its value is the BER serialization of the following\n   ASN.1 sequence:\n \
    \  USMSecurityParametersSyntax DEFINITIONS IMPLICIT TAGS ::= BEGIN\n      UsmSecurityParameters\
    \ ::=\n          SEQUENCE {\n           -- global User-based security parameters\n\
    \              msgAuthoritativeEngineID     OCTET STRING,\n              msgAuthoritativeEngineBoots\
    \  INTEGER (0..2147483647),\n              msgAuthoritativeEngineTime   INTEGER\
    \ (0..2147483647),\n              msgUserName                  OCTET STRING (SIZE(0..32)),\n\
    \           -- authentication protocol specific parameters\n              msgAuthenticationParameters\
    \  OCTET STRING,\n           -- privacy protocol specific parameters\n       \
    \       msgPrivacyParameters         OCTET STRING\n          }\n   END\n   The\
    \ fields of this sequence are:\n   - The msgAuthoritativeEngineID specifies the\
    \ snmpEngineID of the\n     authoritative SNMP engine involved in the exchange\
    \ of the message.\n   - The msgAuthoritativeEngineBoots specifies the snmpEngineBoots\
    \ value\n     at the authoritative SNMP engine involved in the exchange of the\n\
    \     message.\n   - The msgAuthoritativeEngineTime specifies the snmpEngineTime\
    \ value\n     at the authoritative SNMP engine involved in the exchange of the\n\
    \     message.\n   - The msgUserName specifies the user (principal) on whose behalf\
    \ the\n     message is being exchanged.  Note that a zero-length userName will\n\
    \     not match any user, but it can be used for snmpEngineID discovery.\n   -\
    \ The msgAuthenticationParameters are defined by the authentication\n     protocol\
    \ in use for the message, as defined by the\n     usmUserAuthProtocol column in\
    \ the user's entry in the usmUserTable.\n   - The msgPrivacyParameters are defined\
    \ by the privacy protocol in use\n     for the message, as defined by the usmUserPrivProtocol\
    \ column in\n     the user's entry in the usmUserTable).\n   See appendix A.4\
    \ for an example of the BER encoding of field\n   msgSecurityParameters.\n"
- title: 2.5. Services provided by the User-based Security Model
  contents:
  - "2.5. Services provided by the User-based Security Model\n   This section describes\
    \ the services provided by the User-based\n   Security Model with their inputs\
    \ and outputs.\n   The services are described as primitives of an abstract service\n\
    \   interface and the inputs and outputs are described as abstract data\n   elements\
    \ as they are passed in these abstract service primitives.\n"
- title: 2.5.1. Services for Generating an Outgoing SNMP Message
  contents:
  - "2.5.1. Services for Generating an Outgoing SNMP Message\n   When the Message\
    \ Processing (MP) Subsystem invokes the User-based\n   Security module to secure\
    \ an outgoing SNMP message, it must use the\n   appropriate service as provided\
    \ by the Security module.  These two\n   services are provided:\n   1) A service\
    \ to generate a Request message.  The abstract service\n      primitive is:\n\
    \      statusInformation =            -- success or errorIndication\n        generateRequestMsg(\n\
    \        IN   messageProcessingModel  -- typically, SNMP version\n        IN \
    \  globalData              -- message header, admin data\n        IN   maxMessageSize\
    \          -- of the sending SNMP entity\n        IN   securityModel         \
    \  -- for the outgoing message\n        IN   securityEngineID        -- authoritative\
    \ SNMP entity\n        IN   securityName            -- on behalf of this principal\n\
    \        IN   securityLevel           -- Level of Security requested\n       \
    \ IN   scopedPDU               -- message (plaintext) payload\n        OUT  securityParameters\
    \      -- filled in by Security Module\n        OUT  wholeMsg                --\
    \ complete generated message\n        OUT  wholeMsgLength          -- length of\
    \ generated message\n             )\n   2) A service to generate a Response message.\
    \  The abstract service\n      primitive is:\n      statusInformation =      \
    \      -- success or errorIndication\n        generateResponseMsg(\n        IN\
    \   messageProcessingModel  -- typically, SNMP version\n        IN   globalData\
    \              -- message header, admin data\n        IN   maxMessageSize    \
    \      -- of the sending SNMP entity\n        IN   securityModel           --\
    \ for the outgoing message\n        IN   securityEngineID        -- authoritative\
    \ SNMP entity\n        IN   securityName            -- on behalf of this principal\n\
    \        IN   securityLevel           -- Level of Security requested\n       \
    \ IN   scopedPDU               -- message (plaintext) payload\n        IN   securityStateReference\
    \  -- reference to security state\n                                     -- information\
    \ from original\n                                     -- request\n        OUT\
    \  securityParameters      -- filled in by Security Module\n        OUT  wholeMsg\
    \                -- complete generated message\n        OUT  wholeMsgLength  \
    \        -- length of generated message\n             )\n   The abstract data\
    \ elements passed as parameters in the abstract\n   service primitives are as\
    \ follows:\n   statusInformation\n      An indication of whether the encoding\
    \ and securing of the message\n      was successful.  If not it is an indication\
    \ of the problem.\n   messageProcessingModel\n      The SNMP version number for\
    \ the message to be generated.  This\n      data is not used by the User-based\
    \ Security module.\n   globalData\n      The message header (i.e., its administrative\
    \ information).  This\n      data is not used by the User-based Security module.\n\
    \   maxMessageSize\n      The maximum message size as included in the message.\
    \  This data is\n      not used by the User-based Security module.\n   securityParameters\n\
    \      These are the security parameters.  They will be filled in by the\n   \
    \   User-based Security module.\n   securityModel\n      The securityModel in\
    \ use.  Should be User-based Security Model.\n      This data is not used by the\
    \ User-based Security module.\n   securityName\n      Together with the snmpEngineID\
    \ it identifies a row in the\n      usmUserTablethat is to be used for securing\
    \ the message.  The\n      securityName has a format that is independent of the\
    \ Security\n      Model.  In case of a response this parameter is ignored and\
    \ the\n      value from the cache is used.\n   securityLevel\n      The Level\
    \ of Security from which the User-based Security module\n      determines if the\
    \ message needs to be protected from disclosure\n      and if the message needs\
    \ to be authenticated.\n   securityEngineID\n      The snmpEngineID of the authoritative\
    \ SNMP engine to which a\n      dateRequest message is to be sent.  In case of\
    \ a response it is\n      implied to be the processing SNMP engine's snmpEngineID\
    \ and so if\n      it is specified, then it is ignored.\n   scopedPDU\n      The\
    \ message payload.  The data is opaque as far as the User-based\n      Security\
    \ Model is concerned.\n   securityStateReference\n      A handle/reference to\
    \ cachedSecurityData to be used when securing\n      an outgoing Response message.\
    \  This is the exact same\n      handle/reference as it was generated by the User-based\
    \ Security\n      module when processing the incoming Request message to which\
    \ this\n      is the Response message.\n   wholeMsg\n      The fully encoded and\
    \ secured message ready for sending on the\n      wire.\n   wholeMsgLength\n \
    \     The length of the encoded and secured message (wholeMsg).\n   Upon completion\
    \ of the process, the User-based Security module\n   returns statusInformation.\
    \  If the process was successful, the\n   completed message with privacy and authentication\
    \ applied if such was\n   requested by the specified securityLevel is returned.\
    \  If the process\n   was not successful, then an errorIndication is returned.\n"
- title: 2.5.2. Services for Processing an Incoming SNMP Message
  contents:
  - "2.5.2. Services for Processing an Incoming SNMP Message\n   When the Message\
    \ Processing (MP) Subsystem invokes the User-based\n   Security module to verify\
    \ proper security of an incoming message, it\n   must use the service provided\
    \ for an incoming message.  The abstract\n   service primitive is:\n   statusInformation\
    \ =             -- errorIndication or success\n                              \
    \     -- error counter OID/value if error\n     processIncomingMsg(\n     IN \
    \  messageProcessingModel   -- typically, SNMP version\n     IN   maxMessageSize\
    \           -- of the sending SNMP entity\n     IN   securityParameters      \
    \ -- for the received message\n     IN   securityModel            -- for the received\
    \ message\n     IN   securityLevel            -- Level of Security\n     IN  \
    \ wholeMsg                 -- as received on the wire\n     IN   wholeMsgLength\
    \           -- length as received on the wire\n     OUT  securityEngineID    \
    \     -- authoritative SNMP entity\n     OUT  securityName             -- identification\
    \ of the principal\n     OUT  scopedPDU,               -- message (plaintext)\
    \ payload\n     OUT  maxSizeResponseScopedPDU -- maximum size of the Response\
    \ PDU\n     OUT  securityStateReference   -- reference to security state\n   \
    \       )                        -- information, needed for response\n   The abstract\
    \ data elements passed as parameters in the abstract\n   service primitives are\
    \ as follows:\n   statusInformation\n      An indication of whether the process\
    \ was successful or not.  If\n      not, then the statusInformation includes the\
    \ OID and the value of\n      the error counter that was incremented.\n   messageProcessingModel\n\
    \      The SNMP version number as received in the message.  This data is\n   \
    \   not used by the User-based Security module.\n   maxMessageSize\n      The\
    \ maximum message size as included in the message.  The User-bas\n      User-based\
    \ Security module uses this value to calculate the\n      maxSizeResponseScopedPDU.\n\
    \   securityParameters\n      These are the security parameters as received in\
    \ the message.\n   securityModel\n      The securityModel in use.  Should be the\
    \ User-based Security\n      Model.  This data is not used by the User-based Security\
    \ module.\n   securityLevel\n      The Level of Security from which the User-based\
    \ Security module\n      determines if the message needs to be protected from\
    \ disclosure\n      and if the message needs to be authenticated.\n   wholeMsg\n\
    \      The whole message as it was received.\n   wholeMsgLength\n      The length\
    \ of the message as it was received (wholeMsg).\n   securityEngineID\n      The\
    \ snmpEngineID that was extracted from the field\n      msgAuthoritativeEngineID\
    \ and that was used to lookup the secrets\n      in the usmUserTable.\n   securityName\n\
    \      The security name representing the user on whose behalf the\n      message\
    \ was received.  The securityName has a format that is\n      independent of the\
    \ Security Model.\n   scopedPDU\n      The message payload.  The data is opaque\
    \ as far as the User-based\n      Security Model is concerned.\n   maxSizeResponseScopedPDU\n\
    \      The maximum size of a scopedPDU to be included in a possible\n      Response\
    \ message.  The User-based Security module calculates this\n      size based on\
    \ the msgMaxSize (as received in the message) and the\n      space required for\
    \ the message header (including the\n      securityParameters) for such a Response\
    \ message.\n   securityStateReference\n      A handle/reference to cachedSecurityData\
    \ to be used when securing\n      an outgoing Response message.  When the Message\
    \ Processing\n      Subsystem calls the User-based Security module to generate\
    \ a\n      response to this incoming message it must pass this\n      handle/reference.\n\
    \   Upon completion of the process, the User-based Security module\n   returns\
    \ statusInformation and, if the process was successful, the\n   additional data\
    \ elements for further processing of the message.  If\n   the process was not\
    \ successful, then an errorIndication, possibly\n   with a OID and value pair\
    \ of an error counter that was incremented.\n"
- title: 2.6. Key Localization Algorithm.
  contents:
  - "2.6. Key Localization Algorithm.\n   A localized key is a secret key shared between\
    \ a user U and one\n   authoritative SNMP engine E.  Even though a user may have\
    \ only one\n   password and therefore one key for the whole network, the actual\n\
    \   secrets shared between the user and each authoritative SNMP engine\n   will\
    \ be different.  This is achieved by key localization [Localized-\n   key].\n\
    \   First, if a user uses a password, then the user's password is\n   converted\
    \ into a key Ku using one of the two algorithms described in\n   Appendices A.2.1\
    \ and A.2.2.\n   To convert key Ku into a localized key Kul of user U at the\n\
    \   authoritative SNMP engine E, one appends the snmpEngineID of the\n   authoritative\
    \ SNMP engine to the key Ku and then appends the key Ku\n   to the result, thus\
    \ enveloping the snmpEngineID within the two copies\n   of user's key Ku.  Then\
    \ one runs a secure hash function (which one\n   depends on the authentication\
    \ protocol defined for this user U at\n   authoritative SNMP engine E; this document\
    \ defines two authentication\n   protocols with their associated algorithms based\
    \ on MD5 and SHA).\n   The output of the hash-function is the localized key Kul\
    \ for user U\n   at the authoritative SNMP engine E.\n"
- title: 3. Elements of Procedure
  contents:
  - "3. Elements of Procedure\n   This section describes the security related procedures\
    \ followed by an\n   SNMP engine when processing SNMP messages according to the\
    \ User-based\n   Security Model.\n"
- title: 3.1. Generating an Outgoing SNMP Message
  contents:
  - "3.1. Generating an Outgoing SNMP Message\n   This section describes the procedure\
    \ followed by an SNMP engine\n   whenever it generates a message containing a\
    \ management operation\n   (like a request, a response, a notification, or a report)\
    \ on behalf\n   of a user, with a particular securityLevel.\n   1) a) If any securityStateReference\
    \ is passed (Response or Report\n         message), then information concerning\
    \ the user is extracted\n         from the cachedSecurityData.  The cachedSecurityData\
    \ can now be\n         discarded.  The securityEngineID is set to the local\n\
    \         snmpEngineID.  The securityLevel is set to the value specified\n   \
    \      by the calling module.\n         Otherwise,\n      b) based on the securityName,\
    \ information concerning the user at\n         the destination snmpEngineID, specified\
    \ by the\n         securityEngineID, is extracted from the Local Configuration\n\
    \         Datastore (LCD, usmUserTable).  If information about the user\n    \
    \     is absent from the LCD, then an error indication\n         (unknownSecurityName)\
    \ is returned to the calling module.\n   2) If the securityLevel specifies that\
    \ the message is to be protected\n      from disclosure, but the user does not\
    \ support both an\n      authentication and a privacy protocol then the message\
    \ cannot be\n      sent.  An error indication (unsupportedSecurityLevel) is returned\n\
    \      to the calling module.\n   3) If the securityLevel specifies that the message\
    \ is to be\n      authenticated, but the user does not support an authentication\n\
    \      protocol, then the message cannot be sent.  An error indication\n     \
    \ (unsupportedSecurityLevel) is returned to the calling module.\n   4) a) If the\
    \ securityLevel specifies that the message is to be\n         protected from disclosure,\
    \ then the octet sequence representing\n         the serialized scopedPDU is encrypted\
    \ according to the user's\n         privacy protocol.  To do so a call is made\
    \ to the privacy\n         module that implements the user's privacy protocol\
    \ according to\n         the abstract primitive:\n         statusInformation =\
    \       -- success or failure\n           encryptData(\n           IN    encryptKey\
    \        -- user's localized privKey\n           IN    dataToEncrypt     -- serialized\
    \ scopedPDU\n           OUT   encryptedData     -- serialized encryptedPDU\n \
    \          OUT   privParameters    -- serialized privacy parameters\n        \
    \         )\n         statusInformation\n           indicates if the encryption\
    \ process was successful or not.\n         encryptKey\n           the user's localized\
    \ private privKey is the secret key that\n           can be used by the encryption\
    \ algorithm.\n         dataToEncrypt\n           the serialized scopedPDU is the\
    \ data to be encrypted.\n         encryptedData\n           the encryptedPDU represents\
    \ the encrypted scopedPDU, encoded\n           as an OCTET STRING.\n         privParameters\n\
    \           the privacy parameters, encoded as an OCTET STRING.\n         If the\
    \ privacy module returns failure, then the message cannot\n         be sent and\
    \ an error indication (encryptionError) is returned\n         to the calling module.\n\
    \         If the privacy module returns success, then the returned\n         privParameters\
    \ are put into the msgPrivacyParameters field of\n         the securityParameters\
    \ and the encryptedPDU serves as the\n         payload of the message being prepared.\n\
    \         Otherwise,\n      b) If the securityLevel specifies that the message\
    \ is not to be be\n         protected from disclosure, then a zero-length OCTET\
    \ STRING is\n         encoded into the msgPrivacyParameters field of the\n   \
    \      securityParameters and the plaintext scopedPDU serves as the\n        \
    \ payload of the message being prepared.\n   5) The securityEngineID is encoded\
    \ as an OCTET STRING into the\n      msgAuthoritativeEngineID field of the securityParameters.\
    \  Note\n      that an empty (zero length) securityEngineID is OK for a Request\n\
    \      message, because that will cause the remote (authoritative) SNMP\n    \
    \  engine to return a Report PDU with the proper securityEngineID\n      included\
    \ in the msgAuthoritativeEngineID in the securityParameters\n      of that returned\
    \ Report PDU.\n   6) a) If the securityLevel specifies that the message is to\
    \ be\n         authenticated, then the current values of snmpEngineBoots and\n\
    \         snmpEngineTime corresponding to the securityEngineID from the\n    \
    \     LCD are used.\n         Otherwise,\n      b) If this is a Response or Report\
    \ message, then the current value\n         of snmpEngineBoots and snmpEngineTime\
    \ corresponding to the\n         local snmpEngineID from the LCD are used.\n \
    \        Otherwise,\n      c) If this is a Request message, then a zero value\
    \ is used for\n         both snmpEngineBoots and snmpEngineTime.  This zero value\
    \ gets\n         used if snmpEngineID is empty.\n         The values are encoded\
    \ as INTEGER respectively into the\n         msgAuthoritativeEngineBoots and msgAuthoritativeEngineTime\n\
    \         fields of the securityParameters.\n   7) The userName is encoded as\
    \ an OCTET STRING into the msgUserName\n      field of the securityParameters.\n\
    \   8) a) If the securityLevel specifies that the message is to be\n         authenticated,\
    \ the message is authenticated according to the\n         user's authentication\
    \ protocol.  To do so a call is made to the\n         authentication module that\
    \ implements the user's authentication\n         protocol according to the abstract\
    \ service primitive:\n         statusInformation =\n           authenticateOutgoingMsg(\n\
    \           IN  authKey               -- the user's localized authKey\n      \
    \     IN  wholeMsg              -- unauthenticated message\n           OUT authenticatedWholeMsg\
    \ -- authenticated complete message\n               )\n         statusInformation\n\
    \           indicates if authentication was successful or not.\n         authKey\n\
    \           the user's localized private authKey is the secret key that\n    \
    \       can be used by the authentication algorithm.\n         wholeMsg\n    \
    \       the complete serialized message to be authenticated.\n         authenticatedWholeMsg\n\
    \           the same as the input given to the authenticateOutgoingMsg\n     \
    \      service, but with msgAuthenticationParameters properly\n           filled\
    \ in.\n         If the authentication module returns failure, then the message\n\
    \         cannot be sent and an error indication (authenticationFailure)\n   \
    \      is returned to the calling module.\n         If the authentication module\
    \ returns success, then the\n         msgAuthenticationParameters field is put\
    \ into the\n         securityParameters and the authenticatedWholeMsg represents\
    \ the\n         serialization of the authenticated message being prepared.\n \
    \        Otherwise,\n      b) If the securityLevel specifies that the message\
    \ is not to be\n         authenticated then a zero-length OCTET STRING is encoded\
    \ into\n         the msgAuthenticationParameters field of the\n         securityParameters.\
    \  The wholeMsg is now serialized and then\n         represents the unauthenticated\
    \ message being prepared.\n   9) The completed message with its length is returned\
    \ to the calling\n      module with the statusInformation set to success.\n"
- title: 3.2. Processing an Incoming SNMP Message
  contents:
  - "3.2. Processing an Incoming SNMP Message\n   This section describes the procedure\
    \ followed by an SNMP engine\n   whenever it receives a message containing a management\
    \ operation on\n   behalf of a user, with a particular securityLevel.\n   To simplify\
    \ the elements of procedure, the release of state\n   information is not always\
    \ explicitly specified.  As a general rule,\n   if state information is available\
    \ when a message gets discarded, the\n   state information should also be released.\
    \  Also, an error indication\n   can return an OID and value for an incremented\
    \ counter and optionally\n   a value for securityLevel, and values for contextEngineID\
    \ or\n   contextName for the counter.  In addition, the securityStateReference\n\
    \   data is returned if any such information is available at the point\n   where\
    \ the error is detected.\n   1)  If the received securityParameters is not the\
    \ serialization\n       (according to the conventions of [RFC3417]) of an OCTET\
    \ STRING\n       formatted according to the UsmSecurityParameters defined in\n\
    \       section 2.4, then the snmpInASNParseErrs counter [RFC3418] is\n      \
    \ incremented, and an error indication (parseError) is returned to\n       the\
    \ calling module.  Note that we return without the OID and\n       value of the\
    \ incremented counter, because in this case there is\n       not enough information\
    \ to generate a Report PDU.\n   2)  The values of the security parameter fields\
    \ are extracted from\n       the securityParameters.  The securityEngineID to\
    \ be returned to\n       the caller is the value of the msgAuthoritativeEngineID\
    \ field.\n       The cachedSecurityData is prepared and a securityStateReference\n\
    \       is prepared to reference this data.  Values to be cached are:\n      \
    \    msgUserName\n   3)  If the value of the msgAuthoritativeEngineID field in\
    \ the\n       securityParameters is unknown then:\n       a) a non-authoritative\
    \ SNMP engine that performs discovery may\n          optionally create a new entry\
    \ in its Local Configuration\n          Datastore (LCD) and continue processing;\n\
    \          or\n       b) the usmStatsUnknownEngineIDs counter is incremented,\
    \ and an\n          error indication (unknownEngineID) together with the OID and\n\
    \          value of the incremented counter is returned to the calling\n     \
    \     module.\n       Note in the event that a zero-length, or other illegally\
    \ sized\n       msgAuthoritativeEngineID is received, b) should be chosen to\n\
    \       facilitate engineID discovery.  Otherwise the choice between a)\n    \
    \   and b) is an implementation issue.\n   4)  Information about the value of\
    \ the msgUserName and\n       msgAuthoritativeEngineID fields is extracted from\
    \ the Local\n       Configuration Datastore (LCD, usmUserTable).  If no information\n\
    \       is available for the user, then the usmStatsUnknownUserNames\n       counter\
    \ is incremented and an error indication\n       (unknownSecurityName) together\
    \ with the OID and value of the\n       incremented counter is returned to the\
    \ calling module.\n   5)  If the information about the user indicates that it\
    \ does not\n       support the securityLevel requested by the caller, then the\n\
    \       usmStatsUnsupportedSecLevels counter is incremented and an error\n   \
    \    indication (unsupportedSecurityLevel) together with the OID and\n       value\
    \ of the incremented counter is returned to the calling\n       module.\n   6)\
    \  If the securityLevel specifies that the message is to be\n       authenticated,\
    \ then the message is authenticated according to the\n       user's authentication\
    \ protocol.  To do so a call is made to the\n       authentication module that\
    \ implements the user's authentication\n       protocol according to the abstract\
    \ service primitive:\n       statusInformation =          -- success or failure\n\
    \         authenticateIncomingMsg(\n         IN   authKey               -- the\
    \ user's localized authKey\n         IN   authParameters        -- as received\
    \ on the wire\n         IN   wholeMsg              -- as received on the wire\n\
    \         OUT  authenticatedWholeMsg -- checked for authentication\n         \
    \     )\n       statusInformation\n         indicates if authentication was successful\
    \ or not.\n       authKey\n         the user's localized private authKey is the\
    \ secret key that\n         can be used by the authentication algorithm.\n   \
    \    wholeMsg\n         the complete serialized message to be authenticated.\n\
    \       authenticatedWholeMsg\n         the same as the input given to the authenticateIncomingMsg\n\
    \         service, but after authentication has been checked.\n       If the authentication\
    \ module returns failure, then the message\n       cannot be trusted, so the usmStatsWrongDigests\
    \ counter is\n       incremented and an error indication (authenticationFailure)\n\
    \       together with the OID and value of the incremented counter is\n      \
    \ returned to the calling module.\n       If the authentication module returns\
    \ success, then the message is\n       authentic and can be trusted so processing\
    \ continues.\n   7)  If the securityLevel indicates an authenticated message,\
    \ then the\n       local values of snmpEngineBoots, snmpEngineTime and\n     \
    \  latestReceivedEngineTime corresponding to the value of the\n       msgAuthoritativeEngineID\
    \ field are extracted from the Local\n       Configuration Datastore.\n      \
    \ a) If the extracted value of msgAuthoritativeEngineID is the same\n        \
    \  as the value of snmpEngineID of the processing SNMP engine\n          (meaning\
    \ this is the authoritative SNMP engine), then if any\n          of the following\
    \ conditions is true, then the message is\n          considered to be outside\
    \ of the Time Window:\n          - the local value of snmpEngineBoots is 2147483647;\n\
    \          - the value of the msgAuthoritativeEngineBoots field differs\n    \
    \        from the local value of snmpEngineBoots; or,\n          - the value of\
    \ the msgAuthoritativeEngineTime field differs\n            from the local notion\
    \ of snmpEngineTime by more than +/- 150\n            seconds.\n          If the\
    \ message is considered to be outside of the Time Window\n          then the usmStatsNotInTimeWindows\
    \ counter is incremented and\n          an error indication (notInTimeWindow)\
    \ together with the OID,\n          the value of the incremented counter, and\
    \ an indication that\n          the error must be reported with a securityLevel\
    \ of authNoPriv,\n          is returned to the calling module\n       b) If the\
    \ extracted value of msgAuthoritativeEngineID is not the\n          same as the\
    \ value snmpEngineID of the processing SNMP engine\n          (meaning this is\
    \ not the authoritative SNMP engine), then:\n          1) if at least one of the\
    \ following conditions is true:\n             - the extracted value of the msgAuthoritativeEngineBoots\n\
    \               field is greater than the local notion of the value of\n     \
    \          snmpEngineBoots; or,\n             - the extracted value of the msgAuthoritativeEngineBoots\n\
    \               field is equal to the local notion of the value of\n         \
    \      snmpEngineBoots, and the extracted value of\n               msgAuthoritativeEngineTime\
    \ field is greater than the\n               value of latestReceivedEngineTime,\n\
    \             then the LCD entry corresponding to the extracted value of\n   \
    \          the msgAuthoritativeEngineID field is updated, by setting:\n      \
    \       - the local notion of the value of snmpEngineBoots to the\n          \
    \     value of the msgAuthoritativeEngineBoots field,\n             - the local\
    \ notion of the value of snmpEngineTime to the\n               value of the msgAuthoritativeEngineTime\
    \ field, and\n             - the latestReceivedEngineTime to the value of the\
    \ value of\n               the msgAuthoritativeEngineTime field.\n          2)\
    \ if any of the following conditions is true, then the\n             message is\
    \ considered to be outside of the Time Window:\n             - the local notion\
    \ of the value of snmpEngineBoots is\n               2147483647;\n           \
    \  - the value of the msgAuthoritativeEngineBoots field is\n               less\
    \ than the local notion of the value of\n               snmpEngineBoots; or,\n\
    \             - the value of the msgAuthoritativeEngineBoots field is\n      \
    \         equal to the local notion of the value of snmpEngineBoots\n        \
    \       and the value of the msgAuthoritativeEngineTime field is\n           \
    \    more than 150 seconds less than the local notion of the\n               value\
    \ of snmpEngineTime.\n             If the message is considered to be outside\
    \ of the Time\n             Window then an error indication (notInTimeWindow)\
    \ is\n             returned to the calling module.\n             Note that this\
    \ means that a too old (possibly replayed)\n             message has been detected\
    \ and is deemed unauthentic.\n             Note that this procedure allows for\
    \ the value of\n             msgAuthoritativeEngineBoots in the message to be\
    \ greater\n             than the local notion of the value of snmpEngineBoots\
    \ to\n             allow for received messages to be accepted as authentic\n \
    \            when received from an authoritative SNMP engine that has\n      \
    \       re-booted since the receiving SNMP engine last\n             (re-)synchronized.\n\
    \   8)  a) If the securityLevel indicates that the message was protected\n   \
    \       from disclosure, then the OCTET STRING representing the\n          encryptedPDU\
    \ is decrypted according to the user's privacy\n          protocol to obtain an\
    \ unencrypted serialized scopedPDU value.\n          To do so a call is made to\
    \ the privacy module that implements\n          the user's privacy protocol according\
    \ to the abstract\n          primitive:\n          statusInformation =       --\
    \ success or failure\n            decryptData(\n            IN    decryptKey \
    \       -- the user's localized privKey\n            IN    privParameters    --\
    \ as received on the wire\n            IN    encryptedData     -- encryptedPDU\
    \ as received\n            OUT   decryptedData     -- serialized decrypted scopedPDU\n\
    \                  )\n          statusInformation\n             indicates if the\
    \ decryption process was successful or not.\n          decryptKey\n          \
    \   the user's localized private privKey is the secret key that\n            \
    \ can be used by the decryption algorithm.\n          privParameters\n       \
    \      the msgPrivacyParameters, encoded as an OCTET STRING.\n          encryptedData\n\
    \             the encryptedPDU represents the encrypted scopedPDU,\n         \
    \    encoded as an OCTET STRING.\n          decryptedData\n             the serialized\
    \ scopedPDU if decryption is successful.\n          If the privacy module returns\
    \ failure, then the message can\n          not be processed, so the usmStatsDecryptionErrors\
    \ counter is\n          incremented and an error indication (decryptionError)\
    \ together\n          with the OID and value of the incremented counter is returned\n\
    \          to the calling module.\n          If the privacy module returns success,\
    \ then the decrypted\n          scopedPDU is the message payload to be returned\
    \ to the calling\n          module.\n          Otherwise,\n       b) The scopedPDU\
    \ component is assumed to be in plain text and is\n          the message payload\
    \ to be returned to the calling module.\n   9)  The maxSizeResponseScopedPDU is\
    \ calculated.  This is the maximum\n       size allowed for a scopedPDU for a\
    \ possible Response message.\n       Provision is made for a message header that\
    \ allows the same\n       securityLevel as the received Request.\n   10) The securityName\
    \ for the user is retrieved from the usmUserTable.\n   11) The security data is\
    \ cached as cachedSecurityData, so that a\n       possible response to this message\
    \ can and will use the same\n       authentication and privacy secrets.  Information\
    \ to be\n       saved/cached is as follows:\n          msgUserName,\n        \
    \  usmUserAuthProtocol, usmUserAuthKey\n          usmUserPrivProtocol, usmUserPrivKey\n\
    \   12) The statusInformation is set to success and a return is made to\n    \
    \   the calling module passing back the OUT parameters as specified\n       in\
    \ the processIncomingMsg primitive.\n"
- title: 4. Discovery
  contents:
  - "4. Discovery\n   The User-based Security Model requires that a discovery process\n\
    \   obtains sufficient information about other SNMP engines in order to\n   communicate\
    \ with them.  Discovery requires an non-authoritative SNMP\n   engine to learn\
    \ the authoritative SNMP engine's snmpEngineID value\n   before communication\
    \ may proceed.  This may be accomplished by\n   generating a Request message with\
    \ a securityLevel of noAuthNoPriv, a\n   msgUserName of zero-length, a msgAuthoritativeEngineID\
    \ value of zero\n   length, and the varBindList left empty.  The response to this\
    \ message\n   will be a Report message containing the snmpEngineID of the\n  \
    \ authoritative SNMP engine as the value of the\n   msgAuthoritativeEngineID field\
    \ within the msgSecurityParameters\n   field.  It contains a Report PDU with the\
    \ usmStatsUnknownEngineIDs\n   counter in the varBindList.\n   If authenticated\
    \ communication is required, then the discovery\n   process should also establish\
    \ time synchronization with the\n   authoritative SNMP engine.  This may be accomplished\
    \ by sending an\n   authenticated Request message with the value of\n   msgAuthoritativeEngineID\
    \ set to the newly learned snmpEngineID and\n   with the values of msgAuthoritativeEngineBoots\
    \ and\n   msgAuthoritativeEngineTime set to zero.  For an authenticated Request\n\
    \   message, a valid userName must be used in the msgUserName field.  The\n  \
    \ response to this authenticated message will be a Report message\n   containing\
    \ the up to date values of the authoritative SNMP engine's\n   snmpEngineBoots\
    \ and snmpEngineTime as the value of the\n   msgAuthoritativeEngineBoots and msgAuthoritativeEngineTime\
    \ fields\n   respectively.  It also contains the usmStatsNotInTimeWindows counter\n\
    \   in the varBindList of the Report PDU.  The time synchronization then\n   happens\
    \ automatically as part of the procedures in section 3.2 step\n   7b.  See also\
    \ section 2.3.\n"
- title: 5. Definitions
  contents:
  - '5. Definitions

    '
- title: SNMP-USER-BASED-SM-MIB DEFINITIONS ::= BEGIN
  contents:
  - 'SNMP-USER-BASED-SM-MIB DEFINITIONS ::= BEGIN

    '
- title: IMPORTS
  contents:
  - "IMPORTS\n    MODULE-IDENTITY, OBJECT-TYPE,\n    OBJECT-IDENTITY,\n    snmpModules,\
    \ Counter32                FROM SNMPv2-SMI\n    TEXTUAL-CONVENTION, TestAndIncr,\n\
    \    RowStatus, RowPointer,\n    StorageType, AutonomousType           FROM SNMPv2-TC\n\
    \    MODULE-COMPLIANCE, OBJECT-GROUP       FROM SNMPv2-CONF\n    SnmpAdminString,\
    \ SnmpEngineID,\n    snmpAuthProtocols, snmpPrivProtocols  FROM SNMP-FRAMEWORK-MIB;\n"
- title: snmpUsmMIB MODULE-IDENTITY
  contents:
  - "snmpUsmMIB MODULE-IDENTITY\n    LAST-UPDATED \"200210160000Z\"            --\
    \ 16 Oct 2002, midnight\n    ORGANIZATION \"SNMPv3 Working Group\"\n    CONTACT-INFO\
    \ \"WG-email:   snmpv3@lists.tislabs.com\n                  Subscribe:  majordomo@lists.tislabs.com\n\
    \                              In msg body:  subscribe snmpv3\n              \
    \    Chair:      Russ Mundy\n                              Network Associates\
    \ Laboratories\n                  postal:     15204 Omega Drive, Suite 300\n \
    \                             Rockville, MD 20850-4601\n                     \
    \         USA\n                  email:      mundy@tislabs.com\n             \
    \     phone:      +1 301-947-7107\n                  Co-Chair:   David Harrington\n\
    \                              Enterasys Networks\n                  Postal: \
    \    35 Industrial Way\n                              P. O. Box 5004\n       \
    \                       Rochester, New Hampshire 03866-5005\n                \
    \              USA\n                  EMail:      dbh@enterasys.com\n        \
    \          Phone:      +1 603-337-2614\n                  Co-editor   Uri Blumenthal\n\
    \                              Lucent Technologies\n                  postal:\
    \     67 Whippany Rd.\n                              Whippany, NJ 07981\n    \
    \                          USA\n                  email:      uri@lucent.com\n\
    \                  phone:      +1-973-386-2163\n                  Co-editor: \
    \ Bert Wijnen\n                              Lucent Technologies\n           \
    \       postal:     Schagen 33\n                              3461 GL Linschoten\n\
    \                              Netherlands\n                  email:      bwijnen@lucent.com\n\
    \                  phone:      +31-348-480-685\n                 \"\n    DESCRIPTION\
    \  \"The management information definitions for the\n                  SNMP User-based\
    \ Security Model.\n                  Copyright (C) The Internet Society (2002).\
    \ This\n                  version of this MIB module is part of RFC 3414;\n  \
    \                see the RFC itself for full legal notices.\n                \
    \ \"\n"
- title: --  Revision history
  contents:
  - "--  Revision history\n    REVISION     \"200210160000Z\"          -- 16 Oct 2002,\
    \ midnight\n    DESCRIPTION  \"Changes in this revision:\n                  -\
    \ Updated references and contact info.\n                  - Clarification to usmUserCloneFrom\
    \ DESCRIPTION\n                    clause\n                  - Fixed 'command\
    \ responder' into 'command generator'\n                    in last para of DESCRIPTION\
    \ clause of\n                    usmUserTable.\n                  This revision\
    \ published as RFC3414.\n                 \"\n    REVISION     \"199901200000Z\"\
    \          -- 20 Jan 1999, midnight\n    DESCRIPTION  \"Clarifications, published\
    \ as RFC2574\"\n    REVISION     \"199711200000Z\"          -- 20 Nov 1997, midnight\n\
    \    DESCRIPTION  \"Initial version, published as RFC2274\"\n    ::= { snmpModules\
    \ 15 }\n"
- title: -- Administrative assignments ****************************************
  contents:
  - '-- Administrative assignments ****************************************

    '
- title: usmMIBObjects     OBJECT IDENTIFIER ::= { snmpUsmMIB 1 }
  contents:
  - 'usmMIBObjects     OBJECT IDENTIFIER ::= { snmpUsmMIB 1 }

    '
- title: usmMIBConformance OBJECT IDENTIFIER ::= { snmpUsmMIB 2 }
  contents:
  - 'usmMIBConformance OBJECT IDENTIFIER ::= { snmpUsmMIB 2 }

    '
- title: -- Identification of Authentication and Privacy Protocols ************
  contents:
  - '-- Identification of Authentication and Privacy Protocols ************

    '
- title: usmNoAuthProtocol OBJECT-IDENTITY
  contents:
  - "usmNoAuthProtocol OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION\
    \  \"No Authentication Protocol.\"\n    ::= { snmpAuthProtocols 1 }\n"
- title: usmHMACMD5AuthProtocol OBJECT-IDENTITY
  contents:
  - "usmHMACMD5AuthProtocol OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION\
    \  \"The HMAC-MD5-96 Digest Authentication Protocol.\"\n    REFERENCE    \"- H.\
    \ Krawczyk, M. Bellare, R. Canetti HMAC:\n                    Keyed-Hashing for\
    \ Message Authentication,\n                    RFC2104, Feb 1997.\n          \
    \        - Rivest, R., Message Digest Algorithm MD5, RFC1321.\n              \
    \   \"\n    ::= { snmpAuthProtocols 2 }\n"
- title: usmHMACSHAAuthProtocol OBJECT-IDENTITY
  contents:
  - "usmHMACSHAAuthProtocol OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION\
    \  \"The HMAC-SHA-96 Digest Authentication Protocol.\"\n    REFERENCE    \"- H.\
    \ Krawczyk, M. Bellare, R. Canetti, HMAC:\n                    Keyed-Hashing for\
    \ Message Authentication,\n                    RFC2104, Feb 1997.\n          \
    \        - Secure Hash Algorithm. NIST FIPS 180-1.\n                 \"\n    ::=\
    \ { snmpAuthProtocols 3 }\n"
- title: usmNoPrivProtocol OBJECT-IDENTITY
  contents:
  - "usmNoPrivProtocol OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION\
    \  \"No Privacy Protocol.\"\n    ::= { snmpPrivProtocols 1 }\n"
- title: usmDESPrivProtocol OBJECT-IDENTITY
  contents:
  - "usmDESPrivProtocol OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION\
    \  \"The CBC-DES Symmetric Encryption Protocol.\"\n    REFERENCE    \"- Data Encryption\
    \ Standard, National Institute of\n                    Standards and Technology.\
    \  Federal Information\n                    Processing Standard (FIPS) Publication\
    \ 46-1.\n                    Supersedes FIPS Publication 46,\n               \
    \     (January, 1977; reaffirmed January, 1988).\n                  - Data Encryption\
    \ Algorithm, American National\n                    Standards Institute.  ANSI\
    \ X3.92-1981,\n                    (December, 1980).\n                  - DES\
    \ Modes of Operation, National Institute of\n                    Standards and\
    \ Technology.  Federal Information\n                    Processing Standard (FIPS)\
    \ Publication 81,\n                    (December, 1980).\n                  -\
    \ Data Encryption Algorithm - Modes of Operation,\n                    American\
    \ National Standards Institute.\n                    ANSI X3.106-1983, (May 1983).\n\
    \                 \"\n    ::= { snmpPrivProtocols 2 }\n"
- title: -- Textual Conventions ***********************************************
  contents:
  - '-- Textual Conventions ***********************************************

    '
- title: KeyChange ::=     TEXTUAL-CONVENTION
  contents:
  - "KeyChange ::=     TEXTUAL-CONVENTION\n   STATUS         current\n   DESCRIPTION\n\
    \         \"Every definition of an object with this syntax must identify\n   \
    \       a protocol P, a secret key K, and a hash algorithm H\n          that produces\
    \ output of L octets.\n          The object's value is a manager-generated, partially-random\n\
    \          value which, when modified, causes the value of the secret\n      \
    \    key K, to be modified via a one-way function.\n          The value of an\
    \ instance of this object is the concatenation\n          of two components: first\
    \ a 'random' component and then a\n          'delta' component.\n          The\
    \ lengths of the random and delta components\n          are given by the corresponding\
    \ value of the protocol P;\n          if P requires K to be a fixed length, the\
    \ length of both the\n          random and delta components is that fixed length;\
    \ if P\n          allows the length of K to be variable up to a particular\n \
    \         maximum length, the length of the random component is that\n       \
    \   maximum length and the length of the delta component is any\n          length\
    \ less than or equal to that maximum length.\n          For example, usmHMACMD5AuthProtocol\
    \ requires K to be a fixed\n          length of 16 octets and L - of 16 octets.\n\
    \          usmHMACSHAAuthProtocol requires K to be a fixed length of\n       \
    \   20 octets and L - of 20 octets. Other protocols may define\n          other\
    \ sizes, as deemed appropriate.\n          When a requester wants to change the\
    \ old key K to a new\n          key keyNew on a remote entity, the 'random' component\
    \ is\n          obtained from either a true random generator, or from a\n    \
    \      pseudorandom generator, and the 'delta' component is\n          computed\
    \ as follows:\n           - a temporary variable is initialized to the existing\
    \ value\n             of K;\n           - if the length of the keyNew is greater\
    \ than L octets,\n             then:\n              - the random component is\
    \ appended to the value of the\n                temporary variable, and the result\
    \ is input to the\n                the hash algorithm H to produce a digest value,\
    \ and\n                the temporary variable is set to this digest value;\n \
    \             - the value of the temporary variable is XOR-ed with\n         \
    \       the first (next) L-octets (16 octets in case of MD5)\n               \
    \ of the keyNew to produce the first (next) L-octets\n                (16 octets\
    \ in case of MD5) of the 'delta' component.\n              - the above two steps\
    \ are repeated until the unused\n                portion of the keyNew component\
    \ is L octets or less,\n           - the random component is appended to the value\
    \ of the\n             temporary variable, and the result is input to the\n  \
    \           hash algorithm H to produce a digest value;\n           - this digest\
    \ value, truncated if necessary to be the same\n             length as the unused\
    \ portion of the keyNew, is XOR-ed\n             with the unused portion of the\
    \ keyNew to produce the\n             (final portion of the) 'delta' component.\n\
    \           For example, using MD5 as the hash algorithm H:\n              iterations\
    \ = (lenOfDelta - 1)/16; /* integer division */\n              temp = keyOld;\n\
    \              for (i = 0; i < iterations; i++) {\n                  temp = MD5\
    \ (temp || random);\n                  delta[i*16 .. (i*16)+15] =\n          \
    \               temp XOR keyNew[i*16 .. (i*16)+15];\n              }\n       \
    \       temp = MD5 (temp || random);\n              delta[i*16 .. lenOfDelta-1]\
    \ =\n                     temp XOR keyNew[i*16 .. lenOfDelta-1];\n          The\
    \ 'random' and 'delta' components are then concatenated as\n          described\
    \ above, and the resulting octet string is sent to\n          the recipient as\
    \ the new value of an instance of this object.\n          At the receiver side,\
    \ when an instance of this object is set\n          to a new value, then a new\
    \ value of K is computed as follows:\n           - a temporary variable is initialized\
    \ to the existing value\n             of K;\n           - if the length of the\
    \ delta component is greater than L\n             octets, then:\n            \
    \  - the random component is appended to the value of the\n                temporary\
    \ variable, and the result is input to the\n                hash algorithm H to\
    \ produce a digest value, and the\n                temporary variable is set to\
    \ this digest value;\n              - the value of the temporary variable is XOR-ed\
    \ with\n                the first (next) L-octets (16 octets in case of MD5)\n\
    \                of the delta component to produce the first (next)\n        \
    \        L-octets (16 octets in case of MD5) of the new value\n              \
    \  of K.\n              - the above two steps are repeated until the unused\n\
    \                portion of the delta component is L octets or less,\n       \
    \    - the random component is appended to the value of the\n             temporary\
    \ variable, and the result is input to the\n             hash algorithm H to produce\
    \ a digest value;\n           - this digest value, truncated if necessary to be\
    \ the same\n             length as the unused portion of the delta component,\
    \ is\n             XOR-ed with the unused portion of the delta component to\n\
    \             produce the (final portion of the) new value of K.\n           For\
    \ example, using MD5 as the hash algorithm H:\n              iterations = (lenOfDelta\
    \ - 1)/16; /* integer division */\n              temp = keyOld;\n            \
    \  for (i = 0; i < iterations; i++) {\n                  temp = MD5 (temp || random);\n\
    \                  keyNew[i*16 .. (i*16)+15] =\n                         temp\
    \ XOR delta[i*16 .. (i*16)+15];\n              }\n              temp = MD5 (temp\
    \ || random);\n              keyNew[i*16 .. lenOfDelta-1] =\n                \
    \     temp XOR delta[i*16 .. lenOfDelta-1];\n          The value of an object\
    \ with this syntax, whenever it is\n          retrieved by the management protocol,\
    \ is always the zero\n          length string.\n          Note that the keyOld\
    \ and keyNew are the localized keys.\n          Note that it is probably wise\
    \ that when an SNMP entity sends\n          a SetRequest to change a key, that\
    \ it keeps a copy of the old\n          key until it has confirmed that the key\
    \ change actually\n          succeeded.\n         \"\n    SYNTAX       OCTET STRING\n"
- title: -- Statistics for the User-based Security Model **********************
  contents:
  - '-- Statistics for the User-based Security Model **********************

    '
- title: usmStats         OBJECT IDENTIFIER ::= { usmMIBObjects 1 }
  contents:
  - 'usmStats         OBJECT IDENTIFIER ::= { usmMIBObjects 1 }

    '
- title: usmStatsUnsupportedSecLevels OBJECT-TYPE
  contents:
  - "usmStatsUnsupportedSecLevels OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS\
    \   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of\
    \ packets received by the SNMP\n                 engine which were dropped because\
    \ they requested a\n                 securityLevel that was unknown to the SNMP\
    \ engine\n                 or otherwise unavailable.\n                \"\n   \
    \ ::= { usmStats 1 }\n"
- title: usmStatsNotInTimeWindows OBJECT-TYPE
  contents:
  - "usmStatsNotInTimeWindows OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS\
    \   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of\
    \ packets received by the SNMP\n                 engine which were dropped because\
    \ they appeared\n                 outside of the authoritative SNMP engine's window.\n\
    \                \"\n    ::= { usmStats 2 }\n"
- title: usmStatsUnknownUserNames OBJECT-TYPE
  contents:
  - "usmStatsUnknownUserNames OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS\
    \   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of\
    \ packets received by the SNMP\n                 engine which were dropped because\
    \ they referenced a\n                 user that was not known to the SNMP engine.\n\
    \                \"\n    ::= { usmStats 3 }\n"
- title: usmStatsUnknownEngineIDs OBJECT-TYPE
  contents:
  - "usmStatsUnknownEngineIDs OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS\
    \   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of\
    \ packets received by the SNMP\n                 engine which were dropped because\
    \ they referenced an\n                 snmpEngineID that was not known to the\
    \ SNMP engine.\n                \"\n    ::= { usmStats 4 }\n"
- title: usmStatsWrongDigests OBJECT-TYPE
  contents:
  - "usmStatsWrongDigests OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS\
    \   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of\
    \ packets received by the SNMP\n                 engine which were dropped because\
    \ they didn't\n                 contain the expected digest value.\n         \
    \       \"\n    ::= { usmStats 5 }\n"
- title: usmStatsDecryptionErrors OBJECT-TYPE
  contents:
  - "usmStatsDecryptionErrors OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS\
    \   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of\
    \ packets received by the SNMP\n                 engine which were dropped because\
    \ they could not be\n                 decrypted.\n                \"\n    ::=\
    \ { usmStats 6 }\n"
- title: -- The usmUser Group ************************************************
  contents:
  - '-- The usmUser Group ************************************************

    '
- title: usmUser          OBJECT IDENTIFIER ::= { usmMIBObjects 2 }
  contents:
  - 'usmUser          OBJECT IDENTIFIER ::= { usmMIBObjects 2 }

    '
- title: usmUserSpinLock  OBJECT-TYPE
  contents:
  - "usmUserSpinLock  OBJECT-TYPE\n    SYNTAX       TestAndIncr\n    MAX-ACCESS  \
    \ read-write\n    STATUS       current\n    DESCRIPTION \"An advisory lock used\
    \ to allow several cooperating\n                 Command Generator Applications\
    \ to coordinate their\n                 use of facilities to alter secrets in\
    \ the\n                 usmUserTable.\n                \"\n    ::= { usmUser 1\
    \ }\n"
- title: -- The table of valid users for the User-based Security Model ********
  contents:
  - '-- The table of valid users for the User-based Security Model ********

    '
- title: usmUserTable     OBJECT-TYPE
  contents:
  - "usmUserTable     OBJECT-TYPE\n    SYNTAX       SEQUENCE OF UsmUserEntry\n   \
    \ MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION \"The\
    \ table of users configured in the SNMP engine's\n                 Local Configuration\
    \ Datastore (LCD).\n                 To create a new user (i.e., to instantiate\
    \ a new\n                 conceptual row in this table), it is recommended to\n\
    \                 follow this procedure:\n                   1)  GET(usmUserSpinLock.0)\
    \ and save in sValue.\n                   2)  SET(usmUserSpinLock.0=sValue,\n\
    \                           usmUserCloneFrom=templateUser,\n                 \
    \          usmUserStatus=createAndWait)\n                       You should use\
    \ a template user to clone from\n                       which has the proper auth/priv\
    \ protocol defined.\n                 If the new user is to use privacy:\n   \
    \                3)  generate the keyChange value based on the secret\n      \
    \                 privKey of the clone-from user and the secret key\n        \
    \               to be used for the new user. Let us call this\n              \
    \         pkcValue.\n                   4)  GET(usmUserSpinLock.0) and save in\
    \ sValue.\n                   5)  SET(usmUserSpinLock.0=sValue,\n            \
    \               usmUserPrivKeyChange=pkcValue\n                           usmUserPublic=randomValue1)\n\
    \                   6)  GET(usmUserPulic) and check it has randomValue1.\n   \
    \                    If not, repeat steps 4-6.\n                 If the new user\
    \ will never use privacy:\n                   7)  SET(usmUserPrivProtocol=usmNoPrivProtocol)\n\
    \                 If the new user is to use authentication:\n                \
    \   8)  generate the keyChange value based on the secret\n                   \
    \    authKey of the clone-from user and the secret key\n                     \
    \  to be used for the new user. Let us call this\n                       akcValue.\n\
    \                   9)  GET(usmUserSpinLock.0) and save in sValue.\n         \
    \          10) SET(usmUserSpinLock.0=sValue,\n                           usmUserAuthKeyChange=akcValue\n\
    \                           usmUserPublic=randomValue2)\n                   11)\
    \ GET(usmUserPulic) and check it has randomValue2.\n                       If\
    \ not, repeat steps 9-11.\n                 If the new user will never use authentication:\n\
    \                   12) SET(usmUserAuthProtocol=usmNoAuthProtocol)\n         \
    \        Finally, activate the new user:\n                   13) SET(usmUserStatus=active)\n\
    \                 The new user should now be available and ready to be\n     \
    \            used for SNMPv3 communication. Note however that access\n       \
    \          to MIB data must be provided via configuration of the\n           \
    \      SNMP-VIEW-BASED-ACM-MIB.\n                 The use of usmUserSpinlock is\
    \ to avoid conflicts with\n                 another SNMP command generator application\
    \ which may\n                 also be acting on the usmUserTable.\n          \
    \      \"\n    ::= { usmUser 2 }\n"
- title: usmUserEntry     OBJECT-TYPE
  contents:
  - "usmUserEntry     OBJECT-TYPE\n    SYNTAX       UsmUserEntry\n    MAX-ACCESS \
    \  not-accessible\n    STATUS       current\n    DESCRIPTION \"A user configured\
    \ in the SNMP engine's Local\n                 Configuration Datastore (LCD) for\
    \ the User-based\n                 Security Model.\n                \"\n    INDEX\
    \       { usmUserEngineID,\n                  usmUserName\n                }\n\
    \    ::= { usmUserTable 1 }\n"
- title: UsmUserEntry ::= SEQUENCE
  contents:
  - "UsmUserEntry ::= SEQUENCE\n    {\n        usmUserEngineID         SnmpEngineID,\n\
    \        usmUserName             SnmpAdminString,\n        usmUserSecurityName\
    \     SnmpAdminString,\n        usmUserCloneFrom        RowPointer,\n        usmUserAuthProtocol\
    \     AutonomousType,\n        usmUserAuthKeyChange    KeyChange,\n        usmUserOwnAuthKeyChange\
    \ KeyChange,\n        usmUserPrivProtocol     AutonomousType,\n        usmUserPrivKeyChange\
    \    KeyChange,\n        usmUserOwnPrivKeyChange KeyChange,\n        usmUserPublic\
    \           OCTET STRING,\n        usmUserStorageType      StorageType,\n    \
    \    usmUserStatus           RowStatus\n    }\n"
- title: usmUserEngineID  OBJECT-TYPE
  contents:
  - "usmUserEngineID  OBJECT-TYPE\n    SYNTAX       SnmpEngineID\n    MAX-ACCESS \
    \  not-accessible\n    STATUS       current\n    DESCRIPTION \"An SNMP engine's\
    \ administratively-unique identifier.\n                 In a simple agent, this\
    \ value is always that agent's\n                 own snmpEngineID value.\n   \
    \              The value can also take the value of the snmpEngineID\n       \
    \          of a remote SNMP engine with which this user can\n                \
    \ communicate.\n                \"\n    ::= { usmUserEntry 1 }\n"
- title: usmUserName      OBJECT-TYPE
  contents:
  - "usmUserName      OBJECT-TYPE\n    SYNTAX       SnmpAdminString (SIZE(1..32))\n\
    \    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION \"\
    A human readable string representing the name of\n                 the user.\n\
    \                 This is the (User-based Security) Model dependent\n        \
    \         security ID.\n                \"\n    ::= { usmUserEntry 2 }\n"
- title: usmUserSecurityName OBJECT-TYPE
  contents:
  - "usmUserSecurityName OBJECT-TYPE\n    SYNTAX       SnmpAdminString\n    MAX-ACCESS\
    \   read-only\n    STATUS       current\n    DESCRIPTION \"A human readable string\
    \ representing the user in\n                 Security Model independent format.\n\
    \                 The default transformation of the User-based Security\n    \
    \             Model dependent security ID to the securityName and\n          \
    \       vice versa is the identity function so that the\n                 securityName\
    \ is the same as the userName.\n                \"\n    ::= { usmUserEntry 3 }\n"
- title: usmUserCloneFrom OBJECT-TYPE
  contents:
  - "usmUserCloneFrom OBJECT-TYPE\n    SYNTAX       RowPointer\n    MAX-ACCESS   read-create\n\
    \    STATUS       current\n    DESCRIPTION \"A pointer to another conceptual row\
    \ in this\n                 usmUserTable.  The user in this other conceptual\n\
    \                 row is called the clone-from user.\n                 When a\
    \ new user is created (i.e., a new conceptual\n                 row is instantiated\
    \ in this table), the privacy and\n                 authentication parameters\
    \ of the new user must be\n                 cloned from its clone-from user. These\
    \ parameters are:\n                   - authentication protocol (usmUserAuthProtocol)\n\
    \                   - privacy protocol (usmUserPrivProtocol)\n               \
    \  They will be copied regardless of what the current\n                 value\
    \ is.\n                 Cloning also causes the initial values of the secret\n\
    \                 authentication key (authKey) and the secret encryption\n   \
    \              key (privKey) of the new user to be set to the same\n         \
    \        values as the corresponding secrets of the clone-from\n             \
    \    user to allow the KeyChange process to occur as\n                 required\
    \ during user creation.\n                 The first time an instance of this object\
    \ is set by\n                 a management operation (either at or after its\n\
    \                 instantiation), the cloning process is invoked.\n          \
    \       Subsequent writes are successful but invoke no\n                 action\
    \ to be taken by the receiver.\n                 The cloning process fails with\
    \ an 'inconsistentName'\n                 error if the conceptual row representing\
    \ the\n                 clone-from user does not exist or is not in an active\n\
    \                 state when the cloning process is invoked.\n               \
    \  When this object is read, the ZeroDotZero OID\n                 is returned.\n\
    \                \"\n    ::= { usmUserEntry 4 }\n"
- title: usmUserAuthProtocol OBJECT-TYPE
  contents:
  - "usmUserAuthProtocol OBJECT-TYPE\n    SYNTAX       AutonomousType\n    MAX-ACCESS\
    \   read-create\n    STATUS       current\n    DESCRIPTION \"An indication of\
    \ whether messages sent on behalf of\n                 this user to/from the SNMP\
    \ engine identified by\n                 usmUserEngineID, can be authenticated,\
    \ and if so,\n                 the type of authentication protocol which is used.\n\
    \                 An instance of this object is created concurrently\n       \
    \          with the creation of any other object instance for\n              \
    \   the same user (i.e., as part of the processing of\n                 the set\
    \ operation which creates the first object\n                 instance in the same\
    \ conceptual row).\n                 If an initial set operation (i.e. at row\
    \ creation time)\n                 tries to set a value for an unknown or unsupported\n\
    \                 protocol, then a 'wrongValue' error must be returned.\n    \
    \             The value will be overwritten/set when a set operation\n       \
    \          is performed on the corresponding instance of\n                 usmUserCloneFrom.\n\
    \                 Once instantiated, the value of such an instance of\n      \
    \           this object can only be changed via a set operation to\n         \
    \        the value of the usmNoAuthProtocol.\n                 If a set operation\
    \ tries to change the value of an\n                 existing instance of this\
    \ object to any value other\n                 than usmNoAuthProtocol, then an\
    \ 'inconsistentValue'\n                 error must be returned.\n            \
    \     If a set operation tries to set the value to the\n                 usmNoAuthProtocol\
    \ while the usmUserPrivProtocol value\n                 in the same row is not\
    \ equal to usmNoPrivProtocol,\n                 then an 'inconsistentValue' error\
    \ must be returned.\n                 That means that an SNMP command generator\
    \ application\n                 must first ensure that the usmUserPrivProtocol\
    \ is set\n                 to the usmNoPrivProtocol value before it can set\n\
    \                 the usmUserAuthProtocol value to usmNoAuthProtocol.\n      \
    \          \"\n    DEFVAL      { usmNoAuthProtocol }\n    ::= { usmUserEntry 5\
    \ }\n"
- title: usmUserAuthKeyChange OBJECT-TYPE
  contents:
  - "usmUserAuthKeyChange OBJECT-TYPE\n    SYNTAX       KeyChange   -- typically (SIZE\
    \ (0 | 32)) for HMACMD5\n                             -- typically (SIZE (0 |\
    \ 40)) for HMACSHA\n    MAX-ACCESS   read-create\n    STATUS       current\n \
    \   DESCRIPTION \"An object, which when modified, causes the secret\n        \
    \         authentication key used for messages sent on behalf\n              \
    \   of this user to/from the SNMP engine identified by\n                 usmUserEngineID,\
    \ to be modified via a one-way\n                 function.\n                 The\
    \ associated protocol is the usmUserAuthProtocol.\n                 The associated\
    \ secret key is the user's secret\n                 authentication key (authKey).\
    \ The associated hash\n                 algorithm is the algorithm used by the\
    \ user's\n                 usmUserAuthProtocol.\n                 When creating\
    \ a new user, it is an 'inconsistentName'\n                 error for a set operation\
    \ to refer to this object\n                 unless it is previously or concurrently\
    \ initialized\n                 through a set operation on the corresponding instance\n\
    \                 of usmUserCloneFrom.\n                 When the value of the\
    \ corresponding usmUserAuthProtocol\n                 is usmNoAuthProtocol, then\
    \ a set is successful, but\n                 effectively is a no-op.\n       \
    \          When this object is read, the zero-length (empty)\n               \
    \  string is returned.\n                 The recommended way to do a key change\
    \ is as follows:\n                   1) GET(usmUserSpinLock.0) and save in sValue.\n\
    \                   2) generate the keyChange value based on the old\n       \
    \               (existing) secret key and the new secret key,\n              \
    \        let us call this kcValue.\n                 If you do the key change\
    \ on behalf of another user:\n                   3) SET(usmUserSpinLock.0=sValue,\n\
    \                          usmUserAuthKeyChange=kcValue\n                    \
    \      usmUserPublic=randomValue)\n                 If you do the key change for\
    \ yourself:\n                   4) SET(usmUserSpinLock.0=sValue,\n           \
    \               usmUserOwnAuthKeyChange=kcValue\n                          usmUserPublic=randomValue)\n\
    \                 If you get a response with error-status of noError,\n      \
    \           then the SET succeeded and the new key is active.\n              \
    \   If you do not get a response, then you can issue a\n                 GET(usmUserPublic)\
    \ and check if the value is equal\n                 to the randomValue you did\
    \ send in the SET. If so, then\n                 the key change succeeded and\
    \ the new key is active\n                 (probably the response got lost). If\
    \ not, then the SET\n                 request probably never reached the target\
    \ and so you\n                 can start over with the procedure above.\n    \
    \            \"\n    DEFVAL      { ''H }    -- the empty string\n    ::= { usmUserEntry\
    \ 6 }\n"
- title: usmUserOwnAuthKeyChange OBJECT-TYPE
  contents:
  - "usmUserOwnAuthKeyChange OBJECT-TYPE\n    SYNTAX       KeyChange   -- typically\
    \ (SIZE (0 | 32)) for HMACMD5\n                             -- typically (SIZE\
    \ (0 | 40)) for HMACSHA\n    MAX-ACCESS   read-create\n    STATUS       current\n\
    \    DESCRIPTION \"Behaves exactly as usmUserAuthKeyChange, with one\n       \
    \          notable difference: in order for the set operation\n              \
    \   to succeed, the usmUserName of the operation\n                 requester must\
    \ match the usmUserName that\n                 indexes the row which is targeted\
    \ by this\n                 operation.\n                 In addition, the USM\
    \ security model must be\n                 used for this operation.\n        \
    \         The idea here is that access to this column can be\n               \
    \  public, since it will only allow a user to change\n                 his own\
    \ secret authentication key (authKey).\n                 Note that this can only\
    \ be done once the row is active.\n                 When a set is received and\
    \ the usmUserName of the\n                 requester is not the same as the umsUserName\
    \ that\n                 indexes the row which is targeted by this operation,\n\
    \                 then a 'noAccess' error must be returned.\n                \
    \ When a set is received and the security model in use\n                 is not\
    \ USM, then a 'noAccess' error must be returned.\n                \"\n    DEFVAL\
    \      { ''H }    -- the empty string\n    ::= { usmUserEntry 7 }\n"
- title: usmUserPrivProtocol OBJECT-TYPE
  contents:
  - "usmUserPrivProtocol OBJECT-TYPE\n    SYNTAX       AutonomousType\n    MAX-ACCESS\
    \   read-create\n    STATUS       current\n    DESCRIPTION \"An indication of\
    \ whether messages sent on behalf of\n                 this user to/from the SNMP\
    \ engine identified by\n                 usmUserEngineID, can be protected from\
    \ disclosure,\n                 and if so, the type of privacy protocol which\
    \ is used.\n                 An instance of this object is created concurrently\n\
    \                 with the creation of any other object instance for\n       \
    \          the same user (i.e., as part of the processing of\n               \
    \  the set operation which creates the first object\n                 instance\
    \ in the same conceptual row).\n                 If an initial set operation (i.e.\
    \ at row creation time)\n                 tries to set a value for an unknown\
    \ or unsupported\n                 protocol, then a 'wrongValue' error must be\
    \ returned.\n                 The value will be overwritten/set when a set operation\n\
    \                 is performed on the corresponding instance of\n            \
    \     usmUserCloneFrom.\n                 Once instantiated, the value of such\
    \ an instance of\n                 this object can only be changed via a set operation\
    \ to\n                 the value of the usmNoPrivProtocol.\n                 If\
    \ a set operation tries to change the value of an\n                 existing instance\
    \ of this object to any value other\n                 than usmNoPrivProtocol,\
    \ then an 'inconsistentValue'\n                 error must be returned.\n    \
    \             Note that if any privacy protocol is used, then you\n          \
    \       must also use an authentication protocol. In other\n                 words,\
    \ if usmUserPrivProtocol is set to anything else\n                 than usmNoPrivProtocol,\
    \ then the corresponding instance\n                 of usmUserAuthProtocol cannot\
    \ have a value of\n                 usmNoAuthProtocol. If it does, then an\n \
    \                'inconsistentValue' error must be returned.\n               \
    \ \"\n    DEFVAL      { usmNoPrivProtocol }\n    ::= { usmUserEntry 8 }\n"
- title: usmUserPrivKeyChange OBJECT-TYPE
  contents:
  - "usmUserPrivKeyChange OBJECT-TYPE\n    SYNTAX       KeyChange  -- typically (SIZE\
    \ (0 | 32)) for DES\n    MAX-ACCESS   read-create\n    STATUS       current\n\
    \    DESCRIPTION \"An object, which when modified, causes the secret\n       \
    \          encryption key used for messages sent on behalf\n                 of\
    \ this user to/from the SNMP engine identified by\n                 usmUserEngineID,\
    \ to be modified via a one-way\n                 function.\n                 The\
    \ associated protocol is the usmUserPrivProtocol.\n                 The associated\
    \ secret key is the user's secret\n                 privacy key (privKey). The\
    \ associated hash\n                 algorithm is the algorithm used by the user's\n\
    \                 usmUserAuthProtocol.\n                 When creating a new user,\
    \ it is an 'inconsistentName'\n                 error for a set operation to refer\
    \ to this object\n                 unless it is previously or concurrently initialized\n\
    \                 through a set operation on the corresponding instance\n    \
    \             of usmUserCloneFrom.\n                 When the value of the corresponding\
    \ usmUserPrivProtocol\n                 is usmNoPrivProtocol, then a set is successful,\
    \ but\n                 effectively is a no-op.\n                 When this object\
    \ is read, the zero-length (empty)\n                 string is returned.\n   \
    \              See the description clause of usmUserAuthKeyChange for\n      \
    \           a recommended procedure to do a key change.\n                \"\n\
    \    DEFVAL      { ''H }    -- the empty string\n    ::= { usmUserEntry 9 }\n"
- title: usmUserOwnPrivKeyChange OBJECT-TYPE
  contents:
  - "usmUserOwnPrivKeyChange OBJECT-TYPE\n    SYNTAX       KeyChange  -- typically\
    \ (SIZE (0 | 32)) for DES\n    MAX-ACCESS   read-create\n    STATUS       current\n\
    \    DESCRIPTION \"Behaves exactly as usmUserPrivKeyChange, with one\n       \
    \          notable difference: in order for the Set operation\n              \
    \   to succeed, the usmUserName of the operation\n                 requester must\
    \ match the usmUserName that indexes\n                 the row which is targeted\
    \ by this operation.\n                 In addition, the USM security model must\
    \ be\n                 used for this operation.\n                 The idea here\
    \ is that access to this column can be\n                 public, since it will\
    \ only allow a user to change\n                 his own secret privacy key (privKey).\n\
    \                 Note that this can only be done once the row is active.\n  \
    \               When a set is received and the usmUserName of the\n          \
    \       requester is not the same as the umsUserName that\n                 indexes\
    \ the row which is targeted by this operation,\n                 then a 'noAccess'\
    \ error must be returned.\n                 When a set is received and the security\
    \ model in use\n                 is not USM, then a 'noAccess' error must be returned.\n\
    \                \"\n    DEFVAL      { ''H }    -- the empty string\n    ::= {\
    \ usmUserEntry 10 }\n"
- title: usmUserPublic    OBJECT-TYPE
  contents:
  - "usmUserPublic    OBJECT-TYPE\n    SYNTAX       OCTET STRING (SIZE(0..32))\n \
    \   MAX-ACCESS   read-create\n    STATUS       current\n    DESCRIPTION \"A publicly-readable\
    \ value which can be written as part\n                 of the procedure for changing\
    \ a user's secret\n                 authentication and/or privacy key, and later\
    \ read to\n                 determine whether the change of the secret was\n \
    \                effected.\n                \"\n    DEFVAL      { ''H }  -- the\
    \ empty string\n    ::= { usmUserEntry 11 }\n"
- title: usmUserStorageType OBJECT-TYPE
  contents:
  - "usmUserStorageType OBJECT-TYPE\n    SYNTAX       StorageType\n    MAX-ACCESS\
    \   read-create\n    STATUS       current\n    DESCRIPTION \"The storage type\
    \ for this conceptual row.\n                 Conceptual rows having the value\
    \ 'permanent' must\n                 allow write-access at a minimum to:\n   \
    \              - usmUserAuthKeyChange, usmUserOwnAuthKeyChange\n             \
    \      and usmUserPublic for a user who employs\n                   authentication,\
    \ and\n                 - usmUserPrivKeyChange, usmUserOwnPrivKeyChange\n    \
    \               and usmUserPublic for a user who employs\n                   privacy.\n\
    \                 Note that any user who employs authentication or\n         \
    \        privacy must allow its secret(s) to be updated and\n                \
    \ thus cannot be 'readOnly'.\n                 If an initial set operation tries\
    \ to set the value to\n                 'readOnly' for a user who employs authentication\
    \ or\n                 privacy, then an 'inconsistentValue' error must be\n  \
    \               returned.  Note that if the value has been previously\n      \
    \           set (implicit or explicit) to any value, then the rules\n        \
    \         as defined in the StorageType Textual Convention apply.\n          \
    \       It is an implementation issue to decide if a SET for\n               \
    \  a readOnly or permanent row is accepted at all. In some\n                 contexts\
    \ this may make sense, in others it may not. If\n                 a SET for a\
    \ readOnly or permanent row is not accepted\n                 at all, then a 'wrongValue'\
    \ error must be returned.\n                \"\n    DEFVAL      { nonVolatile }\n\
    \    ::= { usmUserEntry 12 }\n"
- title: usmUserStatus    OBJECT-TYPE
  contents:
  - "usmUserStatus    OBJECT-TYPE\n    SYNTAX       RowStatus\n    MAX-ACCESS   read-create\n\
    \    STATUS       current\n    DESCRIPTION \"The status of this conceptual row.\n\
    \                 Until instances of all corresponding columns are\n         \
    \        appropriately configured, the value of the\n                 corresponding\
    \ instance of the usmUserStatus column\n                 is 'notReady'.\n    \
    \             In particular, a newly created row for a user who\n            \
    \     employs authentication, cannot be made active until the\n              \
    \   corresponding usmUserCloneFrom and usmUserAuthKeyChange\n                \
    \ have been set.\n                 Further, a newly created row for a user who\
    \ also\n                 employs privacy, cannot be made active until the\n  \
    \               usmUserPrivKeyChange has been set.\n                 The RowStatus\
    \ TC [RFC2579] requires that this\n                 DESCRIPTION clause states\
    \ under which circumstances\n                 other objects in this row can be\
    \ modified:\n                 The value of this object has no effect on whether\n\
    \                 other objects in this conceptual row can be modified,\n    \
    \             except for usmUserOwnAuthKeyChange and\n                 usmUserOwnPrivKeyChange.\
    \ For these 2 objects, the\n                 value of usmUserStatus MUST be active.\n\
    \                \"\n    ::= { usmUserEntry 13 }\n"
- title: -- Conformance Information *******************************************
  contents:
  - '-- Conformance Information *******************************************

    '
- title: usmMIBCompliances OBJECT IDENTIFIER ::= { usmMIBConformance 1 }
  contents:
  - 'usmMIBCompliances OBJECT IDENTIFIER ::= { usmMIBConformance 1 }

    '
- title: usmMIBGroups      OBJECT IDENTIFIER ::= { usmMIBConformance 2 }
  contents:
  - 'usmMIBGroups      OBJECT IDENTIFIER ::= { usmMIBConformance 2 }

    '
- title: -- Compliance statements
  contents:
  - '-- Compliance statements

    '
- title: usmMIBCompliance MODULE-COMPLIANCE
  contents:
  - "usmMIBCompliance MODULE-COMPLIANCE\n    STATUS       current\n    DESCRIPTION\
    \ \"The compliance statement for SNMP engines which\n                 implement\
    \ the SNMP-USER-BASED-SM-MIB.\n                \"\n    MODULE       -- this module\n\
    \        MANDATORY-GROUPS { usmMIBBasicGroup }\n        OBJECT           usmUserAuthProtocol\n\
    \        MIN-ACCESS       read-only\n        DESCRIPTION     \"Write access is\
    \ not required.\"\n        OBJECT           usmUserPrivProtocol\n        MIN-ACCESS\
    \       read-only\n        DESCRIPTION     \"Write access is not required.\"\n\
    \    ::= { usmMIBCompliances 1 }\n"
- title: -- Units of compliance
  contents:
  - '-- Units of compliance

    '
- title: usmMIBBasicGroup OBJECT-GROUP
  contents:
  - "usmMIBBasicGroup OBJECT-GROUP\n    OBJECTS     {\n                  usmStatsUnsupportedSecLevels,\n\
    \                  usmStatsNotInTimeWindows,\n                  usmStatsUnknownUserNames,\n\
    \                  usmStatsUnknownEngineIDs,\n                  usmStatsWrongDigests,\n\
    \                  usmStatsDecryptionErrors,\n                  usmUserSpinLock,\n\
    \                  usmUserSecurityName,\n                  usmUserCloneFrom,\n\
    \                  usmUserAuthProtocol,\n                  usmUserAuthKeyChange,\n\
    \                  usmUserOwnAuthKeyChange,\n                  usmUserPrivProtocol,\n\
    \                  usmUserPrivKeyChange,\n                  usmUserOwnPrivKeyChange,\n\
    \                  usmUserPublic,\n                  usmUserStorageType,\n   \
    \               usmUserStatus\n                }\n    STATUS       current\n \
    \   DESCRIPTION \"A collection of objects providing for configuration\n      \
    \           of an SNMP engine which implements the SNMP\n                 User-based\
    \ Security Model.\n                \"\n    ::= { usmMIBGroups 1 }\n"
- title: END
  contents:
  - 'END

    '
- title: 6. HMAC-MD5-96 Authentication Protocol
  contents:
  - "6. HMAC-MD5-96 Authentication Protocol\n   This section describes the HMAC-MD5-96\
    \ authentication protocol.  This\n   authentication protocol is the first defined\
    \ for the User-based\n   Security Model.  It uses MD5 hash-function which is described\
    \ in\n   [RFC1321], in HMAC mode described in [RFC2104], truncating the output\n\
    \   to 96 bits.\n   This protocol is identified by usmHMACMD5AuthProtocol.\n \
    \  Over time, other authentication protocols may be defined either as a\n   replacement\
    \ of this protocol or in addition to this protocol.\n"
- title: 6.1. Mechanisms
  contents:
  - "6.1. Mechanisms\n   - In support of data integrity, a message digest algorithm\
    \ is\n     required.  A digest is calculated over an appropriate portion of an\n\
    \     SNMP message and included as part of the message sent to the\n     recipient.\n\
    \   - In support of data origin authentication and data integrity, a\n     secret\
    \ value is prepended to SNMP message prior to computing the\n     digest; the\
    \ calculated digest is partially inserted into the SNMP\n     message prior to\
    \ transmission, and the prepended value is not\n     transmitted.  The secret\
    \ value is shared by all SNMP engines\n     authorized to originate messages on\
    \ behalf of the appropriate user.\n"
- title: 6.1.1. Digest Authentication Mechanism
  contents:
  - "6.1.1. Digest Authentication Mechanism\n   The Digest Authentication Mechanism\
    \ defined in this memo provides\n   for:\n   - verification of the integrity of\
    \ a received message, i.e., the\n     message received is the message sent.\n\
    \     The integrity of the message is protected by computing a digest\n     over\
    \ an appropriate portion of the message.  The digest is computed\n     by the\
    \ originator of the message, transmitted with the message, and\n     verified\
    \ by the recipient of the message.\n   - verification of the user on whose behalf\
    \ the message was generated.\n     A secret value known only to SNMP engines authorized\
    \ to generate\n     messages on behalf of a user is used in HMAC mode (see [RFC2104]).\n\
    \     It also recommends the hash-function output used as Message\n     Authentication\
    \ Code, to be truncated.\n   This protocol uses the MD5 [RFC1321] message digest\
    \ algorithm.  A\n   128-bit MD5 digest is calculated in a special (HMAC) way over\
    \ the\n   designated portion of an SNMP message and the first 96 bits of this\n\
    \   digest is included as part of the message sent to the recipient.  The\n  \
    \ size of the digest carried in a message is 12 octets.  The size of\n   the private\
    \ authentication key (the secret) is 16 octets.  For the\n   details see section\
    \ 6.3.\n"
- title: 6.2. Elements of the Digest Authentication Protocol
  contents:
  - "6.2. Elements of the Digest Authentication Protocol\n   This section contains\
    \ definitions required to realize the\n   authentication module defined in this\
    \ section of this memo.\n"
- title: 6.2.1. Users
  contents:
  - "6.2.1. Users\n   Authentication using this authentication protocol makes use\
    \ of a\n   defined set of userNames.  For any user on whose behalf a message\n\
    \   must be authenticated at a particular SNMP engine, that SNMP engine\n   must\
    \ have knowledge of that user.  An SNMP engine that wishes to\n   communicate\
    \ with another SNMP engine must also have knowledge of a\n   user known to that\
    \ engine, including knowledge of the applicable\n   attributes of that user.\n\
    \   A user and its attributes are defined as follows:\n   <userName>\n     A string\
    \ representing the name of the user.\n   <authKey>\n     A user's secret key to\
    \ be used when calculating a digest.\n     It MUST be 16 octets long for MD5.\n"
- title: 6.2.2. msgAuthoritativeEngineID
  contents:
  - "6.2.2. msgAuthoritativeEngineID\n   The msgAuthoritativeEngineID value contained\
    \ in an authenticated\n   message specifies the authoritative SNMP engine for\
    \ that particular\n   message (see the definition of SnmpEngineID in the SNMP\
    \ Architecture\n   document [RFC3411]).\n   The user's (private) authentication\
    \ key is normally different at each\n   authoritative SNMP engine and so the snmpEngineID\
    \ is used to select\n   the proper key for the authentication process.\n"
- title: 6.2.3. SNMP Messages Using this Authentication Protocol
  contents:
  - "6.2.3. SNMP Messages Using this Authentication Protocol\n   Messages using this\
    \ authentication protocol carry a\n   msgAuthenticationParameters field as part\
    \ of the\n   msgSecurityParameters.  For this protocol, the\n   msgAuthenticationParameters\
    \ field is the serialized OCTET STRING\n   representing the first 12 octets of\
    \ the HMAC-MD5-96 output done over\n   the wholeMsg.\n   The digest is calculated\
    \ over the wholeMsg so if a message is\n   authenticated, that also means that\
    \ all the fields in the message are\n   intact and have not been tampered with.\n"
- title: 6.2.4. Services provided by the HMAC-MD5-96 Authentication Module
  contents:
  - "6.2.4. Services provided by the HMAC-MD5-96 Authentication Module\n   This section\
    \ describes the inputs and outputs that the HMAC-MD5-96\n   Authentication module\
    \ expects and produces when the User-based\n   Security module calls the HMAC-MD5-96\
    \ Authentication module for\n   services.\n"
- title: 6.2.4.1. Services for Generating an Outgoing SNMP Message
  contents:
  - "6.2.4.1. Services for Generating an Outgoing SNMP Message\n   The HMAC-MD5-96\
    \ authentication protocol assumes that the selection of\n   the authKey is done\
    \ by the caller and that the caller passes the\n   secret key to be used.\n  \
    \ Upon completion the authentication module returns statusInformation\n   and,\
    \ if the message digest was correctly calculated, the wholeMsg\n   with the digest\
    \ inserted at the proper place.  The abstract service\n   primitive is:\n   statusInformation\
    \ =              -- success or failure\n     authenticateOutgoingMsg(\n     IN\
    \   authKey                   -- secret key for authentication\n     IN   wholeMsg\
    \                  -- unauthenticated complete message\n     OUT  authenticatedWholeMsg\
    \     -- complete authenticated message\n          )\n   The abstract data elements\
    \ are:\n   statusInformation\n     An indication of whether the authentication\
    \ process was successful.\n     If not it is an indication of the problem.\n \
    \  authKey\n     The secret key to be used by the authentication algorithm.  The\n\
    \     length of this key MUST be 16 octets.\n   wholeMsg\n     The message to\
    \ be authenticated.\n   authenticatedWholeMsg\n     The authenticated message\
    \ (including inserted digest) on output.\n   Note, that authParameters field is\
    \ filled by the authentication\n   module and this module and this field should\
    \ be already present in\n   the wholeMsg before the Message Authentication Code\
    \ (MAC) is\n   generated.\n"
- title: 6.2.4.2. Services for Processing an Incoming SNMP Message
  contents:
  - "6.2.4.2. Services for Processing an Incoming SNMP Message\n   The HMAC-MD5-96\
    \ authentication protocol assumes that the selection of\n   the authKey is done\
    \ by the caller and that the caller passes the\n   secret key to be used.\n  \
    \ Upon completion the authentication module returns statusInformation\n   and,\
    \ if the message digest was correctly calculated, the wholeMsg as\n   it was processed.\
    \  The abstract service primitive is:\n   statusInformation =              --\
    \ success or failure\n     authenticateIncomingMsg(\n     IN   authKey       \
    \            -- secret key for authentication\n     IN   authParameters      \
    \      -- as received on the wire\n     IN   wholeMsg                  -- as received\
    \ on the wire\n     OUT  authenticatedWholeMsg     -- complete authenticated message\n\
    \          )\n   The abstract data elements are:\n   statusInformation\n     An\
    \ indication of whether the authentication process was successful.\n     If not\
    \ it is an indication of the problem.\n   authKey\n     The secret key to be used\
    \ by the authentication algorithm.  The\n     length of this key MUST be 16 octets.\n\
    \   authParameters\n     The authParameters from the incoming message.\n   wholeMsg\n\
    \     The message to be authenticated on input and the authenticated\n     message\
    \ on output.\n   authenticatedWholeMsg\n     The whole message after the authentication\
    \ check is complete.\n"
- title: 6.3. Elements of Procedure
  contents:
  - "6.3. Elements of Procedure\n   This section describes the procedures for the\
    \ HMAC-MD5-96\n   authentication protocol.\n"
- title: 6.3.1. Processing an Outgoing Message
  contents:
  - "6.3.1. Processing an Outgoing Message\n   This section describes the procedure\
    \ followed by an SNMP engine\n   whenever it must authenticate an outgoing message\
    \ using the\n   usmHMACMD5AuthProtocol.\n   1) The msgAuthenticationParameters\
    \ field is set to the serialization,\n      according to the rules in [RFC3417],\
    \ of an OCTET STRING containing\n      12 zero octets.\n   2) From the secret\
    \ authKey, two keys K1 and K2 are derived:\n      a) extend the authKey to 64\
    \ octets by appending 48 zero octets;\n         save it as extendedAuthKey\n \
    \     b) obtain IPAD by replicating the octet 0x36 64 times;\n      c) obtain\
    \ K1 by XORing extendedAuthKey with IPAD;\n      d) obtain OPAD by replicating\
    \ the octet 0x5C 64 times;\n      e) obtain K2 by XORing extendedAuthKey with\
    \ OPAD.\n   3) Prepend K1 to the wholeMsg and calculate MD5 digest over it\n \
    \     according to [RFC1321].\n   4) Prepend K2 to the result of the step 4 and\
    \ calculate MD5 digest\n      over it according to [RFC1321].  Take the first\
    \ 12 octets of the\n      final digest - this is Message Authentication Code (MAC).\n\
    \   5) Replace the msgAuthenticationParameters field with MAC obtained in\n  \
    \    the step 4.\n   6) The authenticatedWholeMsg is then returned to the caller\
    \ together\n      with statusInformation indicating success.\n"
- title: 6.3.2. Processing an Incoming Message
  contents:
  - "6.3.2. Processing an Incoming Message\n   This section describes the procedure\
    \ followed by an SNMP engine\n   whenever it must authenticate an incoming message\
    \ using the\n   usmHMACMD5AuthProtocol.\n   1) If the digest received in the msgAuthenticationParameters\
    \ field is\n      not 12 octets long, then an failure and an errorIndication\n\
    \      (authenticationError) is returned to the calling module.\n   2) The MAC\
    \ received in the msgAuthenticationParameters field is\n      saved.\n   3) The\
    \ digest in the msgAuthenticationParameters field is replaced by\n      the 12\
    \ zero octets.\n   4) From the secret authKey, two keys K1 and K2 are derived:\n\
    \      a) extend the authKey to 64 octets by appending 48 zero octets;\n     \
    \    save it as extendedAuthKey\n      b) obtain IPAD by replicating the octet\
    \ 0x36 64 times;\n      c) obtain K1 by XORing extendedAuthKey with IPAD;\n  \
    \    d) obtain OPAD by replicating the octet 0x5C 64 times;\n      e) obtain K2\
    \ by XORing extendedAuthKey with OPAD.\n   5) The MAC is calculated over the wholeMsg:\n\
    \      a) prepend K1 to the wholeMsg and calculate the MD5 digest over\n     \
    \ it;\n      b) prepend K2 to the result of step 5.a and calculate the MD5\n \
    \     digest over it;\n      c) first 12 octets of the result of step 5.b is the\
    \ MAC.\n      The msgAuthenticationParameters field is replaced with the MAC\n\
    \      value that was saved in step 2.\n   6) Then the newly calculated MAC is\
    \ compared with the MAC saved in\n      step 2.  If they do not match, then an\
    \ failure and an\n      errorIndication (authenticationFailure) is returned to\
    \ the calling\n      module.\n   7) The authenticatedWholeMsg and statusInformation\
    \ indicating success\n      are then returned to the caller.\n"
- title: 7. HMAC-SHA-96 Authentication Protocol
  contents:
  - "7. HMAC-SHA-96 Authentication Protocol\n   This section describes the HMAC-SHA-96\
    \ authentication protocol.  This\n   protocol uses the SHA hash-function which\
    \ is described in [SHA-NIST],\n   in HMAC mode described in [RFC2104], truncating\
    \ the output to 96\n   bits.\n   This protocol is identified by usmHMACSHAAuthProtocol.\n\
    \   Over time, other authentication protocols may be defined either as a\n   replacement\
    \ of this protocol or in addition to this protocol.\n"
- title: 7.1. Mechanisms
  contents:
  - "7.1. Mechanisms\n   - In support of data integrity, a message digest algorithm\
    \ is\n     required.  A digest is calculated over an appropriate portion of an\n\
    \     SNMP message and included as part of the message sent to the\n     recipient.\n\
    \   - In support of data origin authentication and data integrity, a\n     secret\
    \ value is prepended to the SNMP message prior to computing\n     the digest;\
    \ the calculated digest is then partially inserted into\n     the message prior\
    \ to transmission.  The prepended secret is not\n     transmitted.  The secret\
    \ value is shared by all SNMP engines\n     authorized to originate messages on\
    \ behalf of the appropriate user.\n"
- title: 7.1.1. Digest Authentication Mechanism
  contents:
  - "7.1.1. Digest Authentication Mechanism\n   The Digest Authentication Mechanism\
    \ defined in this memo provides\n   for:\n   - verification of the integrity of\
    \ a received message, i.e., the\n     message received is the message sent.\n\
    \     The integrity of the message is protected by computing a digest\n     over\
    \ an appropriate portion of the message.  The digest is computed\n     by the\
    \ originator of the message, transmitted with the message, and\n     verified\
    \ by the recipient of the message.\n   - verification of the user on whose behalf\
    \ the message was generated.\n     A secret value known only to SNMP engines authorized\
    \ to generate\n     messages on behalf of a user is used in HMAC mode (see [RFC2104]).\n\
    \     It also recommends the hash-function output used as Message\n     Authentication\
    \ Code, to be truncated.\n   This mechanism uses the SHA [SHA-NIST] message digest\
    \ algorithm.  A\n   160-bit SHA digest is calculated in a special (HMAC) way over\
    \ the\n   designated portion of an SNMP message and the first 96 bits of this\n\
    \   digest is included as part of the message sent to the recipient.  The\n  \
    \ size of the digest carried in a message is 12 octets.  The size of\n   the private\
    \ authentication key (the secret) is 20 octets.  For the\n   details see section\
    \ 7.3.\n"
- title: 7.2. Elements of the HMAC-SHA-96 Authentication Protocol
  contents:
  - "7.2. Elements of the HMAC-SHA-96 Authentication Protocol\n   This section contains\
    \ definitions required to realize the\n   authentication module defined in this\
    \ section of this memo.\n"
- title: 7.2.1. Users
  contents:
  - "7.2.1. Users\n   Authentication using this authentication protocol makes use\
    \ of a\n   defined set of userNames.  For any user on whose behalf a message\n\
    \   must be authenticated at a particular SNMP engine, that SNMP engine\n   must\
    \ have knowledge of that user.  An SNMP engine that wishes to\n   communicate\
    \ with another SNMP engine must also have knowledge of a\n   user known to that\
    \ engine, including knowledge of the applicable\n   attributes of that user.\n\
    \   A user and its attributes are defined as follows:\n   <userName>\n     A string\
    \ representing the name of the user.\n   <authKey>\n     A user's secret key to\
    \ be used when calculating a digest.\n     It MUST be 20 octets long for SHA.\n"
- title: 7.2.2. msgAuthoritativeEngineID
  contents:
  - "7.2.2. msgAuthoritativeEngineID\n   The msgAuthoritativeEngineID value contained\
    \ in an authenticated\n   message specifies the authoritative SNMP engine for\
    \ that particular\n   message (see the definition of SnmpEngineID in the SNMP\
    \ Architecture\n   document [RFC3411]).\n   The user's (private) authentication\
    \ key is normally different at each\n   authoritative SNMP engine and so the snmpEngineID\
    \ is used to select\n   the proper key for the authentication process.\n"
- title: 7.2.3. SNMP Messages Using this Authentication Protocol
  contents:
  - "7.2.3. SNMP Messages Using this Authentication Protocol\n   Messages using this\
    \ authentication protocol carry a\n   msgAuthenticationParameters field as part\
    \ of the\n   msgSecurityParameters.  For this protocol, the\n   msgAuthenticationParameters\
    \ field is the serialized OCTET STRING\n   representing the first 12 octets of\
    \ HMAC-SHA-96 output done over the\n   wholeMsg.\n   The digest is calculated\
    \ over the wholeMsg so if a message is\n   authenticated, that also means that\
    \ all the fields in the message are\n   intact and have not been tampered with.\n"
- title: 7.2.4. Services Provided by the HMAC-SHA-96 Authentication Module
  contents:
  - "7.2.4. Services Provided by the HMAC-SHA-96 Authentication Module\n   This section\
    \ describes the inputs and outputs that the HMAC-SHA-96\n   Authentication module\
    \ expects and produces when the User-based\n   Security module calls the HMAC-SHA-96\
    \ Authentication module for\n   services.\n"
- title: 7.2.4.1. Services for Generating an Outgoing SNMP Message
  contents:
  - "7.2.4.1. Services for Generating an Outgoing SNMP Message\n   HMAC-SHA-96 authentication\
    \ protocol assumes that the selection of the\n   authKey is done by the caller\
    \ and that the caller passes the secret\n   key to be used.\n   Upon completion\
    \ the authentication module returns statusInformation\n   and, if the message\
    \ digest was correctly calculated, the wholeMsg\n   with the digest inserted at\
    \ the proper place.  The abstract service\n   primitive is:\n   statusInformation\
    \ =              -- success or failure\n     authenticateOutgoingMsg(\n     IN\
    \   authKey                   -- secret key for authentication\n     IN   wholeMsg\
    \                  -- unauthenticated complete message\n     OUT  authenticatedWholeMsg\
    \     -- complete authenticated message\n          )\n   The abstract data elements\
    \ are:\n   statusInformation\n     An indication of whether the authentication\
    \ process was successful.\n     If not it is an indication of the problem.\n \
    \  authKey\n     The secret key to be used by the authentication algorithm.  The\n\
    \     length of this key MUST be 20 octets.\n   wholeMsg\n     The message to\
    \ be authenticated.\n   authenticatedWholeMsg\n     The authenticated message\
    \ (including inserted digest) on output.\n   Note, that authParameters field is\
    \ filled by the authentication\n   module and this field should be already present\
    \ in the wholeMsg\n   before the Message Authentication Code (MAC) is generated.\n"
- title: 7.2.4.2. Services for Processing an Incoming SNMP Message
  contents:
  - "7.2.4.2. Services for Processing an Incoming SNMP Message\n   HMAC-SHA-96 authentication\
    \ protocol assumes that the selection of the\n   authKey is done by the caller\
    \ and that the caller passes the secret\n   key to be used.\n   Upon completion\
    \ the authentication module returns statusInformation\n   and, if the message\
    \ digest was correctly calculated, the wholeMsg as\n   it was processed.  The\
    \ abstract service primitive is:\n   statusInformation =              -- success\
    \ or failure\n     authenticateIncomingMsg(\n     IN   authKey               \
    \    -- secret key for authentication\n     IN   authParameters            --\
    \ as received on the wire\n     IN   wholeMsg                  -- as received\
    \ on the wire\n     OUT  authenticatedWholeMsg     -- complete authenticated message\n\
    \          )\n   The abstract data elements are:\n   statusInformation\n     An\
    \ indication of whether the authentication process was successful.\n     If not\
    \ it is an indication of the problem.\n   authKey\n     The secret key to be used\
    \ by the authentication algorithm.  The\n     length of this key MUST be 20 octets.\n\
    \   authParameters\n     The authParameters from the incoming message.\n   wholeMsg\n\
    \     The message to be authenticated on input and the authenticated\n     message\
    \ on output.\n   authenticatedWholeMsg\n     The whole message after the authentication\
    \ check is complete.\n"
- title: 7.3. Elements of Procedure
  contents:
  - "7.3. Elements of Procedure\n   This section describes the procedures for the\
    \ HMAC-SHA-96\n   authentication protocol.\n"
- title: 7.3.1. Processing an Outgoing Message
  contents:
  - "7.3.1. Processing an Outgoing Message\n   This section describes the procedure\
    \ followed by an SNMP engine\n   whenever it must authenticate an outgoing message\
    \ using the\n   usmHMACSHAAuthProtocol.\n   1) The msgAuthenticationParameters\
    \ field is set to the serialization,\n      according to the rules in [RFC3417],\
    \ of an OCTET STRING containing\n      12 zero octets.\n   2) From the secret\
    \ authKey, two keys K1 and K2 are derived:\n      a) extend the authKey to 64\
    \ octets by appending 44 zero octets;\n         save it as extendedAuthKey\n \
    \     b) obtain IPAD by replicating the octet 0x36 64 times;\n      c) obtain\
    \ K1 by XORing extendedAuthKey with IPAD;\n      d) obtain OPAD by replicating\
    \ the octet 0x5C 64 times;\n      e) obtain K2 by XORing extendedAuthKey with\
    \ OPAD.\n   3) Prepend K1 to the wholeMsg and calculate the SHA digest over it\n\
    \      according to [SHA-NIST].\n   4) Prepend K2 to the result of the step 4\
    \ and calculate SHA digest\n      over it according to [SHA-NIST].  Take the first\
    \ 12 octets of the\n      final digest - this is Message Authentication Code (MAC).\n\
    \   5) Replace the msgAuthenticationParameters field with MAC obtained in\n  \
    \    the step 5.\n   6) The authenticatedWholeMsg is then returned to the caller\
    \ together\n      with statusInformation indicating success.\n"
- title: 7.3.2. Processing an Incoming Message
  contents:
  - "7.3.2. Processing an Incoming Message\n   This section describes the procedure\
    \ followed by an SNMP engine\n   whenever it must authenticate an incoming message\
    \ using the\n   usmHMACSHAAuthProtocol.\n   1) If the digest received in the msgAuthenticationParameters\
    \ field is\n      not 12 octets long, then an failure and an errorIndication\n\
    \      (authenticationError) is returned to the calling module.\n   2) The MAC\
    \ received in the msgAuthenticationParameters field is\n      saved.\n   3) The\
    \ digest in the msgAuthenticationParameters field is replaced by\n      the 12\
    \ zero octets.\n   4) From the secret authKey, two keys K1 and K2 are derived:\n\
    \      a) extend the authKey to 64 octets by appending 44 zero octets;\n     \
    \    save it as extendedAuthKey\n      b) obtain IPAD by replicating the octet\
    \ 0x36 64 times;\n      c) obtain K1 by XORing extendedAuthKey with IPAD;\n  \
    \    d) obtain OPAD by replicating the octet 0x5C 64 times;\n      e) obtain K2\
    \ by XORing extendedAuthKey with OPAD.\n   5)  The MAC is calculated over the\
    \ wholeMsg:\n      a) prepend K1 to the wholeMsg and calculate the SHA digest\
    \ over\n         it;\n      b) prepend K2 to the result of step 5.a and calculate\
    \ the SHA\n         digest over it;\n      c) first 12 octets of the result of\
    \ step 5.b is the MAC.\n      The msgAuthenticationParameters field is replaced\
    \ with the MAC\n      value that was saved in step 2.\n   6) The the newly calculated\
    \ MAC is compared with the MAC saved in\n      step 2.  If they do not match,\
    \ then a failure and an\n      errorIndication (authenticationFailure) are returned\
    \ to the\n      calling module.\n   7) The authenticatedWholeMsg and statusInformation\
    \ indicating success\n      are then returned to the caller.\n"
- title: 8. CBC-DES Symmetric Encryption Protocol
  contents:
  - "8. CBC-DES Symmetric Encryption Protocol\n   This section describes the CBC-DES\
    \ Symmetric Encryption Protocol.\n   This protocol is the first privacy protocol\
    \ defined for the\n   User-based Security Model.\n   This protocol is identified\
    \ by usmDESPrivProtocol.\n   Over time, other privacy protocols may be defined\
    \ either as a\n   replacement of this protocol or in addition to this protocol.\n"
- title: 8.1. Mechanisms
  contents:
  - "8.1. Mechanisms\n   - In support of data confidentiality, an encryption algorithm\
    \ is\n     required.  An appropriate portion of the message is encrypted prior\n\
    \     to being transmitted.  The User-based Security Model specifies that\n  \
    \   the scopedPDU is the portion of the message that needs to be\n     encrypted.\n\
    \   - A secret value in combination with a timeliness value is used to\n     create\
    \ the en/decryption key and the initialization vector.  The\n     secret value\
    \ is shared by all SNMP engines authorized to originate\n     messages on behalf\
    \ of the appropriate user.\n"
- title: 8.1.1. Symmetric Encryption Protocol
  contents:
  - "8.1.1. Symmetric Encryption Protocol\n   The Symmetric Encryption Protocol defined\
    \ in this memo provides\n   support for data confidentiality.  The designated\
    \ portion of an SNMP\n   message is encrypted and included as part of the message\
    \ sent to the\n   recipient.\n   Two organizations have published specifications\
    \ defining the DES:\n   the National Institute of Standards and Technology (NIST)\
    \ [DES-NIST]\n   and the American National Standards Institute [DES-ANSI].  There\
    \ is a\n   companion Modes of Operation specification for each definition\n  \
    \ ([DESO-NIST] and [DESO-ANSI], respectively).\n   The NIST has published three\
    \ additional documents that implementors\n   may find useful.\n   - There is a\
    \ document with guidelines for implementing and using the\n     DES, including\
    \ functional specifications for the DES and its modes\n     of operation [DESG-NIST].\n\
    \   - There is a specification of a validation test suite for the DES\n     [DEST-NIST].\
    \  The suite is designed to test all aspects of the DES\n     and is useful for\
    \ pinpointing specific problems.\n   - There is a specification of a maintenance\
    \ test for the DES [DESM-\n     NIST].  The test utilizes a minimal amount of\
    \ data and processing\n     to test all components of the DES.  It provides a\
    \ simple yes-or-no\n     indication of correct operation and is useful to run\
    \ as part of an\n     initialization step, e.g., when a computer re-boots.\n"
- title: 8.1.1.1. DES key and Initialization Vector
  contents:
  - "8.1.1.1. DES key and Initialization Vector\n   The first 8 octets of the 16-octet\
    \ secret (private privacy key) are\n   used as a DES key.  Since DES uses only\
    \ 56 bits, the Least\n   Significant Bit in each octet is disregarded.\n   The\
    \ Initialization Vector for encryption is obtained using the\n   following procedure.\n\
    \   The last 8 octets of the 16-octet secret (private privacy key) are\n   used\
    \ as pre-IV.\n   In order to ensure that the IV for two different packets encrypted\
    \ by\n   the same key, are not the same (i.e., the IV does not repeat) we need\n\
    \   to \"salt\" the pre-IV with something unique per packet.  An 8-octet\n   string\
    \ is used as the \"salt\".  The concatenation of the generating\n   SNMP engine's\
    \ 32-bit snmpEngineBoots and a local 32-bit integer, that\n   the encryption engine\
    \ maintains, is input to the \"salt\".  The 32-bit\n   integer is initialized\
    \ to an arbitrary value at boot time.\n   The 32-bit snmpEngineBoots is converted\
    \ to the first 4 octets (Most\n   Significant Byte first) of our \"salt\".  The\
    \ 32-bit integer is then\n   converted to the last 4 octet (Most Significant Byte\
    \ first) of our\n   \"salt\".  The resulting \"salt\" is then XOR-ed with the\
    \ pre-IV to\n   obtain the IV.  The 8-octet \"salt\" is then put into the\n  \
    \ privParameters field encoded as an OCTET STRING.  The \"salt\" integer\n   is\
    \ then modified.  We recommend that it be incremented by one and\n   wrap when\
    \ it reaches the maximum value.\n   How exactly the value of the \"salt\" (and\
    \ thus of the IV) varies, is\n   an implementation issue, as long as the measures\
    \ are taken to avoid\n   producing a duplicate IV.\n   The \"salt\" must be placed\
    \ in the privParameters field to enable the\n   receiving entity to compute the\
    \ correct IV and to decrypt the\n   message.\n"
- title: 8.1.1.2. Data Encryption
  contents:
  - "8.1.1.2. Data Encryption\n   The data to be encrypted is treated as sequence\
    \ of octets.  Its\n   length should be an integral multiple of 8 - and if it is\
    \ not, the\n   data is padded at the end as necessary.  The actual pad value is\n\
    \   irrelevant.\n   The data is encrypted in Cipher Block Chaining mode.\n   The\
    \ plaintext is divided into 64-bit blocks.\n   The plaintext for each block is\
    \ XOR-ed with the ciphertext of the\n   previous block, the result is encrypted\
    \ and the output of the\n   encryption is the ciphertext for the block.  This\
    \ procedure is\n   repeated until there are no more plaintext blocks.\n   For\
    \ the very first block, the Initialization Vector is used instead\n   of the ciphertext\
    \ of the previous block.\n"
- title: 8.1.1.3. Data Decryption
  contents:
  - "8.1.1.3. Data Decryption\n   Before decryption, the encrypted data length is\
    \ verified.  If the\n   length of the OCTET STRING to be decrypted is not an integral\n\
    \   multiple of 8 octets, the decryption process is halted and an\n   appropriate\
    \ exception noted.  When decrypting, the padding is\n   ignored.\n   The first\
    \ ciphertext block is decrypted, the decryption output is\n   XOR-ed with the\
    \ Initialization Vector, and the result is the first\n   plaintext block.\n  \
    \ For each subsequent block, the ciphertext block is decrypted, the\n   decryption\
    \ output is XOR-ed with the previous ciphertext block and\n   the result is the\
    \ plaintext block.\n"
- title: 8.2. Elements of the DES Privacy Protocol
  contents:
  - "8.2. Elements of the DES Privacy Protocol\n   This section contains definitions\
    \ required to realize the privacy\n   module defined by this memo.\n"
- title: 8.2.1. Users
  contents:
  - "8.2.1. Users\n   Data en/decryption using this Symmetric Encryption Protocol\
    \ makes use\n   of a defined set of userNames.  For any user on whose behalf a\n\
    \   message must be en/decrypted at a particular SNMP engine, that SNMP\n   engine\
    \ must have knowledge of that user.  An SNMP engine that wishes\n   to communicate\
    \ with another SNMP engine must also have knowledge of a\n   user known to that\
    \ SNMP engine, including knowledge of the applicable\n   attributes of that user.\n\
    \   A user and its attributes are defined as follows:\n   <userName>\n     An\
    \ octet string representing the name of the user.\n   <privKey>\n     A user's\
    \ secret key to be used as input for the DES key and IV.\n     The length of this\
    \ key MUST be 16 octets.\n"
- title: 8.2.2. msgAuthoritativeEngineID
  contents:
  - "8.2.2. msgAuthoritativeEngineID\n   The msgAuthoritativeEngineID value contained\
    \ in an authenticated\n   message specifies the authoritative SNMP engine for\
    \ that particular\n   message (see the definition of SnmpEngineID in the SNMP\
    \ Architecture\n   document [RFC3411]).\n   The user's (private) privacy key is\
    \ normally different at each\n   authoritative SNMP engine and so the snmpEngineID\
    \ is used to select\n   the proper key for the en/decryption process.\n"
- title: 8.2.3. SNMP Messages Using this Privacy Protocol
  contents:
  - "8.2.3. SNMP Messages Using this Privacy Protocol\n   Messages using this privacy\
    \ protocol carry a msgPrivacyParameters\n   field as part of the msgSecurityParameters.\
    \  For this protocol, the\n   msgPrivacyParameters field is the serialized OCTET\
    \ STRING\n   representing the \"salt\" that was used to create the IV.\n"
- title: 8.2.4. Services Provided by the DES Privacy Module
  contents:
  - "8.2.4. Services Provided by the DES Privacy Module\n   This section describes\
    \ the inputs and outputs that the DES Privacy\n   module expects and produces\
    \ when the User-based Security module\n   invokes the DES Privacy module for services.\n"
- title: 8.2.4.1. Services for Encrypting Outgoing Data
  contents:
  - "8.2.4.1. Services for Encrypting Outgoing Data\n   This DES privacy protocol\
    \ assumes that the selection of the privKey\n   is done by the caller and that\
    \ the caller passes the secret key to be\n   used.\n   Upon completion the privacy\
    \ module returns statusInformation and, if\n   the encryption process was successful,\
    \ the encryptedPDU and the\n   msgPrivacyParameters encoded as an OCTET STRING.\
    \  The abstract\n   service primitive is:\n   statusInformation =            \
    \  -- success of failure\n     encryptData(\n     IN    encryptKey           \
    \    -- secret key for encryption\n     IN    dataToEncrypt            -- data\
    \ to encrypt (scopedPDU)\n     OUT   encryptedData            -- encrypted data\
    \ (encryptedPDU)\n     OUT   privParameters           -- filled in by service\
    \ provider\n           )\n   The abstract data elements are:\n   statusInformation\n\
    \     An indication of the success or failure of the encryption process.\n   \
    \  In case of failure, it is an indication of the error.\n   encryptKey\n    \
    \ The secret key to be used by the encryption algorithm.  The length\n     of\
    \ this key MUST be 16 octets.\n   dataToEncrypt\n     The data that must be encrypted.\n\
    \   encryptedData\n     The encrypted data upon successful completion.\n   privParameters\n\
    \     The privParameters encoded as an OCTET STRING.\n"
- title: 8.2.4.2. Services for Decrypting Incoming Data
  contents:
  - "8.2.4.2. Services for Decrypting Incoming Data\n   This DES privacy protocol\
    \ assumes that the selection of the privKey\n   is done by the caller and that\
    \ the caller passes the secret key to be\n   used.\n   Upon completion the privacy\
    \ module returns statusInformation and, if\n   the decryption process was successful,\
    \ the scopedPDU in plain text.\n   The abstract service primitive is:\n   statusInformation\
    \ =\n     decryptData(\n     IN    decryptKey               -- secret key for\
    \ decryption\n     IN    privParameters           -- as received on the wire\n\
    \     IN    encryptedData            -- encrypted data (encryptedPDU)\n     OUT\
    \   decryptedData            -- decrypted data (scopedPDU)\n           )\n   The\
    \ abstract data elements are:\n   statusInformation\n     An indication whether\
    \ the data was successfully decrypted and if\n     not an indication of the error.\n\
    \   decryptKey\n     The secret key to be used by the decryption algorithm.  The\
    \ length\n     of this key MUST be 16 octets.\n   privParameters\n     The \"\
    salt\" to be used to calculate the IV.\n   encryptedData\n     The data to be\
    \ decrypted.\n   decryptedData\n     The decrypted data.\n"
- title: 8.3. Elements of Procedure.
  contents:
  - "8.3. Elements of Procedure.\n   This section describes the procedures for the\
    \ DES privacy protocol.\n"
- title: 8.3.1. Processing an Outgoing Message
  contents:
  - "8.3.1. Processing an Outgoing Message\n   This section describes the procedure\
    \ followed by an SNMP engine\n   whenever it must encrypt part of an outgoing\
    \ message using the\n   usmDESPrivProtocol.\n   1) The secret cryptKey is used\
    \ to construct the DES encryption key,\n      the \"salt\" and the DES pre-IV\
    \ (from which the IV is computed as\n      described in section 8.1.1.1).\n  \
    \ 2) The privParameters field is set to the serialization according to\n     \
    \ the rules in [RFC3417] of an OCTET STRING representing the \"salt\"\n      string.\n\
    \   3) The scopedPDU is encrypted (as described in section 8.1.1.2)\n      and\
    \ the encrypted data is serialized according to the rules in\n      [RFC3417]\
    \ as an OCTET STRING.\n   4) The serialized OCTET STRING representing the encrypted\
    \ scopedPDU\n      together with the privParameters and statusInformation indicating\n\
    \      success is returned to the calling module.\n"
- title: 8.3.2. Processing an Incoming Message
  contents:
  - "8.3.2. Processing an Incoming Message\n   This section describes the procedure\
    \ followed by an SNMP engine\n   whenever it must decrypt part of an incoming\
    \ message using the\n   usmDESPrivProtocol.\n   1) If the privParameters field\
    \ is not an 8-octet OCTET STRING, then\n      an error indication (decryptionError)\
    \ is returned to the calling\n      module.\n   2) The \"salt\" is extracted from\
    \ the privParameters field.\n   3) The secret cryptKey and the \"salt\" are then\
    \ used to construct the\n      DES decryption key and pre-IV (from which the IV\
    \ is computed as\n      described in section 8.1.1.1).\n   4) The encryptedPDU\
    \ is then decrypted (as described in section\n      8.1.1.3).\n   5) If the encryptedPDU\
    \ cannot be decrypted, then an error indication\n      (decryptionError) is returned\
    \ to the calling module.\n   6) The decrypted scopedPDU and statusInformation\
    \ indicating success\n      are returned to the calling module.\n"
- title: 9. Intellectual Property
  contents:
  - "9. Intellectual Property\n   The IETF takes no position regarding the validity\
    \ or scope of any\n   intellectual property or other rights that might be claimed\
    \ to\n   pertain to the implementation or use of the technology described in\n\
    \   this document or the extent to which any license under such rights\n   might\
    \ or might not be available; neither does it represent that it\n   has made any\
    \ effort to identify any such rights.  Information on the\n   IETF's procedures\
    \ with respect to rights in standards-track and\n   standards-related documentation\
    \ can be found in BCP-11.  Copies of\n   claims of rights made available for publication\
    \ and any assurances of\n   licenses to be made available, or the result of an\
    \ attempt made to\n   obtain a general license or permission for the use of such\n\
    \   proprietary rights by implementors or users of this specification can\n  \
    \ be obtained from the IETF Secretariat.\n   The IETF invites any interested party\
    \ to bring to its attention any\n   copyrights, patents or patent applications,\
    \ or other proprietary\n   rights which may cover technology that may be required\
    \ to practice\n   this standard.  Please address the information to the IETF Executive\n\
    \   Director.\n"
- title: 10. Acknowledgements
  contents:
  - "10. Acknowledgements\n   This document is the result of the efforts of the SNMPv3\
    \ Working\n   Group.  Some special thanks are in order to the following SNMPv3\
    \ WG\n   members:\n      Harald Tveit Alvestrand (Maxware)\n      Dave Battle\
    \ (SNMP Research, Inc.)\n      Alan Beard (Disney Worldwide Services)\n      Paul\
    \ Berrevoets (SWI Systemware/Halcyon Inc.)\n      Martin Bjorklund (Ericsson)\n\
    \      Uri Blumenthal (IBM T.J. Watson Research Center)\n      Jeff Case (SNMP\
    \ Research, Inc.)\n      John Curran (BBN)\n      Mike Daniele (Compaq Computer\
    \ Corporation))\n      T. Max Devlin (Eltrax Systems)\n      John Flick (Hewlett\
    \ Packard)\n      Rob Frye (MCI)\n      Wes Hardaker (U.C.Davis, Information Technology\
    \ - D.C.A.S.)\n      David Harrington (Cabletron Systems Inc.)\n      Lauren Heintz\
    \ (BMC Software, Inc.)\n      N.C. Hien (IBM T.J. Watson Research Center)\n  \
    \    Michael Kirkham (InterWorking Labs, Inc.)\n      Dave Levi (SNMP Research,\
    \ Inc.)\n      Louis A Mamakos (UUNET Technologies Inc.)\n      Joe Marzot (Nortel\
    \ Networks)\n      Paul Meyer (Secure Computing Corporation)\n      Keith McCloghrie\
    \ (Cisco Systems)\n      Bob Moore (IBM)\n      Russ Mundy (TIS Labs at Network\
    \ Associates)\n      Bob Natale (ACE*COMM Corporation)\n      Mike O'Dell (UUNET\
    \ Technologies Inc.)\n      Dave Perkins (DeskTalk)\n      Peter Polkinghorne\
    \ (Brunel University)\n      Randy Presuhn (BMC Software, Inc.)\n      David Reeder\
    \ (TIS Labs at Network Associates)\n      David Reid (SNMP Research, Inc.)\n \
    \     Aleksey Romanov (Quality Quorum)\n      Shawn Routhier (Epilogue)\n    \
    \  Juergen Schoenwaelder (TU Braunschweig)\n      Bob Stewart (Cisco Systems)\n\
    \      Mike Thatcher (Independent Consultant)\n      Bert Wijnen (IBM T.J. Watson\
    \ Research Center)\n   The document is based on recommendations of the IETF Security\
    \ and\n   Administrative Framework Evolution for SNMP Advisory Team.  Members\n\
    \   of that Advisory Team were:\n      David Harrington (Cabletron Systems Inc.)\n\
    \      Jeff Johnson (Cisco Systems)\n      David Levi (SNMP Research Inc.)\n \
    \     John Linn (Openvision)\n      Russ Mundy (Trusted Information Systems) chair\n\
    \      Shawn Routhier (Epilogue)\n      Glenn Waters (Nortel)\n      Bert Wijnen\
    \ (IBM T. J. Watson Research Center)\n   As recommended by the Advisory Team and\
    \ the SNMPv3 Working Group\n   Charter, the design incorporates as much as practical\
    \ from previous\n   RFCs and drafts.  As a result, special thanks are due to the\
    \ authors\n   of previous designs known as SNMPv2u and SNMPv2*:\n      Jeff Case\
    \ (SNMP Research, Inc.)\n      David Harrington (Cabletron Systems Inc.)\n   \
    \   David Levi (SNMP Research, Inc.)\n      Keith McCloghrie (Cisco Systems)\n\
    \      Brian O'Keefe (Hewlett Packard)\n      Marshall T. Rose (Dover Beach Consulting)\n\
    \      Jon Saperia (BGS Systems Inc.)\n      Steve Waldbusser (International Network\
    \ Services)\n      Glenn W. Waters (Bell-Northern Research Ltd.)\n"
- title: 11. Security Considerations
  contents:
  - '11. Security Considerations

    '
- title: 11.1. Recommended Practices
  contents:
  - "11.1. Recommended Practices\n   This section describes practices that contribute\
    \ to the secure,\n   effective operation of the mechanisms defined in this memo.\n\
    \   - An SNMP engine must discard SNMP Response messages that do not\n     correspond\
    \ to any currently outstanding Request message.  It is the\n     responsibility\
    \ of the Message Processing module to take care of\n     this.  For example it\
    \ can use a msgID for that.\n     An SNMP Command Generator Application must discard\
    \ any Response\n     Class PDU for which there is no currently outstanding Confirmed\n\
    \     Class PDU; for example for SNMPv2 [RFC3416] PDUs, the request-id\n     component\
    \ in the PDU can be used to correlate Responses to\n     outstanding Requests.\n\
    \     Although it would be typical for an SNMP engine and an SNMP Command\n  \
    \   Generator Application to do this as a matter of course, when using\n     these\
    \ security protocols it is significant due to the possibility\n     of message\
    \ duplication (malicious or otherwise).\n   - If an SNMP engine uses a msgID for\
    \ correlating Response messages to\n     outstanding Request messages, then it\
    \ MUST use different msgIDs in\n     all such Request messages that it sends out\
    \ during a Time Window\n     (150 seconds) period.\n     A Command Generator or\
    \ Notification Originator Application MUST use\n     different request-ids in\
    \ all Request PDUs that it sends out during\n     a TimeWindow (150 seconds) period.\n\
    \     This must be done to protect against the possibility of message\n     duplication\
    \ (malicious or otherwise).\n     For example, starting operations with a msgID\
    \ and/or request-id\n     value of zero is not a good idea.  Initializing them\
    \ with an\n     unpredictable number (so they do not start out the same after\
    \ each\n     reboot) and then incrementing by one would be acceptable.\n   - An\
    \ SNMP engine should perform time synchronization using\n     authenticated messages\
    \ in order to protect against the possibility\n     of message duplication (malicious\
    \ or otherwise).\n   - When sending state altering messages to a managed authoritative\n\
    \     SNMP engine, a Command Generator Application should delay sending\n    \
    \ successive messages to that managed SNMP engine until a positive\n     acknowledgement\
    \ is received for the previous message or until the\n     previous message expires.\n\
    \     No message ordering is imposed by the SNMP.  Messages may be\n     received\
    \ in any order relative to their time of generation and each\n     will be processed\
    \ in the ordered received.  Note that when an\n     authenticated message is sent\
    \ to a managed SNMP engine, it will be\n     valid for a period of time of approximately\
    \ 150 seconds under\n     normal circumstances, and is subject to replay during\
    \ this period.\n     Indeed, an SNMP engine and SNMP Command Generator Applications\
    \ must\n     cope with the loss and re-ordering of messages resulting from\n \
    \    anomalies in the network as a matter of course.\n     However, a managed\
    \ object, snmpSetSerialNo [RFC3418], is\n     specifically defined for use with\
    \ SNMP Set operations in order to\n     provide a mechanism to ensure that the\
    \ processing of SNMP messages\n     occurs in a specific order.\n   - The frequency\
    \ with which the secrets of a User-based Security Model\n     user should be changed\
    \ is indirectly related to the frequency of\n     their use.\n     Protecting\
    \ the secrets from disclosure is critical to the overall\n     security of the\
    \ protocols.  Frequent use of a secret provides a\n     continued source of data\
    \ that may be useful to a cryptanalyst in\n     exploiting known or perceived\
    \ weaknesses in an algorithm.  Frequent\n     changes to the secret avoid this\
    \ vulnerability.\n     Changing a secret after each use is generally regarded\
    \ as the most\n     secure practice, but a significant amount of overhead may\
    \ be\n     associated with that approach.\n     Note, too, in a local environment\
    \ the threat of disclosure may be\n     less significant, and as such the changing\
    \ of secrets may be less\n     frequent.  However, when public data networks are\
    \ used as the\n     communication paths, more caution is prudent.\n"
- title: 11.2  Defining Users
  contents:
  - "11.2  Defining Users\n   The mechanisms defined in this document employ the notion\
    \ of users on\n   whose behalf messages are sent.  How \"users\" are defined is\
    \ subject\n   to the security policy of the network administration.  For example,\n\
    \   users could be individuals (e.g., \"joe\" or \"jane\"), or a particular\n\
    \   role (e.g., \"operator\" or \"administrator\"), or a combination (e.g.,\n\
    \   \"joe-operator\", \"jane-operator\" or \"joe-admin\").  Furthermore, a user\n\
    \   may be a logical entity, such as an SNMP Application or a set of SNMP\n  \
    \ Applications, acting on behalf of an individual or role, or set of\n   individuals,\
    \ or set of roles, including combinations.\n   Appendix A describes an algorithm\
    \ for mapping a user \"password\" to a\n   16/20 octet value for use as either\
    \ a user's authentication key or\n   privacy key (or both).  Note however, that\
    \ using the same password\n   (and therefore the same key) for both authentication\
    \ and privacy is\n   very poor security practice and should be strongly discouraged.\n\
    \   Passwords are often generated, remembered, and input by a human.\n   Human-generated\
    \ passwords may be less than the 16/20 octets required\n   by the authentication\
    \ and privacy protocols, and brute force attacks\n   can be quite easy on a relatively\
    \ short ASCII character set.\n   Therefore, the algorithm is Appendix A performs\
    \ a transformation on\n   the password.  If the Appendix A algorithm is used,\
    \ SNMP\n   implementations (and SNMP configuration applications) must ensure\n\
    \   that passwords are at least 8 characters in length.  Please note that\n  \
    \ longer passwords with repetitive strings may result in exactly the\n   same\
    \ key.  For example, a password 'bertbert' will result in exactly\n   the same\
    \ key as password 'bertbertbert'.\n   Because the Appendix A algorithm uses such\
    \ passwords (nearly)\n   directly, it is very important that they not be easily\
    \ guessed.  It\n   is suggested that they be composed of mixed-case alphanumeric\
    \ and\n   punctuation characters that don't form words or phrases that might be\n\
    \   found in a dictionary.   Longer passwords improve the security of the\n  \
    \ system.  Users may wish to input multiword phrases to make their\n   password\
    \ string longer while ensuring that it is memorable.\n   Since it is infeasible\
    \ for human users to maintain different\n   passwords for every SNMP engine, but\
    \ security requirements strongly\n   discourage having the same key for more than\
    \ one SNMP engine, the\n   User-based Security Model employs a compromise proposed\
    \ in\n   [Localized-key].  It derives the user keys for the SNMP engines from\n\
    \   user's password in such a way that it is practically impossible to\n   either\
    \ determine the user's password, or user's key for another SNMP\n   engine from\
    \ any combination of user's keys on SNMP engines.\n   Note however, that if user's\
    \ password is disclosed, then key\n   localization will not help and network security\
    \ may be compromised in\n   this case.  Therefore a user's password or non-localized\
    \ key MUST NOT\n   be stored on a managed device/node.  Instead the localized\
    \ key SHALL\n   be stored (if at all), so that, in case a device does get\n  \
    \ compromised, no other managed or managing devices get compromised.\n"
- title: 11.3. Conformance
  contents:
  - "11.3. Conformance\n   To be termed a \"Secure SNMP implementation\" based on\
    \ the User-based\n   Security Model, an SNMP implementation MUST:\n   - implement\
    \ one or more Authentication Protocol(s).  The HMAC-MD5-96\n     and HMAC-SHA-96\
    \ Authentication Protocols defined in this memo are\n     examples of such protocols.\n\
    \   - to the maximum extent possible, prohibit access to the secret(s) of\n  \
    \   each user about which it maintains information in a Local\n     Configuration\
    \ Datastore (LCD) under all circumstances except as\n     required to generate\
    \ and/or validate SNMP messages with respect to\n     that user.\n   - implement\
    \ the key-localization mechanism.\n   - implement the SNMP-USER-BASED-SM-MIB.\n\
    \   In addition, an authoritative SNMP engine SHOULD provide initial\n   configuration\
    \ in accordance with Appendix A.1.\n   Implementation of a Privacy Protocol (the\
    \ DES Symmetric Encryption\n   Protocol defined in this memo is one such protocol)\
    \ is optional.\n"
- title: 11.4. Use of Reports
  contents:
  - "11.4. Use of Reports\n   The use of unsecure reports (i.e., sending them with\
    \ a securityLevel\n   of noAuthNoPriv) potentially exposes a non-authoritative\
    \ SNMP engine\n   to some form of attacks.  Some people consider these denial\
    \ of\n   service attacks, others don't.  An installation should evaluate the\n\
    \   risk involved before deploying unsecure Report PDUs.\n"
- title: 11.5  Access to the SNMP-USER-BASED-SM-MIB
  contents:
  - "11.5  Access to the SNMP-USER-BASED-SM-MIB\n   The objects in this MIB may be\
    \ considered sensitive in many\n   environments.  Specifically the objects in\
    \ the usmUserTable contain\n   information about users and their authentication\
    \ and privacy\n   protocols.  It is important to closely control (both read and\
    \ write)\n   access to these MIB objects by using appropriately configured Access\n\
    \   Control models (for example the View-based Access Control Model as\n   specified\
    \ in [RFC3415]).\n"
- title: 12. References
  contents:
  - '12. References

    '
- title: 12.1 Normative References
  contents:
  - "12.1 Normative References\n   [RFC1321]       Rivest, R., \"Message Digest Algorithm\
    \ MD5\", RFC 1321,\n                   April 1992.\n   [RFC2104]       Krawczyk,\
    \ H., Bellare, M. and R. Canetti, \"HMAC:\n                   Keyed-Hashing  for\
    \ Message Authentication\", RFC 2104,\n                   February 1997.\n   [RFC2119]\
    \       Bradner, S., \"Key words for use in RFCs to Indicate\n               \
    \    Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2578]       McCloghrie,\
    \ K., Perkins, D., Schoenwaelder, J., Case,\n                   J., Rose, M. and\
    \ S. Waldbusser, \"Structure of\n                   Management Information Version\
    \ 2 (SMIv2)\", STD 58,\n                   RFC 2578, April 1999.\n   [RFC2579]\
    \       McCloghrie, K., Perkins, D., Schoenwaelder, J., Case,\n              \
    \     J., Rose, M. and S. Waldbusser, \"Textual Conventions\n                \
    \   for SMIv2\", STD 58, RFC 2579, April 1999.\n   [RFC2580]       McCloghrie,\
    \ K., Perkins, D., Schoenwaelder, J., Case,\n                   J., Rose, M. and\
    \ S. Waldbusser, \"Conformance\n                   Statements for SMIv2\", STD\
    \ 58, RFC 2580, April 1999.\n   [RFC3411]       Harrington, D., Presuhn, R. and\
    \ B. Wijnen, \"An\n                   Architecture for Describing Simple Network\
    \ Management\n                   Protocol (SNMP) Management Frameworks\", STD\
    \ 62, RFC\n                   3411, December 2002.\n   [RFC3412]       Case, J.,\
    \ Harrington, D., Presuhn, R. and B. Wijnen,\n                   \"Message Processing\
    \ and Dispatching for the Simple\n                   Network Management Protocol\
    \ (SNMP)\", STD 62, RFC\n                   3412, December 2002.\n   [RFC3415]\
    \       Wijnen, B., Presuhn, R. and K. McCloghrie, \"View-\n                 \
    \  based Access Control Model (VACM) for the Simple\n                   Network\
    \ Management Protocol (SNMP)\", STD 62, RFC\n                   3415, December\
    \ 2002.\n   [RFC3416]       Presuhn, R., Case, J., McCloghrie, K., Rose, M. and\n\
    \                   S. Waldbusser, \"Version 2 of the Protocol Operations\n  \
    \                 for the Simple Network Management Protocol (SNMP)\",\n     \
    \              STD 62, RFC 3416, December 2002.\n   [RFC3417]       Presuhn, R.,\
    \ Case, J., McCloghrie, K., Rose, M. and\n                   S.  Waldbusser, \"\
    Transport Mappings for the Simple\n                   Network Management Protocol\
    \ (SNMP)\", STD 62, RFC\n                   3417, December 2002.\n   [RFC3418]\
    \       Presuhn, R., Case, J., McCloghrie, K., Rose, M. and\n                \
    \   S. Waldbusser, \"Management Information Base (MIB) for\n                 \
    \  the Simple Network Management Protocol (SNMP)\", STD\n                   62,\
    \ RFC 3418, December 2002.\n   [DES-NIST]      Data Encryption Standard, National\
    \ Institute of\n                   Standards and Technology.  Federal Information\n\
    \                   Processing Standard (FIPS) Publication 46-1.\n           \
    \        Supersedes FIPS Publication 46, (January, 1977;\n                   reaffirmed\
    \ January, 1988).\n   [DESO-NIST]     DES Modes of Operation, National Institute\
    \ of\n                   Standards and Technology.  Federal Information\n    \
    \               Processing Standard (FIPS) Publication 81, (December,\n      \
    \             1980).\n   [SHA-NIST]      Secure Hash Algorithm. NIST FIPS 180-1,\
    \ (April, 1995)\n                   http://csrc.nist.gov/fips/fip180-1.txt (ASCII)\n\
    \                   http://csrc.nist.gov/fips/fip180-1.ps  (Postscript)\n"
- title: 12.1 Informative References
  contents:
  - "12.1 Informative References\n   [Localized-Key] U. Blumenthal, N. C. Hien, B.\
    \ Wijnen \"Key Derivation\n                   for Network Management Applications\"\
    \ IEEE Network\n                   Magazine, April/May issue, 1997.\n   [DES-ANSI]\
    \      Data Encryption Algorithm, American National\n                   Standards\
    \ Institute.  ANSI X3.92-1981, (December,\n                   1980).\n   [DESO-ANSI]\
    \     Data Encryption Algorithm - Modes of Operation,\n                   American\
    \ National Standards Institute.  ANSI X3.106-\n                   1983, (May 1983).\n\
    \   [DESG-NIST]     Guidelines for Implementing and Using the NBS Data\n     \
    \              Encryption Standard, National Institute of Standards\n        \
    \           and Technology.  Federal Information Processing\n                \
    \   Standard (FIPS) Publication 74, (April, 1981).\n   [DEST-NIST]     Validating\
    \ the Correctness of Hardware\n                   Implementations of the NBS Data\
    \ Encryption Standard,\n                   National Institute of Standards and\
    \ Technology.\n                   Special Publication 500-20.\n   [DESM-NIST]\
    \     Maintenance Testing for the Data Encryption Standard,\n                \
    \   National Institute of Standards and Technology.\n                   Special\
    \ Publication 500-61, (August, 1980).\n   [RFC3174]       Eastlake, D. 3rd and\
    \ P. Jones, \"US Secure Hash\n                   Algorithm 1 (SHA1)\", RFC 3174,\
    \ September 2001.\n"
- title: APPENDIX A - Installation
  contents:
  - 'APPENDIX A - Installation

    '
- title: A.1. SNMP engine Installation Parameters
  contents:
  - "A.1. SNMP engine Installation Parameters\n   During installation, an authoritative\
    \ SNMP engine SHOULD (in the\n   meaning as defined in [RFC2119]) be configured\
    \ with several initial\n   parameters.  These include:\n   1) A Security Posture\n\
    \      The choice of security posture determines if initial configuration\n  \
    \    is implemented and if so how.  One of three possible choices is\n      selected:\n\
    \         minimum-secure,\n         semi-secure,\n         very-secure (i.e.,\
    \ no-initial-configuration)\n      In the case of a very-secure posture, there\
    \ is no initial\n      configuration, and so the following steps are irrelevant.\n\
    \   2) One or More Secrets\n      These are the authentication/privacy secrets\
    \ for the first user to\n      be configured.\n      One way to accomplish this\
    \ is to have the installer enter a\n      \"password\" for each required secret.\
    \  The password is then\n      algorithmically converted into the required secret\
    \ by:\n      - forming a string of length 1,048,576 octets by repeating the\n\
    \        value of the password as often as necessary, truncating\n        accordingly,\
    \ and using the resulting string as the input to the\n        MD5 algorithm [RFC1321].\
    \  The resulting digest, termed\n        \"digest1\", is used in the next step.\n\
    \      - a second string is formed by concatenating digest1, the SNMP\n      \
    \  engine's snmpEngineID value, and digest1.  This string is used\n        as\
    \ input to the MD5 algorithm [RFC1321].\n        The resulting digest is the required\
    \ secret (see Appendix A.2).\n      With these configured parameters, the SNMP\
    \ engine instantiates the\n      following usmUserEntry in the usmUserTable:\n\
    \                           no privacy support     privacy support\n         \
    \                  ------------------     ---------------\n   usmUserEngineID\
    \         localEngineID          localEngineID\n   usmUserName             \"\
    initial\"              \"initial\"\n   usmUserSecurityName     \"initial\"   \
    \           \"initial\"\n   usmUserCloneFrom        ZeroDotZero            ZeroDotZero\n\
    \   usmUserAuthProtocol     usmHMACMD5AuthProtocol usmHMACMD5AuthProtocol\n  \
    \ usmUserAuthKeyChange    \"\"                     \"\"\n   usmUserOwnAuthKeyChange\
    \ \"\"                     \"\"\n   usmUserPrivProtocol     none             \
    \      usmDESPrivProtocol\n   usmUserPrivKeyChange    \"\"                   \
    \  \"\"\n   usmUserOwnPrivKeyChange \"\"                     \"\"\n   usmUserPublic\
    \           \"\"                     \"\"\n   usmUserStorageType      anyValidStorageType\
    \    anyValidStorageType\n   usmUserStatus           active                 active\n\
    \      It is recommended to also instantiate a set of template\n      usmUserEntries\
    \ which can be used as clone-from users for newly\n      created usmUserEntries.\
    \  These are the two suggested entries:\n                           no privacy\
    \ support     privacy support\n                           ------------------ \
    \    ---------------\n   usmUserEngineID         localEngineID          localEngineID\n\
    \   usmUserName             \"templateMD5\"          \"templateMD5\"\n   usmUserSecurityName\
    \     \"templateMD5\"          \"templateMD5\"\n   usmUserCloneFrom        ZeroDotZero\
    \            ZeroDotZero\n   usmUserAuthProtocol     usmHMACMD5AuthProtocol usmHMACMD5AuthProtocol\n\
    \   usmUserAuthKeyChange    \"\"                     \"\"\n   usmUserOwnAuthKeyChange\
    \ \"\"                     \"\"\n   usmUserPrivProtocol     none             \
    \      usmDESPrivProtocol\n   usmUserPrivKeyChange    \"\"                   \
    \  \"\"\n   usmUserOwnPrivKeyChange \"\"                     \"\"\n   usmUserPublic\
    \           \"\"                     \"\"\n   usmUserStorageType      permanent\
    \              permanent\n   usmUserStatus           active                 active\n\
    \                           no privacy support     privacy support\n         \
    \                  ------------------     ---------------\n   usmUserEngineID\
    \         localEngineID          localEngineID\n   usmUserName             \"\
    templateSHA\"          \"templateSHA\"\n   usmUserSecurityName     \"templateSHA\"\
    \          \"templateSHA\"\n   usmUserCloneFrom        ZeroDotZero           \
    \ ZeroDotZero\n   usmUserAuthProtocol     usmHMACSHAAuthProtocol usmHMACSHAAuthProtocol\n\
    \   usmUserAuthKeyChange    \"\"                     \"\"\n   usmUserOwnAuthKeyChange\
    \ \"\"                     \"\"\n   usmUserPrivProtocol     none             \
    \      usmDESPrivProtocol\n   usmUserPrivKeyChange    \"\"                   \
    \  \"\"\n   usmUserOwnPrivKeyChange \"\"                     \"\"\n   usmUserPublic\
    \           \"\"                     \"\"\n   usmUserStorageType      permanent\
    \              permanent\n   usmUserStatus           active                 active\n"
- title: A.2. Password to Key Algorithm
  contents:
  - "A.2. Password to Key Algorithm\n   A sample code fragment (section A.2.1) demonstrates\
    \ the password to\n   key algorithm which can be used when mapping a password\
    \ to an\n   authentication or privacy key using MD5.  The reference source code\n\
    \   of MD5 is available in [RFC1321].\n   Another sample code fragment (section\
    \ A.2.2) demonstrates the\n   password to key algorithm which can be used when\
    \ mapping a password\n   to an authentication or privacy key using SHA (documented\
    \ in SHA-\n   NIST).\n   An example of the results of a correct implementation\
    \ is provided\n   (section A.3) which an implementor can use to check if his\n\
    \   implementation produces the same result.\n"
- title: A.2.1. Password to Key Sample Code for MD5
  contents:
  - "A.2.1. Password to Key Sample Code for MD5\n   void password_to_key_md5(\n  \
    \    u_char *password,    /* IN */\n      u_int   passwordlen, /* IN */\n    \
    \  u_char *engineID,    /* IN  - pointer to snmpEngineID  */\n      u_int   engineLength,/*\
    \ IN  - length of snmpEngineID */\n      u_char *key)         /* OUT - pointer\
    \ to caller 16-octet buffer */\n   {\n      MD5_CTX     MD;\n      u_char    \
    \ *cp, password_buf[64];\n      u_long      password_index = 0;\n      u_long\
    \      count = 0, i;\n      MD5Init (&MD);   /* initialize MD5 */\n      /**********************************************/\n\
    \      /* Use while loop until we've done 1 Megabyte */\n      /**********************************************/\n\
    \      while (count < 1048576) {\n         cp = password_buf;\n         for (i\
    \ = 0; i < 64; i++) {\n             /*************************************************/\n\
    \             /* Take the next octet of the password, wrapping */\n          \
    \   /* to the beginning of the password as necessary.*/\n             /*************************************************/\n\
    \             *cp++ = password[password_index++ % passwordlen];\n         }\n\
    \         MD5Update (&MD, password_buf, 64);\n         count += 64;\n      }\n\
    \      MD5Final (key, &MD);          /* tell MD5 we're done */\n      /*****************************************************/\n\
    \      /* Now localize the key with the engineID and pass   */\n      /* through\
    \ MD5 to produce final key                  */\n      /* May want to ensure that\
    \ engineLength <= 32,       */\n      /* otherwise need to use a buffer larger\
    \ than 64     */\n      /*****************************************************/\n\
    \      memcpy(password_buf, key, 16);\n      memcpy(password_buf+16, engineID,\
    \ engineLength);\n      memcpy(password_buf+16+engineLength, key, 16);\n     \
    \ MD5Init(&MD);\n      MD5Update(&MD, password_buf, 32+engineLength);\n      MD5Final(key,\
    \ &MD);\n      return;\n   }\n"
- title: A.2.2. Password to Key Sample Code for SHA
  contents:
  - "A.2.2. Password to Key Sample Code for SHA\n   void password_to_key_sha(\n  \
    \    u_char *password,    /* IN */\n      u_int   passwordlen, /* IN */\n    \
    \  u_char *engineID,    /* IN  - pointer to snmpEngineID  */\n      u_int   engineLength,/*\
    \ IN  - length of snmpEngineID */\n      u_char *key)         /* OUT - pointer\
    \ to caller 20-octet buffer */\n   {\n      SHA_CTX     SH;\n      u_char    \
    \ *cp, password_buf[72];\n      u_long      password_index = 0;\n      u_long\
    \      count = 0, i;\n      SHAInit (&SH);   /* initialize SHA */\n      /**********************************************/\n\
    \      /* Use while loop until we've done 1 Megabyte */\n      /**********************************************/\n\
    \      while (count < 1048576) {\n         cp = password_buf;\n         for (i\
    \ = 0; i < 64; i++) {\n             /*************************************************/\n\
    \             /* Take the next octet of the password, wrapping */\n          \
    \   /* to the beginning of the password as necessary.*/\n             /*************************************************/\n\
    \             *cp++ = password[password_index++ % passwordlen];\n         }\n\
    \         SHAUpdate (&SH, password_buf, 64);\n         count += 64;\n      }\n\
    \      SHAFinal (key, &SH);          /* tell SHA we're done */\n      /*****************************************************/\n\
    \      /* Now localize the key with the engineID and pass   */\n      /* through\
    \ SHA to produce final key                  */\n      /* May want to ensure that\
    \ engineLength <= 32,       */\n      /* otherwise need to use a buffer larger\
    \ than 72     */\n      /*****************************************************/\n\
    \      memcpy(password_buf, key, 20);\n      memcpy(password_buf+20, engineID,\
    \ engineLength);\n      memcpy(password_buf+20+engineLength, key, 20);\n     \
    \ SHAInit(&SH);\n      SHAUpdate(&SH, password_buf, 40+engineLength);\n      SHAFinal(key,\
    \ &SH);\n      return;\n   }\n"
- title: A.3. Password to Key Sample Results
  contents:
  - 'A.3. Password to Key Sample Results

    '
- title: A.3.1. Password to Key Sample Results using MD5
  contents:
  - "A.3.1. Password to Key Sample Results using MD5\n   The following shows a sample\
    \ output of the password to key algorithm\n   for a 16-octet key using MD5.\n\
    \   With a password of \"maplesyrup\" the output of the password to key\n   algorithm\
    \ before the key is localized with the SNMP engine's\n   snmpEngineID is:\n  \
    \    '9f af 32 83 88 4e 92 83 4e bc 98 47 d8 ed d9 63'H\n   After the intermediate\
    \ key (shown above) is localized with the\n   snmpEngineID value of:\n      '00\
    \ 00 00 00 00 00 00 00 00 00 00 02'H\n   the final output of the password to key\
    \ algorithm is:\n      '52 6f 5e ed 9f cc e2 6f 89 64 c2 93 07 87 d8 2b'H\n"
- title: A.3.2. Password to Key Sample Results using SHA
  contents:
  - "A.3.2. Password to Key Sample Results using SHA\n   The following shows a sample\
    \ output of the password to key algorithm\n   for a 20-octet key using SHA.\n\
    \   With a password of \"maplesyrup\" the output of the password to key\n   algorithm\
    \ before the key is localized with the SNMP engine's\n   snmpEngineID is:\n  \
    \    '9f b5 cc 03 81 49 7b 37 93 52 89 39 ff 78 8d 5d 79 14 52 11'H\n   After\
    \ the intermediate key (shown above) is localized with the\n   snmpEngineID value\
    \ of:\n      '00 00 00 00 00 00 00 00 00 00 00 02'H\n   the final output of the\
    \ password to key algorithm is:\n      '66 95 fe bc 92 88 e3 62 82 23 5f c7 15\
    \ 1f 12 84 97 b3 8f 3f'H\n"
- title: A.4. Sample Encoding of msgSecurityParameters
  contents:
  - "A.4. Sample Encoding of msgSecurityParameters\n   The msgSecurityParameters in\
    \ an SNMP message are represented as an\n   OCTET STRING.  This OCTET STRING should\
    \ be considered opaque outside\n   a specific Security Model.\n   The User-based\
    \ Security Model defines the contents of the OCTET\n   STRING as a SEQUENCE (see\
    \ section 2.4).\n   Given these two properties, the following is an example of\
    \ they\n   msgSecurityParameters for the User-based Security Model, encoded as\n\
    \   an OCTET STRING:\n      04 <length>\n      30 <length>\n      04 <length>\
    \ <msgAuthoritativeEngineID>\n      02 <length> <msgAuthoritativeEngineBoots>\n\
    \      02 <length> <msgAuthoritativeEngineTime>\n      04 <length> <msgUserName>\n\
    \      04 0c       <HMAC-MD5-96-digest>\n      04 08       <salt>\n   Here is\
    \ the example once more, but now with real values (except for\n   the digest in\
    \ msgAuthenticationParameters and the salt in\n   msgPrivacyParameters, which\
    \ depend on variable data that we have not\n   defined here):\n      Hex Data\
    \                         Description\n      --------------  -----------------------------------------------\n\
    \      04 39           OCTET STRING,                  length 57\n      30 37 \
    \          SEQUENCE,                      length 55\n      04 0c 80000002  msgAuthoritativeEngineID:\
    \      IBM\n            01                                       IPv4 address\n\
    \            09840301                                 9.132.3.1\n      02 01 01\
    \        msgAuthoritativeEngineBoots:   1\n      02 02 0101      msgAuthoritativeEngineTime:\
    \    257\n      04 04 62657274  msgUserName:                   bert\n      04\
    \ 0c 01234567  msgAuthenticationParameters:   sample value\n            89abcdef\n\
    \            fedcba98\n      04 08 01234567  msgPrivacyParameters:          sample\
    \ value\n            89abcdef\n"
- title: A.5. Sample keyChange Results
  contents:
  - 'A.5. Sample keyChange Results

    '
- title: A.5.1. Sample keyChange Results using MD5
  contents:
  - "A.5.1. Sample keyChange Results using MD5\n   Let us assume that a user has a\
    \ current password of \"maplesyrup\" as\n   in section A.3.1. and let us also\
    \ assume the snmpEngineID of 12\n   octets:\n      '00 00 00 00 00 00 00 00 00\
    \ 00 00 02'H\n   If we now want to change the password to \"newsyrup\", then we\
    \ first\n   calculate the key for the new password.  It is as follows:\n     \
    \ '01 ad d2 73 10 7c 4e 59 6b 4b 00 f8 2b 1d 42 a7'H\n   If we localize it for\
    \ the above snmpEngineID, then the localized new\n   key becomes:\n      '87 02\
    \ 1d 7b d9 d1 01 ba 05 ea 6e 3b f9 d9 bd 4a'H\n   If we then use a (not so good,\
    \ but easy to test) random value of:\n      '00 00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00 00 00'H\n   Then the value we must send for keyChange is:\n      '00\
    \ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n       88 05 61 51 41 67 6c c9\
    \ 19 61 74 e7 42 a3 25 51'H\n   If this were for the privacy key, then it would\
    \ be exactly the same.\n"
- title: A.5.2. Sample keyChange Results using SHA
  contents:
  - "A.5.2. Sample keyChange Results using SHA\n   Let us assume that a user has a\
    \ current password of \"maplesyrup\" as\n   in section A.3.2. and let us also\
    \ assume the snmpEngineID of 12\n   octets:\n      '00 00 00 00 00 00 00 00 00\
    \ 00 00 02'H\n   If we now want to change the password to \"newsyrup\", then we\
    \ first\n   calculate the key for the new password.  It is as follows:\n     \
    \ '3a 51 a6 d7 36 aa 34 7b 83 dc 4a 87 e3 e5 5e e4 d6 98 ac 71'H\n   If we localize\
    \ it for the above snmpEngineID, then the localized new\n   key becomes:\n   \
    \   '78 e2 dc ce 79 d5 94 03 b5 8c 1b ba a5 bf f4 63 91 f1 cd 25'H\n   If we then\
    \ use a (not so good, but easy to test) random value of:\n      '00 00 00 00 00\
    \ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'H\n   Then the value we must send\
    \ for keyChange is:\n      '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\
    \ 00 00 00\n       9c 10 17 f4 fd 48 3d 2d e8 d5 fa db f8 43 92 cb 06 45 70 51'\n\
    \   For the key used for privacy, the new nonlocalized key would be:\n      '3a\
    \ 51 a6 d7 36 aa 34 7b 83 dc 4a 87 e3 e5 5e e4 d6 98 ac 71'H\n   For the key used\
    \ for privacy, the new localized key would be (note\n   that they localized key\
    \ gets truncated to 16 octets for DES):\n      '78 e2 dc ce 79 d5 94 03 b5 8c\
    \ 1b ba a5 bf f4 63'H\n   If we then use a (not so good, but easy to test) random\
    \ value of:\n      '00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'H\n   Then\
    \ the value we must send for keyChange for the privacy key is:\n      '00 00 00\
    \ 00 00 00 00 00 00 00 00 00 00 00 00 00\n      '7e f8 d8 a4 c9 cd b2 6b 47 59\
    \ 1c d8 52 ff 88 b5'H\n"
- title: B. Change Log
  contents:
  - "B. Change Log\n   Changes made since RFC2574:\n   - Updated references\n   -\
    \ Updated contact info\n   - Clarifications\n     - to first constraint item 1)\
    \ on page 6.\n     - to usmUserCloneFrom DESCRIPTION clause\n     - to securityName\
    \ in section 2.1\n   - Fixed \"command responder\" into \"command generator\"\
    \ in last para of\n     DESCRIPTION clause of usmUserTable.\n   Changes made since\
    \ RFC2274:\n   - Fixed msgUserName to allow size of zero and explain that this\
    \ can\n     be used for snmpEngineID discovery.\n   - Clarified section 3.1 steps\
    \ 4.b, 5, 6 and 8.b.\n   - Clarified section 3.2 paragraph 2.\n   - Clarified\
    \ section 3.2 step 7.a last paragraph, step 7.b.1 second\n     bullet and step\
    \ 7.b.2 third bullet.\n   - Clarified section 4 to indicate that discovery can\
    \ use a userName\n     of zero length in unAuthenticated messages, whereas a valid\n\
    \     userName must be used in authenticated messages.\n   - Added REVISION clauses\
    \ to MODULE-IDENTITY\n   - Clarified KeyChange TC by adding a note that localized\
    \ keys must be\n     used when calculating a KeyChange value.\n   - Added clarifying\
    \ text to the DESCRIPTION clause of usmUserTable.\n     Added text describes a\
    \ recommended procedure for adding a new user.\n   - Clarified the use of usmUserCloneFrom\
    \ object.\n   - Clarified how and under which conditions the usmUserAuthProtocol\n\
    \     and usmUserPrivProtocol can be initialized and/or changed.\n   - Added comment\
    \ on typical sizes for usmUserAuthKeyChange and\n     usmUserPrivKeyChange.  Also\
    \ for usmUserOwnAuthKeyChange and\n     usmUserOwnPrivKeyChange.\n   - Added clarifications\
    \ to the DESCRIPTION clauses of\n     usmUserAuthKeyChange, usmUserOwnAuthKeychange,\
    \ usmUserPrivKeyChange\n     and usmUserOwnPrivKeychange.\n   - Added clarification\
    \ to DESCRIPTION clause of usmUserStorageType.\n   - Added clarification to DESCRIPTION\
    \ clause of usmUserStatus.\n   - Clarified IV generation procedure in section\
    \ 8.1.1.1 and in\n     addition clarified section 8.3.1 step 1 and section 8.3.2.\
    \ step 3.\n   - Clarified section 11.2 and added a warning that different size\n\
    \     passwords with repetitive strings may result in same key.\n   - Added template\
    \ users to appendix A for cloning process.\n   - Fixed C-code examples in Appendix\
    \ A.\n   - Fixed examples of generated keys in Appendix A.\n   - Added examples\
    \ of KeyChange values to Appendix A.\n   - Used PDU Classes instead of RFC1905\
    \ PDU types.\n   - Added text in the security section about Reports and Access\
    \ Control\n     to the MIB.\n   - Removed a incorrect note at the end of section\
    \ 3.2 step 7.\n   - Added a note in section 3.2 step 3.\n   - Corrected various\
    \ spelling errors and typos.\n   - Corrected procedure for 3.2 step 2.a)\n   -\
    \ various clarifications.\n   - Fixed references to new/revised documents\n  \
    \ - Change to no longer cache data that is not used\n"
- title: Editors' Addresses
  contents:
  - "Editors' Addresses\n   Uri Blumenthal\n   Lucent Technologies\n   67 Whippany\
    \ Rd.\n   Whippany, NJ 07981\n   USA\n   Phone: +1-973-386-2163\n   EMail: uri@lucent.com\n\
    \   Bert Wijnen\n   Lucent Technologies\n   Schagen 33\n   3461 GL Linschoten\n\
    \   Netherlands\n   Phone: +31-348-480-685\n   EMail: bwijnen@lucent.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2002).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
