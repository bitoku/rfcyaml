- title: __initial_text__
  contents:
  - "               Secure Pre-Shared Key (PSK) Authentication\n              for\
    \ the Internet Key Exchange Protocol (IKE)\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes a secure pre-shared key (PSK) authentication\n\
    \   method for the Internet Key Exchange Protocol (IKE).  It is resistant\n  \
    \ to dictionary attack and retains security even when used with weak\n   pre-shared\
    \ keys.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6617.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Keyword Definitions ........................................3\n  \
    \ 2. Usage Scenarios .................................................3\n   3.\
    \ Terms and Notation ..............................................4\n   4. Discrete\
    \ Logarithm Cryptography .................................5\n      4.1. Elliptic\
    \ Curve Cryptography (ECP) Groups ...................5\n      4.2. Finite Field\
    \ Cryptography (MODP) Groups ....................7\n   5. Random Numbers ..................................................8\n\
    \   6. Using Passwords and Raw Keys For Authentication .................8\n  \
    \ 7. Assumptions .....................................................9\n   8.\
    \ Secure PSK Authentication Message Exchange ......................9\n      8.1.\
    \ Negotiation of Secure PSK Authentication ..................10\n      8.2. Fixing\
    \ the Secret Element, SKE ............................11\n           8.2.1. ECP\
    \ Operation to Select SKE ........................12\n           8.2.2. MODP Operation\
    \ to Select SKE .......................13\n      8.3. Encoding and Decoding of\
    \ Group Elements and Scalars .......14\n           8.3.1. Encoding and Decoding\
    \ of Scalars ...................14\n           8.3.2. Encoding and Decoding of\
    \ ECP Elements ..............15\n           8.3.3. Encoding and Decoding of MODP\
    \ Elements .............15\n      8.4. Message Generation and Processing .........................16\n\
    \           8.4.1. Generation of a Commit .............................16\n  \
    \         8.4.2. Processing of a Commit .............................16\n    \
    \              8.4.2.1. Validation of an ECP Element ..............16\n      \
    \            8.4.2.2. Validation of a MODP Element ..............16\n        \
    \          8.4.2.3. Commit Processing Steps ...................17\n          \
    \ 8.4.3. Authentication of the Exchange .....................17\n      8.5. Payload\
    \ Format ............................................18\n           8.5.1. Commit\
    \ Payload .....................................18\n      8.6. IKEv2 Messaging\
    \ ...........................................19\n   9. IANA Considerations ............................................20\n\
    \   10. Security Considerations .......................................20\n  \
    \ 11. Acknowledgements ..............................................22\n   12.\
    \ References ....................................................22\n      12.1.\
    \ Normative References .....................................22\n      12.2. Informative\
    \ References ...................................23\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   [RFC5996] allows for authentication of the IKE peers using\
    \ a pre-\n   shared key.  This exchange, though, is susceptible to dictionary\n\
    \   attack and is therefore insecure when used with weak pre-shared keys,\n  \
    \ such as human-memorizable passwords.  To address the security issue,\n   [RFC5996]\
    \ recommends that the pre-shared key used for authentication\n   \"contain as\
    \ much unpredictability as the strongest key being\n   negotiated\".  That means\
    \ any non-hexadecimal key would require over\n   100 characters to provide enough\
    \ strength to generate a 128-bit key\n   suitable for AES.  This is an unrealistic\
    \ requirement because humans\n   have a hard time entering a string over 20 characters\
    \ without error.\n   Consequently, pre-shared key authentication in [RFC5996]\
    \ is used\n   insecurely today.\n   A pre-shared key authentication method built\
    \ on top of a zero-\n   knowledge proof will provide resistance to dictionary\
    \ attack and\n   still allow for security when used with weak pre-shared keys,\
    \ such as\n   user-chosen passwords.  Such an authentication method is described\
    \ in\n   this memo.\n   Resistance to dictionary attack is achieved when an adversary\
    \ gets\n   one, and only one, guess at the secret per active attack (see, for\n\
    \   example, [BM92], [BMP00], and [BPR00]).  Another way of putting this\n   is\
    \ that any advantage the adversary can realize is through\n   interaction and\
    \ not through computation.  This is demonstrably\n   different than the technique\
    \ from [RFC5996] of using a large, random\n   number as the pre-shared key.  That\
    \ can only make a dictionary attack\n   less likely to succeed; it does not prevent\
    \ a dictionary attack.\n   Furthermore, as [RFC5996] notes, it is completely insecure\
    \ when used\n   with weak keys like user-generated passwords.\n"
- title: 1.1.  Keyword Definitions
  contents:
  - "1.1.  Keyword Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 2.  Usage Scenarios
  contents:
  - "2.  Usage Scenarios\n   [RFC5996] describes usage scenarios for IKEv2.  These\
    \ are:\n   1.  \"Security Gateway to Security Gateway Tunnel\": The endpoints\
    \ of\n       the IKE (and IPsec) communication are network nodes that protect\n\
    \       traffic on behalf of connected networks.  Protected traffic is\n     \
    \  between devices on the respective protected networks.\n   2.  \"Endpoint-to-Endpoint\
    \ Transport\": The endpoints of the IKE (and\n       IPsec) communication are\
    \ hosts according to [RFC4301].  Protected\n       traffic is between the two\
    \ endpoints.\n   3.  \"Endpoint to Security Gateway Tunnel\": One endpoint connects\
    \ to a\n       protected network through a network node.  The endpoints of the\n\
    \       IKE (and IPsec) communication are the endpoint and network node,\n   \
    \    but the protected traffic is between the endpoint and another\n       device\
    \ on the protected network behind the node.\n   The authentication and key exchange\
    \ process described in this memo is\n   suitable for all the usage scenarios described\
    \ in [RFC5996].  In the\n   \"Security Gateway to Security Gateway Tunnel\" scenario\
    \ and the\n   \"Endpoint-to-Endpoint Transport\" scenario, it provides a secure\n\
    \   method of authentication without requiring a certificate.  For the\n   \"\
    Endpoint to Security Gateway Tunnel\" scenario, it provides for\n   secure username+password\
    \ authentication that is popular in remote-\n   access VPN situations.\n"
- title: 3.  Terms and Notation
  contents:
  - "3.  Terms and Notation\n   The following terms and notations are used in this\
    \ memo:\n   PSK\n       A shared, secret, and potentially low-entropy word, phrase,\
    \ code,\n       or key used as a credential to mutually authenticate the peers.\n\
    \   a = prf(b, c)\n       The string \"b\" and \"c\" are given to a pseudo-random\
    \ function\n       (prf) to produce a fixed-length output \"a\".\n   a | b\n \
    \      denotes concatenation of string \"a\" with string \"b\".\n   [a]b\n   \
    \    indicates a string consisting of the single bit \"a\" repeated \"b\"\n  \
    \     times.\n   len(a)\n       indicates the length in bits of the string \"\
    a\".\n   LSB(a)\n       returns the least-significant bit of the bitstring \"\
    a\".\n   element\n       one member of a finite cyclic group.\n   scalar\n   \
    \    a quantity that can multiply an element.\n   The convention for this memo\
    \ to represent an element in a finite\n   cyclic group is to use an upper-case\
    \ letter or acronym, while a\n   scalar is indicated with a lowercase letter or\
    \ acronym.\n"
- title: 4.  Discrete Logarithm Cryptography
  contents:
  - "4.  Discrete Logarithm Cryptography\n   This protocol uses Discrete Logarithm\
    \ Cryptography to achieve\n   authentication.  Each party to the exchange derives\
    \ ephemeral public\n   and private keys with respect to a particular set of domain\n\
    \   parameters (referred to here as a \"group\").  Groups can be either\n   based\
    \ on finite field cryptography (modular exponentiation (MODP)\n   groups) or elliptic\
    \ curve cryptography (ECP groups).\n   This protocol uses the same group as the\
    \ IKE exchange in which it is\n   being used for authentication, with the exception\
    \ of characteristic-\n   two elliptic curve groups (EC2N).  Use of such groups\
    \ is undefined\n   for this authentication method, and an IKE exchange that negotiates\n\
    \   one of these groups MUST NOT use this method of authentication.\n   For each\
    \ group, the following operations are defined:\n   o  \"scalar operation\" --\
    \ takes a scalar and an element in the group\n      to produce another element\
    \ -- Z = scalar-op(x, Y).\n   o  \"element operation\" -- takes two elements in\
    \ the group to produce\n      a third -- Z = element-op(X, Y).\n   o  \"inverse\
    \ operation\" -- takes an element and returns another\n      element such that\
    \ the element operation on the two produces the\n      identity element of the\
    \ group -- Y = inverse(X).\n"
- title: 4.1.  Elliptic Curve Cryptography (ECP) Groups
  contents:
  - "4.1.  Elliptic Curve Cryptography (ECP) Groups\n   The key exchange defined in\
    \ this memo uses fundamental algorithms of\n   ECP groups as described in [RFC6090].\n\
    \   Domain parameters for ECP elliptic curves used for Secure PSK\n   Authentication\
    \ include:\n   o  A prime, p, determining a prime field GF(p).  The cryptographic\n\
    \      group will be a subgroup of the full elliptic curve group that\n      consists\
    \ of points on an elliptic curve -- elements from GF(p)\n      that satisfy the\
    \ curve's equation -- together with the \"point at\n      infinity\" (denoted\
    \ here as \"0\") that serves as the identity\n      element.\n   o  Elements a\
    \ and b from GF(p) that define the curve's equation.  The\n      point (x,y) is\
    \ on the elliptic curve if and only if y^2 = x^3 +\n      a*x + b.\n   o  A prime,\
    \ r, which is the order of, or number of elements in, a\n      subgroup generated\
    \ by an element G.\n   The scalar operation is multiplication of a point on the\
    \ curve by\n   itself a number of times.  The point Y is multiplied x-times to\n\
    \   produce another point Z:\n       Z = scalar-op(x, Y) = x*Y\n   The element\
    \ operation is addition of two points on the curve.  Points\n   X and Y are summed\
    \ to produce another point Z:\n       Z = element-op(X, Y) = X + Y\n   The inverse\
    \ function is defined such that the sum of an element and\n   its inverse is \"\
    0\", the point-at-infinity of an elliptic curve group:\n       Q + inverse(Q)\
    \ = \"0\"\n   Elliptic curve groups require a mapping function, q = F(Q), to\n\
    \   convert a group element to an integer.  The mapping function used in\n   this\
    \ memo returns the x-coordinate of the point it is passed.\n   scalar-op(x, Y)\
    \ can be viewed as x iterations of element-op() by\n   defining:\n       Y = scalar-op(1,\
    \ Y)\n       Y = scalar-op(x, Y) = element-op(Y, scalar-op(x-1, Y)), for x > 1\n\
    \   A definition of how to add two points on an elliptic curve (i.e.,\n   element-op(X,\
    \ Y)) can be found in [RFC6090].\n   Note: There is another ECP domain parameter,\
    \ a cofactor, h, that is\n   defined by the requirement that the size of the full\
    \ elliptic curve\n   group (including \"0\") be the product of h and r.  ECP groups\
    \ used for\n   Secure PSK Authentication MUST have a cofactor of one (1).  At\
    \ the\n   time of publication of this memo, all ECP groups in [IKEV2-IANA] had\n\
    \   a cofactor of one (1).\n"
- title: 4.2.  Finite Field Cryptography (MODP) Groups
  contents:
  - "4.2.  Finite Field Cryptography (MODP) Groups\n   Domain parameters for MODP\
    \ groups used for Secure PSK Authentication\n   include:\n   o  A prime, p, determining\
    \ a prime field GF(p), the integers modulo\n      p.\n   o  A prime, r, which\
    \ is the multiplicative order, and thus also the\n      size, of the cryptographic\
    \ subgroup of GF(p)* that is generated by\n      an element G.\n   The scalar\
    \ operation is exponentiation of a generator modulo a prime.\n   An element Y\
    \ is taken to the x-th power modulo the prime, thereby\n   returning another element,\
    \ Z:\n       Z = scalar-op(x, Y) = Y^x mod p\n   The element operation is modular\
    \ multiplication.  Two elements, X and\n   Y, are multiplied modulo the prime,\
    \ thereby returning another\n   element, Z:\n       Z = element-op(X, Y) = (X\
    \ * Y) mod p\n   The inverse function for a MODP group is defined such that the\n\
    \   product of an element and its inverse modulo the group prime equals\n   one\
    \ (1).  In other words,\n       (Q * inverse(Q)) mod p = 1\n   Unlike ECP groups,\
    \ MODP groups do not require a mapping function to\n   convert an element into\
    \ an integer.  However, for the purposes of\n   notation in protocol definition,\
    \ the function F, when used below,\n   shall just return the value that was passed\
    \ to it, i.e., F(i) = i.\n   Some MODP groups in [IKEV2-IANA] are based on safe\
    \ primes, and the\n   order is not included in the group's domain parameter set.\
    \  In this\n   case only, the order, r, MUST be computed as the prime minus one\n\
    \   divided by two -- (p-1)/2.  If an order is included in the group's\n   domain\
    \ parameter set, that value MUST be used in this exchange when\n   an order is\
    \ called for.  If a MODP group does not include an order in\n   its domain parameter\
    \ set and is not based on a safe prime, it MUST\n   NOT be used with this exchange.\n"
- title: 5.  Random Numbers
  contents:
  - "5.  Random Numbers\n   As with IKE itself, the security of the Secure PSK Authentication\n\
    \   method relies upon each participant in the protocol producing quality\n  \
    \ secret random numbers.  A poor random number chosen by either side in\n   a\
    \ single exchange can compromise the shared secret from that exchange\n   and\
    \ open up the possibility of a dictionary attack.\n   Producing quality random\
    \ numbers without specialized hardware entails\n   using a cryptographic mixing\
    \ function (like a strong hash function)\n   to mix entropy from multiple, uncorrelated\
    \ sources of information and\n   events.  A very good discussion of this can be\
    \ found in [RFC4086].\n"
- title: 6.  Using Passwords and Raw Keys For Authentication
  contents:
  - "6.  Using Passwords and Raw Keys For Authentication\n   The PSK used as an authentication\
    \ credential with this protocol can\n   be either a character-based password or\
    \ passphrase, or it could be a\n   binary or hexadecimal string.  Regardless,\
    \ however, this protocol\n   requires both the Initiator and Responder to have\
    \ identical binary\n   representations of the shared credential.\n   If the PSK\
    \ is a character-based password or passphrase, there are two\n   types of pre-processing\
    \ that SHALL be employed to convert the\n   password or passphrase into a hexadecimal\
    \ string suitable for use\n   with Secure PSK Authentication.  If a PSK is already\
    \ a hexadecimal or\n   binary string, it SHALL be used directly as the shared\
    \ credential\n   without any pre-processing.\n   The first step of pre-processing\
    \ is to remove ambiguities that may\n   arise due to internationalization.  Each\
    \ character-based password or\n   passphrase MUST be pre-processed to remove that\
    \ ambiguity by\n   processing the character-based password or passphrase according\
    \ to\n   the rules of the SASLprep [RFC4013] profile of [RFC3454].  The\n   password\
    \ or passphrase SHALL be considered a \"stored string\" per\n   [RFC3454], and\
    \ unassigned code points are therefore prohibited.  The\n   output SHALL be the\
    \ binary representation of the processed UTF-8\n   character string.  Prohibited\
    \ output and unassigned codepoints\n   encountered in SASLprep pre-processing\
    \ SHALL cause a failure of pre-\n   processing, and the output SHALL NOT be used\
    \ with Secure PSK\n   Authentication.\n   The next pre-processing step for character-based\
    \ passwords or\n   passphrases is to effectively obfuscate the string.  This is\
    \ done in\n   an attempt to reduce exposure of stored passwords in the event of\n\
    \   server compromise, or compromise of a server's database of stored\n   passwords.\
    \  The step involves taking the output of the SASLprep\n   [RFC4013] profile of\
    \ [RFC3454] and passing it, as the key, with the\n   ASCII string \"IKE Secure\
    \ PSK Authentication\", as the data, to HMAC-\n   SHA256().  The output of this\
    \ obfuscation step SHALL become the\n   shared credential used with Secure PSK\
    \ Authentication.\n   Note: Passwords tend to be shared for multiple purposes,\
    \ and\n   compromise of a server or database of stored plaintext passwords can\n\
    \   be used, in that event, to mount multiple attacks.  The obfuscation\n   step\
    \ is merely to hide the password in the event of server compromise\n   or compromise\
    \ of the database of stored passwords.  Advances in\n   distributed computing\
    \ power have diminished the effectiveness of\n   performing multiple prf iterations\
    \ as a technique to prevent\n   dictionary attacks, so no such behavior is proscribed\
    \ here.  Mutually\n   consenting implementations can agree to use a different\
    \ password\n   obfuscation method; the one described here is for interoperability\n\
    \   purposes only.\n   If a device stores passwords for use at a later time, it\
    \ SHOULD pre-\n   process the password prior to storage.  If a user enters a password\n\
    \   into a device at authentication time, it MUST be pre-processed upon\n   entry\
    \ and prior to use with Secure PSK Authentication.\n"
- title: 7.  Assumptions
  contents:
  - "7.  Assumptions\n   The security of the protocol relies on certain assumptions.\
    \  They\n   are:\n   1.  The pseudo-random function, prf, defined in [RFC5996],\
    \ acts as an\n       \"extractor\" (see [RFC5869]) by distilling the entropy from\
    \ a\n       secret input into a short, fixed string.  The output of prf is\n \
    \      indistinguishable from a random source.\n   2.  The discrete logarithm\
    \ problem for the chosen finite cyclic group\n       is hard.  That is, given\
    \ G, p and Y = G^x mod p, it is\n       computationally infeasible to determine\
    \ x.  Similarly, for an\n       elliptic curve group given the curve definition,\
    \ a generator G,\n       and Y = x * G, it is computationally infeasible to determine\
    \ x.\n   3.  The pre-shared key is drawn from a finite pool of potential keys.\n\
    \       Each possible key in the pool has equal probability of being the\n   \
    \    shared key.  All potential adversaries have access to this pool\n       of\
    \ keys.\n"
- title: 8.  Secure PSK Authentication Message Exchange
  contents:
  - "8.  Secure PSK Authentication Message Exchange\n   The key exchange described\
    \ in this memo is based on the \"Dragonfly\"\n   key exchange, which has also\
    \ been defined for use in 802.11 wireless\n   networks (see [SAE]) and as an Extensible\
    \ Authentication Protocol\n   (EAP) method (see [RFC5931]).  \"Dragonfly\" is\
    \ patent-free and\n   royalty-free.  It SHALL use the same pseudo-random function\
    \ (prf) and\n   the same Diffie-Hellman group that are negotiated for use in the\
    \ IKE\n   exchange that \"Dragonfly\" is authenticating.\n   A pseudo-random function\
    \ that uses a block cipher is NOT RECOMMENDED\n   for use with Secure PSK Authentication\
    \ due to its poor job operating\n   as an \"extractor\" (see Section 7).  Pseudo-random\
    \ functions based on\n   hash functions using the HMAC construct from [RFC2104]\
    \ SHOULD be\n   used.\n   To perform Secure PSK Authentication, each side must\
    \ generate a\n   shared and secret element in the chosen group based on the pre-shared\n\
    \   key.  This element, called the Secret Key Element, or SKE, is then\n   used\
    \ in the \"Dragonfly\" authentication and key exchange protocol.\n   \"Dragonfly\"\
    \ consists of each side exchanging a Commit payload and\n   then proving knowledge\
    \ of the resulting shared secret.\n   The Commit payload contributes ephemeral\
    \ information to the exchange\n   and binds the sender to a single value of the\
    \ pre-shared key from the\n   pool of potential pre-shared keys.  An authentication\
    \ payload (AUTH)\n   proves that the pre-shared key is known and completes the\
    \ zero-\n   knowledge proof.\n"
- title: 8.1.  Negotiation of Secure PSK Authentication
  contents:
  - "8.1.  Negotiation of Secure PSK Authentication\n   The Initiator indicates its\
    \ desire to use Secure PSK Authentication\n   by adding a Notify payload of type\
    \ SECURE_PASSWORD_METHODS (see\n   [RFC6467]) to the first message of the IKE_SA_INIT\
    \ exchange and by\n   including 3 in the notification data field of the Notify\
    \ payload,\n   indicating Secure PSK Authentication.\n   The Responder indicates\
    \ its acceptance to perform Secure PSK\n   Authentication by adding a Notify payload\
    \ of type\n   SECURE_PASSWORD_METHODS to its response in the IKE_SA_INIT exchange\n\
    \   and by adding the sole value of 3 to the notification data field of\n   the\
    \ Notify payload.\n   If the Responder does not include a Notify payload of type\n\
    \   SECURE_PASSWORD_METHODS in its IKE_SA_INIT response, the Initiator\n   MUST\
    \ terminate the exchange, and it MUST NOT fall back to the PSK\n   authentication\
    \ method of [RFC5996].  If the Initiator only indicated\n   its support for Secure\
    \ PSK Authentication (i.e., if the Notify data\n   field only contained 3) and\
    \ the Responder replies with a Notify\n   payload of type SECURE_PASSWORD_METHODS\
    \ and a different value in the\n   Notify data field, the Initiator MUST terminate\
    \ the exchange.\n"
- title: 8.2.  Fixing the Secret Element, SKE
  contents:
  - "8.2.  Fixing the Secret Element, SKE\n   The method of fixing SKE depends on\
    \ the type of group, either MODP or\n   ECP.  The function \"prf+\" from [RFC5996]\
    \ is used as a key derivation\n   function.\n   Fixing SKE involves an iterative\
    \ hunting-and-pecking technique using\n   the prime from the negotiated group's\
    \ domain parameter set and an\n   ECP- or MODP-specific operation depending on\
    \ the negotiated group.\n   This technique requires the pre-shared key to be a\
    \ binary string;\n   therefore, any pre-processing transformation (see Section\
    \ 6) MUST be\n   performed on the pre-shared key prior to fixing SKE.\n   To thwart\
    \ side-channel attacks that attempt to determine the number\n   of iterations\
    \ of the hunting-and-pecking loop that are used to find\n   SKE for a given password,\
    \ a security parameter, k, is used to ensure\n   that at least k iterations are\
    \ always performed.\n   Prior to beginning the hunting-and-pecking loop, an 8-bit\
    \ counter is\n   set to the value one (1).  Then the loop begins.  First, the\
    \ pseudo-\n   random function is used to generate a secret seed using the counter,\n\
    \   the pre-shared key, and two nonces (without the fixed headers)\n   exchanged\
    \ by the Initiator and the Responder (see Section 8.6):\n      ske-seed = prf(Ni\
    \ | Nr, psk | counter)\n   Then, the ske-seed is expanded using prf+ to create\
    \ an ske-value:\n      ske-value = prf+(ske-seed, \"IKE SKE Hunting And Pecking\"\
    )\n   where len(ske-value) is the same as len(p), the length of the prime\n  \
    \ from the domain parameter set of the negotiated group.\n   If the ske-seed is\
    \ greater than or equal to the prime, p, the counter\n   is incremented, a new\
    \ ske-seed is generated, and the hunting-and-\n   pecking continues.  If ske-seed\
    \ is less than the prime, p, it is\n   passed to the group-specific operation\
    \ to select the SKE or fail.  If\n   the group-specific operation fails, the counter\
    \ is incremented, a new\n   ske-seed is generated, and the hunting-and-pecking\
    \ continues.  This\n   process continues until the group-specific operation returns\
    \ the\n   password element.  After the password element has been chosen, a\n \
    \  random number is used in place of the password in the ske-seed\n   calculation,\
    \ and the hunting-and-pecking continues until the counter\n   is greater than\
    \ the security parameter, k.\n"
- title: 8.2.1.  ECP Operation to Select SKE
  contents:
  - "8.2.1.  ECP Operation to Select SKE\n   The group-specific operation for ECP\
    \ groups uses ske-value, ske-seed,\n   and the equation of the curve to produce\
    \ SKE.  First, ske-value is\n   used directly as the x-coordinate, x, with the\
    \ equation of the\n   elliptic curve, with parameters a and b from the domain\
    \ parameter set\n   of the curve, to solve for a y-coordinate, y.\n   Note: A\
    \ method of checking whether a solution to the equation of the\n   elliptic curve\
    \ is to see whether the Legendre symbol of (x^3 + ax +\n   b) equals one (1).\
    \  If it does, then a solution exists; if it does\n   not, then there is no solution.\n\
    \   If there is no solution to the equation of the elliptic curve, then\n   the\
    \ operation fails, the counter is incremented, a new ske-value and\n   ske-seed\
    \ are selected, and the hunting-and-pecking continues.  If\n   there is a solution\
    \ then, y is calculated as the square root of (x^3\n   + ax + b) using the equation\
    \ of the elliptic curve.  In this case, an\n   ambiguity exists as there are technically\
    \ two solutions to the\n   equation, and ske-seed is used to unambiguously select\
    \ one of them.\n   If the low-order bit of ske-seed is equal to the low-order\
    \ bit of y,\n   then a candidate SKE is defined as the point (x,y); if the low-order\n\
    \   bit of ske-seed differs from the low-order bit of y then a candidate\n   SKE\
    \ is defined as the point (x, p-y) where p is the prime from the\n   negotiated\
    \ group's domain parameter set.  The candidate SKE becomes\n   the SKE, and the\
    \ ECP-specific operation completes successfully.\n   Algorithmically, the process\
    \ looks like this:\n         found = 0\n         counter = 1\n         v = psk\n\
    \         do {\n           ske-seed = prf(Ni | Nr, v | counter)\n           ske-value\
    \ = prf+(ske-seed, \"IKE SKE Hunting And Pecking\")\n           if (ske-value\
    \ < p)\n           then\n             x = ske-value\n             if ( (y = sqrt(x^3\
    \ + ax + b)) != FAIL)\n             then\n               if (found == 0)\n   \
    \            then\n                 if (LSB(y) == LSB(ske-seed))\n           \
    \      then\n                   SKE = (x,y)\n                 else\n         \
    \          SKE = (x, p-y)\n                 fi\n                 found = 1\n \
    \                v = random()\n               fi\n             fi\n          \
    \ fi\n           counter = counter + 1\n         } while ((found == 0) || (counter\
    \ <= k))\n   where FAIL indicates that there is no solution to sqrt(x^3 + ax +\
    \ b).\n                    Figure 1: Fixing SKE for ECP Groups\n   Note: For ECP\
    \ groups, the probability that more than \"n\" iterations\n   of the hunting-and-pecking\
    \ loop are required to find SKE is roughly\n   (1-(r/2p))^n, which rapidly approaches\
    \ zero (0) as \"n\" increases.\n"
- title: 8.2.2.  MODP Operation to Select SKE
  contents:
  - "8.2.2.  MODP Operation to Select SKE\n   The group-specific operation for MODP\
    \ groups takes ske-value, the\n   prime, p, and order, r, from the group's domain\
    \ parameter set to\n   directly produce a candidate SKE by exponentiating the\
    \ ske-value to\n   the value ((p-1)/r) modulo the prime.  If the candidate SKE\
    \ is\n   greater than one (1), the candidate SKE becomes the SKE, and the\n  \
    \ MODP-specific operation completes successfully.  Otherwise, the MODP-\n   specific\
    \ operation fails (and the hunting-and-pecking continues).\n   Algorithmically,\
    \ the process looks like this:\n         found = 0\n         counter = 1\n   \
    \      v = psk\n         do {\n           ske-seed = prf(Ni | Nr, v | counter)\n\
    \           ske-value = prf+(ske-seed, \"IKE SKE Hunting And Pecking\")\n    \
    \       if (ske-value < p)\n           then\n             ELE = ske-value ^ ((p-1)/r)\
    \ mod p\n             if (ELE > 1)\n             then\n               if (found\
    \ == 0)\n                 SKE = ELE\n                 found = 1\n            \
    \     v = random()\n               fi\n             fi\n           fi\n      \
    \     counter = counter + 1\n         } while ((found == 0) || (counter <= k))\n\
    \                   Figure 2: Fixing SKE for MODP Groups\n   Note: For MODP groups,\
    \ the probability that more than \"n\" iterations\n   of the hunting-and-pecking\
    \ loop are required to find SKE is roughly\n   ((m-p)/p)^n, where m is the largest\
    \ unsigned number that can be\n   expressed in len(p) bits, which rapidly approaches\
    \ zero (0) as \"n\"\n   increases.\n"
- title: 8.3.  Encoding and Decoding of Group Elements and Scalars
  contents:
  - "8.3.  Encoding and Decoding of Group Elements and Scalars\n   The payloads used\
    \ in the Secure PSK Authentication method contain\n   elements from the negotiated\
    \ group and scalar values.  To ensure\n   interoperability, scalars and field\
    \ elements MUST be represented in\n   payloads in accordance with the requirements\
    \ in this section.\n"
- title: 8.3.1.  Encoding and Decoding of Scalars
  contents:
  - "8.3.1.  Encoding and Decoding of Scalars\n   Scalars MUST be represented (in\
    \ binary form) as unsigned integers\n   that are strictly less than r, the order\
    \ of the generator of the\n   agreed-upon cryptographic group.  The binary representation\
    \ of each\n   scalar MUST have a bit length equal to the bit length of the binary\n\
    \   representation of r.  This requirement is enforced, if necessary, by\n   prepending\
    \ the binary representation of the integer with zeros until\n   the required length\
    \ is achieved.\n   Scalars in the form of unsigned integers are converted into\
    \ octet\n   strings and back again using the technique described in [RFC6090].\n"
- title: 8.3.2.  Encoding and Decoding of ECP Elements
  contents:
  - "8.3.2.  Encoding and Decoding of ECP Elements\n   Elements in ECP groups are\
    \ points on the negotiated elliptic curve.\n   Each such element MUST be represented\
    \ by the concatenation of two\n   components, an x-coordinate and a y-coordinate.\n\
    \   Each of the two components, the x-coordinate and the y-coordinate,\n   MUST\
    \ be represented (in binary form) as an unsigned integer that is\n   strictly\
    \ less than the prime, p, from the group's domain parameter\n   set.  The binary\
    \ representation of each component MUST have a bit\n   length equal to the bit\
    \ length of the binary representation of p.\n   This length requirement is enforced,\
    \ if necessary, by prepending the\n   binary representation of the integer with\
    \ zeros until the required\n   length is achieved.\n   The unsigned integers that\
    \ represent the coordinates of the point are\n   converted into octet strings\
    \ and back again using the technique\n   described in [RFC6090].\n   Since the\
    \ field element is represented in a payload by the\n   x-coordinate followed by\
    \ the y-coordinate, it follows, then, that the\n   length of the element in the\
    \ payload MUST be twice the bit length of\n   p.\n"
- title: 8.3.3.  Encoding and Decoding of MODP Elements
  contents:
  - "8.3.3.  Encoding and Decoding of MODP Elements\n   Elements in MODP groups MUST\
    \ be represented (in binary form) as\n   unsigned integers that are strictly less\
    \ than the prime, p, from the\n   group's domain parameter set.  The binary representation\
    \ of each\n   group element MUST have a bit length equal to the bit length of\
    \ the\n   binary representation of p.  This length requirement is enforced, if\n\
    \   necessary, by prepending the binary representation of the integer\n   with\
    \ zeros until the required length is achieved.\n   The unsigned integer that represents\
    \ a MODP element is converted into\n   an octet string and back using the technique\
    \ described in [RFC6090].\n"
- title: 8.4.  Message Generation and Processing
  contents:
  - '8.4.  Message Generation and Processing

    '
- title: 8.4.1.  Generation of a Commit
  contents:
  - "8.4.1.  Generation of a Commit\n   Before a Commit payload can be generated,\
    \ the SKE must be fixed using\n   the process described in Section 8.2.\n   A\
    \ Commit payload has two components, a scalar and an element.  To\n   generate\
    \ a Commit payload, two random numbers, a \"private\" value and\n   a \"mask\"\
    \ value, are generated (see Section 5).  Their sum modulo the\n   order of the\
    \ group, r, becomes the scalar component:\n       scalar = (private + mask) mod\
    \ r\n   If the scalar is not greater than one (1), the private and mask\n   values\
    \ MUST be thrown away, and new values randomly generated.  If\n   the scalar is\
    \ greater than one (1), the inverse of the scalar\n   operation with the mask\
    \ and SKE becomes the element component.\n       Element = inverse(scalar-op(mask,\
    \ SKE))\n   The Commit payload consists of the scalar followed by the element,\n\
    \   and the scalar and element are encoded in the Commit payload\n   according\
    \ to Section 8.3.\n"
- title: 8.4.2.  Processing of a Commit
  contents:
  - "8.4.2.  Processing of a Commit\n   Upon receipt of a peer's Commit payload, the\
    \ scalar and element MUST\n   be validated.  The processing of an element depends\
    \ on the type,\n   either an ECP element or a MODP element.\n"
- title: 8.4.2.1.  Validation of an ECP Element
  contents:
  - "8.4.2.1.  Validation of an ECP Element\n   Validating a received ECP element\
    \ involves: 1) checking whether the\n   two coordinates, x and y, are both greater\
    \ than zero (0) and less\n   than the prime defining the underlying field; and\
    \ 2) checking whether\n   the x- and y-coordinates satisfy the equation of the\
    \ curve (that is,\n   that they produce a valid point on the curve that is not\
    \ \"0\").  If\n   either of these conditions are not met, the received element\
    \ is\n   invalid; otherwise, the received element is valid.\n"
- title: 8.4.2.2.  Validation of a MODP Element
  contents:
  - "8.4.2.2.  Validation of a MODP Element\n   A received MODP element is valid if:\
    \ 1) it is between one (1) and the\n   prime, p, exclusive; and 2) if modular\
    \ exponentiation of the element\n   by the group order, r, equals one (1).  If\
    \ either of these conditions\n   are not true, the received element is invalid;\
    \ otherwise, the\n   received element is valid.\n"
- title: 8.4.2.3.  Commit Processing Steps
  contents:
  - "8.4.2.3.  Commit Processing Steps\n   Commit payload validation is accomplished\
    \ by the following steps:\n   1.  The length of the Commit payload is checked\
    \ against its\n       anticipated length (the anticipated length of the scalar\
    \ plus the\n       anticipated length of the element, for the negotiated group).\
    \  If\n       it is incorrect, the Commit payload is invalidated; otherwise,\n\
    \       processing continues.\n   2.  The peer's scalar is extracted from the\
    \ Commit payload according\n       to Section 8.3.1 and checked to ensure it is\
    \ between one (1) and\n       r, the order of the negotiated group, exclusive.\
    \  If it is not,\n       the Commit payload is invalidated; otherwise, processing\n\
    \       continues.\n   3.  The peer's element is extracted from the Commit payload\
    \ according\n       to Section 8.3.2 and checked in a manner that depends on the\
    \ type\n       of group negotiated.  If the group is ECP, the element is\n   \
    \    validated according to Section 8.4.2.1.  If the group is MODP,\n       the\
    \ element is validated according to Section 8.4.2.2.  If the\n       element is\
    \ not valid, then the Commit payload is invalidated;\n       otherwise, the Commit\
    \ payload is validated.\n   4.  The Initiator of the IKE exchange has an added\
    \ requirement to\n       verify that the received element and scalar from the\
    \ Commit\n       payload differ from the element and scalar sent to the Responder.\n\
    \       If they are identical, it signifies a reflection attack, and the\n   \
    \    Commit payload is invalidated.\n   If the Commit payload is invalidated,\
    \ the payload MUST be discarded\n   and the IKE exchange aborted.\n"
- title: 8.4.3.  Authentication of the Exchange
  contents:
  - "8.4.3.  Authentication of the Exchange\n   After a Commit payload has been generated\
    \ and a peer's Commit payload\n   has been processed, a shared secret used to\
    \ authenticate the peer is\n   derived.  Using SKE, the \"private\" value generated\
    \ as part of Commit\n   payload generation, and the peer's scalar and element\
    \ from the peer's\n   Commit payload, named here peer-scalar and Peer-Element,\n\
    \   respectively, a preliminary shared secret, skey, is generated as:\n      \
    \  skey = F(scalar-op(private,\n                           element-op(Peer-Element,\n\
    \                                      scalar-op(peer-scalar, SKE))))\n   For\
    \ the purposes of subsequent computation, the bit length of skey\n   SHALL be\
    \ equal to the bit length of the prime, p, used in either a\n   MODP or ECP group.\
    \  This bit length SHALL be enforced, if necessary,\n   by prepending zeros to\
    \ the value until the required length is\n   achieved.\n   A shared secret, ss,\
    \ is then computed from skey and the nonces\n   exchanged by the Initiator (Ni)\
    \ and Responder (Nr) (without the fixed\n   headers) using prf():\n        ss\
    \ = prf(Ni | Nr, skey | \"Secure PSK Authentication in IKE\")\n   The shared secret,\
    \ ss, is used in an AUTH authentication payload to\n   prove possession of the\
    \ shared secret and therefore knowledge of the\n   pre-shared key.\n"
- title: 8.5.  Payload Format
  contents:
  - '8.5.  Payload Format

    '
- title: 8.5.1.  Commit Payload
  contents:
  - "8.5.1.  Commit Payload\n   [RFC6467] defines a Generic Secure Password Method\
    \ (GSPM) payload\n   that is used to convey information that is specific to a\
    \ particular\n   secure password method.  This memo uses the GSPM payload as a\
    \ Commit\n   payload to contain the scalar and element used in the Secure PSK\n\
    \   Authentication exchange:\n   The Commit payload is defined as follows:\n \
    \                           1                   2                   3\n      \
    \  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       ! Next Payload  !C!  RESERVED   !         Payload Length        !\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                                                               |\n      \
    \ +                            scalar                             ~\n       |\
    \                                                               |\n       ~  \
    \                             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |    \
    \                           |                               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               ~\n       |                                  \
    \                             |\n       ~                           Element  \
    \                           ~\n       |                                      \
    \                         |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The scalar and element SHALL be encoded in the Commit payload\n   according\
    \ to Section 8.3.\n"
- title: 8.6.  IKEv2 Messaging
  contents:
  - "8.6.  IKEv2 Messaging\n   Secure PSK Authentication modifies the IKE_AUTH exchange\
    \ by adding\n   one additional round trip to exchange Commit payloads to perform\
    \ the\n   Secure PSK Authentication exchange and by changing the calculation of\n\
    \   the AUTH payload data to bind the IKEv2 exchange to the outcome of\n   the\
    \ Secure PSK Authentication exchange (see Figure 3).\n    Initiator          \
    \                     Responder\n   -----------                             -----------\n\
    \   IKE_SA_INIT:\n    HDR, SAi1, KEi, Ni,\n         N(SPM-SPSK)  -->\n       \
    \                           <--    HDR, SAr1, KEr, Nr,\n                     \
    \                         N(SPM-SPSK)\n   IKE_AUTH:\n    HDR, SK {IDi, COMi, [IDr,]\n\
    \             SAi2, TSi, TSr}      -->\n                                  <--\
    \    HDR, SK {IDr, COMr}\n    HDR, SK {AUTHi}               -->\n            \
    \                      <--    HDR, SK {AUTHr, SAr2, TSi, TSr}\n   where N(SPM-SPSK)\
    \ indicates the Secure Password Methods Notify\n   payloads used to negotiate\
    \ the use of Secure PSK Authentication (see\n   Section 8.1), COMi and AUTHi are\
    \ the Commit payload and AUTH payload,\n   respectively, sent by the Initiator,\
    \ and COMr and AUTHr are the\n   Commit payload and AUTH payload, respectively,\
    \ sent by the Responder.\n                       Figure 3: Secure PSK in IKEv2\n\
    \   When doing Secure PSK Authentication, the AUTH payloads SHALL be\n   computed\
    \ as\n       AUTHi = prf(ss, <InitiatorSignedOctets> | COMi | COMr)\n       AUTHr\
    \ = prf(ss, <ResponderSignedOctets> | COMr | COMi)\n   where \"ss\" is the shared\
    \ secret derived in Section 8.4.3, COMi and\n   COMr are the entire Commit payloads\
    \ (including the fixed headers)\n   sent by the Initiator and Responder, respectively,\
    \ and\n   <InitiatorSignedOctets> and <ResponderSignedOctets> are defined in\n\
    \   [RFC5996].  The Authentication Method indicated in both AUTH payloads\n  \
    \ SHALL be \"Generic Secure Password Authentication Method\", value 12,\n   from\
    \ [IKEV2-IANA].\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   IANA has assigned the value 3 for \"Secure PSK Authentication\"\
    \ from\n   the Secure Password Authentication Method registry in [IKEV2-IANA].\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   Both the Initiator and Responder obtain a shared\
    \ secret, \"ss\" (see\n   Section 8.4.3), based on a secret group element and\
    \ their own private\n   values contributed to the exchange.  If they do not share\
    \ the same\n   pre-shared key, they will be unable to derive the same secret group\n\
    \   element, and if they do not share the same secret group element, they\n  \
    \ will be unable to derive the same shared secret.\n   Resistance to dictionary\
    \ attack means that the adversary must launch\n   an active attack to make a single\
    \ guess at the pre-shared key.  If\n   the size of the pool from which the key\
    \ was extracted was d and each\n   key in the pool has an equal probability of\
    \ being chosen, then the\n   probability of success after a single guess is 1/d.\
    \  After x guesses,\n   and removal of failed guesses from the pool of possible\
    \ keys, the\n   probability becomes 1/(d-x).  As x grows, so does the probability\
    \ of\n   success.  Therefore, it is possible for an adversary to determine the\n\
    \   pre-shared key through repeated brute-force, active, guessing\n   attacks.\
    \  This authentication method does not presume to be secure\n   against this,\
    \ and implementations SHOULD ensure the value of d is\n   sufficiently large to\
    \ prevent this attack.  Implementations SHOULD\n   also take countermeasures,\
    \ for instance, refusing authentication\n   attempts for a certain amount of time\
    \ after the number of failed\n   authentication attempts reaches a certain threshold.\
    \  No such\n   threshold or amount of time is recommended in this memo.\n   An\
    \ active attacker can impersonate the Responder of the exchange and\n   send a\
    \ forged Commit payload after receiving the Initiator's Commit\n   payload.  The\
    \ attacker then waits until it receives the\n   authentication payload from the\
    \ Responder.  Now the attacker can\n   attempt to run through all possible values\
    \ of the pre-shared key,\n   computing SKE (see Section 8.2), computing \"ss\"\
    \ (see Section 8.4.3),\n   and attempting to recreate the Confirm payload from\
    \ the Responder.\n   But, by sending a forged Commit payload the attacker commits\
    \ to a\n   single guess of the pre-shared key.  That value was used by the\n \
    \  Responder in his computation of \"ss\", which was used in the\n   authentication\
    \ payload.  Any guess of the pre-shared key that differs\n   from the one used\
    \ in the forged Commit payload would result in each\n   side using a different\
    \ secret element in the computation of \"ss\" and\n   therefore the authentication\
    \ payload could not be verified as\n   correct, even if a subsequent guess, while\
    \ running through all\n   possible values, was correct.  The attacker gets one\
    \ guess, and one\n   guess only, per active attack.\n   An attacker, acting as\
    \ either the Initiator or Responder, can take\n   the element from the Commit\
    \ payload received from the other party,\n   reconstruct the random \"mask\" value\
    \ used in its construction, and\n   then recover the other party's \"private\"\
    \ value from the scalar in the\n   Commit payload.  But this requires the attacker\
    \ to solve the discrete\n   logarithm problem, which we assumed was intractable\
    \ (Section 7).\n   Instead of attempting to guess at pre-shared keys, an attacker\
    \ can\n   attempt to determine SKE and then launch an attack, but SKE is\n   determined\
    \ by the output of the pseudo-random function, prf, which is\n   assumed to be\
    \ indistinguishable from a random source (Section 7).\n   Therefore, each element\
    \ of the finite cyclic group will have an equal\n   probability of being the SKE.\
    \  The probability of guessing SKE will\n   be 1/r, where r is the order of the\
    \ group.  This is the same\n   probability of guessing the solution to the discrete\
    \ logarithm, which\n   is assumed to be intractable (Section 7).  The attacker\
    \ would have a\n   better chance of success at guessing the input to prf, i.e.,\
    \ the pre-\n   shared key, since the order of the group will be many orders of\n\
    \   magnitude greater than the size of the pool of pre-shared keys.\n   The implications\
    \ of resistance to dictionary attack are significant.\n   An implementation can\
    \ provision a pre-shared key in a practical and\n   realistic manner -- i.e.,\
    \ it MAY be a character string, and it MAY be\n   relatively short -- and still\
    \ maintain security.  The nature of the\n   pre-shared key determines the size\
    \ of the pool, D, and\n   countermeasures can prevent an adversary from determining\
    \ the secret\n   in the only possible way: repeated, active, guessing attacks.\
    \  For\n   example, a simple four-character string using lowercase English\n \
    \  characters, and assuming random selection of those characters, will\n   result\
    \ in D of over four hundred thousand.  An adversary would need\n   to mount over\
    \ one hundred thousand active, guessing attacks (which\n   will easily be detected)\
    \ before gaining any significant advantage in\n   determining the pre-shared key.\n\
    \   If an attacker knows the number of hunting-and-pecking loops that\n   were\
    \ required to determine SKE, it is possible to eliminate passwords\n   from the\
    \ pool of potential passwords and increase the probability of\n   successfully\
    \ guessing the real password.  MODP groups will require\n   more than \"n\" loops\
    \ with a probability based on the value of the\n   prime -- if m is the largest\
    \ unsigned number that can be expressed in\n   len(p) bits, then the probability\
    \ is ((m-p)/p)^n -- which will\n   typically be very small for the groups defined\
    \ in [IKEV2-IANA].  ECP\n   groups will require more than one \"n\" loop with\
    \ a probability of\n   roughly (1-(r/2p))^n.  Therefore, a security parameter,\
    \ k, is defined\n   that will ensure that at least k loops will always be executed\n\
    \   regardless of whether SKE is found in less than k loops.  There is\n   still\
    \ a probability that a password would require more than k loops,\n   and a side-channel\
    \ attacker could use that information to his\n   advantage, so selection of the\
    \ value of k should be based on a trade-\n   off between the additional workload\
    \ to always perform k iterations\n   and the potential of providing information\
    \ to a side-channel\n   attacker.  It is important to note that the possibility\
    \ of a\n   successful side-channel attack is greater against ECP groups than\n\
    \   MODP groups, and it might be appropriate to have separate values of k\n  \
    \ for the two.\n   For a more detailed discussion of the security of the key exchange\n\
    \   underlying this authentication method, see [SAE] and [RFC5931].\n"
- title: 11.  Acknowledgements
  contents:
  - "11.  Acknowledgements\n   The author would like to thank Scott Fluhrer and Hideyuki\
    \ Suzuki for\n   their insight in discovering flaws in earlier versions of the\
    \ key\n   exchange that underlies this authentication method and for their\n \
    \  helpful suggestions in improving it.  Thanks to Lily Chen for useful\n   advice\
    \ on the hunting-and-pecking technique to \"hash into\" an element\n   in a group\
    \ and to Jin-Meng Ho for a discussion on countering a small\n   sub-group attack.\
    \  Rich Davis suggested several checks on received\n   messages that greatly increase\
    \ the security of the underlying key\n   exchange.  Hugo Krawczyk suggested using\
    \ the prf as an extractor.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [IKEV2-IANA]  IANA, \"IKEv2 Parameters\",\n \
    \                <http://www.iana.org/assignments/ikev2-parameters>.\n   [RFC2104]\
    \     Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC:\n                 Keyed-Hashing\
    \ for Message Authentication\", RFC 2104,\n                 February 1997.\n \
    \  [RFC2119]     Bradner, S., \"Key words for use in RFCs to Indicate\n      \
    \           Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3454]\
    \     Hoffman, P. and M. Blanchet, \"Preparation of\n                 Internationalized\
    \ Strings (\"stringprep\")\", RFC 3454,\n                 December 2002.\n   [RFC4013]\
    \     Zeilenga, K., \"SASLprep: Stringprep Profile for User\n                \
    \ Names and Passwords\", RFC 4013, February 2005.\n   [RFC5996]     Kaufman, C.,\
    \ Hoffman, P., Nir, Y., and P. Eronen,\n                 \"Internet Key Exchange\
    \ Protocol Version 2 (IKEv2)\",\n                 RFC 5996, September 2010.\n\
    \   [RFC6090]     McGrew, D., Igoe, K., and M. Salter, \"Fundamental\n       \
    \          Elliptic Curve Cryptography Algorithms\", RFC 6090,\n             \
    \    February 2011.\n   [RFC6467]     Kivinen, T., \"Secure Password Framework\
    \ for Internet\n                 Key Exchange Version 2 (IKEv2)\", RFC 6467,\n\
    \                 December 2011.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [BM92]        Bellovin, S. and M. Merritt,\
    \ \"Encrypted Key Exchange:\n                 Password-Based Protocols Secure\
    \ Against Dictionary\n                 Attacks\", Proceedings of the IEEE Symposium\
    \ on Security\n                 and Privacy, Oakland, 1992.\n   [BMP00]      \
    \ Boyko, V., MacKenzie, P., and S. Patel, \"Provably\n                 Secure\
    \ Password-Authenticated Key Exchange Using\n                 Diffie-Hellman\"\
    , Proceedings of Eurocrypt 2000, LNCS\n                 1807 Springer-Verlag,\
    \ 2000.\n   [BPR00]       Bellare, M., Pointcheval, D., and P. Rogaway,\n    \
    \             \"Authenticated Key Exchange Secure Against Dictionary\n       \
    \          Attacks\", Advances in Cryptology -- Eurocrypt '00,\n             \
    \    Lecture Notes in Computer Science Springer-Verlag,\n                 2000.\n\
    \   [RFC4086]     Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n \
    \                Requirements for Security\", BCP 106, RFC 4086,\n           \
    \      June 2005.\n   [RFC4301]     Kent, S. and K. Seo, \"Security Architecture\
    \ for the\n                 Internet Protocol\", RFC 4301, December 2005.\n  \
    \ [RFC5869]     Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-\n      \
    \           Expand Key Derivation Function (HKDF)\", RFC 5869,\n             \
    \    May 2010.\n   [RFC5931]     Harkins, D. and G. Zorn, \"Extensible Authentication\n\
    \                 Protocol (EAP) Authentication Using Only a Password\",\n   \
    \              RFC 5931, August 2010.\n   [SAE]         Harkins, D., \"Simultaneous\
    \ Authentication of Equals: A\n                 Secure, Password-Based Key Exchange\
    \ for Mesh Networks\",\n                 Proceedings of the 2008 Second International\
    \ Conference\n                 on Sensor Technologies and Applications Volume\
    \ 00,\n                 2008.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Dan Harkins\n   Aruba Networks\n   1322 Crossman Avenue\n\
    \   Sunnyvale, CA  94089-1113\n   United States of America\n   EMail: dharkins@arubanetworks.com\n"
