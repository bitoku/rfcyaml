- title: __initial_text__
  contents:
  - '                         Delta encoding in HTTP

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes how delta encoding can be supported as a\n\
    \   compatible extension to HTTP/1.1.\n   Many HTTP (Hypertext Transport Protocol)\
    \ requests cause the retrieval\n   of slightly modified instances of resources\
    \ for which the client\n   already has a cache entry.  Research has shown that\
    \ such modifying\n   updates are frequent, and that the modifications are typically\
    \ much\n   smaller than the actual entity.  In such cases, HTTP would make more\n\
    \   efficient use of network bandwidth if it could transfer a minimal\n   description\
    \ of the changes, rather than the entire new instance of\n   the resource.  This\
    \ is called \"delta encoding.\"\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1 Introduction....................................................\
    \  3\n        1.1 Related research and proposals...........................  4\n\
    \   2 Goals...........................................................  5\n  \
    \ 3 Terminology.....................................................  6\n   4\
    \ The HTTP message-generation sequence............................  8\n      \
    \  4.1 Relationship between deltas and ranges................... 11\n   5 Basic\
    \ mechanisms................................................ 13\n        5.1 Background:\
    \ an overview of HTTP cache validation......... 13\n        5.2 Requesting the\
    \ transmission of deltas.................... 14\n        5.3 Choice of delta algorithm\
    \ and format..................... 16\n        5.4 Identification of delta-encoded\
    \ responses................ 16\n        5.5 Guaranteeing cache safety................................\
    \ 17\n        5.6 Transmission of delta-encoded responses.................. 18\n\
    \        5.7 Examples of requests combining Range and delta encoding.. 19\n  \
    \ 6 Encoding algorithms and formats................................. 22\n   7\
    \ Management of base instances.................................... 23\n      \
    \  7.1 Multiple entity tags in the If-None-Match header......... 24\n        7.2\
    \ Hints for managing the client cache...................... 25\n   8 Deltas and\
    \ intermediate caches.................................. 27\n   9 Digests for data\
    \ integrity...................................... 28\n   10 Specification..................................................\
    \ 28\n        10.1 Protocol parameter specifications....................... 28\n\
    \        10.2 IANA Considerations..................................... 30\n  \
    \      10.3 Basic requirements for delta-encoded responses.......... 30\n    \
    \    10.4 Status code specifications.............................. 30\n      \
    \       10.4.1 226 IM Used...................................... 31\n        10.5\
    \ Header specifications................................... 31\n             10.5.1\
    \ Delta-Base....................................... 31\n             10.5.2 IM...............................................\
    \ 32\n             10.5.3 A-IM............................................. 33\n\
    \        10.6 Caching rules for 226 responses......................... 35\n  \
    \      10.7 Rules for deltas in the presence of content-codings..... 36\n    \
    \         10.7.1 Rules for generating deltas in the presence of\n            \
    \        content-codings.................................. 37\n             10.7.2\
    \ Rules for applying deltas in the presence of\n                    content-codings..................................\
    \ 37\n             10.7.3 Examples for using A-IM, IM, and content-codings. 38\n\
    \        10.8 New Cache-Control directives............................ 40\n  \
    \           10.8.1 Retain directive................................. 40\n    \
    \         10.8.2 IM directive..................................... 40\n      \
    \  10.9 Use of compression with delta encoding.................. 41\n        10.10\
    \ Delta encoding and multipart/byteranges................ 42\n   11 Quantifying\
    \ the protocol overhead.............................. 42\n   12 Security Considerations........................................\
    \ 44\n   13 Acknowledgements............................................... 44\n\
    \   14 Intellectual Property Rights................................... 44\n  \
    \ 15 References..................................................... 44\n   16\
    \ Authors' addresses............................................. 47\n   17 Full\
    \ Copyright Statement....................................... 49\n"
- title: 1 Introduction
  contents:
  - "1 Introduction\n   The World Wide Web is a distributed system, and so often benefits\n\
    \   from caching to reduce retrieval delays.  Retrieval of a Web resource\n  \
    \ (such as a  document, image, icon, or applet) over the Internet or\n   other\
    \ wide-area networks usually takes enough time that the delay is\n   over the\
    \ human threshold of perception.  Often, that delay is\n   measured in seconds.\
    \  Caching can often eliminate or significantly\n   reduce retrieval delays.\n\
    \   Many Web resources change over time, so a practical caching approach\n   must\
    \ include a coherency mechanism, to avoid presenting stale\n   information to\
    \ the user.  Originally, the Hypertext Transfer Protocol\n   (HTTP) provided little\
    \ support for caching, but under operational\n   pressures, it quickly evolved\
    \ to support a simple mechanism for\n   maintaining cache coherency.\n   In HTTP/1.0\
    \ [2], the server may supply a \"last-modified\" timestamp\n   with a response.\
    \  If a client stores this response in a cache entry,\n   and then later wishes\
    \ to re-use the response, it may transmit a\n   request message with an \"If-modified-since\"\
    \ field containing that\n   timestamp; this is known as a conditional retrieval.\
    \  Upon receiving\n   a conditional request, the server may either reply with\
    \ a full\n   response, or, if the resource has not changed, it may send an\n \
    \  abbreviated reply, indicating that the client's cache entry is still\n   valid.\
    \  HTTP/1.0 also includes a means for the server to indicate,\n   via an \"Expires\"\
    \ timestamp, that a response will be valid until that\n   time; if so, a client\
    \ may use a cached copy of the response until\n   that time, without first validating\
    \ it using a conditional retrieval.\n   HTTP/1.1 [10] adds many new features to\
    \ improve cache coherency and\n   performance.  However, it preserves the all-or-none\
    \ model for\n   responses to conditional retrievals: either the server indicates\
    \ that\n   the resource value has not changed at all, or it must transmit the\n\
    \   entire current value.\n   Common sense suggests (and traces confirm), however,\
    \ that even when a\n   Web resource does change, the new instance is often substantially\n\
    \   similar to the old one.  If the difference, or \"delta\", between the\n  \
    \ two instances could be sent to the client instead of the entire new\n   instance,\
    \ a client holding a cached copy of the old instance could\n   apply the delta\
    \ to construct the new version.  In a world of finite\n   bandwidth, the reduction\
    \ in response size and delay could be\n   significant.\n   One can think of deltas\
    \ as a way to squeeze as much benefit as\n   possible from client and proxy caches.\
    \  Rather than treating an\n   entire response as the \"cache line\", with deltas\
    \ we can treat\n   arbitrary pieces of a cached response as the replaceable unit,\
    \ and\n   avoid transferring pieces that have not changed.\n   This document proposes\
    \ a set of compatible extensions to HTTP/1.1\n   that allow clients and servers\
    \ to use delta encoding with minimal\n   overhead.\n   We assume that the reader\
    \ is familiar with the HTTP/1.1\n   specification.\n"
- title: 1.1 Related research and proposals
  contents:
  - "1.1 Related research and proposals\n   The idea of delta encoding to reduce communication\
    \ or storage costs\n   is not new.  For example, the MPEG-1 video compression\
    \ standard\n   transmits occasional still-image frames, but most of the frames\
    \ sent\n   are encoded (to oversimplify) as changes from an adjacent frame.  The\n\
    \   SCCS and RCS [27] systems for software version control represent\n   intermediate\
    \ versions as deltas; SCCS starts with an original version\n   and encodes subsequent\
    \ ones with forward deltas, whereas RCS encodes\n   previous versions as reverse\
    \ deltas from their successors.\n   Jacobson's technique for compressing IP and\
    \ TCP headers over slow\n   links [17] uses a clever, highly specialized form\
    \ of delta encoding.\n   In spite of this history, it appears to have taken several\
    \ years\n   before anyone thought of applying delta encoding to HTTP, perhaps\n\
    \   because the development of HTTP caching has been somewhat haphazard.\n   The\
    \ first published suggestion for delta encoding appears to have\n   been by Williams\
    \ et al. in a paper about HTTP cache removal policies\n   [30], but these authors\
    \ did not elaborate on their design until later\n   [29].\n   The WebExpress project\
    \ [15] appears to be the first published\n   description of an implementation\
    \ of delta encoding for HTTP (which\n   they call \"differencing\").  WebExpress\
    \ is aimed specifically at\n   wireless environments, and includes a number of\
    \ orthogonal\n   optimizations.  Also, the WebExpress design does not propose\
    \ changing\n   the HTTP protocol itself, but rather uses a pair of interposed\n\
    \   proxies to convert the HTTP message stream into an optimized form.\n   The\
    \ results reported for WebExpress differencing are impressive, but\n   are limited\
    \ to a few selected benchmarks.\n   Banga et al. [1] describe the use of optimistic\
    \ deltas, in which a\n   layer of interposed proxies on either end of a slow link\
    \ collaborate\n   to reduce latency.  If the client-side proxy has a cached copy\
    \ of a\n   resource, the server-side proxy can simply send a delta (or a 304\n\
    \   [Not Modified] response).  If only the server-side proxy has a cached\n  \
    \ copy, it may optimistically send its (possibly stale) copy to the\n   client-side\
    \ proxy, followed (if necessary) by a delta once the\n   server-side proxy has\
    \ validated its own cache entry with the origin\n   server.  The use of optimistic\
    \ deltas, unlike delta encoding,\n   actually increases the number of bytes sent\
    \ over the network, in an\n   attempt to improve latency by anticipating a \"\
    Not Modified\" response\n   from the origin server.  The optimistic delta paper,\
    \ like the\n   WebExpress paper, did not propose a change to the HTTP protocol\n\
    \   itself, and reported results only for a small set of selected URLs.\n   Mogul\
    \ et al. [23] collected lengthy traces, at two different sites,\n   of the full\
    \ contents of HTTP messages, to quantify the potential\n   benefits of delta-encoded\
    \ responses.  They showed that delta encoding\n   can provide remarkable improvements\
    \ in response-size and response-\n   delay for an important subset of HTTP content\
    \ types.  They proposed a\n   set of HTTP extensions, but without the level of\
    \ detail required for\n   a specification.  Douglis et al. [8] used the same sets\
    \ of full-\n   content traces to quantify the rate at which resources change in\
    \ the\n   Web.\n   The HTTP Distribution and Replication Protocol (DRP), proposed\
    \ to W3C\n   by Marimba, Netscape, Sun, Novell, and At Home, aims to provide a\n\
    \   collection of new features for HTTP, to support \"the efficient\n   replication\
    \ of data over HTTP\" [13].  One aspect of the DRP proposal\n   is the use of\
    \ \"differential downloading,\" which is essentially a form\n   of delta encoding.\
    \  The original DRP proposal uses a different\n   approach than is described here,\
    \ but a forthcoming revision of DRP\n   will be revised to conform to the proposal\
    \ in this document.\n   Tridgell and Mackerras [28] describe the \"rsync\" algorithm,\
    \ which\n   accomplishes something similar to delta encoding.  In rsync, the\n\
    \   client breaks a cache entry into a series of fixed-sized blocks,\n   computes\
    \ a digest value for each block, and sends the series of\n   digest values to\
    \ the server as part of its request.  The origin\n   server does the same block-based\
    \ computation, and returns only those\n   blocks whose digest values differ. \
    \ We believe that it might be\n   possible to support rsync using the \"instance\
    \ manipulation\" framework\n   described later in this document, but this has\
    \ not been worked out in\n   any detail.\n"
- title: 2 Goals
  contents:
  - "2 Goals\n   The goals of this proposal are:\n      1. Reduce the mean size of\
    \ HTTP responses, thereby improving\n         latency and network utilization.\n\
    \      2. Avoid any extra network round trips.\n      3. Minimize the amount of\
    \ per-request and per-response overheads.\n      4. Support a variety of encoding\
    \ algorithms and formats.\n      5. Interoperate with HTTP/1.0 and HTTP/1.1.\n\
    \      6. Be fully optional for clients, proxies, and servers.\n      7. Allow\
    \ moderately simple implementations.\n   The goals do not include:\n      -  Reducing\
    \ the number of HTTP requests sent to an origin server.\n      -  Reducing the\
    \ size of every HTTP message.\n      -  Increasing the cache-hit ratio of HTTP\
    \ caches.\n      -  Allowing excessively simplistic implementations of delta\n\
    \         encoding.\n      -  Delta encoding of request messages, or of responses\
    \ to methods\n         other than GET.\n         Nothing in this specification\
    \ specifically precludes the use of\n         a delta encoding for the body of\
    \ a PUT request.  However, no\n         mechanism currently exists for the client\
    \ to discover if the\n         server can interpret such messages, and so we do\
    \ not attempt to\n         specify how they might be used.\n"
- title: 3 Terminology
  contents:
  - "3 Terminology\n   HTTP/1.1 [10] defines the following terms:\n   resource   \
    \     A network data object or service that can be\n                   identified\
    \ by a URI, as defined in section 3.2.\n                   Resources may be available\
    \ in multiple\n                   representations (e.g. multiple languages, data\n\
    \                   formats, size, resolutions) or vary in other ways.\n   entity\
    \          The information transferred as the payload of a\n                 \
    \  request or response.  An entity consists of\n                   metainformation\
    \ in the form of entity-header fields\n                   and content in the form\
    \ of an entity-body, as\n                   described in section 7.\n   variant\
    \         A resource may have one, or more than one,\n                   representation(s)\
    \ associated with it at any given\n                   instant.  Each of these\
    \ representations is termed a\n                   `variant.' Use of the term `variant'\
    \ does not\n                   necessarily imply that the resource is subject\
    \ to\n                   content negotiation.\n   The dictionary definition for\
    \ \"entity\" is \"something that has\n   separate and distinct existence and objective\
    \ or conceptual reality\"\n   [21].  Unfortunately, the definition for \"entity\"\
    \ in HTTP/1.1 is\n   similar to that used in MIME [12], based on a false analogy\
    \ between\n   MIME and HTTP.\n   In MIME, electronic mail messages do have distinct\
    \ and separate\n   existences.  MIME defines \"entity\" as something that \"refers\n\
    \   specifically to the MIME-defined header fields and contents of either\n  \
    \ a message or one of the parts in the body of a multipart entity.\"\n   In HTTP,\
    \ however, a response message to a GET does not have a\n   distinct and separate\
    \ existence.  Rather, it reflects the current\n   state of a resource (or a variant,\
    \ subject to a set of constraints).\n   The HTTP/1.1 specification has no term\
    \ to describe \"the value that\n   would be returned in response to a GET request\
    \ at the current time\n   for the selected variant of the specified resource.\"\
    \  This leads to\n   awkward wordings in the HTTP/1.1 specification in places\
    \ where this\n   concept is necessary.\n   To express this concept, we define\
    \ a new term, for use in this\n   document:\n   instance        The entity that\
    \ would be returned in a status-200\n                   response to a GET request,\
    \ at the current time, for\n                   the selected variant of the specified\
    \ resource, with\n                   the application of zero or more content-codings,\
    \ but\n                   without the application of any instance manipulations\n\
    \                   (see below) or transfer-codings.\n   It is convenient to think\
    \ of an entity tag, in HTTP/1.1, as being\n   associated with an instance, rather\
    \ than an entity.  That is, for a\n   given resource, two different response messages\
    \ might include the\n   same entity tag, but two different instances of the resource\
    \ should\n   never be associated with the same (strong) entity tag.\n   We will\
    \ informally use the term \"delta,\" in this document, to mean an\n   HTTP response\
    \ encoded as the difference between two instances.\n   More formally, delta encodings\
    \ are members of a potentially larger\n   class of transformations on instances,\
    \ leading to this new term:\n   instance manipulation\n                   An operation\
    \ on one or more instances which may\n                   result in an instance\
    \ being conveyed from server to\n                   client in parts, or in more\
    \ than one response\n                   message.  For example, a range selection\
    \ or a delta\n                   encoding.  Instance manipulations are end-to-end,\
    \ and\n                   often involve the use of a cache at the client.\n  \
    \ For reasons that will become clear later on, it is convenient to\n   think about\
    \ subrange selection as a form of instance manipulation.\n   In some contexts,\
    \ compression might also be treated as an instance\n   manipulation, rather than\
    \ as a content-coding or transfer-coding.\n"
- title: 4 The HTTP message-generation sequence
  contents:
  - "4 The HTTP message-generation sequence\n   HTTP/1.1 supports a number of different\
    \ transformations on the body\n   of a value:\n   Content-coding  According to\
    \ the specification, \"Content coding\n                   values indicate an encoding\
    \ transformation that has\n                   been or can be applied to an entity.\
    \  Content codings\n                   are primarily used to allow a document\
    \ to be\n                   compressed or otherwise usefully transformed without\n\
    \                   losing the identity of its underlying media type and\n   \
    \                without loss of information.  Frequently, the entity\n      \
    \             is stored in coded form, transmitted directly, and\n           \
    \        only decoded by the recipient.\"  Content-codings are\n             \
    \      normally end-to-end transformations; i.e., once\n                   applied\
    \ at the sender, they are not removed except at\n                   the ultimate\
    \ recipient.  An intermediate server may\n                   apply a content-coding,\
    \ in appropriate circumstances.\n   Transfer-coding According to the specification,\
    \ \"Transfer coding\n                   values are used to indicate an encoding\n\
    \                   transformation that has been, can be, or may need to\n   \
    \                be applied to an entity-body in order to ensure \"safe\n    \
    \               transport\" through the network.  This differs from a\n      \
    \             content coding in that the transfer coding is a\n              \
    \     property of the message, not of the original entity.\"\n               \
    \    Transfer-codings are explicitly hop-by-hop\n                   transformations\
    \ (although, as an optimization, an\n                   intermediate proxy may\
    \ store the transfer-coded\n                   version of a message if this behavior\
    \ is not\n                   inconsistent with its externally visible function.)\n\
    \   Ranges          An HTTP client, using the Range header, may request\n    \
    \               that the server return one or more subranges of the\n        \
    \           instance, rather than the entire instance value.\n               \
    \    HTTP/1.1 only supports byte-ranges, although there is\n                 \
    \  some possibility that future extensions will allow\n                   for\
    \ other kinds of range-specifiers (such as chapters\n                   of a document).\n\
    \   A client signals its willingness to receive a content-coding by\n   sending\
    \ an \"Accept-Encoding\" header, listing the set of content-\n   codings that\
    \ it understands.  It may optionally include information\n   about which content-codings\
    \ it prefers.  If a server uses any non-\n   identity content-coding(s), it includes\
    \ a \"Content-Encoding\" header\n   field in the response, listing these content-codings\
    \ in their order\n   of application.\n   RFC 2068 [9] did not include an analogous\
    \ mechanism for negotiating\n   the use of transfer-codings, although it does\
    \ include an analogous\n   \"Transfer-Encoding\" header for marking the response.\
    \  A new \"TE\"\n   header has since been added to HTTP/1.1 [10], analogous to\
    \ the\n   \"Accept-Encoding\" header.\n   In this document, we add new, optional\
    \ message headers to support the\n   use of instance manipulations.  A client\
    \ signals its willingness to\n   receive an instance-manipulation by sending an\
    \ \"A-IM\" header (short\n   for \"Accept-Instance-Manipulation\", which is far\
    \ too long to spell\n   out), analogous to the \"Accept-Encoding\" header.  Similarly,\
    \ a server\n   lists the set of instance-manipulations it has applied using an\
    \ \"IM\"\n   header.\n   One must understand the relationship between these transformations\
    \ in\n   order to see how delta encoding applies to HTTP responses.\n   Conceptually,\
    \ the various transformations are applied in the\n   following sequence:\n   \
    \   1. Upon receiving a GET request, the server uses the URI in the\n        \
    \ request to identify the requested resource.\n      2. Optionally, it uses information\
    \ from the request (and perhaps\n         additional information) to select a\
    \ variant of that resource.\n      3. At this point, the server may apply a non-identity\
    \ content-\n         coding to the instance, or one might have been inherent in\
    \ its\n         generation.  This also results in a Content-Encoding header.\n\
    \      4. The result of the first three steps, at the time when the\n        \
    \ request is processed, is an instance.  The instance includes a\n         body\
    \ (possibly empty) and possibly some instance headers.  The\n         entity tag,\
    \ if any, is assigned at this point.  That is, an\n         entity tag is associated\
    \ with an instance, NOT an entity.\n      5. The server may then apply an instance-manipulation.\
    \  For\n         example, if the request included a Range header, the server may\n\
    \         optionally produce a range response, consisting of the original\n  \
    \       set of headers, a Content-Range header, and the appropriate\n        \
    \ range(s) from the (possibly encoded) body.  Delta encodings are\n         instance-manipulations,\
    \ and are computed at this stage.\n      6. The result of the fifth step becomes\
    \ the entity, consisting of\n         entity headers and an entity body.\n   \
    \   7. The server may then apply a non-identity transfer-coding; on-\n       \
    \  the-fly compression could be done in this step.  If so, a\n         Transfer-Encoding\
    \ header is added to the message.\n      8. The results of the seventh step is\
    \ the message, consisting of a\n         message body (the transfer-coded version\
    \ of the entity body),\n         the entity headers, and additional response and\
    \ general\n         headers.\n      Note: Section 14.13 of the HTTP/1.1 specification\
    \ [10] says \"The\n      Content-Length entity-header field indicates the size\
    \ of the\n      entity-body.\"  In other words, Content-Length measures the length\n\
    \      of an entity, not of an instance or of a variant.  For example, if\n  \
    \    the message is a delta encoding, Content-Length gives the length\n      of\
    \ the delta encoding, not the length of the current instance.\n   Diagrammatically,\
    \ the sequence is:\n       datatype        operation leading to next datatype\n\
    \       ========        ==================================\n       resource\n\
    \                   |   choose acceptable variant, if needed\n               \
    \    v\n       variant\n                   |   apply content-coding, if any\n\
    \                   v\n                   |   compute/assign entity tag\n    \
    \               v\n       instance\n                   |   apply instance manipulation,\
    \ if any\n                   v      (delta encoding, range selection, etc.)\n\
    \       entity-body\n                   |   apply transfer-coding, if any\n  \
    \                 v\n       message-body\n   This formalization of the HTTP message\
    \ generation sequence has not\n   previously been described.  However, it is clear\
    \ that Range selection\n   needs to be done after the entity tag has been assigned\
    \ and after any\n   content-coding has been applied, and before any transfer-coding\
    \ is\n   applied.  Therefore, this formalization is fully consistent with\n  \
    \ previous practice and specification.\n"
- title: 4.1 Relationship between deltas and ranges
  contents:
  - "4.1 Relationship between deltas and ranges\n   If both Ranges and delta encodings\
    \ are forms of instance\n   manipulation, which should be applied first?  This\
    \ depends on how the\n   Range is being used.\n   Ranges are used for two main\
    \ purposes, at the discretion of the\n   requesting client:\n      1. to complete\
    \ a partial response after a premature termination of\n         a message transmission.\n\
    \      2. to obtain just selected sections of an instance.\n   In the first use\
    \ of Range, it would have to be applied after any\n   delta encoding, since the\
    \ intended use is to recover an intact copy\n   of the delta-encoded instance.\
    \  In the second use of Range, it would\n   have to be applied before any delta\
    \ encoding, because otherwise the\n   offsets specified in the Range request would\
    \ be meaningless (the\n   client generally cannot know how a server's delta encoding\
    \ maps\n   instance byte offsets to entity byte offsets).\n   Therefore, we need\
    \ a mechanism to allow the client to specify the\n   order in which two or more\
    \ instance-manipulations should be applied.\n   This is easily provided as part\
    \ of the specification of the \"A-IM\"\n   header (see section 10.5.3), where\
    \ we require that the server apply\n   instance-manipulations in the order that\
    \ they are listed in the \"A-\n   IM\" header.  We also include a \"range\" literal\
    \ in the set of\n   registered instance-manipulations, to allow the client to\
    \ specify (by\n   its ordering with respect to other instance-manipulations) whether\n\
    \   range selection is done before or after delta encoding.\n   We also need a\
    \ mechanism for the server to indicate in which order\n   two or more instance-manipulations\
    \ have been applied; this is part of\n   the specification of the \"IM\" header\
    \ (see section 10.5.2), where we\n   follow the same practice used for the \"\
    Content-Encoding\" header:  the\n   \"IM\" header lists the instance-manipulations\
    \ in the order that were\n   applied (including, perhaps, the special \"range\"\
    \ literal).\n   A similar issue arises when Ranges are combined with compression.\
    \  If\n   the client is using a Range to complete a partial response after a\n\
    \   premature termination of a compressed message, then the Range would\n   have\
    \ to be applied after the compression.  This is feasible in\n   unmodified HTTP/1.1,\
    \ because the compression can be done as a\n   content-coding.  However, if the\
    \ client is using a Range to obtain\n   selected sections of an instance, it would\
    \ normally be able to\n   specify offsets only in terms of the uncompressed variant.\
    \  If the\n   selected portion was large enough to warrant compression, the client\n\
    \   could request a compressed transfer-coding, but this is a hop-by-hop\n   transformation\
    \ and is not the most efficient approach (especially if\n   an HTTP/1.0 proxy\
    \ is in the path).\n   We can resolve this issue by supporting the use of compression\
    \ as an\n   instance-manipulation (as well as as a content-coding or transfer-\n\
    \   coding), and by using the new mechanism that allows the client to\n   specify\
    \ that the compression instance-manipulation is done after the\n   Range instance-manipulation.\n\
    \   This also allows the client to control whether compression is done\n   before\
    \ or after delta encoding, since some simple differencing\n   algorithms (such\
    \ as the UNIX \"diff\" command) require post-compression\n   of their output to\
    \ yield the best results.\n"
- title: 5 Basic mechanisms
  contents:
  - "5 Basic mechanisms\n   In this section, we explain the concepts behind delta\
    \ encoding.  This\n   is not meant as a formal specification of the proposed extensions;\n\
    \   see section 10 for that.\n"
- title: '5.1 Background: an overview of HTTP cache validation'
  contents:
  - "5.1 Background: an overview of HTTP cache validation\n   When a client has a\
    \ response in its cache, and wishes to ensure that\n   this cache entry is current,\
    \ HTTP/1.1 allows the client to do a\n   \"conditional GET\", using one of two\
    \ forms of \"cache validators.\"  In\n   the traditional form, available in both\
    \ HTTP/1.0 and in HTTP/1.1, the\n   client may use the \"If-Modified-Since\" request-header\
    \ to present to\n   the server the \"Last-Modified\" timestamp (if any) that the\
    \ server\n   provided with the response.  If the server's timestamp for the\n\
    \   resource has not changed, it may send a response with a status code\n   of\
    \ 304 (Not Modified), which does not transmit the body of the\n   resource.  If\
    \ the timestamp has changed, the server would normally\n   send a response with\
    \ a status code of 200 (OK), which carries a\n   complete copy of the resource,\
    \ and a new Last-Modified timestamp.\n   This timestamp-based approach is prone\
    \ to error because of the lack\n   of timestamp resolution: if a resource changes\
    \ twice during one\n   second, the change might not be detectable.  Therefore,\
    \ HTTP/1.1 also\n   allows the server to provide an entity tag with a response.\
    \  An\n   entity tag is an opaque string, constructed by the server according\n\
    \   to its own needs; the protocol specification imposes a bare minimum\n   of\
    \ requirements on entity tags.  (In particular, a \"strong\" entity\n   tag must\
    \ change if the value of the resource changes.) In this case,\n   the client may\
    \ validate its cache entry by sending its conditional\n   request using the \"\
    If-None-Match\" request-header, presenting the\n   entity tag associated with\
    \ the cached response.  (The protocol\n   defines several other ways to transmit\
    \ entity tags, such as the \"If-\n   Range\" header, used for short-circuiting\
    \ an otherwise necessary round\n   trip.) If the presented entity tag matches\
    \ the server's current tag\n   for the resource, the server should send a 304\
    \ (Not Modified)\n   response.  Otherwise, the server should send a 200 (OK) response,\n\
    \   along with a complete copy of the resource.\n   In the existing HTTP protocol\
    \ (HTTP/1.0 or HTTP/1.1), a client\n   sending a conditional request can expect\
    \ either of two responses:\n      -  status = 200 (OK), with a full copy of the\
    \ resource, because\n         the server's copy of the resource is presumably\
    \ different from\n         the client's cached copy.\n      -  status = 304 (Not\
    \ Modified), with no body, because the server's\n         copy of the resource\
    \ is presumably the same as the client's\n         cached copy.\n   Informally,\
    \ one could think of these as \"deltas\" of 100% and 0% of\n   the resource, respectively.\
    \  Note that these deltas are relative to a\n   specific cached response.  That\
    \ is, a client cannot request a delta\n   without specifying, somehow, which two\
    \ instances of a resource are\n   being differenced.  The \"new\" instance is\
    \ implicitly the current\n   instance that the server would return for an unconditional\
    \ request,\n   and the \"old\" instance is the one that is currently in the client's\n\
    \   cache.  The cache validator (last-modified time or entity tag) is\n   what\
    \ is used to communicate to the server the identity of the old\n   instance.\n"
- title: 5.2 Requesting the transmission of deltas
  contents:
  - "5.2 Requesting the transmission of deltas\n   In order to support the transmission\
    \ of actual deltas, an extension\n   to HTTP/1.1 needs to provide these features:\n\
    \      1. A way to mark a request as conditional.\n      2. A way to specify the\
    \ old instance, to which the delta will be\n         applied by the client.\n\
    \      3. A way to indicate that the client is able to apply one or more\n   \
    \      specific forms of delta encoding.\n      4. A way to mark a response as\
    \ being delta-encoded in a particular\n         format.\n   The first two features\
    \ are already provided by HTTP/1.1: the presence\n   of a conditional request-header\
    \ (such as \"If-Modified-Since\" or \"If-\n   None-Match\") marks a request as\
    \ conditional, and the value of that\n   header uniquely specifies the old instance\
    \ (ignoring the problem of\n   last-modified timestamp granularity).\n   We defer\
    \ discussion of the fourth feature, until section 5.6.\n   The third feature,\
    \ a way for the client to indicate that it is able\n   to apply deltas (aside\
    \ from the trivial 0% and 100% deltas), can be\n   accomplished by transmitting\
    \ a list of acceptable delta-encoding\n   formats in a request-header field; specifically,\
    \ the \"A-IM\" header.\n   The presence of this list in a conditional request\
    \ indicates that the\n   client is able to apply delta-encoded cache updates.\n\
    \   For example, a client might send this request:\n      GET /foo.html HTTP/1.1\n\
    \      Host: bar.example.net\n      If-None-Match: \"123xyz\"\n      A-IM: vcdiff,\
    \ diffe, gzip\n   The meaning of this request is that:\n      -  The client wants\
    \ to obtain the current value of /foo.html.\n      -  It already has a cached\
    \ response (instance) for that resource,\n         whose entity tag is \"123xyz\"\
    .\n      -  It is willing to accept delta-encoded updates using either of\n  \
    \       two formats, \"diffe\" (i.e., output from the UNIX \"diff -e\"\n     \
    \    command), and \"vcdiff\".  (Encoding algorithms and formats, such\n     \
    \    as \"vcdiff\", are described in section 6.)\n      -  It is willing to accept\
    \ responses that have been compressed\n         using \"gzip,\" whether or not\
    \ these are delta-encoded.  (It\n         might be useful to compress the output\
    \ of \"diff -e\".)  However,\n         based on the mandatory ordering constraint\
    \ specified in section\n         10.5.3, if both delta encoding and compression\
    \ are applied,\n         then this \"A-IM\" request header specifies that compression\n\
    \         should be done last.\n   If, in this example, the server's current entity\
    \ tag for the resource\n   is still \"123xyz\", then it should simply return a\
    \ 304 (Not Modified)\n   response, as would a traditional server.\n   If the entity\
    \ tag has changed, presumably but not necessarily because\n   of a modification\
    \ of the resource, the server could instead compute\n   the delta between the\
    \ instance whose entity tag was \"123xyz\" and the\n   current instance.\n   We\
    \ defer discussion of what the server needs to store, in order to\n   compute\
    \ deltas, until section 7.\n   We note that if a client indicates it is willing\
    \ to accept deltas,\n   but the server does not support this form of instance-manipulation,\n\
    \   the server will simply ignore this aspect of the request.  (HTTP\n   always\
    \ allows an implementation to ignore a header that is not\n   required by a specification\
    \ that the implementation complies with,\n   and the specification of \"A-IM\"\
    \ allows the server to ignore an\n   instance-manipulation it does not understand.)\
    \  So if a server either\n   does not implement the A-IM header at all, or does\
    \ not implement any\n   of the instance manipulations listed in the A-IM header,\
    \ it acts as\n   if the client had not requested a delta-encoded response: the\
    \ server\n   generates a status-200 response.\n"
- title: 5.3 Choice of delta algorithm and format
  contents:
  - "5.3 Choice of delta algorithm and format\n   The server is not required to transmit\
    \ a delta-encoded response.  For\n   example, the result might be larger than\
    \ the current size of the\n   resource.  The server might not be able to compute\
    \ a delta for this\n   type of resource (e.g., a compressed binary format); the\
    \ server might\n   not have sufficient CPU cycles for the delta computation; the\
    \ server\n   might not support any of the delta formats supported by the client;\n\
    \   or, the network bandwidth might be high enough that the delay\n   involved\
    \ in computing the delta is not worth the delay avoided by\n   sending a smaller\
    \ response.\n   However, if the server does want to compute a delta, and the set\
    \ of\n   encodings it supports has more than one encoding in common with the\n\
    \   set offered by the client, which encoding should it use?  This is\n   mostly\
    \ at the option of the server, although the client can express\n   preferences\
    \ using \"Quality Values\" (or \"qvalues\") in the \"A-IM\"\n   header.  The HTTP/1.1\
    \ specification [10] describes qvalues in more\n   detail.  (Clients may prefer\
    \ one delta encoding format over another\n   that generates a smaller encoding,\
    \ if the decoding costs for the\n   first format are lower and the client is resource-constrained.)\n\
    \   Server implementations have a number of possible approaches.  For\n   example,\
    \ if CPU cycles are plentiful and network bandwidth is scarce,\n   the server\
    \ might compute each of the possible encodings and then send\n   the smallest\
    \ result.  Or the server might use heuristics to choose an\n   encoding format,\
    \ based on things such as the content-type of the\n   resource, the current size\
    \ of the resource, and the expected amount\n   of change between instances of\
    \ the resource.\n   Note that it might pay to cache the deltas internally to the\
    \ server,\n   if a resource is typically requested by several different delta-\n\
    \   capable clients between modifications.  In this case, the cost of\n   computing\
    \ a delta may be amortized over many responses, and so the\n   server might use\
    \ a more expensive computation.\n"
- title: 5.4 Identification of delta-encoded responses
  contents:
  - "5.4 Identification of delta-encoded responses\n   A response using delta encoding\
    \ must be identified as such.  This is\n   done using the \"IM\" response-header,\
    \ specified in section 10.5.2.\n   However, a simplistic application of this approach\
    \ would cause\n   serious problems if a delta-encoded response flows through an\n\
    \   intermediate (proxy) cache that is not cognizant of the delta\n   mechanism.\
    \  Because the Internet still includes a significant number\n   of HTTP/1.0 caches,\
    \ which might never be entirely replaced, and\n   because the HTTP specifications\
    \ insist that message recipients ignore\n   any header field that they do not\
    \ understand, a non-delta-capable\n   proxy cache that receives a delta-encoded\
    \ response might store that\n   response, and might later return it to a non-delta-capable\
    \ client\n   that has made a request for the same resource.  This naive client\n\
    \   would believe that it has received a valid copy of the entire\n   resource,\
    \ with predictably unpleasant results.\n   To solve this problem, we propose that\
    \ delta-encoded responses\n   (actually, all instance-manipulated responses) be\
    \ identified as such\n   using a new HTTP status code.  For specificity in the\
    \ discussion that\n   follows, we will use the (currently unassigned) code of\
    \ 226, with a\n   reason phrase of \"IM Used\".  (We see no benefit in spelling\
    \ out the\n   words \"Instance Manipulation Used,\" since this requires the\n\
    \   transmission of unnecessary bytes, and this Reason-phrase should not\n   normally\
    \ be seen by human users.)  There is some precedent for this\n   approach:  the\
    \ HTTP/1.1 specification introduces the 206 (Partial\n   Content) status code,\
    \ for the transmission of sub-ranges of a\n   resource.  Existing proxies apparently\
    \ forward responses with unknown\n   status codes, and do not attempt to cache\
    \ them.\n   An alternative to using a new status code would be to use the\n  \
    \ \"Expires\" header to prevent HTTP/1.0 caches from storing the\n   response,\
    \ then use \"Cache-Control: max-age\" (defined in HTTP/1.1) to\n   allow more\
    \ modern caches to store delta-encoded responses.  This adds\n   many bytes to\
    \ the response headers, and so would reduce the\n   effectiveness of delta encoding.\
    \  It is also not entirely clear that\n   this approach suppresses all caching\
    \ by all HTTP/1.0 proxies.\n      We were reluctant to define an additional status\
    \ code as part of\n      the support for delta encoding.  However, we see no other\n\
    \      efficient way to remain compatible with the deployed base of\n      HTTP/1.0\
    \ cache implementations.\n"
- title: 5.5 Guaranteeing cache safety
  contents:
  - "5.5 Guaranteeing cache safety\n   Although we are not aware of any HTTP/1.1 proxy\
    \ implementations that\n   would attempt to cache a response with an unknown 2xx\
    \ status code,\n   the HTTP/1.1 specification does allow this behavior if the\
    \ response\n   carries an Expires or Cache-Control header field that explicitly\n\
    \   allows caching.  This would present a problem when a 226 (IM Used)\n   response\
    \ carries such headers.\n   The solution in that case is to exploit the Cache\
    \ Control Extensions\n   mechanism from the HTTP/1.1 specification.  We define\
    \ a new cache-\n   directive, \"im\", which indicates that the \"no-store\" cache-directive\n\
    \   may be ignored by implementations that conform to the specification\n   for\
    \ the IM and A-IM headers.\n   For example, this response:\n      HTTP/1.1 226\
    \ IM Used\n      ETag: \"489uhw\"\n      IM: vcdiff\n      Date: Tue, 25 Nov 1997\
    \ 18:30:05 GMT\n      Cache-Control: no-store, im, max-age=30\n      ...\n   \"\
    MUST NOT\" be stored by a cache that complies with the HTTP/1.1\n   specification\
    \ (which states that the max-age cache-directive \"implies\n   that the response\
    \ is cacheable [...] unless some other, more\n   restrictive cache directive is\
    \ also present.\").  However, a cache\n   that does comply with the specification\
    \ for the im cache-directive\n   (i.e., a cache that complies with the specification\
    \ for the A-IM and\n   IM header fields, and the 226 status code) ignores the\
    \ no-store\n   directive, and therefore sees the max-age directive as allowing\n\
    \   caching.\n      We are not entirely sure that all HTTP/1.1 caches obey the\
    \ rule\n      that the max-age directive is overridden by the no-store\n     \
    \ directive.  If operational testing reveals this to be a problem,\n      more\
    \ elaborate solutions are possible.\n   Warning to origin server implementors:\
    \ it does not suffice to send\n      Vary: If-None-Match, A-IM\n   in status-226\
    \ responses.  We have discovered at least one scenario\n   where this does not\
    \ prevent a proxy cache that does not implement IM\n   and A-IM from incorrectly\
    \ \"validating\" a cached 226 response.\n"
- title: 5.6 Transmission of delta-encoded responses
  contents:
  - "5.6 Transmission of delta-encoded responses\n   A delta-encoded response differs\
    \ from a standard response in four\n   ways:\n      1. It carries a status code\
    \ of 226 (IM Used).\n      2. It carries an \"IM\" response-header field, indicating\
    \ which\n         delta encoding is used in this response.\n      3. Its message-body\
    \ is a delta encoding of the current instance,\n         rather than a full copy\
    \ of the instance.\n      4. It might carry several other new headers, as described\
    \ later in\n         this document.\n   For example, a response to the request\
    \ given in section 5.2 might\n   look like:\n      HTTP/1.1 226 IM Used\n    \
    \  ETag: \"489uhw\"\n      IM: vcdiff\n      Date: Tue, 25 Nov 1997 18:30:05 GMT\n\
    \      ...\n   (We do not show the actual contents of the response body, since\
    \ this\n   is a binary format.)\n      Note: the Etag header in a 226 response\
    \ with a delta encoding\n      provides the entity tag of the current instance\
    \ of the resource\n      variant.  It is not meaningful to associate an entity\
    \ tag with the\n      delta value, which is not an instance.\n"
- title: 5.7 Examples of requests combining Range and delta encoding
  contents:
  - "5.7 Examples of requests combining Range and delta encoding\n   In the example\
    \ used in section 5.2, the client sends:\n      GET /foo.html HTTP/1.1\n     \
    \ Host: bar.example.net\n      If-None-Match: \"123xyz\"\n      A-IM: vcdiff,\
    \ diffe, gzip\n   and the server either responds with a 304 (Not Modified) response,\
    \ or\n   with the appropriate delta encoding.\n   Here are a few more examples,\
    \ to clarify how the client request\n   should be interpreted.\n   If the client\
    \ sends\n      GET /foo.html HTTP/1.1\n      Host: bar.example.net\n      If-None-Match:\
    \ \"123xyz\"\n      A-IM: vcdiff, diffe, gzip, range\n      Range: bytes=0-99\n\
    \   then the meaning is the same as in the example above, except that\n   after\
    \ the delta encoding (and compression, if any) is computed, the\n   server then\
    \ returns only the first 100 bytes of the output of the\n   delta encoding.  (If\
    \ it is shorter than 100 bytes, the entire delta\n   encoding is returned.)  Because\
    \ the \"range\" token appears last in the\n   \"A-IM\" header, this tells the\
    \ origin server to apply any range\n   selection after the other instance-manipulations.\n\
    \   The interaction between the If-Range mechanism and delta encoding is\n   somewhat\
    \ complex.  (If-Range means, informally, \"if the entity is\n   unchanged, send\
    \ me the part(s) that I am missing; otherwise, send me\n   the entire new entity.\"\
    )  Here is an example that should clarify the\n   use of this combination.\n \
    \  Suppose that the client wants to have the complete current instance\n   of\
    \ http://bar.example.net/foo.html.  It already has a (complete)\n   cache entry\
    \ for this URI, with entity tag \"A\", so it issues this\n   request:\n      GET\
    \ /foo.html HTTP/1.1\n      host: bar.example.net\n      If-None-Match: \"A\"\n\
    \      A-IM: vcdiff\n   Suppose that the server's current instance has entity\
    \ tag \"B\", and\n   that the server also has retained a copy of the instance\
    \ with entity\n   tag \"A\".  Then, the server could compute the difference between\
    \ \"B\"\n   and \"A\", and respond with:\n      HTTP/1.1 226 IM Used\n      Etag:\
    \ \"B\"\n      IM: vcdiff\n      Date: Tue, 25 Nov 1997 18:30:05 GMT\n      Content-Length:\
    \ 1000\n      ...\n   but the network connection is terminated after the client\
    \ has\n   received exactly 900 bytes of the message body for the delta-encoded\n\
    \   content.\n   The client wants to retrieve the remaining 100 bytes of the delta\n\
    \   encoding that was being sent in the interrupted response.  It\n   therefore\
    \ should send:\n      GET /foo.html HTTP/1.1\n      host: bar.example.net\n  \
    \    If-None-Match: \"A\"\n      If-Range: \"B\"\n      A-IM: vcdiff,range\n \
    \     Range: bytes=900-\n   This rather elaborate request has a well-defined meaning,\
    \ which\n   depends on the current entity tag Tcur of the instance when the\n\
    \   server receives the request:\n   Tcur = \"A\"      (i.e., for some reason,\
    \ the instance has reverted to\n                   the value already in the client's\
    \ cache).  The server\n                   should return a 304 (Not Modified) response,\
    \ as\n                   required by the HTTP/1.1 specification for \"If-None-\n\
    \                   Match\".\n   Tcur = \"B\"      (i.e., the instance has not\
    \ changed again).  The\n                   HTTP/1.1 specification for \"If-None-Match\"\
    , in this\n                   case, is that the header field is ignored (by a\n\
    \                   server that does not understand delta encoding).\n       \
    \            Therefore, this is equivalent to the client's\n                 \
    \  previous request, except that the Range selection is\n                   applied\
    \ after the vcdiff instance manipulation (if\n                   both are to be\
    \ applied).  So the (delta-aware) server\n                   again computes the\
    \ delta between the \"A\" instance and\n                   the \"B\" instance\
    \ (or uses a cached computation of the\n                   delta), then applies\
    \ the Range selection, and returns\n                   a 226 (IM Used) response,\
    \ with an message-body\n                   containing bytes 900 to 999 of the\
    \ result of the\n                   vcdiff encoding, with an \"IM:vcdiff,range\"\
    \ response\n                   header.\n   Tcur = \"C\"      (i.e., the instance\
    \ has changed again).  In this\n                   case, the HTTP/1.1 specification\
    \ for \"If-None-Match\"\n                   again means that this is equivalent\
    \ to an\n                   unconditional request for the current instance.  The\n\
    \                   specification for \"If-Range\" requires the server to\n  \
    \                 return the entire current instance.  However, a\n          \
    \         delta-aware server can construct the delta between\n               \
    \    the \"A\" instance described by the \"If-None-Match\"\n                 \
    \  field and the current (\"C\") instance, and return a\n                   226\
    \ (IM Used) response, with an \"IM:vcdiff\" response\n                   header.\n\
    \   If the client's request had not included the \"If-None-Match: \"A\"\"\n  \
    \ header field, the server could not have computed a delta, since it\n   would\
    \ not have known which entire instance was already available to\n   the client.\
    \  If the request had not included the \"If-Range: \"B\"\"\n   header field, the\
    \ server could not have distinguished between the\n   latter two cases (Tcur =\
    \ \"B\" or Tcur = \"C\") and would not have been\n   able to apply the Range selection\
    \ to the result of delta encoding.\n   On the other hand, suppose that the client\
    \ has a cache entry for the\n   \"A\" instance of http://bar.example.net/foo.html,\
    \ and it has already\n   received the first 900 bytes of a new instance \"B\"\
    \ (perhaps as the\n   result of an aborted transfer).  Now the client wants to\
    \ receive the\n   entire current instance, so it could send this request:\n  \
    \    GET /foo.html HTTP/1.1\n      host: bar.example.net\n      If-None-Match:\
    \ \"A\"\n      If-Range: \"B\"\n      A-IM: range,vcdiff\n      Range: bytes=900-\n\
    \   In this example, as in the previous example, if Tcur = \"A\" then the\n  \
    \ server should send 304 (Not Modified), and if Tcur = \"C\", then the\n   server\
    \ should send the entire new instance, either as a 200 response\n   or as a delta\
    \ encoding against instance \"A\".\n   However, if Tcur = \"B\", in this case\
    \ the server should first select\n   the specified range (bytes 900 through the\
    \ end) from both instances\n   \"A\" and \"B\", then compute the delta encoding\
    \ between these ranges\n   (using vcdiff), and then transmit the result using\
    \ a 226 (IM Used)\n   response with an \"IM:range,vcdiff\" response header.\n"
- title: 6 Encoding algorithms and formats
  contents:
  - "6 Encoding algorithms and formats\n   A number of delta encoding algorithms and\
    \ formats have been described\n   in the literature:\n   diff -e         The UNIX\
    \ \"diff\" program is ubiquitously available,\n                   and is relatively\
    \ fast for both encoding and decoding\n                   (decoding is actually\
    \ done using the \"ed\" program).\n                   However, the size of the\
    \ resulting deltas is\n                   relatively large.  This algorithm can\
    \ only be used on\n                   text-format files.\n   diff -e | gzip  Running\
    \ the output of \"diff\" through a compression\n                   algorithm such\
    \ as \"gzip\" [5] (or, perhaps better,\n                   \"deflate\" [7, 6])\
    \ yields a more compact encoding, but\n                   the costs of encoding\
    \ and decoding are much higher\n                   than for \"diff\" by itself.\
    \  This algorithm can only\n                   be used on text-format files.\n\
    \   vcdiff (vdelta) The algorithm that generates the \"vcdiff\" format [19,\n\
    \                   20] inherently compresses its output, and generally\n    \
    \               produces smaller results than the combination of\n           \
    \        \"diff\" and \"gzip\".  The algorithm also runs much\n              \
    \     faster, and can be applied to binary-format input.\n                   The\
    \ \"vcdiff\" format is based on previous work on an\n                   algorithm\
    \ named \"vdelta.\"  (Note that the \"vcdiff\"\n                   format can\
    \ be used either for delta encoding or as a\n                   compressed format,\
    \ so two different instance-\n                   manipulation values would have\
    \ to be registered in\n                   order to distinguish these two uses,\
    \ should its use\n                   as a compressed format be adopted.)  The\
    \ most recent\n                   published study suggests that \"vdelta\" is\
    \ the best\n                   overall delta algorithm [16].\n   gdiff       \
    \    The gdiff format [14] was specified as a generic,\n                   algorithm-independent\
    \ format for expressing deltas.\n                   Because it is more generic\
    \ it is easy to implement,\n                   but it may not be the most compact\
    \ encoding format.\n   Our proposal does not recommend any specific algorithm\
    \ or format, but\n   rather encourages client and server implementors to choose\
    \ the most\n   appropriate one(s).  However, to avoid the possibility of excessively\n\
    \   long \"A-IM\" headers, we suggest that, after some period of\n   experimentation,\
    \ it might be reasonable to specify a \"recommended\"\n   set of delta formats\
    \ for general-purpose HTTP implementations.\n   We suspect that it should be possible\
    \ to devise a delta encoding\n   algorithm appropriate for use on typical image\
    \ encodings, such as GIF\n   and JPEG.  Although experiments with vdelta have\
    \ not shown much\n   potential [23], this may simply be because these experiments\
    \ used\n   vdelta directly on the already-compressed forms of these encodings.\n\
    \   However, it might be necessary to devise a delta encoding algorithm\n   that\
    \ is aware of the two-dimensional nature of images.  We have some\n   expectation\
    \ that this is possible, since MPEG compression relies on\n   computing deltas\
    \ between successive frames of a video stream.\n"
- title: 7 Management of base instances
  contents:
  - "7 Management of base instances\n   If the time between modifications of a resource\
    \ is less than the\n   typical eviction time for responses in client caches, this\
    \ means that\n   the \"old instance\" indicated in a client's conditional request\
    \ might\n   not refer to the most recent prior instance.  This raises the\n  \
    \ question of how many old instances of a resource should be maintained\n   by\
    \ the server, if any.  We call these old instances \"base instances.\"\n   There\
    \ are many possible options for server implementors.  For\n   example:\n     \
    \ -  The server might not store any old instances, and so would\n         never\
    \ respond with a delta.\n      -  The server might only store the most recent\
    \ prior instance;\n         requests attempting to validate this instance could\
    \ be answered\n         with a delta, but requests attempting to validate older\n\
    \         instances would be answered with a full copy of the resource.\n    \
    \  -  The server might store all prior instances, allowing it to\n         provide\
    \ a delta response for any client request.\n      -  The server might store only\
    \ a subset of the prior instances.\n         The use of a Least Recently Used\
    \ (LRU) algorithm to determine\n         this kind of subset has proved effective\
    \ in some similar\n         circumstances, such as cache replacement.\n   The\
    \ server might not have to store prior instances explicitly.  It\n   might, instead,\
    \ store just the deltas between specific base instances\n   and subsequent instances\
    \ (or the inverse deltas between base\n   instances and prior instances).  This\
    \ approach might be integrated\n   with a cache of computed deltas.\n   None of\
    \ these approaches necessarily requires additional protocol\n   support.  However,\
    \ if a server administrator wants to store only a\n   subset of the prior instances,\
    \ but would like the server to be able\n   to respond using deltas as often as\
    \ possible, then the client needs\n   some additional information.  Otherwise,\
    \ the client's \"If-None-Match\"\n   header might specify a base instance not\
    \ stored at the server, even\n   though an appropriate base instance is held in\
    \ the client's cache.\n   We identify two additional protocol changes to help\
    \ solve this\n   problem.\n"
- title: 7.1 Multiple entity tags in the If-None-Match header
  contents:
  - "7.1 Multiple entity tags in the If-None-Match header\n   Although the examples\
    \ we have given so far show only one entity tag\n   in an \"If-None-Match\" header,\
    \ the HTTP/1.1 specification allows the\n   header to carry more than one entity-tag.\
    \  This feature was included\n   in HTTP/1.1 to support efficient caching of multiple\
    \ variants of a\n   resource, but it is not restricted to that use.\n   Suppose\
    \ that a client has kept more than one instance of a resource\n   in its cache.\
    \  That is, not only does it keep the most recent\n   instance, but it also holds\
    \ onto copies of one or more prior, invalid\n   instances.  (Alternatively, it\
    \ might retain sufficient delta or\n   inverse-delta information to reconstruct\
    \ older instances.)  In this\n   case, it could use its conditional request to\
    \ tell the server about\n   all of the instances it could apply a delta to.  For\
    \ example, the\n   client might send:\n      GET /foo.html HTTP/1.1\n      host:\
    \ bar.example.net\n      If-None-Match: \"123xyz\", \"337pey\", \"489uhw\"\n \
    \     A-IM: vcdiff\n   to indicate that it has three instances of this resource\
    \ in its\n   cache.  If the server is able to generate a delta from any of these\n\
    \   prior instances, it can select the appropriate base instance, compute\n  \
    \ the delta, and return the result to the client.\n   In this case, however, the\
    \ server must also tell the client which\n   base instance to use, and so we need\
    \ to define a response header,\n   named \"Delta-Base\", for this purpose.  For\
    \ example, the server might\n   reply:\n      HTTP/1.1 226 IM Used\n      ETag:\
    \ \"1acl059\"\n      IM: vcdiff\n      Delta-Base: \"337pey\"\n      Date: Tue,\
    \ 25 Nov 1997 18:30:05 GMT\n   This response tells the client to apply the delta\
    \ to the cached\n   response with entity tag \"337pey\", and to associate the\
    \ entity tag\n   \"1acl059\" with the result.\n   Of course, if the server has\
    \ retained more than one of the prior\n   instances identified by the client,\
    \ this could complicate the problem\n   of choosing the optimal delta to return,\
    \ since now the server has a\n   choice not only of the delta format, but also\
    \ of the base instance to\n   use.\n"
- title: 7.2 Hints for managing the client cache
  contents:
  - "7.2 Hints for managing the client cache\n   Support for multiple entity tags\
    \ in choosing the base instance\n   implies that a client might benefit from storing\
    \ multiple old\n   instances of a resource in its cache.  A client with finite\
    \ space\n   would not want to keep all old instances, so it must manage its cache\n\
    \   for maximal effectiveness by saving those instances most likely to be\n  \
    \ useful for future deltas.  Although this could be accomplished using\n   information\
    \ purely local to the client (e.g., an LRU algorithm),\n   certain \"hint\" information\
    \ from the server could improve the client's\n   ability to manage its cache.\
    \  The use of hints for improving Web\n   cache performance has been described\
    \ previously [4, 22].\n   If the server intends to retain certain instances and\
    \ not others, it\n   can label the responses that transmit the retained instances.\
    \  This\n   would help the client manage its cache, since it would not have to\n\
    \   retain all prior instances on the possibility that only some of them\n   might\
    \ be useful later.  The label is a hint to the client, not a\n   promise that\
    \ the server will indefinitely retain an instance.\n   We propose adding a new\
    \ directive to the existing \"Cache-Control\"\n   header for this purpose, named\
    \ \"retain\".  For example, in response to\n   an unconditional request, the server\
    \ might send:\n      HTTP/1.1 200 OK\n      ETag: \"337pey\"\n      Date: Tue,\
    \ 25 Nov 1997 18:30:05 GMT\n      Cache-Control: retain\n   to suggest that a\
    \ delta-capable client should retain this instance.\n   The \"retain\" directive\
    \ could also appear in a delta response,\n   referring to the current instance:\n\
    \      HTTP/1.1 226 IM Used\n      ETag: \"1acl059\"\n      Date: Tue, 25 Nov\
    \ 1997 18:30:05 GMT\n      Cache-Control: retain\n      IM: vcdiff\n      Delta-Base:\
    \ \"337pey\"\n   The \"retain\" directive includes an optional timeout parameter,\
    \ which\n   the server can use if it expects to delete an old base instance at\
    \ a\n   particular time.  For example,\n      HTTP/1.1 200 OK\n      ETag: \"\
    337pey\"\n      Date: Tue, 25 Nov 1997 18:30:05 GMT\n      Cache-Control: retain=3600\n\
    \   means that the server intends to retain this base instance for one\n   hour.\n\
    \   Another situation where a server can provide a hint to a client is\n   where\
    \ the server supports the delta mechanism in general, but does\n   not intend\
    \ to provide delta-encoded responses for a particular\n   resource.  By sending\
    \ a \"retain=0\" directive, it indicates that the\n   client should not waste\
    \ request-header bytes attempting to obtain a\n   delta-encoded response using\
    \ this base instance (and, by implication,\n   for this resource).  It also indicates\
    \ that the client ought not\n   waste cache space on this instance after it has\
    \ become stale.  To\n   avoid wasting response-header bytes, a server ought not\
    \ send\n   \"retain=0\", except in reply to a request that attempts to obtain\
    \ a\n   delta-encoded response.\n      Note that the \"retain\" directive is orthogonal\
    \ to the \"max-age\"\n      directive.  The \"max-age\" directive indicates how\
    \ long a cache\n      entry remains fresh (i.e.,can be used without contacting\
    \ the\n      origin server for revalidation); the \"retain\" directive is of\n\
    \      interest to a client AFTER the cache entry has become stale.\n   In practice,\
    \ the \"Cache-Control\" response-header field might already\n   be present, so\
    \ the cost (in bytes) of sending this directive might be\n   smaller than these\
    \ examples implies.\n"
- title: 8 Deltas and intermediate caches
  contents:
  - "8 Deltas and intermediate caches\n   Although we have designed the delta-encoded\
    \ responses so that they\n   will not be stored by naive proxy caches, if a proxy\
    \ does understand\n   the delta mechanism, it might be beneficial for it to participate\
    \ in\n   sending and receiving deltas.\n   A proxy could participate in several\
    \ independent ways:\n      -  In addition to forwarding a delta-encoded response,\
    \ the proxy\n         might store it, and then use it to reply to a subsequent\n\
    \         request with a compatible \"If-None-Match\" field (i.e., one that\n\
    \         is either a superset of the corresponding field of the request\n   \
    \      that first elicited the response, or one that includes the\n         \"\
    Delta-Base\" value in the cached response), and with a\n         compatible \"\
    IM\" response-header field (one that includes the\n         actual delta-encoding\
    \ format used in the response.)  Of course,\n         such uses are subject to\
    \ all of the other HTTP rules concerning\n         the validity of cache entries.\n\
    \      -  In addition to forwarding a delta-encoded response, the proxy\n    \
    \     might apply the delta to the appropriate entry in its own\n         cache,\
    \ which could then be used for later responses (even from\n         non-delta-capable\
    \ clients).\n      -  When the proxy receives a conditional request from a delta-\n\
    \         capable client, and the proxy has a complete copy of an up-to-\n   \
    \      date (\"fresh,\" in HTTP/1.1 terminology) response in its cache,\n    \
    \     it could generate a delta locally and return it to the\n         requesting\
    \ client.\n      -  When the proxy receives a request from a non-delta-capable\n\
    \         client, it might convert this into a delta request before\n        \
    \ forwarding it to the server, and then (after applying a\n         resulting\
    \ delta response to one of its own cache entries) it\n         would return a\
    \ full-body response to the client (or a response\n         with status code 206\
    \ or 304, as appropriate).\n   All of these optional techniques increase proxy\
    \ software complexity,\n   and might increase proxy storage or CPU requirements.\
    \  However, if\n   applied carefully, they should help to reduce the latencies\
    \ seen by\n   end users, and load on the network.  Generally, CPU speed and disk\n\
    \   costs are improving faster than network latencies, so we expect to\n   see\
    \ increasing value available from complex proxy implementations.\n"
- title: 9 Digests for data integrity
  contents:
  - "9 Digests for data integrity\n   When a recipient reassembles a complete HTTP\
    \ response from several\n   individual messages, it might be necessary to check\
    \ the integrity of\n   the complete response.  For example, the client's cache\
    \ might be\n   corrupt, or the implementation of delta encoding (either at client\
    \ or\n   server) might have a bug.\n   HTTP/1.1 includes mechanisms for ensuring\
    \ the integrity of individual\n   messages.  A message may include a \"Content-MD5\"\
    \ response header,\n   which provides an MD5 message digest of the body of the\
    \ message (but\n   not the headers).  The Digest Authentication mechanism [11]\
    \ provides\n   a similar message-digest function, except that it includes certain\n\
    \   header fields.  Neither of these mechanisms makes any provision for\n   covering\
    \ a set of data transmitted over several messages, as would be\n   the case for\
    \ the result of applying a delta-encoded response (or, for\n   that matter, a\
    \ Range response).\n   Data integrity for reassembled messages requires the introduction\
    \ of\n   a new message header.  Such a mechanism is proposed in a separate\n \
    \  document [24].  One might still want to use the Digest Authentication\n   mechanism,\
    \ or something stronger, to protect delta messages against\n   tampering.\n"
- title: 10 Specification
  contents:
  - "10 Specification\n   In this specification, the key words \"MUST\", \"MUST NOT\"\
    , \"SHOULD\",\n   \"SHOULD NOT\", and \"MAY\" are to be interpreted as described\
    \ in RFC\n   2119 [3].\n"
- title: 10.1 Protocol parameter specifications
  contents:
  - "10.1 Protocol parameter specifications\n   This specification defines a new HTTP\
    \ parameter type, an instance-\n   manipulation:\n      instance-manipulation\
    \ = token [imparams]\n      imparams = \";\" imparam-name [ \"=\" ( token | quoted-string\
    \ ) ]\n      imparam-name = token\n   Note that the imparam-name MUST NOT be \"\
    q\", to avoid ambiguity with\n   the use of qvalues (see [10]).\n   The set of\
    \ instance-manipulation values is initially:\n      -  vcdiff\n         A delta\
    \ using the \"vcdiff\" encoding format [19, 20].\n      -  diffe\n         The\
    \ output of the UNIX \"diff -e\" command [26].\n      -  gdiff\n         The GDIFF\
    \ encoding format [14].\n      -  gzip\n         Same definition as the HTTP \"\
    gzip\" content-coding.\n      -  deflate\n         Same definition as the HTTP\
    \ \"deflate\" content-coding.\n      -  range\n         A token indicating that\
    \ the result is partial content, as the\n         result of a range selection.\n\
    \      -  identity\n         A token used only in the A-IM header (not in the\
    \ IM header), to\n         indicate whether or not the identity instance-manipulation\
    \ is\n         acceptable.\n   For convenience in the rest of this specification,\
    \ we define a subset\n   of instance-manipulation values as delta-coding values:\n\
    \      delta-coding = \"vcdiff\" | \"diffe\" | \"gdiff\" | token\n   Future instance-manipulation\
    \ values might also be included in this\n   list.\n"
- title: 10.2 IANA Considerations
  contents:
  - "10.2 IANA Considerations\n   The Internet Assigned Numbers Authority (IANA) administers\
    \ the name\n   space for instance-manipulation values.  Values and their meaning\n\
    \   must be documented in an RFC or other peer-reviewed, permanent, and\n   readily\
    \ available reference, in sufficient detail so that\n   interoperability between\
    \ independent implementations is possible.\n   Subject to these constraints, name\
    \ assignments are First Come, First\n   Served (see RFC 2434 [25]).\n   This specification\
    \ also inserts a new value in the IANA HTTP Status\n   Code Registry (see RFC\
    \ 2817 [18]).  See section 10.4.1 for the\n   specification of this code.\n"
- title: 10.3 Basic requirements for delta-encoded responses
  contents:
  - "10.3 Basic requirements for delta-encoded responses\n   A server MAY send a delta-encoded\
    \ response if all of these conditions\n   are true:\n      1. The server would\
    \ be able to send a 200 (OK) response for the\n         request.\n      2. The\
    \ client's request includes an A-IM header field listing at\n         least one\
    \ delta-coding.\n      3. The client's request includes an If-None-Match header\
    \ field\n         listing at least one valid entity tag for an instance of the\n\
    \         Request-URI (a \"base instance\").\n   A delta-encoded response:\n \
    \     -  MUST carry a status code of 226 (IM Used).\n      -  MUST include an\
    \ IM header field listing, at least, the delta-\n         coding employed.\n \
    \     -  MAY include a Delta-Base header field listing the entity tag of\n   \
    \      the base-instance.\n"
- title: 10.4 Status code specifications
  contents:
  - "10.4 Status code specifications\n   The following new status code is defined\
    \ for HTTP.\n"
- title: 10.4.1 226 IM Used
  contents:
  - "10.4.1 226 IM Used\n   The server has fulfilled a GET request for the resource,\
    \ and the\n   response is a representation of the result of one or more instance-\n\
    \   manipulations applied to the current instance.  The actual current\n   instance\
    \ might not be available except by combining this response\n   with other previous\
    \ or future responses, as appropriate for the\n   specific instance-manipulation(s).\
    \  If so, the headers of the\n   resulting instance are the result of combining\
    \ the headers from the\n   status-226 response and the other instances, following\
    \ the rules in\n   section 13.5.3 of the HTTP/1.1 specification [10].\n   The\
    \ request MUST have included an A-IM header field listing at least\n   one instance-manipulation.\
    \  The response MUST include an Etag header\n   field giving the entity tag of\
    \ the current instance.\n   A response received with a status code of 226 MAY\
    \ be stored by a\n   cache and used in reply to a subsequent request, subject\
    \ to the HTTP\n   expiration mechanism and any Cache-Control headers, and to the\n\
    \   requirements in section 10.6.\n   A response received with a status code of\
    \ 226 MAY be used by a cache,\n   in conjunction with a cache entry for the base\
    \ instance, to create a\n   cache entry for the current instance.\n"
- title: 10.5 Header specifications
  contents:
  - "10.5 Header specifications\n   The following headers are defined, for use as\
    \ entity-headers.  (Due\n   to the terminological confusion discussed in section\
    \ 3, some entity-\n   headers are more properly associated with instances than\
    \ with\n   entities.)\n"
- title: 10.5.1 Delta-Base
  contents:
  - "10.5.1 Delta-Base\n   The Delta-Base entity-header field is used in a delta-encoded\n\
    \   response to specify the entity tag of the base instance.\n      Delta-Base\
    \ = \"Delta-Base\" \":\" entity-tag\n   A Delta-Base header field MUST be included\
    \ in a response with an IM\n   header that includes a delta-coding, if the request\
    \ included more\n   than one entity tag in its If-None-Match header field.\n \
    \  Any response with an IM header that includes a delta-coding MAY\n   include\
    \ a Delta-Base header.\n      We are not aware of other cases where a delta-encoded\
    \ response\n      MUST or SHOULD include a Delta-Base header, but we have not\
    \ done\n      an exhaustive or formal analysis.  Implementors might be wise to\n\
    \      include a Delta-Base header in every delta-encoded response.\n   A cache\
    \ or proxy that receives a delta-encoded response that lacks a\n   Delta-base\
    \ header MAY add a Delta-Base header whose value is the\n   entity tag given in\
    \ the If-None-Match field of the request (but only\n   if that field lists exactly\
    \ one entity tag).\n"
- title: 10.5.2 IM
  contents:
  - "10.5.2 IM\n   The IM response-header field is used to indicate the instance-\n\
    \   manipulations, if any, that have been applied to the instance\n   represented\
    \ by the response.  Typical instance manipulations include\n   delta encoding\
    \ and compression.\n      IM = \"IM\" \":\" #(instance-manipulation)\n   Instance-manipulations\
    \ are defined in section 10.1.\n   As a special case, if the instance-manipulations\
    \ include both range\n   selection and at least one other non-identity instance-manipulation,\n\
    \   the IM header field MUST be used to indicate the order in which all\n   of\
    \ these instance-manipulations, including range selection, were\n   applied. \
    \ If the IM header lists the \"range\" instance-manipulation,\n   the response\
    \ MUST include either a Content-Range header or a\n   multipart/byteranges Content-Type\
    \ in which each part contains a\n   Content-Range header.  (See section 10.10\
    \ for specific discussion of\n   combining delta encoding and multipart/byteranges.)\n\
    \   Responses that include an IM header MUST carry a response status code\n  \
    \ of 226 (IM Used), as specified in section 10.4.1.\n   The server SHOULD omit\
    \ the IM header if it would list only the\n   \"range\" instance-manipulation.\
    \  Such responses would normally be sent\n   with response status code 206 (Partial\
    \ Content), as specified by\n   HTTP/1.1 [10].\n   Examples of the use of the\
    \ IM header include:\n      IM: vcdiff\n   This example indicates that the entity-body\
    \ is a delta encoding of\n   the instance, using the vcdiff encoding.\n      IM:\
    \ diffe, deflate, range\n   This example indicates that the instance has first\
    \ been delta-encoded\n   using the diffe encoding, then the result of that has\
    \ been compressed\n   using deflate, and finally one or more ranges of that compressed\n\
    \   encoding have been selected.\n      IM: range, vcdiff\n   This example indicates\
    \ that one or more ranges of the instance have\n   been selected, and the result\
    \ has then been delta encoded against\n   identical ranges of a previous base\
    \ instance.\n   A cache using a response received in reply to one request to reply\
    \ to\n   a subsequent request MUST follow the rules in section 10.6 if the\n \
    \  cached response includes an IM header field.\n"
- title: 10.5.3 A-IM
  contents:
  - "10.5.3 A-IM\n   The A-IM request-header field is similar to Accept, but restricts\
    \ the\n   instance-manipulations (section 10.1) that are acceptable in the\n \
    \  response.  As specified in section 10.5.2, a response may be the\n   result\
    \ of applying multiple instance-manipulations.\n      A-IM = \"A-IM\" \":\" #(\
    \ instance-manipulation\n                               [ \";\" \"q\" \"=\" qvalue\
    \ ] )\n   When an A-IM request-header field includes one or more delta-coding\n\
    \   values, the request MUST contain an If-None-Match header field,\n   listing\
    \ one or more entity tags from prior responses for the\n   request-URI.\n   A\
    \ server tests whether an instance-manipulation (among the ones it is\n   capable\
    \ of employing) is acceptable, according to a given A-IM header\n   field, using\
    \ these rules:\n      1. If the instance-manipulation is listed in the A-IM field,\
    \ then\n         it is acceptable, unless it is accompanied by a qvalue of 0.\n\
    \         (As defined in section 3.9 of the HTTP/1.1 specification [10],\n   \
    \      a qvalue of 0 means \"not acceptable.\")  A server MUST NOT use a\n   \
    \      non-identity instance-manipulation for a response unless the\n        \
    \ instance-manipulation is listed in an A-IM header in the\n         request.\n\
    \      2. If multiple but incompatible instance-manipulations are\n         acceptable,\
    \ then the acceptable instance-manipulation with the\n         highest non-zero\
    \ qvalue is preferred.\n      3. The \"identity\" instance-manipulation is always\
    \ acceptable,\n         unless specifically refused because the A-IM field includes\n\
    \         \"identity;q=0\".\n   If an A-IM field is present in a request, and\
    \ if the server cannot\n   send a response which is acceptable according to the\
    \ A-IM header,\n   then the server SHOULD send an error response with the 406\
    \ (Not\n   Acceptable) status code.\n   If a response uses more than one instance-manipulation,\
    \ the\n   instance-manipulations MUST be applied in the order in which they\n\
    \   appear in the A-IM request-header field.\n   The server's choice about whether\
    \ to apply an instance-manipulation\n   SHOULD be independent of its choice to\
    \ apply any subsequent two-input\n   instance-manipulations to the response. \
    \ (Two-input instance-\n   manipulations include delta-codings, because they take\
    \ two different\n   values as input.  Compression and \"range\" instance-manipulations\
    \ take\n   only one input.  Other instance-manipulations may be defined in the\n\
    \   future.)\n      Note: the intent of this requirement is to prevent the server\
    \ from\n      generating a delta-encoded response that the client can only\n \
    \     decode by first applying an instance-manipulation encoding to its\n    \
    \  cached base instance.  A server implementor might wish to consider\n      what\
    \ the client would logically have in its cache, when deciding\n      which instance-manipulations\
    \ to apply prior to a delta-coding.\n   Examples:\n      A-IM: vcdiff, gdiff\n\
    \   This example means that the client will accept a delta encoding in\n   either\
    \ vcdiff or gdiff format.\n      A-IM: vcdiff, gdiff;q=0.3\n   This example means\
    \ that the client will accept a delta encoding in\n   either vcdiff or gdiff format,\
    \ but prefers the vcdiff format.\n      A-IM: vcdiff, diffe, gzip\n   This example\
    \ means that the client will accept a delta encoding in\n   either vcdiff or diffe\
    \ format, and will accept the output of the\n   delta encoding compressed with\
    \ gzip.  It also means that the client\n   will accept a gzip compression of the\
    \ instance, without any delta\n   encoding, because A-IM provides no way to insist\
    \ that gzip be used\n   only if diffe is used.\n   It is left to the server implementor\
    \ to choose useful combinations of\n   acceptable instance-manipulations (for\
    \ example, following diffe by\n   gzip is useful, but following vcdiff by gzip\
    \ probably is not useful).\n"
- title: 10.6 Caching rules for 226 responses
  contents:
  - "10.6 Caching rules for 226 responses\n   When a client or proxy receives a 226\
    \ (IM Used) response, it MAY use\n   this response to create a cache entry in\
    \ three ways:\n      1. It MAY decode all of the instance-manipulations to recover\
    \ the\n         original instance, and store that instance in the cache.  In\n\
    \         this case, the recovered instance is stored as a status-200\n      \
    \   response, and MUST be used in accordance with the normal HTTP\n         caching\
    \ rules.\n      2. It MAY decode all of the instance-manipulations except for\n\
    \         range selection(s), and store the result in the cache.  In this\n  \
    \       case, the result is stored as a status-206 response, and MUST\n      \
    \   be used in accordance with the normal HTTP caching rules for\n         Partial\
    \ Content.\n      3. It MAY store the status-226 (IM Used) response as a cache\n\
    \         entry.\n   A status-226 cache entry MUST NOT be used in response to\
    \ a subsequent\n   request under any of these conditions (a cache that never stores\n\
    \   status-226 responses may ignore these tests):\n      1. If any of the instance-manipulation\
    \ values from the IM header\n         field in the cached response do not appear\
    \ in the subsequent\n         request's A-IM header field.  The comparison between\
    \ the\n         headers is done using an exact match on each instance-\n     \
    \    manipulation value including any associated imparams values\n         (see\
    \ section 10.1).\n      2. If the order of instance-manipulation values appearing\
    \ in the\n         cached IM header field differs from the order of that set of\n\
    \         instance-manipulations in the A-IM header field of the\n         subsequent\
    \ request.\n      3. If the cache implementation is not aware of, or is not at\
    \ least\n         conditionally compliant with, the specification of any of the\n\
    \         instance-manipulation values in the cached IM header field.\n      \
    \   Note: This rule allows for extending the set of instance-\n         manipulations\
    \ without causing deployed cache implementations to\n         commit errors. \
    \ The specification of new instance-manipulations\n         may include additional\
    \ caching rules to improve cache-hit rates\n         in cognizant implementations.\n\
    \      4. If any of the instance-manipulation values in the cached IM\n      \
    \   header field is a delta-coding, and the cache entry includes a\n         Delta-Base\
    \ header field, and that Delta-Base entity tag is not\n         one of the entity\
    \ tags listed in an If-None-Match header field\n         of the subsequent request.\n\
    \      5. If any of the instance-manipulation values in the cached IM\n      \
    \   header field is a delta-coding, the cache entry does not\n         include\
    \ a Delta-Base header field, and the If-None-Match header\n         field of the\
    \ request that led to that cache entry does not\n         match the If-None-Match\
    \ header field of the subsequent request.\n   If the IM header field of the cached\
    \ response includes the \"range\"\n   instance-manipulation, then a status-226\
    \ cache entry MUST NOT be used\n   in response to a subsequent request if the\
    \ cached response is\n   inconsistent with the Range header field value(s) in\
    \ the request, as\n   would be the case for a cached 206 (Partial Content) response.\n\
    \      Note: we know of no existing, published formal specification for\n    \
    \  deciding if a cached status-206 response is consistent with a\n      subsequent\
    \ request.  We believe that either of these conditions is\n      sufficient:\n\
    \         1. The ranges specified in the headers of the request that led\n   \
    \         to the cached response are the same as specified in the\n          \
    \  headers of the subsequent request.\n         2. The ranges specified in the\
    \ cached response are the same as\n            specified in the headers of the\
    \ subsequent request.\n      Further analysis might be necessary.\n"
- title: 10.7 Rules for deltas in the presence of content-codings
  contents:
  - "10.7 Rules for deltas in the presence of content-codings\n   The use of delta\
    \ encoding with content-encoded instances adds some\n   slight complexity.  When\
    \ a client (perhaps a proxy) has received a\n   delta encoded response, either\
    \ or both of that new response and a\n   cached previous response may have non-identity\
    \ content-codings.  We\n   specify rules for the server and client, to prevent\
    \ situations where\n   the client is unable to make sense of the server's response.\n"
- title: 10.7.1 Rules for generating deltas in the presence of content-codings
  contents:
  - "10.7.1 Rules for generating deltas in the presence of content-codings\n   When\
    \ a server generates a delta-encoded response, the list of\n   content-codings\
    \ the server uses (i.e., the value of the response's\n   Content-Encoding header\
    \ field) SHOULD be a prefix of the list of\n   content-codings the server would\
    \ have used had it not generated a\n   delta encoding.\n   This requirement allows\
    \ a client receiving a delta-encoded response\n   to apply the delta to a cached\
    \ base instance without having to apply\n   any content-codings during the process\
    \ (although the client might, of\n   course, be required to decode some content-codings).\n"
- title: 10.7.2 Rules for applying deltas in the presence of content-codings
  contents:
  - "10.7.2 Rules for applying deltas in the presence of content-codings\n   When\
    \ a client receives a delta response with one or more non-identity\n   content\
    \ codings:\n      1. If both the new (delta) response and the cached response\n\
    \         (instance) have exactly the same set of content-codings, the\n     \
    \    client applies the delta response to the cached response\n         without\
    \ removing the content-codings from either response.\n      2. If the new (delta)\
    \ response and the cached response have a\n         different set of content-codings,\
    \ before applying the delta the\n         client decodes one or more content-codings\
    \ from the cached\n         response, until the result has the same set of content-codings\n\
    \         as the delta response.\n      3. If a proxy or cache is forwarding the\
    \ result of applying the\n         delta response to a cached base instance response,\
    \ or later\n         forwards this result from a cache entry, the forwarded response\n\
    \         MUST carry the same Content-Encoding header field as the new\n     \
    \    (delta) response (and so it must be content-encoded as\n         indicated\
    \ by that header field).\n   The intent of these rules (and in particular, rule\
    \ #3) is that the\n   results are always consistent with the rule that the entity\
    \ tag is\n   associated with the result of the content-coding, and that any\n\
    \   recipient after the application of the delta-coding receives exactly\n   the\
    \ same response it would have received as a status-200 response\n   from the origin\
    \ server (without any delta-coding).\n"
- title: 10.7.3 Examples for using A-IM, IM, and content-codings
  contents:
  - "10.7.3 Examples for using A-IM, IM, and content-codings\n   Suppose a client,\
    \ with an empty cache, sends this request:\n      GET /foo.html HTTP/1.1\n   \
    \   Host: example.com\n      Accept-encoding: gzip\n   and the origin server responds\
    \ with:\n      HTTP/1.1 200 OK\n      Date: Wed, 24 Dec 1997 14:00:00 GMT\n  \
    \    Etag: \"abc\"\n      Content-encoding: gzip\n   We will use the notation\
    \ URI;entity-tag to denote specific instances,\n   so this response would cause\
    \ the client to store in its cache the\n   entity GZIP(foo.html;\"abc\").\n  \
    \ Then suppose that the client, a minute later, issues this conditional\n   request:\n\
    \      GET /foo.html HTTP/1.1\n      Host: example.com\n      If-none-match: \"\
    abc\"\n      Accept-encoding: gzip\n      A-IM: vcdiff\n   If the server is able\
    \ to generate a delta-encoded response, it might\n   choose one of two alternatives.\
    \  The first is to compute the delta\n   from the compressed instances (although\
    \ this might not yield the most\n   efficient coding):\n      HTTP/1.1 226 IM\
    \ Used\n      Date: Wed, 24 Dec 1997 14:01:00 GMT\n      Etag: \"def\"\n     \
    \ Delta-base: \"abc\"\n      Content-encoding: gzip\n      IM: vcdiff\n   The\
    \ body of this response would be the result of\n   VCDIFF_DELTA(GZIP(foo.html;\"\
    abc\"), GZIP(foo.html;\"def\")).  The client\n   would store as a new cache entry\
    \ the entity GZIP(foo.html;\"def\"),\n   after recovering that entity by applying\
    \ the delta to its previous\n   cache entry.\n   The server's other alternative\
    \ would be to compute the delta from the\n   uncompressed values, returning:\n\
    \      HTTP/1.1 226 IM Used\n      Date: Wed, 24 Dec 1997 14:01:00 GMT\n     \
    \ Delta-base: \"abc\"\n      Etag: \"ghi\"\n      IM: vcdiff\n   The body of this\
    \ response would be the result of\n   VCDIFF_DELTA(GUNZIP(GZIP(foo.html;\"abc\"\
    )), foo.html;\"ghi\"), or more\n   simply VCDIFF_DELTA(foo.html;\"abc\", foo.html;\"\
    ghi\").  The client\n   would store as a new cache entry the entity foo.html;\"\
    ghi\" (i.e.,\n   without any content-coding), after recovering that entity by\
    \ applying\n   the delta to its previous cache entry.\n   Note that the new value\
    \ of foo.html (at 14:01:00 GMT) without the\n   gzip content-coding must have\
    \ a different entity tag from the\n   compressed instance of the same underlying\
    \ file.\n   The client's second request might have been:\n       GET /foo.html\
    \ HTTP/1.1\n       Host: example.com\n       If-none-match: \"abc\"\n       Accept-encoding:\
    \ gzip\n       A-IM: diffe, gzip\n   The client lists gzip in both the Accept-Encoding\
    \ and A-IM headers,\n   because if the server does not support delta encoding,\
    \ the client\n   would at least like to achieve the benefits of compression (as\
    \ a\n   content-coding).  However, if the server does support the diffe\n   delta-coding,\
    \ the client would like the result to be compressed, and\n   this must be done\
    \ as an instance-manipulation.\n   A server that does support diffe might reply:\n\
    \      HTTP/1.1 226 IM Used\n      Date: Wed, 24 Dec 1997 14:01:00 GMT\n     \
    \ Delta-base: \"abc\"\n      Etag: \"ghi\"\n      IM: diffe, gzip\n   The body\
    \ of this response would be the result of\n   GZIP(DIFFE_DELTA(GUNZIP(GZIP(foo.html;\"\
    abc\")), foo.html;\"ghi\")), or\n   more simply GZIP(DIFFE_DELTA(foo.html;\"abc\"\
    , foo.html;\"ghi\")).\n   Because the gzip compression is, in this case, an instance-\n\
    \   manipulation and not a content-coding, it is not retained when the\n   reassembled\
    \ response is stored or forwarded, so the client would\n   store as a new cache\
    \ entry the entity foo.html;\"ghi\" (without any\n   content-coding or compression).\n"
- title: 10.8 New Cache-Control directives
  contents:
  - "10.8 New Cache-Control directives\n   We define two new cache-directives (see\
    \ section 14.9 of RFC 2616 [10]\n   for the specification of cache-directive).\n"
- title: 10.8.1 Retain directive
  contents:
  - "10.8.1 Retain directive\n   The set of cache-response-directive values is augmented\
    \ to include\n   the retain directive.\n      cache-response-directive = ...\n\
    \              | \"retain\" [ \"=\" delta-seconds ]\n   A retain directive is\
    \ always a \"hint\" from a server to a client; it\n   never specifies a mandatory\
    \ action for the recipient.\n   The presence of a retain directive indicates that\
    \ a delta-capable\n   client ought to retain the instance in the response in its\
    \ cache,\n   space permitting, and ought to use the corresponding entity tag in\
    \ a\n   future request for a delta-encoded response.  I.e., the server is\n  \
    \ likely to provide delta-encoded responses using the corresponding\n   instance\
    \ as a base instance.  By implication, if a client has\n   retrieved and cached\
    \ several instances of a resource, some of which\n   are marked with \"retain\"\
    \ and some not, then there is no point in\n   caching the instances not marked\
    \ with \"retain\".\n   If the retain directive includes a delta-seconds value,\
    \ then the\n   server is likely to stop using the corresponding instance as a\
    \ base\n   instance after the specified number of seconds.  A client ought not\n\
    \   use the corresponding entity tag in a future request for a delta-\n   encoded\
    \ response after that interval ends.  The interval is measured\n   from the time\
    \ that the response is generated, so a client ought to\n   include the response's\
    \ Age in its calculations.\n   If the retain directive includes a delta-seconds\
    \ value of zero, a\n   client SHOULD NOT use the corresponding entity tag in a\
    \ future\n   request for a delta-encoded response.\n      Note: We recommend that\
    \ server implementors consider the bandwidth\n      implications of sending the\
    \ \"retain=0\" directive to clients or\n      proxies that might not have the\
    \ ability to make use of it.\n"
- title: 10.8.2 IM directive
  contents:
  - "10.8.2 IM directive\n   The set of cache-response-directive values is augmented\
    \ to include\n   the im directive.\n      cache-response-directive = ...\n   \
    \           | \"im\"\n   A cache that complies with the specification for the\
    \ IM header, the\n   A-IM header, and the 226 response-status code SHOULD ignore\
    \ a no-\n   store cache-directive if an im directive is present in the same\n\
    \   response.  All other implementations MUST ignore the im directive\n   (i.e.,\
    \ MUST observe a no-store directive, if present).\n"
- title: 10.9 Use of compression with delta encoding
  contents:
  - "10.9 Use of compression with delta encoding\n   The application of data compression\
    \ to the diffe and gdiff delta\n   codings has been shown to greatly reduce the\
    \ size of the resulting\n   message bodies, in many cases.  (The vcdiff coding,\
    \ on the other\n   hand, is inherently compressed and does not benefit from further\n\
    \   compression.)  Therefore, it is strongly recommended that\n   implementations\
    \ that support the diffe and/or gdiff delta codings\n   also support the gzip\
    \ and/or deflate compression codings.  (The\n   deflate coding provides a more\
    \ compact result.)  However, this is not\n   a requirement for the use of delta\
    \ encoding, primarily because the\n   CPU-time costs associated with compression\
    \ and decompression may be\n   excessive in some environments.\n   A client that\
    \ supports both delta encoding and compression as\n   instance-manipulations signals\
    \ this by, for example\n      A-IM: diffe, deflate\n   The ordering rule stated\
    \ in section 10.5.3 requires, if the server\n   uses both instance-manipulations\
    \ in the response, that compression be\n   applied to the result of the delta\
    \ encoding, rather than vice versa.\n   I.e., the response in this case would\
    \ include\n      IM: diffe, deflate\n   Note that a client might accept compression\
    \ either as a content-\n   coding or as an instance-manipulation.  For example:\n\
    \      Accept-Encoding: gzip\n      A-IM: gzip, gdiff\n   In this example, the\
    \ server may apply the gzip compression, either as\n   a content-coding or as\
    \ an instance-manipulation, before delta\n   encoding.  Remember that the entity\
    \ tag is assigned after content-\n   coding but before instance-manipulation,\
    \ so this choice does affect\n   the semantics of delta encoding.\n"
- title: 10.10 Delta encoding and multipart/byteranges
  contents:
  - "10.10 Delta encoding and multipart/byteranges\n   A client may request multiple,\
    \ non-contiguous byte ranges in a single\n   request.  The server's response uses\
    \ the \"multipart/byteranges\" media\n   type (section 19.2 of [10]) to convey\
    \ multiple ranges in a response.\n   If a multipart/byteranges response is delta\
    \ encoded (i.e, uses a\n   delta-coding as an instance-manipulation), the delta-related\
    \ headers\n   are associated with the entire response, not with the individual\n\
    \   parts.  (This is because there is only one base instance and one\n   current\
    \ instance involved.)  A delta-encoded response with multiple\n   ranges MUST\
    \ use the same delta-coding for all of the ranges.\n   If a server chooses to\
    \ use a delta encoding for a\n   multipart/byteranges response, it MUST generate\
    \ a response in\n   accordance with the following rules.\n   When a multipart/byteranges\
    \ response uses a delta-coding prior to a\n   range selection, the A-IM and IM\
    \ header fields list the delta-coding\n   before the \"range\" literal.  (Recall\
    \ that this is the approach taken\n   to obtain a partial response after a premature\
    \ termination of a\n   message transmission.)  The server firsts generates a sequence\
    \ of\n   bytes representing the difference (delta) between the base instance\n\
    \   and the current instance, then selects the specified ranges of bytes,\n  \
    \ and transmits each such range in a part of the multipart/byteranges\n   media\
    \ type.\n   When a multipart/byteranges response uses a delta-coding after a\n\
    \   range selection, the A-IM and IM header fields list the delta-coding\n   after\
    \ the \"range\" literal.  (Recall that this is the approach taken\n   to obtain\
    \ an updated version just of selected sections of an\n   instance.)  The server\
    \ first selects the specified ranges from the\n   current instance, and also selects\
    \ the same specified ranges from the\n   base instance.  (Some of these selected\
    \ ranges might be the empty\n   sequence, if the instance is not long enough.)\
    \  The server then\n   generates the individual differences (deltas) between the\
    \ pairs of\n   ranges, and transmits each such difference in a part of the\n \
    \  multipart/byteranges media type.\n"
- title: 11 Quantifying the protocol overhead
  contents:
  - "11 Quantifying the protocol overhead\n   The proposed protocol changes increase\
    \ the size of the HTTP message\n   headers slightly.  In the simplest case, a\
    \ conditional request (i.e.,\n   one for a URI for which the client already has\
    \ a cache entry) would\n   include one more header, e.g.:\n      A-IM:vcdiff\n\
    \   This is about 13 extra bytes.  A recent study [23] reports mean\n   request\
    \ sizes from two different traces of 281 and 306 bytes, so the\n   net increase\
    \ in request size would be between 4% and 5%.\n   Because a client must have an\
    \ existing cache entry to use as a base\n   for a delta-encoded response, it would\
    \ never send \"A-IM: vcdiff\" (or\n   listing other delta encoding formats) for\
    \ its unconditional requests.\n   The same study showed that at least 46% of the\
    \ requests in lengthy\n   traces were for URLs not seen previously in the trace;\
    \ this means\n   that no more than about half of typical client requests could\
    \ be\n   conditional (and the actual fraction is likely to be smaller, given\n\
    \   the finite size of real caches).\n   The study also showed that 64% of the\
    \ responses in a lengthy trace\n   were for image content-types (GIF and JPEG).\
    \  As noted in section 6,\n   we do not currently know of a delta-encoding format\
    \ suitable for such\n   image types.  Unless a client did support such a delta-encoding\n\
    \   format, it would presumably not ask for a delta when making a\n   conditional\
    \ request for image content-types.\n   Taken together, these factors suggest that\
    \ the mean increase in\n   request header size would be much less than 5%, and\
    \ probably below\n   1%.\n   Delta-encoded responses carry slightly longer headers.\
    \  In the\n   simplest case, a response carries one more header, e.g.:\n     \
    \ IM:vcdiff\n   This is about 11 bytes.  Other headers (such as \"Delta-Base\"\
    ) might\n   also be included.  However, none of these extra headers would be\n\
    \   included except in cases where a delta encoding is actually employed,\n  \
    \ and the sender of the response can avoid sending a delta encoding if\n   this\
    \ results in a net increase in response size.  Thus, a delta-\n   encoded response\
    \ should never be larger than a regular response for\n   the same request.\n \
    \  Simulations suggest that, when delta encoding pays off at all, it\n   saves\
    \ several thousand bytes [23].  Thus, adding a few dozen bytes to\n   the response\
    \ headers should almost never obviate the savings in the\n   message-body size.\n\
    \   Finally, the use of the \"retain\" Cache-Control directive might cause\n \
    \  some additional overhead.  Some server heuristics might be successful\n   in\
    \ limiting the use of these headers to situations where they would\n   probably\
    \ optimize future responses.  Neither of these headers is\n   necessary for the\
    \ simpler uses of delta encoding.\n"
- title: 12 Security Considerations
  contents:
  - "12 Security Considerations\n   We are not aware of any aspects of the basic delta\
    \ encoding mechanism\n   that affect the existing security considerations for\
    \ the HTTP/1.1\n   protocol.\n"
- title: 13 Acknowledgements
  contents:
  - "13 Acknowledgements\n   Phong Vo has provided a great deal of guidance in the\
    \ choice of delta\n   encoding algorithms and formats.  Issac Goldstand and Mike\
    \ Dahlin\n   provided a number of useful comments on the specification.  Dave\n\
    \   Kristol suggested many textual corrections.\n"
- title: 14 Intellectual Property Rights
  contents:
  - "14 Intellectual Property Rights\n   The IETF has been notified of intellectual\
    \ property rights claimed in\n   regard to some or all of the specification contained\
    \ in this\n   document.  For more information consult the online list of claimed\n\
    \   rights, at <http://www.ietf.org/ipr.html>.\n   The IETF takes no position\
    \ regarding the validity or scope of any\n   intellectual property or other rights\
    \ that might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP 11.  Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n"
- title: 15 References
  contents:
  - "15 References\n   1.  Gaurav Banga, Fred Douglis, and Michael Rabinovich.  Optimistic\n\
    \       Deltas for WWW Latency Reduction.  Proc. 1997 USENIX Technical\n     \
    \  Conference, Anaheim, CA, January, 1997, pp. 289-303.\n   2.  Berners-Lee, T.,\
    \ Fielding, R. and H. Frystyk, \"Hypertext Transfer\n       Protocol -- HTTP/1.0\"\
    , RFC 1945, May 1996.\n   3.  Bradner, S., \"Key words for use in RFCs to Indicate\
    \ Requirement\n       Levels\", BCP 14, RFC 2119, March 1997.\n   4.  Edith Cohen,\
    \ Balachander Krishnamurthy, and Jennifer Rexford.\n       Improving End-to-End\
    \ Performance of the Web Using Server Volumes\n       and Proxy Filters.  Proc.\
    \ SIGCOMM '98, September, 1998, pp. 241-\n       253.\n   5.  Deutsch, P., \"\
    GZIP file format specification version 4.3\", RFC\n       1952, May 1996.\n  \
    \ 6.  Deutsch, P., \"DEFLATE Compressed Data Format Specification\n       version\
    \ 1.3\", RFC 1951, May 1996.\n   7.  Deutsch, P. and J-L. Gailly, \"ZLIB Compressed\
    \ Data Format\n       Specification version 3.3\", RFC 1950, May 1996.\n   8.\
    \  Fred Douglis, Anja Feldmann, Balachander Krishnamurthy, and\n       Jeffrey\
    \ Mogul.  Rate of Change and Other Metrics:  a Live Study\n       of the World\
    \ Wide Web.  Proc. Symposium on Internet Technologies\n       and Systems, USENIX,\
    \ Monterey, CA, December, 1997, pp. 147-158.\n   9.  Fielding, R., Gettys, J.,\
    \ Mogul, J., Nielsen, H. and T. Berners-\n       Lee, \"Hypertext Transfer Protocol\
    \ -- HTTP/1.1\", RFC 2068, January\n       1997.\n   10. Fielding, R., Gettys,\
    \ J., Mogul, J., Nielsen, H., Masinter, L.,\n       Leach, P. and T. Berners-Lee,\
    \ \"Hypertext Transfer Protocol --\n       HTTP/1.1\", RFC 2616, June 1999.\n\
    \   11. Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P., Luotonen,\n  \
    \     A., Luotonen, L. and L. Stewart, \"HTTP Authentication:  Basic and\n   \
    \    Digest Access Authnetication\", RFC 2617, June 1999.\n   12. Freed, N. and\
    \ N. Borenstein, \"Multipurpose Internet Mail\n       Extensions (MIME) Part One:\
    \  Format of Internet Message Bodies\",\n       RFC 2045, November 1996.\n   13.\
    \ Arthur van Hoff, John Giannandrea, Mark Hapner, Steve Carter, and\n       Milo\
    \ Medin.  The HTTP Distribution and Replication Protocol.\n       Technical Report\
    \ NOTE-DRP, World Wide Web Consortium, August,\n       1997.\n   14. Arthur van\
    \ Hoff and Jonathan Payne.  Generic Diff Format\n       Specification.  Technical\
    \ Report NOTE-GDIFF, World Wide Web\n       Consortium, August, 1997.\n   15.\
    \ Barron C. Housel and David B. Lindquist.  WebExpress: A System\n       for Optimizing\
    \ Web Browsing in a Wireless Environment.  Proc. 2nd\n       Annual Intl. Conf.\
    \ on Mobile Computing and Networking, ACM, Rye,\n       New York, November, 1996,\
    \ pp. 108-116.\n   16. James J. Hunt, Kiem-Phong Vo, and Walter F. Tichy.  An\
    \ Empirical\n       Study of Delta Algorithms.  IEEE Soft. Config. and Maint.\n\
    \       Workshop, 1996.\n   17. Jacobson, V., \"Compressing TCP/IP Headers for\
    \ Low-Speed Serial\n       Links\", RFC 1144, February 1990.\n   18. Khare, R.\
    \ and S. Lawrence, \"Upgrading to TLS Within HTTP/1.1\",\n       RFC 2817, May\
    \ 2000.\n   19. David G. Korn and Kiem-Phong Vo.  A Generic Differencing and\n\
    \       Compression Data Format.  Technical Report HA1630000-021899-02TM,\n  \
    \     AT&T Labs - Research, February, 1999.\n   20. Korn, D. and K. Vo, \"The\
    \ VCDIFF Generic Differencing and\n       Compression Data Format\", Work in Progress.\n\
    \   21. Merriam-Webster.   Webster's Seventh New Collegiate Dictionary.\n    \
    \   G. & C. Merriam Co., Springfield, MA, 1963.\n   22. Jeffrey C. Mogul.  Hinted\
    \ caching in the Web.  Proc. Seventh ACM\n       SIGOPS European Workshop, Connemara,\
    \ Ireland, September, 1996,\n       pp.  103-108.\n   23. Jeffrey C. Mogul, Fred\
    \ Douglis, Anja Feldmann, and Balachander\n       Krishnamurthy.  Potential benefits\
    \ of delta encoding and data\n       compression for HTTP.  Research Report 97/4,\
    \ DECWRL, July, 1997.\n   24. Mogul, J. and A. Van Hoff, \"Instance Digests in\
    \ HTTP\", RFC 3230,\n       January 2002.\n   25. Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing an IANA\n       Considerations Section in RFCs\", BCP\
    \ 26, RFC 2434, October 1998.\n   26. The Open Group.  The Single UNIX Specification,\
    \ Version 2 - 6 Vol\n       Set for UNIX 98.  Document number T912, The Open Group,\
    \ February,\n       1997.\n   27. W. Tichy.  \"RCS - A System For Version Control\"\
    .  Software -\n       Practice and Experience 15, 7 (July 1985), 637-654.\n  \
    \ 28. Andrew Tridgell and Paul Mackerras.  The rsync algorithm.\n       Technical\
    \ Report TR-CS-96-05, Department of Computer Science,\n       Australian National\
    \ University, June, 1996.\n   29. Stephen Williams.  Personal communication.\n\
    \       http://ei.cs.vt.edu/~williams/DIFF/prelim.html.\n   30. Stephen Williams,\
    \ Marc Abrams, Charles R. Standridge, Ghaleb\n       Abdulla, and Edward A. Fox.\
    \  Removal Policies in Network Caches\n       for World-Wide Web Documents.  Proc.\
    \ SIGCOMM '96, Stanford, CA,\n       August, 1996, pp. 293-305.\n"
- title: 16 Authors' addresses
  contents:
  - "16 Authors' addresses\n   Jeffrey C. Mogul\n   Western Research Laboratory\n\
    \   Compaq Computer Corporation\n   250 University Avenue\n   Palo Alto, California,\
    \ 94305, U.S.A.\n   Phone: 1 650 617 3304 (email preferred)\n   EMail: JeffMogul@acm.org\n\
    \   Balachander Krishnamurthy\n   AT&T Labs - Research\n   180 Park Ave, Room\
    \ D-229\n   Florham Park, NJ 07932-0971, U.S.A.\n   EMail: bala@research.att.com\n\
    \   Fred Douglis\n   AT&T Labs - Research\n   180 Park Ave, Room B-137\n   Florham\
    \ Park, NJ 07932-0971, U.S.A.\n   Phone: 1 973 360-8775\n   EMail: douglis@research.att.com\n\
    \   Anja Feldmann\n   University of Saarbruecken, Germany,\n   Computer Science\
    \ Department\n   Im Stadtwald, Geb. 36.1, Zimmer 310\n   D-66123 Saarbruecken,\
    \ Germany\n   EMail: anja@cs.uni-sb.de\n   Yaron Y. Goland\n   Email: yaron@goland.org\n\
    \   Arthur van Hoff\n   Marimba, Inc.\n   440 Clyde Avenue\n   Mountain View,\
    \ CA 94043, U.S.A.\n   Phone: 1 650 930 5283\n   EMail: avh@marimba.com\n   Daniel\
    \ M. Hellerstein\n   Economic Research Service, USDA\n   1909 Franwall Ave, Wheaton\
    \ MD 20902\n   Phone: 1 202 694-5613 or 1 301 649-4728\n   EMail: danielh@crosslink.net\
    \ or webmaster@srehttp.org\n"
- title: 17 Full Copyright Statement
  contents:
  - "17 Full Copyright Statement\n   Copyright (C) The Internet Society (2002).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
