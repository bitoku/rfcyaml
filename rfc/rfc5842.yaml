- title: __initial_text__
  contents:
  - "                         Binding Extensions to\n           Web Distributed Authoring\
    \ and Versioning (WebDAV)\n"
- title: Abstract
  contents:
  - "Abstract\n   This specification defines bindings, and the BIND method for creating\n\
    \   multiple bindings to the same resource.  Creating a new binding to a\n   resource\
    \ causes at least one new URI to be mapped to that resource.\n   Servers are required\
    \ to ensure the integrity of any bindings that\n   they allow to be created.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5842.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Terminology ................................................5\n  \
    \    1.2. Method Preconditions and Postconditions ....................6\n   2.\
    \ Overview of Bindings ............................................7\n      2.1.\
    \ Bindings to Collections ....................................7\n           2.1.1.\
    \ Bind Loops ..........................................8\n      2.2. URI Mappings\
    \ Created by a New Binding ......................8\n      2.3. COPY and Bindings\
    \ ..........................................9\n           2.3.1. Example: COPY\
    \ with \"Depth: infinity\" in\n                  Presence of Bind Loops .............................11\n\
    \           2.3.2. Example: COPY Updating Multiple Bindings ...........13\n  \
    \         2.3.3. Example: COPY with \"Depth: infinity\" with\n               \
    \   Multiple Bindings to a Leaf Resource ...............14\n      2.4. DELETE\
    \ and Bindings .......................................15\n      2.5. MOVE and\
    \ Bindings .........................................15\n           2.5.1. Example:\
    \ Simple MOVE ...............................16\n           2.5.2. Example: MOVE\
    \ Request Causing a Bind Loop ..........16\n      2.6. PROPFIND and Bindings .....................................18\n\
    \      2.7. Determining Whether Two Bindings Are to the Same\n           Resource\
    \ ..................................................18\n      2.8. Discovering\
    \ the Bindings to a Resource ....................19\n   3. Properties .....................................................19\n\
    \      3.1. DAV:resource-id Property ..................................20\n  \
    \    3.2. DAV:parent-set Property ...................................20\n    \
    \       3.2.1. Example for DAV:parent-set Property ................20\n   4. BIND\
    \ Method ....................................................21\n      4.1. Example:\
    \ BIND .............................................24\n   5. UNBIND Method ..................................................24\n\
    \      5.1. Example: UNBIND ...........................................26\n  \
    \ 6. REBIND Method ..................................................26\n    \
    \  6.1. Example: REBIND ...........................................28\n      6.2.\
    \ Example: REBIND in Presence of Locks and Bind Loops .......29\n   7. Additional\
    \ Status Codes ........................................31\n      7.1. 208 Already\
    \ Reported ......................................31\n           7.1.1. Example:\
    \ PROPFIND by Bind-Aware Client .............32\n           7.1.2. Example: PROPFIND\
    \ by Non-Bind-Aware Client .........34\n      7.2. 508 Loop Detected .........................................34\n\
    \   8. Capability Discovery ...........................................34\n  \
    \    8.1. OPTIONS Method ............................................34\n    \
    \  8.2. 'DAV' Request Header ......................................34\n   9. Relationship\
    \ to Locking in WebDAV ..............................35\n      9.1. Example: Locking\
    \ and Multiple Bindings ....................36\n   10. Relationship to WebDAV\
    \ Access Control Protocol ................37\n   11. Relationship to Versioning\
    \ Extensions to WebDAV ...............37\n   12. Security Considerations .......................................40\n\
    \      12.1. Privacy Concerns .........................................40\n  \
    \    12.2. Bind Loops ...............................................40\n    \
    \  12.3. Bindings and Denial of Service ...........................40\n      12.4.\
    \ Private Locations May Be Revealed ........................40\n      12.5. DAV:parent-set\
    \ and Denial of Service .....................41\n   13. Internationalization Considerations\
    \ ...........................41\n   14. IANA Considerations ...........................................41\n\
    \   15. Acknowledgements ..............................................41\n  \
    \ 16. References ....................................................41\n    \
    \  16.1. Normative References .....................................41\n      16.2.\
    \ Informative References ...................................42\n   Index .............................................................42\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This specification extends the WebDAV Distributed Authoring\
    \ Protocol\n   ([RFC4918]) to enable clients to create new access paths to existing\n\
    \   resources.  This capability is useful for several reasons:\n   URIs of WebDAV-compliant\
    \ resources are hierarchical and correspond to\n   a hierarchy of collections\
    \ in resource space.  The WebDAV Distributed\n   Authoring Protocol makes it possible\
    \ to organize these resources into\n   hierarchies, placing them into groupings,\
    \ known as collections, which\n   are more easily browsed and manipulated than\
    \ a single flat\n   collection.  However, hierarchies require categorization decisions\n\
    \   that locate resources at a single location in the hierarchy, a\n   drawback\
    \ when a resource has multiple valid categories.  For example,\n   in a hierarchy\
    \ of vehicle descriptions containing collections for\n   cars and boats, a description\
    \ of a combination car/boat vehicle could\n   belong in either collection.  Ideally,\
    \ the description should be\n   accessible from both.  Allowing clients to create\
    \ new URIs that\n   access the existing resource lets them put that resource into\n\
    \   multiple collections.\n   Hierarchies also make resource sharing more difficult,\
    \ since\n   resources that have utility across many collections are still forced\n\
    \   into a single collection.  For example, the mathematics department at\n  \
    \ one university might create a collection of information on fractals\n   that\
    \ contains bindings to some local resources but also provides\n   access to some\
    \ resources at other universities.  For many reasons, it\n   may be undesirable\
    \ to make physical copies of the shared resources on\n   the local server, for\
    \ example, to conserve disk space, to respect\n   copyright constraints, or to\
    \ make any changes in the shared resources\n   visible automatically.  Being able\
    \ to create new access paths to\n   existing resources in other collections or\
    \ even on other servers is\n   useful for this sort of case.\n   The BIND method,\
    \ defined here, provides a mechanism for allowing\n   clients to create alternative\
    \ access paths to existing WebDAV\n   resources.  HTTP [RFC2616] and WebDAV [RFC4918]\
    \ methods are able to\n   work because there are mappings between URIs and resources.\
    \  A method\n   is addressed to a URI, and the server follows the mapping from\
    \ that\n   URI to a resource, applying the method to that resource.  Multiple\n\
    \   URIs may be mapped to the same resource, but until now, there has\n   been\
    \ no way for clients to create additional URIs mapped to existing\n   resources.\n\
    \   BIND lets clients associate a new URI with an existing WebDAV\n   resource,\
    \ and this URI can then be used to submit requests to the\n   resource.  Since\
    \ URIs of WebDAV resources are hierarchical, and\n   correspond to a hierarchy\
    \ of collections in resource space, the BIND\n   method also has the effect of\
    \ adding the resource to a collection.\n   As new URIs are associated with the\
    \ resource, it appears in\n   additional collections.\n   A BIND request does\
    \ not create a new resource, but simply makes a new\n   URI for submitting requests\
    \ to an existing resource available.  The\n   new URI is indistinguishable from\
    \ any other URI when submitting a\n   request to a resource.  Only one round trip\
    \ is needed to submit a\n   request to the intended target.  Servers are required\
    \ to enforce the\n   integrity of the relationships between the new URIs and the\
    \ resources\n   associated with them.  Consequently, it may be very costly for\n\
    \   servers to support BIND requests that cross server boundaries.\n   This specification\
    \ is organized as follows.  Section 1.1 defines\n   terminology used in the rest\
    \ of the specification, while Section 2\n   overviews bindings.  Section 3 defines\
    \ the new properties needed to\n   support multiple bindings to the same resource.\
    \  Section 4 specifies\n   the BIND method, used to create multiple bindings to\
    \ the same\n   resource.  Section 5 specifies the UNBIND method, used to remove\
    \ a\n   binding to a resource.  Section 6 specifies the REBIND method, used\n\
    \   to move a binding to another collection.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   The terminology used here follows and extends that in the\
    \ WebDAV\n   Distributed Authoring Protocol specification [RFC4918].\n   The key\
    \ words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"\
    SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n\
    \   document are to be interpreted as described in [RFC2119].\n   This document\
    \ uses XML DTD fragments ([XML]) as a notational\n   convention, using the rules\
    \ defined in Section 17 of [RFC4918].\n   URI Mapping\n      A relation between\
    \ an absolute URI and a resource.  For an\n      absolute URI U and the resource\
    \ it identifies R, the URI mapping\n      can be thought of as (U => R).  Since\
    \ a resource can represent\n      items that are not network retrievable as well\
    \ as those that are,\n      it is possible for a resource to have zero, one, or\
    \ many URI\n      mappings.  Mapping a resource to an \"http\"-scheme URI makes\
    \ it\n      possible to submit HTTP requests to the resource using the URI.\n\
    \   Path Segment\n      Informally, the characters found between slashes (\"/\"\
    ) in a URI.\n      Formally, as defined in Section 3.3 of [RFC3986].\n   Binding\n\
    \      A relation between a single path segment (in a collection) and a\n    \
    \  resource.  A binding is part of the state of a collection.  If two\n      different\
    \ collections contain a binding between the same path\n      segment and the same\
    \ resource, these are two distinct bindings.\n      So for a collection C, a path\
    \ segment S, and a resource R, the\n      binding can be thought of as C:(S ->\
    \ R).  Bindings create URI\n      mappings, and hence allow requests to be sent\
    \ to a single resource\n      from multiple locations in a URI namespace.  For\
    \ example, given a\n      collection C (accessible through the URI\n      http://www.example.com/CollX),\
    \ a path segment S (equal to\n      \"foo.html\"), and a resource R, then creating\
    \ the binding C: (S ->\n      R) makes it possible to use the URI\n      http://www.example.com/CollX/foo.html\
    \ to access R.\n   Collection\n      A resource that contains, as part of its\
    \ state, a set of bindings\n      that identify internal member resources.\n \
    \  Internal Member URI\n      The URI that identifies an internal member of a\
    \ collection and\n      that consists of the URI for the collection, followed\
    \ by a slash\n      character ('/'), followed by the path segment of the binding\
    \ for\n      that internal member.\n   Binding Integrity\n      The property of\
    \ a binding that says that:\n      *  the binding continues to exist, and\n  \
    \    *  the identity of the resource identified by that binding does\n       \
    \  not change,\n      unless an explicit request is executed that is defined to\
    \ delete\n      that binding (examples of requests that delete a binding are\n\
    \      DELETE, MOVE, and -- defined later on -- UNBIND and REBIND).\n"
- title: 1.2.  Method Preconditions and Postconditions
  contents:
  - "1.2.  Method Preconditions and Postconditions\n   See Section 16 of [RFC4918]\
    \ for the definitions of \"precondition\" and\n   \"postcondition\".\n"
- title: 2.  Overview of Bindings
  contents:
  - "2.  Overview of Bindings\n   Bindings are part of the state of a collection.\
    \  They define the\n   internal members of the collection and the names of those\
    \ internal\n   members.\n   Bindings are added and removed by a variety of existing\
    \ HTTP methods.\n   A method that creates a new resource, such as PUT, COPY, and\
    \ MKCOL,\n   adds a binding.  A method that deletes a resource, such as DELETE,\n\
    \   removes a binding.  A method that moves a resource (e.g., MOVE) both\n   adds\
    \ a binding (in the destination collection) and removes a binding\n   (in the\
    \ source collection).  The BIND method introduced here provides\n   a mechanism\
    \ for adding a second binding to an existing resource.\n   There is no difference\
    \ between an initial binding added by PUT, COPY,\n   or MKCOL and additional bindings\
    \ added with BIND.\n   It would be very undesirable if one binding could be destroyed\
    \ as a\n   side effect of operating on the resource through a different binding.\n\
    \   In particular, the removal of one binding to a resource (e.g., with a\n  \
    \ DELETE or a MOVE) MUST NOT disrupt another binding to that resource,\n   e.g.,\
    \ by turning that binding into a dangling path segment.  The\n   server MUST NOT\
    \ reclaim system resources after removing one binding,\n   while other bindings\
    \ to the resource remain.  In other words, the\n   server MUST maintain the integrity\
    \ of a binding.  It is permissible,\n   however, for future method definitions\
    \ (e.g., a DESTROY method) to\n   have semantics that explicitly remove all bindings\
    \ and/or immediately\n   reclaim system resources.\n      Note: the collection\
    \ model described herein is not compatible with\n      systems in which resources\
    \ inherit properties based solely on the\n      access path, as the ability to\
    \ create additional bindings will\n      cause a single resource to appear as\
    \ member of several different\n      collections at the same time.\n"
- title: 2.1.  Bindings to Collections
  contents:
  - "2.1.  Bindings to Collections\n   Creating a new binding to a collection makes\
    \ each resource associated\n   with a binding in that collection accessible via\
    \ a new URI, and thus\n   creates new URI mappings to those resources but no new\
    \ bindings.\n   For example, suppose a new binding CollY is created for collection\
    \ C1\n   in the figure below.  It immediately becomes possible to access\n   resource\
    \ R1 using the URI /CollY/x.gif and to access resource R2\n   using the URI /CollY/y.jpg,\
    \ but no new bindings for these child\n   resources were created.  This is because\
    \ bindings are part of the\n   state of a collection, and they associate a URI\
    \ that is relative to\n   that collection with its target resource.  No change\
    \ to the bindings\n   in Collection C1 is needed to make its children accessible\
    \ using\n   /CollY/x.gif and /CollY/y.jpg.\n                     +-------------------------+\n\
    \                     | Root Collection         |\n                     |  bindings:\
    \              |\n                     |  CollX          CollY   |\n         \
    \            +-------------------------+\n                         |         \
    \   /\n                         |           /\n                         |    \
    \      /\n                     +------------------+\n                     | Collection\
    \ C1    |\n                     | bindings:        |\n                     | x.gif\
    \     y.jpg  |\n                     +------------------+\n                  \
    \       |          \\\n                         |           \\\n             \
    \            |            \\\n                     +-------------+   +-------------+\n\
    \                     | Resource R1 |   | Resource R2 |\n                    \
    \ +-------------+   +-------------+\n"
- title: 2.1.1.  Bind Loops
  contents:
  - "2.1.1.  Bind Loops\n   Bindings to collections can result in loops (\"cycles\"\
    ), which servers\n   MUST detect when processing \"Depth: infinity\" requests.\
    \  It is\n   sometimes possible to complete an operation in spite of the presence\n\
    \   of a loop.  For instance, a PROPFIND can still succeed if the server\n   uses\
    \ the new status code 208 (Already Reported) defined in\n   Section 7.1.\n   However,\
    \ the 508 (Loop Detected) status code is defined in\n   Section 7.2 for use in\
    \ contexts where an operation is terminated\n   because a loop was encountered.\n\
    \   Support for loops is OPTIONAL: servers MAY reject requests that would\n  \
    \ lead to the creation of a bind loop (see DAV:cycle-allowed\n   precondition\
    \ defined in Section 4).\n"
- title: 2.2.  URI Mappings Created by a New Binding
  contents:
  - "2.2.  URI Mappings Created by a New Binding\n   Suppose a binding from \"Binding-Name\"\
    \ to resource R is to be added to\n   a collection, C.  Then if C-MAP is the set\
    \ of URIs that were mapped\n   to C before the BIND request, then for each URI\
    \ \"C-URI\" in C-MAP, the\n   URI \"C-URI/Binding-Name\" is mapped to resource\
    \ R following the BIND\n   request.\n   For example, if a binding from \"foo.html\"\
    \ to R is added to a\n   collection C, and if the following URIs are mapped to\
    \ C:\n   http://www.example.com/A/1/\n   http://example.com/A/one/\n   then the\
    \ following new mappings to R are introduced:\n   http://www.example.com/A/1/foo.html\n\
    \   http://example.com/A/one/foo.html\n   Note that if R is a collection, additional\
    \ URI mappings are created\n   to the descendents of R.  Also, note that if a\
    \ binding is made in\n   collection C to C itself (or to a parent of C), an infinite\
    \ number of\n   mappings are introduced.\n   For example, if a binding from \"\
    myself\" to C is then added to C, the\n   following infinite number of additional\
    \ mappings to C are introduced:\n   http://www.example.com/A/1/myself\n   http://www.example.com/A/1/myself/myself\n\
    \      ...\n   and the following infinite number of additional mappings to R are\n\
    \   introduced:\n   http://www.example.com/A/1/myself/foo.html\n   http://www.example.com/A/1/myself/myself/foo.html\n\
    \      ...\n"
- title: 2.3.  COPY and Bindings
  contents:
  - "2.3.  COPY and Bindings\n   As defined in Section 9.8 of [RFC4918], COPY causes\
    \ the resource\n   identified by the Request-URI to be duplicated and makes the\
    \ new\n   resource accessible using the URI specified in the Destination\n   header.\
    \  Upon successful completion of a COPY, a new binding is\n   created between\
    \ the last path segment of the Destination header and\n   the destination resource.\
    \  The new binding is added to its parent\n   collection, identified by the Destination\
    \ header minus its final\n   segment.\n   The following figure shows an example:\
    \ suppose that a COPY is issued\n   to URI-3 for resource R (which is also mapped\
    \ to URI-1 and URI-2),\n   with the Destination header set to URI-X.  After successful\n\
    \   completion of the COPY operation, resource R is duplicated to create\n   resource\
    \ R', and a new binding has been created that creates at least\n   the URI mapping\
    \ between URI-X and the new resource (although other\n   URI mappings may also\
    \ have been created).\n     URI-1   URI-2    URI-3                           URI-X\n\
    \        |       |        |                              |\n        |       |\
    \        |   <---- URI Mappings ---->   |\n        |       |        |        \
    \                      |\n     +---------------------+                 +------------------------+\n\
    \     |     Resource R      |                 |     Resource R'        |\n   \
    \  +---------------------+                 +------------------------+\n   It might\
    \ be thought that a COPY request with \"Depth: 0\" on a\n   collection would duplicate\
    \ its bindings, since bindings are part of\n   the collection's state.  This is\
    \ not the case, however.  The\n   definition of Depth in [RFC4918] makes it clear\
    \ that a \"Depth: 0\"\n   request does not apply to a collection's members.  Consequently,\
    \ a\n   COPY with \"Depth: 0\" does not duplicate the bindings contained by the\n\
    \   collection.\n   If a COPY request causes an existing resource to be updated,\
    \ the\n   bindings to that resource MUST be unaffected by the COPY request.\n\
    \   Using the preceding example, suppose that a COPY request is issued to\n  \
    \ URI-X for resource R', with the Destination header set to URI-2.  The\n   content\
    \ and dead properties of resource R would be updated to be a\n   copy of those\
    \ of resource R', but the mappings from URI-1, URI-2, and\n   URI-3 to resource\
    \ R remain unaffected.  If, because of multiple\n   bindings to a resource, more\
    \ than one source resource updates a\n   single destination resource, the order\
    \ of the updates is server\n   defined (see Section 2.3.2 for an example).\n \
    \  If a COPY request would cause a new resource to be created as a copy\n   of\
    \ an existing resource, and that COPY request has already created a\n   copy of\
    \ that existing resource, the COPY request instead creates\n   another binding\
    \ to the previous copy, instead of creating a new\n   resource (see Section 2.3.3\
    \ for an example).\n"
- title: '2.3.1.  Example: COPY with "Depth: infinity" in Presence of Bind Loops'
  contents:
  - "2.3.1.  Example: COPY with \"Depth: infinity\" in Presence of Bind Loops\n  \
    \ As an example of how COPY with \"Depth: infinity\" would work in the\n   presence\
    \ of bindings, consider the following collection:\n                 +------------------+\n\
    \                 | Root Collection  |\n                 |  bindings:       |\n\
    \                 |  CollX           |\n                 +------------------+\n\
    \                     |\n                     |\n                 +-------------------------------+\n\
    \                 | Collection C1                 |<-------+\n               \
    \  | bindings:                     |        |\n                 | x.gif      CollY\
    \              |        |\n                 +-------------------------------+\
    \        |\n                     |            \\        (creates loop) |\n   \
    \                  |             \\                      |\n                 +-------------+\
    \   +------------------+   |\n                 | Resource R1 |   | Collection\
    \ C2    |   |\n                 +-------------+   | bindings:        |   |\n \
    \                                  | y.gif     CollZ  |   |\n                \
    \                   +------------------+   |\n                               \
    \        |         |        |\n                                       |      \
    \   +--------+\n                                       |\n                   \
    \                +-------------+\n                                   | Resource\
    \ R2 |\n                                   +-------------+\n   If a COPY request\
    \ with \"Depth: infinity\" is submitted to /CollX, with\n   a destination of /CollA,\
    \ the outcome of the copy operation is that a\n   copy of the tree is replicated\
    \ to the target /CollA:\n                +------------------+\n              \
    \  | Root Collection  |\n                |  bindings:       |\n              \
    \  |  CollX     CollA |\n                +------------------+\n              \
    \     |           |\n                   |           +---------------------------+\n\
    \                   |                                       |\n              \
    \  +-------------------+                      |\n                | Collection\
    \ C1     |<------------------+  |\n                | bindings:         |     \
    \              |  |\n                | x.gif      CollY  |                   |\
    \  |\n                +-------------------+                   |  |\n         \
    \          |            \\        (creates loop) |  |\n                   |  \
    \           \\                      |  |\n                +-------------+   +-----------------+\
    \   |  |\n                | Resource R1 |   | Collection C2   |   |  |\n     \
    \           +-------------+   | bindings:       |   |  |\n                   \
    \               | y.gif     CollZ |   |  |\n                                 \
    \ +-----------------+   |  |\n                                      |        \
    \ |       |  |\n                                      |         +-------+  |\n\
    \                                      |                    |\n              \
    \                    +-------------+          |\n                            \
    \      | Resource R2 |          |\n                                  +-------------+\
    \          |\n                                                           |\n \
    \                          +-------------------------------+\n               \
    \            |\n                +-------------------+\n                | Collection\
    \ C3     |<------------------+\n                | bindings:         |        \
    \           |\n                | x.gif      CollY  |                   |\n   \
    \             +-------------------+                   |\n                   |\
    \            \\        (creates loop) |\n                   |             \\ \
    \                     |\n                +-------------+   +-----------------+\
    \   |\n                | Resource R3 |   | Collection C4   |   |\n           \
    \     +-------------+   | bindings:       |   |\n                            \
    \      | y.gif     CollZ |   |\n                                  +-----------------+\
    \   |\n                                      |         |       |\n           \
    \                           |         +-------+\n                            \
    \          |\n                                  +-------------+\n            \
    \                      | Resource R4 |\n                                  +-------------+\n\
    \   Note that the same would apply for more complex loops.\n"
- title: '2.3.2.  Example: COPY Updating Multiple Bindings'
  contents:
  - "2.3.2.  Example: COPY Updating Multiple Bindings\n   Given the following collection\
    \ hierarchy:\n                                +------------------+\n         \
    \                       | Root Collection  |\n                               \
    \ |  bindings:       |\n                                |  CollX     CollY |\n\
    \                                +------------------+\n                      \
    \             /              \\\n                                  /         \
    \       \\\n                                 /                  \\\n         \
    \     +--------------------------+   +-----------------+\n              |    \
    \  Collection C1       |   | Collection C2   |\n              |      bindings:\
    \           |   | bindings:       |\n              |     x.gif     y.gif     \
    \ |   | x.gif     y.gif |\n              +--------------------------+   +-----------------+\n\
    \                      |         |                |         |\n              \
    \        |         |                |         |\n            +-------------+ \
    \ +-------------+   +-------------+\n            | Resource R1 |  | Resource R2\
    \ |   | Resource R3 |\n            +-------------+  +-------------+   +-------------+\n\
    \   A COPY of /CollX with \"Depth: infinity\" to /CollY will not result in\n \
    \  a changed hierarchy, and Resource R3 will be updated with the content\n   of\
    \ either Resource R1 or Resource R2.\n"
- title: '2.3.3.  Example: COPY with "Depth: infinity" with Multiple Bindings to a'
  contents:
  - "2.3.3.  Example: COPY with \"Depth: infinity\" with Multiple Bindings to a\n\
    \        Leaf Resource\n   Given the following collection hierarchy:\n       \
    \                     +------------------+\n                            | Root\
    \ Collection  |\n                            |  bindings:       |\n          \
    \                  |  CollX           |\n                            +------------------+\n\
    \                               |\n                               |\n        \
    \                       |\n                            +----------------+\n  \
    \                          | Collection C1  |\n                            | bindings:\
    \      |\n                            | x.gif    y.gif |\n                   \
    \         +----------------+\n                               |         |\n   \
    \                            |         |\n                             +-------------+\n\
    \                             | Resource R1 |\n                             +-------------+\n\
    \   A COPY of /CollX with \"Depth: infinity\" to /CollY results in the\n   following\
    \ collection hierarchy:\n                  +------------------+\n            \
    \      | Root Collection  |\n                  |  bindings:       |\n        \
    \          |  CollX     CollY |\n                  +------------------+\n    \
    \                 |              \\\n                     |               \\\n\
    \                     |                \\\n                  +----------------+\
    \  +-----------------+\n                  | Collection C1  |  | Collection C2\
    \   |\n                  | bindings:      |  | bindings:       |\n           \
    \       | x.gif    y.gif |  | x.gif     y.gif |\n                  +----------------+\
    \  +-----------------+\n                     |         |          |         |\n\
    \                     |         |          |         |\n                   +-------------+\
    \      +-------------+\n                   | Resource R1 |      | Resource R2\
    \ |\n                   +-------------+      +-------------+\n"
- title: 2.4.  DELETE and Bindings
  contents:
  - "2.4.  DELETE and Bindings\n   When there are multiple bindings to a resource,\
    \ a DELETE applied to\n   that resource MUST NOT remove any bindings to that resource\
    \ other\n   than the one identified by the Request-URI.  For example, suppose\
    \ the\n   collection identified by the URI \"/a\" has a binding named \"x\" to\
    \ a\n   resource R, and another collection identified by \"/b\" has a binding\n\
    \   named \"y\" to the same resource R.  Then, a DELETE applied to \"/a/x\"\n\
    \   removes the binding named \"x\" from \"/a\" but MUST NOT remove the\n   binding\
    \ named \"y\" from \"/b\" (i.e., after the DELETE, \"/y/b\" continues\n   to identify\
    \ the resource R).\n   When DELETE is applied to a collection, it MUST NOT modify\
    \ the\n   membership of any other collection that is not itself a member of the\n\
    \   collection being deleted.  For example, if both \"/a/.../x\" and\n   \"/b/.../y\"\
    \ identify the same collection, C, then applying DELETE to\n   \"/a\" must not\
    \ delete an internal member from C or from any other\n   collection that is a\
    \ member of C, because that would modify the\n   membership of \"/b\".\n   If\
    \ a collection supports the UNBIND method (see Section 5), a DELETE\n   of an\
    \ internal member of a collection MAY be implemented as an UNBIND\n   request.\
    \  In this case, applying DELETE to a Request-URI has the\n   effect of removing\
    \ the binding identified by the final segment of the\n   Request-URI from the\
    \ collection identified by the Request-URI minus\n   its final segment.  Although\
    \ [RFC4918] allows a DELETE to be a non-\n   atomic operation, when the DELETE\
    \ operation is implemented as an\n   UNBIND, the operation is atomic.  In particular,\
    \ a DELETE on a\n   hierarchy of resources is simply the removal of a binding\
    \ to the\n   collection identified by the Request-URI.\n"
- title: 2.5.  MOVE and Bindings
  contents:
  - "2.5.  MOVE and Bindings\n   When MOVE is applied to a resource, the other bindings\
    \ to that\n   resource MUST be unaffected; and if the resource being moved is\
    \ a\n   collection, the bindings to any members of that collection MUST be\n \
    \  unaffected.  Also, if MOVE is used with Overwrite:T to delete an\n   existing\
    \ resource, the constraints specified for DELETE apply.\n   If the destination\
    \ collection of a MOVE request supports the REBIND\n   method (see Section 6),\
    \ a MOVE of a resource into that collection MAY\n   be implemented as a REBIND\
    \ request.  Although [RFC4918] allows a MOVE\n   to be a non-atomic operation,\
    \ when the MOVE operation is implemented\n   as a REBIND, the operation is atomic.\
    \  In particular, applying a MOVE\n   to a Request-URI and a Destination URI has\
    \ the effect of removing a\n   binding to a resource (at the Request-URI) and\
    \ creating a new binding\n   to that resource (at the Destination URI).  Even\
    \ when the Request-URI\n   identifies a collection, the MOVE operation involves\
    \ only removing\n   one binding to that collection and adding another.\n"
- title: '2.5.1.  Example: Simple MOVE'
  contents:
  - "2.5.1.  Example: Simple MOVE\n   As an example, suppose that a MOVE is issued\
    \ to URI-3 for resource R\n   below (which is also mapped to URI-1 and URI-2),\
    \ with the Destination\n   header set to URI-X.  After successful completion of\
    \ the MOVE\n   operation, a new binding has been created that creates the URI\n\
    \   mapping between URI-X and resource R.  The binding corresponding to\n   the\
    \ final segment of URI-3 has been removed, which also causes the\n   URI mapping\
    \ between URI-3 and R to be removed.  If resource R were a\n   collection, old\
    \ URI-3-based mappings to members of R would have been\n   removed, and new URI-X-based\
    \ mappings to members of R would have been\n   created.\n   >> Before Request:\n\
    \                URI-1   URI-2    URI-3\n                  |       |        |\n\
    \                  |       |        |      <---- URI Mappings\n              \
    \    |       |        |\n               +---------------------+\n            \
    \   |     Resource R      |\n               +---------------------+\n   >> After\
    \ Request:\n                URI-1   URI-2    URI-X\n                  |      \
    \ |        |\n                  |       |        |      <---- URI Mappings\n \
    \                 |       |        |\n               +---------------------+\n\
    \               |     Resource R      |\n               +---------------------+\n"
- title: '2.5.2.  Example: MOVE Request Causing a Bind Loop'
  contents:
  - "2.5.2.  Example: MOVE Request Causing a Bind Loop\n   Note that in the presence\
    \ of collection bindings, a MOVE request can\n   cause the creation of a bind\
    \ loop.\n   Consider the top-level collections C1 and C2 with URIs \"/CollW/\"\
    \ and\n   \"/CollX/\".  C1 also contains an additional binding named \"CollY\"\
    \ to\n   C2:\n                                     +------------------+\n    \
    \                                 | Root Collection  |\n                     \
    \                |  bindings:       |\n                                     |\
    \  CollW    CollX  |\n                                     +------------------+\n\
    \                                         |          |\n                     \
    \                    |          |\n                            +------------------+\
    \    |\n                            | Collection C1    |    |\n              \
    \              |  bindings:       |    |\n                            |      \
    \     CollY  |    |\n                            +------------------+    |\n \
    \                                        |          |\n                      \
    \                   |          |\n                                     +------------------+\n\
    \                                     | Collection C2    |\n                 \
    \                    |                  |\n                                  \
    \   |                  |\n                                     +------------------+\n\
    \   In this case, the MOVE request below would cause a bind loop:\n   >> Request:\n\
    \   MOVE /CollW HTTP/1.1\n   Host: example.com\n   Destination: /CollX/CollZ\n\
    \   If the request succeeded, the resulting state would be:\n                \
    \                     +------------------+\n                                 \
    \    | Root Collection  |\n                                     |  bindings: \
    \      |\n                                     |           CollX  |\n        \
    \                             +------------------+\n                         \
    \                           |\n                                              \
    \      |\n                            +------------------+    |\n            \
    \                | Collection C1    |    |\n                     +----> |  bindings:\
    \       |    |\n                     |      |           CollY  |    |\n      \
    \               |      +------------------+    |\n                     |     \
    \              |          |\n                     |                   |      \
    \    |\n                     |               +------------------+\n          \
    \           |               | Collection C2    |\n                     |     \
    \          |  bindings:       |\n                     |               | CollZ\
    \            |\n                     |               +------------------+\n  \
    \                   |                   |\n                     |            \
    \       |\n                     +-------------------+\n"
- title: 2.6.  PROPFIND and Bindings
  contents:
  - "2.6.  PROPFIND and Bindings\n   Consistent with [RFC4918], the value of a dead\
    \ property MUST be\n   independent of the number of bindings to its host resource\
    \ or of the\n   path submitted to PROPFIND.  On the other hand, the behavior for\
    \ each\n   live property depends on its individual definition (for example, see\n\
    \   [RFC3744], Section 5, Paragraph 2 for a case where the value is\n   independent\
    \ of its path and bindings, and [RFC4918], Section 8.8 for\n   a discussion about\
    \ the live properties DAV:getetag and DAV:\n   getlastmodified, which may behave\
    \ differently).\n"
- title: 2.7.  Determining Whether Two Bindings Are to the Same Resource
  contents:
  - "2.7.  Determining Whether Two Bindings Are to the Same Resource\n   It is useful\
    \ to have some way of determining whether two bindings are\n   to the same resource.\
    \  Two resources might have identical contents\n   and properties, but not be\
    \ the same resource (e.g., an update to one\n   resource does not affect the other\
    \ resource).\n   The REQUIRED DAV:resource-id property defined in Section 3.1\
    \ is a\n   resource identifier, which MUST be unique across all resources for\n\
    \   all time.  If the values of DAV:resource-id returned by PROPFIND\n   requests\
    \ through two bindings are identical character by character,\n   the client can\
    \ be assured that the two bindings are to the same\n   resource.\n   The DAV:resource-id\
    \ property is created, and its value assigned, when\n   the resource is created.\
    \  The value of DAV:resource-id MUST NOT be\n   changed.  Even after the resource\
    \ is no longer accessible through any\n   URI, that value MUST NOT be reassigned\
    \ to another resource's DAV:\n   resource-id property.\n   Any method that creates\
    \ a new resource MUST assign a new, unique\n   value to its DAV:resource-id property.\
    \  For example, a PUT applied to\n   a null resource, COPY (when not overwriting\
    \ an existing target) and\n   CHECKIN (see [RFC3253], Section 4.4) must assign\
    \ a new, unique value\n   to the DAV:resource-id property of the new resource\
    \ they create.\n   On the other hand, any method that affects an existing resource\
    \ must\n   not change the value of its DAV:resource-id property.  Specifically,\n\
    \   a PUT or a COPY that updates an existing resource must not change the\n  \
    \ value of its DAV:resource-id property.  A REBIND, since it does not\n   create\
    \ a new resource, but only changes the location of an existing\n   resource, must\
    \ not change the value of the DAV:resource-id property.\n"
- title: 2.8.  Discovering the Bindings to a Resource
  contents:
  - "2.8.  Discovering the Bindings to a Resource\n   An OPTIONAL DAV:parent-set property\
    \ on a resource provides a list of\n   the bindings that associate a collection\
    \ and a URI segment with that\n   resource.  If the DAV:parent-set property exists\
    \ on a given resource,\n   it MUST contain a complete list of all bindings to\
    \ that resource that\n   the client is authorized to see.  When deciding whether\
    \ to support\n   the DAV:parent-set property, server implementers / administrators\n\
    \   should balance the benefits it provides against the cost of\n   maintaining\
    \ the property and the security risks enumerated in\n   Sections 12.4 and 12.5.\n"
- title: 3.  Properties
  contents:
  - "3.  Properties\n   The bind feature introduces the properties defined below.\n\
    \   A DAV:allprop PROPFIND request SHOULD NOT return any of the\n   properties\
    \ defined by this document.  This allows a binding server to\n   perform efficiently\
    \ when a naive client, which does not understand\n   the cost of asking a server\
    \ to compute all possible live properties,\n   issues a DAV:allprop PROPFIND request.\n"
- title: 3.1.  DAV:resource-id Property
  contents:
  - "3.1.  DAV:resource-id Property\n   The DAV:resource-id property is a REQUIRED\
    \ property that enables\n   clients to determine whether two bindings are to the\
    \ same resource.\n   The value of DAV:resource-id is a URI, and may use any registered\
    \ URI\n   scheme that guarantees the uniqueness of the value across all\n   resources\
    \ for all time (e.g., the urn:uuid: URN namespace defined in\n   [RFC4122] or\
    \ the opaquelocktoken: URI scheme defined in [RFC4918]).\n   <!ELEMENT resource-id\
    \ (href)>\n"
- title: 3.2.  DAV:parent-set Property
  contents:
  - "3.2.  DAV:parent-set Property\n   The DAV:parent-set property is an OPTIONAL\
    \ property that enables\n   clients to discover what collections contain a binding\
    \ to this\n   resource (i.e., what collections have that resource as an internal\n\
    \   member).  It contains an href/segment pair for each collection that\n   has\
    \ a binding to the resource.  The href identifies the collection,\n   and the\
    \ segment identifies the binding name of that resource in that\n   collection.\n\
    \   A given collection MUST appear only once in the DAV:parent-set for\n   any\
    \ given binding, even if there are multiple URI mappings to that\n   collection.\n\
    \   <!ELEMENT parent-set (parent)*>\n   <!ELEMENT parent (href, segment)>\n  \
    \ <!ELEMENT segment (#PCDATA)>\n   <!-- PCDATA value: segment, as defined in Section\
    \ 3.3 of\n        [RFC3986] -->\n"
- title: 3.2.1.  Example for DAV:parent-set Property
  contents:
  - "3.2.1.  Example for DAV:parent-set Property\n   For example, if collection C1\
    \ is mapped to both /CollX and /CollY,\n   and C1 contains a binding named \"\
    x.gif\" to a resource R1, then either\n   [/CollX, x.gif] or [/CollY, x.gif] can\
    \ appear in the DAV:parent-set\n   of R1, but not both.  But if C1 also had a\
    \ binding named \"y.gif\" to\n   R1, then there would be two entries for C1 in\
    \ the DAV:parent-set of\n   R1 (i.e., both [/CollX, x.gif] and [/CollX, y.gif]\
    \ or, alternatively,\n   both [/CollY, x.gif] and [/CollY, y.gif]).\n        \
    \                +-------------------------+\n                        | Root Collection\
    \         |\n                        |  bindings:              |\n           \
    \             |  CollX          CollY   |\n                        +-------------------------+\n\
    \                            |            /\n                            |   \
    \        /\n                            |          /\n                       \
    \ +-----------------+\n                        | Collection C1   |\n         \
    \               | bindings:       |\n                        | x.gif    y.gif\
    \  |\n                        +-----------------+\n                          \
    \   |      |\n                             |      |\n                        \
    \     |      |\n                         +-------------+\n                   \
    \      | Resource R1 |\n                         +-------------+\n   In this case,\
    \ one possible value for the DAV:parent-set property on\n   \"/CollX/x.gif\" would\
    \ be:\n     <parent-set xmlns=\"DAV:\">\n       <parent>\n         <href>/CollX</href>\n\
    \         <segment>x.gif</segment>\n       </parent>\n       <parent>\n      \
    \   <href>/CollX</href>\n         <segment>y.gif</segment>\n       </parent>\n\
    \     </parent-set>\n"
- title: 4.  BIND Method
  contents:
  - "4.  BIND Method\n   The BIND method modifies the collection identified by the\
    \ Request-\n   URI, by adding a new binding from the segment specified in the\
    \ BIND\n   body to the resource identified in the BIND body.\n   If a server cannot\
    \ guarantee the integrity of the binding, the BIND\n   request MUST fail.  Note\
    \ that it is especially difficult to maintain\n   the integrity of cross-server\
    \ bindings.  Unless the server where the\n   resource resides knows about all\
    \ bindings on all servers to that\n   resource, it may unwittingly destroy the\
    \ resource or make it\n   inaccessible without notifying another server that manages\
    \ a binding\n   to the resource.  For example, if server A permits the creation\
    \ of a\n   binding to a resource on server B, server A must notify server B\n\
    \   about its binding and must have an agreement with B that B will not\n   destroy\
    \ the resource while A's binding exists.  Otherwise, server B\n   may receive\
    \ a DELETE request that it thinks removes the last binding\n   to the resource\
    \ and destroy the resource while A's binding still\n   exists.  The precondition\
    \ DAV:cross-server-binding is defined below\n   for cases where servers fail cross-server\
    \ BIND requests because they\n   cannot guarantee the integrity of cross-server\
    \ bindings.\n   By default, if there already is a binding for the specified segment\n\
    \   in the collection, the new binding replaces the existing binding.\n   This\
    \ default binding replacement behavior can be overridden using the\n   Overwrite\
    \ header defined in Section 10.6 of [RFC4918].\n   If a BIND request fails, the\
    \ server state preceding the request MUST\n   be restored.  This method is unsafe\
    \ and idempotent (see [RFC2616],\n   Section 9.1).\n   Marshalling:\n      The\
    \ request MAY include an Overwrite header.\n      The request body MUST be a DAV:bind\
    \ XML element.\n      <!ELEMENT bind (segment, href)>\n      If the request succeeds,\
    \ the server MUST return 201 (Created) when\n      a new binding was created and\
    \ 200 (OK) or 204 (No Content) when an\n      existing binding was replaced.\n\
    \      If a response body for a successful request is included, it MUST\n    \
    \  be a DAV:bind-response XML element.  Note that this document does\n      not\
    \ define any elements for the BIND response body, but the DAV:\n      bind-response\
    \ element is defined to ensure interoperability\n      between future extensions\
    \ that do define elements for the BIND\n      response body.\n      <!ELEMENT\
    \ bind-response ANY>\n   Preconditions:\n      (DAV:bind-into-collection): The\
    \ Request-URI MUST identify a\n      collection.\n      (DAV:bind-source-exists):\
    \ The DAV:href element MUST identify a\n      resource.\n      (DAV:binding-allowed):\
    \ The resource identified by the DAV:href\n      supports multiple bindings to\
    \ it.\n      (DAV:cross-server-binding): If the resource identified by the DAV:\n\
    \      href element in the request body is on another server from the\n      collection\
    \ identified by the Request-URI, the server MUST support\n      cross-server bindings\
    \ (servers that do not support cross-server\n      bindings can use this condition\
    \ code to signal the client exactly\n      why the request failed).\n      (DAV:name-allowed):\
    \ The name specified by the DAV:segment is\n      available for use as a new binding\
    \ name.\n      (DAV:can-overwrite): If the collection already contains a binding\n\
    \      with the specified path segment, and if an Overwrite header is\n      included,\
    \ the value of the Overwrite header MUST be \"T\".\n      (DAV:cycle-allowed):\
    \ If the DAV:href element identifies a\n      collection, and if the Request-URI\
    \ identifies a collection that is\n      a member of that collection, the server\
    \ MUST support cycles in the\n      URI namespace (servers that do not support\
    \ cycles can use this\n      condition code to signal the client exactly why the\
    \ request\n      failed).\n      (DAV:locked-update-allowed): If the collection\
    \ identified by the\n      Request-URI is write-locked, then the appropriate token\
    \ MUST be\n      specified in an If request header.\n      (DAV:locked-overwrite-allowed):\
    \ If the collection already contains\n      a binding with the specified path\
    \ segment, and if that binding is\n      protected by a write lock, then the appropriate\
    \ token MUST be\n      specified in an If request header.\n   Postconditions:\n\
    \      (DAV:new-binding): The collection MUST have a binding that maps\n     \
    \ the segment specified in the DAV:segment element in the request\n      body\
    \ to the resource identified by the DAV:href element in the\n      request body.\n"
- title: '4.1.  Example: BIND'
  contents:
  - "4.1.  Example: BIND\n   >> Request:\n   BIND /CollY HTTP/1.1\n   Host: www.example.com\n\
    \   Content-Type: application/xml; charset=\"utf-8\"\n   Content-Length: 172\n\
    \   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:bind xmlns:D=\"DAV:\">\n\
    \      <D:segment>bar.html</D:segment>\n      <D:href>http://www.example.com/CollX/foo.html</D:href>\n\
    \   </D:bind>\n   >> Response:\n   HTTP/1.1 201 Created\n   Location: http://www.example.com/CollY/bar.html\n\
    \   The server added a new binding to the collection,\n   \"http://www.example.com/CollY\"\
    , associating \"bar.html\" with the\n   resource identified by the URI\n   \"\
    http://www.example.com/CollX/foo.html\".  Clients can now use the URI\n   \"http://www.example.com/CollY/bar.html\"\
    \ to submit requests to that\n   resource.\n"
- title: 5.  UNBIND Method
  contents:
  - "5.  UNBIND Method\n   The UNBIND method modifies the collection identified by\
    \ the Request-\n   URI by removing the binding identified by the segment specified\
    \ in\n   the UNBIND body.\n   Once a resource is unreachable by any URI mapping,\
    \ the server MAY\n   reclaim system resources associated with that resource. \
    \ If UNBIND\n   removes a binding to a resource, but there remain URI mappings\
    \ to\n   that resource, the server MUST NOT reclaim system resources\n   associated\
    \ with the resource.\n   If an UNBIND request fails, the server state preceding\
    \ the request\n   MUST be restored.  This method is unsafe and idempotent (see\n\
    \   [RFC2616], Section 9.1).\n   Marshalling:\n      The request body MUST be\
    \ a DAV:unbind XML element.\n      <!ELEMENT unbind (segment)>\n      If the request\
    \ succeeds, the server MUST return 200 (OK) or 204\n      (No Content) when the\
    \ binding was successfully deleted.\n      If a response body for a successful\
    \ request is included, it MUST\n      be a DAV:unbind-response XML element.  Note\
    \ that this document\n      does not define any elements for the UNBIND response\
    \ body, but the\n      DAV:unbind-response element is defined to ensure interoperability\n\
    \      between future extensions that do define elements for the UNBIND\n    \
    \  response body.\n      <!ELEMENT unbind-response ANY>\n   Preconditions:\n \
    \     (DAV:unbind-from-collection): The Request-URI MUST identify a\n      collection.\n\
    \      (DAV:unbind-source-exists): The DAV:segment element MUST identify\n   \
    \   a binding in the collection identified by the Request-URI.\n      (DAV:locked-update-allowed):\
    \ If the collection identified by the\n      Request-URI is write-locked, then\
    \ the appropriate token MUST be\n      specified in the request.\n      (DAV:protected-url-deletion-allowed):\
    \ If the binding identified by\n      the segment is protected by a write lock,\
    \ then the appropriate\n      token MUST be specified in the request.\n   Postconditions:\n\
    \      (DAV:binding-deleted): The collection MUST NOT have a binding for\n   \
    \   the segment specified in the DAV:segment element in the request\n      body.\n\
    \      (DAV:lock-deleted): If the internal member URI of the binding\n      specified\
    \ by the Request-URI and the DAV:segment element in the\n      request body was\
    \ protected by a write lock at the time of the\n      request, that write lock\
    \ must have been deleted by the request.\n"
- title: '5.1.  Example: UNBIND'
  contents:
  - "5.1.  Example: UNBIND\n   >> Request:\n   UNBIND /CollX HTTP/1.1\n   Host: www.example.com\n\
    \   Content-Type: application/xml; charset=\"utf-8\"\n   Content-Length: 117\n\
    \   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:unbind xmlns:D=\"DAV:\"\
    >\n      <D:segment>foo.html</D:segment>\n   </D:unbind>\n   >> Response:\n  \
    \ HTTP/1.1 200 OK\n   The server removed the binding named \"foo.html\" from the\
    \ collection,\n   \"http://www.example.com/CollX\".  A request to the resource\
    \ named\n   \"http://www.example.com/CollX/foo.html\" will return a 404 (Not Found)\n\
    \   response.\n"
- title: 6.  REBIND Method
  contents:
  - "6.  REBIND Method\n   The REBIND method removes a binding to a resource from\
    \ a collection,\n   and adds a binding to that resource into the collection identified\
    \ by\n   the Request-URI.  The request body specifies the binding to be added\n\
    \   (segment) and the old binding to be removed (href).  It is\n   effectively\
    \ an atomic form of a MOVE request, and MUST be treated the\n   same way as MOVE\
    \ for the purpose of determining access permissions.\n   If a REBIND request fails,\
    \ the server state preceding the request\n   MUST be restored.  This method is\
    \ unsafe and idempotent (see\n   [RFC2616], Section 9.1).\n   Marshalling:\n \
    \     The request MAY include an Overwrite header.\n      The request body MUST\
    \ be a DAV:rebind XML element.\n      <!ELEMENT rebind (segment, href)>\n    \
    \  If the request succeeds, the server MUST return 201 (Created) when\n      a\
    \ new binding was created and 200 (OK) or 204 (No Content) when an\n      existing\
    \ binding was replaced.\n      If a response body for a successful request is\
    \ included, it MUST\n      be a DAV:rebind-response XML element.  Note that this\
    \ document\n      does not define any elements for the REBIND response body, but\
    \ the\n      DAV:rebind-response element is defined to ensure interoperability\n\
    \      between future extensions that do define elements for the REBIND\n    \
    \  response body.\n      <!ELEMENT rebind-response ANY>\n   Preconditions:\n \
    \     (DAV:rebind-into-collection): The Request-URI MUST identify a\n      collection.\n\
    \      (DAV:rebind-source-exists): The DAV:href element MUST identify a\n    \
    \  resource.\n      (DAV:cross-server-binding): If the resource identified by\
    \ the DAV:\n      href element in the request body is on another server from the\n\
    \      collection identified by the Request-URI, the server MUST support\n   \
    \   cross-server bindings (servers that do not support cross-server\n      bindings\
    \ can use this condition code to signal the client exactly\n      why the request\
    \ failed).\n      (DAV:name-allowed): The name specified by the DAV:segment is\n\
    \      available for use as a new binding name.\n      (DAV:can-overwrite): If\
    \ the collection already contains a binding\n      with the specified path segment,\
    \ and if an Overwrite header is\n      included, the value of the Overwrite header\
    \ MUST be \"T\".\n      (DAV:cycle-allowed): If the DAV:href element identifies\
    \ a\n      collection, and if the Request-URI identifies a collection that is\n\
    \      a member of that collection, the server MUST support cycles in the\n  \
    \    URI namespace (servers that do not support cycles can use this\n      condition\
    \ code to signal the client exactly why the request\n      failed).\n      (DAV:locked-update-allowed):\
    \ If the collection identified by the\n      Request-URI is write-locked, then\
    \ the appropriate token MUST be\n      specified in the request.\n      (DAV:protected-url-modification-allowed):\
    \ If the collection\n      identified by the Request-URI already contains a binding\
    \ with the\n      specified path segment, and if that binding is protected by\
    \ a\n      write lock, then the appropriate token MUST be specified in the\n \
    \     request.\n      (DAV:locked-source-collection-update-allowed): If the collection\n\
    \      identified by the parent collection prefix of the DAV:href URI is\n   \
    \   write-locked, then the appropriate token MUST be specified in the\n      request.\n\
    \      (DAV:protected-source-url-deletion-allowed): If the DAV:href URI\n    \
    \  is protected by a write lock, then the appropriate token MUST be\n      specified\
    \ in the request.\n   Postconditions:\n      (DAV:new-binding): The collection\
    \ MUST have a binding that maps\n      the segment specified in the DAV:segment\
    \ element in the request\n      body, to the resource that was identified by the\
    \ DAV:href element\n      in the request body.\n      (DAV:binding-deleted): The\
    \ URL specified in the DAV:href element\n      in the request body MUST NOT be\
    \ mapped to a resource.\n      (DAV:lock-deleted): If the URL specified in the\
    \ DAV:href element\n      in the request body was protected by a write lock at\
    \ the time of\n      the request, that write lock must have been deleted by the\n\
    \      request.\n"
- title: '6.1.  Example: REBIND'
  contents:
  - "6.1.  Example: REBIND\n   >> Request:\n   REBIND /CollX HTTP/1.1\n   Host: www.example.com\n\
    \   Content-Type: application/xml; charset=\"utf-8\"\n   Content-Length: 176\n\
    \   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:rebind xmlns:D=\"DAV:\"\
    >\n      <D:segment>foo.html</D:segment>\n      <D:href>http://www.example.com/CollY/bar.html</D:href>\n\
    \   </D:rebind>\n   >> Response:\n   HTTP/1.1 200 OK\n   The server added a new\
    \ binding to the collection,\n   \"http://www.example.com/CollX\", associating\
    \ \"foo.html\" with the\n   resource identified by the URI\n   \"http://www.example.com/CollY/bar.html\"\
    \ and removes the binding named\n   \"bar.html\" from the collection identified\
    \ by the URI\n   \"http://www.example.com/CollY\".  Clients can now use the URI\n\
    \   \"http://www.example.com/CollX/foo.html\" to submit requests to that\n   resource,\
    \ and requests on the URI\n   \"http://www.example.com/CollY/bar.html\" will fail\
    \ with a 404 (Not\n   Found) response.\n"
- title: '6.2.  Example: REBIND in Presence of Locks and Bind Loops'
  contents:
  - "6.2.  Example: REBIND in Presence of Locks and Bind Loops\n   To illustrate the\
    \ effects of locks and bind loops on a REBIND\n   operation, consider the following\
    \ collection:\n              +------------------+\n              | Root Collection\
    \  |\n              |  bindings:       |\n              |  CollW           |\n\
    \              +------------------+\n                   |\n                  \
    \ |\n                   |\n              +-------------------------------+\n \
    \             | Collection C1                 |<--------+\n              | LOCKED\
    \ infinity               |         |\n              | (lock token L1)        \
    \       |         |\n              | bindings:                     |         |\n\
    \              | CollX               CollY     |         |\n              +-------------------------------+\
    \         |\n                   |                  |                 |\n     \
    \              |                  |  (creates loop) |\n                   |  \
    \                |                 |\n              +-----------------+  +------------------+\
    \ |\n              | Collection C2   |  | Collection C3    | |\n             \
    \ | (inherit lock)  |  | (inherit lock)   | |\n              | (lock token L1)\
    \ |  | (lock token L1)  | |\n              | bindings:       |  | bindings:  \
    \      | |\n              |  {none}         |  | y.gif     CollZ  | |\n      \
    \        +-----------------+  +------------------+ |\n                       \
    \              |            |     |\n                                     |  \
    \          +-----+\n                                     |\n                 \
    \                +---------------------------+\n                             \
    \    | Resource R2               |\n                                 | (lock inherited\
    \ from C1)  |\n                                 | (lock token L1)           |\n\
    \                                 +---------------------------+\n   (where L1\
    \ is \"urn:uuid:f92d4fae-7012-11ab-a765-00c0ca1f6bf9\").\n   Note that the binding\
    \ between CollZ and C1 creates a loop in the\n   containment hierarchy.  Servers\
    \ are not required to support such\n   loops, though the server in this example\
    \ does.\n   The REBIND request below will remove the segment \"CollZ\" from C3\
    \ and\n   add a new binding from \"CollA\" to the collection C2.\n   REBIND /CollW/CollX\
    \ HTTP/1.1\n   Host: www.example.com\n   If: (<urn:uuid:f92d4fae-7012-11ab-a765-00c0ca1f6bf9>)\n\
    \   Content-Type: application/xml; charset=\"utf-8\"\n   Content-Length: 152\n\
    \   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:rebind xmlns:D=\"DAV:\"\
    >\n     <D:segment>CollA</D:segment>\n     <D:href>/CollW/CollY/CollZ</D:href>\n\
    \   </D:rebind>\n   The outcome of the REBIND operation is:\n              +------------------+\n\
    \              | Root Collection  |\n              |  bindings:       |\n    \
    \          |  CollW           |\n              +------------------+\n        \
    \           |\n                   |\n                   |\n              +-------------------------------+\n\
    \              | Collection C1                 |\n              | LOCKED infinity\
    \               |\n              | (lock token L1)               |\n         \
    \     | bindings:                     |\n              | CollX               \
    \   CollY  |\n              +-------------------------------+\n              \
    \     |              ^      |\n                   |              |      |\n  \
    \            +-----------------+ | +------------------+\n              | Collection\
    \ C2   | | | Collection C3    |\n              |(inherited lock) | | | (inherited\
    \ lock) |\n              |(lock token L1)  | | | (lock token L1)  |\n        \
    \      | bindings:       | | | bindings:        |\n              | CollA     \
    \      | | | y.gif            |\n              +-----------------+ | +------------------+\n\
    \                  |               |    |\n                  +---------------+\
    \    |\n                   (creates loop)      |\n                           \
    \      +---------------------------+\n                                 | Resource\
    \ R2               |\n                                 | (inherited lock from\
    \ C1)  |\n                                 | (lock token L1)           |\n   \
    \                              +---------------------------+\n"
- title: 7.  Additional Status Codes
  contents:
  - '7.  Additional Status Codes

    '
- title: 7.1.  208 Already Reported
  contents:
  - "7.1.  208 Already Reported\n   The 208 (Already Reported) status code can be\
    \ used inside a DAV:\n   propstat response element to avoid enumerating the internal\
    \ members\n   of multiple bindings to the same collection repeatedly.  For each\n\
    \   binding to a collection inside the request's scope, only one will be\n   reported\
    \ with a 200 status, while subsequent DAV:response elements\n   for all other\
    \ bindings will use the 208 status, and no DAV:response\n   elements for their\
    \ descendants are included.\n   Note that the 208 status will only occur for \"\
    Depth: infinity\"\n   requests, and that it is of particular importance when the\
    \ multiple\n   collection bindings cause a bind loop as discussed in Section 2.2.\n\
    \   A client can request the DAV:resource-id property in a PROPFIND\n   request\
    \ to guarantee that they can accurately reconstruct the binding\n   structure\
    \ of a collection with multiple bindings to a single\n   resource.\n   For backward\
    \ compatibility with clients not aware of the 208 status\n   code appearing in\
    \ multistatus response bodies, it SHOULD NOT be used\n   unless the client has\
    \ signaled support for this specification using\n   the \"DAV\" request header\
    \ (see Section 8.2).  Instead, a 508 status\n   should be returned when a binding\
    \ loop is discovered.  This allows\n   the server to return the 508 as the top-level\
    \ return status, if it\n   discovers it before it started the response, or in\
    \ the middle of a\n   multistatus, if it discovers it in the middle of streaming\
    \ out a\n   multistatus response.\n"
- title: '7.1.1.  Example: PROPFIND by Bind-Aware Client'
  contents:
  - "7.1.1.  Example: PROPFIND by Bind-Aware Client\n   For example, consider a PROPFIND\
    \ request on /Coll (bound to\n   collection C), where the members of /Coll are\
    \ /Coll/Foo (bound to\n   resource R) and /Coll/Bar (bound to collection C).\n\
    \   >> Request:\n   PROPFIND /Coll/ HTTP/1.1\n   Host: www.example.com\n   Depth:\
    \ infinity\n   DAV: bind\n   Content-Type: application/xml; charset=\"utf-8\"\n\
    \   Content-Length: 152\n   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:propfind\
    \ xmlns:D=\"DAV:\">\n     <D:prop>\n      <D:displayname/>\n      <D:resource-id/>\n\
    \     </D:prop>\n   </D:propfind>\n   >> Response:\n   HTTP/1.1 207 Multi-Status\n\
    \   Content-Type: application/xml; charset=\"utf-8\"\n   Content-Length: 1241\n\
    \   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:multistatus xmlns:D=\"\
    DAV:\">\n     <D:response>\n       <D:href>http://www.example.com/Coll/</D:href>\n\
    \       <D:propstat>\n         <D:prop>\n           <D:displayname>Loop Demo</D:displayname>\n\
    \           <D:resource-id>\n             <D:href\n   >urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf8</D:href>\n\
    \           </D:resource-id>\n         </D:prop>\n         <D:status>HTTP/1.1\
    \ 200 OK</D:status>\n       </D:propstat>\n     </D:response>\n     <D:response>\n\
    \       <D:href>http://www.example.com/Coll/Foo</D:href>\n       <D:propstat>\n\
    \         <D:prop>\n           <D:displayname>Bird Inventory</D:displayname>\n\
    \           <D:resource-id>\n             <D:href\n   >urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf9</D:href>\n\
    \           </D:resource-id>\n         </D:prop>\n         <D:status>HTTP/1.1\
    \ 200 OK</D:status>\n       </D:propstat>\n     </D:response>\n     <D:response>\n\
    \       <D:href>http://www.example.com/Coll/Bar</D:href>\n       <D:propstat>\n\
    \         <D:prop>\n           <D:displayname>Loop Demo</D:displayname>\n    \
    \       <D:resource-id>\n             <D:href\n   >urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf8</D:href>\n\
    \           </D:resource-id>\n         </D:prop>\n         <D:status>HTTP/1.1\
    \ 208 Already Reported</D:status>\n       </D:propstat>\n     </D:response>\n\
    \   </D:multistatus>\n"
- title: '7.1.2.  Example: PROPFIND by Non-Bind-Aware Client'
  contents:
  - "7.1.2.  Example: PROPFIND by Non-Bind-Aware Client\n   In this example, the client\
    \ isn't aware of the 208 status code\n   introduced by this specification.  As\
    \ the \"Depth: infinity\" PROPFIND\n   request would cause a loop condition, the\
    \ whole request is rejected\n   with a 508 status.\n   >> Request:\n   PROPFIND\
    \ /Coll/ HTTP/1.1\n   Host: www.example.com\n   Depth: infinity\n   Content-Type:\
    \ application/xml; charset=\"utf-8\"\n   Content-Length: 125\n   <?xml version=\"\
    1.0\" encoding=\"utf-8\" ?>\n   <D:propfind xmlns:D=\"DAV:\">\n      <D:prop>\
    \ <D:displayname/> </D:prop>\n   </D:propfind>\n   >> Response:\n   HTTP/1.1 508\
    \ Loop Detected\n"
- title: 7.2.  508 Loop Detected
  contents:
  - "7.2.  508 Loop Detected\n   The 508 (Loop Detected) status code indicates that\
    \ the server\n   terminated an operation because it encountered an infinite loop\
    \ while\n   processing a request with \"Depth: infinity\".  This status indicates\n\
    \   that the entire operation failed.\n"
- title: 8.  Capability Discovery
  contents:
  - '8.  Capability Discovery

    '
- title: 8.1.  OPTIONS Method
  contents:
  - "8.1.  OPTIONS Method\n   If the server supports bindings, it MUST return the\
    \ compliance class\n   name \"bind\" as a field in the \"DAV\" response header\
    \ (see [RFC4918],\n   Section 10.1) from an OPTIONS request on any resource implemented\
    \ by\n   that server.  A value of \"bind\" in the \"DAV\" header MUST indicate\n\
    \   that the server supports all MUST-level requirements and REQUIRED\n   features\
    \ specified in this document.\n"
- title: 8.2.  'DAV' Request Header
  contents:
  - "8.2.  'DAV' Request Header\n   Clients SHOULD signal support for all MUST-level\
    \ requirements and\n   REQUIRED features by submitting a \"DAV\" request header\
    \ containing the\n   compliance class name \"bind\".  In particular, the client\
    \ MUST\n   understand the 208 status code defined in Section 7.1.\n"
- title: 9.  Relationship to Locking in WebDAV
  contents:
  - "9.  Relationship to Locking in WebDAV\n   Locking is an optional feature of WebDAV\
    \ ([RFC4918]).  The base\n   WebDAV specification and this protocol extension\
    \ have been designed\n   in parallel, making sure that all features of WebDAV\
    \ can be\n   implemented on a server that implements this protocol as well.\n\
    \   Unfortunately, WebDAV uses the term \"lock-root\" inconsistently.  It\n  \
    \ is introduced in Section 6.1 of [RFC4918], point 2, as:\n      2.  A resource\
    \ becomes directly locked when a LOCK request to a\n      URL of that resource\
    \ creates a new lock.  The \"lock-root\" of the\n      new lock is that URL. \
    \ If at the time of the request, the URL is\n      not mapped to a resource, a\
    \ new empty resource is created and\n      directly locked.\n   On the other hand,\
    \ [RFC4918], Section 9.10.1 states:\n      A LOCK request to an existing resource\
    \ will create a lock on the\n      resource identified by the Request-URI, provided\
    \ the resource is\n      not already locked with a conflicting lock.  The resource\n\
    \      identified in the Request-URI becomes the root of the lock.\n   Servers\
    \ that implement both WebDAV locking and support for multiple\n   bindings MUST\
    \ use the first interpretation: the lock-root is the URI\n   through which the\
    \ lock was created, not a resource.  This URI, and\n   potential aliases of this\
    \ URI ([RFC4918], Section 5), are said to be\n   \"protected\" by the lock.\n\
    \   As defined in the introduction to Section 7 of [RFC4918], write\n   operations\
    \ that modify the state of a locked resource require that\n   the lock token is\
    \ submitted with the request.  Consistent with\n   WebDAV, the state of the resource\
    \ consists of the content (\"any\n   variant\"), dead properties, lockable live\
    \ properties (item 1), plus,\n   for a collection, all its bindings (item 2).\
    \  Note that this, by\n   definition, does not depend on the Request-URI to which\
    \ the write\n   operation is applied (the locked state is a property of the resource,\n\
    \   not its URI).\n   However, the lock-root is the URI through which the lock\
    \ was\n   requested.  Thus, the protection defined in item 3 of the list does\n\
    \   not apply to additional URIs that may be mapped to the same resource\n   due\
    \ to the existence of multiple bindings.\n"
- title: '9.1.  Example: Locking and Multiple Bindings'
  contents:
  - "9.1.  Example: Locking and Multiple Bindings\n   Consider a root collection \"\
    /\", containing the two collections C1 and\n   C2, named \"/CollX\" and \"/CollY\"\
    , and a child resource R, bound to C1\n   as \"/CollX/test\" and bound to C2 as\
    \ \"/CollY/test\":\n                         +-------------------------+\n   \
    \                      | Root Collection         |\n                         |\
    \  bindings:              |\n                         |  CollX          CollY\
    \   |\n                         +-------------------------+\n                \
    \             |                |\n                             |             \
    \   |\n                             |                |\n                    +---------------+\
    \  +---------------+\n                    | Collection C1 |  | Collection C2 |\n\
    \                    | bindings:     |  | bindings:     |\n                  \
    \  |     test      |  |     test      |\n                    +---------------+\
    \  +---------------+\n                             |               |\n       \
    \                      |               |\n                             |     \
    \          |\n                            +------------------+\n             \
    \               |    Resource R    |\n                            +------------------+\n\
    \   Given a host name of \"www.example.com\", applying a depth-zero write\n  \
    \ lock to \"/CollX/test\" will lock the resource R, and the lock-root of\n   this\
    \ lock will be \"http://www.example.com/CollX/test\".\n   Thus, the following\
    \ operations will require that the associated lock\n   token is submitted with\
    \ the \"If\" request header ([RFC4918], Section\n   10.4):\n   o  a PUT or PROPPATCH\
    \ request modifying the content or lockable\n      properties of resource R (as\
    \ R is locked) -- no matter which URI\n      is used as request target, and\n\
    \   o  a MOVE, REBIND, UNBIND, or DELETE request causing \"/CollX/test\"\n   \
    \   not to be mapped to resource R anymore (be it addressed to\n      \"/CollX\"\
    \ or \"/CollX/test\").\n   The following operations will not require submission\
    \ of the lock\n   token:\n   o  a DELETE request addressed to \"/CollY\" or \"\
    /CollY/test\", as it\n      does not affect the resource R, nor the lock-root,\n\
    \   o  for the same reason, an UNBIND request removing the binding \"test\"\n\
    \      from collection C2, or the binding \"CollY\" from the root\n      collection,\
    \ and\n   o  similarly, a MOVE or REBIND request causing \"/CollY/test\" not\n\
    \      being mapped to resource R anymore.\n   Note that despite the lock-root\
    \ being\n   \"http://www.example.com/CollX/test\", an UNLOCK request can be\n\
    \   addressed through any URI mapped to resource R, as UNLOCK operates on\n  \
    \ the resource identified by the Request-URI, not that URI (see\n   [RFC4918],\
    \ Section 9.11).\n"
- title: 10.  Relationship to WebDAV Access Control Protocol
  contents:
  - "10.  Relationship to WebDAV Access Control Protocol\n   Note that the WebDAV\
    \ Access Control Protocol has been designed for\n   compatibility with systems\
    \ that allow multiple URIs to map to the\n   same resource (see [RFC3744], Section\
    \ 5):\n      Access control properties (especially DAV:acl and DAV:inherited-\n\
    \      acl-set) are defined on the resource identified by the Request-URI\n  \
    \    of a PROPFIND request.  A direct consequence is that if the\n      resource\
    \ is accessible via multiple URI, the value of access\n      control properties\
    \ is the same across these URI.\n   Furthermore, note that BIND and REBIND behave\
    \ the same as MOVE with\n   respect to the DAV:acl property (see [RFC3744], Section\
    \ 7.3).\n"
- title: 11.  Relationship to Versioning Extensions to WebDAV
  contents:
  - "11.  Relationship to Versioning Extensions to WebDAV\n   Servers that implement\
    \ Workspaces ([RFC3253], Section 6) and Version-\n   Controlled Collections ([RFC3253],\
    \ Section 14) already need to\n   implement BIND-like behavior in order to handle\
    \ UPDATE and UNCHECKOUT\n   semantics.\n   Consider a workspace \"/ws1/\", containing\
    \ the version-controlled,\n   checked-out collections C1 and C2, named \"/ws1/CollX\"\
    \ and \"/ws1/\n   CollY\", and a version-controlled resource R, bound to C1 as\
    \ \"/ws1/\n   CollX/test\":\n                         +-------------------------+\n\
    \                         | Workspace               |\n                      \
    \   |  bindings:              |\n                         |  CollX          CollY\
    \   |\n                         +-------------------------+\n                \
    \             |                |\n                             |             \
    \   |\n                             |                |\n                    +---------------+\
    \  +---------------+\n                    | Collection C1 |  | Collection C2 |\n\
    \                    | bindings:     |  |               |\n                  \
    \  |     test      |  |               |\n                    +---------------+\
    \  +---------------+\n                             |\n                       \
    \      |\n                             |\n                            +------------------+\n\
    \                            |    Resource R    |\n                          \
    \  +------------------+\n   Moving \"/ws1/CollX/test\" into \"/ws1/CollY\", checking\
    \ in C2, but\n   undoing the checkout on C1 will undo part of the MOVE request,\
    \ thus\n   restoring the binding from C1 to R, but keeping the new binding from\n\
    \   C2 to R:\n   >> Request:\n   MOVE /ws1/CollX/test HTTP/1.1\n   Host: www.example.com\n\
    \   Destination: /ws1/CollY/test\n   >> Response:\n   HTTP/1.1 204 No Content\n\
    \   >> Request:\n   CHECKIN /ws1/CollY/ HTTP/1.1\n   Host: www.example.com\n \
    \  >> Response:\n   HTTP/1.1 201 Created\n   Cache-Control: no-cache\n   Location:\
    \ http://repo.example.com/his/17/ver/42\n   >> Request:\n   UNCHECKOUT /ws1/CollX/\
    \ HTTP/1.1\n   Host: www.example.com\n   >> Response:\n   HTTP/1.1 200 OK\n  \
    \ Cache-Control: no-cache\n   As a result, both C1 and C2 would have a binding\
    \ to R:\n                         +-------------------------+\n              \
    \           | Workspace               |\n                         |  bindings:\
    \              |\n                         |  CollX          CollY   |\n     \
    \                    +-------------------------+\n                           \
    \  |                |\n                             |                |\n     \
    \                        |                |\n                    +---------------+\
    \  +---------------+\n                    | Collection C1 |  | Collection C2 |\n\
    \                    | bindings:     |  | bindings:     |\n                  \
    \  |     test      |  |     test      |\n                    +---------------+\
    \  +---------------+\n                             |                |\n      \
    \                       |                |\n                             |   \
    \             |\n                            +------------------+\n          \
    \                  |    Resource R    |\n                            +------------------+\n\
    \   The MOVE semantics defined in Section 3.15 of [RFC3253] already\n   require\
    \ that \"/ws1/CollX/test\" and \"/ws1/CollY/test\" will have the\n   same version\
    \ history (as exposed in the DAV:version-history\n   property).  Furthermore,\
    \ the UNCHECKOUT semantics (which in this case\n   is similar to UPDATE, see Section\
    \ 14.11 of [RFC3253]) require:\n      If a new version-controlled member is in\
    \ a workspace that already\n      has a version-controlled resource for that version\
    \ history, then\n      the new version-controlled member MUST be just a binding\
    \ (i.e.,\n      another name for) that existing version-controlled resource.\n\
    \   Thus, \"/ws1/CollX/test\" and \"/ws1/CollY/test\" will be bindings to the\n\
    \   same resource R, and have identical DAV:resource-id properties.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   This section is provided to make WebDAV implementers\
    \ aware of the\n   security implications of this protocol.\n   All of the security\
    \ considerations of HTTP/1.1 ([RFC2616], Section\n   15) and the WebDAV Distributed\
    \ Authoring Protocol specification\n   ([RFC4918], Section 20) also apply to this\
    \ protocol specification.\n   In addition, bindings introduce several new security\
    \ concerns and\n   increase the risk of some existing threats.  These issues are\n\
    \   detailed below.\n"
- title: 12.1.  Privacy Concerns
  contents:
  - "12.1.  Privacy Concerns\n   In a context where cross-server bindings are supported,\
    \ creating\n   bindings on a trusted server may make it possible for a hostile\
    \ agent\n   to induce users to send private information to a target on a\n   different\
    \ server.\n"
- title: 12.2.  Bind Loops
  contents:
  - "12.2.  Bind Loops\n   Although bind loops were already possible in HTTP 1.1,\
    \ the\n   introduction of the BIND method creates a new avenue for clients to\n\
    \   create loops accidentally or maliciously.  If the binding and its\n   target\
    \ are on the same server, the server may be able to detect BIND\n   requests that\
    \ would create loops.  Servers are required to detect\n   loops that are caused\
    \ by bindings to collections during the\n   processing of any requests with \"\
    Depth: infinity\".\n"
- title: 12.3.  Bindings and Denial of Service
  contents:
  - "12.3.  Bindings and Denial of Service\n   Denial-of-service attacks were already\
    \ possible by posting URIs that\n   were intended for limited use at heavily used\
    \ Web sites.  The\n   introduction of BIND creates a new avenue for similar denial-of-\n\
    \   service attacks.  If cross-server bindings are supported, clients can\n  \
    \ now create bindings at heavily used sites to target locations that\n   were\
    \ not designed for heavy usage.\n"
- title: 12.4.  Private Locations May Be Revealed
  contents:
  - "12.4.  Private Locations May Be Revealed\n   If the DAV:parent-set property is\
    \ maintained on a resource, the\n   owners of the bindings risk revealing private\
    \ locations.  The\n   directory structures where bindings are located are available\
    \ to\n   anyone who has access to the DAV:parent-set property on the resource.\n\
    \   Moving a binding may reveal its new location to anyone with access to\n  \
    \ DAV:parent-set on its resource.\n"
- title: 12.5.  DAV:parent-set and Denial of Service
  contents:
  - "12.5.  DAV:parent-set and Denial of Service\n   If the server maintains the DAV:parent-set\
    \ property in response to\n   bindings created in other administrative domains,\
    \ it is exposed to\n   hostile attempts to make it devote resources to adding\
    \ bindings to\n   the list.\n"
- title: 13.  Internationalization Considerations
  contents:
  - "13.  Internationalization Considerations\n   All internationalization considerations\
    \ mentioned in Section 19 of\n   [RFC4918] also apply to this document.\n"
- title: 14.  IANA Considerations
  contents:
  - "14.  IANA Considerations\n   Section 7 defines the HTTP status codes 208 (Already\
    \ Reported) and\n   508 (Loop Detected), which have been added to the HTTP Status\
    \ Code\n   Registry.\n"
- title: 15.  Acknowledgements
  contents:
  - "15.  Acknowledgements\n   This document is the collaborative product of the authors\
    \ and Tyson\n   Chihaya, Jim Davis, Chuck Fay and Judith Slein.  It has benefited\n\
    \   from thoughtful discussion by Jim Amsden, Peter Carlson, Steve\n   Carter,\
    \ Ken Coar, Ellis Cohen, Dan Connolly, Bruce Cragun, Cyrus\n   Daboo, Spencer\
    \ Dawkins, Mark Day, Werner Donne, Rajiv Dulepet, David\n   Durand, Lisa Dusseault,\
    \ Stefan Eissing, Roy Fielding, Yaron Goland,\n   Joe Hildebrand, Fred Hitt, Alex\
    \ Hopmann, James Hunt, Marcus Jager,\n   Chris Kaler, Manoj Kasichainula, Rohit\
    \ Khare, Brian Korver, Daniel\n   LaLiberte, Steve Martin, Larry Masinter, Jeff\
    \ McAffer, Alexey\n   Melnikov, Surendra Koduru Reddy, Max Rible, Sam Ruby, Bradley\n\
    \   Sergeant, Nick Shelness, John Stracke, John Tigue, John Turner, Kevin\n  \
    \ Wiggen, and other members of the concluded WebDAV working group.\n"
- title: 16.  References
  contents:
  - '16.  References

    '
- title: 16.1.  Normative References
  contents:
  - "16.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n   \
    \           Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n       \
    \       Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n   [RFC3986]  Berners-Lee,\
    \ T., Fielding, R., and L. Masinter, \"Uniform\n              Resource Identifier\
    \ (URI): Generic Syntax\", STD 66,\n              RFC 3986, January 2005.\n  \
    \ [RFC4918]  Dusseault, L., Ed., \"HTTP Extensions for Web Distributed\n     \
    \         Authoring and Versioning (WebDAV)\", RFC 4918, June 2007.\n   [XML]\
    \      Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and\n           \
    \   F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth\n              Edition)\"\
    , W3C REC-xml-20081126, November 2008,\n              <http://www.w3.org/TR/2008/REC-xml-20081126/>.\n"
- title: 16.2.  Informative References
  contents:
  - "16.2.  Informative References\n   [RFC3253]  Clemm, G., Amsden, J., Ellison,\
    \ T., Kaler, C., and J.\n              Whitehead, \"Versioning Extensions to WebDAV\
    \ (Web\n              Distributed Authoring and Versioning)\", RFC 3253,\n   \
    \           March 2002.\n   [RFC3744]  Clemm, G., Reschke, J., Sedlar, E., and\
    \ J. Whitehead, \"Web\n              Distributed Authoring and Versioning (WebDAV)\
    \ Access\n              Control Protocol\", RFC 3744, May 2004.\n   [RFC4122]\
    \  Leach, P., Mealling, M., and R. Salz, \"A Universally\n              Unique\
    \ IDentifier (UUID) URN Namespace\", RFC 4122,\n              July 2005.\n"
- title: Index
  contents:
  - "Index\n   2\n      208 Already Reported (status code)  31, 41\n   5\n      508\
    \ Loop Detected (status code)  34, 41\n   B\n      BIND method  21\n         Marshalling\
    \  22\n         Postconditions  23\n         Preconditions  22\n      Binding\
    \  6\n      Binding Integrity  6-7, 21\n   C\n      Collection  6\n      Condition\
    \ Names\n         DAV:bind-into-collection (pre)  22\n         DAV:bind-source-exists\
    \ (pre)  22\n         DAV:binding-allowed (pre)  23\n         DAV:binding-deleted\
    \ (post)  25, 28\n         DAV:can-overwrite (pre)  23, 27\n         DAV:cross-server-binding\
    \ (pre)  23, 27\n         DAV:cycle-allowed (pre)  23, 27\n         DAV:lock-deleted\
    \ (post)  25, 28\n         DAV:locked-overwrite-allowed (pre)  23\n         DAV:locked-source-collection-update-allowed\
    \ (pre)  28\n         DAV:locked-update-allowed (pre)  23, 25, 27\n         DAV:name-allowed\
    \ (pre)  23, 27\n         DAV:new-binding (post)  23, 28\n         DAV:protected-source-url-deletion-allowed\
    \ (pre)  28\n         DAV:protected-url-deletion-allowed (pre)  25\n         DAV:protected-url-modification-allowed\
    \ (pre)  27\n         DAV:rebind-into-collection (pre)  27\n         DAV:rebind-source-exists\
    \ (pre)  27\n         DAV:unbind-from-collection (pre)  25\n         DAV:unbind-source-exists\
    \ (pre)  25\n   D\n      DAV header\n         compliance class 'bind'  34\n  \
    \    DAV:bind-into-collection precondition  22\n      DAV:bind-source-exists precondition\
    \  22\n      DAV:binding-allowed precondition  23\n      DAV:binding-deleted postcondition\
    \  25, 28\n      DAV:can-overwrite precondition  23, 27\n      DAV:cross-server-binding\
    \ precondition  23, 27\n      DAV:cycle-allowed precondition  23, 27\n      DAV:lock-deleted\
    \ postcondition  25, 28\n      DAV:locked-overwrite-allowed precondition  23\n\
    \      DAV:locked-source-collection-update-allowed precondition  28\n      DAV:locked-update-allowed\
    \ precondition  23, 25, 27\n      DAV:name-allowed precondition  23, 27\n    \
    \  DAV:new-binding postcondition  23, 28\n      DAV:parent-set property  20\n\
    \      DAV:protected-source-url-deletion-allowed precondition  28\n      DAV:protected-url-deletion-allowed\
    \ precondition  25\n      DAV:protected-url-modification-allowed precondition\
    \  27\n      DAV:rebind-into-collection precondition  27\n      DAV:rebind-source-exists\
    \ precondition  27\n      DAV:resource-id property  19\n      DAV:unbind-from-collection\
    \ precondition  25\n      DAV:unbind-source-exists precondition  25\n   I\n  \
    \    Internal Member URI  6\n   L\n      Locking  35\n   M\n      Methods\n  \
    \       BIND  21\n         REBIND  26\n         UNBIND  24\n   P\n      Path Segment\
    \  5\n      Properties\n         DAV:parent-set  20\n         DAV:resource-id\
    \  19\n   R\n      REBIND method  26\n         Marshalling  26\n         Postconditions\
    \  28\n         Preconditions  27\n   S\n      Status Codes\n         208 Already\
    \ Reported  31, 41\n         508 Loop Detected  34, 41\n   U\n      UNBIND method\
    \  24\n         Marshalling  24\n         Postconditions  25\n         Preconditions\
    \  25\n      URI Mapping  5\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Geoffrey Clemm\n   IBM\n   550 King Street\n   Littleton,\
    \ MA  01460\n   EMail: geoffrey.clemm@us.ibm.com\n   Jason Crawford\n   IBM Research\n\
    \   P.O. Box 704\n   Yorktown Heights, NY  10598\n   EMail: ccjason@us.ibm.com\n\
    \   Julian F. Reschke (editor)\n   greenbytes GmbH\n   Hafenweg 16\n   Muenster,\
    \ NW  48155\n   Germany\n   EMail: julian.reschke@greenbytes.de\n   Jim Whitehead\n\
    \   UC Santa Cruz, Dept. of Computer Science\n   1156 High Street\n   Santa Cruz,\
    \ CA  95064\n   EMail: ejw@cse.ucsc.edu\n"
