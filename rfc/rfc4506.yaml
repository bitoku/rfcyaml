- title: __initial_text__
  contents:
  - '               XDR: External Data Representation Standard

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the External Data Representation Standard\n\
    \   (XDR) protocol as it is currently deployed and accepted.  This\n   document\
    \ obsoletes RFC 1832.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Changes from RFC 1832 ...........................................3\n  \
    \ 3. Basic Block Size ................................................3\n   4.\
    \ XDR Data Types ..................................................4\n      4.1.\
    \ Integer ....................................................4\n      4.2. Unsigned\
    \ Integer ...........................................4\n      4.3. Enumeration\
    \ ................................................5\n      4.4. Boolean ....................................................5\n\
    \      4.5. Hyper Integer and Unsigned Hyper Integer ...................5\n  \
    \    4.6. Floating-Point .............................................6\n    \
    \  4.7. Double-Precision Floating-Point ............................7\n      4.8.\
    \ Quadruple-Precision Floating-Point .........................8\n      4.9. Fixed-Length\
    \ Opaque Data ...................................9\n      4.10. Variable-Length\
    \ Opaque Data ...............................9\n      4.11. String ...................................................10\n\
    \      4.12. Fixed-Length Array .......................................11\n  \
    \    4.13. Variable-Length Array ....................................11\n    \
    \  4.14. Structure ................................................12\n      4.15.\
    \ Discriminated Union ......................................12\n      4.16. Void\
    \ .....................................................13\n      4.17. Constant\
    \ .................................................13\n      4.18. Typedef ..................................................13\n\
    \      4.19. Optional-Data ............................................14\n  \
    \    4.20. Areas for Future Enhancement .............................16\n   5.\
    \ Discussion .....................................................16\n   6. The\
    \ XDR Language Specification .................................17\n      6.1. Notational\
    \ Conventions ....................................17\n      6.2. Lexical Notes\
    \ .............................................18\n      6.3. Syntax Information\
    \ ........................................18\n      6.4. Syntax Notes ..............................................20\n\
    \   7. An Example of an XDR Data Description ..........................21\n  \
    \ 8. Security Considerations ........................................22\n   9.\
    \ IANA Considerations ............................................23\n   10. Trademarks\
    \ and Owners .........................................23\n   11. ANSI/IEEE Standard\
    \ 754-1985 ...................................24\n   12. Normative References\
    \ ..........................................25\n   13. Informative References\
    \ ........................................25\n   14. Acknowledgements ..............................................26\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   XDR is a standard for the description and encoding of data.\
    \  It is\n   useful for transferring data between different computer\n   architectures,\
    \ and it has been used to communicate data between such\n   diverse machines as\
    \ the SUN WORKSTATION*, VAX*, IBM-PC*, and Cray*.\n   XDR fits into the ISO presentation\
    \ layer and is roughly analogous in\n   purpose to X.409, ISO Abstract Syntax\
    \ Notation.  The major difference\n   between these two is that XDR uses implicit\
    \ typing, while X.409 uses\n   explicit typing.\n   XDR uses a language to describe\
    \ data formats.  The language can be\n   used only to describe data; it is not\
    \ a programming language.  This\n   language allows one to describe intricate\
    \ data formats in a concise\n   manner.  The alternative of using graphical representations\
    \ (itself\n   an informal language) quickly becomes incomprehensible when faced\n\
    \   with complexity.  The XDR language itself is similar to the C\n   language\
    \ [KERN], just as Courier [COUR] is similar to Mesa.\n   Protocols such as ONC\
    \ RPC (Remote Procedure Call) and the NFS*\n   (Network File System) use XDR to\
    \ describe the format of their data.\n   The XDR standard makes the following\
    \ assumption: that bytes (or\n   octets) are portable, where a byte is defined\
    \ as 8 bits of data.  A\n   given hardware device should encode the bytes onto\
    \ the various media\n   in such a way that other hardware devices may decode the\
    \ bytes\n   without loss of meaning.  For example, the Ethernet* standard\n  \
    \ suggests that bytes be encoded in \"little-endian\" style [COHE], or\n   least\
    \ significant bit first.\n"
- title: 2.  Changes from RFC 1832
  contents:
  - "2.  Changes from RFC 1832\n   This document makes no technical changes to RFC\
    \ 1832 and is published\n   for the purposes of noting IANA considerations, augmenting\
    \ security\n   considerations, and distinguishing normative from informative\n\
    \   references.\n"
- title: 3.  Basic Block Size
  contents:
  - "3.  Basic Block Size\n   The representation of all items requires a multiple\
    \ of four bytes (or\n   32 bits) of data.  The bytes are numbered 0 through n-1.\
    \  The bytes\n   are read or written to some byte stream such that byte m always\n\
    \   precedes byte m+1.  If the n bytes needed to contain the data are not\n  \
    \ a multiple of four, then the n bytes are followed by enough (0 to 3)\n   residual\
    \ zero bytes, r, to make the total byte count a multiple of 4.\n   We include\
    \ the familiar graphic box notation for illustration and\n   comparison.  In most\
    \ illustrations, each box (delimited by a plus\n   sign at the 4 corners and vertical\
    \ bars and dashes) depicts a byte.\n   Ellipses (...) between boxes show zero\
    \ or more additional bytes where\n   required.\n        +--------+--------+...+--------+--------+...+--------+\n\
    \        | byte 0 | byte 1 |...|byte n-1|    0   |...|    0   |   BLOCK\n    \
    \    +--------+--------+...+--------+--------+...+--------+\n        |<-----------n\
    \ bytes---------->|<------r bytes------>|\n        |<-----------n+r (where (n+r)\
    \ mod 4 = 0)>----------->|\n"
- title: 4.   XDR Data Types
  contents:
  - "4.   XDR Data Types\n   Each of the sections that follow describes a data type\
    \ defined in the\n   XDR standard, shows how it is declared in the language, and\
    \ includes\n   a graphic illustration of its encoding.\n   For each data type\
    \ in the language we show a general paradigm\n   declaration.  Note that angle\
    \ brackets (< and >) denote variable-\n   length sequences of data and that square\
    \ brackets ([ and ]) denote\n   fixed-length sequences of data.  \"n\", \"m\"\
    , and \"r\" denote integers.\n   For the full language specification and more\
    \ formal definitions of\n   terms such as \"identifier\" and \"declaration\",\
    \ refer to Section 6,\n   \"The XDR Language Specification\".\n   For some data\
    \ types, more specific examples are included.  A more\n   extensive example of\
    \ a data description is in Section 7, \"An Example\n   of an XDR Data Description\"\
    .\n"
- title: 4.1.  Integer
  contents:
  - "4.1.  Integer\n   An XDR signed integer is a 32-bit datum that encodes an integer\
    \ in\n   the range [-2147483648,2147483647].  The integer is represented in\n\
    \   two's complement notation.  The most and least significant bytes are\n   0\
    \ and 3, respectively.  Integers are declared as follows:\n         int identifier;\n\
    \           (MSB)                   (LSB)\n         +-------+-------+-------+-------+\n\
    \         |byte 0 |byte 1 |byte 2 |byte 3 |                      INTEGER\n   \
    \      +-------+-------+-------+-------+\n         <------------32 bits------------>\n"
- title: 4.2.  Unsigned Integer
  contents:
  - "4.2.  Unsigned Integer\n   An XDR unsigned integer is a 32-bit datum that encodes\
    \ a non-negative\n   integer in the range [0,4294967295].  It is represented by\
    \ an\n   unsigned binary number whose most and least significant bytes are 0\n\
    \   and 3, respectively.  An unsigned integer is declared as follows:\n      \
    \   unsigned int identifier;\n           (MSB)                   (LSB)\n     \
    \       +-------+-------+-------+-------+\n            |byte 0 |byte 1 |byte 2\
    \ |byte 3 |           UNSIGNED INTEGER\n            +-------+-------+-------+-------+\n\
    \            <------------32 bits------------>\n"
- title: 4.3.  Enumeration
  contents:
  - "4.3.  Enumeration\n   Enumerations have the same representation as signed integers.\n\
    \   Enumerations are handy for describing subsets of the integers.\n   Enumerated\
    \ data is declared as follows:\n         enum { name-identifier = constant, ...\
    \ } identifier;\n   For example, the three colors red, yellow, and blue could\
    \ be\n   described by an enumerated type:\n         enum { RED = 2, YELLOW = 3,\
    \ BLUE = 5 } colors;\n   It is an error to encode as an enum any integer other\
    \ than those that\n   have been given assignments in the enum declaration.\n"
- title: 4.4.  Boolean
  contents:
  - "4.4.  Boolean\n   Booleans are important enough and occur frequently enough to\
    \ warrant\n   their own explicit type in the standard.  Booleans are declared\
    \ as\n   follows:\n         bool identifier;\n   This is equivalent to:\n    \
    \     enum { FALSE = 0, TRUE = 1 } identifier;\n"
- title: 4.5.  Hyper Integer and Unsigned Hyper Integer
  contents:
  - "4.5.  Hyper Integer and Unsigned Hyper Integer\n   The standard also defines\
    \ 64-bit (8-byte) numbers called hyper\n   integers and unsigned hyper integers.\
    \  Their representations are the\n   obvious extensions of integer and unsigned\
    \ integer defined above.\n   They are represented in two's complement notation.\
    \  The most and\n   least significant bytes are 0 and 7, respectively.  Their\n\
    \   declarations:\n   hyper identifier; unsigned hyper identifier;\n        (MSB)\
    \                                                   (LSB)\n      +-------+-------+-------+-------+-------+-------+-------+-------+\n\
    \      |byte 0 |byte 1 |byte 2 |byte 3 |byte 4 |byte 5 |byte 6 |byte 7 |\n   \
    \   +-------+-------+-------+-------+-------+-------+-------+-------+\n      <----------------------------64\
    \ bits---------------------------->\n                                        \
    \         HYPER INTEGER\n                                                 UNSIGNED\
    \ HYPER INTEGER\n"
- title: 4.6.  Floating-Point
  contents:
  - "4.6.  Floating-Point\n   The standard defines the floating-point data type \"\
    float\" (32 bits or\n   4 bytes).  The encoding used is the IEEE standard for\
    \ normalized\n   single-precision floating-point numbers [IEEE].  The following\
    \ three\n   fields describe the single-precision floating-point number:\n    \
    \  S: The sign of the number.  Values 0 and 1 represent positive and\n       \
    \  negative, respectively.  One bit.\n      E: The exponent of the number, base\
    \ 2.  8 bits are devoted to this\n         field.  The exponent is biased by 127.\n\
    \      F: The fractional part of the number's mantissa, base 2.  23 bits\n   \
    \      are devoted to this field.\n   Therefore, the floating-point number is\
    \ described by:\n         (-1)**S * 2**(E-Bias) * 1.F\n   It is declared as follows:\n\
    \         float identifier;\n         +-------+-------+-------+-------+\n    \
    \     |byte 0 |byte 1 |byte 2 |byte 3 |              SINGLE-PRECISION\n      \
    \   S|   E   |           F          |         FLOATING-POINT NUMBER\n        \
    \ +-------+-------+-------+-------+\n         1|<- 8 ->|<-------23 bits------>|\n\
    \         <------------32 bits------------>\n   Just as the most and least significant\
    \ bytes of a number are 0 and 3,\n   the most and least significant bits of a\
    \ single-precision floating-\n   point number are 0 and 31.  The beginning bit\
    \ (and most significant\n   bit) offsets of S, E, and F are 0, 1, and 9, respectively.\
    \  Note that\n   these numbers refer to the mathematical positions of the bits,\
    \ and\n   NOT to their actual physical locations (which vary from medium to\n\
    \   medium).\n   The IEEE specifications should be consulted concerning the encoding\n\
    \   for signed zero, signed infinity (overflow), and denormalized numbers\n  \
    \ (underflow) [IEEE].  According to IEEE specifications, the \"NaN\" (not\n  \
    \ a number) is system dependent and should not be interpreted within\n   XDR as\
    \ anything other than \"NaN\".\n"
- title: 4.7.  Double-Precision Floating-Point
  contents:
  - "4.7.  Double-Precision Floating-Point\n   The standard defines the encoding for\
    \ the double-precision floating-\n   point data type \"double\" (64 bits or 8\
    \ bytes).  The encoding used is\n   the IEEE standard for normalized double-precision\
    \ floating-point\n   numbers [IEEE].  The standard encodes the following three\
    \ fields,\n   which describe the double-precision floating-point number:\n   \
    \   S: The sign of the number.  Values 0 and 1 represent positive and\n      \
    \      negative, respectively.  One bit.\n      E: The exponent of the number,\
    \ base 2.  11 bits are devoted to\n            this field.  The exponent is biased\
    \ by 1023.\n      F: The fractional part of the number's mantissa, base 2.  52\
    \ bits\n            are devoted to this field.\n   Therefore, the floating-point\
    \ number is described by:\n         (-1)**S * 2**(E-Bias) * 1.F\n   It is declared\
    \ as follows:\n         double identifier;\n         +------+------+------+------+------+------+------+------+\n\
    \         |byte 0|byte 1|byte 2|byte 3|byte 4|byte 5|byte 6|byte 7|\n        \
    \ S|    E   |                    F                        |\n         +------+------+------+------+------+------+------+------+\n\
    \         1|<--11-->|<-----------------52 bits------------------->|\n        \
    \ <-----------------------64 bits------------------------->\n                \
    \                        DOUBLE-PRECISION FLOATING-POINT\n   Just as the most\
    \ and least significant bytes of a number are 0 and 3,\n   the most and least\
    \ significant bits of a double-precision floating-\n   point number are 0 and\
    \ 63.  The beginning bit (and most significant\n   bit) offsets of S, E, and F\
    \ are 0, 1, and 12, respectively.  Note\n   that these numbers refer to the mathematical\
    \ positions of the bits,\n   and NOT to their actual physical locations (which\
    \ vary from medium to\n   medium).\n   The IEEE specifications should be consulted\
    \ concerning the encoding\n   for signed zero, signed infinity (overflow), and\
    \ denormalized numbers\n   (underflow) [IEEE].  According to IEEE specifications,\
    \ the \"NaN\" (not\n   a number) is system dependent and should not be interpreted\
    \ within\n   XDR as anything other than \"NaN\".\n"
- title: 4.8.  Quadruple-Precision Floating-Point
  contents:
  - "4.8.  Quadruple-Precision Floating-Point\n   The standard defines the encoding\
    \ for the quadruple-precision\n   floating-point data type \"quadruple\" (128\
    \ bits or 16 bytes).  The\n   encoding used is designed to be a simple analog\
    \ of the encoding used\n   for single- and double-precision floating-point numbers\
    \ using one\n   form of IEEE double extended precision.  The standard encodes\
    \ the\n   following three fields, which describe the quadruple-precision\n   floating-point\
    \ number:\n      S: The sign of the number.  Values 0 and 1 represent positive\
    \ and\n         negative, respectively.  One bit.\n      E: The exponent of the\
    \ number, base 2.  15 bits are devoted to\n         this field.  The exponent\
    \ is biased by 16383.\n      F: The fractional part of the number's mantissa,\
    \ base 2.  112 bits\n         are devoted to this field.\n   Therefore, the floating-point\
    \ number is described by:\n         (-1)**S * 2**(E-Bias) * 1.F\n   It is declared\
    \ as follows:\n         quadruple identifier;\n         +------+------+------+------+------+------+-...--+------+\n\
    \         |byte 0|byte 1|byte 2|byte 3|byte 4|byte 5| ...  |byte15|\n        \
    \ S|    E       |                  F                      |\n         +------+------+------+------+------+------+-...--+------+\n\
    \         1|<----15---->|<-------------112 bits------------------>|\n        \
    \ <-----------------------128 bits------------------------>\n                \
    \                      QUADRUPLE-PRECISION FLOATING-POINT\n   Just as the most\
    \ and least significant bytes of a number are 0 and 3,\n   the most and least\
    \ significant bits of a quadruple-precision\n   floating-point number are 0 and\
    \ 127.  The beginning bit (and most\n   significant bit) offsets of S, E , and\
    \ F are 0, 1, and 16,\n   respectively.  Note that these numbers refer to the\
    \ mathematical\n   positions of the bits, and NOT to their actual physical locations\n\
    \   (which vary from medium to medium).\n   The encoding for signed zero, signed\
    \ infinity (overflow), and\n   denormalized numbers are analogs of the corresponding\
    \ encodings for\n   single and double-precision floating-point numbers [SPAR],\
    \ [HPRE].\n   The \"NaN\" encoding as it applies to quadruple-precision floating-\n\
    \   point numbers is system dependent and should not be interpreted\n   within\
    \ XDR as anything other than \"NaN\".\n"
- title: 4.9.  Fixed-Length Opaque Data
  contents:
  - "4.9.  Fixed-Length Opaque Data\n   At times, fixed-length uninterpreted data\
    \ needs to be passed among\n   machines.  This data is called \"opaque\" and is\
    \ declared as follows:\n         opaque identifier[n];\n   where the constant\
    \ n is the (static) number of bytes necessary to\n   contain the opaque data.\
    \  If n is not a multiple of four, then the n\n   bytes are followed by enough\
    \ (0 to 3) residual zero bytes, r, to make\n   the total byte count of the opaque\
    \ object a multiple of four.\n          0        1     ...\n      +--------+--------+...+--------+--------+...+--------+\n\
    \      | byte 0 | byte 1 |...|byte n-1|    0   |...|    0   |\n      +--------+--------+...+--------+--------+...+--------+\n\
    \      |<-----------n bytes---------->|<------r bytes------>|\n      |<-----------n+r\
    \ (where (n+r) mod 4 = 0)------------>|\n                                    \
    \               FIXED-LENGTH OPAQUE\n"
- title: 4.10.  Variable-Length Opaque Data
  contents:
  - "4.10.  Variable-Length Opaque Data\n   The standard also provides for variable-length\
    \ (counted) opaque data,\n   defined as a sequence of n (numbered 0 through n-1)\
    \ arbitrary bytes\n   to be the number n encoded as an unsigned integer (as described\n\
    \   below), and followed by the n bytes of the sequence.\n   Byte m of the sequence\
    \ always precedes byte m+1 of the sequence, and\n   byte 0 of the sequence always\
    \ follows the sequence's length (count).\n   If n is not a multiple of four, then\
    \ the n bytes are followed by\n   enough (0 to 3) residual zero bytes, r, to make\
    \ the total byte count\n   a multiple of four.  Variable-length opaque data is\
    \ declared in the\n   following way:\n         opaque identifier<m>;\n      or\n\
    \         opaque identifier<>;\n   The constant m denotes an upper bound of the\
    \ number of bytes that the\n   sequence may contain.  If m is not specified, as\
    \ in the second\n   declaration, it is assumed to be (2**32) - 1, the maximum\
    \ length.\n   The constant m would normally be found in a protocol specification.\n\
    \   For example, a filing protocol may state that the maximum data\n   transfer\
    \ size is 8192 bytes, as follows:\n         opaque filedata<8192>;\n         \
    \   0     1     2     3     4     5   ...\n         +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+\n\
    \         |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |\n  \
    \       +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+\n    \
    \     |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|\n      \
    \                           |<----n+r (where (n+r) mod 4 = 0)---->|\n        \
    \                                          VARIABLE-LENGTH OPAQUE\n   It is an\
    \ error to encode a length greater than the maximum described\n   in the specification.\n"
- title: 4.11.  String
  contents:
  - "4.11.  String\n   The standard defines a string of n (numbered 0 through n-1)\
    \ ASCII\n   bytes to be the number n encoded as an unsigned integer (as described\n\
    \   above), and followed by the n bytes of the string.  Byte m of the\n   string\
    \ always precedes byte m+1 of the string, and byte 0 of the\n   string always\
    \ follows the string's length.  If n is not a multiple of\n   four, then the n\
    \ bytes are followed by enough (0 to 3) residual zero\n   bytes, r, to make the\
    \ total byte count a multiple of four.  Counted\n   byte strings are declared\
    \ as follows:\n         string object<m>;\n      or\n         string object<>;\n\
    \   The constant m denotes an upper bound of the number of bytes that a\n   string\
    \ may contain.  If m is not specified, as in the second\n   declaration, it is\
    \ assumed to be (2**32) - 1, the maximum length.\n   The constant m would normally\
    \ be found in a protocol specification.\n   For example, a filing protocol may\
    \ state that a file name can be no\n   longer than 255 bytes, as follows:\n  \
    \       string filename<255>;\n            0     1     2     3     4     5   ...\n\
    \         +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+\n  \
    \       |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |\n    \
    \     +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+\n      \
    \   |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|\n        \
    \                         |<----n+r (where (n+r) mod 4 = 0)---->|\n          \
    \                                                        STRING\n   It is an error\
    \ to encode a length greater than the maximum described\n   in the specification.\n"
- title: 4.12.  Fixed-Length Array
  contents:
  - "4.12.  Fixed-Length Array\n   Declarations for fixed-length arrays of homogeneous\
    \ elements are in\n   the following form:\n         type-name identifier[n];\n\
    \   Fixed-length arrays of elements numbered 0 through n-1 are encoded by\n  \
    \ individually encoding the elements of the array in their natural\n   order,\
    \ 0 through n-1.  Each element's size is a multiple of four\n   bytes.  Though\
    \ all elements are of the same type, the elements may\n   have different sizes.\
    \  For example, in a fixed-length array of\n   strings, all elements are of type\
    \ \"string\", yet each element will\n   vary in its length.\n         +---+---+---+---+---+---+---+---+...+---+---+---+---+\n\
    \         |   element 0   |   element 1   |...|  element n-1  |\n         +---+---+---+---+---+---+---+---+...+---+---+---+---+\n\
    \         |<--------------------n elements------------------->|\n            \
    \                                   FIXED-LENGTH ARRAY\n"
- title: 4.13.  Variable-Length Array
  contents:
  - "4.13.  Variable-Length Array\n   Counted arrays provide the ability to encode\
    \ variable-length arrays\n   of homogeneous elements.  The array is encoded as\
    \ the element count n\n   (an unsigned integer) followed by the encoding of each\
    \ of the array's\n   elements, starting with element 0 and progressing through\
    \ element\n   n-1.  The declaration for variable-length arrays follows this form:\n\
    \         type-name identifier<m>;\n      or\n         type-name identifier<>;\n\
    \   The constant m specifies the maximum acceptable element count of an\n   array;\
    \ if m is not specified, as in the second declaration, it is\n   assumed to be\
    \ (2**32) - 1.\n           0  1  2  3\n         +--+--+--+--+--+--+--+--+--+--+--+--+...+--+--+--+--+\n\
    \         |     n     | element 0 | element 1 |...|element n-1|\n         +--+--+--+--+--+--+--+--+--+--+--+--+...+--+--+--+--+\n\
    \         |<-4 bytes->|<--------------n elements------------->|\n            \
    \                                             COUNTED ARRAY\n   It is an error\
    \ to encode a value of n that is greater than the\n   maximum described in the\
    \ specification.\n"
- title: 4.14.  Structure
  contents:
  - "4.14.  Structure\n   Structures are declared as follows:\n         struct {\n\
    \            component-declaration-A;\n            component-declaration-B;\n\
    \            ...\n         } identifier;\n   The components of the structure are\
    \ encoded in the order of their\n   declaration in the structure.  Each component's\
    \ size is a multiple of\n   four bytes, though the components may be different\
    \ sizes.\n         +-------------+-------------+...\n         | component A |\
    \ component B |...                      STRUCTURE\n         +-------------+-------------+...\n"
- title: 4.15.  Discriminated Union
  contents:
  - "4.15.  Discriminated Union\n   A discriminated union is a type composed of a\
    \ discriminant followed\n   by a type selected from a set of prearranged types\
    \ according to the\n   value of the discriminant.  The type of discriminant is\
    \ either \"int\",\n   \"unsigned int\", or an enumerated type, such as \"bool\"\
    .  The component\n   types are called \"arms\" of the union and are preceded by\
    \ the value of\n   the discriminant that implies their encoding.  Discriminated\
    \ unions\n   are declared as follows:\n         union switch (discriminant-declaration)\
    \ {\n         case discriminant-value-A:\n            arm-declaration-A;\n   \
    \      case discriminant-value-B:\n            arm-declaration-B;\n         ...\n\
    \         default: default-declaration;\n         } identifier;\n   Each \"case\"\
    \ keyword is followed by a legal value of the discriminant.\n   The default arm\
    \ is optional.  If it is not specified, then a valid\n   encoding of the union\
    \ cannot take on unspecified discriminant values.\n   The size of the implied\
    \ arm is always a multiple of four bytes.\n   The discriminated union is encoded\
    \ as its discriminant followed by\n   the encoding of the implied arm.\n     \
    \      0   1   2   3\n         +---+---+---+---+---+---+---+---+\n         | \
    \ discriminant |  implied arm  |          DISCRIMINATED UNION\n         +---+---+---+---+---+---+---+---+\n\
    \         |<---4 bytes--->|\n"
- title: 4.16.  Void
  contents:
  - "4.16.  Void\n   An XDR void is a 0-byte quantity.  Voids are useful for describing\n\
    \   operations that take no data as input or no data as output.  They are\n  \
    \ also useful in unions, where some arms may contain data and others do\n   not.\
    \  The declaration is simply as follows:\n         void;\n   Voids are illustrated\
    \ as follows:\n           ++\n           ||                                  \
    \                   VOID\n           ++\n         --><-- 0 bytes\n"
- title: 4.17.  Constant
  contents:
  - "4.17.  Constant\n   The data declaration for a constant follows this form:\n\
    \         const name-identifier = n;\n   \"const\" is used to define a symbolic\
    \ name for a constant; it does not\n   declare any data.  The symbolic constant\
    \ may be used anywhere a\n   regular constant may be used.  For example, the following\
    \ defines a\n   symbolic constant DOZEN, equal to 12.\n         const DOZEN =\
    \ 12;\n"
- title: 4.18.  Typedef
  contents:
  - "4.18.  Typedef\n   \"typedef\" does not declare any data either, but serves to\
    \ define new\n   identifiers for declaring data.  The syntax is:\n         typedef\
    \ declaration;\n   The new type name is actually the variable name in the declaration\n\
    \   part of the typedef.  For example, the following defines a new type\n   called\
    \ \"eggbox\" using an existing type called \"egg\":\n         typedef egg eggbox[DOZEN];\n\
    \   Variables declared using the new type name have the same type as the\n   new\
    \ type name would have in the typedef, if it were considered a\n   variable. \
    \ For example, the following two declarations are equivalent\n   in declaring\
    \ the variable \"fresheggs\":\n         eggbox  fresheggs; egg     fresheggs[DOZEN];\n\
    \   When a typedef involves a struct, enum, or union definition, there is\n  \
    \ another (preferred) syntax that may be used to define the same type.\n   In\
    \ general, a typedef of the following form:\n         typedef <<struct, union,\
    \ or enum definition>> identifier;\n   may be converted to the alternative form\
    \ by removing the \"typedef\"\n   part and placing the identifier after the \"\
    struct\", \"union\", or\n   \"enum\" keyword, instead of at the end.  For example,\
    \ here are the two\n   ways to define the type \"bool\":\n         typedef enum\
    \ {    /* using typedef */\n            FALSE = 0,\n            TRUE = 1\n   \
    \      } bool;\n         enum bool {       /* preferred alternative */\n     \
    \       FALSE = 0,\n            TRUE = 1\n         };\n   This syntax is preferred\
    \ because one does not have to wait until the\n   end of a declaration to figure\
    \ out the name of the new type.\n"
- title: 4.19.  Optional-Data
  contents:
  - "4.19.  Optional-Data\n   Optional-data is one kind of union that occurs so frequently\
    \ that we\n   give it a special syntax of its own for declaring it.  It is declared\n\
    \   as follows:\n         type-name *identifier;\n   This is equivalent to the\
    \ following union:\n         union switch (bool opted) {\n         case TRUE:\n\
    \            type-name element;\n         case FALSE:\n            void;\n   \
    \      } identifier;\n   It is also equivalent to the following variable-length\
    \ array\n   declaration, since the boolean \"opted\" can be interpreted as the\n\
    \   length of the array:\n         type-name identifier<1>;\n   Optional-data\
    \ is not so interesting in itself, but it is very useful\n   for describing recursive\
    \ data-structures such as linked-lists and\n   trees.  For example, the following\
    \ defines a type \"stringlist\" that\n   encodes lists of zero or more arbitrary\
    \ length strings:\n        struct stringentry {\n           string item<>;\n \
    \          stringentry *next;\n        };\n        typedef stringentry *stringlist;\n\
    \   It could have been equivalently declared as the following union:\n       \
    \  union stringlist switch (bool opted) {\n         case TRUE:\n            struct\
    \ {\n               string item<>;\n               stringlist next;\n        \
    \    } element;\n         case FALSE:\n            void;\n         };\n   or as\
    \ a variable-length array:\n        struct stringentry {\n           string item<>;\n\
    \           stringentry next<1>;\n        };\n        typedef stringentry stringlist<1>;\n\
    \   Both of these declarations obscure the intention of the stringlist\n   type,\
    \ so the optional-data declaration is preferred over both of\n   them.  The optional-data\
    \ type also has a close correlation to how\n   recursive data structures are represented\
    \ in high-level languages\n   such as Pascal or C by use of pointers.  In fact,\
    \ the syntax is the\n   same as that of the C language for pointers.\n"
- title: 4.20.  Areas for Future Enhancement
  contents:
  - "4.20.  Areas for Future Enhancement\n   The XDR standard lacks representations\
    \ for bit fields and bitmaps,\n   since the standard is based on bytes.  Also\
    \ missing are packed (or\n   binary-coded) decimals.\n   The intent of the XDR\
    \ standard was not to describe every kind of data\n   that people have ever sent\
    \ or will ever want to send from machine to\n   machine.  Rather, it only describes\
    \ the most commonly used data-types\n   of high-level languages such as Pascal\
    \ or C so that applications\n   written in these languages will be able to communicate\
    \ easily over\n   some medium.\n   One could imagine extensions to XDR that would\
    \ let it describe almost\n   any existing protocol, such as TCP.  The minimum\
    \ necessary for this\n   is support for different block sizes and byte-orders.\
    \  The XDR\n   discussed here could then be considered the 4-byte big-endian member\n\
    \   of a larger XDR family.\n"
- title: 5.  Discussion
  contents:
  - "5.  Discussion\n   (1) Why use a language for describing data?  What's wrong\
    \ with\n       diagrams?\n   There are many advantages in using a data-description\
    \ language such\n   as XDR versus using diagrams.  Languages are more formal than\n\
    \   diagrams and lead to less ambiguous descriptions of data.  Languages\n   are\
    \ also easier to understand and allow one to think of other issues\n   instead\
    \ of the low-level details of bit encoding.  Also, there is a\n   close analogy\
    \ between the types of XDR and a high-level language such\n   as C or Pascal.\
    \  This makes the implementation of XDR encoding and\n   decoding modules an easier\
    \ task.  Finally, the language specification\n   itself is an ASCII string that\
    \ can be passed from machine to machine\n   to perform on-the-fly data interpretation.\n\
    \   (2) Why is there only one byte-order for an XDR unit?\n   Supporting two byte-orderings\
    \ requires a higher-level protocol for\n   determining in which byte-order the\
    \ data is encoded.  Since XDR is\n   not a protocol, this can't be done.  The\
    \ advantage of this, though,\n   is that data in XDR format can be written to\
    \ a magnetic tape, for\n   example, and any machine will be able to interpret\
    \ it, since no\n   higher-level protocol is necessary for determining the byte-order.\n\
    \   (3) Why is the XDR byte-order big-endian instead of little-endian?\n     \
    \  Isn't this unfair to little-endian machines such as the VAX(r),\n       which\
    \ has to convert from one form to the other?\n   Yes, it is unfair, but having\
    \ only one byte-order means you have to\n   be unfair to somebody.  Many architectures,\
    \ such as the Motorola\n   68000* and IBM 370*, support the big-endian byte-order.\n\
    \   (4) Why is the XDR unit four bytes wide?\n   There is a tradeoff in choosing\
    \ the XDR unit size.  Choosing a small\n   size, such as two, makes the encoded\
    \ data small, but causes alignment\n   problems for machines that aren't aligned\
    \ on these boundaries.  A\n   large size, such as eight, means the data will be\
    \ aligned on\n   virtually every machine, but causes the encoded data to grow\
    \ too big.\n   We chose four as a compromise.  Four is big enough to support most\n\
    \   architectures efficiently, except for rare machines such as the\n   eight-byte-aligned\
    \ Cray*.  Four is also small enough to keep the\n   encoded data restricted to\
    \ a reasonable size.\n   (5) Why must variable-length data be padded with zeros?\n\
    \   It is desirable that the same data encode into the same thing on all\n   machines,\
    \ so that encoded data can be meaningfully compared or\n   checksummed.  Forcing\
    \ the padded bytes to be zero ensures this.\n   (6) Why is there no explicit data-typing?\n\
    \   Data-typing has a relatively high cost for what small advantages it\n   may\
    \ have.  One cost is the expansion of data due to the inserted type\n   fields.\
    \  Another is the added cost of interpreting these type fields\n   and acting\
    \ accordingly.  And most protocols already know what type\n   they expect, so\
    \ data-typing supplies only redundant information.\n   However, one can still\
    \ get the benefits of data-typing using XDR.\n   One way is to encode two things:\
    \ first, a string that is the XDR data\n   description of the encoded data, and\
    \ then the encoded data itself.\n   Another way is to assign a value to all the\
    \ types in XDR, and then\n   define a universal type that takes this value as\
    \ its discriminant and\n   for each value, describes the corresponding data type.\n"
- title: 6.  The XDR Language Specification
  contents:
  - '6.  The XDR Language Specification

    '
- title: 6.1.  Notational Conventions
  contents:
  - "6.1.  Notational Conventions\n   This specification uses an extended Back-Naur\
    \ Form notation for\n   describing the XDR language.  Here is a brief description\
    \ of the\n   notation:\n   (1) The characters '|', '(', ')', '[', ']', '\"', and\
    \ '*' are special.\n   (2) Terminal symbols are strings of any characters surrounded\
    \ by\n   double quotes.  (3) Non-terminal symbols are strings of non-special\n\
    \   characters.  (4) Alternative items are separated by a vertical bar\n   (\"\
    |\").  (5) Optional items are enclosed in brackets.  (6) Items are\n   grouped\
    \ together by enclosing them in parentheses.  (7) A '*'\n   following an item\
    \ means 0 or more occurrences of that item.\n   For example, consider the following\
    \ pattern:\n         \"a \" \"very\" (\", \" \"very\")* [\" cold \" \"and \"]\
    \  \" rainy \"\n         (\"day\" | \"night\")\n   An infinite number of strings\
    \ match this pattern.  A few of them are:\n         \"a very rainy day\"\n   \
    \      \"a very, very rainy day\"\n         \"a very cold and  rainy day\"\n \
    \        \"a very, very, very cold and  rainy night\"\n"
- title: 6.2.  Lexical Notes
  contents:
  - "6.2.  Lexical Notes\n   (1) Comments begin with '/*' and terminate with '*/'.\
    \  (2) White\n   space serves to separate items and is otherwise ignored.  (3)\
    \ An\n   identifier is a letter followed by an optional sequence of letters,\n\
    \   digits, or underbar ('_').  The case of identifiers is not ignored.\n   (4)\
    \ A decimal constant expresses a number in base 10 and is a\n   sequence of one\
    \ or more decimal digits, where the first digit is not\n   a zero, and is optionally\
    \ preceded by a minus-sign ('-').  (5) A\n   hexadecimal constant expresses a\
    \ number in base 16, and must be\n   preceded by '0x', followed by one or hexadecimal\
    \ digits ('A', 'B',\n   'C', 'D', E', 'F', 'a', 'b', 'c', 'd', 'e', 'f', '0',\
    \ '1', '2', '3',\n   '4', '5', '6', '7', '8', '9').  (6) An octal constant expresses\
    \ a\n   number in base 8, always leads with digit 0, and is a sequence of one\n\
    \   or more octal digits ('0', '1', '2', '3', '4', '5', '6', '7').\n"
- title: 6.3.  Syntax Information
  contents:
  - "6.3.  Syntax Information\n      declaration:\n           type-specifier identifier\n\
    \         | type-specifier identifier \"[\" value \"]\"\n         | type-specifier\
    \ identifier \"<\" [ value ] \">\"\n         | \"opaque\" identifier \"[\" value\
    \ \"]\"\n         | \"opaque\" identifier \"<\" [ value ] \">\"\n         | \"\
    string\" identifier \"<\" [ value ] \">\"\n         | type-specifier \"*\" identifier\n\
    \         | \"void\"\n      value:\n           constant\n         | identifier\n\
    \      constant:\n         decimal-constant | hexadecimal-constant | octal-constant\n\
    \      type-specifier:\n           [ \"unsigned\" ] \"int\"\n         | [ \"unsigned\"\
    \ ] \"hyper\"\n         | \"float\"\n         | \"double\"\n         | \"quadruple\"\
    \n         | \"bool\"\n         | enum-type-spec\n         | struct-type-spec\n\
    \         | union-type-spec\n         | identifier\n      enum-type-spec:\n  \
    \       \"enum\" enum-body\n      enum-body:\n         \"{\"\n            ( identifier\
    \ \"=\" value )\n            ( \",\" identifier \"=\" value )*\n         \"}\"\
    \n      struct-type-spec:\n         \"struct\" struct-body\n      struct-body:\n\
    \         \"{\"\n            ( declaration \";\" )\n            ( declaration\
    \ \";\" )*\n         \"}\"\n      union-type-spec:\n         \"union\" union-body\n\
    \      union-body:\n         \"switch\" \"(\" declaration \")\" \"{\"\n      \
    \      case-spec\n            case-spec *\n            [ \"default\" \":\" declaration\
    \ \";\" ]\n         \"}\"\n      case-spec:\n        ( \"case\" value \":\")\n\
    \        ( \"case\" value \":\") *\n        declaration \";\"\n      constant-def:\n\
    \         \"const\" identifier \"=\" constant \";\"\n      type-def:\n       \
    \    \"typedef\" declaration \";\"\n         | \"enum\" identifier enum-body \"\
    ;\"\n         | \"struct\" identifier struct-body \";\"\n         | \"union\"\
    \ identifier union-body \";\"\n      definition:\n           type-def\n      \
    \   | constant-def\n      specification:\n           definition *\n"
- title: 6.4.  Syntax Notes
  contents:
  - "6.4.  Syntax Notes\n   (1) The following are keywords and cannot be used as identifiers:\n\
    \   \"bool\", \"case\", \"const\", \"default\", \"double\", \"quadruple\", \"\
    enum\",\n   \"float\", \"hyper\", \"int\", \"opaque\", \"string\", \"struct\"\
    , \"switch\",\n   \"typedef\", \"union\", \"unsigned\", and \"void\".\n   (2)\
    \ Only unsigned constants may be used as size specifications for\n   arrays. \
    \ If an identifier is used, it must have been declared\n   previously as an unsigned\
    \ constant in a \"const\" definition.\n   (3) Constant and type identifiers within\
    \ the scope of a specification\n   are in the same name space and must be declared\
    \ uniquely within this\n   scope.\n   (4) Similarly, variable names must be unique\
    \ within the scope of\n   struct and union declarations.  Nested struct and union\
    \ declarations\n   create new scopes.\n   (5) The discriminant of a union must\
    \ be of a type that evaluates to\n   an integer.  That is, \"int\", \"unsigned\
    \ int\", \"bool\", an enumerated\n   type, or any typedefed type that evaluates\
    \ to one of these is legal.\n   Also, the case values must be one of the legal\
    \ values of the\n   discriminant.  Finally, a case value may not be specified\
    \ more than\n   once within the scope of a union declaration.\n"
- title: 7.  An Example of an XDR Data Description
  contents:
  - "7.  An Example of an XDR Data Description\n   Here is a short XDR data description\
    \ of a thing called a \"file\",\n   which might be used to transfer files from\
    \ one machine to another.\n         const MAXUSERNAME = 32;     /* max length\
    \ of a user name */\n         const MAXFILELEN = 65535;   /* max length of a file\
    \      */\n         const MAXNAMELEN = 255;     /* max length of a file name */\n\
    \         /*\n          * Types of files:\n          */\n         enum filekind\
    \ {\n            TEXT = 0,       /* ascii data */\n            DATA = 1,     \
    \  /* raw data   */\n            EXEC = 2        /* executable */\n         };\n\
    \         /*\n          * File information, per kind of file:\n          */\n\
    \         union filetype switch (filekind kind) {\n         case TEXT:\n     \
    \       void;                           /* no extra information */\n         case\
    \ DATA:\n            string creator<MAXNAMELEN>;     /* data creator         */\n\
    \         case EXEC:\n            string interpretor<MAXNAMELEN>; /* program interpretor\
    \  */\n         };\n         /*\n          * A complete file:\n          */\n\
    \         struct file {\n            string filename<MAXNAMELEN>; /* name of file\
    \    */\n            filetype type;               /* info about file */\n    \
    \        string owner<MAXUSERNAME>;   /* owner of file   */\n            opaque\
    \ data<MAXFILELEN>;     /* file data       */\n         };\n   Suppose now that\
    \ there is a user named \"john\" who wants to store his\n   lisp program \"sillyprog\"\
    \ that contains just the data \"(quit)\".  His\n   file would be encoded as follows:\n\
    \       OFFSET  HEX BYTES       ASCII    COMMENTS\n       ------  ---------  \
    \     -----    --------\n        0      00 00 00 09     ....     -- length of\
    \ filename = 9\n        4      73 69 6c 6c     sill     -- filename characters\n\
    \        8      79 70 72 6f     ypro     -- ... and more characters ...\n    \
    \   12      67 00 00 00     g...     -- ... and 3 zero-bytes of fill\n       16\
    \      00 00 00 02     ....     -- filekind is EXEC = 2\n       20      00 00\
    \ 00 04     ....     -- length of interpretor = 4\n       24      6c 69 73 70\
    \     lisp     -- interpretor characters\n       28      00 00 00 04     ....\
    \     -- length of owner = 4\n       32      6a 6f 68 6e     john     -- owner\
    \ characters\n       36      00 00 00 06     ....     -- length of file data =\
    \ 6\n       40      28 71 75 69     (qui     -- file data bytes ...\n       44\
    \      74 29 00 00     t)..     -- ... and 2 zero-bytes of fill\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   XDR is a data description language, not a protocol,\
    \ and hence it does\n   not inherently give rise to any particular security considerations.\n\
    \   Protocols that carry XDR-formatted data, such as NFSv4, are\n   responsible\
    \ for providing any necessary security services to secure\n   the data they transport.\n\
    \   Care must be take to properly encode and decode data to avoid\n   attacks.\
    \  Known and avoidable risks include:\n   *    Buffer overflow attacks.  Where\
    \ feasible, protocols should be\n        defined with explicit limits (via the\
    \ \"<\" [ value ] \">\" notation\n        instead of \"<\" \">\") on elements\
    \ with variable-length data types.\n        Regardless of the feasibility of an\
    \ explicit limit on the\n        variable length of an element of a given protocol,\
    \ decoders need\n        to ensure the incoming size does not exceed the length\
    \ of any\n        provisioned receiver buffers.\n   *    Nul octets embedded in\
    \ an encoded value of type string.  If the\n        decoder's native string format\
    \ uses nul-terminated strings, then\n        the apparent size of the decoded\
    \ object will be less than the\n        amount of memory allocated for the string.\
    \  Some memory\n        deallocation interfaces take a size argument.  The caller\
    \ of the\n        deallocation interface would likely determine the size of the\n\
    \        string by counting to the location of the nul octet and adding\n    \
    \    one.  This discrepancy can cause memory leakage (because less\n        memory\
    \ is actually returned to the free pool than allocated),\n        leading to system\
    \ failure and a denial of service attack.\n   *    Decoding of characters in strings\
    \ that are legal ASCII\n        characters but nonetheless are illegal for the\
    \ intended\n        application.  For example, some operating systems treat the\
    \ '/'\n        character as a component separator in path names.  For a\n    \
    \    protocol that encodes a string in the argument to a file\n        creation\
    \ operation, the decoder needs to ensure that '/' is not\n        inside the component\
    \ name.  Otherwise, a file with an illegal\n        '/' in its name will be created,\
    \ making it difficult to remove,\n        and is therefore a denial of service\
    \ attack.\n   *    Denial of service caused by recursive decoder or encoder\n\
    \        subroutines.  A recursive decoder or encoder might process data\n   \
    \     that has a structured type with a member of type optional data\n       \
    \ that directly or indirectly refers to the structured type (i.e.,\n        a\
    \ linked list).  For example,\n              struct m {\n                int x;\n\
    \                struct m *next;\n              };\n        An encoder or decoder\
    \ subroutine might be written to recursively\n        call itself each time another\
    \ element of type \"struct m\" is\n        found.  An attacker could construct\
    \ a long linked list of\n        \"struct m\" elements in the request or response,\
    \ which then\n        causes a stack overflow on the decoder or encoder.  Decoders\
    \ and\n        encoders should be written non-recursively or impose a limit on\n\
    \        list length.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   It is possible, if not likely, that new data types\
    \ will be added to\n   XDR in the future.  The process for adding new types is\
    \ via a\n   standards track RFC and not registration of new types with IANA.\n\
    \   Standards track RFCs that update or replace this document should be\n   documented\
    \ as such in the RFC Editor's database of RFCs.\n"
- title: 10.  Trademarks and Owners
  contents:
  - "10.  Trademarks and Owners\n   SUN WORKSTATION  Sun Microsystems, Inc.\n   VAX\
    \              Hewlett-Packard Company\n   IBM-PC           International Business\
    \ Machines Corporation\n   Cray             Cray Inc.\n   NFS              Sun\
    \ Microsystems, Inc.\n   Ethernet         Xerox Corporation.\n   Motorola 68000\
    \   Motorola, Inc.\n   IBM 370          International Business Machines Corporation\n"
- title: 11.  ANSI/IEEE Standard 754-1985
  contents:
  - "11.  ANSI/IEEE Standard 754-1985\n   The definition of NaNs, signed zero and\
    \ infinity, and denormalized\n   numbers from [IEEE] is reproduced here for convenience.\
    \  The\n   definitions for quadruple-precision floating point numbers are\n  \
    \ analogs of those for single and double-precision floating point\n   numbers\
    \ and are defined in [IEEE].\n   In the following, 'S' stands for the sign bit,\
    \ 'E' for the exponent,\n   and 'F' for the fractional part.  The symbol 'u' stands\
    \ for an\n   undefined bit (0 or 1).\n   For single-precision floating point numbers:\n\
    \    Type                  S (1 bit)   E (8 bits)    F (23 bits)\n    ----   \
    \               ---------   ----------    -----------\n    signalling NaN    \
    \    u           255 (max)     .0uuuuu---u\n                                 \
    \                   (with at least\n                                         \
    \            one 1 bit)\n    quiet NaN             u           255 (max)     .1uuuuu---u\n\
    \    negative infinity     1           255 (max)     .000000---0\n    positive\
    \ infinity     0           255 (max)     .000000---0\n    negative zero      \
    \   1           0             .000000---0\n    positive zero         0       \
    \    0             .000000---0\n   For double-precision floating point numbers:\n\
    \    Type                  S (1 bit)   E (11 bits)   F (52 bits)\n    ----   \
    \               ---------   -----------   -----------\n    signalling NaN    \
    \    u           2047 (max)    .0uuuuu---u\n                                 \
    \                   (with at least\n                                         \
    \            one 1 bit)\n    quiet NaN             u           2047 (max)    .1uuuuu---u\n\
    \    negative infinity     1           2047 (max)    .000000---0\n    positive\
    \ infinity     0           2047 (max)    .000000---0\n    negative zero      \
    \   1           0             .000000---0\n    positive zero         0       \
    \    0             .000000---0\n   For quadruple-precision floating point numbers:\n\
    \    Type                  S (1 bit)   E (15 bits)   F (112 bits)\n    ----  \
    \                ---------   -----------   ------------\n    signalling NaN  \
    \      u           32767 (max)   .0uuuuu---u\n                               \
    \                     (with at least\n                                       \
    \              one 1 bit)\n    quiet NaN             u           32767 (max) \
    \  .1uuuuu---u\n    negative infinity     1           32767 (max)   .000000---0\n\
    \    positive infinity     0           32767 (max)   .000000---0\n    negative\
    \ zero         1           0             .000000---0\n    positive zero      \
    \   0           0             .000000---0\n   Subnormal numbers are represented\
    \ as follows:\n    Precision            Exponent       Value\n    ---------  \
    \          --------       -----\n    Single               0              (-1)**S\
    \ * 2**(-126) * 0.F\n    Double               0              (-1)**S * 2**(-1022)\
    \ * 0.F\n    Quadruple            0              (-1)**S * 2**(-16382) * 0.F\n"
- title: 12.  Normative References
  contents:
  - "12.  Normative References\n   [IEEE]  \"IEEE Standard for Binary Floating-Point\
    \ Arithmetic\",\n           ANSI/IEEE Standard 754-1985, Institute of Electrical\
    \ and\n           Electronics Engineers, August 1985.\n"
- title: 13.  Informative References
  contents:
  - "13.  Informative References\n   [KERN]  Brian W. Kernighan & Dennis M. Ritchie,\
    \ \"The C Programming\n           Language\", Bell Laboratories, Murray Hill,\
    \ New Jersey, 1978.\n   [COHE]  Danny Cohen, \"On Holy Wars and a Plea for Peace\"\
    , IEEE\n           Computer, October 1981.\n   [COUR]  \"Courier: The Remote Procedure\
    \ Call Protocol\", XEROX\n           Corporation, XSIS 038112, December 1981.\n\
    \   [SPAR]  \"The SPARC Architecture Manual: Version 8\", Prentice Hall,\n   \
    \        ISBN 0-13-825001-4.\n   [HPRE]  \"HP Precision Architecture Handbook\"\
    , June 1987, 5954-9906.\n"
- title: 14.  Acknowledgements
  contents:
  - "14.  Acknowledgements\n   Bob Lyon was Sun's visible force behind ONC RPC in\
    \ the 1980s.  Sun\n   Microsystems, Inc., is listed as the author of RFC 1014.\
    \  Raj\n   Srinivasan and the rest of the old ONC RPC working group edited RFC\n\
    \   1014 into RFC 1832, from which this document is derived.  Mike Eisler\n  \
    \ and Bill Janssen submitted the implementation reports for this\n   standard.\
    \  Kevin Coffman, Benny Halevy, and Jon Peterson reviewed\n   this document and\
    \ gave feedback.  Peter Astrand and Bryan Olson\n   pointed out several errors\
    \ in RFC 1832 which are corrected in this\n   document.\n"
- title: Editor's Address
  contents:
  - "Editor's Address\n   Mike Eisler\n   5765 Chase Point Circle\n   Colorado Springs,\
    \ CO 80919\n   USA\n   Phone: 719-599-9026\n   EMail: email2mre-rfc4506@yahoo.com\n\
    \   Please address comments to: nfsv4@ietf.org\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
