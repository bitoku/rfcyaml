This document is being published for the information of the community.
It describes a protocol that is currently being deployed in a number of products.
Implementers should be aware of developments in the IETF Megaco Working Group and ITF T SG16 who are currently working on a potential successor to this protocol.
Abstract This document describes an application programming interface and a corresponding protocol (MGCP) for controlling Voice over IP (VoIP) Gateways from external call control elements.
MGCP assumes a call control architecture where the call control "intelligence"
is outside the gateways and handled by external call control elements.
The document is structured in 6 main sections:
The introduction presents the basic assumptions and the relation to other protocols such as H.323, RTSP, SAP or SIP.
The interface section presents a conceptual overview of the MGCP, presenting the naming conventions, the usage of the session description protocol SDP, and the procedures that compose MGCP:
Notifications Request, Notification, Create Connection, Modify Connection, Delete Connection, AuditEndpoint, AuditConnection and RestartInProgress.
The protocol description section presents the MGCP encodings, which are based on simple text formats, and the transmission procedure over UDP.
The security section presents the security requirement of MGCP, and its usage of IP security services (IPSEC).
The event packages section provides an initial definition of packages and event names.
The description of the changes made in combining SGCP 1.1 and IPDC to create MGCP 1.0.
This document describes an abstract application programming interface and a corresponding protocol (MGCP) for controlling Telephony Gateways from external call control elements called media gateway controllers or call agents.
A telephony gateway is a network element that provides conversion between the audio signals carried on telephone circuits and data packets carried over the Internet or over other packet networks.
Such gateways typically manage a large number of digital circuits.
Voice over ATM gateways, which operate much the same way as voice over IP trunking gateways, except that they interface to an ATM network.
Residential gateways, that provide a traditional analog (RJ11) interface to a Voice over IP network.
Examples of residential gateways include cable modem/cable set top boxes, xDSL devices, broad band wireless devices    Access gateways, that provide a traditional analog (RJ11) or digital PBX interface to a Voice over IP network.
Examples of access gateways include small scale voice over IP gateways.
Business gateways, that provide a traditional digital PBX interface or an integrated "soft PBX" interface to a Voice over IP network.
Network Access Servers, that can attach a "modem" to a telephone circuit and provide data access to the Internet.
We expect that, in the future, the same gateways will combine Voice over IP services and Network Access services.
Circuit switches, or packet switches, which can offer a control interface to an external call control element.
MGCP assumes a call control architecture where the call control "intelligence"
is outside the gateways and handled by external call control elements.
The MGCP assumes that these call control elements, or Call Agents, will synchronize with each other to send coherent commands to the gateways under their control.
MGCP does not define a mechanism for synchronizing Call Agents.
MGCP is, in essence, a master/slave protocol, where the gateways are expected to execute commands sent by the Call Agents.
In consequence, this document specifies in great detail the expected behavior of the gateways, but only specify those parts of a call agent implementation, such as timer management, that are mandated for proper operation of the protocol.
MGCP assumes a connection model where the basic constructs are endpoints and connections.
Endpoints are sources or sinks of data and could be physical or virtual.
A gateway that terminates trunks is called a trunk gateway.
An interface on a gateway that terminates an analog POTS connection to a phone, key system, PBX, etc.
A gateway that terminates residential POTS lines (to phones) is called a residential gateway.
An example of a virtual endpoint is an audio source in an audio  content server.
Creation of physical endpoints requires hardware installation, while creation of virtual endpoints can be done by software.
Connections may be either point to point or multipoint.
A point to point connection is an association between two endpoints with the purpose of transmitting data between these endpoints.
Once this association is established for both endpoints, data transfer between these endpoints can take place.
A multipoint connection is established by connecting the endpoint to a multipoint session.
Transmission of audio packets using AAL2, or another adaptation layer, over an ATM network.
Transmission of packets over an internal connection, for example the TDM backplane or the interconnection bus of a gateway.
This is used, in particular, for "hairpin" connections, connections that terminate in a gateway but are immediately rerouted over the telephone network.
For point to point connections the endpoints of a connection could be in separate gateways or in the same gateway.
Relation with the H.323 standards
MGCP is designed as an internal protocol within a distributed system that appears to the outside as a single VoIP gateway.
This system is composed of a Call Agent, that may or may not be distributed over several computer platforms, and of a set of gateways, including at least one "media gateway" that perform the conversion of media signals between circuits and packets,  and at least one "signalling gateway" when connecting to an SS7 controlled network.
In a typical configuration, this distributed gateway system will interface on one side with one or more telephony (i.e. circuit) switches, and on the other side with H.323 conformant systems, as indicated in the following table:
In the MGCP model, the gateways focus on the audio signal translation function, while the Call Agent handles the signaling and call processing functions.
As a consequence, the Call Agent implements the "signaling" layers of the H.323 standard, and presents itself as an "H.323 Gatekeeper" or as one or more "H.323 Endpoints"  to the H.323 systems.
Relation with the IETF standards
While H.323 is the recognized standard for VoIP terminals, the IETF has also produced specifications for other types of multi media applications.
The latter three specifications are in fact alternative signaling standards that allow for the transmission of a session description to an interested party.
SAP is used by multicast session managers to distribute a multicast session description to a large group of recipients, SIP is used to invite an individual user to take part in a point to point or unicast session, RTSP is used to interface a server that provides real time data.
In all three cases, the session description is described according to SDP; when audio is transmitted, it is transmitted through the Real time Transport Protocol, RTP.
The distributed gateway systems and MGCP will enable PSTN telephony users to access sessions set up using SAP, SIP or RTSP.
The SDP standard has a pivotal status in this architecture.
We will see in the following description that we also use it to carry session descriptions in MGCP.
A communication channel between two switching systems.
E.g., a DS0 on a T1 or E1 line.
The interface functions provide for connection control and endpoint control.
Both use the same system model and the same naming conventions.
The MGCP assumes a connection model where the basic constructs are endpoints and connections.
Connections are grouped in calls.
One or more connections can belong to one call.
Connections and calls are set up at the initiative of one or several Call Agents.
Types of endpoints In the introduction, we presented several classes of gateways.
Such classifications, however, can be misleading.
Manufacturers can arbitrarily decide to provide several types of services in a single packaging.
A single product could well, for example, provide some trunk connections to telephony switches, some primary rate connections and some analog line interfaces, thus sharing the characteristics of what we described in the introduction as "trunking", "access" and "residential" gateways.
MGCP does not make assumptions about such groupings.
We simply assume that media gateways support collections of endpoints.
The type of the endpoint determines its functionalities.
In this section, we will develop the expected behavior of such end points.
This list is not limitative.
There may be other types of endpoints defined in the future, for example test endpoint that could be used to check network quality, or frame relay endpoints that could be used to managed audio channels multiplexed over a frame relay virtual circuit.
Digital channels provide an 8Khz 8bit service.
Such channels are found in trunk and ISDN interfaces.
They are typically part of digital multiplexes, such as T1, E1, T3 or E3 interfaces.
Media gateways that support such channels are capable of translating the digital signals received on the channel, which may be encoded according to A or mu law, using either the complete set of 8 bits or only 7 of these bits, into audio packets.
When the media gateway also supports a NAS service, the gateway shall be capable of receiving either audio encoded data (modem connection) or binary data (ISDN connection) and convert them into data packets.
The signals originating from these connections shall be mixed according to the connection "mode", as specified later in this document.
The precise number of connections that an endpoint support is a characteristic of the gateway, and may in fact vary according with the allocation of resource within the gateway.
In some cases, digital channels are used to carry signalling.
This is the case for example of SS7 "F" links, or ISDN "D" channels.
Media gateways that support these signalling functions shall be able to send and receive the signalling packets to and from a call agent, using the "back haul" procedures defined by the SIGTRAN working group of the IETF.
Digital channels are sometimes used in conjunction with channel associated signalling, such as "MF R2".
Media gateways that support these signalling functions shall be able to detect and produce the corresponding signals, such as for example "wink" or "A", according to the event signalling and reporting procedures defined in MGCP.
Analog line Analog lines can be used either as a "client" interface, providing service to a classic telephone unit, or as a "service" interface, allowing the gateway to send and receive analog calls.
When the media gateway also supports a NAS service, the gateway shall be capable of receiving audio encoded data (modem connection) and convert them into data packets.
The audio signals originating from these connections shall be mixed according to the connection "mode", as specified later in this document.
The precise number of connections that an endpoint support is a characteristic of the gateway, and may in fact vary according with the allocation of resource within the gateway.
A typical gateway should however be able to support two or three connections per endpoint, in order to provide services such as "call waiting" or "three ways calling".
Annoucement server access point An announcement server endpoint provides acces to an announcement service.
Under requests from the call agent, the announcement server will "play" a specified announcement.
The requests from the call agent will follow the event signalling and reporting procedures defined in MGCP.
A given announcement endpoint is not supposed to support more than one connection at a time.
If several connections were established to the same endpoint, then the same announcements would be played simultaneously over all the connections.
Connections to an announcement server are typically oneway, or "half duplex"   the announcement server is not expected to listen the audio signals from the connection.
Interactive Voice Response access point
An Interactive Voice Response (IVR) endpoint provides acces to an IVR service.
Under requests from the call agent, the IVR server will "play" announcements and tones, and will "listen" to responses from the user.
The requests from the call agent will follow the event signalling and reporting procedures defined in MGCP.
A given IVR endpoint is not supposed to support more than one connection at a time.
If several connections were established to the same endpoint, then the same tones and announcements would be played simultaneously over all the connections.
Conference bridge access point A conference bridge endpoint is used to provide access to a specific conference.
The signals originating from these connections shall be mixed according to the connection "mode", as specified later in this document.
The precise number of connections that an endpoint support is a characteristic of the gateway, and may in fact vary according with the allocation of resource within the gateway.
A packet relay endpoint is a specific form of conference bridge, that typically only supports two connections.
Packets relays can be found in firewalls between a protected and an open network, or in transcoding servers used to provide interoperation between incompatible gateways, for example gateways that do not support compatible compression algorithms, or gateways that operate over different transmission networks such as IP and ATM.
Packet relay endpoint   2 connections
A wiretap access point provides access to a wiretap service, providing either a recording or a life playback of a connection.
A given wiretap endpoint is not supposed to support more than one connection at a time.
If several connections were established to the same endpoint, then the recording or playback would mix the audio signals received on this connections.
Connections to an wiretap endpoint are typically oneway, or "half duplex"   the wiretap server is not expected to signal its presence in a call.
ATM "trunk side" endpoints are typically found when one or several ATM permanent virtual circuits are used as a replacement for the classic "TDM" trunks linking switches.
When ATM/AAL2 is used, several trunks or channels are multiplexed on a single virtual circuit; each of these trunks correspond to a single endpoint.
The signals originating from these connections shall be mixed according to the connection "mode", as specified later in this document.
The precise number of connections that an endpoint support is a characteristic of the gateway, and may in fact vary according with the allocation of resource within the gateway.
However, the local name for each of these types is naturally hierarchical, beginning with a term which identifies the physical gateway containing the given endpoint and ending in a term which specifies the individual endpoint concerned.
With this in mind,  the following rules for construction and interpretation of the Entity Name field for these entity types MUST be supported: 1)
Thus, if the full naming path looks like term1/
/term3 then the Entity Name field looks like this depending on which terms are wild carded:  /term2
if term1 is wild carded term1/ /term3 if term2 is wild carded term1
In each of these examples a dollar sign could have appeared instead of an asterisk.
A term represented by an asterisk is to be interpreted as: "use ALL values of this term known within the scope of the Media Gateway".
A term represented by a dollar sign is to be interpreted as: "use ANY ONE value of this term known within the scope of the Media Gateway".
The description of a specific command may add further criteria for selection within the general rules given here.
If the Media Gateway controls multiple physical gateways, the first term of the naming MUST identify the physical gateway containing the desired entity.
If the Media Gateway controls only a single physical gateway, the first term of the naming string MAY identify that physical gateway, depending on local practice.
In the case of trunking gateways, endpoints are trunk circuits linking a gateway to a telephone switch.
These circuits are typically grouped into a digital multiplex, that is connected to the gateway by a physical interface.
Such circuits are named in three contexts:
In the ISUP protocol, trunks are grouped into trunk groups, identified by the SS7 point codes of the switches that the group connects.
Circuits within a trunk group are identified by a circuit number (CIC in ISUP).
In the gateway configuration files, physical interfaces are typically identified by the name of the interface, an arbitrary text string.
When the interface multiplexes several circuits, individual circuits are typically identified by a circuit number.
In MGCP, the endpoints are identified by an endpoint identifier.
The Call Agents use configuration databases to map ranges of circuit numbers within an ISUP trunk group to corresponding ranges of circuits in a multiplex connected to a gateway through a physical interface.
The gateway will be identified, in MGCP, by a domain name.
The local name will be structured to encode both the name of the physical interface, for example X35V3 A4, and the circuit number within the multiplex connected to the interface, for example 13.
The circuit number will be separated from the name of the interface by a fraction bar, as in: X35V3
A4/13 Other types of endpoints will use different conventions.
For example, in gateways were physical interfaces by construction only control one circuit, the circuit number will be omitted.
The exact syntax of such names should be specified in the corresponding server specification.
Calls and connections Connections are created on the call agent on each endpoint that will be involved in the "call."
When the two endpoints are located on gateways that are managed by the same call agent, the creation is done via the three following steps: 1)
The call agent asks the first gateway to "create a connection" on the first endpoint.
The gateway allocates resources to that connection, and respond to the command by providing a "session description."
The session description contains the information necessary for a third party to send packets towards the newly created connection, such as for example IP address, UDP port, and packetization parameters.
The call agent then asks the second gateway to "create a connection" on the second endpoint.
The command carries the "session description" provided by the first gateway.
The gateway allocates resources to that connection, and respond to the command by providing its own "session description.
The call agent uses a "modify connection" command to provide this second "session description" to the first endpoint.
Once this is done, communication can proceed in both directions.
When the two endpoints are located on gateways that are managed by the different call agents, these two call agents shall exchange information through a call agent to call agent signalling protocol, in order to synchronize the creation of the connection on the two endpoints.
Once established, the connection parameters can be modified at any time by a "modify connection" command.
The call agent may for example instruct the gateway to change the compression algorithm used on a connection, or to modify the IP address and UDP port to which data should be sent, if a connection is "redirected.
" The call agent removes a connection by sending to the gateway a "delete connection" command.
The gateway may also, under some circumstances, inform a gateway that a connection could not be sustained.
Names of calls One of the attributes of each connection is the "call identifier.
" Calls are identified by unique identifiers, independent of the underlying platforms or agents.
These identifiers are created by the Call Agent.
They are treated in MGCP as unstructured octet strings.
Call identifiers are expected to be unique within the system, or at a minimum, unique within the collection of Call Agents that control the same gateways.
When a Call Agent builds several connections that pertain to the same call, either on the same gateway or in different gateways, these connections that belong to the same call share the same call
This identifier can then be used by accounting or management procedures, which are outside the scope of MGCP.
Connection identifiers are created by the gateway when it is requested to create a connection.
They identify the connection within the context of an endpoint.
They are treated in MGCP as unstructured octet strings.
The gateway should make sure that a proper waiting period, at least 3 minutes, elapses between the end of a connection that used this identifier and its use in a new connection for the same endpoint.
(Gateways may decide to use identifiers that are unique within the context of the gateway.)
Management of resources, attributes of connections
Many types of resources will be associated to a connection, such as specific signal processing functions or packetization functions.
Generally, these resources fall in two categories: 1) Externally visible resources, that affect the format of "the bits on the network" and must be communicated to the second endpoint involved in the connection.
Internal resources, that determine which signal is being sent over the connection and how the received signals are processed by the endpoint.
The resources allocated to a connection, and more generally the handling of the connection, are chosen by the gateway under instructions from the call agent.
The call agent will provide these instructions by sending two set of parameters to the gateway: 1)
The local directives instruct the gateway on the choice of resources that should be used for a connection, 2)
When available, the "session description" provided by the other end of the connection.
The local directives specify such parameters as the mode of the connection (e.g. send only, send receive), preferred coding or packetization methods, usage of echo cancellation or silence suppression.
(A detailed list can be found in the specification of the LocalConnectionOptions parameter of the CreateConnection command.)
For each of these parameters, the call agent can either specify a value, a range of value, or no value at all.
This allow various implementations to implement various level of control, from a very tight control where the call agent specifies minute details of the connection handling to a very loose control where the call agent only specifies broad guidelines, such as the maximum bandwidth, and let the gateway choose the detailed values.
Based on the value of the local directives, the gateway will determine the resources allocated to the connection.
When this is possible, the gateway will choose values that are in line with the remote session description
but there is no absolute requirement that the parameters be exactly the same.
Once the resource have been allocated, the gateway will compose a "session description" that describes the way it intends to receive packets.
Note that the session description may in some cases present a range of values.
For example, if the gateway is ready to accept one of several compression algorithm, it can provide a list of these accepted algorithms.
Information flow: local directives & session descriptions   2.1.3.4.
Special case of local connections Large gateways include a large number of endpoints which are often of different types.
In some networks, we may often have to set up connections between endpoints that are located within the same gateway.
Routing a call from on endpoint to another, something often described as a "hairpin" connection.
Local connections are much simpler to establish than network connections.
In most cases, the connection will be established through some local interconnecting device, such as for example a TDM bus.
When two endpoints are managed by the same gateway, it is possible to specify the connection in a single command that conveys the name of the two endpoints that will be connected.
The command is essentially a "Create Connection" command which includes the name of the second endpoint in lieu of the "remote session description."
Names of Call Agents and other entities
The media gateway control protocol has been designed to allow the implementation of redundant Call Agents, for enhanced network reliability.
This means that there is no fixed binding between entities and hardware platforms or network interfaces.
Several addresses can be associated with a domain name.
If a command or a response cannot be forwarded to one of the network addresses, implementations should retry the transmission using another address.
Entities may move to another platform.
The association between a logical name (domain name) and the actual platform are kept in the domain name service.
Call Agents and Gateways should keep track of the time to live of the record they read from the DNS.
They should query the DNS to refresh the information if the time to live has expired.
In addition to the indirection provided by the use of domain names and the DNS, the concept of "notified entity" is central to reliability and fail over in MGCP.
The "notified entity" for an endpoint is the Call Agent currently controlling that endpoint.
At any point in time, an endpoint has one, and only one, "notified entity" associated with it, and when the endpoint needs to send a command to the Call Agent, it MUST send the command to the current "notified entity" for which endpoint(s) the command pertains.
Upon startup, the "notified entity" MUST be set to a provisioned value.
Most commands sent by the Call Agent include the ability to explicitly name the "notified entity" through the use of a "NotifiedEntity" parameter.
The "notified entity" will stay the same until either a new "NotifiedEntity" parameter is received or the endpoint reboots.
If the "notified entity" for an endpoint is empty or has not been set explicitly, the "notified entity" will then default to the source address of the last connection handling command or notification request received for the endpoint.
Auditing will thus not change the "notified entity."
The Call Agent can ask the gateway to collect digits dialed by the user.
This facility is intended to be used with residential gateways to collect the numbers that a user dials; it may also be used with trunking gateways and access gateways alike, to collect the access codes, credit card numbers and other numbers requested by call control services.
An alternative procedure is for the gateway to notify the Call Agent of the dialed digits, as soon as they are dialed.
However, such a procedure generates a large number of interactions.
It is preferable to accumulate the dialed numbers in a buffer, and to transmit them in a single message.
The problem with this accumulation approach, however, is that it is hard for the gateway to predict how many numbers it needs to accumulate before transmission.
The solution to this problem is to load the gateway with a digit map that correspond to the dial plan.
This digit map is expressed using a syntax derived from the Unix system command, egrep.
For example, the dial plan described above results in the following digit map: (0T  00T [1 7]xxx 8xxxxxxx #xxxxxxx  xx 91xxxxxxxxxx 9011x.
The formal syntax of the digit map is described by the DigitMap rule in the formal syntax description of the protocol (section 3.4).
A Digit Map, according to this syntax, is defined either by a "string" or by a list of strings.
Each string in the list is an alternative numbering scheme, specified either as a set of digits or timers, or as regular expression.
A gateway that detects digits, letters or timers will: 1) Add the event parameter code as a token to the end of an internal state variable called the "current dial string" 2)
Apply the current dial string to the digit map table, attempting a match to each regular expression in the Digit Map in lexical order 3)
If the result is under qualified (partially matches at least one entry in the digit map), do nothing further.
If the result matches, or is over qualified (i.e. no further digits could possibly produce a match), send the current digit string to the Call Agent.
A match, in this specification, can be either a "perfect match," exactly matching one of the specified alternatives, or an impossible match, which occur when the dial string does not match any of the alternative.
Unexpected timers, for example, can cause "impossible matches."
Both perfect matches and impossible matches trigger notification of the accumulated digits.
Digit maps are provided to the gateway by the Call Agent, whenever the Call Agent instructs the gateway to listen for digits.
The concept of events and signals is central to MGCP.
A Call Agent may ask to be notified about certain events occurring in an endpoint, e.g.  off hook events, and a call agent may request certain signals to be applied to an endpoint, e.g. dial tone.
Events and signals are grouped in packages within which they share the same namespace which we will refer to as event names in the following.
Packages are groupings of the events and signals supported by a particular type of endpoint.
For instance, one package may support a certain group of events and signals for analog access lines, and another package may support another group of events and signals for video lines.
One or more packages may exist for a given endpoint type.
Event names are case insensitive and are composed of two logical parts, a package name and an event name.
Both names are strings of letters, hyphens and digits, with the restriction that hyphens shall never be the first or last characters in a name.
Package or event names are not case sensitive values such as "hu", "Hu", "HU" or "hU" should be considered equal.
Examples of package names are "D" (DTMF), "M" (MF), "T" (Trunk) or "L" (Line).
Examples of event names can be "hu" (off hook or "hang  up" transition), "hf" (flash hook) or "0" (the digit zero).
The package name is in fact optional.
Each endpoint type has a default package associated with it, and if the package name is excluded from the event name, the default package name for that endpoint type is assumed.
For example, for an analog access line, the following two event names are equal:
l/dl dial tone in the line package for an analog access line.
dial tone in the line package (default) for an analog access line.
This document defines a basic set of package names and event names.
Additional package names and event names can be registered with the IANA.
A package definition shall define the name of the package, and the definition of each event belonging to the package.
The event definition shall include the precise name of the event (i.e., the code used in MGCP), a plain text definition of the event, and, when appropriate, the precise definition of the corresponding signals, for example the exact frequencies of audio signal such as dial tones or DTMF tones.
In addition, implementers can gain experience by using experimental packages.
The names of experimental packages must start with the two characters "x "; the IANA shall not register package names that start with these characters.
Digits, or letters, are supported in many packages, notably "DTMF" and "MF".
Digits and letters are defined by the rules "Digit" and "Letter" in the definition of digit maps.
These letters can be combined in "digit string" that represent the keys that a user punched on a dial.
The need to easily express the digit strings has a consequence on the form of event names:
An event name that does not denote a digit should always contain at least one character that is neither a digit, nor one of the letters A, B, C, D, T or X.
A Call Agent may often have to ask a gateway to detect a group of events.
Two conventions can be used to denote such groups:
The wildcard convention can be used to detect any event belonging to a package, or a given event in many packages, or event any event in any package supported by the gateway.
The regular expression Range notation can be used to detect a range of digits.
A name such as "foo/all" denotes all events in package "foo" A name such as " /bar" denotes the event "bar" in any package supported by the gateway
The call agent can ask a gateway to detect a set of digits or letters either by individually describing those letters, or by using the "range" notation defined in the syntax of digit strings.
For example, the call agent can: Use the letter "x" to denote "any letter or digit."
Use the notation "[0 9#]" to denote the digits 0 to 9 and the pound sign.
In some cases, Call Agents will request the gateway to generate or detect events on connections rather than on the end point itself.
For example, gateways may be asked to provide a ringback tone on a connection.
When this convention is used, the gateway will generate or detect the event on all the connections that are connected to the endpoint.
An example of this convention could be:
" It should only be used by the call agent, when the event notification request is "encapsulated" within a command creation or modification command.
When this convention is used, the gateway will generate or detect the event on the connection that is currently being created or modified.
An example of this convention is: G
The connection id, or a wildcard replacement, can be used in conjunction with the "all packages" and "all events" conventions.
For example, the notation:  /all@  can be used to designate all events on all connections.
Events and signals are described in packages.
The package description must provide, for each events, the following informations:
The description of the event and its purpose, which should mean the actual signal that is generated by the client (i.e., xx ms FSK tone) as well as the resulting user observed result (i.e., MW light on/off).
The detailed characteristics of the event, such as for example frequencies and amplitude of audio signals, modulations and repetitions,
The typical and maximum duration of the event.
Signals are divided into different types depending on their behavior:
Once applied, these signals last forever until they are turned off.
This may happen either as the result of an event or a new SignalRequests (see later).
Once applied, these signals last until they are either turned off (by an event or SignalRequests) or a signal specific period of time has elapsed.
Depending on package specifications, a signal that times out may generate an "operation complete" event.
The duration of these signals is so short, that they stop on their own.
If an event occurs the signal will not stop, however if a new SignalRequests is applied, the signal will stop.
(Note: this point should be debated.
One could make a case that events such as strings of DTMF digits should in fact be allowed to complete.)
TO signals are normally used to alert the endpoints' users, to signal them that they are expected to perform a specific action, such as hang down the phone (ringing).
Transmission of these signals should typically be interrupted as soon as the first of the requested events has been produced.
Package descriptions should describe, for all signals, their type (OO, TO, BR).
They should also describe the maximum duration of the TO signals.
The Call Agent uses the MGCP to provision the gateways with the description of connection parameters such as IP addresses, UDP port and RTP profiles.
These descriptions will follow the conventions delineated in the Session Description Protocol which is now an IETF proposed standard, documented in RFC 2327.
SDP allows for description of multimedia conferences.
This version limits SDP usage to the setting of audio circuits and data access circuits.
The initial session descriptions contain the description of exactly one media, of type "audio" for audio connections, "nas" for data access.
This section describes the commands of the MGCP.
The service consists of connection handling and endpoint handling commands.
There are nine commands in the protocol:
The Call Agent can issue an EndpointConfiguration command to a gateway, instructing the gateway about the coding characteristics expected by the "line side" of the endpoint.
The Call Agent can issue a NotificationRequest command to a gateway, instructing the gateway to watch for specific events such as hook actions or DTMF tones on a specified endpoint .
The gateway will then use the Notify command to inform the Call Agent when the requested events occur.
The Call Agent can use the CreateConnection command to create a connection that terminates in an "endpoint" inside the gateway.
The Call Agent can use the ModifyConnection command to change the parameters associated to a previously established connection.
The Call Agent can use the DeleteConnection command to delete an existing connection.
The DeleteConnection command may also be used by a gateway to indicate that a connection can no longer be sustained.
The Call Agent can use the AuditEndpoint and AuditConnection commands to audit the status of an "endpoint" and any connections associated with it.
Network management beyond the capabilities provided by these commands are generally desirable, e.g. information about the status of the gateway.
Such capabilities are expected to be supported by the use of the Simple Network Management Protocol (SNMP) and definition of a MIB which is outside the scope of this specification.
The Gateway can use the RestartInProgress command to notify the Call Agent that the gateway, or a group of endpoints managed by the gateway, is being taken out of service or is being placed back in service.
These services allow a controller (normally, the Call Agent) to instruct a gateway on the creation of connections that terminate in an "endpoint" attached to the gateway, and to be informed about events occurring at the endpoint.
Connections are grouped into "calls".
Several connections, that may or may not belong to the same call, can terminate in the same endpoint .
Each connection is qualified by a "mode" parameter, which can be set to "send only" (sendonly), "receive only" (recvonly), "send/receive" (sendrecv), "conference" (confrnce), "data", "inactive" (inactive), "loopback", "continuity test" (conttest), "network loop back" (netwloop) or "network continuity test" (netwtest).
The handling of the audio signals received on these connections is determined by the mode parameters:
Audio signals received in data packets through connections in "receive", "conference" or "send/receive" mode are mixed and sent to the endpoint.
Audio signals originating from the endpoint are transmitted over all the connections whose mode is "send", "conference" or "send/receive."
In addition to being sent to the endpoint, audio signals received in data packets through connections in "conference" mode are replicated to all the other connections whose mode is "conference."
The "loopback" and "continuity test" modes are used during maintenance and continuity test operations.
There are two flavors of continuity test, one specified by ITU and one used in the US.
In the first case, the test is a loopback test.
The originating switch will send a tone (the go tone) on the bearer circuit and expect the terminating switch to loopback the circuit.
If the originating switch sees the same tone returned (the return tone), the COT has passed.
If not, the COT has failed.
In the second case, the go and return tones are different.
The originating switch sends a certain go tone.
The terminating switch detects the go tone, it asserts a different return tone in the backwards direction.
When the originating switch detects the return tone, the COT is passed.
If the originating switch never detects the return tone, the COT has failed.
If the mode is set to "loopback", the gateway is expected to return the incoming signal from the endpoint back into that same endpoint.
This procedure will be used, typically, for testing the continuity of trunk circuits according to the ITU specifications.
If the mode is set to "continuity test", the gateway is informed that the other end of the circuit has initiated a continuity test procedure according to the GR specification.
The gateway will place the circuit in the transponder mode required for dual tone continuity tests.
If the mode is set to "network loopback", the audio signals received from the connection will be echoed back on the same connection.
If the mode is set to "network continuity test", the gateway will process the packets received from the connection according to the transponder mode required for dual tone continuity test, and send the processed signal back on the connection.
EndpointConfiguration The EndpointConfiguration commands are used to specify the encoding of the signals that will be received by the endpoint.
For example, in certain international telephony configurations, some calls will carry mu law encoded audio signals, while other will use A law.
The Call Agent will use the EndpointConfiguration command to pass this information to the gateway.
The configuration may vary on a call by call basis, but can also be used in the absence of any connection.
ReturnCode   EndpointConfiguration( EndpointId, BearerInformation) EndpointId is the name for the endpoint in the gateway where EndpointConfiguration executes, as defined in section 2.1.1.
The "any of" wildcard convention shall not be used.
If the "all of" wildcard convention is used, the command applies to all the endpoint whose name matches the wildcard.
BearerInformation is a parameter defining the coding of the data received from the line side.
These information is encoded as a list of sub parameters.
The only sub parameter defined in this version of the specification is the encoding method, whose values can be set to "A law" and "mu law".
ReturnCode is a parameter returned by the gateway.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
The NotificationRequest commands are used to request the gateway to send notifications upon the occurrence of specified events in an endpoint.
For example, a notification may be requested for when a gateway detects that an endpoint is receiving tones associated with fax communication.
The entity receiving this notification may decide to use a different type of encoding method in the connections bound to this endpoint.
ReturnCode   NotificationRequest( EndpointId, [NotifiedEntity,] [RequestedEvents,] RequestIdentifier, [DigitMap,]
[SignalRequests,] [QuarantineHandling,] [DetectEvents,] [encapsulated EndpointConfiguration])
EndpointId is the name for the endpoint in the gateway where NotificationRequest executes, as defined in section 2.1.1.
NotifiedEntity is an optional parameter that specifies where the notifications should be sent.
When this parameter is absent, the notifications should be sent to the originator of the NotificationRequest.
RequestIdentifier is used to correlate this request with the notifications that it triggers.
RequestedEvents is a list of events that the gateway is requested to detect and report.
Such events include, for example, fax tones, continuity tones, or on hook transition.
Some actions can be combined.
The "keep signal active" action can be combined with "Notify", "Accumulate", "Accumulate according to Digit Map", "Ignore" and "Embedded Notification Request."
The "Embedded Notification Request" can be combined with "Accumulate" and with "Keep signals active.
" It can also be combined with Notify, if the gateway is allowed to issue several Notify commands in response to a single Notification request.
In addition to the requestedEvents parameter specified in the command, some profiles of MGCP have introduced the concept of "persistent events."
According to such profiles, the persistent event list is configured in the endpoint, by means outside the scope of MGCP.
The basic MGCP specification does not specify any persistent event.
If a persistent event is not included in the list of RequestedEvents, and the event occurs, the event will be detected anyway, and processed like all other events, as if the persistent event had been requested with a Notify action.
Thus, informally, persistent events can be viewed as always being implicitly included in the list of RequestedEvents with an action to Notify, although no glare detection, etc., will be performed.
Non persistent events are those events explicitly included in the RequestedEvents list.
The (possibly empty) list of requested events completely replaces the previous list of requested events.
In addition to the persistent events, only the events specified in the requested events list will be detected by the endpoint.
If a persistent event is included in the RequestedEvents list, the action specified will then replace the default action associated with the event for the life of the RequestedEvents list, after which the default action is restored.
For example, if "Ignore off hook" was specified, and a new request without any off hook instructions were received, the default "Notify off hook" operation then would be restored.
A given event MUST NOT appear more than once in a RequestedEvents.
The gateway will detect the union of the persistent events and the requested events.
If an event is not specified in either list, it will be ignored.
The Swap Audio action can be used when a gateway handles more than one active connection on an endpoint.
This will be the case for three way calling, call waiting, and possibly other feature scenarios.
In order to avoid the round trip to the Call Agent when just changing which connection is attached to the audio functions of the endpoint, the NotificationRequest can map an event (usually hook flash, but could be some other event) to a local function swap audio, which selects the "next" connection in a round robin fashion.
If there is only one connection, this action is effectively a no op.
If signal(s) are desired to start when an event being looked for occurs, the "Embedded NotificationRequest" action can be used.
The embedded NotificationRequest may include a new list of RequestedEvents, SignalRequests and a new digit map as well.
The semantics of the embedded NotificationRequest is as if a new NotificationRequest was just received with the same NotifiedEntity, and RequestIdentifier.
When the "Embedded NotificationRequest" is activated, the "current dial string" will be cleared; the list of observed events and the quarantine buffer will be unaffected.
MGCP implementations shall be able to support at least one level of embedding.
An embedded NotificationRequest that respects this limitation shall not contain another Embedded NotificationRequest.
DigitMap is an optional parameter that allows the Call Agent to provision the gateways with a digit map according to which digits will be accumulated.
If this optional parameter is absent, the previously defined value is retained.
This parameter must be defined, either explicitly or through a previous command, if the RequestedEvent parameters contain an request to "accumulate according to the digit map.
" The collection of these digits will result in a digit string.
The digit string is initialized to a null string upon reception of the NotificationRequest, so that a subsequent notification only returns the digits that were collected after this request.
Digits that were accumulated according to the digit map are reported as any other accumulated event, in the order in which they occur.
It is therefore possible that other events be accumulated may be found in between the list of digits.
SignalRequests is a parameter that contains the set of signals that the gateway is asked to apply to the endpoint, such as, for example ringing, or continuity tones.
Signals are identified by their name, which is an event name, and may be qualified by parameters.
The action triggered by the SignalRequests is synchronized with the collection of events specified in the RequestedEvents parameter.
For example, if the NotificationRequest mandates "ringing" and the event request ask to look for an "off hook" event, the ringing shall stop as soon as the gateway detect an off hook event.
The formal definition is that the generation of all "Time Out" signals shall stop as soon as one of the requested events is detected, unless the "Keep signals active" action is associated to the specified event.
The specific definition of actions that are requested via these SignalRequests, such as the duration of and frequency of a DTMF digit, is out side the scope of MGCP.
This definition may vary from location to location and hence from gateway to gateway.
The RequestedEvents and SignalRequests refer to the same event definitions.
In one case, the gateway is asked to detect the occurrence of the event, and in the other case it is asked to generate it.
The specific events and signals that a given endpoint can detect or perform are determined by the list of event packages that are supported by that end point.
Each package specifies a list of events and actions that can be detected or performed.
A gateway that is requested to detect or perform an event belonging to a package that is not supported by the specified endpoint shall return an error.
When the event name is not qualified by a package name, the default package name for the end point is assumed.
If the event name is not registered in this default package, the gateway shall return an error.
The Call Agent can send a NotificationRequest whose requested signal list is empty.
It will do so for example when tone generation should stop.
The optional QuarantineHandling parameter specifies the handling of "quarantine" events, i.e. events that have been detected by the gateway before the arrival of this NotificationRequest command, but have not yet been notified to the Call Agent.
whether the gateway is expected to generate at most one notification (step by step), or multiple notifications (loop), in response to this request (the default is exactly one.)
When the parameter is absent, the default value is assumed.
We should note that the quarantine handling parameter also governs the handling of events that were detected but not yet notified when the command is received.
DetectEvents is an optional parameter that specifies a list of events that the gateway is requested to detect during the quarantine period.
When this parameter is absent, the events that should be detected in the quarantine period are those listed in the last received DetectEvents list.
In addition, the gateway should also detect the events specified in the request list, including those for which the "ignore" action is specified.
Some events and signals, such as the in line ringback or the quality alert, are performed or detected on connections terminating in the end point rather than on the endpoint itself.
The structure of the event names allow the Call Agent to specify the connection (or connections) on which the events should be performed or detected.
The command may carry an encapsulated EndpointConfiguration command, that will apply to the same endpoint.
When this command is present, the parameters of the EndpointConfiguration command are inserted after the normal parameters of the NotificationRequest, with the exception of the EndpointId, which is not replicated.
The encapsulated EndpointConfiguration command shares the fate of the NotificationRequest command.
If the NotificationRequest is rejected, the EndpointConfiguration is not executed.
ReturnCode is a parameter returned by the gateway.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
3 Notifications Notifications are sent via the Notify command and are sent by the gateway when the observed events occur.
RequestIdentifier, ObservedEvents) EndpointId is the name for the endpoint in the gateway which is issuing the Notify command, as defined in section 2.1.1.
The identifier should be a fully qualified endpoint identifier, including the domain name of the gateway.
The local part of the name shall not use the wildcard convention.
NotifiedEntity is an optional parameter that identifies the entity to which the notifications is sent.
This parameter is equal to the last received value of the NotifiedEntity parameter.
The parameter is absent if there was no such parameter in the triggering request.
The notification is sent to the "current notified entity" or, if no such entity was ever specified, to the address from which the request was received.
RequestIdentifier is parameter that repeats the RequestIdentifier parameter of the NotificationRequest that triggered this notification.
It is used to correlate this notification with the request that triggered it.
ObservedEvents is a list of events that the gateway detected.
A single notification may report a list of events that will be reported in the order in which they were detected.
The list may only contain the identification of events that were requested in the RequestedEvents parameter of the triggering NotificationRequest.
It will contain the events that were either accumulated (but not notified) or treated according to digit map (but no match yet), and the final event that triggered the detection or provided a final match in the digit map.
ReturnCode is a parameter returned by the call agent.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
This command is used to create a connection between two endpoints.
[SecondConnectionId]   CreateConnection(CallId, EndpointId, [NotifiedEntity,] [LocalConnectionOptions,]
A connection is defined by its endpoints.
The input parameters in CreateConnection provide the data necessary to build a gateway's "view" of a connection.
CallId is a globally unique parameter that identifies the call (or session) to which this connection belongs.
Connections that belong to the same call share the same call
id can be used to identify calls for reporting and accounting purposes.
It does not affect the handling of connections by the gateway.
EndpointId is the identifier for the connection endpoint in the gateway where CreateConnection executes.
The EndpointId can be fully specified by assigning a value to the parameter EndpointId in the function call or it may be under specified by using the "anyone" wildcard convention.
If the endpoint is underspecified, the endpoint identifier will be assigned by the gateway and its complete value returned in the SpecificEndPointId parameter of the response.
The NotifiedEntity is an optional parameter that specifies where the Notify or DeleteConnection commands should be sent.
If the parameter is absent, the Notify or DeleteConnection commands should be sent to the last received Notified Entity, or to originator of the CreateConnection command if no Notified Entity was ever received for the end point.
LocalConnectionOptions is a parameter used by the Call Agent to direct the handling of the connection by the gateway.
This set of field can be completed by vendor specific optional or mandatory extensions.
The encoding of the first three fields, when they are present, will be compatible with the SDP and RTP profiles:
The encoding method shall be specified by using one or several valid encoding names, as defined in the RTP AV Profile or registered with the IANA.
The packetization period is encoded as either the length of time in milliseconds represented by the media in a packet, as specified in the "ptime" parameter of SDP, or as a range value, specifying both the minimum and maximum acceptable packetization periods.
The bandwidth is encoded as either a single value or a range, expressed as an integer number of kilobit per seconds.
For each of the first three fields, the Call Agent has three options:
The bandwidth specification shall not contradict the specification of encoding methods and packetization period.
If an encoding method is specified, then the gateway is authorized to use it, even if it results in the usage of a larger bandwidth than specified.
The LocalConnectionOptions parameter may be absent in the case of a data call.
The Type of Service specifies the class of service that will be used for the connection.
When the connection is transmitted over an IP network, the parameters encodes the 8 bit type of service value parameter of the IP header.
When the Type of Service is not specified, the gateway shall use a default or configured value.
The gateways can be instructed to perform a reservation, for example using RSVP, on a given connection.
When a reservation is needed, the call agent will specify the reservation profile that should be used, which is either "controlled load" or "guaranteed service."
The absence of reservation can be indicated by asking for the "best effort" service, which is the default value of this parameter.
The RSVP filters will be deduced from the characteristics of the connection.
The RSVP resource profiles will be deduced from the connection's bandwidth and packetization period.
By default, the telephony gateways always perform echo cancellation.
However, it is necessary, for some calls, to turn off these operations.
The echo cancellation parameter can have two values, "on" (when the echo cancellation is requested) and "off" (when it is turned off.)
The telephony gateways may perform gain control, in order to adapt the level of the signal.
However, it is necessary, for example for modem calls, to turn off this function.
The gain control parameter may either be specified as "automatic", or as an explicit number of decibels of gain.
The default is to not perform gain control, which is equivalent to specifying a gain of 0 decibels.
The telephony gateways may perform voice activity detection, and avoid sending packets during periods of silence.
However, it is necessary, for example for modem calls, to turn off this detection.
The silence suppression parameter can have two values, "on" (when the detection is requested) and "off" (when it is turned off.)
The Call agent can request the gateway to enable encryption of the audio Packets.
It does so by providing an key specification, as specified in RFC 2327.
By default, encryption is not used.
The Call Agent may instruct the gateway to prepare the connection on a specified type of network.
The type of network is encoded as in the "connection field" parameter of the SDP standard.
Possible values are IN (Internet), ATM and LOCAL.
The parameter is optional; if absent, the network is determined by the type of gateway.
RemoteConnectionDescriptor is the connection descriptor for the remote side of a connection, on the other side of the IP network.
It includes the same fields as in the LocalConnectionDescriptor, i.e. the fields that describe a session according to the SDP standard.
This parameter may have a null value when the information for the remote end is not known yet.
This occurs because the entity that builds a connection starts by sending a CreateConnection to one of the two gateways involved in it.
For the first CreateConnection issued, there is no information available about the other side of the connection.
This information may be provided later via a ModifyConnection call.
In the case of data connections (mode data), this parameter describes the characteristics of the data connection.
The SecondEndpointId can be used instead of the RemoteConnectionDescriptor to establish a connection between two endpoints located on the same gateway.
The connection is by definition a local connection.
The SecondEndpointId can be fully  specified by assigning a value to the parameter SecondEndpointId in the function call or it may be under specified by using the "anyone" wildcard convention.
If the secondendpoint is underspecified, the second endpoint identifier will be assigned by the gateway and its complete value returned in the SecondEndPointId parameter of the response.
Mode indicates the mode of operation for this side of the connection.
The mode are "send", "receive", "send/receive", "conference", "data", "inactive", "loopback", "continuity test", "network loop back" or "network continuity test.
" The expected handling of these modes is specified in the introduction of the "Gateway Handling Function" section.
Some end points may not be capable of supporting all modes.
If the command specifies a mode that the endpoint cannot support, and error shall be returned.
The gateway returns a ConnectionId, that uniquely identifies the connection within one endpoint, and a LocalConnectionDescriptor, which is a session description that contains information about addresses and RTP ports, as defined in SDP.
The LocalConnectionDescriptor is not returned in the case of data connections.
The SpecificEndPointId is an optional parameter that identifies the responding endpoint.
It can be used when the EndpointId argument referred to a "any of" wildcard name.
When a SpecificEndPointId is returned, the Call Agent should use it as the EndpointId value is successive commands referring to this call.
When a SecondEndpointId is specified, the command really creates two connections that can be manipulated separately through ModifyConnection and DeleteConnection commands.
The response to the creation provides a SecondConnectionId parameter that identifies the second connection.
After receiving a "CreateConnection" request that did not include a RemoteConnectionDescriptor parameter, a gateway is in an ambiguous situation.
Because it has exported a LocalConnectionDescriptor parameter, it can potentially receive packets.
Because it has not yet received the RemoteConnectionDescriptor parameter of the other gateway, it does not know whether the packets that it receives have been authorized by the Call Agent.
It must thus navigate between two risks, i.e. clipping some important announcements or listening to insane data.
The behavior of the gateway is determined by the value of the Mode parameter:
If the mode was set to ReceiveOnly, the gateway should accept the voice signals and transmit them through the endpoint.
If the mode was set to Inactive, Loopback, Continuity Test, the gateway should refuse the voice signals.
If the mode was set to Network Loopback or Network Continuity Test, the gateway should perform the expected echo or Response.
Note that the mode values SendReceive, Conference, Data and SendOnly don't make sense in this situation.
They should be treated as errors, and the command should be rejected (Error code 517).
The command may optionally contain an encapsulated Notification Request command, in which case a RequestIdentifier parameter will be present, as well as, optionally, the RequestedEvents DigitMap, SignalRequests, QuarantineHandling and DetectEvents parameters.
The encapsulated NotificationRequest is executed simultaneously with the creation of the connection.
This can be accomplished in a single CreateConnection command, by also transmitting the RequestedEvent parameters for the off hook event, and the SignalRequest parameter for the ringing signal.
When these parameters are present, the creation and the NotificationRequests should be synchronized, which means that bothshould be accepted, or both refused.
In our example, the CreateConnection may be refused if the gateway does not have sufficient resources, or cannot get adequate resources from the local network access, and the off hook Notification Request can be refused in the glare condition, if the user is already off hook.
In this example, the phone should not ring if the connection cannot be established, and the connection should not be established if the user is already off hook.
The NotifiedEntity parameter, if present, applies to both the CreateConnection and the NotificationRequest command.
It defines the new "notified entity" for the endpoint.
The command may carry an encapsulated EndpointConfiguration command, that will apply to the same endpoint.
When this command is present, the parameters of the EndpointConfiguration command are inserted after the normal parameters of the CreateConnection with the exception of the EndpointId, which is not replicated.
The EndpointConfiguration command may be encapsulated together with an encapsulated NotificationRequest command.
The encapsulated EndpointConfiguration command shares the fate of the CreateConnection command.
If the CreateConnection is rejected, the EndpointConfiguration is not executed.
ReturnCode is a parameter returned by the gateway.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
This command is used to modify the characteristics of a gateway's "view" of a connection.
This "view" of the call includes both the local connection descriptors as well as the remote connection descriptor.
ModifyConnection(CallId, EndpointId, ConnectionId, [NotifiedEntity,] [LocalConnectionOptions,]
The parameters used are the same as in the CreateConnection command, with the addition of a ConnectionId that identifies the connection within the endpoint.
This parameter is returned by the CreateConnection function, as part of the local connection descriptor.
It uniquely identifies the connection within the context of the endpoint.
The EndpointId should be a fully qualified endpoint identifier.
The local name shall not use the wildcard convention.
The ModifyConnection command can be used to affect parameters of a connection in the following ways:
This can occur at any time during the connection, with arbitrary parameter values.
Change the sending parameters of the connection, for example by switching to a different coding scheme, changing the packetization period, or modifying the handling of echo cancellation.
Connections can only be activated if the RemoteConnectionDescriptor has been provided to the gateway.
The receive only mode, however, can be activated without the provision of this descriptor.
The command will only return a LocalConnectionDescriptor if the local connection parameters, such as RTP ports, were modified.
(Usage of this feature is actually for further study.)
The command may optionally contain an encapsulated Notification Request command, in which case a RequestIdentifier parameter will be present, as well as, optionnally, the RequestedEvents DigitMap, SignalRequests, QuarantineHandling and DetectEvents parameters.
The encapsulated NotificationRequest is executed simultaneously with the modification of the connection.
For example, when a connection is accepted, the calling gateway should be instructed to place the circuit in send receive mode and to stop providing ringing tones.
This can be accomplished in a single ModifyConnection command, by also transmitting the RequestedEvent parameters, for the on hook event, and an empty SignalRequest parameter, to stop the provision of ringing tones.
When these parameters are present, the modification and the NotificationRequests should be synchronized, which means that both should be accepted, or both refused.
The NotifiedEntity parameter, if present, applies to both the ModifyConnection and the NotificationRequest command.
The command may carry an encapsulated EndpointConfiguration command, that will apply to the same endpoint.
When this command is present, the parameters of the EndpointConfiguration command are inserted after the normal parameters of the ModifyConnection with the exception of the EndpointId, which is not replicated.
The EndpointConfiguration command may be encapsulated together with an encapsulated NotificationRequest command.
The encapsulated EndpointConfiguration command shares the fate of the ModifyConnection command.
If the ModifyConnection is rejected, the EndpointConfiguration is not executed.
ReturnCode is a parameter returned by the gateway.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
DeleteConnection (from the Call Agent)
This command is used to terminate a connection.
As a side effect, it collects statistics on the execution of the connection.
DeleteConnection(CallId, EndpointId, ConnectionId, [Encapsulated NotificationRequest,] [Encapsulated EndpointConfiguration])
The endpoint identifier, in this form of the DeleteConnection command, shall be fully qualified.
Wildcard conventions shall not be used.
In the general case where a connection has two ends, this command has to be sent to both gateways involved in the connection.
Some connections, however, may use IP multicast.
In this case, they can be deleted individually.
After the connection has been deleted, any loopback that has been requested for the connection should be cancelled.
When all connections to an endpoint have been deleted, that endpoint should be placed in inactive mode.
In response to the DeleteConnection command, the gateway returns a list of parameters that describe the status of the connection.
These parameters are: Number of packets sent:
The total number of RTP data packets transmitted by the sender since starting transmission on this connection.
The count is not reset if the sender changes its synchronization source identifier (SSRC, as defined in RTP), for example as a result of a Modify command.
The value is zero if the connection was set in "receive only" mode.
Number of octets sent: The total number of payload octets (i.e., not including header or padding) transmitted in RTP data packets by the sender since starting transmission on this connection.
The count is not reset if the sender changes its SSRC identifier, for example as a result of a ModifyConnection command.
The value is zero if the connection was set in "receive only" mode.
Number of packets received: The total number of RTP data packets received by the sender since starting reception on this connection.
The count includes packets received from different SSRC, if the sender used several values.
The value is zero if the connection was set in "send only" mode.
Number of octets received: The total number of payload octets (i.e., not including header or padding) transmitted in RTP data packets by the sender since starting transmission on this connection.
The count includes packets received from different SSRC, if the sender used several values.
The value is zero if the connection was set in "send only" mode.
Number of packets lost: The total number of RTP data packets that have been lost since the beginning of reception.
This number is defined to be the number of packets expected less the number of packets actually received, where the number of packets received includes any which are late or duplicates.
The count includes packets received from different SSRC, if the sender used several values.
Thus packets that arrive late are not counted as lost, and the loss may be negative if there are duplicates.
The count includes packets received from different SSRC, if the sender used several values.
The number of packets expected is defined to be the extended last sequence number received, as defined next, less the initial sequence number received.
The count includes packets received from different SSRC, if the sender used several values.
The value is zero if the connection was set in "send only" mode.
This parameter is omitted if the connection was set in "data" mode.
An estimate of the statistical variance of the RTP data packet interarrival time measured in milliseconds and expressed as an unsigned integer.
The interarrival jitter J is defined to be the mean deviation (smoothed absolute value) of the difference D in packet spacing at the receiver compared to the sender for a pair of packets.
Detailed computation algorithms are found in RFC 1889.
The count includes packets received from different SSRC, if the sender used several values.
The value is zero if the connection was set in "send only" mode.
This parameter is omitted if the connection was set in "data" mode.
An estimate of the network latency, expressed in milliseconds.
This is the average value of the difference between the NTP timestamp indicated by the senders of the RTCP messages and the NTP timestamp of the receivers, measured when this messages are received.
The average is obtained by summing all the estimates, then dividing by the number of RTCP messages that have been received.
This parameter is omitted if the connection was set in "data" mode.
When the gateway's clock is not synchronized by NTP, the latency value can be computed as one half of the round trip delay, as measured through RTCP.
When the gateway cannot compute the one way delay or the round trip delay, the parameter conveys a null value.
For a detailed definition of these variables, refer to RFC 1889.
When the connection was set up over an ATM network, the meaning of these parameters may change:
The total number of ATM cells transmitted since starting transmission on this connection.
Number of octets sent: The total number of payload octets transmitted in ATM cells.
Number of packets received: The total number of ATM cells received since starting reception on this connection.
Number of octets received: The total number of payload octets received in ATM cells.
Number of packets lost: Should be determined as the number of cell losts, or set to zero if the adaptation layer does not enable the gateway to assess losses.
Interarrival jitter: Should be understood as the interarrival jitter between ATM cells.
The gateway may not be able to assess this parameter over an ATM network.
It could simply report a null value.
When the connection was set up over an LOCAL interconnect, the meaning of these parameters is defined as follows:
Number of packets sent: Not significant.
Number of octets sent: The total number of payload octets transmitted over the local connection.
Number of packets received: Not significant.
Number of octets received: The total number of payload octets received over the connection.
Number of packets lost: Not significant.
A value of zero is assumed.
A value of zero is assumed.
Average transmission delay: Not significant.
A value of zero is assumed.
The standard set of connection parameters can be extended by the creation of extension parameters.
The command may optionally contain an encapsulated Notification Request command, in which case a RequestIdentifier parameter will be present, as well as, optionnally, the RequestedEvents DigitMap, SignalRequests, QuarantineHandling and DetectEvents parameters.
The encapsulated NotificationRequest is executed simultaneously with the deletion of the connection.
For example, when a user hang up is notified, the gateway should be instructed to delete the connection and to start looking for an off hook event.
This can be accomplished in a single DeleteConnection command, by also transmitting the RequestedEvent parameters, for the off hook event, and an empty SignalRequest parameter.
When these parameters are present, the DeleteConnection and the NotificationRequests should be synchronized, which means that both should be accepted, or both refused.
The command may carry an encapsulated EndpointConfiguration command, that will apply to the same endpoint.
When this command is present, the parameters of the EndpointConfiguration command are inserted after the normal parameters of the DeleteConnection with the exception of the EndpointId, which is not replicated.
The EndpointConfiguration command may be encapsulated together with an encapsulated NotificationRequest command.
The encapsulated EndpointConfiguration command shares the fate of the DeleteConnection command.
If the DeleteConnection is rejected, the EndpointConfiguration is not executed.
ReturnCode is a parameter returned by the gateway.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
DeleteConnection (from the VoIP gateway)
In some circumstances, a gateway may have to clear a connection, for example because it has lost the resource associated with the connection, or because it has detected that the endpoint no longer is capable or willing to send or receive voice.
The gateway terminates the connection by using a variant of the DeleteConnection command: ReturnCode,   DeleteConnection( CallId, EndpointId, ConnectionId, Reason code, Connection parameters)
In addition to the call, endpoint and connection identifiers, the gateway will also send the call's parameters that would have been returned to the Call Agent in response to a DeleteConnection command.
The reason code indicates the cause of the disconnection.
ReturnCode is a parameter returned by the call agent.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
DeleteConnection (multiple connections, from the Call Agent)
A variation of the DeleteConnection function can be used by the Call Agent to delete multiple connections at the same time.
The command can be used to delete all connections that relate to a Call for an endpoint: ReturnCode,   DeleteConnection( CallId, EndpointId)
It can also be used to delete all connections that terminate in a given endpoint: ReturnCode,   DeleteConnection( EndpointId)
Finally, Call Agents can take advantage of the hierarchical naming structure of endoints to delete all the connections that belong to a group of endpoints.
In this case, the "local name" component of the EndpointID will be specified using the "all value" wildcarding convention.
The "any value" convention shall not be used.
This "wildcard" command instructs the gateway to delete all the connections that where attached to circuits connected to the physical interface "X35V3 A4".
After the connections have been deleted, the endpoint should be placed in inactive mode.
Any loopback that has been requested for the connections should be cancelled.
This command does not return any individual statistics or call parameters.
ReturnCode is a parameter returned by the gateway.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
The AuditEndPoint command can be used by the Call Agent to find out the status of a given endpoint.
ReturnCode, EndPointIdList { [RequestedEvents,] [DigitMap,]
The EndpointId identifies the endpoint that is being audited.
The "all of" wildcard convention can be used to start auditing of a group of endpoints.
If this convention is used, the gateway should return the list of endpoint identifiers that match the wildcard in the EndPointIdList parameter.
It shall not return any parameter specific to one of these endpoints.
When a non wildcard EndpointId is specified, the (possibly empty)
RequestedInfo parameter describes the information that is requested for the EndpointId specified.
The following endpoint info can be audited with this command: RequestedEvents, DigitMap, SignalRequests, RequestIdentifier, NotifiedEntity, ConnectionIdentifiers, DetectEvents, ObservedEvents, EventStates, RestartReason, RestartDelay, ReasonCode, and Capabilities.
The current value of RequestedEvents the endpoint is using including the action associated with each event.
Persistent events are included in the list.
DigitMap: the digit map the endpoint is currently using.
A list of the; Time Out signals that are currently active, On/Off signals that are currently "on" for the endpoint (with or without parameter), and any pending Brief signals.
Time  Out signals that have timed out, and currently playing Brief signals are not included.
RequestIdentifier, the RequestIdentifier for the last Notification Request received by this endpoint (includes NotificationRequest encapsulated in Connection handling primitives).
If no notification request has been received, the value zero will be returned.
QuarantineHandling, the QuarantineHandling for the last NotificationRequest received by this endpoint.
DetectEvents, the list of events that are currently detected in quarantine mode.
NotifiedEntity, the current notified entity for the endpoint.
ConnectionIdentifiers, the list of ConnectionIdentifiers for all connections that currently exist for the specified endpoint.
ObservedEvents: the current list of observed events for the endpoint.
For events that have auditable states associated with them, the event corresponding to the state the endpoint is in, e.g., off hook if the endpoint is off hook.
The definition of the individual events will state if the event in question has an auditable state associated with it.
the value of the last received BearerInformation parameter for this endpoint.
RestartReason: the value of the restart reason parameter in the last RestartInProgress command issued by the endpoint
, "restart" indicating a fully functional endpoint.
RestartDelay: the value of the  restart delay parameter if a RestartInProgress command was issued by the endpoint at the time of the response, or
zero if the command would not include this parameter.
ReasonCode:the value of the Reason Code parameter in the last RestartInProgress or DeleteConnection command issued by the gateway for the endpoint, or the special value
if the endpoint's state is nominal.
The capabilities for the endpoint similar to the LocalConnectionOptions parameter and including event packages and connection modes.
If there is a need to specify that some parameters, such as e.g., silence suppression, are only compatible with some    codecs,
then the gateway will return several capability sets:
Compression Algorithm: a list of supported codecs.
The rest of the parameters will apply to all codecs specified in this list.
A single value or a range may be specified.
A single value or a range corresponding to the range for packetization periods may be specified (assuming no silence suppression).
Whether echo cancellation is supported or not.
Whether silence suppression is supported or not.
Type of Service: Whether type of service is supported or not.
Event Packages: A list of event packages supported.
The first event package in the list will be the default package.
A list of supported connection modes.
The Call Agent may then decide to use the AuditConnection command to obtain further information about the connections.
If no info was requested and the EndpointId refers to a valid endpoint, the gateway simply returns a positive acknowledgement.
If no NotifiedEntity has been specified in the last NotificationRequest, the notified entity defaults to the source address of the last NotificationRequest command received for this connection.
ReturnCode is a parameter returned by the gateway.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
The AuditConnection command can be used by the Call Agent to retrieve the parameters attached to a connection: ReturnCode, [CallId,] [NotifiedEntity,] [LocalConnectionOptions,]
[Mode,] [RemoteConnectionDescriptor,] [LocalConnectionDescriptor,] [ConnectionParameters]   AuditConnection(EndpointId, ConnectionId, RequestedInfo)
The EndpointId parameter specifies the endpoint that handles the connection.
The wildcard conventions shall not be used.
The ConnectionId parameter is the identifier of the audited connection, within the context of the specified endpoint.
RequestedInfo describes the information that is requested for the ConnectionId within the EndpointId specified.
The following connection info can be audited with this command: CallId, NotifiedEntity, LocalConnectionOptions, Mode, RemoteConnectionDescriptor, LocalConnectionDescriptor,
NotifiedEntity, the current notified entity for the Connection.
LocalConnectionOptions, the LocalConnectionOptions that was supplied for the connection.
Mode, the current mode of the connection.
RemoteConnectionDescriptor, the RemoteConnectionDescriptor that was supplied to the gateway for the connection.
LocalConnectionDescriptor, the LocalConnectionDescriptor the gate
way supplied for the connection.
ConnectionParameters, the current value of the connection parameters for the connection.
If no info was requested and the EndpointId is valid, the gateway simply checks that the connection exists, and if so returns a positive acknowledgement.
If no NotifiedEntity has been specified for the connection, the notified entity defaults to the source address of the last connection handling command received for this connection.
ReturnCode is a parameter returned by the gateway.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
The RestartInProgress command is used by the gateway to signal that An endpoint, or a group of endpoint, is taken in or out of service.
( EndPointId, RestartMethod, [RestartDelay,] [Reason code]
The EndPointId identifies the endpoint that are taken in or out of service.
The "all of" wildcard convention may be used to apply the command to a group of endpoint, such as for example all endpoints that are attached to a specified interface, or even all endpoints that are attached to a given gateway.
The "any of" wildcard convention shall not be used.
The RestartMethod parameter specified the type of restart.
The established connections are not yet affected, but the Call Agent should refrain to establish new connections, and should try to gracefully tear down the existing connections.
A "forced" restart method indicates that the specified endpoints are taken abruptely out of service.
The established connections, if any, are lost.
A "restart" method indicates that service will be restored on the endpoints after the specified "restart delay.
" There are no connections that are currently established on the endpoints.
A "disconnected" method indicates that the endpoint has become disconnected and is now trying to establish connectivity.
The "restart delay" specifies the number of seconds the endpoint has been disconnected.
Established connections are not affected.
A "cancel graceful" method indicates that a gateway is canceling a previously issued "graceful" restart command.
The optional "restart delay" parameter is expressed as a number of seconds.
If the number is absent, the delay value should be considered null.
In the case of the "graceful" method, a null delay indicates that the call agent should simply wait for the natural termination of the existing connections, without establishing new connections.
The restart delay is always considered null in the case of the "forced" method.
A restart delay of null for the "restart" method indicates that service has already been restored.
This typically will occur after gateway startup/reboot.
The optional reason code parameter the cause of the restart.
Gateways SHOULD send a "graceful" or "forced" RestartInProgress message as a courtesy to the Call Agent when they are taken out of service, e.g., by being shutdown, or taken out of service by a network management system, although the Call Agent cannot rely on always receiving such messages.
Gateways MUST send a "restart"
RestartInProgress message with a null delay to their Call Agent when they are back in service according to the restart procedure specified in Section 4.3.4 Call Agents can rely on receiving this message.
Also, gateways MUST send a "disconnected" RestartInProgress message to their current "notified entity" according to the "disconnected" procedure specified in Section 4.3.5.
The "restart delay" parameter MUST NOT be used with the "forced" restart method.
The RestartInProgress message will be sent to the current notified entity for the EndpointId in question.
It is expected that a default Call Agent, i.e., notified entity, has been provisioned for each endpoint so, after a reboot, the default Call Agent will be the notified entity for each endpoint.
Gateways should take full advantage of wild  carding to minimize the number of RestartInProgress messages generated when multiple endpoints in a gateway restart and the endpoints are managed by the same Call Agent.
ReturnCode is a parameter returned by the gateway.
It indicates the outcome of the command and consists of an integer number optionally followed by commentary.
A NotifiedEntity may additionally be returned with the response from the Call Agent:
If the response indicated success (return code 200 transaction executed), the restart procedure has  completed, and the NotifiedEntity returned is the new "notified entity" for the endpoint(s).
If the response from the Call Agent indicated an error, the restart procedure is not yet complete, and must therefore be initiated again.
If a NotifiedEntity parameter was returned, it then specifies the new "notified entity" for the endpoint(s), which must consequently be used when retrying the restart procedure.
Return codes and error codes.
All MGCP commands are acknowledged.
The acknowledgment carries a return code, which indicates the status of the command.
The values that have been already defined are listed in the following list: 100
The transaction is currently being executed.
An actual completion message will follow on later.
The requested transaction was executed normally.
The transaction could not be executed, due to a transient error.
The phone is already off hook 402
The phone is already on hook 403
The transaction could not be executed, because the endpoint does not have sufficient resources at this time 404  Insufficient bandwidth at this time 500
The transaction could not be executed, because the endpoint is unknown.
The transaction could not be executed, because the endpoint is not ready.
The transaction could not be executed, because the endpoint does not have sufficient resources 510
The transaction could not be executed, because a protocol error was detected.
The transaction could not be executed, because the command contained an unrecognized extension.
The transaction could not be executed, because the gateway is not equipped to detect one of the requested events.
The transaction could not be executed, because the gateway is not equipped to generate one of the requested signals.
The transaction could not be executed, because the gateway cannot send the specified announcement.
The transaction refers to an incorrect connection
id (may have been already deleted)
The transaction refers to an unknown call
517  Unsupported or invalid mode.
518  Unsupported or unknown package.
519  Endpoint does not have a digit map.
The transaction could not be executed, because the endpoint is "restarting".
521  Endpoint redirected to another Call Agent.
No such event or signal.
523  Unknown action or illegal combination of actions 524  Internal inconsistency in LocalConnectionOptions 525  Unknown extension in LocalConnectionOptions 526  Insufficient bandwidth 527
Missing RemoteConnectionDescriptor 528  Incompatible protocol version 529  Internal hardware failure 530  CAS signaling protocol error.
531  failure of a grouping of trunks (e.g. facility failure).
Reason Codes Reason codes are used by the gateway when deleting a connection to inform the Call Agent about the reason for deleting the connection.
They may also be used in a RestartInProgress command, to inform the gateway of the Restart's reason.
The reason code is an integer number, and the following values have been defined: 000  Endpoint state is nominal.
(This code is used only in response to audit requests.)
900  Endpoint malfunctioning 901  Endpoint taken out of service 902  Loss of lower layer connectivity (e.g., downstream sync)
The MGCP implements the media gateway control interface as a set of transactions.
The transactions are composed of a command and a mandatory response.
The first four commands are sent by the Call Agent to a gateway.
The Notify command is sent by the gateway to the Call Agent.
The gateway may also send a DeleteConnection as defined in 2.3.6.
The Call Agent may send either of the Audit commands to the gateway.
The Gateway may send a RestartInProgress command to the Call Agent.
All commands are composed of a Command header, optionally followed by a session description.
All responses are composed of a Response header, optionally followed by a session description.
Headers and session descriptions are encoded as a set of text lines, separated by a carriage return and line feed character (or, optionnally, a single line feed character).
The headers are separated from the session description by an empty line.
MGCP uses a transaction identifier to correlate commands and responses.
The transaction identifier is encoded as a component of the command header and repeated as a component of the response header (see section 3.2.1, 3.2.1.2 and 3.3).
A set of parameter lines, composed of a parameter name followed by a parameter value.
Unless otherwise noted or dictated by other referenced standards, each component in the command header is case insensitive.
This goes for verbs as well as parameters and values, and all comparisons MUST treat upper and lower case as well as combinations of these as being equal.
The command line is composed of:
The name of the requested verb,
The identification of the transaction,
The name of the endpoint that should execute the command (in notifications or restarts, the name of the endpoint that is issuing the command),
These four items are encoded as strings of printable ASCII characters, separated by white spaces, i.e. the ASCII space (0x20) or tabulation (0x09) characters.
It is recommended to use exactly one ASCII space separator.
Coding of the requested verb
The verbs that can be requested are encoded as four letter upper or lower case ASCII codes (comparisons should be case insensitive) as defined in the following table:
The transaction identifier is encoded as a string of up to 9 decimal digits.
In the command lines, it immediately follows the coding of the verb.
New verbs may be defined in further versions of the protocol.
It may be necessary, for experimentation purposes, to use new verbs before they are sanctioned in a published version of this protocol.
Experimental verbs should be identified by a four letter code starting with the letter X, such as for example XPER.
Transaction Identifiers MGCP uses a transaction identifier to correlate commands and responses.
A gateway supports two separate transaction identifier name spaces: a transaction identifier name space for sending transactions, and a transaction identifier name space for receiving transactions.
At a minimum, transaction identifiers for commands sent to a given gateway MUST be unique for the maximum lifetime of the transactions within the collection of Call Agents that control that gateway.
Thus, regardless of the sending Call Agent, gateways can always detect duplicate transactions by simply examining the transaction identifier.
The coordination of these transaction identifiers between Call Agents is outside the scope of this specification though.
Transaction identifiers for all commands sent from a given gateway MUST be unique for the maximum lifetime of the transactions regardless of which Call Agent the command is sent to.
Thus, a Call Agent can always detect a duplicate transaction from a gateway by the combination of the domain name of the endpoint and the transaction identifier.
The transaction identifier is encoded as a string of up to nine decimal digits.
In the command lines, it immediately follows the coding of the verb.
Transaction identifiers have values between 1 and 999999999.
An MGCP entity MUST NOT reuse a transaction identifier more quickly than three minutes after completion of the previous command in which the identifier was used.
Coding of the endpoint identifiers and entity names
The endpoint identifiers and entity names are encoded as case insensitive e mail addresses, as defined in RFC 821.
In these addresses, the domain name identifies the system where the endpoint is attached, while the left side identifies a specific endpoint on that system.
The name of notified entities is expressed with the same syntax, with the possible addition of a port number as in: Call agent@ca.example.net:5234
In case the port number is omitted, the default MGCP port (2427) will be used.
Coding of the protocol version
The protocol version is coded as the key word MGCP followed by a white space and the version number, and optionally followed by a profile name..
The version number is composed of a major version, coded by a decimal number, a dot, and a minor version number, coded as a decimal number.
The version described in this document is version 1.0.
The profile name, if present, is represented by a white space separated strings of  visible (printable) characters extending to the end of the line.
Profile names may be defined for user communities who want to apply restrictions or other profiling to MGCP.
In the initial messages, the version will be coded as: MGCP 1.0 3.2.2.
Parameter lines are composed of a parameter name, which in most cases is composed of a single upper case character, followed by a colon, a white space and the parameter value.
The parameter that can be present in commands are defined in the following table:
A text encoding of a digit map
The parameters are not necessarily present in all commands.
The following table provides the association between parameters and commands.
The letter M stands for mandatory, O for optional and F for forbidden.
O    O    O    O    O    O    O
F    F    F    F    O
F    F    F    F    F    F
If these parameters are omitted, the corresponding lists will be considered empty.
If implementers need to experiment with new parameters, for example when developing a new application of MGCP, they should identify these parameters by names that start with the string
"X " or "X ", such as for example:
Daisy Parameter names that start with "X " are critical parameter extensions.
An MGCP entity that receives a critical parameter extension that it cannot understand should refuse to execute the command.
It should respond with an error code 511 (Unrecognized extension).
Parameter names that start with "X " are non critical parameter extensions.
An MGCP entity that receives a non critical parameter extension that it cannot understand can safely ignore that parameter.
The local connection options describe the operational parameters that the Call Agent suggests to the gateway.
If the Call Agent specifies a range of values, the range will be specified as two decimal numbers separated by an hyphen.
The preferred type of compression algorithm, encoded as the keyword "a", followed by a colon and a character string.
If the Call Agent specifies a list of values, these values will be separated by a semicolon.
The bandwidth in kilobits per second (1000 bits per second), encoded as the keyword "b", followed by a colon and a decimal number.
If the Call Agent specifies a range of values, the range will be specified as two decimal numbers separated by an hyphen.
The echo cancellation parameter, encoded as the keyword "e", followed by a colon and the value "on" or "off".
The gain control parameter, encoded as the keyword "gc", followed by a colon a value which can be either the keyword "auto" or a decimal number (positive or negative) representing the number of decibels of gain.
The silence suppression parameter, encoded as the keyword "s", followed by a colon and the value "on" or "off".
The type of service parameter, encoded as the keyword "t", followed by a colon and the value encoded as two hexadecimal digits.
The resource reservation parameter, encoded as the keyword "r", followed by a colon and the value "g" (guaranteed service), "cl" (controlled load) or "be" (best effort).
The encryption key, encoded as the keyword "k"
followed by a colon and a key specification, as defined for the parameter "K" of SDP (RFC 2327).
The type of network, encoded as the keyword "nt" followed by a colon and the type of network encoded as the keyword "IN", "ATM" or "LOCAL".
Each of the parameters is optional.
When several parameters are present, the values are separated by a comma.
Examples of connection descriptors are: L: p:10, a:PCMU L:
b:32 64, e:off These set of attributes may be extended by extension attributes.
Extension attributes are composed of an attribute name, followed by a semi colon and by an attribute value.
The attribute name should start by the two characters "x ", for a mandatory extensions, or "x ", for a non mandatory extension.
If a gateway receives a mandatory extension attribute that it does not recognize, it should reject the command with an error code 525 (Unknown extension in LocalConnectionOptions).
Capabilities Capabilities inform the Call Agent about endpoints' capabilities when audited.
The encoding of capabilities is based on the Local Connection Options encoding for the parameters that are common to both.
In addition, capabilities can also contain a list of supported packages, and a list of supported modes.
A list of supported codecs.
The following parameters will apply to all codecs specified in this list.
If there is a need to specify that some parameters, such as e.g. silence suppression, are only compatible with some codecs, then the gateway will return several LocalConnectionOptions parameters, one for each set of codecs.
Packetization Period: A range may be specified.
A range corresponding to the range for packetization periods may be specified (assuming no silence suppression).
If absent, the values will be deduced from the codec type.
Echo Cancellation: "on" if echo cancellation is supported for this codec, "off" otherwise.
Silence Suppression: "on" if silence suppression is supported for this codec, "off" otherwise.
Gain Control: "0" if gain control is not supported.
The value "0" indicates no support for type of service, all other values indicate support for type of service.
The parameter indicates the reservation services that are supported, in addition to best effort.
The value "g" is encoded when the gateway supports both the guaranteed and the controlled load service, "cl" when only the controlled load service is supported.
The default is "best effort."
Encryption Key: Encoding any value indicates support for encryption.
The keyword "nt", followed by a colon and a semicolon separated list of supported network types.
Event Packages The event packages supported by this endpoint encoded as the keyword "v", followed by a colon and a character string.
If a list of values is specified, these values will be separated by a semicolon.
The first value specified will be the default package for that endpoint.
The modes supported by this endpoint encoded as the keyword "m", followed by a colon and a semicolon separated list of supported connection modes for this endpoint.
Connection parameters Connection parameters are encoded as a string of type and value pairs, where the type is a either letter identifier of the parameter or an extension type, and the value a decimal integer.
Parameters are encoded from each other by a comma.
Extension parameters names are composed of the string "X " followed by a two letters extension parameter name.
Call agents that received unrecognized extensions shall silently ignore these extensions.
An example of connection parameter encoding is: P: PS 1245, OS 62345, PR 0, OR 0, PL 0, JI 0, LA 48 3.2.2.5.
Reason Codes Reason codes are three digit numeric values.
The reason code is optionally followed by a white space and commentary, e.g.: 900 Endpoint malfunctioning A list of reason codes can be found in Section 2.5.
The connection mode describes the mode of operation of the connection.
Event names are used in the RequestedEvents, SignalRequests and ObservedEvents parameter.
Each signal has one of the following signal types associated with: On/Off (OO), Time out (TO), Brief (BR).
(These signal types are specified in the package definitions, and are not present in the messages.)
If an on/off signal is not parameterized, the signal is turned on.
The following are valid examples of event names:
In addition, the range and wildcard notation of events can be used, instead of individual names, in the RequestedEvents and DetectEvents parameters.
The star sign can be used to denote "all connections", and the dollar sign can be used to denote the "current" connection.
All events in the trunk packages.
The RequestedEvent parameter provides the list of events that have been requested.
The event codes are described in the previous section.
Each event can be qualified by a requested action, or by a list of actions.
The actions, when specified, are encoded as a list of keywords, enclosed in parenthesis and separated by commas.
according to digit map    D
When no action is specified, the default action is to notify the event.
This means that, for example, ft and ft(N) are equivalent.
Events that are not listed are ignored.
The digit map action can only be specified for the digits, letters and interdigit timers in the MF and DTMF packages, or in other packages that would define the encoding of digits and timers.
The requested list is encoded on a single line, with event/action groups separated by commas.
Examples of RequestedEvents encoding are: R: hu(N), hf(S,N
) R: hu(N), [0 9#T](D)
In the case of the "enable" action, the embedded notification request parameters are encoded as a list of up to three parameter groups, separated by commas.
Each group start by a one letter identifier, followed by a list of parameters enclosed between parenthesis.
The first optional parameter group, identified by the letter "R", is the enabled value of the RequestedEvents parameter.
The second optional group, identified by the letter "S", is the enabled value of the SignalRequests parameter.
The third optional group, identified by the letter "D", is the enabled value of the DigitMap.
(Note that some existing implementation may encode these three components in a different order.)
If the RequestedEvents is not present, the parameter will be set to a null value.
If the SignalRequest is not present, the parameter will be set to a null value.
If the DigitMap is absent, the current value should be used.
The following are valid examples of embedded requests: R: hd(E(R([0 9#T](D),hu(N)),S(dl),D([0 9].[#T])))
The SignalRequests parameter provides the name of the signals that have been requested.
Each signal is identified by a name, as indicated in the previous section.
These parameters will be encoded as a set of UTF8 character strings, spearated by comams and enclosed within parenthesis, as in: S: adsi("123456 Francois Gerard")
When several signals are requested, their codes are separated by a comma, as in: S: asdi(123456 Your friend), rg 3.2.2.10.
The observed event parameters provides the list of events that have been observed.
The event codes are the same as those used in the NotificationRequest.
Events that have been accumulated according to the digit map may be grouped in a single string; they should be reported as lists of isolated events if other events where detected during the digit accumulation.
Examples of observed actions are: O:
The RequestedInfo parameter contains a comma separated list of parameter codes, as defined in the "Parameter lines" section.
For example, if one wants to audit the value of the NotifiedEntity, RequestIdentifier, RequestedEvents, SignalRequests, DigitMap, QuarantineHandling and DetectEvents parameters, The value of the RequestedInfo parameter will be:
The capabilities request, in the AuditEndPoint command, is encoded by the keyword "A", as in: F:A 3.2.2.12.
The quarantine handling parameter contains a list of comma separated keywords:
The keyword "process" or "discard" to indicate the treatment of quarantined events.
If neither process or discard is present, process is assumed.
The keyword "step" or "loop" to indicate whether exactly at most one notification is expected, or whether multiple notifications are allowed.
If neither step or loop is present, step is assumed.
The following values are valid examples: Q:loop Q:process Q:discard,loop 3.2.2.13.
The DetectEvent parameter is encoded as a comma separated list of events, such as for example:
It should be noted, that no actions can be associated with the events.
The EventStates parameter is encoded as a comma separated list of events, such as for example:
It should be noted, that no actions can be associated with the events.
RestartMethod The RestartMethod parameter is encoded as one of the keywords "graceful", "forced", "restart", "disconnected" or "cancel graceful" as for example: RM:restart 3.2.2.16.
The values of the bearer informations are encoded as a comma separated list of attributes, represented by an attribute name, separated by a colon from an attribute value.
The only attribute that is defined is the "encoding" (code "e"), whose defined values are "A" (A law) and "mu" (mu law).
An example of bearer information encoding is: B: e:mu 3.3.
The response header is composed of a response line, optionally followed by headers that encode the response parameters.
An example of response header could be: 200 1203 OK
The response line starts with the response code, which is a three digit numeric value.
The code is followed by a white space, the transaction identifier, and an optional commentary preceded by a white space.
The following table describe the parameters whose presence is mandatory or optional in a response header, as a function of the command that triggered the response.
The letter M stands for mandatory, O for optional and F for forbidden.
F    F    F    F    F    F
F    F    F    F    F    F    F
F    F    F    F    F    F
F    F    F    F    F
F    F    F    F    F    F
F    F    F    F    F    F
F    F    F    F    F    F
F    F    F    F    F    F
In the case of a CreateConnection message, the response line is followed by
It may also be followed a Specific Endpoint Id parameter, if the creation request was sent to
a wildcarded Endpoint Id. The connection
Id parameter is marked as optional in the Table.
In fact, it is mandatory with all positive responses, when a connection was created, and forbidden when the response is negative, when no connection as created.
In the case of a DeleteConnection message, the response line is followed by a Connection Parameters parameter, as defined in section 3.2.2.2.
A LocalConnectionDescriptor should be transmitted with a positive response (code 200) to a CreateConnection.
It may be transmitted in response to a ModifyConnection command, if the modification resulted in a modification of the session parameters.
The LocalConnectionDescriptor is encoded as a "session description," as defined in section 3.4.
It is separated from the response header by an empty line.
When several session descriptors are encoded in the same response, they are encoded one after each other, separated by an empty line.
This is the case for example when the response to an audit connection request carries both a local session description and a remote session description, as in: 200 1203 OK C:
PCMU;G726 32 M: sendrecv P:
PS 1245, OS 62345, PR 780, OR 45123, PL 10, JI 27,LA
48 v 0 c IN IP4 128.96.41.1
m audio 1296 RTP/AVP 0 v 0 c IN IP4 128.96.63.25
m audio 1296 RTP/AVP 0 96
The local description is always transmitted before the remote description.
If a connection descriptor is requested, but it does not exist for the connection audited, that connection descriptor will appear with the SDP protocol version field only.
Formal syntax description of the protocol In this section
, we provided a formal description of the protocol syntax, following the "Augmented BNF for Syntax Specifications" defined in RFC 2234.
MGCPMessage   MGCPCommand / MGCPResponse MGCPCommand
"X" 3(ALPHA / DIGIT) transaction
1 9(DIGIT) endpointName    localEndpointName "@"
The audit request response may include a list of identifiers
(eventId / "all" / eventRange)
(ALPHA / DIGIT / HYPHEN)
"," 0 (WSP) requestedAction) requestedAction
QuarantineHandling   loopControl / processControl / (loopControl "
(%x00 21 / %x23 FF)
EOL   CRLF / LF SDPinformation
Encoding of the session description
The session description is encoded in conformance with the session description protocol, SDP.
MGCP implementations are expected to be fully capable of parsing any conformant SDP message, and should send session descriptions that strictly conform to the SDP standard.
if the mode is set to any other value, the session description is for an audio service.
For an audio service, the gateway will consider the information provided in SDP for the "audio" media.
For a data service, the gateway will consider the information provided for the "network  access" media.
Usage of SDP for an audio service
In a telephony gateway, we only have to describe sessions that use exactly one media, audio.
The parameters of SDP that are relevant for the telephony application are: At the session description level:
The IP address of the remote gateway (in commands) or of the local gateway (in responses), or multicast address of the audio conference, encoded as an SDP "connection data" parameter.
This parameter specifies the IP address that will be used to exchange RTP packets.
This list should normally always include the code 0 (reserved for PCMU).
Optionally, an attribute defining the type of connection (sendonly, recvonly, sendrecv, inactive).
Note that this attribute does not have a direct relation with the "Mode" parameter of MGCP.
In fact, the SDP type of connection will most of the time be set to "sendrecv", regardless of the value used by MGCP.
Other values will only be used rarely, for example in the case of information or announcement servers that need to establish one way connections.
The IP address of the remote gateway (in commands) or of the local gateway (in responses), if it is not present at the session level.
An example of SDP specification for an audio connection could be:
v 0 c IN IP4 128.96.41.1
m audio 3456 RTP/AVP 0 96
There is a request, in some environments, to use the MGCP to negotiate connections that will use other transmission channels than RTP over UDP and IP.
This will be detailed in an extension to this document.
Usage of SDP in a network access service
The field may also specify the port that should be used for contacting the server, as specified in the SDP syntax.
Connection address parameter (c ) specifying the address, or the domain name, of the server that implement the access control method.
This parameter may also be specified at the session level.
Optionally, a bearer type attribute (a bearer:) describing the type of data connection to be used, including the modem type.
Optionally, a framing type attribue (a framing:) describing the type of framing that will be used on the channel.
Optionally, attributes describing the called number (a dialed:), the number to which the call was delivered (a called:) and the calling number (a dialing:).
Optionally, attributes describing the range of addresses that could be used by the dialup client on its LAN (a subnet:).
Optionally, an encryption key, encoded as specified in the SDP protocol(k ).
The connection address shall be encoded as specified in the SDP standard.
The address and port are those of the LNS.
If needed, the gateway may use the key specified in the announcement to access the service.
That key, in particular, may be used for the establishment of an L2TP tunnel.
The bearer attribute is composed of a bearer name and an optional extension.
The bearer type specifies the type of modulation (modem name) or, in the case of digital connections, the type of ISDN service (8 bits, 7 bits).
ISDN transparent access, 56 kbps
The network access authentication parameter provides instructions on the access control that should be exercized for the data call.
This optional attribute is encoded as: "a subnet:" <network type> <address type>
Where the parameters "network type", "address type", and "connection address" are formatted as defined for the connection address parameter (c ) in SDP, and where the "prefix length" is a decimal representation of the number of bits in the prefix.
Examples of SDP announcement for the network access service could be:
v 0 m nas/radius c IN IP4 radius.example.net
a dialed:18001234567 a called:12345678901 a
dialing:12340567890 v 0 m nas/none c IN IP4 128.96.41.1
IN IP4 123.45.67.64/26 a bearer:isdn64
a framing:ppp sync a dialed:18001234567
a dialing:2345678901 v 0 c IN IP4 access.example.net m nas/l2tp
k clear:some shared secret a bearer:v.32 a framing:
Usage of SDP for ATM connections
The specification of the SDP payload for ATM connections will be described in a companion document, "Usage of MGCP to control Voice over ATM gateways.
" The following text is indicative.
The "m audio" parameter will specify the audio encoding and, if needed, the VPI and VCI.
Additional attributes parameters (a ) will be used to specify the ATM coding variants, such as the type of adaptation layer and the error correction or loss compenmsation algorithms.
An example of SDP payload for an ATM connection could be: v 0 c ATM NSAP 47.0091.8100.0000.0060.3e64.fd01.0060.3e64.fd01.fe m audio 5/1002
ATM/AVP PCMU a connection type:AAL2 3.5.4.
Usage of SDP for local connections When MGCP is used to set up internal connections within a single gateway, the SDP format is used to encode the parameters of that connection.
The following parameters will be used:
The connection parameter (C ) will specify that the connection is local, using the keyword "LOCAL" as network type space, the keyword "EPN" (endpoint name) as  address type, and the name of the endpoint as the connection address.
The "m audio" parameter will specify a port number, which will always be set to 0, the type of protocol, always set to the keyword LOCAL, and the type of encoding, using the same conventions used for RTP (RTP payload numbers.)
The type of encoding should normally be set to 0 (PCMU).
An example of local SDP payload could be: v 0 c LOCAL
Transmission over UDP MGCP messages are transmitted over UDP.
Commands are sent to one of the IP addresses defined in the DNS for the specified endpoint .
The responses are sent back to the source address of the commands.
by the Gateways, to the default MGCP port for Call Agents, 2727.
Providing the At Most Once functionality MGCP messages, being carried over UDP, may be subject to losses.
In the absence of a timely response, commands are repeated.
Most MGCP commands are not idempotent.
The state of the gateway would become unpredictable if, for example, CreateConnection commands were executed several times.
The transmission procedures must thus provide an "At Most Once" functionality.
MGCP entities are expected to keep in memory a list of the responses that they sent to recent transactions and a list of the transactions that are currently being executed.
The transaction identifiers of incoming commands are compared to the transaction identifiers of the recent responses.
If a match is found, the MGCP entity does not execute the transaction, but simply repeats the response.
The remaining commands will be compared to the list of current transaction.
If a match is found, the MGCP entity does not execute the transaction, which is simply ignored.
The procedure use a long timer value, noted LONG TIMER in the following.
The timer should be set larger than the maximum duration of a transaction, which should take into account the maximum number of repetitions, the maximum value of the repetition timer and the maximum propagation delay of a packet in the network.
A suggested value is 30 seconds.
The copy of the responses can be destroyed either LONG TIMER seconds after the response is issued, or when the gateway (or the call agent) receives a confirmation that the response has been received, through the "Response Acknowledgement attribute".
For transactions that are acknowledged through this attribute, the gateway shall keep a copy of the transaction id for LONG TIMER seconds after the response is issued, in order to detect and ignore duplicate copies of the transaction request that could be produced by the network.
Transaction identifiers and three ways handshake Transaction identifiers are integer numbers in the range from 0 to 999,999,999.
Call agents may decide to use a specific number space for each of the gateways that they manage, or to use the same number space for all gateways that belong to some arbitrary group.
Call agents may decide to share the load of managing a large gateway between several independent processes.
These processes will share the same transaction number space.
There are multiple possible implementations of this sharing, such as having a centralized allocation of transaction identifiers, or pre allocating non  overlapping ranges of identifiers to different processes.
The implementations must guarantee that unique transaction identifiers are allocated to all transactions that originate from a logical call agent, as defined in the "states, failover and race conditions" section.
Gateways can simply detect duplicate transactions by looking at the transaction identifier only.
The Response Acknowledgement Attribute can be found in any command.
It carries a set of "confirmed transaction id ranges."
MGCP gateways may choose to delete the copies of the responses to transactions whose id is included in "confirmed transaction
id ranges" received in the Response Confirmation messages.
They should silently discard further commands from that Call Agent when the transaction id falls within these ranges.
The "confirmed transaction id ranges" values shall not be used if more than LONG TIMER seconds have elapsed since the gateway issued its last response to that call agent, or when a gateway resumes operation.
In this situation, commands should be accepted and processed, without any test on the transaction id.
Commands that carry the "Response Acknowledgement attribute" may be transmitted in disorder.
The gateway shall retain the union of the "confirmed transaction id ranges" received in recent commands.
It is the responsibility of the requesting entity to provide suitable time outs for all outstanding commands, and to retry commands when time outs have been exceeded.
Furthermore, when repeated commands fail to be acknowledged, it is the responsibility of the requesting entity to seek redundant services and/or clear existing or pending connections.
The specification purposely avoids specifying any value for the retransmission timers.
These values are typically network dependent.
The retransmission timers should normally estimate the timer by measuring the time spent between the sending of a command and the return of a response.
The retransmission timer, in TCP, is set to the sum of the average delay plus N times the average deviation.
In MGCP, the maximum value of the timer should however be bounded, in order to guarantee that no repeated packet will be received by the gateways after LONG TIMER seconds.
A suggested maximum value is 4 seconds.
After any retransmission, the MGCP entity should do the following:
It should double the estimated value of the average delay, AAD    It should compute a random value, uniformly distributed between 0.5 AAD and AAD
It should set the retransmission timer to the sum of that random value and N times the average deviation.
This procedure has two effects.
Because it includes an exponentially increasing component, it will automatically slow down the stream of messages in case of congestion.
Because it includes a random component, it will break the potential synchronization between notifications triggered by the same external event.
There are cases when a Call Agent will want to send several messages at the same time to the same gateways.
When several MGCP messages have to be sent in the same UDP packets, they should be separated by a line of text that contain a single dot, as in for example: 200 2005 OK DLCX 1244
The piggy backed messages should be processed exactly has if they had been received in several simultaneous messages.
Provisional responses Executing some transactions may require a long time.
Long execution times may interact with the timer based retransmission procedure.
This may result either in an inordinate number of retransmissions, or in timer values that become too long to be efficient.
Gateways that can predict that a transaction will require a long execution time may send a provisional response, with response code 100.
They should send this response if they receive a repetition of a transaction that is still being executed.
MGCP entities that receive a provisional response shall switch to a longer repetition timer for that transaction.
States, failover and race conditions.
In order to implement proper call signalling, the Call Agent must keep track of the state of the endpoint, and the gateway must make sure that events are properly notified to the call agent.
Special conditions exist when the gateway or the call agent are restarted: the gateway must be redirected to a new call agent during "failover" procedures, the call agent must take special action when the gateway is taken offline, or restarted.
The support of "failover" is based on the following assumptions:
Call Agents are identified by their domain name, not their network addresses, and several addresses can be associated with a domain name.
An endpoint has one NotifiedEntity associated with it any given point in time.
The NotifiedEntity is the last value of the "NotifiedEntity" parameter received for this endpoint (including wild carded end  point names).
When the "notified entity" refers to a domain name that resolves to multiple IP  address, endpoints are capable of switching between different interfaces on the same  logical call agent, however they cannot switch to other (backup) call agent(s) on their own.
A backup call agent can however instruct them to switch, either directly or indirectly.
If an entire call agent becomes unavailable, the endpoints managed by that call agent will eventually become "disconnected".
The only way for these endpoints to become connected again is either for the failed call agent to become available, or for a backup call agent to contact the affected endpoints.
When a backup call agent has taken over control of a group of endpoints, it is assumed that the failed call agent will communicate and synchronize with the backup call agent in order to transfer control of the affected endpoints back to the original call agent (if that's even desired maybe the failed call agent should simply become the backup call agent now).
We should note that handover conflict resolution between separate CA's is not in place we are relying strictly on the CA's knowing what they are doing and communicating with each other (although AuditEndpoint can be used to learn about the current NotifiedEntity).
Security, Retransmission, and Detection of Lost Associations: The media gateway control protocol is organized as a set of transactions, each of which is composed of a command and a response, commonly referred to as an acknowledgement.
The MGCP messages, being carried over UDP, may be subject to losses.
In the absence of a timely response, commands are repeated.
MGCP entities are expected to keep in memory a list of the responses that they sent to recent transactions, i.e. a list of all the responses they sent over the last LONG TIMER seconds, and a list of the transactions that are currently being executed.
The transaction identifiers of incoming commands are compared to the transaction identifiers of the recent responses.
If a match is found, the MGCP entity does not execute the transaction, but simply repeats the response.
The remaining commands will be compared to the list of current transaction.
If a match is found, the MGCP entity does not execute the transaction, which is simply ignored a response will be provided when the execution of the command is complete.
The elements should be able to derive from the past history an estimate of the packet loss rate due to transmission errors.
In a properly configured system, this loss rate should be kept very low, typically less than 1%.
If a call agent or a gateway has to repeat a message more than a few times, it is very legitimate to assume that something else than a transmission error is occurring.
For example, given a loss rate of 1%, the probability that 5 consecutive transmission attempts fail is 1 in 100 billion, an event that should occur less than once every 10 days for a call agent that processes 1,000 transactions per second.
(Indeed, the number of repetition that is considered excessive should be a function of the prevailing packet loss rate.)
We should note that the "suspicion threshold", which we will call "Max1", is normally lower than the "disconnection threshold", which should be set to a larger value.
A classic retransmission algorithm would simply count the number of successive repetitions, and conclude that the association is broken after re transmitting the packet an excessive number of times (typically between 7 and 11 times.)
In order to account for the possibility of an undetected or in progress "failover", we modify the classic algorithm as follows:
We request that the gateway always checks for the presence of a new call agent.
It can be noticed either by  receiving a valid multicast message announcing a failover, or  receiving a command where the NotifiedEntity points to the new call agent, or  receiving a redirection response pointing to a new Call Agent.
If a new call agent is detected, the gateway starts transmitting outstanding commands to that new agent.
Responses to commands are still transmitted to the source address of the command.
we request that if the number of repetitions for this Call Agent is larger than "Max1", that the gateway actively queries the name server in order to detect the possible change of the call agent interfaces.
The gateway may have learned several IP addresses for the call agent.
If the number of repetitions is larger than "Max1" and lower than "Max2", and there are more interfaces that have not been tried, then the gateway should direct the retransmissions to alternate addresses.
If there are no more interfaces to try, and the number of repetitions is Max2, then the gateway contacts the DNS
one more time to see if any other interface should have become available.
If not, the gateway is now disconnected.
The procedure will maximize the chances of detecting an ongoing failover.
It poses indeed two very specific problems, the potentially long delays of a timer based procedure and the risk of confusion caused by the use of cryptographic protections.
In order to automatically adapt to network load, MGCP specifies exponentially increasing timers.
If the initial timer is set to 200 milliseconds, the loss of a fifth retransmission will be detected after about 6 seconds.
This is probably an acceptable waiting delay to detect a failover.
The repetitions should continue after that delay not only in order to perhaps overcome a transient connectivity problem, but also in order to allow some more time for the execution of a failover waiting a total delay of 30 seconds is probably acceptable.
It is however important that the maximum delay of retransmissions be bounded.
Prior to any retransmission, it is checked that the time elapsed since the sending of the initial datagram is no greater than T  MAX.
If more than T MAX time has elapsed, the endpoint becomes disconnected.
The value T MAX is related to the LONG TIMER value: the LONG TIMER value is obtained by adding to T MAX the maximum propagation delay in the network.
Another potential cause of connection failure would be the reception of a "wrong key" message, sent by a call agent that could not authenticate the command, presumably because it had lost the security parameters of the association.
Such messages are actually not authorized in IPSEC, and they should in fact not be taken at face value: an attacker could easily forge "wrong key" messages in order to precipitate the loss of a control connection.
The current algorithm ignores these messages, which translates into a strict reliance on timers.
The algorithm could in fact be improved, maybe by executing a check with the key server of the call agent after "Max1" repetitions.
Race conditions MGCP deals with race conditions through the notion of a "quarantine list" and through explicit detection of desynchronization.
MGCP does not assume that the transport mechanism will maintain the order of command and responses.
This may cause race conditions, that may be obviated through a proper behavior of the call agent.
(Note that some race conditions are inherent to distributed systems; they would still occur, even if the commands were transmitted in strict order.)
In some cases, many gateways may decide to restart operation at the same time.
This may occur, for example, if an area loses power or transmission capability during an earthquake or an ice storm.
When power and transmission are reestablished, many gateways may decide to send "RestartInProgress" commands simultaneously, leading to very unstable operation.
Quarantine list MGCP controlled gateways will receive "notification requests" that ask them to watch for a list of "events."
The protocol elements that determine the handling of these events are the "Requested Events" list, the "Digit Map" and the "Detect Events" list.
When the endpoint is initialized, the requested events list and the digit map are empty.
After reception of a command, the gateway starts observing the endpoint for occurrences of the events mentioned in the list.
The events are examined as they occur.
The action that follows is determined by the "action" parameter associated to the event in the list of requested events, and also by the digit map.
The events that are defined as "accumulate" or "treat according to digit map" are accumulated in a list of events, the events that are marked as "treated according to the digit map" will additionally be accumulated in the dialed string.
This will go on until one event is encountered that triggers a Notification to the "notified entity.
The gateway, at this point, will transmit the notification command and will place the endpoint in a "notification" state.
As long as the endpoint is in this notification state, the events that are to be detected on the endpoint are stored in a "quarantine" buffer for later processing.
The events are, in a sense, "quarantined.
" All events that are specified by the union of the RequestedEvents parameter and the most recently received DetectEvent parameter or, in the absence of the latter, all events that are referred to in the RequestedEvents, should be detected and quarantined, regardless of the action associated to the event.
The endpoint exits the "notification state" when the acknowledgement of the Notify  command is received.
The Notify command may be retransmitted in the "notification state", as specified in section 3.5.
When the endpoint exits the "notification state" it resets the list of observed events and the "current dial string" of the endpoint to a null value.
Following that point, the behavior of the gateway depends on the value of The QuarantineHandling parameter in the notification request.
If the Call Agent specified that it expected at most one notification in response to the notification request command, then the gateway should simply keep on accumulating events in the quarantine list until it receives the next notification request command.
If the gateway is authorized to send multiple successive Notify commands, it will proceed as follows.
When the gateway exits the "notification state", it resets the list of observed events and the "current dial string" of the endpoint to a null value and starts processing the list of quarantined events, using the already received list of requested events and digit map.
When processing these events, the gateway may encounter an event which requires a Notify command to be sent.
The dial string is reset to a null value after each triggering event.
The events that follow the last triggering event are left in the quarantine list.
If the gateway transmits a Notify command, the end point will remain in the "notification state" until the acknowledgement is received.
If the gateway does not find a quarantined event that requests a Notify command, it places the end point in a normal state.
Events are then processed as they come, in exactly the same way as if a Notification Request command had just been received.
A gateway may receive at any time a new Notification Request command for the end point.
When a new notification request is received in the notification state, the gateway shall ensure that the pending notification is received by the Call Agent prior to a successful response to the new NotificationRequest.
It does so by using the "piggy backing" functionality of the protocol.
The messages will then be sent in a single packetto the source of the new NotificationRequest, regardless of respectively the source and "notified entity" for the old and new command.
The steps involved are the following: a)
the gateway builds a message that carries in a single packet a repetition of the old pending Notify command and the acknowledgement of the new notification request.
the endpoint is then taken out of the "notification state" without waiting for the acknowledgement of the notification command.
a copy of the unacknowledged Notify command command is kept until an acknowledgement is received.
If a timer elapses, the notification will be repeated, in a packet that will also carry a repetition of the acknowledgement of the notification request.
d) if the acknowledgement is lost, the Call Agent will retransmit the Notification Request.
The gateway will reply to this repetition by retransmitting in a single packet the unacknowledged Notify and the acknowledgement of the notification request.
e) if the gateway has to transmit a Notify before the previous Notify is acknowledged, it should construct a packet that piggybacks a repetition of the old Notify, a repetition of the acknowledgement of the last notification request and the new Notify.
f) Gateways that cannot piggyback several packets in the same message should elect to leave the endpoint in the "notification" state as long as the last notification is not acknowledged.
After receiving the Notification Request command, the requested events list and digit map (if a new one was provided) are replaced by the newly received parameters, and the list of observed events and accumulated dial string are reset to a null value.
The behavior is conditioned by the value of the QuarantineHandling parameter.
The parameter may specify that quarantined events, or previously observed events, should be discarded, in which case they will be.
If the parameter specifies that the quarantined events should be processed, the gateway will start processing the list of quarantined events or previously observed events, using the newly received list of requested events and digit map.
When processing these events, the gateway may encounter an event which requires a Notify command to be sent.
If that is the case, the gateway will immediately transmit a Notify command that will report all events that were accumulated in the list of observed events until the triggering event, included, leaving the unprocessed events in the quarantine buffer, and will enter the "notification state".
A new notification request may be received while the gateway has accumulated events according to the previous notification requests, but has not yet detected a notification triggering events.
The handling of not yet notified events is determined, as with the quarantined events, by the quarantine handling parameters:
If the quarantine handling parameter specifies that quarantined events shall be ignored, the observed event list is simply reset.
If the quarantine handling parameter specifies that quarantined events shall be processed, the observed event list is transferred to the quarantined event list.
The observed event list is then reset, and the quarantined event list is processed.
Call Agents SHOULD provide the response to a successful Notify message and the new NotificationRequest in the same datagram using the piggy backing mechanism.
A key element of the state of several endpoints is the position of the hook.
A race condition may occur when the user decides to go off hook before the Call Agent has the time to ask the gateway to notify an off hook event (the "glare" condition well known in telephony), or if the user goes on hook before the Call Agent has the time to request the event's notification.
To avoid this race condition, the gateway should check the condition of the endpoint before acknowledging a NotificationRequest.
It should return an error: 1
If the gateway is requested to notify an "off hook" transition while the phone is already off hook, 2  If the gateway is requested to notify an "on hook" or "flash hook" condition while the phone is already on hook.
It should be noted, that the condition check is performed at the time the notification request is received, where as the actual event that caused the current condition may have either been reported, or ignored earlier, or it may currently be quarantined.
The other state variables of the gateway, such as the list of RequestedEvent or list of requested signals, are entirely replaced after each successful NotificationRequest, which prevents any long term discrepancy between the Call Agent and the gateway.
When a NotificationRequest is unsuccessful, whether it is included in a connection handling command or not, the gateway will simply continue as if the command had never been received.
As all other transactions, the NotificationRequest should operate as an atomic transaction, thus any changes initiated as a result of the command should be reverted.
Another race condition may occur when a Notify is issued shortly before the reception by the gateway of a NotificationRequest.
The RequestIdentifier is used to correlate Notify commands with NotificationRequest commands.
Ordering of commands, and treatment of disorder MGCP does not mandate that the underlying transport protocol guarantees the sequencing of commands sent to a gateway or an endpoint.
This property tends to maximize the timeliness of actions, but it has a few draw backs.
If a new NotificationRequest is transmitted before a previous one is acknowledged, there is no guarantee that the previous one will not be received in second position.
Agents that want to guarantee consistent operation of the end points can use the following rules: 1) When a gateway handles several endpoints, commands pertaining to the different endpoints can be sent in parallel, for example following a model where each endpoint is controlled by its own process or its own thread.
When several connections are created on the same endpoint, commands pertaining to different connections can be sent in parallel.
On a given connection, there should normally be only one outstanding command (create or modify).
However, a DeleteConnection command can be issued at any time.
In consequence, a gateway may sometimes receive a ModifyConnection command that applies to a previously deleted connection.
Such commands should be ignored, and an error code should be returned.
On a given endpoint, there should normally be only one outstanding NotificationRequest command at any time.
The RequestId parameter should be used to correlate Notify commands with the triggering notification request.
In some cases, an implicitly or explicitly wildcarded DeleteConnection command that applies to a group of endpoints can step in front of a pending CreateConnection command.
The Call Agent should individually delete all connections whose completion was pending at the time of the global DeleteConnection command.
Also, new CreateConnection commands for endpoints named by the wild carding cannot be sent until the wild carded DeleteConnection command is acknowledged.
When commands are embedded within each other, sequencing requirements for all commands must be adhered to.
For example a Create Connection command with a Notification Request in it must adhere to the sequencing for CreateConnection and NotificationRequest at the same time.
7) AuditEndpoint and AuditConnection is not subject to any sequencing.
8) RestartInProgress must always be the first command sent by an endpoint as defined by the restart procedure.
Any other command or response must be delivered after this RestartInProgress command (piggy backing allowed).
When multiple messages are piggy backed in a single packet, the messages are always processed in order.
These rules do not affect the gateway, which should always respond to commands.
Fighting the restart avalanche Let's suppose that a large number of gateways are powered on simultaneously.
If they were to all initiate a RestartInProgress transaction, the call agent would very likely be swamped, leading to message losses and network congestion during the critical period of service restoration.
In order to prevent such avalanches, the following behavior is suggested: 1) When a gateway is powered on, it should initiate a restart timer to a random value, uniformly distributed between 0 and a maximum waiting delay (MWD).
Care should be taken to avoid synchronicity of the random number generation between multiple gateways that would use the same algorithm.
The gateway should then wait for either the end of this timer, the reception of a command from the call agent, or the detection of a local user activity, such as for example an off hook transition on a residential gateway.
When the timer elapses, when a command is received, or when an activity is detected, the gateway should initiate the restart procedure.
The restart procedure simply requires the endpoint to guarantee that the first message (command or response) that the Call Agent sees from this endpoint is a RestartInProgress message informing the Call Agent about the restart.
The endpoint is free to take full advantage of piggy backing to achieve this.
It is expected that each endpoint in a gateway will have a provisionable Call Agent, i.e., "notified entity", to direct the initial restart message towards.
When the collection of endpoints in a gateway is managed by more than one Call Agent, the above procedure must be performed for each collection of endpoints managed by a given Call Agent.
The gateway MUST take full advantage of wild carding to minimize the number of RestartInProgress messages generated when multiple endpoints in a gateway restart and the endpoints are managed by the same Call Agent.
The value of MWD is a configuration parameter that depends on the type of the gateway.
The following ]reasoning can be used to determine the value of this delay on residential gateways.
Call agents are typically dimensioned to handle the peak hour traffic load, during which, in average, 10% of the lines will be busy, placing calls whose average duration is typically 3 minutes.
The processing of a call typically involves 5 to 6 MGCP transactions between each end point and the call agent.
This simple calculation shows that the call agent is expected to handle 5 to 6 transactions for each end point, every 30 minutes on average, or, to put it otherwise, about one transaction per end point every 5 to 6 minutes on average.
This suggest that a reasonable value of MWD for a residential gateway would be 10 to 12 minutes.
In the absence of explicit configuration, residential gateways should adopt a value of 600 seconds for MWD.
The same reasoning suggests that the value of MWD should be much shorter for trunking gateways or for business gateways, because they handle a large number of endpoints, and also because the usage rate of these endpoints is much higher than 10% during the peak busy hour, a typical value being 60%.
These endpoints, during the peak hour, are this expected to contribute about one transaction per minute to the call agent load.
A reasonable algorithm is to make the value of MWD per "trunk" endpoint six times shorter than the MWD per residential gateway, and also inversely proportional to the number of endpoints that are being restarted.
for example MWD should be set to 2.5 seconds for a gateway that handles a T1 line, or to 60 milliseconds for a gateway that handles a T3 line.
In addition to the restart procedure, gateways also have a "disconnected" procedure, which is initiated when an endpoint becomes "disconnected" as described in Section 3.4.2.
It should here be noted, that endpoints can only become disconnected when they attempt to communicate with the Call Agent.
The following steps are followed by an endpoint that becomes "disconnected": 1.
A "disconnected" timer is initialized to a random value, uniformly distributed between 0 and a provisionable "disconnected" initial waiting delay (Tdinit), e.g., 15 seconds.
Care MUST be taken to avoid synchronicity of the random number generation between multiple gateways and endpoints that would use the same algorithm.
The gateway then waits for either the end of this timer, the reception of a command from the call agent, or the detection of a local user activity for the endpoint, such as for example an off  hook transition.
When the "disconnected" timer elapses, when a command is received, or when a local user activity is detected, the gateway initiates the "disconnected" procedure for the endpoint.
In the case of local user activity, a provisionable "disconnected" minimum waiting delay (Tdmin) must furthermore have elapsed since the gateway became disconnected or the last time it initiated the "disconnected" procedure in order to limit the rate at which the procedure is performed.
If the "disconnected" procedure still left the endpoint disconnected, the "disconnected" timer is then doubled, subject to a provisionable "disconnected" maximum waiting delay (Tdmax), e.g., 600 seconds, and the gateway proceeds with step 2 again.
The "disconnected" procedure is similar to the restart procedure in that it now simply states that the endpoint MUST send a RestartInProgress command to the Call Agent informing it that the endpoint was disconnected and furthermore guarantee that the first message (command or response) that the Call Agent now sees from this endpoint MUST be this RestartInProgress command.
The endpoint MUST take full advantage of piggy backing in achieving this.
The Call Agent may then for instance decide to audit the endpoint, or simply clear all connections for the endpoint.
This specification purposely does not specify any additional behavior for a disconnected endpoint.
Vendors MAY for instance choose to provide silence, play reorder tone, or even enable a downloaded wav file to be played.
The default value for Tdinit is 15 seconds, the default value for Tdmin, is 15 seconds, and the default value for Tdmax is 600 seconds.
Security requirements If unauthorized entities could use the MGCP, they would be able to set up unauthorized calls, or to interfere with authorized calls.
We expect that MGCP messages will always be carried over secure Internet connections, as defined in the IP security architecture as defined in RFC 2401, using either the IP Authentication Header, defined in RFC 2402, or the IP Encapsulating Security Payload, defined in RFC 2406.
An encryption service will provide additional protection against eavesdropping, thus forbidding third parties from monitoring the connections set up by a given endpoint
The encryption service will also be requested if the session descriptions are used to carry session keys, as defined in SDP.
These procedures do not necessarily protect against denial of service attacks by misbehaving gateways or misbehaving call agents.
However, they will provide an identification of these misbehaving entities, which should then be deprived of their authorization through maintenance procedures.
Protection of media connections MGCP allows call agent to provide gateways with "session keys" that can be used to encrypt the audio messages, protecting against eavesdropping.
A specific problem of packet networks is "uncontrolled barge in.
This attack can be performed by directing media packets to the IP address and UDP port used by a connection.
If no protection is implemented, the packets will be decompressed and the signals will be played on the "line side".
A basic protection against this attack is to only accept packets from known sources, checking for example that the IP source address and UDP source port match the values announced in the "remote session description."
But this has two inconveniences: it slows down connection establishment and it can be fooled by source spoofing:
To enable the address based protection, the call agent must obtain the remote session description of the e gress gateway and pass it to the in gress gateway.
This requires at least one network round trip, and leaves us with a dilemma:
either allow the call to proceed without waiting for the round trip to complete, and risk for example "clipping" a remote announcement, or wait for the full round trip and settle for slower call set up procedures.
Source spoofing is only effective if the attacker can obtain valid pairs of source destination addresses and ports, for example by listening to a fraction of the traffic.
To fight source spoofing, one could try to control all access points to the network.
But this is in practice very hard to achieve.
An alternative to checking the source address is to encrypt and authenticate the packets, using a secret key that is conveyed during the call set up procedure.
This will no slow down the call set up, and provides strong protection against address spoofing.
Event packages and end point types This section provides an initial definition of packages and event names.
More packages can be defined in additional documents.
In the tables of events for each package, there are five columns:
Symbol: the unique symbol used for the event Definition: a short description of the event R: an x appears in this column is the event can be Requested by the call agent.
if nothing appears in this column for an event, then the event cannot be signaled on command by the call agent.
Otherwise, the following symbols identify the type of event:
The signal is turned on until commanded by the call agent to turn it off, and vice versa.
The signal lasts for a given duration unless it is superseded by a new signal.
The event has a short, known duration.
Duration: specifies the duration of TO signals.
Generic Media Package Package Name:
G The generic media package group the events and signals that can be observed on several types of endpoints, such as trunking gateways, access gateways or residential gateways.
The signals are defined as follows: The pattern definition can be used for specific algorithms such as answering machine detection, tone detection, and the like.
an Audible Ring Tone, a combination of two AC tones with frequencies of 440 and 480 Hertz and levels of  19 dBm each, to give a combined level of  16 dBm.
The cadence for Audible Ring Tone is 2 seconds on followed by 4 seconds off.
See GR  506 CORE LSSGR:  SIGNALING, Section 17.2.5.
Ring back on connection A ring back tone, applied to the connection whose identifier is passed as a parameter.
The "long duration connection" is detected when a connection has been established for more than 1 hour.
In this case, timer T functions as an inter digit timer.
When timer T is used without a digit map, the timer is started immediately and simply cancelled (but not restarted) as soon as a digit is entered.
In this case, timer T can be used as an interdigit timer when overlap sending is used.
When used with a digit map, timer T takes on one of two values, T(partial) or T(critical).
When at least one more digit is required for the digit string to match any of the patterns in the digit map, timer T takes on the value T(partial), corresponding to partial dial timing.
If a timer is all that is required to produce a match, timer T takes on the value T(critical) corresponding to critical timing.
When timer T is used without a digit map, timer T takes on the value T(critical).
The default value for T(partial) is 16 seconds and the default value for T(critical) is 4 seconds.
The provisioning process may alter both of these.
The "long duration indicator" is observed when a DTMF signal is produced for a duration larger than two seconds.
In this case, the gateway will detect two successive events: first, when the signal has been recognized, the DTMF signal, and then, 2 seconds later, the long duration signal.
The definition of the MF package events is as follows:
Wink A transition from unseized to seized to unseized trunk states within a specified period.
Typical seizure period is 100 350 msec.)
Incoming seizure Incoming indication of call attempt.
Seizure in response to outgoing seizure.
Unseizure of a circuit at the end of a call.
A signal used in operator services trunks.
A transition from seized to unseized to seized trunk states within a specified period of 100 350 ms.
Old Milliwatt Tone (1000 Hz)
The definition of the trunk package signal events is as follows:
A tone at 2010   or 30 Hz.
A tone at the 1780   or 30 Hz.
Old Milliwatt Tone (1000 Hz), New Milliwatt Tone (1004 Hz)
Line Test: 105 Test Line test progress tone (2225
Hz   or 25 Hz at  10
No circuit: (that annoying tri tone, low to high)
: Reorder Tone: Reorder tone is a combination of two AC tones with frequencies of 480 and 620 Hertz and levels of  24 dBm each, to give a combined level of  21 dBm.
The cadence for Station Busy Tone is 0.25 seconds on followed by 0.25 seconds off, repeating continuously.
See GR 506 CORE LSSGR:
The continuity tones are used when the call agent wants to initiate a continuity test.
There are two types of tests, single tone and dual tone.
The Call agent is expected to know, through provisioning information, which test should be applied to a given endpoint.
For example, the call agent that wants to initiate a single frequency test will send to the gateway a command of the form:
If it wanted instead to initiate a dual tone test, it would send the command: RQNT 1234 epx t1/17@tgw2.example.net X:
The gateway would send the requested signal, and in both cases would look for the return of the 2010 Hz tone (co1).
When it detects that tone, it will send the corresponding  notification.
The tones are of type OO: the gateway will keep sending them until it receives a new notification request.
The definition of the tones is as follows:
Dial tone: A combined 350   440 Hz tone.
The transmission of the VMWI messages will conform to the requirements in Section 2.3.2, "
On hook Data Transmission Not Associated with Ringing" in TR H 000030 and the CPE guidelines in SR TSV 002476.
VMWI messages will only be sent from the SPCS when the line is idle.
If new messages arrive while the line is busy, the VMWI indicator message will be delayed until the line goes back to the idle state.
The CA should periodically refresh the CPE's visual indicator.
See TR NWT 001401 Visual Message Waiting Indicator Generic Requirements; and GR  30 CORE Voiceband Data Transmission Interface.
Message waiting Indicator See GR 506 CORE, 17.2.3.
Alerting Tone: a 440 Hz Tone of 2 second duration followed by 1/2 second of tone every 10 seconds.
Ring splash Ringsplash, also known as "Reminder ring" is a burst of ringing that may be applied to the physical forwarding line (when idle) to indicate that a call has been forwarded and to remind the user that a CF subfeature is active.
In the US, it is defined to be a 0.5( 0, 0.1) second burst of power ringing.
See TR TSY 000586 Call Forwarding Subfeatures.
Waiting tone is defined in GR 506 CORE, 14.2.
Call Waiting feature is defined in TR TSY 000571.
By defining "wt" as a TO signal you are really defining the feature which seems wrong to me (given the spirit of MGCP), hence the definition of "wt" as a BR signal in ECS, per GR 506 CORE.
Also, it turns out that there is actually four different call waiting tone patterns (see GR 506  CORE, 14.2)
so we have wt1, wt2, wt3, wt4.
Caller Id (ci(time, number, name))
: The caller id event carries three parameters, the time of the call, the calling number and the calling name.
Each of the three fields are optional, however each of the commas will always be included.
See TR NWT 001188, GR 30 CORE, and TR NWT 000031.
Recorder Warning Tone: 1400 Hz of Tone of 0.5 second duration every 15 seconds.
SIT tone: used for indicating a line is out of service.
Calling Card Service Tone: 60 ms of 941
Hz and 940 ms of 350
Can be used for distinctive ringing, customized dial tone, etc.
The report on completion event is detected when the gateway was asked to perform one or several signals of type TO on the endpoint, and when these signals were completed without being stopped by the detection of a requested event such as off hook transition or dialed digit.
The completion report may carry as parameter the name of the signal that came to the end of its live time, as in: O:
Ring back on connection A ring back tone, applied to the connection
wghose identifier is passed as a parameter.
We should note that many of these definitions vary from country to country.
The frequencies listed above are the one in use in North America.
There is a need to accommodate different tone sets in different countries, and there is still an ongoing debate on the best way to meet that requirement:
One solution is to define different event packages specifying for example the German dialtone as "L DE/DL".
Another solution is to use a management interface to specify on an endpoint basis which frequency shall be associated to what tone.
Handset emulation package Package Name:
The handset emulation package is an extension of the line package, to be used when the gateway is capable of emulating a handset.
The difference with the line package is that events such as "off hook" can be signalled as well as detected.
Codec Changed: Codec changed to hexadecimal codec number enclosed in parenthesis, as in UC(15), to indicate the codec was changed to PCM mu law.
Codec Numbers are specified in RFC 1890, or in a new definition of the audio profiles for RTP that replaces this RFC.
Some implementations of media gateways may not allow the codec to be changed upon command from the call agent.
codec changed to codec hexadecimal
Sampling Rate Changed: Sampling rate changed to decimal number in milliseconds enclosed in parenthesis, as in SR(20), to indicate the sampling rate was changed to 20 milliseconds.
Some implementations of media gateways may not allow the sampling rate to be changed upon command from a call agent.
Jitter Buffer Size Changed: When the media gateway has the ability to automatically adjust the depth of the jitter buffer for received RTP streams, it is useful for the media gateway controller to receive notification that the media gateway has automatically increased its jitter buffer size to accomodate increased or decreased variability in network latency.
The syntax for requesting notification is "JI", which tells the media gateway that the controller wants notification of any jitter buffer size changes.
Packet loss rate exceed the threshold of the specified decimal number of packets per 100,000 packets, where the packet loss number is contained in parenthesis.
For example, PL(10) indicates packets are being dropped at a rate of 1 in 10,000 packets.
The packet loss rate or the combination of delay and jitter exceed a specified quality threshold.
The continuity tones are the same as those defined in the Trunk package.
They can be use in conjunction with the Network LoopBack or Network Continuity Test modes to test the continuity of an RTP circuit.
The "operation failure" code can be used to report problems such as the loss of underlying connectivity.
The observed event can include as parameter the reason code of the failure.
Network Access Server Package Package Name:
The packet arrival event is used to notify that at least one packet was recently sent to an Internet address that is observed by an endpoint.
The event report includes the Internet address, in standard ASCII encoding, between parenthesis:
The call back event is used to notify that a call back has been requested during the initial phase of a data connection.
The event report includes the identification of the user that should be called back, between parenthesis: O: cbk(user25) 6.1.9.
Announcement Server Package Package Name:
The announcement action is qualified by an URL name and by a set of initial parameters as in for example: S: ann(http://scripts.example.net/all lines busy.au)
The "operation complete" event will be detected when the announcement is played out.
If the announcement cannot be played out, an operation failure event can be returned.
The failure may be explained by a commentary, as in: O: A/of(file not found) 6.1.10.
The "language" action define is qualified by an URL name and by a set of initial parameters as in for example: S: script/java(http://scripts.example.net/credit  card.java,long,1234)
The current definition defines keywords for the most common languages.
More languages may be defined in further version of this documents.
For each language, an API specification will describe how the scripts can issue local "notificationRequest" commands, and receive the corresponding notifications.
The script produces an output which consists of one or several text string, separated by commas.
The text string are reported as a commentary in the report on completion, as in for example: O: script/oc(21223456794567,9738234567)
The failure report may also return a string, as in: O: script/oc(21223456794567,9738234567)
The definition of the script environment and the specific actions in that environment are for further study.
Basic endpoint types and profiles
We define the following basic endpoint types and profiles:
Combined NAS/VOIP gateway    Access Gateway    Residential Gateway    Announcement servers
GM, MF, DTMF, TK, NAS, RTP    Access Gateway (VOIP)
Advanced trunking servers may support the ANN package, the Script package, and in some cases the Line and Handset package as well.
Differences between version 1.0 and draft 0.5 Draft 0 5 was issued in February 1999, as the last update of draft version 0.1.
Version 1.0 benefits from implementation experience, and also aligns as much as possible with the CableLabs' NCS project.
Specified how the quarantine handling parameter governs the handling of detected but not yet specified events.
Specified that unexpected timers or digits should trigger transmission of the dialed string.
Removed the digit map syntax description from section 2.1.5
(it was redundant with section 3.4.)
Corrected miscellaneous bugs in the formal syntax description.
Aligned specification of commands with the CableLabs NCS specification.
This mostly affects the AuditEndpoint and RestartInProgress commands.
Aligned the handling of retransmission with the CableLabs NCS specification.
Added the provisional response return code and corresponding behavior description.
Added an optional reason code parameter to restart in progress.
Added the possibility to audit the restart method, restart delay and reason code.
Differences between draft 04 and draft 05
Differences are minor: corrected the copyright statement, and corrected a bug in the formal description.
Differences between draft 03 and draft 04 Draft 04 corrects a number of minor editing mistakes that were pointed out during the review of draft 03, issued on February 1. 7.4.
Differences between draft 02 and draft 03
Introduced a three way handshake procedure, using a ResponseAck parameter, in order to allow gateways to delete copies of old responses without waiting for a 30 seconds timer,
Expanded the security section to include a discussion of "uncontrolled barge in."
Propsed a "create two connections" command, as an appendix.
Differences between draft 01 and draft 02
Addition of a specification for the handling of "failover."
Revision of the section on race conditions.
The making of MGCP from IPDC and SGCP MGCP version 0.1 results from the fusion of the SGCP and IPDC proposals.
Changes between MGCP and initial versions of SGCP MGCP version 0.1 (which subsumes SGCP version 1.2) introduces the following changes from SGCP version 1.1:
Protocol name changed to MGCP.
Introduce a formal wildcarding structure in the name of endpoints, inspired from IPDC, and detailed the usage of wildcard names in each operation.
Naming scheme for events, introducing a package structure inspired from IPDC.
New operations for audit endpoint, audit connection (requested by the Cablelabs) and restart (inspired from IPDC).
New parameter to control the behavior of the notification request.
Improved text on the detection and handling of race conditions.
Syntax modification for event reporting, to incorporate package names.
Definition of basic event packages (inspired from IPDC).
Incorporation of mandatory and optional extension parameters, inspired by IPDC.
SGCP version 1.1 introduces the following changes from version SGCP 1.0:
All event codes can be used in RequestEvent, SignalRequest and ObservedEvent parameters.
Error Code 512 (Not equipped to detect requested event).
(Not equipped to generate requested signal).
Specific Endpoint ID can be returned in creation commands.
Changed the code for the ASDI display from "ad" to "asdi" to avoid conflict with the digits
the timer mark T    Changed the code for the busy tone from "bt" to "bz" to avoid conflict with the digit B and
the timer mark T    Specified that the continuity tone value is "co"
(CT was incorrectly used in several instances; CT conflicts with .)
Changed the code for the dial tone from "dt" to "dl" to avoid conflict with the digit D and
the timer mark T    Added a code point for announcement requests.
Added a code point for the "wink" event.
Set the "octet received" code in the "Connection Parameters" to "OR" (was set to RO, but then "OR" was used throughout all examples.)
Added a description of SDP parameters for the network access mode (NAS).
Added four flow diagrams for the network access mode.
Incorporated numerous editing suggestions to make the description easier to understand.
In particular, cleared the confusion between requests, queries, functions and commands.
Defined the continuity test mode as specifying a dual tone transponder, while the loopback mode can be used for a single tone test.
Added event code "OC", operation completed.
Added the specification of the "quarantine list", which clarifies the expected handling of events and notifications.
Added the specification of a "wildcard delete" operation.
Security Considerations Security issues are discussed in section 5.
It has been proposed to create a new command
, that would move an existing connection from one endpoint to another, on the same gateway.
This command would be specially useful for handling certain call services, such as call forwarding between endpoints served by the same gateway.
ModifyConnection(CallId, EndpointId, ConnectionId, SecondEndPointId, [NotifiedEntity,] [LocalConnectionOptions,]
The parameters used are the same as in the ModifyConnection command, with the addition of a SecondEndpointId that identifies the endpoint towards which the connection is moved.
The EndpointId should be the fully qualified endpoint identifier of the endpoint on which the connection has been created.
The local name shall not use the wildcard convention.
The SecondEndpointId shall be the endpoint identifier of the endpoint towards which the connection has been created.
The "any of" wildcard convention can be used, but
not the "all of" convention.
If the SecondEndpointId parameter is unqualified, the gateway will choose a value, that will be returned to the call agent as a response parameter.
The command will result in the "move" of the existing connection to the second endpoint.
Depending on gateway implementations, the connection identifier of the connection after the move may or may not be the same as the connection identifier before the move.
If it is not the same, the new value is returned as a response parameter.
The intent of the command is to effect a local relocation of the connection, without having to modify such transmission parameters as IP addresses and port, and thus without forcing the call agent to signal the change of parameters to the remote gateway, at the other end of the connection.
However, gateway architectures may not always allow such transparent moves.
For example, some architectures could allow specific IP addresses to different boards that handles specific group of endpoints.
If for any reason the transmission parameters have to be changed as a result of the move, the new LocalConnectionDescriptor is returned as a response parameter.
The LocalConnectionOptions, Mode, and RemoteConnectionDescriptor, when present, are applied after the move.
The RequestedEvents, RequestIdentifier, DigitMap, SignalRequests, QuarantineHandling and DetectEvents parameters are optional.
They can be used by the Call Agent to transmit a NotificationRequest that is executed simultaneously with the move of the connection.
When these parameters are present, the NotificationRequest applies to the second endpoint.
When these parameters are present, the move and the NotificationRequests should be synchronized, which means that both should be accepted, or both refused.
The NotifiedEntity parameter, if present, applies to both the ModifyConnection and the NotificationRequest command.
The command may carry an encapsulated EndpointConfiguration command, that will also apply to the second endpoint.
When this command is present, the parameters of the EndpointConfiguration command are inserted after the normal parameters of the MoveConnection with the exception of the SecondEndpointId, which is not replicated.
The End  pointConfiguration command may be encapsulated together with an encapsulated NotificationRequest command.
The encapsulated EndpointConfiguration command shares the fate of the MoveConnection command.
If the MoveConnection is rejected, the End  pointConfiguration is not executed.
The only syntax modification necessary for the addition of the moveConnection command is the addition of the keyword MOVE to the authorized values in the MGCPVerb clause of the formal syntax.
