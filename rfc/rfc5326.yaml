- title: __initial_text__
  contents:
  - ''
- title: Networking Working Group                                      M. Ramadas
  contents:
  - "Networking Working Group                                      M. Ramadas\n  \
    \          Licklider Transmission Protocol - Specification\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This RFC is not a candidate for any level of Internet Standard.\
    \  It\n   represents the consensus of the Delay Tolerant Networking (DTN)\n  \
    \ Research Group of the Internet Research Task Force (IRTF).  It may be\n   considered\
    \ for standardization by the IETF in the future, but the\n   IETF disclaims any\
    \ knowledge of the fitness of this RFC for any\n   purpose and in particular notes\
    \ that the decision to publish is not\n   based on IETF review for such things\
    \ as security, congestion control,\n   or inappropriate interaction with deployed\
    \ protocols.  See RFC 3932\n   for more information.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Licklider Transmission Protocol (LTP),\n\
    \   designed to provide retransmission-based reliability over links\n   characterized\
    \ by extremely long message round-trip times (RTTs)\n   and/or frequent interruptions\
    \ in connectivity.  Since communication\n   across interplanetary space is the\
    \ most prominent example of this\n   sort of environment, LTP is principally aimed\
    \ at supporting \"long-\n   haul\" reliable transmission in interplanetary space,\
    \ but it has\n   applications in other environments as well.\n   This document\
    \ is a product of the Delay Tolerant Networking Research\n   Group and has been\
    \ reviewed by that group.  No objections to its\n   publication as an RFC were\
    \ raised.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................4\n  \
    \ 3. Segment Structure ...............................................9\n    \
    \  3.1. Segment Header ............................................10\n      \
    \     3.1.1. Segment Type Flags .................................11\n        \
    \   3.1.2. Segment Type Codes .................................13\n          \
    \ 3.1.3. Segment Class Masks ................................14\n           3.1.4.\
    \ Extensions Field ...................................14\n      3.2. Segment Content\
    \ ...........................................16\n           3.2.1. Data Segment\
    \ (DS) ..................................16\n           3.2.2. Report Segment\
    \ (RS) ................................17\n           3.2.3. Report Acknowledgment\
    \ Segment ......................19\n           3.2.4. Session Management Segments\
    \ ........................20\n      3.3. Segment Trailer ...........................................20\n\
    \   4. Requests from Client Service ...................................20\n  \
    \    4.1. Transmission Request ......................................21\n    \
    \  4.2. Cancellation Request ......................................22\n   5. Requirements\
    \ from the Operating Environment ....................23\n   6. Internal Procedures\
    \ ............................................24\n      6.1. Start Transmission\
    \ ........................................25\n      6.2. Start Checkpoint Timer\
    \ ....................................25\n      6.3. Start RS Timer ............................................25\n\
    \      6.4. Stop Transmission .........................................25\n  \
    \    6.5. Suspend Timers ............................................26\n    \
    \  6.6. Resume Timers .............................................26\n      6.7.\
    \ Retransmit Checkpoint .....................................27\n      6.8. Retransmit\
    \ RS .............................................27\n      6.9. Signify Red-Part\
    \ Reception ................................28\n      6.10. Signify Green-Part\
    \ Segment Arrival .......................28\n      6.11. Send Reception Report\
    \ ....................................28\n      6.12. Signify Transmission Completion\
    \ ..........................30\n      6.13. Retransmit Data ..........................................30\n\
    \      6.14. Stop RS Timer ............................................31\n  \
    \    6.15. Start Cancel Timer .......................................32\n    \
    \  6.16. Retransmit Cancellation Segment ..........................32\n      6.17.\
    \ Acknowledge Cancellation .................................32\n      6.18. Stop\
    \ Cancel Timer ........................................33\n      6.19. Cancel\
    \ Session ...........................................33\n      6.20. Close Session\
    \ ............................................33\n      6.21. Handle Miscolored\
    \ Segment ................................33\n      6.22. Handling System Error\
    \ Conditions .........................34\n   7. Notices to Client Service ......................................35\n\
    \      7.1. Session Start .............................................35\n  \
    \    7.2. Green-Part Segment Arrival ................................36\n    \
    \  7.3. Red-Part Reception ........................................36\n      7.4.\
    \ Transmission-Session Completion ...........................36\n      7.5. Transmission-Session\
    \ Cancellation .........................37\n      7.6. Reception-Session Cancellation\
    \ ............................37\n      7.7. Initial-Transmission Completion ...........................37\n\
    \   8. State Transition Diagrams ......................................38\n  \
    \    8.1. Sender ....................................................39\n    \
    \  8.2. Receiver ..................................................44\n   9. Security\
    \ Considerations ........................................48\n      9.1. Denial\
    \ of Service Considerations ..........................48\n      9.2. Replay Handling\
    \ ...........................................49\n      9.3. Implementation Considerations\
    \ .............................50\n   10. IANA Considerations ...........................................51\n\
    \      10.1. UDP Port Number for LTP ..................................51\n  \
    \    10.2. LTP Extension Tag Registry ...............................51\n   11.\
    \ Acknowledgments ...............................................51\n   12. References\
    \ ....................................................52\n      12.1. Normative\
    \ References .....................................52\n      12.2. Informative\
    \ References ...................................52\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This document serves as the main protocol specification of\
    \ LTP and is\n   part of a series of documents describing LTP.  Other documents\
    \ in\n   this series include the motivation document [LTPMTV] and the protocol\n\
    \   extensions document [LTPEXT].  We strongly recommend reading the\n   protocol\
    \ motivation document before reading this document, to\n   establish sufficient\
    \ background and motivation for the specification.\n   LTP does Automatic Repeat\
    \ reQuest (ARQ) of data transmissions by\n   soliciting selective-acknowledgment\
    \ reception reports.  It is\n   stateful, and has no negotiation or handshakes.\n\
    \   In an Interplanetary Internet setting deploying the Bundle Protocol\n   that\
    \ is being developed by the Delay Tolerant Networking Research\n   Group, LTP\
    \ is intended to serve as a reliable \"convergence layer\"\n   protocol operating\
    \ in pairwise fashion between adjacent\n   Interplanetary Internet nodes that\
    \ are in direct radio frequency (RF)\n   communication.  In that operational scenario,\
    \ and potentially in some\n   other deployments of the Bundle Protocol, LTP runs\
    \ directly over a\n   data-link layer protocol; when this is the case, forward\
    \ error\n   correction coding and/or checksum mechanisms in the underlying data-\n\
    \   link layer protocol must ensure the integrity of the data passed\n   between\
    \ the communicating entities.\n   Since no mechanisms for flow control or congestion\
    \ control are\n   included in the design of LTP, this protocol is not intended\
    \ or\n   appropriate for ubiquitous deployment in the global Internet.\n   When\
    \ LTP is run over UDP, it must only be used for software\n   development or in\
    \ private local area networks.  When LTP is not run\n   over UDP, it must be run\
    \ directly over a protocol (nominally a link-\n   layer protocol) that meets the\
    \ requirements specified in Section 5.\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [B97].\n"
- title: 2. Terminology
  contents:
  - "2. Terminology\n   (1) Engine ID\n   A number that uniquely identifies a given\
    \ LTP engine, within some\n   closed set of communicating LTP engines.  Note that\
    \ when LTP is\n   operating underneath the Delay-Tolerant Networking (DTN) [DTN]\
    \ Bundle\n   Protocol [BP], the convergence layer adapter mediating the two will\n\
    \   be responsible for translating between DTN endpoint IDs and LTP\n   engine\
    \ IDs in an implementation-specific manner.\n   (2) Block\n   An array of contiguous\
    \ octets of application data handed down by the\n   upper layer protocol (typically\
    \ Bundle Protocol) to be transmitted\n   from one LTP client service instance\
    \ to another.\n   Any subset of a block comprising contiguous octets beginning\
    \ at the\n   start of the block is termed a \"block prefix\", and any such subset\
    \ of\n   the block ending with the end of the block is termed a \"block\n   suffix\"\
    .\n   (3) Red-Part\n   The block prefix that is to be transmitted reliably, i.e.,\
    \ subject to\n   acknowledgment and retransmission.\n   (4) Green-Part\n   The\
    \ block suffix that is to be transmitted unreliably, i.e., not\n   subject to\
    \ acknowledgments or retransmissions.  If present, the\n   green-part of a block\
    \ begins at the octet following the end of the\n   red-part.\n   (5) Session\n\
    \   A thread of LTP protocol activity conducted between two peer engines\n   for\
    \ the purpose of transmitting a block.  Data flow in a session is\n   unidirectional:\
    \ data traffic flows from the sending peer to the\n   receiving peer, while data-acknowledgment\
    \ traffic flows from the\n   receiving peer to the sending peer.\n   (6) Sender\n\
    \   The data sending peer of a session.\n   (7) Receiver\n   The data receiving\
    \ peer of a session.\n   (8) Client Service Instance\n   A software entity, such\
    \ as an application or a higher-layer protocol\n   implementation, that is using\
    \ LTP to transfer data.\n   (9) Segment\n   The unit of LTP data transmission\
    \ activity.  It is the data structure\n   transmitted from one LTP engine to another\
    \ in the course of a\n   session.  Each LTP segment is of one of the following\
    \ types: data\n   segment, report segment, report-acknowledgment segment, cancel\n\
    \   segment, cancel-acknowledgment segment.\n   (10) Reception Claim\n   An assertion\
    \ of reception of some number of contiguous octets of\n   application data (a\
    \ subset of a block) characterized by: the offset\n   of the first received octet,\
    \ and the number of contiguous octets\n   received (beginning at the offset).\n\
    \   (11) Scope\n   Scope identifies a subset of a block and comprises two numbers\
    \ --\n   upper bound and lower bound.\n   For a data segment, lower bound is the\
    \ offset of the segment's\n   application data from the start of the block (in\
    \ octets), while upper\n   bound is the sum of the offset and length of the segment's\n\
    \   application data (in octets).  For example, a segment with a block\n   offset\
    \ of 1000 and length of 500 would have a lower bound of 1000 and\n   upper bound\
    \ of 1500.\n   For a report segment, upper bound is the end of the block prefix\
    \ to\n   which the reception claims in the report apply, while lower bound is\n\
    \   the end of the (smaller) interior block prefix to which the reception\n  \
    \ claims in the report do *not* apply.  That is, data at any offset\n   equal\
    \ to or greater than the report's lower bound but less than its\n   upper bound\
    \ and not designated as \"received\" by any of the report's\n   reception claims\
    \ must be assumed not received, and therefore eligible\n   for retransmission.\
    \  For example, if a report segment carried a lower\n   bound of 1000 and an upper\
    \ bound of 5000, and the reception claims\n   indicated reception of data within\
    \ offsets 1000-1999 and 3000-4999,\n   data within the block offsets 2000-2999\
    \ can be considered missing and\n   eligible for retransmission.\n   Reception\
    \ reports (which may comprise multiple report segments) also\n   have scope, as\
    \ defined in Section 6.11.\n   (12) End of Block (EOB)\n   The last data segment\
    \ transmitted as part of the original\n   transmission of a block.  This data\
    \ segment also indicates that the\n   segment's upper bound is the total length\
    \ of the block (in octets).\n   (13) End of Red-Part (EORP)\n   The segment transmitted\
    \ as part of the original transmission of a\n   block containing the last octet\
    \ of the block's red-part.  This data\n   segment also indicates that the segment's\
    \ upper bound is the length\n   of the block's red-part (in octets).\n   (14)\
    \ Checkpoint\n   A data segment soliciting a reception report from the receiving\
    \ LTP\n   engine.  The EORP segment must be flagged as a checkpoint, as must\n\
    \   the last segment of any retransmission; these are \"mandatory\n   checkpoints\"\
    .  All other checkpoints are \"discretionary checkpoints\".\n   (15) Reception\
    \ Report\n   A sequence of one or more report segments reporting on all block\
    \ data\n   reception within some scope.\n   (16) Synchronous Reception Report\n\
    \   A reception report that is issued in response to a checkpoint.\n   (17) Asynchronous\
    \ Reception Report\n   A reception report that is issued in response to some implementation-\n\
    \   defined event other than the arrival of a checkpoint.\n   (18) Primary Reception\
    \ Report\n   A reception report that is issued in response to some event other\n\
    \   than the arrival of a checkpoint segment that was itself issued in\n   response\
    \ to a reception report.  Primary reception reports include\n   all asynchronous\
    \ reception reports and all synchronous reception\n   reports that are sent in\
    \ response to discretionary checkpoints or to\n   the EORP segment for a session.\n\
    \   (19) Secondary Reception Report\n   A reception report that is issued in response\
    \ to the arrival of a\n   checkpoint segment that was itself issued in response\
    \ to a reception\n   report.\n   (20) Self-Delimiting Numeric Value (SDNV)\n \
    \  The design of LTP attempts to reconcile minimal consumption of\n   transmission\
    \ bandwidth with\n      (a) extensibility to satisfy requirements not yet identified,\
    \ and\n      (b) scalability across a very wide range of network sizes and\n \
    \         transmission payload sizes.\n   The SDNV encoding scheme is modeled\
    \ after the Abstract Syntax\n   Notation One [ASN1] scheme for encoding Object\
    \ Identifier values.  In\n   a data field encoded as an SDNV, the most significant\
    \ bit (MSB) of\n   each octet of the SDNV serves to indicate whether or not the\
    \ octet is\n   the last octet of the SDNV.  An octet with an MSB of 1 indicates\
    \ that\n   it is either the first or a middle octet of a multi-octet SDNV; the\n\
    \   octet with an MSB of 0 is the last octet of the SDNV.  The value\n   encoded\
    \ in an SDNV is found by concatenating the 7 least significant\n   bits of each\
    \ octet of the SDNV, beginning at the first octet and\n   ending at the last octet.\n\
    \   The following examples illustrate the encoding scheme for various\n   hexadecimal\
    \ values.\n   0xABC  : 1010 1011 1100\n            is encoded as\n           \
    \ {100 1010 1} {0 011 1100}\n             -            -\n            = 10010101\
    \ 00111100\n   0x1234 : 0001 0010 0011 0100\n            =  1 0010 0011 0100\n\
    \            is encoded as\n            {10 1 0010 0} {0 011 0100}\n         \
    \    -             -\n            = 10100100 00110100\n   0x4234 : 0100 0010 0011\
    \ 0100\n            =100 0010 0011 0100\n            is encoded as\n         \
    \   {1000000 1} {1 00 0010 0} {0 011 0100}\n             -           -       \
    \      -\n            = 10000001 10000100 00110100\n   0x7F   : 0111 1111\n  \
    \          =111 1111\n            is encoded as\n            {0 111 1111}\n  \
    \           -\n            = 01111111\n   Note:\n   Care must be taken to make\
    \ sure that the value to be encoded is\n   padded with zeroes at the most significant\
    \ bit end (NOT at the least\n   significant bit end) to make its bitwise length\
    \ a multiple of 7\n   before encoding.\n   While there is no theoretical limit\
    \ on the size of an SDNV field, we\n   note that the overhead of the SDNV scheme\
    \ is 1:7, i.e., 1 bit of\n   overhead for every 7 bits of actual data to be encoded.\
    \  Thus, a\n   7-octet value (a 56-bit quantity with no leading zeroes) would\
    \ be\n   encoded in an 8-octet SDNV; an 8-octet value (a 64-bit quantity with\n\
    \   no leading zeroes) would be encoded in a 10-octet SDNV.  In general,\n   an\
    \ N-bit quantity with no leading zeroes would be encoded in a\n   ceil(N/7) octet\
    \ SDNV, where ceil is the integer ceiling function.\n   Clearly, for fields that\
    \ typically carry larger values such as RSA\n   public keys, the SDNV overhead\
    \ could become unacceptable.  Hence,\n   when adopting the SDNV scheme for other\
    \ purposes related to this\n   document, such as any protocol extensions, we RECOMMEND\
    \ that if the\n   typical data field value is expected to be larger than 8 octets,\
    \ then\n   the data field should be specified as a {LENGTH, VALUE} tuple, with\n\
    \   the LENGTH parameter encoded as an SDNV followed by LENGTH octets\n   housing\
    \ the VALUE of the data field.\n   We also note that SDNV is clearly not the best\
    \ way to represent every\n   numeric value.  When the maximum possible value of\
    \ a number is known\n   without question, the cost of additional bits may not\
    \ be justified.\n   For example, an SDNV is a poor way to represent an integer\
    \ whose\n   value typically falls in the range 128 to 255.  In general, though,\n\
    \   we believe that the SDNV representation of various protocol data\n   fields\
    \ in LTP segments yields the smallest segment sizes without\n   sacrificing scalability.\n"
- title: 3.  Segment Structure
  contents:
  - "3.  Segment Structure\n   Each LTP segment comprises\n      (a) a \"header\"\
    \ in the format defined below.\n      (b) zero or more octets of \"content\".\n\
    \      (c) zero or more octets of \"trailer\" as indicated by information\n  \
    \        in the \"Extensions field\" of the header.\n   LTP segments are of four\
    \ general types depending on the nature of the\n   content carried:\n      Data\
    \ segments flow from the sender to the receiver and carry\n      client service\
    \ (application) data.\n      A report segment flows from the receiver to the sender\
    \ and carries\n      data reception claims together with the upper and lower bounds\
    \ of\n      the block scope to which the claims pertain.\n      A report-acknowledgment\
    \ segment flows from the sender to the\n      receiver and acknowledges reception\
    \ of a report segment.  It\n      carries the serial number of the report being\
    \ acknowledged.\n      Session management segments may be generated by both the\
    \ sender\n      and the receiver and are of two general sub-types: cancellation\n\
    \      and cancellation-acknowledgment.  A cancellation segment initiates\n  \
    \    session cancellation procedures at the peer and carries a single\n      byte\
    \ reason-code to indicate the reason for session cancellation.\n      Cancellation-acknowledgment\
    \ segments merely acknowledge reception\n      of a cancellation segment and have\
    \ no content.\n   The overall segment structure is illustrated below:\n      \
    \ Bit    0     1     2     3     4     5     6     7\n     ^     +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \     |     |    Version number     |  Segment Type Flags   | Control\n     |\
    \     +-----------------------+-----------------------+     -byte\n     |    \
    \ |                                               |\n     |     /            \
    \     Session ID                    \\\n     |     \\                        \
    \                       /\n   Header  +-----------------------+-----------------------+\n\
    \     |     | Header Extension Cnt. | Trailer Extension Cnt.| Extensions\n   \
    \  |     +-----------------------+-----------------------+\n     |     |     \
    \                                          |\n     |     /              Header\
    \ Extensions                \\\n     |     \\                                \
    \               /\n     V     +-----------------------------------------------+\n\
    \           |                                               |\n           |  \
    \                                             |\n           |                \
    \                               |\n           |              Segment Content \
    \                 |\n           /                                            \
    \   \\\n           \\                                               /\n      \
    \     |                                               |\n           |        \
    \                                       |\n           |                      \
    \                         |\n     ^     +-----------------------------------------------+\n\
    \     |     |                                               |\n   Trailer /  \
    \            Trailer Extensions               \\\n     |     \\              \
    \                                 /\n     V     +-----------------------------------------------+\n"
- title: 3.1.  Segment Header
  contents:
  - "3.1.  Segment Header\n   An LTP segment header comprises three data items: a\
    \ single-octet\n   control byte, the session ID, and the Extensions field.\n \
    \  Control byte comprises the following:\n      Version number (4 bits): MUST\
    \ be set to the binary value 0000 for\n      this version of the protocol.\n \
    \     Segment type flags (4 bits): described in Section 3.1.1.\n   Session ID\
    \ uniquely identifies, among all transmissions between the\n   sender and receiver,\
    \ the session of which the segment is one token.\n   It comprises the following:\n\
    \      Session originator (SDNV): the engine ID of the sender.\n      Session\
    \ number (SDNV): typically a random number (for anti-DoS\n      reasons), generated\
    \ by the sender.\n      The format and resolution of session number are matters\
    \ that are\n      private to the LTP sender; the only requirement imposed by LTP\
    \ is\n      that every session initiated by an LTP engine MUST be uniquely\n \
    \     identified by the session ID.\n   The Extensions field is described in Section\
    \ 3.1.4.\n"
- title: 3.1.1.  Segment Type Flags
  contents:
  - "3.1.1.  Segment Type Flags\n   The last 4 bits of the control byte in the segment\
    \ header are flags\n   that indicate the nature of the segment.  In order (most\
    \ significant\n   bit first), these flags are CTRL, EXC, Flag 1, and Flag 0.\n\
    \   A value of 0 in the CTRL (Control) flag identifies the segment as a\n   data\
    \ segment, while a value of 1 identifies it as a control segment.\n   A data segment\
    \ with the EXC (Exception) flag set to 0 is a red-part\n   segment; a data segment\
    \ with EXC set to 1 is a green-part segment.\n   For a control segment, having\
    \ the EXC flag set to 1 indicates that\n   the segment pertains to session cancellation\
    \ activity.  Any data\n   segment (whether red-part or green-part) with both Flag\
    \ 1 and Flag 0\n   set to 1 indicates EOB.  Any data segment (whether red-part\
    \ or\n   green-part) with both Flag 1 and Flag 0 set to 0 indicates data\n   without\
    \ any additional protocol significance.  Any red-part data\n   segment with either\
    \ flag bit non-zero is a checkpoint.  Any red-part\n   data segment with Flag\
    \ 1 set to 1 indicates the end of red-part.\n   Put another way:\n   if (CTRL\
    \ flag = 0)\n      segment is a data segment if (EXC flag = 0)\n         segment\
    \ contains only red-part data if (Flag 1 = 1)\n            segment is a checkpoint\
    \ segment is the last segment in the\n            red part of the block if (Flag\
    \ 0 = 1)\n               segment is the last segment in the block\n         else\
    \ // segment is not end of red-part\n            if (Flag 0 = 1)\n           \
    \    segment is a checkpoint\n      else\n         segment contains only green-part\
    \ data if (Flag 1 = 1)\n            if (Flag 0 = 1)\n               segment is\
    \ the last segment in the block\n   else\n      segment is a control segment if\
    \ (EXC flag = 0)\n         segment pertains to report activity if (flag 0 = 0)\n\
    \            segment is a report segment\n         else\n            segment is\
    \ an acknowledgment of a report segment\n      else\n         segment pertains\
    \ to session cancellation activity if (Flag 1 =\n         0)\n            segment\
    \ pertains to cancellation by block sender if (Flag 0\n            = 1)\n    \
    \           segment is a cancellation by sender\n            else\n          \
    \     segment is an acknowledgment of a cancellation by sender\n         else\n\
    \            segment pertains to cancellation by block receiver if (Flag\n   \
    \         0 = 1)\n               segment is a cancellation by receiver\n     \
    \       else\n               segment is an acknowledgment of a cancellation by\n\
    \               receiver\n"
- title: 3.1.2.  Segment Type Codes
  contents:
  - "3.1.2.  Segment Type Codes\n   Combinations of the settings of the segment type\
    \ flags CTRL, EXC,\n   Flag 1, and Flag 0 constitute segment type codes, which\
    \ serve as\n   concise representations of detailed segment nature.\n   CTRL EXC\
    \ Flag 1 Flag 0 Code  Nature of segment\n   ---- --- ------ ------ ----  ---------------------------------------\n\
    \     0   0     0      0     0   Red data, NOT {Checkpoint, EORP or EOB}\n   \
    \  0   0     0      1     1   Red data, Checkpoint, NOT {EORP or EOB}\n     0\
    \   0     1      0     2   Red data, Checkpoint, EORP, NOT EOB\n     0   0   \
    \  1      1     3   Red data, Checkpoint, EORP, EOB\n     0   1     0      0 \
    \    4   Green data, NOT EOB\n     0   1     0      1     5   Green data, undefined\n\
    \     0   1     1      0     6   Green data, undefined\n     0   1     1     \
    \ 1     7   Green data, EOB\n     1   0     0      0     8   Report segment\n\
    \     1   0     0      1     9   Report-acknowledgment segment\n     1   0   \
    \  1      0    10   Control segment, undefined\n     1   0     1      1    11\
    \   Control segment, undefined\n     1   1     0      0    12   Cancel segment\
    \ from block sender\n     1   1     0      1    13   Cancel-acknowledgment segment\n\
    \                                to block sender\n     1   1     1      0    14\
    \   Cancel segment from block receiver\n     1   1     1      1    15   Cancel-acknowledgment\
    \ segment\n                                to block receiver\n"
- title: 3.1.3.  Segment Class Masks
  contents:
  - "3.1.3.  Segment Class Masks\n   For the purposes of this specification, some\
    \ bit patterns in the\n   segment type flags field correspond to \"segment classes\"\
    \ that are\n   designated by mnemonics.  The mnemonics are intended to evoke the\n\
    \   characteristics shared by all types of segments characterized by\n   these\
    \ flag bit patterns.\n   CTRL EXC Flag 1 Flag 0  Mnemonic  Description\n   ----\
    \ --- ------ ------  --------  ---------------------------\n     0   0     - \
    \     1\n        -- or --\n     0   0     1      -      CP      Checkpoint\n \
    \    0   0     1      -      EORP    End of red-part;\n                      \
    \               red-part size = offset + length\n     0   -     1      1     \
    \ EOB     End of block;\n                                     block size = offset\
    \ + length\n     1   0     0      0      RS      Report segment;\n           \
    \                          carries reception claims\n     1   0     0      1 \
    \     RA      Report-acknowledgment segment\n     1   1     0      0      CS \
    \     Cancel segment from block sender\n     1   1     0      1      CAS     Cancel-acknowledgment\
    \ segment\n                                     to block sender\n     1   1  \
    \   1      0      CR      Cancel segment from block receiver\n     1   1     1\
    \      1      CAR     Cancel-acknowledgment segment\n                        \
    \             to block receiver\n     1   1     -      0      Cx      Cancel segment\
    \ (generic)\n     1   1     -      1      CAx     Cancel-acknowledgment segment\n\
    \                                     (generic)\n"
- title: 3.1.4.  Extensions Field
  contents:
  - "3.1.4.  Extensions Field\n   The Extensions field enables the inclusion of zero\
    \ or more functional\n   extensions to the basic LTP segment, each in type-length-value\
    \ (TLV)\n   representation as explained below.\n   The first octet of the Extensions\
    \ field indicates the number of\n   extensions present in the segment: the high-order\
    \ 4 bits indicate the\n   number of extension TLVs in the header (immediately\
    \ following the\n   extensions count octet and preceding the segment's content),\
    \ while\n   the low-order 4 bits indicate the number of extension TLVs in the\n\
    \   trailer (immediately following the segment's content).  That is, each\n  \
    \ segment may have from 0 to 15 extension TLVs in its header and from 0\n   to\
    \ 15 extension TLVs in its trailer.  In the absence of any extension\n   TLVs,\
    \ all bits of this extensions count octet MUST be set to zero.\n   Note that it\
    \ is valid for header extensions to be immediately\n   followed by trailer extensions;\
    \ for example, since a CAx segment has\n   no contents, it may have header extensions\
    \ immediately followed by\n   trailer extensions.\n   Each extension consists\
    \ of a one-octet tag identifying the type of\n   the extension, followed by a\
    \ length parameter in SDNV form, followed\n   by a value of the specified length.\n\
    \   The diagram below illustrates the extension TLVs as they may occur in\n  \
    \ the header or trailer.\n   +--------+----///-----///--+\n   |ext-tag | length\
    \  | value |\n   +--------+-------///-------+----------///-------+\n   |ext-tag\
    \ |     length      |       value        |\n   +--------+-----///-----///-+---------////-------+\n\
    \   |ext-tag |   length |   value  |\n   +--------+----------+----------+\n  \
    \ The IANA maintains an LTP Extension Tag registry as shown below.  See\n   the\
    \ IANA considerations section below for details of code point\n   assignment in\
    \ the Unassigned range.\n   Extension tag     Meaning\n   -------------     -------\n\
    \   0x00              LTP authentication extension [LTPEXT]\n   0x01         \
    \     LTP cookie extension [LTPEXT]\n   0x02-0xAF         Unassigned\n   0xB0-0xBF\
    \         Reserved\n   0xC0-0xFF         Private / Experimental Use\n   Note that\
    \ since the last quarter of the extension-tag space is for\n   experimental use,\
    \ implementations should be aware that collisions for\n   these tags are possible.\n"
- title: 3.2.  Segment Content
  contents:
  - '3.2.  Segment Content

    '
- title: 3.2.1.  Data Segment (DS)
  contents:
  - "3.2.1.  Data Segment (DS)\n   The content of a data segment includes client service\
    \ data and the\n   metadata enabling the receiving client service instance to\
    \ receive\n   and make use of that data.\n   Client service ID (SDNV)\n      The\
    \ client service ID number identifies the upper-level service to\n      which\
    \ the segment is to be delivered by the receiver.  It is\n      functionally analogous\
    \ to a TCP port number.  If multiple\n      instances of the client service are\
    \ present at the destination,\n      multiplexing must be done by the client service\
    \ itself on the\n      basis of information encoded within the transmitted block.\n\
    \   Offset (SDNV)\n      Offset indicates the location of the segment's client\
    \ service data\n      within the session's transmitted block.  It is the number\
    \ of bytes\n      in the block prior to the byte from which the first octet of\
    \ the\n      segment's client service data was copied.\n   Length (SDNV)\n   \
    \   The length of the ensuing client service data, in octets.\n   If the data\
    \ segment is a checkpoint, the segment MUST additionally\n   include the following\
    \ two serial numbers (checkpoint serial number\n   and report serial number) to\
    \ support efficient retransmission.  Data\n   segments that are not checkpoints\
    \ MUST NOT have these two fields in\n   the header and MUST continue on directly\
    \ with the client service\n   data.\n   Checkpoint serial number (SDNV)\n    \
    \  The checkpoint serial number uniquely identifies the checkpoint\n      among\
    \ all checkpoints issued by the block sender in a session.\n      The first checkpoint\
    \ issued by the sender MUST have this serial\n      number chosen randomly for\
    \ security reasons, and it is RECOMMENDED\n      that the sender use the guidelines\
    \ in [ESC05] for this.  Any\n      subsequent checkpoints issued by the sender\
    \ MUST have the serial\n      number value found by incrementing the prior checkpoint\
    \ serial\n      number by 1.  When a checkpoint segment is retransmitted, however,\n\
    \      its serial number MUST be the same as when it was originally\n      transmitted.\
    \  The checkpoint serial number MUST NOT be zero.\n   Report serial number (SDNV)\n\
    \      If the checkpoint was queued for transmission in response to the\n    \
    \  reception of an RS (Section 6.13), then its value MUST be the\n      report\
    \ serial number value of the RS that caused the data segment\n      to be queued\
    \ for transmission.\n      Otherwise, the value of report serial number MUST be\
    \ zero.\n   Client service data (array of octets)\n      The client service data\
    \ carried in the segment is a copy of a\n      subset of the bytes in the original\
    \ client service data block,\n      starting at the indicated offset.\n"
- title: 3.2.2.  Report Segment (RS)
  contents:
  - "3.2.2.  Report Segment (RS)\n   The content of an RS comprises one or more data\
    \ reception claims,\n   together with the upper and lower bounds of the scope\
    \ within the data\n   block to which the claims pertain.  It also includes two\
    \ serial\n   numbers to support efficient retransmission.\n   Report serial number\
    \ (SDNV)\n      The report serial number uniquely identifies the report among\
    \ all\n      reports issued by the receiver in a session.  The first report\n\
    \      issued by the receiver MUST have this serial number chosen\n      randomly\
    \ for security reasons, and it is RECOMMENDED that the\n      receiver use the\
    \ guidelines in [ESC05] for this.  Any subsequent\n      RS issued by the receiver\
    \ MUST have the serial number value found\n      by incrementing the last report\
    \ serial number by 1.  When an RS is\n      retransmitted however, its serial\
    \ number MUST be the same as when\n      it was originally transmitted.  The report\
    \ serial number MUST NOT\n      be zero.\n   Checkpoint serial number (SDNV)\n\
    \      The value of the checkpoint serial number MUST be zero if the\n      report\
    \ segment is NOT a response to reception of a checkpoint,\n      i.e., the reception\
    \ report is asynchronous; otherwise, it MUST be\n      the checkpoint serial number\
    \ of the checkpoint that caused the RS\n      to be issued.\n   Upper bound (SDNV)\n\
    \      The upper bound of a report segment is the size of the block\n      prefix\
    \ to which the segment's reception claims pertain.\n   Lower bound (SDNV)\n  \
    \    The lower bound of a report segment is the size of the (interior)\n     \
    \ block prefix to which the segment's reception claims do NOT\n      pertain.\n\
    \   Reception claim count (SDNV)\n      The number of data reception claims in\
    \ this report segment.\n   Reception claims\n      Each reception claim comprises\
    \ two elements: offset and length.\n      Offset (SDNV)\n         The offset indicates\
    \ the successful reception of data beginning\n         at the indicated offset\
    \ from the lower bound of the RS.  The\n         offset within the entire block\
    \ can be calculated by summing\n         this offset with the lower bound of the\
    \ RS.\n      Length (SDNV)\n         The length of a reception claim indicates\
    \ the number of\n         contiguous octets of block data starting at the indicated\n\
    \         offset that have been successfully received.\n      Reception claims\
    \ MUST conform to the following rules:\n         A reception claim's length shall\
    \ never be less than 1 and shall\n         never exceed the difference between\
    \ the upper and lower bounds\n         of the report segment.\n         The offset\
    \ of a reception claim shall always be greater than\n         the sum of the offset\
    \ and length of the prior claim, if any.\n         The sum of a reception claim's\
    \ offset and length and the lower\n         bound of the report segment shall\
    \ never exceed the upper bound\n         of the report segment.\n   Implied requests\
    \ for retransmission of client service data can be\n   inferred from an RS's data\
    \ reception claims.  However, *nothing* can\n   be inferred regarding reception\
    \ of block data at any offset equal to\n   or greater than the segment's upper\
    \ bound or at any offset less than\n   the segment's lower bound.\n   For example,\
    \ if the scope of a report segment has lower bound 0 and\n   upper bound 6000,\
    \ and the report contains a single data reception\n   claim with offset 0 and\
    \ length 6000, then the report signifies\n   successful reception of the first\
    \ 6000 bytes of the block.  If the\n   total length of the block is 6000, then\
    \ the report additionally\n   signifies successful reception of the entire block.\n\
    \   If on the other hand, the scope of a report segment has lower bound\n   1000\
    \ and upper bound 6000, and the report contains two data reception\n   claims,\
    \ one with offset 0 and length 2000 and the other with offset\n   3000 and length\
    \ 500, then the report signifies successful reception\n   only of bytes 1000-2999\
    \ and 4000-4499 of the block.  From this we can\n   infer that bytes 3000-3999\
    \ and 4500-5999 of the block need to be\n   retransmitted, but we cannot infer\
    \ anything about reception of the\n   first 1000 bytes or of any subsequent data\
    \ beginning at block offset\n   6000.\n"
- title: 3.2.3.  Report Acknowledgment Segment
  contents:
  - "3.2.3.  Report Acknowledgment Segment\n   The content of an RA is simply the\
    \ report serial number of the RS in\n   response to which the segment was generated.\n\
    \   Report serial number (SDNV)\n      This field returns the report serial number\
    \ of the RS being\n      acknowledged.\n"
- title: 3.2.4.  Session Management Segments
  contents:
  - "3.2.4.  Session Management Segments\n   Cancel segments (Cx) carry a single byte\
    \ reason-code with the\n   following semantics:\n   Reason-Code    Mnemonic  \
    \  Semantics\n   -----------    --------    ---------------------------------------\n\
    \       00         USR_CNCLD   Client service canceled session.\n       01   \
    \      UNREACH     Unreachable client service.\n       02         RLEXC      \
    \ Retransmission limit exceeded.\n       03         MISCOLORED  Received either\
    \ a red-part data segment\n                              at block offset above\
    \ any green-part\n                              data segment offset or a green-part\n\
    \                              data segment at block offset below any\n      \
    \                        red-part data segment offset.\n       04         SYS_CNCLD\
    \   A system error condition caused\n                              unexpected\
    \ session termination.\n       05         RXMTCYCEXC  Exceeded the Retransmission-Cycles\
    \ limit.\n      06-FF       Reserved\n   The Cancel-acknowledgments (CAx) have\
    \ no content.\n   Note: The reason we use different cancel segment types for the\n\
    \   originator and recipient is to allow a loopback mode to work without\n   disturbing\
    \ any replay protection mechanism in use.\n"
- title: 3.3.  Segment Trailer
  contents:
  - "3.3.  Segment Trailer\n   The segment trailer consists of a sequence of zero\
    \ to 15 extension\n   TLVs as described in Section 3.1.4 above.\n"
- title: 4.  Requests from Client Service
  contents:
  - "4.  Requests from Client Service\n   In all cases, the representation of request\
    \ parameters is a local\n   implementation matter, as are validation of parameter\
    \ values and\n   notification of the client service in the event that a request\
    \ is\n   found to be invalid.\n"
- title: 4.1.  Transmission Request
  contents:
  - "4.1.  Transmission Request\n   In order to request transmission of a block of\
    \ client service data,\n   the client service MUST provide the following parameters\
    \ to LTP:\n      Destination client service ID.\n      Destination LTP engine\
    \ ID.\n      Client service data to send, as an array of bytes.\n      Length\
    \ of the data to be sent.\n      Length of the red-part of the data.  This value\
    \ MUST be in the\n      range from zero to the total length of data to be sent.\n\
    \   On reception of a valid transmission request from a client service,\n   LTP\
    \ proceeds as follows.\n   First, the array of data to be sent is subdivided as\
    \ necessary, with\n   each subdivision serving as the client service data of a\
    \ single new\n   LTP data segment.  The algorithm used for subdividing the data\
    \ is a\n   local implementation matter; it is expected that data size\n   constraints\
    \ imposed by the underlying communication service, if any,\n   will be accommodated\
    \ in this algorithm.\n   The last (and only the last) of the resulting data segments\
    \ must be\n   marked as the EOB (end of block).\n   Note that segment type indicates\
    \ that the client service data in a\n   given LTP segment either is or is not\
    \ in the red-part of the block.\n   To prevent segment type ambiguity, each data\
    \ segment MUST contain\n   either only red-part data or only green-part data.\
    \  Therefore, when\n   the length of the block's red-part is N, the total length\
    \ of the\n   block is M, and N is not equal to M, the (N+1)th byte of the block\n\
    \   SHOULD be the first byte of client service data in a green-part data\n   segment.\
    \  Note that this means that at the red-part boundary, LTP may\n   send a segment\
    \ of size lesser than the link MTU size.  For bandwidth\n   efficiency reasons,\
    \ implementations MAY choose to instead mark the\n   entire segment (within which\
    \ the red-part boundary falls) as red-\n   part, causing green-part data falling\
    \ within the segment to also be\n   treated as red-part.\n   If the length of\
    \ the block's red-part is greater than zero, then the\n   last data segment containing\
    \ red-part data must be marked as the EORP\n   (end of red-part) segment by setting\
    \ the appropriate segment type\n   flag bits (Section 3.1.2).  Zero or more preceding\
    \ data segments\n   containing red-part data (selected according to an algorithm\
    \ that is\n   a local implementation matter) MAY additionally be marked as a CP\n\
    \   (Checkpoint), and serve as additional discretionary checkpoints\n   (Section\
    \ 3.1.2).\n   All data segments are appended to the (conceptual) application data\n\
    \   queue bound for the destination engine, for subsequent transmission.\n   Finally,\
    \ a session start notice (Section 7.1) is sent back to the\n   client service\
    \ that requested the transmission.\n"
- title: 4.2.  Cancellation Request
  contents:
  - "4.2.  Cancellation Request\n   In order to request cancellation of a session,\
    \ either as the sender\n   or as the receiver of the associated data block, the\
    \ client service\n   must provide the session ID identifying the session to be\
    \ canceled.\n   On reception of a valid cancellation request from a client service,\n\
    \   LTP proceeds as follows.\n   First, the internal \"Cancel Session\" procedure\
    \ (Section 6.19) is\n   invoked.\n   Next, if the session is being canceled by\
    \ the sender (i.e., the\n   session originator part of the session ID supplied\
    \ in the\n   cancellation request is the local LTP engine ID):\n      - If none\
    \ of the data segments previously queued for transmission\n        as part of\
    \ this session have yet been de-queued and transmitted\n        -- i.e., if the\
    \ destination engine cannot possibly be aware of\n        this session -- then\
    \ the session is simply closed; the \"Close\n        Session\" procedure (Section\
    \ 6.20) is invoked.\n      - Otherwise, a CS (cancel by block sender) segment\
    \ with the\n        reason-code USR_CNCLD MUST be queued for transmission to the\n\
    \        destination LTP engine specified in the transmission request\n      \
    \  that started this session.\n   Otherwise (i.e., the session is being canceled\
    \ by the receiver):\n      - If there is no transmission queue-set bound for the\
    \ sender\n        (possibly because the local LTP engine is running on a receive-\n\
    \        only device), then the session is simply closed; the \"Close\n      \
    \  Session\" procedure (Section 6.20) is invoked.\n      - Otherwise, a CR (cancel\
    \ by block receiver) segment with reason-\n        code USR_CNCLD MUST be queued\
    \ for transmission to the block\n        sender.\n"
- title: 5.  Requirements from the Operating Environment
  contents:
  - "5.  Requirements from the Operating Environment\n   LTP is designed to run directly\
    \ over a data-link layer protocol.\n   LTP MUST only be deployed directly over\
    \ UDP, for software development\n   purposes or for use in private local area\
    \ networks, for example, in a\n   sparse sensor network where the link, when available,\
    \ is only used\n   for LTP traffic.\n   In either case, the protocol layer immediately\
    \ underlying LTP is\n   referred to as the \"local data-link layer\" for the purposes\
    \ of this\n   specification.\n   When the local data-link layer protocol is UDP,\
    \ (a) the content of\n   each UDP datagram MUST be an integral number of LTP segments\
    \ and (b)\n   the LTP authentication [LTPEXT] extension SHOULD be used unless\
    \ the\n   end-to-end path is one in which either the likelihood of datagram\n\
    \   content corruption is negligible or the consequences of receiving and\n  \
    \ processing corrupt LTP segments are insignificant (as during software\n   development).\
    \  In addition, the LTP authentication [LTPEXT] extension\n   SHOULD be used to\
    \ ensure data integrity unless the end-to-end path is\n   one in which either\
    \ the likelihood of datagram content corruption is\n   negligible (as in some\
    \ private local area networks) or the\n   consequences of receiving and processing\
    \ corrupt LTP segments are\n   insignificant (as perhaps during software development).\n\
    \   When the local data-link layer protocol is not UDP, the content of\n   each\
    \ local data-link layer protocol frame MUST be an integral number\n   of LTP segments.\n\
    \   The local data-link layer protocol MUST be a protocol that, together\n   with\
    \ the operating environment in which that protocol is implemented,\n   satisfies\
    \ the following requirements:\n      - It is required to inform LTP whenever the\
    \ link to a specific LTP\n        destination is brought up or torn down.  Similarly,\
    \ it is\n        required to inform the local LTP engine whenever it is known\n\
    \        that a remote LTP engine is set to begin or stop communication\n    \
    \    with the local engine based on the engines' operating schedules.\n      -\
    \ It is required to provide link state cues to LTP upon\n        transmission\
    \ of the CP, RS (report), EORP, EOB, and Cx (cancel)\n        segments so that\
    \ timers can be started.\n      - It is required to provide, upon request, the\
    \ current distance\n        (in light seconds) to any peer engine in order to\
    \ calculate\n        timeout intervals.\n   A MIB (Management Information Base)\
    \ with the above parameters,\n   updated periodically by the local data-link layer\
    \ and the operating\n   environment, should be made available to the LTP engine\
    \ for its\n   operations.  The details of the MIB are, however, beyond the scope\
    \ of\n   this document.\n   The underlying data-link layer is required to never\
    \ deliver\n   incompletely received LTP segments to LTP.  In the absence of the\
    \ use\n   of LTP authentication [LTPEXT], LTP also requires the underlying\n \
    \  local data-link layer protocol to perform data integrity checking of\n   the\
    \ segments received.  Specifically, the local data-link layer\n   protocol is\
    \ required to detect any corrupted segments received and to\n   silently discard\
    \ them.\n"
- title: 6.  Internal Procedures
  contents:
  - "6.  Internal Procedures\n   This section describes the internal procedures that\
    \ are triggered by\n   the occurrence of various events during the lifetime of\
    \ an LTP\n   session.\n   Whenever the content of any of the fields of the header\
    \ of any\n   received LTP segment does not conform to this specification document,\n\
    \   the segment is assumed to be corrupt and MUST be discarded\n   immediately\
    \ and processed no further.  This procedure supersedes all\n   other procedures\
    \ described below.\n   All internal procedures described below that are triggered\
    \ by the\n   arrival of a data segment are superseded by the following procedure\n\
    \   in the event that the client service identified by the data segment\n   does\
    \ not exist at the local LTP engine:\n      - If there is no transmission queue-set\
    \ bound for the block sender\n        (possibly because the local LTP engine is\
    \ running on a receive-\n        only device), then the received data segment\
    \ is simply\n        discarded.\n      - Otherwise, if the data segment contains\
    \ data from the red-part\n        of the block, a CR with reason-code UNREACH\
    \ MUST be enqueued for\n        transmission to the block sender.  A CR with reason-code\
    \ UNREACH\n        SHOULD be similarly enqueued for transmission to the data sender\n\
    \        even if the data segment contained data from the green-part of\n    \
    \    the block; note however that (for example) in the case where the\n      \
    \  block receiver knows that the sender of this green-part data is\n        functioning\
    \ in a \"beacon\" (transmit-only) fashion, a CR need not\n        be sent.  In\
    \ either case, the received data segment is\n        discarded.\n"
- title: 6.1.  Start Transmission
  contents:
  - "6.1.  Start Transmission\n   This procedure is triggered by the arrival of a\
    \ link state cue\n   indicating the start of transmission to a specified remote\
    \ LTP\n   engine.\n   Response: the de-queuing and delivery of segments to the\
    \ LTP engine\n   specified in the link state cue begins.\n"
- title: 6.2.  Start Checkpoint Timer
  contents:
  - "6.2.  Start Checkpoint Timer\n   This procedure is triggered by the arrival of\
    \ a link state cue\n   indicating the de-queuing (for transmission) of a CP segment.\n\
    \   Response: the expected arrival time of the RS segment that will be\n   produced\
    \ on reception of this CP segment is computed, and a countdown\n   timer is started\
    \ for this arrival time.  However, if it is known that\n   the remote LTP engine\
    \ has ceased transmission (Section 6.5), then\n   this timer is immediately suspended,\
    \ because the computed expected\n   arrival time may require an adjustment that\
    \ cannot yet be computed.\n"
- title: 6.3.  Start RS Timer
  contents:
  - "6.3.  Start RS Timer\n   This procedure is triggered by the arrival of a link\
    \ state cue\n   indicating the de-queuing (for transmission) of an RS segment.\n\
    \   Response: the expected arrival time of the RA (report acknowledgment)\n  \
    \ segment in response to the reception of this RS segment is computed,\n   and\
    \ a countdown timer is started for this arrival time.  However, as\n   in Section\
    \ 6.2, if it is known that the remote LTP engine has ceased\n   transmission (Section\
    \ 6.5), then this timer is immediately suspended,\n   because the computed expected\
    \ arrival time may require an adjustment\n   that cannot yet be computed.\n"
- title: 6.4.  Stop Transmission
  contents:
  - "6.4.  Stop Transmission\n   This procedure is triggered by the arrival of a link\
    \ state cue\n   indicating the cessation of transmission to a specified remote\
    \ LTP\n   engine.\n   Response: the de-queuing and delivery to the underlying\
    \ communication\n   system of segments from traffic queues bound for the LTP engine\n\
    \   specified in the link state cue ceases.\n"
- title: 6.5.  Suspend Timers
  contents:
  - "6.5.  Suspend Timers\n   This procedure is triggered by the arrival of a link\
    \ state cue\n   indicating the cessation of transmission from a specified remote\
    \ LTP\n   engine to the local LTP engine.  Normally, this event is inferred\n\
    \   from advance knowledge of the remote engine's planned transmission\n   schedule.\n\
    \   Response: countdown timers for the acknowledging segments that the\n   remote\
    \ engine is expected to return are suspended as necessary based\n   on the following\
    \ procedure.\n   The nominal remote engine acknowledge transmission time is computed\n\
    \   as the sum of the transmission time of the original segment (to which\n  \
    \ the acknowledging segment will respond) and the one-way light time to\n   the\
    \ remote engine, plus N seconds of \"additional anticipated latency\"\n   (AAL)\
    \ encompassing anticipated transmission delays other than signal\n   propagation\
    \ time.  N is determined in an implementation-specific\n   manner.  For example,\
    \ when LTP is deployed in deep-space vehicles,\n   the one-way light time to the\
    \ remote engine may be very large while N\n   may be relatively small, covering\
    \ processing and queuing delays.  N\n   may be a network management parameter,\
    \ for which 2 seconds seems like\n   a reasonable default value.  As another example,\
    \ when LTP is deployed\n   in a terrestrial \"data mule\" environment, one-way\
    \ light time latency\n   is effectively zero while N may need to be some dynamically\
    \ computed\n   function of the data mule circulation schedule.\n   If the nominal\
    \ remote engine acknowledge transmission time is greater\n   than or equal to\
    \ the current time (i.e., the acknowledging segment\n   may be presented for transmission\
    \ during the time that transmission\n   at the remote engine is suspended), then\
    \ the countdown timer for this\n   acknowledging segment is suspended.\n"
- title: 6.6.  Resume Timers
  contents:
  - "6.6.  Resume Timers\n   This procedure is triggered by the arrival of a link\
    \ state cue\n   indicating the start of transmission from a specified remote LTP\n\
    \   engine to the local LTP engine.  Normally, this event is inferred\n   from\
    \ advance knowledge of the remote engine's planned transmission\n   schedule.\n\
    \   Response: expected arrival time is adjusted for every acknowledging\n   segment\
    \ that the remote engine is expected to return, for which the\n   countdown timer\
    \ has been suspended.  First, the transmission delay\n   interval is calculated\
    \ as follows:\n      - The nominal remote engine acknowledge transmission time\
    \ is\n        computed as the sum of the transmission time of the original\n \
    \       segment (to which the acknowledging segment will respond) and\n      \
    \  the one-way light time to the remote engine, plus N seconds of\n        AAL\
    \ Section 6.5.\n      - If the nominal remote engine acknowledge transmission\
    \ time is\n        greater than the current time, i.e., the remote engine resumed\n\
    \        transmission prior to presentation of the acknowledging segment\n   \
    \     for transmission, then the transmission delay interval is zero.\n      -\
    \ Otherwise, the transmission delay interval is computed as the\n        current\
    \ time less the nominal remote engine acknowledge\n        transmission time.\n\
    \   The expected arrival time is increased by the computed transmission\n   delay\
    \ interval for each of the suspended countdown timers, and the\n   timers are\
    \ resumed.\n"
- title: 6.7.  Retransmit Checkpoint
  contents:
  - "6.7.  Retransmit Checkpoint\n   This procedure is triggered by the expiration\
    \ of a countdown timer\n   associated with a CP segment.\n   Response: if the\
    \ number of times this CP segment has been queued for\n   transmission exceeds\
    \ the checkpoint retransmission limit established\n   for the local LTP engine\
    \ by network management, then the session of\n   which the segment is one token\
    \ is canceled: the \"Cancel Session\"\n   procedure (Section 6.19) is invoked,\
    \ a CS with reason-code RLEXC is\n   appended to the (conceptual) application\
    \ data queue, and a\n   transmission-session cancellation notice (Section 7.5)\
    \ is sent back\n   to the client service that requested the transmission.\n  \
    \ Otherwise, a new copy of the CP segment is appended to the\n   (conceptual)\
    \ application data queue for the destination LTP engine.\n"
- title: 6.8.  Retransmit RS
  contents:
  - "6.8.  Retransmit RS\n   This procedure is triggered by either (a) the expiration\
    \ of a\n   countdown timer associated with an RS segment or (b) the reception\
    \ of\n   a CP segment for which one or more RS segments were previously issued\n\
    \   -- a redundantly retransmitted checkpoint.\n   Response: if the number of\
    \ times any affected RS segment has been\n   queued for transmission exceeds the\
    \ report retransmission limit\n   established for the local LTP engine by network\
    \ management, then the\n   session of which the segment is one token is canceled:\
    \ the \"Cancel\n   Session\" procedure (Section 6.19) is invoked, a CR segment\
    \ with\n   reason-code RLEXC is queued for transmission to the LTP engine that\n\
    \   originated the session, and a reception-session cancellation notice\n   (Section\
    \ 7.6) is sent to the client service identified in each of the\n   data segments\
    \ received in this session.\n   Otherwise, a new copy of each affected RS segment\
    \ is queued for\n   transmission to the LTP engine that originated the session.\n"
- title: 6.9.  Signify Red-Part Reception
  contents:
  - "6.9.  Signify Red-Part Reception\n   This procedure is triggered by the arrival\
    \ of a CP segment when the\n   EORP for this session has been received (ensuring\
    \ that the size of\n   the data block's red-part is known; this includes the case\
    \ where the\n   CP segment itself is the EORP segment) and all data in the red-part\n\
    \   of the block being transmitted in this session have been received.\n   Response:\
    \ a red-part reception notice (Section 7.3) is sent to the\n   specified client\
    \ service.\n"
- title: 6.10.  Signify Green-Part Segment Arrival
  contents:
  - "6.10.  Signify Green-Part Segment Arrival\n   This procedure is triggered by\
    \ the arrival of a data segment whose\n   content is a portion of the green-part\
    \ of a block.\n   Response: a green-part segment arrival notice (Section 7.2)\
    \ is sent\n   to the specified client service.\n"
- title: 6.11.  Send Reception Report
  contents:
  - "6.11.  Send Reception Report\n   This procedure is triggered by either (a) the\
    \ original reception of a\n   CP segment (the checkpoint serial number identifying\
    \ this CP is new)\n   (b) an implementation-specific circumstance pertaining to\
    \ a\n   particular block reception session for which no EORP has yet been\n  \
    \ received (\"asynchronous\" reception reporting).\n   Response: if the number\
    \ of reception problems detected for this\n   session exceeds a limit established\
    \ for the local LTP engine by\n   network management, then the affected session\
    \ is canceled: the\n   \"Cancel Session\" procedure (Section 6.19) is invoked,\
    \ a CR segment\n   with reason-code RLEXC is issued and is, in concept, appended\
    \ to the\n   queue of internal operations traffic bound for the LTP engine that\n\
    \   originated the session, and a reception-session cancellation notice\n   (Section\
    \ 7.6) is sent to the client service identified in each of the\n   data segments\
    \ received in this session.  One possible limit on\n   reception problems would\
    \ be the maximum number of reception reports\n   that can be issued for any single\
    \ session.\n   If such a limit is not reached, a reception report is issued as\n\
    \   follows.\n   If production of the reception report was triggered by reception\
    \ of a\n   checkpoint:\n      - The upper bound of the report SHOULD be the upper\
    \ bound (the sum\n        of the offset and length) of the checkpoint data segment,\
    \ to\n        minimize unnecessary retransmission.  Note: If a discretionary\n\
    \        checkpoint is lost but subsequent segments are received, then by\n  \
    \      the time the retransmission of the lost checkpoint is received\n      \
    \  the receiver would have segments at block offsets beyond the\n        upper\
    \ bound of the checkpoint.  For deployments where bandwidth\n        economy is\
    \ not critical, the upper bound of a synchronous\n        reception report MAY\
    \ be the maximum upper bound value among all\n        red-part data segments received\
    \ so far in the affected session.\n      - If the checkpoint was itself issued\
    \ in response to a report\n        segment, then this report is a \"secondary\"\
    \ reception report.  In\n        that case, the lower bound of the report SHOULD\
    \ be the lower\n        bound of the report segment to which the triggering checkpoint\n\
    \        was itself a response, to minimize unnecessary retransmission.\n    \
    \    Note: For deployments where bandwidth economy is not critical,\n        the\
    \ lower bound of the report MAY instead be zero.\n      - If the checkpoint was\
    \ not issued in response to a report\n        segment, this report is a \"primary\"\
    \ reception report.  The lower\n        bound of the first primary reception report\
    \ issued for any\n        session MUST be zero.  The lower bound of each subsequent\n\
    \        primary reception report issued for the same session SHOULD be\n    \
    \    the upper bound of the prior primary reception report issued for\n      \
    \  the session, to minimize unnecessary retransmission.  Note: For\n        deployments\
    \ where bandwidth economy is not critical, the lower\n        bound of every primary\
    \ reception report MAY be zero.\n   If production of the reception report is \"\
    asynchronous\" as noted\n   above:\n      - The upper bound of the report MUST\
    \ be the maximum upper bound\n        among all red-part data segments received\
    \ so far for this\n        session.\n      - The lower bound of the first asynchronous\
    \ reception report\n        issued for any session for which no other primary\
    \ reception\n        reports have yet been issued MUST be zero.  The lower bound\
    \ of\n        each subsequent asynchronous reception report SHOULD be the\n  \
    \      upper bound of the prior primary reception report issued for the\n    \
    \    session, to minimize unnecessary retransmission.  Note: For\n        deployments\
    \ where bandwidth economy is not critical, the lower\n        bound of every asynchronous\
    \ reception report MAY be zero.\n   In all cases, if the applicable lower bound\
    \ of the scope of a report\n   is determined to be greater than or equal to the\
    \ applicable upper\n   bound (for example, due to out-of-order arrival of discretionary\n\
    \   checkpoints) then the reception report MUST NOT be issued.\n   Otherwise:\n\
    \   As many RS segments must be produced as are needed in order to report\n  \
    \ on all data reception within the scope of the report, given whatever\n   data\
    \ size constraints are imposed by the underlying communication\n   service.  The\
    \ RS segments are, in concept, appended to the queue of\n   internal operations\
    \ traffic bound for the LTP engine that originated\n   the indicated session.\
    \  The lower bound of the first RS segment of\n   the report MUST be the reception\
    \ report's lower bound.  The upper\n   bound of the last RS segment of the report\
    \ MUST be the reception\n   report's upper bound.\n"
- title: 6.12.  Signify Transmission Completion
  contents:
  - "6.12.  Signify Transmission Completion\n   This procedure is triggered at the\
    \ earliest time at which (a) all\n   data in the block are known to have been\
    \ transmitted *and* (b) the\n   entire red-part of the block -- if of non-zero\
    \ length -- is known to\n   have been successfully received.  Condition (a) is\
    \ signaled by\n   arrival of a link state cue indicating the de-queuing (for\n\
    \   transmission) of the EOB segment for the block.  Condition (b) is\n   signaled\
    \ by reception of an RS segment whose reception claims, taken\n   together with\
    \ the reception claims of all other RS segments\n   previously received in the\
    \ course of this session, indicate complete\n   reception of the red-part of the\
    \ block.\n   Response: a transmission-session completion notice (Section 7.4)\
    \ is\n   sent to the local client service associated with the session, and the\n\
    \   session is closed: the \"Close Session\" procedure (Section 6.20) is\n   invoked.\n"
- title: 6.13.  Retransmit Data
  contents:
  - "6.13.  Retransmit Data\n   This procedure is triggered by the reception of an\
    \ RS segment.\n   Response: first, an RA segment with the same report serial number\
    \ as\n   the RS segment is issued and is, in concept, appended to the queue of\n\
    \   internal operations traffic bound for the receiver.  If the RS\n   segment\
    \ is redundant -- i.e., either the indicated session is unknown\n   (for example,\
    \ the RS segment is received after the session has been\n   completed or canceled)\
    \ or the RS segment's report serial number\n   matches that of an RS segment that\
    \ has already been received and\n   processed -- then no further action is taken.\
    \  Otherwise, the\n   procedure below is followed.\n   If the report's checkpoint\
    \ serial number is not zero, then the\n   countdown timer associated with the\
    \ indicated checkpoint segment is\n   deleted.\n   Note: All retransmission buffer\
    \ space occupied by data whose\n   reception is claimed in the report segment\
    \ can (in concept) be\n   released.\n   If the segment's reception claims indicate\
    \ incomplete data reception\n   within the scope of the report segment:\n    \
    \  - If the number of transmission problems for this session exceeds\n       \
    \ a limit established for the local LTP engine by network\n        management,\
    \ then the session of which the segment is one token\n        is canceled: the\
    \ \"Cancel Session\" procedure (Section 6.19) is\n        invoked, a CS with reason-code\
    \ RLEXC is appended to the\n        transmission queue specified in the transmission\
    \ request that\n        started this session, and a transmission-session cancellation\n\
    \        notice (Section 7.5) is sent back to the client service that\n      \
    \  requested the transmission.  One possible limit on transmission\n        problems\
    \ would be the maximum number of retransmission CP\n        segments that may\
    \ be issued for any single session.\n      - If the number of transmission problems\
    \ for this session has not\n        exceeded any limit, new data segments encapsulating\
    \ all block\n        data whose non-reception is implied by the reception claims\
    \ are\n        appended to the transmission queue bound for the receiver.  The\n\
    \        last -- and only the last -- data segment must be marked as a CP\n  \
    \      segment carrying a new CP serial number (obtained by\n        incrementing\
    \ the last CP serial number used) and the report\n        serial number of the\
    \ received RS segment.\n"
- title: 6.14.  Stop RS Timer
  contents:
  - "6.14.  Stop RS Timer\n   This procedure is triggered by the reception of an RA.\n\
    \   Response: the countdown timer associated with the original RS segment\n  \
    \ (identified by the report serial number of the RA segment) is\n   deleted. \
    \ If no other countdown timers associated with RS segments\n   exist for this\
    \ session, then the session is closed: the \"Close\n   Session\" procedure (Section\
    \ 6.20) is invoked.\n"
- title: 6.15.  Start Cancel Timer
  contents:
  - "6.15.  Start Cancel Timer\n   This procedure is triggered by arrival of a link\
    \ state cue indicating\n   the de-queuing (for transmission) of a Cx segment.\n\
    \   Response: the expected arrival time of the CAx segment that will be\n   produced\
    \ on reception of this Cx segment is computed and a countdown\n   timer for this\
    \ arrival time is started.  However, if it is known that\n   the remote LTP engine\
    \ has ceased transmission (Section 6.5), then\n   this timer is immediately suspended,\
    \ because the computed expected\n   arrival time may require an adjustment that\
    \ cannot yet be computed.\n"
- title: 6.16.  Retransmit Cancellation Segment
  contents:
  - "6.16.  Retransmit Cancellation Segment\n   This procedure is triggered by the\
    \ expiration of a countdown timer\n   associated with a Cx segment.\n   Response:\
    \ if the number of times this Cx segment has been queued for\n   transmission\
    \ exceeds the cancellation retransmission limit\n   established for the local\
    \ LTP engine by network management, then the\n   session of which the segment\
    \ is one token is simply closed: the\n   \"Close Session\" procedure (Section\
    \ 6.20) is invoked.\n   Otherwise, a copy of the cancellation segment (retaining\
    \ the same\n   reason-code) is queued for transmission to the appropriate LTP\n\
    \   engine.\n"
- title: 6.17.  Acknowledge Cancellation
  contents:
  - "6.17.  Acknowledge Cancellation\n   This procedure is triggered by the reception\
    \ of a Cx segment.\n   Response: in the case of a CS segment where there is no\
    \ transmission\n   queue-set bound for the sender (possibly because the receiver\
    \ is a\n   receive-only device), then no action is taken.  Otherwise:\n      -\
    \ If the received segment is a CS segment, a CAS (cancel\n        acknowledgment\
    \ to block sender) segment is issued and is, in\n        concept, appended to\
    \ the queue of internal operations traffic\n        bound for the sender.\n  \
    \    - If the received segment is a CR segment, a CAR (cancel\n        acknowledgment\
    \ to block receiver) segment is issued and is, in\n        concept, appended to\
    \ the queue of internal operations traffic\n        bound for the receiver.\n\
    \   It is possible that the Cx segment has been retransmitted because a\n   previous\
    \ responding acknowledgment CAx (cancel acknowledgment)\n   segment was lost,\
    \ in which case there will no longer be any record of\n   the session of which\
    \ the segment is one token.  If so, no further\n   action is taken.\n   Otherwise:\
    \ the \"Cancel Session\" procedure (Section 6.19) is invoked\n   and a reception-session\
    \ cancellation notice (Section 7.6) is sent to\n   the client service identified\
    \ in each of the data segments received\n   in this session.  Finally, the session\
    \ is closed: the \"Close Session\"\n   procedure (Section 6.20) is invoked.\n"
- title: 6.18.  Stop Cancel Timer
  contents:
  - "6.18.  Stop Cancel Timer\n   This procedure is triggered by the reception of\
    \ a CAx segment.\n   Response: the timer associated with the Cx segment is deleted,\
    \ and\n   the session of which the segment is one token is closed, i.e., the\n\
    \   \"Close Session\" procedure (Section 6.20) is invoked.\n"
- title: 6.19.  Cancel Session
  contents:
  - "6.19.  Cancel Session\n   This procedure is triggered internally by one of the\
    \ other procedures\n   described above.\n   Response: all segments of the affected\
    \ session that are currently\n   queued for transmission can be deleted from the\
    \ outbound traffic\n   queues.  All countdown timers currently associated with\
    \ the session\n   are deleted.  Note: If the local LTP engine is the sender, then\
    \ all\n   remaining data retransmission buffer space allocated to the session\n\
    \   can be released.\n"
- title: 6.20.  Close Session
  contents:
  - "6.20.  Close Session\n   This procedure is triggered internally by one of the\
    \ other procedures\n   described above.\n   Response: any remaining countdown\
    \ timers associated with the session\n   are deleted.  The session state record\
    \ (SSR|RSR) for the session is\n   deleted; existence of the session is no longer\
    \ recognized.\n"
- title: 6.21.  Handle Miscolored Segment
  contents:
  - "6.21.  Handle Miscolored Segment\n   This procedure is triggered by the arrival\
    \ of either (a) a red-part\n   data segment whose block offset begins at an offset\
    \ higher than the\n   block offset of any green-part data segment previously received\
    \ for\n   the same session or (b) a green-part data segment whose block offset\n\
    \   is lower than the block offset of any red-part data segment\n   previously\
    \ received for the same session.  The arrival of a segment\n   matching either\
    \ of the above checks is a violation of the protocol\n   requirement of having\
    \ all red-part data as the block prefix and all\n   green-part data as the block\
    \ suffix.\n   Response: the received data segment is simply discarded.\n   The\
    \ Cancel Session procedure (Section 6.19) is invoked and a CR\n   segment with\
    \ reason-code MISCOLORED SHOULD be enqueued for\n   transmission to the data sender.\n\
    \   Note: If there is no transmission queue-set bound for the sender\n   (possibly\
    \ because the local LTP engine is running on a receive-only\n   device), or if\
    \ the receiver knows that the sender is functioning in a\n   \"beacon\" (transmit-only)\
    \ fashion, a CR segment need not be sent.\n   A reception-session cancellation\
    \ notice (Section 7.6) is sent to the\n   client service.\n"
- title: 6.22.  Handling System Error Conditions
  contents:
  - "6.22.  Handling System Error Conditions\n   It is possible (especially for long-lived\
    \ LTP sessions) that an\n   unexpected operating system error condition may occur\
    \ during the\n   lifetime of an LTP session.  An example is the case where the\
    \ system\n   faces severe memory crunch forcing LTP sessions into a scenario\n\
    \   similar to that of TCP SACK [SACK] reneging.  But unlike TCP SACK\n   reception\
    \ reports, which are advisory, LTP reception reports are\n   binding, and reneging\
    \ is NOT permitted on previously made reception\n   claims.\n   Under any such\
    \ irrecoverable system error condition, the following\n   response is to be initiated:\
    \ the Cancel Session procedure (Section\n   6.19) is invoked.  If the error condition\
    \ is observed on the sender,\n   a CS segment with reason-code SYS_CNCLD SHOULD\
    \ be enqueued for\n   transmission to the receiver, and a transmission-session\
    \ cancellation\n   notice (Section 7.5) is sent to the client service; on the\
    \ other\n   hand, if it is observed on the receiver, a CR segment with the same\n\
    \   reason-code SYS_CNCLD SHOULD be enqueued for transmission to the\n   sender,\
    \ and a reception-session cancellation notice (Section 7.6) is\n   sent to the\
    \ client service.\n   Note that as in (Section 6.21), if there is no transmission\
    \ queue-set\n   bound for the sender (possibly because the local LTP engine is\n\
    \   running on a receive-only device), or if the receiver knows that the\n   sender\
    \ of this green-part data is functioning in a \"beacon\"\n   (transmit-only) fashion,\
    \ a CR segment need not be sent.\n   There may be other implementation-specific\
    \ limits that may cause an\n   LTP implementation to initiate session-cancellation\
    \ procedures.  One\n   such limit is the maximum number of retransmission-cycles\
    \ seen.  A\n   retransmission cycle at the LTP Sender comprises the two related\n\
    \   events: the transmission of all outstanding CP segments from the\n   sender,\
    \ and the reception of all RS segments issued from the receiver\n   in response\
    \ to those CP segments.  A similar definition would apply\n   at the LTP Receiver\
    \ but relate to the reception of the CP segments\n   and transmission of all RS\
    \ segments in response.  Note that the\n   retransmitted CP and RS segments remain\
    \ part of their original\n   retransmission-cycle.  Also, a single CP segment\
    \ may cause multiple\n   RS segments to be generated if a reception report would\
    \ not fit in a\n   single data link-MTU-sized RS segment; all RS segments that\
    \ are part\n   of a reception report belong to the same retransmission cycle to\n\
    \   which the CP segment belongs.  In the presence of severe channel\n   error\
    \ conditions, many retransmission cycles may elapse before red-\n   part transmission\
    \ is deemed successful; an implementation may\n   therefore impose a retransmission-cycle\
    \ limit to shield itself from a\n   resource-crunch situation.  If an LTP sender\
    \ notices the\n   retransmission-cycle limit being exceeded, it SHOULD initiate\
    \ the\n   Cancel Session procedure (Section 6.19), queuing a CS segment with\n\
    \   reason-code RXMTCYCEXC and sending a transmission-session\n   cancellation\
    \ notice (Section 7.5) to the client service.\n"
- title: 7.  Notices to Client Service
  contents:
  - "7.  Notices to Client Service\n   In all cases, the representation of notice\
    \ parameters is a local\n   implementation matter.\n"
- title: 7.1.  Session Start
  contents:
  - "7.1.  Session Start\n   The Session Start notice returns the session ID identifying\
    \ a newly\n   created session.\n   At the sender, the session start notice informs\
    \ the client service of\n   the initiation of the transmission session.  On receiving\
    \ this notice\n   the client service may, for example, release resources of its\
    \ own\n   that are allocated to the block being transmitted, or remember the\n\
    \   session ID so that the session can be canceled in the future if\n   necessary.\
    \  At the receiver, this notice indicates the beginning of a\n   new reception\
    \ session, and is delivered upon arrival of the first\n   data segment carrying\
    \ a new session ID.\n"
- title: 7.2.  Green-Part Segment Arrival
  contents:
  - "7.2.  Green-Part Segment Arrival\n   The following parameters are provided by\
    \ the LTP engine when a green-\n   part segment arrival notice is delivered:\n\
    \      Session ID of the transmission session.\n      Array of client service\
    \ data bytes contained in the data segment.\n      Offset of the data segment's\
    \ content from the start of the block.\n      Length of the data segment's content.\n\
    \      Indication as to whether or not the last byte of this data\n      segment's\
    \ content is also the end of the block.\n      Source LTP engine ID.\n"
- title: 7.3.  Red-Part Reception
  contents:
  - "7.3.  Red-Part Reception\n   The following parameters are provided by the LTP\
    \ engine when a red-\n   part reception notice is delivered:\n      Session ID\
    \ of the transmission session.\n      Array of client service data bytes that\
    \ constitute the red-part of\n      the block.\n      Length of the red-part of\
    \ the block.\n      Indication as to whether or not the last byte of the red-part\
    \ is\n      also the end of the block.\n      Source LTP engine ID.\n"
- title: 7.4.  Transmission-Session Completion
  contents:
  - "7.4.  Transmission-Session Completion\n   The sole parameter provided by the\
    \ LTP engine when a transmission-\n   session completion notice is delivered is\
    \ the session ID of the\n   transmission session.\n   A transmission-session completion\
    \ notice informs the client service\n   that all bytes of the indicated data block\
    \ have been transmitted and\n   that the receiver has received the red-part of\
    \ the block.\n"
- title: 7.5.  Transmission-Session Cancellation
  contents:
  - "7.5.  Transmission-Session Cancellation\n   The parameters provided by the LTP\
    \ engine when a transmission-session\n   cancellation notice is delivered are:\n\
    \      Session ID of the transmission session.\n      The reason-code sent or\
    \ received in the Cx segment that initiated\n      the cancellation sequence.\n\
    \   A transmission-session cancellation notice informs the client service\n  \
    \ that the indicated session was terminated, either by the receiver or\n   else\
    \ due to an error or a resource quench condition in the local LTP\n   engine.\
    \  There is no assurance that the destination client service\n   instance received\
    \ any portion of the data block.\n"
- title: 7.6.  Reception-Session Cancellation
  contents:
  - "7.6.  Reception-Session Cancellation\n   The parameters provided by the LTP engine\
    \ when a reception\n   cancellation notice is delivered are:\n      Session ID\
    \ of the transmission session.\n      The reason-code explaining the cancellation.\n\
    \   A reception-session cancellation notice informs the client service\n   that\
    \ the indicated session was terminated, either by the sender or\n   else due to\
    \ an error or a resource quench condition in the local LTP\n   engine.  No subsequent\
    \ delivery notices will be issued for this\n   session.\n"
- title: 7.7.  Initial-Transmission Completion
  contents:
  - "7.7.  Initial-Transmission Completion\n   The session ID of the transmission\
    \ session is included with the\n   initial-transmission completion notice.\n \
    \  This notice informs the client service that all segments of a block\n   (both\
    \ red-part and green-part) have been transmitted.  This notice\n   only indicates\
    \ that original transmission is complete; retransmission\n   of any lost red-part\
    \ data segments may still be necessary.\n"
- title: 8.  State Transition Diagrams
  contents:
  - "8.  State Transition Diagrams\n   The following mnemonics have been used in the\
    \ sender and LTP receiver\n   state transition diagrams that follow:\n      TE\
    \      Timer Expiry\n      RDS     Regular Red Data Segment (NOT {CP|EORP|EOB})\n\
    \      GDS     Regular Green Data Segment (NOT EOB)\n      RL EXC  Retransmission\
    \ Limit Exceeded\n      RP        Red-Part\n      GP        Green-Part\n     \
    \ FG        Fully-Green\n   Note that blocks represented in rectangles, as in\n\
    \      +---------+\n      | FG_XMIT |\n      +---------+\n   specify actual states\
    \ in the state-transition diagrams, while blocks\n   represented with jagged edges,\
    \ as in\n       /\\/\\/\\/\\\n      | Cncld |\n       \\/\\/\\/\\/\n   are either\
    \ pointers to a state or place-holders for sequences of\n   state transitions.\n"
- title: 8.1.  Sender
  contents:
  - "8.1.  Sender\n                 LTP Sender State Transition Diagram\n        \
    \                          /\\/\\/\\/\\\n                                 | Cncld\
    \ |\n                                  \\/\\/\\/\\/\n                       +--------+\
    \    |     +------+\n              Rcv CR;  |        V    V     V      | Rcv RS;\n\
    \              Snd CAR  |       +-------------+    | Snd RA\n                \
    \       +-------+   CLOSED    +----+\n +---------------------------->+------+------+\n\
    \ |                                    | Blk. Trans. Req\n |                 \
    \      Zero RP      +\n |  Xmit     ________________________/ \\  Non-Zero RP\n\
    \ |  GDS;    /                           \\\n | +---+   |       +------------------+\
    \  |  +------+\n | |   V   V       |   /\\/\\   Rcv RS  V  V  V      |\n | | \
    \ +---------+  +<-| RX |<---+   +---------+    |\n | +<-+ FG_XMIT |  |   \\/\\\
    /     +---+         +--->+ Xmit RDS;\n |    +----+----+  |                | RP_XMIT\
    \ |    |\n |         |       |   /\\/\\     +---+         +--->+ Xmit {RDS, CP};\n\
    \ +<--------+       +<-| CP |<---+   +-----+---+      Start CP Tmr\n |    Xmit\
    \             \\/\\/   CP TE       |    \\\n | {GDS, EOB};                   \
    \         |     |\n |                  Xmit {RDS, CP, EORP}; |     +-------+\n\
    \ |                  Start CP Tmr          |             |\n |               \
    \                         |             |\n |                 +------------------+\
    \   |  +---+      | Xmit {RDS,\n |                 |   /\\/\\  Rcv RS   V   V\
    \  V   |      | CP, EORP,\n |                 +<-| RX |<---+   +---------+  |\
    \      | EOB};\n |                 |   \\/\\/     +---+         |  |      | Start\n\
    \ |                 |                | GP_XMIT +->+      | CP Tmr\n |        \
    \         |   /\\/\\     +---+         | Xmit    |\n |                 +<-| CP\
    \ |<---+   +-----+---+ GDS;    |\n |                     \\/\\/  CP TE       \
    \ |             |\n |                                        |             |\n\
    \ |                       Xmit {GDS, EOB}; |   +---------+\n |               \
    \                         |   |\n |                 +------------------+   | \
    \  |\n |                 |   /\\/\\  Rcv RS   V   V   V\n |                 +<-|\
    \ RX |<---+   +-------------+\n |                 |   \\/\\/     +---+       \
    \      |\n |                 |                | WAIT_RP_ACK |\n |            \
    \     |   /\\/\\     +---+             |\n |                 +<-| CP |<---+  \
    \ +-----+-------+\n |                     \\/\\/  CP TE        | RP acknowledged\
    \ fully;\n |                                        V\n +----------------------------------------+\n\
    \          LTP Sender State Transition Diagram (contd.)\n         /\\/\\     \
    \                          /\\/\\\n         |CP|                             \
    \  |CX |\n         \\/\\/                               \\/\\/\n          | |\
    \                                 | Snd CS,\n          | | RL EXC;           \
    \              | Start CS Tmr;\n          | |                                \
    \ |\n          | |        /\\/\\                     |  +---+\n          | +------>|\
    \ CX |                    V  V   |\n          |          \\/\\/              \
    \  +---------+ | CS TE,\n          |                              | CS_SENT |\
    \ | RL NOT EXC;\n          V  RL NOT EXC;                 +-+--+--+-+ | Rxmt CS,\n\
    \             Rxmt CP,                      |  |  |   | Restart\n            \
    \ Start CP Tmr;         CS TE,  |  |  +---+ CS Tmr\n                         \
    \          RL EXC; |  |\n                                           |  | Rcv CAS;\n\
    \                                           V  V\n                           \
    \                /\\/\\/\\/\\\n                                          | Cncld\
    \  |\n                                           \\/\\/\\/\\/\n             /\\\
    /\\\n            | RX |\n             \\/\\/\n               |  Cncl CP Tmr (if\
    \ any)\n               V  Snd RA\n         +---------+                       \
    \         +----+\n         | CHK_RPT |                                |    |\n\
    \         +-+--+----+       RP in scope              V    |\n           |  | \
    \    \\     NOT rcvd. fully   +---------+  | Rxmt\n Redundant |  | RP   +--------------------->|\
    \ RP_RXMT |  | missing\n RS rcvd;  |  | in scope                    +----+--+-+\
    \  | RDS;\n           |  | rcvd. fully                      |  |    |\n      \
    \     V  V                    Rxmt last     |  +----+\n                      \
    \             missing RDS   |\n                                   (marked CP)\
    \   |\n                                   Start CP Tmr; |\n                  \
    \                               V\n   Asynchronous cancel request may be received\
    \ from the local client\n   service while the LTP sender is in any of the states\
    \ shown.  If it\n   was not already in the sequence of state transitions beginning\
    \ at the\n   CX marker, the internal procedure Cancel Session (Section 6.19) is\n\
    \   followed, and the LTP sender moves from its current state into the\n   sequence\
    \ beginning at the CX marker initiating session cancellation\n   with reason-code\
    \ USR_CNCLD.  From the CX marker, the CS segment with\n   appropriate reason-code\
    \ (USR_CNCLD or RLEXC depending on how the CX\n   sequence was entered) is queued\
    \ for transmission to the LTP receiver\n   and the sender enters the Cancel-from-Sender\
    \ Sent (CS_SENT) state.\n   The internal procedure Start Cancel Timer (Section\
    \ 6.15) is started\n   upon receiving a link state cue indicating the beginning\
    \ of\n   transmission of the CS segment.  Upon receiving the acknowledging CAS\n\
    \   segment from the receiver, the LTP sender moves to the CLOSED state\n   (via\
    \ the 'Cncld' pointer).  If the CS timer expires, the internal\n   procedure Retransmit\
    \ Cancellation Segment (Section 6.16) is followed:\n      - If the network management\
    \ set retransmission limit is exceeded,\n        the session is simply closed\
    \ and the LTP sender follows the\n        Cncld marker to the CLOSED state.  If\
    \ the retransmission limit\n        is not exceeded however, the CS segment is\
    \ queued for a\n        retransmission and the LTP sender stays in the CS_SENT\
    \ state.\n        The CS timer is started upon receiving a link state cue\n  \
    \      indicating the beginning of actual transmission according to the\n    \
    \    internal procedure Start Cancel Timer (Section 6.15).\n   Asynchronous cancel\
    \ request may also be received from the receiver\n   LTP in the form of a CR segment\
    \ when the LTP sender is in any of the\n   states.  Upon receiving such a CR segment,\
    \ the internal procedure\n   Acknowledge Cancellation (Section 6.17) is invoked:\
    \ The LTP sender\n   sends a CAR segment in response and returns to the CLOSED\
    \ state.\n   The LTP sender stays in the CLOSED state until receiving a Block\n\
    \   Transmission Request (Blk. Trans. Req) from the client service\n   instance.\
    \  Upon receiving the request, it moves to either the Fully\n   Green Transmission\
    \ State (FG_XMIT) if no portion of the block was\n   requested to be transmitted\
    \ as red or to the Red-Part Transmission\n   State (RP_XMIT) state if a non-zero\
    \ block-prefix was requested to be\n   transmitted red.\n   In the FG_XMIT state,\
    \ the block is segmented as multiple green LTP\n   data segments respecting the\
    \ link MTU size and the segments are\n   queued for transmission to the remote\
    \ engine.  The last such segment\n   is marked as EOB, and the LTP sender returns\
    \ to the CLOSED state\n   after queuing it for transmission.\n   Similarly, from\
    \ the RP_XMIT state, multiple red data segments are\n   queued for transmission,\
    \ respecting the link MTU size.  The sender\n   LTP may optionally mark some of\
    \ the red data segments as asynchronous\n   checkpoints; the internal procedure\
    \ Start Checkpoint Timer (Section\n   6.2) is followed upon receiving a link state\
    \ cue indicating the\n   transmission of the asynchronous checkpoints.  If the\
    \ block\n   transmission request comprises a non-zero green part, the LTP sender\n\
    \   marks the last red data segment as CP and EORP, and after queuing it\n   for\
    \ transmission, moves to the Green Part Transmission (GP_XMIT)\n   state.  If\
    \ the block transmission request was fully red however, the\n   last red data\
    \ segment is marked as CP, EORP, and EOB and the sender\n   LTP moves directly\
    \ to the Wait-for-Red-Part-Acknowledgment\n   (WAIT_RP_ACK) state.  In both of\
    \ the above state-transitions, the\n   internal procedure Start Checkpoint Timer\
    \ (Section 6.2) is followed\n   upon receiving a link state cue indicating the\
    \ beginning of\n   transmission of the queued CP segments.  In the GP_XMIT state,\
    \ the\n   green-part of the block is segmented as green data segments and\n  \
    \ queued for transmission to the LTP receiver; the last green segment\n   of the\
    \ block is additionally marked as EOB, and after queueing it for\n   transmission\
    \ the LTP sender moves to the WAIT_RP_ACK state.\n   While the LTP sender is at\
    \ any of the RP_XMIT, GP_XMIT, or\n   WAIT_RP_ACK states, it might be interrupted\
    \ by the occurrence of the\n   following events:\n      1. An RS might be received\
    \ from the LTP receiver (either in\n         response to a previously transmitted\
    \ CP segment or sent\n         asynchronously for accelerated retransmission).\
    \  The LTP sender\n         then moves to perform the sequence of state transitions\n\
    \         beginning at the RX marker (second part of the diagram), and\n     \
    \    retransmits data if necessary, illustrating the internal\n         procedure\
    \ Retransmit Data (Section 6.13):\n         First, if the RS segment had a non-zero\
    \ CP serial number, the\n         corresponding CP timer is canceled.  Then an\
    \ RA segment\n         acknowledging the received RS segment is queued for\n \
    \        transmission to the LTP receiver and the LTP sender moves to\n      \
    \   the Check Report state (CHK_RPT).  If the RS segment was\n         redundantly\
    \ transmitted by the LTP receiver (possibly because\n         either the last\
    \ transmitted RA segment got lost or the RS\n         segment timer expired prematurely\
    \ at the receiver), the LTP\n         sender does nothing more and returns back\
    \ to the interrupted\n         state.  Similarly, if all red data within the scope\
    \ of the RS\n         segment is reported as received, there is no work to be\
    \ done\n         and the LTP sender returns to the interrupted state.  However,\n\
    \         if the RS segment indicated incomplete reception of data within\n  \
    \       its scope, the LTP sender moves to the Red-Part Retransmit\n         state\
    \ (RP_RXMT) where missing red data segments within scope\n         are queued\
    \ for transmission.  The last such segment is marked\n         as a CP, and the\
    \ LTP sender returns to the interrupted state.\n         The internal procedure\
    \ (Section 6.2) is followed upon receiving\n         a link state cue indicating\
    \ the beginning of transmission of\n         the CP segment.\n      2. A previously\
    \ set CP timer might expire.  Now the LTP sender\n         follows the states\
    \ beginning at the CP marker (second part of\n         the diagram), and follows\
    \ the internal procedure Retransmit\n         Checkpoint (Section 6.7):\n    \
    \     If the CP Retransmission Limit set by network management for\n         the\
    \ session has been exceeded, the LTP sender proceeds towards\n         canceling\
    \ the session (with reason-code RLEXC) as indicated by\n         the sequence\
    \ of state transitions following the CX marker.\n         Otherwise (if the Retransmission\
    \ Limit is not exceeded yet),\n         the CP segment is queued for retransmission\
    \ and the LTP sender\n         returns to the interrupted state.  The internal\
    \ procedure Start\n         Checkpoint Timer (Section 6.2) is started again upon\
    \ receiving\n         a link state cue indicating the beginning of transmission\
    \ of\n         the segment.\n   The LTP sender stays at the WAIT_RP_ACK state\
    \ after reaching it until\n   the red-part data is fully acknowledged as received\
    \ by the receiver\n   LTP, and then returns to the CLOSED state following the\
    \ internal\n   procedure Close Session (Section 6.20).\n   Note that while at\
    \ the CLOSED state, the LTP sender might receive an\n   RS segment (if the last\
    \ transmitted RA segment before session close\n   got lost or if the LTP receiver\
    \ retransmitted the RS segment\n   prematurely), in which case it retransmits\
    \ an acknowledging RA\n   segment and stays in the CLOSED state.  If the session\
    \ was canceled\n   by the receiver by issuing a CR segment, the receiver may retransmit\n\
    \   the CR segment (either prematurely or because the acknowledging CAR\n   segment\
    \ got lost).  In this case, the LTP sender retransmits the\n   acknowledging CAR\
    \ segment and stays in the CLOSED state.\n"
- title: 8.2.  Receiver
  contents:
  - "8.2.  Receiver\n                  LTP Receiver State Transition Diagram\n   \
    \                                          /\\/\\/\\/\\\n                    \
    \      +----+       +----+ Cncld  |\n                  Rcv CS; |    V       V\
    \     \\/\\/\\/\\/\n                  Snd CAS |  +-------------+\n           \
    \               +--+    CLOSED   +<--------------------------+\n             \
    \                +------+------+                           |\n               \
    \             +----+  | Rcv first DS                     |\n                 Rcv\
    \ RA;    |    V  V                                  |\n                Cncl RS\
    \ Tmr |   +--------+                             |\n                         \
    \   +---+ DS_REC |                             |\n +----------------------------->+-+--+-+-+<----------------------+---+\
    \ |\n |          Svc. does not exist   |  | | RS TE                   |   | |\n\
    \ |   /\\/\\  or Rcv miscolored seg. |  | |               /\\/\\      |   | |\n\
    \ |  | CX |<-----------------------+  | +------------->| RX |---->+   | |\n |\
    \   \\/\\/                            |                 \\/\\/          | |\n\
    \ |                        Rcv RDS;   |   Rcv GDS;                    | |\n |\
    \                       +-----------+------------+                  | |\n |  \
    \                     V                        V                  | |\n |   /\\\
    /\\  RS TE +--------------+             +--------+             | |\n +<-| RX |<------+\
    \    RCV_RP    |             | RCV_GP |             | |\n |   \\/\\/        +-+----+--+--+-+\
    \             +--+-+-+-+             | |\n |                 |    |  |  |    \
    \              | | |               | |\n |    Rcvd RDS;    |    |  |  | Rcvd {RDS,\
    \ CP,   | | | RS TE  /\\/\\   | |\n |                 |    |  |  | EORP, EOB};\
    \      | | +------>| RX |->+ |\n +<----------------+    |  |  | Snd RS,      \
    \    | |          \\/\\/   | |\n |                      |  |  | Start RS Tmr \
    \    | | Rcvd GDS;       | |\n | Rcvd {RDS, CP};      |  |  |                \
    \  | +---------------->+ |\n | Snd RS, Start RS Tmr |  |  +-------+    +-----+\
    \                     |\n +<---------------------+  |          |    | Rcvd {GDS,\
    \ EOB};          |\n |                         |          |    |             \
    \              |\n |                         | +-----+  |    |   +------+    \
    \            |\n | Rcvd {RDS, CP, EORP};   | |     V  V    V   V      |      \
    \          |\n | Snd RS, Start RS Tmr    | |   +----------------+   | Rcv RDS;\
    \       |\n |                         | |   |                +-->+           \
    \     |\n |                         | |   |   WAIT_RP_REC  |   | Rcv {RDS, CP};\
    \ |\n |                         | |   |                +-->+ Snd RS, Start  |\n\
    \ +<------------------------+ |   +---+--+-+-+-----+   |        RS Tmr  |\n  \
    \                           | RS TE |  | | | Rcv RA; |                |\n    \
    \                         |       V  | | | Cncl    |                |\n      \
    \                       |    /\\/\\  | | | RS Tmr  |                |\n      \
    \                       +---| RX | | | +-------->+                |\n        \
    \                          \\/\\/  | |                            |\n        \
    \  /\\/\\                          | |                            |\n        \
    \ | CX |<------------------------+ |  RP rcvd. fully            |\n          \\\
    /\\/      Rcv miscolored seg.   +--------------------------->+\n Receiver State\
    \ Transition Diagram (contd.)\n               /\\/\\\n              | RX |\n \
    \              \\/\\/\n               |  |\n               |  | RL EXC;    /\\\
    /\\\n  RL NOT EXC;  |  +---------->| CX |\n  Rxmt RS,     |               \\/\\\
    /\n  Start RS Tmr |\n               V\n               /\\/\\\n              |\
    \ CX |\n               \\/\\/\n                 | Snd CR,\n                 |\
    \ Start CR Tmr;\n                 |\n                 |  +----+\n            \
    \     V  V    |\n             +---------+ | CR TE,\n             | CR_SENT | |\
    \ RL NOT EXC;\n             +-+--+--+-+ | Rxmt CR,\n               |  |  |   |\
    \ Restart\n       CR TE,  |  |  +---+ CR Tmr\n       RL EXC; |  |\n          \
    \     |  | Rcv CAR;\n               V  V\n               /\\/\\/\\/\\\n      \
    \        | Cncld  |\n               \\/\\/\\/\\/\n   Asynchronous cancel requests\
    \ are handled in a manner similar to the\n   way they are handled in the LTP sender.\
    \  If the cancel request was\n   made from the local client service instance and\
    \ the LTP receiver was\n   not already in the CR_SENT state, a CR segment with\
    \ reason-code\n   USR_CNCLD SHOULD be sent to the LTP sender following the sequence\
    \ of\n   state transitions beginning at the CX marker as described above.  If\n\
    \   the asynchronous cancel request is received from the LTP sender, a\n   CAS\
    \ segment is sent and the LTP receiver moves to the CLOSED state\n   (independent\
    \ of the state the LTP receiver may be in).\n   The LTP receiver begins at the\
    \ CLOSED state and enters the Data\n   Segment Reception (DS_REC) state upon receiving\
    \ the first data\n   segment.  If the client service ID referenced in the data\
    \ segment was\n   non-existent, a Cx segment with reason-code UNREACH SHOULD be\
    \ sent to\n   the LTP sender via the Cancellation sequence beginning with the\
    \ CX\n   marker (second part of the diagram).  If the received segment was\n \
    \  found to be miscolored, the internal procedure Handle Miscolored\n   Segment\
    \ (Section 6.21) is followed, and a CX segment with reason-code\n   MISCOLORED\
    \ SHOULD be sent to the LTP sender with the Cancellation\n   sequence beginning\
    \ with the CX marker.\n   Otherwise, the LTP receiver enters the Receive Red-Part\
    \ state\n   (RCV_RP) or the Receive Green-Part state (RCV_GP) depending on\n \
    \  whether the segment received was red or green, respectively.\n   In the RCV_RP\
    \ state, a check is made of the nature of the received\n   red DS.  If the segment\
    \ was a regular red data segment, the receiver\n   LTP just returns to the DS_REC\
    \ state.  For red data segments marked\n   also as CP and as CP & EORP, a responding\
    \ RS segment is queued for\n   transmission to the sender following either the\
    \ internal procedure\n   Retransmit RS (Section 6.8) or Send Reception Report\
    \ (Section 6.11)\n   depending on whether the CP segment was a retransmission\
    \ (an RS\n   segment corresponding to the checkpoint serial number in the CP\n\
    \   segment was previously issued) or not, respectively.  The LTP\n   receiver\
    \ then returns to the DS_REC state.  If the block transmission\n   was fully red\
    \ and the segment was marked as CP, EORP, and EOB, the\n   LTP receiver enters\
    \ the Wait-for-Red-Part-Reception state\n   (WAIT_RP_REC).  In all cases, the\
    \ internal procedure Start RS Timer\n   (Section 6.3) is followed upon receiving\
    \ link state cues indicating\n   the beginning of transmission of the RS segments.\n\
    \   In the RCV_GP state, if the received green data segment was not\n   marked\
    \ EOB, the LTP receiver returns to the DS_REC state.  Otherwise,\n   it enters\
    \ the WAIT_RP_REC state to receive the red-part of the block\n   fully.\n   A\
    \ previously set RS timer may expire and interrupt the LTP receiver\n   while\
    \ in the DS_REC, RCV_RP, RCV_GP, or WAIT_RP_REC state.  If so,\n   the internal\
    \ procedure Retransmit RS (Section 6.8) is followed as\n   illustrated in the\
    \ states beginning at the RX marker (shown in the\n   second part of the diagram)\
    \ before returning to the interrupted\n   state:\n      - A check is made here\
    \ to see if the retransmission limit set by\n        the network management has\
    \ been exceeded in the number of RSs\n        sent in the session.  If so, a CR\
    \ segment with reason-code RLEXC\n        SHOULD be sent to the LTP sender and\
    \ the sequence indicated by\n        the CX marker is followed.  Otherwise, the\
    \ RS segment is queued\n        for retransmission and the associated RS timer\
    \ is started\n        following the internal procedure Start RS Timer (Section\
    \ 6.3)\n        upon receiving a link state cue indicating the beginning of its\n\
    \        transmission.\n   The LTP receiver may also receive RA segments from\
    \ the sender in\n   response to the RS segments sent while in the DS_REC state.\
    \  If so,\n   then the RS timer corresponding to the report serial number mentioned\n\
    \   in the RA segment is canceled following the internal procedure Stop\n   RS\
    \ Timer (Section 6.14).\n   The LTP receiver stays in the WAIT_RP_REC state until\
    \ the entire red-\n   part of the block is received, and moves to the CLOSED state\
    \ upon\n   full red-part reception.  In this state, a check is made upon\n   reception\
    \ of every red-part data segment to see if it is at a block\n   offset higher\
    \ than any green-part data segment received.  If so, the\n   internal procedure\
    \ Handle Miscolored Segment (Section 6.21) is\n   invoked and the sequence of\
    \ state transitions beginning with the CX\n   marker is followed; a CX segment\
    \ with reason-code MISCOLORED SHOULD\n   be sent to the LTP sender with the Cancellation\
    \ sequence beginning\n   with the CX marker.\n   Note that if there were no red\
    \ data segments received in the session\n   yet, including the case where the\
    \ session was indeed fully green or\n   the pathological case where the entire\
    \ red-part of the block gets\n   lost but at least the green data segment marked\
    \ EOB is received (the\n   LTP receiver has no indication of whether the session\
    \ had a red-part\n   transmission), the LTP receiver assumes the \"RP rcvd. fully\"\
    \n   condition to be true and moves to the CLOSED state from the\n   WAIT_RP_REC\
    \ state.\n   In the WAIT_RP_REC state, the LTP receiver may receive the\n   retransmitted\
    \ red data segments.  Upon receiving red data segments\n   marked CP, it queues\
    \ the responding RS segment for transmission based\n   on either internal procedure\
    \ Retransmit RS (Section 6.8) or Send\n   Reception Report (Section 6.11) depending\
    \ on whether the CP was found\n   to be a retransmission or not, respectively.\
    \  The internal procedure\n   Start RS Timer is invoked upon receiving a link\
    \ state cue indicating\n   the beginning of transmission of the RS segment.  If\
    \ an RA segment is\n   received, the RS timer corresponding to the report segment\
    \ mentioned\n   is canceled and the LTP receiver stays in the state until the\
    \ entire\n   red-part is received.\n   In the sequence of state transitions beginning\
    \ at the CX marker, the\n   CR segment with the given reason-code (depending on\
    \ how the sequence\n   is entered) is queued for transmission, and the CR timer\
    \ is started\n   upon reception of the link state cue indicating actual transmission\n\
    \   following the internal procedure Start Cancel Timer (Section 6.15).\n   If\
    \ the CAR segment is received from the LTP sender, the LTP receiver\n   returns\
    \ to the CLOSED state (via the Cncld marker) following the\n   internal procedure\
    \ Stop Cancel Timer (Section 6.18).  If the CR timer\n   expires asynchronously,\
    \ the internal procedure Retransmit\n   Cancellation Segment (Section 6.16) is\
    \ followed:\n      - A check is made to see if the retransmission limit set by\
    \ the\n        network management for the number of CR segments per session has\n\
    \        been exceeded.  If so, the LTP receiver returns to the CLOSED\n     \
    \   state following the Cncld marker.  Otherwise, a CR segment is\n        scheduled\
    \ for retransmission with the CR timer being started\n        following the internal\
    \ procedure Start Cancel Timer (Section\n        6.15) upon reception of a link\
    \ state cue indicating actual\n        transmission.\n   The LTP receiver might\
    \ also receive a retransmitted CS segment at the\n   CLOSED state (either if the\
    \ CAS segment previously transmitted was\n   lost or if the CS timer expired prematurely\
    \ at the LTP sender).  In\n   such a case, the CAS is scheduled for retransmission.\n"
- title: 9.  Security Considerations
  contents:
  - '9.  Security Considerations

    '
- title: 9.1.  Denial of Service Considerations
  contents:
  - "9.1.  Denial of Service Considerations\n   Implementers SHOULD consider the likelihood\
    \ of the following Denial\n   of Service (DoS) attacks:\n      - A fake Cx could\
    \ be inserted, thus bringing down a session.\n      - Various acknowledgment segments\
    \ (RA, RS, etc.) could be deleted,\n        causing timers to expire, and having\
    \ the potential to disable\n        communication altogether if done with a knowledge\
    \ of the\n        communications schedule.  This could be achieved either by\n\
    \        mounting a DoS attack on a lower-layer service in order to\n        prevent\
    \ it from sending an acknowledgment segment, or by simply\n        jamming the\
    \ transmission (all of which are more likely for\n        terrestrial applications\
    \ of LTP).\n      - An attacker might also corrupt some bits, which is tantamount\
    \ to\n        deleting that segment.\n      - An attacker may flood an LTP engine\
    \ with segments for the\n        internal operations queue and prevent transmission\
    \ of legitimate\n        data segments.\n      - An attacker could attempt to\
    \ fill up the storage in an engine by\n        sending many large messages to\
    \ it.  In terrestrial LTP\n        applications, this may be much more serious\
    \ since spotting the\n        additional traffic may not be possible from any\
    \ network\n        management point.\n   If any of the above DoS attacks is likely,\
    \ then one or more of the\n   following anti-DoS mechanisms ought to be employed:\n\
    \      - Session numbers SHOULD be partly random making it harder to\n       \
    \ insert valid segments.\n      - An engine that suspects that either it or its\
    \ peer is under DoS\n        attack could frequently checkpoint its data segments\
    \ (if it were\n        the sender) or send asynchronous RSs (if it were the receiver),\n\
    \        thus eliciting an earlier response from its peer or timing out\n    \
    \    earlier due to the failure of an attacker to respond.\n      - Serial numbers\
    \ (checkpoint serial numbers, report serial\n        numbers) MUST begin each\
    \ session anew using random numbers\n        rather than from 0.\n      - The\
    \ authentication header [LTPEXT].\n"
- title: 9.2.  Replay Handling
  contents:
  - "9.2.  Replay Handling\n   The following algorithm is given as an example of how\
    \ an LTP\n   implementation MAY handle replays.\n   1. On receipt of an LTP segment,\
    \ check against a cache for replay.\n      If this is a replay segment and if\
    \ a pre-cooked response is\n      available (stored from the last time this segment\
    \ was processed),\n      then send the pre-cooked response.  If there is no pre-cooked\n\
    \      response, then silently drop the inbound segment.  This can all be\n  \
    \    done without attempting to decode the buffer.\n   2. If the inbound segment\
    \ does not decode correctly, then silently\n      drop the segment.  If the segment\
    \ decodes properly, then add its\n      hash to the replay cache and return a\
    \ handle to the entry.\n   3. For those cases where a pre-cooked response should\
    \ be stored,\n      store the response using the handle received from the previous\n\
    \      step.  These cases include:\n      (a) when the inbound packet is a CP\
    \ segment, the RS segment sent\n          in response gets stored as pre-cooked,\n\
    \      (b) when the Incoming packet is an RS segment, the RA segment is\n    \
    \      stored as pre-cooked, and\n      (c) when the incoming packet is a Cx segment,\
    \ the CAx segment sent\n          in response gets stored pre-cooked.\n   4. Occasionally\
    \ clean out the replay cache -- how frequently this\n      happens is an implementation\
    \ issue.\n   The downside of this algorithm is that receiving a totally bogus\n\
    \   segment still results in a replay cache search and attempted LTP\n   decode\
    \ operation.  It is not clear that it is possible to do much\n   better though,\
    \ since all an attacker would have to do to get past the\n   replay cache would\
    \ be to tweak a single bit in the inbound segment\n   each time, which is certainly\
    \ cheaper than the hash+lookup+decode\n   combination, though also certainly more\
    \ expensive than simply sending\n   the same octets many times.\n   The benefit\
    \ of doing this is that implementers no longer need to\n   analyze many bugs/attacks\
    \ based on replaying packets, which in\n   combination with the use of LTP authentication\
    \ should defeat many\n   attempted DoS attacks.\n"
- title: 9.3.  Implementation Considerations
  contents:
  - "9.3.  Implementation Considerations\n   SDNV\n      Implementations SHOULD make\
    \ sanity checks on SDNV length fields\n      and SHOULD check that no SDNV field\
    \ is too long when compared with\n      the overall segment length.\n      Implementations\
    \ SHOULD check that SDNV values are within suitable\n      ranges where possible.\n\
    \   Byte ranges\n      Various report and other segments contain offset and length\n\
    \      fields.  Implementations MUST ensure that these are consistent and\n  \
    \    sane.\n   Randomness\n      Various fields in LTP (e.g., serial numbers)\
    \ MUST be initialized\n      using random values.  Good sources of randomness\
    \ that are not\n      easily guessable SHOULD be used [ESC05].  The collision\
    \ of random\n      values is subject to the birthday paradox, which means that\
    \ a\n      collision is likely after roughly the square root of the space has\n\
    \      been seen (e.g., 2^16 in the case of a 32-bit random value).\n      Implementers\
    \ MUST ensure that they use sufficiently long random\n      values so that the\
    \ birthday paradox doesn't cause a problem in\n      their environment.\n"
- title: 10.  IANA Considerations
  contents:
  - '10.  IANA Considerations

    '
- title: 10.1.  UDP Port Number for LTP
  contents:
  - "10.1.  UDP Port Number for LTP\n   The UDP port number 1113 with the name \"\
    ltp-deepspace\" has been\n   reserved for LTP deployments.  An LTP implementation\
    \ may be\n   implemented to operate over UDP datagrams using this port number\
    \ for\n   study and testing over the Internet.\n"
- title: 10.2.  LTP Extension Tag Registry
  contents:
  - "10.2.  LTP Extension Tag Registry\n   The IANA has created and now maintains\
    \ a registry for known LTP\n   Extension Tags (as indicated in Section 3.1). \
    \ The registry has been\n   populated using the initial values given in Section\
    \ 3.1 above.  IANA\n   may assign LTP Extension Tag values from the range 0x02-0xAF\n\
    \   (inclusive) using the Specification Required rule [GUIDE].  The\n   specification\
    \ concerned can be an RFC (whether Standards Track,\n   Experimental, or Informational),\
    \ or a specification from any other\n   standards development organization recognized\
    \ by IANA or with a\n   liaison with the IESG, specifically including CCSDS\n\
    \   (http://www.ccsds.org/).  Any use of Reserved values (0xB0-0xBF\n   inclusive)\
    \ requires an update this specification.\n"
- title: 11.  Acknowledgments
  contents:
  - "11.  Acknowledgments\n   Many thanks to Tim Ray, Vint Cerf, Bob Durst, Kevin\
    \ Fall, Adrian\n   Hooke, Keith Scott, Leigh Torgerson, Eric Travis, and Howie\
    \ Weiss for\n   their thoughts on this protocol and its role in Delay-Tolerant\n\
    \   Networking architecture.\n   Part of the research described in this document\
    \ was carried out at\n   the Jet Propulsion Laboratory, California Institute of\
    \ Technology,\n   under a contract with the National Aeronautics and Space\n \
    \  Administration.  This work was performed under DOD Contract DAA-B07-\n   00-CC201,\
    \ DARPA AO H912; JPL Task Plan No. 80-5045, DARPA AO H870;\n   and NASA Contract\
    \ NAS7-1407.\n   Thanks are also due to Shawn Ostermann, Hans Kruse, Dovel Myers,\
    \ and\n   Jayram Deshpande at Ohio University for their suggestions and advice\n\
    \   in making various design decisions.  This work was done when\n   Manikantan\
    \ Ramadas was a graduate student at the EECS Dept., Ohio\n   University, in the\
    \ Internetworking Research Group Laboratory.\n   Part of this work was carried\
    \ out at Trinity College Dublin as part\n   of the SeNDT contract funded by Enterprise\
    \ Ireland's research\n   innovation fund.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [B97]    Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n            Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [GUIDE]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n\
    \            IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May\n  \
    \          2008.\n   [LTPMTV] Burleigh, S., Ramadas, M., and S. Farrell,\"Licklider\n\
    \            Transmission Protocol - Motivation\", RFC 5325, September\n     \
    \       2008.\n   [LTPEXT] Farrell, S., Ramadas, M., and S. Burleigh, \"Licklider\n\
    \            Transmission Protocol - Security Extensions\", RFC 5327,\n      \
    \      September 2008.\n"
- title: 12.2. Informative References
  contents:
  - "12.2. Informative References\n   [ASN1]   Abstract Syntax Notation One (ASN.1).\
    \ ASN.1 Encoding Rules:\n            Specification of Basic Encoding Rules (BER),\
    \ Canonical\n            Encoding Rules (CER), and Distinguished Encoding Rules\n\
    \            (DER). ITU-T Rec. X.690 (2002) | ISO/IEC 8825-1:2002.\n   [BP]  \
    \   Scott, K. and S. Burleigh, \"Bundle Protocol Specification\",\n          \
    \  RFC 5050, November 2007.\n   [DTN]    K. Fall, \"A Delay-Tolerant Network Architecture\
    \ for\n            Challenged Internets\", In Proceedings of ACM SIGCOMM 2003,\n\
    \            Karlsruhe, Germany, Aug 2003.\n   [ESC05]  D. Eastlake, J. Schiller\
    \ and S. Crockerr, \"Randomness\n            Recommendations for Security\", RFC\
    \ 4086, June 2005.\n   [SACK]   M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow,\
    \ \"TCP\n            Selective Acknowledgement Options\", RFC 2018, October 1996.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Manikantan Ramadas\n   ISRO Telemetry Tracking and Command\
    \ Network (ISTRAC)\n   Indian Space Research Organization (ISRO)\n   Plot # 12\
    \ & 13, 3rd Main, 2nd Phase\n   Peenya Industrial Area\n   Bangalore 560097\n\
    \   India\n   Telephone: +91 80 2364 2602\n   EMail: mramadas@gmail.com\n   Scott\
    \ C. Burleigh\n   Jet Propulsion Laboratory\n   4800 Oak Grove Drive\n   M/S:\
    \ 301-490\n   Pasadena, CA 91109-8099\n   Telephone: +1 (818) 393-3353\n   Fax:\
    \ +1 (818) 354-1075\n   EMail: Scott.Burleigh@jpl.nasa.gov\n   Stephen Farrell\n\
    \   Computer Science Department\n   Trinity College Dublin\n   Ireland\n   Telephone:\
    \ +353-1-896-1761\n   EMail: stephen.farrell@cs.tcd.ie\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78\
    \ and at http://www.rfc-editor.org/copyright.html,\n   and except as set forth\
    \ therein, the authors retain all their rights.\n   This document and the information\
    \ contained herein are provided on an\n   \"AS IS\" basis and THE CONTRIBUTOR,\
    \ THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED BY (IF ANY), THE INTERNET\
    \ SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING TASK FORCE DISCLAIM\
    \ ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY\
    \ THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY\
    \ IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
