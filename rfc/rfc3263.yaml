- title: __initial_text__
  contents:
  - '        Session Initiation Protocol (SIP): Locating SIP Servers

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Session Initiation Protocol (SIP) uses DNS procedures to allow\
    \ a\n   client to resolve a SIP Uniform Resource Identifier (URI) into the IP\n\
    \   address, port, and transport protocol of the next hop to contact.  It\n  \
    \ also uses DNS to allow a server to send a response to a backup client\n   if\
    \ the primary client has failed.  This document describes those DNS\n   procedures\
    \ in detail.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   13         Authors' Addresses ..................................\
    \   16\n   14         Full Copyright Statement ............................  \
    \ 17\n"
- title: 1 Introduction
  contents:
  - "1 Introduction\n   The Session Initiation Protocol (SIP) (RFC 3261 [1]) is a\
    \ client-\n   server protocol used for the initiation and management of\n   communications\
    \ sessions between users.  SIP end systems are called\n   user agents, and intermediate\
    \ elements are known as proxy servers.  A\n   typical SIP configuration, referred\
    \ to as the SIP \"trapezoid\", is\n   shown in Figure 1.  In this diagram, a caller\
    \ in domain A (UA1)\n   wishes to call Joe in domain B (joe@B).  To do so, it\
    \ communicates\n   with proxy 1 in its domain (domain A).  Proxy 1 forwards the\
    \ request\n   to the proxy for the domain of the called party (domain B), which\
    \ is\n   proxy 2.  Proxy 2 forwards the call to the called party, UA 2.\n   As\
    \ part of this call flow, proxy 1 needs to determine a SIP server\n   for domain\
    \ B.  To do this, proxy 1 makes use of DNS procedures, using\n   both SRV [2]\
    \ and NAPTR [3] records.  This document describes the\n   specific problems that\
    \ SIP uses DNS to help solve, and provides a\n   solution.\n"
- title: 2 Problems DNS is Needed to Solve
  contents:
  - "2 Problems DNS is Needed to Solve\n   DNS is needed to help solve two aspects\
    \ of the general call flow\n   described in the Introduction.  The first is for\
    \ proxy 1 to discover\n   the SIP server in domain B, in order to forward the\
    \ call for joe@B.\n   The second is for proxy 2 to identify a backup for proxy\
    \ 1 in the\n   event it fails after forwarding the request.\n   For the first\
    \ aspect, proxy 1 specifically needs to determine the IP\n   address, port, and\
    \ transport protocol for the server in domain B.\n   The choice of transport protocol\
    \ is particularly noteworthy.  Unlike\n   many other protocols, SIP can run over\
    \ a variety of transport\n   protocols, including TCP, UDP, and SCTP.  SIP can\
    \ also use TLS.\n   Currently, use of TLS is defined for TCP only.  Thus, clients\
    \ need to\n   be able to automatically determine which transport protocols are\n\
    \   available.  The proxy sending the request has a particular set of\n   transport\
    \ protocols it supports and a preference for using those\n   transport protocols.\
    \  Proxy 2 has its own set of transport protocols\n   it supports, and relative\
    \ preferences for those transport protocols.\n   All proxies must implement both\
    \ UDP and TCP, along with TLS over TCP,\n   so that there is always an intersection\
    \ of capabilities.  Some form\n   of DNS procedures are needed for proxy 1 to\
    \ discover the available\n   transport protocols for SIP services at domain B,\
    \ and the relative\n   preferences of those transport protocols.  Proxy 1 intersects\
    \ its\n   list of supported transport protocols with those of proxy 2 and then\n\
    \   chooses the protocol preferred by proxy 2.\n    ............................\
    \          ..............................\n    .                          .  \
    \        .                            .\n    .                +-------+ .    \
    \      . +-------+                  .\n    .                |       | .      \
    \    . |       |                  .\n    .                | Proxy |-------------\
    \ | Proxy |                  .\n    .                |   1   | .          . |\
    \  2    |                  .\n    .                |       | .          . |  \
    \     |                  .\n    .              / +-------+ .          . +-------+\
    \ \\                .\n    .             /            .          .           \
    \ \\               .\n    .            /             .          .            \
    \ \\              .\n    .           /              .          .             \
    \ \\             .\n    .          /               .          .              \
    \ \\            .\n    .         /                .          .               \
    \ \\           .\n    .        /                 .          .                \
    \ \\          .\n    .       /                  .          .                 \
    \ \\         .\n    .   +-------+              .          .                +-------+\
    \   .\n    .   |       |              .          .                |       |  \
    \ .\n    .   |       |              .          .                |       |   .\n\
    \    .   | UA 1  |              .          .                | UA 2  |   .\n  \
    \  .   |       |              .          .                |       |   .\n    .\
    \   +-------+              .          .                +-------+   .\n    .  \
    \            Domain A    .          .   Domain B                 .\n    ............................\
    \          ..............................\n                        Figure 1: The\
    \ SIP trapezoid\n   It is important to note that DNS lookups can be used multiple\
    \ times\n   throughout the processing of a call.  In general, an element that\n\
    \   wishes to send a request (called a client) may need to perform DNS\n   processing\
    \ to determine the IP address, port, and transport protocol\n   of a next hop\
    \ element, called a server (it can be a proxy or a user\n   agent).  Such processing\
    \ could, in principle, occur at every hop\n   between elements.\n   Since SIP\
    \ is used for the establishment of interactive communications\n   services, the\
    \ time it takes to complete a transaction between a\n   caller and called party\
    \ is important.  Typically, the time from when\n   the caller initiates a call\
    \ until the time the called party is\n   alerted should be no more than a few\
    \ seconds.  Given that there can\n   be multiple hops, each of which is doing\
    \ DNS lookups in addition to\n   other potentially time-intensive operations,\
    \ the amount of time\n   available for DNS lookups at each hop is limited.\n \
    \  Scalability and high availability are important in SIP. SIP services\n   scale\
    \ up through clustering techniques.  Typically, in a realistic\n   version of\
    \ the network in Figure 1, proxy 2 would be a cluster of\n   homogeneously configured\
    \ proxies.  DNS needs to provide the ability\n   for domain B to configure a set\
    \ of servers, along with prioritization\n   and weights, in order to provide a\
    \ crude level of capacity-based load\n   balancing.\n   SIP assures high availability\
    \ by having upstream elements detect\n   failures.  For example, assume that proxy\
    \ 2 is implemented as a\n   cluster of two proxies, proxy 2.1 and proxy 2.2. \
    \ If proxy 1 sends a\n   request to proxy 2.1 and the request fails, it retries\
    \ the request by\n   sending it to proxy 2.2.  In many cases, proxy 1 will not\
    \ know which\n   domains it will ultimately communicate with.  That information\
    \ would\n   be known when a user actually makes a call to another user in that\n\
    \   domain.  Proxy 1 may never communicate with that domain again after\n   the\
    \ call completes.  Proxy 1 may communicate with thousands of\n   different domains\
    \ within a few minutes, and proxy 2 could receive\n   requests from thousands\
    \ of different domains within a few minutes.\n   Because of this \"many-to-many\"\
    \ relationship, and the possibly long\n   intervals between communications between\
    \ a pair of domains, it is not\n   generally possible for an element to maintain\
    \ dynamic availability\n   state for the proxies it will communicate with.  When\
    \ a proxy gets\n   its first call with a particular domain, it will try the servers\
    \ in\n   that domain in some order until it finds one that is available.  The\n\
    \   identity of the available server would ideally be cached for some\n   amount\
    \ of time in order to reduce call setup delays of subsequent\n   calls.  The client\
    \ cannot query a failed server continuously to\n   determine when it becomes available\
    \ again, since this does not scale.\n   Furthermore, the availability state must\
    \ eventually be flushed in\n   order to redistribute load to recovered elements\
    \ when they come back\n   online.\n   It is possible for elements to fail in the\
    \ middle of a transaction.\n   For example, after proxy 2 forwards the request\
    \ to UA 2, proxy 1\n   fails.  UA 2 sends its response to proxy 2, which tries\
    \ to forward it\n   to proxy 1, which is no longer available.  The second aspect\
    \ of the\n   flow in the introduction for which DNS is needed, is for proxy 2\
    \ to\n   identify a backup for proxy 1 that it can send the response to.  This\n\
    \   problem is more realistic in SIP than it is in other transactional\n   protocols.\
    \  The reason is that some SIP responses can take a long\n   time to be generated,\
    \ because a human user frequently needs to be\n   consulted in order to generate\
    \ that response.  As such, it is not\n   uncommon for tens of seconds to elapse\
    \ between a call request and its\n   acceptance.\n"
- title: 3 Terminology
  contents:
  - "3 Terminology\n   In this document, the key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\",\n   and \"OPTIONAL\" are to be interpreted as described in RFC 2119\
    \ [4] and\n   indicate requirement levels for compliant SIP implementations.\n"
- title: 4 Client Usage
  contents:
  - "4 Client Usage\n   Usage of DNS differs for clients and for servers.  This section\n\
    \   discusses client usage.  We assume that the client is stateful\n   (either\
    \ a User Agent Client (UAC) or a stateful proxy).  Stateless\n   proxies are discussed\
    \ in Section 4.4.\n   The procedures here are invoked when a client needs to send\
    \ a request\n   to a resource identified by a SIP or SIPS (secure SIP) URI.  This\
    \ URI\n   can identify the desired resource to which the request is targeted\n\
    \   (in which case, the URI is found in the Request-URI), or it can\n   identify\
    \ an intermediate hop towards that resource (in which case,\n   the URI is found\
    \ in the Route header).  The procedures defined here\n   in no way affect this\
    \ URI (i.e., the URI is not rewritten with the\n   result of the DNS lookup),\
    \ they only result in an IP address, port\n   and transport protocol where the\
    \ request can be sent.  RFC 3261 [1]\n   provides guidelines on determining which\
    \ URI needs to be resolved in\n   DNS to determine the host that the request needs\
    \ to be sent to.  In\n   some cases, also documented in [1], the request can be\
    \ sent to a\n   specific intermediate proxy not identified by a SIP URI, but rather,\n\
    \   by a hostname or numeric IP address.  In that case, a temporary URI,\n   used\
    \ for purposes of this specification, is constructed.  That URI is\n   of the\
    \ form sip:<proxy>, where <proxy> is the FQDN or numeric IP\n   address of the\
    \ next-hop proxy.  As a result, in all cases, the\n   problem boils down to resolution\
    \ of a SIP or SIPS URI in DNS to\n   determine the IP address, port, and transport\
    \ of the host to which\n   the request is to be sent.\n   The procedures here\
    \ MUST be done exactly once per transaction, where\n   transaction is as defined\
    \ in [1].  That is, once a SIP server has\n   successfully been contacted (success\
    \ is defined below), all\n   retransmissions of the SIP request and the ACK for\
    \ non-2xx SIP\n   responses to INVITE MUST be sent to the same host.  Furthermore,\
    \ a\n   CANCEL for a particular SIP request MUST be sent to the same SIP\n   server\
    \ that the SIP request was delivered to.\n   Because the ACK request for 2xx responses\
    \ to INVITE constitutes a\n   different transaction, there is no requirement that\
    \ it be delivered\n   to the same server that received the original request (indeed,\
    \ if\n   that server did not record-route, it will not get the ACK).\n   We define\
    \ TARGET as the value of the maddr parameter of the URI, if\n   present, otherwise,\
    \ the host value of the hostport component of the\n   URI.  It identifies the\
    \ domain to be contacted.  A description of the\n   SIP and SIPS URIs and a definition\
    \ of these parameters can be found\n   in [1].\n   We determine the transport\
    \ protocol, port and IP address of a\n   suitable instance of TARGET in Sections\
    \ 4.1 and 4.2.\n"
- title: 4.1 Selecting a Transport Protocol
  contents:
  - "4.1 Selecting a Transport Protocol\n   First, the client selects a transport\
    \ protocol.\n   If the URI specifies a transport protocol in the transport parameter,\n\
    \   that transport protocol SHOULD be used.\n   Otherwise, if no transport protocol\
    \ is specified, but the TARGET is a\n   numeric IP address, the client SHOULD\
    \ use UDP for a SIP URI, and TCP\n   for a SIPS URI.  Similarly, if no transport\
    \ protocol is specified,\n   and the TARGET is not numeric, but an explicit port\
    \ is provided, the\n   client SHOULD use UDP for a SIP URI, and TCP for a SIPS\
    \ URI.  This is\n   because UDP is the only mandatory transport in RFC 2543 [6],\
    \ and thus\n   the only one guaranteed to be interoperable for a SIP URI.  It\
    \ was\n   also specified as the default transport in RFC 2543 when no transport\n\
    \   was present in the SIP URI.  However, another transport, such as TCP,\n  \
    \ MAY be used if the guidelines of SIP mandate it for this particular\n   request.\
    \  That is the case, for example, for requests that exceed the\n   path MTU.\n\
    \   Otherwise, if no transport protocol or port is specified, and the\n   target\
    \ is not a numeric IP address, the client SHOULD perform a NAPTR\n   query for\
    \ the domain in the URI.  The services relevant for the task\n   of transport\
    \ protocol selection are those with NAPTR service fields\n   with values \"SIP+D2X\"\
    \ and \"SIPS+D2X\", where X is a letter that\n   corresponds to a transport protocol\
    \ supported by the domain.  This\n   specification defines D2U for UDP, D2T for\
    \ TCP, and D2S for SCTP.  We\n   also establish an IANA registry for NAPTR service\
    \ name to transport\n   protocol mappings.\n   These NAPTR records provide a mapping\
    \ from a domain to the SRV record\n   for contacting a server with the specific\
    \ transport protocol in the\n   NAPTR services field.  The resource record will\
    \ contain an empty\n   regular expression and a replacement value, which is the\
    \ SRV record\n   for that particular transport protocol.  If the server supports\n\
    \   multiple transport protocols, there will be multiple NAPTR records,\n   each\
    \ with a different service value.  As per RFC 2915 [3], the client\n   discards\
    \ any records whose services fields are not applicable.  For\n   the purposes\
    \ of this specification, several rules are defined.\n   First, a client resolving\
    \ a SIPS URI MUST discard any services that\n   do not contain \"SIPS\" as the\
    \ protocol in the service field.  The\n   converse is not true, however.  A client\
    \ resolving a SIP URI SHOULD\n   retain records with \"SIPS\" as the protocol,\
    \ if the client supports\n   TLS.  Second, a client MUST discard any service fields\
    \ that identify\n   a resolution service whose value is not \"D2X\", for values\
    \ of X that\n   indicate transport protocols supported by the client.  The NAPTR\n\
    \   processing as described in RFC 2915 will result in the discovery of\n   the\
    \ most preferred transport protocol of the server that is supported\n   by the\
    \ client, as well as an SRV record for the server.  It will also\n   allow the\
    \ client to discover if TLS is available and its preference\n   for its usage.\n\
    \   As an example, consider a client that wishes to resolve\n   sip:user@example.com.\
    \  The client performs a NAPTR query for that\n   domain, and the following NAPTR\
    \ records are returned:\n   ;          order pref flags service      regexp  replacement\n\
    \      IN NAPTR 50   50  \"s\"  \"SIPS+D2T\"     \"\"  _sips._tcp.example.com.\n\
    \      IN NAPTR 90   50  \"s\"  \"SIP+D2T\"      \"\"  _sip._tcp.example.com\n\
    \      IN NAPTR 100  50  \"s\"  \"SIP+D2U\"      \"\"  _sip._udp.example.com.\n\
    \   This indicates that the server supports TLS over TCP, TCP, and UDP,\n   in\
    \ that order of preference.  Since the client supports TCP and UDP,\n   TCP will\
    \ be used, targeted to a host determined by an SRV lookup of\n   _sip._tcp.example.com.\
    \  That lookup would return:\n   ;;          Priority Weight Port   Target\n \
    \      IN SRV  0        1      5060   server1.example.com\n       IN SRV  0  \
    \      2      5060   server2.example.com\n   If a SIP proxy, redirect server,\
    \ or registrar is to be contacted\n   through the lookup of NAPTR records, there\
    \ MUST be at least three\n   records - one with a \"SIP+D2T\" service field, one\
    \ with a \"SIP+D2U\"\n   service field, and one with a \"SIPS+D2T\" service field.\
    \  The records\n   with SIPS as the protocol in the service field SHOULD be preferred\n\
    \   (i.e., have a lower value of the order field) above records with SIP\n   as\
    \ the protocol in the service field.  A record with a \"SIPS+D2U\"\n   service\
    \ field SHOULD NOT be placed into the DNS, since it is not\n   possible to use\
    \ TLS over UDP.\n   It is not necessary for the domain suffixes in the NAPTR replacement\n\
    \   field to match the domain of the original query (i.e., example.com\n   above).\
    \  However, for backwards compatibility with RFC 2543, a domain\n   MUST maintain\
    \ SRV records for the domain of the original query, even\n   if the NAPTR record\
    \ is in a different domain.  As an example, even\n   though the SRV record for\
    \ TCP is _sip._tcp.school.edu, there MUST\n   also be an SRV record at _sip._tcp.example.com.\n\
    \      RFC 2543 will look up the SRV records for the domain directly.  If\n  \
    \    these do not exist because the NAPTR replacement points to a\n      different\
    \ domain, the client will fail.\n   For NAPTR records with SIPS protocol fields,\
    \ (if the server is using\n   a site certificate), the domain name in the query\
    \ and the domain name\n   in the replacement field MUST both be valid based on\
    \ the site\n   certificate handed out by the server in the TLS exchange.  Similarly,\n\
    \   the domain name in the SRV query and the domain name in the target in\n  \
    \ the SRV record MUST both be valid based on the same site certificate.\n   Otherwise,\
    \ an attacker could modify the DNS records to contain\n   replacement values in\
    \ a different domain, and the client could not\n   validate that this was the\
    \ desired behavior or the result of an\n   attack.\n   If no NAPTR records are\
    \ found, the client constructs SRV queries for\n   those transport protocols it\
    \ supports, and does a query for each.\n   Queries are done using the service\
    \ identifier \"_sip\" for SIP URIs and\n   \"_sips\" for SIPS URIs.  A particular\
    \ transport is supported if the\n   query is successful.  The client MAY use any\
    \ transport protocol it\n   desires which is supported by the server.\n      This\
    \ is a change from RFC 2543.  It specified that a client would\n      lookup SRV\
    \ records for all transports it supported, and merge the\n      priority values\
    \ across those records.  Then, it would choose the\n      most preferred record.\n\
    \   If no SRV records are found, the client SHOULD use TCP for a SIPS\n   URI,\
    \ and UDP for a SIP URI.  However, another transport protocol,\n   such as TCP,\
    \ MAY be used if the guidelines of SIP mandate it for this\n   particular request.\
    \  That is the case, for example, for requests that\n   exceed the path MTU.\n"
- title: 4.2 Determining Port and IP Address
  contents:
  - "4.2 Determining Port and IP Address\n   Once the transport protocol has been\
    \ determined, the next step is to\n   determine the IP address and port.\n   If\
    \ TARGET is a numeric IP address, the client uses that address.  If\n   the URI\
    \ also contains a port, it uses that port.  If no port is\n   specified, it uses\
    \ the default port for the particular transport\n   protocol.\n   If the TARGET\
    \ was not a numeric IP address, but a port is present in\n   the URI, the client\
    \ performs an A or AAAA record lookup of the domain\n   name.  The result will\
    \ be a list of IP addresses, each of which can\n   be contacted at the specific\
    \ port from the URI and transport protocol\n   determined previously.  The client\
    \ SHOULD try the first record.  If\n   an attempt should fail, based on the definition\
    \ of failure in Section\n   4.3, the next SHOULD be tried, and if that should\
    \ fail, the next\n   SHOULD be tried, and so on.\n      This is a change from\
    \ RFC 2543.  Previously, if the port was\n      explicit, but with a value of\
    \ 5060, SRV records were used.  Now, A\n      or AAAA records will be used.\n\
    \   If the TARGET was not a numeric IP address, and no port was present\n   in\
    \ the URI, the client performs an SRV query on the record returned\n   from the\
    \ NAPTR processing of Section 4.1, if such processing was\n   performed.  If it\
    \ was not, because a transport was specified\n   explicitly, the client performs\
    \ an SRV query for that specific\n   transport, using the service identifier \"\
    _sips\" for SIPS URIs.  For a\n   SIP URI, if the client wishes to use TLS, it\
    \ also uses the service\n   identifier \"_sips\" for that specific transport,\
    \ otherwise, it uses\n   \"_sip\".  If the NAPTR processing was not done because\
    \ no NAPTR\n   records were found, but an SRV query for a supported transport\n\
    \   protocol was successful, those SRV records are selected. Irregardless\n  \
    \ of how the SRV records were determined, the procedures of RFC 2782,\n   as described\
    \ in the section titled \"Usage rules\" are followed,\n   augmented by the additional\
    \ procedures of Section 4.3 of this\n   document.\n   If no SRV records were found,\
    \ the client performs an A or AAAA record\n   lookup of the domain name.  The\
    \ result will be a list of IP\n   addresses, each of which can be contacted using\
    \ the transport\n   protocol determined previously, at the default port for that\n\
    \   transport.  Processing then proceeds as described above for an\n   explicit\
    \ port once the A or AAAA records have been looked up.\n"
- title: 4.3 Details of RFC 2782 Process
  contents:
  - "4.3 Details of RFC 2782 Process\n   RFC 2782 spells out the details of how a\
    \ set of SRV records are\n   sorted and then tried.  However, it only states that\
    \ the client\n   should \"try to connect to the (protocol, address, service)\"\
    \ without\n   giving any details on what happens in the event of failure.  Those\n\
    \   details are described here for SIP.\n   For SIP requests, failure occurs if\
    \ the transaction layer reports a\n   503 error response or a transport failure\
    \ of some sort (generally,\n   due to fatal ICMP errors in UDP or connection failures\
    \ in TCP).\n   Failure also occurs if the transaction layer times out without\
    \ ever\n   having received any response, provisional or final (i.e., timer B or\n\
    \   timer F in RFC 3261 [1] fires).  If a failure occurs, the client\n   SHOULD\
    \ create a new request, which is identical to the previous, but\n   has a different\
    \ value of the Via branch ID than the previous (and\n   therefore constitutes\
    \ a new SIP transaction).  That request is sent\n   to the next element in the\
    \ list as specified by RFC 2782.\n"
- title: 4.4 Consideration for Stateless Proxies
  contents:
  - "4.4 Consideration for Stateless Proxies\n   The process of the previous sections\
    \ is highly stateful.  When a\n   server is contacted successfully, all retransmissions\
    \ of the request\n   for the transaction, as well as ACK for a non-2xx final response,\
    \ and\n   CANCEL requests for that transaction, MUST go to the same server.\n\
    \   The identity of the successfully contacted server is a form of\n   transaction\
    \ state.  This presents a challenge for stateless proxies,\n   which still need\
    \ to meet the requirement for sending all requests in\n   the transaction to the\
    \ same server.\n   The problem is similar, but different, to the problem of HTTP\n\
    \   transactions within a cookie session getting routed to different\n   servers\
    \ based on DNS randomization.  There, such distribution is not\n   a problem.\
    \  Farms of servers generally have common back-end data\n   stores, where the\
    \ session data is stored.  Whenever a server in the\n   farm receives an HTTP\
    \ request, it takes the session identifier, if\n   present, and extracts the needed\
    \ state to process the request.  A\n   request without a session identifier creates\
    \ a new one.  The problem\n   with stateless proxies is at a lower layer; it is\
    \ retransmitted\n   requests within a transaction that are being potentially spread\n\
    \   across servers.  Since none of these retransmissions carries a\n   \"session\
    \ identifier\" (a complete dialog identifier in SIP terms), a\n   new dialog would\
    \ be created identically at each server.  This could,\n   for example result in\
    \ multiple phone calls to be made to the same\n   phone.  Therefore, it is critical\
    \ to prevent such a thing from\n   happening in the first place.\n   The requirement\
    \ is not difficult to meet in the simple case where\n   there were no failures\
    \ when attempting to contact a server.  Whenever\n   the stateless proxy receives\
    \ the request, it performs the appropriate\n   DNS queries as described above.\
    \  However, the procedures of RFC 2782\n   are not guaranteed to be deterministic.\
    \  This is because records that\n   contain the same priority have no specified\
    \ order.  The stateless\n   proxy MUST define a deterministic order to the records\
    \ in that case,\n   using any algorithm at its disposal.  One suggestion is to\n\
    \   alphabetize them, or, more generally, sort them by ASCII-compatible\n   encoding.\
    \  To make processing easier for stateless proxies, it is\n   RECOMMENDED that\
    \ domain administrators make the weights of SRV\n   records with equal priority\
    \ different (for example, using weights of\n   1000 and 1001 if two servers are\
    \ equivalent, rather than assigning\n   both a weight of 1000), and similarly\
    \ for NAPTR records.  If the\n   first server is contacted successfully, the proxy\
    \ can remain\n   stateless.  However, if the first server is not contacted\n \
    \  successfully, and a subsequent server is, the proxy cannot remain\n   stateless\
    \ for this transaction.  If it were stateless, a\n   retransmission could very\
    \ well go to a different server if the failed\n   one recovers between retransmissions.\
    \  As such, whenever a proxy does\n   not successfully contact the first server,\
    \ it SHOULD act as a\n   stateful proxy.\n   Unfortunately, it is still possible\
    \ for a stateless proxy to deliver\n   retransmissions to different servers, even\
    \ if it follows the\n   recommendations above.  This can happen if the DNS TTLs\
    \ expire in the\n   middle of a transaction, and the entries had changed.  This\
    \ is\n   unavoidable.  Network implementors should be aware of this\n   limitation,\
    \ and not use stateless proxies that access DNS if this\n   error is deemed critical.\n"
- title: 5 Server Usage
  contents:
  - "5 Server Usage\n   RFC 3261 [1] defines procedures for sending responses from\
    \ a server\n   back to the client.  Typically, for unicast UDP requests, the\n\
    \   response is sent back to the source IP address where the request came\n  \
    \ from, using the port contained in the Via header.  For reliable\n   transport\
    \ protocols, the response is sent over the connection the\n   request arrived\
    \ on.  However, it is important to provide failover\n   support when the client\
    \ element fails between sending the request and\n   receiving the response.\n\
    \   A server, according to RFC 3261 [1], will send a response on the\n   connection\
    \ it arrived on (in the case of reliable transport\n   protocols), and for unreliable\
    \ transport protocols, to the source\n   address of the request, and the port\
    \ in the Via header field.  The\n   procedures here are invoked when a server\
    \ attempts to send to that\n   location and that response fails (the specific\
    \ conditions are\n   detailed in RFC 3261). \"Fails\" is defined as any closure\
    \ of the\n   transport connection the request came in on before the response can\n\
    \   be sent, or communication of a fatal error from the transport layer.\n   In\
    \ these cases, the server examines the value of the sent-by\n   construction in\
    \ the topmost Via header.  If it contains a numeric IP\n   address, the server\
    \ attempts to send the response to that address,\n   using the transport protocol\
    \ from the Via header, and the port from\n   sent-by, if present, else the default\
    \ for that transport protocol.\n   The transport protocol in the Via header can\
    \ indicate \"TLS\", which\n   refers to TLS over TCP.  When this value is present,\
    \ the server MUST\n   use TLS over TCP to send the response.\n   If, however,\
    \ the sent-by field contained a domain name and a port\n   number, the server\
    \ queries for A or AAAA records with that name.  It\n   tries to send the response\
    \ to each element on the resulting list of\n   IP addresses, using the port from\
    \ the Via, and the transport protocol\n   from the Via (again, a value of TLS\
    \ refers to TLS over TCP).  As in\n   the client processing, the next entry in\
    \ the list is tried if the one\n   before it results in a failure.\n   If, however,\
    \ the sent-by field contained a domain name and no port,\n   the server queries\
    \ for SRV records at that domain name using the\n   service identifier \"_sips\"\
    \ if the Via transport is \"TLS\", \"_sip\"\n   otherwise, and the transport from\
    \ the topmost Via header (\"TLS\"\n   implies that the transport protocol in the\
    \ SRV query is TCP).  The\n   resulting list is sorted as described in [2], and\
    \ the response is\n   sent to the topmost element on the new list described there.\
    \  If that\n   results in a failure, the next entry on the list is tried.\n"
- title: 6 Constructing SIP URIs
  contents:
  - "6 Constructing SIP URIs\n   In many cases, an element needs to construct a SIP\
    \ URI for inclusion\n   in a Contact header in a REGISTER, or in a Record-Route\
    \ header in an\n   INVITE.  According to RFC 3261 [1], these URIs have to have\
    \ the\n   property that they resolve to the specific element that inserted\n \
    \  them.  However, if they are constructed with just an IP address, for\n   example:\n\
    \   sip:1.2.3.4\n   then should the element fail, there is no way to route the\
    \ request or\n   response through a backup.\n   SRV provides a way to fix this.\
    \  Instead of using an IP address, a\n   domain name that resolves to an SRV record\
    \ can be used:\n   sip:server23.provider.com\n   The SRV records for a particular\
    \ target can be set up so that there\n   is a single record with a low value for\
    \ the priority field\n   (indicating the preferred choice), and this record points\
    \ to the\n   specific element that constructed the URI.  However, there are\n\
    \   additional records with higher values of the priority field that\n   point\
    \ to backup elements that would be used in the event of failure.\n   This allows\
    \ the constraint of RFC 3261 [1] to be met while allowing\n   for robust operation.\n"
- title: 7 Security Considerations
  contents:
  - "7 Security Considerations\n   DNS NAPTR records are used to allow a client to\
    \ discover that the\n   server supports TLS.  An attacker could potentially modify\
    \ these\n   records, resulting in a client using a non-secure transport when TLS\n\
    \   is in fact available and preferred.\n   This is partially mitigated by the\
    \ presence of the sips URI scheme,\n   which is always sent only over TLS.  An\
    \ attacker cannot force a bid\n   down through deletion or modification of DNS\
    \ records.  In the worst\n   case, they can prevent communication from occurring\
    \ by deleting all\n   records.  A sips URI itself is generally exchanged within\
    \ a secure\n   context, frequently on a business card or secure web page, or within\n\
    \   a SIP message which has already been secured with TLS.  See RFC 3261\n   [1]\
    \ for details.  The sips URI is therefore preferred when security\n   is truly\
    \ needed, but we allow TLS to be used for requests resolved by\n   a SIP URI to\
    \ allow security that is better than no TLS at all.\n   The bid down attack can\
    \ also be mitigated through caching.  A client\n   which frequently contacts the\
    \ same domain SHOULD cache whether or not\n   its NAPTR records contain SIPS in\
    \ the services field.  If such\n   records were present, but in later queries\
    \ cease to appear, it is a\n   sign of a potential attack.  In this case, the\
    \ client SHOULD generate\n   some kind of alert or alarm, and MAY reject the request.\n\
    \   An additional problem is that proxies, which are intermediaries\n   between\
    \ the users of the system, are frequently the clients that\n   perform the NAPTR\
    \ queries.  It is therefore possible for a proxy to\n   ignore SIPS entries even\
    \ though they are present, resulting in\n   downgraded security.  There is very\
    \ little that can be done to\n   prevent such attacks.  Clients are simply dependent\
    \ on proxy servers\n   for call completion, and must trust that they implement\
    \ the protocol\n   properly in order for security to be provided.  Falsifying\
    \ DNS\n   records can be done by tampering with wire traffic (in the absence of\n\
    \   DNSSEC), whereas compromising and commandeering a proxy server\n   requires\
    \ a break-in, and is seen as the considerably less likely\n   downgrade threat.\n"
- title: 8 The Transport Determination Application
  contents:
  - "8 The Transport Determination Application\n   This section more formally defines\
    \ the NAPTR usage of this\n   specification, using the Dynamic Delegation Discovery\
    \ System (DDDS)\n   framework as a guide [7].  DDDS represents the evolution of\
    \ the NAPTR\n   resource record.  DDDS defines applications, which can make use\
    \ of\n   the NAPTR record for specific resolution services.  This application\n\
    \   is called the Transport Determination Application, and its goal is to\n  \
    \ map an incoming SIP or SIPS URI to a set of SRV records for the\n   various\
    \ servers that can handle the URI.\n   The following is the information that DDDS\
    \ requests an application to\n   provide:\n      Application Unique String: The\
    \ Application Unique String (AUS) is\n         the input to the resolution service.\
    \  For this application, it\n         is the URI to resolve.\n      First Well\
    \ Known Rule: The first well known rule extracts a key\n         from the AUS.\
    \  For this application, the first well known rule\n         extracts the host\
    \ portion of the SIP or SIPS URI.\n      Valid Databases: The key resulting from\
    \ the first well known rule\n         is looked up in a single database, the DNS\
    \ [8].\n      Expected Output: The result of the application is an SRV record\n\
    \         for the server to contact.\n"
- title: 9 IANA Considerations
  contents:
  - "9 IANA Considerations\n   The usage of NAPTR records described here requires\
    \ well known values\n   for the service fields for each transport supported by\
    \ SIP.  The\n   table of mappings from service field values to transport protocols\
    \ is\n   to be maintained by IANA.  New entries in the table MAY be added\n  \
    \ through the publication of standards track RFCs, as described in RFC\n   2434\
    \ [5].\n   The registration in the RFC MUST include the following information:\n\
    \      Service Field: The service field being registered.  An example for\n  \
    \       a new fictitious transport protocol called NCTP might be\n         \"\
    SIP+D2N\".\n      Protocol: The specific transport protocol associated with that\n\
    \         service field.  This MUST include the name and acronym for the\n   \
    \      protocol, along with reference to a document that describes the\n     \
    \    transport protocol.  For example - \"New Connectionless\n         Transport\
    \ Protocol (NCTP), RFC 5766\".\n      Name and Contact Information: The name,\
    \ address, email address and\n         telephone number for the person performing\
    \ the registration.\n   The following values have been placed into the registry:\n\
    \   Services Field               Protocol\n   SIP+D2T                       TCP\n\
    \   SIPS+D2T                      TCP\n   SIP+D2U                       UDP\n\
    \   SIP+D2S                       SCTP (RFC 2960)\n"
- title: 10 Acknowledgements
  contents:
  - "10 Acknowledgements\n   The authors would like to thank Randy Bush, Leslie Daigle,\
    \ Patrik\n   Faltstrom, Jo Hornsby, Rohan Mahy, Allison Mankin, Michael Mealling,\n\
    \   Thomas Narten, and Jon Peterson for their useful comments.\n"
- title: 11 Normative References
  contents:
  - "11 Normative References\n   [1]   Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G., Johnston, A.,\n         Peterson, J., Sparks, R., Handley, M. and E. Schooler,\
    \ \"SIP:\n         Session Initiation Protocol\", RFC 3261, June 2002.\n   [2]\
    \   Gulbrandsen, A., Vixie, P. and L. Esibov, \"A DNS RR for\n         Specifying\
    \ the Location of Services (DNS SRV)\", RFC 2782,\n         February 2000.\n \
    \  [3]   Mealling, M. and R. Daniel, \"The Naming Authority Pointer\n        \
    \ (NAPTR) DNS Resource Record\", RFC 2915, September 2000.\n   [4]   Bradner,\
    \ S., \"Key Words for Use in RFCs to Indicate Requirement\n         Levels\",\
    \ BCP 14, RFC 2119, March 1997.\n   [5]   Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an IANA\n         Considerations Section in RFCs\", BCP 26, RFC\
    \ 2434, October\n         1998.\n"
- title: 12 Informative References
  contents:
  - "12 Informative References\n   [6]   Handley, M., Schulzrinne, H., Schooler, E.\
    \ and J. Rosenberg,\n         \"SIP: Session Initiation Protocol\", RFC 2543,\
    \ March 1999.\n   [7]   Mealling, M., \"Dynamic Delegation Discovery System (DDDS)\
    \ Part\n         One: The Comprehensive DDDS Standard\", Work in Progress.\n \
    \  [8]   Mealling, M., \"Dynamic Delegation Discovery System (DDDS) Part\n   \
    \      Three: The DNS Database\", Work in Progress.\n"
- title: 13 Authors' Addresses
  contents:
  - "13 Authors' Addresses\n   Jonathan Rosenberg\n   dynamicsoft\n   72 Eagle Rock\
    \ Avenue\n   First Floor\n   East Hanover, NJ 07936\n   EMail: jdrosen@dynamicsoft.com\n\
    \   Henning Schulzrinne\n   Columbia University\n   M/S 0401\n   1214 Amsterdam\
    \ Ave.\n   New York, NY 10027-7003\n   EMail: schulzrinne@cs.columbia.edu\n"
- title: 14  Full Copyright Statement
  contents:
  - "14  Full Copyright Statement\n   Copyright (C) The Internet Society (2002). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
