- contents:
  - '                  The YANG 1.1 Data Modeling Language

    '
  title: __initial_text__
- contents:
  - "Abstract\n   YANG is a data modeling language used to model configuration data,\n
    \  state data, Remote Procedure Calls, and notifications for network\n   management
    protocols.  This document describes the syntax and\n   semantics of version 1.1
    of the YANG language.  YANG version 1.1 is a\n   maintenance release of the YANG
    language, addressing ambiguities and\n   defects in the original specification.
    \ There are a small number of\n   backward incompatibilities from YANG version
    1.  This document also\n   specifies the YANG mappings to the Network Configuration
    Protocol\n   (NETCONF).\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7950.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................9\n
    \     1.1. Summary of Changes from RFC 6020 ..........................10\n   2.
    Key Words ......................................................12\n   3. Terminology
    ....................................................12\n      3.1. A Note on Examples
    ........................................16\n   4. YANG Overview ..................................................16\n
    \     4.1. Functional Overview .......................................16\n      4.2.
    Language Overview .........................................18\n           4.2.1.
    Modules and Submodules .............................18\n           4.2.2. Data
    Modeling Basics ...............................19\n           4.2.3. Configuration
    and State Data .......................23\n           4.2.4. Built-In Types .....................................24\n
    \          4.2.5. Derived Types (typedef) ............................25\n           4.2.6.
    Reusable Node Groups (grouping) ....................25\n           4.2.7. Choices
    ............................................27\n           4.2.8. Extending Data
    Models (augment) ....................28\n           4.2.9. Operation Definitions
    ..............................29\n           4.2.10. Notification Definitions
    ..........................31\n   5. Language Concepts ..............................................32\n
    \     5.1. Modules and Submodules ....................................32\n           5.1.1.
    Import and Include by Revision .....................33\n           5.1.2. Module
    Hierarchies .................................34\n      5.2. File Layout ...............................................36\n
    \     5.3. XML Namespaces ............................................36\n           5.3.1.
    YANG XML Namespace .................................36\n      5.4. Resolving Grouping,
    Type, and Identity Names ..............37\n      5.5. Nested Typedefs and Groupings
    .............................37\n      5.6. Conformance ...............................................38\n
    \          5.6.1. Basic Behavior .....................................38\n           5.6.2.
    Optional Features ..................................38\n           5.6.3. Deviations
    .........................................39\n           5.6.4. Announcing Conformance
    Information in NETCONF ......40\n           5.6.5. Implementing a Module ..............................40\n
    \     5.7. Datastore Modification ....................................44\n   6.
    YANG Syntax ....................................................44\n      6.1.
    Lexical Tokenization ......................................45\n           6.1.1.
    Comments ...........................................45\n           6.1.2. Tokens
    .............................................45\n           6.1.3. Quoting ............................................45\n
    \     6.2. Identifiers ...............................................47\n           6.2.1.
    Identifiers and Their Namespaces ...................47\n      6.3. Statements
    ................................................48\n           6.3.1. Language
    Extensions ................................48\n      6.4. XPath Evaluations .........................................49\n
    \          6.4.1. XPath Context ......................................50\n      6.5.
    Schema Node Identifier ....................................54\n   7. YANG Statements
    ................................................55\n      7.1. The \"module\"
    Statement ....................................55\n           7.1.1. The module's
    Substatements .........................56\n           7.1.2. The \"yang-version\"
    Statement .......................57\n           7.1.3. The \"namespace\" Statement
    ..........................57\n           7.1.4. The \"prefix\" Statement .............................57\n
    \          7.1.5. The \"import\" Statement .............................58\n           7.1.6.
    The \"include\" Statement ............................59\n           7.1.7. The
    \"organization\" Statement .......................60\n           7.1.8. The \"contact\"
    Statement ............................60\n           7.1.9. The \"revision\" Statement
    ...........................60\n           7.1.10. Usage Example .....................................61\n
    \     7.2. The \"submodule\" Statement .................................62\n           7.2.1.
    The submodule's Substatements ......................63\n           7.2.2. The
    \"belongs-to\" Statement .........................63\n           7.2.3. Usage
    Example ......................................64\n      7.3. The \"typedef\" Statement
    ...................................65\n           7.3.1. The typedef's Substatements
    ........................65\n           7.3.2. The typedef's \"type\" Statement
    .....................65\n           7.3.3. The \"units\" Statement ..............................65\n
    \          7.3.4. The typedef's \"default\" Statement ..................66\n           7.3.5.
    Usage Example ......................................66\n      7.4. The \"type\"
    Statement ......................................66\n           7.4.1. The type's
    Substatements ...........................67\n      7.5. The \"container\" Statement
    .................................67\n           7.5.1. Containers with Presence
    ...........................67\n           7.5.2. The container's Substatements
    ......................68\n           7.5.3. The \"must\" Statement ...............................69\n
    \          7.5.4. The must's Substatements ...........................70\n           7.5.5.
    The \"presence\" Statement ...........................71\n           7.5.6. The
    container's Child Node Statements ..............71\n           7.5.7. XML Encoding
    Rules .................................71\n           7.5.8. NETCONF <edit-config>
    Operations ...................72\n           7.5.9. Usage Example ......................................72\n
    \     7.6. The \"leaf\" Statement ......................................73\n           7.6.1.
    The leaf's Default Value ...........................74\n           7.6.2. The
    leaf's Substatements ...........................75\n           7.6.3. The leaf's
    \"type\" Statement ........................75\n           7.6.4. The leaf's \"default\"
    Statement .....................75\n           7.6.5. The leaf's \"mandatory\"
    Statement ...................76\n           7.6.6. XML Encoding Rules .................................76\n
    \          7.6.7. NETCONF <edit-config> Operations ...................76\n           7.6.8.
    Usage Example ......................................77\n      7.7. The \"leaf-list\"
    Statement .................................77\n           7.7.1. Ordering ...........................................78\n
    \          7.7.2. The leaf-list's Default Values .....................79\n           7.7.3.
    The leaf-list's Substatements ......................80\n           7.7.4. The
    leaf-list's \"default\" Statement ................80\n           7.7.5. The \"min-elements\"
    Statement .......................80\n           7.7.6. The \"max-elements\" Statement
    .......................81\n           7.7.7. The \"ordered-by\" Statement .........................81\n
    \          7.7.8. XML Encoding Rules .................................82\n           7.7.9.
    NETCONF <edit-config> Operations ...................82\n           7.7.10. Usage
    Example .....................................83\n      7.8. The \"list\" Statement
    ......................................84\n           7.8.1. The list's Substatements
    ...........................85\n           7.8.2. The list's \"key\" Statement
    .........................85\n           7.8.3. The list's \"unique\" Statement
    ......................86\n           7.8.4. The list's Child Node Statements ...................87\n
    \          7.8.5. XML Encoding Rules .................................88\n           7.8.6.
    NETCONF <edit-config> Operations ...................88\n           7.8.7. Usage
    Example ......................................90\n      7.9. The \"choice\" Statement
    ....................................93\n           7.9.1. The choice's Substatements
    .........................94\n           7.9.2. The choice's \"case\" Statement
    ......................94\n           7.9.3. The choice's \"default\" Statement
    ...................96\n           7.9.4. The choice's \"mandatory\" Statement
    .................98\n           7.9.5. XML Encoding Rules .................................98\n
    \          7.9.6. Usage Example ......................................99\n      7.10.
    The \"anydata\" Statement .................................100\n           7.10.1.
    The anydata's Substatements ......................100\n           7.10.2. XML
    Encoding Rules ...............................101\n           7.10.3. NETCONF
    <edit-config> Operations .................101\n           7.10.4. Usage Example
    ....................................101\n      7.11. The \"anyxml\" Statement
    ..................................102\n           7.11.1. The anyxml's Substatements
    .......................103\n           7.11.2. XML Encoding Rules ...............................103\n
    \          7.11.3. NETCONF <edit-config> Operations .................103\n           7.11.4.
    Usage Example ....................................104\n      7.12. The \"grouping\"
    Statement ................................104\n           7.12.1. The grouping's
    Substatements .....................105\n           7.12.2. Usage Example ....................................105\n
    \     7.13. The \"uses\" Statement ....................................106\n           7.13.1.
    The uses's Substatements .........................106\n           7.13.2. The
    \"refine\" Statement ...........................106\n           7.13.3. XML Encoding
    Rules ...............................107\n           7.13.4. Usage Example ....................................107\n
    \     7.14. The \"rpc\" Statement .....................................108\n           7.14.1.
    The rpc's Substatements ..........................109\n           7.14.2. The
    \"input\" Statement ............................109\n           7.14.3. The \"output\"
    Statement ...........................110\n           7.14.4. NETCONF XML Encoding
    Rules .......................111\n           7.14.5. Usage Example ....................................112\n
    \     7.15. The \"action\" Statement ..................................113\n           7.15.1.
    The action's Substatements .......................114\n           7.15.2. NETCONF
    XML Encoding Rules .......................114\n           7.15.3. Usage Example
    ....................................115\n      7.16. The \"notification\" Statement
    ............................116\n           7.16.1. The notification's Substatements
    .................117\n           7.16.2. NETCONF XML Encoding Rules .......................117\n
    \          7.16.3. Usage Example ....................................118\n      7.17.
    The \"augment\" Statement .................................119\n           7.17.1.
    The augment's Substatements ......................121\n           7.17.2. XML
    Encoding Rules ...............................121\n           7.17.3. Usage Example
    ....................................122\n      7.18. The \"identity\" Statement
    ................................124\n           7.18.1. The identity's Substatements
    .....................124\n           7.18.2. The \"base\" Statement .............................124\n
    \          7.18.3. Usage Example ....................................125\n      7.19.
    The \"extension\" Statement ...............................126\n           7.19.1.
    The extension's Substatements ....................126\n           7.19.2. The
    \"argument\" Statement .........................127\n           7.19.3. Usage
    Example ....................................127\n      7.20. Conformance-Related
    Statements ..........................128\n           7.20.1. The \"feature\" Statement
    ..........................128\n           7.20.2. The \"if-feature\" Statement
    .......................130\n           7.20.3. The \"deviation\" Statement ........................131\n
    \     7.21. Common Statements .......................................134\n           7.21.1.
    The \"config\" Statement ...........................134\n           7.21.2. The
    \"status\" Statement ...........................135\n           7.21.3. The \"description\"
    Statement ......................136\n           7.21.4. The \"reference\" Statement
    ........................136\n           7.21.5. The \"when\" Statement .............................136\n
    \  8. Constraints ...................................................138\n      8.1.
    Constraints on Data ......................................138\n      8.2. Configuration
    Data Modifications .........................139\n      8.3. NETCONF Constraint
    Enforcement Model .....................139\n           8.3.1. Payload Parsing
    ...................................139\n           8.3.2. NETCONF <edit-config>
    Processing ..................140\n           8.3.3. Validation ........................................141\n
    \  9. Built-In Types ................................................141\n      9.1.
    Canonical Representation .................................141\n      9.2. The
    Integer Built-In Types ...............................142\n           9.2.1. Lexical
    Representation ............................142\n           9.2.2. Canonical Form
    ....................................143\n           9.2.3. Restrictions ......................................143\n
    \          9.2.4. The \"range\" Statement .............................143\n           9.2.5.
    Usage Example .....................................144\n      9.3. The decimal64
    Built-In Type ..............................144\n           9.3.1. Lexical Representation
    ............................145\n           9.3.2. Canonical Form ....................................145\n
    \          9.3.3. Restrictions ......................................145\n           9.3.4.
    The \"fraction-digits\" Statement ...................145\n           9.3.5. Usage
    Example .....................................146\n      9.4. The string Built-In
    Type .................................146\n           9.4.1. Lexical Representation
    ............................146\n           9.4.2. Canonical Form ....................................147\n
    \          9.4.3. Restrictions ......................................147\n           9.4.4.
    The \"length\" Statement ............................147\n           9.4.5. The
    \"pattern\" Statement ...........................148\n           9.4.6. The \"modifier\"
    Statement ..........................148\n           9.4.7. Usage Example .....................................149\n
    \     9.5. The boolean Built-In Type ................................150\n           9.5.1.
    Lexical Representation ............................150\n           9.5.2. Canonical
    Form ....................................150\n           9.5.3. Restrictions ......................................150\n
    \     9.6. The enumeration Built-In Type ............................150\n           9.6.1.
    Lexical Representation ............................150\n           9.6.2. Canonical
    Form ....................................151\n           9.6.3. Restrictions ......................................151\n
    \          9.6.4. The \"enum\" Statement ..............................151\n           9.6.5.
    Usage Example .....................................152\n      9.7. The bits Built-In
    Type ...................................154\n           9.7.1. Restrictions ......................................154\n
    \          9.7.2. Lexical Representation ............................154\n           9.7.3.
    Canonical Form ....................................154\n           9.7.4. The
    \"bit\" Statement ...............................155\n           9.7.5. Usage
    Example .....................................156\n      9.8. The binary Built-In
    Type .................................157\n           9.8.1. Restrictions ......................................157\n
    \          9.8.2. Lexical Representation ............................157\n           9.8.3.
    Canonical Form ....................................157\n      9.9. The leafref
    Built-In Type ................................157\n           9.9.1. Restrictions
    ......................................158\n           9.9.2. The \"path\" Statement
    ..............................158\n           9.9.3. The \"require-instance\"
    Statement ..................159\n           9.9.4. Lexical Representation ............................159\n
    \          9.9.5. Canonical Form ....................................159\n           9.9.6.
    Usage Example .....................................159\n      9.10. The identityref
    Built-In Type ...........................163\n           9.10.1. Restrictions
    .....................................163\n           9.10.2. The identityref's
    \"base\" Statement ...............163\n           9.10.3. Lexical Representation
    ...........................163\n           9.10.4. Canonical Form ...................................164\n
    \          9.10.5. Usage Example ....................................164\n      9.11.
    The empty Built-In Type .................................165\n           9.11.1.
    Restrictions .....................................165\n           9.11.2. Lexical
    Representation ...........................165\n           9.11.3. Canonical Form
    ...................................165\n           9.11.4. Usage Example ....................................166\n
    \     9.12. The union Built-In Type .................................166\n           9.12.1.
    Restrictions .....................................166\n           9.12.2. Lexical
    Representation ...........................166\n           9.12.3. Canonical Form
    ...................................167\n           9.12.4. Usage Example ....................................167\n
    \     9.13. The instance-identifier Built-In Type ...................168\n           9.13.1.
    Restrictions .....................................168\n           9.13.2. Lexical
    Representation ...........................169\n           9.13.3. Canonical Form
    ...................................169\n           9.13.4. Usage Example ....................................169\n
    \  10. XPath Functions ..............................................170\n      10.1.
    Function for Node Sets ..................................170\n           10.1.1.
    current() ........................................170\n      10.2. Function for
    Strings ....................................170\n           10.2.1. re-match()
    .......................................170\n      10.3. Function for the YANG
    Types \"leafref\" and\n            \"instance-identifier\" ...................................171\n
    \          10.3.1. deref() ..........................................171\n      10.4.
    Functions for the YANG Type \"identityref\" ...............172\n           10.4.1.
    derived-from() ...................................172\n           10.4.2. derived-from-or-self()
    ...........................174\n      10.5. Function for the YANG Type \"enumeration\"
    ................174\n           10.5.1. enum-value() .....................................174\n
    \     10.6. Function for the YANG Type \"bits\" .......................175\n           10.6.1.
    bit-is-set() .....................................175\n   11. Updating a Module
    ............................................176\n   12. Coexistence with YANG
    Version 1 ..............................179\n   13. YIN ..........................................................179\n
    \     13.1. Formal YIN Definition ...................................180\n           13.1.1.
    Usage Example ....................................182\n   14. YANG ABNF Grammar
    ............................................184\n   15. NETCONF Error Responses
    for YANG-Related Errors ..............211\n      15.1. Error Message for Data
    That Violates a \"unique\"\n            Statement ...............................................211\n
    \     15.2. Error Message for Data That Violates a\n            \"max-elements\"
    Statement ................................211\n      15.3. Error Message for Data
    That Violates a\n            \"min-elements\" Statement ................................211\n
    \     15.4. Error Message for Data That Violates a \"must\"\n            Statement
    ...............................................212\n      15.5. Error Message
    for Data That Violates a\n            \"require-instance\" Statement ............................212\n
    \     15.6. Error Message for Data That Violates a Mandatory\n            \"choice\"
    Statement ......................................212\n      15.7. Error Message
    for the \"insert\" Operation ................212\n   16. IANA Considerations ..........................................213\n
    \  17. Security Considerations ......................................213\n   18.
    References ...................................................214\n      18.1.
    Normative References ....................................214\n      18.2. Informative
    References ..................................215\n   Acknowledgements .................................................217\n
    \  Contributors .....................................................217\n   Author's
    Address .................................................217\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   YANG is a data modeling language originally designed to
    model\n   configuration and state data manipulated by the Network Configuration\n
    \  Protocol (NETCONF), NETCONF Remote Procedure Calls, and NETCONF\n   notifications
    [RFC6241].  Since the publication of YANG version 1\n   [RFC6020], YANG has been
    used or proposed to be used for other\n   protocols (e.g., RESTCONF [RESTCONF]
    and the Constrained Application\n   Protocol (CoAP) Management Interface (CoMI)
    [CoMI]).  Further,\n   encodings other than XML have been proposed (e.g., JSON
    [RFC7951]).\n   This document describes the syntax and semantics of version 1.1
    of\n   the YANG language.  It also describes how a data model defined in a\n   YANG
    module is encoded in the Extensible Markup Language (XML) [XML]\n   and how NETCONF
    operations are used to manipulate the data.  Other\n   protocols and encodings
    are possible but are out of scope for this\n   specification.\n   In terms of
    developing YANG data models, [YANG-Guidelines] provides\n   some guidelines and
    recommendations.\n   Note that this document does not obsolete RFC 6020 [RFC6020].\n"
  - contents:
    - "1.1.  Summary of Changes from RFC 6020\n   This document defines version 1.1
      of the YANG language.  YANG\n   version 1.1 is a maintenance release of the
      YANG language, addressing\n   ambiguities and defects in the original specification
      [RFC6020].\n   The following changes are not backward compatible with YANG\n
      \  version 1:\n   o  Changed the rules for the interpretation of escaped characters
      in\n      double-quoted strings.  This is a backward-incompatible change\n      from
      YANG version 1.  When updating a YANG version 1 module to 1.1\n      and the
      module uses a character sequence that is now illegal, the\n      string must
      be changed to match the new rules.  See Section 6.1.3\n      for details.\n
      \  o  An unquoted string cannot contain any single or double quote\n      characters.
      \ This is a backward-incompatible change from YANG\n      version 1.  When updating
      a YANG version 1 module to 1.1 and the\n      module uses such quote characters,
      the string must be changed to\n      match the new rules.  See Section 6.1.3
      for details.\n   o  Made \"when\" and \"if-feature\" illegal on list keys.  This
      is a\n      backward-incompatible change from YANG version 1.  When updating
      a\n      YANG version 1 module to 1.1 and the module uses these constructs,\n
      \     they must be removed to match the new rules.\n   o  Defined the legal
      characters in YANG modules.  When updating a\n      YANG version 1 module to
      1.1, any characters that are now illegal\n      must be removed.  See Section
      6 for details.\n   o  Made noncharacters illegal in the built-in type \"string\".
      \ This\n      change affects the runtime behavior of YANG-based protocols.\n
      \  The following additional changes have been done to YANG:\n   o  Changed the
      YANG version from \"1\" to \"1.1\".\n   o  Made the \"yang-version\" statement
      mandatory in YANG version \"1.1\".\n   o  Extended the \"if-feature\" syntax
      to be a boolean expression over\n      feature names.\n   o  Allow \"if-feature\"
      in \"bit\", \"enum\", and \"identity\".\n   o  Allow \"if-feature\" in \"refine\".\n
      \  o  Allow \"choice\" as a shorthand \"case\" statement (see\n      Section
      7.9.2).\n   o  Added a new substatement \"modifier\" to the \"pattern\" statement\n
      \     (see Section 9.4.6).\n   o  Allow \"must\" in \"input\", \"output\", and
      \"notification\".\n   o  Allow \"require-instance\" in leafref.\n   o  Allow
      \"description\" and \"reference\" in \"import\" and \"include\".\n   o  Allow
      imports of multiple revisions of a module.\n   o  Allow \"augment\" to add conditionally
      mandatory nodes (see\n      Section 7.17).\n   o  Added a set of new XML Path
      Language (XPath) functions in\n      Section 10.\n   o  Clarified the XPath
      context's tree in Section 6.4.1.\n   o  Defined the string value of an identityref
      in XPath expressions\n      (see Section 9.10).\n   o  Clarified what unprefixed
      names mean in leafrefs in typedefs (see\n      Sections 6.4.1 and 9.9.2).\n
      \  o  Allow identities to be derived from multiple base identities (see\n      Sections
      7.18 and 9.10).\n   o  Allow enumerations and bits to be subtyped (see Sections
      9.6\n      and 9.7).\n   o  Allow leaf-lists to have default values (see Section
      7.7.2).\n   o  Allow non-unique values in non-configuration leaf-lists (see\n
      \     Section 7.7).\n   o  Use syntax for case-sensitive strings (as per [RFC7405])
      in the\n      grammar.\n   o  Changed the module advertisement mechanism (see
      Section 5.6.4).\n   o  Changed the scoping rules for definitions in submodules.
      \ A\n      submodule can now reference all definitions in all submodules that\n
      \     belong to the same module, without using the \"include\" statement.\n
      \  o  Added a new statement \"action\", which is used to define operations\n
      \     tied to data nodes.\n   o  Allow notifications to be tied to data nodes.\n
      \  o  Added a new data definition statement \"anydata\" (see\n      Section
      7.10), which is RECOMMENDED to be used instead of \"anyxml\"\n      when the
      data can be modeled in YANG.\n   o  Allow types \"empty\" and \"leafref\" in
      unions.\n   o  Allow type \"empty\" in a key.\n   o  Removed the restriction
      that identifiers could not start with the\n      characters \"xml\".\n   The
      following changes have been done to the NETCONF mapping:\n   o  A server advertises
      support for YANG 1.1 modules by using\n      ietf-yang-library [RFC7895] instead
      of listing them as\n      capabilities in the <hello> message.\n"
    title: 1.1.  Summary of Changes from RFC 6020
  title: 1.  Introduction
- contents:
  - "2.  Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119].\n"
  title: 2.  Key Words
- contents:
  - "3.  Terminology\n   The following terms are used within this document:\n   o
    \ action: An operation defined for a node in the data tree.\n   o  anydata: A
    data node that can contain an unknown set of nodes that\n      can be modeled
    by YANG, except anyxml.\n   o  anyxml: A data node that can contain an unknown
    chunk of XML data.\n   o  augment: Adds new schema nodes to a previously defined
    schema\n      node.\n   o  base type: The type from which a derived type was derived,
    which\n      may be either a built-in type or another derived type.\n   o  built-in
    type: A YANG data type defined in the YANG language, such\n      as uint32 or
    string.\n   o  choice: A schema node where only one of a number of identified\n
    \     alternatives is valid.\n   o  client: An entity that can access YANG-defined
    data on a server,\n      over some network management protocol.\n   o  conformance:
    A measure of how accurately a server follows a data\n      model.\n   o  container:
    An interior data node that exists in at most one\n      instance in the data tree.
    \ A container has no value, but rather a\n      set of child nodes.\n   o  data
    definition statement: A statement that defines new data\n      nodes.  One of
    \"container\", \"leaf\", \"leaf-list\", \"list\", \"choice\",\n      \"case\",
    \"augment\", \"uses\", \"anydata\", and \"anyxml\".\n   o  data model: A data
    model describes how data is represented and\n      accessed.\n   o  data node:
    A node in the schema tree that can be instantiated in a\n      data tree.  One
    of container, leaf, leaf-list, list, anydata, and\n      anyxml.\n   o  data tree:
    An instantiated tree of any data modeled with YANG,\n      e.g., configuration
    data, state data, combined configuration and\n      state data, RPC or action
    input, RPC or action output, or\n      notification.\n   o  derived type: A type
    that is derived from a built-in type (such as\n      uint32) or another derived
    type.\n   o  extension: An extension attaches non-YANG semantics to statements.\n
    \     The \"extension\" statement defines new statements to express these\n      semantics.\n
    \  o  feature: A mechanism for marking a portion of the model as\n      optional.
    \ Definitions can be tagged with a feature name and are\n      only valid on servers
    that support that feature.\n   o  grouping: A reusable set of schema nodes, which
    may be used\n      locally in the module and by other modules that import from
    it.\n      The \"grouping\" statement is not a data definition statement and,\n
    \     as such, does not define any nodes in the schema tree.\n   o  identifier:
    A string used to identify different kinds of YANG\n      items by name.\n   o
    \ identity: A globally unique, abstract, and untyped name.\n   o  instance identifier:
    A mechanism for identifying a particular node\n      in a data tree.\n   o  interior
    node: Nodes within a hierarchy that are not leaf nodes.\n   o  leaf: A data node
    that exists in at most one instance in the data\n      tree.  A leaf has a value
    but no child nodes.\n   o  leaf-list: Like the leaf node but defines a set of
    uniquely\n      identifiable nodes rather than a single node.  Each node has a\n
    \     value but no child nodes.\n   o  list: An interior data node that may exist
    in multiple instances\n      in the data tree.  A list has no value, but rather
    a set of child\n      nodes.\n   o  mandatory node: A mandatory node is one of:\n
    \     *  A leaf, choice, anydata, or anyxml node with a \"mandatory\"\n         statement
    with the value \"true\".\n      *  A list or leaf-list node with a \"min-elements\"
    statement with a\n         value greater than zero.\n      *  A container node
    without a \"presence\" statement and that has at\n         least one mandatory
    node as a child.\n   o  module: A YANG module defines hierarchies of schema nodes.
    \ With\n      its definitions and the definitions it imports or includes from\n
    \     elsewhere, a module is self-contained and \"compilable\".\n   o  non-presence
    container: A container that has no meaning of its\n      own, existing only to
    contain child nodes.\n   o  presence container: A container where the presence
    of the\n      container itself carries some meaning.\n   o  RPC: A Remote Procedure
    Call.\n   o  RPC operation: A specific Remote Procedure Call.\n   o  schema node:
    A node in the schema tree.  One of action, container,\n      leaf, leaf-list,
    list, choice, case, rpc, input, output,\n      notification, anydata, and anyxml.\n
    \  o  schema node identifier: A mechanism for identifying a particular\n      node
    in the schema tree.\n   o  schema tree: The definition hierarchy specified within
    a module.\n   o  server: An entity that provides access to YANG-defined data to
    a\n      client, over some network management protocol.\n   o  server deviation:
    A failure of the server to implement a module\n      faithfully.\n   o  submodule:
    A partial module definition that contributes derived\n      types, groupings,
    data nodes, RPCs, actions, and notifications to\n      a module.  A YANG module
    can be constructed from a number of\n      submodules.\n   o  top-level data node:
    A data node where there is no other data node\n      between it and a \"module\"
    or \"submodule\" statement.\n   o  uses: The \"uses\" statement is used to instantiate
    the set of\n      schema nodes defined in a \"grouping\" statement.  The instantiated\n
    \     nodes may be refined and augmented to tailor them to any specific\n      needs.\n
    \  o  value space: For a data type; the set of values permitted by the\n      data
    type.  For a leaf or leaf-list instance; the value space of\n      its data type.\n
    \  The following terms are defined in [RFC6241]:\n   o  configuration data\n   o
    \ configuration datastore\n   o  datastore\n   o  state data\n   When modeled
    with YANG, a datastore is realized as an instantiated\n   data tree.\n   When
    modeled with YANG, a configuration datastore is realized as an\n   instantiated
    data tree with configuration data.\n"
  - contents:
    - "3.1.  A Note on Examples\n   Throughout this document, there are many examples
      of YANG statements.\n   These examples are supposed to illustrate certain features
      and are\n   not supposed to be complete, valid YANG modules.\n"
    title: 3.1.  A Note on Examples
  title: 3.  Terminology
- contents:
  - "4.  YANG Overview\n   This non-normative section is intended to give a high-level
    overview\n   of YANG to first-time readers.\n"
  - contents:
    - "4.1.  Functional Overview\n   YANG is a language originally designed to model
      data for the NETCONF\n   protocol.  A YANG module defines hierarchies of data
      that can be used\n   for NETCONF-based operations, including configuration,
      state data,\n   RPCs, and notifications.  This allows a complete description
      of all\n   data sent between a NETCONF client and server.  Although out of scope\n
      \  for this specification, YANG can also be used with protocols other\n   than
      NETCONF.\n   YANG models the hierarchical organization of data as a tree in
      which\n   each node has a name, and either a value or a set of child nodes.\n
      \  YANG provides clear and concise descriptions of the nodes, as well as\n   the
      interaction between those nodes.\n   YANG structures data models into modules
      and submodules.  A module\n   can import definitions from other external modules
      and can include\n   definitions from submodules.  The hierarchy can be augmented,\n
      \  allowing one module to add data nodes to the hierarchy defined in\n   another
      module.  This augmentation can be conditional, with new nodes\n   appearing
      only if certain conditions are met.\n   YANG data models can describe constraints
      to be enforced on the data,\n   restricting the presence or value of nodes based
      on the presence or\n   value of other nodes in the hierarchy.  These constraints
      are\n   enforceable by either the client or the server.\n   YANG defines a set
      of built-in types and has a type mechanism through\n   which additional types
      may be defined.  Derived types can restrict\n   their base type's set of valid
      values using mechanisms like range or\n   pattern restrictions that can be enforced
      by clients or servers.\n   They can also define usage conventions for use of
      the derived type,\n   such as a string-based type that contains a hostname.\n
      \  YANG permits the definition of reusable groupings of nodes.  The\n   usage
      of these groupings can refine or augment the nodes, allowing it\n   to tailor
      the nodes to its particular needs.  Derived types and\n   groupings can be defined
      in one module and used in either the same\n   module or another module that
      imports it.\n   YANG data hierarchy constructs include defining lists where
      list\n   entries are identified by keys that distinguish them from each other.\n
      \  Such lists may be defined as either sorted by user or automatically\n   sorted
      by the system.  For user-sorted lists, operations are defined\n   for manipulating
      the order of the list entries.\n   YANG modules can be translated into an equivalent
      XML syntax called\n   YANG Independent Notation (YIN) (Section 13), allowing
      applications\n   using XML parsers and Extensible Stylesheet Language Transformations\n
      \  (XSLT) scripts to operate on the models.  The conversion from YANG to\n   YIN
      is semantically lossless, so content in YIN can be round-tripped\n   back into
      YANG.\n   YANG is an extensible language, allowing extensions to be defined
      by\n   standards bodies, vendors, and individuals.  The statement syntax\n   allows
      these extensions to coexist with standard YANG statements in a\n   natural way,
      while extensions in a YANG module stand out sufficiently\n   for the reader
      to notice them.\n   YANG resists the tendency to solve all possible problems,
      limiting\n   the problem space to allow expression of data models for network\n
      \  management protocols such as NETCONF, not arbitrary XML documents or\n   arbitrary
      data models.\n   To the extent possible, YANG maintains compatibility with the
      Simple\n   Network Management Protocol's (SNMP's) SMIv2 (Structure of Management\n
      \  Information version 2 [RFC2578] [RFC2579]).  SMIv2-based MIB modules\n   can
      be automatically translated into YANG modules for read-only\n   access [RFC6643].
      \ However, YANG is not concerned with reverse\n   translation from YANG to SMIv2.\n"
    title: 4.1.  Functional Overview
  - contents:
    - "4.2.  Language Overview\n   This section introduces some important constructs
      used in YANG that\n   will aid in the understanding of the language specifics
      in later\n   sections.\n"
    - contents:
      - "4.2.1.  Modules and Submodules\n   YANG data models are defined in modules.
        \ A module contains a\n   collection of related definitions.\n   A module
        contains three types of statements: module header\n   statements, \"revision\"
        statements, and definition statements.  The\n   module header statements describe
        the module and give information\n   about the module itself, the \"revision\"
        statements give information\n   about the history of the module, and the definition
        statements are\n   the body of the module where the data model is defined.\n
        \  A server may implement a number of modules, allowing multiple views\n   of
        the same data or multiple views of disjoint subsections of the\n   server's
        data.  Alternatively, the server may implement only one\n   module that defines
        all available data.\n   A module may have portions of its definitions separated
        into\n   submodules, based on the needs of the module designer.  The external\n
        \  view remains that of a single module, regardless of the presence or\n   size
        of its submodules.\n   The \"import\" statement allows a module or submodule
        to reference\n   definitions defined in other modules.\n   The \"include\"
        statement is used in a module to identify each\n   submodule that belongs
        to it.\n"
      title: 4.2.1.  Modules and Submodules
    - contents:
      - "4.2.2.  Data Modeling Basics\n   YANG defines four main types of data nodes
        for data modeling.  In\n   each of the following subsections, the examples
        show the YANG syntax\n   as well as a corresponding XML encoding.  The syntax
        of YANG\n   statements is defined in Section 6.3.\n"
      - contents:
        - "4.2.2.1.  Leaf Nodes\n   A leaf instance contains simple data like an integer
          or a string.  It\n   has exactly one value of a particular type and no child
          nodes.\n   YANG Example:\n     leaf host-name {\n       type string;\n       description\n
          \        \"Hostname for this system.\";\n     }\n   XML Encoding Example:\n
          \    <host-name>my.example.com</host-name>\n   The \"leaf\" statement is
          covered in Section 7.6.\n"
        title: 4.2.2.1.  Leaf Nodes
      - contents:
        - "4.2.2.2.  Leaf-List Nodes\n   A leaf-list defines a sequence of values
          of a particular type.\n   YANG Example:\n     leaf-list domain-search {\n
          \      type string;\n       description\n         \"List of domain names
          to search.\";\n     }\n   XML Encoding Example:\n     <domain-search>high.example.com</domain-search>\n
          \    <domain-search>low.example.com</domain-search>\n     <domain-search>everywhere.example.com</domain-search>\n
          \  The \"leaf-list\" statement is covered in Section 7.7.\n"
        title: 4.2.2.2.  Leaf-List Nodes
      - contents:
        - "4.2.2.3.  Container Nodes\n   A container is used to group related nodes
          in a subtree.  A container\n   has only child nodes and no value.  A container
          may contain any\n   number of child nodes of any type (leafs, lists, containers,\n
          \  leaf-lists, actions, and notifications).\n   YANG Example:\n     container
          system {\n       container login {\n         leaf message {\n           type
          string;\n           description\n             \"Message given at start of
          login session.\";\n         }\n       }\n     }\n   XML Encoding Example:\n
          \    <system>\n       <login>\n         <message>Good morning</message>\n
          \      </login>\n     </system>\n   The \"container\" statement is covered
          in Section 7.5.\n"
        title: 4.2.2.3.  Container Nodes
      - contents:
        - "4.2.2.4.  List Nodes\n   A list defines a sequence of list entries.  Each
          entry is like a\n   container and is uniquely identified by the values of
          its key leafs\n   if it has any key leafs defined.  A list can define multiple
          key\n   leafs and may contain any number of child nodes of any type\n   (including
          leafs, lists, containers, etc.).\n   YANG Example:\n     list user {\n       key
          \"name\";\n       leaf name {\n         type string;\n       }\n       leaf
          full-name {\n         type string;\n       }\n       leaf class {\n         type
          string;\n       }\n     }\n   XML Encoding Example:\n     <user>\n       <name>glocks</name>\n
          \      <full-name>Goldie Locks</full-name>\n       <class>intruder</class>\n
          \    </user>\n     <user>\n       <name>snowey</name>\n       <full-name>Snow
          White</full-name>\n       <class>free-loader</class>\n     </user>\n     <user>\n
          \      <name>rzell</name>\n       <full-name>Rapun Zell</full-name>\n       <class>tower</class>\n
          \    </user>\n   The \"list\" statement is covered in Section 7.8.\n"
        title: 4.2.2.4.  List Nodes
      - contents:
        - "4.2.2.5.  Example Module\n   These statements are combined to define the
          module:\n     // Contents of \"example-system.yang\"\n     module example-system
          {\n       yang-version 1.1;\n       namespace \"urn:example:system\";\n
          \      prefix \"sys\";\n       organization \"Example Inc.\";\n       contact
          \"joe@example.com\";\n       description\n         \"The module for entities
          implementing the Example system.\";\n       revision 2007-06-09 {\n         description
          \"Initial revision.\";\n       }\n       container system {\n         leaf
          host-name {\n           type string;\n           description\n             \"Hostname
          for this system.\";\n         }\n         leaf-list domain-search {\n           type
          string;\n           description\n             \"List of domain names to
          search.\";\n         }\n         container login {\n           leaf message
          {\n             type string;\n             description\n               \"Message
          given at start of login session.\";\n           }\n           list user
          {\n             key \"name\";\n             leaf name {\n               type
          string;\n             }\n             leaf full-name {\n               type
          string;\n             }\n             leaf class {\n               type
          string;\n             }\n           }\n         }\n       }\n     }\n"
        title: 4.2.2.5.  Example Module
      title: 4.2.2.  Data Modeling Basics
    - contents:
      - "4.2.3.  Configuration and State Data\n   YANG can model state data, as well
        as configuration data, based on\n   the \"config\" statement.  When a node
        is tagged with \"config false\",\n   its subhierarchy is flagged as state
        data.  If it is tagged with\n   \"config true\", its subhierarchy is flagged
        as configuration data.\n   Parent containers, lists, and key leafs are reported
        also, giving the\n   context for the state data.\n   In this example, two
        leafs are defined for each interface, a\n   configured speed and an observed
        speed.\n     list interface {\n       key \"name\";\n       config true;\n
        \      leaf name {\n         type string;\n       }\n       leaf speed {\n
        \        type enumeration {\n           enum 10m;\n           enum 100m;\n
        \          enum auto;\n         }\n       }\n       leaf observed-speed {\n
        \        type uint32;\n         config false;\n       }\n     }\n   The \"config\"
        statement is covered in Section 7.21.1.\n"
      title: 4.2.3.  Configuration and State Data
    - contents:
      - "4.2.4.  Built-In Types\n   YANG has a set of built-in types, similar to those
        of many\n   programming languages, but with some differences due to special\n
        \  requirements of network management.  The following table summarizes\n   the
        built-in types discussed in Section 9:\n       +---------------------+-------------------------------------+\n
        \      | Name                | Description                         |\n       +---------------------+-------------------------------------+\n
        \      | binary              | Any binary data                     |\n       |
        bits                | A set of bits or flags              |\n       | boolean
        \            | \"true\" or \"false\"                   |\n       | decimal64
        \          | 64-bit signed decimal number        |\n       | empty               |
        A leaf that does not have any value |\n       | enumeration         | One
        of an enumerated set of strings |\n       | identityref         | A reference
        to an abstract identity |\n       | instance-identifier | A reference to a
        data tree node     |\n       | int8                | 8-bit signed integer
        \               |\n       | int16               | 16-bit signed integer               |\n
        \      | int32               | 32-bit signed integer               |\n       |
        int64               | 64-bit signed integer               |\n       | leafref
        \            | A reference to a leaf instance      |\n       | string              |
        A character string                  |\n       | uint8               | 8-bit
        unsigned integer              |\n       | uint16              | 16-bit unsigned
        integer             |\n       | uint32              | 32-bit unsigned integer
        \            |\n       | uint64              | 64-bit unsigned integer             |\n
        \      | union               | Choice of member types              |\n       +---------------------+-------------------------------------+\n
        \  The \"type\" statement is covered in Section 7.4.\n"
      title: 4.2.4.  Built-In Types
    - contents:
      - "4.2.5.  Derived Types (typedef)\n   YANG can define derived types from base
        types using the \"typedef\"\n   statement.  A base type can be either a built-in
        type or a derived\n   type, allowing a hierarchy of derived types.\n   A derived
        type can be used as the argument for the \"type\" statement.\n   YANG Example:\n
        \    typedef percent {\n       type uint8 {\n         range \"0 .. 100\";\n
        \      }\n     }\n     leaf completed {\n       type percent;\n     }\n   XML
        Encoding Example:\n     <completed>20</completed>\n   The \"typedef\" statement
        is covered in Section 7.3.\n"
      title: 4.2.5.  Derived Types (typedef)
    - contents:
      - "4.2.6.  Reusable Node Groups (grouping)\n   Groups of nodes can be assembled
        into reusable collections using the\n   \"grouping\" statement.  A grouping
        defines a set of nodes that are\n   instantiated with the \"uses\" statement.\n
        \  YANG Example:\n     grouping target {\n       leaf address {\n         type
        inet:ip-address;\n         description \"Target IP address.\";\n       }\n
        \      leaf port {\n         type inet:port-number;\n          description
        \"Target port number.\";\n       }\n     }\n     container peer {\n       container
        destination {\n         uses target;\n       }\n     }\n   XML Encoding Example:\n
        \    <peer>\n       <destination>\n         <address>2001:db8::2</address>\n
        \        <port>830</port>\n       </destination>\n     </peer>\n   The grouping
        can be refined as it is used, allowing certain\n   statements to be overridden.
        \ In this example, the description is\n   refined:\n     container connection
        {\n       container source {\n         uses target {\n           refine \"address\"
        {\n             description \"Source IP address.\";\n           }\n           refine
        \"port\" {\n             description \"Source port number.\";\n           }\n
        \        }\n       }\n       container destination {\n         uses target
        {\n           refine \"address\" {\n             description \"Destination
        IP address.\";\n           }\n           refine \"port\" {\n             description
        \"Destination port number.\";\n           }\n         }\n       }\n     }\n
        \  The \"grouping\" statement is covered in Section 7.12.\n"
      title: 4.2.6.  Reusable Node Groups (grouping)
    - contents:
      - "4.2.7.  Choices\n   YANG allows the data model to segregate incompatible
        nodes into\n   distinct choices using the \"choice\" and \"case\" statements.
        \ The\n   \"choice\" statement contains a set of \"case\" statements that
        define\n   sets of schema nodes that cannot appear together.  Each \"case\"
        may\n   contain multiple nodes, but each node may appear in only one \"case\"\n
        \  under a \"choice\".\n   The choice and case nodes appear only in the schema
        tree and not in\n   the data tree.  The additional levels of hierarchy are
        not needed\n   beyond the conceptual schema.  The presence of a case is indicated
        by\n   the presence of one or more of the nodes within it.\n   Since only
        one of the choice's cases can be valid at any time, when a\n   node from one
        case is created in the data tree, all nodes from all\n   other cases are implicitly
        deleted.  The server handles the\n   enforcement of the constraint, preventing
        incompatibilities from\n   existing in the configuration.\n   YANG Example:\n
        \    container food {\n       choice snack {\n         case sports-arena {\n
        \          leaf pretzel {\n             type empty;\n           }\n           leaf
        beer {\n             type empty;\n           }\n         }\n         case
        late-night {\n           leaf chocolate {\n             type enumeration {\n
        \              enum dark;\n               enum milk;\n               enum
        first-available;\n             }\n           }\n         }\n       }\n     }\n
        \  XML Encoding Example:\n     <food>\n       <pretzel/>\n       <beer/>\n
        \    </food>\n   The \"choice\" statement is covered in Section 7.9.\n"
      title: 4.2.7.  Choices
    - contents:
      - "4.2.8.  Extending Data Models (augment)\n   YANG allows a module to insert
        additional nodes into data models,\n   including both the current module (and
        its submodules) and an\n   external module.  This is useful, for example,
        for vendors to add\n   vendor-specific parameters to standard data models
        in an\n   interoperable way.\n   The \"augment\" statement defines the location
        in the data model\n   hierarchy where new nodes are inserted, and the \"when\"
        statement\n   defines the conditions when the new nodes are valid.\n   When
        a server implements a module containing an \"augment\" statement,\n   that
        implies that the server's implementation of the augmented module\n   contains
        the additional nodes.\n   YANG Example:\n     augment /system/login/user {\n
        \      when \"class != 'wheel'\";\n       leaf uid {\n         type uint16
        {\n           range \"1000 .. 30000\";\n         }\n       }\n     }\n   This
        example defines a \"uid\" node that is valid only when the user's\n   \"class\"
        is not \"wheel\".\n   If a module augments another module, the XML elements
        that are added\n   to the encoding are in the namespace of the augmenting
        module.  For\n   example, if the above augmentation were in a module with
        prefix\n   \"other\", the XML would look like:\n   XML Encoding Example:\n
        \    <user>\n       <name>alicew</name>\n       <full-name>Alice N. Wonderland</full-name>\n
        \      <class>drop-out</class>\n       <other:uid>1024</other:uid>\n     </user>\n
        \  The \"augment\" statement is covered in Section 7.17.\n"
      title: 4.2.8.  Extending Data Models (augment)
    - contents:
      - "4.2.9.  Operation Definitions\n   YANG allows the definition of operations.
        \ The operations' names,\n   input parameters, and output parameters are modeled
        using YANG data\n   definition statements.  Operations on the top level in
        a module are\n   defined with the \"rpc\" statement.  Operations can also
        be tied to a\n   container or list data node.  Such operations are defined
        with the\n   \"action\" statement.\n   YANG Example for an operation at the
        top level:\n     rpc activate-software-image {\n       input {\n         leaf
        image-name {\n           type string;\n         }\n       }\n       output
        {\n         leaf status {\n           type string;\n         }\n       }\n
        \    }\n   NETCONF XML Example:\n     <rpc message-id=\"101\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
        \      <activate-software-image xmlns=\"http://example.com/system\">\n         <image-name>example-fw-2.3</image-name>\n
        \      </activate-software-image>\n     </rpc>\n     <rpc-reply message-id=\"101\"\n
        \               xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n       <status
        xmlns=\"http://example.com/system\">\n         The image example-fw-2.3 is
        being installed.\n       </status>\n     </rpc-reply>\n   YANG Example for
        an operation tied to a list data node:\n     list interface {\n       key
        \"name\";\n       leaf name {\n         type string;\n       }\n       action
        ping {\n         input {\n           leaf destination {\n             type
        inet:ip-address;\n           }\n         }\n         output {\n           leaf
        packet-loss {\n             type uint8;\n           }\n         }\n       }\n
        \    }\n   NETCONF XML Example:\n     <rpc message-id=\"102\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
        \      <action xmlns=\"urn:ietf:params:xml:ns:yang:1\">\n         <interface
        xmlns=\"http://example.com/system\">\n           <name>eth1</name>\n           <ping>\n
        \            <destination>192.0.2.1</destination>\n           </ping>\n         </interface>\n
        \      </action>\n     </rpc>\n     <rpc-reply message-id=\"102\"\n                xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
        \               xmlns:sys=\"http://example.com/system\">\n       <sys:packet-loss>60</sys:packet-loss>\n
        \    </rpc-reply>\n   The \"rpc\" statement is covered in Section 7.14, and
        the \"action\"\n   statement is covered in Section 7.15.\n"
      title: 4.2.9.  Operation Definitions
    - contents:
      - "4.2.10.  Notification Definitions\n   YANG allows the definition of notifications.
        \ YANG data definition\n   statements are used to model the content of the
        notification.\n   YANG Example:\n     notification link-failure {\n       description\n
        \        \"A link failure has been detected.\";\n       leaf if-name {\n         type
        leafref {\n           path \"/interface/name\";\n         }\n       }\n       leaf
        if-admin-status {\n         type admin-status;\n       }\n       leaf if-oper-status
        {\n         type oper-status;\n       }\n     }\n   NETCONF XML Example:\n
        \    <notification\n         xmlns=\"urn:ietf:params:netconf:capability:notification:1.0\">\n
        \      <eventTime>2007-09-01T10:00:00Z</eventTime>\n       <link-failure xmlns=\"urn:example:system\">\n
        \        <if-name>so-1/2/3.0</if-name>\n         <if-admin-status>up</if-admin-status>\n
        \        <if-oper-status>down</if-oper-status>\n       </link-failure>\n     </notification>\n
        \  The \"notification\" statement is covered in Section 7.16.\n"
      title: 4.2.10.  Notification Definitions
    title: 4.2.  Language Overview
  title: 4.  YANG Overview
- contents:
  - '5.  Language Concepts

    '
  - contents:
    - "5.1.  Modules and Submodules\n   The module is the base unit of definition
      in YANG.  A module defines\n   a single data model.  A module can also augment
      an existing data\n   model with additional nodes.\n   Submodules are partial
      modules that contribute definitions to a\n   module.  A module may include any
      number of submodules, but each\n   submodule may belong to only one module.\n
      \  Developers of YANG modules and submodules are RECOMMENDED to choose\n   names
      for their modules that will have a low probability of colliding\n   with standard
      or other enterprise modules, e.g., by using the\n   enterprise or organization
      name as a prefix for the module name.\n   Within a server, all module names
      MUST be unique.\n   A module uses the \"include\" statement to list all its
      submodules.  A\n   module, or submodule belonging to that module, can reference\n
      \  definitions in the module and all submodules included by the module.\n   A
      module or submodule uses the \"import\" statement to reference\n   external
      modules.  Statements in the module or submodule can\n   reference definitions
      in the external module using the prefix\n   specified in the \"import\" statement.\n
      \  For backward compatibility with YANG version 1, a submodule MAY use\n   the
      \"include\" statement to reference other submodules within its\n   module, but
      this is not necessary in YANG version 1.1.  A submodule\n   can reference any
      definition in the module it belongs to and in all\n   submodules included by
      the module.  A submodule MUST NOT include\n   different revisions of other submodules
      than the revisions that its\n   module includes.\n   A module or submodule MUST
      NOT include submodules from other modules,\n   and a submodule MUST NOT import
      its own module.\n   The \"import\" and \"include\" statements are used to make
      definitions\n   available from other modules:\n   o  For a module or submodule
      to reference definitions in an external\n      module, the external module MUST
      be imported.\n   o  A module MUST include all its submodules.\n   o  A module,
      or submodule belonging to that module, MAY reference\n      definitions in the
      module and all submodules included by the\n      module.\n   There MUST NOT
      be any circular chains of imports.  For example, if\n   module \"a\" imports
      module \"b\", \"b\" cannot import \"a\".\n   When a definition in an external
      module is referenced, a locally\n   defined prefix MUST be used, followed by
      a colon (\":\") and then the\n   external identifier.  References to definitions
      in the local module\n   MAY use the prefix notation.  Since built-in data types
      do not belong\n   to any module and have no prefix, references to built-in data
      types\n   (e.g., int32) cannot use the prefix notation.  The syntax for a\n
      \  reference to a definition is formally defined by the rule\n   \"identifier-ref\"
      in Section 14.\n"
    - contents:
      - "5.1.1.  Import and Include by Revision\n   Published modules evolve independently
        over time.  In order to allow\n   for this evolution, modules can be imported
        using specific revisions.\n   Initially, a module imports the revisions of
        other modules that are\n   current when the module is written.  As future
        revisions of the\n   imported modules are published, the importing module
        is unaffected\n   and its contents are unchanged.  When the author of the
        module is\n   prepared to move to the most recently published revision of
        an\n   imported module, the module is republished with an updated \"import\"\n
        \  statement.  By republishing with the new revision, the authors\n   explicitly
        indicate their acceptance of any changes in the imported\n   module.\n   For
        submodules, the issue is related but simpler.  A module or\n   submodule that
        includes submodules may specify the revision of the\n   included submodules.
        \ If a submodule changes, any module or submodule\n   that includes it by
        revision needs to be updated to reference the new\n   revision.\n   For example,
        module \"b\" imports module \"a\".\n     module a {\n       yang-version 1.1;\n
        \      namespace \"urn:example:a\";\n       prefix \"a\";\n       revision
        2008-01-01 { ... }\n       grouping a {\n         leaf eh { .... }\n       }\n
        \    }\n     module b {\n       yang-version 1.1;\n       namespace \"urn:example:b\";\n
        \      prefix \"b\";\n       import a {\n         prefix \"p\";\n         revision-date
        2008-01-01;\n       }\n       container bee {\n         uses p:a;\n       }\n
        \    }\n   When the author of \"a\" publishes a new revision, the changes
        may not\n   be acceptable to the author of \"b\".  If the new revision is\n
        \  acceptable, the author of \"b\" can republish with an updated revision\n
        \  in the \"import\" statement.\n   If a module is not imported with a specific
        revision, it is undefined\n   which revision is used.\n"
      title: 5.1.1.  Import and Include by Revision
    - contents:
      - "5.1.2.  Module Hierarchies\n   YANG allows modeling of data in multiple hierarchies,
        where data may\n   have more than one top-level node.  Each top-level data
        node in a\n   module defines a separate hierarchy.  Models that have multiple\n
        \  top-level nodes are sometimes convenient and are supported by YANG.\n"
      - contents:
        - "5.1.2.1.  NETCONF XML Encoding\n   NETCONF is capable of carrying any XML
          content as the payload in the\n   <config> and <data> elements.  The top-level
          nodes of YANG modules\n   are encoded as child elements, in any order, within
          these elements.\n   This encapsulation guarantees that the corresponding
          NETCONF messages\n   are always well-formed XML documents.\n   For example,
          an instance of:\n     module example-config {\n       yang-version 1.1;\n
          \      namespace \"urn:example:config\";\n       prefix \"co\";\n       container
          system { ... }\n       container routing { ... }\n     }\n   could be encoded
          in NETCONF as:\n     <rpc message-id=\"101\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
          \         xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n       <edit-config>\n
          \        <target>\n           <running/>\n         </target>\n         <config>\n
          \          <system xmlns=\"urn:example:config\">\n             <!-- system
          data here -->\n           </system>\n           <routing xmlns=\"urn:example:config\">\n
          \            <!-- routing data here -->\n           </routing>\n         </config>\n
          \      </edit-config>\n     </rpc>\n"
        title: 5.1.2.1.  NETCONF XML Encoding
      title: 5.1.2.  Module Hierarchies
    title: 5.1.  Modules and Submodules
  - contents:
    - "5.2.  File Layout\n   YANG modules and submodules are typically stored in files,
      one\n   \"module\" or \"submodule\" statement per file.  The name of the file\n
      \  SHOULD be of the form:\n     module-or-submodule-name ['@' revision-date]
      ( '.yang' / '.yin' )\n   \"module-or-submodule-name\" is the name of the module
      or submodule,\n   and the optional \"revision-date\" is the latest revision
      of the module\n   or submodule, as defined by the \"revision\" statement (Section
      7.1.9).\n   The file extension \".yang\" denotes that the contents of the file
      are\n   written with YANG syntax (Section 6), and \".yin\" denotes that the\n
      \  contents of the file are written with YIN syntax (Section 13).\n   YANG parsers
      can find imported modules and included submodules via\n   this convention.\n"
    title: 5.2.  File Layout
  - contents:
    - "5.3.  XML Namespaces\n   All YANG definitions are specified within a module.
      \ Each module is\n   bound to a distinct XML namespace [XML-NAMES], which is
      a globally\n   unique URI [RFC3986].  A NETCONF client or server uses the namespace\n
      \  during XML encoding of data.\n   XML namespaces for modules published in
      RFC streams [RFC4844] MUST be\n   assigned by IANA; see Section 14 in [RFC6020].\n
      \  XML namespaces for private modules are assigned by the organization\n   owning
      the module without a central registry.  Namespace URIs MUST be\n   chosen so
      they cannot collide with standard or other enterprise\n   namespaces -- for
      example, by using the enterprise or organization\n   name in the namespace.\n
      \  The \"namespace\" statement is covered in Section 7.1.3.\n"
    - contents:
      - "5.3.1.  YANG XML Namespace\n   YANG defines an XML namespace for NETCONF
        <edit-config> operations,\n   <error-info> content, and the <action> element.
        \ The name of this\n   namespace is \"urn:ietf:params:xml:ns:yang:1\".\n"
      title: 5.3.1.  YANG XML Namespace
    title: 5.3.  XML Namespaces
  - contents:
    - "5.4.  Resolving Grouping, Type, and Identity Names\n   Grouping, type, and
      identity names are resolved in the context in\n   which they are defined, rather
      than the context in which they are\n   used.  Users of groupings, typedefs,
      and identities are not required\n   to import modules or include submodules
      to satisfy all references\n   made by the original definition.  This behaves
      like static scoping in\n   a conventional programming language.\n   For example,
      if a module defines a grouping in which a type is\n   referenced, when the grouping
      is used in a second module, the type is\n   resolved in the context of the original
      module, not the second\n   module.  There is no ambiguity if both modules define
      the type.\n"
    title: 5.4.  Resolving Grouping, Type, and Identity Names
  - contents:
    - "5.5.  Nested Typedefs and Groupings\n   Typedefs and groupings may appear nested
      under many YANG statements,\n   allowing these to be lexically scoped by the
      statement hierarchy\n   under which they appear.  This allows types and groupings
      to be\n   defined near where they are used, rather than placing them at the\n
      \  top level of the hierarchy.  The close proximity increases\n   readability.\n
      \  Scoping also allows types to be defined without concern for naming\n   conflicts
      between types in different submodules.  Type names can be\n   specified without
      adding leading strings designed to prevent name\n   collisions within large
      modules.\n   Finally, scoping allows the module author to keep types and groupings\n
      \  private to their module or submodule, preventing their reuse.  Since\n   only
      top-level types and groupings (i.e., those appearing as\n   substatements to
      a \"module\" or \"submodule\" statement) can be used\n   outside the module
      or submodule, the developer has more control over\n   what pieces of their module
      are presented to the outside world,\n   supporting the need to hide internal
      information and maintaining a\n   boundary between what is shared with the outside
      world and what is\n   kept private.\n   Scoped definitions MUST NOT shadow definitions
      at a higher scope.  A\n   type or grouping cannot be defined if a higher level
      in the statement\n   hierarchy has a definition with a matching identifier.\n
      \  A reference to an unprefixed type or grouping, or one that uses the\n   prefix
      of the current module, is resolved by locating the matching\n   \"typedef\"
      or \"grouping\" statement among the immediate substatements\n   of each ancestor
      statement.\n"
    title: 5.5.  Nested Typedefs and Groupings
  - contents:
    - "5.6.  Conformance\n   Conformance to a model is a measure of how accurately
      a server\n   follows the model.  Generally speaking, servers are responsible
      for\n   implementing the model faithfully, allowing applications to treat\n
      \  servers that implement the model identically.  Deviations from the\n   model
      can reduce the utility of the model and increase the fragility\n   of applications
      that use it.\n   YANG modelers have three mechanisms for conformance:\n   o
      \ the basic behavior of the model\n   o  optional features that are part of
      the model\n   o  deviations from the model\n   We will consider each of these
      in sequence.\n"
    - contents:
      - "5.6.1.  Basic Behavior\n   The model defines a contract between a YANG-based
        client and server;\n   this contract allows both parties to have faith that
        the other knows\n   the syntax and semantics behind the modeled data.  The
        strength of\n   YANG lies in the strength of this contract.\n"
      title: 5.6.1.  Basic Behavior
    - contents:
      - "5.6.2.  Optional Features\n   In many models, the modeler will allow sections
        of the model to be\n   conditional.  The server controls whether these conditional
        portions\n   of the model are supported or valid for that particular server.\n
        \  For example, a syslog data model may choose to include the ability to\n
        \  save logs locally, but the modeler will realize that this is only\n   possible
        if the server has local storage.  If there is no local\n   storage, an application
        should not tell the server to save logs.\n   YANG supports this conditional
        mechanism using a construct called\n   \"feature\".  Features give the modeler
        a mechanism for making portions\n   of the module conditional in a manner
        that is controlled by the\n   server.  The model can express constructs that
        are not universally\n   present in all servers.  These features are included
        in the model\n   definition, allowing a consistent view and allowing applications
        to\n   learn which features are supported and tailor their behavior to the\n
        \  server.\n   A module may declare any number of features, identified by
        simple\n   strings, and may make portions of the module optional based on
        those\n   features.  If the server supports a feature, then the corresponding\n
        \  portions of the module are valid for that server.  If the server\n   doesn't
        support the feature, those parts of the module are not valid,\n   and applications
        should behave accordingly.\n   Features are defined using the \"feature\"
        statement.  Definitions in\n   the module that are conditional to the feature
        are noted by the\n   \"if-feature\" statement.\n   Further details are available
        in Section 7.20.1.\n"
      title: 5.6.2.  Optional Features
    - contents:
      - "5.6.3.  Deviations\n   In an ideal world, all servers would be required to
        implement the\n   model exactly as defined, and deviations from the model
        would not be\n   allowed.  But in the real world, servers are often not able
        or\n   designed to implement the model as written.  For YANG-based\n   automation
        to deal with these server deviations, a mechanism must\n   exist for servers
        to inform applications of the specifics of such\n   deviations.\n   For example,
        a BGP module may allow any number of BGP peers, but a\n   particular server
        may only support 16 BGP peers.  Any application\n   configuring the 17th peer
        will receive an error.  While an error may\n   suffice to let the application
        know it cannot add another peer, it\n   would be far better if the application
        had prior knowledge of this\n   limitation and could prevent the user from
        starting down the path\n   that could not succeed.\n   Server deviations are
        declared using the \"deviation\" statement, which\n   takes as its argument
        a string that identifies a node in the schema\n   tree.  The contents of the
        statement detail the manner in which the\n   server implementation deviates
        from the contract as defined in the\n   module.\n   Further details are available
        in Section 7.20.3.\n"
      title: 5.6.3.  Deviations
    - contents:
      - "5.6.4.  Announcing Conformance Information in NETCONF\n   This document defines
        the following mechanism for announcing\n   conformance information.  Other
        mechanisms may be defined by future\n   specifications.\n   A NETCONF server
        MUST announce the modules it implements (see\n   Section 5.6.5) by implementing
        the YANG module \"ietf-yang-library\"\n   defined in [RFC7895] and listing
        all implemented modules in the\n   \"/modules-state/module\" list.\n   The
        server also MUST advertise the following capability in the\n   <hello> message
        (line breaks and whitespaces are used for formatting\n   reasons only):\n
        \    urn:ietf:params:netconf:capability:yang-library:1.0?\n       revision=<date>&module-set-id=<id>\n
        \  The parameter \"revision\" has the same value as the revision date of\n
        \  the \"ietf-yang-library\" module implemented by the server.  This\n   parameter
        MUST be present.\n   The parameter \"module-set-id\" has the same value as
        the leaf\n   \"/modules-state/module-set-id\" from \"ietf-yang-library\".
        \ This\n   parameter MUST be present.\n   With this mechanism, a client can
        cache the supported modules for a\n   server and only update the cache if
        the \"module-set-id\" value in the\n   <hello> message changes.\n"
      title: 5.6.4.  Announcing Conformance Information in NETCONF
    - contents:
      - "5.6.5.  Implementing a Module\n   A server implements a module if it implements
        the module's data\n   nodes, RPCs, actions, notifications, and deviations.\n
        \  A server MUST NOT implement more than one revision of a module.\n   If
        a server implements a module A that imports a module B, and A uses\n   any
        node from B in an \"augment\" or \"path\" statement that the server\n   supports,
        then the server MUST implement a revision of module B that\n   has these nodes
        defined.  This is regardless of whether module B is\n   imported by revision
        or not.\n   If a server implements a module A that imports a module C without\n
        \  specifying the revision date of module C and the server does not\n   implement
        C (e.g., if C only defines some typedefs), the server MUST\n   list module
        C in the \"/modules-state/module\" list from\n   \"ietf-yang-library\" [RFC7895],
        and it MUST set the leaf\n   \"conformance-type\" to \"import\" for this module.\n
        \  If a server lists a module C in the \"/modules-state/module\" list from\n
        \  \"ietf-yang-library\" and there are other modules Ms listed that import\n
        \  C without specifying the revision date of module C, the server MUST\n   use
        the definitions from the most recent revision of C listed for\n   modules
        Ms.\n   The reason for these rules is that clients need to be able to know\n
        \  the specific data model structure and types of all leafs and\n   leaf-lists
        implemented in a server.\n   For example, with these modules:\n     module
        a {\n       yang-version 1.1;\n       namespace \"urn:example:a\";\n       prefix
        \"a\";\n       import b {\n         revision-date 2015-01-01;\n       }\n
        \      import c;\n       revision 2015-01-01;\n       feature foo;\n       augment
        \"/b:x\" {\n         if-feature foo;\n         leaf y {\n           type b:myenum;\n
        \        }\n       }\n       container a {\n         leaf x {\n           type
        c:bar;\n         }\n       }\n     }\n     module b {\n       yang-version
        1.1;\n       namespace \"urn:example:b\";\n       prefix \"b\";\n       revision
        2015-01-01;\n       typedef myenum {\n         type enumeration {\n           enum
        zero;\n         }\n       }\n       container x {\n       }\n     }\n     module
        b {\n       yang-version 1.1;\n       namespace \"urn:example:b\";\n       prefix
        \"b\";\n       revision 2015-04-04;\n       revision 2015-01-01;\n       typedef
        myenum {\n         type enumeration {\n           enum zero; // added in 2015-01-01\n
        \          enum one;  // added in 2015-04-04\n         }\n       }\n       container
        x {  // added in 2015-01-01\n         container y; // added in 2015-04-04\n
        \      }\n     }\n     module c {\n       yang-version 1.1;\n       namespace
        \"urn:example:c\";\n       prefix \"c\";\n       revision 2015-02-02;\n       typedef
        bar {\n         ...\n       }\n     }\n     module c {\n       yang-version
        1.1;\n       namespace \"urn:example:c\";\n       prefix \"c\";\n       revision
        2015-03-03;\n       revision 2015-02-02;\n       typedef bar {\n         ...\n
        \      }\n     }\n   A server that implements revision \"2015-01-01\" of module
        \"a\" and\n   supports feature \"foo\" can implement revision \"2015-01-01\"
        or\n   \"2015-04-04\" of module \"b\".  Since \"b\" was imported by revision,
        the\n   type of leaf \"/b:x/a:y\" is the same, regardless of which revision
        of\n   \"b\" the server implements.\n   A server that implements module \"a\"
        but does not support feature\n   \"foo\" does not have to implement module
        \"b\".\n   A server that implements revision \"2015-01-01\" of module \"a\"\n
        \  picks any revision of module \"c\" and lists it in the\n   \"/modules-state/module\"
        list from \"ietf-yang-library\".\n   The following XML encoding example shows
        valid data for the\n   \"/modules-state/module\" list for a server that implements
        module \"a\":\n     <modules-state\n         xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-library\">\n
        \      <module-set-id>ee1ecb017370cafd</module-set-id>\n       <module>\n
        \        <name>a</name>\n         <revision>2015-01-01</revision>\n         <namespace>urn:example:a</namespace>\n
        \        <feature>foo</feature>\n         <conformance-type>implement</conformance-type>\n
        \      </module>\n       <module>\n         <name>b</name>\n         <revision>2015-04-04</revision>\n
        \        <namespace>urn:example:b</namespace>\n         <conformance-type>implement</conformance-type>\n
        \      </module>\n       <module>\n         <name>c</name>\n         <revision>2015-02-02</revision>\n
        \        <namespace>urn:example:c</namespace>\n         <conformance-type>import</conformance-type>\n
        \      </module>\n     </modules-state>\n"
      title: 5.6.5.  Implementing a Module
    title: 5.6.  Conformance
  - contents:
    - "5.7.  Datastore Modification\n   Data models may allow the server to alter
      the configuration datastore\n   in ways not explicitly directed via network
      management protocol\n   messages.  For example, a data model may define leafs
      that are\n   assigned system-generated values when the client does not provide\n
      \  one.  A formal mechanism for specifying the circumstances where these\n   changes
      are allowed is out of scope for this specification.\n"
    title: 5.7.  Datastore Modification
  title: 5.  Language Concepts
- contents:
  - "6.  YANG Syntax\n   The YANG syntax is similar to that of SMIng [RFC3780] and
    programming\n   languages like C and C++.  This C-like syntax was chosen specifically\n
    \  for its readability, since YANG values the time and effort of the\n   readers
    of models above those of modules writers and YANG tool-chain\n   developers.  This
    section introduces the YANG syntax.\n   Legal characters in YANG modules are the
    Unicode and ISO/IEC 10646\n   [ISO.10646] characters, including tab, carriage
    return, and line feed\n   but excluding the other C0 control characters, the surrogate
    blocks,\n   and the noncharacters.  The character syntax is formally defined by\n
    \  the rule \"yang-char\" in Section 14.\n   YANG modules and submodules are stored
    in files using the UTF-8\n   [RFC3629] character encoding.\n   Lines in a YANG
    module end with a carriage return-line feed\n   combination or with a line feed
    alone.  A carriage return that is not\n   followed by a line feed may only appear
    inside a quoted string\n   (Section 6.1.3).  Note that carriage returns and line
    feeds that\n   appear inside quoted strings become part of the value of the string\n
    \  without modification; the value of a multi-line quoted string\n   contains
    the same form of line ends as those lines of the YANG\n   module.\n"
  - contents:
    - "6.1.  Lexical Tokenization\n   YANG modules are parsed as a series of tokens.
      \ This section details\n   the rules for recognizing tokens from an input stream.
      \ YANG\n   tokenization rules are both simple and powerful.  The simplicity
      is\n   driven by a need to keep the parsers easy to implement, while the\n   power
      is driven by the fact that modelers need to express their\n   models in readable
      formats.\n"
    - contents:
      - "6.1.1.  Comments\n   Comments are C++ style.  A single line comment starts
        with \"//\" and\n   ends at the end of the line.  A block comment starts with
        \"/*\" and\n   ends with the nearest following \"*/\".\n   Note that inside
        a quoted string (Section 6.1.3), these character\n   pairs are never interpreted
        as the start or end of a comment.\n"
      title: 6.1.1.  Comments
    - contents:
      - "6.1.2.  Tokens\n   A token in YANG is either a keyword, a string, a semicolon
        (\";\"), or\n   braces (\"{\" or \"}\").  A string can be quoted or unquoted.
        \ A keyword\n   is either one of the YANG keywords defined in this document,
        or a\n   prefix identifier, followed by a colon (\":\"), followed by a language\n
        \  extension keyword.  Keywords are case sensitive.  See Section 6.2 for\n
        \  a formal definition of identifiers.\n"
      title: 6.1.2.  Tokens
    - contents:
      - "6.1.3.  Quoting\n   An unquoted string is any sequence of characters that
        does not\n   contain any space, tab, carriage return, or line feed characters,
        a\n   single or double quote character, a semicolon (\";\"), braces (\"{\"
        or\n   \"}\"), or comment sequences (\"//\", \"/*\", or \"*/\").\n   Note
        that any keyword can legally appear as an unquoted string.\n   Within an unquoted
        string, every character is preserved.  Note that\n   this means that the backslash
        character does not have any special\n   meaning in an unquoted string.\n   If
        a double-quoted string contains a line break followed by space or\n   tab
        characters that are used to indent the text according to the\n   layout in
        the YANG file, this leading whitespace is stripped from the\n   string, up
        to and including the column of the starting double quote\n   character, or
        to the first non-whitespace character, whichever occurs\n   first.  Any tab
        character in a succeeding line that must be examined\n   for stripping is
        first converted into 8 space characters.\n   If a double-quoted string contains
        space or tab characters before a\n   line break, this trailing whitespace
        is stripped from the string.\n   A single-quoted string (enclosed within '
        ') preserves each character\n   within the quotes.  A single quote character
        cannot occur in a\n   single-quoted string, even when preceded by a backslash.\n
        \  Within a double-quoted string (enclosed within \" \"), a backslash\n   character
        introduces a representation of a special character, which\n   depends on the
        character that immediately follows the backslash:\n    \\n      newline\n
        \   \\t      a tab character\n    \\\"      a double quote\n    \\\\      a
        single backslash\n   The backslash MUST NOT be followed by any other character.\n
        \  If a quoted string is followed by a plus character (\"+\"), followed by\n
        \  another quoted string, the two strings are concatenated into one\n   string,
        allowing multiple concatenations to build one string.\n   Whitespace, line
        breaks, and comments are allowed between the quoted\n   strings and the plus
        character.\n   In double-quoted strings, whitespace trimming is done before\n
        \  substitution of backslash-escaped characters.  Concatenation is\n   performed
        as the last step.\n"
      - contents:
        - "6.1.3.1.  Quoting Examples\n   The following strings are equivalent:\n
          \    hello\n     \"hello\"\n     'hello'\n     \"hel\" + \"lo\"\n     'hel'
          + \"lo\"\n   The following examples show some special strings:\n     \"\\\"\"
          \ - string containing a double quote\n     '\"'   - string containing a
          double quote\n     \"\\n\"  - string containing a newline character\n     '\\n'
          \ - string containing a backslash followed\n             by the character
          n\n   The following examples show some illegal strings:\n     ''''  - a
          single-quoted string cannot contain single quotes\n     \"\"\"   - a double
          quote must be escaped in a double-quoted string\n   The following strings
          are equivalent:\n         \"first line\n            second line\"\n     \"first
          line\\n\" + \"  second line\"\n"
        title: 6.1.3.1.  Quoting Examples
      title: 6.1.3.  Quoting
    title: 6.1.  Lexical Tokenization
  - contents:
    - "6.2.  Identifiers\n   Identifiers are used to identify different kinds of YANG
      items by\n   name.  Each identifier starts with an uppercase or lowercase ASCII\n
      \  letter or an underscore character, followed by zero or more ASCII\n   letters,
      digits, underscore characters, hyphens, and dots.\n   Implementations MUST support
      identifiers up to 64 characters in\n   length and MAY support longer identifiers.
      \ Identifiers are case\n   sensitive.  The identifier syntax is formally defined
      by the rule\n   \"identifier\" in Section 14.  Identifiers can be specified
      as quoted\n   or unquoted strings.\n"
    - contents:
      - "6.2.1.  Identifiers and Their Namespaces\n   Each identifier is valid in
        a namespace that depends on the type of\n   the YANG item being defined.  All
        identifiers defined in a namespace\n   MUST be unique.\n   o  All module and
        submodule names share the same global module\n      identifier namespace.\n
        \  o  All extension names defined in a module and its submodules share\n      the
        same extension identifier namespace.\n   o  All feature names defined in a
        module and its submodules share the\n      same feature identifier namespace.\n
        \  o  All identity names defined in a module and its submodules share\n      the
        same identity identifier namespace.\n   o  All derived type names defined
        within a parent node or at the top\n      level of the module or its submodules
        share the same type\n      identifier namespace.  This namespace is scoped
        to all descendant\n      nodes of the parent node or module.  This means that
        any\n      descendant node may use that typedef, and it MUST NOT define a\n
        \     typedef with the same name.\n   o  All grouping names defined within
        a parent node or at the top\n      level of the module or its submodules share
        the same grouping\n      identifier namespace.  This namespace is scoped to
        all descendant\n      nodes of the parent node or module.  This means that
        any\n      descendant node may use that grouping, and it MUST NOT define a\n
        \     grouping with the same name.\n   o  All leafs, leaf-lists, lists, containers,
        choices, rpcs, actions,\n      notifications, anydatas, and anyxmls defined
        (directly or through\n      a \"uses\" statement) within a parent node or
        at the top level of\n      the module or its submodules share the same identifier
        namespace.\n      This namespace is scoped to the parent node or module, unless
        the\n      parent node is a case node.  In that case, the namespace is scoped\n
        \     to the closest ancestor node that is not a case or choice node.\n   o
        \ All cases within a choice share the same case identifier\n      namespace.
        \ This namespace is scoped to the parent choice node.\n   Forward references
        are allowed in YANG.\n"
      title: 6.2.1.  Identifiers and Their Namespaces
    title: 6.2.  Identifiers
  - contents:
    - "6.3.  Statements\n   A YANG module contains a sequence of statements.  Each
      statement\n   starts with a keyword, followed by zero or one argument, followed
      by\n   either a semicolon (\";\") or a block of substatements enclosed within\n
      \  braces (\"{ }\"):\n     statement = keyword [argument] (\";\" / \"{\" *statement
      \"}\")\n   The argument is a string, as defined in Section 6.1.2.\n"
    - contents:
      - "6.3.1.  Language Extensions\n   A module can introduce YANG extensions by
        using the \"extension\"\n   keyword (see Section 7.19).  The extensions can
        be imported by other\n   modules with the \"import\" statement (see Section
        7.1.5).  When an\n   imported extension is used, the extension's keyword MUST
        be qualified\n   using the prefix with which the extension's module was imported.
        \ If\n   an extension is used in the module where it is defined, the\n   extension's
        keyword MUST be qualified with the prefix of this module.\n   The processing
        of extensions depends on whether support for those\n   extensions is claimed
        for a given YANG parser or the tool set in\n   which it is embedded.  An unsupported
        extension appearing in a YANG\n   module as an unknown-statement (see Section
        14) MAY be ignored in its\n   entirety.  Any supported extension MUST be processed
        in accordance\n   with the specification governing that extension.\n   Care
        must be taken when defining extensions so that modules that use\n   the extensions
        are meaningful also for applications that do not\n   support the extensions.\n"
      title: 6.3.1.  Language Extensions
    title: 6.3.  Statements
  - contents:
    - "6.4.  XPath Evaluations\n   YANG relies on XML Path Language (XPath) 1.0 [XPATH]
      as a notation\n   for specifying many inter-node references and dependencies.
      \ An\n   implementation is not required to implement an XPath interpreter but\n
      \  MUST ensure that the requirements encoded in the data model are\n   enforced.
      \ The manner of enforcement is an implementation decision.\n   The XPath expressions
      MUST be syntactically correct, and all prefixes\n   used MUST be present in
      the XPath context (see Section 6.4.1).  An\n   implementation may choose to
      implement them by hand, rather than\n   using the XPath expression directly.\n
      \  The data model used in the XPath expressions is the same as that used\n   in
      XPath 1.0 [XPATH], with the same extension for root node children\n   as used
      by XSLT 1.0 (see Section 3.1 in [XSLT]).  Specifically, it\n   means that the
      root node may have any number of element nodes as its\n   children.\n   The
      data tree has no concept of document order.  An implementation\n   needs to
      choose some document order, but how it is done is an\n   implementation decision.
      \ This means that XPath expressions in YANG\n   modules SHOULD NOT rely on any
      specific document order.\n   Numbers in XPath 1.0 are IEEE 754 [IEEE754-2008]
      double-precision\n   floating-point values; see Section 3.5 in [XPATH].  This
      means that\n   some values of int64, uint64, and decimal64 types (see Sections
      9.2\n   and 9.3) cannot be exactly represented in XPath expressions.\n   Therefore,
      due caution should be exercised when using nodes with\n   64-bit numeric values
      in XPath expressions.  In particular, numerical\n   comparisons involving equality
      may yield unexpected results.\n   For example, consider the following definition:\n
      \    leaf lxiv {\n       type decimal64 {\n         fraction-digits 18;\n       }\n
      \      must \". <= 10\";\n     }\n   An instance of the \"lxiv\" leaf having
      the value of\n   10.0000000000000001 will then successfully pass validation.\n"
    - contents:
      - "6.4.1.  XPath Context\n   All YANG XPath expressions share the following
        XPath context\n   definition:\n   o  The set of namespace declarations is
        the set of all \"import\"\n      statements' prefix and namespace pairs in
        the module where the\n      XPath expression is specified, and the \"prefix\"
        statement's prefix\n      for the \"namespace\" statement's URI.\n   o  Names
        without a namespace prefix belong to the same namespace as\n      the identifier
        of the current node.  Inside a grouping, that\n      namespace is affected
        by where the grouping is used (see\n      Section 7.13).  Inside a typedef,
        that namespace is affected by\n      where the typedef is referenced.  If
        a typedef is defined and\n      referenced within a grouping, the namespace
        is affected by where\n      the grouping is used (see Section 7.13).\n   o
        \ The function library is the core function library defined in\n      [XPATH]
        and the functions defined in Section 10.\n   o  The set of variable bindings
        is empty.\n   The mechanism for handling unprefixed names is adopted from
        XPath 2.0\n   [XPATH2.0] and helps simplify XPath expressions in YANG.  No\n
        \  ambiguity may ever arise, because YANG node identifiers are always\n   qualified
        names with a non-null namespace URI.\n   The accessible tree depends on where
        the statement with the XPath\n   expression is defined:\n   o  If the XPath
        expression is defined in a substatement to a data\n      node that represents
        configuration, the accessible tree is the\n      data in the datastore where
        the context node exists.  The root\n      node has all top-level configuration
        data nodes in all modules as\n      children.\n   o  If the XPath expression
        is defined in a substatement to a data\n      node that represents state data,
        the accessible tree is all state\n      data in the server, and the running
        configuration datastore.  The\n      root node has all top-level data nodes
        in all modules as children.\n   o  If the XPath expression is defined in a
        substatement to a\n      \"notification\" statement, the accessible tree is
        the notification\n      instance, all state data in the server, and the running\n
        \     configuration datastore.  If the notification is defined on the\n      top
        level in a module, then the root node has the node\n      representing the
        notification being defined and all top-level data\n      nodes in all modules
        as children.  Otherwise, the root node has\n      all top-level data nodes
        in all modules as children.\n   o  If the XPath expression is defined in a
        substatement to an \"input\"\n      statement in an \"rpc\" or \"action\"
        statement, the accessible tree\n      is the RPC or action operation instance,
        all state data in the\n      server, and the running configuration datastore.
        \ The root node\n      has top-level data nodes in all modules as children.\n
        \     Additionally, for an RPC, the root node also has the node\n      representing
        the RPC operation being defined as a child.  The node\n      representing
        the operation being defined has the operation's input\n      parameters as
        children.\n   o  If the XPath expression is defined in a substatement to an\n
        \     \"output\" statement in an \"rpc\" or \"action\" statement, the\n      accessible
        tree is the RPC or action operation instance, all state\n      data in the
        server, and the running configuration datastore.  The\n      root node has
        top-level data nodes in all modules as children.\n      Additionally, for
        an RPC, the root node also has the node\n      representing the RPC operation
        being defined as a child.  The node\n      representing the operation being
        defined has the operation's\n      output parameters as children.\n   In the
        accessible tree, all leafs and leaf-lists with default values\n   in use exist
        (see Sections 7.6.1 and 7.7.2).\n   If a node that exists in the accessible
        tree has a non-presence\n   container as a child, then the non-presence container
        also exists in\n   the accessible tree.\n   The context node varies with the
        YANG XPath expression and is\n   specified where the YANG statement with the
        XPath expression is\n   defined.\n"
      - contents:
        - "6.4.1.1.  Examples\n   Given the following module:\n     module example-a
          {\n       yang-version 1.1;\n       namespace urn:example:a;\n       prefix
          a;\n       container a {\n         list b {\n           key id;\n           leaf
          id {\n             type string;\n           }\n           notification down
          {\n             leaf reason {\n               type string;\n             }\n
          \          }\n           action reset {\n             input {\n               leaf
          delay {\n                 type uint32;\n               }\n             }\n
          \            output {\n               leaf result {\n                 type
          string;\n               }\n             }\n           }\n         }\n       }\n
          \      notification failure {\n         leaf b-ref {\n           type leafref
          {\n             path \"/a/b/id\";\n           }\n         }\n       }\n
          \    }\n   and given the following data tree, specified in XML:\n     <a
          xmlns=\"urn:example:a\">\n       <b>\n         <id>1</id>\n       </b>\n
          \      <b>\n         <id>2</id>\n       </b>\n     </a>\n   The accessible
          tree for a notification \"down\" on /a/b[id=\"2\"] is:\n     <a xmlns=\"urn:example:a\">\n
          \      <b>\n         <id>1</id>\n       </b>\n       <b>\n         <id>2</id>\n
          \        <down>\n           <reason>error</reason>\n         </down>\n       </b>\n
          \    </a>\n     // possibly other top-level nodes here\n   The accessible
          tree for an action invocation of \"reset\" on\n   /a/b[id=\"1\"] with the
          \"when\" parameter set to \"10\" would be:\n     <a xmlns=\"urn:example:a\">\n
          \      <b>\n         <id>1</id>\n         <reset>\n           <delay>10</delay>\n
          \        </reset>\n       </b>\n       <b>\n         <id>2</id>\n       </b>\n
          \    </a>\n     // possibly other top-level nodes here\n   The accessible
          tree for the action output of this action is:\n     <a xmlns=\"urn:example:a\">\n
          \      <b>\n         <id>1</id>\n         <reset>\n           <result>ok</result>\n
          \        </reset>\n       </b>\n       <b>\n         <id>2</id>\n       </b>\n
          \    </a>\n     // possibly other top-level nodes here\n   The accessible
          tree for a notification \"failure\" could be:\n     <a xmlns=\"urn:example:a\">\n
          \      <b>\n         <id>1</id>\n       </b>\n       <b>\n         <id>2</id>\n
          \      </b>\n     </a>\n     <failure>\n       <b-ref>2</b-ref>\n     </failure>\n
          \    // possibly other top-level nodes here\n"
        title: 6.4.1.1.  Examples
      title: 6.4.1.  XPath Context
    title: 6.4.  XPath Evaluations
  - contents:
    - "6.5.  Schema Node Identifier\n   A schema node identifier is a string that
      identifies a node in the\n   schema tree.  It has two forms, \"absolute\" and
      \"descendant\", defined\n   by the rules \"absolute-schema-nodeid\" and \"descendant-schema-nodeid\"\n
      \  in Section 14, respectively.  A schema node identifier consists of a\n   path
      of identifiers, separated by slashes (\"/\").  In an absolute\n   schema node
      identifier, the first identifier after the leading slash\n   is any top-level
      schema node in the local module or in an imported\n   module.\n   References
      to identifiers defined in external modules MUST be\n   qualified with appropriate
      prefixes, and references to identifiers\n   defined in the current module and
      its submodules MAY use a prefix.\n   For example, to identify the child node
      \"b\" of top-level node \"a\",\n   the string \"/a/b\" can be used.\n"
    title: 6.5.  Schema Node Identifier
  title: 6.  YANG Syntax
- contents:
  - "7.  YANG Statements\n   The following sections describe all of the YANG statements.\n
    \  Note that even a statement that does not have any substatements\n   defined
    in YANG can have vendor-specific extensions as substatements.\n   For example,
    the \"description\" statement does not have any\n   substatements defined in YANG,
    but the following is legal:\n     description \"Some text.\" {\n       ex:documentation-flag
    5;\n     }\n"
  - contents:
    - "7.1.  The \"module\" Statement\n   The \"module\" statement defines the module's
      name and groups all\n   statements that belong to the module together.  The
      \"module\"\n   statement's argument is the name of the module, followed by a
      block\n   of substatements that holds detailed module information.  The module\n
      \  name is an identifier (see Section 6.2).\n   Names of modules published in
      RFC streams [RFC4844] MUST be assigned\n   by IANA; see Section 14 in [RFC6020].\n
      \  Private module names are assigned by the organization owning the\n   module
      without a central registry.  See Section 5.1 for\n   recommendations on how
      to name modules.\n   A module typically has the following layout:\n     module
      <module-name> {\n       // header information\n       <yang-version statement>\n
      \      <namespace statement>\n       <prefix statement>\n       // linkage statements\n
      \      <import statements>\n       <include statements>\n       // meta-information\n
      \      <organization statement>\n       <contact statement>\n       <description
      statement>\n       <reference statement>\n       // revision history\n       <revision
      statements>\n       // module definitions\n       <other statements>\n     }\n"
    - contents:
      - "7.1.1.  The module's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | anydata      | 7.10    | 0..n        |\n                 |
        anyxml       | 7.11    | 0..n        |\n                 | augment      |
        7.17    | 0..n        |\n                 | choice       | 7.9     | 0..n
        \       |\n                 | contact      | 7.1.8   | 0..1        |\n                 |
        container    | 7.5     | 0..n        |\n                 | description  |
        7.21.3  | 0..1        |\n                 | deviation    | 7.20.3  | 0..n
        \       |\n                 | extension    | 7.19    | 0..n        |\n                 |
        feature      | 7.20.1  | 0..n        |\n                 | grouping     |
        7.12    | 0..n        |\n                 | identity     | 7.18    | 0..n
        \       |\n                 | import       | 7.1.5   | 0..n        |\n                 |
        include      | 7.1.6   | 0..n        |\n                 | leaf         |
        7.6     | 0..n        |\n                 | leaf-list    | 7.7     | 0..n
        \       |\n                 | list         | 7.8     | 0..n        |\n                 |
        namespace    | 7.1.3   | 1           |\n                 | notification |
        7.16    | 0..n        |\n                 | organization | 7.1.7   | 0..1
        \       |\n                 | prefix       | 7.1.4   | 1           |\n                 |
        reference    | 7.21.4  | 0..1        |\n                 | revision     |
        7.1.9   | 0..n        |\n                 | rpc          | 7.14    | 0..n
        \       |\n                 | typedef      | 7.3     | 0..n        |\n                 |
        uses         | 7.13    | 0..n        |\n                 | yang-version |
        7.1.2   | 1           |\n                 +--------------+---------+-------------+\n"
      title: 7.1.1.  The module's Substatements
    - contents:
      - "7.1.2.  The \"yang-version\" Statement\n   The \"yang-version\" statement
        specifies which version of the YANG\n   language was used in developing the
        module.  The statement's argument\n   is a string.  It MUST contain the value
        \"1.1\" for YANG modules\n   defined based on this specification.\n   A module
        or submodule that doesn't contain the \"yang-version\"\n   statement, or one
        that contains the value \"1\", is developed for YANG\n   version 1, defined
        in [RFC6020].\n   Handling of the \"yang-version\" statement for versions
        other than\n   \"1.1\" (the version defined here) is out of scope for this\n
        \  specification.  Any document that defines a higher version will need\n
        \  to define the backward compatibility of such a higher version.\n   For
        compatibility between YANG versions 1 and 1.1, see Section 12.\n"
      title: 7.1.2.  The "yang-version" Statement
    - contents:
      - "7.1.3.  The \"namespace\" Statement\n   The \"namespace\" statement defines
        the XML namespace that all\n   identifiers defined by the module are qualified
        by in the XML\n   encoding, with the exception of identifiers for data nodes,
        action\n   nodes, and notification nodes defined inside a grouping (see\n
        \  Section 7.13 for details).  The argument to the \"namespace\" statement\n
        \  is the URI of the namespace.\n   See also Section 5.3.\n"
      title: 7.1.3.  The "namespace" Statement
    - contents:
      - "7.1.4.  The \"prefix\" Statement\n   The \"prefix\" statement is used to
        define the prefix associated with\n   the module and its namespace.  The \"prefix\"
        statement's argument is\n   the prefix string that is used as a prefix to
        access a module.  The\n   prefix string MAY be used with the module to refer
        to definitions\n   contained in the module, e.g., \"if:ifName\".  A prefix
        is an\n   identifier (see Section 6.2).\n   When used inside the \"module\"
        statement, the \"prefix\" statement\n   defines the prefix suggested to be
        used when this module is imported.\n   To improve readability of the NETCONF
        XML, a NETCONF client or server\n   that generates XML or XPath that uses
        prefixes SHOULD use the prefix\n   defined by the module as the XML namespace
        prefix, unless there is a\n   conflict.\n   When used inside the \"import\"
        statement, the \"prefix\" statement\n   defines the prefix to be used when
        accessing definitions inside the\n   imported module.  When a reference to
        an identifier from the imported\n   module is used, the prefix string for
        the imported module followed by\n   a colon (\":\") and the identifier is
        used, e.g., \"if:ifIndex\".  To\n   improve readability of YANG modules, the
        prefix defined by a module\n   SHOULD be used when the module is imported,
        unless there is a\n   conflict.  If there is a conflict, i.e., two different
        modules that\n   both have defined the same prefix are imported, at least
        one of them\n   MUST be imported with a different prefix.\n   All prefixes,
        including the prefix for the module itself, MUST be\n   unique within the
        module or submodule.\n"
      title: 7.1.4.  The "prefix" Statement
    - contents:
      - "7.1.5.  The \"import\" Statement\n   The \"import\" statement makes definitions
        from one module available\n   inside another module or submodule.  The argument
        is the name of the\n   module to import, and the statement is followed by
        a block of\n   substatements that holds detailed import information.  When
        a module\n   is imported, the importing module may:\n   o  use any grouping
        and typedef defined at the top level in the\n      imported module or its
        submodules.\n   o  use any extension, feature, and identity defined in the
        imported\n      module or its submodules.\n   o  use any node in the imported
        module's schema tree in \"must\",\n      \"path\", and \"when\" statements,
        or as the target node in \"augment\"\n      and \"deviation\" statements.\n
        \  The mandatory \"prefix\" substatement assigns a prefix for the imported\n
        \  module that is scoped to the importing module or submodule.  Multiple\n
        \  \"import\" statements may be specified to import from different\n   modules.\n
        \  When the optional \"revision-date\" substatement is present, any\n   typedef,
        grouping, extension, feature, and identity referenced by\n   definitions in
        the local module are taken from the specified revision\n   of the imported
        module.  It is an error if the specified revision of\n   the imported module
        does not exist.  If no \"revision-date\"\n   substatement is present, it is
        undefined from which revision of the\n   module they are taken.\n   Multiple
        revisions of the same module can be imported, provided that\n   different
        prefixes are used.\n                 +---------------+---------+-------------+\n
        \                | substatement  | section | cardinality |\n                 +---------------+---------+-------------+\n
        \                | description   | 7.21.3  | 0..1        |\n                 |
        prefix        | 7.1.4   | 1           |\n                 | reference     |
        7.21.4  | 0..1        |\n                 | revision-date | 7.1.5.1 | 0..1
        \       |\n                 +---------------+---------+-------------+\n                        The
        import's Substatements\n"
      - contents:
        - "7.1.5.1.  The import's \"revision-date\" Statement\n   The import's \"revision-date\"
          statement is used to specify the version\n   of the module to import.\n"
        title: 7.1.5.1.  The import's "revision-date" Statement
      title: 7.1.5.  The "import" Statement
    - contents:
      - "7.1.6.  The \"include\" Statement\n   The \"include\" statement is used to
        make content from a submodule\n   available to that submodule's parent module.
        \ The argument is an\n   identifier that is the name of the submodule to include.
        \ Modules are\n   only allowed to include submodules that belong to that module,
        as\n   defined by the \"belongs-to\" statement (see Section 7.2.2).\n   When
        a module includes a submodule, it incorporates the contents of\n   the submodule
        into the node hierarchy of the module.\n   For backward compatibility with
        YANG version 1, a submodule is\n   allowed to include another submodule belonging
        to the same module,\n   but this is not necessary in YANG version 1.1 (see
        Section 5.1).\n   When the optional \"revision-date\" substatement is present,
        the\n   specified revision of the submodule is included in the module.  It
        is\n   an error if the specified revision of the submodule does not exist.\n
        \  If no \"revision-date\" substatement is present, it is undefined which\n
        \  revision of the submodule is included.\n   Multiple revisions of the same
        submodule MUST NOT be included.\n                 +---------------+---------+-------------+\n
        \                | substatement  | section | cardinality |\n                 +---------------+---------+-------------+\n
        \                | description   | 7.21.3  | 0..1        |\n                 |
        reference     | 7.21.4  | 0..1        |\n                 | revision-date
        | 7.1.5.1 | 0..1        |\n                 +---------------+---------+-------------+\n
        \                      The includes's Substatements\n"
      title: 7.1.6.  The "include" Statement
    - contents:
      - "7.1.7.  The \"organization\" Statement\n   The \"organization\" statement
        defines the party responsible for this\n   module.  The argument is a string
        that is used to specify a textual\n   description of the organization(s) under
        whose auspices this module\n   was developed.\n"
      title: 7.1.7.  The "organization" Statement
    - contents:
      - "7.1.8.  The \"contact\" Statement\n   The \"contact\" statement provides
        contact information for the module.\n   The argument is a string that is used
        to specify contact information\n   for the person or persons to whom technical
        queries concerning this\n   module should be sent, such as their name, postal
        address, telephone\n   number, and electronic mail address.\n"
      title: 7.1.8.  The "contact" Statement
    - contents:
      - "7.1.9.  The \"revision\" Statement\n   The \"revision\" statement specifies
        the editorial revision history of\n   the module, including the initial revision.
        \ A series of \"revision\"\n   statements detail the changes in the module's
        definition.  The\n   argument is a date string in the format \"YYYY-MM-DD\",
        followed by a\n   block of substatements that holds detailed revision information.
        \ A\n   module SHOULD have at least one \"revision\" statement.  For every\n
        \  published editorial change, a new one SHOULD be added in front of the\n
        \  revisions sequence so that all revisions are in reverse chronological\n
        \  order.\n"
      - contents:
        - "7.1.9.1.  The revision's Substatements\n                 +--------------+---------+-------------+\n
          \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
          \                | description  | 7.21.3  | 0..1        |\n                 |
          reference    | 7.21.4  | 0..1        |\n                 +--------------+---------+-------------+\n"
        title: 7.1.9.1.  The revision's Substatements
      title: 7.1.9.  The "revision" Statement
    - contents:
      - "7.1.10.  Usage Example\n   The following example relies on [RFC6991].\n     module
        example-system {\n       yang-version 1.1;\n       namespace \"urn:example:system\";\n
        \      prefix \"sys\";\n       import ietf-yang-types {\n         prefix \"yang\";\n
        \        reference \"RFC 6991: Common YANG Data Types\";\n       }\n       include
        example-types;\n       organization \"Example Inc.\";\n       contact\n         \"Joe
        L. User\n          Example Inc.\n          42 Anywhere Drive\n          Nowhere,
        CA 95134\n          USA\n          Phone: +1 800 555 0100\n          Email:
        joe@example.com\";\n       description\n         \"The module for entities
        implementing the Example system.\";\n       revision 2007-06-09 {\n         description
        \"Initial revision.\";\n       }\n       // definitions follow...\n     }\n"
      title: 7.1.10.  Usage Example
    title: 7.1.  The "module" Statement
  - contents:
    - "7.2.  The \"submodule\" Statement\n   While the primary unit in YANG is a module,
      a YANG module can itself\n   be constructed out of several submodules.  Submodules
      allow a module\n   designer to split a complex model into several pieces where
      all the\n   submodules contribute to a single namespace, which is defined by
      the\n   module that includes the submodules.\n   The \"submodule\" statement
      defines the submodule's name, and it groups\n   all statements that belong to
      the submodule together.  The\n   \"submodule\" statement's argument is the name
      of the submodule,\n   followed by a block of substatements that holds detailed
      submodule\n   information.  The submodule name is an identifier (see Section
      6.2).\n   Names of submodules published in RFC streams [RFC4844] MUST be\n   assigned
      by IANA; see Section 14 in [RFC6020].\n   Private submodule names are assigned
      by the organization owning the\n   submodule without a central registry.  See
      Section 5.1 for\n   recommendations on how to name submodules.\n   A submodule
      typically has the following layout:\n     submodule <module-name> {\n       <yang-version
      statement>\n       // module identification\n       <belongs-to statement>\n
      \      // linkage statements\n       <import statements>\n       // meta-information\n
      \      <organization statement>\n       <contact statement>\n       <description
      statement>\n       <reference statement>\n       // revision history\n       <revision
      statements>\n       // module definitions\n       <other statements>\n     }\n"
    - contents:
      - "7.2.1.  The submodule's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | anydata      | 7.10    | 0..n        |\n                 |
        anyxml       | 7.11    | 0..n        |\n                 | augment      |
        7.17    | 0..n        |\n                 | belongs-to   | 7.2.2   | 1           |\n
        \                | choice       | 7.9     | 0..n        |\n                 |
        contact      | 7.1.8   | 0..1        |\n                 | container    |
        7.5     | 0..n        |\n                 | description  | 7.21.3  | 0..1
        \       |\n                 | deviation    | 7.20.3  | 0..n        |\n                 |
        extension    | 7.19    | 0..n        |\n                 | feature      |
        7.20.1  | 0..n        |\n                 | grouping     | 7.12    | 0..n
        \       |\n                 | identity     | 7.18    | 0..n        |\n                 |
        import       | 7.1.5   | 0..n        |\n                 | include      |
        7.1.6   | 0..n        |\n                 | leaf         | 7.6     | 0..n
        \       |\n                 | leaf-list    | 7.7     | 0..n        |\n                 |
        list         | 7.8     | 0..n        |\n                 | notification |
        7.16    | 0..n        |\n                 | organization | 7.1.7   | 0..1
        \       |\n                 | reference    | 7.21.4  | 0..1        |\n                 |
        revision     | 7.1.9   | 0..n        |\n                 | rpc          |
        7.14    | 0..n        |\n                 | typedef      | 7.3     | 0..n
        \       |\n                 | uses         | 7.13    | 0..n        |\n                 |
        yang-version | 7.1.2   | 1           |\n                 +--------------+---------+-------------+\n"
      title: 7.2.1.  The submodule's Substatements
    - contents:
      - "7.2.2.  The \"belongs-to\" Statement\n   The \"belongs-to\" statement specifies
        the module to which the\n   submodule belongs.  The argument is an identifier
        that is the name of\n   the module.\n   A submodule MUST only be included
        by either the module to which it\n   belongs or another submodule that belongs
        to that module.\n   The mandatory \"prefix\" substatement assigns a prefix
        for the module\n   to which the submodule belongs.  All definitions in the
        module that\n   the submodule belongs to and all its submodules can be accessed
        by\n   using the prefix.\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | prefix       | 7.1.4   | 1           |\n                 +--------------+---------+-------------+\n
        \                      The belongs-to's Substatement\n"
      title: 7.2.2.  The "belongs-to" Statement
    - contents:
      - "7.2.3.  Usage Example\n     submodule example-types {\n       yang-version
        1.1;\n       belongs-to \"example-system\" {\n         prefix \"sys\";\n       }\n
        \      import ietf-yang-types {\n         prefix \"yang\";\n       }\n       organization
        \"Example Inc.\";\n       contact\n         \"Joe L. User\n          Example
        Inc.\n          42 Anywhere Drive\n          Nowhere, CA 95134\n          USA\n
        \         Phone: +1 800 555 0100\n          Email: joe@example.com\";\n       description\n
        \        \"This submodule defines common Example types.\";\n       revision
        \"2007-06-09\" {\n         description \"Initial revision.\";\n       }\n
        \      // definitions follow...\n     }\n"
      title: 7.2.3.  Usage Example
    title: 7.2.  The "submodule" Statement
  - contents:
    - "7.3.  The \"typedef\" Statement\n   The \"typedef\" statement defines a new
      type that may be used locally\n   in the module or submodule, and by other modules
      that import from it,\n   according to the rules in Section 5.5.  The new type
      is called the\n   \"derived type\", and the type from which it was derived is
      called the\n   \"base type\".  All derived types can be traced back to a YANG\n
      \  built-in type.\n   The \"typedef\" statement's argument is an identifier
      that is the name\n   of the type to be defined and MUST be followed by a block
      of\n   substatements that holds detailed typedef information.\n   The name of
      the type MUST NOT be one of the YANG built-in types.  If\n   the typedef is
      defined at the top level of a YANG module or\n   submodule, the name of the
      type to be defined MUST be unique within\n   the module.\n"
    - contents:
      - "7.3.1.  The typedef's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | default      | 7.3.4   | 0..1        |\n                 |
        description  | 7.21.3  | 0..1        |\n                 | reference    |
        7.21.4  | 0..1        |\n                 | status       | 7.21.2  | 0..1
        \       |\n                 | type         | 7.3.2   | 1           |\n                 |
        units        | 7.3.3   | 0..1        |\n                 +--------------+---------+-------------+\n"
      title: 7.3.1.  The typedef's Substatements
    - contents:
      - "7.3.2.  The typedef's \"type\" Statement\n   The \"type\" statement, which
        MUST be present, defines the base type\n   from which this type is derived.
        \ See Section 7.4 for details.\n"
      title: 7.3.2.  The typedef's "type" Statement
    - contents:
      - "7.3.3.  The \"units\" Statement\n   The \"units\" statement, which is optional,
        takes as an argument a\n   string that contains a textual definition of the
        units associated\n   with the type.\n"
      title: 7.3.3.  The "units" Statement
    - contents:
      - "7.3.4.  The typedef's \"default\" Statement\n   The \"default\" statement
        takes as an argument a string that contains a\n   default value for the new
        type.\n   The value of the \"default\" statement MUST be valid according to
        the\n   type specified in the \"type\" statement.\n   If the base type has
        a default value and the new derived type does\n   not specify a new default
        value, the base type's default value is\n   also the default value of the
        new derived type.\n   If the type's default value is not valid according to
        the new\n   restrictions specified in a derived type or leaf definition, the\n
        \  derived type or leaf definition MUST specify a new default value\n   compatible
        with the restrictions.\n"
      title: 7.3.4.  The typedef's "default" Statement
    - contents:
      - "7.3.5.  Usage Example\n     typedef listen-ipv4-address {\n       type inet:ipv4-address;\n
        \      default \"0.0.0.0\";\n     }\n"
      title: 7.3.5.  Usage Example
    title: 7.3.  The "typedef" Statement
  - contents:
    - "7.4.  The \"type\" Statement\n   The \"type\" statement takes as an argument
      a string that is the name\n   of a YANG built-in type (see Section 9) or a derived
      type (see\n   Section 7.3), followed by an optional block of substatements that
      is\n   used to put further restrictions on the type.\n   The restrictions that
      can be applied depend on the type being\n   restricted.  The restriction statements
      for all built-in types are\n   described in the subsections of Section 9.\n"
    - contents:
      - "7.4.1.  The type's Substatements\n               +------------------+---------+-------------+\n
        \              | substatement     | section | cardinality |\n               +------------------+---------+-------------+\n
        \              | base             | 7.18.2  | 0..n        |\n               |
        bit              | 9.7.4   | 0..n        |\n               | enum             |
        9.6.4   | 0..n        |\n               | fraction-digits  | 9.3.4   | 0..1
        \       |\n               | length           | 9.4.4   | 0..1        |\n               |
        path             | 9.9.2   | 0..1        |\n               | pattern          |
        9.4.5   | 0..n        |\n               | range            | 9.2.4   | 0..1
        \       |\n               | require-instance | 9.9.3   | 0..1        |\n               |
        type             | 7.4     | 0..n        |\n               +------------------+---------+-------------+\n"
      title: 7.4.1.  The type's Substatements
    title: 7.4.  The "type" Statement
  - contents:
    - "7.5.  The \"container\" Statement\n   The \"container\" statement is used to
      define an interior data node in\n   the schema tree.  It takes one argument,
      which is an identifier,\n   followed by a block of substatements that holds
      detailed container\n   information.\n   A container node does not have a value,
      but it has a list of child\n   nodes in the data tree.  The child nodes are
      defined in the\n   container's substatements.\n"
    - contents:
      - "7.5.1.  Containers with Presence\n   YANG supports two styles of containers,
        those that exist only for\n   organizing the hierarchy of data nodes and those
        whose presence in\n   the data tree has an explicit meaning.\n   In the first
        style, the container has no meaning of its own, existing\n   only to contain
        child nodes.  In particular, the presence of the\n   container node with no
        child nodes is semantically equivalent to the\n   absence of the container
        node.  YANG calls this style a \"non-presence\n   container\".  This is the
        default style.\n   For example, the set of scrambling options for Synchronous
        Optical\n   Network (SONET) interfaces may be placed inside a \"scrambling\"\n
        \  container to enhance the organization of the configuration hierarchy\n
        \  and to keep these nodes together.  The \"scrambling\" node itself has\n
        \  no meaning, so removing the node when it becomes empty relieves the\n   user
        from performing this task.\n   In the second style, the presence of the container
        itself carries\n   some meaning, representing a single bit of data.\n   For
        configuration data, the container acts as both a configuration\n   knob and
        a means of organizing related configuration nodes.  These\n   containers are
        explicitly created and deleted.\n   YANG calls this style a \"presence container\",
        and it is indicated\n   using the \"presence\" statement, which takes as its
        argument a text\n   string indicating what the presence of the node means.\n
        \  For example, an \"ssh\" container may turn on the ability to log into\n
        \  the server using Secure SHell (SSH) but can also contain any\n   SSH-related
        configuration knobs, such as connection rates or retry\n   limits.\n   The
        \"presence\" statement (see Section 7.5.5) is used to give\n   semantics to
        the existence of the container in the data tree.\n"
      title: 7.5.1.  Containers with Presence
    - contents:
      - "7.5.2.  The container's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | action       | 7.15    | 0..n        |\n                 |
        anydata      | 7.10    | 0..n        |\n                 | anyxml       |
        7.11    | 0..n        |\n                 | choice       | 7.9     | 0..n
        \       |\n                 | config       | 7.21.1  | 0..1        |\n                 |
        container    | 7.5     | 0..n        |\n                 | description  |
        7.21.3  | 0..1        |\n                 | grouping     | 7.12    | 0..n
        \       |\n                 | if-feature   | 7.20.2  | 0..n        |\n                 |
        leaf         | 7.6     | 0..n        |\n                 | leaf-list    |
        7.7     | 0..n        |\n                 | list         | 7.8     | 0..n
        \       |\n                 | must         | 7.5.3   | 0..n        |\n                 |
        notification | 7.16    | 0..n        |\n                 | presence     |
        7.5.5   | 0..1        |\n                 | reference    | 7.21.4  | 0..1
        \       |\n                 | status       | 7.21.2  | 0..1        |\n                 |
        typedef      | 7.3     | 0..n        |\n                 | uses         |
        7.13    | 0..n        |\n                 | when         | 7.21.5  | 0..1
        \       |\n                 +--------------+---------+-------------+\n"
      title: 7.5.2.  The container's Substatements
    - contents:
      - "7.5.3.  The \"must\" Statement\n   The \"must\" statement, which is optional,
        takes as an argument a\n   string that contains an XPath expression (see Section
        6.4).  It is\n   used to formally declare a constraint on valid data.  The
        constraint\n   is enforced according to the rules in Section 8.\n   When a
        datastore is validated, all \"must\" constraints are\n   conceptually evaluated
        once for each node in the accessible tree (see\n   Section 6.4.1).\n   All
        such constraints MUST evaluate to \"true\" for the data to be\n   valid.\n
        \  The XPath expression is conceptually evaluated in the following\n   context,
        in addition to the definition in Section 6.4.1:\n   o  If the \"must\" statement
        is a substatement of a \"notification\"\n      statement, the context node
        is the node representing the\n      notification in the accessible tree.\n
        \  o  If the \"must\" statement is a substatement of an \"input\" statement,\n
        \     the context node is the node representing the operation in the\n      accessible
        tree.\n   o  If the \"must\" statement is a substatement of an \"output\"\n
        \     statement, the context node is the node representing the operation\n
        \     in the accessible tree.\n   o  Otherwise, the context node is the node
        in the accessible tree for\n      which the \"must\" statement is defined.\n
        \  The result of the XPath expression is converted to a boolean value\n   using
        the standard XPath rules.\n   Note that since all leaf values in the data
        tree are conceptually\n   stored in their canonical form (see Section 9.1),
        any XPath\n   comparisons are done on the canonical value.\n   Also note that
        the XPath expression is conceptually evaluated.  This\n   means that an implementation
        does not have to use an XPath evaluator\n   in the server.  How the evaluation
        is done in practice is an\n   implementation decision.\n"
      title: 7.5.3.  The "must" Statement
    - contents:
      - "7.5.4.  The must's Substatements\n                 +---------------+---------+-------------+\n
        \                | substatement  | section | cardinality |\n                 +---------------+---------+-------------+\n
        \                | description   | 7.21.3  | 0..1        |\n                 |
        error-app-tag | 7.5.4.2 | 0..1        |\n                 | error-message
        | 7.5.4.1 | 0..1        |\n                 | reference     | 7.21.4  | 0..1
        \       |\n                 +---------------+---------+-------------+\n"
      - contents:
        - "7.5.4.1.  The \"error-message\" Statement\n   The \"error-message\" statement,
          which is optional, takes a string as\n   an argument.  If the constraint
          evaluates to \"false\", the string is\n   passed as <error-message> in the
          <rpc-error> in NETCONF.\n"
        title: 7.5.4.1.  The "error-message" Statement
      - contents:
        - "7.5.4.2.  The \"error-app-tag\" Statement\n   The \"error-app-tag\" statement,
          which is optional, takes a string as\n   an argument.  If the constraint
          evaluates to \"false\", the string is\n   passed as <error-app-tag> in the
          <rpc-error> in NETCONF.\n"
        title: 7.5.4.2.  The "error-app-tag" Statement
      - contents:
        - "7.5.4.3.  Usage Example of must and error-message\n     container interface
          {\n       leaf ifType {\n         type enumeration {\n           enum ethernet;\n
          \          enum atm;\n         }\n       }\n       leaf ifMTU {\n         type
          uint32;\n       }\n       must 'ifType != \"ethernet\" or ifMTU = 1500'
          {\n         error-message \"An Ethernet MTU must be 1500\";\n       }\n
          \      must 'ifType != \"atm\" or'\n          + ' (ifMTU <= 17966 and ifMTU
          >= 64)' {\n         error-message \"An ATM MTU must be 64 .. 17966\";\n
          \      }\n     }\n"
        title: 7.5.4.3.  Usage Example of must and error-message
      title: 7.5.4.  The must's Substatements
    - contents:
      - "7.5.5.  The \"presence\" Statement\n   The \"presence\" statement assigns
        a meaning to the presence of a\n   container in the data tree.  It takes as
        an argument a string that\n   contains a textual description of what the node's
        presence means.\n   If a container has the \"presence\" statement, the container's\n
        \  existence in the data tree carries some meaning.  Otherwise, the\n   container
        is used to give some structure to the data, and it carries\n   no meaning
        by itself.\n   See Section 7.5.1 for additional information.\n"
      title: 7.5.5.  The "presence" Statement
    - contents:
      - "7.5.6.  The container's Child Node Statements\n   Within a container, the
        \"container\", \"leaf\", \"list\", \"leaf-list\",\n   \"uses\", \"choice\",
        \"anydata\", and \"anyxml\" statements can be used to\n   define child nodes
        to the container.\n"
      title: 7.5.6.  The container's Child Node Statements
    - contents:
      - "7.5.7.  XML Encoding Rules\n   A container node is encoded as an XML element.
        \ The element's local\n   name is the container's identifier, and its namespace
        is the module's\n   XML namespace (see Section 7.1.3).\n   The container's
        child nodes are encoded as subelements to the\n   container element.  If the
        container defines RPC or action input or\n   output parameters, these subelements
        are encoded in the same order as\n   they are defined within the \"container\"
        statement.  Otherwise, the\n   subelements are encoded in any order.\n   Any
        whitespace between the subelements to the container is\n   insignificant,
        i.e., an implementation MAY insert whitespace\n   characters between subelements.\n
        \  If a non-presence container does not have any child nodes, the\n   container
        may or may not be present in the XML encoding.\n"
      title: 7.5.7.  XML Encoding Rules
    - contents:
      - "7.5.8.  NETCONF <edit-config> Operations\n   Containers can be created, deleted,
        replaced, and modified through\n   <edit-config> by using the \"operation\"
        attribute (see Section 7.2 in\n   [RFC6241]) in the container's XML element.\n
        \  If a container does not have a \"presence\" statement and the last\n   child
        node is deleted, the NETCONF server MAY delete the container.\n   When a NETCONF
        server processes an <edit-config> request, the\n   elements of procedure for
        the container node are as follows:\n   o  If the operation is \"merge\" or
        \"replace\", the node is created if\n      it does not exist.\n   o  If the
        operation is \"create\", the node is created if it does not\n      exist.
        \ If the node already exists, a \"data-exists\" error is\n      returned.\n
        \  o  If the operation is \"delete\", the node is deleted if it exists.\n
        \     If the node does not exist, a \"data-missing\" error is returned.\n"
      title: 7.5.8.  NETCONF <edit-config> Operations
    - contents:
      - "7.5.9.  Usage Example\n   Given the following container definition:\n     container
        system {\n       description\n         \"Contains various system parameters.\";\n
        \      container services {\n         description\n           \"Configure
        externally available services.\";\n         container \"ssh\" {\n           presence
        \"Enables SSH\";\n           description\n             \"SSH service-specific
        configuration.\";\n           // more leafs, containers, and stuff here...\n
        \        }\n       }\n     }\n   A corresponding XML instance example:\n     <system>\n
        \      <services>\n         <ssh/>\n       </services>\n     </system>\n   Since
        the <ssh> element is present, SSH is enabled.\n   To delete a container with
        an <edit-config>:\n     <rpc message-id=\"101\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
        \         xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n       <edit-config>\n
        \        <target>\n           <running/>\n         </target>\n         <config>\n
        \          <system xmlns=\"urn:example:config\">\n             <services>\n
        \              <ssh nc:operation=\"delete\"/>\n             </services>\n
        \          </system>\n         </config>\n       </edit-config>\n     </rpc>\n"
      title: 7.5.9.  Usage Example
    title: 7.5.  The "container" Statement
  - contents:
    - "7.6.  The \"leaf\" Statement\n   The \"leaf\" statement is used to define a
      leaf node in the schema\n   tree.  It takes one argument, which is an identifier,
      followed by a\n   block of substatements that holds detailed leaf information.\n
      \  A leaf node has a value, but no child nodes, in the data tree.\n   Conceptually,
      the value in the data tree is always in the canonical\n   form (see Section
      9.1).\n   A leaf node exists in zero or one instance in the data tree.\n   The
      \"leaf\" statement is used to define a scalar variable of a\n   particular built-in
      or derived type.\n"
    - contents:
      - "7.6.1.  The leaf's Default Value\n   The default value of a leaf is the value
        that the server uses if the\n   leaf does not exist in the data tree.  The
        usage of the default value\n   depends on the leaf's closest ancestor node
        in the schema tree that\n   is not a non-presence container (see Section 7.5.1):\n
        \  o  If no such ancestor exists in the schema tree, the default value\n      MUST
        be used.\n   o  Otherwise, if this ancestor is a case node, the default value
        MUST\n      be used if any node from the case exists in the data tree or the\n
        \     case node is the choice's default case, and if no nodes from any\n      other
        case exist in the data tree.\n   o  Otherwise, the default value MUST be used
        if the ancestor node\n      exists in the data tree.\n   In these cases, the
        default value is said to be in use.\n   Note that if the leaf or any of its
        ancestors has a \"when\" condition\n   or \"if-feature\" expression that evaluates
        to \"false\", then the\n   default value is not in use.\n   When the default
        value is in use, the server MUST operationally\n   behave as if the leaf was
        present in the data tree with the default\n   value as its value.\n   If a
        leaf has a \"default\" statement, the leaf's default value is the\n   value
        of the \"default\" statement.  Otherwise, if the leaf's type has\n   a default
        value and the leaf is not mandatory, then the leaf's\n   default value is
        the type's default value.  In all other cases, the\n   leaf does not have
        a default value.\n"
      title: 7.6.1.  The leaf's Default Value
    - contents:
      - "7.6.2.  The leaf's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | config       | 7.21.1  | 0..1        |\n                 |
        default      | 7.6.4   | 0..1        |\n                 | description  |
        7.21.3  | 0..1        |\n                 | if-feature   | 7.20.2  | 0..n
        \       |\n                 | mandatory    | 7.6.5   | 0..1        |\n                 |
        must         | 7.5.3   | 0..n        |\n                 | reference    |
        7.21.4  | 0..1        |\n                 | status       | 7.21.2  | 0..1
        \       |\n                 | type         | 7.6.3   | 1           |\n                 |
        units        | 7.3.3   | 0..1        |\n                 | when         |
        7.21.5  | 0..1        |\n                 +--------------+---------+-------------+\n"
      title: 7.6.2.  The leaf's Substatements
    - contents:
      - "7.6.3.  The leaf's \"type\" Statement\n   The \"type\" statement, which MUST
        be present, takes as an argument the\n   name of an existing built-in or derived
        type.  The optional\n   substatements specify restrictions on this type.  See
        Section 7.4 for\n   details.\n"
      title: 7.6.3.  The leaf's "type" Statement
    - contents:
      - "7.6.4.  The leaf's \"default\" Statement\n   The \"default\" statement, which
        is optional, takes as an argument a\n   string that contains a default value
        for the leaf.\n   The value of the \"default\" statement MUST be valid according
        to the\n   type specified in the leaf's \"type\" statement.\n   The \"default\"
        statement MUST NOT be present on nodes where\n   \"mandatory\" is \"true\".\n
        \  The definition of the default value MUST NOT be marked with an\n   \"if-feature\"
        statement.  For example, the following is illegal:\n     leaf color {\n       type
        enumeration {\n         enum blue { if-feature blue; }\n         ...\n       }\n
        \      default blue; // illegal - enum value is conditional\n     }\n"
      title: 7.6.4.  The leaf's "default" Statement
    - contents:
      - "7.6.5.  The leaf's \"mandatory\" Statement\n   The \"mandatory\" statement,
        which is optional, takes as an argument\n   the string \"true\" or \"false\"
        and puts a constraint on valid data.  If\n   not specified, the default is
        \"false\".\n   If \"mandatory\" is \"true\", the behavior of the constraint
        depends on\n   the type of the leaf's closest ancestor node in the schema
        tree that\n   is not a non-presence container (see Section 7.5.1):\n   o  If
        no such ancestor exists in the schema tree, the leaf MUST\n      exist.\n
        \  o  Otherwise, if this ancestor is a case node, the leaf MUST exist if\n
        \     any node from the case exists in the data tree.\n   o  Otherwise, the
        leaf MUST exist if the ancestor node exists in the\n      data tree.\n   This
        constraint is enforced according to the rules in Section 8.\n"
      title: 7.6.5.  The leaf's "mandatory" Statement
    - contents:
      - "7.6.6.  XML Encoding Rules\n   A leaf node is encoded as an XML element.
        \ The element's local name\n   is the leaf's identifier, and its namespace
        is the module's XML\n   namespace (see Section 7.1.3).\n   The value of the
        leaf node is encoded to XML according to the type\n   and is sent as character
        data in the element.\n   See Section 7.6.8 for an example.\n"
      title: 7.6.6.  XML Encoding Rules
    - contents:
      - "7.6.7.  NETCONF <edit-config> Operations\n   When a NETCONF server processes
        an <edit-config> request, the\n   elements of procedure for the leaf node
        are as follows:\n   o  If the operation is \"merge\" or \"replace\", the node
        is created if\n      it does not exist, and its value is set to the value
        found in the\n      XML RPC data.\n   o  If the operation is \"create\", the
        node is created if it does not\n      exist.  If the node already exists,
        a \"data-exists\" error is\n      returned.\n   o  If the operation is \"delete\",
        the node is deleted if it exists.\n      If the node does not exist, a \"data-missing\"
        error is returned.\n"
      title: 7.6.7.  NETCONF <edit-config> Operations
    - contents:
      - "7.6.8.  Usage Example\n   Given the following \"leaf\" statement, placed
        in the previously\n   defined \"ssh\" container (see Section 7.5.9):\n     leaf
        port {\n       type inet:port-number;\n       default 22;\n       description\n
        \        \"The port to which the SSH server listens.\";\n     }\n   A corresponding
        XML instance example:\n     <port>2022</port>\n   To set the value of a leaf
        with an <edit-config>:\n     <rpc message-id=\"101\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
        \         xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n       <edit-config>\n
        \        <target>\n           <running/>\n         </target>\n         <config>\n
        \          <system xmlns=\"urn:example:config\">\n             <services>\n
        \              <ssh>\n                 <port>2022</port>\n               </ssh>\n
        \            </services>\n           </system>\n         </config>\n       </edit-config>\n
        \    </rpc>\n"
      title: 7.6.8.  Usage Example
    title: 7.6.  The "leaf" Statement
  - contents:
    - "7.7.  The \"leaf-list\" Statement\n   Where the \"leaf\" statement is used
      to define a simple scalar variable\n   of a particular type, the \"leaf-list\"
      statement is used to define an\n   array of a particular type.  The \"leaf-list\"
      statement takes one\n   argument, which is an identifier, followed by a block
      of\n   substatements that holds detailed leaf-list information.\n   In configuration
      data, the values in a leaf-list MUST be unique.\n   The definitions of the default
      values MUST NOT be marked with an\n   \"if-feature\" statement.\n   Conceptually,
      the values in the data tree MUST be in the canonical\n   form (see Section 9.1).\n"
    - contents:
      - "7.7.1.  Ordering\n   YANG supports two styles for ordering the entries within
        lists and\n   leaf-lists.  In many lists, the order of list entries does not
        impact\n   the implementation of the list's configuration, and the server
        is\n   free to sort the list entries in any reasonable order.  The\n   \"description\"
        string for the list may suggest an order to the server\n   implementor.  YANG
        calls this style of list \"system ordered\"; such\n   lists are indicated
        with the statement \"ordered-by system\".\n   For example, a list of valid
        users would typically be sorted\n   alphabetically, since the order in which
        the users appeared in the\n   configuration would not impact the creation
        of those users' accounts.\n   In the other style of lists, the order of list
        entries matters for\n   the implementation of the list's configuration and
        the user is\n   responsible for ordering the entries, while the server maintains
        that\n   order.  YANG calls this style of list \"user ordered\"; such lists
        are\n   indicated with the statement \"ordered-by user\".\n   For example,
        the order in which packet filter entries are applied to\n   incoming traffic
        may affect how that traffic is filtered.  The user\n   would need to decide
        if the filter entry that discards all TCP\n   traffic should be applied before
        or after the filter entry that\n   allows all traffic from trusted interfaces.
        \ The choice of order\n   would be crucial.\n   YANG provides a rich set of
        facilities within NETCONF's <edit-config>\n   operation that allows the order
        of list entries in user-ordered lists\n   to be controlled.  List entries
        may be inserted or rearranged,\n   positioned as the first or last entry in
        the list, or positioned\n   before or after another specific entry.\n   The
        \"ordered-by\" statement is covered in Section 7.7.7.\n"
      title: 7.7.1.  Ordering
    - contents:
      - "7.7.2.  The leaf-list's Default Values\n   The default values of a leaf-list
        are the values that the server uses\n   if the leaf-list does not exist in
        the data tree.  The usage of the\n   default values depends on the leaf-list's
        closest ancestor node in\n   the schema tree that is not a non-presence container
        (see\n   Section 7.5.1):\n   o  If no such ancestor exists in the schema tree,
        the default values\n      MUST be used.\n   o  Otherwise, if this ancestor
        is a case node, the default values\n      MUST be used if any node from the
        case exists in the data tree or\n      the case node is the choice's default
        case, and if no nodes from\n      any other case exist in the data tree.\n
        \  o  Otherwise, the default values MUST be used if the ancestor node\n      exists
        in the data tree.\n   In these cases, the default values are said to be in
        use.\n   Note that if the leaf-list or any of its ancestors has a \"when\"\n
        \  condition or \"if-feature\" expression that evaluates to \"false\", then\n
        \  the default values are not in use.\n   When the default values are in use,
        the server MUST operationally\n   behave as if the leaf-list was present in
        the data tree with the\n   default values as its values.\n   If a leaf-list
        has one or more \"default\" statements, the leaf-list's\n   default values
        are the values of the \"default\" statements, and if the\n   leaf-list is
        user ordered, the default values are used in the order\n   of the \"default\"
        statements.  Otherwise, if the leaf-list's type has\n   a default value and
        the leaf-list does not have a \"min-elements\"\n   statement with a value
        greater than or equal to one, then the\n   leaf-list's default value is one
        instance of the type's default\n   value.  In all other cases, the leaf-list
        does not have any default\n   values.\n"
      title: 7.7.2.  The leaf-list's Default Values
    - contents:
      - "7.7.3.  The leaf-list's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | config       | 7.21.1  | 0..1        |\n                 |
        default      | 7.7.4   | 0..n        |\n                 | description  |
        7.21.3  | 0..1        |\n                 | if-feature   | 7.20.2  | 0..n
        \       |\n                 | max-elements | 7.7.6   | 0..1        |\n                 |
        min-elements | 7.7.5   | 0..1        |\n                 | must         |
        7.5.3   | 0..n        |\n                 | ordered-by   | 7.7.7   | 0..1
        \       |\n                 | reference    | 7.21.4  | 0..1        |\n                 |
        status       | 7.21.2  | 0..1        |\n                 | type         |
        7.4     | 1           |\n                 | units        | 7.3.3   | 0..1
        \       |\n                 | when         | 7.21.5  | 0..1        |\n                 +--------------+---------+-------------+\n"
      title: 7.7.3.  The leaf-list's Substatements
    - contents:
      - "7.7.4.  The leaf-list's \"default\" Statement\n   The \"default\" statement,
        which is optional, takes as an argument a\n   string that contains a default
        value for the leaf-list.\n   The value of the \"default\" statement MUST be
        valid according to the\n   type specified in the leaf-list's \"type\" statement.\n
        \  The \"default\" statement MUST NOT be present on nodes where\n   \"min-elements\"
        has a value greater than or equal to one.\n"
      title: 7.7.4.  The leaf-list's "default" Statement
    - contents:
      - "7.7.5.  The \"min-elements\" Statement\n   The \"min-elements\" statement,
        which is optional, takes as an argument\n   a non-negative integer that puts
        a constraint on valid list entries.\n   A valid leaf-list or list MUST have
        at least min-elements entries.\n   If no \"min-elements\" statement is present,
        it defaults to zero.\n   The behavior of the constraint depends on the type
        of the leaf-list's\n   or list's closest ancestor node in the schema tree
        that is not a\n   non-presence container (see Section 7.5.1):\n   o  If no
        such ancestor exists in the schema tree, the constraint is\n      enforced.\n
        \  o  Otherwise, if this ancestor is a case node, the constraint is\n      enforced
        if any other node from the case exists.\n   o  Otherwise, it is enforced if
        the ancestor node exists.\n   The constraint is further enforced according
        to the rules in\n   Section 8.\n"
      title: 7.7.5.  The "min-elements" Statement
    - contents:
      - "7.7.6.  The \"max-elements\" Statement\n   The \"max-elements\" statement,
        which is optional, takes as an argument\n   a positive integer or the string
        \"unbounded\", which puts a constraint\n   on valid list entries.  A valid
        leaf-list or list always has at most\n   max-elements entries.\n   If no \"max-elements\"
        statement is present, it defaults to\n   \"unbounded\".\n   The \"max-elements\"
        constraint is enforced according to the rules in\n   Section 8.\n"
      title: 7.7.6.  The "max-elements" Statement
    - contents:
      - "7.7.7.  The \"ordered-by\" Statement\n   The \"ordered-by\" statement defines
        whether the order of entries\n   within a list are determined by the user
        or the system.  The argument\n   is one of the strings \"system\" or \"user\".
        \ If not present, ordering\n   defaults to \"system\".\n   This statement
        is ignored if the list represents state data, RPC\n   output parameters, or
        notification content.\n   See Section 7.7.1 for additional information.\n"
      - contents:
        - "7.7.7.1.  ordered-by system\n   The entries in the list are ordered according
          to an order determined\n   by the system.  The \"description\" string for
          the list may suggest an\n   order to the server implementor.  If not, an
          implementation is free\n   to order the entries in any order.  An implementation
          SHOULD use the\n   same order for the same data, regardless of how the data
          were\n   created.  Using a deterministic order will make comparisons possible\n
          \  using simple tools like \"diff\".\n   This is the default order.\n"
        title: 7.7.7.1.  ordered-by system
      - contents:
        - "7.7.7.2.  ordered-by user\n   The entries in the list are ordered according
          to an order defined by\n   the user.  In NETCONF, this order is controlled
          by using special XML\n   attributes in the <edit-config> request.  See Section
          7.7.9 for\n   details.\n"
        title: 7.7.7.2.  ordered-by user
      title: 7.7.7.  The "ordered-by" Statement
    - contents:
      - "7.7.8.  XML Encoding Rules\n   A leaf-list node is encoded as a series of
        XML elements.  Each\n   element's local name is the leaf-list's identifier,
        and its namespace\n   is the module's XML namespace (see Section 7.1.3).\n
        \  The value of each leaf-list entry is encoded to XML according to the\n
        \  type and is sent as character data in the element.\n   The XML elements
        representing leaf-list entries MUST appear in the\n   order specified by the
        user if the leaf-list is \"ordered-by user\";\n   otherwise, the order is
        implementation dependent.  The XML elements\n   representing leaf-list entries
        MAY be interleaved with elements for\n   siblings of the leaf-list, unless
        the leaf-list defines RPC or action\n   input or output parameters.\n   See
        Section 7.7.10 for an example.\n"
      title: 7.7.8.  XML Encoding Rules
    - contents:
      - "7.7.9.  NETCONF <edit-config> Operations\n   Leaf-list entries can be created
        and deleted, but not modified,\n   through <edit-config>, by using the \"operation\"
        attribute in the\n   leaf-list entry's XML element.\n   In an \"ordered-by
        user\" leaf-list, the attributes \"insert\" and\n   \"value\" in the YANG
        XML namespace (Section 5.3.1) can be used to\n   control where in the leaf-list
        the entry is inserted.  These can be\n   used during \"create\" operations
        to insert a new leaf-list entry, or\n   during \"merge\" or \"replace\" operations
        to insert a new leaf-list\n   entry or move an existing one.\n   The \"insert\"
        attribute can take the values \"first\", \"last\", \"before\",\n   and \"after\".
        \ If the value is \"before\" or \"after\", the \"value\"\n   attribute MUST
        also be used to specify an existing entry in the\n   leaf-list.\n   If no
        \"insert\" attribute is present in the \"create\" operation, it\n   defaults
        to \"last\".\n   If several entries in an \"ordered-by user\" leaf-list are
        modified in\n   the same <edit-config> request, the entries are modified one
        at a\n   time, in the order of the XML elements in the request.\n   In a <copy-config>
        or in an <edit-config> with a \"replace\" operation\n   that covers the entire
        leaf-list, the leaf-list order is the same as\n   the order of the XML elements
        in the request.\n   When a NETCONF server processes an <edit-config> request,
        the\n   elements of procedure for a leaf-list node are as follows:\n   o  If
        the operation is \"merge\" or \"replace\", the leaf-list entry is\n      created
        if it does not exist.\n   o  If the operation is \"create\", the leaf-list
        entry is created if it\n      does not exist.  If the leaf-list entry already
        exists, a\n      \"data-exists\" error is returned.\n   o  If the operation
        is \"delete\", the entry is deleted from the\n      leaf-list if it exists.
        \ If the leaf-list entry does not exist, a\n      \"data-missing\" error is
        returned.\n"
      title: 7.7.9.  NETCONF <edit-config> Operations
    - contents:
      - "7.7.10.  Usage Example\n     leaf-list allow-user {\n       type string;\n
        \      description\n         \"A list of user name patterns to allow.\";\n
        \    }\n   A corresponding XML instance example:\n     <allow-user>alice</allow-user>\n
        \    <allow-user>bob</allow-user>\n   To create a new element in this list,
        using the default <edit-config>\n   operation \"merge\":\n     <rpc message-id=\"101\"\n
        \         xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n          xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
        \      <edit-config>\n         <target>\n           <running/>\n         </target>\n
        \        <config>\n           <system xmlns=\"urn:example:config\">\n             <services>\n
        \              <ssh>\n                 <allow-user>eric</allow-user>\n               </ssh>\n
        \            </services>\n           </system>\n         </config>\n       </edit-config>\n
        \    </rpc>\n   Given the following ordered-by user leaf-list:\n     leaf-list
        cipher {\n       type string;\n       ordered-by user;\n       description\n
        \        \"A list of ciphers.\";\n     }\n   The following would be used to
        insert a new cipher \"blowfish-cbc\"\n   after \"3des-cbc\":\n     <rpc message-id=\"102\"\n
        \         xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n          xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
        \         xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n       <edit-config>\n
        \        <target>\n           <running/>\n         </target>\n         <config>\n
        \          <system xmlns=\"urn:example:config\">\n             <services>\n
        \              <ssh>\n                 <cipher nc:operation=\"create\"\n                         yang:insert=\"after\"\n
        \                        yang:value=\"3des-cbc\">blowfish-cbc</cipher>\n               </ssh>\n
        \            </services>\n           </system>\n         </config>\n       </edit-config>\n
        \    </rpc>\n"
      title: 7.7.10.  Usage Example
    title: 7.7.  The "leaf-list" Statement
  - contents:
    - "7.8.  The \"list\" Statement\n   The \"list\" statement is used to define an
      interior data node in the\n   schema tree.  A list node may exist in multiple
      instances in the data\n   tree.  Each such instance is known as a list entry.
      \ The \"list\"\n   statement takes one argument, which is an identifier, followed
      by a\n   block of substatements that holds detailed list information.\n   A
      list entry is uniquely identified by the values of the list's keys,\n   if defined.\n"
    - contents:
      - "7.8.1.  The list's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | action       | 7.15    | 0..n        |\n                 |
        anydata      | 7.10    | 0..n        |\n                 | anyxml       |
        7.11    | 0..n        |\n                 | choice       | 7.9     | 0..n
        \       |\n                 | config       | 7.21.1  | 0..1        |\n                 |
        container    | 7.5     | 0..n        |\n                 | description  |
        7.21.3  | 0..1        |\n                 | grouping     | 7.12    | 0..n
        \       |\n                 | if-feature   | 7.20.2  | 0..n        |\n                 |
        key          | 7.8.2   | 0..1        |\n                 | leaf         |
        7.6     | 0..n        |\n                 | leaf-list    | 7.7     | 0..n
        \       |\n                 | list         | 7.8     | 0..n        |\n                 |
        max-elements | 7.7.6   | 0..1        |\n                 | min-elements |
        7.7.5   | 0..1        |\n                 | must         | 7.5.3   | 0..n
        \       |\n                 | notification | 7.16    | 0..n        |\n                 |
        ordered-by   | 7.7.7   | 0..1        |\n                 | reference    |
        7.21.4  | 0..1        |\n                 | status       | 7.21.2  | 0..1
        \       |\n                 | typedef      | 7.3     | 0..n        |\n                 |
        unique       | 7.8.3   | 0..n        |\n                 | uses         |
        7.13    | 0..n        |\n                 | when         | 7.21.5  | 0..1
        \       |\n                 +--------------+---------+-------------+\n"
      title: 7.8.1.  The list's Substatements
    - contents:
      - "7.8.2.  The list's \"key\" Statement\n   The \"key\" statement, which MUST
        be present if the list represents\n   configuration and MAY be present otherwise,
        takes as an argument a\n   string that specifies a space-separated list of
        one or more leaf\n   identifiers of this list.  A leaf identifier MUST NOT
        appear more\n   than once in the key.  Each such leaf identifier MUST refer
        to a\n   child leaf of the list.  The leafs can be defined directly in\n   substatements
        to the list or in groupings used in the list.\n   The combined values of all
        the leafs specified in the key are used to\n   uniquely identify a list entry.
        \ All key leafs MUST be given values\n   when a list entry is created.  Thus,
        any default values in the key\n   leafs or their types are ignored.  Any \"mandatory\"
        statements in the\n   key leafs are ignored.\n   A leaf that is part of the
        key can be of any built-in or\n   derived type.\n   All key leafs in a list
        MUST have the same value for their \"config\"\n   as the list itself.\n   The
        key string syntax is formally defined by the rule \"key-arg\" in\n   Section
        14.\n"
      title: 7.8.2.  The list's "key" Statement
    - contents:
      - "7.8.3.  The list's \"unique\" Statement\n   The \"unique\" statement is used
        to put constraints on valid list\n   entries.  It takes as an argument a string
        that contains a space-\n   separated list of schema node identifiers, which
        MUST be given in the\n   descendant form (see the rule \"descendant-schema-nodeid\"
        in\n   Section 14).  Each such schema node identifier MUST refer to a leaf.\n
        \  If one of the referenced leafs represents configuration data, then\n   all
        of the referenced leafs MUST represent configuration data.\n   The \"unique\"
        constraint specifies that the combined values of all the\n   leaf instances
        specified in the argument string, including leafs with\n   default values,
        MUST be unique within all list entry instances in\n   which all referenced
        leafs exist or have default values.  The\n   constraint is enforced according
        to the rules in Section 8.\n   The unique string syntax is formally defined
        by the rule \"unique-arg\"\n   in Section 14.\n"
      - contents:
        - "7.8.3.1.  Usage Example\n   With the following list:\n     list server
          {\n       key \"name\";\n       unique \"ip port\";\n       leaf name {\n
          \        type string;\n       }\n       leaf ip {\n         type inet:ip-address;\n
          \      }\n       leaf port {\n         type inet:port-number;\n       }\n
          \    }\n   the following configuration is not valid:\n     <server>\n       <name>smtp</name>\n
          \      <ip>192.0.2.1</ip>\n       <port>25</port>\n     </server>\n     <server>\n
          \      <name>http</name>\n       <ip>192.0.2.1</ip>\n       <port>25</port>\n
          \    </server>\n   The following configuration is valid, since the \"http\"
          and \"ftp\" list\n   entries do not have a value for all referenced leafs
          and are thus not\n   taken into account when the \"unique\" constraint is
          enforced:\n     <server>\n       <name>smtp</name>\n       <ip>192.0.2.1</ip>\n
          \      <port>25</port>\n     </server>\n     <server>\n       <name>http</name>\n
          \      <ip>192.0.2.1</ip>\n     </server>\n     <server>\n       <name>ftp</name>\n
          \      <ip>192.0.2.1</ip>\n     </server>\n"
        title: 7.8.3.1.  Usage Example
      title: 7.8.3.  The list's "unique" Statement
    - contents:
      - "7.8.4.  The list's Child Node Statements\n   Within a list, the \"container\",
        \"leaf\", \"list\", \"leaf-list\", \"uses\",\n   \"choice\", \"anydata\",
        and \"anyxml\" statements can be used to define\n   child nodes to the list.\n"
      title: 7.8.4.  The list's Child Node Statements
    - contents:
      - "7.8.5.  XML Encoding Rules\n   A list is encoded as a series of XML elements,
        one for each entry in\n   the list.  Each element's local name is the list's
        identifier, and\n   its namespace is the module's XML namespace (see Section
        7.1.3).\n   There is no XML element surrounding the list as a whole.\n   The
        list's key nodes are encoded as subelements to the list's\n   identifier element,
        in the same order as they are defined within the\n   \"key\" statement.\n
        \  The rest of the list's child nodes are encoded as subelements to the\n
        \  list element, after the keys.  If the list defines RPC or action\n   input
        or output parameters, the subelements are encoded in the same\n   order as
        they are defined within the \"list\" statement.  Otherwise,\n   the subelements
        are encoded in any order.\n   Any whitespace between the subelements to the
        list entry is\n   insignificant, i.e., an implementation MAY insert whitespace\n
        \  characters between subelements.\n   The XML elements representing list
        entries MUST appear in the order\n   specified by the user if the list is
        \"ordered-by user\"; otherwise,\n   the order is implementation dependent.
        \ The XML elements representing\n   list entries MAY be interleaved with elements
        for siblings of the\n   list, unless the list defines RPC or action input
        or output\n   parameters.\n"
      title: 7.8.5.  XML Encoding Rules
    - contents:
      - "7.8.6.  NETCONF <edit-config> Operations\n   List entries can be created,
        deleted, replaced, and modified through\n   <edit-config> by using the \"operation\"
        attribute in the list's XML\n   element.  In each case, the values of all
        keys are used to uniquely\n   identify a list entry.  If all keys are not
        specified for a list\n   entry, a \"missing-element\" error is returned.\n
        \  In an \"ordered-by user\" list, the attributes \"insert\" and \"key\" in\n
        \  the YANG XML namespace (Section 5.3.1) can be used to control where\n   in
        the list the entry is inserted.  These can be used during \"create\"\n   operations
        to insert a new list entry, or during \"merge\" or \"replace\"\n   operations
        to insert a new list entry or move an existing one.\n   The \"insert\" attribute
        can take the values \"first\", \"last\", \"before\",\n   and \"after\".  If
        the value is \"before\" or \"after\", the \"key\"\n   attribute MUST also
        be used, to specify an existing element in the\n   list.  The value of the
        \"key\" attribute is the key predicates of the\n   full instance identifier
        (see Section 9.13) for the list entry.\n   If no \"insert\" attribute is present
        in the \"create\" operation, it\n   defaults to \"last\".\n   If several entries
        in an \"ordered-by user\" list are modified in the\n   same <edit-config>
        request, the entries are modified one at a time,\n   in the order of the XML
        elements in the request.\n   In a <copy-config> or in an <edit-config> with
        a \"replace\" operation\n   that covers the entire list, the list entry order
        is the same as the\n   order of the XML elements in the request.\n   When
        a NETCONF server processes an <edit-config> request, the\n   elements of procedure
        for a list node are as follows:\n   o  If the operation is \"merge\" or \"replace\",
        the list entry is\n      created if it does not exist.  If the list entry
        already exists\n      and the \"insert\" and \"key\" attributes are present,
        the list entry\n      is moved according to the values of the \"insert\" and
        \"key\"\n      attributes.  If the list entry exists and the \"insert\" and
        \"key\"\n      attributes are not present, the list entry is not moved.\n
        \  o  If the operation is \"create\", the list entry is created if it does\n
        \     not exist.  If the list entry already exists, a \"data-exists\"\n      error
        is returned.\n   o  If the operation is \"delete\", the entry is deleted from
        the list\n      if it exists.  If the list entry does not exist, a \"data-missing\"\n
        \     error is returned.\n"
      title: 7.8.6.  NETCONF <edit-config> Operations
    - contents:
      - "7.8.7.  Usage Example\n   Given the following list:\n     list user {\n       key
        \"name\";\n       config true;\n       description\n         \"This is a list
        of users in the system.\";\n       leaf name {\n         type string;\n       }\n
        \      leaf type {\n         type string;\n       }\n       leaf full-name
        {\n         type string;\n       }\n     }\n   A corresponding XML instance
        example:\n     <user>\n       <name>fred</name>\n       <type>admin</type>\n
        \      <full-name>Fred Flintstone</full-name>\n     </user>\n   To create
        a new user \"barney\":\n     <rpc message-id=\"101\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
        \         xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n       <edit-config>\n
        \        <target>\n           <running/>\n         </target>\n         <config>\n
        \          <system xmlns=\"urn:example:config\">\n             <user nc:operation=\"create\">\n
        \              <name>barney</name>\n               <type>admin</type>\n               <full-name>Barney
        Rubble</full-name>\n             </user>\n           </system>\n         </config>\n
        \      </edit-config>\n     </rpc>\n   To change the type of \"fred\" to \"superuser\":\n
        \    <rpc message-id=\"102\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
        \         xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n       <edit-config>\n
        \        <target>\n           <running/>\n         </target>\n         <config>\n
        \          <system xmlns=\"urn:example:config\">\n             <user>\n               <name>fred</name>\n
        \              <type>superuser</type>\n             </user>\n           </system>\n
        \        </config>\n       </edit-config>\n     </rpc>\n   Given the following
        ordered-by user list:\n     list user {\n       description\n         \"This
        is a list of users in the system.\";\n       ordered-by user;\n       config
        true;\n       key \"first-name surname\";\n       leaf first-name {\n         type
        string;\n       }\n       leaf surname {\n         type string;\n       }\n
        \      leaf type {\n         type string;\n       }\n     }\n   The following
        would be used to insert a new user \"barney rubble\"\n   after the user \"fred
        flintstone\":\n     <rpc message-id=\"101\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
        \         xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n          xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n
        \      <edit-config>\n         <target>\n           <running/>\n         </target>\n
        \        <config>\n           <system xmlns=\"urn:example:config\"\n                xmlns:ex=\"urn:example:config\">\n
        \            <user nc:operation=\"create\"\n                   yang:insert=\"after\"\n
        \                  yang:key=\"[ex:first-name='fred']\n                             [ex:surname='flintstone']\">\n
        \              <first-name>barney</first-name>\n               <surname>rubble</surname>\n
        \              <type>admin</type>\n             </user>\n           </system>\n
        \        </config>\n       </edit-config>\n     </rpc>\n   The following would
        be used to move the user \"barney rubble\" before\n   the user \"fred flintstone\":\n
        \    <rpc message-id=\"102\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
        \         xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n          xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n
        \      <edit-config>\n         <target>\n           <running/>\n         </target>\n
        \        <config>\n           <system xmlns=\"urn:example:config\"\n                xmlns:ex=\"urn:example:config\">\n
        \            <user nc:operation=\"merge\"\n                   yang:insert=\"before\"\n
        \                  yang:key=\"[ex:name='fred']\n                             [ex:surname='flintstone']\">\n
        \              <first-name>barney</first-name>\n               <surname>rubble</surname>\n
        \            </user>\n           </system>\n         </config>\n       </edit-config>\n
        \    </rpc>\n"
      title: 7.8.7.  Usage Example
    title: 7.8.  The "list" Statement
  - contents:
    - "7.9.  The \"choice\" Statement\n   The \"choice\" statement defines a set of
      alternatives, only one of\n   which may be present in any one data tree.  The
      argument is an\n   identifier, followed by a block of substatements that holds
      detailed\n   choice information.  The identifier is used to identify the choice\n
      \  node in the schema tree.  A choice node does not exist in the data\n   tree.\n
      \  A choice consists of a number of branches, each defined with a \"case\"\n
      \  substatement.  Each branch contains a number of child nodes.  The\n   nodes
      from at most one of the choice's branches exist at the same\n   time.\n   Since
      only one of the choice's cases can be valid at any time in the\n   data tree,
      the creation of a node from one case implicitly deletes\n   all nodes from all
      other cases.  If a request creates a node from a\n   case, the server will delete
      any existing nodes that are defined in\n   other cases inside the choice.\n"
    - contents:
      - "7.9.1.  The choice's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | anydata      | 7.10    | 0..n        |\n                 |
        anyxml       | 7.11    | 0..n        |\n                 | case         |
        7.9.2   | 0..n        |\n                 | choice       | 7.9     | 0..n
        \       |\n                 | config       | 7.21.1  | 0..1        |\n                 |
        container    | 7.5     | 0..n        |\n                 | default      |
        7.9.3   | 0..1        |\n                 | description  | 7.21.3  | 0..1
        \       |\n                 | if-feature   | 7.20.2  | 0..n        |\n                 |
        leaf         | 7.6     | 0..n        |\n                 | leaf-list    |
        7.7     | 0..n        |\n                 | list         | 7.8     | 0..n
        \       |\n                 | mandatory    | 7.9.4   | 0..1        |\n                 |
        reference    | 7.21.4  | 0..1        |\n                 | status       |
        7.21.2  | 0..1        |\n                 | when         | 7.21.5  | 0..1
        \       |\n                 +--------------+---------+-------------+\n"
      title: 7.9.1.  The choice's Substatements
    - contents:
      - "7.9.2.  The choice's \"case\" Statement\n   The \"case\" statement is used
        to define branches of the choice.  It\n   takes as an argument an identifier,
        followed by a block of\n   substatements that holds detailed case information.\n
        \  The identifier is used to identify the case node in the schema tree.\n
        \  A case node does not exist in the data tree.\n   Within a \"case\" statement,
        the \"anydata\", \"anyxml\", \"choice\",\n   \"container\", \"leaf\", \"list\",
        \"leaf-list\", and \"uses\" statements can\n   be used to define child nodes
        to the case node.  The identifiers of\n   all these child nodes MUST be unique
        within all cases in a choice.\n   For example, the following is illegal:\n
        \    choice interface-type {     // This example is illegal YANG\n       case
        a {\n         leaf ethernet { ... }\n       }\n       case b {\n         container
        ethernet { ...}\n       }\n     }\n   As a shorthand, the \"case\" statement
        can be omitted if the branch\n   contains a single \"anydata\", \"anyxml\",
        \"choice\", \"container\", \"leaf\",\n   \"list\", or \"leaf-list\" statement.
        \ In this case, the case node still\n   exists in the schema tree, and its
        identifier is the same as the\n   identifier of the child node.  Schema node
        identifiers (Section 6.5)\n   MUST always explicitly include case node identifiers.
        \ The following\n   example:\n     choice interface-type {\n       container
        ethernet { ... }\n     }\n   is equivalent to:\n     choice interface-type
        {\n       case ethernet {\n         container ethernet { ... }\n       }\n
        \    }\n   The case identifier MUST be unique within a choice.\n"
      - contents:
        - "7.9.2.1.  The case's Substatements\n                 +--------------+---------+-------------+\n
          \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
          \                | anydata      | 7.10    | 0..n        |\n                 |
          anyxml       | 7.11    | 0..n        |\n                 | choice       |
          7.9     | 0..n        |\n                 | container    | 7.5     | 0..n
          \       |\n                 | description  | 7.21.3  | 0..1        |\n                 |
          if-feature   | 7.20.2  | 0..n        |\n                 | leaf         |
          7.6     | 0..n        |\n                 | leaf-list    | 7.7     | 0..n
          \       |\n                 | list         | 7.8     | 0..n        |\n                 |
          reference    | 7.21.4  | 0..1        |\n                 | status       |
          7.21.2  | 0..1        |\n                 | uses         | 7.13    | 0..n
          \       |\n                 | when         | 7.21.5  | 0..1        |\n                 +--------------+---------+-------------+\n"
        title: 7.9.2.1.  The case's Substatements
      title: 7.9.2.  The choice's "case" Statement
    - contents:
      - "7.9.3.  The choice's \"default\" Statement\n   The \"default\" statement
        indicates if a case should be considered as\n   the default if no child nodes
        from any of the choice's cases exist.\n   The argument is the identifier of
        the default \"case\" statement.  If\n   the \"default\" statement is missing,
        there is no default case.\n   The \"default\" statement MUST NOT be present
        on choices where\n   \"mandatory\" is \"true\".\n   The default case is only
        important when considering the \"default\"\n   statements of nodes under the
        cases (i.e., default values of leafs\n   and leaf-lists, and default cases
        of nested choices).  The default\n   values and nested default cases under
        the default case are used if\n   none of the nodes under any of the cases
        are present.\n   There MUST NOT be any mandatory nodes (Section 3) directly
        under the\n   default case.\n   Default values for child nodes under a case
        are only used if one of\n   the nodes under that case is present or if that
        case is the default\n   case.  If none of the nodes under a case are present
        and the case is\n   not the default case, the default values of the cases'
        child nodes\n   are ignored.\n   In this example, the choice defaults to \"interval\",
        and the default\n   value will be used if none of \"daily\", \"time-of-day\",
        or \"manual\" are\n   present.  If \"daily\" is present, the default value
        for \"time-of-day\"\n   will be used.\n     container transfer {\n       choice
        how {\n         default interval;\n         case interval {\n           leaf
        interval {\n             type uint16;\n             units minutes;\n             default
        30;\n           }\n         }\n         case daily {\n           leaf daily
        {\n             type empty;\n           }\n           leaf time-of-day {\n
        \            type string;\n             units 24-hour-clock;\n             default
        \"01.00\";\n           }\n         }\n         case manual {\n           leaf
        manual {\n             type empty;\n           }\n         }\n       }\n     }\n"
      title: 7.9.3.  The choice's "default" Statement
    - contents:
      - "7.9.4.  The choice's \"mandatory\" Statement\n   The \"mandatory\" statement,
        which is optional, takes as an argument\n   the string \"true\" or \"false\"
        and puts a constraint on valid data.  If\n   \"mandatory\" is \"true\", at
        least one node from exactly one of the\n   choice's case branches MUST exist.\n
        \  If not specified, the default is \"false\".\n   The behavior of the constraint
        depends on the type of the choice's\n   closest ancestor node in the schema
        tree that is not a non-presence\n   container (see Section 7.5.1):\n   o  If
        no such ancestor exists in the schema tree, the constraint is\n      enforced.\n
        \  o  Otherwise, if this ancestor is a case node, the constraint is\n      enforced
        if any other node from the case exists.\n   o  Otherwise, it is enforced if
        the ancestor node exists.\n   The constraint is further enforced according
        to the rules in\n   Section 8.\n"
      title: 7.9.4.  The choice's "mandatory" Statement
    - contents:
      - "7.9.5.  XML Encoding Rules\n   The choice and case nodes are not visible
        in XML.\n   The child nodes of the selected \"case\" statement MUST be encoded
        in\n   the same order as they are defined in the \"case\" statement if they\n
        \  are part of an RPC or action input or output parameter definition.\n   Otherwise,
        the subelements are encoded in any order.\n"
      title: 7.9.5.  XML Encoding Rules
    - contents:
      - "7.9.6.  Usage Example\n   Given the following choice:\n     container protocol
        {\n       choice name {\n         case a {\n           leaf udp {\n             type
        empty;\n           }\n         }\n         case b {\n           leaf tcp {\n
        \            type empty;\n           }\n         }\n       }\n     }\n   A
        corresponding XML instance example:\n     <protocol>\n       <tcp/>\n     </protocol>\n
        \  To change the protocol from TCP to UDP:\n     <rpc message-id=\"101\"\n
        \         xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n          xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
        \      <edit-config>\n         <target>\n           <running/>\n         </target>\n
        \        <config>\n           <system xmlns=\"urn:example:config\">\n             <protocol>\n
        \              <udp nc:operation=\"create\"/>\n             </protocol>\n
        \          </system>\n         </config>\n       </edit-config>\n     </rpc>\n"
      title: 7.9.6.  Usage Example
    title: 7.9.  The "choice" Statement
  - contents:
    - "7.10.  The \"anydata\" Statement\n   The \"anydata\" statement defines an interior
      node in the schema tree.\n   It takes one argument, which is an identifier,
      followed by a block of\n   substatements that holds detailed anydata information.\n
      \  The \"anydata\" statement is used to represent an unknown set of nodes\n
      \  that can be modeled with YANG, except anyxml, but for which the data\n   model
      is not known at module design time.  It is possible, though not\n   required,
      for the data model for anydata content to become known\n   through protocol
      signaling or other means that are outside the scope\n   of this document.\n
      \  An example of where anydata can be useful is a list of received\n   notifications
      where the specific notifications are not known at\n   design time.\n   An anydata
      node cannot be augmented (see Section 7.17).\n   An anydata node exists in zero
      or one instance in the data tree.\n   An implementation may or may not know
      the data model used to model a\n   specific instance of an anydata node.\n   Since
      the use of anydata limits the manipulation of the content, the\n   \"anydata\"
      statement SHOULD NOT be used to define configuration data.\n"
    - contents:
      - "7.10.1.  The anydata's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | config       | 7.21.1  | 0..1        |\n                 |
        description  | 7.21.3  | 0..1        |\n                 | if-feature   |
        7.20.2  | 0..n        |\n                 | mandatory    | 7.6.5   | 0..1
        \       |\n                 | must         | 7.5.3   | 0..n        |\n                 |
        reference    | 7.21.4  | 0..1        |\n                 | status       |
        7.21.2  | 0..1        |\n                 | when         | 7.21.5  | 0..1
        \       |\n                 +--------------+---------+-------------+\n"
      title: 7.10.1.  The anydata's Substatements
    - contents:
      - "7.10.2.  XML Encoding Rules\n   An anydata node is encoded as an XML element.
        \ The element's local\n   name is the anydata's identifier, and its namespace
        is the module's\n   XML namespace (see Section 7.1.3).  The value of the anydata
        node is\n   a set of nodes, which are encoded as XML subelements to the anydata\n
        \  element.\n"
      title: 7.10.2.  XML Encoding Rules
    - contents:
      - "7.10.3.  NETCONF <edit-config> Operations\n   An anydata node is treated
        as an opaque chunk of data.  This data can\n   be modified in its entirety
        only.\n   Any \"operation\" attributes present on subelements of an anydata
        node\n   are ignored by the NETCONF server.\n   When a NETCONF server processes
        an <edit-config> request, the\n   elements of procedure for the anydata node
        are as follows:\n   o  If the operation is \"merge\" or \"replace\", the node
        is created if\n      it does not exist, and its value is set to the subelements
        of the\n      anydata node found in the XML RPC data.\n   o  If the operation
        is \"create\", the node is created if it does not\n      exist, and its value
        is set to the subelements of the anydata node\n      found in the XML RPC
        data.  If the node already exists, a\n      \"data-exists\" error is returned.\n
        \  o  If the operation is \"delete\", the node is deleted if it exists.\n
        \     If the node does not exist, a \"data-missing\" error is returned.\n"
      title: 7.10.3.  NETCONF <edit-config> Operations
    - contents:
      - "7.10.4.  Usage Example\n   Given the following \"anydata\" statement:\n     list
        logged-notification {\n       key time;\n       leaf time {\n         type
        yang:date-and-time;\n       }\n       anydata data;\n     }\n   The following
        is a valid encoding of such a list instance:\n     <logged-notification>\n
        \      <time>2014-07-29T13:43:12Z</time>\n       <data>\n         <notification\n
        \          xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n           <eventTime>2014-07-29T13:43:01Z</eventTime>\n
        \          <event xmlns=\"urn:example:event\">\n             <event-class>fault</event-class>\n
        \            <reporting-entity>\n               <card>Ethernet0</card>\n             </reporting-entity>\n
        \            <severity>major</severity>\n           </event>\n         </notification>\n
        \      </data>\n     </logged-notification>\n"
      title: 7.10.4.  Usage Example
    title: 7.10.  The "anydata" Statement
  - contents:
    - "7.11.  The \"anyxml\" Statement\n   The \"anyxml\" statement defines an interior
      node in the schema tree.\n   It takes one argument, which is an identifier,
      followed by a block of\n   substatements that holds detailed anyxml information.\n
      \  The \"anyxml\" statement is used to represent an unknown chunk of XML.\n
      \  No restrictions are placed on the XML.  This can be useful, for\n   example,
      in RPC replies.  An example is the <filter> parameter in the\n   <get-config>
      operation in NETCONF.\n   An anyxml node cannot be augmented (see Section 7.17).\n
      \  An anyxml node exists in zero or one instance in the data tree.\n   Since
      the use of anyxml limits the manipulation of the content, the\n   \"anyxml\"
      statement SHOULD NOT be used to define configuration data.\n   It should be
      noted that in YANG version 1, \"anyxml\" was the only\n   statement that could
      model an unknown hierarchy of data.  In many\n   cases, this unknown hierarchy
      of data is actually modeled in YANG,\n   but the specific YANG data model is
      not known at design time.  In\n   these situations, it is RECOMMENDED to use
      \"anydata\" (Section 7.10)\n   instead of \"anyxml\".\n"
    - contents:
      - "7.11.1.  The anyxml's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | config       | 7.21.1  | 0..1        |\n                 |
        description  | 7.21.3  | 0..1        |\n                 | if-feature   |
        7.20.2  | 0..n        |\n                 | mandatory    | 7.6.5   | 0..1
        \       |\n                 | must         | 7.5.3   | 0..n        |\n                 |
        reference    | 7.21.4  | 0..1        |\n                 | status       |
        7.21.2  | 0..1        |\n                 | when         | 7.21.5  | 0..1
        \       |\n                 +--------------+---------+-------------+\n"
      title: 7.11.1.  The anyxml's Substatements
    - contents:
      - "7.11.2.  XML Encoding Rules\n   An anyxml node is encoded as an XML element.
        \ The element's local\n   name is the anyxml's identifier, and its namespace
        is the module's\n   XML namespace (see Section 7.1.3).  The value of the anyxml
        node is\n   encoded as XML content of this element.\n   Note that any XML
        prefixes used in the encoding are local to each\n   instance encoding.  This
        means that the same XML may be encoded\n   differently by different implementations.\n"
      title: 7.11.2.  XML Encoding Rules
    - contents:
      - "7.11.3.  NETCONF <edit-config> Operations\n   An anyxml node is treated as
        an opaque chunk of data.  This data can\n   be modified in its entirety only.\n
        \  Any \"operation\" attributes present on subelements of an anyxml node\n
        \  are ignored by the NETCONF server.\n   When a NETCONF server processes
        an <edit-config> request, the\n   elements of procedure for the anyxml node
        are as follows:\n   o  If the operation is \"merge\" or \"replace\", the node
        is created if\n      it does not exist, and its value is set to the XML content
        of the\n      anyxml node found in the XML RPC data.\n   o  If the operation
        is \"create\", the node is created if it does not\n      exist, and its value
        is set to the XML content of the anyxml node\n      found in the XML RPC data.
        \ If the node already exists, a\n      \"data-exists\" error is returned.\n
        \  o  If the operation is \"delete\", the node is deleted if it exists.\n
        \     If the node does not exist, a \"data-missing\" error is returned.\n"
      title: 7.11.3.  NETCONF <edit-config> Operations
    - contents:
      - "7.11.4.  Usage Example\n   Given the following \"anyxml\" statement:\n     anyxml
        html-info;\n   The following are two valid encodings of the same anyxml value:\n
        \     <html-info>\n        <p xmlns=\"http://www.w3.org/1999/xhtml\">\n          This
        is <em>very</em> cool.\n        </p>\n      </html-info>\n      <html-info>\n
        \       <x:p xmlns:x=\"http://www.w3.org/1999/xhtml\">\n          This is
        <x:em>very</x:em> cool.\n        </x:p>\n      </html-info>\n"
      title: 7.11.4.  Usage Example
    title: 7.11.  The "anyxml" Statement
  - contents:
    - "7.12.  The \"grouping\" Statement\n   The \"grouping\" statement is used to
      define a reusable block of nodes,\n   which may be used locally in the module
      or submodule, and by other\n   modules that import from it, according to the
      rules in Section 5.5.\n   It takes one argument, which is an identifier, followed
      by a block of\n   substatements that holds detailed grouping information.\n
      \  The \"grouping\" statement is not a data definition statement and, as\n   such,
      does not define any nodes in the schema tree.\n   A grouping is like a \"structure\"
      or a \"record\" in conventional\n   programming languages.\n   Once a grouping
      is defined, it can be referenced in a \"uses\"\n   statement (see Section 7.13).
      \ A grouping MUST NOT reference itself,\n   neither directly nor indirectly
      through a chain of other groupings.\n   If the grouping is defined at the top
      level of a YANG module or\n   submodule, the grouping's identifier MUST be unique
      within the\n   module.\n   A grouping is more than just a mechanism for textual
      substitution;\n   it also defines a collection of nodes.  Identifiers appearing
      inside\n   the grouping are resolved relative to the scope in which the grouping\n
      \  is defined, not where it is used.  Prefix mappings, type names,\n   grouping
      names, and extension usage are evaluated in the hierarchy\n   where the \"grouping\"
      statement appears.  For extensions, this means\n   that extensions defined as
      direct children to a \"grouping\" statement\n   are applied to the grouping
      itself.\n   Note that if a grouping defines an action or a notification node
      in\n   its hierarchy, then it cannot be used in all contexts.  For example,\n
      \  it cannot be used in an rpc definition.  See Sections 7.15 and 7.16.\n"
    - contents:
      - "7.12.1.  The grouping's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | action       | 7.15    | 0..n        |\n                 |
        anydata      | 7.10    | 0..n        |\n                 | anyxml       |
        7.11    | 0..n        |\n                 | choice       | 7.9     | 0..n
        \       |\n                 | container    | 7.5     | 0..n        |\n                 |
        description  | 7.21.3  | 0..1        |\n                 | grouping     |
        7.12    | 0..n        |\n                 | leaf         | 7.6     | 0..n
        \       |\n                 | leaf-list    | 7.7     | 0..n        |\n                 |
        list         | 7.8     | 0..n        |\n                 | notification |
        7.16    | 0..n        |\n                 | reference    | 7.21.4  | 0..1
        \       |\n                 | status       | 7.21.2  | 0..1        |\n                 |
        typedef      | 7.3     | 0..n        |\n                 | uses         |
        7.13    | 0..n        |\n                 +--------------+---------+-------------+\n"
      title: 7.12.1.  The grouping's Substatements
    - contents:
      - "7.12.2.  Usage Example\n     import ietf-inet-types {\n       prefix \"inet\";\n
        \    }\n     grouping endpoint {\n       description \"A reusable endpoint
        group.\";\n       leaf ip {\n         type inet:ip-address;\n       }\n       leaf
        port {\n         type inet:port-number;\n       }\n     }\n"
      title: 7.12.2.  Usage Example
    title: 7.12.  The "grouping" Statement
  - contents:
    - "7.13.  The \"uses\" Statement\n   The \"uses\" statement is used to reference
      a \"grouping\" definition.\n   It takes one argument, which is the name of the
      grouping.\n   The effect of a \"uses\" reference to a grouping is that the nodes\n
      \  defined by the grouping are copied into the current schema tree and\n   are
      then updated according to the \"refine\" and \"augment\" statements.\n   The
      identifiers defined in the grouping are not bound to a namespace\n   until the
      contents of the grouping are added to the schema tree via a\n   \"uses\" statement
      that does not appear inside a \"grouping\" statement,\n   at which point they
      are bound to the namespace of the current module.\n"
    - contents:
      - "7.13.1.  The uses's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | augment      | 7.17    | 0..n        |\n                 |
        description  | 7.21.3  | 0..1        |\n                 | if-feature   |
        7.20.2  | 0..n        |\n                 | reference    | 7.21.4  | 0..1
        \       |\n                 | refine       | 7.13.2  | 0..n        |\n                 |
        status       | 7.21.2  | 0..1        |\n                 | when         |
        7.21.5  | 0..1        |\n                 +--------------+---------+-------------+\n"
      title: 7.13.1.  The uses's Substatements
    - contents:
      - "7.13.2.  The \"refine\" Statement\n   Some of the properties of each node
        in the grouping can be refined\n   with the \"refine\" statement.  The argument
        is a string that\n   identifies a node in the grouping.  This node is called
        the refine's\n   target node.  If a node in the grouping is not present as
        a target\n   node of a \"refine\" statement, it is not refined and thus is
        used\n   exactly as it was defined in the grouping.\n   The argument string
        is a descendant schema node identifier (see\n   Section 6.5).\n   The following
        refinements can be done:\n   o  A leaf or choice node may get a default value,
        or a new default\n      value if it already had one.\n   o  A leaf-list node
        may get a set of default values, or a new set of\n      default values if
        it already had defaults; i.e., the set of\n      refined default values replaces
        the defaults already given.\n   o  Any node may get a specialized \"description\"
        string.\n   o  Any node may get a specialized \"reference\" string.\n   o
        \ Any node may get a different \"config\" statement.\n   o  A leaf, anydata,
        anyxml, or choice node may get a different\n      \"mandatory\" statement.\n
        \  o  A container node may get a \"presence\" statement.\n   o  A leaf, leaf-list,
        list, container, anydata, or anyxml node may\n      get additional \"must\"
        expressions.\n   o  A leaf-list or list node may get a different \"min-elements\"
        or\n      \"max-elements\" statement.\n   o  A leaf, leaf-list, list, container,
        choice, case, anydata, or\n      anyxml node may get additional \"if-feature\"
        expressions.\n   o  Any node can get refined extensions, if the extension
        allows\n      refinement.  See Section 7.19 for details.\n"
      title: 7.13.2.  The "refine" Statement
    - contents:
      - "7.13.3.  XML Encoding Rules\n   Each node in the grouping is encoded as if
        it was defined inline,\n   even if it is imported from another module with
        another XML\n   namespace.\n"
      title: 7.13.3.  XML Encoding Rules
    - contents:
      - "7.13.4.  Usage Example\n   To use the \"endpoint\" grouping defined in Section
        7.12.2 in a\n   definition of an HTTP server in some other module, we can
        do:\n     import example-system {\n       prefix \"sys\";\n     }\n     container
        http-server {\n       leaf name {\n         type string;\n       }\n       uses
        sys:endpoint;\n     }\n   A corresponding XML instance example:\n     <http-server>\n
        \      <name>extern-web</name>\n       <ip>192.0.2.1</ip>\n       <port>80</port>\n
        \    </http-server>\n   If port 80 should be the default for the HTTP server,
        a default can\n   be added:\n     container http-server {\n       leaf name
        {\n         type string;\n       }\n       uses sys:endpoint {\n         refine
        port {\n           default 80;\n         }\n       }\n     }\n   If we want
        to define a list of servers and each server has \"ip\" and\n   \"port\" as
        keys, we can do:\n     list server {\n       key \"ip port\";\n       leaf
        name {\n         type string;\n       }\n       uses sys:endpoint;\n     }\n
        \  The following is an error:\n     container http-server {\n       uses sys:endpoint;\n
        \      leaf ip {          // illegal - same identifier \"ip\" used twice\n
        \        type string;\n       }\n     }\n"
      title: 7.13.4.  Usage Example
    title: 7.13.  The "uses" Statement
  - contents:
    - "7.14.  The \"rpc\" Statement\n   The \"rpc\" statement is used to define an
      RPC operation.  It takes one\n   argument, which is an identifier, followed
      by a block of\n   substatements that holds detailed rpc information.  This argument
      is\n   the name of the RPC.\n   The \"rpc\" statement defines an rpc node in
      the schema tree.  Under\n   the rpc node, a schema node with the name \"input\"
      and a schema node\n   with the name \"output\" are also defined.  The nodes
      \"input\" and\n   \"output\" are defined in the module's namespace.\n"
    - contents:
      - "7.14.1.  The rpc's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | description  | 7.21.3  | 0..1        |\n                 |
        grouping     | 7.12    | 0..n        |\n                 | if-feature   |
        7.20.2  | 0..n        |\n                 | input        | 7.14.2  | 0..1
        \       |\n                 | output       | 7.14.3  | 0..1        |\n                 |
        reference    | 7.21.4  | 0..1        |\n                 | status       |
        7.21.2  | 0..1        |\n                 | typedef      | 7.3     | 0..n
        \       |\n                 +--------------+---------+-------------+\n"
      title: 7.14.1.  The rpc's Substatements
    - contents:
      - "7.14.2.  The \"input\" Statement\n   The \"input\" statement, which is optional,
        is used to define input\n   parameters to the operation.  It does not take
        an argument.  The\n   substatements to \"input\" define nodes under the operation's
        input\n   node.\n   If a leaf in the input tree has a \"mandatory\" statement
        with the\n   value \"true\", the leaf MUST be present in an RPC invocation.\n
        \  If a leaf in the input tree has a default value, the server MUST use\n
        \  this value in the same cases as those described in Section 7.6.1.  In\n
        \  these cases, the server MUST operationally behave as if the leaf was\n
        \  present in the RPC invocation with the default value as its value.\n   If
        a leaf-list in the input tree has one or more default values, the\n   server
        MUST use these values in the same cases as those described in\n   Section
        7.7.2.  In these cases, the server MUST operationally behave\n   as if the
        leaf-list was present in the RPC invocation with the\n   default values as
        its values.\n   Since the input tree is not part of any datastore, all \"config\"\n
        \  statements for nodes in the input tree are ignored.\n   If any node has
        a \"when\" statement that would evaluate to \"false\",\n   then this node
        MUST NOT be present in the input tree.\n"
      - contents:
        - "7.14.2.1.  The input's Substatements\n                 +--------------+---------+-------------+\n
          \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
          \                | anydata      | 7.10    | 0..n        |\n                 |
          anyxml       | 7.11    | 0..n        |\n                 | choice       |
          7.9     | 0..n        |\n                 | container    | 7.5     | 0..n
          \       |\n                 | grouping     | 7.12    | 0..n        |\n                 |
          leaf         | 7.6     | 0..n        |\n                 | leaf-list    |
          7.7     | 0..n        |\n                 | list         | 7.8     | 0..n
          \       |\n                 | must         | 7.5.3   | 0..n        |\n                 |
          typedef      | 7.3     | 0..n        |\n                 | uses         |
          7.13    | 0..n        |\n                 +--------------+---------+-------------+\n"
        title: 7.14.2.1.  The input's Substatements
      title: 7.14.2.  The "input" Statement
    - contents:
      - "7.14.3.  The \"output\" Statement\n   The \"output\" statement, which is
        optional, is used to define output\n   parameters to the RPC operation.  It
        does not take an argument.  The\n   substatements to \"output\" define nodes
        under the operation's output\n   node.\n   If a leaf in the output tree has
        a \"mandatory\" statement with the\n   value \"true\", the leaf MUST be present
        in an RPC reply.\n   If a leaf in the output tree has a default value, the
        client MUST use\n   this value in the same cases as those described in Section
        7.6.1.  In\n   these cases, the client MUST operationally behave as if the
        leaf was\n   present in the RPC reply with the default value as its value.\n
        \  If a leaf-list in the output tree has one or more default values, the\n
        \  client MUST use these values in the same cases as those described in\n
        \  Section 7.7.2.  In these cases, the client MUST operationally behave\n
        \  as if the leaf-list was present in the RPC reply with the default\n   values
        as its values.\n   Since the output tree is not part of any datastore, all
        \"config\"\n   statements for nodes in the output tree are ignored.\n   If
        any node has a \"when\" statement that would evaluate to \"false\",\n   then
        this node MUST NOT be present in the output tree.\n"
      - contents:
        - "7.14.3.1.  The output's Substatements\n                 +--------------+---------+-------------+\n
          \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
          \                | anydata      | 7.10    | 0..n        |\n                 |
          anyxml       | 7.11    | 0..n        |\n                 | choice       |
          7.9     | 0..n        |\n                 | container    | 7.5     | 0..n
          \       |\n                 | grouping     | 7.12    | 0..n        |\n                 |
          leaf         | 7.6     | 0..n        |\n                 | leaf-list    |
          7.7     | 0..n        |\n                 | list         | 7.8     | 0..n
          \       |\n                 | must         | 7.5.3   | 0..n        |\n                 |
          typedef      | 7.3     | 0..n        |\n                 | uses         |
          7.13    | 0..n        |\n                 +--------------+---------+-------------+\n"
        title: 7.14.3.1.  The output's Substatements
      title: 7.14.3.  The "output" Statement
    - contents:
      - "7.14.4.  NETCONF XML Encoding Rules\n   An rpc node is encoded as a child
        XML element to the <rpc> element,\n   as designated by the substitution group
        \"rpcOperation\" in [RFC6241].\n   The element's local name is the rpc's identifier,
        and its namespace\n   is the module's XML namespace (see Section 7.1.3).\n
        \  Input parameters are encoded as child XML elements to the rpc node's\n
        \  XML element, in the same order as they are defined within the \"input\"\n
        \  statement.\n   If the RPC operation invocation succeeded and no output
        parameters\n   are returned, the <rpc-reply> contains a single <ok/> element
        defined\n   in [RFC6241].  If output parameters are returned, they are encoded
        as\n   child elements to the <rpc-reply> element defined in [RFC6241], in\n
        \  the same order as they are defined within the \"output\" statement.\n"
      title: 7.14.4.  NETCONF XML Encoding Rules
    - contents:
      - "7.14.5.  Usage Example\n   The following example defines an RPC operation:\n
        \    module example-rock {\n       yang-version 1.1;\n       namespace \"urn:example:rock\";\n
        \      prefix \"rock\";\n       rpc rock-the-house {\n         input {\n           leaf
        zip-code {\n             type string;\n           }\n         }\n       }\n
        \    }\n   A corresponding XML instance example of the complete rpc and\n
        \  rpc-reply:\n     <rpc message-id=\"101\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
        \      <rock-the-house xmlns=\"urn:example:rock\">\n         <zip-code>27606-0100</zip-code>\n
        \      </rock-the-house>\n     </rpc>\n     <rpc-reply message-id=\"101\"\n
        \               xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n       <ok/>\n
        \    </rpc-reply>\n"
      title: 7.14.5.  Usage Example
    title: 7.14.  The "rpc" Statement
  - contents:
    - "7.15.  The \"action\" Statement\n   The \"action\" statement is used to define
      an operation connected to a\n   specific container or list data node.  It takes
      one argument, which\n   is an identifier, followed by a block of substatements
      that holds\n   detailed action information.  The argument is the name of the
      action.\n   The \"action\" statement defines an action node in the schema tree.\n
      \  Under the action node, a schema node with the name \"input\" and a\n   schema
      node with the name \"output\" are also defined.  The nodes\n   \"input\" and
      \"output\" are defined in the module's namespace.\n   An action MUST NOT be
      defined within an rpc, another action, or a\n   notification, i.e., an action
      node MUST NOT have an rpc, action, or a\n   notification node as one of its
      ancestors in the schema tree.  For\n   example, this means that it is an error
      if a grouping that contains\n   an action somewhere in its node hierarchy is
      used in a notification\n   definition.\n   An action MUST NOT have any ancestor
      node that is a list node without\n   a \"key\" statement.\n   Since an action
      cannot be defined at the top level of a module or in\n   a \"case\" statement,
      it is an error if a grouping that contains an\n   action at the top of its node
      hierarchy is used at the top level of a\n   module or in a case definition.\n
      \  The difference between an action and an rpc is that an action is tied\n   to
      a node in the datastore, whereas an rpc is not.  When an action is\n   invoked,
      the node in the datastore is specified along with the name\n   of the action
      and the input parameters.\n"
    - contents:
      - "7.15.1.  The action's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | description  | 7.21.3  | 0..1        |\n                 |
        grouping     | 7.12    | 0..n        |\n                 | if-feature   |
        7.20.2  | 0..n        |\n                 | input        | 7.14.2  | 0..1
        \       |\n                 | output       | 7.14.3  | 0..1        |\n                 |
        reference    | 7.21.4  | 0..1        |\n                 | status       |
        7.21.2  | 0..1        |\n                 | typedef      | 7.3     | 0..n
        \       |\n                 +--------------+---------+-------------+\n"
      title: 7.15.1.  The action's Substatements
    - contents:
      - "7.15.2.  NETCONF XML Encoding Rules\n   When an action is invoked, an element
        with the local name \"action\" in\n   the namespace \"urn:ietf:params:xml:ns:yang:1\"
        (see Section 5.3.1) is\n   encoded as a child XML element to the <rpc> element
        defined in\n   [RFC6241], as designated by the substitution group \"rpcOperation\"
        in\n   [RFC6241].\n   The <action> element contains a hierarchy of nodes that
        identifies\n   the node in the datastore.  It MUST contain all containers
        and list\n   nodes in the direct path from the top level down to the list
        or\n   container containing the action.  For lists, all key leafs MUST also\n
        \  be included.  The innermost container or list contains an XML element\n
        \  that carries the name of the defined action.  Within this element,\n   the
        input parameters are encoded as child XML elements, in the same\n   order
        as they are defined within the \"input\" statement.\n   Only one action can
        be invoked in one <rpc>.  If more than one action\n   is present in the <rpc>,
        the server MUST reply with a \"bad-element\"\n   <error-tag> in the <rpc-error>.\n
        \  If the action operation invocation succeeded and no output parameters\n
        \  are returned, the <rpc-reply> contains a single <ok/> element defined\n
        \  in [RFC6241].  If output parameters are returned, they are encoded as\n
        \  child elements to the <rpc-reply> element defined in [RFC6241], in\n   the
        same order as they are defined within the \"output\" statement.\n"
      title: 7.15.2.  NETCONF XML Encoding Rules
    - contents:
      - "7.15.3.  Usage Example\n   The following example defines an action to reset
        one server at a\n   server farm:\n     module example-server-farm {\n       yang-version
        1.1;\n       namespace \"urn:example:server-farm\";\n       prefix \"sfarm\";\n
        \      import ietf-yang-types {\n         prefix \"yang\";\n       }\n       list
        server {\n         key name;\n         leaf name {\n           type string;\n
        \        }\n         action reset {\n           input {\n             leaf
        reset-at {\n               type yang:date-and-time;\n               mandatory
        true;\n              }\n            }\n            output {\n              leaf
        reset-finished-at {\n                type yang:date-and-time;\n                mandatory
        true;\n              }\n            }\n          }\n        }\n      }\n   A
        corresponding XML instance example of the complete rpc and\n   rpc-reply:\n
        \    <rpc message-id=\"101\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
        \      <action xmlns=\"urn:ietf:params:xml:ns:yang:1\">\n         <server
        xmlns=\"urn:example:server-farm\">\n           <name>apache-1</name>\n           <reset>\n
        \            <reset-at>2014-07-29T13:42:00Z</reset-at>\n           </reset>\n
        \        </server>\n       </action>\n     </rpc>\n     <rpc-reply message-id=\"101\"\n
        \               xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n       <reset-finished-at
        xmlns=\"urn:example:server-farm\">\n         2014-07-29T13:42:12Z\n       </reset-finished-at>\n
        \    </rpc-reply>\n"
      title: 7.15.3.  Usage Example
    title: 7.15.  The "action" Statement
  - contents:
    - "7.16.  The \"notification\" Statement\n   The \"notification\" statement is
      used to define a notification.  It\n   takes one argument, which is an identifier,
      followed by a block of\n   substatements that holds detailed notification information.
      \ The\n   \"notification\" statement defines a notification node in the schema\n
      \  tree.\n   A notification can be defined at the top level of a module, or\n
      \  connected to a specific container or list data node in the schema\n   tree.\n
      \  A notification MUST NOT be defined within an rpc, action, or another\n   notification,
      i.e., a notification node MUST NOT have an rpc, action,\n   or a notification
      node as one of its ancestors in the schema tree.\n   For example, this means
      that it is an error if a grouping that\n   contains a notification somewhere
      in its node hierarchy is used in an\n   rpc definition.\n   A notification MUST
      NOT have any ancestor node that is a list node\n   without a \"key\" statement.\n
      \  Since a notification cannot be defined in a \"case\" statement, it is\n   an
      error if a grouping that contains a notification at the top of its\n   node
      hierarchy is used in a case definition.\n   If a leaf in the notification tree
      has a \"mandatory\" statement with\n   the value \"true\", the leaf MUST be
      present in a notification\n   instance.\n   If a leaf in the notification tree
      has a default value, the client\n   MUST use this value in the same cases as
      those described in\n   Section 7.6.1.  In these cases, the client MUST operationally
      behave\n   as if the leaf was present in the notification instance with the\n
      \  default value as its value.\n   If a leaf-list in the notification tree has
      one or more default\n   values, the client MUST use these values in the same
      cases as those\n   described in Section 7.7.2.  In these cases, the client MUST\n
      \  operationally behave as if the leaf-list was present in the\n   notification
      instance with the default values as its values.\n   Since the notification tree
      is not part of any datastore, all\n   \"config\" statements for nodes in the
      notification tree are ignored.\n"
    - contents:
      - "7.16.1.  The notification's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | anydata      | 7.10    | 0..n        |\n                 |
        anyxml       | 7.11    | 0..n        |\n                 | choice       |
        7.9     | 0..n        |\n                 | container    | 7.5     | 0..n
        \       |\n                 | description  | 7.21.3  | 0..1        |\n                 |
        grouping     | 7.12    | 0..n        |\n                 | if-feature   |
        7.20.2  | 0..n        |\n                 | leaf         | 7.6     | 0..n
        \       |\n                 | leaf-list    | 7.7     | 0..n        |\n                 |
        list         | 7.8     | 0..n        |\n                 | must         |
        7.5.3   | 0..n        |\n                 | reference    | 7.21.4  | 0..1
        \       |\n                 | status       | 7.21.2  | 0..1        |\n                 |
        typedef      | 7.3     | 0..n        |\n                 | uses         |
        7.13    | 0..n        |\n                 +--------------+---------+-------------+\n"
      title: 7.16.1.  The notification's Substatements
    - contents:
      - "7.16.2.  NETCONF XML Encoding Rules\n   A notification node that is defined
        on the top level of a module is\n   encoded as a child XML element to the
        <notification> element defined\n   in \"NETCONF Event Notifications\" [RFC5277].
        \ The element's local name\n   is the notification's identifier, and its namespace
        is the module's\n   XML namespace (see Section 7.1.3).\n   When a notification
        node is defined as a child to a data node, the\n   <notification> element
        defined in [RFC5277] contains a hierarchy of\n   nodes that identifies the
        node in the datastore.  It MUST contain all\n   containers and list nodes
        from the top level down to the list or\n   container containing the notification.
        \ For lists, all key leafs MUST\n   also be included.  The innermost container
        or list contains an XML\n   element that carries the name of the defined notification.\n
        \  The notification's child nodes are encoded as subelements to the\n   notification
        node's XML element, in any order.\n"
      title: 7.16.2.  NETCONF XML Encoding Rules
    - contents:
      - "7.16.3.  Usage Example\n   The following example defines a notification at
        the top level of a\n   module:\n     module example-event {\n       yang-version
        1.1;\n       namespace \"urn:example:event\";\n       prefix \"ev\";\n       notification
        event {\n         leaf event-class {\n           type string;\n         }\n
        \        leaf reporting-entity {\n           type instance-identifier;\n         }\n
        \        leaf severity {\n           type string;\n         }\n       }\n
        \    }\n   A corresponding XML instance example of the complete notification:\n
        \    <notification\n       xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n
        \      <eventTime>2008-07-08T00:01:00Z</eventTime>\n       <event xmlns=\"urn:example:event\">\n
        \        <event-class>fault</event-class>\n         <reporting-entity>\n           /ex:interface[ex:name='Ethernet0']\n
        \        </reporting-entity>\n         <severity>major</severity>\n       </event>\n
        \    </notification>\n   The following example defines a notification in a
        data node:\n     module example-interface-module {\n       yang-version 1.1;\n
        \      namespace \"urn:example:interface-module\";\n       prefix \"if\";\n
        \      container interfaces {\n         list interface {\n           key \"name\";\n
        \          leaf name {\n             type string;\n           }\n           notification
        interface-enabled {\n             leaf by-user {\n               type string;\n
        \            }\n           }\n         }\n       }\n     }\n   A corresponding
        XML instance example of the complete notification:\n     <notification\n       xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n
        \      <eventTime>2008-07-08T00:01:00Z</eventTime>\n       <interfaces xmlns=\"urn:example:interface-module\">\n
        \        <interface>\n           <name>eth1</name>\n           <interface-enabled>\n
        \            <by-user>fred</by-user>\n           </interface-enabled>\n         </interface>\n
        \      </interfaces>\n     </notification>\n"
      title: 7.16.3.  Usage Example
    title: 7.16.  The "notification" Statement
  - contents:
    - "7.17.  The \"augment\" Statement\n   The \"augment\" statement allows a module
      or submodule to add to a\n   schema tree defined in an external module, or in
      the current module\n   and its submodules, and to add to the nodes from a grouping
      in a\n   \"uses\" statement.  The argument is a string that identifies a node
      in\n   the schema tree.  This node is called the augment's target node.  The\n
      \  target node MUST be either a container, list, choice, case, input,\n   output,
      or notification node.  It is augmented with the nodes defined\n   in the substatements
      that follow the \"augment\" statement.\n   The argument string is a schema node
      identifier (see Section 6.5).\n   If the \"augment\" statement is on the top
      level in a module or\n   submodule, the absolute form (defined by the rule\n
      \  \"absolute-schema-nodeid\" in Section 14) of a schema node identifier\n   MUST
      be used.  If the \"augment\" statement is a substatement to the\n   \"uses\"
      statement, the descendant form (defined by the rule\n   \"descendant-schema-nodeid\"
      in Section 14) MUST be used.\n   If the target node is a container, list, case,
      input, output, or\n   notification node, the \"container\", \"leaf\", \"list\",
      \"leaf-list\",\n   \"uses\", and \"choice\" statements can be used within the
      \"augment\"\n   statement.\n   If the target node is a container or list node,
      the \"action\" and\n   \"notification\" statements can be used within the \"augment\"
      statement.\n   If the target node is a choice node, the \"case\" statement or
      a\n   shorthand \"case\" statement (see Section 7.9.2) can be used within the\n
      \  \"augment\" statement.\n   The \"augment\" statement MUST NOT add multiple
      nodes with the same\n   name from the same module to the target node.\n   If
      the augmentation adds mandatory nodes (see Section 3) that\n   represent configuration
      to a target node in another module, the\n   augmentation MUST be made conditional
      with a \"when\" statement.  Care\n   must be taken when defining the \"when\"
      expression so that clients\n   that do not know about the augmenting module
      do not break.\n   In the following example, it is OK to augment the \"interface\"
      entry\n   with \"mandatory-leaf\" because the augmentation depends on support
      for\n   \"some-new-iftype\".  The old client does not know about this type,
      so\n   it would never select this type and would therefore not be adding a\n
      \  mandatory data node.\n     module example-augment {\n       yang-version
      1.1;\n       namespace \"urn:example:augment\";\n       prefix mymod;\n       import
      ietf-interfaces {\n         prefix if;\n       }\n       identity some-new-iftype
      {\n          base if:interface-type;\n       }\n       augment \"/if:interfaces/if:interface\"
      {\n          when 'derived-from-or-self(if:type, \"mymod:some-new-iftype\")';\n
      \         leaf mandatory-leaf {\n             mandatory true;\n             type
      string;\n          }\n       }\n     }\n"
    - contents:
      - "7.17.1.  The augment's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | action       | 7.15    | 0..n        |\n                 |
        anydata      | 7.10    | 0..n        |\n                 | anyxml       |
        7.11    | 0..n        |\n                 | case         | 7.9.2   | 0..n
        \       |\n                 | choice       | 7.9     | 0..n        |\n                 |
        container    | 7.5     | 0..n        |\n                 | description  |
        7.21.3  | 0..1        |\n                 | if-feature   | 7.20.2  | 0..n
        \       |\n                 | leaf         | 7.6     | 0..n        |\n                 |
        leaf-list    | 7.7     | 0..n        |\n                 | list         |
        7.8     | 0..n        |\n                 | notification | 7.16    | 0..n
        \       |\n                 | reference    | 7.21.4  | 0..1        |\n                 |
        status       | 7.21.2  | 0..1        |\n                 | uses         |
        7.13    | 0..n        |\n                 | when         | 7.21.5  | 0..1
        \       |\n                 +--------------+---------+-------------+\n"
      title: 7.17.1.  The augment's Substatements
    - contents:
      - "7.17.2.  XML Encoding Rules\n   All data nodes defined in the \"augment\"
        statement are defined as XML\n   elements in the XML namespace of the module
        where the \"augment\" is\n   specified.\n   When a node is augmented, the
        augmenting child nodes are encoded as\n   subelements to the augmented node,
        in any order.\n"
      title: 7.17.2.  XML Encoding Rules
    - contents:
      - "7.17.3.  Usage Example\n   In namespace urn:example:interface-module, we
        have:\n     container interfaces {\n       list ifEntry {\n         key \"ifIndex\";\n
        \        leaf ifIndex {\n           type uint32;\n         }\n         leaf
        ifDescr {\n           type string;\n         }\n         leaf ifType {\n           type
        iana:IfType;\n         }\n         leaf ifMtu {\n           type int32;\n
        \        }\n       }\n     }\n   Then, in namespace urn:example:ds0, we have:\n
        \    import example-interface-module {\n       prefix \"if\";\n     }\n     augment
        \"/if:interfaces/if:ifEntry\" {\n       when \"if:ifType='ds0'\";\n       leaf
        ds0ChannelNumber {\n         type ChannelNumber;\n       }\n     }\n   A corresponding
        XML instance example:\n     <interfaces xmlns=\"urn:example:interface-module\"\n
        \                xmlns:ds0=\"urn:example:ds0\">\n       <ifEntry>\n         <ifIndex>1</ifIndex>\n
        \        <ifDescr>Flintstone Inc Ethernet A562</ifDescr>\n         <ifType>ethernetCsmacd</ifType>\n
        \        <ifMtu>1500</ifMtu>\n       </ifEntry>\n       <ifEntry>\n         <ifIndex>2</ifIndex>\n
        \        <ifDescr>Flintstone Inc DS0</ifDescr>\n         <ifType>ds0</ifType>\n
        \        <ds0:ds0ChannelNumber>1</ds0:ds0ChannelNumber>\n       </ifEntry>\n
        \    </interfaces>\n   As another example, suppose we have the choice defined
        in\n   Section 7.9.6.  The following construct can be used to extend the\n
        \  protocol definition:\n     augment /ex:system/ex:protocol/ex:name {\n       case
        c {\n         leaf smtp {\n           type empty;\n         }\n       }\n
        \    }\n   A corresponding XML instance example:\n     <ex:system>\n       <ex:protocol>\n
        \        <ex:tcp/>\n       </ex:protocol>\n     </ex:system>\n   or\n     <ex:system>\n
        \      <ex:protocol>\n         <other:smtp/>\n       </ex:protocol>\n     </ex:system>\n"
      title: 7.17.3.  Usage Example
    title: 7.17.  The "augment" Statement
  - contents:
    - "7.18.  The \"identity\" Statement\n   The \"identity\" statement is used to
      define a new globally unique,\n   abstract, and untyped identity.  The identity's
      only purpose is to\n   denote its name, semantics, and existence.  An identity
      can be either\n   defined from scratch or derived from one or more base identities.\n
      \  The identity's argument is an identifier that is the name of the\n   identity.
      \ It is followed by a block of substatements that holds\n   detailed identity
      information.\n   The built-in datatype \"identityref\" (see Section 9.10) can
      be used to\n   reference identities within a data model.\n"
    - contents:
      - "7.18.1.  The identity's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | base         | 7.18.2  | 0..n        |\n                 |
        description  | 7.21.3  | 0..1        |\n                 | if-feature   |
        7.20.2  | 0..n        |\n                 | reference    | 7.21.4  | 0..1
        \       |\n                 | status       | 7.21.2  | 0..1        |\n                 +--------------+---------+-------------+\n"
      title: 7.18.1.  The identity's Substatements
    - contents:
      - "7.18.2.  The \"base\" Statement\n   The \"base\" statement, which is optional,
        takes as an argument a\n   string that is the name of an existing identity,
        from which the new\n   identity is derived.  If no \"base\" statement is present,
        the identity\n   is defined from scratch.  If multiple \"base\" statements
        are present,\n   the identity is derived from all of them.\n   If a prefix
        is present on the base name, it refers to an identity\n   defined in the module
        that was imported with that prefix, or the\n   local module if the prefix
        matches the local module's prefix.\n   Otherwise, an identity with the matching
        name MUST be defined in the\n   current module or an included submodule.\n
        \  An identity MUST NOT reference itself, neither directly nor\n   indirectly
        through a chain of other identities.\n   The derivation of identities has
        the following properties:\n   o  It is irreflexive, which means that an identity
        is not derived\n      from itself.\n   o  It is transitive, which means that
        if identity B is derived from A\n      and C is derived from B, then C is
        also derived from A.\n"
      title: 7.18.2.  The "base" Statement
    - contents:
      - "7.18.3.  Usage Example\n     module example-crypto-base {\n       yang-version
        1.1;\n       namespace \"urn:example:crypto-base\";\n       prefix \"crypto\";\n
        \      identity crypto-alg {\n         description\n           \"Base identity
        from which all crypto algorithms\n            are derived.\";\n       }\n
        \      identity symmetric-key {\n         description\n           \"Base identity
        used to identify symmetric-key crypto\n            algorithms.\";\n         }\n
        \      identity public-key {\n         description\n           \"Base identity
        used to identify public-key crypto\n            algorithms.\";\n         }\n
        \    }\n     module example-des {\n       yang-version 1.1;\n       namespace
        \"urn:example:des\";\n       prefix \"des\";\n       import \"example-crypto-base\"
        {\n         prefix \"crypto\";\n       }\n       identity des {\n         base
        \"crypto:crypto-alg\";\n         base \"crypto:symmetric-key\";\n         description
        \"DES crypto algorithm.\";\n       }\n       identity des3 {\n         base
        \"crypto:crypto-alg\";\n         base \"crypto:symmetric-key\";\n         description
        \"Triple DES crypto algorithm.\";\n       }\n     }\n"
      title: 7.18.3.  Usage Example
    title: 7.18.  The "identity" Statement
  - contents:
    - "7.19.  The \"extension\" Statement\n   The \"extension\" statement allows the
      definition of new statements\n   within the YANG language.  This new statement
      definition can be\n   imported and used by other modules.\n   The \"extension\"
      statement's argument is an identifier that is the new\n   keyword for the extension
      and must be followed by a block of\n   substatements that holds detailed extension
      information.  The purpose\n   of the \"extension\" statement is to define a
      keyword so that it can be\n   imported and used by other modules.\n   The extension
      can be used like a normal YANG statement, with the\n   statement name followed
      by an argument if one is defined by the\n   \"extension\" statement, and an
      optional block of substatements.  The\n   statement's name is created by combining
      the prefix of the module in\n   which the extension was defined, a colon (\":\"),
      and the extension's\n   keyword, with no interleaving whitespace.  The substatements
      of an\n   extension are defined by the \"extension\" statement, using some\n
      \  mechanism outside the scope of this specification.  Syntactically,\n   the
      substatements MUST be YANG statements, including extensions\n   defined using
      \"extension\" statements.  YANG statements in extensions\n   MUST follow the
      syntactical rules in Section 14.\n   An extension can allow refinement (see
      Section 7.13.2) and deviations\n   (Section 7.20.3.2), but the mechanism for
      how this is defined is\n   outside the scope of this specification.\n"
    - contents:
      - "7.19.1.  The extension's Substatements\n                 +--------------+---------+-------------+\n
        \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
        \                | argument     | 7.19.2  | 0..1        |\n                 |
        description  | 7.21.3  | 0..1        |\n                 | reference    |
        7.21.4  | 0..1        |\n                 | status       | 7.21.2  | 0..1
        \       |\n                 +--------------+---------+-------------+\n"
      title: 7.19.1.  The extension's Substatements
    - contents:
      - "7.19.2.  The \"argument\" Statement\n   The \"argument\" statement, which
        is optional, takes as an argument a\n   string that is the name of the argument
        to the keyword.  If no\n   \"argument\" statement is present, the keyword
        expects no argument when\n   it is used.\n   The argument's name is used in
        the YIN mapping, where it is used as\n   an XML attribute or element name,
        depending on the argument's\n   \"yin-element\" statement.\n"
      - contents:
        - "7.19.2.1.  The argument's Substatement\n                 +--------------+----------+-------------+\n
          \                | substatement | section  | cardinality |\n                 +--------------+----------+-------------+\n
          \                | yin-element  | 7.19.2.2 | 0..1        |\n                 +--------------+----------+-------------+\n"
        title: 7.19.2.1.  The argument's Substatement
      - contents:
        - "7.19.2.2.  The \"yin-element\" Statement\n   The \"yin-element\" statement,
          which is optional, takes as an argument\n   the string \"true\" or \"false\".
          \ This statement indicates whether the\n   argument is mapped to an XML
          element in YIN or to an XML attribute\n   (see Section 13).\n   If no \"yin-element\"
          statement is present, it defaults to \"false\".\n"
        title: 7.19.2.2.  The "yin-element" Statement
      title: 7.19.2.  The "argument" Statement
    - contents:
      - "7.19.3.  Usage Example\n   To define an extension:\n     module example-extensions
        {\n       yang-version 1.1;\n       ...\n       extension c-define {\n         description\n
        \          \"Takes as an argument a name string.\n            Makes the code
        generator use the given name\n            in the #define.\";\n         argument
        \"name\";\n       }\n     }\n   To use the extension:\n     module example-interfaces
        {\n       yang-version 1.1;\n       ...\n       import example-extensions
        {\n         prefix \"myext\";\n       }\n       ...\n       container interfaces
        {\n         ...\n         myext:c-define \"MY_INTERFACES\";\n       }\n     }\n"
      title: 7.19.3.  Usage Example
    title: 7.19.  The "extension" Statement
  - contents:
    - "7.20.  Conformance-Related Statements\n   This section defines statements related
      to conformance, as described\n   in Section 5.6.\n"
    - contents:
      - "7.20.1.  The \"feature\" Statement\n   The \"feature\" statement is used
        to define a mechanism by which\n   portions of the schema are marked as conditional.
        \ A feature name is\n   defined that can later be referenced using the \"if-feature\"
        statement\n   (see Section 7.20.2).  Schema nodes tagged with an \"if-feature\"\n
        \  statement are ignored by the server unless the server supports the\n   given
        feature expression.  This allows portions of the YANG module to\n   be conditional
        based on conditions in the server.  The model can\n   represent the abilities
        of the server within the model, giving a\n   richer model that allows for
        differing server abilities and roles.\n   The argument to the \"feature\"
        statement is the name of the new\n   feature and follows the rules for identifiers
        in Section 6.2.  This\n   name is used by the \"if-feature\" statement to
        tie the schema nodes to\n   the feature.\n   In this example, a feature called
        \"local-storage\" represents the\n   ability for a server to store syslog
        messages on local storage of\n   some sort.  This feature is used to make
        the \"local-storage-limit\"\n   leaf conditional on the presence of some sort
        of local storage.  If\n   the server does not report that it supports this
        feature, the\n   \"local-storage-limit\" node is not supported.\n     module
        example-syslog {\n       yang-version 1.1;\n       ...\n       feature local-storage
        {\n         description\n           \"This feature means that the server supports
        local\n            storage (memory, flash, or disk) that can be used to\n
        \           store syslog messages.\";\n       }\n       container syslog {\n
        \        leaf local-storage-limit {\n           if-feature local-storage;\n
        \          type uint64;\n           units \"kilobyte\";\n           config
        false;\n           description\n             \"The amount of local storage
        that can be\n              used to hold syslog messages.\";\n         }\n
        \      }\n     }\n   The \"if-feature\" statement can be used in many places
        within the YANG\n   syntax.  Definitions tagged with \"if-feature\" are ignored
        when the\n   server does not support that feature.\n   A feature MUST NOT
        reference itself, neither directly nor indirectly\n   through a chain of other
        features.\n   In order for a server to support a feature that is dependent
        on any\n   other features (i.e., the feature has one or more \"if-feature\"\n
        \  substatements), the server MUST also support all the dependent\n   features.\n"
      - contents:
        - "7.20.1.1.  The feature's Substatements\n                 +--------------+---------+-------------+\n
          \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
          \                | description  | 7.21.3  | 0..1        |\n                 |
          if-feature   | 7.20.2  | 0..n        |\n                 | reference    |
          7.21.4  | 0..1        |\n                 | status       | 7.21.2  | 0..1
          \       |\n                 +--------------+---------+-------------+\n"
        title: 7.20.1.1.  The feature's Substatements
      title: 7.20.1.  The "feature" Statement
    - contents:
      - "7.20.2.  The \"if-feature\" Statement\n   The \"if-feature\" statement makes
        its parent statement conditional.\n   The argument is a boolean expression
        over feature names.  In this\n   expression, a feature name evaluates to \"true\"
        if and only if the\n   feature is supported by the server.  The parent statement
        is\n   implemented by servers where the boolean expression evaluates to\n
        \  \"true\".\n   The if-feature boolean expression syntax is formally defined
        by the\n   rule \"if-feature-expr\" in Section 14.  Parentheses are used to
        group\n   expressions.  When the expression is evaluated, the order of\n   precedence
        is (highest precedence first): grouping (parentheses),\n   \"not\", \"and\",
        \"or\".\n   If a prefix is present on a feature name in the boolean expression,\n
        \  the prefixed name refers to a feature defined in the module that was\n
        \  imported with that prefix, or the local module if the prefix matches\n
        \  the local module's prefix.  Otherwise, a feature with the matching\n   name
        MUST be defined in the current module or an included submodule.\n   A leaf
        that is a list key MUST NOT have any \"if-feature\" statements.\n"
      - contents:
        - "7.20.2.1.  Usage Example\n   In this example, the container \"target\"
          is implemented if either the\n   \"outbound-tls\" or \"outbound-ssh\" feature
          is supported by the server.\n     container target {\n       if-feature
          \"outbound-tls or outbound-ssh\";\n       ...\n     }\n   The following
          examples are equivalent:\n     if-feature \"not foo or bar and baz\";\n
          \    if-feature \"(not foo) or (bar and baz)\";\n"
        title: 7.20.2.1.  Usage Example
      title: 7.20.2.  The "if-feature" Statement
    - contents:
      - "7.20.3.  The \"deviation\" Statement\n   The \"deviation\" statement defines
        a hierarchy of a module that the\n   server does not implement faithfully.
        \ The argument is a string that\n   identifies the node in the schema tree
        where a deviation from the\n   module occurs.  This node is called the deviation's
        target node.  The\n   contents of the \"deviation\" statement give details
        about the\n   deviation.\n   The argument string is an absolute schema node
        identifier (see\n   Section 6.5).\n   Deviations define the way a server or
        class of servers deviate from a\n   standard.  This means that deviations
        MUST never be part of a\n   published standard, since they are the mechanism
        for learning how\n   implementations vary from the standards.\n   Server deviations
        are strongly discouraged and MUST only be used as a\n   last resort.  Telling
        the application how a server fails to follow a\n   standard is no substitute
        for implementing the standard correctly.  A\n   server that deviates from
        a module is not fully compliant with the\n   module.\n   However, in some
        cases, a particular device may not have the hardware\n   or software ability
        to support parts of a standard module.  When this\n   occurs, the server makes
        a choice to either treat attempts to\n   configure unsupported parts of the
        module as an error that is\n   reported back to the unsuspecting application
        or ignore those\n   incoming requests.  Neither choice is acceptable.\n   Instead,
        YANG allows servers to document portions of a base module\n   that are not
        supported, or that are supported but with different\n   syntax, by using the
        \"deviation\" statement.\n   After applying all deviations announced by a
        server, in any order,\n   the resulting data model MUST still be valid.\n"
      - contents:
        - "7.20.3.1.  The deviation's Substatements\n                 +--------------+----------+-------------+\n
          \                | substatement | section  | cardinality |\n                 +--------------+----------+-------------+\n
          \                | description  | 7.21.3   | 0..1        |\n                 |
          deviate      | 7.20.3.2 | 1..n        |\n                 | reference    |
          7.21.4   | 0..1        |\n                 +--------------+----------+-------------+\n"
        title: 7.20.3.1.  The deviation's Substatements
      - contents:
        - "7.20.3.2.  The \"deviate\" Statement\n   The \"deviate\" statement defines
          how the server's implementation of\n   the target node deviates from its
          original definition.  The argument\n   is one of the strings \"not-supported\",
          \"add\", \"replace\", or \"delete\".\n   The argument \"not-supported\"
          indicates that the target node is not\n   implemented by this server.\n
          \  The argument \"add\" adds properties to the target node.  The\n   properties
          to add are identified by substatements to the \"deviate\"\n   statement.
          \ If a property can only appear once, the property MUST NOT\n   exist in
          the target node.\n   The argument \"replace\" replaces properties of the
          target node.  The\n   properties to replace are identified by substatements
          to the\n   \"deviate\" statement.  The properties to replace MUST exist
          in the\n   target node.\n   The argument \"delete\" deletes properties from
          the target node.  The\n   properties to delete are identified by substatements
          to the \"delete\"\n   statement.  The substatement's keyword MUST match
          a corresponding\n   keyword in the target node, and the argument's string
          MUST be equal\n   to the corresponding keyword's argument string in the
          target node.\n               +--------------+--------------+-------------+\n
          \              | substatement | section      | cardinality |\n               +--------------+--------------+-------------+\n
          \              | config       | 7.21.1       | 0..1        |\n               |
          default      | 7.6.4, 7.7.4 | 0..n        |\n               | mandatory
          \   | 7.6.5        | 0..1        |\n               | max-elements | 7.7.6
          \       | 0..1        |\n               | min-elements | 7.7.5        |
          0..1        |\n               | must         | 7.5.3        | 0..n        |\n
          \              | type         | 7.4          | 0..1        |\n               |
          unique       | 7.8.3        | 0..n        |\n               | units        |
          7.3.3        | 0..1        |\n               +--------------+--------------+-------------+\n
          \                       The deviate's Substatements\n   If the target node
          has a property defined by an extension, this\n   property can be deviated
          if the extension allows deviations.  See\n   Section 7.19 for details.\n"
        title: 7.20.3.2.  The "deviate" Statement
      - contents:
        - "7.20.3.3.  Usage Example\n   In this example, the server is informing client
          applications that it\n   does not support the \"daytime\" service in the
          style of RFC 867.\n     module example-deviations {\n       yang-version
          1.1;\n       namespace \"urn:example:deviations\";\n       prefix md;\n
          \      import example-base {\n         prefix base;\n       }\n       deviation
          /base:system/base:daytime {\n         deviate not-supported;\n       }\n
          \      ...\n     }\n   A server would advertise both modules \"example-base\"
          and\n   \"example-deviations\".\n   The following example sets a server-specific
          default value to a leaf\n   that does not have a default value defined:\n
          \    deviation /base:system/base:user/base:type {\n       deviate add {\n
          \        default \"admin\"; // new users are 'admin' by default\n       }\n
          \    }\n   In this example, the server limits the number of name servers
          to 3:\n     deviation /base:system/base:name-server {\n       deviate replace
          {\n         max-elements 3;\n       }\n     }\n   If the original definition
          is:\n     container system {\n       must \"daytime or time\";\n       ...\n
          \    }\n   a server might remove this \"must\" constraint by doing:\n     deviation
          /base:system {\n       deviate delete {\n         must \"daytime or time\";\n
          \      }\n     }\n"
        title: 7.20.3.3.  Usage Example
      title: 7.20.3.  The "deviation" Statement
    title: 7.20.  Conformance-Related Statements
  - contents:
    - "7.21.  Common Statements\n   This section defines substatements common to several
      other\n   statements.\n"
    - contents:
      - "7.21.1.  The \"config\" Statement\n   The \"config\" statement takes as an
        argument the string \"true\" or\n   \"false\".  If \"config\" is \"true\",
        the definition represents\n   configuration.  Data nodes representing configuration
        are part of\n   configuration datastores.\n   If \"config\" is \"false\",
        the definition represents state data.  Data\n   nodes representing state data
        are not part of configuration\n   datastores.\n   If \"config\" is not specified,
        the default is the same as the parent\n   schema node's \"config\" value.
        \ If the parent node is a case node, the\n   value is the same as the case
        node's parent choice node.\n   If the top node does not specify a \"config\"
        statement, the default is\n   \"true\".\n   If a node has \"config\" set to
        \"false\", no node underneath it can have\n   \"config\" set to \"true\".\n"
      title: 7.21.1.  The "config" Statement
    - contents:
      - "7.21.2.  The \"status\" Statement\n   The \"status\" statement takes as an
        argument one of the strings\n   \"current\", \"deprecated\", or \"obsolete\".\n
        \  o  \"current\" means that the definition is current and valid.\n   o  \"deprecated\"
        indicates an obsolete definition, but it permits\n      new/continued implementation
        in order to foster interoperability\n      with older/existing implementations.\n
        \  o  \"obsolete\" means that the definition is obsolete and SHOULD NOT be\n
        \     implemented and/or can be removed from implementations.\n   If no status
        is specified, the default is \"current\".\n   If a definition is \"current\",
        it MUST NOT reference a \"deprecated\" or\n   \"obsolete\" definition within
        the same module.\n   If a definition is \"deprecated\", it MUST NOT reference
        an \"obsolete\"\n   definition within the same module.\n   For example, the
        following is illegal:\n     typedef my-type {\n       status deprecated;\n
        \      type int32;\n     }\n     leaf my-leaf {\n       status current;\n
        \      type my-type; // illegal, since my-type is deprecated\n     }\n"
      title: 7.21.2.  The "status" Statement
    - contents:
      - "7.21.3.  The \"description\" Statement\n   The \"description\" statement
        takes as an argument a string that\n   contains a human-readable textual description
        of this definition.\n   The text is provided in a language (or languages)
        chosen by the\n   module developer; for the sake of interoperability, it is
        RECOMMENDED\n   to choose a language that is widely understood among the community
        of\n   network administrators who will use the module.\n"
      title: 7.21.3.  The "description" Statement
    - contents:
      - "7.21.4.  The \"reference\" Statement\n   The \"reference\" statement takes
        as an argument a string that is a\n   human-readable cross-reference to an
        external document -- either\n   another module that defines related management
        information or a\n   document that provides additional information relevant
        to this\n   definition.\n   For example, a typedef for a \"uri\" data type
        could look like:\n     typedef uri {\n       type string;\n       reference\n
        \        \"RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\";\n
        \      ...\n     }\n"
      title: 7.21.4.  The "reference" Statement
    - contents:
      - "7.21.5.  The \"when\" Statement\n   The \"when\" statement makes its parent
        data definition statement\n   conditional.  The node defined by the parent
        data definition\n   statement is only valid when the condition specified by
        the \"when\"\n   statement is satisfied.  The statement's argument is an XPath\n
        \  expression (see Section 6.4), which is used to formally specify this\n
        \  condition.  If the XPath expression conceptually evaluates to \"true\"\n
        \  for a particular instance, then the node defined by the parent data\n   definition
        statement is valid; otherwise, it is not.\n   A leaf that is a list key MUST
        NOT have a \"when\" statement.\n   If a key leaf is defined in a grouping
        that is used in a list, the\n   \"uses\" statement MUST NOT have a \"when\"
        statement.\n   See Section 8.3.2 for additional information.\n   The XPath
        expression is conceptually evaluated in the following\n   context, in addition
        to the definition in Section 6.4.1:\n   o  If the \"when\" statement is a
        child of an \"augment\" statement, then\n      the context node is the augment's
        target node in the data tree, if\n      the target node is a data node.  Otherwise,
        the context node is\n      the closest ancestor node to the target node that
        is also a data\n      node.  If no such node exists, the context node is the
        root node.\n      The accessible tree is tentatively altered during the processing\n
        \     of the XPath expression by removing all instances (if any) of the\n
        \     nodes added by the \"augment\" statement.\n   o  If the \"when\" statement
        is a child of a \"uses\", \"choice\", or\n      \"case\" statement, then the
        context node is the closest ancestor\n      node to the node with the \"when\"
        statement that is also a data\n      node.  If no such node exists, the context
        node is the root node.\n      The accessible tree is tentatively altered during
        the processing\n      of the XPath expression by removing all instances (if
        any) of the\n      nodes added by the \"uses\", \"choice\", or \"case\" statement.\n
        \  o  If the \"when\" statement is a child of any other data definition\n
        \     statement, the accessible tree is tentatively altered during the\n      processing
        of the XPath expression by replacing all instances of\n      the data node
        for which the \"when\" statement is defined with a\n      single dummy node
        with the same name, but with no value and no\n      children.  If no such
        instance exists, the dummy node is\n      tentatively created.  The context
        node is this dummy node.\n   The result of the XPath expression is converted
        to a boolean value\n   using the standard XPath rules.\n   If the XPath expression
        references any node that also has associated\n   \"when\" statements, those
        \"when\" expressions MUST be evaluated first.\n   There MUST NOT be any circular
        dependencies among \"when\" expressions.\n   Note that the XPath expression
        is conceptually evaluated.  This means\n   that an implementation does not
        have to use an XPath evaluator in the\n   server.  The \"when\" statement
        can very well be implemented with\n   specially written code.\n"
      title: 7.21.5.  The "when" Statement
    title: 7.21.  Common Statements
  title: 7.  YANG Statements
- contents:
  - '8.  Constraints

    '
  - contents:
    - "8.1.  Constraints on Data\n   Several YANG statements define constraints on
      valid data.  These\n   constraints are enforced in different ways, depending
      on what type of\n   data the statement defines.\n   o  If the constraint is
      defined on configuration data, it MUST be\n      true in a valid configuration
      data tree.\n   o  If the constraint is defined on state data, it MUST be true
      in a\n      valid state data tree.\n   o  If the constraint is defined on notification
      content, it MUST be\n      true in any notification data tree.\n   o  If the
      constraint is defined on RPC or action input parameters, it\n      MUST be true
      in an invocation of the RPC or action operation.\n   o  If the constraint is
      defined on RPC or action output parameters,\n      it MUST be true in the RPC
      or action reply.\n   The following properties are true in all data trees:\n
      \  o  All leaf data values MUST match the type constraints for the leaf,\n      including
      those defined in the type's \"range\", \"length\", and\n      \"pattern\" properties.\n
      \  o  All key leafs MUST be present for all list entries.\n   o  Nodes MUST
      be present for at most one case branch in all choices.\n   o  There MUST be
      no nodes tagged with \"if-feature\" present if the\n      \"if-feature\" expression
      evaluates to \"false\" in the server.\n   o  There MUST be no nodes tagged with
      \"when\" present if the \"when\"\n      condition evaluates to \"false\" in
      the data tree.\n   The following properties are true in a valid data tree:\n
      \  o  All \"must\" constraints MUST evaluate to \"true\".\n   o  All referential
      integrity constraints defined via the \"path\"\n      statement MUST be satisfied.\n
      \  o  All \"unique\" constraints on lists MUST be satisfied.\n   o  The \"mandatory\"
      constraint is enforced for leafs and choices,\n      unless the node or any
      of its ancestors has a \"when\" condition or\n      \"if-feature\" expression
      that evaluates to \"false\".\n   o  The \"min-elements\" and \"max-elements\"
      constraints are enforced for\n      lists and leaf-lists, unless the node or
      any of its ancestors has\n      a \"when\" condition or \"if-feature\" expression
      that evaluates to\n      \"false\".\n   The running configuration datastore
      MUST always be valid.\n"
    title: 8.1.  Constraints on Data
  - contents:
    - "8.2.  Configuration Data Modifications\n   o  If a request creates configuration
      data nodes under a choice, any\n      existing nodes from other case branches
      in the data tree are\n      deleted by the server.\n   o  If a request modifies
      a configuration data node such that any\n      node's \"when\" expression becomes
      false, then the node in the data\n      tree with the \"when\" expression is
      deleted by the server.\n"
    title: 8.2.  Configuration Data Modifications
  - contents:
    - "8.3.  NETCONF Constraint Enforcement Model\n   For configuration data, there
      are three windows when constraints MUST\n   be enforced:\n   o  during parsing
      of RPC payloads\n   o  during processing of the <edit-config> operation\n   o
      \ during validation\n   Each of these scenarios is considered in the following
      sections.\n"
    - contents:
      - "8.3.1.  Payload Parsing\n   When content arrives in RPC payloads, it MUST
        be well-formed XML,\n   following the hierarchy and content rules defined
        by the set of\n   models the server implements.\n   o  If a leaf data value
        does not match the type constraints for the\n      leaf, including those defined
        in the type's \"range\", \"length\", and\n      \"pattern\" properties, the
        server MUST reply with an\n      \"invalid-value\" <error-tag> in the <rpc-error>,
        and with the\n      error-app-tag (Section 7.5.4.2) and error-message\n      (Section
        7.5.4.1) associated with the constraint, if any exist.\n   o  If all keys
        of a list entry are not present, the server MUST reply\n      with a \"missing-element\"
        <error-tag> in the <rpc-error>.\n   o  If data for more than one case branch
        of a choice is present, the\n      server MUST reply with a \"bad-element\"
        <error-tag> in the\n      <rpc-error>.\n   o  If data for a node tagged with
        \"if-feature\" is present and the\n      \"if-feature\" expression evaluates
        to \"false\" in the server, the\n      server MUST reply with an \"unknown-element\"
        <error-tag> in the\n      <rpc-error>.\n   o  If data for a node tagged with
        \"when\" is present and the \"when\"\n      condition evaluates to \"false\",
        the server MUST reply with an\n      \"unknown-element\" <error-tag> in the
        <rpc-error>.\n   o  For insert handling, if the values for the attributes
        \"before\" and\n      \"after\" are not valid for the type of the appropriate
        key leafs,\n      the server MUST reply with a \"bad-attribute\" <error-tag>
        in the\n      <rpc-error>.\n   o  If the attributes \"before\" and \"after\"
        appear in any element that\n      is not a list whose \"ordered-by\" property
        is \"user\", the server\n      MUST reply with an \"unknown-attribute\" <error-tag>
        in the\n      <rpc-error>.\n"
      title: 8.3.1.  Payload Parsing
    - contents:
      - "8.3.2.  NETCONF <edit-config> Processing\n   After the incoming data is parsed,
        the NETCONF server performs the\n   <edit-config> operation by applying the
        data to the configuration\n   datastore.  During this processing, the following
        errors MUST be\n   detected:\n   o  Delete requests for non-existent data.\n
        \  o  Create requests for existent data.\n   o  Insert requests with \"before\"
        or \"after\" parameters that do not\n      exist.\n   o  Modification requests
        for nodes tagged with \"when\", and the \"when\"\n      condition evaluates
        to \"false\".  In this case, the server MUST\n      reply with an \"unknown-element\"
        <error-tag> in the <rpc-error>.\n"
      title: 8.3.2.  NETCONF <edit-config> Processing
    - contents:
      - "8.3.3.  Validation\n   When datastore processing is complete, the final contents
        MUST obey\n   all validation constraints.  This validation processing is performed\n
        \  at differing times according to the datastore.  If the datastore is\n   \"running\"
        or \"startup\", these constraints MUST be enforced at the end\n   of the <edit-config>
        or <copy-config> operation.  If the datastore is\n   \"candidate\", the constraint
        enforcement is delayed until a <commit>\n   or <validate> operation takes
        place.\n"
      title: 8.3.3.  Validation
    title: 8.3.  NETCONF Constraint Enforcement Model
  title: 8.  Constraints
- contents:
  - "9.  Built-In Types\n   YANG has a set of built-in types, similar to those of
    many\n   programming languages, but with some differences due to special\n   requirements
    from the management information model.\n   Additional types may be defined that
    are derived from those built-in\n   types or from other derived types.  Derived
    types may use subtyping\n   to formally restrict the set of possible values.\n
    \  The different built-in types and their derived types allow different\n   kinds
    of subtyping, namely length and regular expression restrictions\n   of strings
    (Sections 9.4.4 and 9.4.5) and range restrictions of\n   numeric types (Section
    9.2.4).\n   The lexical representation of a value of a certain type is used in\n
    \  the XML encoding and when specifying default values and numerical\n   ranges
    in YANG modules.\n"
  - contents:
    - "9.1.  Canonical Representation\n   For most types, there is a single canonical
      representation of the\n   type's values.  Some types allow multiple lexical
      representations of\n   the same value; for example, the positive integer \"17\"
      can be\n   represented as \"+17\" or \"17\".  Implementations MUST support all\n
      \  lexical representations specified in this document.\n   When a server sends
      XML-encoded data, it MUST use the canonical form\n   defined in this section.
      \ Other encodings may introduce alternate\n   representations.  Note, however,
      that values in the data tree are\n   conceptually stored in the canonical representation
      as defined in\n   this section.  In particular, any XPath expression evaluations
      are\n   done using the canonical form if the data type has a canonical form.\n
      \  If the data type does not have a canonical form, the format of the\n   value
      MUST match the data type's lexical representation, but the\n   exact format
      is implementation dependent.\n   Some types have a lexical representation that
      depends on the\n   encoding, e.g., the XML context in which they occur.  These
      types do\n   not have a canonical form.\n"
    title: 9.1.  Canonical Representation
  - contents:
    - "9.2.  The Integer Built-In Types\n   The integer built-in types are int8, int16,
      int32, int64, uint8,\n   uint16, uint32, and uint64.  They represent signed
      and unsigned\n   integers of different sizes:\n   int8  represents integer values
      between -128 and 127, inclusively.\n   int16  represents integer values between
      -32768 and 32767,\n      inclusively.\n   int32  represents integer values between
      -2147483648 and 2147483647,\n      inclusively.\n   int64  represents integer
      values between -9223372036854775808 and\n      9223372036854775807, inclusively.\n
      \  uint8  represents integer values between 0 and 255, inclusively.\n   uint16
      \ represents integer values between 0 and 65535, inclusively.\n   uint32  represents
      integer values between 0 and 4294967295,\n      inclusively.\n   uint64  represents
      integer values between 0 and 18446744073709551615,\n      inclusively.\n"
    - contents:
      - "9.2.1.  Lexical Representation\n   An integer value is lexically represented
        as an optional sign (\"+\" or\n   \"-\"), followed by a sequence of decimal
        digits.  If no sign is\n   specified, \"+\" is assumed.\n   For convenience,
        when specifying a default value for an integer in a\n   YANG module, an alternative
        lexical representation can be used that\n   represents the value in a hexadecimal
        or octal notation.  The\n   hexadecimal notation consists of an optional sign
        (\"+\" or \"-\"),\n   followed by the characters \"0x\", followed by a number
        of hexadecimal\n   digits where letters may be uppercase or lowercase.  The
        octal\n   notation consists of an optional sign (\"+\" or \"-\"), followed
        by the\n   character \"0\", followed by a number of octal digits.\n   Note
        that if a default value in a YANG module has a leading zero\n   (\"0\"), it
        is interpreted as an octal number.  In the XML encoding, an\n   integer is
        always interpreted as a decimal number, and leading zeros\n   are allowed.\n
        \  Examples:\n     // legal values\n     +4711                       // legal
        positive value\n     4711                        // legal positive value\n
        \    -123                        // legal negative value\n     0xf00f                      //
        legal positive hexadecimal value\n     -0xf                        // legal
        negative hexadecimal value\n     052                         // legal positive
        octal value\n     // illegal values\n     - 1                         // illegal
        intermediate space\n"
      title: 9.2.1.  Lexical Representation
    - contents:
      - "9.2.2.  Canonical Form\n   The canonical form of a positive integer does
        not include the sign\n   \"+\".  Leading zeros are prohibited.  The value
        zero is represented\n   as \"0\".\n"
      title: 9.2.2.  Canonical Form
    - contents:
      - "9.2.3.  Restrictions\n   All integer types can be restricted with the \"range\"
        statement\n   (Section 9.2.4).\n"
      title: 9.2.3.  Restrictions
    - contents:
      - "9.2.4.  The \"range\" Statement\n   The \"range\" statement, which is an
        optional substatement to the\n   \"type\" statement, takes as an argument
        a range expression string.  It\n   is used to restrict integer and decimal
        built-in types, or types\n   derived from them.\n   A range consists of an
        explicit value, or a lower-inclusive bound,\n   two consecutive dots \"..\",
        and an upper-inclusive bound.  Multiple\n   values or ranges can be given,
        separated by \"|\".  If multiple values\n   or ranges are given, they all
        MUST be disjoint and MUST be in\n   ascending order.  If a range restriction
        is applied to a type that is\n   already range-restricted, the new restriction
        MUST be equally\n   limiting or more limiting, i.e., raising the lower bounds,
        reducing\n   the upper bounds, removing explicit values or ranges, or splitting\n
        \  ranges into multiple ranges with intermediate gaps.  Each explicit\n   value
        and range boundary value given in the range expression MUST\n   match the
        type being restricted or be one of the special values \"min\"\n   or \"max\".
        \ \"min\" and \"max\" mean the minimum and maximum values\n   accepted for
        the type being restricted, respectively.\n   The range expression syntax is
        formally defined by the rule\n   \"range-arg\" in Section 14.\n"
      - contents:
        - "9.2.4.1.  The range's Substatements\n                 +---------------+---------+-------------+\n
          \                | substatement  | section | cardinality |\n                 +---------------+---------+-------------+\n
          \                | description   | 7.21.3  | 0..1        |\n                 |
          error-app-tag | 7.5.4.2 | 0..1        |\n                 | error-message
          | 7.5.4.1 | 0..1        |\n                 | reference     | 7.21.4  |
          0..1        |\n                 +---------------+---------+-------------+\n"
        title: 9.2.4.1.  The range's Substatements
      title: 9.2.4.  The "range" Statement
    - contents:
      - "9.2.5.  Usage Example\n     typedef my-base-int32-type {\n       type int32
        {\n         range \"1..4 | 10..20\";\n       }\n     }\n     typedef my-type1
        {\n       type my-base-int32-type {\n         // legal range restriction\n
        \        range \"11..max\"; // 11..20\n       }\n     }\n     typedef my-type2
        {\n       type my-base-int32-type {\n         // illegal range restriction\n
        \        range \"11..100\";\n       }\n     }\n"
      title: 9.2.5.  Usage Example
    title: 9.2.  The Integer Built-In Types
  - contents:
    - "9.3.  The decimal64 Built-In Type\n   The decimal64 built-in type represents
      a subset of the real numbers,\n   which can be represented by decimal numerals.
      \ The value space of\n   decimal64 is the set of numbers that can be obtained
      by multiplying a\n   64-bit signed integer by a negative power of ten, i.e.,
      expressible\n   as \"i x 10^-n\" where i is an integer64 and n is an integer
      between 1\n   and 18, inclusively.\n"
    - contents:
      - "9.3.1.  Lexical Representation\n   A decimal64 value is lexically represented
        as an optional sign (\"+\"\n   or \"-\"), followed by a sequence of decimal
        digits, optionally\n   followed by a period ('.') as a decimal indicator and
        a sequence of\n   decimal digits.  If no sign is specified, \"+\" is assumed.\n"
      title: 9.3.1.  Lexical Representation
    - contents:
      - "9.3.2.  Canonical Form\n   The canonical form of a positive decimal64 value
        does not include the\n   sign \"+\".  The decimal point is required.  Leading
        and trailing zeros\n   are prohibited, subject to the rule that there MUST
        be at least one\n   digit before and after the decimal point.  The value zero
        is\n   represented as \"0.0\".\n"
      title: 9.3.2.  Canonical Form
    - contents:
      - "9.3.3.  Restrictions\n   A decimal64 type can be restricted with the \"range\"
        statement\n   (Section 9.2.4).\n"
      title: 9.3.3.  Restrictions
    - contents:
      - "9.3.4.  The \"fraction-digits\" Statement\n   The \"fraction-digits\" statement,
        which is a substatement to the\n   \"type\" statement, MUST be present if
        the type is \"decimal64\".  It\n   takes as an argument an integer between
        1 and 18, inclusively.  It\n   controls the size of the minimum difference
        between values of a\n   decimal64 type by restricting the value space to numbers
        that are\n   expressible as \"i x 10^-n\" where n is the fraction-digits argument.\n
        \  The following table lists the minimum and maximum values for each\n   fraction-digit
        value:\n     +----------------+-----------------------+----------------------+\n
        \    | fraction-digit | min                   | max                  |\n     +----------------+-----------------------+----------------------+\n
        \    | 1              | -922337203685477580.8 | 922337203685477580.7 |\n     |
        2              | -92233720368547758.08 | 92233720368547758.07 |\n     | 3
        \             | -9223372036854775.808 | 9223372036854775.807 |\n     | 4              |
        -922337203685477.5808 | 922337203685477.5807 |\n     | 5              | -92233720368547.75808
        | 92233720368547.75807 |\n     | 6              | -9223372036854.775808 |
        9223372036854.775807 |\n     | 7              | -922337203685.4775808 | 922337203685.4775807
        |\n     | 8              | -92233720368.54775808 | 92233720368.54775807 |\n
        \    | 9              | -9223372036.854775808 | 9223372036.854775807 |\n     |
        10             | -922337203.6854775808 | 922337203.6854775807 |\n     | 11
        \            | -92233720.36854775808 | 92233720.36854775807 |\n     | 12             |
        -9223372.036854775808 | 9223372.036854775807 |\n     | 13             | -922337.2036854775808
        | 922337.2036854775807 |\n     | 14             | -92233.72036854775808 |
        92233.72036854775807 |\n     | 15             | -9223.372036854775808 | 9223.372036854775807
        |\n     | 16             | -922.3372036854775808 | 922.3372036854775807 |\n
        \    | 17             | -92.23372036854775808 | 92.23372036854775807 |\n     |
        18             | -9.223372036854775808 | 9.223372036854775807 |\n     +----------------+-----------------------+----------------------+\n"
      title: 9.3.4.  The "fraction-digits" Statement
    - contents:
      - "9.3.5.  Usage Example\n     typedef my-decimal {\n       type decimal64 {\n
        \        fraction-digits 2;\n         range \"1 .. 3.14 | 10 | 20..max\";\n
        \      }\n     }\n"
      title: 9.3.5.  Usage Example
    title: 9.3.  The decimal64 Built-In Type
  - contents:
    - "9.4.  The string Built-In Type\n   The string built-in type represents human-readable
      strings in YANG.\n   Legal characters are the Unicode and ISO/IEC 10646 [ISO.10646]\n
      \  characters, including tab, carriage return, and line feed but\n   excluding
      the other C0 control characters, the surrogate blocks, and\n   the noncharacters.
      \ The string syntax is formally defined by the rule\n   \"yang-string\" in Section
      14.\n"
    - contents:
      - "9.4.1.  Lexical Representation\n   A string value is lexically represented
        as character data in the XML\n   encoding.\n"
      title: 9.4.1.  Lexical Representation
    - contents:
      - "9.4.2.  Canonical Form\n   The canonical form is the same as the lexical
        representation.  No\n   Unicode normalization of string values is performed.\n"
      title: 9.4.2.  Canonical Form
    - contents:
      - "9.4.3.  Restrictions\n   A string can be restricted with the \"length\" (Section
        9.4.4) and\n   \"pattern\" (Section 9.4.5) statements.\n"
      title: 9.4.3.  Restrictions
    - contents:
      - "9.4.4.  The \"length\" Statement\n   The \"length\" statement, which is an
        optional substatement to the\n   \"type\" statement, takes as an argument
        a length expression string.\n   It is used to restrict the built-in types
        \"string\" and \"binary\" or\n   types derived from them.\n   A \"length\"
        statement restricts the number of Unicode characters in\n   the string.\n
        \  A length range consists of an explicit value, or a lower bound, two\n   consecutive
        dots \"..\", and an upper bound.  Multiple values or ranges\n   can be given,
        separated by \"|\".  Length-restricting values MUST NOT\n   be negative.  If
        multiple values or ranges are given, they all MUST\n   be disjoint and MUST
        be in ascending order.  If a length restriction\n   is applied to a type that
        is already length-restricted, the new\n   restriction MUST be equally limiting
        or more limiting, i.e., raising\n   the lower bounds, reducing the upper bounds,
        removing explicit length\n   values or ranges, or splitting ranges into multiple
        ranges with\n   intermediate gaps.  A length value is a non-negative integer
        or one\n   of the special values \"min\" or \"max\".  \"min\" and \"max\"
        mean the\n   minimum and maximum lengths accepted for the type being restricted,\n
        \  respectively.  An implementation is not required to support a length\n
        \  value larger than 18446744073709551615.\n   The length expression syntax
        is formally defined by the rule\n   \"length-arg\" in Section 14.\n"
      - contents:
        - "9.4.4.1.  The length's Substatements\n                 +---------------+---------+-------------+\n
          \                | substatement  | section | cardinality |\n                 +---------------+---------+-------------+\n
          \                | description   | 7.21.3  | 0..1        |\n                 |
          error-app-tag | 7.5.4.2 | 0..1        |\n                 | error-message
          | 7.5.4.1 | 0..1        |\n                 | reference     | 7.21.4  |
          0..1        |\n                 +---------------+---------+-------------+\n"
        title: 9.4.4.1.  The length's Substatements
      title: 9.4.4.  The "length" Statement
    - contents:
      - "9.4.5.  The \"pattern\" Statement\n   The \"pattern\" statement, which is
        an optional substatement to the\n   \"type\" statement, takes as an argument
        a regular expression string,\n   as defined in [XSD-TYPES].  It is used to
        restrict the built-in type\n   \"string\", or types derived from \"string\",
        to values that match the\n   pattern.\n   If the type has multiple \"pattern\"
        statements, the expressions are\n   ANDed together, i.e., all such expressions
        have to match.\n   If a pattern restriction is applied to a type that is already\n
        \  pattern-restricted, values must match all patterns in the base type,\n
        \  in addition to the new patterns.\n"
      - contents:
        - "9.4.5.1.  The pattern's Substatements\n                 +---------------+---------+-------------+\n
          \                | substatement  | section | cardinality |\n                 +---------------+---------+-------------+\n
          \                | description   | 7.21.3  | 0..1        |\n                 |
          error-app-tag | 7.5.4.2 | 0..1        |\n                 | error-message
          | 7.5.4.1 | 0..1        |\n                 | modifier      | 9.4.6   |
          0..1        |\n                 | reference     | 7.21.4  | 0..1        |\n
          \                +---------------+---------+-------------+\n"
        title: 9.4.5.1.  The pattern's Substatements
      title: 9.4.5.  The "pattern" Statement
    - contents:
      - "9.4.6.  The \"modifier\" Statement\n   The \"modifier\" statement, which
        is an optional substatement to the\n   \"pattern\" statement, takes as an
        argument the string \"invert-match\".\n   If a pattern has the \"invert-match\"
        modifier present, the type is\n   restricted to values that do not match the
        pattern.\n"
      title: 9.4.6.  The "modifier" Statement
    - contents:
      - "9.4.7.  Usage Example\n   With the following typedef:\n     typedef my-base-str-type
        {\n       type string {\n         length \"1..255\";\n       }\n     }\n   the
        following refinement is legal:\n     type my-base-str-type {\n       // legal
        length refinement\n       length \"11 | 42..max\"; // 11 | 42..255\n     }\n
        \  and the following refinement is illegal:\n     type my-base-str-type {\n
        \      // illegal length refinement\n       length \"1..999\";\n     }\n   With
        the following type:\n     type string {\n       length \"0..4\";\n       pattern
        \"[0-9a-fA-F]*\";\n     }\n   the following strings match:\n     AB          //
        legal\n     9A00        // legal\n   and the following strings do not match:\n
        \    00ABAB      // illegal, too long\n     xx00        // illegal, bad characters\n
        \  With the following type:\n     type string {\n       length \"1..max\";\n
        \      pattern '[a-zA-Z_][a-zA-Z0-9\\-_.]*';\n       pattern '[xX][mM][lL].*'
        {\n         modifier invert-match;\n       }\n     }\n   the following string
        matches:\n     enabled     // legal\n   and the following strings do not match:\n
        \    10-mbit     // illegal, starts with a number\n     xml-element // illegal,
        starts with illegal sequence\n"
      title: 9.4.7.  Usage Example
    title: 9.4.  The string Built-In Type
  - contents:
    - "9.5.  The boolean Built-In Type\n   The boolean built-in type represents a
      boolean value.\n"
    - contents:
      - "9.5.1.  Lexical Representation\n   The lexical representation of a boolean
        value is a string with a\n   value of \"true\" or \"false\".  These values
        MUST be in lowercase.\n"
      title: 9.5.1.  Lexical Representation
    - contents:
      - "9.5.2.  Canonical Form\n   The canonical form is the same as the lexical
        representation.\n"
      title: 9.5.2.  Canonical Form
    - contents:
      - "9.5.3.  Restrictions\n   A boolean cannot be restricted.\n"
      title: 9.5.3.  Restrictions
    title: 9.5.  The boolean Built-In Type
  - contents:
    - "9.6.  The enumeration Built-In Type\n   The enumeration built-in type represents
      values from a set of\n   assigned names.\n"
    - contents:
      - "9.6.1.  Lexical Representation\n   The lexical representation of an enumeration
        value is the assigned\n   name string.\n"
      title: 9.6.1.  Lexical Representation
    - contents:
      - "9.6.2.  Canonical Form\n   The canonical form is the assigned name string.\n"
      title: 9.6.2.  Canonical Form
    - contents:
      - "9.6.3.  Restrictions\n   An enumeration can be restricted with one or more
        \"enum\"\n   (Section 9.6.4) statements, which enumerate a subset of the values\n
        \  for the base type.\n"
      title: 9.6.3.  Restrictions
    - contents:
      - "9.6.4.  The \"enum\" Statement\n   The \"enum\" statement, which is a substatement
        to the \"type\"\n   statement, MUST be present if the type is \"enumeration\".
        \ It is\n   repeatedly used to specify each assigned name of an enumeration
        type.\n   It takes as an argument a string that is the assigned name.  The\n
        \  string MUST NOT be zero-length and MUST NOT have any leading or\n   trailing
        whitespace characters (any Unicode character with the\n   \"White_Space\"
        property).  The use of Unicode control codes SHOULD be\n   avoided.\n   The
        statement is optionally followed by a block of substatements that\n   holds
        detailed enum information.\n   All assigned names in an enumeration MUST be
        unique.\n   When an existing enumeration type is restricted, the set of assigned\n
        \  names in the new type MUST be a subset of the base type's set of\n   assigned
        names.  The value of such an assigned name MUST NOT be\n   changed.\n"
      - contents:
        - "9.6.4.1.  The enum's Substatements\n                 +--------------+---------+-------------+\n
          \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
          \                | description  | 7.21.3  | 0..1        |\n                 |
          if-feature   | 7.20.2  | 0..n        |\n                 | reference    |
          7.21.4  | 0..1        |\n                 | status       | 7.21.2  | 0..1
          \       |\n                 | value        | 9.6.4.2 | 0..1        |\n                 +--------------+---------+-------------+\n"
        title: 9.6.4.1.  The enum's Substatements
      - contents:
        - "9.6.4.2.  The \"value\" Statement\n   The \"value\" statement, which is
          optional, is used to associate an\n   integer value with the assigned name
          for the enum.  This integer\n   value MUST be in the range -2147483648 to
          2147483647, and it MUST be\n   unique within the enumeration type.\n   If
          a value is not specified, then one will be automatically assigned.\n   If
          the \"enum\" substatement is the first one defined, the assigned\n   value
          is zero (0); otherwise, the assigned value is one greater than\n   the current
          highest enum value (i.e., the highest enum value,\n   implicit or explicit,
          prior to the current \"enum\" substatement in the\n   parent \"type\" statement).\n
          \  Note that the presence of an \"if-feature\" statement in an \"enum\"\n
          \  statement does not affect the automatically assigned value.\n   If the
          current highest value is equal to 2147483647, then an enum\n   value MUST
          be specified for \"enum\" substatements following the one\n   with the current
          highest value.\n   When an existing enumeration type is restricted, the
          \"value\"\n   statement MUST either have the same value as in the base type
          or not\n   be present, in which case the value is the same as in the base
          type.\n"
        title: 9.6.4.2.  The "value" Statement
      title: 9.6.4.  The "enum" Statement
    - contents:
      - "9.6.5.  Usage Example\n     leaf myenum {\n       type enumeration {\n         enum
        zero;\n         enum one;\n         enum seven {\n           value 7;\n         }\n
        \      }\n     }\n   The lexical representation of the leaf \"myenum\" with\n
        \  value \"seven\" is:\n     <myenum>seven</myenum>\n   With the following
        typedef:\n     typedef my-base-enumeration-type {\n       type enumeration
        {\n         enum white {\n           value 1;\n         }\n         enum yellow
        {\n           value 2;\n         }\n         enum red {\n           value
        3;\n         }\n       }\n     }\n   the following refinement is legal:\n
        \    type my-base-enumeration-type {\n       // legal enum refinement\n       enum
        yellow;\n       enum red {\n         value 3;\n       }\n     }\n   and the
        following refinement is illegal:\n     type my-base-enumeration-type {\n       //
        illegal enum refinement\n       enum yellow {\n         value 4; // illegal
        value change\n       }\n       enum black; // illegal addition of new name\n
        \    }\n   The following example shows how an \"enum\" can be tagged with\n
        \  \"if-feature\", making the value legal only on servers that advertise\n
        \  the corresponding feature:\n     type enumeration {\n       enum tcp;\n
        \      enum ssh {\n         if-feature ssh;\n       }\n       enum tls {\n
        \        if-feature tls;\n       }\n     }\n"
      title: 9.6.5.  Usage Example
    title: 9.6.  The enumeration Built-In Type
  - contents:
    - "9.7.  The bits Built-In Type\n   The bits built-in type represents a bit set.
      \ That is, a bits value\n   is a set of flags identified by small integer position
      numbers\n   starting at 0.  Each bit number has an assigned name.\n   When an
      existing bits type is restricted, the set of assigned names\n   in the new type
      MUST be a subset of the base type's set of assigned\n   names.  The bit position
      of such an assigned name MUST NOT be\n   changed.\n"
    - contents:
      - "9.7.1.  Restrictions\n   A bits type can be restricted with the \"bit\" (Section
        9.7.4)\n   statement.\n"
      title: 9.7.1.  Restrictions
    - contents:
      - "9.7.2.  Lexical Representation\n   The lexical representation of the bits
        type is a space-separated list\n   of the names of the bits that are set.
        \ A zero-length string thus\n   represents a value where no bits are set.\n"
      title: 9.7.2.  Lexical Representation
    - contents:
      - "9.7.3.  Canonical Form\n   In the canonical form, the bit values are separated
        by a single space\n   character and they appear ordered by their position
        (see\n   Section 9.7.4.2).\n"
      title: 9.7.3.  Canonical Form
    - contents:
      - "9.7.4.  The \"bit\" Statement\n   The \"bit\" statement, which is a substatement
        to the \"type\" statement,\n   MUST be present if the type is \"bits\".  It
        is repeatedly used to\n   specify each assigned named bit of a bits type.
        \ It takes as an\n   argument a string that is the assigned name of the bit.
        \ It is\n   followed by a block of substatements that holds detailed bit\n
        \  information.  The assigned name follows the same syntax rules as an\n   identifier
        (see Section 6.2).\n   All assigned names in a bits type MUST be unique.\n"
      - contents:
        - "9.7.4.1.  The bit's Substatements\n                 +--------------+---------+-------------+\n
          \                | substatement | section | cardinality |\n                 +--------------+---------+-------------+\n
          \                | description  | 7.21.3  | 0..1        |\n                 |
          if-feature   | 7.20.2  | 0..n        |\n                 | position     |
          9.7.4.2 | 0..1        |\n                 | reference    | 7.21.4  | 0..1
          \       |\n                 | status       | 7.21.2  | 0..1        |\n                 +--------------+---------+-------------+\n"
        title: 9.7.4.1.  The bit's Substatements
      - contents:
        - "9.7.4.2.  The \"position\" Statement\n   The \"position\" statement, which
          is optional, takes as an argument a\n   non-negative integer value that
          specifies the bit's position within a\n   hypothetical bit field.  The position
          value MUST be in the range 0 to\n   4294967295, and it MUST be unique within
          the bits type.\n   If a bit position is not specified, then one will be
          automatically\n   assigned.  If the \"bit\" substatement is the first one
          defined, the\n   assigned value is zero (0); otherwise, the assigned value
          is one\n   greater than the current highest bit position (i.e., the highest
          bit\n   position, implicit or explicit, prior to the current \"bit\"\n   substatement
          in the parent \"type\" statement).\n   Note that the presence of an \"if-feature\"
          statement in a \"bit\"\n   statement does not affect the automatically assigned
          position.\n   If the current highest bit position value is equal to 4294967295,\n
          \  then a position value MUST be specified for \"bit\" substatements\n   following
          the one with the current highest position value.\n   When an existing bits
          type is restricted, the \"position\" statement\n   MUST either have the
          same value as in the base type or not be\n   present, in which case the
          value is the same as in the base type.\n"
        title: 9.7.4.2.  The "position" Statement
      title: 9.7.4.  The "bit" Statement
    - contents:
      - "9.7.5.  Usage Example\n   Given the following typedef and leaf:\n     typedef
        mybits-type {\n       type bits {\n         bit disable-nagle {\n           position
        0;\n         }\n         bit auto-sense-speed {\n           position 1;\n
        \        }\n         bit ten-mb-only {\n           position 2;\n         }\n
        \      }\n     }\n     leaf mybits {\n       type mybits-type;\n       default
        \"auto-sense-speed\";\n     }\n   The lexical representation of this leaf
        with bit values disable-nagle\n   and ten-mb-only set would be:\n     <mybits>disable-nagle
        ten-mb-only</mybits>\n   The following example shows a legal refinement of
        this type:\n     type mybits-type {\n       // legal bit refinement\n       bit
        disable-nagle {\n         position 0;\n       }\n       bit auto-sense-speed
        {\n         position 1;\n       }\n     }\n   and the following refinement
        is illegal:\n     type mybits-type {\n       // illegal bit refinement\n       bit
        disable-nagle {\n         position 2; // illegal position change\n       }\n
        \      bit hundred-mb-only; // illegal addition of new name\n     }\n"
      title: 9.7.5.  Usage Example
    title: 9.7.  The bits Built-In Type
  - contents:
    - "9.8.  The binary Built-In Type\n   The binary built-in type represents any
      binary data, i.e., a sequence\n   of octets.\n"
    - contents:
      - "9.8.1.  Restrictions\n   A binary type can be restricted with the \"length\"
        (Section 9.4.4)\n   statement.  The length of a binary value is the number
        of octets it\n   contains.\n"
      title: 9.8.1.  Restrictions
    - contents:
      - "9.8.2.  Lexical Representation\n   Binary values are encoded with the base64
        encoding scheme (see\n   Section 4 in [RFC4648]).\n"
      title: 9.8.2.  Lexical Representation
    - contents:
      - "9.8.3.  Canonical Form\n   The canonical form of a binary value follows the
        rules of \"Base 64\n   Encoding\" in [RFC4648].\n"
      title: 9.8.3.  Canonical Form
    title: 9.8.  The binary Built-In Type
  - contents:
    - "9.9.  The leafref Built-In Type\n   The leafref built-in type is restricted
      to the value space of some\n   leaf or leaf-list node in the schema tree and
      optionally further\n   restricted by corresponding instance nodes in the data
      tree.  The\n   \"path\" substatement (Section 9.9.2) is used to identify the
      referred\n   leaf or leaf-list node in the schema tree.  The value space of
      the\n   referring node is the value space of the referred node.\n   If the \"require-instance\"
      property (Section 9.9.3) is \"true\", there\n   MUST exist a node in the data
      tree, or a node with a default value in\n   use (see Sections 7.6.1 and 7.7.2),
      of the referred schema tree leaf\n   or leaf-list node with the same value as
      the leafref value in a valid\n   data tree.\n   If the referring node represents
      configuration data and the\n   \"require-instance\" property (Section 9.9.3)
      is \"true\", the referred\n   node MUST also represent configuration.\n   There
      MUST NOT be any circular chains of leafrefs.\n   If the leaf that the leafref
      refers to is conditional based on one or\n   more features (see Section 7.20.2),
      then the leaf with the leafref\n   type MUST also be conditional based on at
      least the same set of\n   features.\n"
    - contents:
      - "9.9.1.  Restrictions\n   A leafref can be restricted with the \"require-instance\"
        statement\n   (Section 9.9.3).\n"
      title: 9.9.1.  Restrictions
    - contents:
      - "9.9.2.  The \"path\" Statement\n   The \"path\" statement, which is a substatement
        to the \"type\"\n   statement, MUST be present if the type is \"leafref\".
        \ It takes as an\n   argument a string that MUST refer to a leaf or leaf-list
        node.\n   The syntax for a path argument is a subset of the XPath abbreviated\n
        \  syntax.  Predicates are used only for constraining the values for the\n
        \  key nodes for list entries.  Each predicate consists of exactly one\n   equality
        test per key, and multiple adjacent predicates MAY be\n   present if a list
        has multiple keys.  The syntax is formally defined\n   by the rule \"path-arg\"
        in Section 14.\n   The predicates are only used when more than one key reference
        is\n   needed to uniquely identify a leaf instance.  This occurs if a list\n
        \  has multiple keys or a reference to a leaf other than the key in a\n   list
        is needed.  In these cases, multiple leafrefs are typically\n   specified,
        and predicates are used to tie them together.\n   The \"path\" expression
        evaluates to a node set consisting of zero,\n   one, or more nodes.  If the
        \"require-instance\" property is \"true\",\n   this node set MUST be non-empty.\n
        \  The \"path\" XPath expression is conceptually evaluated in the\n   following
        context, in addition to the definition in Section 6.4.1:\n   o  If the \"path\"
        statement is defined within a typedef, the context\n      node is the leaf
        or leaf-list node in the data tree that\n      references the typedef.\n   o
        \ Otherwise, the context node is the node in the data tree for which\n      the
        \"path\" statement is defined.\n"
      title: 9.9.2.  The "path" Statement
    - contents:
      - "9.9.3.  The \"require-instance\" Statement\n   The \"require-instance\" statement,
        which is a substatement to the\n   \"type\" statement, MAY be present if the
        type is \"instance-identifier\"\n   or \"leafref\".  It takes as an argument
        the string \"true\" or \"false\".\n   If this statement is not present, it
        defaults to \"true\".\n   If \"require-instance\" is \"true\", it means that
        the instance being\n   referred to MUST exist for the data to be valid.  This
        constraint is\n   enforced according to the rules in Section 8.\n   If \"require-instance\"
        is \"false\", it means that the instance being\n   referred to MAY exist in
        valid data.\n"
      title: 9.9.3.  The "require-instance" Statement
    - contents:
      - "9.9.4.  Lexical Representation\n   A leafref value is lexically represented
        the same way as the leaf it\n   references represents its value.\n"
      title: 9.9.4.  Lexical Representation
    - contents:
      - "9.9.5.  Canonical Form\n   The canonical form of a leafref is the same as
        the canonical form of\n   the leaf it references.\n"
      title: 9.9.5.  Canonical Form
    - contents:
      - "9.9.6.  Usage Example\n   With the following list:\n     list interface {\n
        \      key \"name\";\n       leaf name {\n         type string;\n       }\n
        \      leaf admin-status {\n         type admin-status;\n       }\n       list
        address {\n         key \"ip\";\n         leaf ip {\n           type yang:ip-address;\n
        \        }\n       }\n     }\n   the following leafref refers to an existing
        interface:\n     leaf mgmt-interface {\n       type leafref {\n         path
        \"../interface/name\";\n       }\n     }\n   An example of a corresponding
        XML snippet:\n     <interface>\n       <name>eth0</name>\n     </interface>\n
        \    <interface>\n       <name>lo</name>\n     </interface>\n     <mgmt-interface>eth0</mgmt-interface>\n
        \  The following leafrefs refer to an existing address of an interface:\n
        \    container default-address {\n       leaf ifname {\n         type leafref
        {\n           path \"../../interface/name\";\n         }\n       }\n       leaf
        address {\n         type leafref {\n           path \"../../interface[name
        = current()/../ifname]\"\n              + \"/address/ip\";\n         }\n       }\n
        \    }\n   An example of a corresponding XML snippet:\n     <interface>\n
        \      <name>eth0</name>\n       <admin-status>up</admin-status>\n       <address>\n
        \        <ip>192.0.2.1</ip>\n       </address>\n       <address>\n         <ip>192.0.2.2</ip>\n
        \      </address>\n     </interface>\n     <interface>\n       <name>lo</name>\n
        \      <admin-status>up</admin-status>\n       <address>\n         <ip>127.0.0.1</ip>\n
        \      </address>\n     </interface>\n     <default-address>\n       <ifname>eth0</ifname>\n
        \      <address>192.0.2.2</address>\n     </default-address>\n   The following
        list uses a leafref for one of its keys.  This is\n   similar to a foreign
        key in a relational database.\n     list packet-filter {\n       key \"if-name
        filter-id\";\n       leaf if-name {\n         type leafref {\n           path
        \"/interface/name\";\n         }\n       }\n       leaf filter-id {\n         type
        uint32;\n       }\n       ...\n     }\n   An example of a corresponding XML
        snippet:\n     <interface>\n       <name>eth0</name>\n       <admin-status>up</admin-status>\n
        \      <address>\n         <ip>192.0.2.1</ip>\n       </address>\n       <address>\n
        \        <ip>192.0.2.2</ip>\n       </address>\n     </interface>\n     <packet-filter>\n
        \      <if-name>eth0</if-name>\n       <filter-id>1</filter-id>\n       ...\n
        \    </packet-filter>\n     <packet-filter>\n       <if-name>eth0</if-name>\n
        \      <filter-id>2</filter-id>\n       ...\n     </packet-filter>\n   The
        following notification defines two leafrefs to refer to an\n   existing admin-status:\n
        \    notification link-failure {\n       leaf if-name {\n         type leafref
        {\n           path \"/interface/name\";\n         }\n       }\n       leaf
        admin-status {\n         type leafref {\n           path \"/interface[name
        = current()/../if-name]\"\n              + \"/admin-status\";\n         }\n
        \      }\n     }\n   An example of a corresponding XML notification:\n     <notification\n
        \      xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n       <eventTime>2008-04-01T00:01:00Z</eventTime>\n
        \      <link-failure xmlns=\"urn:example:system\">\n         <if-name>eth0</if-name>\n
        \        <admin-status>up</admin-status>\n       </link-failure>\n     </notification>\n"
      title: 9.9.6.  Usage Example
    title: 9.9.  The leafref Built-In Type
  - contents:
    - "9.10.  The identityref Built-In Type\n   The identityref built-in type is used
      to reference an existing\n   identity (see Section 7.18).\n"
    - contents:
      - "9.10.1.  Restrictions\n   An identityref cannot be restricted.\n"
      title: 9.10.1.  Restrictions
    - contents:
      - "9.10.2.  The identityref's \"base\" Statement\n   The \"base\" statement,
        which is a substatement to the \"type\"\n   statement, MUST be present at
        least once if the type is\n   \"identityref\".  The argument is the name of
        an identity, as defined\n   by an \"identity\" statement.  If a prefix is
        present on the identity\n   name, it refers to an identity defined in the
        module that was\n   imported with that prefix.  Otherwise, an identity with
        the matching\n   name MUST be defined in the current module or an included
        submodule.\n   Valid values for an identityref are any identities derived
        from all\n   the identityref's base identities.  On a particular server, the
        valid\n   values are further restricted to the set of identities defined in
        the\n   modules implemented by the server.\n"
      title: 9.10.2.  The identityref's "base" Statement
    - contents:
      - "9.10.3.  Lexical Representation\n   An identityref is lexically represented
        as the referred identity's\n   qualified name as defined in [XML-NAMES].  If
        the prefix is not\n   present, the namespace of the identityref is the default
        namespace\n   in effect on the element that contains the identityref value.\n
        \  When an identityref is given a default value using the \"default\"\n   statement,
        the identity name in the default value MAY have a prefix.\n   If a prefix
        is present on the identity name, it refers to an identity\n   defined in the
        module that was imported with that prefix, or the\n   prefix for the current
        module if the identity is defined in the\n   current module or one of its
        submodules.  Otherwise, an identity with\n   the matching name MUST be defined
        in the current module or one of its\n   submodules.\n   The string value of
        a node of type \"identityref\" in a \"must\" or\n   \"when\" XPath expression
        is the referred identity's qualified name\n   with the prefix present.  If
        the referred identity is defined in an\n   imported module, the prefix in
        the string value is the prefix defined\n   in the corresponding \"import\"
        statement.  Otherwise, the prefix in\n   the string value is the prefix for
        the current module.\n"
      title: 9.10.3.  Lexical Representation
    - contents:
      - "9.10.4.  Canonical Form\n   Since the lexical form depends on the XML context
        in which the value\n   occurs, this type does not have a canonical form.\n"
      title: 9.10.4.  Canonical Form
    - contents:
      - "9.10.5.  Usage Example\n   With the identity definitions in Section 7.18.3
        and the following\n   module:\n     module example-my-crypto {\n       yang-version
        1.1;\n       namespace \"urn:example:my-crypto\";\n       prefix mc;\n       import
        \"example-crypto-base\" {\n         prefix \"crypto\";\n       }\n       identity
        aes {\n         base \"crypto:crypto-alg\";\n       }\n       leaf crypto
        {\n         type identityref {\n           base \"crypto:crypto-alg\";\n         }\n
        \      }\n       container aes-parameters {\n         when \"../crypto = 'mc:aes'\";\n
        \        ...\n       }\n     }\n   the following is an example of how the
        leaf \"crypto\" can be encoded,\n   if the value is the \"des3\" identity
        defined in the \"des\" module:\n     <crypto xmlns:des=\"urn:example:des\">des:des3</crypto>\n
        \  Any prefixes used in the encoding are local to each instance\n   encoding.
        \ This means that the same identityref may be encoded\n   differently by different
        implementations.  For example, the following\n   example encodes the same
        leaf as above:\n     <crypto xmlns:x=\"urn:example:des\">x:des3</crypto>\n
        \  If the \"crypto\" leaf's value is instead \"aes\", defined in the\n   \"example-my-crypto\"
        module, it can be encoded as:\n     <crypto xmlns:mc=\"urn:example:my-crypto\">mc:aes</crypto>\n
        \  or, using the default namespace:\n     <crypto>aes</crypto>\n"
      title: 9.10.5.  Usage Example
    title: 9.10.  The identityref Built-In Type
  - contents:
    - "9.11.  The empty Built-In Type\n   The empty built-in type represents a leaf
      that does not have any\n   value; it conveys information by its presence or
      absence.\n   An empty type cannot have a default value.\n"
    - contents:
      - "9.11.1.  Restrictions\n   An empty type cannot be restricted.\n"
      title: 9.11.1.  Restrictions
    - contents:
      - "9.11.2.  Lexical Representation\n   Not applicable.\n"
      title: 9.11.2.  Lexical Representation
    - contents:
      - "9.11.3.  Canonical Form\n   Not applicable.\n"
      title: 9.11.3.  Canonical Form
    - contents:
      - "9.11.4.  Usage Example\n   With the following leaf:\n     leaf enable-qos
        {\n       type empty;\n     }\n   the following is an example of a valid encoding
        if the leaf exists:\n     <enable-qos/>\n"
      title: 9.11.4.  Usage Example
    title: 9.11.  The empty Built-In Type
  - contents:
    - "9.12.  The union Built-In Type\n   The union built-in type represents a value
      that corresponds to one of\n   its member types.\n   When the type is \"union\",
      the \"type\" statement (Section 7.4) MUST be\n   present.  It is repeatedly
      used to specify each member type of the\n   union.  It takes as an argument
      a string that is the name of a\n   member type.\n   A member type can be of
      any built-in or derived type.\n   When generating an XML encoding, a value is
      encoded according to the\n   rules of the member type to which the value belongs.
      \ When\n   interpreting an XML encoding, a value is validated consecutively\n
      \  against each member type, in the order they are specified in the\n   \"type\"
      statement, until a match is found.  The type that matched will\n   be the type
      of the value for the node that was validated, and the\n   encoding is interpreted
      according to the rules for that type.\n   Any default value or \"units\" property
      defined in the member types is\n   not inherited by the union type.\n"
    - contents:
      - "9.12.1.  Restrictions\n   A union cannot be restricted.  However, each member
        type can be\n   restricted, based on the rules defined in Section 9.\n"
      title: 9.12.1.  Restrictions
    - contents:
      - "9.12.2.  Lexical Representation\n   The lexical representation of a union
        is a value that corresponds to\n   the representation of any one of the member
        types.\n"
      title: 9.12.2.  Lexical Representation
    - contents:
      - "9.12.3.  Canonical Form\n   The canonical form of a union value is the same
        as the canonical form\n   of the member type of the value.\n"
      title: 9.12.3.  Canonical Form
    - contents:
      - "9.12.4.  Usage Example\n   The following is a union of an int32 and an enumeration:\n
        \    type union {\n       type int32;\n       type enumeration {\n         enum
        \"unbounded\";\n       }\n     }\n   Care must be taken when a member type
        is a leafref where the\n   \"require-instance\" property (Section 9.9.3) is
        \"true\".  If a leaf of\n   such a type refers to an existing instance, the
        leaf's value must be\n   revalidated if the target instance is deleted.  For
        example, with the\n   following definitions:\n     list filter {\n       key
        name;\n       leaf name {\n         type string;\n       }\n       ...\n     }\n
        \    leaf outbound-filter {\n       type union {\n         type leafref {\n
        \          path \"/filter/name\";\n         }\n         type enumeration {\n
        \          enum default-filter;\n         }\n       }\n     }\n   assume that
        there exists an entry in the filter list with the name\n   \"http\" and that
        the outbound-filter leaf has this value:\n     <filter>\n       <name>http</name>\n
        \    </filter>\n     <outbound-filter>http</outbound-filter>\n   If the filter
        entry \"http\" is removed, the outbound-filter leaf's\n   value doesn't match
        the leafref, and the next member type is checked.\n   The current value (\"http\")
        doesn't match the enumeration, so the\n   resulting configuration is invalid.\n
        \  If the second member type in the union had been of type \"string\"\n   instead
        of an enumeration, the current value would have matched, and\n   the resulting
        configuration would have been valid.\n"
      title: 9.12.4.  Usage Example
    title: 9.12.  The union Built-In Type
  - contents:
    - "9.13.  The instance-identifier Built-In Type\n   The instance-identifier built-in
      type is used to uniquely identify a\n   particular instance node in the data
      tree.\n   The syntax for an instance-identifier is a subset of the XPath\n   abbreviated
      syntax, formally defined by the rule\n   \"instance-identifier\" in Section
      14.  It is used to uniquely identify\n   a node in the data tree.  Predicates
      are used only for specifying the\n   values for the key nodes for list entries,
      a value of a leaf-list\n   entry, or a positional index for a list without keys.
      \ For\n   identifying list entries with keys, each predicate consists of one\n
      \  equality test per key, and each key MUST have a corresponding\n   predicate.
      \ If a key is of type \"empty\", it is represented as a\n   zero-length string
      (\"\").\n   If the leaf with the instance-identifier type represents\n   configuration
      data and the \"require-instance\" property\n   (Section 9.9.3) is \"true\",
      the node it refers to MUST also represent\n   configuration.  Such a leaf puts
      a constraint on valid data.  All\n   such leaf nodes MUST reference existing
      nodes or leaf or leaf-list\n   nodes with their default value in use (see Sections
      7.6.1 and 7.7.2)\n   for the data to be valid.  This constraint is enforced
      according to\n   the rules in Section 8.\n   The \"instance-identifier\" XPath
      expression is conceptually evaluated\n   in the following context, in addition
      to the definition in\n   Section 6.4.1:\n   o  The context node is the root
      node in the accessible tree.\n"
    - contents:
      - "9.13.1.  Restrictions\n   An instance-identifier can be restricted with the
        \"require-instance\"\n   statement (Section 9.9.3).\n"
      title: 9.13.1.  Restrictions
    - contents:
      - "9.13.2.  Lexical Representation\n   An instance-identifier value is lexically
        represented as a string.\n   All node names in an instance-identifier value
        MUST be qualified with\n   explicit namespace prefixes, and these prefixes
        MUST be declared in\n   the XML namespace scope in the instance-identifier's
        XML element.\n   Any prefixes used in the encoding are local to each instance\n
        \  encoding.  This means that the same instance-identifier may be\n   encoded
        differently by different implementations.\n"
      title: 9.13.2.  Lexical Representation
    - contents:
      - "9.13.3.  Canonical Form\n   Since the lexical form depends on the XML context
        in which the value\n   occurs, this type does not have a canonical form.\n"
      title: 9.13.3.  Canonical Form
    - contents:
      - "9.13.4.  Usage Example\n   The following are examples of instance identifiers:\n
        \    /* instance-identifier for a container */\n     /ex:system/ex:services/ex:ssh\n
        \    /* instance-identifier for a leaf */\n     /ex:system/ex:services/ex:ssh/ex:port\n
        \    /* instance-identifier for a list entry */\n     /ex:system/ex:user[ex:name='fred']\n
        \    /* instance-identifier for a leaf in a list entry */\n     /ex:system/ex:user[ex:name='fred']/ex:type\n
        \    /* instance-identifier for a list entry with two keys */\n     /ex:system/ex:server[ex:ip='192.0.2.1'][ex:port='80']\n
        \    /* instance-identifier for a list entry where the second\n        key
        (\"enabled\") is of type \"empty\" */\n     /ex:system/ex:service[ex:name='foo'][ex:enabled='']\n
        \    /* instance-identifier for a leaf-list entry */\n     /ex:system/ex:services/ex:ssh/ex:cipher[.='blowfish-cbc']\n
        \    /* instance-identifier for a list entry without keys */\n     /ex:stats/ex:port[3]\n"
      title: 9.13.4.  Usage Example
    title: 9.13.  The instance-identifier Built-In Type
  title: 9.  Built-In Types
- contents:
  - "10.  XPath Functions\n   This document defines two generic XPath functions and
    five YANG\n   type-specific XPath functions.  The function signatures are specified\n
    \  with the syntax used in [XPATH].\n"
  - contents:
    - '10.1.  Function for Node Sets

      '
    - contents:
      - "10.1.1.  current()\n     node-set current()\n   The current() function takes
        no input parameters and returns a node\n   set with the initial context node
        as its only member.\n"
      - contents:
        - "10.1.1.1.  Usage Example\n   With this list:\n     list interface {\n       key
          \"name\";\n       ...\n       leaf enabled {\n         type boolean;\n       }\n
          \      ...\n     }\n   the following leaf defines a \"must\" expression
          that ensures that the\n   referred interface is enabled:\n     leaf outgoing-interface
          {\n       type leafref {\n         path \"/interface/name\";\n       }\n
          \      must '/interface[name=current()]/enabled = \"true\"';\n     }\n"
        title: 10.1.1.1.  Usage Example
      title: 10.1.1.  current()
    title: 10.1.  Function for Node Sets
  - contents:
    - '10.2.  Function for Strings

      '
    - contents:
      - "10.2.1.  re-match()\n     boolean re-match(string subject, string pattern)\n
        \  The re-match() function returns \"true\" if the \"subject\" string\n   matches
        the regular expression \"pattern\"; otherwise, it returns\n   \"false\".\n
        \  The re-match() function checks to see if a string matches a given\n   regular
        expression.  The regular expressions used are the XML Schema\n   regular expressions
        [XSD-TYPES].  Note that this includes implicit\n   anchoring of the regular
        expression at the head and tail.\n"
      - contents:
        - "10.2.1.1.  Usage Example\n   The expression:\n     re-match(\"1.22.333\",
          \"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\")\n   returns \"true\".\n   To count all
          logical interfaces called eth0.<number>, do:\n     count(/interface[re-match(name,
          \"eth0\\.\\d+\")])\n"
        title: 10.2.1.1.  Usage Example
      title: 10.2.1.  re-match()
    title: 10.2.  Function for Strings
  - contents:
    - '10.3.  Function for the YANG Types "leafref" and "instance-identifier"

      '
    - contents:
      - "10.3.1.  deref()\n     node-set deref(node-set nodes)\n   The deref() function
        follows the reference defined by the first node\n   in document order in the
        argument \"nodes\" and returns the nodes it\n   refers to.\n   If the first
        argument node is of type \"instance-identifier\", the\n   function returns
        a node set that contains the single node that the\n   instance identifier
        refers to, if it exists.  If no such node exists,\n   an empty node set is
        returned.\n   If the first argument node is of type \"leafref\", the function
        returns\n   a node set that contains the nodes that the leafref refers to.\n
        \  Specifically, this set contains the nodes selected by the leafref's\n   \"path\"
        statement (Section 9.9.2) that have the same value as the\n   first argument
        node.\n   If the first argument node is of any other type, an empty node set
        is\n   returned.\n"
      - contents:
        - "10.3.1.1.  Usage Example\n     list interface {\n       key \"name type\";\n
          \      leaf name { ... }\n       leaf type { ... }\n       leaf enabled
          {\n         type boolean;\n       }\n       ...\n     }\n     container
          mgmt-interface {\n       leaf name {\n         type leafref {\n           path
          \"/interface/name\";\n         }\n       }\n       leaf type {\n         type
          leafref {\n           path \"/interface[name=current()/../name]/type\";\n
          \        }\n         must 'deref(.)/../enabled = \"true\"' {\n           error-message\n
          \            \"The management interface cannot be disabled.\";\n         }\n
          \      }\n     }\n"
        title: 10.3.1.1.  Usage Example
      title: 10.3.1.  deref()
    title: 10.3.  Function for the YANG Types "leafref" and "instance-identifier"
  - contents:
    - '10.4.  Functions for the YANG Type "identityref"

      '
    - contents:
      - "10.4.1.  derived-from()\n     boolean derived-from(node-set nodes, string
        identity)\n   The derived-from() function returns \"true\" if any node in
        the\n   argument \"nodes\" is a node of type \"identityref\" and its value
        is an\n   identity that is derived from (see Section 7.18.2) the identity\n
        \  \"identity\"; otherwise, it returns \"false\".\n   The parameter \"identity\"
        is a string matching the rule\n   \"identifier-ref\" in Section 14.  If a
        prefix is present on the\n   identity, it refers to an identity defined in
        the module that was\n   imported with that prefix, or the local module if
        the prefix matches\n   the local module's prefix.  If no prefix is present,
        the identity\n   refers to an identity defined in the current module or an
        included\n   submodule.\n"
      - contents:
        - "10.4.1.1.  Usage Example\n     module example-interface {\n       yang-version
          1.1;\n       ...\n       identity interface-type;\n       identity ethernet
          {\n         base interface-type;\n       }\n       identity fast-ethernet
          {\n         base ethernet;\n       }\n       identity gigabit-ethernet {\n
          \        base ethernet;\n       }\n       list interface {\n         key
          name;\n         ...\n         leaf type {\n           type identityref {\n
          \            base interface-type;\n           }\n         }\n         ...\n
          \      }\n       augment \"/interface\" {\n         when 'derived-from(type,
          \"exif:ethernet\")';\n         // generic Ethernet definitions here\n       }\n
          \      ...\n     }\n"
        title: 10.4.1.1.  Usage Example
      title: 10.4.1.  derived-from()
    - contents:
      - "10.4.2.  derived-from-or-self()\n     boolean derived-from-or-self(node-set
        nodes, string identity)\n   The derived-from-or-self() function returns \"true\"
        if any node in the\n   argument \"nodes\" is a node of type \"identityref\"
        and its value is an\n   identity that is equal to or derived from (see Section
        7.18.2) the\n   identity \"identity\"; otherwise, it returns \"false\".\n
        \  The parameter \"identity\" is a string matching the rule\n   \"identifier-ref\"
        in Section 14.  If a prefix is present on the\n   identity, it refers to an
        identity defined in the module that was\n   imported with that prefix, or
        the local module if the prefix matches\n   the local module's prefix.  If
        no prefix is present, the identity\n   refers to an identity defined in the
        current module or an included\n   submodule.\n"
      - contents:
        - "10.4.2.1.  Usage Example\n   The module defined in Section 10.4.1.1 might
          also have:\n       augment \"/interface\" {\n         when 'derived-from-or-self(type,
          \"exif:fast-ethernet\");\n         // Fast-Ethernet-specific definitions
          here\n       }\n"
        title: 10.4.2.1.  Usage Example
      title: 10.4.2.  derived-from-or-self()
    title: 10.4.  Functions for the YANG Type "identityref"
  - contents:
    - '10.5.  Function for the YANG Type "enumeration"

      '
    - contents:
      - "10.5.1.  enum-value()\n     number enum-value(node-set nodes)\n   The enum-value()
        function checks to see if the first node in document\n   order in the argument
        \"nodes\" is a node of type \"enumeration\" and\n   returns the enum's integer
        value.  If the \"nodes\" node set is empty\n   or if the first node in \"nodes\"
        is not of type \"enumeration\", it\n   returns NaN (not a number).\n"
      - contents:
        - "10.5.1.1.  Usage Example\n   With this data model:\n     list alarm {\n
          \      ...\n       leaf severity {\n         type enumeration {\n           enum
          cleared {\n             value 1;\n           }\n           enum indeterminate
          {\n             value 2;\n           }\n           enum minor {\n             value
          3;\n           }\n           enum warning {\n             value 4;\n           }\n
          \          enum major {\n             value 5;\n           }\n           enum
          critical {\n             value 6;\n           }\n         }\n       }\n
          \    }\n   the following XPath expression selects only alarms that are of\n
          \  severity \"major\" or higher:\n     /alarm[enum-value(severity) >= 5]\n"
        title: 10.5.1.1.  Usage Example
      title: 10.5.1.  enum-value()
    title: 10.5.  Function for the YANG Type "enumeration"
  - contents:
    - '10.6.  Function for the YANG Type "bits"

      '
    - contents:
      - "10.6.1.  bit-is-set()\n     boolean bit-is-set(node-set nodes, string bit-name)\n
        \  The bit-is-set() function returns \"true\" if the first node in\n   document
        order in the argument \"nodes\" is a node of type \"bits\" and\n   its value
        has the bit \"bit-name\" set; otherwise, it returns \"false\".\n"
      - contents:
        - "10.6.1.1.  Usage Example\n   If an interface has this leaf:\n     leaf
          flags {\n       type bits {\n         bit UP;\n         bit PROMISCUOUS\n
          \        bit DISABLED;\n       }\n      }\n   the following XPath expression
          can be used to select all interfaces\n   with the UP flag set:\n     /interface[bit-is-set(flags,
          \"UP\")]\n"
        title: 10.6.1.1.  Usage Example
      title: 10.6.1.  bit-is-set()
    title: 10.6.  Function for the YANG Type "bits"
  title: 10.  XPath Functions
- contents:
  - "11.  Updating a Module\n   As experience is gained with a module, it may be desirable
    to revise\n   that module.  However, changes to published modules are not allowed\n
    \  if they have any potential to cause interoperability problems between\n   a
    client using an original specification and a server using an\n   updated specification.\n
    \  For any published change, a new \"revision\" statement (Section 7.1.9)\n   MUST
    be included in front of the existing \"revision\" statements.  If\n   there are
    no existing \"revision\" statements, then one MUST be added\n   to identify the
    new revision.  Furthermore, any necessary changes\n   MUST be applied to any metadata
    statements, including the\n   \"organization\" and \"contact\" statements (Sections
    7.1.7 and 7.1.8).\n   Note that definitions contained in a module are available
    to be\n   imported by any other module and are referenced in \"import\"\n   statements
    via the module name.  Thus, a module name MUST NOT be\n   changed.  Furthermore,
    the \"namespace\" statement MUST NOT be changed,\n   since all XML elements are
    qualified by the namespace.\n   Obsolete definitions MUST NOT be removed from
    published modules,\n   since their identifiers may still be referenced by other
    modules.\n   A definition in a published module may be revised in any of the\n
    \  following ways:\n   o  An \"enumeration\" type may have new enums added, provided
    the old\n      enums's values do not change.  Note that inserting a new enum\n
    \     before an existing enum or reordering existing enums will result\n      in
    new values for the existing enums, unless they have explicit\n      values assigned
    to them.\n   o  A \"bits\" type may have new bits added, provided the old bit\n
    \     positions do not change.  Note that inserting a new bit before an\n      existing
    bit or reordering existing bits will result in new\n      positions for the existing
    bits, unless they have explicit\n      positions assigned to them.\n   o  A \"range\",
    \"length\", or \"pattern\" statement may expand the allowed\n      value space.\n
    \  o  A \"default\" statement may be added to a leaf that does not have a\n      default
    value (either directly or indirectly through its type).\n   o  A \"units\" statement
    may be added.\n   o  A \"reference\" statement may be added or updated.\n   o
    \ A \"must\" statement may be removed or its constraint relaxed.\n   o  A \"when\"
    statement may be removed or its constraint relaxed.\n   o  A \"mandatory\" statement
    may be removed or changed from \"true\" to\n      \"false\".\n   o  A \"min-elements\"
    statement may be removed, or changed to require\n      fewer elements.\n   o  A
    \"max-elements\" statement may be removed, or changed to allow\n      more elements.\n
    \  o  A \"description\" statement may be added or changed without changing\n      the
    semantics of the definition.\n   o  A \"base\" statement may be added to an \"identity\"
    statement.\n   o  A \"base\" statement may be removed from an \"identityref\"
    type,\n      provided there is at least one \"base\" statement left.\n   o  New
    typedefs, groupings, rpcs, notifications, extensions,\n      features, and identities
    may be added.\n   o  New data definition statements may be added if they do not
    add\n      mandatory nodes (Section 3) to existing nodes or at the top level\n
    \     in a module or submodule, or if they are conditionally dependent\n      on
    a new feature (i.e., have an \"if-feature\" statement that refers\n      to a
    new feature).\n   o  A new \"case\" statement may be added.\n   o  A node that
    represented state data may be changed to represent\n      configuration, provided
    it is not mandatory (Section 3).\n   o  An \"if-feature\" statement may be removed,
    provided its node is not\n      mandatory (Section 3).\n   o  A \"status\" statement
    may be added, or changed from \"current\" to\n      \"deprecated\" or \"obsolete\",
    or changed from \"deprecated\" to\n      \"obsolete\".\n   o  A \"type\" statement
    may be replaced with another \"type\" statement\n      that does not change the
    syntax or semantics of the type.  For\n      example, an inline type definition
    may be replaced with a typedef,\n      but an int8 type cannot be replaced by
    an int16, since the syntax\n      would change.\n   o  Any set of data definition
    nodes may be replaced with another set\n      of syntactically and semantically
    equivalent nodes.  For example,\n      a set of leafs may be replaced by a \"uses\"
    statement of a grouping\n      with the same leafs.\n   o  A module may be split
    into a set of submodules or a submodule may\n      be removed, provided the definitions
    in the module do not change\n      in any way other than those allowed here.\n
    \  o  The \"prefix\" statement may be changed, provided all local uses of\n      the
    prefix are also changed.\n   Otherwise, if the semantics of any previous definition
    are changed\n   (i.e., if a non-editorial change is made to any definition other
    than\n   those specifically allowed above), then this MUST be achieved by a\n
    \  new definition with a new identifier.\n   In statements that have any data
    definition statements as\n   substatements, those data definition substatements
    MUST NOT be\n   reordered.  If new data definition statements are added, they
    can be\n   added anywhere in the sequence of existing substatements.\n"
  title: 11.  Updating a Module
- contents:
  - "12.  Coexistence with YANG Version 1\n   A YANG version 1.1 module MUST NOT include
    a YANG version 1\n   submodule, and a YANG version 1 module MUST NOT include a
    YANG\n   version 1.1 submodule.\n   A YANG version 1 module or submodule MUST
    NOT import a YANG\n   version 1.1 module by revision.\n   A YANG version 1.1 module
    or submodule MAY import a YANG version 1\n   module by revision.\n   If a YANG
    version 1 module A imports module B without revision and\n   module B is updated
    to YANG version 1.1, a server MAY implement both\n   of these modules (A and B)
    at the same time.  In such cases, a\n   NETCONF server MUST advertise both modules
    using the rules defined in\n   Section 5.6.4, and SHOULD advertise module A and
    the latest revision\n   of module B that is specified with YANG version 1 according
    to the\n   rules defined in [RFC6020].\n   This rule exists in order to allow
    implementations of existing YANG\n   version 1 modules together with YANG version
    1.1 modules.  Without\n   this rule, updating a single module to YANG version
    1.1 would have a\n   cascading effect on modules that import it, requiring all
    of them to\n   also be updated to YANG version 1.1, and so on.\n"
  title: 12.  Coexistence with YANG Version 1
- contents:
  - "13.  YIN\n   A YANG module can be translated into an alternative XML-based syntax\n
    \  called YIN.  The translated module is called a YIN module.  This\n   section
    describes bidirectional mapping rules between the two\n   formats.\n   The YANG
    and YIN formats contain equivalent information using\n   different notations.
    \ The YIN notation enables developers to\n   represent YANG data models in XML
    and therefore use the rich set of\n   XML-based tools for data filtering and validation,
    automated\n   generation of code and documentation, and other tasks.  Tools like\n
    \  XSLT or XML validators can be utilized.\n   The mapping between YANG and YIN
    does not modify the information\n   content of the model.  Comments and whitespace
    are not preserved.\n"
  - contents:
    - "13.1.  Formal YIN Definition\n   There is a one-to-one correspondence between
      YANG keywords and YIN\n   elements.  The local name of a YIN element is identical
      to the\n   corresponding YANG keyword.  This means, in particular, that the\n
      \  document element (root) of a YIN document is always <module> or\n   <submodule>.\n
      \  YIN elements corresponding to the YANG keywords belong to the\n   namespace
      whose associated URI is\n   \"urn:ietf:params:xml:ns:yang:yin:1\".\n   YIN elements
      corresponding to extension keywords belong to the\n   namespace of the YANG
      module where the extension keyword is declared\n   via the \"extension\" statement.\n
      \  The names of all YIN elements MUST be properly qualified with their\n   namespaces
      (as specified above) using the standard mechanisms of\n   [XML-NAMES], i.e.,
      \"xmlns\" and \"xmlns:xxx\" attributes.\n   The argument of a YANG statement
      is represented in YIN as either an\n   XML attribute or a subelement of the
      keyword element.  Table 1\n   defines the mapping for the set of YANG keywords.
      \ For extensions,\n   the argument mapping is specified within the \"extension\"
      statement\n   (see Section 7.19).  The following rules hold for arguments:\n
      \  o  If the argument is represented as an attribute, this attribute has\n      no
      namespace.\n   o  If the argument is represented as an element, it is qualified
      by\n      the same namespace as its parent keyword element.\n   o  If the argument
      is represented as an element, it MUST be the first\n      child of the keyword
      element.\n   Substatements of a YANG statement are represented as (additional)\n
      \  children of the keyword element, and their relative order MUST be the\n   same
      as the order of substatements in YANG.\n   Comments in YANG MAY be mapped to
      XML comments.\n            +------------------+---------------+-------------+\n
      \           | keyword          | argument name | yin-element |\n            +------------------+---------------+-------------+\n
      \           | action           | name          | false       |\n            |
      anydata          | name          | false       |\n            | anyxml           |
      name          | false       |\n            | argument         | name          |
      false       |\n            | augment          | target-node   | false       |\n
      \           | base             | name          | false       |\n            |
      belongs-to       | module        | false       |\n            | bit              |
      name          | false       |\n            | case             | name          |
      false       |\n            | choice           | name          | false       |\n
      \           | config           | value         | false       |\n            |
      contact          | text          | true        |\n            | container        |
      name          | false       |\n            | default          | value         |
      false       |\n            | description      | text          | true        |\n
      \           | deviate          | value         | false       |\n            |
      deviation        | target-node   | false       |\n            | enum             |
      name          | false       |\n            | error-app-tag    | value         |
      false       |\n            | error-message    | value         | true        |\n
      \           | extension        | name          | false       |\n            |
      feature          | name          | false       |\n            | fraction-digits
      \ | value         | false       |\n            | grouping         | name          |
      false       |\n            | identity         | name          | false       |\n
      \           | if-feature       | name          | false       |\n            |
      import           | module        | false       |\n            | include          |
      module        | false       |\n            | input            | <no argument>
      | n/a         |\n            | key              | value         | false       |\n
      \           | leaf             | name          | false       |\n            |
      leaf-list        | name          | false       |\n            | length           |
      value         | false       |\n            | list             | name          |
      false       |\n            | mandatory        | value         | false       |\n
      \           | max-elements     | value         | false       |\n            |
      min-elements     | value         | false       |\n            | modifier         |
      value         | false       |\n            | module           | name          |
      false       |\n            | must             | condition     | false       |\n
      \           | namespace        | uri           | false       |\n            |
      notification     | name          | false       |\n            | ordered-by       |
      value         | false       |\n            | organization     | text          |
      true        |\n            | output           | <no argument> | n/a         |\n
      \           | path             | value         | false       |\n            |
      pattern          | value         | false       |\n            | position         |
      value         | false       |\n            | prefix           | value         |
      false       |\n            | presence         | value         | false       |\n
      \           | range            | value         | false       |\n            |
      reference        | text          | true        |\n            | refine           |
      target-node   | false       |\n            | require-instance | value         |
      false       |\n            | revision         | date          | false       |\n
      \           | revision-date    | date          | false       |\n            |
      rpc              | name          | false       |\n            | status           |
      value         | false       |\n            | submodule        | name          |
      false       |\n            | type             | name          | false       |\n
      \           | typedef          | name          | false       |\n            |
      unique           | tag           | false       |\n            | units            |
      name          | false       |\n            | uses             | name          |
      false       |\n            | value            | value         | false       |\n
      \           | when             | condition     | false       |\n            |
      yang-version     | value         | false       |\n            | yin-element
      \     | value         | false       |\n            +------------------+---------------+-------------+\n
      \          Table 1: Mapping of Arguments of the YANG Statements\n"
    - contents:
      - "13.1.1.  Usage Example\n   The following YANG module:\n     module example-foo
        {\n       yang-version 1.1;\n       namespace \"urn:example:foo\";\n       prefix
        \"foo\";\n       import example-extensions {\n         prefix \"myext\";\n
        \      }\n       list interface {\n         key \"name\";\n         leaf name
        {\n           type string;\n         }\n         leaf mtu {\n           type
        uint32;\n           description \"The MTU of the interface.\";\n           myext:c-define
        \"MY_MTU\";\n         }\n       }\n     }\n   where the extension \"c-define\"
        is defined in Section 7.19.3, is\n   translated into the following YIN:\n
        \    <module name=\"example-foo\"\n             xmlns=\"urn:ietf:params:xml:ns:yang:yin:1\"\n
        \            xmlns:foo=\"urn:example:foo\"\n             xmlns:myext=\"urn:example:extensions\">\n
        \      <namespace uri=\"urn:example:foo\"/>\n       <prefix value=\"foo\"/>\n
        \      <import module=\"example-extensions\">\n         <prefix value=\"myext\"/>\n
        \      </import>\n       <list name=\"interface\">\n         <key value=\"name\"/>\n
        \        <leaf name=\"name\">\n           <type name=\"string\"/>\n         </leaf>\n
        \        <leaf name=\"mtu\">\n           <type name=\"uint32\"/>\n           <description>\n
        \            <text>The MTU of the interface.</text>\n           </description>\n
        \          <myext:c-define name=\"MY_MTU\"/>\n         </leaf>\n       </list>\n
        \    </module>\n"
      title: 13.1.1.  Usage Example
    title: 13.1.  Formal YIN Definition
  title: 13.  YIN
- contents:
  - "14.  YANG ABNF Grammar\n   In YANG, almost all statements are unordered.  The
    ABNF grammar\n   [RFC5234] [RFC7405] defines the canonical order.  To improve
    module\n   readability, it is RECOMMENDED that clauses be entered in this order.\n
    \  Within the ABNF grammar, unordered statements are marked with\n   comments.\n
    \  This grammar assumes that the scanner replaces YANG comments with a\n   single
    space character.\n   <CODE BEGINS> file \"yang.abnf\"\n   module-stmt         =
    optsep module-keyword sep identifier-arg-str\n                         optsep\n
    \                        \"{\" stmtsep\n                             module-header-stmts\n
    \                            linkage-stmts\n                             meta-stmts\n
    \                            revision-stmts\n                             body-stmts\n
    \                        \"}\" optsep\n   submodule-stmt      = optsep submodule-keyword
    sep identifier-arg-str\n                         optsep\n                         \"{\"
    stmtsep\n                             submodule-header-stmts\n                             linkage-stmts\n
    \                            meta-stmts\n                             revision-stmts\n
    \                            body-stmts\n                         \"}\" optsep\n
    \  module-header-stmts = ;; these stmts can appear in any order\n                         yang-version-stmt\n
    \                        namespace-stmt\n                         prefix-stmt\n
    \  submodule-header-stmts =\n                         ;; these stmts can appear
    in any order\n                         yang-version-stmt\n                         belongs-to-stmt\n
    \  meta-stmts          = ;; these stmts can appear in any order\n                         [organization-stmt]\n
    \                        [contact-stmt]\n                         [description-stmt]\n
    \                        [reference-stmt]\n   linkage-stmts       = ;; these stmts
    can appear in any order\n                         *import-stmt\n                         *include-stmt\n
    \  revision-stmts      = *revision-stmt\n   body-stmts          = *(extension-stmt
    /\n                           feature-stmt /\n                           identity-stmt
    /\n                           typedef-stmt /\n                           grouping-stmt
    /\n                           data-def-stmt /\n                           augment-stmt
    /\n                           rpc-stmt /\n                           notification-stmt
    /\n                           deviation-stmt)\n   data-def-stmt       = container-stmt
    /\n                         leaf-stmt /\n                         leaf-list-stmt
    /\n                         list-stmt /\n                         choice-stmt
    /\n                         anydata-stmt /\n                         anyxml-stmt
    /\n                         uses-stmt\n   yang-version-stmt   = yang-version-keyword
    sep yang-version-arg-str\n                         stmtend\n   yang-version-arg-str
    = < a string that matches the rule >\n                          < yang-version-arg
    >\n   yang-version-arg    = \"1.1\"\n   import-stmt         = import-keyword sep
    identifier-arg-str optsep\n                         \"{\" stmtsep\n                             ;;
    these stmts can appear in any order\n                             prefix-stmt\n
    \                            [revision-date-stmt]\n                             [description-stmt]\n
    \                            [reference-stmt]\n                         \"}\"
    stmtsep\n   include-stmt        = include-keyword sep identifier-arg-str optsep\n
    \                        (\";\" /\n                          \"{\" stmtsep\n                              ;;
    these stmts can appear in any order\n                              [revision-date-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                         \"}\") stmtsep\n   namespace-stmt      = namespace-keyword
    sep uri-str stmtend\n   uri-str             = < a string that matches the rule
    >\n                         < URI in RFC 3986 >\n   prefix-stmt         = prefix-keyword
    sep prefix-arg-str stmtend\n   belongs-to-stmt     = belongs-to-keyword sep identifier-arg-str\n
    \                        optsep\n                         \"{\" stmtsep\n                             prefix-stmt\n
    \                        \"}\" stmtsep\n   organization-stmt   = organization-keyword
    sep string stmtend\n   contact-stmt        = contact-keyword sep string stmtend\n
    \  description-stmt    = description-keyword sep string stmtend\n   reference-stmt
    \     = reference-keyword sep string stmtend\n   units-stmt          = units-keyword
    sep string stmtend\n   revision-stmt       = revision-keyword sep revision-date
    optsep\n                         (\";\" /\n                          \"{\" stmtsep\n
    \                             ;; these stmts can appear in any order\n                              [description-stmt]\n
    \                             [reference-stmt]\n                          \"}\")
    stmtsep\n   revision-date       = date-arg-str\n   revision-date-stmt  = revision-date-keyword
    sep revision-date stmtend\n   extension-stmt      = extension-keyword sep identifier-arg-str
    optsep\n                         (\";\" /\n                          \"{\" stmtsep\n
    \                             ;; these stmts can appear in any order\n                              [argument-stmt]\n
    \                             [status-stmt]\n                              [description-stmt]\n
    \                             [reference-stmt]\n                          \"}\")
    stmtsep\n   argument-stmt       = argument-keyword sep identifier-arg-str optsep\n
    \                        (\";\" /\n                          \"{\" stmtsep\n                              [yin-element-stmt]\n
    \                         \"}\") stmtsep\n   yin-element-stmt    = yin-element-keyword
    sep yin-element-arg-str\n                         stmtend\n   yin-element-arg-str
    = < a string that matches the rule >\n                         < yin-element-arg
    >\n   yin-element-arg     = true-keyword / false-keyword\n   identity-stmt       =
    identity-keyword sep identifier-arg-str optsep\n                         (\";\"
    /\n                          \"{\" stmtsep\n                              ;; these
    stmts can appear in any order\n                              *if-feature-stmt\n
    \                             *base-stmt\n                              [status-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                         \"}\") stmtsep\n   base-stmt           = base-keyword
    sep identifier-ref-arg-str\n                         stmtend\n   feature-stmt
    \       = feature-keyword sep identifier-arg-str optsep\n                         (\";\"
    /\n                          \"{\" stmtsep\n                              ;; these
    stmts can appear in any order\n                              *if-feature-stmt\n
    \                             [status-stmt]\n                              [description-stmt]\n
    \                             [reference-stmt]\n                          \"}\")
    stmtsep\n   if-feature-stmt     = if-feature-keyword sep if-feature-expr-str\n
    \                        stmtend\n   if-feature-expr-str = < a string that matches
    the rule >\n                         < if-feature-expr >\n   if-feature-expr     =
    if-feature-term\n                           [sep or-keyword sep if-feature-expr]\n
    \  if-feature-term     = if-feature-factor\n                           [sep and-keyword
    sep if-feature-term]\n   if-feature-factor   = not-keyword sep if-feature-factor
    /\n                         \"(\" optsep if-feature-expr optsep \")\" /\n                         identifier-ref-arg\n
    \  typedef-stmt        = typedef-keyword sep identifier-arg-str optsep\n                         \"{\"
    stmtsep\n                             ;; these stmts can appear in any order\n
    \                            type-stmt\n                             [units-stmt]\n
    \                            [default-stmt]\n                             [status-stmt]\n
    \                            [description-stmt]\n                             [reference-stmt]\n
    \                         \"}\" stmtsep\n   type-stmt           = type-keyword
    sep identifier-ref-arg-str optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              [type-body-stmts]\n                          \"}\")
    stmtsep\n   type-body-stmts     = numerical-restrictions /\n                         decimal64-specification
    /\n                         string-restrictions /\n                         enum-specification
    /\n                         leafref-specification /\n                         identityref-specification
    /\n                         instance-identifier-specification /\n                         bits-specification
    /\n                         union-specification /\n                         binary-specification\n
    \  numerical-restrictions = [range-stmt]\n   range-stmt          = range-keyword
    sep range-arg-str optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [error-message-stmt]\n                              [error-app-tag-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                          \"}\") stmtsep\n   decimal64-specification = ;; these
    stmts can appear in any order\n                             fraction-digits-stmt\n
    \                            [range-stmt]\n   fraction-digits-stmt = fraction-digits-keyword
    sep\n                          fraction-digits-arg-str stmtend\n   fraction-digits-arg-str
    = < a string that matches the rule >\n                             < fraction-digits-arg
    >\n   fraction-digits-arg = (\"1\" [\"0\" / \"1\" / \"2\" / \"3\" / \"4\" /\n
    \                              \"5\" / \"6\" / \"7\" / \"8\"])\n                         /
    \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\"\n   string-restrictions
    = ;; these stmts can appear in any order\n                         [length-stmt]\n
    \                        *pattern-stmt\n   length-stmt         = length-keyword
    sep length-arg-str optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [error-message-stmt]\n                              [error-app-tag-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                          \"}\") stmtsep\n   pattern-stmt        = pattern-keyword
    sep string optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [modifier-stmt]\n                              [error-message-stmt]\n
    \                             [error-app-tag-stmt]\n                              [description-stmt]\n
    \                             [reference-stmt]\n                           \"}\")
    stmtsep\n   modifier-stmt       = modifier-keyword sep modifier-arg-str stmtend\n
    \  modifier-arg-str    = < a string that matches the rule >\n                         <
    modifier-arg >\n   modifier-arg        = invert-match-keyword\n   default-stmt
    \       = default-keyword sep string stmtend\n   enum-specification  = 1*enum-stmt\n
    \  enum-stmt           = enum-keyword sep string optsep\n                         (\";\"
    /\n                          \"{\" stmtsep\n                              ;; these
    stmts can appear in any order\n                              *if-feature-stmt\n
    \                             [value-stmt]\n                              [status-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                          \"}\") stmtsep\n   leafref-specification =\n                         ;;
    these stmts can appear in any order\n                         path-stmt\n                         [require-instance-stmt]\n
    \  path-stmt           = path-keyword sep path-arg-str stmtend\n   require-instance-stmt
    = require-instance-keyword sep\n                            require-instance-arg-str
    stmtend\n   require-instance-arg-str = < a string that matches the rule >\n                              <
    require-instance-arg >\n   require-instance-arg = true-keyword / false-keyword\n
    \  instance-identifier-specification =\n                         [require-instance-stmt]\n
    \  identityref-specification =\n                         1*base-stmt\n   union-specification
    = 1*type-stmt\n   binary-specification = [length-stmt]\n   bits-specification
    \ = 1*bit-stmt\n   bit-stmt            = bit-keyword sep identifier-arg-str optsep\n
    \                        (\";\" /\n                          \"{\" stmtsep\n                              ;;
    these stmts can appear in any order\n                              *if-feature-stmt\n
    \                             [position-stmt]\n                              [status-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                         \"}\") stmtsep\n   position-stmt       = position-keyword
    sep\n                         position-value-arg-str stmtend\n   position-value-arg-str
    = < a string that matches the rule >\n                            < position-value-arg
    >\n   position-value-arg  = non-negative-integer-value\n   status-stmt         =
    status-keyword sep status-arg-str stmtend\n   status-arg-str      = < a string
    that matches the rule >\n                         < status-arg >\n   status-arg
    \         = current-keyword /\n                         obsolete-keyword /\n                         deprecated-keyword\n
    \  config-stmt         = config-keyword sep\n                         config-arg-str
    stmtend\n   config-arg-str      = < a string that matches the rule >\n                         <
    config-arg >\n   config-arg          = true-keyword / false-keyword\n   mandatory-stmt
    \     = mandatory-keyword sep\n                         mandatory-arg-str stmtend\n
    \  mandatory-arg-str   = < a string that matches the rule >\n                         <
    mandatory-arg >\n   mandatory-arg       = true-keyword / false-keyword\n   presence-stmt
    \      = presence-keyword sep string stmtend\n   ordered-by-stmt     = ordered-by-keyword
    sep\n                         ordered-by-arg-str stmtend\n   ordered-by-arg-str
    \ = < a string that matches the rule >\n                         < ordered-by-arg
    >\n   ordered-by-arg      = user-keyword / system-keyword\n   must-stmt           =
    must-keyword sep string optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [error-message-stmt]\n                              [error-app-tag-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                          \"}\") stmtsep\n   error-message-stmt  = error-message-keyword
    sep string stmtend\n   error-app-tag-stmt  = error-app-tag-keyword sep string
    stmtend\n   min-elements-stmt   = min-elements-keyword sep\n                         min-value-arg-str
    stmtend\n   min-value-arg-str   = < a string that matches the rule >\n                         <
    min-value-arg >\n   min-value-arg       = non-negative-integer-value\n   max-elements-stmt
    \  = max-elements-keyword sep\n                         max-value-arg-str stmtend\n
    \  max-value-arg-str   = < a string that matches the rule >\n                         <
    max-value-arg >\n   max-value-arg       = unbounded-keyword /\n                         positive-integer-value\n
    \  value-stmt          = value-keyword sep integer-value-str stmtend\n   integer-value-str
    \  = < a string that matches the rule >\n                         < integer-value
    >\n   grouping-stmt       = grouping-keyword sep identifier-arg-str optsep\n                         (\";\"
    /\n                          \"{\" stmtsep\n                              ;; these
    stmts can appear in any order\n                              [status-stmt]\n                              [description-stmt]\n
    \                             [reference-stmt]\n                              *(typedef-stmt
    / grouping-stmt)\n                              *data-def-stmt\n                              *action-stmt\n
    \                             *notification-stmt\n                          \"}\")
    stmtsep\n   container-stmt      = container-keyword sep identifier-arg-str optsep\n
    \                        (\";\" /\n                          \"{\" stmtsep\n                              ;;
    these stmts can appear in any order\n                              [when-stmt]\n
    \                             *if-feature-stmt\n                              *must-stmt\n
    \                             [presence-stmt]\n                              [config-stmt]\n
    \                             [status-stmt]\n                              [description-stmt]\n
    \                             [reference-stmt]\n                              *(typedef-stmt
    / grouping-stmt)\n                              *data-def-stmt\n                              *action-stmt\n
    \                             *notification-stmt\n                          \"}\")
    stmtsep\n   leaf-stmt           = leaf-keyword sep identifier-arg-str optsep\n
    \                        \"{\" stmtsep\n                             ;; these
    stmts can appear in any order\n                             [when-stmt]\n                             *if-feature-stmt\n
    \                            type-stmt\n                             [units-stmt]\n
    \                            *must-stmt\n                             [default-stmt]\n
    \                            [config-stmt]\n                             [mandatory-stmt]\n
    \                            [status-stmt]\n                             [description-stmt]\n
    \                            [reference-stmt]\n                          \"}\"
    stmtsep\n   leaf-list-stmt      = leaf-list-keyword sep identifier-arg-str optsep\n
    \                        \"{\" stmtsep\n                             ;; these
    stmts can appear in any order\n                             [when-stmt]\n                             *if-feature-stmt\n
    \                            type-stmt stmtsep\n                             [units-stmt]\n
    \                            *must-stmt\n                             *default-stmt\n
    \                            [config-stmt]\n                             [min-elements-stmt]\n
    \                            [max-elements-stmt]\n                             [ordered-by-stmt]\n
    \                            [status-stmt]\n                             [description-stmt]\n
    \                            [reference-stmt]\n                          \"}\"
    stmtsep\n   list-stmt           = list-keyword sep identifier-arg-str optsep\n
    \                        \"{\" stmtsep\n                             ;; these
    stmts can appear in any order\n                             [when-stmt]\n                             *if-feature-stmt\n
    \                            *must-stmt\n                             [key-stmt]\n
    \                            *unique-stmt\n                             [config-stmt]\n
    \                            [min-elements-stmt]\n                             [max-elements-stmt]\n
    \                            [ordered-by-stmt]\n                             [status-stmt]\n
    \                            [description-stmt]\n                             [reference-stmt]\n
    \                            *(typedef-stmt / grouping-stmt)\n                             1*data-def-stmt\n
    \                            *action-stmt\n                             *notification-stmt\n
    \                         \"}\" stmtsep\n   key-stmt            = key-keyword
    sep key-arg-str stmtend\n   key-arg-str         = < a string that matches the
    rule >\n                         < key-arg >\n   key-arg             = node-identifier
    *(sep node-identifier)\n   unique-stmt         = unique-keyword sep unique-arg-str
    stmtend\n   unique-arg-str      = < a string that matches the rule >\n                         <
    unique-arg >\n   unique-arg          = descendant-schema-nodeid\n                         *(sep
    descendant-schema-nodeid)\n   choice-stmt         = choice-keyword sep identifier-arg-str
    optsep\n                         (\";\" /\n                          \"{\" stmtsep\n
    \                             ;; these stmts can appear in any order\n                              [when-stmt]\n
    \                             *if-feature-stmt\n                              [default-stmt]\n
    \                             [config-stmt]\n                              [mandatory-stmt]\n
    \                             [status-stmt]\n                              [description-stmt]\n
    \                             [reference-stmt]\n                              *(short-case-stmt
    / case-stmt)\n                          \"}\") stmtsep\n   short-case-stmt     =
    choice-stmt /\n                         container-stmt /\n                         leaf-stmt
    /\n                         leaf-list-stmt /\n                         list-stmt
    /\n                         anydata-stmt /\n                         anyxml-stmt\n
    \  case-stmt           = case-keyword sep identifier-arg-str optsep\n                         (\";\"
    /\n                          \"{\" stmtsep\n                              ;; these
    stmts can appear in any order\n                              [when-stmt]\n                              *if-feature-stmt\n
    \                             [status-stmt]\n                              [description-stmt]\n
    \                             [reference-stmt]\n                              *data-def-stmt\n
    \                         \"}\") stmtsep\n   anydata-stmt        = anydata-keyword
    sep identifier-arg-str optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [when-stmt]\n                              *if-feature-stmt\n
    \                             *must-stmt\n                              [config-stmt]\n
    \                             [mandatory-stmt]\n                              [status-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                          \"}\") stmtsep\n   anyxml-stmt         = anyxml-keyword
    sep identifier-arg-str optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [when-stmt]\n                              *if-feature-stmt\n
    \                             *must-stmt\n                              [config-stmt]\n
    \                             [mandatory-stmt]\n                              [status-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                          \"}\") stmtsep\n   uses-stmt           = uses-keyword
    sep identifier-ref-arg-str optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [when-stmt]\n                              *if-feature-stmt\n
    \                             [status-stmt]\n                              [description-stmt]\n
    \                             [reference-stmt]\n                              *refine-stmt\n
    \                             *uses-augment-stmt\n                          \"}\")
    stmtsep\n   refine-stmt         = refine-keyword sep refine-arg-str optsep\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             *if-feature-stmt\n                              *must-stmt\n
    \                             [presence-stmt]\n                              *default-stmt\n
    \                             [config-stmt]\n                              [mandatory-stmt]\n
    \                             [min-elements-stmt]\n                              [max-elements-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                           \"}\" stmtsep\n   refine-arg-str      = < a string
    that matches the rule >\n                         < refine-arg >\n   refine-arg
    \         = descendant-schema-nodeid\n   uses-augment-stmt   = augment-keyword
    sep uses-augment-arg-str optsep\n                         \"{\" stmtsep\n                             ;;
    these stmts can appear in any order\n                             [when-stmt]\n
    \                            *if-feature-stmt\n                             [status-stmt]\n
    \                            [description-stmt]\n                             [reference-stmt]\n
    \                            1*(data-def-stmt / case-stmt /\n                                action-stmt
    / notification-stmt)\n                          \"}\" stmtsep\n   uses-augment-arg-str
    = < a string that matches the rule >\n                          < uses-augment-arg
    >\n   uses-augment-arg    = descendant-schema-nodeid\n   augment-stmt        =
    augment-keyword sep augment-arg-str optsep\n                         \"{\" stmtsep\n
    \                            ;; these stmts can appear in any order\n                             [when-stmt]\n
    \                            *if-feature-stmt\n                             [status-stmt]\n
    \                            [description-stmt]\n                             [reference-stmt]\n
    \                            1*(data-def-stmt / case-stmt /\n                                action-stmt
    / notification-stmt)\n                          \"}\" stmtsep\n   augment-arg-str
    \    = < a string that matches the rule >\n                         < augment-arg
    >\n   augment-arg         = absolute-schema-nodeid\n   when-stmt           = when-keyword
    sep string optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                          \"}\") stmtsep\n   rpc-stmt            = rpc-keyword
    sep identifier-arg-str optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             *if-feature-stmt\n                              [status-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                             *(typedef-stmt / grouping-stmt)\n                              [input-stmt]\n
    \                             [output-stmt]\n                          \"}\")
    stmtsep\n   action-stmt         = action-keyword sep identifier-arg-str optsep\n
    \                        (\";\" /\n                          \"{\" stmtsep\n                              ;;
    these stmts can appear in any order\n                              *if-feature-stmt\n
    \                             [status-stmt]\n                              [description-stmt]\n
    \                             [reference-stmt]\n                              *(typedef-stmt
    / grouping-stmt)\n                              [input-stmt]\n                              [output-stmt]\n
    \                         \"}\") stmtsep\n   input-stmt          = input-keyword
    optsep\n                         \"{\" stmtsep\n                             ;;
    these stmts can appear in any order\n                             *must-stmt\n
    \                            *(typedef-stmt / grouping-stmt)\n                             1*data-def-stmt\n
    \                        \"}\" stmtsep\n   output-stmt         = output-keyword
    optsep\n                         \"{\" stmtsep\n                             ;;
    these stmts can appear in any order\n                             *must-stmt\n
    \                            *(typedef-stmt / grouping-stmt)\n                             1*data-def-stmt\n
    \                        \"}\" stmtsep\n   notification-stmt   = notification-keyword
    sep\n                         identifier-arg-str optsep\n                         (\";\"
    /\n                          \"{\" stmtsep\n                              ;; these
    stmts can appear in any order\n                              *if-feature-stmt\n
    \                             *must-stmt\n                              [status-stmt]\n
    \                             [description-stmt]\n                              [reference-stmt]\n
    \                             *(typedef-stmt / grouping-stmt)\n                              *data-def-stmt\n
    \                         \"}\") stmtsep\n   deviation-stmt      = deviation-keyword
    sep\n                         deviation-arg-str optsep\n                         \"{\"
    stmtsep\n                             ;; these stmts can appear in any order\n
    \                            [description-stmt]\n                             [reference-stmt]\n
    \                            (deviate-not-supported-stmt /\n                               1*(deviate-add-stmt
    /\n                                  deviate-replace-stmt /\n                                  deviate-delete-stmt))\n
    \                        \"}\" stmtsep\n   deviation-arg-str   = < a string that
    matches the rule >\n                         < deviation-arg >\n   deviation-arg
    \      = absolute-schema-nodeid\n   deviate-not-supported-stmt =\n                         deviate-keyword
    sep\n                         not-supported-keyword-str stmtend\n   deviate-add-stmt
    \   = deviate-keyword sep add-keyword-str optsep\n                         (\";\"
    /\n                          \"{\" stmtsep\n                              ;; these
    stmts can appear in any order\n                              [units-stmt]\n                              *must-stmt\n
    \                             *unique-stmt\n                              *default-stmt\n
    \                             [config-stmt]\n                              [mandatory-stmt]\n
    \                             [min-elements-stmt]\n                              [max-elements-stmt]\n
    \                         \"}\") stmtsep\n   deviate-delete-stmt = deviate-keyword
    sep delete-keyword-str optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [units-stmt]\n                              *must-stmt\n
    \                             *unique-stmt\n                              *default-stmt\n
    \                         \"}\") stmtsep\n   deviate-replace-stmt = deviate-keyword
    sep replace-keyword-str optsep\n                         (\";\" /\n                          \"{\"
    stmtsep\n                              ;; these stmts can appear in any order\n
    \                             [type-stmt]\n                              [units-stmt]\n
    \                             [default-stmt]\n                              [config-stmt]\n
    \                             [mandatory-stmt]\n                              [min-elements-stmt]\n
    \                             [max-elements-stmt]\n                          \"}\")
    stmtsep\n   not-supported-keyword-str = < a string that matches the rule >\n                               <
    not-supported-keyword >\n   add-keyword-str     = < a string that matches the
    rule >\n                         < add-keyword >\n   delete-keyword-str  = < a
    string that matches the rule >\n                         < delete-keyword >\n
    \  replace-keyword-str = < a string that matches the rule >\n                         <
    replace-keyword >\n   ;; represents the usage of an extension\n   unknown-statement
    \  = prefix \":\" identifier [sep string] optsep\n                         (\";\"
    /\n                          \"{\" optsep\n                              *((yang-stmt
    / unknown-statement) optsep)\n                           \"}\") stmtsep\n   yang-stmt
    \          = action-stmt /\n                         anydata-stmt /\n                         anyxml-stmt
    /\n                         argument-stmt /\n                         augment-stmt
    /\n                         base-stmt /\n                         belongs-to-stmt
    /\n                         bit-stmt /\n                         case-stmt /\n
    \                        choice-stmt /\n                         config-stmt /\n
    \                        contact-stmt /\n                         container-stmt
    /\n                         default-stmt /\n                         description-stmt
    /\n                         deviate-add-stmt /\n                         deviate-delete-stmt
    /\n                         deviate-not-supported-stmt /\n                         deviate-replace-stmt
    /\n                         deviation-stmt /\n                         enum-stmt
    /\n                         error-app-tag-stmt /\n                         error-message-stmt
    /\n                         extension-stmt /\n                         feature-stmt
    /\n                         fraction-digits-stmt /\n                         grouping-stmt
    /\n                         identity-stmt /\n                         if-feature-stmt
    /\n                         import-stmt /\n                         include-stmt
    /\n                         input-stmt /\n                         key-stmt /\n
    \                        leaf-list-stmt /\n                         leaf-stmt
    /\n                         length-stmt /\n                         list-stmt
    /\n                         mandatory-stmt /\n                         max-elements-stmt
    /\n                         min-elements-stmt /\n                         modifier-stmt
    /\n                         module-stmt /\n                         must-stmt
    /\n                         namespace-stmt /\n                         notification-stmt
    /\n                         ordered-by-stmt /\n                         organization-stmt
    /\n                         output-stmt /\n                         path-stmt
    /\n                         pattern-stmt /\n                         position-stmt
    /\n                         prefix-stmt /\n                         presence-stmt
    /\n                         range-stmt /\n                         reference-stmt
    /\n                         refine-stmt /\n                         require-instance-stmt
    /\n                         revision-date-stmt /\n                         revision-stmt
    /\n                         rpc-stmt /\n                         status-stmt /\n
    \                        submodule-stmt /\n                         typedef-stmt
    /\n                         type-stmt /\n                         unique-stmt
    /\n                         units-stmt /\n                         uses-augment-stmt
    /\n                         uses-stmt /\n                         value-stmt /\n
    \                        when-stmt /\n                         yang-version-stmt
    /\n                         yin-element-stmt\n   ;; Ranges\n   range-arg-str       =
    < a string that matches the rule >\n                         < range-arg >\n   range-arg
    \          = range-part *(optsep \"|\" optsep range-part)\n   range-part          =
    range-boundary\n                         [optsep \"..\" optsep range-boundary]\n
    \  range-boundary      = min-keyword / max-keyword /\n                         integer-value
    / decimal-value\n   ;; Lengths\n   length-arg-str      = < a string that matches
    the rule >\n                         < length-arg >\n   length-arg          =
    length-part *(optsep \"|\" optsep length-part)\n   length-part         = length-boundary\n
    \                        [optsep \"..\" optsep length-boundary]\n   length-boundary
    \    = min-keyword / max-keyword /\n                         non-negative-integer-value\n
    \  ;; Date\n   date-arg-str        = < a string that matches the rule >\n                         <
    date-arg >\n   date-arg            = 4DIGIT \"-\" 2DIGIT \"-\" 2DIGIT\n   ;; Schema
    Node Identifiers\n   schema-nodeid       = absolute-schema-nodeid /\n                         descendant-schema-nodeid\n
    \  absolute-schema-nodeid = 1*(\"/\" node-identifier)\n   descendant-schema-nodeid
    =\n                         node-identifier\n                         [absolute-schema-nodeid]\n
    \  node-identifier     = [prefix \":\"] identifier\n   ;; Instance Identifiers\n
    \  instance-identifier = 1*(\"/\" (node-identifier\n                                 [1*key-predicate
    /\n                                  leaf-list-predicate /\n                                  pos]))\n
    \  key-predicate       = \"[\" *WSP key-predicate-expr *WSP \"]\"\n   key-predicate-expr
    \ = node-identifier *WSP \"=\" *WSP quoted-string\n   leaf-list-predicate = \"[\"
    *WSP leaf-list-predicate-expr *WSP \"]\"\n   leaf-list-predicate-expr = \".\"
    *WSP \"=\" *WSP quoted-string\n   pos                 = \"[\" *WSP positive-integer-value
    *WSP \"]\"\n   quoted-string       = (DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)\n
    \  ;; leafref path\n   path-arg-str        = < a string that matches the rule
    >\n                         < path-arg >\n   path-arg            = absolute-path
    / relative-path\n   absolute-path       = 1*(\"/\" (node-identifier *path-predicate))\n
    \  relative-path       = 1*(\"../\") descendant-path\n   descendant-path     =
    node-identifier\n                         [*path-predicate absolute-path]\n   path-predicate
    \     = \"[\" *WSP path-equality-expr *WSP \"]\"\n   path-equality-expr  = node-identifier
    *WSP \"=\" *WSP path-key-expr\n   path-key-expr       = current-function-invocation
    *WSP \"/\" *WSP\n                         rel-path-keyexpr\n   rel-path-keyexpr
    \   = 1*(\"..\" *WSP \"/\" *WSP)\n                         *(node-identifier *WSP
    \"/\" *WSP)\n                         node-identifier\n   ;;; Keywords, using
    the syntax for case-sensitive strings (RFC 7405)\n   ;; statement keywords\n   action-keyword
    \          = %s\"action\"\n   anydata-keyword          = %s\"anydata\"\n   anyxml-keyword
    \          = %s\"anyxml\"\n   argument-keyword         = %s\"argument\"\n   augment-keyword
    \         = %s\"augment\"\n   base-keyword             = %s\"base\"\n   belongs-to-keyword
    \      = %s\"belongs-to\"\n   bit-keyword              = %s\"bit\"\n   case-keyword
    \            = %s\"case\"\n   choice-keyword           = %s\"choice\"\n   config-keyword
    \          = %s\"config\"\n   contact-keyword          = %s\"contact\"\n   container-keyword
    \       = %s\"container\"\n   default-keyword          = %s\"default\"\n   description-keyword
    \     = %s\"description\"\n   deviate-keyword          = %s\"deviate\"\n   deviation-keyword
    \       = %s\"deviation\"\n   enum-keyword             = %s\"enum\"\n   error-app-tag-keyword
    \   = %s\"error-app-tag\"\n   error-message-keyword    = %s\"error-message\"\n
    \  extension-keyword        = %s\"extension\"\n   feature-keyword          = %s\"feature\"\n
    \  fraction-digits-keyword  = %s\"fraction-digits\"\n   grouping-keyword         =
    %s\"grouping\"\n   identity-keyword         = %s\"identity\"\n   if-feature-keyword
    \      = %s\"if-feature\"\n   import-keyword           = %s\"import\"\n   include-keyword
    \         = %s\"include\"\n   input-keyword            = %s\"input\"\n   key-keyword
    \             = %s\"key\"\n   leaf-keyword             = %s\"leaf\"\n   leaf-list-keyword
    \       = %s\"leaf-list\"\n   length-keyword           = %s\"length\"\n   list-keyword
    \            = %s\"list\"\n   mandatory-keyword        = %s\"mandatory\"\n   max-elements-keyword
    \    = %s\"max-elements\"\n   min-elements-keyword     = %s\"min-elements\"\n
    \  modifier-keyword         = %s\"modifier\"\n   module-keyword           = %s\"module\"\n
    \  must-keyword             = %s\"must\"\n   namespace-keyword        = %s\"namespace\"\n
    \  notification-keyword     = %s\"notification\"\n   ordered-by-keyword       =
    %s\"ordered-by\"\n   organization-keyword     = %s\"organization\"\n   output-keyword
    \          = %s\"output\"\n   path-keyword             = %s\"path\"\n   pattern-keyword
    \         = %s\"pattern\"\n   position-keyword         = %s\"position\"\n   prefix-keyword
    \          = %s\"prefix\"\n   presence-keyword         = %s\"presence\"\n   range-keyword
    \           = %s\"range\"\n   reference-keyword        = %s\"reference\"\n   refine-keyword
    \          = %s\"refine\"\n   require-instance-keyword = %s\"require-instance\"\n
    \  revision-keyword         = %s\"revision\"\n   revision-date-keyword    = %s\"revision-date\"\n
    \  rpc-keyword              = %s\"rpc\"\n   status-keyword           = %s\"status\"\n
    \  submodule-keyword        = %s\"submodule\"\n   type-keyword             = %s\"type\"\n
    \  typedef-keyword          = %s\"typedef\"\n   unique-keyword           = %s\"unique\"\n
    \  units-keyword            = %s\"units\"\n   uses-keyword             = %s\"uses\"\n
    \  value-keyword            = %s\"value\"\n   when-keyword             = %s\"when\"\n
    \  yang-version-keyword     = %s\"yang-version\"\n   yin-element-keyword      =
    %s\"yin-element\"\n   ;; other keywords\n   add-keyword              = %s\"add\"\n
    \  current-keyword          = %s\"current\"\n   delete-keyword           = %s\"delete\"\n
    \  deprecated-keyword       = %s\"deprecated\"\n   false-keyword            =
    %s\"false\"\n   invert-match-keyword     = %s\"invert-match\"\n   max-keyword
    \             = %s\"max\"\n   min-keyword              = %s\"min\"\n   not-supported-keyword
    \   = %s\"not-supported\"\n   obsolete-keyword         = %s\"obsolete\"\n   replace-keyword
    \         = %s\"replace\"\n   system-keyword           = %s\"system\"\n   true-keyword
    \            = %s\"true\"\n   unbounded-keyword        = %s\"unbounded\"\n   user-keyword
    \            = %s\"user\"\n   and-keyword              = %s\"and\"\n   or-keyword
    \              = %s\"or\"\n   not-keyword              = %s\"not\"\n   current-function-invocation
    = current-keyword *WSP \"(\" *WSP \")\"\n   ;;; Basic Rules\n   prefix-arg-str
    \     = < a string that matches the rule >\n                         < prefix-arg
    >\n   prefix-arg          = prefix\n   prefix              = identifier\n   identifier-arg-str
    \ = < a string that matches the rule >\n                         < identifier-arg
    >\n   identifier-arg      = identifier\n   identifier          = (ALPHA / \"_\")\n
    \                        *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")\n   identifier-ref-arg-str
    = < a string that matches the rule >\n                            < identifier-ref-arg
    >\n   identifier-ref-arg  = identifier-ref\n   identifier-ref      = [prefix \":\"]
    identifier\n   string              = < an unquoted string, as returned by >\n
    \                        < the scanner, that matches the rule >\n                         <
    yang-string >\n   yang-string         = *yang-char\n   ;; any Unicode or ISO/IEC
    10646 character, including tab, carriage\n   ;; return, and line feed but excluding
    the other C0 control\n   ;; characters, the surrogate blocks, and the noncharacters\n
    \  yang-char = %x09 / %x0A / %x0D / %x20-D7FF /\n                               ;
    exclude surrogate blocks %xD800-DFFF\n              %xE000-FDCF /    ; exclude
    noncharacters %xFDD0-FDEF\n              %xFDF0-FFFD /    ; exclude noncharacters
    %xFFFE-FFFF\n              %x10000-1FFFD /  ; exclude noncharacters %x1FFFE-1FFFF\n
    \             %x20000-2FFFD /  ; exclude noncharacters %x2FFFE-2FFFF\n              %x30000-3FFFD
    /  ; exclude noncharacters %x3FFFE-3FFFF\n              %x40000-4FFFD /  ; exclude
    noncharacters %x4FFFE-4FFFF\n              %x50000-5FFFD /  ; exclude noncharacters
    %x5FFFE-5FFFF\n              %x60000-6FFFD /  ; exclude noncharacters %x6FFFE-6FFFF\n
    \             %x70000-7FFFD /  ; exclude noncharacters %x7FFFE-7FFFF\n              %x80000-8FFFD
    /  ; exclude noncharacters %x8FFFE-8FFFF\n              %x90000-9FFFD /  ; exclude
    noncharacters %x9FFFE-9FFFF\n              %xA0000-AFFFD /  ; exclude noncharacters
    %xAFFFE-AFFFF\n              %xB0000-BFFFD /  ; exclude noncharacters %xBFFFE-BFFFF\n
    \             %xC0000-CFFFD /  ; exclude noncharacters %xCFFFE-CFFFF\n              %xD0000-DFFFD
    /  ; exclude noncharacters %xDFFFE-DFFFF\n              %xE0000-EFFFD /  ; exclude
    noncharacters %xEFFFE-EFFFF\n              %xF0000-FFFFD /  ; exclude noncharacters
    %xFFFFE-FFFFF\n              %x100000-10FFFD  ; exclude noncharacters %x10FFFE-10FFFF\n
    \  integer-value       = (\"-\" non-negative-integer-value) /\n                          non-negative-integer-value\n
    \  non-negative-integer-value = \"0\" / positive-integer-value\n   positive-integer-value
    = (non-zero-digit *DIGIT)\n   zero-integer-value  = 1*DIGIT\n   stmtend             =
    optsep (\";\" / \"{\" stmtsep \"}\") stmtsep\n   sep                 = 1*(WSP
    / line-break)\n                         ; unconditional separator\n   optsep              =
    *(WSP / line-break)\n   stmtsep             = *(WSP / line-break / unknown-statement)\n
    \  line-break          = CRLF / LF\n   non-zero-digit      = %x31-39\n   decimal-value
    \      = integer-value (\".\" zero-integer-value)\n   SQUOTE              = %x27\n
    \                        ; single quote\n   ;;; core rules from RFC 5234\n   ALPHA
    \              = %x41-5A / %x61-7A\n                         ; A-Z / a-z\n   CR
    \                 = %x0D\n                         ; carriage return\n   CRLF
    \               = CR LF\n                         ; Internet standard newline\n
    \  DIGIT               = %x30-39\n                         ; 0-9\n   DQUOTE              =
    %x22\n                         ; double quote\n   HTAB                = %x09\n
    \                        ; horizontal tab\n   LF                  = %x0A\n                         ;
    line feed\n   SP                  = %x20\n                         ; space\n   WSP
    \                = SP / HTAB\n                         ; whitespace\n   <CODE
    ENDS>\n"
  title: 14.  YANG ABNF Grammar
- contents:
  - "15.  NETCONF Error Responses for YANG-Related Errors\n   A number of NETCONF
    error responses are defined for error cases\n   related to the data model handling.
    \ If the relevant YANG statement\n   has an \"error-app-tag\" substatement, that
    overrides the default value\n   specified below.\n"
  - contents:
    - "15.1.  Error Message for Data That Violates a \"unique\" Statement\n   If a
      NETCONF operation would result in configuration data where a\n   \"unique\"
      constraint is invalidated, the following error MUST be\n   returned:\n     error-tag:
      \     operation-failed\n     error-app-tag:  data-not-unique\n     error-info:
      \    <non-unique>: Contains an instance identifier that\n                     points
      to a leaf that invalidates the \"unique\"\n                     constraint.
      \ This element is present once for each\n                     non-unique leaf.\n
      \                    The <non-unique> element is in the YANG\n                     namespace
      (\"urn:ietf:params:xml:ns:yang:1\").\n"
    title: 15.1.  Error Message for Data That Violates a "unique" Statement
  - contents:
    - "15.2.  Error Message for Data That Violates a \"max-elements\" Statement\n
      \  If a NETCONF operation would result in configuration data where a\n   list
      or a leaf-list would have too many entries, the following error\n   MUST be
      returned:\n     error-tag:      operation-failed\n     error-app-tag:  too-many-elements\n
      \  This error is returned once, with the error-path identifying the list\n   node,
      even if there is more than one extra child present.\n"
    title: 15.2.  Error Message for Data That Violates a "max-elements" Statement
  - contents:
    - "15.3.  Error Message for Data That Violates a \"min-elements\" Statement\n
      \  If a NETCONF operation would result in configuration data where a\n   list
      or a leaf-list would have too few entries, the following error\n   MUST be returned:\n
      \    error-tag:      operation-failed\n     error-app-tag:  too-few-elements\n
      \  This error is returned once, with the error-path identifying the list\n   node,
      even if there is more than one child missing.\n"
    title: 15.3.  Error Message for Data That Violates a "min-elements" Statement
  - contents:
    - "15.4.  Error Message for Data That Violates a \"must\" Statement\n   If a NETCONF
      operation would result in configuration data where the\n   restrictions imposed
      by a \"must\" statement are violated, the\n   following error MUST be returned,
      unless a specific \"error-app-tag\"\n   substatement is present for the \"must\"
      statement.\n     error-tag:      operation-failed\n     error-app-tag:  must-violation\n"
    title: 15.4.  Error Message for Data That Violates a "must" Statement
  - contents:
    - "15.5.  Error Message for Data That Violates a \"require-instance\"\n       Statement\n
      \  If a NETCONF operation would result in configuration data where a\n   leaf
      of type \"instance-identifier\" or \"leafref\" marked with\n   require-instance
      \"true\" refers to an instance that does not exist,\n   the following error
      MUST be returned:\n     error-tag:      data-missing\n     error-app-tag:  instance-required\n
      \    error-path:     Path to the instance-identifier or leafref leaf.\n"
    title: 15.5.  Error Message for Data That Violates a "require-instance"
  - contents:
    - "15.6.  Error Message for Data That Violates a Mandatory \"choice\"\n       Statement\n
      \  If a NETCONF operation would result in configuration data where no\n   nodes
      exists in a mandatory choice, the following error MUST be\n   returned:\n     error-tag:
      \     data-missing\n     error-app-tag:  missing-choice\n     error-path:     Path
      to the element with the missing choice.\n     error-info:     <missing-choice>:
      Contains the name of the missing\n                     mandatory choice.\n                     The
      <missing-choice> element is in the YANG\n                     namespace (\"urn:ietf:params:xml:ns:yang:1\").\n"
    title: 15.6.  Error Message for Data That Violates a Mandatory "choice"
  - contents:
    - "15.7.  Error Message for the \"insert\" Operation\n   If the \"insert\" and
      \"key\" or \"value\" attributes are used in an\n   <edit-config> for a list
      or leaf-list node and the \"key\" or \"value\"\n   refers to an instance that
      does not exist, the following error MUST\n   be returned:\n     error-tag:      bad-attribute\n
      \    error-app-tag:  missing-instance\n"
    title: 15.7.  Error Message for the "insert" Operation
  title: 15.  NETCONF Error Responses for YANG-Related Errors
- contents:
  - "16.  IANA Considerations\n   This document registers one capability identifier
    URN from the\n   \"Network Configuration Protocol (NETCONF) Capability URNs\"
    registry:\n     Index           Capability Identifier\n     -------------   ---------------------------------------------------\n
    \    :yang-library   urn:ietf:params:netconf:capability:yang-library:1.0\n"
  title: 16.  IANA Considerations
- contents:
  - "17.  Security Considerations\n   This document defines a language with which
    to write and read\n   descriptions of management information.  The language itself
    has no\n   security impact on the Internet.\n   The same considerations are relevant
    as those for the base NETCONF\n   protocol (see Section 9 in [RFC6241]).\n   Data
    modeled in YANG might contain sensitive information.  RPCs or\n   notifications
    defined in YANG might transfer sensitive information.\n   Security issues are
    related to the usage of data modeled in YANG.\n   Such issues shall be dealt with
    in documents describing the data\n   models and documents about the interfaces
    used to manipulate the\n   data, e.g., the NETCONF documents.\n   Data modeled
    in YANG is dependent upon:\n   o  the security of the transmission infrastructure
    used to send\n      sensitive information.\n   o  the security of applications
    that store or release such sensitive\n      information.\n   o  adequate authentication
    and access control mechanisms to restrict\n      the usage of sensitive data.\n
    \  YANG parsers need to be robust with respect to malformed documents.\n   Reading
    malformed documents from unknown or untrusted sources could\n   result in an attacker
    gaining the privileges of the user running the\n   YANG parser.  In an extreme
    situation, the entire machine could be\n   compromised.\n"
  title: 17.  Security Considerations
- contents:
  - '18.  References

    '
  - contents:
    - "18.1.  Normative References\n   [ISO.10646]\n              International Organization
      for Standardization,\n              \"Information Technology - Universal Multiple-Octet
      Coded\n              Character Set (UCS)\", ISO Standard 10646:2014, 2014.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3629]  Yergeau,
      F., \"UTF-8, a transformation format of\n              ISO 10646\", STD 63,
      RFC 3629, DOI 10.17487/RFC3629,\n              November 2003, <http://www.rfc-editor.org/info/rfc3629>.\n
      \  [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource
      Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, DOI 10.17487/RFC3986,
      January 2005,\n              <http://www.rfc-editor.org/info/rfc3986>.\n   [RFC4648]
      \ Josefsson, S., \"The Base16, Base32, and Base64 Data\n              Encodings\",
      RFC 4648, DOI 10.17487/RFC4648, October 2006,\n              <http://www.rfc-editor.org/info/rfc4648>.\n
      \  [RFC5234]  Crocker, D., Ed., and P. Overell, \"Augmented BNF for\n              Syntax
      Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,
      January 2008,\n              <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC5277]
      \ Chisholm, S. and H. Trevino, \"NETCONF Event\n              Notifications\",
      RFC 5277, DOI 10.17487/RFC5277, July 2008,\n              <http://www.rfc-editor.org/info/rfc5277>.\n
      \  [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,\n              and
      A. Bierman, Ed., \"Network Configuration Protocol\n              (NETCONF)\",
      RFC 6241, DOI 10.17487/RFC6241, June 2011,\n              <http://www.rfc-editor.org/info/rfc6241>.\n
      \  [RFC7405]  Kyzivat, P., \"Case-Sensitive String Support in ABNF\",\n              RFC
      7405, DOI 10.17487/RFC7405, December 2014,\n              <http://www.rfc-editor.org/info/rfc7405>.\n
      \  [RFC7895]  Bierman, A., Bjorklund, M., and K. Watsen, \"YANG Module\n              Library\",
      RFC 7895, DOI 10.17487/RFC7895, June 2016,\n              <http://www.rfc-editor.org/info/rfc7895>.\n
      \  [XML]      Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and\n              F.
      Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth\n              Edition)\",
      W3C Recommendation REC-xml-20081126,\n              November 2008,\n              <https://www.w3.org/TR/2008/REC-xml-20081126/>.\n
      \  [XML-NAMES]\n              Bray, T., Hollander, D., Layman, A., Tobin, R.,
      and H.\n              Thompson, \"Namespaces in XML 1.0 (Third Edition)\", World\n
      \             Wide Web Consortium Recommendation REC-xml-names-20091208,\n              December
      2009,\n              <http://www.w3.org/TR/2009/REC-xml-names-20091208>.\n   [XPATH]
      \   Clark, J. and S. DeRose, \"XML Path Language (XPath)\n              Version
      1.0\", World Wide Web Consortium Recommendation\n              REC-xpath-19991116,
      November 1999,\n              <http://www.w3.org/TR/1999/REC-xpath-19991116>.\n
      \  [XSD-TYPES]\n              Biron, P. and A. Malhotra, \"XML Schema Part 2:
      Datatypes\n              Second Edition\", World Wide Web Consortium Recommendation\n
      \             REC-xmlschema-2-20041028, October 2004,\n              <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.\n"
    title: 18.1.  Normative References
  - contents:
    - "18.2.  Informative References\n   [CoMI]     van der Stok, P. and A. Bierman,
      \"CoAP Management\n              Interface\", Work in Progress,\n              draft-vanderstok-core-comi-09,
      March 2016.\n   [IEEE754-2008]\n              IEEE, \"IEEE Standard for Floating-Point
      Arithmetic\",\n              IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935,
      2008,\n              <http://standards.ieee.org/findstds/\n              standard/754-2008.html>.\n
      \  [RESTCONF]\n              Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF\n
      \             Protocol\", Work in Progress,\n              draft-ietf-netconf-restconf-16,
      August 2016.\n   [RFC2578]  McCloghrie, K., Ed., Perkins, D., Ed., and J.\n
      \             Schoenwaelder, Ed., \"Structure of Management Information\n              Version
      2 (SMIv2)\", STD 58, RFC 2578,\n              DOI 10.17487/RFC2578, April 1999,\n
      \             <http://www.rfc-editor.org/info/rfc2578>.\n   [RFC2579]  McCloghrie,
      K., Ed., Perkins, D., Ed., and J.\n              Schoenwaelder, Ed., \"Textual
      Conventions for SMIv2\",\n              STD 58, RFC 2579, DOI 10.17487/RFC2579,
      April 1999,\n              <http://www.rfc-editor.org/info/rfc2579>.\n   [RFC3780]
      \ Strauss, F. and J. Schoenwaelder, \"SMIng - Next Generation\n              Structure
      of Management Information\", RFC 3780,\n              DOI 10.17487/RFC3780,
      May 2004,\n              <http://www.rfc-editor.org/info/rfc3780>.\n   [RFC4844]
      \ Daigle, L., Ed., and Internet Architecture Board, \"The RFC\n              Series
      and RFC Editor\", RFC 4844, DOI 10.17487/RFC4844,\n              July 2007,
      <http://www.rfc-editor.org/info/rfc4844>.\n   [RFC6020]  Bjorklund, M., Ed.,
      \"YANG - A Data Modeling Language for\n              the Network Configuration
      Protocol (NETCONF)\", RFC 6020,\n              DOI 10.17487/RFC6020, October
      2010,\n              <http://www.rfc-editor.org/info/rfc6020>.\n   [RFC6643]
      \ Schoenwaelder, J., \"Translation of Structure of Management\n              Information
      Version 2 (SMIv2) MIB Modules to YANG\n              Modules\", RFC 6643, DOI
      10.17487/RFC6643, July 2012,\n              <http://www.rfc-editor.org/info/rfc6643>.\n
      \  [RFC6991]  Schoenwaelder, J., Ed., \"Common YANG Data Types\",\n              RFC
      6991, DOI 10.17487/RFC6991, July 2013,\n              <http://www.rfc-editor.org/info/rfc6991>.\n
      \  [RFC7951]  Lhotka, L., \"JSON Encoding of Data Modeled with YANG\",\n              RFC
      7951, DOI 10.17487/RFC7951, August 2016,\n              <http://www.rfc-editor.org/info/rfc7951>.\n
      \  [XPATH2.0]\n              Berglund, A., Boag, S., Chamberlin, D., Fernandez,
      M.,\n              Kay, M., Robie, J., and J. Simeon, \"XML Path Language\n
      \             (XPath) 2.0 (Second Edition)\", World Wide Web Consortium\n              Recommendation
      REC-xpath20-20101214, December 2010,\n              <http://www.w3.org/TR/2010/REC-xpath20-20101214>.\n
      \  [XSLT]     Clark, J., \"XSL Transformations (XSLT) Version 1.0\", World\n
      \             Wide Web Consortium Recommendation REC-xslt-19991116,\n              November
      1999,\n              <http://www.w3.org/TR/1999/REC-xslt-19991116>.\n   [YANG-Guidelines]\n
      \             Bierman, A., \"Guidelines for Authors and Reviewers of YANG\n
      \             Data Model Documents\", Work in Progress,\n              draft-ietf-netmod-rfc6087bis-07,
      July 2016.\n"
    title: 18.2.  Informative References
  title: 18.  References
- contents:
  - "Acknowledgements\n   The editor wishes to thank the following individuals, who
    all\n   provided helpful comments on various draft versions of this document:\n
    \  Mehmet Ersue, Washam Fan, Joel Halpern, Per Hedeland, Leif Johansson,\n   Ladislav
    Lhotka, Lionel Morand, Gerhard Muenz, Peyman Owladi, Tom\n   Petch, Randy Presuhn,
    David Reid, Jernej Tuljak, Kent Watsen, Bert\n   Wijnen, Robert Wilton, and Dale
    Worley.\n"
  title: Acknowledgements
- contents:
  - "Contributors\n   The following people all contributed significantly to the initial\n
    \  YANG document:\n    - Andy Bierman (YumaWorks)\n    - Balazs Lengyel (Ericsson)\n
    \   - David Partain (Ericsson)\n    - Juergen Schoenwaelder (Jacobs University
    Bremen)\n    - Phil Shafer (Juniper Networks)\n"
  title: Contributors
- contents:
  - "Author's Address\n   Martin Bjorklund (editor)\n   Tail-f Systems\n   Email:
    mbj@tail-f.com\n"
  title: Author's Address
