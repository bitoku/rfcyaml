- title: __initial_text__
  contents:
  - '                Hypertext Transfer Protocol -- HTTP/1.1

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n\
    \   protocol for distributed, collaborative, hypermedia information\n   systems.\
    \ It is a generic, stateless, protocol which can be used for\n   many tasks beyond\
    \ its use for hypertext, such as name servers and\n   distributed object management\
    \ systems, through extension of its\n   request methods, error codes and headers\
    \ [47]. A feature of HTTP is\n   the typing and negotiation of data representation,\
    \ allowing systems\n   to be built independently of the data being transferred.\n\
    \   HTTP has been in use by the World-Wide Web global information\n   initiative\
    \ since 1990. This specification defines the protocol\n   referred to as \"HTTP/1.1\"\
    , and is an update to RFC 2068 [33].\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1   Introduction ...................................................7\n\
    \   1.1    Purpose......................................................7\n  \
    \ 1.2   Requirements .................................................8\n   1.3\
    \   Terminology ..................................................8\n   1.4  \
    \ Overall Operation ...........................................12\n   2   Notational\
    \ Conventions and Generic Grammar ....................14\n   2.1   Augmented BNF\
    \ ...............................................14\n   2.2   Basic Rules .................................................15\n\
    \   3   Protocol Parameters ...........................................17\n  \
    \ 3.1   HTTP Version ................................................17\n   3.2\
    \   Uniform Resource Identifiers ................................18\n   3.2.1\
    \    General Syntax ...........................................19\n   3.2.2  \
    \  http URL .................................................19\n   3.2.3    URI\
    \ Comparison ...........................................20\n   3.3   Date/Time\
    \ Formats ...........................................20\n   3.3.1    Full Date\
    \ ................................................20\n   3.3.2    Delta Seconds\
    \ ............................................21\n   3.4   Character Sets ..............................................21\n\
    \   3.4.1    Missing Charset ..........................................22\n  \
    \ 3.5   Content Codings .............................................23\n   3.6\
    \   Transfer Codings ............................................24\n   3.6.1\
    \    Chunked Transfer Coding ..................................25\n   3.7   Media\
    \ Types .................................................26\n   3.7.1    Canonicalization\
    \ and Text Defaults .......................27\n   3.7.2    Multipart Types ..........................................27\n\
    \   3.8   Product Tokens ..............................................28\n  \
    \ 3.9   Quality Values ..............................................29\n   3.10\
    \  Language Tags ...............................................29\n   3.11  Entity\
    \ Tags .................................................30\n   3.12  Range Units\
    \ .................................................30\n   4   HTTP Message ..................................................31\n\
    \   4.1   Message Types ...............................................31\n  \
    \ 4.2   Message Headers .............................................31\n   4.3\
    \   Message Body ................................................32\n   4.4  \
    \ Message Length ..............................................33\n   4.5   General\
    \ Header Fields .......................................34\n   5   Request .......................................................35\n\
    \   5.1   Request-Line ................................................35\n  \
    \ 5.1.1    Method ...................................................36\n   5.1.2\
    \    Request-URI ..............................................36\n   5.2   The\
    \ Resource Identified by a Request ........................38\n   5.3   Request\
    \ Header Fields .......................................38\n   6   Response ......................................................39\n\
    \   6.1   Status-Line .................................................39\n  \
    \ 6.1.1    Status Code and Reason Phrase ............................39\n   6.2\
    \   Response Header Fields ......................................41\n   7   Entity\
    \ ........................................................42\n   7.1   Entity\
    \ Header Fields ........................................42\n   7.2   Entity Body\
    \ .................................................43\n   7.2.1    Type .....................................................43\n\
    \   7.2.2    Entity Length ............................................43\n  \
    \ 8   Connections ...................................................44\n   8.1\
    \   Persistent Connections ......................................44\n   8.1.1\
    \    Purpose ..................................................44\n   8.1.2  \
    \  Overall Operation ........................................45\n   8.1.3    Proxy\
    \ Servers ............................................46\n   8.1.4    Practical\
    \ Considerations .................................46\n   8.2   Message Transmission\
    \ Requirements ...........................47\n   8.2.1    Persistent Connections\
    \ and Flow Control ..................47\n   8.2.2    Monitoring Connections for\
    \ Error Status Messages .........48\n   8.2.3    Use of the 100 (Continue) Status\
    \ .........................48\n   8.2.4    Client Behavior if Server Prematurely\
    \ Closes Connection ..50\n   9   Method Definitions ............................................51\n\
    \   9.1   Safe and Idempotent Methods .................................51\n  \
    \ 9.1.1    Safe Methods .............................................51\n   9.1.2\
    \    Idempotent Methods .......................................51\n   9.2   OPTIONS\
    \ .....................................................52\n   9.3   GET .........................................................53\n\
    \   9.4   HEAD ........................................................54\n  \
    \ 9.5   POST ........................................................54\n   9.6\
    \   PUT .........................................................55\n   9.7  \
    \ DELETE ......................................................56\n   9.8   TRACE\
    \ .......................................................56\n   9.9   CONNECT\
    \ .....................................................57\n   10   Status Code\
    \ Definitions ......................................57\n   10.1  Informational\
    \ 1xx ...........................................57\n   10.1.1   100 Continue\
    \ .............................................58\n   10.1.2   101 Switching Protocols\
    \ ..................................58\n   10.2  Successful 2xx ..............................................58\n\
    \   10.2.1   200 OK ...................................................58\n  \
    \ 10.2.2   201 Created ..............................................59\n   10.2.3\
    \   202 Accepted .............................................59\n   10.2.4  \
    \ 203 Non-Authoritative Information ........................59\n   10.2.5   204\
    \ No Content ...........................................60\n   10.2.6   205 Reset\
    \ Content ........................................60\n   10.2.7   206 Partial\
    \ Content ......................................60\n   10.3  Redirection 3xx .............................................61\n\
    \   10.3.1   300 Multiple Choices .....................................61\n  \
    \ 10.3.2   301 Moved Permanently ....................................62\n   10.3.3\
    \   302 Found ................................................62\n   10.3.4  \
    \ 303 See Other ............................................63\n   10.3.5   304\
    \ Not Modified .........................................63\n   10.3.6   305 Use\
    \ Proxy ............................................64\n   10.3.7   306 (Unused)\
    \ .............................................64\n   10.3.8   307 Temporary Redirect\
    \ ...................................65\n   10.4  Client Error 4xx ............................................65\n\
    \   10.4.1    400 Bad Request .........................................65\n  \
    \ 10.4.2    401 Unauthorized ........................................66\n   10.4.3\
    \    402 Payment Required ....................................66\n   10.4.4  \
    \  403 Forbidden ...........................................66\n   10.4.5    404\
    \ Not Found ...........................................66\n   10.4.6    405 Method\
    \ Not Allowed ..................................66\n   10.4.7    406 Not Acceptable\
    \ ......................................67\n   10.4.8    407 Proxy Authentication\
    \ Required .......................67\n   10.4.9    408 Request Timeout .....................................67\n\
    \   10.4.10   409 Conflict ............................................67\n  \
    \ 10.4.11   410 Gone ................................................68\n   10.4.12\
    \   411 Length Required .....................................68\n   10.4.13  \
    \ 412 Precondition Failed .................................68\n   10.4.14   413\
    \ Request Entity Too Large ............................69\n   10.4.15   414 Request-URI\
    \ Too Long ................................69\n   10.4.16   415 Unsupported Media\
    \ Type ..............................69\n   10.4.17   416 Requested Range Not\
    \ Satisfiable .....................69\n   10.4.18   417 Expectation Failed ..................................70\n\
    \   10.5  Server Error 5xx ............................................70\n  \
    \ 10.5.1   500 Internal Server Error ................................70\n   10.5.2\
    \   501 Not Implemented ......................................70\n   10.5.3  \
    \ 502 Bad Gateway ..........................................70\n   10.5.4   503\
    \ Service Unavailable ..................................70\n   10.5.5   504 Gateway\
    \ Timeout ......................................71\n   10.5.6   505 HTTP Version\
    \ Not Supported ...........................71\n   11   Access Authentication ........................................71\n\
    \   12   Content Negotiation ..........................................71\n  \
    \ 12.1  Server-driven Negotiation ...................................72\n   12.2\
    \  Agent-driven Negotiation ....................................73\n   12.3  Transparent\
    \ Negotiation .....................................74\n   13   Caching in HTTP\
    \ ..............................................74\n   13.1.1   Cache Correctness\
    \ ........................................75\n   13.1.2   Warnings .................................................76\n\
    \   13.1.3   Cache-control Mechanisms .................................77\n  \
    \ 13.1.4   Explicit User Agent Warnings .............................78\n   13.1.5\
    \   Exceptions to the Rules and Warnings .....................78\n   13.1.6  \
    \ Client-controlled Behavior ...............................79\n   13.2  Expiration\
    \ Model ............................................79\n   13.2.1   Server-Specified\
    \ Expiration ..............................79\n   13.2.2   Heuristic Expiration\
    \ .....................................80\n   13.2.3   Age Calculations .........................................80\n\
    \   13.2.4   Expiration Calculations ..................................83\n  \
    \ 13.2.5   Disambiguating Expiration Values .........................84\n   13.2.6\
    \   Disambiguating Multiple Responses ........................84\n   13.3  Validation\
    \ Model ............................................85\n   13.3.1   Last-Modified\
    \ Dates ......................................86\n   13.3.2   Entity Tag Cache\
    \ Validators ..............................86\n   13.3.3   Weak and Strong Validators\
    \ ...............................86\n   13.3.4   Rules for When to Use Entity\
    \ Tags and Last-Modified Dates.89\n   13.3.5   Non-validating Conditionals ..............................90\n\
    \   13.4  Response Cacheability .......................................91\n  \
    \ 13.5  Constructing Responses From Caches ..........................92\n   13.5.1\
    \   End-to-end and Hop-by-hop Headers ........................92\n   13.5.2  \
    \ Non-modifiable Headers ...................................92\n   13.5.3   Combining\
    \ Headers ........................................94\n   13.5.4   Combining Byte\
    \ Ranges ....................................95\n   13.6  Caching Negotiated Responses\
    \ ................................95\n   13.7  Shared and Non-Shared Caches ................................96\n\
    \   13.8  Errors or Incomplete Response Cache Behavior ................97\n  \
    \ 13.9  Side Effects of GET and HEAD ................................97\n   13.10\
    \   Invalidation After Updates or Deletions ...................97\n   13.11  \
    \ Write-Through Mandatory ...................................98\n   13.12   Cache\
    \ Replacement .........................................99\n   13.13   History\
    \ Lists .............................................99\n   14   Header Field\
    \ Definitions ....................................100\n   14.1  Accept .....................................................100\n\
    \   14.2  Accept-Charset .............................................102\n  \
    \ 14.3  Accept-Encoding ............................................102\n   14.4\
    \  Accept-Language ............................................104\n   14.5  Accept-Ranges\
    \ ..............................................105\n   14.6  Age ........................................................106\n\
    \   14.7  Allow ......................................................106\n  \
    \ 14.8  Authorization ..............................................107\n   14.9\
    \  Cache-Control ..............................................108\n   14.9.1\
    \   What is Cacheable .......................................109\n   14.9.2  \
    \ What May be Stored by Caches ............................110\n   14.9.3   Modifications\
    \ of the Basic Expiration Mechanism .........111\n   14.9.4   Cache Revalidation\
    \ and Reload Controls ..................113\n   14.9.5   No-Transform Directive\
    \ ..................................115\n   14.9.6   Cache Control Extensions\
    \ ................................116\n   14.10   Connection ...............................................117\n\
    \   14.11   Content-Encoding .........................................118\n  \
    \ 14.12   Content-Language .........................................118\n   14.13\
    \   Content-Length ...........................................119\n   14.14  \
    \ Content-Location .........................................120\n   14.15   Content-MD5\
    \ ..............................................121\n   14.16   Content-Range\
    \ ............................................122\n   14.17   Content-Type .............................................124\n\
    \   14.18   Date .....................................................124\n  \
    \ 14.18.1   Clockless Origin Server Operation ......................125\n   14.19\
    \   ETag .....................................................126\n   14.20  \
    \ Expect ...................................................126\n   14.21   Expires\
    \ ..................................................127\n   14.22   From .....................................................128\n\
    \   14.23   Host .....................................................128\n  \
    \ 14.24   If-Match .................................................129\n   14.25\
    \   If-Modified-Since ........................................130\n   14.26  \
    \ If-None-Match ............................................132\n   14.27   If-Range\
    \ .................................................133\n   14.28   If-Unmodified-Since\
    \ ......................................134\n   14.29   Last-Modified ............................................134\n\
    \   14.30   Location .................................................135\n  \
    \ 14.31   Max-Forwards .............................................136\n   14.32\
    \   Pragma ...................................................136\n   14.33  \
    \ Proxy-Authenticate .......................................137\n   14.34   Proxy-Authorization\
    \ ......................................137\n   14.35   Range ....................................................138\n\
    \   14.35.1    Byte Ranges ...........................................138\n  \
    \ 14.35.2    Range Retrieval Requests ..............................139\n   14.36\
    \   Referer ..................................................140\n   14.37  \
    \ Retry-After ..............................................141\n   14.38   Server\
    \ ...................................................141\n   14.39   TE .......................................................142\n\
    \   14.40   Trailer ..................................................143\n  \
    \ 14.41  Transfer-Encoding..........................................143\n   14.42\
    \   Upgrade ..................................................144\n   14.43  \
    \ User-Agent ...............................................145\n   14.44   Vary\
    \ .....................................................145\n   14.45   Via ......................................................146\n\
    \   14.46   Warning ..................................................148\n  \
    \ 14.47   WWW-Authenticate .........................................150\n   15\
    \ Security Considerations .......................................150\n   15.1\
    \      Personal Information....................................151\n   15.1.1\
    \   Abuse of Server Log Information .........................151\n   15.1.2  \
    \ Transfer of Sensitive Information .......................151\n   15.1.3   Encoding\
    \ Sensitive Information in URI's .................152\n   15.1.4   Privacy Issues\
    \ Connected to Accept Headers ..............152\n   15.2  Attacks Based On File\
    \ and Path Names .......................153\n   15.3  DNS Spoofing ...............................................154\n\
    \   15.4  Location Headers and Spoofing ..............................154\n  \
    \ 15.5  Content-Disposition Issues .................................154\n   15.6\
    \  Authentication Credentials and Idle Clients ................155\n   15.7  Proxies\
    \ and Caching ........................................155\n   15.7.1    Denial\
    \ of Service Attacks on Proxies....................156\n   16   Acknowledgments\
    \ .............................................156\n   17   References ..................................................158\n\
    \   18   Authors' Addresses ..........................................162\n  \
    \ 19   Appendices ..................................................164\n   19.1\
    \  Internet Media Type message/http and application/http ......164\n   19.2  Internet\
    \ Media Type multipart/byteranges ...................165\n   19.3  Tolerant Applications\
    \ ......................................166\n   19.4  Differences Between HTTP\
    \ Entities and RFC 2045 Entities ....167\n   19.4.1   MIME-Version ............................................167\n\
    \   19.4.2   Conversion to Canonical Form ............................167\n  \
    \ 19.4.3   Conversion of Date Formats ..............................168\n   19.4.4\
    \   Introduction of Content-Encoding ........................168\n   19.4.5  \
    \ No Content-Transfer-Encoding ............................168\n   19.4.6   Introduction\
    \ of Transfer-Encoding .......................169\n   19.4.7   MHTML and Line\
    \ Length Limitations .......................169\n   19.5  Additional Features\
    \ ........................................169\n   19.5.1   Content-Disposition\
    \ .....................................170\n   19.6  Compatibility with Previous\
    \ Versions .......................170\n   19.6.1   Changes from HTTP/1.0 ...................................171\n\
    \   19.6.2   Compatibility with HTTP/1.0 Persistent Connections ......172\n  \
    \ 19.6.3   Changes from RFC 2068 ...................................172\n   20\
    \   Index .......................................................175\n   21  \
    \ Full Copyright Statement ....................................176\n"
- title: 1 Introduction
  contents:
  - '1 Introduction

    '
- title: 1.1 Purpose
  contents:
  - "1.1 Purpose\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n\
    \   protocol for distributed, collaborative, hypermedia information\n   systems.\
    \ HTTP has been in use by the World-Wide Web global\n   information initiative\
    \ since 1990. The first version of HTTP,\n   referred to as HTTP/0.9, was a simple\
    \ protocol for raw data transfer\n   across the Internet. HTTP/1.0, as defined\
    \ by RFC 1945 [6], improved\n   the protocol by allowing messages to be in the\
    \ format of MIME-like\n   messages, containing metainformation about the data\
    \ transferred and\n   modifiers on the request/response semantics. However, HTTP/1.0\
    \ does\n   not sufficiently take into consideration the effects of hierarchical\n\
    \   proxies, caching, the need for persistent connections, or virtual\n   hosts.\
    \ In addition, the proliferation of incompletely-implemented\n   applications\
    \ calling themselves \"HTTP/1.0\" has necessitated a\n   protocol version change\
    \ in order for two communicating applications\n   to determine each other's true\
    \ capabilities.\n   This specification defines the protocol referred to as \"\
    HTTP/1.1\".\n   This protocol includes more stringent requirements than HTTP/1.0\
    \ in\n   order to ensure reliable implementation of its features.\n   Practical\
    \ information systems require more functionality than simple\n   retrieval, including\
    \ search, front-end update, and annotation. HTTP\n   allows an open-ended set\
    \ of methods and headers that indicate the\n   purpose of a request [47]. It builds\
    \ on the discipline of reference\n   provided by the Uniform Resource Identifier\
    \ (URI) [3], as a location\n   (URL) [4] or name (URN) [20], for indicating the\
    \ resource to which a\n   method is to be applied. Messages are passed in a format\
    \ similar to\n   that used by Internet mail [9] as defined by the Multipurpose\n\
    \   Internet Mail Extensions (MIME) [7].\n   HTTP is also used as a generic protocol\
    \ for communication between\n   user agents and proxies/gateways to other Internet\
    \ systems, including\n   those supported by the SMTP [16], NNTP [13], FTP [18],\
    \ Gopher [2],\n   and WAIS [10] protocols. In this way, HTTP allows basic hypermedia\n\
    \   access to resources available from diverse applications.\n"
- title: 1.2 Requirements
  contents:
  - "1.2 Requirements\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [34].\n   An implementation is not compliant if it fails to satisfy one\
    \ or more\n   of the MUST or REQUIRED level requirements for the protocols it\n\
    \   implements. An implementation that satisfies all the MUST or REQUIRED\n  \
    \ level and all the SHOULD level requirements for its protocols is said\n   to\
    \ be \"unconditionally compliant\"; one that satisfies all the MUST\n   level\
    \ requirements but not all the SHOULD level requirements for its\n   protocols\
    \ is said to be \"conditionally compliant.\"\n"
- title: 1.3 Terminology
  contents:
  - "1.3 Terminology\n   This specification uses a number of terms to refer to the\
    \ roles\n   played by participants in, and objects of, the HTTP communication.\n\
    \   connection\n      A transport layer virtual circuit established between two\
    \ programs\n      for the purpose of communication.\n   message\n      The basic\
    \ unit of HTTP communication, consisting of a structured\n      sequence of octets\
    \ matching the syntax defined in section 4 and\n      transmitted via the connection.\n\
    \   request\n      An HTTP request message, as defined in section 5.\n   response\n\
    \      An HTTP response message, as defined in section 6.\n   resource\n     \
    \ A network data object or service that can be identified by a URI,\n      as\
    \ defined in section 3.2. Resources may be available in multiple\n      representations\
    \ (e.g. multiple languages, data formats, size, and\n      resolutions) or vary\
    \ in other ways.\n   entity\n      The information transferred as the payload\
    \ of a request or\n      response. An entity consists of metainformation in the\
    \ form of\n      entity-header fields and content in the form of an entity-body,\
    \ as\n      described in section 7.\n   representation\n      An entity included\
    \ with a response that is subject to content\n      negotiation, as described\
    \ in section 12. There may exist multiple\n      representations associated with\
    \ a particular response status.\n   content negotiation\n      The mechanism for\
    \ selecting the appropriate representation when\n      servicing a request, as\
    \ described in section 12. The\n      representation of entities in any response\
    \ can be negotiated\n      (including error responses).\n   variant\n      A resource\
    \ may have one, or more than one, representation(s)\n      associated with it\
    \ at any given instant. Each of these\n      representations is termed a `varriant'.\
    \  Use of the term `variant'\n      does not necessarily imply that the resource\
    \ is subject to content\n      negotiation.\n   client\n      A program that establishes\
    \ connections for the purpose of sending\n      requests.\n   user agent\n   \
    \   The client which initiates a request. These are often browsers,\n      editors,\
    \ spiders (web-traversing robots), or other end user tools.\n   server\n     \
    \ An application program that accepts connections in order to\n      service requests\
    \ by sending back responses. Any given program may\n      be capable of being\
    \ both a client and a server; our use of these\n      terms refers only to the\
    \ role being performed by the program for a\n      particular connection, rather\
    \ than to the program's capabilities\n      in general. Likewise, any server may\
    \ act as an origin server,\n      proxy, gateway, or tunnel, switching behavior\
    \ based on the nature\n      of each request.\n   origin server\n      The server\
    \ on which a given resource resides or is to be created.\n   proxy\n      An intermediary\
    \ program which acts as both a server and a client\n      for the purpose of making\
    \ requests on behalf of other clients.\n      Requests are serviced internally\
    \ or by passing them on, with\n      possible translation, to other servers. A\
    \ proxy MUST implement\n      both the client and server requirements of this\
    \ specification. A\n      \"transparent proxy\" is a proxy that does not modify\
    \ the request or\n      response beyond what is required for proxy authentication\
    \ and\n      identification. A \"non-transparent proxy\" is a proxy that modifies\n\
    \      the request or response in order to provide some added service to\n   \
    \   the user agent, such as group annotation services, media type\n      transformation,\
    \ protocol reduction, or anonymity filtering. Except\n      where either transparent\
    \ or non-transparent behavior is explicitly\n      stated, the HTTP proxy requirements\
    \ apply to both types of\n      proxies.\n   gateway\n      A server which acts\
    \ as an intermediary for some other server.\n      Unlike a proxy, a gateway receives\
    \ requests as if it were the\n      origin server for the requested resource;\
    \ the requesting client\n      may not be aware that it is communicating with\
    \ a gateway.\n   tunnel\n      An intermediary program which is acting as a blind\
    \ relay between\n      two connections. Once active, a tunnel is not considered\
    \ a party\n      to the HTTP communication, though the tunnel may have been\n\
    \      initiated by an HTTP request. The tunnel ceases to exist when both\n  \
    \    ends of the relayed connections are closed.\n   cache\n      A program's\
    \ local store of response messages and the subsystem\n      that controls its\
    \ message storage, retrieval, and deletion. A\n      cache stores cacheable responses\
    \ in order to reduce the response\n      time and network bandwidth consumption\
    \ on future, equivalent\n      requests. Any client or server may include a cache,\
    \ though a cache\n      cannot be used by a server that is acting as a tunnel.\n\
    \   cacheable\n      A response is cacheable if a cache is allowed to store a\
    \ copy of\n      the response message for use in answering subsequent requests.\
    \ The\n      rules for determining the cacheability of HTTP responses are\n  \
    \    defined in section 13. Even if a resource is cacheable, there may\n     \
    \ be additional constraints on whether a cache can use the cached\n      copy\
    \ for a particular request.\n   first-hand\n      A response is first-hand if\
    \ it comes directly and without\n      unnecessary delay from the origin server,\
    \ perhaps via one or more\n      proxies. A response is also first-hand if its\
    \ validity has just\n      been checked directly with the origin server.\n   explicit\
    \ expiration time\n      The time at which the origin server intends that an entity\
    \ should\n      no longer be returned by a cache without further validation.\n\
    \   heuristic expiration time\n      An expiration time assigned by a cache when\
    \ no explicit expiration\n      time is available.\n   age\n      The age of a\
    \ response is the time since it was sent by, or\n      successfully validated\
    \ with, the origin server.\n   freshness lifetime\n      The length of time between\
    \ the generation of a response and its\n      expiration time.\n   fresh\n   \
    \   A response is fresh if its age has not yet exceeded its freshness\n      lifetime.\n\
    \   stale\n      A response is stale if its age has passed its freshness lifetime.\n\
    \   semantically transparent\n      A cache behaves in a \"semantically transparent\"\
    \ manner, with\n      respect to a particular response, when its use affects neither\
    \ the\n      requesting client nor the origin server, except to improve\n    \
    \  performance. When a cache is semantically transparent, the client\n      receives\
    \ exactly the same response (except for hop-by-hop headers)\n      that it would\
    \ have received had its request been handled directly\n      by the origin server.\n\
    \   validator\n      A protocol element (e.g., an entity tag or a Last-Modified\
    \ time)\n      that is used to find out whether a cache entry is an equivalent\n\
    \      copy of an entity.\n   upstream/downstream\n      Upstream and downstream\
    \ describe the flow of a message: all\n      messages flow from upstream to downstream.\n\
    \   inbound/outbound\n      Inbound and outbound refer to the request and response\
    \ paths for\n      messages: \"inbound\" means \"traveling toward the origin server\"\
    ,\n      and \"outbound\" means \"traveling toward the user agent\"\n"
- title: 1.4 Overall Operation
  contents:
  - "1.4 Overall Operation\n   The HTTP protocol is a request/response protocol. A\
    \ client sends a\n   request to the server in the form of a request method, URI,\
    \ and\n   protocol version, followed by a MIME-like message containing request\n\
    \   modifiers, client information, and possible body content over a\n   connection\
    \ with a server. The server responds with a status line,\n   including the message's\
    \ protocol version and a success or error code,\n   followed by a MIME-like message\
    \ containing server information, entity\n   metainformation, and possible entity-body\
    \ content. The relationship\n   between HTTP and MIME is described in appendix\
    \ 19.4.\n   Most HTTP communication is initiated by a user agent and consists\
    \ of\n   a request to be applied to a resource on some origin server. In the\n\
    \   simplest case, this may be accomplished via a single connection (v)\n   between\
    \ the user agent (UA) and the origin server (O).\n          request chain ------------------------>\n\
    \       UA -------------------v------------------- O\n          <-----------------------\
    \ response chain\n   A more complicated situation occurs when one or more intermediaries\n\
    \   are present in the request/response chain. There are three common\n   forms\
    \ of intermediary: proxy, gateway, and tunnel. A proxy is a\n   forwarding agent,\
    \ receiving requests for a URI in its absolute form,\n   rewriting all or part\
    \ of the message, and forwarding the reformatted\n   request toward the server\
    \ identified by the URI. A gateway is a\n   receiving agent, acting as a layer\
    \ above some other server(s) and, if\n   necessary, translating the requests to\
    \ the underlying server's\n   protocol. A tunnel acts as a relay point between\
    \ two connections\n   without changing the messages; tunnels are used when the\n\
    \   communication needs to pass through an intermediary (such as a\n   firewall)\
    \ even when the intermediary cannot understand the contents\n   of the messages.\n\
    \          request chain -------------------------------------->\n       UA -----v-----\
    \ A -----v----- B -----v----- C -----v----- O\n          <-------------------------------------\
    \ response chain\n   The figure above shows three intermediaries (A, B, and C)\
    \ between the\n   user agent and origin server. A request or response message\
    \ that\n   travels the whole chain will pass through four separate connections.\n\
    \   This distinction is important because some HTTP communication options\n  \
    \ may apply only to the connection with the nearest, non-tunnel\n   neighbor,\
    \ only to the end-points of the chain, or to all connections\n   along the chain.\
    \ Although the diagram is linear, each participant may\n   be engaged in multiple,\
    \ simultaneous communications. For example, B\n   may be receiving requests from\
    \ many clients other than A, and/or\n   forwarding requests to servers other than\
    \ C, at the same time that it\n   is handling A's request.\n   Any party to the\
    \ communication which is not acting as a tunnel may\n   employ an internal cache\
    \ for handling requests. The effect of a cache\n   is that the request/response\
    \ chain is shortened if one of the\n   participants along the chain has a cached\
    \ response applicable to that\n   request. The following illustrates the resulting\
    \ chain if B has a\n   cached copy of an earlier response from O (via C) for a\
    \ request which\n   has not been cached by UA or A.\n          request chain ---------->\n\
    \       UA -----v----- A -----v----- B - - - - - - C - - - - - - O\n         \
    \ <--------- response chain\n   Not all responses are usefully cacheable, and\
    \ some requests may\n   contain modifiers which place special requirements on\
    \ cache behavior.\n   HTTP requirements for cache behavior and cacheable responses\
    \ are\n   defined in section 13.\n   In fact, there are a wide variety of architectures\
    \ and configurations\n   of caches and proxies currently being experimented with\
    \ or deployed\n   across the World Wide Web. These systems include national hierarchies\n\
    \   of proxy caches to save transoceanic bandwidth, systems that\n   broadcast\
    \ or multicast cache entries, organizations that distribute\n   subsets of cached\
    \ data via CD-ROM, and so on. HTTP systems are used\n   in corporate intranets\
    \ over high-bandwidth links, and for access via\n   PDAs with low-power radio\
    \ links and intermittent connectivity. The\n   goal of HTTP/1.1 is to support\
    \ the wide diversity of configurations\n   already deployed while introducing\
    \ protocol constructs that meet the\n   needs of those who build web applications\
    \ that require high\n   reliability and, failing that, at least reliable indications\
    \ of\n   failure.\n   HTTP communication usually takes place over TCP/IP connections.\
    \ The\n   default port is TCP 80 [19], but other ports can be used. This does\n\
    \   not preclude HTTP from being implemented on top of any other protocol\n  \
    \ on the Internet, or on other networks. HTTP only presumes a reliable\n   transport;\
    \ any protocol that provides such guarantees can be used;\n   the mapping of the\
    \ HTTP/1.1 request and response structures onto the\n   transport data units of\
    \ the protocol in question is outside the scope\n   of this specification.\n \
    \  In HTTP/1.0, most implementations used a new connection for each\n   request/response\
    \ exchange. In HTTP/1.1, a connection may be used for\n   one or more request/response\
    \ exchanges, although connections may be\n   closed for a variety of reasons (see\
    \ section 8.1).\n"
- title: 2 Notational Conventions and Generic Grammar
  contents:
  - '2 Notational Conventions and Generic Grammar

    '
- title: 2.1 Augmented BNF
  contents:
  - "2.1 Augmented BNF\n   All of the mechanisms specified in this document are described\
    \ in\n   both prose and an augmented Backus-Naur Form (BNF) similar to that\n\
    \   used by RFC 822 [9]. Implementors will need to be familiar with the\n   notation\
    \ in order to understand this specification. The augmented BNF\n   includes the\
    \ following constructs:\n   name = definition\n      The name of a rule is simply\
    \ the name itself (without any\n      enclosing \"<\" and \">\") and is separated\
    \ from its definition by the\n      equal \"=\" character. White space is only\
    \ significant in that\n      indentation of continuation lines is used to indicate\
    \ a rule\n      definition that spans more than one line. Certain basic rules\
    \ are\n      in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle\n\
    \      brackets are used within definitions whenever their presence will\n   \
    \   facilitate discerning the use of rule names.\n   \"literal\"\n      Quotation\
    \ marks surround literal text. Unless stated otherwise,\n      the text is case-insensitive.\n\
    \   rule1 | rule2\n      Elements separated by a bar (\"|\") are alternatives,\
    \ e.g., \"yes |\n      no\" will accept yes or no.\n   (rule1 rule2)\n      Elements\
    \ enclosed in parentheses are treated as a single element.\n      Thus, \"(elem\
    \ (foo | bar) elem)\" allows the token sequences \"elem\n      foo elem\" and\
    \ \"elem bar elem\".\n   *rule\n      The character \"*\" preceding an element\
    \ indicates repetition. The\n      full form is \"<n>*<m>element\" indicating\
    \ at least <n> and at most\n      <m> occurrences of element. Default values are\
    \ 0 and infinity so\n      that \"*(element)\" allows any number, including zero;\
    \ \"1*element\"\n      requires at least one; and \"1*2element\" allows one or\
    \ two.\n   [rule]\n      Square brackets enclose optional elements; \"[foo bar]\"\
    \ is\n      equivalent to \"*1(foo bar)\".\n   N rule\n      Specific repetition:\
    \ \"<n>(element)\" is equivalent to\n      \"<n>*<n>(element)\"; that is, exactly\
    \ <n> occurrences of (element).\n      Thus 2DIGIT is a 2-digit number, and 3ALPHA\
    \ is a string of three\n      alphabetic characters.\n   #rule\n      A construct\
    \ \"#\" is defined, similar to \"*\", for defining lists of\n      elements. The\
    \ full form is \"<n>#<m>element\" indicating at least\n      <n> and at most <m>\
    \ elements, each separated by one or more commas\n      (\",\") and OPTIONAL linear\
    \ white space (LWS). This makes the usual\n      form of lists very easy; a rule\
    \ such as\n         ( *LWS element *( *LWS \",\" *LWS element ))\n      can be\
    \ shown as\n         1#element\n      Wherever this construct is used, null elements\
    \ are allowed, but do\n      not contribute to the count of elements present.\
    \ That is,\n      \"(element), , (element) \" is permitted, but counts as only\
    \ two\n      elements. Therefore, where at least one element is required, at\n\
    \      least one non-null element MUST be present. Default values are 0\n    \
    \  and infinity so that \"#element\" allows any number, including zero;\n    \
    \  \"1#element\" requires at least one; and \"1#2element\" allows one or\n   \
    \   two.\n   ; comment\n      A semi-colon, set off some distance to the right\
    \ of rule text,\n      starts a comment that continues to the end of line. This\
    \ is a\n      simple way of including useful notes in parallel with the\n    \
    \  specifications.\n   implied *LWS\n      The grammar described by this specification\
    \ is word-based. Except\n      where noted otherwise, linear white space (LWS)\
    \ can be included\n      between any two adjacent words (token or quoted-string),\
    \ and\n      between adjacent words and separators, without changing the\n   \
    \   interpretation of a field. At least one delimiter (LWS and/or\n      separators)\
    \ MUST exist between any two tokens (for the definition\n      of \"token\" below),\
    \ since they would otherwise be interpreted as a\n      single token.\n"
- title: 2.2 Basic Rules
  contents:
  - "2.2 Basic Rules\n   The following rules are used throughout this specification\
    \ to\n   describe basic parsing constructs. The US-ASCII coded character set\n\
    \   is defined by ANSI X3.4-1986 [21].\n       OCTET          = <any 8-bit sequence\
    \ of data>\n       CHAR           = <any US-ASCII character (octets 0 - 127)>\n\
    \       UPALPHA        = <any US-ASCII uppercase letter \"A\"..\"Z\">\n      \
    \ LOALPHA        = <any US-ASCII lowercase letter \"a\"..\"z\">\n       ALPHA\
    \          = UPALPHA | LOALPHA\n       DIGIT          = <any US-ASCII digit \"\
    0\"..\"9\">\n       CTL            = <any US-ASCII control character\n       \
    \                 (octets 0 - 31) and DEL (127)>\n       CR             = <US-ASCII\
    \ CR, carriage return (13)>\n       LF             = <US-ASCII LF, linefeed (10)>\n\
    \       SP             = <US-ASCII SP, space (32)>\n       HT             = <US-ASCII\
    \ HT, horizontal-tab (9)>\n       <\">            = <US-ASCII double-quote mark\
    \ (34)>\n   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for\
    \ all\n   protocol elements except the entity-body (see appendix 19.3 for\n  \
    \ tolerant applications). The end-of-line marker within an entity-body\n   is\
    \ defined by its associated media type, as described in section 3.7.\n       CRLF\
    \           = CR LF\n   HTTP/1.1 header field values can be folded onto multiple\
    \ lines if the\n   continuation line begins with a space or horizontal tab. All\
    \ linear\n   white space, including folding, has the same semantics as SP. A\n\
    \   recipient MAY replace any linear white space with a single SP before\n   interpreting\
    \ the field value or forwarding the message downstream.\n       LWS          \
    \  = [CRLF] 1*( SP | HT )\n   The TEXT rule is only used for descriptive field\
    \ contents and values\n   that are not intended to be interpreted by the message\
    \ parser. Words\n   of *TEXT MAY contain characters from character sets other\
    \ than ISO-\n   8859-1 [22] only when encoded according to the rules of RFC 2047\n\
    \   [14].\n       TEXT           = <any OCTET except CTLs,\n                 \
    \       but including LWS>\n   A CRLF is allowed in the definition of TEXT only\
    \ as part of a header\n   field continuation. It is expected that the folding\
    \ LWS will be\n   replaced with a single SP before interpretation of the TEXT\
    \ value.\n   Hexadecimal numeric characters are used in several protocol elements.\n\
    \       HEX            = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n     \
    \                 | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | DIGIT\n  \
    \ Many HTTP/1.1 header field values consist of words separated by LWS\n   or special\
    \ characters. These special characters MUST be in a quoted\n   string to be used\
    \ within a parameter value (as defined in section\n   3.6).\n       token    \
    \      = 1*<any CHAR except CTLs or separators>\n       separators     = \"(\"\
    \ | \")\" | \"<\" | \">\" | \"@\"\n                      | \",\" | \";\" | \"\
    :\" | \"\\\" | <\">\n                      | \"/\" | \"[\" | \"]\" | \"?\" | \"\
    =\"\n                      | \"{\" | \"}\" | SP | HT\n   Comments can be included\
    \ in some HTTP header fields by surrounding\n   the comment text with parentheses.\
    \ Comments are only allowed in\n   fields containing \"comment\" as part of their\
    \ field value definition.\n   In all other fields, parentheses are considered\
    \ part of the field\n   value.\n       comment        = \"(\" *( ctext | quoted-pair\
    \ | comment ) \")\"\n       ctext          = <any TEXT excluding \"(\" and \"\
    )\">\n   A string of text is parsed as a single word if it is quoted using\n \
    \  double-quote marks.\n       quoted-string  = ( <\"> *(qdtext | quoted-pair\
    \ ) <\"> )\n       qdtext         = <any TEXT except <\">>\n   The backslash character\
    \ (\"\\\") MAY be used as a single-character\n   quoting mechanism only within\
    \ quoted-string and comment constructs.\n       quoted-pair    = \"\\\" CHAR\n"
- title: 3 Protocol Parameters
  contents:
  - '3 Protocol Parameters

    '
- title: 3.1 HTTP Version
  contents:
  - "3.1 HTTP Version\n   HTTP uses a \"<major>.<minor>\" numbering scheme to indicate\
    \ versions\n   of the protocol. The protocol versioning policy is intended to\
    \ allow\n   the sender to indicate the format of a message and its capacity for\n\
    \   understanding further HTTP communication, rather than the features\n   obtained\
    \ via that communication. No change is made to the version\n   number for the\
    \ addition of message components which do not affect\n   communication behavior\
    \ or which only add to extensible field values.\n   The <minor> number is incremented\
    \ when the changes made to the\n   protocol add features which do not change the\
    \ general message parsing\n   algorithm, but which may add to the message semantics\
    \ and imply\n   additional capabilities of the sender. The <major> number is\n\
    \   incremented when the format of a message within the protocol is\n   changed.\
    \ See RFC 2145 [36] for a fuller explanation.\n   The version of an HTTP message\
    \ is indicated by an HTTP-Version field\n   in the first line of the message.\n\
    \       HTTP-Version   = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n   Note that the\
    \ major and minor numbers MUST be treated as separate\n   integers and that each\
    \ MAY be incremented higher than a single digit.\n   Thus, HTTP/2.4 is a lower\
    \ version than HTTP/2.13, which in turn is\n   lower than HTTP/12.3. Leading zeros\
    \ MUST be ignored by recipients and\n   MUST NOT be sent.\n   An application that\
    \ sends a request or response message that includes\n   HTTP-Version of \"HTTP/1.1\"\
    \ MUST be at least conditionally compliant\n   with this specification. Applications\
    \ that are at least conditionally\n   compliant with this specification SHOULD\
    \ use an HTTP-Version of\n   \"HTTP/1.1\" in their messages, and MUST do so for\
    \ any message that is\n   not compatible with HTTP/1.0. For more details on when\
    \ to send\n   specific HTTP-Version values, see RFC 2145 [36].\n   The HTTP version\
    \ of an application is the highest HTTP version for\n   which the application\
    \ is at least conditionally compliant.\n   Proxy and gateway applications need\
    \ to be careful when forwarding\n   messages in protocol versions different from\
    \ that of the application.\n   Since the protocol version indicates the protocol\
    \ capability of the\n   sender, a proxy/gateway MUST NOT send a message with a\
    \ version\n   indicator which is greater than its actual version. If a higher\n\
    \   version request is received, the proxy/gateway MUST either downgrade\n   the\
    \ request version, or respond with an error, or switch to tunnel\n   behavior.\n\
    \   Due to interoperability problems with HTTP/1.0 proxies discovered\n   since\
    \ the publication of RFC 2068[33], caching proxies MUST, gateways\n   MAY, and\
    \ tunnels MUST NOT upgrade the request to the highest version\n   they support.\
    \ The proxy/gateway's response to that request MUST be in\n   the same major version\
    \ as the request.\n      Note: Converting between versions of HTTP may involve\
    \ modification\n      of header fields required or forbidden by the versions involved.\n"
- title: 3.2 Uniform Resource Identifiers
  contents:
  - "3.2 Uniform Resource Identifiers\n   URIs have been known by many names: WWW\
    \ addresses, Universal Document\n   Identifiers, Universal Resource Identifiers\
    \ [3], and finally the\n   combination of Uniform Resource Locators (URL) [4]\
    \ and Names (URN)\n   [20]. As far as HTTP is concerned, Uniform Resource Identifiers\
    \ are\n   simply formatted strings which identify--via name, location, or any\n\
    \   other characteristic--a resource.\n"
- title: 3.2.1 General Syntax
  contents:
  - "3.2.1 General Syntax\n   URIs in HTTP can be represented in absolute form or\
    \ relative to some\n   known base URI [11], depending upon the context of their\
    \ use. The two\n   forms are differentiated by the fact that absolute URIs always\
    \ begin\n   with a scheme name followed by a colon. For definitive information\
    \ on\n   URL syntax and semantics, see \"Uniform Resource Identifiers (URI):\n\
    \   Generic Syntax and Semantics,\" RFC 2396 [42] (which replaces RFCs\n   1738\
    \ [4] and RFC 1808 [11]). This specification adopts the\n   definitions of \"\
    URI-reference\", \"absoluteURI\", \"relativeURI\", \"port\",\n   \"host\",\"abs_path\"\
    , \"rel_path\", and \"authority\" from that\n   specification.\n   The HTTP protocol\
    \ does not place any a priori limit on the length of\n   a URI. Servers MUST be\
    \ able to handle the URI of any resource they\n   serve, and SHOULD be able to\
    \ handle URIs of unbounded length if they\n   provide GET-based forms that could\
    \ generate such URIs. A server\n   SHOULD return 414 (Request-URI Too Long) status\
    \ if a URI is longer\n   than the server can handle (see section 10.4.15).\n \
    \     Note: Servers ought to be cautious about depending on URI lengths\n    \
    \  above 255 bytes, because some older client or proxy\n      implementations\
    \ might not properly support these lengths.\n"
- title: 3.2.2 http URL
  contents:
  - "3.2.2 http URL\n   The \"http\" scheme is used to locate network resources via\
    \ the HTTP\n   protocol. This section defines the scheme-specific syntax and\n\
    \   semantics for http URLs.\n   http_URL = \"http:\" \"//\" host [ \":\" port\
    \ ] [ abs_path [ \"?\" query ]]\n   If the port is empty or not given, port 80\
    \ is assumed. The semantics\n   are that the identified resource is located at\
    \ the server listening\n   for TCP connections on that port of that host, and\
    \ the Request-URI\n   for the resource is abs_path (section 5.1.2). The use of\
    \ IP addresses\n   in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]).\
    \ If\n   the abs_path is not present in the URL, it MUST be given as \"/\" when\n\
    \   used as a Request-URI for a resource (section 5.1.2). If a proxy\n   receives\
    \ a host name which is not a fully qualified domain name, it\n   MAY add its domain\
    \ to the host name it received. If a proxy receives\n   a fully qualified domain\
    \ name, the proxy MUST NOT change the host\n   name.\n"
- title: 3.2.3 URI Comparison
  contents:
  - "3.2.3 URI Comparison\n   When comparing two URIs to decide if they match or not,\
    \ a client\n   SHOULD use a case-sensitive octet-by-octet comparison of the entire\n\
    \   URIs, with these exceptions:\n      - A port that is empty or not given is\
    \ equivalent to the default\n        port for that URI-reference;\n        - Comparisons\
    \ of host names MUST be case-insensitive;\n        - Comparisons of scheme names\
    \ MUST be case-insensitive;\n        - An empty abs_path is equivalent to an abs_path\
    \ of \"/\".\n   Characters other than those in the \"reserved\" and \"unsafe\"\
    \ sets (see\n   RFC 2396 [42]) are equivalent to their \"\"%\" HEX HEX\" encoding.\n\
    \   For example, the following three URIs are equivalent:\n      http://abc.com:80/~smith/home.html\n\
    \      http://ABC.com/%7Esmith/home.html\n      http://ABC.com:/%7esmith/home.html\n"
- title: 3.3 Date/Time Formats
  contents:
  - '3.3 Date/Time Formats

    '
- title: 3.3.1 Full Date
  contents:
  - "3.3.1 Full Date\n   HTTP applications have historically allowed three different\
    \ formats\n   for the representation of date/time stamps:\n      Sun, 06 Nov 1994\
    \ 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n      Sunday, 06-Nov-94 08:49:37\
    \ GMT ; RFC 850, obsoleted by RFC 1036\n      Sun Nov  6 08:49:37 1994       ;\
    \ ANSI C's asctime() format\n   The first format is preferred as an Internet standard\
    \ and represents\n   a fixed-length subset of that defined by RFC 1123 [8] (an\
    \ update to\n   RFC 822 [9]). The second format is in common use, but is based\
    \ on the\n   obsolete RFC 850 [12] date format and lacks a four-digit year.\n\
    \   HTTP/1.1 clients and servers that parse the date value MUST accept\n   all\
    \ three formats (for compatibility with HTTP/1.0), though they MUST\n   only generate\
    \ the RFC 1123 format for representing HTTP-date values\n   in header fields.\
    \ See section 19.3 for further information.\n      Note: Recipients of date values\
    \ are encouraged to be robust in\n      accepting date values that may have been\
    \ sent by non-HTTP\n      applications, as is sometimes the case when retrieving\
    \ or posting\n      messages via proxies/gateways to SMTP or NNTP.\n   All HTTP\
    \ date/time stamps MUST be represented in Greenwich Mean Time\n   (GMT), without\
    \ exception. For the purposes of HTTP, GMT is exactly\n   equal to UTC (Coordinated\
    \ Universal Time). This is indicated in the\n   first two formats by the inclusion\
    \ of \"GMT\" as the three-letter\n   abbreviation for time zone, and MUST be assumed\
    \ when reading the\n   asctime format. HTTP-date is case sensitive and MUST NOT\
    \ include\n   additional LWS beyond that specifically included as SP in the\n\
    \   grammar.\n       HTTP-date    = rfc1123-date | rfc850-date | asctime-date\n\
    \       rfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\n       rfc850-date\
    \  = weekday \",\" SP date2 SP time SP \"GMT\"\n       asctime-date = wkday SP\
    \ date3 SP time SP 4DIGIT\n       date1        = 2DIGIT SP month SP 4DIGIT\n \
    \                     ; day month year (e.g., 02 Jun 1982)\n       date2     \
    \   = 2DIGIT \"-\" month \"-\" 2DIGIT\n                      ; day-month-year\
    \ (e.g., 02-Jun-82)\n       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n\
    \                      ; month day (e.g., Jun  2)\n       time         = 2DIGIT\
    \ \":\" 2DIGIT \":\" 2DIGIT\n                      ; 00:00:00 - 23:59:59\n   \
    \    wkday        = \"Mon\" | \"Tue\" | \"Wed\"\n                    | \"Thu\"\
    \ | \"Fri\" | \"Sat\" | \"Sun\"\n       weekday      = \"Monday\" | \"Tuesday\"\
    \ | \"Wednesday\"\n                    | \"Thursday\" | \"Friday\" | \"Saturday\"\
    \ | \"Sunday\"\n       month        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n\
    \                    | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n               \
    \     | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n      Note: HTTP requirements for\
    \ the date/time stamp format apply only\n      to their usage within the protocol\
    \ stream. Clients and servers are\n      not required to use these formats for\
    \ user presentation, request\n      logging, etc.\n"
- title: 3.3.2 Delta Seconds
  contents:
  - "3.3.2 Delta Seconds\n   Some HTTP header fields allow a time value to be specified\
    \ as an\n   integer number of seconds, represented in decimal, after the time\n\
    \   that the message was received.\n       delta-seconds  = 1*DIGIT\n"
- title: 3.4 Character Sets
  contents:
  - "3.4 Character Sets\n   HTTP uses the same definition of the term \"character\
    \ set\" as that\n   described for MIME:\n   The term \"character set\" is used\
    \ in this document to refer to a\n   method used with one or more tables to convert\
    \ a sequence of octets\n   into a sequence of characters. Note that unconditional\
    \ conversion in\n   the other direction is not required, in that not all characters\
    \ may\n   be available in a given character set and a character set may provide\n\
    \   more than one sequence of octets to represent a particular character.\n  \
    \ This definition is intended to allow various kinds of character\n   encoding,\
    \ from simple single-table mappings such as US-ASCII to\n   complex table switching\
    \ methods such as those that use ISO-2022's\n   techniques. However, the definition\
    \ associated with a MIME character\n   set name MUST fully specify the mapping\
    \ to be performed from octets\n   to characters. In particular, use of external\
    \ profiling information\n   to determine the exact mapping is not permitted.\n\
    \      Note: This use of the term \"character set\" is more commonly\n      referred\
    \ to as a \"character encoding.\" However, since HTTP and\n      MIME share the\
    \ same registry, it is important that the terminology\n      also be shared.\n\
    \   HTTP character sets are identified by case-insensitive tokens. The\n   complete\
    \ set of tokens is defined by the IANA Character Set registry\n   [19].\n    \
    \   charset = token\n   Although HTTP allows an arbitrary token to be used as\
    \ a charset\n   value, any token that has a predefined value within the IANA\n\
    \   Character Set registry [19] MUST represent the character set defined\n   by\
    \ that registry. Applications SHOULD limit their use of character\n   sets to\
    \ those defined by the IANA registry.\n   Implementors should be aware of IETF\
    \ character set requirements [38]\n   [41].\n"
- title: 3.4.1 Missing Charset
  contents:
  - "3.4.1 Missing Charset\n   Some HTTP/1.0 software has interpreted a Content-Type\
    \ header without\n   charset parameter incorrectly to mean \"recipient should\
    \ guess.\"\n   Senders wishing to defeat this behavior MAY include a charset\n\
    \   parameter even when the charset is ISO-8859-1 and SHOULD do so when\n   it\
    \ is known that it will not confuse the recipient.\n   Unfortunately, some older\
    \ HTTP/1.0 clients did not deal properly with\n   an explicit charset parameter.\
    \ HTTP/1.1 recipients MUST respect the\n   charset label provided by the sender;\
    \ and those user agents that have\n   a provision to \"guess\" a charset MUST\
    \ use the charset from the\n   content-type field if they support that charset,\
    \ rather than the\n   recipient's preference, when initially displaying a document.\
    \ See\n   section 3.7.1.\n"
- title: 3.5 Content Codings
  contents:
  - "3.5 Content Codings\n   Content coding values indicate an encoding transformation\
    \ that has\n   been or can be applied to an entity. Content codings are primarily\n\
    \   used to allow a document to be compressed or otherwise usefully\n   transformed\
    \ without losing the identity of its underlying media type\n   and without loss\
    \ of information. Frequently, the entity is stored in\n   coded form, transmitted\
    \ directly, and only decoded by the recipient.\n       content-coding   = token\n\
    \   All content-coding values are case-insensitive. HTTP/1.1 uses\n   content-coding\
    \ values in the Accept-Encoding (section 14.3) and\n   Content-Encoding (section\
    \ 14.11) header fields. Although the value\n   describes the content-coding, what\
    \ is more important is that it\n   indicates what decoding mechanism will be required\
    \ to remove the\n   encoding.\n   The Internet Assigned Numbers Authority (IANA)\
    \ acts as a registry for\n   content-coding value tokens. Initially, the registry\
    \ contains the\n   following tokens:\n   gzip An encoding format produced by the\
    \ file compression program\n        \"gzip\" (GNU zip) as described in RFC 1952\
    \ [25]. This format is a\n        Lempel-Ziv coding (LZ77) with a 32 bit CRC.\n\
    \   compress\n        The encoding format produced by the common UNIX file compression\n\
    \        program \"compress\". This format is an adaptive Lempel-Ziv-Welch\n \
    \       coding (LZW).\n        Use of program names for the identification of\
    \ encoding formats\n        is not desirable and is discouraged for future encodings.\
    \ Their\n        use here is representative of historical practice, not good\n\
    \        design. For compatibility with previous implementations of HTTP,\n  \
    \      applications SHOULD consider \"x-gzip\" and \"x-compress\" to be\n    \
    \    equivalent to \"gzip\" and \"compress\" respectively.\n   deflate\n     \
    \   The \"zlib\" format defined in RFC 1950 [31] in combination with\n       \
    \ the \"deflate\" compression mechanism described in RFC 1951 [29].\n   identity\n\
    \        The default (identity) encoding; the use of no transformation\n     \
    \   whatsoever. This content-coding is used only in the Accept-\n        Encoding\
    \ header, and SHOULD NOT be used in the Content-Encoding\n        header.\n  \
    \ New content-coding value tokens SHOULD be registered; to allow\n   interoperability\
    \ between clients and servers, specifications of the\n   content coding algorithms\
    \ needed to implement a new value SHOULD be\n   publicly available and adequate\
    \ for independent implementation, and\n   conform to the purpose of content coding\
    \ defined in this section.\n"
- title: 3.6 Transfer Codings
  contents:
  - "3.6 Transfer Codings\n   Transfer-coding values are used to indicate an encoding\n\
    \   transformation that has been, can be, or may need to be applied to an\n  \
    \ entity-body in order to ensure \"safe transport\" through the network.\n   This\
    \ differs from a content coding in that the transfer-coding is a\n   property\
    \ of the message, not of the original entity.\n       transfer-coding        \
    \ = \"chunked\" | transfer-extension\n       transfer-extension      = token *(\
    \ \";\" parameter )\n   Parameters are in  the form of attribute/value pairs.\n\
    \       parameter               = attribute \"=\" value\n       attribute    \
    \           = token\n       value                   = token | quoted-string\n\
    \   All transfer-coding values are case-insensitive. HTTP/1.1 uses\n   transfer-coding\
    \ values in the TE header field (section 14.39) and in\n   the Transfer-Encoding\
    \ header field (section 14.41).\n   Whenever a transfer-coding is applied to a\
    \ message-body, the set of\n   transfer-codings MUST include \"chunked\", unless\
    \ the message is\n   terminated by closing the connection. When the \"chunked\"\
    \ transfer-\n   coding is used, it MUST be the last transfer-coding applied to\
    \ the\n   message-body. The \"chunked\" transfer-coding MUST NOT be applied more\n\
    \   than once to a message-body. These rules allow the recipient to\n   determine\
    \ the transfer-length of the message (section 4.4).\n   Transfer-codings are analogous\
    \ to the Content-Transfer-Encoding\n   values of MIME [7], which were designed\
    \ to enable safe transport of\n   binary data over a 7-bit transport service.\
    \ However, safe transport\n   has a different focus for an 8bit-clean transfer\
    \ protocol. In HTTP,\n   the only unsafe characteristic of message-bodies is the\
    \ difficulty in\n   determining the exact body length (section 7.2.2), or the\
    \ desire to\n   encrypt data over a shared transport.\n   The Internet Assigned\
    \ Numbers Authority (IANA) acts as a registry for\n   transfer-coding value tokens.\
    \ Initially, the registry contains the\n   following tokens: \"chunked\" (section\
    \ 3.6.1), \"identity\" (section\n   3.6.2), \"gzip\" (section 3.5), \"compress\"\
    \ (section 3.5), and \"deflate\"\n   (section 3.5).\n   New transfer-coding value\
    \ tokens SHOULD be registered in the same way\n   as new content-coding value\
    \ tokens (section 3.5).\n   A server which receives an entity-body with a transfer-coding\
    \ it does\n   not understand SHOULD return 501 (Unimplemented), and close the\n\
    \   connection. A server MUST NOT send transfer-codings to an HTTP/1.0\n   client.\n"
- title: 3.6.1 Chunked Transfer Coding
  contents:
  - "3.6.1 Chunked Transfer Coding\n   The chunked encoding modifies the body of a\
    \ message in order to\n   transfer it as a series of chunks, each with its own\
    \ size indicator,\n   followed by an OPTIONAL trailer containing entity-header\
    \ fields. This\n   allows dynamically produced content to be transferred along\
    \ with the\n   information necessary for the recipient to verify that it has\n\
    \   received the full message.\n       Chunked-Body   = *chunk\n             \
    \           last-chunk\n                        trailer\n                    \
    \    CRLF\n       chunk          = chunk-size [ chunk-extension ] CRLF\n     \
    \                   chunk-data CRLF\n       chunk-size     = 1*HEX\n       last-chunk\
    \     = 1*(\"0\") [ chunk-extension ] CRLF\n       chunk-extension= *( \";\" chunk-ext-name\
    \ [ \"=\" chunk-ext-val ] )\n       chunk-ext-name = token\n       chunk-ext-val\
    \  = token | quoted-string\n       chunk-data     = chunk-size(OCTET)\n      \
    \ trailer        = *(entity-header CRLF)\n   The chunk-size field is a string\
    \ of hex digits indicating the size of\n   the chunk. The chunked encoding is\
    \ ended by any chunk whose size is\n   zero, followed by the trailer, which is\
    \ terminated by an empty line.\n   The trailer allows the sender to include additional\
    \ HTTP header\n   fields at the end of the message. The Trailer header field can\
    \ be\n   used to indicate which header fields are included in a trailer (see\n\
    \   section 14.40).\n   A server using chunked transfer-coding in a response MUST\
    \ NOT use the\n   trailer for any header fields unless at least one of the following\
    \ is\n   true:\n   a)the request included a TE header field that indicates \"\
    trailers\" is\n     acceptable in the transfer-coding of the  response, as described\
    \ in\n     section 14.39; or,\n   b)the server is the origin server for the response,\
    \ the trailer\n     fields consist entirely of optional metadata, and the recipient\n\
    \     could use the message (in a manner acceptable to the origin server)\n  \
    \   without receiving this metadata.  In other words, the origin server\n    \
    \ is willing to accept the possibility that the trailer fields might\n     be\
    \ silently discarded along the path to the client.\n   This requirement prevents\
    \ an interoperability failure when the\n   message is being received by an HTTP/1.1\
    \ (or later) proxy and\n   forwarded to an HTTP/1.0 recipient. It avoids a situation\
    \ where\n   compliance with the protocol would have necessitated a possibly\n\
    \   infinite buffer on the proxy.\n   An example process for decoding a Chunked-Body\
    \ is presented in\n   appendix 19.4.6.\n   All HTTP/1.1 applications MUST be able\
    \ to receive and decode the\n   \"chunked\" transfer-coding, and MUST ignore chunk-extension\
    \ extensions\n   they do not understand.\n"
- title: 3.7 Media Types
  contents:
  - "3.7 Media Types\n   HTTP uses Internet Media Types [17] in the Content-Type (section\n\
    \   14.17) and Accept (section 14.1) header fields in order to provide\n   open\
    \ and extensible data typing and type negotiation.\n       media-type     = type\
    \ \"/\" subtype *( \";\" parameter )\n       type           = token\n       subtype\
    \        = token\n   Parameters MAY follow the type/subtype in the form of attribute/value\n\
    \   pairs (as defined in section 3.6).\n   The type, subtype, and parameter attribute\
    \ names are case-\n   insensitive. Parameter values might or might not be case-sensitive,\n\
    \   depending on the semantics of the parameter name. Linear white space\n   (LWS)\
    \ MUST NOT be used between the type and subtype, nor between an\n   attribute\
    \ and its value. The presence or absence of a parameter might\n   be significant\
    \ to the processing of a media-type, depending on its\n   definition within the\
    \ media type registry.\n   Note that some older HTTP applications do not recognize\
    \ media type\n   parameters. When sending data to older HTTP applications,\n \
    \  implementations SHOULD only use media type parameters when they are\n   required\
    \ by that type/subtype definition.\n   Media-type values are registered with the\
    \ Internet Assigned Number\n   Authority (IANA [19]). The media type registration\
    \ process is\n   outlined in RFC 1590 [17]. Use of non-registered media types\
    \ is\n   discouraged.\n"
- title: 3.7.1 Canonicalization and Text Defaults
  contents:
  - "3.7.1 Canonicalization and Text Defaults\n   Internet media types are registered\
    \ with a canonical form. An\n   entity-body transferred via HTTP messages MUST\
    \ be represented in the\n   appropriate canonical form prior to its transmission\
    \ except for\n   \"text\" types, as defined in the next paragraph.\n   When in\
    \ canonical form, media subtypes of the \"text\" type use CRLF as\n   the text\
    \ line break. HTTP relaxes this requirement and allows the\n   transport of text\
    \ media with plain CR or LF alone representing a line\n   break when it is done\
    \ consistently for an entire entity-body. HTTP\n   applications MUST accept CRLF,\
    \ bare CR, and bare LF as being\n   representative of a line break in text media\
    \ received via HTTP. In\n   addition, if the text is represented in a character\
    \ set that does not\n   use octets 13 and 10 for CR and LF respectively, as is\
    \ the case for\n   some multi-byte character sets, HTTP allows the use of whatever\
    \ octet\n   sequences are defined by that character set to represent the\n   equivalent\
    \ of CR and LF for line breaks. This flexibility regarding\n   line breaks applies\
    \ only to text media in the entity-body; a bare CR\n   or LF MUST NOT be substituted\
    \ for CRLF within any of the HTTP control\n   structures (such as header fields\
    \ and multipart boundaries).\n   If an entity-body is encoded with a content-coding,\
    \ the underlying\n   data MUST be in a form defined above prior to being encoded.\n\
    \   The \"charset\" parameter is used with some media types to define the\n  \
    \ character set (section 3.4) of the data. When no explicit charset\n   parameter\
    \ is provided by the sender, media subtypes of the \"text\"\n   type are defined\
    \ to have a default charset value of \"ISO-8859-1\" when\n   received via HTTP.\
    \ Data in character sets other than \"ISO-8859-1\" or\n   its subsets MUST be\
    \ labeled with an appropriate charset value. See\n   section 3.4.1 for compatibility\
    \ problems.\n"
- title: 3.7.2 Multipart Types
  contents:
  - "3.7.2 Multipart Types\n   MIME provides for a number of \"multipart\" types --\
    \ encapsulations of\n   one or more entities within a single message-body. All\
    \ multipart\n   types share a common syntax, as defined in section 5.1.1 of RFC\
    \ 2046\n   [40], and MUST include a boundary parameter as part of the media type\n\
    \   value. The message body is itself a protocol element and MUST\n   therefore\
    \ use only CRLF to represent line breaks between body-parts.\n   Unlike in RFC\
    \ 2046, the epilogue of any multipart message MUST be\n   empty; HTTP applications\
    \ MUST NOT transmit the epilogue (even if the\n   original multipart contains\
    \ an epilogue). These restrictions exist in\n   order to preserve the self-delimiting\
    \ nature of a multipart message-\n   body, wherein the \"end\" of the message-body\
    \ is indicated by the\n   ending multipart boundary.\n   In general, HTTP treats\
    \ a multipart message-body no differently than\n   any other media type: strictly\
    \ as payload. The one exception is the\n   \"multipart/byteranges\" type (appendix\
    \ 19.2) when it appears in a 206\n   (Partial Content) response, which will be\
    \ interpreted by some HTTP\n   caching mechanisms as described in sections 13.5.4\
    \ and 14.16. In all\n   other cases, an HTTP user agent SHOULD follow the same\
    \ or similar\n   behavior as a MIME user agent would upon receipt of a multipart\
    \ type.\n   The MIME header fields within each body-part of a multipart message-\n\
    \   body do not have any significance to HTTP beyond that defined by\n   their\
    \ MIME semantics.\n   In general, an HTTP user agent SHOULD follow the same or\
    \ similar\n   behavior as a MIME user agent would upon receipt of a multipart\
    \ type.\n   If an application receives an unrecognized multipart subtype, the\n\
    \   application MUST treat it as being equivalent to \"multipart/mixed\".\n  \
    \    Note: The \"multipart/form-data\" type has been specifically defined\n  \
    \    for carrying form data suitable for processing via the POST\n      request\
    \ method, as described in RFC 1867 [15].\n"
- title: 3.8 Product Tokens
  contents:
  - "3.8 Product Tokens\n   Product tokens are used to allow communicating applications\
    \ to\n   identify themselves by software name and version. Most fields using\n\
    \   product tokens also allow sub-products which form a significant part\n   of\
    \ the application to be listed, separated by white space. By\n   convention, the\
    \ products are listed in order of their significance\n   for identifying the application.\n\
    \       product         = token [\"/\" product-version]\n       product-version\
    \ = token\n   Examples:\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n\
    \       Server: Apache/0.8.4\n   Product tokens SHOULD be short and to the point.\
    \ They MUST NOT be\n   used for advertising or other non-essential information.\
    \ Although any\n   token character MAY appear in a product-version, this token\
    \ SHOULD\n   only be used for a version identifier (i.e., successive versions\
    \ of\n   the same product SHOULD only differ in the product-version portion of\n\
    \   the product value).\n"
- title: 3.9 Quality Values
  contents:
  - "3.9 Quality Values\n   HTTP content negotiation (section 12) uses short \"floating\
    \ point\"\n   numbers to indicate the relative importance (\"weight\") of various\n\
    \   negotiable parameters.  A weight is normalized to a real number in\n   the\
    \ range 0 through 1, where 0 is the minimum and 1 the maximum\n   value. If a\
    \ parameter has a quality value of 0, then content with\n   this parameter is\
    \ `not acceptable' for the client. HTTP/1.1\n   applications MUST NOT generate\
    \ more than three digits after the\n   decimal point. User configuration of these\
    \ values SHOULD also be\n   limited in this fashion.\n       qvalue         =\
    \ ( \"0\" [ \".\" 0*3DIGIT ] )\n                      | ( \"1\" [ \".\" 0*3(\"\
    0\") ] )\n   \"Quality values\" is a misnomer, since these values merely represent\n\
    \   relative degradation in desired quality.\n"
- title: 3.10 Language Tags
  contents:
  - "3.10 Language Tags\n   A language tag identifies a natural language spoken, written,\
    \ or\n   otherwise conveyed by human beings for communication of information\n\
    \   to other human beings. Computer languages are explicitly excluded.\n   HTTP\
    \ uses language tags within the Accept-Language and Content-\n   Language fields.\n\
    \   The syntax and registry of HTTP language tags is the same as that\n   defined\
    \ by RFC 1766 [1]. In summary, a language tag is composed of 1\n   or more parts:\
    \ A primary language tag and a possibly empty series of\n   subtags:\n       \
    \ language-tag  = primary-tag *( \"-\" subtag )\n        primary-tag   = 1*8ALPHA\n\
    \        subtag        = 1*8ALPHA\n   White space is not allowed within the tag\
    \ and all tags are case-\n   insensitive. The name space of language tags is administered\
    \ by the\n   IANA. Example tags include:\n       en, en-US, en-cockney, i-cherokee,\
    \ x-pig-latin\n   where any two-letter primary-tag is an ISO-639 language abbreviation\n\
    \   and any two-letter initial subtag is an ISO-3166 country code. (The\n   last\
    \ three tags above are not registered tags; all but the last are\n   examples\
    \ of tags which could be registered in future.)\n"
- title: 3.11 Entity Tags
  contents:
  - "3.11 Entity Tags\n   Entity tags are used for comparing two or more entities\
    \ from the same\n   requested resource. HTTP/1.1 uses entity tags in the ETag\
    \ (section\n   14.19), If-Match (section 14.24), If-None-Match (section 14.26),\
    \ and\n   If-Range (section 14.27) header fields. The definition of how they\n\
    \   are used and compared as cache validators is in section 13.3.3. An\n   entity\
    \ tag consists of an opaque quoted string, possibly prefixed by\n   a weakness\
    \ indicator.\n      entity-tag = [ weak ] opaque-tag\n      weak       = \"W/\"\
    \n      opaque-tag = quoted-string\n   A \"strong entity tag\" MAY be shared by\
    \ two entities of a resource\n   only if they are equivalent by octet equality.\n\
    \   A \"weak entity tag,\" indicated by the \"W/\" prefix, MAY be shared by\n\
    \   two entities of a resource only if the entities are equivalent and\n   could\
    \ be substituted for each other with no significant change in\n   semantics. A\
    \ weak entity tag can only be used for weak comparison.\n   An entity tag MUST\
    \ be unique across all versions of all entities\n   associated with a particular\
    \ resource. A given entity tag value MAY\n   be used for entities obtained by\
    \ requests on different URIs. The use\n   of the same entity tag value in conjunction\
    \ with entities obtained by\n   requests on different URIs does not imply the\
    \ equivalence of those\n   entities.\n"
- title: 3.12 Range Units
  contents:
  - "3.12 Range Units\n   HTTP/1.1 allows a client to request that only part (a range\
    \ of) the\n   response entity be included within the response. HTTP/1.1 uses range\n\
    \   units in the Range (section 14.35) and Content-Range (section 14.16)\n   header\
    \ fields. An entity can be broken down into subranges according\n   to various\
    \ structural units.\n      range-unit       = bytes-unit | other-range-unit\n\
    \      bytes-unit       = \"bytes\"\n      other-range-unit = token\n   The only\
    \ range unit defined by HTTP/1.1 is \"bytes\". HTTP/1.1\n   implementations MAY\
    \ ignore ranges specified using other units.\n   HTTP/1.1 has been designed to\
    \ allow implementations of applications\n   that do not depend on knowledge of\
    \ ranges.\n"
- title: 4 HTTP Message
  contents:
  - '4 HTTP Message

    '
- title: 4.1 Message Types
  contents:
  - "4.1 Message Types\n   HTTP messages consist of requests from client to server\
    \ and responses\n   from server to client.\n       HTTP-message   = Request |\
    \ Response     ; HTTP/1.1 messages\n   Request (section 5) and Response (section\
    \ 6) messages use the generic\n   message format of RFC 822 [9] for transferring\
    \ entities (the payload\n   of the message). Both types of message consist of\
    \ a start-line, zero\n   or more header fields (also known as \"headers\"), an\
    \ empty line (i.e.,\n   a line with nothing preceding the CRLF) indicating the\
    \ end of the\n   header fields, and possibly a message-body.\n        generic-message\
    \ = start-line\n                          *(message-header CRLF)\n           \
    \               CRLF\n                          [ message-body ]\n        start-line\
    \      = Request-Line | Status-Line\n   In the interest of robustness, servers\
    \ SHOULD ignore any empty\n   line(s) received where a Request-Line is expected.\
    \ In other words, if\n   the server is reading the protocol stream at the beginning\
    \ of a\n   message and receives a CRLF first, it should ignore the CRLF.\n   Certain\
    \ buggy HTTP/1.0 client implementations generate extra CRLF's\n   after a POST\
    \ request. To restate what is explicitly forbidden by the\n   BNF, an HTTP/1.1\
    \ client MUST NOT preface or follow a request with an\n   extra CRLF.\n"
- title: 4.2 Message Headers
  contents:
  - "4.2 Message Headers\n   HTTP header fields, which include general-header (section\
    \ 4.5),\n   request-header (section 5.3), response-header (section 6.2), and\n\
    \   entity-header (section 7.1) fields, follow the same generic format as\n  \
    \ that given in Section 3.1 of RFC 822 [9]. Each header field consists\n   of\
    \ a name followed by a colon (\":\") and the field value. Field names\n   are\
    \ case-insensitive. The field value MAY be preceded by any amount\n   of LWS,\
    \ though a single SP is preferred. Header fields can be\n   extended over multiple\
    \ lines by preceding each extra line with at\n   least one SP or HT. Applications\
    \ ought to follow \"common form\", where\n   one is known or indicated, when generating\
    \ HTTP constructs, since\n   there might exist some implementations that fail\
    \ to accept anything\n   beyond the common forms.\n       message-header = field-name\
    \ \":\" [ field-value ]\n       field-name     = token\n       field-value   \
    \ = *( field-content | LWS )\n       field-content  = <the OCTETs making up the\
    \ field-value\n                        and consisting of either *TEXT or combinations\n\
    \                        of token, separators, and quoted-string>\n   The field-content\
    \ does not include any leading or trailing LWS:\n   linear white space occurring\
    \ before the first non-whitespace\n   character of the field-value or after the\
    \ last non-whitespace\n   character of the field-value. Such leading or trailing\
    \ LWS MAY be\n   removed without changing the semantics of the field value. Any\
    \ LWS\n   that occurs between field-content MAY be replaced with a single SP\n\
    \   before interpreting the field value or forwarding the message\n   downstream.\n\
    \   The order in which header fields with differing field names are\n   received\
    \ is not significant. However, it is \"good practice\" to send\n   general-header\
    \ fields first, followed by request-header or response-\n   header fields, and\
    \ ending with the entity-header fields.\n   Multiple message-header fields with\
    \ the same field-name MAY be\n   present in a message if and only if the entire\
    \ field-value for that\n   header field is defined as a comma-separated list [i.e.,\
    \ #(values)].\n   It MUST be possible to combine the multiple header fields into\
    \ one\n   \"field-name: field-value\" pair, without changing the semantics of\
    \ the\n   message, by appending each subsequent field-value to the first, each\n\
    \   separated by a comma. The order in which header fields with the same\n   field-name\
    \ are received is therefore significant to the\n   interpretation of the combined\
    \ field value, and thus a proxy MUST NOT\n   change the order of these field values\
    \ when a message is forwarded.\n"
- title: 4.3 Message Body
  contents:
  - "4.3 Message Body\n   The message-body (if any) of an HTTP message is used to\
    \ carry the\n   entity-body associated with the request or response. The message-body\n\
    \   differs from the entity-body only when a transfer-coding has been\n   applied,\
    \ as indicated by the Transfer-Encoding header field (section\n   14.41).\n  \
    \     message-body = entity-body\n                    | <entity-body encoded as\
    \ per Transfer-Encoding>\n   Transfer-Encoding MUST be used to indicate any transfer-codings\n\
    \   applied by an application to ensure safe and proper transfer of the\n   message.\
    \ Transfer-Encoding is a property of the message, not of the\n   entity, and thus\
    \ MAY be added or removed by any application along the\n   request/response chain.\
    \ (However, section 3.6 places restrictions on\n   when certain transfer-codings\
    \ may be used.)\n   The rules for when a message-body is allowed in a message\
    \ differ for\n   requests and responses.\n   The presence of a message-body in\
    \ a request is signaled by the\n   inclusion of a Content-Length or Transfer-Encoding\
    \ header field in\n   the request's message-headers. A message-body MUST NOT be\
    \ included in\n   a request if the specification of the request method (section\
    \ 5.1.1)\n   does not allow sending an entity-body in requests. A server SHOULD\n\
    \   read and forward a message-body on any request; if the request method\n  \
    \ does not include defined semantics for an entity-body, then the\n   message-body\
    \ SHOULD be ignored when handling the request.\n   For response messages, whether\
    \ or not a message-body is included with\n   a message is dependent on both the\
    \ request method and the response\n   status code (section 6.1.1). All responses\
    \ to the HEAD request method\n   MUST NOT include a message-body, even though\
    \ the presence of entity-\n   header fields might lead one to believe they do.\
    \ All 1xx\n   (informational), 204 (no content), and 304 (not modified) responses\n\
    \   MUST NOT include a message-body. All other responses do include a\n   message-body,\
    \ although it MAY be of zero length.\n"
- title: 4.4 Message Length
  contents:
  - "4.4 Message Length\n   The transfer-length of a message is the length of the\
    \ message-body as\n   it appears in the message; that is, after any transfer-codings\
    \ have\n   been applied. When a message-body is included with a message, the\n\
    \   transfer-length of that body is determined by one of the following\n   (in\
    \ order of precedence):\n   1.Any response message which \"MUST NOT\" include\
    \ a message-body (such\n     as the 1xx, 204, and 304 responses and any response\
    \ to a HEAD\n     request) is always terminated by the first empty line after\
    \ the\n     header fields, regardless of the entity-header fields present in\n\
    \     the message.\n   2.If a Transfer-Encoding header field (section 14.41) is\
    \ present and\n     has any value other than \"identity\", then the transfer-length\
    \ is\n     defined by use of the \"chunked\" transfer-coding (section 3.6),\n\
    \     unless the message is terminated by closing the connection.\n   3.If a Content-Length\
    \ header field (section 14.13) is present, its\n     decimal value in OCTETs represents\
    \ both the entity-length and the\n     transfer-length. The Content-Length header\
    \ field MUST NOT be sent\n     if these two lengths are different (i.e., if a\
    \ Transfer-Encoding\n     header field is present). If a message is received with\
    \ both a\n     Transfer-Encoding header field and a Content-Length header field,\n\
    \     the latter MUST be ignored.\n   4.If the message uses the media type \"\
    multipart/byteranges\", and the\n     ransfer-length is not otherwise specified,\
    \ then this self-\n     elimiting media type defines the transfer-length. This\
    \ media type\n     UST NOT be used unless the sender knows that the recipient\
    \ can arse\n     it; the presence in a request of a Range header with ultiple\
    \ byte-\n     range specifiers from a 1.1 client implies that the lient can parse\n\
    \     multipart/byteranges responses.\n       A range header might be forwarded\
    \ by a 1.0 proxy that does not\n       understand multipart/byteranges; in this\
    \ case the server MUST\n       delimit the message using methods defined in items\
    \ 1,3 or 5 of\n       this section.\n   5.By the server closing the connection.\
    \ (Closing the connection\n     cannot be used to indicate the end of a request\
    \ body, since that\n     would leave no possibility for the server to send back\
    \ a response.)\n   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests\n\
    \   containing a message-body MUST include a valid Content-Length header\n   field\
    \ unless the server is known to be HTTP/1.1 compliant. If a\n   request contains\
    \ a message-body and a Content-Length is not given,\n   the server SHOULD respond\
    \ with 400 (bad request) if it cannot\n   determine the length of the message,\
    \ or with 411 (length required) if\n   it wishes to insist on receiving a valid\
    \ Content-Length.\n   All HTTP/1.1 applications that receive entities MUST accept\
    \ the\n   \"chunked\" transfer-coding (section 3.6), thus allowing this mechanism\n\
    \   to be used for messages when the message length cannot be determined\n   in\
    \ advance.\n   Messages MUST NOT include both a Content-Length header field and\
    \ a\n   non-identity transfer-coding. If the message does include a non-\n   identity\
    \ transfer-coding, the Content-Length MUST be ignored.\n   When a Content-Length\
    \ is given in a message where a message-body is\n   allowed, its field value MUST\
    \ exactly match the number of OCTETs in\n   the message-body. HTTP/1.1 user agents\
    \ MUST notify the user when an\n   invalid length is received and detected.\n"
- title: 4.5 General Header Fields
  contents:
  - "4.5 General Header Fields\n   There are a few header fields which have general\
    \ applicability for\n   both request and response messages, but which do not apply\
    \ to the\n   entity being transferred. These header fields apply only to the\n\
    \   message being transmitted.\n       general-header = Cache-Control        \
    \    ; Section 14.9\n                      | Connection               ; Section\
    \ 14.10\n                      | Date                     ; Section 14.18\n  \
    \                    | Pragma                   ; Section 14.32\n            \
    \          | Trailer                  ; Section 14.40\n                      |\
    \ Transfer-Encoding        ; Section 14.41\n                      | Upgrade  \
    \                ; Section 14.42\n                      | Via                \
    \      ; Section 14.45\n                      | Warning                  ; Section\
    \ 14.46\n   General-header field names can be extended reliably only in\n   combination\
    \ with a change in the protocol version. However, new or\n   experimental header\
    \ fields may be given the semantics of general\n   header fields if all parties\
    \ in the communication recognize them to\n   be general-header fields. Unrecognized\
    \ header fields are treated as\n   entity-header fields.\n"
- title: 5 Request
  contents:
  - "5 Request\n   A request message from a client to a server includes, within the\n\
    \   first line of that message, the method to be applied to the resource,\n  \
    \ the identifier of the resource, and the protocol version in use.\n        Request\
    \       = Request-Line              ; Section 5.1\n                        *((\
    \ general-header        ; Section 4.5\n                         | request-header\
    \         ; Section 5.3\n                         | entity-header ) CRLF)  ; Section\
    \ 7.1\n                        CRLF\n                        [ message-body ]\
    \          ; Section 4.3\n"
- title: 5.1 Request-Line
  contents:
  - "5.1 Request-Line\n   The Request-Line begins with a method token, followed by\
    \ the\n   Request-URI and the protocol version, and ending with CRLF. The\n  \
    \ elements are separated by SP characters. No CR or LF is allowed\n   except in\
    \ the final CRLF sequence.\n        Request-Line   = Method SP Request-URI SP\
    \ HTTP-Version CRLF\n"
- title: 5.1.1 Method
  contents:
  - "5.1.1 Method\n   The Method  token indicates the method to be performed on the\n\
    \   resource identified by the Request-URI. The method is case-sensitive.\n  \
    \     Method         = \"OPTIONS\"                ; Section 9.2\n            \
    \          | \"GET\"                    ; Section 9.3\n                      |\
    \ \"HEAD\"                   ; Section 9.4\n                      | \"POST\" \
    \                  ; Section 9.5\n                      | \"PUT\"            \
    \        ; Section 9.6\n                      | \"DELETE\"                 ; Section\
    \ 9.7\n                      | \"TRACE\"                  ; Section 9.8\n    \
    \                  | \"CONNECT\"                ; Section 9.9\n              \
    \        | extension-method\n       extension-method = token\n   The list of methods\
    \ allowed by a resource can be specified in an\n   Allow header field (section\
    \ 14.7). The return code of the response\n   always notifies the client whether\
    \ a method is currently allowed on a\n   resource, since the set of allowed methods\
    \ can change dynamically. An\n   origin server SHOULD return the status code 405\
    \ (Method Not Allowed)\n   if the method is known by the origin server but not\
    \ allowed for the\n   requested resource, and 501 (Not Implemented) if the method\
    \ is\n   unrecognized or not implemented by the origin server. The methods GET\n\
    \   and HEAD MUST be supported by all general-purpose servers. All other\n   methods\
    \ are OPTIONAL; however, if the above methods are implemented,\n   they MUST be\
    \ implemented with the same semantics as those specified\n   in section 9.\n"
- title: 5.1.2 Request-URI
  contents:
  - "5.1.2 Request-URI\n   The Request-URI is a Uniform Resource Identifier (section\
    \ 3.2) and\n   identifies the resource upon which to apply the request.\n    \
    \   Request-URI    = \"*\" | absoluteURI | abs_path | authority\n   The four options\
    \ for Request-URI are dependent on the nature of the\n   request. The asterisk\
    \ \"*\" means that the request does not apply to a\n   particular resource, but\
    \ to the server itself, and is only allowed\n   when the method used does not\
    \ necessarily apply to a resource. One\n   example would be\n       OPTIONS *\
    \ HTTP/1.1\n   The absoluteURI form is REQUIRED when the request is being made\
    \ to a\n   proxy. The proxy is requested to forward the request or service it\n\
    \   from a valid cache, and return the response. Note that the proxy MAY\n   forward\
    \ the request on to another proxy or directly to the server\n   specified by the\
    \ absoluteURI. In order to avoid request loops, a\n   proxy MUST be able to recognize\
    \ all of its server names, including\n   any aliases, local variations, and the\
    \ numeric IP address. An example\n   Request-Line would be:\n       GET http://www.w3.org/pub/WWW/TheProject.html\
    \ HTTP/1.1\n   To allow for transition to absoluteURIs in all requests in future\n\
    \   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI\n   form\
    \ in requests, even though HTTP/1.1 clients will only generate\n   them in requests\
    \ to proxies.\n   The authority form is only used by the CONNECT method (section\
    \ 9.9).\n   The most common form of Request-URI is that used to identify a\n \
    \  resource on an origin server or gateway. In this case the absolute\n   path\
    \ of the URI MUST be transmitted (see section 3.2.1, abs_path) as\n   the Request-URI,\
    \ and the network location of the URI (authority) MUST\n   be transmitted in a\
    \ Host header field. For example, a client wishing\n   to retrieve the resource\
    \ above directly from the origin server would\n   create a TCP connection to port\
    \ 80 of the host \"www.w3.org\" and send\n   the lines:\n       GET /pub/WWW/TheProject.html\
    \ HTTP/1.1\n       Host: www.w3.org\n   followed by the remainder of the Request.\
    \ Note that the absolute path\n   cannot be empty; if none is present in the original\
    \ URI, it MUST be\n   given as \"/\" (the server root).\n   The Request-URI is\
    \ transmitted in the format specified in section\n   3.2.1. If the Request-URI\
    \ is encoded using the \"% HEX HEX\" encoding\n   [42], the origin server MUST\
    \ decode the Request-URI in order to\n   properly interpret the request. Servers\
    \ SHOULD respond to invalid\n   Request-URIs with an appropriate status code.\n\
    \   A transparent proxy MUST NOT rewrite the \"abs_path\" part of the\n   received\
    \ Request-URI when forwarding it to the next inbound server,\n   except as noted\
    \ above to replace a null abs_path with \"/\".\n      Note: The \"no rewrite\"\
    \ rule prevents the proxy from changing the\n      meaning of the request when\
    \ the origin server is improperly using\n      a non-reserved URI character for\
    \ a reserved purpose.  Implementors\n      should be aware that some pre-HTTP/1.1\
    \ proxies have been known to\n      rewrite the Request-URI.\n"
- title: 5.2 The Resource Identified by a Request
  contents:
  - "5.2 The Resource Identified by a Request\n   The exact resource identified by\
    \ an Internet request is determined by\n   examining both the Request-URI and\
    \ the Host header field.\n   An origin server that does not allow resources to\
    \ differ by the\n   requested host MAY ignore the Host header field value when\n\
    \   determining the resource identified by an HTTP/1.1 request. (But see\n   section\
    \ 19.6.1.1 for other requirements on Host support in HTTP/1.1.)\n   An origin\
    \ server that does differentiate resources based on the host\n   requested (sometimes\
    \ referred to as virtual hosts or vanity host\n   names) MUST use the following\
    \ rules for determining the requested\n   resource on an HTTP/1.1 request:\n \
    \  1. If Request-URI is an absoluteURI, the host is part of the\n     Request-URI.\
    \ Any Host header field value in the request MUST be\n     ignored.\n   2. If\
    \ the Request-URI is not an absoluteURI, and the request includes\n     a Host\
    \ header field, the host is determined by the Host header\n     field value.\n\
    \   3. If the host as determined by rule 1 or 2 is not a valid host on\n     the\
    \ server, the response MUST be a 400 (Bad Request) error message.\n   Recipients\
    \ of an HTTP/1.0 request that lacks a Host header field MAY\n   attempt to use\
    \ heuristics (e.g., examination of the URI path for\n   something unique to a\
    \ particular host) in order to determine what\n   exact resource is being requested.\n"
- title: 5.3 Request Header Fields
  contents:
  - "5.3 Request Header Fields\n   The request-header fields allow the client to pass\
    \ additional\n   information about the request, and about the client itself, to\
    \ the\n   server. These fields act as request modifiers, with semantics\n   equivalent\
    \ to the parameters on a programming language method\n   invocation.\n       request-header\
    \ = Accept                   ; Section 14.1\n                      | Accept-Charset\
    \           ; Section 14.2\n                      | Accept-Encoding          ;\
    \ Section 14.3\n                      | Accept-Language          ; Section 14.4\n\
    \                      | Authorization            ; Section 14.8\n           \
    \           | Expect                   ; Section 14.20\n                     \
    \ | From                     ; Section 14.22\n                      | Host   \
    \                  ; Section 14.23\n                      | If-Match         \
    \        ; Section 14.24\n                      | If-Modified-Since        ; Section\
    \ 14.25\n                      | If-None-Match            ; Section 14.26\n  \
    \                    | If-Range                 ; Section 14.27\n            \
    \          | If-Unmodified-Since      ; Section 14.28\n                      |\
    \ Max-Forwards             ; Section 14.31\n                      | Proxy-Authorization\
    \      ; Section 14.34\n                      | Range                    ; Section\
    \ 14.35\n                      | Referer                  ; Section 14.36\n  \
    \                    | TE                       ; Section 14.39\n            \
    \          | User-Agent               ; Section 14.43\n   Request-header field\
    \ names can be extended reliably only in\n   combination with a change in the\
    \ protocol version. However, new or\n   experimental header fields MAY be given\
    \ the semantics of request-\n   header fields if all parties in the communication\
    \ recognize them to\n   be request-header fields. Unrecognized header fields are\
    \ treated as\n   entity-header fields.\n"
- title: 6 Response
  contents:
  - "6 Response\n   After receiving and interpreting a request message, a server responds\n\
    \   with an HTTP response message.\n       Response      = Status-Line       \
    \        ; Section 6.1\n                       *(( general-header        ; Section\
    \ 4.5\n                        | response-header        ; Section 6.2\n      \
    \                  | entity-header ) CRLF)  ; Section 7.1\n                  \
    \     CRLF\n                       [ message-body ]          ; Section 7.2\n"
- title: 6.1 Status-Line
  contents:
  - "6.1 Status-Line\n   The first line of a Response message is the Status-Line,\
    \ consisting\n   of the protocol version followed by a numeric status code and\
    \ its\n   associated textual phrase, with each element separated by SP\n   characters.\
    \ No CR or LF is allowed except in the final CRLF sequence.\n       Status-Line\
    \ = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n"
- title: 6.1.1 Status Code and Reason Phrase
  contents:
  - "6.1.1 Status Code and Reason Phrase\n   The Status-Code element is a 3-digit\
    \ integer result code of the\n   attempt to understand and satisfy the request.\
    \ These codes are fully\n   defined in section 10. The Reason-Phrase is intended\
    \ to give a short\n   textual description of the Status-Code. The Status-Code\
    \ is intended\n   for use by automata and the Reason-Phrase is intended for the\
    \ human\n   user. The client is not required to examine or display the Reason-\n\
    \   Phrase.\n   The first digit of the Status-Code defines the class of response.\
    \ The\n   last two digits do not have any categorization role. There are 5\n \
    \  values for the first digit:\n      - 1xx: Informational - Request received,\
    \ continuing process\n      - 2xx: Success - The action was successfully received,\n\
    \        understood, and accepted\n      - 3xx: Redirection - Further action must\
    \ be taken in order to\n        complete the request\n      - 4xx: Client Error\
    \ - The request contains bad syntax or cannot\n        be fulfilled\n      - 5xx:\
    \ Server Error - The server failed to fulfill an apparently\n        valid request\n\
    \   The individual values of the numeric status codes defined for\n   HTTP/1.1,\
    \ and an example set of corresponding Reason-Phrase's, are\n   presented below.\
    \ The reason phrases listed here are only\n   recommendations -- they MAY be replaced\
    \ by local equivalents without\n   affecting the protocol.\n      Status-Code\
    \    =\n            \"100\"  ; Section 10.1.1: Continue\n          | \"101\" \
    \ ; Section 10.1.2: Switching Protocols\n          | \"200\"  ; Section 10.2.1:\
    \ OK\n          | \"201\"  ; Section 10.2.2: Created\n          | \"202\"  ; Section\
    \ 10.2.3: Accepted\n          | \"203\"  ; Section 10.2.4: Non-Authoritative Information\n\
    \          | \"204\"  ; Section 10.2.5: No Content\n          | \"205\"  ; Section\
    \ 10.2.6: Reset Content\n          | \"206\"  ; Section 10.2.7: Partial Content\n\
    \          | \"300\"  ; Section 10.3.1: Multiple Choices\n          | \"301\"\
    \  ; Section 10.3.2: Moved Permanently\n          | \"302\"  ; Section 10.3.3:\
    \ Found\n          | \"303\"  ; Section 10.3.4: See Other\n          | \"304\"\
    \  ; Section 10.3.5: Not Modified\n          | \"305\"  ; Section 10.3.6: Use\
    \ Proxy\n          | \"307\"  ; Section 10.3.8: Temporary Redirect\n         \
    \ | \"400\"  ; Section 10.4.1: Bad Request\n          | \"401\"  ; Section 10.4.2:\
    \ Unauthorized\n          | \"402\"  ; Section 10.4.3: Payment Required\n    \
    \      | \"403\"  ; Section 10.4.4: Forbidden\n          | \"404\"  ; Section\
    \ 10.4.5: Not Found\n          | \"405\"  ; Section 10.4.6: Method Not Allowed\n\
    \          | \"406\"  ; Section 10.4.7: Not Acceptable\n          | \"407\"  ;\
    \ Section 10.4.8: Proxy Authentication Required\n          | \"408\"  ; Section\
    \ 10.4.9: Request Time-out\n          | \"409\"  ; Section 10.4.10: Conflict\n\
    \          | \"410\"  ; Section 10.4.11: Gone\n          | \"411\"  ; Section\
    \ 10.4.12: Length Required\n          | \"412\"  ; Section 10.4.13: Precondition\
    \ Failed\n          | \"413\"  ; Section 10.4.14: Request Entity Too Large\n \
    \         | \"414\"  ; Section 10.4.15: Request-URI Too Large\n          | \"\
    415\"  ; Section 10.4.16: Unsupported Media Type\n          | \"416\"  ; Section\
    \ 10.4.17: Requested range not satisfiable\n          | \"417\"  ; Section 10.4.18:\
    \ Expectation Failed\n          | \"500\"  ; Section 10.5.1: Internal Server Error\n\
    \          | \"501\"  ; Section 10.5.2: Not Implemented\n          | \"502\" \
    \ ; Section 10.5.3: Bad Gateway\n          | \"503\"  ; Section 10.5.4: Service\
    \ Unavailable\n          | \"504\"  ; Section 10.5.5: Gateway Time-out\n     \
    \     | \"505\"  ; Section 10.5.6: HTTP Version not supported\n          | extension-code\n\
    \      extension-code = 3DIGIT\n      Reason-Phrase  = *<TEXT, excluding CR, LF>\n\
    \   HTTP status codes are extensible. HTTP applications are not required\n   to\
    \ understand the meaning of all registered status codes, though such\n   understanding\
    \ is obviously desirable. However, applications MUST\n   understand the class\
    \ of any status code, as indicated by the first\n   digit, and treat any unrecognized\
    \ response as being equivalent to the\n   x00 status code of that class, with\
    \ the exception that an\n   unrecognized response MUST NOT be cached. For example,\
    \ if an\n   unrecognized status code of 431 is received by the client, it can\n\
    \   safely assume that there was something wrong with its request and\n   treat\
    \ the response as if it had received a 400 status code. In such\n   cases, user\
    \ agents SHOULD present to the user the entity returned\n   with the response,\
    \ since that entity is likely to include human-\n   readable information which\
    \ will explain the unusual status.\n"
- title: 6.2 Response Header Fields
  contents:
  - "6.2 Response Header Fields\n   The response-header fields allow the server to\
    \ pass additional\n   information about the response which cannot be placed in\
    \ the Status-\n   Line. These header fields give information about the server\
    \ and about\n   further access to the resource identified by the Request-URI.\n\
    \       response-header = Accept-Ranges           ; Section 14.5\n           \
    \            | Age                     ; Section 14.6\n                      \
    \ | ETag                    ; Section 14.19\n                       | Location\
    \                ; Section 14.30\n                       | Proxy-Authenticate\
    \      ; Section 14.33\n                       | Retry-After             ; Section\
    \ 14.37\n                       | Server                  ; Section 14.38\n  \
    \                     | Vary                    ; Section 14.44\n            \
    \           | WWW-Authenticate        ; Section 14.47\n   Response-header field\
    \ names can be extended reliably only in\n   combination with a change in the\
    \ protocol version. However, new or\n   experimental header fields MAY be given\
    \ the semantics of response-\n   header fields if all parties in the communication\
    \ recognize them to\n   be response-header fields. Unrecognized header fields\
    \ are treated as\n   entity-header fields.\n"
- title: 7 Entity
  contents:
  - "7 Entity\n   Request and Response messages MAY transfer an entity if not otherwise\n\
    \   restricted by the request method or response status code. An entity\n   consists\
    \ of entity-header fields and an entity-body, although some\n   responses will\
    \ only include the entity-headers.\n   In this section, both sender and recipient\
    \ refer to either the client\n   or the server, depending on who sends and who\
    \ receives the entity.\n"
- title: 7.1 Entity Header Fields
  contents:
  - "7.1 Entity Header Fields\n   Entity-header fields define metainformation about\
    \ the entity-body or,\n   if no body is present, about the resource identified\
    \ by the request.\n   Some of this metainformation is OPTIONAL; some might be\
    \ REQUIRED by\n   portions of this specification.\n       entity-header  = Allow\
    \                    ; Section 14.7\n                      | Content-Encoding\
    \         ; Section 14.11\n                      | Content-Language         ;\
    \ Section 14.12\n                      | Content-Length           ; Section 14.13\n\
    \                      | Content-Location         ; Section 14.14\n          \
    \            | Content-MD5              ; Section 14.15\n                    \
    \  | Content-Range            ; Section 14.16\n                      | Content-Type\
    \             ; Section 14.17\n                      | Expires               \
    \   ; Section 14.21\n                      | Last-Modified            ; Section\
    \ 14.29\n                      | extension-header\n       extension-header = message-header\n\
    \   The extension-header mechanism allows additional entity-header fields\n  \
    \ to be defined without changing the protocol, but these fields cannot\n   be\
    \ assumed to be recognizable by the recipient. Unrecognized header\n   fields\
    \ SHOULD be ignored by the recipient and MUST be forwarded by\n   transparent\
    \ proxies.\n"
- title: 7.2 Entity Body
  contents:
  - "7.2 Entity Body\n   The entity-body (if any) sent with an HTTP request or response\
    \ is in\n   a format and encoding defined by the entity-header fields.\n     \
    \  entity-body    = *OCTET\n   An entity-body is only present in a message when\
    \ a message-body is\n   present, as described in section 4.3. The entity-body\
    \ is obtained\n   from the message-body by decoding any Transfer-Encoding that\
    \ might\n   have been applied to ensure safe and proper transfer of the message.\n"
- title: 7.2.1 Type
  contents:
  - "7.2.1 Type\n   When an entity-body is included with a message, the data type\
    \ of that\n   body is determined via the header fields Content-Type and Content-\n\
    \   Encoding. These define a two-layer, ordered encoding model:\n       entity-body\
    \ := Content-Encoding( Content-Type( data ) )\n   Content-Type specifies the media\
    \ type of the underlying data.\n   Content-Encoding may be used to indicate any\
    \ additional content\n   codings applied to the data, usually for the purpose\
    \ of data\n   compression, that are a property of the requested resource. There\
    \ is\n   no default encoding.\n   Any HTTP/1.1 message containing an entity-body\
    \ SHOULD include a\n   Content-Type header field defining the media type of that\
    \ body. If\n   and only if the media type is not given by a Content-Type field,\
    \ the\n   recipient MAY attempt to guess the media type via inspection of its\n\
    \   content and/or the name extension(s) of the URI used to identify the\n   resource.\
    \ If the media type remains unknown, the recipient SHOULD\n   treat it as type\
    \ \"application/octet-stream\".\n"
- title: 7.2.2 Entity Length
  contents:
  - "7.2.2 Entity Length\n   The entity-length of a message is the length of the message-body\n\
    \   before any transfer-codings have been applied. Section 4.4 defines\n   how\
    \ the transfer-length of a message-body is determined.\n"
- title: 8 Connections
  contents:
  - '8 Connections

    '
- title: 8.1 Persistent Connections
  contents:
  - '8.1 Persistent Connections

    '
- title: 8.1.1 Purpose
  contents:
  - "8.1.1 Purpose\n   Prior to persistent connections, a separate TCP connection\
    \ was\n   established to fetch each URL, increasing the load on HTTP servers\n\
    \   and causing congestion on the Internet. The use of inline images and\n   other\
    \ associated data often require a client to make multiple\n   requests of the\
    \ same server in a short amount of time. Analysis of\n   these performance problems\
    \ and results from a prototype\n   implementation are available [26] [30]. Implementation\
    \ experience and\n   measurements of actual HTTP/1.1 (RFC 2068) implementations\
    \ show good\n   results [39]. Alternatives have also been explored, for example,\n\
    \   T/TCP [27].\n   Persistent HTTP connections have a number of advantages:\n\
    \      - By opening and closing fewer TCP connections, CPU time is saved\n   \
    \     in routers and hosts (clients, servers, proxies, gateways,\n        tunnels,\
    \ or caches), and memory used for TCP protocol control\n        blocks can be\
    \ saved in hosts.\n      - HTTP requests and responses can be pipelined on a connection.\n\
    \        Pipelining allows a client to make multiple requests without\n      \
    \  waiting for each response, allowing a single TCP connection to\n        be\
    \ used much more efficiently, with much lower elapsed time.\n      - Network congestion\
    \ is reduced by reducing the number of packets\n        caused by TCP opens, and\
    \ by allowing TCP sufficient time to\n        determine the congestion state of\
    \ the network.\n      - Latency on subsequent requests is reduced since there\
    \ is no time\n        spent in TCP's connection opening handshake.\n      - HTTP\
    \ can evolve more gracefully, since errors can be reported\n        without the\
    \ penalty of closing the TCP connection. Clients using\n        future versions\
    \ of HTTP might optimistically try a new feature,\n        but if communicating\
    \ with an older server, retry with old\n        semantics after an error is reported.\n\
    \   HTTP implementations SHOULD implement persistent connections.\n"
- title: 8.1.2 Overall Operation
  contents:
  - "8.1.2 Overall Operation\n   A significant difference between HTTP/1.1 and earlier\
    \ versions of\n   HTTP is that persistent connections are the default behavior\
    \ of any\n   HTTP connection. That is, unless otherwise indicated, the client\n\
    \   SHOULD assume that the server will maintain a persistent connection,\n   even\
    \ after error responses from the server.\n   Persistent connections provide a\
    \ mechanism by which a client and a\n   server can signal the close of a TCP connection.\
    \ This signaling takes\n   place using the Connection header field (section 14.10).\
    \ Once a close\n   has been signaled, the client MUST NOT send any more requests\
    \ on that\n   connection.\n"
- title: 8.1.2.1 Negotiation
  contents:
  - "8.1.2.1 Negotiation\n   An HTTP/1.1 server MAY assume that a HTTP/1.1 client\
    \ intends to\n   maintain a persistent connection unless a Connection header including\n\
    \   the connection-token \"close\" was sent in the request. If the server\n  \
    \ chooses to close the connection immediately after sending the\n   response,\
    \ it SHOULD send a Connection header including the\n   connection-token close.\n\
    \   An HTTP/1.1 client MAY expect a connection to remain open, but would\n   decide\
    \ to keep it open based on whether the response from a server\n   contains a Connection\
    \ header with the connection-token close. In case\n   the client does not want\
    \ to maintain a connection for more than that\n   request, it SHOULD send a Connection\
    \ header including the\n   connection-token close.\n   If either the client or\
    \ the server sends the close token in the\n   Connection header, that request\
    \ becomes the last one for the\n   connection.\n   Clients and servers SHOULD\
    \ NOT assume that a persistent connection is\n   maintained for HTTP versions\
    \ less than 1.1 unless it is explicitly\n   signaled. See section 19.6.2 for more\
    \ information on backward\n   compatibility with HTTP/1.0 clients.\n   In order\
    \ to remain persistent, all messages on the connection MUST\n   have a self-defined\
    \ message length (i.e., one not defined by closure\n   of the connection), as\
    \ described in section 4.4.\n"
- title: 8.1.2.2 Pipelining
  contents:
  - "8.1.2.2 Pipelining\n   A client that supports persistent connections MAY \"pipeline\"\
    \ its\n   requests (i.e., send multiple requests without waiting for each\n  \
    \ response). A server MUST send its responses to those requests in the\n   same\
    \ order that the requests were received.\n   Clients which assume persistent connections\
    \ and pipeline immediately\n   after connection establishment SHOULD be prepared\
    \ to retry their\n   connection if the first pipelined attempt fails. If a client\
    \ does\n   such a retry, it MUST NOT pipeline before it knows the connection is\n\
    \   persistent. Clients MUST also be prepared to resend their requests if\n  \
    \ the server closes the connection before sending all of the\n   corresponding\
    \ responses.\n   Clients SHOULD NOT pipeline requests using non-idempotent methods\
    \ or\n   non-idempotent sequences of methods (see section 9.1.2). Otherwise, a\n\
    \   premature termination of the transport connection could lead to\n   indeterminate\
    \ results. A client wishing to send a non-idempotent\n   request SHOULD wait to\
    \ send that request until it has received the\n   response status for the previous\
    \ request.\n"
- title: 8.1.3 Proxy Servers
  contents:
  - "8.1.3 Proxy Servers\n   It is especially important that proxies correctly implement\
    \ the\n   properties of the Connection header field as specified in section\n\
    \   14.10.\n   The proxy server MUST signal persistent connections separately\
    \ with\n   its clients and the origin servers (or other proxy servers) that it\n\
    \   connects to. Each persistent connection applies to only one transport\n  \
    \ link.\n   A proxy server MUST NOT establish a HTTP/1.1 persistent connection\n\
    \   with an HTTP/1.0 client (but see RFC 2068 [33] for information and\n   discussion\
    \ of the problems with the Keep-Alive header implemented by\n   many HTTP/1.0\
    \ clients).\n"
- title: 8.1.4 Practical Considerations
  contents:
  - "8.1.4 Practical Considerations\n   Servers will usually have some time-out value\
    \ beyond which they will\n   no longer maintain an inactive connection. Proxy\
    \ servers might make\n   this a higher value since it is likely that the client\
    \ will be making\n   more connections through the same server. The use of persistent\n\
    \   connections places no requirements on the length (or existence) of\n   this\
    \ time-out for either the client or the server.\n   When a client or server wishes\
    \ to time-out it SHOULD issue a graceful\n   close on the transport connection.\
    \ Clients and servers SHOULD both\n   constantly watch for the other side of the\
    \ transport close, and\n   respond to it as appropriate. If a client or server\
    \ does not detect\n   the other side's close promptly it could cause unnecessary\
    \ resource\n   drain on the network.\n   A client, server, or proxy MAY close\
    \ the transport connection at any\n   time. For example, a client might have started\
    \ to send a new request\n   at the same time that the server has decided to close\
    \ the \"idle\"\n   connection. From the server's point of view, the connection\
    \ is being\n   closed while it was idle, but from the client's point of view,\
    \ a\n   request is in progress.\n   This means that clients, servers, and proxies\
    \ MUST be able to recover\n   from asynchronous close events. Client software\
    \ SHOULD reopen the\n   transport connection and retransmit the aborted sequence\
    \ of requests\n   without user interaction so long as the request sequence is\n\
    \   idempotent (see section 9.1.2). Non-idempotent methods or sequences\n   MUST\
    \ NOT be automatically retried, although user agents MAY offer a\n   human operator\
    \ the choice of retrying the request(s). Confirmation by\n   user-agent software\
    \ with semantic understanding of the application\n   MAY substitute for user confirmation.\
    \ The automatic retry SHOULD NOT\n   be repeated if the second sequence of requests\
    \ fails.\n   Servers SHOULD always respond to at least one request per connection,\n\
    \   if at all possible. Servers SHOULD NOT close a connection in the\n   middle\
    \ of transmitting a response, unless a network or client failure\n   is suspected.\n\
    \   Clients that use persistent connections SHOULD limit the number of\n   simultaneous\
    \ connections that they maintain to a given server. A\n   single-user client SHOULD\
    \ NOT maintain more than 2 connections with\n   any server or proxy. A proxy SHOULD\
    \ use up to 2*N connections to\n   another server or proxy, where N is the number\
    \ of simultaneously\n   active users. These guidelines are intended to improve\
    \ HTTP response\n   times and avoid congestion.\n"
- title: 8.2 Message Transmission Requirements
  contents:
  - '8.2 Message Transmission Requirements

    '
- title: 8.2.1 Persistent Connections and Flow Control
  contents:
  - "8.2.1 Persistent Connections and Flow Control\n   HTTP/1.1 servers SHOULD maintain\
    \ persistent connections and use TCP's\n   flow control mechanisms to resolve\
    \ temporary overloads, rather than\n   terminating connections with the expectation\
    \ that clients will retry.\n   The latter technique can exacerbate network congestion.\n"
- title: 8.2.2 Monitoring Connections for Error Status Messages
  contents:
  - "8.2.2 Monitoring Connections for Error Status Messages\n   An HTTP/1.1 (or later)\
    \ client sending a message-body SHOULD monitor\n   the network connection for\
    \ an error status while it is transmitting\n   the request. If the client sees\
    \ an error status, it SHOULD\n   immediately cease transmitting the body. If the\
    \ body is being sent\n   using a \"chunked\" encoding (section 3.6), a zero length\
    \ chunk and\n   empty trailer MAY be used to prematurely mark the end of the message.\n\
    \   If the body was preceded by a Content-Length header, the client MUST\n   close\
    \ the connection.\n"
- title: 8.2.3 Use of the 100 (Continue) Status
  contents:
  - "8.2.3 Use of the 100 (Continue) Status\n   The purpose of the 100 (Continue)\
    \ status (see section 10.1.1) is to\n   allow a client that is sending a request\
    \ message with a request body\n   to determine if the origin server is willing\
    \ to accept the request\n   (based on the request headers) before the client sends\
    \ the request\n   body. In some cases, it might either be inappropriate or highly\n\
    \   inefficient for the client to send the body if the server will reject\n  \
    \ the message without looking at the body.\n   Requirements for HTTP/1.1 clients:\n\
    \      - If a client will wait for a 100 (Continue) response before\n        sending\
    \ the request body, it MUST send an Expect request-header\n        field (section\
    \ 14.20) with the \"100-continue\" expectation.\n      - A client MUST NOT send\
    \ an Expect request-header field (section\n        14.20) with the \"100-continue\"\
    \ expectation if it does not intend\n        to send a request body.\n   Because\
    \ of the presence of older implementations, the protocol allows\n   ambiguous\
    \ situations in which a client may send \"Expect: 100-\n   continue\" without\
    \ receiving either a 417 (Expectation Failed) status\n   or a 100 (Continue) status.\
    \ Therefore, when a client sends this\n   header field to an origin server (possibly\
    \ via a proxy) from which it\n   has never seen a 100 (Continue) status, the client\
    \ SHOULD NOT wait\n   for an indefinite period before sending the request body.\n\
    \   Requirements for HTTP/1.1 origin servers:\n      - Upon receiving a request\
    \ which includes an Expect request-header\n        field with the \"100-continue\"\
    \ expectation, an origin server MUST\n        either respond with 100 (Continue)\
    \ status and continue to read\n        from the input stream, or respond with\
    \ a final status code. The\n        origin server MUST NOT wait for the request\
    \ body before sending\n        the 100 (Continue) response. If it responds with\
    \ a final status\n        code, it MAY close the transport connection or it MAY\
    \ continue\n        to read and discard the rest of the request.  It MUST NOT\n\
    \        perform the requested method if it returns a final status code.\n   \
    \   - An origin server SHOULD NOT send a 100 (Continue) response if\n        the\
    \ request message does not include an Expect request-header\n        field with\
    \ the \"100-continue\" expectation, and MUST NOT send a\n        100 (Continue)\
    \ response if such a request comes from an HTTP/1.0\n        (or earlier) client.\
    \ There is an exception to this rule: for\n        compatibility with RFC 2068,\
    \ a server MAY send a 100 (Continue)\n        status in response to an HTTP/1.1\
    \ PUT or POST request that does\n        not include an Expect request-header\
    \ field with the \"100-\n        continue\" expectation. This exception, the purpose\
    \ of which is\n        to minimize any client processing delays associated with\
    \ an\n        undeclared wait for 100 (Continue) status, applies only to\n   \
    \     HTTP/1.1 requests, and not to requests with any other HTTP-\n        version\
    \ value.\n      - An origin server MAY omit a 100 (Continue) response if it has\n\
    \        already received some or all of the request body for the\n        corresponding\
    \ request.\n      - An origin server that sends a 100 (Continue) response MUST\n\
    \        ultimately send a final status code, once the request body is\n     \
    \   received and processed, unless it terminates the transport\n        connection\
    \ prematurely.\n      - If an origin server receives a request that does not include\
    \ an\n        Expect request-header field with the \"100-continue\" expectation,\n\
    \        the request includes a request body, and the server responds\n      \
    \  with a final status code before reading the entire request body\n        from\
    \ the transport connection, then the server SHOULD NOT close\n        the transport\
    \ connection until it has read the entire request,\n        or until the client\
    \ closes the connection. Otherwise, the client\n        might not reliably receive\
    \ the response message. However, this\n        requirement is not be construed\
    \ as preventing a server from\n        defending itself against denial-of-service\
    \ attacks, or from\n        badly broken client implementations.\n   Requirements\
    \ for HTTP/1.1 proxies:\n      - If a proxy receives a request that includes an\
    \ Expect request-\n        header field with the \"100-continue\" expectation,\
    \ and the proxy\n        either knows that the next-hop server complies with HTTP/1.1\
    \ or\n        higher, or does not know the HTTP version of the next-hop\n    \
    \    server, it MUST forward the request, including the Expect header\n      \
    \  field.\n      - If the proxy knows that the version of the next-hop server\
    \ is\n        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST\n\
    \        respond with a 417 (Expectation Failed) status.\n      - Proxies SHOULD\
    \ maintain a cache recording the HTTP version\n        numbers received from recently-referenced\
    \ next-hop servers.\n      - A proxy MUST NOT forward a 100 (Continue) response\
    \ if the\n        request message was received from an HTTP/1.0 (or earlier)\n\
    \        client and did not include an Expect request-header field with\n    \
    \    the \"100-continue\" expectation. This requirement overrides the\n      \
    \  general rule for forwarding of 1xx responses (see section 10.1).\n"
- title: 8.2.4 Client Behavior if Server Prematurely Closes Connection
  contents:
  - "8.2.4 Client Behavior if Server Prematurely Closes Connection\n   If an HTTP/1.1\
    \ client sends a request which includes a request body,\n   but which does not\
    \ include an Expect request-header field with the\n   \"100-continue\" expectation,\
    \ and if the client is not directly\n   connected to an HTTP/1.1 origin server,\
    \ and if the client sees the\n   connection close before receiving any status\
    \ from the server, the\n   client SHOULD retry the request.  If the client does\
    \ retry this\n   request, it MAY use the following \"binary exponential backoff\"\
    \n   algorithm to be assured of obtaining a reliable response:\n      1. Initiate\
    \ a new connection to the server\n      2. Transmit the request-headers\n    \
    \  3. Initialize a variable R to the estimated round-trip time to the\n      \
    \   server (e.g., based on the time it took to establish the\n         connection),\
    \ or to a constant value of 5 seconds if the round-\n         trip time is not\
    \ available.\n      4. Compute T = R * (2**N), where N is the number of previous\n\
    \         retries of this request.\n      5. Wait either for an error response\
    \ from the server, or for T\n         seconds (whichever comes first)\n      6.\
    \ If no error response is received, after T seconds transmit the\n         body\
    \ of the request.\n      7. If client sees that the connection is closed prematurely,\n\
    \         repeat from step 1 until the request is accepted, an error\n       \
    \  response is received, or the user becomes impatient and\n         terminates\
    \ the retry process.\n   If at any point an error status is received, the client\n\
    \      - SHOULD NOT continue and\n      - SHOULD close the connection if it has\
    \ not completed sending the\n        request message.\n"
- title: 9 Method Definitions
  contents:
  - "9 Method Definitions\n   The set of common methods for HTTP/1.1 is defined below.\
    \ Although\n   this set can be expanded, additional methods cannot be assumed\
    \ to\n   share the same semantics for separately extended clients and servers.\n\
    \   The Host request-header field (section 14.23) MUST accompany all\n   HTTP/1.1\
    \ requests.\n"
- title: 9.1 Safe and Idempotent Methods
  contents:
  - '9.1 Safe and Idempotent Methods

    '
- title: 9.1.1 Safe Methods
  contents:
  - "9.1.1 Safe Methods\n   Implementors should be aware that the software represents\
    \ the user in\n   their interactions over the Internet, and should be careful\
    \ to allow\n   the user to be aware of any actions they might take which may have\
    \ an\n   unexpected significance to themselves or others.\n   In particular, the\
    \ convention has been established that the GET and\n   HEAD methods SHOULD NOT\
    \ have the significance of taking an action\n   other than retrieval. These methods\
    \ ought to be considered \"safe\".\n   This allows user agents to represent other\
    \ methods, such as POST, PUT\n   and DELETE, in a special way, so that the user\
    \ is made aware of the\n   fact that a possibly unsafe action is being requested.\n\
    \   Naturally, it is not possible to ensure that the server does not\n   generate\
    \ side-effects as a result of performing a GET request; in\n   fact, some dynamic\
    \ resources consider that a feature. The important\n   distinction here is that\
    \ the user did not request the side-effects,\n   so therefore cannot be held accountable\
    \ for them.\n"
- title: 9.1.2 Idempotent Methods
  contents:
  - "9.1.2 Idempotent Methods\n   Methods can also have the property of \"idempotence\"\
    \ in that (aside\n   from error or expiration issues) the side-effects of N >\
    \ 0 identical\n   requests is the same as for a single request. The methods GET,\
    \ HEAD,\n   PUT and DELETE share this property. Also, the methods OPTIONS and\n\
    \   TRACE SHOULD NOT have side effects, and so are inherently idempotent.\n  \
    \ However, it is possible that a sequence of several requests is non-\n   idempotent,\
    \ even if all of the methods executed in that sequence are\n   idempotent. (A\
    \ sequence is idempotent if a single execution of the\n   entire sequence always\
    \ yields a result that is not changed by a\n   reexecution of all, or part, of\
    \ that sequence.) For example, a\n   sequence is non-idempotent if its result\
    \ depends on a value that is\n   later modified in the same sequence.\n   A sequence\
    \ that never has side effects is idempotent, by definition\n   (provided that\
    \ no concurrent operations are being executed on the\n   same set of resources).\n"
- title: 9.2 OPTIONS
  contents:
  - "9.2 OPTIONS\n   The OPTIONS method represents a request for information about\
    \ the\n   communication options available on the request/response chain\n   identified\
    \ by the Request-URI. This method allows the client to\n   determine the options\
    \ and/or requirements associated with a resource,\n   or the capabilities of a\
    \ server, without implying a resource action\n   or initiating a resource retrieval.\n\
    \   Responses to this method are not cacheable.\n   If the OPTIONS request includes\
    \ an entity-body (as indicated by the\n   presence of Content-Length or Transfer-Encoding),\
    \ then the media type\n   MUST be indicated by a Content-Type field. Although\
    \ this\n   specification does not define any use for such a body, future\n   extensions\
    \ to HTTP might use the OPTIONS body to make more detailed\n   queries on the\
    \ server. A server that does not support such an\n   extension MAY discard the\
    \ request body.\n   If the Request-URI is an asterisk (\"*\"), the OPTIONS request\
    \ is\n   intended to apply to the server in general rather than to a specific\n\
    \   resource. Since a server's communication options typically depend on\n   the\
    \ resource, the \"*\" request is only useful as a \"ping\" or \"no-op\"\n   type\
    \ of method; it does nothing beyond allowing the client to test\n   the capabilities\
    \ of the server. For example, this can be used to test\n   a proxy for HTTP/1.1\
    \ compliance (or lack thereof).\n   If the Request-URI is not an asterisk, the\
    \ OPTIONS request applies\n   only to the options that are available when communicating\
    \ with that\n   resource.\n   A 200 response SHOULD include any header fields\
    \ that indicate\n   optional features implemented by the server and applicable\
    \ to that\n   resource (e.g., Allow), possibly including extensions not defined\
    \ by\n   this specification. The response body, if any, SHOULD also include\n\
    \   information about the communication options. The format for such a\n   body\
    \ is not defined by this specification, but might be defined by\n   future extensions\
    \ to HTTP. Content negotiation MAY be used to select\n   the appropriate response\
    \ format. If no response body is included, the\n   response MUST include a Content-Length\
    \ field with a field-value of\n   \"0\".\n   The Max-Forwards request-header field\
    \ MAY be used to target a\n   specific proxy in the request chain. When a proxy\
    \ receives an OPTIONS\n   request on an absoluteURI for which request forwarding\
    \ is permitted,\n   the proxy MUST check for a Max-Forwards field. If the Max-Forwards\n\
    \   field-value is zero (\"0\"), the proxy MUST NOT forward the message;\n   instead,\
    \ the proxy SHOULD respond with its own communication options.\n   If the Max-Forwards\
    \ field-value is an integer greater than zero, the\n   proxy MUST decrement the\
    \ field-value when it forwards the request. If\n   no Max-Forwards field is present\
    \ in the request, then the forwarded\n   request MUST NOT include a Max-Forwards\
    \ field.\n"
- title: 9.3 GET
  contents:
  - "9.3 GET\n   The GET method means retrieve whatever information (in the form of\
    \ an\n   entity) is identified by the Request-URI. If the Request-URI refers\n\
    \   to a data-producing process, it is the produced data which shall be\n   returned\
    \ as the entity in the response and not the source text of the\n   process, unless\
    \ that text happens to be the output of the process.\n   The semantics of the\
    \ GET method change to a \"conditional GET\" if the\n   request message includes\
    \ an If-Modified-Since, If-Unmodified-Since,\n   If-Match, If-None-Match, or If-Range\
    \ header field. A conditional GET\n   method requests that the entity be transferred\
    \ only under the\n   circumstances described by the conditional header field(s).\
    \ The\n   conditional GET method is intended to reduce unnecessary network\n \
    \  usage by allowing cached entities to be refreshed without requiring\n   multiple\
    \ requests or transferring data already held by the client.\n   The semantics\
    \ of the GET method change to a \"partial GET\" if the\n   request message includes\
    \ a Range header field. A partial GET requests\n   that only part of the entity\
    \ be transferred, as described in section\n   14.35. The partial GET method is\
    \ intended to reduce unnecessary\n   network usage by allowing partially-retrieved\
    \ entities to be\n   completed without transferring data already held by the client.\n\
    \   The response to a GET request is cacheable if and only if it meets\n   the\
    \ requirements for HTTP caching described in section 13.\n   See section 15.1.3\
    \ for security considerations when used for forms.\n"
- title: 9.4 HEAD
  contents:
  - "9.4 HEAD\n   The HEAD method is identical to GET except that the server MUST\
    \ NOT\n   return a message-body in the response. The metainformation contained\n\
    \   in the HTTP headers in response to a HEAD request SHOULD be identical\n  \
    \ to the information sent in response to a GET request. This method can\n   be\
    \ used for obtaining metainformation about the entity implied by the\n   request\
    \ without transferring the entity-body itself. This method is\n   often used for\
    \ testing hypertext links for validity, accessibility,\n   and recent modification.\n\
    \   The response to a HEAD request MAY be cacheable in the sense that the\n  \
    \ information contained in the response MAY be used to update a\n   previously\
    \ cached entity from that resource. If the new field values\n   indicate that\
    \ the cached entity differs from the current entity (as\n   would be indicated\
    \ by a change in Content-Length, Content-MD5, ETag\n   or Last-Modified), then\
    \ the cache MUST treat the cache entry as\n   stale.\n"
- title: 9.5 POST
  contents:
  - "9.5 POST\n   The POST method is used to request that the origin server accept\
    \ the\n   entity enclosed in the request as a new subordinate of the resource\n\
    \   identified by the Request-URI in the Request-Line. POST is designed\n   to\
    \ allow a uniform method to cover the following functions:\n      - Annotation\
    \ of existing resources;\n      - Posting a message to a bulletin board, newsgroup,\
    \ mailing list,\n        or similar group of articles;\n      - Providing a block\
    \ of data, such as the result of submitting a\n        form, to a data-handling\
    \ process;\n      - Extending a database through an append operation.\n   The\
    \ actual function performed by the POST method is determined by the\n   server\
    \ and is usually dependent on the Request-URI. The posted entity\n   is subordinate\
    \ to that URI in the same way that a file is subordinate\n   to a directory containing\
    \ it, a news article is subordinate to a\n   newsgroup to which it is posted,\
    \ or a record is subordinate to a\n   database.\n   The action performed by the\
    \ POST method might not result in a\n   resource that can be identified by a URI.\
    \ In this case, either 200\n   (OK) or 204 (No Content) is the appropriate response\
    \ status,\n   depending on whether or not the response includes an entity that\n\
    \   describes the result.\n   If a resource has been created on the origin server,\
    \ the response\n   SHOULD be 201 (Created) and contain an entity which describes\
    \ the\n   status of the request and refers to the new resource, and a Location\n\
    \   header (see section 14.30).\n   Responses to this method are not cacheable,\
    \ unless the response\n   includes appropriate Cache-Control or Expires header\
    \ fields. However,\n   the 303 (See Other) response can be used to direct the\
    \ user agent to\n   retrieve a cacheable resource.\n   POST requests MUST obey\
    \ the message transmission requirements set out\n   in section 8.2.\n   See section\
    \ 15.1.3 for security considerations.\n"
- title: 9.6 PUT
  contents:
  - "9.6 PUT\n   The PUT method requests that the enclosed entity be stored under\
    \ the\n   supplied Request-URI. If the Request-URI refers to an already\n   existing\
    \ resource, the enclosed entity SHOULD be considered as a\n   modified version\
    \ of the one residing on the origin server. If the\n   Request-URI does not point\
    \ to an existing resource, and that URI is\n   capable of being defined as a new\
    \ resource by the requesting user\n   agent, the origin server can create the\
    \ resource with that URI. If a\n   new resource is created, the origin server\
    \ MUST inform the user agent\n   via the 201 (Created) response. If an existing\
    \ resource is modified,\n   either the 200 (OK) or 204 (No Content) response codes\
    \ SHOULD be sent\n   to indicate successful completion of the request. If the\
    \ resource\n   could not be created or modified with the Request-URI, an appropriate\n\
    \   error response SHOULD be given that reflects the nature of the\n   problem.\
    \ The recipient of the entity MUST NOT ignore any Content-*\n   (e.g. Content-Range)\
    \ headers that it does not understand or implement\n   and MUST return a 501 (Not\
    \ Implemented) response in such cases.\n   If the request passes through a cache\
    \ and the Request-URI identifies\n   one or more currently cached entities, those\
    \ entries SHOULD be\n   treated as stale. Responses to this method are not cacheable.\n\
    \   The fundamental difference between the POST and PUT requests is\n   reflected\
    \ in the different meaning of the Request-URI. The URI in a\n   POST request identifies\
    \ the resource that will handle the enclosed\n   entity. That resource might be\
    \ a data-accepting process, a gateway to\n   some other protocol, or a separate\
    \ entity that accepts annotations.\n   In contrast, the URI in a PUT request identifies\
    \ the entity enclosed\n   with the request -- the user agent knows what URI is\
    \ intended and the\n   server MUST NOT attempt to apply the request to some other\
    \ resource.\n   If the server desires that the request be applied to a different\
    \ URI,\n   it MUST send a 301 (Moved Permanently) response; the user agent MAY\n\
    \   then make its own decision regarding whether or not to redirect the\n   request.\n\
    \   A single resource MAY be identified by many different URIs. For\n   example,\
    \ an article might have a URI for identifying \"the current\n   version\" which\
    \ is separate from the URI identifying each particular\n   version. In this case,\
    \ a PUT request on a general URI might result in\n   several other URIs being\
    \ defined by the origin server.\n   HTTP/1.1 does not define how a PUT method\
    \ affects the state of an\n   origin server.\n   PUT requests MUST obey the message\
    \ transmission requirements set out\n   in section 8.2.\n   Unless otherwise specified\
    \ for a particular entity-header, the\n   entity-headers in the PUT request SHOULD\
    \ be applied to the resource\n   created or modified by the PUT.\n"
- title: 9.7 DELETE
  contents:
  - "9.7 DELETE\n   The DELETE method requests that the origin server delete the resource\n\
    \   identified by the Request-URI. This method MAY be overridden by human\n  \
    \ intervention (or other means) on the origin server. The client cannot\n   be\
    \ guaranteed that the operation has been carried out, even if the\n   status code\
    \ returned from the origin server indicates that the action\n   has been completed\
    \ successfully. However, the server SHOULD NOT\n   indicate success unless, at\
    \ the time the response is given, it\n   intends to delete the resource or move\
    \ it to an inaccessible\n   location.\n   A successful response SHOULD be 200\
    \ (OK) if the response includes an\n   entity describing the status, 202 (Accepted)\
    \ if the action has not\n   yet been enacted, or 204 (No Content) if the action\
    \ has been enacted\n   but the response does not include an entity.\n   If the\
    \ request passes through a cache and the Request-URI identifies\n   one or more\
    \ currently cached entities, those entries SHOULD be\n   treated as stale. Responses\
    \ to this method are not cacheable.\n"
- title: 9.8 TRACE
  contents:
  - "9.8 TRACE\n   The TRACE method is used to invoke a remote, application-layer\
    \ loop-\n   back of the request message. The final recipient of the request\n\
    \   SHOULD reflect the message received back to the client as the\n   entity-body\
    \ of a 200 (OK) response. The final recipient is either the\n   origin server\
    \ or the first proxy or gateway to receive a Max-Forwards\n   value of zero (0)\
    \ in the request (see section 14.31). A TRACE request\n   MUST NOT include an\
    \ entity.\n   TRACE allows the client to see what is being received at the other\n\
    \   end of the request chain and use that data for testing or diagnostic\n   information.\
    \ The value of the Via header field (section 14.45) is of\n   particular interest,\
    \ since it acts as a trace of the request chain.\n   Use of the Max-Forwards header\
    \ field allows the client to limit the\n   length of the request chain, which\
    \ is useful for testing a chain of\n   proxies forwarding messages in an infinite\
    \ loop.\n   If the request is valid, the response SHOULD contain the entire\n\
    \   request message in the entity-body, with a Content-Type of\n   \"message/http\"\
    . Responses to this method MUST NOT be cached.\n"
- title: 9.9 CONNECT
  contents:
  - "9.9 CONNECT\n   This specification reserves the method name CONNECT for use with\
    \ a\n   proxy that can dynamically switch to being a tunnel (e.g. SSL\n   tunneling\
    \ [44]).\n"
- title: 10 Status Code Definitions
  contents:
  - "10 Status Code Definitions\n   Each Status-Code is described below, including\
    \ a description of which\n   method(s) it can follow and any metainformation required\
    \ in the\n   response.\n"
- title: 10.1 Informational 1xx
  contents:
  - "10.1 Informational 1xx\n   This class of status code indicates a provisional\
    \ response,\n   consisting only of the Status-Line and optional headers, and is\n\
    \   terminated by an empty line. There are no required headers for this\n   class\
    \ of status code. Since HTTP/1.0 did not define any 1xx status\n   codes, servers\
    \ MUST NOT send a 1xx response to an HTTP/1.0 client\n   except under experimental\
    \ conditions.\n   A client MUST be prepared to accept one or more 1xx status responses\n\
    \   prior to a regular response, even if the client does not expect a 100\n  \
    \ (Continue) status message. Unexpected 1xx status responses MAY be\n   ignored\
    \ by a user agent.\n   Proxies MUST forward 1xx responses, unless the connection\
    \ between the\n   proxy and its client has been closed, or unless the proxy itself\n\
    \   requested the generation of the 1xx response. (For example, if a\n   proxy\
    \ adds a \"Expect: 100-continue\" field when it forwards a request,\n   then it\
    \ need not forward the corresponding 100 (Continue)\n   response(s).)\n"
- title: 10.1.1 100 Continue
  contents:
  - "10.1.1 100 Continue\n   The client SHOULD continue with its request. This interim\
    \ response is\n   used to inform the client that the initial part of the request\
    \ has\n   been received and has not yet been rejected by the server. The client\n\
    \   SHOULD continue by sending the remainder of the request or, if the\n   request\
    \ has already been completed, ignore this response. The server\n   MUST send a\
    \ final response after the request has been completed. See\n   section 8.2.3 for\
    \ detailed discussion of the use and handling of this\n   status code.\n"
- title: 10.1.2 101 Switching Protocols
  contents:
  - "10.1.2 101 Switching Protocols\n   The server understands and is willing to comply\
    \ with the client's\n   request, via the Upgrade message header field (section\
    \ 14.42), for a\n   change in the application protocol being used on this connection.\
    \ The\n   server will switch protocols to those defined by the response's\n  \
    \ Upgrade header field immediately after the empty line which\n   terminates the\
    \ 101 response.\n   The protocol SHOULD be switched only when it is advantageous\
    \ to do\n   so. For example, switching to a newer version of HTTP is advantageous\n\
    \   over older versions, and switching to a real-time, synchronous\n   protocol\
    \ might be advantageous when delivering resources that use\n   such features.\n"
- title: 10.2 Successful 2xx
  contents:
  - "10.2 Successful 2xx\n   This class of status code indicates that the client's\
    \ request was\n   successfully received, understood, and accepted.\n"
- title: 10.2.1 200 OK
  contents:
  - "10.2.1 200 OK\n   The request has succeeded. The information returned with the\
    \ response\n   is dependent on the method used in the request, for example:\n\
    \   GET    an entity corresponding to the requested resource is sent in\n    \
    \      the response;\n   HEAD   the entity-header fields corresponding to the\
    \ requested\n          resource are sent in the response without any message-body;\n\
    \   POST   an entity describing or containing the result of the action;\n   TRACE\
    \  an entity containing the request message as received by the\n          end\
    \ server.\n"
- title: 10.2.2 201 Created
  contents:
  - "10.2.2 201 Created\n   The request has been fulfilled and resulted in a new resource\
    \ being\n   created. The newly created resource can be referenced by the URI(s)\n\
    \   returned in the entity of the response, with the most specific URI\n   for\
    \ the resource given by a Location header field. The response\n   SHOULD include\
    \ an entity containing a list of resource\n   characteristics and location(s)\
    \ from which the user or user agent can\n   choose the one most appropriate. The\
    \ entity format is specified by\n   the media type given in the Content-Type header\
    \ field. The origin\n   server MUST create the resource before returning the 201\
    \ status code.\n   If the action cannot be carried out immediately, the server\
    \ SHOULD\n   respond with 202 (Accepted) response instead.\n   A 201 response\
    \ MAY contain an ETag response header field indicating\n   the current value of\
    \ the entity tag for the requested variant just\n   created, see section 14.19.\n"
- title: 10.2.3 202 Accepted
  contents:
  - "10.2.3 202 Accepted\n   The request has been accepted for processing, but the\
    \ processing has\n   not been completed.  The request might or might not eventually\
    \ be\n   acted upon, as it might be disallowed when processing actually takes\n\
    \   place. There is no facility for re-sending a status code from an\n   asynchronous\
    \ operation such as this.\n   The 202 response is intentionally non-committal.\
    \ Its purpose is to\n   allow a server to accept a request for some other process\
    \ (perhaps a\n   batch-oriented process that is only run once per day) without\n\
    \   requiring that the user agent's connection to the server persist\n   until\
    \ the process is completed. The entity returned with this\n   response SHOULD\
    \ include an indication of the request's current status\n   and either a pointer\
    \ to a status monitor or some estimate of when the\n   user can expect the request\
    \ to be fulfilled.\n"
- title: 10.2.4 203 Non-Authoritative Information
  contents:
  - "10.2.4 203 Non-Authoritative Information\n   The returned metainformation in\
    \ the entity-header is not the\n   definitive set as available from the origin\
    \ server, but is gathered\n   from a local or a third-party copy. The set presented\
    \ MAY be a subset\n   or superset of the original version. For example, including\
    \ local\n   annotation information about the resource might result in a superset\n\
    \   of the metainformation known by the origin server. Use of this\n   response\
    \ code is not required and is only appropriate when the\n   response would otherwise\
    \ be 200 (OK).\n"
- title: 10.2.5 204 No Content
  contents:
  - "10.2.5 204 No Content\n   The server has fulfilled the request but does not need\
    \ to return an\n   entity-body, and might want to return updated metainformation.\
    \ The\n   response MAY include new or updated metainformation in the form of\n\
    \   entity-headers, which if present SHOULD be associated with the\n   requested\
    \ variant.\n   If the client is a user agent, it SHOULD NOT change its document\
    \ view\n   from that which caused the request to be sent. This response is\n \
    \  primarily intended to allow input for actions to take place without\n   causing\
    \ a change to the user agent's active document view, although\n   any new or updated\
    \ metainformation SHOULD be applied to the document\n   currently in the user\
    \ agent's active view.\n   The 204 response MUST NOT include a message-body, and\
    \ thus is always\n   terminated by the first empty line after the header fields.\n"
- title: 10.2.6 205 Reset Content
  contents:
  - "10.2.6 205 Reset Content\n   The server has fulfilled the request and the user\
    \ agent SHOULD reset\n   the document view which caused the request to be sent.\
    \ This response\n   is primarily intended to allow input for actions to take place\
    \ via\n   user input, followed by a clearing of the form in which the input is\n\
    \   given so that the user can easily initiate another input action. The\n   response\
    \ MUST NOT include an entity.\n"
- title: 10.2.7 206 Partial Content
  contents:
  - "10.2.7 206 Partial Content\n   The server has fulfilled the partial GET request\
    \ for the resource.\n   The request MUST have included a Range header field (section\
    \ 14.35)\n   indicating the desired range, and MAY have included an If-Range\n\
    \   header field (section 14.27) to make the request conditional.\n   The response\
    \ MUST include the following header fields:\n      - Either a Content-Range header\
    \ field (section 14.16) indicating\n        the range included with this response,\
    \ or a multipart/byteranges\n        Content-Type including Content-Range fields\
    \ for each part. If a\n        Content-Length header field is present in the response,\
    \ its\n        value MUST match the actual number of OCTETs transmitted in the\n\
    \        message-body.\n      - Date\n      - ETag and/or Content-Location, if\
    \ the header would have been sent\n        in a 200 response to the same request\n\
    \      - Expires, Cache-Control, and/or Vary, if the field-value might\n     \
    \   differ from that sent in any previous response for the same\n        variant\n\
    \   If the 206 response is the result of an If-Range request that used a\n   strong\
    \ cache validator (see section 13.3.3), the response SHOULD NOT\n   include other\
    \ entity-headers. If the response is the result of an\n   If-Range request that\
    \ used a weak validator, the response MUST NOT\n   include other entity-headers;\
    \ this prevents inconsistencies between\n   cached entity-bodies and updated headers.\
    \ Otherwise, the response\n   MUST include all of the entity-headers that would\
    \ have been returned\n   with a 200 (OK) response to the same request.\n   A cache\
    \ MUST NOT combine a 206 response with other previously cached\n   content if\
    \ the ETag or Last-Modified headers do not match exactly,\n   see 13.5.4.\n  \
    \ A cache that does not support the Range and Content-Range headers\n   MUST NOT\
    \ cache 206 (Partial) responses.\n"
- title: 10.3 Redirection 3xx
  contents:
  - "10.3 Redirection 3xx\n   This class of status code indicates that further action\
    \ needs to be\n   taken by the user agent in order to fulfill the request.  The\
    \ action\n   required MAY be carried out by the user agent without interaction\n\
    \   with the user if and only if the method used in the second request is\n  \
    \ GET or HEAD. A client SHOULD detect infinite redirection loops, since\n   such\
    \ loops generate network traffic for each redirection.\n      Note: previous versions\
    \ of this specification recommended a\n      maximum of five redirections. Content\
    \ developers should be aware\n      that there might be clients that implement\
    \ such a fixed\n      limitation.\n"
- title: 10.3.1 300 Multiple Choices
  contents:
  - "10.3.1 300 Multiple Choices\n   The requested resource corresponds to any one\
    \ of a set of\n   representations, each with its own specific location, and agent-\n\
    \   driven negotiation information (section 12) is being provided so that\n  \
    \ the user (or user agent) can select a preferred representation and\n   redirect\
    \ its request to that location.\n   Unless it was a HEAD request, the response\
    \ SHOULD include an entity\n   containing a list of resource characteristics and\
    \ location(s) from\n   which the user or user agent can choose the one most appropriate.\
    \ The\n   entity format is specified by the media type given in the Content-\n\
    \   Type header field. Depending upon the format and the capabilities of\n   the\
    \ user agent, selection of the most appropriate choice MAY be\n   performed automatically.\
    \ However, this specification does not define\n   any standard for such automatic\
    \ selection.\n   If the server has a preferred choice of representation, it SHOULD\n\
    \   include the specific URI for that representation in the Location\n   field;\
    \ user agents MAY use the Location field value for automatic\n   redirection.\
    \ This response is cacheable unless indicated otherwise.\n"
- title: 10.3.2 301 Moved Permanently
  contents:
  - "10.3.2 301 Moved Permanently\n   The requested resource has been assigned a new\
    \ permanent URI and any\n   future references to this resource SHOULD use one\
    \ of the returned\n   URIs.  Clients with link editing capabilities ought to automatically\n\
    \   re-link references to the Request-URI to one or more of the new\n   references\
    \ returned by the server, where possible. This response is\n   cacheable unless\
    \ indicated otherwise.\n   The new permanent URI SHOULD be given by the Location\
    \ field in the\n   response. Unless the request method was HEAD, the entity of\
    \ the\n   response SHOULD contain a short hypertext note with a hyperlink to\n\
    \   the new URI(s).\n   If the 301 status code is received in response to a request\
    \ other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n\
    \   request unless it can be confirmed by the user, since this might\n   change\
    \ the conditions under which the request was issued.\n      Note: When automatically\
    \ redirecting a POST request after\n      receiving a 301 status code, some existing\
    \ HTTP/1.0 user agents\n      will erroneously change it into a GET request.\n"
- title: 10.3.3 302 Found
  contents:
  - "10.3.3 302 Found\n   The requested resource resides temporarily under a different\
    \ URI.\n   Since the redirection might be altered on occasion, the client SHOULD\n\
    \   continue to use the Request-URI for future requests.  This response\n   is\
    \ only cacheable if indicated by a Cache-Control or Expires header\n   field.\n\
    \   The temporary URI SHOULD be given by the Location field in the\n   response.\
    \ Unless the request method was HEAD, the entity of the\n   response SHOULD contain\
    \ a short hypertext note with a hyperlink to\n   the new URI(s).\n   If the 302\
    \ status code is received in response to a request other\n   than GET or HEAD,\
    \ the user agent MUST NOT automatically redirect the\n   request unless it can\
    \ be confirmed by the user, since this might\n   change the conditions under which\
    \ the request was issued.\n      Note: RFC 1945 and RFC 2068 specify that the\
    \ client is not allowed\n      to change the method on the redirected request.\
    \  However, most\n      existing user agent implementations treat 302 as if it\
    \ were a 303\n      response, performing a GET on the Location field-value regardless\n\
    \      of the original request method. The status codes 303 and 307 have\n   \
    \   been added for servers that wish to make unambiguously clear which\n     \
    \ kind of reaction is expected of the client.\n"
- title: 10.3.4 303 See Other
  contents:
  - "10.3.4 303 See Other\n   The response to the request can be found under a different\
    \ URI and\n   SHOULD be retrieved using a GET method on that resource. This method\n\
    \   exists primarily to allow the output of a POST-activated script to\n   redirect\
    \ the user agent to a selected resource. The new URI is not a\n   substitute reference\
    \ for the originally requested resource. The 303\n   response MUST NOT be cached,\
    \ but the response to the second\n   (redirected) request might be cacheable.\n\
    \   The different URI SHOULD be given by the Location field in the\n   response.\
    \ Unless the request method was HEAD, the entity of the\n   response SHOULD contain\
    \ a short hypertext note with a hyperlink to\n   the new URI(s).\n      Note:\
    \ Many pre-HTTP/1.1 user agents do not understand the 303\n      status. When\
    \ interoperability with such clients is a concern, the\n      302 status code\
    \ may be used instead, since most user agents react\n      to a 302 response as\
    \ described here for 303.\n"
- title: 10.3.5 304 Not Modified
  contents:
  - "10.3.5 304 Not Modified\n   If the client has performed a conditional GET request\
    \ and access is\n   allowed, but the document has not been modified, the server\
    \ SHOULD\n   respond with this status code. The 304 response MUST NOT contain\
    \ a\n   message-body, and thus is always terminated by the first empty line\n\
    \   after the header fields.\n   The response MUST include the following header\
    \ fields:\n      - Date, unless its omission is required by section 14.18.1\n\
    \   If a clockless origin server obeys these rules, and proxies and\n   clients\
    \ add their own Date to any response received without one (as\n   already specified\
    \ by [RFC 2068], section 14.19), caches will operate\n   correctly.\n      - ETag\
    \ and/or Content-Location, if the header would have been sent\n        in a 200\
    \ response to the same request\n      - Expires, Cache-Control, and/or Vary, if\
    \ the field-value might\n        differ from that sent in any previous response\
    \ for the same\n        variant\n   If the conditional GET used a strong cache\
    \ validator (see section\n   13.3.3), the response SHOULD NOT include other entity-headers.\n\
    \   Otherwise (i.e., the conditional GET used a weak validator), the\n   response\
    \ MUST NOT include other entity-headers; this prevents\n   inconsistencies between\
    \ cached entity-bodies and updated headers.\n   If a 304 response indicates an\
    \ entity not currently cached, then the\n   cache MUST disregard the response\
    \ and repeat the request without the\n   conditional.\n   If a cache uses a received\
    \ 304 response to update a cache entry, the\n   cache MUST update the entry to\
    \ reflect any new field values given in\n   the response.\n"
- title: 10.3.6 305 Use Proxy
  contents:
  - "10.3.6 305 Use Proxy\n   The requested resource MUST be accessed through the\
    \ proxy given by\n   the Location field. The Location field gives the URI of the\
    \ proxy.\n   The recipient is expected to repeat this single request via the\n\
    \   proxy. 305 responses MUST only be generated by origin servers.\n      Note:\
    \ RFC 2068 was not clear that 305 was intended to redirect a\n      single request,\
    \ and to be generated by origin servers only.  Not\n      observing these limitations\
    \ has significant security consequences.\n"
- title: 10.3.7 306 (Unused)
  contents:
  - "10.3.7 306 (Unused)\n   The 306 status code was used in a previous version of\
    \ the\n   specification, is no longer used, and the code is reserved.\n"
- title: 10.3.8 307 Temporary Redirect
  contents:
  - "10.3.8 307 Temporary Redirect\n   The requested resource resides temporarily\
    \ under a different URI.\n   Since the redirection MAY be altered on occasion,\
    \ the client SHOULD\n   continue to use the Request-URI for future requests. \
    \ This response\n   is only cacheable if indicated by a Cache-Control or Expires\
    \ header\n   field.\n   The temporary URI SHOULD be given by the Location field\
    \ in the\n   response. Unless the request method was HEAD, the entity of the\n\
    \   response SHOULD contain a short hypertext note with a hyperlink to\n   the\
    \ new URI(s) , since many pre-HTTP/1.1 user agents do not\n   understand the 307\
    \ status. Therefore, the note SHOULD contain the\n   information necessary for\
    \ a user to repeat the original request on\n   the new URI.\n   If the 307 status\
    \ code is received in response to a request other\n   than GET or HEAD, the user\
    \ agent MUST NOT automatically redirect the\n   request unless it can be confirmed\
    \ by the user, since this might\n   change the conditions under which the request\
    \ was issued.\n"
- title: 10.4 Client Error 4xx
  contents:
  - "10.4 Client Error 4xx\n   The 4xx class of status code is intended for cases\
    \ in which the\n   client seems to have erred. Except when responding to a HEAD\
    \ request,\n   the server SHOULD include an entity containing an explanation of\
    \ the\n   error situation, and whether it is a temporary or permanent\n   condition.\
    \ These status codes are applicable to any request method.\n   User agents SHOULD\
    \ display any included entity to the user.\n   If the client is sending data,\
    \ a server implementation using TCP\n   SHOULD be careful to ensure that the client\
    \ acknowledges receipt of\n   the packet(s) containing the response, before the\
    \ server closes the\n   input connection. If the client continues sending data\
    \ to the server\n   after the close, the server's TCP stack will send a reset\
    \ packet to\n   the client, which may erase the client's unacknowledged input\
    \ buffers\n   before they can be read and interpreted by the HTTP application.\n"
- title: 10.4.1 400 Bad Request
  contents:
  - "10.4.1 400 Bad Request\n   The request could not be understood by the server\
    \ due to malformed\n   syntax. The client SHOULD NOT repeat the request without\n\
    \   modifications.\n"
- title: 10.4.2 401 Unauthorized
  contents:
  - "10.4.2 401 Unauthorized\n   The request requires user authentication. The response\
    \ MUST include a\n   WWW-Authenticate header field (section 14.47) containing\
    \ a challenge\n   applicable to the requested resource. The client MAY repeat\
    \ the\n   request with a suitable Authorization header field (section 14.8). If\n\
    \   the request already included Authorization credentials, then the 401\n   response\
    \ indicates that authorization has been refused for those\n   credentials. If\
    \ the 401 response contains the same challenge as the\n   prior response, and\
    \ the user agent has already attempted\n   authentication at least once, then\
    \ the user SHOULD be presented the\n   entity that was given in the response,\
    \ since that entity might\n   include relevant diagnostic information. HTTP access\
    \ authentication\n   is explained in \"HTTP Authentication: Basic and Digest Access\n\
    \   Authentication\" [43].\n"
- title: 10.4.3 402 Payment Required
  contents:
  - "10.4.3 402 Payment Required\n   This code is reserved for future use.\n"
- title: 10.4.4 403 Forbidden
  contents:
  - "10.4.4 403 Forbidden\n   The server understood the request, but is refusing to\
    \ fulfill it.\n   Authorization will not help and the request SHOULD NOT be repeated.\n\
    \   If the request method was not HEAD and the server wishes to make\n   public\
    \ why the request has not been fulfilled, it SHOULD describe the\n   reason for\
    \ the refusal in the entity.  If the server does not wish to\n   make this information\
    \ available to the client, the status code 404\n   (Not Found) can be used instead.\n"
- title: 10.4.5 404 Not Found
  contents:
  - "10.4.5 404 Not Found\n   The server has not found anything matching the Request-URI.\
    \ No\n   indication is given of whether the condition is temporary or\n   permanent.\
    \ The 410 (Gone) status code SHOULD be used if the server\n   knows, through some\
    \ internally configurable mechanism, that an old\n   resource is permanently unavailable\
    \ and has no forwarding address.\n   This status code is commonly used when the\
    \ server does not wish to\n   reveal exactly why the request has been refused,\
    \ or when no other\n   response is applicable.\n"
- title: 10.4.6 405 Method Not Allowed
  contents:
  - "10.4.6 405 Method Not Allowed\n   The method specified in the Request-Line is\
    \ not allowed for the\n   resource identified by the Request-URI. The response\
    \ MUST include an\n   Allow header containing a list of valid methods for the\
    \ requested\n   resource.\n"
- title: 10.4.7 406 Not Acceptable
  contents:
  - "10.4.7 406 Not Acceptable\n   The resource identified by the request is only\
    \ capable of generating\n   response entities which have content characteristics\
    \ not acceptable\n   according to the accept headers sent in the request.\n  \
    \ Unless it was a HEAD request, the response SHOULD include an entity\n   containing\
    \ a list of available entity characteristics and location(s)\n   from which the\
    \ user or user agent can choose the one most\n   appropriate. The entity format\
    \ is specified by the media type given\n   in the Content-Type header field. Depending\
    \ upon the format and the\n   capabilities of the user agent, selection of the\
    \ most appropriate\n   choice MAY be performed automatically. However, this specification\n\
    \   does not define any standard for such automatic selection.\n      Note: HTTP/1.1\
    \ servers are allowed to return responses which are\n      not acceptable according\
    \ to the accept headers sent in the\n      request. In some cases, this may even\
    \ be preferable to sending a\n      406 response. User agents are encouraged to\
    \ inspect the headers of\n      an incoming response to determine if it is acceptable.\n\
    \   If the response could be unacceptable, a user agent SHOULD\n   temporarily\
    \ stop receipt of more data and query the user for a\n   decision on further actions.\n"
- title: 10.4.8 407 Proxy Authentication Required
  contents:
  - "10.4.8 407 Proxy Authentication Required\n   This code is similar to 401 (Unauthorized),\
    \ but indicates that the\n   client must first authenticate itself with the proxy.\
    \ The proxy MUST\n   return a Proxy-Authenticate header field (section 14.33)\
    \ containing a\n   challenge applicable to the proxy for the requested resource.\
    \ The\n   client MAY repeat the request with a suitable Proxy-Authorization\n\
    \   header field (section 14.34). HTTP access authentication is explained\n  \
    \ in \"HTTP Authentication: Basic and Digest Access Authentication\"\n   [43].\n"
- title: 10.4.9 408 Request Timeout
  contents:
  - "10.4.9 408 Request Timeout\n   The client did not produce a request within the\
    \ time that the server\n   was prepared to wait. The client MAY repeat the request\
    \ without\n   modifications at any later time.\n"
- title: 10.4.10 409 Conflict
  contents:
  - "10.4.10 409 Conflict\n   The request could not be completed due to a conflict\
    \ with the current\n   state of the resource. This code is only allowed in situations\
    \ where\n   it is expected that the user might be able to resolve the conflict\n\
    \   and resubmit the request. The response body SHOULD include enough\n   information\
    \ for the user to recognize the source of the conflict.\n   Ideally, the response\
    \ entity would include enough information for the\n   user or user agent to fix\
    \ the problem; however, that might not be\n   possible and is not required.\n\
    \   Conflicts are most likely to occur in response to a PUT request. For\n   example,\
    \ if versioning were being used and the entity being PUT\n   included changes\
    \ to a resource which conflict with those made by an\n   earlier (third-party)\
    \ request, the server might use the 409 response\n   to indicate that it can't\
    \ complete the request. In this case, the\n   response entity would likely contain\
    \ a list of the differences\n   between the two versions in a format defined by\
    \ the response\n   Content-Type.\n"
- title: 10.4.11 410 Gone
  contents:
  - "10.4.11 410 Gone\n   The requested resource is no longer available at the server\
    \ and no\n   forwarding address is known. This condition is expected to be\n \
    \  considered permanent. Clients with link editing capabilities SHOULD\n   delete\
    \ references to the Request-URI after user approval. If the\n   server does not\
    \ know, or has no facility to determine, whether or not\n   the condition is permanent,\
    \ the status code 404 (Not Found) SHOULD be\n   used instead. This response is\
    \ cacheable unless indicated otherwise.\n   The 410 response is primarily intended\
    \ to assist the task of web\n   maintenance by notifying the recipient that the\
    \ resource is\n   intentionally unavailable and that the server owners desire\
    \ that\n   remote links to that resource be removed. Such an event is common for\n\
    \   limited-time, promotional services and for resources belonging to\n   individuals\
    \ no longer working at the server's site. It is not\n   necessary to mark all\
    \ permanently unavailable resources as \"gone\" or\n   to keep the mark for any\
    \ length of time -- that is left to the\n   discretion of the server owner.\n"
- title: 10.4.12 411 Length Required
  contents:
  - "10.4.12 411 Length Required\n   The server refuses to accept the request without\
    \ a defined Content-\n   Length. The client MAY repeat the request if it adds\
    \ a valid\n   Content-Length header field containing the length of the message-body\n\
    \   in the request message.\n"
- title: 10.4.13 412 Precondition Failed
  contents:
  - "10.4.13 412 Precondition Failed\n   The precondition given in one or more of\
    \ the request-header fields\n   evaluated to false when it was tested on the server.\
    \ This response\n   code allows the client to place preconditions on the current\
    \ resource\n   metainformation (header field data) and thus prevent the requested\n\
    \   method from being applied to a resource other than the one intended.\n"
- title: 10.4.14 413 Request Entity Too Large
  contents:
  - "10.4.14 413 Request Entity Too Large\n   The server is refusing to process a\
    \ request because the request\n   entity is larger than the server is willing\
    \ or able to process. The\n   server MAY close the connection to prevent the client\
    \ from continuing\n   the request.\n   If the condition is temporary, the server\
    \ SHOULD include a Retry-\n   After header field to indicate that it is temporary\
    \ and after what\n   time the client MAY try again.\n"
- title: 10.4.15 414 Request-URI Too Long
  contents:
  - "10.4.15 414 Request-URI Too Long\n   The server is refusing to service the request\
    \ because the Request-URI\n   is longer than the server is willing to interpret.\
    \ This rare\n   condition is only likely to occur when a client has improperly\n\
    \   converted a POST request to a GET request with long query\n   information,\
    \ when the client has descended into a URI \"black hole\" of\n   redirection (e.g.,\
    \ a redirected URI prefix that points to a suffix of\n   itself), or when the\
    \ server is under attack by a client attempting to\n   exploit security holes\
    \ present in some servers using fixed-length\n   buffers for reading or manipulating\
    \ the Request-URI.\n"
- title: 10.4.16 415 Unsupported Media Type
  contents:
  - "10.4.16 415 Unsupported Media Type\n   The server is refusing to service the\
    \ request because the entity of\n   the request is in a format not supported by\
    \ the requested resource\n   for the requested method.\n"
- title: 10.4.17 416 Requested Range Not Satisfiable
  contents:
  - "10.4.17 416 Requested Range Not Satisfiable\n   A server SHOULD return a response\
    \ with this status code if a request\n   included a Range request-header field\
    \ (section 14.35), and none of\n   the range-specifier values in this field overlap\
    \ the current extent\n   of the selected resource, and the request did not include\
    \ an If-Range\n   request-header field. (For byte-ranges, this means that the\
    \ first-\n   byte-pos of all of the byte-range-spec values were greater than the\n\
    \   current length of the selected resource.)\n   When this status code is returned\
    \ for a byte-range request, the\n   response SHOULD include a Content-Range entity-header\
    \ field\n   specifying the current length of the selected resource (see section\n\
    \   14.16). This response MUST NOT use the multipart/byteranges content-\n   type.\n"
- title: 10.4.18 417 Expectation Failed
  contents:
  - "10.4.18 417 Expectation Failed\n   The expectation given in an Expect request-header\
    \ field (see section\n   14.20) could not be met by this server, or, if the server\
    \ is a proxy,\n   the server has unambiguous evidence that the request could not\
    \ be met\n   by the next-hop server.\n"
- title: 10.5 Server Error 5xx
  contents:
  - "10.5 Server Error 5xx\n   Response status codes beginning with the digit \"5\"\
    \ indicate cases in\n   which the server is aware that it has erred or is incapable\
    \ of\n   performing the request. Except when responding to a HEAD request, the\n\
    \   server SHOULD include an entity containing an explanation of the\n   error\
    \ situation, and whether it is a temporary or permanent\n   condition. User agents\
    \ SHOULD display any included entity to the\n   user. These response codes are\
    \ applicable to any request method.\n"
- title: 10.5.1 500 Internal Server Error
  contents:
  - "10.5.1 500 Internal Server Error\n   The server encountered an unexpected condition\
    \ which prevented it\n   from fulfilling the request.\n"
- title: 10.5.2 501 Not Implemented
  contents:
  - "10.5.2 501 Not Implemented\n   The server does not support the functionality\
    \ required to fulfill the\n   request. This is the appropriate response when the\
    \ server does not\n   recognize the request method and is not capable of supporting\
    \ it for\n   any resource.\n"
- title: 10.5.3 502 Bad Gateway
  contents:
  - "10.5.3 502 Bad Gateway\n   The server, while acting as a gateway or proxy, received\
    \ an invalid\n   response from the upstream server it accessed in attempting to\n\
    \   fulfill the request.\n"
- title: 10.5.4 503 Service Unavailable
  contents:
  - "10.5.4 503 Service Unavailable\n   The server is currently unable to handle the\
    \ request due to a\n   temporary overloading or maintenance of the server. The\
    \ implication\n   is that this is a temporary condition which will be alleviated\
    \ after\n   some delay. If known, the length of the delay MAY be indicated in\
    \ a\n   Retry-After header. If no Retry-After is given, the client SHOULD\n  \
    \ handle the response as it would for a 500 response.\n      Note: The existence\
    \ of the 503 status code does not imply that a\n      server must use it when\
    \ becoming overloaded. Some servers may wish\n      to simply refuse the connection.\n"
- title: 10.5.5 504 Gateway Timeout
  contents:
  - "10.5.5 504 Gateway Timeout\n   The server, while acting as a gateway or proxy,\
    \ did not receive a\n   timely response from the upstream server specified by\
    \ the URI (e.g.\n   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS)\
    \ it needed\n   to access in attempting to complete the request.\n      Note:\
    \ Note to implementors: some deployed proxies are known to\n      return 400 or\
    \ 500 when DNS lookups time out.\n"
- title: 10.5.6 505 HTTP Version Not Supported
  contents:
  - "10.5.6 505 HTTP Version Not Supported\n   The server does not support, or refuses\
    \ to support, the HTTP protocol\n   version that was used in the request message.\
    \ The server is\n   indicating that it is unable or unwilling to complete the\
    \ request\n   using the same major version as the client, as described in section\n\
    \   3.1, other than with this error message. The response SHOULD contain\n   an\
    \ entity describing why that version is not supported and what other\n   protocols\
    \ are supported by that server.\n"
- title: 11 Access Authentication
  contents:
  - "11 Access Authentication\n   HTTP provides several OPTIONAL challenge-response\
    \ authentication\n   mechanisms which can be used by a server to challenge a client\n\
    \   request and by a client to provide authentication information. The\n   general\
    \ framework for access authentication, and the specification of\n   \"basic\"\
    \ and \"digest\" authentication, are specified in \"HTTP\n   Authentication: Basic\
    \ and Digest Access Authentication\" [43]. This\n   specification adopts the definitions\
    \ of \"challenge\" and \"credentials\"\n   from that specification.\n"
- title: 12 Content Negotiation
  contents:
  - "12 Content Negotiation\n   Most HTTP responses include an entity which contains\
    \ information for\n   interpretation by a human user. Naturally, it is desirable\
    \ to supply\n   the user with the \"best available\" entity corresponding to the\n\
    \   request. Unfortunately for servers and caches, not all users have the\n  \
    \ same preferences for what is \"best,\" and not all user agents are\n   equally\
    \ capable of rendering all entity types. For that reason, HTTP\n   has provisions\
    \ for several mechanisms for \"content negotiation\" --\n   the process of selecting\
    \ the best representation for a given response\n   when there are multiple representations\
    \ available.\n      Note: This is not called \"format negotiation\" because the\n\
    \      alternate representations may be of the same media type, but use\n    \
    \  different capabilities of that type, be in different languages,\n      etc.\n\
    \   Any response containing an entity-body MAY be subject to negotiation,\n  \
    \ including error responses.\n   There are two kinds of content negotiation which\
    \ are possible in\n   HTTP: server-driven and agent-driven negotiation. These\
    \ two kinds of\n   negotiation are orthogonal and thus may be used separately\
    \ or in\n   combination. One method of combination, referred to as transparent\n\
    \   negotiation, occurs when a cache uses the agent-driven negotiation\n   information\
    \ provided by the origin server in order to provide\n   server-driven negotiation\
    \ for subsequent requests.\n"
- title: 12.1 Server-driven Negotiation
  contents:
  - "12.1 Server-driven Negotiation\n   If the selection of the best representation\
    \ for a response is made by\n   an algorithm located at the server, it is called\
    \ server-driven\n   negotiation. Selection is based on the available representations\
    \ of\n   the response (the dimensions over which it can vary; e.g. language,\n\
    \   content-coding, etc.) and the contents of particular header fields in\n  \
    \ the request message or on other information pertaining to the request\n   (such\
    \ as the network address of the client).\n   Server-driven negotiation is advantageous\
    \ when the algorithm for\n   selecting from among the available representations\
    \ is difficult to\n   describe to the user agent, or when the server desires to\
    \ send its\n   \"best guess\" to the client along with the first response (hoping\
    \ to\n   avoid the round-trip delay of a subsequent request if the \"best\n  \
    \ guess\" is good enough for the user). In order to improve the server's\n   guess,\
    \ the user agent MAY include request header fields (Accept,\n   Accept-Language,\
    \ Accept-Encoding, etc.) which describe its\n   preferences for such a response.\n\
    \   Server-driven negotiation has disadvantages:\n      1. It is impossible for\
    \ the server to accurately determine what\n         might be \"best\" for any\
    \ given user, since that would require\n         complete knowledge of both the\
    \ capabilities of the user agent\n         and the intended use for the response\
    \ (e.g., does the user want\n         to view it on screen or print it on paper?).\n\
    \      2. Having the user agent describe its capabilities in every\n         request\
    \ can be both very inefficient (given that only a small\n         percentage of\
    \ responses have multiple representations) and a\n         potential violation\
    \ of the user's privacy.\n      3. It complicates the implementation of an origin\
    \ server and the\n         algorithms for generating responses to a request.\n\
    \      4. It may limit a public cache's ability to use the same response\n   \
    \      for multiple user's requests.\n   HTTP/1.1 includes the following request-header\
    \ fields for enabling\n   server-driven negotiation through description of user\
    \ agent\n   capabilities and user preferences: Accept (section 14.1), Accept-\n\
    \   Charset (section 14.2), Accept-Encoding (section 14.3), Accept-\n   Language\
    \ (section 14.4), and User-Agent (section 14.43). However, an\n   origin server\
    \ is not limited to these dimensions and MAY vary the\n   response based on any\
    \ aspect of the request, including information\n   outside the request-header\
    \ fields or within extension header fields\n   not defined by this specification.\n\
    \   The Vary  header field can be used to express the parameters the\n   server\
    \ uses to select a representation that is subject to server-\n   driven negotiation.\
    \ See section 13.6 for use of the Vary header field\n   by caches and section\
    \ 14.44 for use of the Vary header field by\n   servers.\n"
- title: 12.2 Agent-driven Negotiation
  contents:
  - "12.2 Agent-driven Negotiation\n   With agent-driven negotiation, selection of\
    \ the best representation\n   for a response is performed by the user agent after\
    \ receiving an\n   initial response from the origin server. Selection is based\
    \ on a list\n   of the available representations of the response included within\
    \ the\n   header fields or entity-body of the initial response, with each\n  \
    \ representation identified by its own URI. Selection from among the\n   representations\
    \ may be performed automatically (if the user agent is\n   capable of doing so)\
    \ or manually by the user selecting from a\n   generated (possibly hypertext)\
    \ menu.\n   Agent-driven negotiation is advantageous when the response would vary\n\
    \   over commonly-used dimensions (such as type, language, or encoding),\n   when\
    \ the origin server is unable to determine a user agent's\n   capabilities from\
    \ examining the request, and generally when public\n   caches are used to distribute\
    \ server load and reduce network usage.\n   Agent-driven negotiation suffers from\
    \ the disadvantage of needing a\n   second request to obtain the best alternate\
    \ representation. This\n   second request is only efficient when caching is used.\
    \ In addition,\n   this specification does not define any mechanism for supporting\n\
    \   automatic selection, though it also does not prevent any such\n   mechanism\
    \ from being developed as an extension and used within\n   HTTP/1.1.\n   HTTP/1.1\
    \ defines the 300 (Multiple Choices) and 406 (Not Acceptable)\n   status codes\
    \ for enabling agent-driven negotiation when the server is\n   unwilling or unable\
    \ to provide a varying response using server-driven\n   negotiation.\n"
- title: 12.3 Transparent Negotiation
  contents:
  - "12.3 Transparent Negotiation\n   Transparent negotiation is a combination of\
    \ both server-driven and\n   agent-driven negotiation. When a cache is supplied\
    \ with a form of the\n   list of available representations of the response (as\
    \ in agent-driven\n   negotiation) and the dimensions of variance are completely\
    \ understood\n   by the cache, then the cache becomes capable of performing server-\n\
    \   driven negotiation on behalf of the origin server for subsequent\n   requests\
    \ on that resource.\n   Transparent negotiation has the advantage of distributing\
    \ the\n   negotiation work that would otherwise be required of the origin\n  \
    \ server and also removing the second request delay of agent-driven\n   negotiation\
    \ when the cache is able to correctly guess the right\n   response.\n   This specification\
    \ does not define any mechanism for transparent\n   negotiation, though it also\
    \ does not prevent any such mechanism from\n   being developed as an extension\
    \ that could be used within HTTP/1.1.\n"
- title: 13 Caching in HTTP
  contents:
  - "13 Caching in HTTP\n   HTTP is typically used for distributed information systems,\
    \ where\n   performance can be improved by the use of response caches. The\n \
    \  HTTP/1.1 protocol includes a number of elements intended to make\n   caching\
    \ work as well as possible. Because these elements are\n   inextricable from other\
    \ aspects of the protocol, and because they\n   interact with each other, it is\
    \ useful to describe the basic caching\n   design of HTTP separately from the\
    \ detailed descriptions of methods,\n   headers, response codes, etc.\n   Caching\
    \ would be useless if it did not significantly improve\n   performance. The goal\
    \ of caching in HTTP/1.1 is to eliminate the need\n   to send requests in many\
    \ cases, and to eliminate the need to send\n   full responses in many other cases.\
    \ The former reduces the number of\n   network round-trips required for many operations;\
    \ we use an\n   \"expiration\" mechanism for this purpose (see section 13.2).\
    \ The\n   latter reduces network bandwidth requirements; we use a \"validation\"\
    \n   mechanism for this purpose (see section 13.3).\n   Requirements for performance,\
    \ availability, and disconnected\n   operation require us to be able to relax\
    \ the goal of semantic\n   transparency. The HTTP/1.1 protocol allows origin servers,\
    \ caches,\n   and clients to explicitly reduce transparency when necessary.\n\
    \   However, because non-transparent operation may confuse non-expert\n   users,\
    \ and might be incompatible with certain server applications\n   (such as those\
    \ for ordering merchandise), the protocol requires that\n   transparency be relaxed\n\
    \      - only by an explicit protocol-level request when relaxed by\n        client\
    \ or origin server\n      - only with an explicit warning to the end user when\
    \ relaxed by\n        cache or client\n   Therefore, the HTTP/1.1 protocol provides\
    \ these important elements:\n      1. Protocol features that provide full semantic\
    \ transparency when\n         this is required by all parties.\n      2. Protocol\
    \ features that allow an origin server or user agent to\n         explicitly request\
    \ and control non-transparent operation.\n      3. Protocol features that allow\
    \ a cache to attach warnings to\n         responses that do not preserve the requested\
    \ approximation of\n         semantic transparency.\n   A basic principle is that\
    \ it must be possible for the clients to\n   detect any potential relaxation of\
    \ semantic transparency.\n      Note: The server, cache, or client implementor\
    \ might be faced with\n      design decisions not explicitly discussed in this\
    \ specification.\n      If a decision might affect semantic transparency, the\
    \ implementor\n      ought to err on the side of maintaining transparency unless\
    \ a\n      careful and complete analysis shows significant benefits in\n     \
    \ breaking transparency.\n"
- title: 13.1.1 Cache Correctness
  contents:
  - "13.1.1 Cache Correctness\n   A correct cache MUST respond to a request with the\
    \ most up-to-date\n   response held by the cache that is appropriate to the request\
    \ (see\n   sections 13.2.5, 13.2.6, and 13.12) which meets one of the following\n\
    \   conditions:\n      1. It has been checked for equivalence with what the origin\
    \ server\n         would have returned by revalidating the response with the\n\
    \         origin server (section 13.3);\n      2. It is \"fresh enough\" (see\
    \ section 13.2). In the default case,\n         this means it meets the least\
    \ restrictive freshness requirement\n         of the client, origin server, and\
    \ cache (see section 14.9); if\n         the origin server so specifies, it is\
    \ the freshness requirement\n         of the origin server alone.\n         If\
    \ a stored response is not \"fresh enough\" by the most\n         restrictive\
    \ freshness requirement of both the client and the\n         origin server, in\
    \ carefully considered circumstances the cache\n         MAY still return the\
    \ response with the appropriate Warning\n         header (see section 13.1.5 and\
    \ 14.46), unless such a response\n         is prohibited (e.g., by a \"no-store\"\
    \ cache-directive, or by a\n         \"no-cache\" cache-request-directive; see\
    \ section 14.9).\n      3. It is an appropriate 304 (Not Modified), 305 (Proxy\
    \ Redirect),\n         or error (4xx or 5xx) response message.\n   If the cache\
    \ can not communicate with the origin server, then a\n   correct cache SHOULD\
    \ respond as above if the response can be\n   correctly served from the cache;\
    \ if not it MUST return an error or\n   warning indicating that there was a communication\
    \ failure.\n   If a cache receives a response (either an entire response, or a\
    \ 304\n   (Not Modified) response) that it would normally forward to the\n   requesting\
    \ client, and the received response is no longer fresh, the\n   cache SHOULD forward\
    \ it to the requesting client without adding a new\n   Warning (but without removing\
    \ any existing Warning headers). A cache\n   SHOULD NOT attempt to revalidate\
    \ a response simply because that\n   response became stale in transit; this might\
    \ lead to an infinite\n   loop. A user agent that receives a stale response without\
    \ a Warning\n   MAY display a warning indication to the user.\n"
- title: 13.1.2 Warnings
  contents:
  - "13.1.2 Warnings\n   Whenever a cache returns a response that is neither first-hand\
    \ nor\n   \"fresh enough\" (in the sense of condition 2 in section 13.1.1), it\n\
    \   MUST attach a warning to that effect, using a Warning general-header.\n  \
    \ The Warning header and the currently defined warnings are described\n   in section\
    \ 14.46. The warning allows clients to take appropriate\n   action.\n   Warnings\
    \ MAY be used for other purposes, both cache-related and\n   otherwise. The use\
    \ of a warning, rather than an error status code,\n   distinguish these responses\
    \ from true failures.\n   Warnings are assigned three digit warn-codes. The first\
    \ digit\n   indicates whether the Warning MUST or MUST NOT be deleted from a\n\
    \   stored cache entry after a successful revalidation:\n   1xx  Warnings that\
    \ describe the freshness or revalidation status of\n     the response, and so\
    \ MUST be deleted after a successful\n     revalidation. 1XX warn-codes MAY be\
    \ generated by a cache only when\n     validating a cached entry. It MUST NOT\
    \ be generated by clients.\n   2xx  Warnings that describe some aspect of the\
    \ entity body or entity\n     headers that is not rectified by a revalidation\
    \ (for example, a\n     lossy compression of the entity bodies) and which MUST\
    \ NOT be\n     deleted after a successful revalidation.\n   See section 14.46\
    \ for the definitions of the codes themselves.\n   HTTP/1.0 caches will cache\
    \ all Warnings in responses, without\n   deleting the ones in the first category.\
    \ Warnings in responses that\n   are passed to HTTP/1.0 caches carry an extra\
    \ warning-date field,\n   which prevents a future HTTP/1.1 recipient from believing\
    \ an\n   erroneously cached Warning.\n   Warnings also carry a warning text. The\
    \ text MAY be in any\n   appropriate natural language (perhaps based on the client's\
    \ Accept\n   headers), and include an OPTIONAL indication of what character set\
    \ is\n   used.\n   Multiple warnings MAY be attached to a response (either by\
    \ the origin\n   server or by a cache), including multiple warnings with the same\
    \ code\n   number. For example, a server might provide the same warning with\n\
    \   texts in both English and Basque.\n   When multiple warnings are attached\
    \ to a response, it might not be\n   practical or reasonable to display all of\
    \ them to the user. This\n   version of HTTP does not specify strict priority\
    \ rules for deciding\n   which warnings to display and in what order, but does\
    \ suggest some\n   heuristics.\n"
- title: 13.1.3 Cache-control Mechanisms
  contents:
  - "13.1.3 Cache-control Mechanisms\n   The basic cache mechanisms in HTTP/1.1 (server-specified\
    \ expiration\n   times and validators) are implicit directives to caches. In some\n\
    \   cases, a server or client might need to provide explicit directives\n   to\
    \ the HTTP caches. We use the Cache-Control header for this purpose.\n   The Cache-Control\
    \ header allows a client or server to transmit a\n   variety of directives in\
    \ either requests or responses. These\n   directives typically override the default\
    \ caching algorithms. As a\n   general rule, if there is any apparent conflict\
    \ between header\n   values, the most restrictive interpretation is applied (that\
    \ is, the\n   one that is most likely to preserve semantic transparency). However,\n\
    \   in some cases, cache-control directives are explicitly specified as\n   weakening\
    \ the approximation of semantic transparency (for example,\n   \"max-stale\" or\
    \ \"public\").\n   The cache-control directives are described in detail in section\
    \ 14.9.\n"
- title: 13.1.4 Explicit User Agent Warnings
  contents:
  - "13.1.4 Explicit User Agent Warnings\n   Many user agents make it possible for\
    \ users to override the basic\n   caching mechanisms. For example, the user agent\
    \ might allow the user\n   to specify that cached entities (even explicitly stale\
    \ ones) are\n   never validated. Or the user agent might habitually add \"Cache-\n\
    \   Control: max-stale=3600\" to every request. The user agent SHOULD NOT\n  \
    \ default to either non-transparent behavior, or behavior that results\n   in\
    \ abnormally ineffective caching, but MAY be explicitly configured\n   to do so\
    \ by an explicit action of the user.\n   If the user has overridden the basic\
    \ caching mechanisms, the user\n   agent SHOULD explicitly indicate to the user\
    \ whenever this results in\n   the display of information that might not meet\
    \ the server's\n   transparency requirements (in particular, if the displayed\
    \ entity is\n   known to be stale). Since the protocol normally allows the user\
    \ agent\n   to determine if responses are stale or not, this indication need only\n\
    \   be displayed when this actually happens. The indication need not be a\n  \
    \ dialog box; it could be an icon (for example, a picture of a rotting\n   fish)\
    \ or some other indicator.\n   If the user has overridden the caching mechanisms\
    \ in a way that would\n   abnormally reduce the effectiveness of caches, the user\
    \ agent SHOULD\n   continually indicate this state to the user (for example, by\
    \ a\n   display of a picture of currency in flames) so that the user does not\n\
    \   inadvertently consume excess resources or suffer from excessive\n   latency.\n"
- title: 13.1.5 Exceptions to the Rules and Warnings
  contents:
  - "13.1.5 Exceptions to the Rules and Warnings\n   In some cases, the operator of\
    \ a cache MAY choose to configure it to\n   return stale responses even when not\
    \ requested by clients. This\n   decision ought not be made lightly, but may be\
    \ necessary for reasons\n   of availability or performance, especially when the\
    \ cache is poorly\n   connected to the origin server. Whenever a cache returns\
    \ a stale\n   response, it MUST mark it as such (using a Warning header) enabling\n\
    \   the client software to alert the user that there might be a potential\n  \
    \ problem.\n   It also allows the user agent to take steps to obtain a first-hand\
    \ or\n   fresh response. For this reason, a cache SHOULD NOT return a stale\n\
    \   response if the client explicitly requests a first-hand or fresh one,\n  \
    \ unless it is impossible to comply for technical or policy reasons.\n"
- title: 13.1.6 Client-controlled Behavior
  contents:
  - "13.1.6 Client-controlled Behavior\n   While the origin server (and to a lesser\
    \ extent, intermediate caches,\n   by their contribution to the age of a response)\
    \ are the primary\n   source of expiration information, in some cases the client\
    \ might need\n   to control a cache's decision about whether to return a cached\n\
    \   response without validating it. Clients do this using several\n   directives\
    \ of the Cache-Control header.\n   A client's request MAY specify the maximum\
    \ age it is willing to\n   accept of an unvalidated response; specifying a value\
    \ of zero forces\n   the cache(s) to revalidate all responses. A client MAY also\
    \ specify\n   the minimum time remaining before a response expires. Both of these\n\
    \   options increase constraints on the behavior of caches, and so cannot\n  \
    \ further relax the cache's approximation of semantic transparency.\n   A client\
    \ MAY also specify that it will accept stale responses, up to\n   some maximum\
    \ amount of staleness. This loosens the constraints on the\n   caches, and so\
    \ might violate the origin server's specified\n   constraints on semantic transparency,\
    \ but might be necessary to\n   support disconnected operation, or high availability\
    \ in the face of\n   poor connectivity.\n"
- title: 13.2 Expiration Model
  contents:
  - '13.2 Expiration Model

    '
- title: 13.2.1 Server-Specified Expiration
  contents:
  - "13.2.1 Server-Specified Expiration\n   HTTP caching works best when caches can\
    \ entirely avoid making\n   requests to the origin server. The primary mechanism\
    \ for avoiding\n   requests is for an origin server to provide an explicit expiration\n\
    \   time in the future, indicating that a response MAY be used to satisfy\n  \
    \ subsequent requests. In other words, a cache can return a fresh\n   response\
    \ without first contacting the server.\n   Our expectation is that servers will\
    \ assign future explicit\n   expiration times to responses in the belief that\
    \ the entity is not\n   likely to change, in a semantically significant way, before\
    \ the\n   expiration time is reached. This normally preserves semantic\n   transparency,\
    \ as long as the server's expiration times are carefully\n   chosen.\n   The expiration\
    \ mechanism applies only to responses taken from a cache\n   and not to first-hand\
    \ responses forwarded immediately to the\n   requesting client.\n   If an origin\
    \ server wishes to force a semantically transparent cache\n   to validate every\
    \ request, it MAY assign an explicit expiration time\n   in the past. This means\
    \ that the response is always stale, and so the\n   cache SHOULD validate it before\
    \ using it for subsequent requests. See\n   section 14.9.4 for a more restrictive\
    \ way to force revalidation.\n   If an origin server wishes to force any HTTP/1.1\
    \ cache, no matter how\n   it is configured, to validate every request, it SHOULD\
    \ use the \"must-\n   revalidate\" cache-control directive (see section 14.9).\n\
    \   Servers specify explicit expiration times using either the Expires\n   header,\
    \ or the max-age directive of the Cache-Control header.\n   An expiration time\
    \ cannot be used to force a user agent to refresh\n   its display or reload a\
    \ resource; its semantics apply only to caching\n   mechanisms, and such mechanisms\
    \ need only check a resource's\n   expiration status when a new request for that\
    \ resource is initiated.\n   See section 13.13 for an explanation of the difference\
    \ between caches\n   and history mechanisms.\n"
- title: 13.2.2 Heuristic Expiration
  contents:
  - "13.2.2 Heuristic Expiration\n   Since origin servers do not always provide explicit\
    \ expiration times,\n   HTTP caches typically assign heuristic expiration times,\
    \ employing\n   algorithms that use other header values (such as the Last-Modified\n\
    \   time) to estimate a plausible expiration time. The HTTP/1.1\n   specification\
    \ does not provide specific algorithms, but does impose\n   worst-case constraints\
    \ on their results. Since heuristic expiration\n   times might compromise semantic\
    \ transparency, they ought to used\n   cautiously, and we encourage origin servers\
    \ to provide explicit\n   expiration times as much as possible.\n"
- title: 13.2.3 Age Calculations
  contents:
  - "13.2.3 Age Calculations\n   In order to know if a cached entry is fresh, a cache\
    \ needs to know if\n   its age exceeds its freshness lifetime. We discuss how\
    \ to calculate\n   the latter in section 13.2.4; this section describes how to\
    \ calculate\n   the age of a response or cache entry.\n   In this discussion,\
    \ we use the term \"now\" to mean \"the current value\n   of the clock at the\
    \ host performing the calculation.\" Hosts that use\n   HTTP, but especially hosts\
    \ running origin servers and caches, SHOULD\n   use NTP [28] or some similar protocol\
    \ to synchronize their clocks to\n   a globally accurate time standard.\n   HTTP/1.1\
    \ requires origin servers to send a Date header, if possible,\n   with every response,\
    \ giving the time at which the response was\n   generated (see section 14.18).\
    \ We use the term \"date_value\" to denote\n   the value of the Date header, in\
    \ a form appropriate for arithmetic\n   operations.\n   HTTP/1.1 uses the Age\
    \ response-header to convey the estimated age of\n   the response message when\
    \ obtained from a cache. The Age field value\n   is the cache's estimate of the\
    \ amount of time since the response was\n   generated or revalidated by the origin\
    \ server.\n   In essence, the Age value is the sum of the time that the response\n\
    \   has been resident in each of the caches along the path from the\n   origin\
    \ server, plus the amount of time it has been in transit along\n   network paths.\n\
    \   We use the term \"age_value\" to denote the value of the Age header, in\n\
    \   a form appropriate for arithmetic operations.\n   A response's age can be\
    \ calculated in two entirely independent ways:\n      1. now minus date_value,\
    \ if the local clock is reasonably well\n         synchronized to the origin server's\
    \ clock. If the result is\n         negative, the result is replaced by zero.\n\
    \      2. age_value, if all of the caches along the response path\n         implement\
    \ HTTP/1.1.\n   Given that we have two independent ways to compute the age of\
    \ a\n   response when it is received, we can combine these as\n       corrected_received_age\
    \ = max(now - date_value, age_value)\n   and as long as we have either nearly\
    \ synchronized clocks or all-\n   HTTP/1.1 paths, one gets a reliable (conservative)\
    \ result.\n   Because of network-imposed delays, some significant interval might\n\
    \   pass between the time that a server generates a response and the time\n  \
    \ it is received at the next outbound cache or client. If uncorrected,\n   this\
    \ delay could result in improperly low ages.\n   Because the request that resulted\
    \ in the returned Age value must have\n   been initiated prior to that Age value's\
    \ generation, we can correct\n   for delays imposed by the network by recording\
    \ the time at which the\n   request was initiated. Then, when an Age value is\
    \ received, it MUST\n   be interpreted relative to the time the request was initiated,\
    \ not\n   the time that the response was received. This algorithm results in\n\
    \   conservative behavior no matter how much delay is experienced. So, we\n  \
    \ compute:\n      corrected_initial_age = corrected_received_age\n           \
    \                 + (now - request_time)\n   where \"request_time\" is the time\
    \ (according to the local clock) when\n   the request that elicited this response\
    \ was sent.\n   Summary of age calculation algorithm, when a cache receives a\n\
    \   response:\n      /*\n       * age_value\n       *      is the value of Age:\
    \ header received by the cache with\n       *              this response.\n  \
    \     * date_value\n       *      is the value of the origin server's Date: header\n\
    \       * request_time\n       *      is the (local) time when the cache made\
    \ the request\n       *              that resulted in this cached response\n \
    \      * response_time\n       *      is the (local) time when the cache received\
    \ the\n       *              response\n       * now\n       *      is the current\
    \ (local) time\n       */\n      apparent_age = max(0, response_time - date_value);\n\
    \      corrected_received_age = max(apparent_age, age_value);\n      response_delay\
    \ = response_time - request_time;\n      corrected_initial_age = corrected_received_age\
    \ + response_delay;\n      resident_time = now - response_time;\n      current_age\
    \   = corrected_initial_age + resident_time;\n   The current_age of a cache entry\
    \ is calculated by adding the amount\n   of time (in seconds) since the cache\
    \ entry was last validated by the\n   origin server to the corrected_initial_age.\
    \ When a response is\n   generated from a cache entry, the cache MUST include\
    \ a single Age\n   header field in the response with a value equal to the cache\
    \ entry's\n   current_age.\n   The presence of an Age header field in a response\
    \ implies that a\n   response is not first-hand. However, the converse is not\
    \ true, since\n   the lack of an Age header field in a response does not imply\
    \ that the\n   response is first-hand unless all caches along the request path\
    \ are\n   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement\n\
    \   the Age header field).\n"
- title: 13.2.4 Expiration Calculations
  contents:
  - "13.2.4 Expiration Calculations\n   In order to decide whether a response is fresh\
    \ or stale, we need to\n   compare its freshness lifetime to its age. The age\
    \ is calculated as\n   described in section 13.2.3; this section describes how\
    \ to calculate\n   the freshness lifetime, and to determine if a response has\
    \ expired.\n   In the discussion below, the values can be represented in any form\n\
    \   appropriate for arithmetic operations.\n   We use the term \"expires_value\"\
    \ to denote the value of the Expires\n   header. We use the term \"max_age_value\"\
    \ to denote an appropriate\n   value of the number of seconds carried by the \"\
    max-age\" directive of\n   the Cache-Control header in a response (see section\
    \ 14.9.3).\n   The max-age directive takes priority over Expires, so if max-age\
    \ is\n   present in a response, the calculation is simply:\n      freshness_lifetime\
    \ = max_age_value\n   Otherwise, if Expires is present in the response, the calculation\
    \ is:\n      freshness_lifetime = expires_value - date_value\n   Note that neither\
    \ of these calculations is vulnerable to clock skew,\n   since all of the information\
    \ comes from the origin server.\n   If none of Expires, Cache-Control: max-age,\
    \ or Cache-Control: s-\n   maxage (see section 14.9.3) appears in the response,\
    \ and the response\n   does not include other restrictions on caching, the cache\
    \ MAY compute\n   a freshness lifetime using a heuristic. The cache MUST attach\
    \ Warning\n   113 to any response whose age is more than 24 hours if such warning\n\
    \   has not already been added.\n   Also, if the response does have a Last-Modified\
    \ time, the heuristic\n   expiration value SHOULD be no more than some fraction\
    \ of the interval\n   since that time. A typical setting of this fraction might\
    \ be 10%.\n   The calculation to determine if a response has expired is quite\n\
    \   simple:\n      response_is_fresh = (freshness_lifetime > current_age)\n"
- title: 13.2.5 Disambiguating Expiration Values
  contents:
  - "13.2.5 Disambiguating Expiration Values\n   Because expiration values are assigned\
    \ optimistically, it is possible\n   for two caches to contain fresh values for\
    \ the same resource that are\n   different.\n   If a client performing a retrieval\
    \ receives a non-first-hand response\n   for a request that was already fresh\
    \ in its own cache, and the Date\n   header in its existing cache entry is newer\
    \ than the Date on the new\n   response, then the client MAY ignore the response.\
    \ If so, it MAY\n   retry the request with a \"Cache-Control: max-age=0\" directive\
    \ (see\n   section 14.9), to force a check with the origin server.\n   If a cache\
    \ has two fresh responses for the same representation with\n   different validators,\
    \ it MUST use the one with the more recent Date\n   header. This situation might\
    \ arise because the cache is pooling\n   responses from other caches, or because\
    \ a client has asked for a\n   reload or a revalidation of an apparently fresh\
    \ cache entry.\n"
- title: 13.2.6 Disambiguating Multiple Responses
  contents:
  - "13.2.6 Disambiguating Multiple Responses\n   Because a client might be receiving\
    \ responses via multiple paths, so\n   that some responses flow through one set\
    \ of caches and other\n   responses flow through a different set of caches, a\
    \ client might\n   receive responses in an order different from that in which\
    \ the origin\n   server sent them. We would like the client to use the most recently\n\
    \   generated response, even if older responses are still apparently\n   fresh.\n\
    \   Neither the entity tag nor the expiration value can impose an\n   ordering\
    \ on responses, since it is possible that a later response\n   intentionally carries\
    \ an earlier expiration time. The Date values are\n   ordered to a granularity\
    \ of one second.\n   When a client tries to revalidate a cache entry, and the\
    \ response it\n   receives contains a Date header that appears to be older than\
    \ the one\n   for the existing entry, then the client SHOULD repeat the request\n\
    \   unconditionally, and include\n       Cache-Control: max-age=0\n   to force\
    \ any intermediate caches to validate their copies directly\n   with the origin\
    \ server, or\n       Cache-Control: no-cache\n   to force any intermediate caches\
    \ to obtain a new copy from the origin\n   server.\n   If the Date values are\
    \ equal, then the client MAY use either response\n   (or MAY, if it is being extremely\
    \ prudent, request a new response).\n   Servers MUST NOT depend on clients being\
    \ able to choose\n   deterministically between responses generated during the\
    \ same second,\n   if their expiration times overlap.\n"
- title: 13.3 Validation Model
  contents:
  - "13.3 Validation Model\n   When a cache has a stale entry that it would like to\
    \ use as a\n   response to a client's request, it first has to check with the\
    \ origin\n   server (or possibly an intermediate cache with a fresh response)\
    \ to\n   see if its cached entry is still usable. We call this \"validating\"\n\
    \   the cache entry. Since we do not want to have to pay the overhead of\n   retransmitting\
    \ the full response if the cached entry is good, and we\n   do not want to pay\
    \ the overhead of an extra round trip if the cached\n   entry is invalid, the\
    \ HTTP/1.1 protocol supports the use of\n   conditional methods.\n   The key protocol\
    \ features for supporting conditional methods are\n   those concerned with \"\
    cache validators.\" When an origin server\n   generates a full response, it attaches\
    \ some sort of validator to it,\n   which is kept with the cache entry. When a\
    \ client (user agent or\n   proxy cache) makes a conditional request for a resource\
    \ for which it\n   has a cache entry, it includes the associated validator in\
    \ the\n   request.\n   The server then checks that validator against the current\
    \ validator\n   for the entity, and, if they match (see section 13.3.3), it responds\n\
    \   with a special status code (usually, 304 (Not Modified)) and no\n   entity-body.\
    \ Otherwise, it returns a full response (including\n   entity-body). Thus, we\
    \ avoid transmitting the full response if the\n   validator matches, and we avoid\
    \ an extra round trip if it does not\n   match.\n   In HTTP/1.1, a conditional\
    \ request looks exactly the same as a normal\n   request for the same resource,\
    \ except that it carries a special\n   header (which includes the validator) that\
    \ implicitly turns the\n   method (usually, GET) into a conditional.\n   The protocol\
    \ includes both positive and negative senses of cache-\n   validating conditions.\
    \ That is, it is possible to request either that\n   a method be performed if\
    \ and only if a validator matches or if and\n   only if no validators match.\n\
    \      Note: a response that lacks a validator may still be cached, and\n    \
    \  served from cache until it expires, unless this is explicitly\n      prohibited\
    \ by a cache-control directive. However, a cache cannot\n      do a conditional\
    \ retrieval if it does not have a validator for the\n      entity, which means\
    \ it will not be refreshable after it expires.\n"
- title: 13.3.1 Last-Modified Dates
  contents:
  - "13.3.1 Last-Modified Dates\n   The Last-Modified entity-header field value is\
    \ often used as a cache\n   validator. In simple terms, a cache entry is considered\
    \ to be valid\n   if the entity has not been modified since the Last-Modified\
    \ value.\n"
- title: 13.3.2 Entity Tag Cache Validators
  contents:
  - "13.3.2 Entity Tag Cache Validators\n   The ETag response-header field value,\
    \ an entity tag, provides for an\n   \"opaque\" cache validator. This might allow\
    \ more reliable validation\n   in situations where it is inconvenient to store\
    \ modification dates,\n   where the one-second resolution of HTTP date values\
    \ is not\n   sufficient, or where the origin server wishes to avoid certain\n\
    \   paradoxes that might arise from the use of modification dates.\n   Entity\
    \ Tags are described in section 3.11. The headers used with\n   entity tags are\
    \ described in sections 14.19, 14.24, 14.26 and 14.44.\n"
- title: 13.3.3 Weak and Strong Validators
  contents:
  - "13.3.3 Weak and Strong Validators\n   Since both origin servers and caches will\
    \ compare two validators to\n   decide if they represent the same or different\
    \ entities, one normally\n   would expect that if the entity (the entity-body\
    \ or any entity-\n   headers) changes in any way, then the associated validator\
    \ would\n   change as well. If this is true, then we call this validator a\n \
    \  \"strong validator.\"\n   However, there might be cases when a server prefers\
    \ to change the\n   validator only on semantically significant changes, and not\
    \ when\n   insignificant aspects of the entity change. A validator that does not\n\
    \   always change when the resource changes is a \"weak validator.\"\n   Entity\
    \ tags are normally \"strong validators,\" but the protocol\n   provides a mechanism\
    \ to tag an entity tag as \"weak.\" One can think of\n   a strong validator as\
    \ one that changes whenever the bits of an entity\n   changes, while a weak value\
    \ changes whenever the meaning of an entity\n   changes. Alternatively, one can\
    \ think of a strong validator as part\n   of an identifier for a specific entity,\
    \ while a weak validator is\n   part of an identifier for a set of semantically\
    \ equivalent entities.\n      Note: One example of a strong validator is an integer\
    \ that is\n      incremented in stable storage every time an entity is changed.\n\
    \      An entity's modification time, if represented with one-second\n      resolution,\
    \ could be a weak validator, since it is possible that\n      the resource might\
    \ be modified twice during a single second.\n      Support for weak validators\
    \ is optional. However, weak validators\n      allow for more efficient caching\
    \ of equivalent objects; for\n      example, a hit counter on a site is probably\
    \ good enough if it is\n      updated every few days or weeks, and any value during\
    \ that period\n      is likely \"good enough\" to be equivalent.\n   A \"use\"\
    \ of a validator is either when a client generates a request\n   and includes\
    \ the validator in a validating header field, or when a\n   server compares two\
    \ validators.\n   Strong validators are usable in any context. Weak validators\
    \ are only\n   usable in contexts that do not depend on exact equality of an entity.\n\
    \   For example, either kind is usable for a conditional GET of a full\n   entity.\
    \ However, only a strong validator is usable for a sub-range\n   retrieval, since\
    \ otherwise the client might end up with an internally\n   inconsistent entity.\n\
    \   Clients MAY issue simple (non-subrange) GET requests with either weak\n  \
    \ validators or strong validators. Clients MUST NOT use weak validators\n   in\
    \ other forms of request.\n   The only function that the HTTP/1.1 protocol defines\
    \ on validators is\n   comparison. There are two validator comparison functions,\
    \ depending\n   on whether the comparison context allows the use of weak validators\n\
    \   or not:\n      - The strong comparison function: in order to be considered\
    \ equal,\n        both validators MUST be identical in every way, and both MUST\n\
    \        NOT be weak.\n      - The weak comparison function: in order to be considered\
    \ equal,\n        both validators MUST be identical in every way, but either or\n\
    \        both of them MAY be tagged as \"weak\" without affecting the\n      \
    \  result.\n   An entity tag is strong unless it is explicitly tagged as weak.\n\
    \   Section 3.11 gives the syntax for entity tags.\n   A Last-Modified time, when\
    \ used as a validator in a request, is\n   implicitly weak unless it is possible\
    \ to deduce that it is strong,\n   using the following rules:\n      - The validator\
    \ is being compared by an origin server to the\n        actual current validator\
    \ for the entity and,\n      - That origin server reliably knows that the associated\
    \ entity did\n        not change twice during the second covered by the presented\n\
    \        validator.\n   or\n      - The validator is about to be used by a client\
    \ in an If-\n        Modified-Since or If-Unmodified-Since header, because the\
    \ client\n        has a cache entry for the associated entity, and\n      - That\
    \ cache entry includes a Date value, which gives the time\n        when the origin\
    \ server sent the original response, and\n      - The presented Last-Modified\
    \ time is at least 60 seconds before\n        the Date value.\n   or\n      -\
    \ The validator is being compared by an intermediate cache to the\n        validator\
    \ stored in its cache entry for the entity, and\n      - That cache entry includes\
    \ a Date value, which gives the time\n        when the origin server sent the\
    \ original response, and\n      - The presented Last-Modified time is at least\
    \ 60 seconds before\n        the Date value.\n   This method relies on the fact\
    \ that if two different responses were\n   sent by the origin server during the\
    \ same second, but both had the\n   same Last-Modified time, then at least one\
    \ of those responses would\n   have a Date value equal to its Last-Modified time.\
    \ The arbitrary 60-\n   second limit guards against the possibility that the Date\
    \ and Last-\n   Modified values are generated from different clocks, or at somewhat\n\
    \   different times during the preparation of the response. An\n   implementation\
    \ MAY use a value larger than 60 seconds, if it is\n   believed that 60 seconds\
    \ is too short.\n   If a client wishes to perform a sub-range retrieval on a value\
    \ for\n   which it has only a Last-Modified time and no opaque validator, it\n\
    \   MAY do this only if the Last-Modified time is strong in the sense\n   described\
    \ here.\n   A cache or origin server receiving a conditional request, other than\n\
    \   a full-body GET request, MUST use the strong comparison function to\n   evaluate\
    \ the condition.\n   These rules allow HTTP/1.1 caches and clients to safely perform\
    \ sub-\n   range retrievals on values that have been obtained from HTTP/1.0\n\
    \   servers.\n"
- title: 13.3.4 Rules for When to Use Entity Tags and Last-Modified Dates
  contents:
  - "13.3.4 Rules for When to Use Entity Tags and Last-Modified Dates\n   We adopt\
    \ a set of rules and recommendations for origin servers,\n   clients, and caches\
    \ regarding when various validator types ought to\n   be used, and for what purposes.\n\
    \   HTTP/1.1 origin servers:\n      - SHOULD send an entity tag validator unless\
    \ it is not feasible to\n        generate one.\n      - MAY send a weak entity\
    \ tag instead of a strong entity tag, if\n        performance considerations support\
    \ the use of weak entity tags,\n        or if it is unfeasible to send a strong\
    \ entity tag.\n      - SHOULD send a Last-Modified value if it is feasible to\
    \ send one,\n        unless the risk of a breakdown in semantic transparency that\n\
    \        could result from using this date in an If-Modified-Since header\n  \
    \      would lead to serious problems.\n   In other words, the preferred behavior\
    \ for an HTTP/1.1 origin server\n   is to send both a strong entity tag and a\
    \ Last-Modified value.\n   In order to be legal, a strong entity tag MUST change\
    \ whenever the\n   associated entity value changes in any way. A weak entity tag\
    \ SHOULD\n   change whenever the associated entity changes in a semantically\n\
    \   significant way.\n      Note: in order to provide semantically transparent\
    \ caching, an\n      origin server must avoid reusing a specific strong entity\
    \ tag\n      value for two different entities, or reusing a specific weak\n  \
    \    entity tag value for two semantically different entities. Cache\n      entries\
    \ might persist for arbitrarily long periods, regardless of\n      expiration\
    \ times, so it might be inappropriate to expect that a\n      cache will never\
    \ again attempt to validate an entry using a\n      validator that it obtained\
    \ at some point in the past.\n   HTTP/1.1 clients:\n      - If an entity tag has\
    \ been provided by the origin server, MUST\n        use that entity tag in any\
    \ cache-conditional request (using If-\n        Match or If-None-Match).\n   \
    \   - If only a Last-Modified value has been provided by the origin\n        server,\
    \ SHOULD use that value in non-subrange cache-conditional\n        requests (using\
    \ If-Modified-Since).\n      - If only a Last-Modified value has been provided\
    \ by an HTTP/1.0\n        origin server, MAY use that value in subrange cache-conditional\n\
    \        requests (using If-Unmodified-Since:). The user agent SHOULD\n      \
    \  provide a way to disable this, in case of difficulty.\n      - If both an entity\
    \ tag and a Last-Modified value have been\n        provided by the origin server,\
    \ SHOULD use both validators in\n        cache-conditional requests. This allows\
    \ both HTTP/1.0 and\n        HTTP/1.1 caches to respond appropriately.\n   An\
    \ HTTP/1.1 origin server, upon receiving a conditional request that\n   includes\
    \ both a Last-Modified date (e.g., in an If-Modified-Since or\n   If-Unmodified-Since\
    \ header field) and one or more entity tags (e.g.,\n   in an If-Match, If-None-Match,\
    \ or If-Range header field) as cache\n   validators, MUST NOT return a response\
    \ status of 304 (Not Modified)\n   unless doing so is consistent with all of the\
    \ conditional header\n   fields in the request.\n   An HTTP/1.1 caching proxy,\
    \ upon receiving a conditional request that\n   includes both a Last-Modified\
    \ date and one or more entity tags as\n   cache validators, MUST NOT return a\
    \ locally cached response to the\n   client unless that cached response is consistent\
    \ with all of the\n   conditional header fields in the request.\n      Note: The\
    \ general principle behind these rules is that HTTP/1.1\n      servers and clients\
    \ should transmit as much non-redundant\n      information as is available in\
    \ their responses and requests.\n      HTTP/1.1 systems receiving this information\
    \ will make the most\n      conservative assumptions about the validators they\
    \ receive.\n      HTTP/1.0 clients and caches will ignore entity tags. Generally,\n\
    \      last-modified values received or used by these systems will\n      support\
    \ transparent and efficient caching, and so HTTP/1.1 origin\n      servers should\
    \ provide Last-Modified values. In those rare cases\n      where the use of a\
    \ Last-Modified value as a validator by an\n      HTTP/1.0 system could result\
    \ in a serious problem, then HTTP/1.1\n      origin servers should not provide\
    \ one.\n"
- title: 13.3.5 Non-validating Conditionals
  contents:
  - "13.3.5 Non-validating Conditionals\n   The principle behind entity tags is that\
    \ only the service author\n   knows the semantics of a resource well enough to\
    \ select an\n   appropriate cache validation mechanism, and the specification\
    \ of any\n   validator comparison function more complex than byte-equality would\n\
    \   open up a can of worms. Thus, comparisons of any other headers\n   (except\
    \ Last-Modified, for compatibility with HTTP/1.0) are never\n   used for purposes\
    \ of validating a cache entry.\n"
- title: 13.4 Response Cacheability
  contents:
  - "13.4 Response Cacheability\n   Unless specifically constrained by a cache-control\
    \ (section 14.9)\n   directive, a caching system MAY always store a successful\
    \ response\n   (see section 13.8) as a cache entry, MAY return it without validation\n\
    \   if it is fresh, and MAY return it after successful validation. If\n   there\
    \ is neither a cache validator nor an explicit expiration time\n   associated\
    \ with a response, we do not expect it to be cached, but\n   certain caches MAY\
    \ violate this expectation (for example, when little\n   or no network connectivity\
    \ is available). A client can usually detect\n   that such a response was taken\
    \ from a cache by comparing the Date\n   header to the current time.\n      Note:\
    \ some HTTP/1.0 caches are known to violate this expectation\n      without providing\
    \ any Warning.\n   However, in some cases it might be inappropriate for a cache\
    \ to\n   retain an entity, or to return it in response to a subsequent\n   request.\
    \ This might be because absolute semantic transparency is\n   deemed necessary\
    \ by the service author, or because of security or\n   privacy considerations.\
    \ Certain cache-control directives are\n   therefore provided so that the server\
    \ can indicate that certain\n   resource entities, or portions thereof, are not\
    \ to be cached\n   regardless of other considerations.\n   Note that section 14.8\
    \ normally prevents a shared cache from saving\n   and returning a response to\
    \ a previous request if that request\n   included an Authorization header.\n \
    \  A response received with a status code of 200, 203, 206, 300, 301 or\n   410\
    \ MAY be stored by a cache and used in reply to a subsequent\n   request, subject\
    \ to the expiration mechanism, unless a cache-control\n   directive prohibits\
    \ caching. However, a cache that does not support\n   the Range and Content-Range\
    \ headers MUST NOT cache 206 (Partial\n   Content) responses.\n   A response received\
    \ with any other status code (e.g. status codes 302\n   and 307) MUST NOT be returned\
    \ in a reply to a subsequent request\n   unless there are cache-control directives\
    \ or another header(s) that\n   explicitly allow it. For example, these include\
    \ the following: an\n   Expires header (section 14.21); a \"max-age\", \"s-maxage\"\
    ,  \"must-\n   revalidate\", \"proxy-revalidate\", \"public\" or \"private\" cache-control\n\
    \   directive (section 14.9).\n"
- title: 13.5 Constructing Responses From Caches
  contents:
  - "13.5 Constructing Responses From Caches\n   The purpose of an HTTP cache is to\
    \ store information received in\n   response to requests for use in responding\
    \ to future requests. In\n   many cases, a cache simply returns the appropriate\
    \ parts of a\n   response to the requester. However, if the cache holds a cache\
    \ entry\n   based on a previous response, it might have to combine parts of a\
    \ new\n   response with what is held in the cache entry.\n"
- title: 13.5.1 End-to-end and Hop-by-hop Headers
  contents:
  - "13.5.1 End-to-end and Hop-by-hop Headers\n   For the purpose of defining the\
    \ behavior of caches and non-caching\n   proxies, we divide HTTP headers into\
    \ two categories:\n      - End-to-end headers, which are  transmitted to the ultimate\n\
    \        recipient of a request or response. End-to-end headers in\n        responses\
    \ MUST be stored as part of a cache entry and MUST be\n        transmitted in\
    \ any response formed from a cache entry.\n      - Hop-by-hop headers, which are\
    \ meaningful only for a single\n        transport-level connection, and are not\
    \ stored by caches or\n        forwarded by proxies.\n   The following HTTP/1.1\
    \ headers are hop-by-hop headers:\n      - Connection\n      - Keep-Alive\n  \
    \    - Proxy-Authenticate\n      - Proxy-Authorization\n      - TE\n      - Trailers\n\
    \      - Transfer-Encoding\n      - Upgrade\n   All other headers defined by HTTP/1.1\
    \ are end-to-end headers.\n   Other hop-by-hop headers MUST be listed in a Connection\
    \ header,\n   (section 14.10) to be introduced into HTTP/1.1 (or later).\n"
- title: 13.5.2 Non-modifiable Headers
  contents:
  - "13.5.2 Non-modifiable Headers\n   Some features of the HTTP/1.1 protocol, such\
    \ as Digest\n   Authentication, depend on the value of certain end-to-end headers.\
    \ A\n   transparent proxy SHOULD NOT modify an end-to-end header unless the\n\
    \   definition of that header requires or specifically allows that.\n   A transparent\
    \ proxy MUST NOT modify any of the following fields in a\n   request or response,\
    \ and it MUST NOT add any of these fields if not\n   already present:\n      -\
    \ Content-Location\n      - Content-MD5\n      - ETag\n      - Last-Modified\n\
    \   A transparent proxy MUST NOT modify any of the following fields in a\n   response:\n\
    \      - Expires\n   but it MAY add any of these fields if not already present.\
    \ If an\n   Expires header is added, it MUST be given a field-value identical\
    \ to\n   that of the Date header in that response.\n   A  proxy MUST NOT modify\
    \ or add any of the following fields in a\n   message that contains the no-transform\
    \ cache-control directive, or in\n   any request:\n      - Content-Encoding\n\
    \      - Content-Range\n      - Content-Type\n   A non-transparent proxy MAY modify\
    \ or add these fields to a message\n   that does not include no-transform, but\
    \ if it does so, it MUST add a\n   Warning 214 (Transformation applied) if one\
    \ does not already appear\n   in the message (see section 14.46).\n      Warning:\
    \ unnecessary modification of end-to-end headers might\n      cause authentication\
    \ failures if stronger authentication\n      mechanisms are introduced in later\
    \ versions of HTTP. Such\n      authentication mechanisms MAY rely on the values\
    \ of header fields\n      not listed here.\n   The Content-Length field of a request\
    \ or response is added or deleted\n   according to the rules in section 4.4. A\
    \ transparent proxy MUST\n   preserve the entity-length (section 7.2.2) of the\
    \ entity-body,\n   although it MAY change the transfer-length (section 4.4).\n"
- title: 13.5.3 Combining Headers
  contents:
  - "13.5.3 Combining Headers\n   When a cache makes a validating request to a server,\
    \ and the server\n   provides a 304 (Not Modified) response or a 206 (Partial\
    \ Content)\n   response, the cache then constructs a response to send to the\n\
    \   requesting client.\n   If the status code is 304 (Not Modified), the cache\
    \ uses the entity-\n   body stored in the cache entry as the entity-body of this\
    \ outgoing\n   response. If the status code is 206 (Partial Content) and the ETag\
    \ or\n   Last-Modified headers match exactly, the cache MAY combine the\n   contents\
    \ stored in the cache entry with the new contents received in\n   the response\
    \ and use the result as the entity-body of this outgoing\n   response, (see 13.5.4).\n\
    \   The end-to-end headers stored in the cache entry are used for the\n   constructed\
    \ response, except that\n      - any stored Warning headers with warn-code 1xx\
    \ (see section\n        14.46) MUST be deleted from the cache entry and the forwarded\n\
    \        response.\n      - any stored Warning headers with warn-code 2xx MUST\
    \ be retained\n        in the cache entry and the forwarded response.\n      -\
    \ any end-to-end headers provided in the 304 or 206 response MUST\n        replace\
    \ the corresponding headers from the cache entry.\n   Unless the cache decides\
    \ to remove the cache entry, it MUST also\n   replace the end-to-end headers stored\
    \ with the cache entry with\n   corresponding headers received in the incoming\
    \ response, except for\n   Warning headers as described immediately above. If\
    \ a header field-\n   name in the incoming response matches more than one header\
    \ in the\n   cache entry, all such old headers MUST be replaced.\n   In other\
    \ words, the set of end-to-end headers received in the\n   incoming response overrides\
    \ all corresponding end-to-end headers\n   stored with the cache entry (except\
    \ for stored Warning headers with\n   warn-code 1xx, which are deleted even if\
    \ not overridden).\n      Note: this rule allows an origin server to use a 304\
    \ (Not\n      Modified) or a 206 (Partial Content) response to update any header\n\
    \      associated with a previous response for the same entity or sub-\n     \
    \ ranges thereof, although it might not always be meaningful or\n      correct\
    \ to do so. This rule does not allow an origin server to use\n      a 304 (Not\
    \ Modified) or a 206 (Partial Content) response to\n      entirely delete a header\
    \ that it had provided with a previous\n      response.\n"
- title: 13.5.4 Combining Byte Ranges
  contents:
  - "13.5.4 Combining Byte Ranges\n   A response might transfer only a subrange of\
    \ the bytes of an entity-\n   body, either because the request included one or\
    \ more Range\n   specifications, or because a connection was broken prematurely.\
    \ After\n   several such transfers, a cache might have received several ranges\
    \ of\n   the same entity-body.\n   If a cache has a stored non-empty set of subranges\
    \ for an entity, and\n   an incoming response transfers another subrange, the\
    \ cache MAY\n   combine the new subrange with the existing set if both the following\n\
    \   conditions are met:\n      - Both the incoming response and the cache entry\
    \ have a cache\n        validator.\n      - The two cache validators match using\
    \ the strong comparison\n        function (see section 13.3.3).\n   If either\
    \ requirement is not met, the cache MUST use only the most\n   recent partial\
    \ response (based on the Date values transmitted with\n   every response, and\
    \ using the incoming response if these values are\n   equal or missing), and MUST\
    \ discard the other partial information.\n"
- title: 13.6 Caching Negotiated Responses
  contents:
  - "13.6 Caching Negotiated Responses\n   Use of server-driven content negotiation\
    \ (section 12.1), as indicated\n   by the presence of a Vary header field in a\
    \ response, alters the\n   conditions and procedure by which a cache can use the\
    \ response for\n   subsequent requests. See section 14.44 for use of the Vary\
    \ header\n   field by servers.\n   A server SHOULD use the Vary header field to\
    \ inform a cache of what\n   request-header fields were used to select among multiple\n\
    \   representations of a cacheable response subject to server-driven\n   negotiation.\
    \ The set of header fields named by the Vary field value\n   is known as the \"\
    selecting\" request-headers.\n   When the cache receives a subsequent request\
    \ whose Request-URI\n   specifies one or more cache entries including a Vary header\
    \ field,\n   the cache MUST NOT use such a cache entry to construct a response\
    \ to\n   the new request unless all of the selecting request-headers present\n\
    \   in the new request match the corresponding stored request-headers in\n   the\
    \ original request.\n   The selecting request-headers from two requests are defined\
    \ to match\n   if and only if the selecting request-headers in the first request\
    \ can\n   be transformed to the selecting request-headers in the second request\n\
    \   by adding or removing linear white space (LWS) at places where this\n   is\
    \ allowed by the corresponding BNF, and/or combining multiple\n   message-header\
    \ fields with the same field name following the rules\n   about message headers\
    \ in section 4.2.\n   A Vary header field-value of \"*\" always fails to match\
    \ and subsequent\n   requests on that resource can only be properly interpreted\
    \ by the\n   origin server.\n   If the selecting request header fields for the\
    \ cached entry do not\n   match the selecting request header fields of the new\
    \ request, then\n   the cache MUST NOT use a cached entry to satisfy the request\
    \ unless\n   it first relays the new request to the origin server in a conditional\n\
    \   request and the server responds with 304 (Not Modified), including an\n  \
    \ entity tag or Content-Location that indicates the entity to be used.\n   If\
    \ an entity tag was assigned to a cached representation, the\n   forwarded request\
    \ SHOULD be conditional and include the entity tags\n   in an If-None-Match header\
    \ field from all its cache entries for the\n   resource. This conveys to the server\
    \ the set of entities currently\n   held by the cache, so that if any one of these\
    \ entities matches the\n   requested entity, the server can use the ETag header\
    \ field in its 304\n   (Not Modified) response to tell the cache which entry is\
    \ appropriate.\n   If the entity-tag of the new response matches that of an existing\n\
    \   entry, the new response SHOULD be used to update the header fields of\n  \
    \ the existing entry, and the result MUST be returned to the client.\n   If any\
    \ of the existing cache entries contains only partial content\n   for the associated\
    \ entity, its entity-tag SHOULD NOT be included in\n   the If-None-Match header\
    \ field unless the request is for a range that\n   would be fully satisfied by\
    \ that entry.\n   If a cache receives a successful response whose Content-Location\n\
    \   field matches that of an existing cache entry for the same Request-\n   ]URI,\
    \ whose entity-tag differs from that of the existing entry, and\n   whose Date\
    \ is more recent than that of the existing entry, the\n   existing entry SHOULD\
    \ NOT be returned in response to future requests\n   and SHOULD be deleted from\
    \ the cache.\n"
- title: 13.7 Shared and Non-Shared Caches
  contents:
  - "13.7 Shared and Non-Shared Caches\n   For reasons of security and privacy, it\
    \ is necessary to make a\n   distinction between \"shared\" and \"non-shared\"\
    \ caches. A non-shared\n   cache is one that is accessible only to a single user.\
    \ Accessibility\n   in this case SHOULD be enforced by appropriate security mechanisms.\n\
    \   All other caches are considered to be \"shared.\" Other sections of\n   this\
    \ specification place certain constraints on the operation of\n   shared caches\
    \ in order to prevent loss of privacy or failure of\n   access controls.\n"
- title: 13.8 Errors or Incomplete Response Cache Behavior
  contents:
  - "13.8 Errors or Incomplete Response Cache Behavior\n   A cache that receives an\
    \ incomplete response (for example, with fewer\n   bytes of data than specified\
    \ in a Content-Length header) MAY store\n   the response. However, the cache MUST\
    \ treat this as a partial\n   response. Partial responses MAY be combined as described\
    \ in section\n   13.5.4; the result might be a full response or might still be\n\
    \   partial. A cache MUST NOT return a partial response to a client\n   without\
    \ explicitly marking it as such, using the 206 (Partial\n   Content) status code.\
    \ A cache MUST NOT return a partial response\n   using a status code of 200 (OK).\n\
    \   If a cache receives a 5xx response while attempting to revalidate an\n   entry,\
    \ it MAY either forward this response to the requesting client,\n   or act as\
    \ if the server failed to respond. In the latter case, it MAY\n   return a previously\
    \ received response unless the cached entry\n   includes the \"must-revalidate\"\
    \ cache-control directive (see section\n   14.9).\n"
- title: 13.9 Side Effects of GET and HEAD
  contents:
  - "13.9 Side Effects of GET and HEAD\n   Unless the origin server explicitly prohibits\
    \ the caching of their\n   responses, the application of GET and HEAD methods\
    \ to any resources\n   SHOULD NOT have side effects that would lead to erroneous\
    \ behavior if\n   these responses are taken from a cache. They MAY still have\
    \ side\n   effects, but a cache is not required to consider such side effects\
    \ in\n   its caching decisions. Caches are always expected to observe an\n   origin\
    \ server's explicit restrictions on caching.\n   We note one exception to this\
    \ rule: since some applications have\n   traditionally used GETs and HEADs with\
    \ query URLs (those containing a\n   \"?\" in the rel_path part) to perform operations\
    \ with significant side\n   effects, caches MUST NOT treat responses to such URIs\
    \ as fresh unless\n   the server provides an explicit expiration time. This specifically\n\
    \   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT\n   be\
    \ taken from a cache. See section 9.1.1 for related information.\n"
- title: 13.10 Invalidation After Updates or Deletions
  contents:
  - "13.10 Invalidation After Updates or Deletions\n   The effect of certain methods\
    \ performed on a resource at the origin\n   server might cause one or more existing\
    \ cache entries to become non-\n   transparently invalid. That is, although they\
    \ might continue to be\n   \"fresh,\" they do not accurately reflect what the\
    \ origin server would\n   return for a new request on that resource.\n   There\
    \ is no way for the HTTP protocol to guarantee that all such\n   cache entries\
    \ are marked invalid. For example, the request that\n   caused the change at the\
    \ origin server might not have gone through\n   the proxy where a cache entry\
    \ is stored. However, several rules help\n   reduce the likelihood of erroneous\
    \ behavior.\n   In this section, the phrase \"invalidate an entity\" means that\
    \ the\n   cache will either remove all instances of that entity from its\n   storage,\
    \ or will mark these as \"invalid\" and in need of a mandatory\n   revalidation\
    \ before they can be returned in response to a subsequent\n   request.\n   Some\
    \ HTTP methods MUST cause a cache to invalidate an entity. This is\n   either\
    \ the entity referred to by the Request-URI, or by the Location\n   or Content-Location\
    \ headers (if present). These methods are:\n      - PUT\n      - DELETE\n    \
    \  - POST\n   In order to prevent denial of service attacks, an invalidation based\n\
    \   on the URI in a Location or Content-Location header MUST only be\n   performed\
    \ if the host part is the same as in the Request-URI.\n   A cache that passes\
    \ through requests for methods it does not\n   understand SHOULD invalidate any\
    \ entities referred to by the\n   Request-URI.\n"
- title: 13.11 Write-Through Mandatory
  contents:
  - "13.11 Write-Through Mandatory\n   All methods that might be expected to cause\
    \ modifications to the\n   origin server's resources MUST be written through to\
    \ the origin\n   server. This currently includes all methods except for GET and\
    \ HEAD.\n   A cache MUST NOT reply to such a request from a client before having\n\
    \   transmitted the request to the inbound server, and having received a\n   corresponding\
    \ response from the inbound server. This does not prevent\n   a proxy cache from\
    \ sending a 100 (Continue) response before the\n   inbound server has sent its\
    \ final reply.\n   The alternative (known as \"write-back\" or \"copy-back\" caching)\
    \ is not\n   allowed in HTTP/1.1, due to the difficulty of providing consistent\n\
    \   updates and the problems arising from server, cache, or network\n   failure\
    \ prior to write-back.\n"
- title: 13.12 Cache Replacement
  contents:
  - "13.12 Cache Replacement\n   If a new cacheable (see sections 14.9.2, 13.2.5,\
    \ 13.2.6 and 13.8)\n   response is received from a resource while any existing\
    \ responses for\n   the same resource are cached, the cache SHOULD use the new\
    \ response\n   to reply to the current request. It MAY insert it into cache storage\n\
    \   and MAY, if it meets all other requirements, use it to respond to any\n  \
    \ future requests that would previously have caused the old response to\n   be\
    \ returned. If it inserts the new response into cache storage  the\n   rules in\
    \ section 13.5.3 apply.\n      Note: a new response that has an older Date header\
    \ value than\n      existing cached responses is not cacheable.\n"
- title: 13.13 History Lists
  contents:
  - "13.13 History Lists\n   User agents often have history mechanisms, such as \"\
    Back\" buttons and\n   history lists, which can be used to redisplay an entity\
    \ retrieved\n   earlier in a session.\n   History mechanisms and caches are different.\
    \ In particular history\n   mechanisms SHOULD NOT try to show a semantically transparent\
    \ view of\n   the current state of a resource. Rather, a history mechanism is\
    \ meant\n   to show exactly what the user saw at the time when the resource was\n\
    \   retrieved.\n   By default, an expiration time does not apply to history mechanisms.\n\
    \   If the entity is still in storage, a history mechanism SHOULD display\n  \
    \ it even if the entity has expired, unless the user has specifically\n   configured\
    \ the agent to refresh expired history documents.\n   This is not to be construed\
    \ to prohibit the history mechanism from\n   telling the user that a view might\
    \ be stale.\n      Note: if history list mechanisms unnecessarily prevent users\
    \ from\n      viewing stale resources, this will tend to force service authors\n\
    \      to avoid using HTTP expiration controls and cache controls when\n     \
    \ they would otherwise like to. Service authors may consider it\n      important\
    \ that users not be presented with error messages or\n      warning messages when\
    \ they use navigation controls (such as BACK)\n      to view previously fetched\
    \ resources. Even though sometimes such\n      resources ought not to cached,\
    \ or ought to expire quickly, user\n      interface considerations may force service\
    \ authors to resort to\n      other means of preventing caching (e.g. \"once-only\"\
    \ URLs) in order\n      not to suffer the effects of improperly functioning history\n\
    \      mechanisms.\n"
- title: 14 Header Field Definitions
  contents:
  - "14 Header Field Definitions\n   This section defines the syntax and semantics\
    \ of all standard\n   HTTP/1.1 header fields. For entity-header fields, both sender\
    \ and\n   recipient refer to either the client or the server, depending on who\n\
    \   sends and who receives the entity.\n"
- title: 14.1 Accept
  contents:
  - "14.1 Accept\n   The Accept request-header field can be used to specify certain\
    \ media\n   types which are acceptable for the response. Accept headers can be\n\
    \   used to indicate that the request is specifically limited to a small\n   set\
    \ of desired types, as in the case of a request for an in-line\n   image.\n  \
    \     Accept         = \"Accept\" \":\"\n                        #( media-range\
    \ [ accept-params ] )\n       media-range    = ( \"*/*\"\n                   \
    \     | ( type \"/\" \"*\" )\n                        | ( type \"/\" subtype )\n\
    \                        ) *( \";\" parameter )\n       accept-params  = \";\"\
    \ \"q\" \"=\" qvalue *( accept-extension )\n       accept-extension = \";\" token\
    \ [ \"=\" ( token | quoted-string ) ]\n   The asterisk \"*\" character is used\
    \ to group media types into ranges,\n   with \"*/*\" indicating all media types\
    \ and \"type/*\" indicating all\n   subtypes of that type. The media-range MAY\
    \ include media type\n   parameters that are applicable to that range.\n   Each\
    \ media-range MAY be followed by one or more accept-params,\n   beginning with\
    \ the \"q\" parameter for indicating a relative quality\n   factor. The first\
    \ \"q\" parameter (if any) separates the media-range\n   parameter(s) from the\
    \ accept-params. Quality factors allow the user\n   or user agent to indicate\
    \ the relative degree of preference for that\n   media-range, using the qvalue\
    \ scale from 0 to 1 (section 3.9). The\n   default value is q=1.\n      Note:\
    \ Use of the \"q\" parameter name to separate media type\n      parameters from\
    \ Accept extension parameters is due to historical\n      practice. Although this\
    \ prevents any media type parameter named\n      \"q\" from being used with a\
    \ media range, such an event is believed\n      to be unlikely given the lack\
    \ of any \"q\" parameters in the IANA\n      media type registry and the rare\
    \ usage of any media type\n      parameters in Accept. Future media types are\
    \ discouraged from\n      registering any parameter named \"q\".\n   The example\n\
    \       Accept: audio/*; q=0.2, audio/basic\n   SHOULD be interpreted as \"I prefer\
    \ audio/basic, but send me any audio\n   type if it is the best available after\
    \ an 80% mark-down in quality.\"\n   If no Accept header field is present, then\
    \ it is assumed that the\n   client accepts all media types. If an Accept header\
    \ field is present,\n   and if the server cannot send a response which is acceptable\n\
    \   according to the combined Accept field value, then the server SHOULD\n   send\
    \ a 406 (not acceptable) response.\n   A more elaborate example is\n       Accept:\
    \ text/plain; q=0.5, text/html,\n               text/x-dvi; q=0.8, text/x-c\n\
    \   Verbally, this would be interpreted as \"text/html and text/x-c are\n   the\
    \ preferred media types, but if they do not exist, then send the\n   text/x-dvi\
    \ entity, and if that does not exist, send the text/plain\n   entity.\"\n   Media\
    \ ranges can be overridden by more specific media ranges or\n   specific media\
    \ types. If more than one media range applies to a given\n   type, the most specific\
    \ reference has precedence. For example,\n       Accept: text/*, text/html, text/html;level=1,\
    \ */*\n   have the following precedence:\n       1) text/html;level=1\n      \
    \ 2) text/html\n       3) text/*\n       4) */*\n   The media type quality factor\
    \ associated with a given type is\n   determined by finding the media range with\
    \ the highest precedence\n   which matches that type. For example,\n       Accept:\
    \ text/*;q=0.3, text/html;q=0.7, text/html;level=1,\n               text/html;level=2;q=0.4,\
    \ */*;q=0.5\n   would cause the following values to be associated:\n       text/html;level=1\
    \         = 1\n       text/html                 = 0.7\n       text/plain     \
    \           = 0.3\n       image/jpeg                = 0.5\n       text/html;level=2\
    \         = 0.4\n       text/html;level=3         = 0.7\n      Note: A user agent\
    \ might be provided with a default set of quality\n      values for certain media\
    \ ranges. However, unless the user agent is\n      a closed system which cannot\
    \ interact with other rendering agents,\n      this default set ought to be configurable\
    \ by the user.\n"
- title: 14.2 Accept-Charset
  contents:
  - "14.2 Accept-Charset\n   The Accept-Charset request-header field can be used to\
    \ indicate what\n   character sets are acceptable for the response. This field\
    \ allows\n   clients capable of understanding more comprehensive or special-\n\
    \   purpose character sets to signal that capability to a server which is\n  \
    \ capable of representing documents in those character sets.\n      Accept-Charset\
    \ = \"Accept-Charset\" \":\"\n              1#( ( charset | \"*\" )[ \";\" \"\
    q\" \"=\" qvalue ] )\n   Character set values are described in section 3.4. Each\
    \ charset MAY\n   be given an associated quality value which represents the user's\n\
    \   preference for that charset. The default value is q=1. An example is\n   \
    \   Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n   The special value \"*\"\
    , if present in the Accept-Charset field,\n   matches every character set (including\
    \ ISO-8859-1) which is not\n   mentioned elsewhere in the Accept-Charset field.\
    \ If no \"*\" is present\n   in an Accept-Charset field, then all character sets\
    \ not explicitly\n   mentioned get a quality value of 0, except for ISO-8859-1,\
    \ which gets\n   a quality value of 1 if not explicitly mentioned.\n   If no Accept-Charset\
    \ header is present, the default is that any\n   character set is acceptable.\
    \ If an Accept-Charset header is present,\n   and if the server cannot send a\
    \ response which is acceptable\n   according to the Accept-Charset header, then\
    \ the server SHOULD send\n   an error response with the 406 (not acceptable) status\
    \ code, though\n   the sending of an unacceptable response is also allowed.\n"
- title: 14.3 Accept-Encoding
  contents:
  - "14.3 Accept-Encoding\n   The Accept-Encoding request-header field is similar\
    \ to Accept, but\n   restricts the content-codings (section 3.5) that are acceptable\
    \ in\n   the response.\n       Accept-Encoding  = \"Accept-Encoding\" \":\"\n\
    \                          1#( codings [ \";\" \"q\" \"=\" qvalue ] )\n      \
    \ codings          = ( content-coding | \"*\" )\n   Examples of its use are:\n\
    \       Accept-Encoding: compress, gzip\n       Accept-Encoding:\n       Accept-Encoding:\
    \ *\n       Accept-Encoding: compress;q=0.5, gzip;q=1.0\n       Accept-Encoding:\
    \ gzip;q=1.0, identity; q=0.5, *;q=0\n   A server tests whether a content-coding\
    \ is acceptable, according to\n   an Accept-Encoding field, using these rules:\n\
    \      1. If the content-coding is one of the content-codings listed in\n    \
    \     the Accept-Encoding field, then it is acceptable, unless it is\n       \
    \  accompanied by a qvalue of 0. (As defined in section 3.9, a\n         qvalue\
    \ of 0 means \"not acceptable.\")\n      2. The special \"*\" symbol in an Accept-Encoding\
    \ field matches any\n         available content-coding not explicitly listed in\
    \ the header\n         field.\n      3. If multiple content-codings are acceptable,\
    \ then the acceptable\n         content-coding with the highest non-zero qvalue\
    \ is preferred.\n      4. The \"identity\" content-coding is always acceptable,\
    \ unless\n         specifically refused because the Accept-Encoding field includes\n\
    \         \"identity;q=0\", or because the field includes \"*;q=0\" and does\n\
    \         not explicitly include the \"identity\" content-coding. If the\n   \
    \      Accept-Encoding field-value is empty, then only the \"identity\"\n    \
    \     encoding is acceptable.\n   If an Accept-Encoding field is present in a\
    \ request, and if the\n   server cannot send a response which is acceptable according\
    \ to the\n   Accept-Encoding header, then the server SHOULD send an error response\n\
    \   with the 406 (Not Acceptable) status code.\n   If no Accept-Encoding field\
    \ is present in a request, the server MAY\n   assume that the client will accept\
    \ any content coding. In this case,\n   if \"identity\" is one of the available\
    \ content-codings, then the\n   server SHOULD use the \"identity\" content-coding,\
    \ unless it has\n   additional information that a different content-coding is\
    \ meaningful\n   to the client.\n      Note: If the request does not include an\
    \ Accept-Encoding field,\n      and if the \"identity\" content-coding is unavailable,\
    \ then\n      content-codings commonly understood by HTTP/1.0 clients (i.e.,\n\
    \      \"gzip\" and \"compress\") are preferred; some older clients\n      improperly\
    \ display messages sent with other content-codings.  The\n      server might also\
    \ make this decision based on information about\n      the particular user-agent\
    \ or client.\n      Note: Most HTTP/1.0 applications do not recognize or obey\
    \ qvalues\n      associated with content-codings. This means that qvalues will\
    \ not\n      work and are not permitted with x-gzip or x-compress.\n"
- title: 14.4 Accept-Language
  contents:
  - "14.4 Accept-Language\n   The Accept-Language request-header field is similar\
    \ to Accept, but\n   restricts the set of natural languages that are preferred\
    \ as a\n   response to the request. Language tags are defined in section 3.10.\n\
    \       Accept-Language = \"Accept-Language\" \":\"\n                        \
    \ 1#( language-range [ \";\" \"q\" \"=\" qvalue ] )\n       language-range  =\
    \ ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) | \"*\" )\n   Each language-range MAY be\
    \ given an associated quality value which\n   represents an estimate of the user's\
    \ preference for the languages\n   specified by that range. The quality value\
    \ defaults to \"q=1\". For\n   example,\n       Accept-Language: da, en-gb;q=0.8,\
    \ en;q=0.7\n   would mean: \"I prefer Danish, but will accept British English\
    \ and\n   other types of English.\" A language-range matches a language-tag if\n\
    \   it exactly equals the tag, or if it exactly equals a prefix of the\n   tag\
    \ such that the first tag character following the prefix is \"-\".\n   The special\
    \ range \"*\", if present in the Accept-Language field,\n   matches every tag\
    \ not matched by any other range present in the\n   Accept-Language field.\n \
    \     Note: This use of a prefix matching rule does not imply that\n      language\
    \ tags are assigned to languages in such a way that it is\n      always true that\
    \ if a user understands a language with a certain\n      tag, then this user will\
    \ also understand all languages with tags\n      for which this tag is a prefix.\
    \ The prefix rule simply allows the\n      use of prefix tags if this is the case.\n\
    \   The language quality factor assigned to a language-tag by the\n   Accept-Language\
    \ field is the quality value of the longest language-\n   range in the field that\
    \ matches the language-tag. If no language-\n   range in the field matches the\
    \ tag, the language quality factor\n   assigned is 0. If no Accept-Language header\
    \ is present in the\n   request, the server\n   SHOULD assume that all languages\
    \ are equally acceptable. If an\n   Accept-Language header is present, then all\
    \ languages which are\n   assigned a quality factor greater than 0 are acceptable.\n\
    \   It might be contrary to the privacy expectations of the user to send\n   an\
    \ Accept-Language header with the complete linguistic preferences of\n   the user\
    \ in every request. For a discussion of this issue, see\n   section 15.1.4.\n\
    \   As intelligibility is highly dependent on the individual user, it is\n   recommended\
    \ that client applications make the choice of linguistic\n   preference available\
    \ to the user. If the choice is not made\n   available, then the Accept-Language\
    \ header field MUST NOT be given in\n   the request.\n      Note: When making\
    \ the choice of linguistic preference available to\n      the user, we remind\
    \ implementors of  the fact that users are not\n      familiar with the details\
    \ of language matching as described above,\n      and should provide appropriate\
    \ guidance. As an example, users\n      might assume that on selecting \"en-gb\"\
    , they will be served any\n      kind of English document if British English is\
    \ not available. A\n      user agent might suggest in such a case to add \"en\"\
    \ to get the\n      best matching behavior.\n"
- title: 14.5 Accept-Ranges
  contents:
  - "14.5 Accept-Ranges\n      The Accept-Ranges response-header field allows the\
    \ server to\n      indicate its acceptance of range requests for a resource:\n\
    \          Accept-Ranges     = \"Accept-Ranges\" \":\" acceptable-ranges\n   \
    \       acceptable-ranges = 1#range-unit | \"none\"\n      Origin servers that\
    \ accept byte-range requests MAY send\n          Accept-Ranges: bytes\n      but\
    \ are not required to do so. Clients MAY generate byte-range\n      requests without\
    \ having received this header for the resource\n      involved. Range units are\
    \ defined in section 3.12.\n      Servers that do not accept any kind of range\
    \ request for a\n      resource MAY send\n          Accept-Ranges: none\n    \
    \  to advise the client not to attempt a range request.\n"
- title: 14.6 Age
  contents:
  - "14.6 Age\n      The Age response-header field conveys the sender's estimate of\
    \ the\n      amount of time since the response (or its revalidation) was\n   \
    \   generated at the origin server. A cached response is \"fresh\" if\n      its\
    \ age does not exceed its freshness lifetime. Age values are\n      calculated\
    \ as specified in section 13.2.3.\n           Age = \"Age\" \":\" age-value\n\
    \           age-value = delta-seconds\n      Age values are non-negative decimal\
    \ integers, representing time in\n      seconds.\n      If a cache receives a\
    \ value larger than the largest positive\n      integer it can represent, or if\
    \ any of its age calculations\n      overflows, it MUST transmit an Age header\
    \ with a value of\n      2147483648 (2^31). An HTTP/1.1 server that includes a\
    \ cache MUST\n      include an Age header field in every response generated from\
    \ its\n      own cache. Caches SHOULD use an arithmetic type of at least 31\n\
    \      bits of range.\n"
- title: 14.7 Allow
  contents:
  - "14.7 Allow\n      The Allow entity-header field lists the set of methods supported\n\
    \      by the resource identified by the Request-URI. The purpose of this\n  \
    \    field is strictly to inform the recipient of valid methods\n      associated\
    \ with the resource. An Allow header field MUST be\n      present in a 405 (Method\
    \ Not Allowed) response.\n          Allow   = \"Allow\" \":\" #Method\n      Example\
    \ of use:\n          Allow: GET, HEAD, PUT\n      This field cannot prevent a\
    \ client from trying other methods.\n      However, the indications given by the\
    \ Allow header field value\n      SHOULD be followed. The actual set of allowed\
    \ methods is defined\n      by the origin server at the time of each request.\n\
    \      The Allow header field MAY be provided with a PUT request to\n      recommend\
    \ the methods to be supported by the new or modified\n      resource. The server\
    \ is not required to support these methods and\n      SHOULD include an Allow\
    \ header in the response giving the actual\n      supported methods.\n      A\
    \ proxy MUST NOT modify the Allow header field even if it does not\n      understand\
    \ all the methods specified, since the user agent might\n      have other means\
    \ of communicating with the origin server.\n"
- title: 14.8 Authorization
  contents:
  - "14.8 Authorization\n      A user agent that wishes to authenticate itself with\
    \ a server--\n      usually, but not necessarily, after receiving a 401 response--does\n\
    \      so by including an Authorization request-header field with the\n      request.\
    \  The Authorization field value consists of credentials\n      containing the\
    \ authentication information of the user agent for\n      the realm of the resource\
    \ being requested.\n          Authorization  = \"Authorization\" \":\" credentials\n\
    \      HTTP access authentication is described in \"HTTP Authentication:\n   \
    \   Basic and Digest Access Authentication\" [43]. If a request is\n      authenticated\
    \ and a realm specified, the same credentials SHOULD\n      be valid for all other\
    \ requests within this realm (assuming that\n      the authentication scheme itself\
    \ does not require otherwise, such\n      as credentials that vary according to\
    \ a challenge value or using\n      synchronized clocks).\n      When a shared\
    \ cache (see section 13.7) receives a request\n      containing an Authorization\
    \ field, it MUST NOT return the\n      corresponding response as a reply to any\
    \ other request, unless one\n      of the following specific exceptions holds:\n\
    \      1. If the response includes the \"s-maxage\" cache-control\n         directive,\
    \ the cache MAY use that response in replying to a\n         subsequent request.\
    \ But (if the specified maximum age has\n         passed) a proxy cache MUST first\
    \ revalidate it with the origin\n         server, using the request-headers from\
    \ the new request to allow\n         the origin server to authenticate the new\
    \ request. (This is the\n         defined behavior for s-maxage.) If the response\
    \ includes \"s-\n         maxage=0\", the proxy MUST always revalidate it before\
    \ re-using\n         it.\n      2. If the response includes the \"must-revalidate\"\
    \ cache-control\n         directive, the cache MAY use that response in replying\
    \ to a\n         subsequent request. But if the response is stale, all caches\n\
    \         MUST first revalidate it with the origin server, using the\n       \
    \  request-headers from the new request to allow the origin server\n         to\
    \ authenticate the new request.\n      3. If the response includes the \"public\"\
    \ cache-control directive,\n         it MAY be returned in reply to any subsequent\
    \ request.\n"
- title: 14.9 Cache-Control
  contents:
  - "14.9 Cache-Control\n   The Cache-Control general-header field is used to specify\
    \ directives\n   that MUST be obeyed by all caching mechanisms along the\n   request/response\
    \ chain. The directives specify behavior intended to\n   prevent caches from adversely\
    \ interfering with the request or\n   response. These directives typically override\
    \ the default caching\n   algorithms. Cache directives are unidirectional in that\
    \ the presence\n   of a directive in a request does not imply that the same directive\
    \ is\n   to be given in the response.\n      Note that HTTP/1.0 caches might not\
    \ implement Cache-Control and\n      might only implement Pragma: no-cache (see\
    \ section 14.32).\n   Cache directives MUST be passed through by a proxy or gateway\n\
    \   application, regardless of their significance to that application,\n   since\
    \ the directives might be applicable to all recipients along the\n   request/response\
    \ chain. It is not possible to specify a cache-\n   directive for a specific cache.\n\
    \    Cache-Control   = \"Cache-Control\" \":\" 1#cache-directive\n    cache-directive\
    \ = cache-request-directive\n         | cache-response-directive\n    cache-request-directive\
    \ =\n           \"no-cache\"                          ; Section 14.9.1\n     \
    \    | \"no-store\"                          ; Section 14.9.2\n         | \"max-age\"\
    \ \"=\" delta-seconds         ; Section 14.9.3, 14.9.4\n         | \"max-stale\"\
    \ [ \"=\" delta-seconds ]   ; Section 14.9.3\n         | \"min-fresh\" \"=\" delta-seconds\
    \       ; Section 14.9.3\n         | \"no-transform\"                      ; Section\
    \ 14.9.5\n         | \"only-if-cached\"                    ; Section 14.9.4\n\
    \         | cache-extension                     ; Section 14.9.6\n     cache-response-directive\
    \ =\n           \"public\"                               ; Section 14.9.1\n  \
    \       | \"private\" [ \"=\" <\"> 1#field-name <\"> ] ; Section 14.9.1\n    \
    \     | \"no-cache\" [ \"=\" <\"> 1#field-name <\"> ]; Section 14.9.1\n      \
    \   | \"no-store\"                             ; Section 14.9.2\n         | \"\
    no-transform\"                         ; Section 14.9.5\n         | \"must-revalidate\"\
    \                      ; Section 14.9.4\n         | \"proxy-revalidate\"     \
    \                ; Section 14.9.4\n         | \"max-age\" \"=\" delta-seconds\
    \            ; Section 14.9.3\n         | \"s-maxage\" \"=\" delta-seconds   \
    \        ; Section 14.9.3\n         | cache-extension                        ;\
    \ Section 14.9.6\n    cache-extension = token [ \"=\" ( token | quoted-string\
    \ ) ]\n   When a directive appears without any 1#field-name parameter, the\n \
    \  directive applies to the entire request or response. When such a\n   directive\
    \ appears with a 1#field-name parameter, it applies only to\n   the named field\
    \ or fields, and not to the rest of the request or\n   response. This mechanism\
    \ supports extensibility; implementations of\n   future versions of the HTTP protocol\
    \ might apply these directives to\n   header fields not defined in HTTP/1.1.\n\
    \   The cache-control directives can be broken down into these general\n   categories:\n\
    \      - Restrictions on what are cacheable; these may only be imposed by\n  \
    \      the origin server.\n      - Restrictions on what may be stored by a cache;\
    \ these may be\n        imposed by either the origin server or the user agent.\n\
    \      - Modifications of the basic expiration mechanism; these may be\n     \
    \   imposed by either the origin server or the user agent.\n      - Controls over\
    \ cache revalidation and reload; these may only be\n        imposed by a user\
    \ agent.\n      - Control over transformation of entities.\n      - Extensions\
    \ to the caching system.\n"
- title: 14.9.1 What is Cacheable
  contents:
  - "14.9.1 What is Cacheable\n   By default, a response is cacheable if the requirements\
    \ of the\n   request method, request header fields, and the response status\n\
    \   indicate that it is cacheable. Section 13.4 summarizes these defaults\n  \
    \ for cacheability. The following Cache-Control response directives\n   allow\
    \ an origin server to override the default cacheability of a\n   response:\n \
    \  public\n      Indicates that the response MAY be cached by any cache, even\
    \ if it\n      would normally be non-cacheable or cacheable only within a non-\n\
    \      shared cache. (See also Authorization, section 14.8, for\n      additional\
    \ details.)\n   private\n      Indicates that all or part of the response message\
    \ is intended for\n      a single user and MUST NOT be cached by a shared cache.\
    \ This\n      allows an origin server to state that the specified parts of the\n\
    \      response are intended for only one user and are not a valid\n      response\
    \ for requests by other users. A private (non-shared) cache\n      MAY cache the\
    \ response.\n       Note: This usage of the word private only controls where the\n\
    \       response may be cached, and cannot ensure the privacy of the\n       message\
    \ content.\n   no-cache\n       If the no-cache directive does not specify a field-name,\
    \ then a\n      cache MUST NOT use the response to satisfy a subsequent request\n\
    \      without successful revalidation with the origin server. This\n      allows\
    \ an origin server to prevent caching even by caches that\n      have been configured\
    \ to return stale responses to client requests.\n      If the no-cache directive\
    \ does specify one or more field-names,\n      then a cache MAY use the response\
    \ to satisfy a subsequent request,\n      subject to any other restrictions on\
    \ caching. However, the\n      specified field-name(s) MUST NOT be sent in the\
    \ response to a\n      subsequent request without successful revalidation with\
    \ the origin\n      server. This allows an origin server to prevent the re-use\
    \ of\n      certain header fields in a response, while still allowing caching\n\
    \      of the rest of the response.\n       Note: Most HTTP/1.0 caches will not\
    \ recognize or obey this\n       directive.\n"
- title: 14.9.2 What May be Stored by Caches
  contents:
  - "14.9.2 What May be Stored by Caches\n   no-store\n      The purpose of the no-store\
    \ directive is to prevent the\n      inadvertent release or retention of sensitive\
    \ information (for\n      example, on backup tapes). The no-store directive applies\
    \ to the\n      entire message, and MAY be sent either in a response or in a\n\
    \      request. If sent in a request, a cache MUST NOT store any part of\n   \
    \   either this request or any response to it. If sent in a response,\n      a\
    \ cache MUST NOT store any part of either this response or the\n      request\
    \ that elicited it. This directive applies to both non-\n      shared and shared\
    \ caches. \"MUST NOT store\" in this context means\n      that the cache MUST\
    \ NOT intentionally store the information in\n      non-volatile storage, and\
    \ MUST make a best-effort attempt to\n      remove the information from volatile\
    \ storage as promptly as\n      possible after forwarding it.\n      Even when\
    \ this directive is associated with a response, users\n      might explicitly\
    \ store such a response outside of the caching\n      system (e.g., with a \"\
    Save As\" dialog). History buffers MAY store\n      such responses as part of\
    \ their normal operation.\n      The purpose of this directive is to meet the\
    \ stated requirements\n      of certain users and service authors who are concerned\
    \ about\n      accidental releases of information via unanticipated accesses to\n\
    \      cache data structures. While the use of this directive might\n      improve\
    \ privacy in some cases, we caution that it is NOT in any\n      way a reliable\
    \ or sufficient mechanism for ensuring privacy. In\n      particular, malicious\
    \ or compromised caches might not recognize or\n      obey this directive, and\
    \ communications networks might be\n      vulnerable to eavesdropping.\n"
- title: 14.9.3 Modifications of the Basic Expiration Mechanism
  contents:
  - "14.9.3 Modifications of the Basic Expiration Mechanism\n   The expiration time\
    \ of an entity MAY be specified by the origin\n   server using the Expires header\
    \ (see section 14.21). Alternatively,\n   it MAY be specified using the max-age\
    \ directive in a response. When\n   the max-age cache-control directive is present\
    \ in a cached response,\n   the response is stale if its current age is greater\
    \ than the age\n   value given (in seconds) at the time of a new request for that\n\
    \   resource. The max-age directive on a response implies that the\n   response\
    \ is cacheable (i.e., \"public\") unless some other, more\n   restrictive cache\
    \ directive is also present.\n   If a response includes both an Expires header\
    \ and a max-age\n   directive, the max-age directive overrides the Expires header,\
    \ even\n   if the Expires header is more restrictive. This rule allows an origin\n\
    \   server to provide, for a given response, a longer expiration time to\n   an\
    \ HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be\n   useful\
    \ if certain HTTP/1.0 caches improperly calculate ages or\n   expiration times,\
    \ perhaps due to desynchronized clocks.\n   Many HTTP/1.0 cache implementations\
    \ will treat an Expires value that\n   is less than or equal to the response Date\
    \ value as being equivalent\n   to the Cache-Control response directive \"no-cache\"\
    . If an HTTP/1.1\n   cache receives such a response, and the response does not\
    \ include a\n   Cache-Control header field, it SHOULD consider the response to\
    \ be\n   non-cacheable in order to retain compatibility with HTTP/1.0 servers.\n\
    \       Note: An origin server might wish to use a relatively new HTTP\n     \
    \  cache control feature, such as the \"private\" directive, on a\n       network\
    \ including older caches that do not understand that\n       feature. The origin\
    \ server will need to combine the new feature\n       with an Expires field whose\
    \ value is less than or equal to the\n       Date value. This will prevent older\
    \ caches from improperly\n       caching the response.\n   s-maxage\n       If\
    \ a response includes an s-maxage directive, then for a shared\n       cache (but\
    \ not for a private cache), the maximum age specified by\n       this directive\
    \ overrides the maximum age specified by either the\n       max-age directive\
    \ or the Expires header. The s-maxage directive\n       also implies the semantics\
    \ of the proxy-revalidate directive (see\n       section 14.9.4), i.e., that the\
    \ shared cache must not use the\n       entry after it becomes stale to respond\
    \ to a subsequent request\n       without first revalidating it with the origin\
    \ server. The s-\n       maxage directive is always ignored by a private cache.\n\
    \   Note that most older caches, not compliant with this specification,\n   do\
    \ not implement any cache-control directives. An origin server\n   wishing to\
    \ use a cache-control directive that restricts, but does not\n   prevent, caching\
    \ by an HTTP/1.1-compliant cache MAY exploit the\n   requirement that the max-age\
    \ directive overrides the Expires header,\n   and the fact that pre-HTTP/1.1-compliant\
    \ caches do not observe the\n   max-age directive.\n   Other directives allow\
    \ a user agent to modify the basic expiration\n   mechanism. These directives\
    \ MAY be specified on a request:\n   max-age\n      Indicates that the client\
    \ is willing to accept a response whose\n      age is no greater than the specified\
    \ time in seconds. Unless max-\n      stale directive is also included, the client\
    \ is not willing to\n      accept a stale response.\n   min-fresh\n      Indicates\
    \ that the client is willing to accept a response whose\n      freshness lifetime\
    \ is no less than its current age plus the\n      specified time in seconds. That\
    \ is, the client wants a response\n      that will still be fresh for at least\
    \ the specified number of\n      seconds.\n   max-stale\n      Indicates that\
    \ the client is willing to accept a response that has\n      exceeded its expiration\
    \ time. If max-stale is assigned a value,\n      then the client is willing to\
    \ accept a response that has exceeded\n      its expiration time by no more than\
    \ the specified number of\n      seconds. If no value is assigned to max-stale,\
    \ then the client is\n      willing to accept a stale response of any age.\n \
    \  If a cache returns a stale response, either because of a max-stale\n   directive\
    \ on a request, or because the cache is configured to\n   override the expiration\
    \ time of a response, the cache MUST attach a\n   Warning header to the stale\
    \ response, using Warning 110 (Response is\n   stale).\n   A cache MAY be configured\
    \ to return stale responses without\n   validation, but only if this does not\
    \ conflict with any \"MUST\"-level\n   requirements concerning cache validation\
    \ (e.g., a \"must-revalidate\"\n   cache-control directive).\n   If both the new\
    \ request and the cached entry include \"max-age\"\n   directives, then the lesser\
    \ of the two values is used for determining\n   the freshness of the cached entry\
    \ for that request.\n"
- title: 14.9.4 Cache Revalidation and Reload Controls
  contents:
  - "14.9.4 Cache Revalidation and Reload Controls\n   Sometimes a user agent might\
    \ want or need to insist that a cache\n   revalidate its cache entry with the\
    \ origin server (and not just with\n   the next cache along the path to the origin\
    \ server), or to reload its\n   cache entry from the origin server. End-to-end\
    \ revalidation might be\n   necessary if either the cache or the origin server\
    \ has overestimated\n   the expiration time of the cached response. End-to-end\
    \ reload may be\n   necessary if the cache entry has become corrupted for some\
    \ reason.\n   End-to-end revalidation may be requested either when the client\
    \ does\n   not have its own local cached copy, in which case we call it\n   \"\
    unspecified end-to-end revalidation\", or when the client does have a\n   local\
    \ cached copy, in which case we call it \"specific end-to-end\n   revalidation.\"\
    \n   The client can specify these three kinds of action using Cache-\n   Control\
    \ request directives:\n   End-to-end reload\n      The request includes a \"no-cache\"\
    \ cache-control directive or, for\n      compatibility with HTTP/1.0 clients,\
    \ \"Pragma: no-cache\". Field\n      names MUST NOT be included with the no-cache\
    \ directive in a\n      request. The server MUST NOT use a cached copy when responding\
    \ to\n      such a request.\n   Specific end-to-end revalidation\n      The request\
    \ includes a \"max-age=0\" cache-control directive, which\n      forces each cache\
    \ along the path to the origin server to\n      revalidate its own entry, if any,\
    \ with the next cache or server.\n      The initial request includes a cache-validating\
    \ conditional with\n      the client's current validator.\n   Unspecified end-to-end\
    \ revalidation\n      The request includes \"max-age=0\" cache-control directive,\
    \ which\n      forces each cache along the path to the origin server to\n    \
    \  revalidate its own entry, if any, with the next cache or server.\n      The\
    \ initial request does not include a cache-validating\n      conditional; the\
    \ first cache along the path (if any) that holds a\n      cache entry for this\
    \ resource includes a cache-validating\n      conditional with its current validator.\n\
    \   max-age\n      When an intermediate cache is forced, by means of a max-age=0\n\
    \      directive, to revalidate its own cache entry, and the client has\n    \
    \  supplied its own validator in the request, the supplied validator\n      might\
    \ differ from the validator currently stored with the cache\n      entry. In this\
    \ case, the cache MAY use either validator in making\n      its own request without\
    \ affecting semantic transparency.\n      However, the choice of validator might\
    \ affect performance. The\n      best approach is for the intermediate cache to\
    \ use its own\n      validator when making its request. If the server replies\
    \ with 304\n      (Not Modified), then the cache can return its now validated\
    \ copy\n      to the client with a 200 (OK) response. If the server replies with\n\
    \      a new entity and cache validator, however, the intermediate cache\n   \
    \   can compare the returned validator with the one provided in the\n      client's\
    \ request, using the strong comparison function. If the\n      client's validator\
    \ is equal to the origin server's, then the\n      intermediate cache simply returns\
    \ 304 (Not Modified). Otherwise,\n      it returns the new entity with a 200 (OK)\
    \ response.\n      If a request includes the no-cache directive, it SHOULD NOT\n\
    \      include min-fresh, max-stale, or max-age.\n   only-if-cached\n      In\
    \ some cases, such as times of extremely poor network\n      connectivity, a client\
    \ may want a cache to return only those\n      responses that it currently has\
    \ stored, and not to reload or\n      revalidate with the origin server. To do\
    \ this, the client may\n      include the only-if-cached directive in a request.\
    \ If it receives\n      this directive, a cache SHOULD either respond using a\
    \ cached entry\n      that is consistent with the other constraints of the request,\
    \ or\n      respond with a 504 (Gateway Timeout) status. However, if a group\n\
    \      of caches is being operated as a unified system with good internal\n  \
    \    connectivity, such a request MAY be forwarded within that group of\n    \
    \  caches.\n   must-revalidate\n      Because a cache MAY be configured to ignore\
    \ a server's specified\n      expiration time, and because a client request MAY\
    \ include a max-\n      stale directive (which has a similar effect), the protocol\
    \ also\n      includes a mechanism for the origin server to require revalidation\n\
    \      of a cache entry on any subsequent use. When the must-revalidate\n    \
    \  directive is present in a response received by a cache, that cache\n      MUST\
    \ NOT use the entry after it becomes stale to respond to a\n      subsequent request\
    \ without first revalidating it with the origin\n      server. (I.e., the cache\
    \ MUST do an end-to-end revalidation every\n      time, if, based solely on the\
    \ origin server's Expires or max-age\n      value, the cached response is stale.)\n\
    \      The must-revalidate directive is necessary to support reliable\n      operation\
    \ for certain protocol features. In all circumstances an\n      HTTP/1.1 cache\
    \ MUST obey the must-revalidate directive; in\n      particular, if the cache\
    \ cannot reach the origin server for any\n      reason, it MUST generate a 504\
    \ (Gateway Timeout) response.\n      Servers SHOULD send the must-revalidate directive\
    \ if and only if\n      failure to revalidate a request on the entity could result\
    \ in\n      incorrect operation, such as a silently unexecuted financial\n   \
    \   transaction. Recipients MUST NOT take any automated action that\n      violates\
    \ this directive, and MUST NOT automatically provide an\n      unvalidated copy\
    \ of the entity if revalidation fails.\n      Although this is not recommended,\
    \ user agents operating under\n      severe connectivity constraints MAY violate\
    \ this directive but, if\n      so, MUST explicitly warn the user that an unvalidated\
    \ response has\n      been provided. The warning MUST be provided on each unvalidated\n\
    \      access, and SHOULD require explicit user confirmation.\n   proxy-revalidate\n\
    \      The proxy-revalidate directive has the same meaning as the must-\n    \
    \  revalidate directive, except that it does not apply to non-shared\n      user\
    \ agent caches. It can be used on a response to an\n      authenticated request\
    \ to permit the user's cache to store and\n      later return the response without\
    \ needing to revalidate it (since\n      it has already been authenticated once\
    \ by that user), while still\n      requiring proxies that service many users\
    \ to revalidate each time\n      (in order to make sure that each user has been\
    \ authenticated).\n      Note that such authenticated responses also need the\
    \ public cache\n      control directive in order to allow them to be cached at\
    \ all.\n"
- title: 14.9.5 No-Transform Directive
  contents:
  - "14.9.5 No-Transform Directive\n   no-transform\n      Implementors of intermediate\
    \ caches (proxies) have found it useful\n      to convert the media type of certain\
    \ entity bodies. A non-\n      transparent proxy might, for example, convert between\
    \ image\n      formats in order to save cache space or to reduce the amount of\n\
    \      traffic on a slow link.\n      Serious operational problems occur, however,\
    \ when these\n      transformations are applied to entity bodies intended for\
    \ certain\n      kinds of applications. For example, applications for medical\n\
    \      imaging, scientific data analysis and those using end-to-end\n      authentication,\
    \ all depend on receiving an entity body that is bit\n      for bit identical\
    \ to the original entity-body.\n      Therefore, if a message includes the no-transform\
    \ directive, an\n      intermediate cache or proxy MUST NOT change those headers\
    \ that are\n      listed in section 13.5.2 as being subject to the no-transform\n\
    \      directive. This implies that the cache or proxy MUST NOT change\n     \
    \ any aspect of the entity-body that is specified by these headers,\n      including\
    \ the value of the entity-body itself.\n"
- title: 14.9.6 Cache Control Extensions
  contents:
  - "14.9.6 Cache Control Extensions\n   The Cache-Control header field can be extended\
    \ through the use of one\n   or more cache-extension tokens, each with an optional\
    \ assigned value.\n   Informational extensions (those which do not require a change\
    \ in\n   cache behavior) MAY be added without changing the semantics of other\n\
    \   directives. Behavioral extensions are designed to work by acting as\n   modifiers\
    \ to the existing base of cache directives. Both the new\n   directive and the\
    \ standard directive are supplied, such that\n   applications which do not understand\
    \ the new directive will default\n   to the behavior specified by the standard\
    \ directive, and those that\n   understand the new directive will recognize it\
    \ as modifying the\n   requirements associated with the standard directive. In\
    \ this way,\n   extensions to the cache-control directives can be made without\n\
    \   requiring changes to the base protocol.\n   This extension mechanism depends\
    \ on an HTTP cache obeying all of the\n   cache-control directives defined for\
    \ its native HTTP-version, obeying\n   certain extensions, and ignoring all directives\
    \ that it does not\n   understand.\n   For example, consider a hypothetical new\
    \ response directive called\n   community which acts as a modifier to the private\
    \ directive. We\n   define this new directive to mean that, in addition to any\
    \ non-shared\n   cache, any cache which is shared only by members of the community\n\
    \   named within its value may cache the response. An origin server\n   wishing\
    \ to allow the UCI community to use an otherwise private\n   response in their\
    \ shared cache(s) could do so by including\n       Cache-Control: private, community=\"\
    UCI\"\n   A cache seeing this header field will act correctly even if the cache\n\
    \   does not understand the community cache-extension, since it will also\n  \
    \ see and understand the private directive and thus default to the safe\n   behavior.\n\
    \   Unrecognized cache-directives MUST be ignored; it is assumed that any\n  \
    \ cache-directive likely to be unrecognized by an HTTP/1.1 cache will\n   be combined\
    \ with standard directives (or the response's default\n   cacheability) such that\
    \ the cache behavior will remain minimally\n   correct even if the cache does\
    \ not understand the extension(s).\n"
- title: 14.10 Connection
  contents:
  - "14.10 Connection\n   The Connection general-header field allows the sender to\
    \ specify\n   options that are desired for that particular connection and MUST\
    \ NOT\n   be communicated by proxies over further connections.\n   The Connection\
    \ header has the following grammar:\n       Connection = \"Connection\" \":\"\
    \ 1#(connection-token)\n       connection-token  = token\n   HTTP/1.1 proxies\
    \ MUST parse the Connection header field before a\n   message is forwarded and,\
    \ for each connection-token in this field,\n   remove any header field(s) from\
    \ the message with the same name as the\n   connection-token. Connection options\
    \ are signaled by the presence of\n   a connection-token in the Connection header\
    \ field, not by any\n   corresponding additional header field(s), since the additional\
    \ header\n   field may not be sent if there are no parameters associated with\
    \ that\n   connection option.\n   Message headers listed in the Connection header\
    \ MUST NOT include\n   end-to-end headers, such as Cache-Control.\n   HTTP/1.1\
    \ defines the \"close\" connection option for the sender to\n   signal that the\
    \ connection will be closed after completion of the\n   response. For example,\n\
    \       Connection: close\n   in either the request or the response header fields\
    \ indicates that\n   the connection SHOULD NOT be considered `persistent' (section\
    \ 8.1)\n   after the current request/response is complete.\n   HTTP/1.1 applications\
    \ that do not support persistent connections MUST\n   include the \"close\" connection\
    \ option in every message.\n   A system receiving an HTTP/1.0 (or lower-version)\
    \ message that\n   includes a Connection header MUST, for each connection-token\
    \ in this\n   field, remove and ignore any header field(s) from the message with\n\
    \   the same name as the connection-token. This protects against mistaken\n  \
    \ forwarding of such header fields by pre-HTTP/1.1 proxies. See section\n   19.6.2.\n"
- title: 14.11 Content-Encoding
  contents:
  - "14.11 Content-Encoding\n   The Content-Encoding entity-header field is used as\
    \ a modifier to the\n   media-type. When present, its value indicates what additional\
    \ content\n   codings have been applied to the entity-body, and thus what decoding\n\
    \   mechanisms must be applied in order to obtain the media-type\n   referenced\
    \ by the Content-Type header field. Content-Encoding is\n   primarily used to\
    \ allow a document to be compressed without losing\n   the identity of its underlying\
    \ media type.\n       Content-Encoding  = \"Content-Encoding\" \":\" 1#content-coding\n\
    \   Content codings are defined in section 3.5. An example of its use is\n   \
    \    Content-Encoding: gzip\n   The content-coding is a characteristic of the\
    \ entity identified by\n   the Request-URI. Typically, the entity-body is stored\
    \ with this\n   encoding and is only decoded before rendering or analogous usage.\n\
    \   However, a non-transparent proxy MAY modify the content-coding if the\n  \
    \ new coding is known to be acceptable to the recipient, unless the\n   \"no-transform\"\
    \ cache-control directive is present in the message.\n   If the content-coding\
    \ of an entity is not \"identity\", then the\n   response MUST include a Content-Encoding\
    \ entity-header (section\n   14.11) that lists the non-identity content-coding(s)\
    \ used.\n   If the content-coding of an entity in a request message is not\n \
    \  acceptable to the origin server, the server SHOULD respond with a\n   status\
    \ code of 415 (Unsupported Media Type).\n   If multiple encodings have been applied\
    \ to an entity, the content\n   codings MUST be listed in the order in which they\
    \ were applied.\n   Additional information about the encoding parameters MAY be\
    \ provided\n   by other entity-header fields not defined by this specification.\n"
- title: 14.12 Content-Language
  contents:
  - "14.12 Content-Language\n   The Content-Language entity-header field describes\
    \ the natural\n   language(s) of the intended audience for the enclosed entity.\
    \ Note\n   that this might not be equivalent to all the languages used within\n\
    \   the entity-body.\n       Content-Language  = \"Content-Language\" \":\" 1#language-tag\n\
    \   Language tags are defined in section 3.10. The primary purpose of\n   Content-Language\
    \ is to allow a user to identify and differentiate\n   entities according to the\
    \ user's own preferred language. Thus, if the\n   body content is intended only\
    \ for a Danish-literate audience, the\n   appropriate field is\n       Content-Language:\
    \ da\n   If no Content-Language is specified, the default is that the content\n\
    \   is intended for all language audiences. This might mean that the\n   sender\
    \ does not consider it to be specific to any natural language,\n   or that the\
    \ sender does not know for which language it is intended.\n   Multiple languages\
    \ MAY be listed for content that is intended for\n   multiple audiences. For example,\
    \ a rendition of the \"Treaty of\n   Waitangi,\" presented simultaneously in the\
    \ original Maori and English\n   versions, would call for\n       Content-Language:\
    \ mi, en\n   However, just because multiple languages are present within an entity\n\
    \   does not mean that it is intended for multiple linguistic audiences.\n   An\
    \ example would be a beginner's language primer, such as \"A First\n   Lesson\
    \ in Latin,\" which is clearly intended to be used by an\n   English-literate\
    \ audience. In this case, the Content-Language would\n   properly only include\
    \ \"en\".\n   Content-Language MAY be applied to any media type -- it is not\n\
    \   limited to textual documents.\n"
- title: 14.13 Content-Length
  contents:
  - "14.13 Content-Length\n   The Content-Length entity-header field indicates the\
    \ size of the\n   entity-body, in decimal number of OCTETs, sent to the recipient\
    \ or,\n   in the case of the HEAD method, the size of the entity-body that\n \
    \  would have been sent had the request been a GET.\n       Content-Length   \
    \ = \"Content-Length\" \":\" 1*DIGIT\n   An example is\n       Content-Length:\
    \ 3495\n   Applications SHOULD use this field to indicate the transfer-length\
    \ of\n   the message-body, unless this is prohibited by the rules in section\n\
    \   4.4.\n   Any Content-Length greater than or equal to zero is a valid value.\n\
    \   Section 4.4 describes how to determine the length of a message-body\n   if\
    \ a Content-Length is not given.\n   Note that the meaning of this field is significantly\
    \ different from\n   the corresponding definition in MIME, where it is an optional\
    \ field\n   used within the \"message/external-body\" content-type. In HTTP, it\n\
    \   SHOULD be sent whenever the message's length can be determined prior\n   to\
    \ being transferred, unless this is prohibited by the rules in\n   section 4.4.\n"
- title: 14.14 Content-Location
  contents:
  - "14.14 Content-Location\n   The Content-Location entity-header field MAY be used\
    \ to supply the\n   resource location for the entity enclosed in the message when\
    \ that\n   entity is accessible from a location separate from the requested\n\
    \   resource's URI. A server SHOULD provide a Content-Location for the\n   variant\
    \ corresponding to the response entity; especially in the case\n   where a resource\
    \ has multiple entities associated with it, and those\n   entities actually have\
    \ separate locations by which they might be\n   individually accessed, the server\
    \ SHOULD provide a Content-Location\n   for the particular variant which is returned.\n\
    \       Content-Location = \"Content-Location\" \":\"\n                      \
    \   ( absoluteURI | relativeURI )\n   The value of Content-Location also defines\
    \ the base URI for the\n   entity.\n   The Content-Location value is not a replacement\
    \ for the original\n   requested URI; it is only a statement of the location of\
    \ the resource\n   corresponding to this particular entity at the time of the\
    \ request.\n   Future requests MAY specify the Content-Location URI as the request-\n\
    \   URI if the desire is to identify the source of that particular\n   entity.\n\
    \   A cache cannot assume that an entity with a Content-Location\n   different\
    \ from the URI used to retrieve it can be used to respond to\n   later requests\
    \ on that Content-Location URI. However, the Content-\n   Location can be used\
    \ to differentiate between multiple entities\n   retrieved from a single requested\
    \ resource, as described in section\n   13.6.\n   If the Content-Location is a\
    \ relative URI, the relative URI is\n   interpreted relative to the Request-URI.\n\
    \   The meaning of the Content-Location header in PUT or POST requests is\n  \
    \ undefined; servers are free to ignore it in those cases.\n"
- title: 14.15 Content-MD5
  contents:
  - "14.15 Content-MD5\n   The Content-MD5 entity-header field, as defined in RFC\
    \ 1864 [23], is\n   an MD5 digest of the entity-body for the purpose of providing\
    \ an\n   end-to-end message integrity check (MIC) of the entity-body. (Note: a\n\
    \   MIC is good for detecting accidental modification of the entity-body\n   in\
    \ transit, but is not proof against malicious attacks.)\n        Content-MD5 \
    \  = \"Content-MD5\" \":\" md5-digest\n        md5-digest   = <base64 of 128 bit\
    \ MD5 digest as per RFC 1864>\n   The Content-MD5 header field MAY be generated\
    \ by an origin server or\n   client to function as an integrity check of the entity-body.\
    \ Only\n   origin servers or clients MAY generate the Content-MD5 header field;\n\
    \   proxies and gateways MUST NOT generate it, as this would defeat its\n   value\
    \ as an end-to-end integrity check. Any recipient of the entity-\n   body, including\
    \ gateways and proxies, MAY check that the digest value\n   in this header field\
    \ matches that of the entity-body as received.\n   The MD5 digest is computed\
    \ based on the content of the entity-body,\n   including any content-coding that\
    \ has been applied, but not including\n   any transfer-encoding applied to the\
    \ message-body. If the message is\n   received with a transfer-encoding, that\
    \ encoding MUST be removed\n   prior to checking the Content-MD5 value against\
    \ the received entity.\n   This has the result that the digest is computed on\
    \ the octets of the\n   entity-body exactly as, and in the order that, they would\
    \ be sent if\n   no transfer-encoding were being applied.\n   HTTP extends RFC\
    \ 1864 to permit the digest to be computed for MIME\n   composite media-types\
    \ (e.g., multipart/* and message/rfc822), but\n   this does not change how the\
    \ digest is computed as defined in the\n   preceding paragraph.\n   There are\
    \ several consequences of this. The entity-body for composite\n   types MAY contain\
    \ many body-parts, each with its own MIME and HTTP\n   headers (including Content-MD5,\
    \ Content-Transfer-Encoding, and\n   Content-Encoding headers). If a body-part\
    \ has a Content-Transfer-\n   Encoding or Content-Encoding header, it is assumed\
    \ that the content\n   of the body-part has had the encoding applied, and the\
    \ body-part is\n   included in the Content-MD5 digest as is -- i.e., after the\n\
    \   application. The Transfer-Encoding header field is not allowed within\n  \
    \ body-parts.\n   Conversion of all line breaks to CRLF MUST NOT be done before\n\
    \   computing or checking the digest: the line break convention used in\n   the\
    \ text actually transmitted MUST be left unaltered when computing\n   the digest.\n\
    \      Note: while the definition of Content-MD5 is exactly the same for\n   \
    \   HTTP as in RFC 1864 for MIME entity-bodies, there are several ways\n     \
    \ in which the application of Content-MD5 to HTTP entity-bodies\n      differs\
    \ from its application to MIME entity-bodies. One is that\n      HTTP, unlike\
    \ MIME, does not use Content-Transfer-Encoding, and\n      does use Transfer-Encoding\
    \ and Content-Encoding. Another is that\n      HTTP more frequently uses binary\
    \ content types than MIME, so it is\n      worth noting that, in such cases, the\
    \ byte order used to compute\n      the digest is the transmission byte order\
    \ defined for the type.\n      Lastly, HTTP allows transmission of text types\
    \ with any of several\n      line break conventions and not just the canonical\
    \ form using CRLF.\n"
- title: 14.16 Content-Range
  contents:
  - "14.16 Content-Range\n   The Content-Range entity-header is sent with a partial\
    \ entity-body to\n   specify where in the full entity-body the partial body should\
    \ be\n   applied. Range units are defined in section 3.12.\n       Content-Range\
    \ = \"Content-Range\" \":\" content-range-spec\n       content-range-spec    \
    \  = byte-content-range-spec\n       byte-content-range-spec = bytes-unit SP\n\
    \                                 byte-range-resp-spec \"/\"\n               \
    \                  ( instance-length | \"*\" )\n       byte-range-resp-spec =\
    \ (first-byte-pos \"-\" last-byte-pos)\n                                     \
    \ | \"*\"\n       instance-length           = 1*DIGIT\n   The header SHOULD indicate\
    \ the total length of the full entity-body,\n   unless this length is unknown\
    \ or difficult to determine. The asterisk\n   \"*\" character means that the instance-length\
    \ is unknown at the time\n   when the response was generated.\n   Unlike byte-ranges-specifier\
    \ values (see section 14.35.1), a byte-\n   range-resp-spec MUST only specify\
    \ one range, and MUST contain\n   absolute byte positions for both the first and\
    \ last byte of the\n   range.\n   A byte-content-range-spec with a byte-range-resp-spec\
    \ whose last-\n   byte-pos value is less than its first-byte-pos value, or whose\n\
    \   instance-length value is less than or equal to its last-byte-pos\n   value,\
    \ is invalid. The recipient of an invalid byte-content-range-\n   spec MUST ignore\
    \ it and any content transferred along with it.\n   A server sending a response\
    \ with status code 416 (Requested range not\n   satisfiable) SHOULD include a\
    \ Content-Range field with a byte-range-\n   resp-spec of \"*\". The instance-length\
    \ specifies the current length of\n   the selected resource. A response with status\
    \ code 206 (Partial\n   Content) MUST NOT include a Content-Range field with a\
    \ byte-range-\n   resp-spec of \"*\".\n   Examples of byte-content-range-spec\
    \ values, assuming that the entity\n   contains a total of 1234 bytes:\n     \
    \ . The first 500 bytes:\n       bytes 0-499/1234\n      . The second 500 bytes:\n\
    \       bytes 500-999/1234\n      . All except for the first 500 bytes:\n    \
    \   bytes 500-1233/1234\n      . The last 500 bytes:\n       bytes 734-1233/1234\n\
    \   When an HTTP message includes the content of a single range (for\n   example,\
    \ a response to a request for a single range, or to a request\n   for a set of\
    \ ranges that overlap without any holes), this content is\n   transmitted with\
    \ a Content-Range header, and a Content-Length header\n   showing the number of\
    \ bytes actually transferred. For example,\n       HTTP/1.1 206 Partial content\n\
    \       Date: Wed, 15 Nov 1995 06:25:24 GMT\n       Last-Modified: Wed, 15 Nov\
    \ 1995 04:58:08 GMT\n       Content-Range: bytes 21010-47021/47022\n       Content-Length:\
    \ 26012\n       Content-Type: image/gif\n   When an HTTP message includes the\
    \ content of multiple ranges (for\n   example, a response to a request for multiple\
    \ non-overlapping\n   ranges), these are transmitted as a multipart message. The\
    \ multipart\n   media type used for this purpose is \"multipart/byteranges\" as\
    \ defined\n   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.\n\
    \   A response to a request for a single range MUST NOT be sent using the\n  \
    \ multipart/byteranges media type.  A response to a request for\n   multiple ranges,\
    \ whose result is a single range, MAY be sent as a\n   multipart/byteranges media\
    \ type with one part. A client that cannot\n   decode a multipart/byteranges message\
    \ MUST NOT ask for multiple\n   byte-ranges in a single request.\n   When a client\
    \ requests multiple byte-ranges in one request, the\n   server SHOULD return them\
    \ in the order that they appeared in the\n   request.\n   If the server ignores\
    \ a byte-range-spec because it is syntactically\n   invalid, the server SHOULD\
    \ treat the request as if the invalid Range\n   header field did not exist. (Normally,\
    \ this means return a 200\n   response containing the full entity).\n   If the\
    \ server receives a request (other than one including an If-\n   Range request-header\
    \ field) with an unsatisfiable Range request-\n   header field (that is, all of\
    \ whose byte-range-spec values have a\n   first-byte-pos value greater than the\
    \ current length of the selected\n   resource), it SHOULD return a response code\
    \ of 416 (Requested range\n   not satisfiable) (section 10.4.17).\n      Note:\
    \ clients cannot depend on servers to send a 416 (Requested\n      range not satisfiable)\
    \ response instead of a 200 (OK) response for\n      an unsatisfiable Range request-header,\
    \ since not all servers\n      implement this request-header.\n"
- title: 14.17 Content-Type
  contents:
  - "14.17 Content-Type\n   The Content-Type entity-header field indicates the media\
    \ type of the\n   entity-body sent to the recipient or, in the case of the HEAD\
    \ method,\n   the media type that would have been sent had the request been a\
    \ GET.\n       Content-Type   = \"Content-Type\" \":\" media-type\n   Media types\
    \ are defined in section 3.7. An example of the field is\n       Content-Type:\
    \ text/html; charset=ISO-8859-4\n   Further discussion of methods for identifying\
    \ the media type of an\n   entity is provided in section 7.2.1.\n"
- title: 14.18 Date
  contents:
  - "14.18 Date\n   The Date general-header field represents the date and time at\
    \ which\n   the message was originated, having the same semantics as orig-date\
    \ in\n   RFC 822. The field value is an HTTP-date, as described in section\n \
    \  3.3.1; it MUST be sent in RFC 1123 [8]-date format.\n       Date  = \"Date\"\
    \ \":\" HTTP-date\n   An example is\n       Date: Tue, 15 Nov 1994 08:12:31 GMT\n\
    \   Origin servers MUST include a Date header field in all responses,\n   except\
    \ in these cases:\n      1. If the response status code is 100 (Continue) or 101\
    \ (Switching\n         Protocols), the response MAY include a Date header field,\
    \ at\n         the server's option.\n      2. If the response status code conveys\
    \ a server error, e.g. 500\n         (Internal Server Error) or 503 (Service Unavailable),\
    \ and it is\n         inconvenient or impossible to generate a valid Date.\n \
    \     3. If the server does not have a clock that can provide a\n         reasonable\
    \ approximation of the current time, its responses\n         MUST NOT include\
    \ a Date header field. In this case, the rules\n         in section 14.18.1 MUST\
    \ be followed.\n   A received message that does not have a Date header field MUST\
    \ be\n   assigned one by the recipient if the message will be cached by that\n\
    \   recipient or gatewayed via a protocol which requires a Date. An HTTP\n   implementation\
    \ without a clock MUST NOT cache responses without\n   revalidating them on every\
    \ use. An HTTP cache, especially a shared\n   cache, SHOULD use a mechanism, such\
    \ as NTP [28], to synchronize its\n   clock with a reliable external standard.\n\
    \   Clients SHOULD only send a Date header field in messages that include\n  \
    \ an entity-body, as in the case of the PUT and POST requests, and even\n   then\
    \ it is optional. A client without a clock MUST NOT send a Date\n   header field\
    \ in a request.\n   The HTTP-date sent in a Date header SHOULD NOT represent a\
    \ date and\n   time subsequent to the generation of the message. It SHOULD represent\n\
    \   the best available approximation of the date and time of message\n   generation,\
    \ unless the implementation has no means of generating a\n   reasonably accurate\
    \ date and time. In theory, the date ought to\n   represent the moment just before\
    \ the entity is generated. In\n   practice, the date can be generated at any time\
    \ during the message\n   origination without affecting its semantic value.\n"
- title: 14.18.1 Clockless Origin Server Operation
  contents:
  - "14.18.1 Clockless Origin Server Operation\n   Some origin server implementations\
    \ might not have a clock available.\n   An origin server without a clock MUST\
    \ NOT assign Expires or Last-\n   Modified values to a response, unless these\
    \ values were associated\n   with the resource by a system or user with a reliable\
    \ clock. It MAY\n   assign an Expires value that is known, at or before server\n\
    \   configuration time, to be in the past (this allows \"pre-expiration\"\n  \
    \ of responses without storing separate Expires values for each\n   resource).\n"
- title: 14.19 ETag
  contents:
  - "14.19 ETag\n   The ETag response-header field provides the current value of the\n\
    \   entity tag for the requested variant. The headers used with entity\n   tags\
    \ are described in sections 14.24, 14.26 and 14.44. The entity tag\n   MAY be\
    \ used for comparison with other entities from the same resource\n   (see section\
    \ 13.3.3).\n      ETag = \"ETag\" \":\" entity-tag\n   Examples:\n      ETag:\
    \ \"xyzzy\"\n      ETag: W/\"xyzzy\"\n      ETag: \"\"\n"
- title: 14.20 Expect
  contents:
  - "14.20 Expect\n   The Expect request-header field is used to indicate that particular\n\
    \   server behaviors are required by the client.\n      Expect       =  \"Expect\"\
    \ \":\" 1#expectation\n      expectation  =  \"100-continue\" | expectation-extension\n\
    \      expectation-extension =  token [ \"=\" ( token | quoted-string )\n    \
    \                           *expect-params ]\n      expect-params =  \";\" token\
    \ [ \"=\" ( token | quoted-string ) ]\n   A server that does not understand or\
    \ is unable to comply with any of\n   the expectation values in the Expect field\
    \ of a request MUST respond\n   with appropriate error status. The server MUST\
    \ respond with a 417\n   (Expectation Failed) status if any of the expectations\
    \ cannot be met\n   or, if there are other problems with the request, some other\
    \ 4xx\n   status.\n   This header field is defined with extensible syntax to allow\
    \ for\n   future extensions. If a server receives a request containing an\n  \
    \ Expect field that includes an expectation-extension that it does not\n   support,\
    \ it MUST respond with a 417 (Expectation Failed) status.\n   Comparison of expectation\
    \ values is case-insensitive for unquoted\n   tokens (including the 100-continue\
    \ token), and is case-sensitive for\n   quoted-string expectation-extensions.\n\
    \   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST\n   return\
    \ a 417 (Expectation Failed) status if it receives a request\n   with an expectation\
    \ that it cannot meet. However, the Expect\n   request-header itself is end-to-end;\
    \ it MUST be forwarded if the\n   request is forwarded.\n   Many older HTTP/1.0\
    \ and HTTP/1.1 applications do not understand the\n   Expect header.\n   See section\
    \ 8.2.3 for the use of the 100 (continue) status.\n"
- title: 14.21 Expires
  contents:
  - "14.21 Expires\n   The Expires entity-header field gives the date/time after which\
    \ the\n   response is considered stale. A stale cache entry may not normally be\n\
    \   returned by a cache (either a proxy cache or a user agent cache)\n   unless\
    \ it is first validated with the origin server (or with an\n   intermediate cache\
    \ that has a fresh copy of the entity). See section\n   13.2 for further discussion\
    \ of the expiration model.\n   The presence of an Expires field does not imply\
    \ that the original\n   resource will change or cease to exist at, before, or\
    \ after that\n   time.\n   The format is an absolute date and time as defined\
    \ by HTTP-date in\n   section 3.3.1; it MUST be in RFC 1123 date format:\n   \
    \   Expires = \"Expires\" \":\" HTTP-date\n   An example of its use is\n     \
    \ Expires: Thu, 01 Dec 1994 16:00:00 GMT\n      Note: if a response includes a\
    \ Cache-Control field with the max-\n      age directive (see section 14.9.3),\
    \ that directive overrides the\n      Expires field.\n   HTTP/1.1 clients and\
    \ caches MUST treat other invalid date formats,\n   especially including the value\
    \ \"0\", as in the past (i.e., \"already\n   expired\").\n   To mark a response\
    \ as \"already expired,\" an origin server sends an\n   Expires date that is equal\
    \ to the Date header value. (See the rules\n   for expiration calculations in\
    \ section 13.2.4.)\n   To mark a response as \"never expires,\" an origin server\
    \ sends an\n   Expires date approximately one year from the time the response\
    \ is\n   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one\n\
    \   year in the future.\n   The presence of an Expires header field with a date\
    \ value of some\n   time in the future on a response that otherwise would by default\
    \ be\n   non-cacheable indicates that the response is cacheable, unless\n   indicated\
    \ otherwise by a Cache-Control header field (section 14.9).\n"
- title: 14.22 From
  contents:
  - "14.22 From\n   The From request-header field, if given, SHOULD contain an Internet\n\
    \   e-mail address for the human user who controls the requesting user\n   agent.\
    \ The address SHOULD be machine-usable, as defined by \"mailbox\"\n   in RFC 822\
    \ [9] as updated by RFC 1123 [8]:\n       From   = \"From\" \":\" mailbox\n  \
    \ An example is:\n       From: webmaster@w3.org\n   This header field MAY be used\
    \ for logging purposes and as a means for\n   identifying the source of invalid\
    \ or unwanted requests. It SHOULD NOT\n   be used as an insecure form of access\
    \ protection. The interpretation\n   of this field is that the request is being\
    \ performed on behalf of the\n   person given, who accepts responsibility for\
    \ the method performed. In\n   particular, robot agents SHOULD include this header\
    \ so that the\n   person responsible for running the robot can be contacted if\
    \ problems\n   occur on the receiving end.\n   The Internet e-mail address in\
    \ this field MAY be separate from the\n   Internet host which issued the request.\
    \ For example, when a request\n   is passed through a proxy the original issuer's\
    \ address SHOULD be\n   used.\n   The client SHOULD NOT send the From header field\
    \ without the user's\n   approval, as it might conflict with the user's privacy\
    \ interests or\n   their site's security policy. It is strongly recommended that\
    \ the\n   user be able to disable, enable, and modify the value of this field\n\
    \   at any time prior to a request.\n"
- title: 14.23 Host
  contents:
  - "14.23 Host\n   The Host request-header field specifies the Internet host and\
    \ port\n   number of the resource being requested, as obtained from the original\n\
    \   URI given by the user or referring resource (generally an HTTP URL,\n   as\
    \ described in section 3.2.2). The Host field value MUST represent\n   the naming\
    \ authority of the origin server or gateway given by the\n   original URL. This\
    \ allows the origin server or gateway to\n   differentiate between internally-ambiguous\
    \ URLs, such as the root \"/\"\n   URL of a server for multiple host names on\
    \ a single IP address.\n       Host = \"Host\" \":\" host [ \":\" port ] ; Section\
    \ 3.2.2\n   A \"host\" without any trailing port information implies the default\n\
    \   port for the service requested (e.g., \"80\" for an HTTP URL). For\n   example,\
    \ a request on the origin server for\n   <http://www.w3.org/pub/WWW/> would properly\
    \ include:\n       GET /pub/WWW/ HTTP/1.1\n       Host: www.w3.org\n   A client\
    \ MUST include a Host header field in all HTTP/1.1 request\n   messages . If the\
    \ requested URI does not include an Internet host\n   name for the service being\
    \ requested, then the Host header field MUST\n   be given with an empty value.\
    \ An HTTP/1.1 proxy MUST ensure that any\n   request message it forwards does\
    \ contain an appropriate Host header\n   field that identifies the service being\
    \ requested by the proxy. All\n   Internet-based HTTP/1.1 servers MUST respond\
    \ with a 400 (Bad Request)\n   status code to any HTTP/1.1 request message which\
    \ lacks a Host header\n   field.\n   See sections 5.2 and 19.6.1.1 for other requirements\
    \ relating to\n   Host.\n"
- title: 14.24 If-Match
  contents:
  - "14.24 If-Match\n   The If-Match request-header field is used with a method to\
    \ make it\n   conditional. A client that has one or more entities previously\n\
    \   obtained from the resource can verify that one of those entities is\n   current\
    \ by including a list of their associated entity tags in the\n   If-Match header\
    \ field. Entity tags are defined in section 3.11. The\n   purpose of this feature\
    \ is to allow efficient updates of cached\n   information with a minimum amount\
    \ of transaction overhead. It is also\n   used, on updating requests, to prevent\
    \ inadvertent modification of\n   the wrong version of a resource. As a special\
    \ case, the value \"*\"\n   matches any current entity of the resource.\n    \
    \   If-Match = \"If-Match\" \":\" ( \"*\" | 1#entity-tag )\n   If any of the entity\
    \ tags match the entity tag of the entity that\n   would have been returned in\
    \ the response to a similar GET request\n   (without the If-Match header) on that\
    \ resource, or if \"*\" is given\n   and any current entity exists for that resource,\
    \ then the server MAY\n   perform the requested method as if the If-Match header\
    \ field did not\n   exist.\n   A server MUST use the strong comparison function\
    \ (see section 13.3.3)\n   to compare the entity tags in If-Match.\n   If none\
    \ of the entity tags match, or if \"*\" is given and no current\n   entity exists,\
    \ the server MUST NOT perform the requested method, and\n   MUST return a 412\
    \ (Precondition Failed) response. This behavior is\n   most useful when the client\
    \ wants to prevent an updating method, such\n   as PUT, from modifying a resource\
    \ that has changed since the client\n   last retrieved it.\n   If the request\
    \ would, without the If-Match header field, result in\n   anything other than\
    \ a 2xx or 412 status, then the If-Match header\n   MUST be ignored.\n   The meaning\
    \ of \"If-Match: *\" is that the method SHOULD be performed\n   if the representation\
    \ selected by the origin server (or by a cache,\n   possibly using the Vary mechanism,\
    \ see section 14.44) exists, and\n   MUST NOT be performed if the representation\
    \ does not exist.\n   A request intended to update a resource (e.g., a PUT) MAY\
    \ include an\n   If-Match header field to signal that the request method MUST\
    \ NOT be\n   applied if the entity corresponding to the If-Match value (a single\n\
    \   entity tag) is no longer a representation of that resource. This\n   allows\
    \ the user to indicate that they do not wish the request to be\n   successful\
    \ if the resource has been changed without their knowledge.\n   Examples:\n  \
    \     If-Match: \"xyzzy\"\n       If-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\
    \n       If-Match: *\n   The result of a request having both an If-Match header\
    \ field and\n   either an If-None-Match or an If-Modified-Since header fields\
    \ is\n   undefined by this specification.\n"
- title: 14.25 If-Modified-Since
  contents:
  - "14.25 If-Modified-Since\n   The If-Modified-Since request-header field is used\
    \ with a method to\n   make it conditional: if the requested variant has not been\
    \ modified\n   since the time specified in this field, an entity will not be\n\
    \   returned from the server; instead, a 304 (not modified) response will\n  \
    \ be returned without any message-body.\n       If-Modified-Since = \"If-Modified-Since\"\
    \ \":\" HTTP-date\n   An example of the field is:\n       If-Modified-Since: Sat,\
    \ 29 Oct 1994 19:43:31 GMT\n   A GET method with an If-Modified-Since header and\
    \ no Range header\n   requests that the identified entity be transferred only\
    \ if it has\n   been modified since the date given by the If-Modified-Since header.\n\
    \   The algorithm for determining this includes the following cases:\n      a)\
    \ If the request would normally result in anything other than a\n         200\
    \ (OK) status, or if the passed If-Modified-Since date is\n         invalid, the\
    \ response is exactly the same as for a normal GET.\n         A date which is\
    \ later than the server's current time is\n         invalid.\n      b) If the\
    \ variant has been modified since the If-Modified-Since\n         date, the response\
    \ is exactly the same as for a normal GET.\n      c) If the variant has not been\
    \ modified since a valid If-\n         Modified-Since date, the server SHOULD\
    \ return a 304 (Not\n         Modified) response.\n   The purpose of this feature\
    \ is to allow efficient updates of cached\n   information with a minimum amount\
    \ of transaction overhead.\n      Note: The Range request-header field modifies\
    \ the meaning of If-\n      Modified-Since; see section 14.35 for full details.\n\
    \      Note: If-Modified-Since times are interpreted by the server, whose\n  \
    \    clock might not be synchronized with the client.\n      Note: When handling\
    \ an If-Modified-Since header field, some\n      servers will use an exact date\
    \ comparison function, rather than a\n      less-than function, for deciding whether\
    \ to send a 304 (Not\n      Modified) response. To get best results when sending\
    \ an If-\n      Modified-Since header field for cache validation, clients are\n\
    \      advised to use the exact date string received in a previous Last-\n   \
    \   Modified header field whenever possible.\n      Note: If a client uses an\
    \ arbitrary date in the If-Modified-Since\n      header instead of a date taken\
    \ from the Last-Modified header for\n      the same request, the client should\
    \ be aware of the fact that this\n      date is interpreted in the server's understanding\
    \ of time. The\n      client should consider unsynchronized clocks and rounding\
    \ problems\n      due to the different encodings of time between the client and\n\
    \      server. This includes the possibility of race conditions if the\n     \
    \ document has changed between the time it was first requested and\n      the\
    \ If-Modified-Since date of a subsequent request, and the\n      possibility of\
    \ clock-skew-related problems if the If-Modified-\n      Since date is derived\
    \ from the client's clock without correction\n      to the server's clock. Corrections\
    \ for different time bases\n      between client and server are at best approximate\
    \ due to network\n      latency.\n   The result of a request having both an If-Modified-Since\
    \ header field\n   and either an If-Match or an If-Unmodified-Since header fields\
    \ is\n   undefined by this specification.\n"
- title: 14.26 If-None-Match
  contents:
  - "14.26 If-None-Match\n   The If-None-Match request-header field is used with a\
    \ method to make\n   it conditional. A client that has one or more entities previously\n\
    \   obtained from the resource can verify that none of those entities is\n   current\
    \ by including a list of their associated entity tags in the\n   If-None-Match\
    \ header field. The purpose of this feature is to allow\n   efficient updates\
    \ of cached information with a minimum amount of\n   transaction overhead. It\
    \ is also used to prevent a method (e.g. PUT)\n   from inadvertently modifying\
    \ an existing resource when the client\n   believes that the resource does not\
    \ exist.\n   As a special case, the value \"*\" matches any current entity of\
    \ the\n   resource.\n       If-None-Match = \"If-None-Match\" \":\" ( \"*\" |\
    \ 1#entity-tag )\n   If any of the entity tags match the entity tag of the entity\
    \ that\n   would have been returned in the response to a similar GET request\n\
    \   (without the If-None-Match header) on that resource, or if \"*\" is\n   given\
    \ and any current entity exists for that resource, then the\n   server MUST NOT\
    \ perform the requested method, unless required to do\n   so because the resource's\
    \ modification date fails to match that\n   supplied in an If-Modified-Since header\
    \ field in the request.\n   Instead, if the request method was GET or HEAD, the\
    \ server SHOULD\n   respond with a 304 (Not Modified) response, including the\
    \ cache-\n   related header fields (particularly ETag) of one of the entities\
    \ that\n   matched. For all other request methods, the server MUST respond with\n\
    \   a status of 412 (Precondition Failed).\n   See section 13.3.3 for rules on\
    \ how to determine if two entities tags\n   match. The weak comparison function\
    \ can only be used with GET or HEAD\n   requests.\n   If none of the entity tags\
    \ match, then the server MAY perform the\n   requested method as if the If-None-Match\
    \ header field did not exist,\n   but MUST also ignore any If-Modified-Since header\
    \ field(s) in the\n   request. That is, if no entity tags match, then the server\
    \ MUST NOT\n   return a 304 (Not Modified) response.\n   If the request would,\
    \ without the If-None-Match header field, result\n   in anything other than a\
    \ 2xx or 304 status, then the If-None-Match\n   header MUST be ignored. (See section\
    \ 13.3.4 for a discussion of\n   server behavior when both If-Modified-Since and\
    \ If-None-Match appear\n   in the same request.)\n   The meaning of \"If-None-Match:\
    \ *\" is that the method MUST NOT be\n   performed if the representation selected\
    \ by the origin server (or by\n   a cache, possibly using the Vary mechanism,\
    \ see section 14.44)\n   exists, and SHOULD be performed if the representation\
    \ does not exist.\n   This feature is intended to be useful in preventing races\
    \ between PUT\n   operations.\n   Examples:\n       If-None-Match: \"xyzzy\"\n\
    \       If-None-Match: W/\"xyzzy\"\n       If-None-Match: \"xyzzy\", \"r2d2xxxx\"\
    , \"c3piozzzz\"\n       If-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"\
    \n       If-None-Match: *\n   The result of a request having both an If-None-Match\
    \ header field and\n   either an If-Match or an If-Unmodified-Since header fields\
    \ is\n   undefined by this specification.\n"
- title: 14.27 If-Range
  contents:
  - "14.27 If-Range\n   If a client has a partial copy of an entity in its cache,\
    \ and wishes\n   to have an up-to-date copy of the entire entity in its cache,\
    \ it\n   could use the Range request-header with a conditional GET (using\n  \
    \ either or both of If-Unmodified-Since and If-Match.) However, if the\n   condition\
    \ fails because the entity has been modified, the client\n   would then have to\
    \ make a second request to obtain the entire current\n   entity-body.\n   The\
    \ If-Range header allows a client to \"short-circuit\" the second\n   request.\
    \ Informally, its meaning is `if the entity is unchanged, send\n   me the part(s)\
    \ that I am missing; otherwise, send me the entire new\n   entity'.\n        If-Range\
    \ = \"If-Range\" \":\" ( entity-tag | HTTP-date )\n   If the client has no entity\
    \ tag for an entity, but does have a Last-\n   Modified date, it MAY use that\
    \ date in an If-Range header. (The\n   server can distinguish between a valid\
    \ HTTP-date and any form of\n   entity-tag by examining no more than two characters.)\
    \ The If-Range\n   header SHOULD only be used together with a Range header, and\
    \ MUST be\n   ignored if the request does not include a Range header, or if the\n\
    \   server does not support the sub-range operation.\n   If the entity tag given\
    \ in the If-Range header matches the current\n   entity tag for the entity, then\
    \ the server SHOULD provide the\n   specified sub-range of the entity using a\
    \ 206 (Partial content)\n   response. If the entity tag does not match, then the\
    \ server SHOULD\n   return the entire entity using a 200 (OK) response.\n"
- title: 14.28 If-Unmodified-Since
  contents:
  - "14.28 If-Unmodified-Since\n   The If-Unmodified-Since request-header field is\
    \ used with a method to\n   make it conditional. If the requested resource has\
    \ not been modified\n   since the time specified in this field, the server SHOULD\
    \ perform the\n   requested operation as if the If-Unmodified-Since header were\
    \ not\n   present.\n   If the requested variant has been modified since the specified\
    \ time,\n   the server MUST NOT perform the requested operation, and MUST return\n\
    \   a 412 (Precondition Failed).\n      If-Unmodified-Since = \"If-Unmodified-Since\"\
    \ \":\" HTTP-date\n   An example of the field is:\n       If-Unmodified-Since:\
    \ Sat, 29 Oct 1994 19:43:31 GMT\n   If the request normally (i.e., without the\
    \ If-Unmodified-Since\n   header) would result in anything other than a 2xx or\
    \ 412 status, the\n   If-Unmodified-Since header SHOULD be ignored.\n   If the\
    \ specified date is invalid, the header is ignored.\n   The result of a request\
    \ having both an If-Unmodified-Since header\n   field and either an If-None-Match\
    \ or an If-Modified-Since header\n   fields is undefined by this specification.\n"
- title: 14.29 Last-Modified
  contents:
  - "14.29 Last-Modified\n   The Last-Modified entity-header field indicates the date\
    \ and time at\n   which the origin server believes the variant was last modified.\n\
    \       Last-Modified  = \"Last-Modified\" \":\" HTTP-date\n   An example of its\
    \ use is\n       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n   The exact meaning\
    \ of this header field depends on the implementation\n   of the origin server\
    \ and the nature of the original resource. For\n   files, it may be just the file\
    \ system last-modified time. For\n   entities with dynamically included parts,\
    \ it may be the most recent\n   of the set of last-modify times for its component\
    \ parts. For database\n   gateways, it may be the last-update time stamp of the\
    \ record. For\n   virtual objects, it may be the last time the internal state\
    \ changed.\n   An origin server MUST NOT send a Last-Modified date which is later\n\
    \   than the server's time of message origination. In such cases, where\n   the\
    \ resource's last modification would indicate some time in the\n   future, the\
    \ server MUST replace that date with the message\n   origination date.\n   An\
    \ origin server SHOULD obtain the Last-Modified value of the entity\n   as close\
    \ as possible to the time that it generates the Date value of\n   its response.\
    \ This allows a recipient to make an accurate assessment\n   of the entity's modification\
    \ time, especially if the entity changes\n   near the time that the response is\
    \ generated.\n   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.\n"
- title: 14.30 Location
  contents:
  - "14.30 Location\n   The Location response-header field is used to redirect the\
    \ recipient\n   to a location other than the Request-URI for completion of the\n\
    \   request or identification of a new resource. For 201 (Created)\n   responses,\
    \ the Location is that of the new resource which was created\n   by the request.\
    \ For 3xx responses, the location SHOULD indicate the\n   server's preferred URI\
    \ for automatic redirection to the resource. The\n   field value consists of a\
    \ single absolute URI.\n       Location       = \"Location\" \":\" absoluteURI\n\
    \   An example is:\n       Location: http://www.w3.org/pub/WWW/People.html\n \
    \     Note: The Content-Location header field (section 14.14) differs\n      from\
    \ Location in that the Content-Location identifies the original\n      location\
    \ of the entity enclosed in the request. It is therefore\n      possible for a\
    \ response to contain header fields for both Location\n      and Content-Location.\
    \ Also see section 13.10 for cache\n      requirements of some methods.\n"
- title: 14.31 Max-Forwards
  contents:
  - "14.31 Max-Forwards\n   The Max-Forwards request-header field provides a mechanism\
    \ with the\n   TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit\
    \ the\n   number of proxies or gateways that can forward the request to the\n\
    \   next inbound server. This can be useful when the client is attempting\n  \
    \ to trace a request chain which appears to be failing or looping in\n   mid-chain.\n\
    \       Max-Forwards   = \"Max-Forwards\" \":\" 1*DIGIT\n   The Max-Forwards value\
    \ is a decimal integer indicating the remaining\n   number of times this request\
    \ message may be forwarded.\n   Each proxy or gateway recipient of a TRACE or\
    \ OPTIONS request\n   containing a Max-Forwards header field MUST check and update\
    \ its\n   value prior to forwarding the request. If the received value is zero\n\
    \   (0), the recipient MUST NOT forward the request; instead, it MUST\n   respond\
    \ as the final recipient. If the received Max-Forwards value is\n   greater than\
    \ zero, then the forwarded message MUST contain an updated\n   Max-Forwards field\
    \ with a value decremented by one (1).\n   The Max-Forwards header field MAY be\
    \ ignored for all other methods\n   defined by this specification and for any\
    \ extension methods for which\n   it is not explicitly referred to as part of\
    \ that method definition.\n"
- title: 14.32 Pragma
  contents:
  - "14.32 Pragma\n   The Pragma general-header field is used to include implementation-\n\
    \   specific directives that might apply to any recipient along the\n   request/response\
    \ chain. All pragma directives specify optional\n   behavior from the viewpoint\
    \ of the protocol; however, some systems\n   MAY require that behavior be consistent\
    \ with the directives.\n       Pragma            = \"Pragma\" \":\" 1#pragma-directive\n\
    \       pragma-directive  = \"no-cache\" | extension-pragma\n       extension-pragma\
    \  = token [ \"=\" ( token | quoted-string ) ]\n   When the no-cache directive\
    \ is present in a request message, an\n   application SHOULD forward the request\
    \ toward the origin server even\n   if it has a cached copy of what is being requested.\
    \ This pragma\n   directive has the same semantics as the no-cache cache-directive\
    \ (see\n   section 14.9) and is defined here for backward compatibility with\n\
    \   HTTP/1.0. Clients SHOULD include both header fields when a no-cache\n   request\
    \ is sent to a server not known to be HTTP/1.1 compliant.\n   Pragma directives\
    \ MUST be passed through by a proxy or gateway\n   application, regardless of\
    \ their significance to that application,\n   since the directives might be applicable\
    \ to all recipients along the\n   request/response chain. It is not possible to\
    \ specify a pragma for a\n   specific recipient; however, any pragma directive\
    \ not relevant to a\n   recipient SHOULD be ignored by that recipient.\n   HTTP/1.1\
    \ caches SHOULD treat \"Pragma: no-cache\" as if the client had\n   sent \"Cache-Control:\
    \ no-cache\". No new Pragma directives will be\n   defined in HTTP.\n      Note:\
    \ because the meaning of \"Pragma: no-cache as a response\n      header field\
    \ is not actually specified, it does not provide a\n      reliable replacement\
    \ for \"Cache-Control: no-cache\" in a response\n"
- title: 14.33 Proxy-Authenticate
  contents:
  - "14.33 Proxy-Authenticate\n   The Proxy-Authenticate response-header field MUST\
    \ be included as part\n   of a 407 (Proxy Authentication Required) response. The\
    \ field value\n   consists of a challenge that indicates the authentication scheme\
    \ and\n   parameters applicable to the proxy for this Request-URI.\n       Proxy-Authenticate\
    \  = \"Proxy-Authenticate\" \":\" 1#challenge\n   The HTTP access authentication\
    \ process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\"\
    \ [43]. Unlike\n   WWW-Authenticate, the Proxy-Authenticate header field applies\
    \ only to\n   the current connection and SHOULD NOT be passed on to downstream\n\
    \   clients. However, an intermediate proxy might need to obtain its own\n   credentials\
    \ by requesting them from the downstream client, which in\n   some circumstances\
    \ will appear as if the proxy is forwarding the\n   Proxy-Authenticate header\
    \ field.\n"
- title: 14.34 Proxy-Authorization
  contents:
  - "14.34 Proxy-Authorization\n   The Proxy-Authorization request-header field allows\
    \ the client to\n   identify itself (or its user) to a proxy which requires\n\
    \   authentication. The Proxy-Authorization field value consists of\n   credentials\
    \ containing the authentication information of the user\n   agent for the proxy\
    \ and/or realm of the resource being requested.\n       Proxy-Authorization  \
    \   = \"Proxy-Authorization\" \":\" credentials\n   The HTTP access authentication\
    \ process is described in \"HTTP\n   Authentication: Basic and Digest Access Authentication\"\
    \ [43] . Unlike\n   Authorization, the Proxy-Authorization header field applies\
    \ only to\n   the next outbound proxy that demanded authentication using the Proxy-\n\
    \   Authenticate field. When multiple proxies are used in a chain, the\n   Proxy-Authorization\
    \ header field is consumed by the first outbound\n   proxy that was expecting\
    \ to receive credentials. A proxy MAY relay\n   the credentials from the client\
    \ request to the next proxy if that is\n   the mechanism by which the proxies\
    \ cooperatively authenticate a given\n   request.\n"
- title: 14.35 Range
  contents:
  - '14.35 Range

    '
- title: 14.35.1 Byte Ranges
  contents:
  - "14.35.1 Byte Ranges\n   Since all HTTP entities are represented in HTTP messages\
    \ as sequences\n   of bytes, the concept of a byte range is meaningful for any\
    \ HTTP\n   entity. (However, not all clients and servers need to support byte-\n\
    \   range operations.)\n   Byte range specifications in HTTP apply to the sequence\
    \ of bytes in\n   the entity-body (not necessarily the same as the message-body).\n\
    \   A byte range operation MAY specify a single range of bytes, or a set\n   of\
    \ ranges within a single entity.\n       ranges-specifier = byte-ranges-specifier\n\
    \       byte-ranges-specifier = bytes-unit \"=\" byte-range-set\n       byte-range-set\
    \  = 1#( byte-range-spec | suffix-byte-range-spec )\n       byte-range-spec =\
    \ first-byte-pos \"-\" [last-byte-pos]\n       first-byte-pos  = 1*DIGIT\n   \
    \    last-byte-pos   = 1*DIGIT\n   The first-byte-pos value in a byte-range-spec\
    \ gives the byte-offset\n   of the first byte in a range. The last-byte-pos value\
    \ gives the\n   byte-offset of the last byte in the range; that is, the byte\n\
    \   positions specified are inclusive. Byte offsets start at zero.\n   If the\
    \ last-byte-pos value is present, it MUST be greater than or\n   equal to the\
    \ first-byte-pos in that byte-range-spec, or the byte-\n   range-spec is syntactically\
    \ invalid. The recipient of a byte-range-\n   set that includes one or more syntactically\
    \ invalid byte-range-spec\n   values MUST ignore the header field that includes\
    \ that byte-range-\n   set.\n   If the last-byte-pos value is absent, or if the\
    \ value is greater than\n   or equal to the current length of the entity-body,\
    \ last-byte-pos is\n   taken to be equal to one less than the current length of\
    \ the entity-\n   body in bytes.\n   By its choice of last-byte-pos, a client\
    \ can limit the number of\n   bytes retrieved without knowing the size of the\
    \ entity.\n       suffix-byte-range-spec = \"-\" suffix-length\n       suffix-length\
    \ = 1*DIGIT\n   A suffix-byte-range-spec is used to specify the suffix of the\n\
    \   entity-body, of a length given by the suffix-length value. (That is,\n   this\
    \ form specifies the last N bytes of an entity-body.) If the\n   entity is shorter\
    \ than the specified suffix-length, the entire\n   entity-body is used.\n   If\
    \ a syntactically valid byte-range-set includes at least one byte-\n   range-spec\
    \ whose first-byte-pos is less than the current length of\n   the entity-body,\
    \ or at least one suffix-byte-range-spec with a non-\n   zero suffix-length, then\
    \ the byte-range-set is satisfiable.\n   Otherwise, the byte-range-set is unsatisfiable.\
    \ If the byte-range-set\n   is unsatisfiable, the server SHOULD return a response\
    \ with a status\n   of 416 (Requested range not satisfiable). Otherwise, the server\n\
    \   SHOULD return a response with a status of 206 (Partial Content)\n   containing\
    \ the satisfiable ranges of the entity-body.\n   Examples of byte-ranges-specifier\
    \ values (assuming an entity-body of\n   length 10000):\n      - The first 500\
    \ bytes (byte offsets 0-499, inclusive):  bytes=0-\n        499\n      - The second\
    \ 500 bytes (byte offsets 500-999, inclusive):\n        bytes=500-999\n      -\
    \ The final 500 bytes (byte offsets 9500-9999, inclusive):\n        bytes=-500\n\
    \      - Or bytes=9500-\n      - The first and last bytes only (bytes 0 and 9999):\
    \  bytes=0-0,-1\n      - Several legal but not canonical specifications of the\
    \ second 500\n        bytes (byte offsets 500-999, inclusive):\n         bytes=500-600,601-999\n\
    \         bytes=500-700,601-999\n"
- title: 14.35.2 Range Retrieval Requests
  contents:
  - "14.35.2 Range Retrieval Requests\n   HTTP retrieval requests using conditional\
    \ or unconditional GET\n   methods MAY request one or more sub-ranges of the entity,\
    \ instead of\n   the entire entity, using the Range request header, which applies\
    \ to\n   the entity returned as the result of the request:\n      Range = \"Range\"\
    \ \":\" ranges-specifier\n   A server MAY ignore the Range header. However, HTTP/1.1\
    \ origin\n   servers and intermediate caches ought to support byte ranges when\n\
    \   possible, since Range supports efficient recovery from partially\n   failed\
    \ transfers, and supports efficient partial retrieval of large\n   entities.\n\
    \   If the server supports the Range header and the specified range or\n   ranges\
    \ are appropriate for the entity:\n      - The presence of a Range header in an\
    \ unconditional GET modifies\n        what is returned if the GET is otherwise\
    \ successful. In other\n        words, the response carries a status code of 206\
    \ (Partial\n        Content) instead of 200 (OK).\n      - The presence of a Range\
    \ header in a conditional GET (a request\n        using one or both of If-Modified-Since\
    \ and If-None-Match, or\n        one or both of If-Unmodified-Since and If-Match)\
    \ modifies what\n        is returned if the GET is otherwise successful and the\n\
    \        condition is true. It does not affect the 304 (Not Modified)\n      \
    \  response returned if the conditional is false.\n   In some cases, it might\
    \ be more appropriate to use the If-Range\n   header (see section 14.27) in addition\
    \ to the Range header.\n   If a proxy that supports ranges receives a Range request,\
    \ forwards\n   the request to an inbound server, and receives an entire entity\
    \ in\n   reply, it SHOULD only return the requested range to its client. It\n\
    \   SHOULD store the entire received response in its cache if that is\n   consistent\
    \ with its cache allocation policies.\n"
- title: 14.36 Referer
  contents:
  - "14.36 Referer\n   The Referer[sic] request-header field allows the client to\
    \ specify,\n   for the server's benefit, the address (URI) of the resource from\n\
    \   which the Request-URI was obtained (the \"referrer\", although the\n   header\
    \ field is misspelled.) The Referer request-header allows a\n   server to generate\
    \ lists of back-links to resources for interest,\n   logging, optimized caching,\
    \ etc. It also allows obsolete or mistyped\n   links to be traced for maintenance.\
    \ The Referer field MUST NOT be\n   sent if the Request-URI was obtained from\
    \ a source that does not have\n   its own URI, such as input from the user keyboard.\n\
    \       Referer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\n   Example:\n\
    \       Referer: http://www.w3.org/hypertext/DataSources/Overview.html\n   If\
    \ the field value is a relative URI, it SHOULD be interpreted\n   relative to\
    \ the Request-URI. The URI MUST NOT include a fragment. See\n   section 15.1.3\
    \ for security considerations.\n"
- title: 14.37 Retry-After
  contents:
  - "14.37 Retry-After\n   The Retry-After response-header field can be used with\
    \ a 503 (Service\n   Unavailable) response to indicate how long the service is\
    \ expected to\n   be unavailable to the requesting client. This field MAY also\
    \ be used\n   with any 3xx (Redirection) response to indicate the minimum time\
    \ the\n   user-agent is asked wait before issuing the redirected request. The\n\
    \   value of this field can be either an HTTP-date or an integer number\n   of\
    \ seconds (in decimal) after the time of the response.\n       Retry-After  =\
    \ \"Retry-After\" \":\" ( HTTP-date | delta-seconds )\n   Two examples of its\
    \ use are\n       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT\n       Retry-After:\
    \ 120\n   In the latter example, the delay is 2 minutes.\n"
- title: 14.38 Server
  contents:
  - "14.38 Server\n   The Server response-header field contains information about\
    \ the\n   software used by the origin server to handle the request. The field\n\
    \   can contain multiple product tokens (section 3.8) and comments\n   identifying\
    \ the server and any significant subproducts. The product\n   tokens are listed\
    \ in order of their significance for identifying the\n   application.\n      \
    \ Server         = \"Server\" \":\" 1*( product | comment )\n   Example:\n   \
    \    Server: CERN/3.0 libwww/2.17\n   If the response is being forwarded through\
    \ a proxy, the proxy\n   application MUST NOT modify the Server response-header.\
    \ Instead, it\n   SHOULD include a Via field (as described in section 14.45).\n\
    \      Note: Revealing the specific software version of the server might\n   \
    \   allow the server machine to become more vulnerable to attacks\n      against\
    \ software that is known to contain security holes. Server\n      implementors\
    \ are encouraged to make this field a configurable\n      option.\n"
- title: 14.39 TE
  contents:
  - "14.39 TE\n   The TE request-header field indicates what extension transfer-codings\n\
    \   it is willing to accept in the response and whether or not it is\n   willing\
    \ to accept trailer fields in a chunked transfer-coding. Its\n   value may consist\
    \ of the keyword \"trailers\" and/or a comma-separated\n   list of extension transfer-coding\
    \ names with optional accept\n   parameters (as described in section 3.6).\n \
    \      TE        = \"TE\" \":\" #( t-codings )\n       t-codings = \"trailers\"\
    \ | ( transfer-extension [ accept-params ] )\n   The presence of the keyword \"\
    trailers\" indicates that the client is\n   willing to accept trailer fields in\
    \ a chunked transfer-coding, as\n   defined in section 3.6.1. This keyword is\
    \ reserved for use with\n   transfer-coding values even though it does not itself\
    \ represent a\n   transfer-coding.\n   Examples of its use are:\n       TE: deflate\n\
    \       TE:\n       TE: trailers, deflate;q=0.5\n   The TE header field only applies\
    \ to the immediate connection.\n   Therefore, the keyword MUST be supplied within\
    \ a Connection header\n   field (section 14.10) whenever TE is present in an HTTP/1.1\
    \ message.\n   A server tests whether a transfer-coding is acceptable, according\
    \ to\n   a TE field, using these rules:\n      1. The \"chunked\" transfer-coding\
    \ is always acceptable. If the\n         keyword \"trailers\" is listed, the client\
    \ indicates that it is\n         willing to accept trailer fields in the chunked\
    \ response on\n         behalf of itself and any downstream clients. The implication\
    \ is\n         that, if given, the client is stating that either all\n       \
    \  downstream clients are willing to accept trailer fields in the\n         forwarded\
    \ response, or that it will attempt to buffer the\n         response on behalf\
    \ of downstream recipients.\n         Note: HTTP/1.1 does not define any means\
    \ to limit the size of a\n         chunked response such that a client can be\
    \ assured of buffering\n         the entire response.\n      2. If the transfer-coding\
    \ being tested is one of the transfer-\n         codings listed in the TE field,\
    \ then it is acceptable unless it\n         is accompanied by a qvalue of 0. (As\
    \ defined in section 3.9, a\n         qvalue of 0 means \"not acceptable.\")\n\
    \      3. If multiple transfer-codings are acceptable, then the\n         acceptable\
    \ transfer-coding with the highest non-zero qvalue is\n         preferred.  The\
    \ \"chunked\" transfer-coding always has a qvalue\n         of 1.\n   If the TE\
    \ field-value is empty or if no TE field is present, the only\n   transfer-coding\
    \  is \"chunked\". A message with no transfer-coding is\n   always acceptable.\n"
- title: 14.40 Trailer
  contents:
  - "14.40 Trailer\n   The Trailer general field value indicates that the given set\
    \ of\n   header fields is present in the trailer of a message encoded with\n \
    \  chunked transfer-coding.\n       Trailer  = \"Trailer\" \":\" 1#field-name\n\
    \   An HTTP/1.1 message SHOULD include a Trailer header field in a\n   message\
    \ using chunked transfer-coding with a non-empty trailer. Doing\n   so allows\
    \ the recipient to know which header fields to expect in the\n   trailer.\n  \
    \ If no Trailer header field is present, the trailer SHOULD NOT include\n   any\
    \ header fields. See section 3.6.1 for restrictions on the use of\n   trailer\
    \ fields in a \"chunked\" transfer-coding.\n   Message header fields listed in\
    \ the Trailer header field MUST NOT\n   include the following header fields:\n\
    \      . Transfer-Encoding\n      . Content-Length\n      . Trailer\n"
- title: 14.41 Transfer-Encoding
  contents:
  - "14.41 Transfer-Encoding\n   The Transfer-Encoding general-header field indicates\
    \ what (if any)\n   type of transformation has been applied to the message body\
    \ in order\n   to safely transfer it between the sender and the recipient. This\n\
    \   differs from the content-coding in that the transfer-coding is a\n   property\
    \ of the message, not of the entity.\n     Transfer-Encoding       = \"Transfer-Encoding\"\
    \ \":\" 1#transfer-coding\n   Transfer-codings are defined in section 3.6. An\
    \ example is:\n     Transfer-Encoding: chunked\n   If multiple encodings have\
    \ been applied to an entity, the transfer-\n   codings MUST be listed in the order\
    \ in which they were applied.\n   Additional information about the encoding parameters\
    \ MAY be provided\n   by other entity-header fields not defined by this specification.\n\
    \   Many older HTTP/1.0 applications do not understand the Transfer-\n   Encoding\
    \ header.\n"
- title: 14.42 Upgrade
  contents:
  - "14.42 Upgrade\n   The Upgrade general-header allows the client to specify what\n\
    \   additional communication protocols it supports and would like to use\n   if\
    \ the server finds it appropriate to switch protocols. The server\n   MUST use\
    \ the Upgrade header field within a 101 (Switching Protocols)\n   response to\
    \ indicate which protocol(s) are being switched.\n       Upgrade        = \"Upgrade\"\
    \ \":\" 1#product\n   For example,\n       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9,\
    \ RTA/x11\n   The Upgrade header field is intended to provide a simple mechanism\n\
    \   for transition from HTTP/1.1 to some other, incompatible protocol. It\n  \
    \ does so by allowing the client to advertise its desire to use another\n   protocol,\
    \ such as a later version of HTTP with a higher major version\n   number, even\
    \ though the current request has been made using HTTP/1.1.\n   This eases the\
    \ difficult transition between incompatible protocols by\n   allowing the client\
    \ to initiate a request in the more commonly\n   supported protocol while indicating\
    \ to the server that it would like\n   to use a \"better\" protocol if available\
    \ (where \"better\" is determined\n   by the server, possibly according to the\
    \ nature of the method and/or\n   resource being requested).\n   The Upgrade header\
    \ field only applies to switching application-layer\n   protocols upon the existing\
    \ transport-layer connection. Upgrade\n   cannot be used to insist on a protocol\
    \ change; its acceptance and use\n   by the server is optional. The capabilities\
    \ and nature of the\n   application-layer communication after the protocol change\
    \ is entirely\n   dependent upon the new protocol chosen, although the first action\n\
    \   after changing the protocol MUST be a response to the initial HTTP\n   request\
    \ containing the Upgrade header field.\n   The Upgrade header field only applies\
    \ to the immediate connection.\n   Therefore, the upgrade keyword MUST be supplied\
    \ within a Connection\n   header field (section 14.10) whenever Upgrade is present\
    \ in an\n   HTTP/1.1 message.\n   The Upgrade header field cannot be used to indicate\
    \ a switch to a\n   protocol on a different connection. For that purpose, it is\
    \ more\n   appropriate to use a 301, 302, 303, or 305 redirection response.\n\
    \   This specification only defines the protocol name \"HTTP\" for use by\n  \
    \ the family of Hypertext Transfer Protocols, as defined by the HTTP\n   version\
    \ rules of section 3.1 and future updates to this\n   specification. Any token\
    \ can be used as a protocol name; however, it\n   will only be useful if both\
    \ the client and server associate the name\n   with the same protocol.\n"
- title: 14.43 User-Agent
  contents:
  - "14.43 User-Agent\n   The User-Agent request-header field contains information\
    \ about the\n   user agent originating the request. This is for statistical purposes,\n\
    \   the tracing of protocol violations, and automated recognition of user\n  \
    \ agents for the sake of tailoring responses to avoid particular user\n   agent\
    \ limitations. User agents SHOULD include this field with\n   requests. The field\
    \ can contain multiple product tokens (section 3.8)\n   and comments identifying\
    \ the agent and any subproducts which form a\n   significant part of the user\
    \ agent. By convention, the product tokens\n   are listed in order of their significance\
    \ for identifying the\n   application.\n       User-Agent     = \"User-Agent\"\
    \ \":\" 1*( product | comment )\n   Example:\n       User-Agent: CERN-LineMode/2.15\
    \ libwww/2.17b3\n"
- title: 14.44 Vary
  contents:
  - "14.44 Vary\n   The Vary field value indicates the set of request-header fields\
    \ that\n   fully determines, while the response is fresh, whether a cache is\n\
    \   permitted to use the response to reply to a subsequent request\n   without\
    \ revalidation. For uncacheable or stale responses, the Vary\n   field value advises\
    \ the user agent about the criteria that were used\n   to select the representation.\
    \ A Vary field value of \"*\" implies that\n   a cache cannot determine from the\
    \ request headers of a subsequent\n   request whether this response is the appropriate\
    \ representation. See\n   section 13.6 for use of the Vary header field by caches.\n\
    \       Vary  = \"Vary\" \":\" ( \"*\" | 1#field-name )\n   An HTTP/1.1 server\
    \ SHOULD include a Vary header field with any\n   cacheable response that is subject\
    \ to server-driven negotiation.\n   Doing so allows a cache to properly interpret\
    \ future requests on that\n   resource and informs the user agent about the presence\
    \ of negotiation\n   on that resource. A server MAY include a Vary header field\
    \ with a\n   non-cacheable response that is subject to server-driven negotiation,\n\
    \   since this might provide the user agent with useful information about\n  \
    \ the dimensions over which the response varies at the time of the\n   response.\n\
    \   A Vary field value consisting of a list of field-names signals that\n   the\
    \ representation selected for the response is based on a selection\n   algorithm\
    \ which considers ONLY the listed request-header field values\n   in selecting\
    \ the most appropriate representation. A cache MAY assume\n   that the same selection\
    \ will be made for future requests with the\n   same values for the listed field\
    \ names, for the duration of time for\n   which the response is fresh.\n   The\
    \ field-names given are not limited to the set of standard\n   request-header\
    \ fields defined by this specification. Field names are\n   case-insensitive.\n\
    \   A Vary field value of \"*\" signals that unspecified parameters not\n   limited\
    \ to the request-headers (e.g., the network address of the\n   client), play a\
    \ role in the selection of the response representation.\n   The \"*\" value MUST\
    \ NOT be generated by a proxy server; it may only be\n   generated by an origin\
    \ server.\n"
- title: 14.45  Via
  contents:
  - "14.45  Via\n   The Via general-header field MUST be used by gateways and proxies\
    \ to\n   indicate the intermediate protocols and recipients between the user\n\
    \   agent and the server on requests, and between the origin server and\n   the\
    \ client on responses. It is analogous to the \"Received\" field of\n   RFC 822\
    \ [9] and is intended to be used for tracking message forwards,\n   avoiding request\
    \ loops, and identifying the protocol capabilities of\n   all senders along the\
    \ request/response chain.\n      Via =  \"Via\" \":\" 1#( received-protocol received-by\
    \ [ comment ] )\n      received-protocol = [ protocol-name \"/\" ] protocol-version\n\
    \      protocol-name     = token\n      protocol-version  = token\n      received-by\
    \       = ( host [ \":\" port ] ) | pseudonym\n      pseudonym         = token\n\
    \   The received-protocol indicates the protocol version of the message\n   received\
    \ by the server or client along each segment of the\n   request/response chain.\
    \ The received-protocol version is appended to\n   the Via field value when the\
    \ message is forwarded so that information\n   about the protocol capabilities\
    \ of upstream applications remains\n   visible to all recipients.\n   The protocol-name\
    \ is optional if and only if it would be \"HTTP\". The\n   received-by field is\
    \ normally the host and optional port number of a\n   recipient server or client\
    \ that subsequently forwarded the message.\n   However, if the real host is considered\
    \ to be sensitive information,\n   it MAY be replaced by a pseudonym. If the port\
    \ is not given, it MAY\n   be assumed to be the default port of the received-protocol.\n\
    \   Multiple Via field values represents each proxy or gateway that has\n   forwarded\
    \ the message. Each recipient MUST append its information\n   such that the end\
    \ result is ordered according to the sequence of\n   forwarding applications.\n\
    \   Comments MAY be used in the Via header field to identify the software\n  \
    \ of the recipient proxy or gateway, analogous to the User-Agent and\n   Server\
    \ header fields. However, all comments in the Via field are\n   optional and MAY\
    \ be removed by any recipient prior to forwarding the\n   message.\n   For example,\
    \ a request message could be sent from an HTTP/1.0 user\n   agent to an internal\
    \ proxy code-named \"fred\", which uses HTTP/1.1 to\n   forward the request to\
    \ a public proxy at nowhere.com, which completes\n   the request by forwarding\
    \ it to the origin server at www.ics.uci.edu.\n   The request received by www.ics.uci.edu\
    \ would then have the following\n   Via header field:\n       Via: 1.0 fred, 1.1\
    \ nowhere.com (Apache/1.1)\n   Proxies and gateways used as a portal through a\
    \ network firewall\n   SHOULD NOT, by default, forward the names and ports of\
    \ hosts within\n   the firewall region. This information SHOULD only be propagated\
    \ if\n   explicitly enabled. If not enabled, the received-by host of any host\n\
    \   behind the firewall SHOULD be replaced by an appropriate pseudonym\n   for\
    \ that host.\n   For organizations that have strong privacy requirements for hiding\n\
    \   internal structures, a proxy MAY combine an ordered subsequence of\n   Via\
    \ header field entries with identical received-protocol values into\n   a single\
    \ such entry. For example,\n       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy\n\
    \        could be collapsed to\n       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy\n \
    \  Applications SHOULD NOT combine multiple entries unless they are all\n   under\
    \ the same organizational control and the hosts have already been\n   replaced\
    \ by pseudonyms. Applications MUST NOT combine entries which\n   have different\
    \ received-protocol values.\n"
- title: 14.46 Warning
  contents:
  - "14.46 Warning\n   The Warning general-header field is used to carry additional\n\
    \   information about the status or transformation of a message which\n   might\
    \ not be reflected in the message. This information is typically\n   used to warn\
    \ about a possible lack of semantic transparency from\n   caching operations or\
    \ transformations applied to the entity body of\n   the message.\n   Warning headers\
    \ are sent with responses using:\n       Warning    = \"Warning\" \":\" 1#warning-value\n\
    \       warning-value = warn-code SP warn-agent SP warn-text\n               \
    \                              [SP warn-date]\n       warn-code  = 3DIGIT\n  \
    \     warn-agent = ( host [ \":\" port ] ) | pseudonym\n                     \
    \  ; the name or pseudonym of the server adding\n                       ; the\
    \ Warning header, for use in debugging\n       warn-text  = quoted-string\n  \
    \     warn-date  = <\"> HTTP-date <\">\n   A response MAY carry more than one\
    \ Warning header.\n   The warn-text SHOULD be in a natural language and character\
    \ set that\n   is most likely to be intelligible to the human user receiving the\n\
    \   response. This decision MAY be based on any available knowledge, such\n  \
    \ as the location of the cache or user, the Accept-Language field in a\n   request,\
    \ the Content-Language field in a response, etc. The default\n   language is English\
    \ and the default character set is ISO-8859-1.\n   If a character set other than\
    \ ISO-8859-1 is used, it MUST be encoded\n   in the warn-text using the method\
    \ described in RFC 2047 [14].\n   Warning headers can in general be applied to\
    \ any message, however\n   some specific warn-codes are specific to caches and\
    \ can only be\n   applied to response messages. New Warning headers SHOULD be\
    \ added\n   after any existing Warning headers. A cache MUST NOT delete any\n\
    \   Warning header that it received with a message. However, if a cache\n   successfully\
    \ validates a cache entry, it SHOULD remove any Warning\n   headers previously\
    \ attached to that entry except as specified for\n   specific Warning codes. It\
    \ MUST then add any Warning headers received\n   in the validating response. In\
    \ other words, Warning headers are those\n   that would be attached to the most\
    \ recent relevant response.\n   When multiple Warning headers are attached to\
    \ a response, the user\n   agent ought to inform the user of as many of them as\
    \ possible, in the\n   order that they appear in the response. If it is not possible\
    \ to\n   inform the user of all of the warnings, the user agent SHOULD follow\n\
    \   these heuristics:\n      - Warnings that appear early in the response take\
    \ priority over\n        those appearing later in the response.\n      - Warnings\
    \ in the user's preferred character set take priority\n        over warnings in\
    \ other character sets but with identical warn-\n        codes and warn-agents.\n\
    \   Systems that generate multiple Warning headers SHOULD order them with\n  \
    \ this user agent behavior in mind.\n   Requirements for the behavior of caches\
    \ with respect to Warnings are\n   stated in section 13.1.2.\n   This is a list\
    \ of the currently-defined warn-codes, each with a\n   recommended warn-text in\
    \ English, and a description of its meaning.\n   110 Response is stale\n     MUST\
    \ be included whenever the returned response is stale.\n   111 Revalidation failed\n\
    \     MUST be included if a cache returns a stale response because an\n     attempt\
    \ to revalidate the response failed, due to an inability to\n     reach the server.\n\
    \   112 Disconnected operation\n     SHOULD be included if the cache is intentionally\
    \ disconnected from\n     the rest of the network for a period of time.\n   113\
    \ Heuristic expiration\n     MUST be included if the cache heuristically chose\
    \ a freshness\n     lifetime greater than 24 hours and the response's age is greater\n\
    \     than 24 hours.\n   199 Miscellaneous warning\n     The warning text MAY\
    \ include arbitrary information to be presented\n     to a human user, or logged.\
    \ A system receiving this warning MUST\n     NOT take any automated action, besides\
    \ presenting the warning to\n     the user.\n   214 Transformation applied\n \
    \    MUST be added by an intermediate cache or proxy if it applies any\n     transformation\
    \ changing the content-coding (as specified in the\n     Content-Encoding header)\
    \ or media-type (as specified in the\n     Content-Type header) of the response,\
    \ or the entity-body of the\n     response, unless this Warning code already appears\
    \ in the response.\n   299 Miscellaneous persistent warning\n     The warning\
    \ text MAY include arbitrary information to be presented\n     to a human user,\
    \ or logged. A system receiving this warning MUST\n     NOT take any automated\
    \ action.\n   If an implementation sends a message with one or more Warning headers\n\
    \   whose version is HTTP/1.0 or lower, then the sender MUST include in\n   each\
    \ warning-value a warn-date that matches the date in the response.\n   If an implementation\
    \ receives a message with a warning-value that\n   includes a warn-date, and that\
    \ warn-date is different from the Date\n   value in the response, then that warning-value\
    \ MUST be deleted from\n   the message before storing, forwarding, or using it.\
    \ (This prevents\n   bad consequences of naive caching of Warning header fields.)\
    \ If all\n   of the warning-values are deleted for this reason, the Warning header\n\
    \   MUST be deleted as well.\n"
- title: 14.47 WWW-Authenticate
  contents:
  - "14.47 WWW-Authenticate\n   The WWW-Authenticate response-header field MUST be\
    \ included in 401\n   (Unauthorized) response messages. The field value consists\
    \ of at\n   least one challenge that indicates the authentication scheme(s) and\n\
    \   parameters applicable to the Request-URI.\n       WWW-Authenticate  = \"WWW-Authenticate\"\
    \ \":\" 1#challenge\n   The HTTP access authentication process is described in\
    \ \"HTTP\n   Authentication: Basic and Digest Access Authentication\" [43]. User\n\
    \   agents are advised to take special care in parsing the WWW-\n   Authenticate\
    \ field value as it might contain more than one challenge,\n   or if more than\
    \ one WWW-Authenticate header field is provided, the\n   contents of a challenge\
    \ itself can contain a comma-separated list of\n   authentication parameters.\n"
- title: 15 Security Considerations
  contents:
  - "15 Security Considerations\n   This section is meant to inform application developers,\
    \ information\n   providers, and users of the security limitations in HTTP/1.1\
    \ as\n   described by this document. The discussion does not include\n   definitive\
    \ solutions to the problems revealed, though it does make\n   some suggestions\
    \ for reducing security risks.\n"
- title: 15.1 Personal Information
  contents:
  - "15.1 Personal Information\n   HTTP clients are often privy to large amounts of\
    \ personal information\n   (e.g. the user's name, location, mail address, passwords,\
    \ encryption\n   keys, etc.), and SHOULD be very careful to prevent unintentional\n\
    \   leakage of this information via the HTTP protocol to other sources.\n   We\
    \ very strongly recommend that a convenient interface be provided\n   for the\
    \ user to control dissemination of such information, and that\n   designers and\
    \ implementors be particularly careful in this area.\n   History shows that errors\
    \ in this area often create serious security\n   and/or privacy problems and generate\
    \ highly adverse publicity for the\n   implementor's company.\n"
- title: 15.1.1 Abuse of Server Log Information
  contents:
  - "15.1.1 Abuse of Server Log Information\n   A server is in the position to save\
    \ personal data about a user's\n   requests which might identify their reading\
    \ patterns or subjects of\n   interest. This information is clearly confidential\
    \ in nature and its\n   handling can be constrained by law in certain countries.\
    \ People using\n   the HTTP protocol to provide data are responsible for ensuring\
    \ that\n   such material is not distributed without the permission of any\n  \
    \ individuals that are identifiable by the published results.\n"
- title: 15.1.2 Transfer of Sensitive Information
  contents:
  - "15.1.2 Transfer of Sensitive Information\n   Like any generic data transfer protocol,\
    \ HTTP cannot regulate the\n   content of the data that is transferred, nor is\
    \ there any a priori\n   method of determining the sensitivity of any particular\
    \ piece of\n   information within the context of any given request. Therefore,\n\
    \   applications SHOULD supply as much control over this information as\n   possible\
    \ to the provider of that information. Four header fields are\n   worth special\
    \ mention in this context: Server, Via, Referer and From.\n   Revealing the specific\
    \ software version of the server might allow the\n   server machine to become\
    \ more vulnerable to attacks against software\n   that is known to contain security\
    \ holes. Implementors SHOULD make the\n   Server header field a configurable option.\n\
    \   Proxies which serve as a portal through a network firewall SHOULD\n   take\
    \ special precautions regarding the transfer of header information\n   that identifies\
    \ the hosts behind the firewall. In particular, they\n   SHOULD remove, or replace\
    \ with sanitized versions, any Via fields\n   generated behind the firewall.\n\
    \   The Referer header allows reading patterns to be studied and reverse\n   links\
    \ drawn. Although it can be very useful, its power can be abused\n   if user details\
    \ are not separated from the information contained in\n   the Referer. Even when\
    \ the personal information has been removed, the\n   Referer header might indicate\
    \ a private document's URI whose\n   publication would be inappropriate.\n   The\
    \ information sent in the From field might conflict with the user's\n   privacy\
    \ interests or their site's security policy, and hence it\n   SHOULD NOT be transmitted\
    \ without the user being able to disable,\n   enable, and modify the contents\
    \ of the field. The user MUST be able\n   to set the contents of this field within\
    \ a user preference or\n   application defaults configuration.\n   We suggest,\
    \ though do not require, that a convenient toggle interface\n   be provided for\
    \ the user to enable or disable the sending of From and\n   Referer information.\n\
    \   The User-Agent (section 14.43) or Server (section 14.38) header\n   fields\
    \ can sometimes be used to determine that a specific client or\n   server have\
    \ a particular security hole which might be exploited.\n   Unfortunately, this\
    \ same information is often used for other valuable\n   purposes for which HTTP\
    \ currently has no better mechanism.\n"
- title: 15.1.3 Encoding Sensitive Information in URI's
  contents:
  - "15.1.3 Encoding Sensitive Information in URI's\n   Because the source of a link\
    \ might be private information or might\n   reveal an otherwise private information\
    \ source, it is strongly\n   recommended that the user be able to select whether\
    \ or not the\n   Referer field is sent. For example, a browser client could have\
    \ a\n   toggle switch for browsing openly/anonymously, which would\n   respectively\
    \ enable/disable the sending of Referer and From\n   information.\n   Clients\
    \ SHOULD NOT include a Referer header field in a (non-secure)\n   HTTP request\
    \ if the referring page was transferred with a secure\n   protocol.\n   Authors\
    \ of services which use the HTTP protocol SHOULD NOT use GET\n   based forms for\
    \ the submission of sensitive data, because this will\n   cause this data to be\
    \ encoded in the Request-URI. Many existing\n   servers, proxies, and user agents\
    \ will log the request URI in some\n   place where it might be visible to third\
    \ parties. Servers can use\n   POST-based form submission instead\n"
- title: 15.1.4 Privacy Issues Connected to Accept Headers
  contents:
  - "15.1.4 Privacy Issues Connected to Accept Headers\n   Accept request-headers\
    \ can reveal information about the user to all\n   servers which are accessed.\
    \ The Accept-Language header in particular\n   can reveal information the user\
    \ would consider to be of a private\n   nature, because the understanding of particular\
    \ languages is often\n   strongly correlated to the membership of a particular\
    \ ethnic group.\n   User agents which offer the option to configure the contents\
    \ of an\n   Accept-Language header to be sent in every request are strongly\n\
    \   encouraged to let the configuration process include a message which\n   makes\
    \ the user aware of the loss of privacy involved.\n   An approach that limits\
    \ the loss of privacy would be for a user agent\n   to omit the sending of Accept-Language\
    \ headers by default, and to ask\n   the user whether or not to start sending\
    \ Accept-Language headers to a\n   server if it detects, by looking for any Vary\
    \ response-header fields\n   generated by the server, that such sending could\
    \ improve the quality\n   of service.\n   Elaborate user-customized accept header\
    \ fields sent in every request,\n   in particular if these include quality values,\
    \ can be used by servers\n   as relatively reliable and long-lived user identifiers.\
    \ Such user\n   identifiers would allow content providers to do click-trail tracking,\n\
    \   and would allow collaborating content providers to match cross-server\n  \
    \ click-trails or form submissions of individual users. Note that for\n   many\
    \ users not behind a proxy, the network address of the host\n   running the user\
    \ agent will also serve as a long-lived user\n   identifier. In environments where\
    \ proxies are used to enhance\n   privacy, user agents ought to be conservative\
    \ in offering accept\n   header configuration options to end users. As an extreme\
    \ privacy\n   measure, proxies could filter the accept headers in relayed requests.\n\
    \   General purpose user agents which provide a high degree of header\n   configurability\
    \ SHOULD warn users about the loss of privacy which can\n   be involved.\n"
- title: 15.2 Attacks Based On File and Path Names
  contents:
  - "15.2 Attacks Based On File and Path Names\n   Implementations of HTTP origin\
    \ servers SHOULD be careful to restrict\n   the documents returned by HTTP requests\
    \ to be only those that were\n   intended by the server administrators. If an\
    \ HTTP server translates\n   HTTP URIs directly into file system calls, the server\
    \ MUST take\n   special care not to serve files that were not intended to be\n\
    \   delivered to HTTP clients. For example, UNIX, Microsoft Windows, and\n   other\
    \ operating systems use \"..\" as a path component to indicate a\n   directory\
    \ level above the current one. On such a system, an HTTP\n   server MUST disallow\
    \ any such construct in the Request-URI if it\n   would otherwise allow access\
    \ to a resource outside those intended to\n   be accessible via the HTTP server.\
    \ Similarly, files intended for\n   reference only internally to the server (such\
    \ as access control\n   files, configuration files, and script code) MUST be protected\
    \ from\n   inappropriate retrieval, since they might contain sensitive\n   information.\
    \ Experience has shown that minor bugs in such HTTP server\n   implementations\
    \ have turned into security risks.\n"
- title: 15.3 DNS Spoofing
  contents:
  - "15.3 DNS Spoofing\n   Clients using HTTP rely heavily on the Domain Name Service,\
    \ and are\n   thus generally prone to security attacks based on the deliberate\n\
    \   mis-association of IP addresses and DNS names. Clients need to be\n   cautious\
    \ in assuming the continuing validity of an IP number/DNS name\n   association.\n\
    \   In particular, HTTP clients SHOULD rely on their name resolver for\n   confirmation\
    \ of an IP number/DNS name association, rather than\n   caching the result of\
    \ previous host name lookups. Many platforms\n   already can cache host name lookups\
    \ locally when appropriate, and\n   they SHOULD be configured to do so. It is\
    \ proper for these lookups to\n   be cached, however, only when the TTL (Time\
    \ To Live) information\n   reported by the name server makes it likely that the\
    \ cached\n   information will remain useful.\n   If HTTP clients cache the results\
    \ of host name lookups in order to\n   achieve a performance improvement, they\
    \ MUST observe the TTL\n   information reported by DNS.\n   If HTTP clients do\
    \ not observe this rule, they could be spoofed when\n   a previously-accessed\
    \ server's IP address changes. As network\n   renumbering is expected to become\
    \ increasingly common [24], the\n   possibility of this form of attack will grow.\
    \ Observing this\n   requirement thus reduces this potential security vulnerability.\n\
    \   This requirement also improves the load-balancing behavior of clients\n  \
    \ for replicated servers using the same DNS name and reduces the\n   likelihood\
    \ of a user's experiencing failure in accessing sites which\n   use that strategy.\n"
- title: 15.4 Location Headers and Spoofing
  contents:
  - "15.4 Location Headers and Spoofing\n   If a single server supports multiple organizations\
    \ that do not trust\n   one another, then it MUST check the values of Location\
    \ and Content-\n   Location headers in responses that are generated under control\
    \ of\n   said organizations to make sure that they do not attempt to\n   invalidate\
    \ resources over which they have no authority.\n"
- title: 15.5 Content-Disposition Issues
  contents:
  - "15.5 Content-Disposition Issues\n   RFC 1806 [35], from which the often implemented\
    \ Content-Disposition\n   (see section 19.5.1) header in HTTP is derived, has\
    \ a number of very\n   serious security considerations. Content-Disposition is\
    \ not part of\n   the HTTP standard, but since it is widely implemented, we are\n\
    \   documenting its use and risks for implementors. See RFC 2183 [49]\n   (which\
    \ updates RFC 1806) for details.\n"
- title: 15.6 Authentication Credentials and Idle Clients
  contents:
  - "15.6 Authentication Credentials and Idle Clients\n   Existing HTTP clients and\
    \ user agents typically retain authentication\n   information indefinitely. HTTP/1.1.\
    \ does not provide a method for a\n   server to direct clients to discard these\
    \ cached credentials. This is\n   a significant defect that requires further extensions\
    \ to HTTP.\n   Circumstances under which credential caching can interfere with\
    \ the\n   application's security model include but are not limited to:\n     \
    \ - Clients which have been idle for an extended period following\n        which\
    \ the server might wish to cause the client to reprompt the\n        user for\
    \ credentials.\n      - Applications which include a session termination indication\n\
    \        (such as a `logout' or `commit' button on a page) after which\n     \
    \   the server side of the application `knows' that there is no\n        further\
    \ reason for the client to retain the credentials.\n   This is currently under\
    \ separate study. There are a number of work-\n   arounds to parts of this problem,\
    \ and we encourage the use of\n   password protection in screen savers, idle time-outs,\
    \ and other\n   methods which mitigate the security problems inherent in this\n\
    \   problem. In particular, user agents which cache credentials are\n   encouraged\
    \ to provide a readily accessible mechanism for discarding\n   cached credentials\
    \ under user control.\n"
- title: 15.7 Proxies and Caching
  contents:
  - "15.7 Proxies and Caching\n   By their very nature, HTTP proxies are men-in-the-middle,\
    \ and\n   represent an opportunity for man-in-the-middle attacks. Compromise of\n\
    \   the systems on which the proxies run can result in serious security\n   and\
    \ privacy problems. Proxies have access to security-related\n   information, personal\
    \ information about individual users and\n   organizations, and proprietary information\
    \ belonging to users and\n   content providers. A compromised proxy, or a proxy\
    \ implemented or\n   configured without regard to security and privacy considerations,\n\
    \   might be used in the commission of a wide range of potential attacks.\n  \
    \ Proxy operators should protect the systems on which proxies run as\n   they\
    \ would protect any system that contains or transports sensitive\n   information.\
    \ In particular, log information gathered at proxies often\n   contains highly\
    \ sensitive personal information, and/or information\n   about organizations.\
    \ Log information should be carefully guarded, and\n   appropriate guidelines\
    \ for use developed and followed. (Section\n   15.1.1).\n   Caching proxies provide\
    \ additional potential vulnerabilities, since\n   the contents of the cache represent\
    \ an attractive target for\n   malicious exploitation. Because cache contents\
    \ persist after an HTTP\n   request is complete, an attack on the cache can reveal\
    \ information\n   long after a user believes that the information has been removed\
    \ from\n   the network. Therefore, cache contents should be protected as\n   sensitive\
    \ information.\n   Proxy implementors should consider the privacy and security\n\
    \   implications of their design and coding decisions, and of the\n   configuration\
    \ options they provide to proxy operators (especially the\n   default configuration).\n\
    \   Users of a proxy need to be aware that they are no trustworthier than\n  \
    \ the people who run the proxy; HTTP itself cannot solve this problem.\n   The\
    \ judicious use of cryptography, when appropriate, may suffice to\n   protect\
    \ against a broad range of security and privacy attacks. Such\n   cryptography\
    \ is beyond the scope of the HTTP/1.1 specification.\n"
- title: 15.7.1 Denial of Service Attacks on Proxies
  contents:
  - "15.7.1 Denial of Service Attacks on Proxies\n   They exist. They are hard to\
    \ defend against. Research continues.\n   Beware.\n"
- title: 16 Acknowledgments
  contents:
  - "16 Acknowledgments\n   This specification makes heavy use of the augmented BNF\
    \ and generic\n   constructs defined by David H. Crocker for RFC 822 [9]. Similarly,\
    \ it\n   reuses many of the definitions provided by Nathaniel Borenstein and\n\
    \   Ned Freed for MIME [7]. We hope that their inclusion in this\n   specification\
    \ will help reduce past confusion over the relationship\n   between HTTP and Internet\
    \ mail message formats.\n   The HTTP protocol has evolved considerably over the\
    \ years. It has\n   benefited from a large and active developer community--the\
    \ many\n   people who have participated on the www-talk mailing list--and it is\n\
    \   that community which has been most responsible for the success of\n   HTTP\
    \ and of the World-Wide Web in general. Marc Andreessen, Robert\n   Cailliau,\
    \ Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois\n   Groff, Phillip\
    \ M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob\n   McCool, Lou Montulli, Dave\
    \ Raggett, Tony Sanders, and Marc\n   VanHeyningen deserve special recognition\
    \ for their efforts in\n   defining early aspects of the protocol.\n   This document\
    \ has benefited greatly from the comments of all those\n   participating in the\
    \ HTTP-WG. In addition to those already mentioned,\n   the following individuals\
    \ have contributed to this specification:\n       Gary Adams                 \
    \ Ross Patterson\n       Harald Tveit Alvestrand     Albert Lunde\n       Keith\
    \ Ball                  John C. Mallery\n       Brian Behlendorf            Jean-Philippe\
    \ Martin-Flatin\n       Paul Burchard               Mitra\n       Maurizio Codogno\
    \            David Morris\n       Mike Cowlishaw              Gavin Nicol\n  \
    \     Roman Czyborra              Bill Perry\n       Michael A. Dolan        \
    \    Jeffrey Perry\n       David J. Fiander            Scott Powers\n       Alan\
    \ Freier                 Owen Rees\n       Marc Hedlund                Luigi Rizzo\n\
    \       Greg Herlihy                David Robinson\n       Koen Holtman      \
    \          Marc Salomon\n       Alex Hopmann                Rich Salz\n      \
    \ Bob Jernigan                Allan M. Schiffman\n       Shel Kaphan         \
    \        Jim Seidman\n       Rohit Khare                 Chuck Shotton\n     \
    \  John Klensin                Eric W. Sink\n       Martijn Koster           \
    \   Simon E. Spero\n       Alexei Kosut                Richard N. Taylor\n   \
    \    David M. Kristol            Robert S. Thau\n       Daniel LaLiberte     \
    \       Bill (BearHeart) Weinman\n       Ben Laurie                  Francois\
    \ Yergeau\n       Paul J. Leach               Mary Ellen Zurko\n       Daniel\
    \ DuBois               Josh Cohen\n   Much of the content and presentation of\
    \ the caching design is due to\n   suggestions and comments from individuals including:\
    \ Shel Kaphan,\n   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.\n\
    \   Most of the specification of ranges is based on work originally done\n   by\
    \ Ari Luotonen and John Franks, with additional input from Steve\n   Zilles.\n\
    \   Thanks to the \"cave men\" of Palo Alto. You know who you are.\n   Jim Gettys\
    \ (the current editor of this document) wishes particularly\n   to thank Roy Fielding,\
    \ the previous editor of this document, along\n   with John Klensin, Jeff Mogul,\
    \ Paul Leach, Dave Kristol, Koen\n   Holtman, John Franks, Josh Cohen, Alex Hopmann,\
    \ Scott Lawrence, and\n   Larry Masinter for their help. And thanks go particularly\
    \ to Jeff\n   Mogul and Scott Lawrence for performing the \"MUST/MAY/SHOULD\"\
    \ audit.\n   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik\n\
    \   Frystyk implemented RFC 2068 early, and we wish to thank them for the\n  \
    \ discovery of many of the problems that this document attempts to\n   rectify.\n"
- title: 17 References
  contents:
  - "17 References\n   [1] Alvestrand, H., \"Tags for the Identification of Languages\"\
    , RFC\n       1766, March 1995.\n   [2] Anklesaria, F., McCahill, M., Lindner,\
    \ P., Johnson, D., Torrey,\n       D. and B. Alberti, \"The Internet Gopher Protocol\
    \ (a distributed\n       document search and retrieval protocol)\", RFC 1436,\
    \ March 1993.\n   [3] Berners-Lee, T., \"Universal Resource Identifiers in WWW\"\
    , RFC\n       1630, June 1994.\n   [4] Berners-Lee, T., Masinter, L. and M. McCahill,\
    \ \"Uniform Resource\n       Locators (URL)\", RFC 1738, December 1994.\n   [5]\
    \ Berners-Lee, T. and D. Connolly, \"Hypertext Markup Language -\n       2.0\"\
    , RFC 1866, November 1995.\n   [6] Berners-Lee, T., Fielding, R. and H. Frystyk,\
    \ \"Hypertext Transfer\n       Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n \
    \  [7] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n       Extensions\
    \ (MIME) Part One: Format of Internet Message Bodies\",\n       RFC 2045, November\
    \ 1996.\n   [8] Braden, R., \"Requirements for Internet Hosts -- Communication\n\
    \       Layers\", STD 3, RFC 1123, October 1989.\n   [9] Crocker, D., \"Standard\
    \ for The Format of ARPA Internet Text\n       Messages\", STD 11, RFC 822, August\
    \ 1982.\n   [10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang,\
    \ R.,\n        Sui, J., and M. Grinbaum, \"WAIS Interface Protocol Prototype\n\
    \        Functional Specification,\" (v1.5), Thinking Machines\n        Corporation,\
    \ April 1990.\n   [11] Fielding, R., \"Relative Uniform Resource Locators\", RFC\
    \ 1808,\n        June 1995.\n   [12] Horton, M. and R. Adams, \"Standard for Interchange\
    \ of USENET\n        Messages\", RFC 1036, December 1987.\n   [13] Kantor, B.\
    \ and P. Lapsley, \"Network News Transfer Protocol\", RFC\n        977, February\
    \ 1986.\n   [14] Moore, K., \"MIME (Multipurpose Internet Mail Extensions) Part\n\
    \        Three: Message Header Extensions for Non-ASCII Text\", RFC 2047,\n  \
    \      November 1996.\n   [15] Nebel, E. and L. Masinter, \"Form-based File Upload\
    \ in HTML\", RFC\n        1867, November 1995.\n   [16] Postel, J., \"Simple Mail\
    \ Transfer Protocol\", STD 10, RFC 821,\n        August 1982.\n   [17] Postel,\
    \ J., \"Media Type Registration Procedure\", RFC 1590,\n        November 1996.\n\
    \   [18] Postel, J. and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC\n\
    \        959, October 1985.\n   [19] Reynolds, J. and J. Postel, \"Assigned Numbers\"\
    , STD 2, RFC 1700,\n        October 1994.\n   [20] Sollins, K. and L. Masinter,\
    \ \"Functional Requirements for\n        Uniform Resource Names\", RFC 1737, December\
    \ 1994.\n   [21] US-ASCII. Coded Character Set - 7-Bit American Standard Code\
    \ for\n        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.\n\
    \   [22] ISO-8859. International Standard -- Information Processing --\n     \
    \   8-bit Single-Byte Coded Graphic Character Sets --\n        Part 1: Latin alphabet\
    \ No. 1, ISO-8859-1:1987.\n        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.\n\
    \        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.\n        Part 4: Latin\
    \ alphabet No. 4, ISO-8859-4, 1988.\n        Part 5: Latin/Cyrillic alphabet,\
    \ ISO-8859-5, 1988.\n        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.\n\
    \        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.\n        Part 8: Latin/Hebrew\
    \ alphabet, ISO-8859-8, 1988.\n        Part 9: Latin alphabet No. 5, ISO-8859-9,\
    \ 1990.\n   [23] Meyers, J. and M. Rose, \"The Content-MD5 Header Field\", RFC\n\
    \        1864, October 1995.\n   [24] Carpenter, B. and Y. Rekhter, \"Renumbering\
    \ Needs Work\", RFC\n        1900, February 1996.\n   [25] Deutsch, P., \"GZIP\
    \ file format specification version 4.3\", RFC\n        1952, May 1996.\n   [26]\
    \ Venkata N. Padmanabhan, and Jeffrey C. Mogul. \"Improving HTTP\n        Latency\"\
    , Computer Networks and ISDN Systems, v. 28, pp. 25-35,\n        Dec. 1995. Slightly\
    \ revised version of paper in Proc. 2nd\n        International WWW Conference\
    \ '94: Mosaic and the Web, Oct. 1994,\n        which is available at\n       \
    \ http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat\n        ency.html.\n\
    \   [27] Joe Touch, John Heidemann, and Katia Obraczka. \"Analysis of HTTP\n \
    \       Performance\", <URL: http://www.isi.edu/touch/pubs/http-perf96/>,\n  \
    \      ISI Research Report ISI/RR-98-463, (original report dated Aug.\n      \
    \  1996), USC/Information Sciences Institute, August 1998.\n   [28] Mills, D.,\
    \ \"Network Time Protocol (Version 3) Specification,\n        Implementation and\
    \ Analysis\", RFC 1305, March 1992.\n   [29] Deutsch, P., \"DEFLATE Compressed\
    \ Data Format Specification\n        version 1.3\", RFC 1951, May 1996.\n   [30]\
    \ S. Spero, \"Analysis of HTTP Performance Problems,\"\n        http://sunsite.unc.edu/mdma-release/http-prob.html.\n\
    \   [31] Deutsch, P. and J. Gailly, \"ZLIB Compressed Data Format\n        Specification\
    \ version 3.3\", RFC 1950, May 1996.\n   [32] Franks, J., Hallam-Baker, P., Hostetler,\
    \ J., Leach, P.,\n        Luotonen, A., Sink, E. and L. Stewart, \"An Extension\
    \ to HTTP:\n        Digest Access Authentication\", RFC 2069, January 1997.\n\
    \   [33] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T.\n        Berners-Lee,\
    \ \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC\n        2068, January 1997.\n\
    \   [34] Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n  \
    \      Levels\", BCP 14, RFC 2119, March 1997.\n   [35] Troost, R. and Dorner,\
    \ S., \"Communicating Presentation\n        Information in Internet Messages:\
    \ The Content-Disposition\n        Header\", RFC 1806, June 1995.\n   [36] Mogul,\
    \ J., Fielding, R., Gettys, J. and H. Frystyk, \"Use and\n        Interpretation\
    \ of HTTP Version Numbers\", RFC 2145, May 1997.\n        [jg639]\n   [37] Palme,\
    \ J., \"Common Internet Message Headers\", RFC 2076, February\n        1997. [jg640]\n\
    \   [38] Yergeau, F., \"UTF-8, a transformation format of Unicode and\n      \
    \  ISO-10646\", RFC 2279, January 1998. [jg641]\n   [39] Nielsen, H.F., Gettys,\
    \ J., Baird-Smith, A., Prud'hommeaux, E.,\n        Lie, H., and C. Lilley. \"\
    Network Performance Effects of\n        HTTP/1.1, CSS1, and PNG,\" Proceedings\
    \ of ACM SIGCOMM '97, Cannes\n        France, September 1997.[jg642]\n   [40]\
    \ Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n        Extensions\
    \ (MIME) Part Two: Media Types\", RFC 2046, November\n        1996. [jg643]\n\
    \   [41] Alvestrand, H., \"IETF Policy on Character Sets and Languages\",\n  \
    \      BCP 18, RFC 2277, January 1998. [jg644]\n   [42] Berners-Lee, T., Fielding,\
    \ R. and L. Masinter, \"Uniform Resource\n        Identifiers (URI): Generic Syntax\
    \ and Semantics\", RFC 2396,\n        August 1998. [jg645]\n   [43] Franks, J.,\
    \ Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n        Leach, P., Luotonen,\
    \ A., Sink, E. and L. Stewart, \"HTTP\n        Authentication: Basic and Digest\
    \ Access Authentication\", RFC\n        2617, June 1999. [jg646]\n   [44] Luotonen,\
    \ A., \"Tunneling TCP based protocols through Web proxy\n        servers,\" Work\
    \ in Progress. [jg647]\n   [45] Palme, J. and A. Hopmann, \"MIME E-mail Encapsulation\
    \ of\n        Aggregate Documents, such as HTML (MHTML)\", RFC 2110, March\n \
    \       1997.\n   [46] Bradner, S., \"The Internet Standards Process -- Revision\
    \ 3\", BCP\n        9, RFC 2026, October 1996.\n   [47] Masinter, L., \"Hyper\
    \ Text Coffee Pot Control Protocol\n        (HTCPCP/1.0)\", RFC 2324, 1 April\
    \ 1998.\n   [48] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n \
    \       Extensions (MIME) Part Five: Conformance Criteria and Examples\",\n  \
    \      RFC 2049, November 1996.\n   [49] Troost, R., Dorner, S. and K. Moore,\
    \ \"Communicating Presentation\n        Information in Internet Messages: The\
    \ Content-Disposition Header\n        Field\", RFC 2183, August 1997.\n"
- title: 18 Authors' Addresses
  contents:
  - "18 Authors' Addresses\n   Roy T. Fielding\n   Information and Computer Science\n\
    \   University of California, Irvine\n   Irvine, CA 92697-3425, USA\n   Fax: +1\
    \ (949) 824-1715\n   EMail: fielding@ics.uci.edu\n   James Gettys\n   World Wide\
    \ Web Consortium\n   MIT Laboratory for Computer Science\n   545 Technology Square\n\
    \   Cambridge, MA 02139, USA\n   Fax: +1 (617) 258 8682\n   EMail: jg@w3.org\n\
    \   Jeffrey C. Mogul\n   Western Research Laboratory\n   Compaq Computer Corporation\n\
    \   250 University Avenue\n   Palo Alto, California, 94305, USA\n   EMail: mogul@wrl.dec.com\n\
    \   Henrik Frystyk Nielsen\n   World Wide Web Consortium\n   MIT Laboratory for\
    \ Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n  \
    \ Fax: +1 (617) 258 8682\n   EMail: frystyk@w3.org\n   Larry Masinter\n   Xerox\
    \ Corporation\n   3333 Coyote Hill Road\n   Palo Alto, CA 94034, USA\n   EMail:\
    \ masinter@parc.xerox.com\n   Paul J. Leach\n   Microsoft Corporation\n   1 Microsoft\
    \ Way\n   Redmond, WA 98052, USA\n   EMail: paulle@microsoft.com\n   Tim Berners-Lee\n\
    \   Director, World Wide Web Consortium\n   MIT Laboratory for Computer Science\n\
    \   545 Technology Square\n   Cambridge, MA 02139, USA\n   Fax: +1 (617) 258 8682\n\
    \   EMail: timbl@w3.org\n"
- title: 19 Appendices
  contents:
  - '19 Appendices

    '
- title: 19.1 Internet Media Type message/http and application/http
  contents:
  - "19.1 Internet Media Type message/http and application/http\n   In addition to\
    \ defining the HTTP/1.1 protocol, this document serves\n   as the specification\
    \ for the Internet media type \"message/http\" and\n   \"application/http\". The\
    \ message/http type can be used to enclose a\n   single HTTP request or response\
    \ message, provided that it obeys the\n   MIME restrictions for all \"message\"\
    \ types regarding line length and\n   encodings. The application/http type can\
    \ be used to enclose a\n   pipeline of one or more HTTP request or response messages\
    \ (not\n   intermixed). The following is to be registered with IANA [17].\n  \
    \     Media Type name:         message\n       Media subtype name:      http\n\
    \       Required parameters:     none\n       Optional parameters:     version,\
    \ msgtype\n        version: The HTTP-Version number of the enclosed message\n\
    \                 (e.g., \"1.1\"). If not present, the version can be\n      \
    \           determined from the first line of the body.\n        msgtype: The\
    \ message type -- \"request\" or \"response\". If not\n                 present,\
    \ the type can be determined from the first\n                 line of the body.\n\
    \       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n\
    \                                permitted\n       Security considerations: none\n\
    \       Media Type name:         application\n       Media subtype name:     \
    \ http\n       Required parameters:     none\n       Optional parameters:    \
    \ version, msgtype\n        version: The HTTP-Version number of the enclosed messages\n\
    \                 (e.g., \"1.1\"). If not present, the version can be\n      \
    \           determined from the first line of the body.\n        msgtype: The\
    \ message type -- \"request\" or \"response\". If not\n                 present,\
    \ the type can be determined from the first\n                 line of the body.\n\
    \       Encoding considerations: HTTP messages enclosed by this type\n       \
    \          are in \"binary\" format; use of an appropriate\n                 Content-Transfer-Encoding\
    \ is required when\n                 transmitted via E-mail.\n       Security\
    \ considerations: none\n"
- title: 19.2 Internet Media Type multipart/byteranges
  contents:
  - "19.2 Internet Media Type multipart/byteranges\n   When an HTTP 206 (Partial Content)\
    \ response message includes the\n   content of multiple ranges (a response to\
    \ a request for multiple\n   non-overlapping ranges), these are transmitted as\
    \ a multipart\n   message-body. The media type for this purpose is called\n  \
    \ \"multipart/byteranges\".\n   The multipart/byteranges media type includes two\
    \ or more parts, each\n   with its own Content-Type and Content-Range fields.\
    \ The required\n   boundary parameter specifies the boundary string used to separate\n\
    \   each body-part.\n       Media Type name:         multipart\n       Media subtype\
    \ name:      byteranges\n       Required parameters:     boundary\n       Optional\
    \ parameters:     none\n       Encoding considerations: only \"7bit\", \"8bit\"\
    , or \"binary\" are\n                                permitted\n       Security\
    \ considerations: none\n   For example:\n   HTTP/1.1 206 Partial Content\n   Date:\
    \ Wed, 15 Nov 1995 06:25:24 GMT\n   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\n\
    \   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n   --THIS_STRING_SEPARATES\n\
    \   Content-type: application/pdf\n   Content-range: bytes 500-999/8000\n   ...the\
    \ first range...\n   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n\
    \   Content-range: bytes 7000-7999/8000\n   ...the second range\n   --THIS_STRING_SEPARATES--\n\
    \      Notes:\n      1) Additional CRLFs may precede the first boundary string\
    \ in the\n         entity.\n      2) Although RFC 2046 [40] permits the boundary\
    \ string to be\n         quoted, some existing implementations handle a quoted\
    \ boundary\n         string incorrectly.\n      3) A number of browsers and servers\
    \ were coded to an early draft\n         of the byteranges specification to use\
    \ a media type of\n         multipart/x-byteranges, which is almost, but not quite\n\
    \         compatible with the version documented in HTTP/1.1.\n"
- title: 19.3 Tolerant Applications
  contents:
  - "19.3 Tolerant Applications\n   Although this document specifies the requirements\
    \ for the generation\n   of HTTP/1.1 messages, not all applications will be correct\
    \ in their\n   implementation. We therefore recommend that operational applications\n\
    \   be tolerant of deviations whenever those deviations can be\n   interpreted\
    \ unambiguously.\n   Clients SHOULD be tolerant in parsing the Status-Line and\
    \ servers\n   tolerant when parsing the Request-Line. In particular, they SHOULD\n\
    \   accept any amount of SP or HT characters between fields, even though\n   only\
    \ a single SP is required.\n   The line terminator for message-header fields is\
    \ the sequence CRLF.\n   However, we recommend that applications, when parsing\
    \ such headers,\n   recognize a single LF as a line terminator and ignore the\
    \ leading CR.\n   The character set of an entity-body SHOULD be labeled as the\
    \ lowest\n   common denominator of the character codes used within that body,\
    \ with\n   the exception that not labeling the entity is preferred over labeling\n\
    \   the entity with the labels US-ASCII or ISO-8859-1. See section 3.7.1\n   and\
    \ 3.4.1.\n   Additional rules for requirements on parsing and encoding of dates\n\
    \   and other potential problems with date encodings include:\n      - HTTP/1.1\
    \ clients and caches SHOULD assume that an RFC-850 date\n        which appears\
    \ to be more than 50 years in the future is in fact\n        in the past (this\
    \ helps solve the \"year 2000\" problem).\n      - An HTTP/1.1 implementation\
    \ MAY internally represent a parsed\n        Expires date as earlier than the\
    \ proper value, but MUST NOT\n        internally represent a parsed Expires date\
    \ as later than the\n        proper value.\n      - All expiration-related calculations\
    \ MUST be done in GMT. The\n        local time zone MUST NOT influence the calculation\
    \ or comparison\n        of an age or expiration time.\n      - If an HTTP header\
    \ incorrectly carries a date value with a time\n        zone other than GMT, it\
    \ MUST be converted into GMT using the\n        most conservative possible conversion.\n"
- title: 19.4 Differences Between HTTP Entities and RFC 2045 Entities
  contents:
  - "19.4 Differences Between HTTP Entities and RFC 2045 Entities\n   HTTP/1.1 uses\
    \ many of the constructs defined for Internet Mail (RFC\n   822 [9]) and the Multipurpose\
    \ Internet Mail Extensions (MIME [7]) to\n   allow entities to be transmitted\
    \ in an open variety of\n   representations and with extensible mechanisms. However,\
    \ RFC 2045\n   discusses mail, and HTTP has a few features that are different\
    \ from\n   those described in RFC 2045. These differences were carefully chosen\n\
    \   to optimize performance over binary connections, to allow greater\n   freedom\
    \ in the use of new media types, to make date comparisons\n   easier, and to acknowledge\
    \ the practice of some early HTTP servers\n   and clients.\n   This appendix describes\
    \ specific areas where HTTP differs from RFC\n   2045. Proxies and gateways to\
    \ strict MIME environments SHOULD be\n   aware of these differences and provide\
    \ the appropriate conversions\n   where necessary. Proxies and gateways from MIME\
    \ environments to HTTP\n   also need to be aware of the differences because some\
    \ conversions\n   might be required.\n"
- title: 19.4.1 MIME-Version
  contents:
  - "19.4.1 MIME-Version\n   HTTP is not a MIME-compliant protocol. However, HTTP/1.1\
    \ messages MAY\n   include a single MIME-Version general-header field to indicate\
    \ what\n   version of the MIME protocol was used to construct the message. Use\n\
    \   of the MIME-Version header field indicates that the message is in\n   full\
    \ compliance with the MIME protocol (as defined in RFC 2045[7]).\n   Proxies/gateways\
    \ are responsible for ensuring full compliance (where\n   possible) when exporting\
    \ HTTP messages to strict MIME environments.\n       MIME-Version   = \"MIME-Version\"\
    \ \":\" 1*DIGIT \".\" 1*DIGIT\n   MIME version \"1.0\" is the default for use\
    \ in HTTP/1.1. However,\n   HTTP/1.1 message parsing and semantics are defined\
    \ by this document\n   and not the MIME specification.\n"
- title: 19.4.2 Conversion to Canonical Form
  contents:
  - "19.4.2 Conversion to Canonical Form\n   RFC 2045 [7] requires that an Internet\
    \ mail entity be converted to\n   canonical form prior to being transferred, as\
    \ described in section 4\n   of RFC 2049 [48]. Section 3.7.1 of this document\
    \ describes the forms\n   allowed for subtypes of the \"text\" media type when\
    \ transmitted over\n   HTTP. RFC 2046 requires that content with a type of \"\
    text\" represent\n   line breaks as CRLF and forbids the use of CR or LF outside\
    \ of line\n   break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate\
    \ a\n   line break within text content when a message is transmitted over\n  \
    \ HTTP.\n   Where it is possible, a proxy or gateway from HTTP to a strict MIME\n\
    \   environment SHOULD translate all line breaks within the text media\n   types\
    \ described in section 3.7.1 of this document to the RFC 2049\n   canonical form\
    \ of CRLF. Note, however, that this might be complicated\n   by the presence of\
    \ a Content-Encoding and by the fact that HTTP\n   allows the use of some character\
    \ sets which do not use octets 13 and\n   10 to represent CR and LF, as is the\
    \ case for some multi-byte\n   character sets.\n   Implementors should note that\
    \ conversion will break any cryptographic\n   checksums applied to the original\
    \ content unless the original content\n   is already in canonical form. Therefore,\
    \ the canonical form is\n   recommended for any content that uses such checksums\
    \ in HTTP.\n"
- title: 19.4.3 Conversion of Date Formats
  contents:
  - "19.4.3 Conversion of Date Formats\n   HTTP/1.1 uses a restricted set of date\
    \ formats (section 3.3.1) to\n   simplify the process of date comparison. Proxies\
    \ and gateways from\n   other protocols SHOULD ensure that any Date header field\
    \ present in a\n   message conforms to one of the HTTP/1.1 formats and rewrite\
    \ the date\n   if necessary.\n"
- title: 19.4.4 Introduction of Content-Encoding
  contents:
  - "19.4.4 Introduction of Content-Encoding\n   RFC 2045 does not include any concept\
    \ equivalent to HTTP/1.1's\n   Content-Encoding header field. Since this acts\
    \ as a modifier on the\n   media type, proxies and gateways from HTTP to MIME-compliant\n\
    \   protocols MUST either change the value of the Content-Type header\n   field\
    \ or decode the entity-body before forwarding the message. (Some\n   experimental\
    \ applications of Content-Type for Internet mail have used\n   a media-type parameter\
    \ of \";conversions=<content-coding>\" to perform\n   a function equivalent to\
    \ Content-Encoding. However, this parameter is\n   not part of RFC 2045.)\n"
- title: 19.4.5 No Content-Transfer-Encoding
  contents:
  - "19.4.5 No Content-Transfer-Encoding\n   HTTP does not use the Content-Transfer-Encoding\
    \ (CTE) field of RFC\n   2045. Proxies and gateways from MIME-compliant protocols\
    \ to HTTP MUST\n   remove any non-identity CTE (\"quoted-printable\" or \"base64\"\
    ) encoding\n   prior to delivering the response message to an HTTP client.\n \
    \  Proxies and gateways from HTTP to MIME-compliant protocols are\n   responsible\
    \ for ensuring that the message is in the correct format\n   and encoding for\
    \ safe transport on that protocol, where \"safe\n   transport\" is defined by\
    \ the limitations of the protocol being used.\n   Such a proxy or gateway SHOULD\
    \ label the data with an appropriate\n   Content-Transfer-Encoding if doing so\
    \ will improve the likelihood of\n   safe transport over the destination protocol.\n"
- title: 19.4.6 Introduction of Transfer-Encoding
  contents:
  - "19.4.6 Introduction of Transfer-Encoding\n   HTTP/1.1 introduces the Transfer-Encoding\
    \ header field (section\n   14.41). Proxies/gateways MUST remove any transfer-coding\
    \ prior to\n   forwarding a message via a MIME-compliant protocol.\n   A process\
    \ for decoding the \"chunked\" transfer-coding (section 3.6)\n   can be represented\
    \ in pseudo-code as:\n       length := 0\n       read chunk-size, chunk-extension\
    \ (if any) and CRLF\n       while (chunk-size > 0) {\n          read chunk-data\
    \ and CRLF\n          append chunk-data to entity-body\n          length := length\
    \ + chunk-size\n          read chunk-size and CRLF\n       }\n       read entity-header\n\
    \       while (entity-header not empty) {\n          append entity-header to existing\
    \ header fields\n          read entity-header\n       }\n       Content-Length\
    \ := length\n       Remove \"chunked\" from Transfer-Encoding\n"
- title: 19.4.7 MHTML and Line Length Limitations
  contents:
  - "19.4.7 MHTML and Line Length Limitations\n   HTTP implementations which share\
    \ code with MHTML [45] implementations\n   need to be aware of MIME line length\
    \ limitations. Since HTTP does not\n   have this limitation, HTTP does not fold\
    \ long lines. MHTML messages\n   being transported by HTTP follow all conventions\
    \ of MHTML, including\n   line length limitations and folding, canonicalization,\
    \ etc., since\n   HTTP transports all message-bodies as payload (see section 3.7.2)\
    \ and\n   does not interpret the content or any MIME header lines that might be\n\
    \   contained therein.\n"
- title: 19.5 Additional Features
  contents:
  - "19.5 Additional Features\n   RFC 1945 and RFC 2068 document protocol elements\
    \ used by some\n   existing HTTP implementations, but not consistently and correctly\n\
    \   across most HTTP/1.1 applications. Implementors are advised to be\n   aware\
    \ of these features, but cannot rely upon their presence in, or\n   interoperability\
    \ with, other HTTP/1.1 applications. Some of these\n   describe proposed experimental\
    \ features, and some describe features\n   that experimental deployment found\
    \ lacking that are now addressed in\n   the base HTTP/1.1 specification.\n   A\
    \ number of other headers, such as Content-Disposition and Title,\n   from SMTP\
    \ and MIME are also often implemented (see RFC 2076 [37]).\n"
- title: 19.5.1 Content-Disposition
  contents:
  - "19.5.1 Content-Disposition\n   The Content-Disposition response-header field\
    \ has been proposed as a\n   means for the origin server to suggest a default\
    \ filename if the user\n   requests that the content is saved to a file. This\
    \ usage is derived\n   from the definition of Content-Disposition in RFC 1806\
    \ [35].\n        content-disposition = \"Content-Disposition\" \":\"\n       \
    \                       disposition-type *( \";\" disposition-parm )\n       \
    \ disposition-type = \"attachment\" | disp-extension-token\n        disposition-parm\
    \ = filename-parm | disp-extension-parm\n        filename-parm = \"filename\"\
    \ \"=\" quoted-string\n        disp-extension-token = token\n        disp-extension-parm\
    \ = token \"=\" ( token | quoted-string )\n   An example is\n        Content-Disposition:\
    \ attachment; filename=\"fname.ext\"\n   The receiving user agent SHOULD NOT respect\
    \ any directory path\n   information present in the filename-parm parameter, which\
    \ is the only\n   parameter believed to apply to HTTP implementations at this\
    \ time. The\n   filename SHOULD be treated as a terminal component only.\n   If\
    \ this header is used in a response with the application/octet-\n   stream content-type,\
    \ the implied suggestion is that the user agent\n   should not display the response,\
    \ but directly enter a `save response\n   as...' dialog.\n   See section 15.5\
    \ for Content-Disposition security issues.\n"
- title: 19.6 Compatibility with Previous Versions
  contents:
  - "19.6 Compatibility with Previous Versions\n   It is beyond the scope of a protocol\
    \ specification to mandate\n   compliance with previous versions. HTTP/1.1 was\
    \ deliberately\n   designed, however, to make supporting previous versions easy.\
    \ It is\n   worth noting that, at the time of composing this specification\n \
    \  (1996), we would expect commercial HTTP/1.1 servers to:\n      - recognize\
    \ the format of the Request-Line for HTTP/0.9, 1.0, and\n        1.1 requests;\n\
    \      - understand any valid request in the format of HTTP/0.9, 1.0, or\n   \
    \     1.1;\n      - respond appropriately with a message in the same major version\n\
    \        used by the client.\n   And we would expect HTTP/1.1 clients to:\n  \
    \    - recognize the format of the Status-Line for HTTP/1.0 and 1.1\n        responses;\n\
    \      - understand any valid response in the format of HTTP/0.9, 1.0, or\n  \
    \      1.1.\n   For most implementations of HTTP/1.0, each connection is established\n\
    \   by the client prior to the request and closed by the server after\n   sending\
    \ the response. Some implementations implement the Keep-Alive\n   version of persistent\
    \ connections described in section 19.7.1 of RFC\n   2068 [33].\n"
- title: 19.6.1 Changes from HTTP/1.0
  contents:
  - "19.6.1 Changes from HTTP/1.0\n   This section summarizes major differences between\
    \ versions HTTP/1.0\n   and HTTP/1.1.\n"
- title: 19.6.1.1 Changes to Simplify Multi-homed Web Servers and Conserve IP
  contents:
  - "19.6.1.1 Changes to Simplify Multi-homed Web Servers and Conserve IP\n      \
    \   Addresses\n   The requirements that clients and servers support the Host request-\n\
    \   header, report an error if the Host request-header (section 14.23) is\n  \
    \ missing from an HTTP/1.1 request, and accept absolute URIs (section\n   5.1.2)\
    \ are among the most important changes defined by this\n   specification.\n  \
    \ Older HTTP/1.0 clients assumed a one-to-one relationship of IP\n   addresses\
    \ and servers; there was no other established mechanism for\n   distinguishing\
    \ the intended server of a request than the IP address\n   to which that request\
    \ was directed. The changes outlined above will\n   allow the Internet, once older\
    \ HTTP clients are no longer common, to\n   support multiple Web sites from a\
    \ single IP address, greatly\n   simplifying large operational Web servers, where\
    \ allocation of many\n   IP addresses to a single host has created serious problems.\
    \ The\n   Internet will also be able to recover the IP addresses that have been\n\
    \   allocated for the sole purpose of allowing special-purpose domain\n   names\
    \ to be used in root-level HTTP URLs. Given the rate of growth of\n   the Web,\
    \ and the number of servers already deployed, it is extremely\n   important that\
    \ all implementations of HTTP (including updates to\n   existing HTTP/1.0 applications)\
    \ correctly implement these\n   requirements:\n      - Both clients and servers\
    \ MUST support the Host request-header.\n      - A client that sends an HTTP/1.1\
    \ request MUST send a Host header.\n      - Servers MUST report a 400 (Bad Request)\
    \ error if an HTTP/1.1\n        request does not include a Host request-header.\n\
    \      - Servers MUST accept absolute URIs.\n"
- title: 19.6.2 Compatibility with HTTP/1.0 Persistent Connections
  contents:
  - "19.6.2 Compatibility with HTTP/1.0 Persistent Connections\n   Some clients and\
    \ servers might wish to be compatible with some\n   previous implementations of\
    \ persistent connections in HTTP/1.0\n   clients and servers. Persistent connections\
    \ in HTTP/1.0 are\n   explicitly negotiated as they are not the default behavior.\
    \ HTTP/1.0\n   experimental implementations of persistent connections are faulty,\n\
    \   and the new facilities in HTTP/1.1 are designed to rectify these\n   problems.\
    \ The problem was that some existing 1.0 clients may be\n   sending Keep-Alive\
    \ to a proxy server that doesn't understand\n   Connection, which would then erroneously\
    \ forward it to the next\n   inbound server, which would establish the Keep-Alive\
    \ connection and\n   result in a hung HTTP/1.0 proxy waiting for the close on\
    \ the\n   response. The result is that HTTP/1.0 clients must be prevented from\n\
    \   using Keep-Alive when talking to proxies.\n   However, talking to proxies\
    \ is the most important use of persistent\n   connections, so that prohibition\
    \ is clearly unacceptable. Therefore,\n   we need some other mechanism for indicating\
    \ a persistent connection\n   is desired, which is safe to use even when talking\
    \ to an old proxy\n   that ignores Connection. Persistent connections are the\
    \ default for\n   HTTP/1.1 messages; we introduce a new keyword (Connection: close)\
    \ for\n   declaring non-persistence. See section 14.10.\n   The original HTTP/1.0\
    \ form of persistent connections (the Connection:\n   Keep-Alive and Keep-Alive\
    \ header) is documented in RFC 2068. [33]\n"
- title: 19.6.3 Changes from RFC 2068
  contents:
  - "19.6.3 Changes from RFC 2068\n   This specification has been carefully audited\
    \ to correct and\n   disambiguate key word usage; RFC 2068 had many problems in\
    \ respect to\n   the conventions laid out in RFC 2119 [34].\n   Clarified which\
    \ error code should be used for inbound server failures\n   (e.g. DNS failures).\
    \ (Section 10.5.5).\n   CREATE had a race that required an Etag be sent when a\
    \ resource is\n   first created. (Section 10.2.2).\n   Content-Base was deleted\
    \ from the specification: it was not\n   implemented widely, and there is no simple,\
    \ safe way to introduce it\n   without a robust extension mechanism. In addition,\
    \ it is used in a\n   similar, but not identical fashion in MHTML [45].\n   Transfer-coding\
    \ and message lengths all interact in ways that\n   required fixing exactly when\
    \ chunked encoding is used (to allow for\n   transfer encoding that may not be\
    \ self delimiting); it was important\n   to straighten out exactly how message\
    \ lengths are computed. (Sections\n   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)\n\
    \   A content-coding of \"identity\" was introduced, to solve problems\n   discovered\
    \ in caching. (section 3.5)\n   Quality Values of zero should indicate that \"\
    I don't want something\"\n   to allow clients to refuse a representation. (Section\
    \ 3.9)\n   The use and interpretation of HTTP version numbers has been clarified\n\
    \   by RFC 2145. Require proxies to upgrade requests to highest protocol\n   version\
    \ they support to deal with problems discovered in HTTP/1.0\n   implementations\
    \ (Section 3.1)\n   Charset wildcarding is introduced to avoid explosion of character\
    \ set\n   names in accept headers. (Section 14.2)\n   A case was missed in the\
    \ Cache-Control model of HTTP/1.1; s-maxage\n   was introduced to add this missing\
    \ case. (Sections 13.4, 14.8, 14.9,\n   14.9.3)\n   The Cache-Control: max-age\
    \ directive was not properly defined for\n   responses. (Section 14.9.3)\n   There\
    \ are situations where a server (especially a proxy) does not\n   know the full\
    \ length of a response but is capable of serving a\n   byterange request. We therefore\
    \ need a mechanism to allow byteranges\n   with a content-range not indicating\
    \ the full length of the message.\n   (Section 14.16)\n   Range request responses\
    \ would become very verbose if all meta-data\n   were always returned; by allowing\
    \ the server to only send needed\n   headers in a 206 response, this problem can\
    \ be avoided. (Section\n   10.2.7, 13.5.3, and 14.27)\n   Fix problem with unsatisfiable\
    \ range requests; there are two cases:\n   syntactic problems, and range doesn't\
    \ exist in the document. The 416\n   status code was needed to resolve this ambiguity\
    \ needed to indicate\n   an error for a byte range request that falls outside\
    \ of the actual\n   contents of a document. (Section 10.4.17, 14.16)\n   Rewrite\
    \ of message transmission requirements to make it much harder\n   for implementors\
    \ to get it wrong, as the consequences of errors here\n   can have significant\
    \ impact on the Internet, and to deal with the\n   following problems:\n     \
    \ 1. Changing \"HTTP/1.1 or later\" to \"HTTP/1.1\", in contexts where\n     \
    \    this was incorrectly placing a requirement on the behavior of\n         an\
    \ implementation of a future version of HTTP/1.x\n      2. Made it clear that\
    \ user-agents should retry requests, not\n         \"clients\" in general.\n \
    \     3. Converted requirements for clients to ignore unexpected 100\n       \
    \  (Continue) responses, and for proxies to forward 100 responses,\n         into\
    \ a general requirement for 1xx responses.\n      4. Modified some TCP-specific\
    \ language, to make it clearer that\n         non-TCP transports are possible\
    \ for HTTP.\n      5. Require that the origin server MUST NOT wait for the request\n\
    \         body before it sends a required 100 (Continue) response.\n      6. Allow,\
    \ rather than require, a server to omit 100 (Continue) if\n         it has already\
    \ seen some of the request body.\n      7. Allow servers to defend against denial-of-service\
    \ attacks and\n         broken clients.\n   This change adds the Expect header\
    \ and 417 status code. The message\n   transmission requirements fixes are in\
    \ sections 8.2, 10.4.18,\n   8.1.2.2, 13.11, and 14.20.\n   Proxies should be\
    \ able to add Content-Length when appropriate.\n   (Section 13.5.2)\n   Clean\
    \ up confusion between 403 and 404 responses. (Section 10.4.4,\n   10.4.5, and\
    \ 10.4.11)\n   Warnings could be cached incorrectly, or not updated appropriately.\n\
    \   (Section 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning\n   also\
    \ needed to be a general header, as PUT or other methods may have\n   need for\
    \ it in requests.\n   Transfer-coding had significant problems, particularly with\n\
    \   interactions with chunked encoding. The solution is that transfer-\n   codings\
    \ become as full fledged as content-codings. This involves\n   adding an IANA\
    \ registry for transfer-codings (separate from content\n   codings), a new header\
    \ field (TE) and enabling trailer headers in the\n   future. Transfer encoding\
    \ is a major performance benefit, so it was\n   worth fixing [39]. TE also solves\
    \ another, obscure, downward\n   interoperability problem that could have occurred\
    \ due to interactions\n   between authentication trailers, chunked encoding and\
    \ HTTP/1.0\n   clients.(Section 3.6, 3.6.1, and 14.39)\n   The PATCH, LINK, UNLINK\
    \ methods were defined but not commonly\n   implemented in previous versions of\
    \ this specification. See RFC 2068\n   [33].\n   The Alternates, Content-Version,\
    \ Derived-From, Link, URI, Public and\n   Content-Base header fields were defined\
    \ in previous versions of this\n   specification, but not commonly implemented.\
    \ See RFC 2068 [33].\n"
- title: 20 Index
  contents:
  - "20 Index\n   Please see the PostScript version of this RFC for the INDEX.\n"
- title: 21.  Full Copyright Statement
  contents:
  - "21.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
