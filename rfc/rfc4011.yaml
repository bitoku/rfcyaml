- title: __initial_text__
  contents:
  - '                      Policy Based Management MIB

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo defines a portion of the Management Information Base (MIB)\n\
    \   for use with network management protocols in TCP/IP-based internets.\n   In\
    \ particular, this MIB defines objects that enable policy-based\n   monitoring\
    \ and management of Simple Network Management Protocol\n   (SNMP) infrastructures,\
    \ a scripting language, and a script execution\n   environment.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n       5.2.  Variables .............................................\
    \  18\n             5.2.1.  The Var Class .................................  19\n\
    \       5.3.  PolicyScript QuickStart Guide .........................  23\n  \
    \           5.3.1.  Quickstart for C Programmers ..................  25\n    \
    \         5.3.2.  Quickstart for Perl Programmers ...............  25\n      \
    \       5.3.3.  Quickstart for TCL Programmers ................  25\n        \
    \     5.3.4.  Quickstart for Python Programmers .............  26\n          \
    \   5.3.5.  Quickstart for JavaScript/ECMAScript/JScript\n                   \
    \  Programmers ...................................  26\n       5.4.  PolicyScript\
    \ Script Return Values .....................  26\n   6.  Index Information for\
    \ `this element' ........................  27\n   7.  Library Functions ...........................................\
    \  28\n   8.  Base Function Library .......................................  29\n\
    \       8.1.  SNMP Library Functions ................................  29\n  \
    \           8.1.1.  SNMP Operations on Non-Local Systems ..........  30\n    \
    \         8.1.2.  Form of SNMP Values ...........................  32\n      \
    \       8.1.3.  Convenience SNMP Functions ....................  34\n        \
    \             8.1.3.1.  getVar() ............................  34\n          \
    \           8.1.3.2.  exists() ............................  34\n            \
    \         8.1.3.3.  setVar() ............................  35\n              \
    \       8.1.3.4.  searchColumn() ......................  36\n                \
    \     8.1.3.5.  setRowStatus() ......................  38\n                  \
    \   8.1.3.6.  createRow() .........................  39\n                    \
    \ 8.1.3.7.  counterRate() .......................  42\n             8.1.4.  General\
    \ SNMP Functions ........................  44\n                     8.1.4.1. \
    \ newPDU() ............................  45\n                     8.1.4.2.  writeVar()\
    \ ..........................  45\n                     8.1.4.3.  readVar() ...........................\
    \  46\n                     8.1.4.4.  snmpSend() ..........................  47\n\
    \                     8.1.4.5.  readError() .........................  48\n  \
    \                   8.1.4.6.  writeBulkParameters() ...............  48\n    \
    \         8.1.5.  Constants for SNMP Library Functions ..........  49\n      \
    \ 8.2.  Policy Library Functions ..............................  51\n        \
    \     8.2.1.  elementName() .................................  51\n          \
    \   8.2.2.  elementAddress() ..............................  51\n            \
    \ 8.2.3.  elementContext() ..............................  52\n             8.2.4.\
    \  ec() ..........................................  52\n             8.2.5.  ev()\
    \ ..........................................  52\n             8.2.6.  roleMatch()\
    \ ...................................  52\n             8.2.7.  Scratchpad Functions\
    \ ..........................  53\n             8.2.8.  setScratchpad() ...............................\
    \  55\n             8.2.9.  getScratchpad() ...............................  56\n\
    \             8.2.10. signalError() .................................  57\n  \
    \           8.2.11. defer() .......................................  57\n    \
    \         8.2.12. fail() ........................................  58\n      \
    \       8.2.13. getParameters() ...............................  58\n       8.3.\
    \  Utility Library Functions .............................  59\n             8.3.1.\
    \  regexp() ......................................  59\n             8.3.2.  regexpReplace()\
    \ ...............................  60\n             8.3.3.  oidlen() ......................................\
    \  60\n             8.3.4.  oidncmp() .....................................  60\n\
    \             8.3.5.  inSubtree() ...................................  60\n  \
    \           8.3.6.  subid() .......................................  61\n    \
    \         8.3.7.  subidWrite() ..................................  61\n      \
    \       8.3.8.  oidSplice() ...................................  61\n        \
    \     8.3.9.  parseIndex() ..................................  62\n          \
    \   8.3.10. stringToDotted() ..............................  63\n            \
    \ 8.3.11. integer() .....................................  64\n             8.3.12.\
    \ string() ......................................  64\n             8.3.13. type()\
    \ ........................................  64\n             8.3.14. chr() .........................................\
    \  64\n             8.3.15. ord() .........................................  64\n\
    \             8.3.16. substr() ......................................  65\n  \
    \     8.4.  General Functions .....................................  65\n   9.\
    \  International String Library ................................  65\n       9.1.\
    \  stringprep() ..........................................  66\n             9.1.1.\
    \  Stringprep Profile ............................  66\n       9.2.  utf8Strlen()\
    \ ..........................................  67\n       9.3.  utf8Chr() .............................................\
    \  68\n       9.4.  utf8Ord() .............................................  68\n\
    \       9.5.  utf8Substr() ..........................................  68\n  \
    \ 10. Schedule Table ..............................................  69\n   11.\
    \ Definitions .................................................  70\n   12. Relationship\
    \ to Other MIB Modules ........................... 113\n   13. Security Considerations\
    \ ..................................... 114\n   14. IANA Considerations .........................................\
    \ 117\n   15. Acknowledgements ............................................ 118\n\
    \   16. References .................................................. 118\n  \
    \     16.1. Normative References .................................. 118\n    \
    \   16.2. Informative References ................................ 119\n   Authors'\
    \ Addresses .............................................. 120\n   Full Copyright\
    \ Statement ........................................ 121\n"
- title: 1.  The Internet-Standard Management Framework
  contents:
  - "1.  The Internet-Standard Management Framework\n   For a detailed overview of\
    \ the documents that describe the current\n   Internet-Standard Management Framework,\
    \ please refer to section 7 of\n   RFC 3410 [16].\n   Managed objects are accessed\
    \ via a virtual information store, termed\n   the Management Information Base\
    \ or MIB.  MIB objects are generally\n   accessed through the Simple Network Management\
    \ Protocol (SNMP).\n   Objects in the MIB are defined using the mechanisms defined\
    \ in the\n   Structure of Management Information (SMI).  This memo specifies a\
    \ MIB\n   module that is compliant to the SMIv2, which is described in STD 58,\n\
    \   RFC 2578 [2], STD 58, RFC 2579 [3], and STD 58, RFC 2580 [4].\n"
- title: 2.  Overview
  contents:
  - "2.  Overview\n   Large IT organizations have developed management strategies\
    \ to cope\n   with the extraordinarily large scale and complexity of today's\n\
    \   networks.  In particular, they have tried to configure the network as\n  \
    \ a whole by describing and implementing high-level business policies,\n   rather\
    \ than manage device by device, where orders of magnitude more\n   decisions (and\
    \ mistakes) may be made.\n   The following are examples of \"business policies\"\
    :\n   - All routers will run code version 6.2.\n   - On-site contractors will\
    \ only be connected to ports that are\n     configured with special security restrictions.\n\
    \   - All voice over cable ports in California must provide free local\n     calling.\n\
    \   - Apply special forwarding to all ports whose customers have paid for\n  \
    \   premium service.\n   Each of these policies could represent an action applied\
    \ to hundreds\n   of thousands of variables.\n   To automate this practice, customers\
    \ need software tools that will\n   implement business policies across their networks,\
    \ as well as\n   standard protocols that will ensure that policies can be applied\
    \ to\n   all of their devices, regardless of the vendor.\n   This practice is\
    \ called Policy-Based Management.  This document\n   defines managed objects for\
    \ the Simple Network Management Protocol\n   that are used to distribute policies\
    \ in a common form throughout the\n   network.\n"
- title: 3.  Policy-Based Management Architecture
  contents:
  - "3.  Policy-Based Management Architecture\n   Policy-based management is the practice\
    \ of applying management\n   operations globally on all managed elements that\
    \ share certain\n   attributes.\n   Policies are intended to express a notion\
    \ of:\n      if (an element has certain characteristics) then (apply an\n    \
    \  operation to that element)\n   Policies take the following normal form:\n \
    \     if (policyCondition) then (policyAction)\n   A policyCondition is a script\
    \ that results in a boolean to determine\n   whether an element is a member of\
    \ a set of elements upon which an\n   action is to be performed.\n   A policyAction\
    \ is an operation performed on an element or a set of\n   elements.\n   These\
    \ policies are most often executed on or near managed devices\n   where the elements\
    \ live (and thus their characteristics may be easily\n   inspected) and where\
    \ operations on those elements will be performed.\n   A management station is\
    \ responsible for distributing an\n   organization's policies to all the managed\
    \ devices in the\n   infrastructure.  The pmPolicyTable provides managed objects\
    \ for\n   representing a policy on a managed device.\n   An element is an instance\
    \ of a physical or logical entity and is\n   embodied by a group of related MIB\
    \ variables, such as all the\n   variables for interface 7.  This enables policies\
    \ to be expressed\n   more efficiently and concisely.  Elements can also model\
    \ circuits,\n   CPUs, queues, processes, systems, etc.\n   Conceptually, policies\
    \ are executed in the following manner:\n   for each element for which policyCondition\
    \ returns true, execute\n      policyAction on that element\n   For example:\n\
    \   If (interface is fast ethernet)       then (apply full-duplex mode)\n   If\
    \ (interface is access)              then (apply security filters)\n   If (circuit\
    \ w/gold service paid for)  then (apply special queuing)\n   Each unique combination\
    \ of policy and element is called an execution\n   context.  Within a particular\
    \ execution context, the phrase 'this\n   element' is often used to refer to the\
    \ associated element, as most\n   policy operations will be applied to 'this element'.\
    \  The address of\n   'this element' contains the object identifier of any attribute\
    \ of the\n   element, the SNMP context the element was discovered in, and the\n\
    \   address of the system on which the element was discovered.\n   Policies can\
    \ manage elements on the same system:\n         -----------------------------------------------------\n\
    \         |                                                   |\n         |  \
    \            Managed System                       |\n         |              \
    \                                     |\n         |                          \
    \                         |\n         |   ------------------             Managed\
    \ Elements |\n         |   |                |               interfaces     |\n\
    \         |   | Policy Manager | manages...    circuits       |\n         |  \
    \ |                |               queues         |\n         |   ------------------\
    \               processes      |\n         |                                 \
    \   ...            |\n         |                                             \
    \      |\n         -----------------------------------------------------\n   or\
    \ they can manage elements on other systems:\n                               \
    \             --------------------------\n                                   \
    \         |  Managed System        |\n     --------------------------        \
    \     |    Managed Elements    |\n     |                        |            \
    \ |      interfaces        |\n     |  Management Station or |             |  \
    \    circuits          |\n     |    Mid-Level Manager   |             |      ...\
    \               |\n     |                        |             --------------------------\n\
    \     |   ------------------   | manages...\n     |   | Policy Manager |   | \
    \            --------------------------\n     |   ------------------   |     \
    \        |  Managed System        |\n     |                        |         \
    \    |    Managed Elements    |\n     --------------------------             |\
    \      interfaces        |\n                                            |    \
    \  circuits          |\n                                            |      ...\
    \               |\n                                            --------------------------\n\
    \                                            ...\n   PolicyConditions have the\
    \ capability of performing comparison\n   operations on SNMP variables, logical\
    \ expressions, and other\n   functions.  Many device characteristics are already\
    \ defined in MIB\n   Modules and are easy to include in policyCondition expressions\n\
    \   (ifType == ethernet, frCircuitCommittedBurst < 128K, etc).  However,\n   there\
    \ are important characteristics that aren't currently in MIB\n   objects, and,\
    \ worse, it is not current practice to store this\n   information on managed devices.\
    \  Therefore, this document defines MIB\n   objects for this information.  To\
    \ meet today's needs there are three\n   missing areas:  roles, capabilities,\
    \ and time.\n   Roles\n   A role is an administratively specified characteristic\
    \ of a managed\n   element.  As a selector for policies, it determines the applicability\n\
    \   of the policy to a particular managed element.\n   Some examples of roles\
    \ are political, financial, legal, geographical,\n   or architectural characteristics,\
    \ typically not directly derivable\n   from information stored on the managed\
    \ system.  For example, \"paid\n   for premium service\" or \"is plugged into\
    \ a UPS\" are examples of\n   roles, whereas the \"percent utilization of a link\"\
    \ would not be.\n   Some types of information one would put into a role include\
    \ the\n   following:\n   political - describes the role of a person or group of\
    \ people, or of\n               a service that a group of people uses.  Examples:\n\
    \               executive, sales, outside-contractor, customer.\n        If (attached\
    \ user is executive) then (apply higher bandwidth)\n        If (attached user\
    \ is outside-contractor) then (restrict access)\n   financial/legal - describes\
    \ what financial consideration was\n                     received.  Could also\
    \ include contractual or legal\n                     considerations.  Examples:\
    \ paid, gold, free, trial,\n                     demo, lifeline.\n        If (gold\
    \ service paid for) then (apply special queuing)\n   geographical - describes\
    \ the location of an element.  Examples:\n                  California, Headquarters,\
    \ insecure conduit.\n        If (interface leaves the building) then (apply special\
    \ security)\n   architectural - describes the network architects \"intent\" for\
    \ an\n                   element.  Examples: backup, trunk.\n        If (interface\
    \ is backup) then (set ifAdminStatus = down)\n      Roles in this model are human-defined\
    \ strings that can be\n      referenced by policy code.  The role table in this\
    \ MIB may be used\n      to assign role strings to elements and to view all role\
    \ string\n      assignments.  Implementation-specific mechanisms may also be used\n\
    \      to assign role strings; however, these assignments must be visible\n  \
    \    in the role table.  Multiple roles may be assigned to each\n      element.\
    \  Because policy code has access to data in MIB objects\n      that represent\
    \ the current state of the system and (in contrast)\n      role strings are more\
    \ static, it is recommended that role strings\n      not duplicate information\
    \ available in MIB objects.  Role strings\n      generally should be used to describe\
    \ information not accessible in\n      MIB objects.\n      Policy scripts may\
    \ inspect role assignments to make decisions\n      based on whether an element\
    \ has a particular role assigned to it.\n      The pmRoleTable allows a management\
    \ station to learn what roles\n      exist on a managed system.  The management\
    \ station may choose not\n      to install policies that depend on a role that\
    \ does not exist on\n      any elements in the system.  The management station\
    \ can then\n      register for notifications of new roles.  Upon receipt of a\n\
    \      pmNewRoleNotification, it may choose to install new policies that\n   \
    \   make use of that new role.\n   Capabilities\n      The capabilities table\
    \ allows a management station to learn what\n      capabilities exist on a managed\
    \ system.  The management station\n      may choose not to install policies that\
    \ depend on a capability\n      that does not exist on any elements in the system.\
    \  The management\n      station can then register for notifications of new capabilities.\n\
    \      Upon receipt of a pmNewCapabilityNotification, it may choose to\n     \
    \ install new policies that make use of that new capability.\n   Time\n      Managers\
    \ may wish to define policies that are intended to apply\n      for certain periods\
    \ of time.  This might mean that a policy is\n      installed and is dormant for\
    \ a period of time, becomes ready, and\n      then later goes dormant again. \
    \ Sometimes these time periods will\n      be regular (Monday-Friday 9-5), and\
    \ sometimes ad hoc.  This MIB\n      provides a schedule table that can schedule\
    \ when a policy is ready\n      and when it is dormant.\n   A policy manager contains\
    \ the following:\n         -------------------------------------------------------\n\
    \         | Policy Manager                                      |\n         |\
    \                                                     |\n         |   ----------------------------------------\
    \          |\n         |   | Agent                                |          |\n\
    \         |   |                                      |          |\n         |\
    \   |  ---------------------------------   |          |\n         |   |  | Policy\
    \ Download and Control   |   |          |\n         |   |  |   pmPolicyTable \
    \              |   |          |\n         |   |  |   pmElementTypeRegTable   \
    \    |   |          |\n         |   |  |   pmSchedTable                |   | \
    \         |\n         |   |  ---------------------------------   |          |\n\
    \         |   |                                      |          |\n         |\
    \   |  ---------------------------------   |          |\n         |   |  | Policy\
    \ Environment Control    |   |          |\n         |   |  |   pmRoleTable   \
    \              |   |          |\n         |   |  |   pmCapabilitiesTables    \
    \    |   |          |\n         |   |  ---------------------------------   | \
    \         |\n         |   |                                      |          |\n\
    \         |   |  ---------------------------------   |          |\n         |\
    \   |  | Policy Monitoring             |   |          |\n         |   |  |   pmTrackingTables\
    \            |   |          |\n         |   |  |   pmDebuggingTable          \
    \  |   |          |\n         |   |  ---------------------------------   |   \
    \       |\n         |   ----------------------------------------          |\n\
    \         |                                                     |\n         |\
    \   --------------------------------                  |\n         |   | Execution\
    \ Environment        |                  |\n         |   |                    \
    \          |                  |\n         |   |  -----------------------     |\
    \                  |\n         |   |  | Policy Scheduler    |     |          \
    \        |\n         |   |  -----------------------     |                  |\n\
    \         |   |  -----------------------     |                  |\n         |\
    \   |  | Language            |     |                  |\n         |   |  -----------------------\
    \     |                  |\n         |   |  -----------------------     |    \
    \              |\n         |   |  | Function Library    |     |              \
    \    |\n         |   |  -----------------------     |                  |\n   \
    \      |   --------------------------------                  |\n         -------------------------------------------------------\n"
- title: 4.  Policy-Based Management Execution Environment
  contents:
  - '4.  Policy-Based Management Execution Environment

    '
- title: 4.1.  Terminology
  contents:
  - "4.1.  Terminology\n   Active Schedule - A schedule specifies certain times that\
    \ it will be\n      considered active.  A schedule is active during those times.\n\
    \   Valid Policy - A valid policy is a policy that is fully configured\n     \
    \ and enabled to run.  A valid policy may run unless it is linked to\n      a\
    \ schedule entry that says the policy is not currently active.\n   Ready Policy\
    \ - A ready policy is a valid policy that either has no\n      schedule or is\
    \ linked to a schedule that is currently active.\n   Precedence Group - Multiple\
    \ policies can be assigned to a precedence\n      group with the resulting behavior\
    \ that for each element, of the\n      ready policies that match the condition,\
    \ only the one with the\n      highest precedence value will be active.  For example,\
    \ if there is\n      a default bronze policy that applies to any interface and\
    \ a\n      special policy for gold interfaces, the higher precedence of the\n\
    \      gold policy will ensure that it is run on gold ports and that the\n   \
    \   bronze policy isn't.\n   Active Execution Context - An active execution context\
    \ is a pairing\n      of a ready policy with an element that matches the element\
    \ type\n      filter and the policy condition.  If there are multiple policies\n\
    \      in the precedence group, it is also necessary that no higher\n      precedence\
    \ policy in the group match the policy condition.\n   Run-Time Exception (RTE)\
    \ - A run-time exception is a fatal error\n      caused in language or function\
    \ processing.  If, during the\n      invocation of a script, a run-time exception\
    \ occurs, execution of\n      that script is immediately terminated.  If a policyCondition\n\
    \      experiences a run-time exception while processing an element, the\n   \
    \   element is not matched by the condition and the associated action\n      will\
    \ not be run on that element.  A run-time exception can cause\n      an entry\
    \ to be added to the pmDebuggingTable and will be reflected\n      in the pmTrackingPEInfo\
    \ object.\n"
- title: 4.2.  Execution Environment - Elements of Procedure
  contents:
  - "4.2.  Execution Environment - Elements of Procedure\n   There are several steps\
    \ performed in order to execute policies in\n   this environment:\n      - Element\
    \ Discovery\n      - Element Filtering\n      - Policy Enforcement\n"
- title: 4.3.  Element Discovery
  contents:
  - "4.3.  Element Discovery\n   An element is an instance of a physical or logical\
    \ entity.  Examples\n   of elements include interfaces, circuits, queues, CPUs,\
    \ and\n   processes.  Sometimes various attributes of an entity will be\n   described\
    \ through tables in several standard and proprietary MIB\n   Modules.  As long\
    \ as the indexing is consistent between these tables,\n   the entity can be modeled\
    \ as one element.  For example, the ifTable\n   and the dot3Stats table both contain\
    \ attributes of interfaces and\n   share the same index (ifIndex), therefore they\
    \ can be modeled as one\n   element type.\n   The Element Type Registration table\
    \ allows the manager to learn what\n   element types are being managed by the\
    \ system and to register new\n   types, if necessary.  An element type is registered\
    \ by providing the\n   OID of an SNMP object (i.e., without the instance).  Each\
    \ SNMP\n   instance that exists under that object is a distinct element.  The\n\
    \   index part of the discovered OID will be supplied to policy\n   conditions\
    \ and actions so that this code can inspect and configure\n   the element.  The\
    \ agent can determine the index portion of discovered\n   OIDs based on the length\
    \ of the pmElementTypeRegOIDPrefix for the\n   portion of the MIB that is being\
    \ retrieved.  For example, if the\n   OIDPrefix is 'ifEntry', which has 9 subids,\
    \ the index starts on the\n   11th subid (skipping the subidentifier for the column;\
    \ e.g.,\n   ifSpeed).\n   For each element that is discovered, the policy condition\
    \ is called\n   with the element's name as an argument to see whether the element\
    \ is\n   a member of the set the policy acts upon.\n   Note that agents may automatically\
    \ configure entries in this table\n   for frequently used element types (interfaces,\
    \ circuits, etc.).  In\n   particular, it may configure elements for which discovery\
    \ is\n   optimized in one or both of the following ways:\n   1. The agent may\
    \ discover elements by scanning internal data\n      structures as opposed to\
    \ issuing local SNMP requests.  It is\n      possible to recreate the exact semantics\
    \ described in this table\n      even if local SNMP requests are not issued.\n\
    \   2. The agent may receive asynchronous notification of new elements\n     \
    \ (for example, \"card inserted\") and use that information to create\n      elements\
    \ instantly rather than through polling.  A similar feature\n      might be available\
    \ for the deletion of elements.\n   Note that upon restart, the disposition of\
    \ agent-installed entries is\n   described by the pmPolicyStorageType object.\n\
    \   A special element type \"0.0\" represents the \"system element\".  \"0.0\"\
    \n   represents the single instance of the system itself and provides an\n   execution\
    \ context for policies to operate on \"the system\" and on MIB\n   objects modeled\
    \ as scalars.  For example, \"0.0\" gives an execution\n   context for policy-based\
    \ selection of the operating system code\n   version (likely modeled as a scalar\
    \ MIB object).  The element type\n   \"0.0\" always exists.  As a consequence,\
    \ no actual discovery will take\n   place and the pmElementTypeRegMaxLatency object\
    \ will have no effect\n   for the \"0.0\" element type.  However, if the \"0.0\"\
    \ element type is\n   not registered in the table, policies will not be executed\
    \ on the\n   \"0.0\" element.\n   If the agent is discovering elements by polling,\
    \ it should check for\n   new elements no less frequently than pmElementTypeRegMaxLatency\
    \ would\n   dictate.  When an element is first discovered, all policyConditions\n\
    \   are run immediately, and policyConditions that match will have the\n   associated\
    \ policyAction run immediately.  Subsequently, the\n   policyCondition will be\
    \ run regularly for the element, with no more\n   than pmPolicyConditionMaxLatency\
    \ milliseconds elapsing between each\n   invocation.  Note that if an implementation\
    \ has the ability to be\n   alerted immediately when a particular type of element\
    \ is created, it\n   is urged to discover that type of element in this fashion\
    \ rather than\n   through polling, resulting in immediate configuration of the\n\
    \   discovered element.\n"
- title: 4.3.1.  Implementation Notes
  contents:
  - "4.3.1.  Implementation Notes\n   Note that although the external behavior of\
    \ this registration process\n   is defined in terms of the walking of MIB tables,\
    \ implementation\n   strategies may differ.  For example, commonly used element\
    \ types\n   (such as interface) may have purpose-built element discovery\n   capability\
    \ built-in and advertised to managers through an entry in\n   the pmElementTypeRegTable.\n\
    \   Before registering an element type, a manager is responsible for\n   inspecting\
    \ the table to see whether it is already registered (either\n   by the agent or\
    \ by another manager).  Note that entries that differ\n   only in the last subid\
    \ (which specifies which object is an entry) are\n   effectively duplicates and\
    \ should be treated as such by the manager.\n   The system that implements the\
    \ Policy-Based Management MIB may not\n   have knowledge of the format of object\
    \ identifiers in other MIB\n   Modules.  Therefore it is inappropriate for it\
    \ to check these OIDs\n   for errors.  It is the responsibility of the management\
    \ station to\n   register well-formed object identifiers.  For example, if an\
    \ extra\n   sub-identifier is supplied when the ifTable is registered, no\n  \
    \ elements will be discovered.  Similarly, if a sub-identifier is\n   missing,\
    \ every element will be discovered numerous times (once per\n   column) and none\
    \ of the element addresses will be well formed.\n"
- title: 4.4.  Element Filtering
  contents:
  - "4.4.  Element Filtering\n   The first step in executing a policy is to see whether\
    \ the policy is\n   ready to run based on its schedule.  If the pmPolicySchedule\
    \ object\n   is equal to zero, there is no schedule defined, and the policy is\n\
    \   always ready.  If the pmPolicySchedule object is non-zero, then the\n   policy\
    \ is ready only if the referenced schedule group contains at\n   least one valid\
    \ schedule entry that is active at the current time.\n   If the policy is ready,\
    \ the next step in executing a policy is to see\n   which elements match the policy\
    \ condition.  The policy condition is\n   called once for each element and runs\
    \ to completion.  The element's\n   name is the only argument that is passed to\
    \ the condition code for\n   each invocation.  No state is remembered within the\
    \ policy script\n   from the previous invocation of 'this element' or from the\
    \ previous\n   invocation of the policy condition, except for state accessible\n\
    \   through library functions.  Two notable examples of these are the\n   scratchpad\
    \ functions, which explicitly provide for storing state, and\n   the SNMP functions,\
    \ which can store state in local or remote MIB\n   objects.  If any run-time exception\
    \ occurs, the condition will\n   terminate immediately for 'this element'.  If\
    \ the condition returns\n   non-zero, the corresponding policy action will be\
    \ executed for 'this\n   element'.\n   If an element matches a condition and it\
    \ had not matched that\n   condition the last time it was checked (or if it is\
    \ a newly\n   discovered element), the associated policyAction will be executed\n\
    \   immediately.  If the element had matched the condition at the last\n   check,\
    \ it will remain in the set of elements whose policyAction will\n   be run within\
    \ the policyActionMaxLatency.\n"
- title: 4.4.1.  Implementation Notes
  contents:
  - "4.4.1.  Implementation Notes\n   Whether policy conditions are multi-tasked is\
    \ an implementation-\n   dependent matter.  Each condition/element combination\
    \ is conceptually\n   its own process and can be scheduled sequentially, or two\
    \ or more\n   could be run simultaneously.\n"
- title: 4.5.  Policy Enforcement
  contents:
  - "4.5.  Policy Enforcement\n   For each element that has returned non-zero from\
    \ the policy\n   condition, the corresponding policy action is called.  The element's\n\
    \   name is the only argument that is passed to the policy action for\n   each\
    \ invocation.  Except for state accessible from library functions,\n   no state\
    \ is remembered from the policy condition evaluation, or from\n   the previous\
    \ condition/action invocation of 'this element' or from\n   the previous invocation\
    \ of the policy condition or action on any\n   other element.  If any run-time\
    \ exception occurs, the action will\n   terminate immediately for 'this element'.\n"
- title: 4.5.1.  Implementation Notes
  contents:
  - "4.5.1.  Implementation Notes\n   How policy actions are multi-tasked is an implementation-dependent\n\
    \   matter.  Each condition/element combination is conceptually its own\n   process\
    \ and can be scheduled sequentially, or two or more could be\n   run simultaneously.\n"
- title: 5.  The PolicyScript Language
  contents:
  - "5.  The PolicyScript Language\n   Policy conditions and policy actions are expressed\
    \ with the\n   PolicyScript language.  The PolicyScript language is designed to\
    \ be a\n   small interpreted language that is simple to understand and\n   implement;\
    \ it is designed to be appropriate for writing small scripts\n   that make up\
    \ policy conditions and actions.\n   PolicyScript is intended to be familiar to\
    \ programmers that know one\n   of several common languages, including Perl and\
    \ C.  Nominally,\n   policyScript is a subset of the C language; however, it was\
    \ desirable\n   to have access to C++'s operator overloading (solely to aid in\n\
    \   documenting the language).  Therefore, PolicyScript is defined\n   formally\
    \ as a subset of the C++ language in which many of the\n   operators are overloaded\
    \ as part of the \"var\" class.  Note, however,\n   that a PolicyScript program\
    \ cannot further overload operators, as the\n   syntax to specify overloading\
    \ is not part of the PolicyScript syntax.\n   A subset was used to provide for\
    \ easy development of low-cost\n   interpreters of PolicyScript and to take away\
    \ language constructs\n   that are peculiar to the C/C++ languages.  For example,\
    \ it is\n   expected that both C and Perl programmers will understand the\n  \
    \ constructs allowed in PolicyScript.\n   Some examples of the C/C++ features\
    \ that are not available are\n   function definitions, pointer variables, structures,\
    \ enums, typedefs,\n   floating point and pre-processor functions (except for\
    \ comments).\n   This language is formally defined as a subset of ISO C++ [10]\
    \ but\n   only allows constructs that may be expressed in the Extended Backus-\n\
    \   Naur Form (EBNF) documented here.  This is because although EBNF\n   doesn't\
    \ fully specify syntactical rules (it allows constructs that\n   are invalid)\
    \ and doesn't specify semantic rules, it can successfully\n   be used to define\
    \ the subset of the language that is required for\n   conformance to this specification.\
    \  Unless explicitly described\n   herein, the meaning of any construct expressed\
    \ in the EBNF can be\n   found by reference to the ISO C++ standard.\n   The use\
    \ of comments and newlines are allowed and encouraged in order\n   to promote\
    \ readability of PolicyScript code.  Comments begin with\n   '/*' and end with\
    \ '*/' or begin with '//' and go until the end of the\n   line.\n   One subset\
    \ is not expressible in the EBNF syntax: all variables\n   within an instance\
    \ of a PolicyScript script are within the same\n   scope.  In other words, variables\
    \ defined in a block delimited with\n   '{' and '}' are not in a separate scope\
    \ from variables in the\n   enclosing block.\n   PolicyScript code must be expressed\
    \ in the ASCII character set.\n   In the EBNF used here, terminals are character\
    \ set members (singly or\n   in a sequence) that are enclosed between two single-quote\
    \ characters\n   or described as a phrase between '<' and '>' characters.\n  \
    \ Nonterminals are a sequence of letters and underscore characters.  A\n   colon\
    \ (:) following a nonterminal introduces its definition, a\n   production.  In\
    \ a production, a '|' character separates alternatives.\n   The '(' and ')' symbols\
    \ group the enclosed items.  The '[' and ']'\n   symbols indicate that the enclosed\
    \ items are optional.  A '?'  symbol\n   following an item indicates that the\
    \ item is optional.  A '*' symbol\n   following an item indicates that the item\
    \ is repeated zero, one, or\n   more times.  A '+' symbol following an item indicates\
    \ that the item\n   is repeated one or more times.  The symbol '--' begins a comment\
    \ that\n   ends at the end of the line.\n"
- title: 5.1.  Formal Definition
  contents:
  - "5.1.  Formal Definition\n   The PolicyScript language follows the syntax and\
    \ semantics of ISO C++\n   [10], but is limited to that which can be expressed\
    \ in the EBNF\n   below.\n   The following keywords are reserved words and cannot\
    \ be used in any\n   policy script.  This prevents someone from using a common\
    \ keyword in\n   another language as an identifier in a script, thereby confusing\
    \ the\n   meaning of the script.  The reserved words are:\n      auto, case, char,\
    \ const, default, do, double, enum, extern, float,\n      goto, inline, int, long,\
    \ register, short, signed, sizeof, static,\n      struct, switch, typedef, union,\
    \ unsigned, void, and volatile.\n   Any syntax error, use of a reserved keyword,\
    \ reference to an unknown\n   identifier, improper number of function arguments,\
    \ error in coercing\n   an argument to the proper type, exceeding local limitations\
    \ on string\n   length, or exceeding local limitations on the total amount of\
    \ storage\n   used by local variables will cause an RTE.\n   PolicyScript permits\
    \ comments using the comment delimiters, '/*' to\n   '*/', or the start of comment\
    \ symbol '//'.\n"
- title: -- Lexical Grammar
  contents:
  - "-- Lexical Grammar\n   letter:       '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n\
    \               | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm'\n               | 'n'\
    \ | 'o' | 'p' | 'q' | 'r' | 's' | 't'\n               | 'u' | 'v' | 'w' | 'x'\
    \ | 'y' | 'z'\n               | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n          \
    \     | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M'\n               | 'N' | 'O' |\
    \ 'P' | 'Q' | 'R' | 'S' | 'T'\n               | 'U' | 'V' | 'W' | 'X' | 'Y' |\
    \ 'Z'\n   digit:        '0' | '1' | '2' | '3' | '4'\n               | '5' | '6'\
    \ | '7' | '8' | '9'\n   non_zero:   '1' | '2' | '3' | '4' | '5' | '6' | '7' |\
    \ '8' | '9'\n   oct_digit:  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'\n  \
    \ hex_digit:    digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n                  \
    \     | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n   escape_seq:    '\\''   |   '\\\"\
    '   |   '\\?'   |   '\\\\'\n                | '\\a'   |   '\\b'   |   '\\f'  \
    \ |   '\\n'\n                | '\\r'   |  '\\t'    |   '\\v'\n               \
    \ | '\\' oct_digit+    | '\\x' hex_digit+\n   non_quote:  Any character in the\
    \ ASCII character set\n               except single quote ('), double quote (\"\
    ),\n               backslash ('\\'), or newline.\n   c_char:            non_quote\
    \ | '\"' | escape_seq\n   string_literal:    '\"' s_char* '\"'\n   s_char:   \
    \         non_quote | ''' | escape_seq\n   char_constant:     ''' c_char '''\n\
    \   decimal_constant:  non_zero digit*\n   octal_constant:    '0' oct_digit*\n\
    \   hex_constant:      ( '0x' | '0X' ) hex_digit+\n   integer_constant:  decimal_constant\
    \ | octal_constant | hex_constant\n   identifier:        letter ( letter | digit\
    \ )*\n"
- title: -- Phrase Structure Grammar
  contents:
  - "-- Phrase Structure Grammar\n   -- Expressions\n   primary_expr:      identifier\
    \ | integer_constant | char_constant\n                    | string_literal  |\
    \  '(' expression ')'\n   postfix_expr:      primary_expr\n                  \
    \  | identifier '(' argument_expression_list? ')'\n                    | postfix_expr\
    \ '++'\n                    | postfix_expr '--'\n                    | postfix_expr\
    \ '[' expression ']'\n   argument_expression_list:\n                      assignment_expr\n\
    \                    | argument_expression_list ',' assignment_expr\n   unary_expr:\
    \        postfix_expr  |  unary_op unary_expr\n   unary_op:          '+' | '-'\
    \ | '~' | '!' | '++' | '--'\n   binary_expr:  unary_expr | binary_expr binary_op\
    \ unary_expr\n   binary_op:       '||' | '&&' | '|'  | '^'  | '&'  | '!='\n  \
    \                | '==' | '>=' | '<=' | '>'  | '<'  | '>>'\n                 \
    \ | '<<' |  '-' | '+'  | '%'  | '/'  |  '*'\n   assignment_expr:      binary_expr\n\
    \                       | unary_expr assignment_op assignment_expr\n   assignment_op:\
    \     '=' | '*='  | '/=' | '%=' | '+=' | '-='\n                  | '<<=' | '>>='\
    \ | '&=' | '^=' | '|='\n   expression:    assignment_expr | expression ',' assignment_expr\n\
    \   -- Declarations\n   declaration:       'var' declarator_list ';'\n   declarator_list:\
    \   init_declarator\n                    | declarator_list ',' init_declarator\n\
    \   init_declarator:   identifier [ '=' assignment_expr ]\n   -- Statements\n\
    \   statement:   declaration\n              | compound_statement\n           \
    \   | expression_statement\n              | selection_statement\n            \
    \  | iteration_statement\n              | jump_statement\n   compound_statement:\
    \    '{' statement* '}'\n   expression_statement:  expression? ';'\n   selection_statement:\n\
    \           'if' '(' expression ')' statement\n         | 'if' '(' expression\
    \ ')' statement 'else' statement\n   iteration_statement:\n           'while'\
    \ '(' expression ')' statement\n         | 'for' '(' expression? ';' expression?\
    \ ';' expression? ')'\n               statement\n   jump_statement:    'continue'\
    \ ';'\n                    | 'break' ';'\n                    | 'return' expression?\
    \ ';'\n   -- Root production\n   PolicyScript:     statement*\n"
- title: 5.2.  Variables
  contents:
  - "5.2.  Variables\n   To promote shorter scripts and ease in writing them, PolicyScript\n\
    \   provides a loosely typed data class, \"var\", that can store both\n   integer\
    \ and string values.  The native C++ types (char, int, etc.)\n   are thus unnecessary\
    \ and have not been carried into the subset that\n   comprises this language.\
    \  The semantics of the \"var\" type are modeled\n   after those of ECMAScript[17].\n\
    \      For example:\n         var number = 0, name = \"IETF\";\n   This language\
    \ will be executed in an environment where the following\n   typedef is declared.\
    \  (Note that this typedef will not be visible in\n   the policyCondition or policyAction\
    \ code.)\n      typedef ... var;\n   Although this declaration is expressed here\
    \ as a typedef, the\n   'typedef' keyword itself is not available to be used in\
    \ PolicyScript\n   code.\n"
- title: 5.2.1.  The Var Class
  contents:
  - "5.2.1.  The Var Class\n   A value is an entity that takes on one of two types:\
    \ string or\n   integer.\n   The String type is the set of all finite ordered\
    \ sequences of zero or\n   more 8-bit unsigned integer values (\"elements\").\
    \  The string type can\n   store textual data as well as binary data sequences.\
    \  Each element is\n   considered to occupy a position within the sequence.  These\
    \ positions\n   are indexed with nonnegative integers.  The first element (if\
    \ any) is\n   at position 0, the next element (if any) at position 1, and so on.\n\
    \   The length of a string is the number of elements (i.e., 8-bit values)\n  \
    \ within it.  The empty string has length zero and therefore contains\n   no elements.\n\
    \   The integer type is the set of all integer values in the range\n   -9223372036854775808\
    \ (-2^63) to 18446744073709551615 (2^64-1).  If an\n   integer operation would\
    \ cause a (positive) overflow, then the result\n   is returned modulo 2^64.  If\
    \ an integer operation would cause a\n   (negative) underflow, then the result\
    \ is undefined.  Integer division\n   rounds toward zero.\n   Prior to initialization,\
    \ a var object has type String and a length of\n   zero.\n   The policy script\
    \ runtime system performs automatic type conversion\n   as needed.  To clarify\
    \ the semantics of certain constructs it is\n   useful to define a set of conversion\
    \ operators: ToInteger(),\n   ToString(), ToBoolean(), and Type().  These operators\
    \ are not a part\n   of the language; they are defined here to aid the specification\
    \ of\n   the semantics of the language.  The conversion operators are\n   polymorphic;\
    \ that is, they can accept a value of any standard type.\n   ToInteger\n   The\
    \ operator ToInteger converts its argument to a value of type\n   Integer according\
    \ to the following table:\n         Integer            The result equals the input\
    \ argument\n                            (no conversion).\n         String    \
    \         See grammar and note below.\n         integer_constant   The result\
    \ equals the input argument\n                            (no conversion).\n  \
    \       string_literal     See grammar and note below.\n         char_constant\
    \      See grammar and note below.\n   ToInteger Applied to Strings\n   ToInteger\
    \ applied to the String Type string_literal and to\n   char_constants applies\
    \ the following grammar to the input.  If the\n   grammar cannot interpret the\
    \ string as an expansion of\n   numeric_string, then an RTE is generated.  Note\
    \ that a numeric_string\n   that is empty or contains only white space is converted\
    \ to 0.\n -- EBNF for numeric_string\n   numeric_string : white_space* numeric?\
    \ white_space*\n   white_space :      <TAB> |  <SP> |  <NBSP> |  <FF> |  <VT>\n\
    \                    | <CR>  |  <LF> |  <LS>   |  <PS> |  <USP>\n   numeric :\
    \        signed_decimal |  hex_constant | octal_constant |\n                 \
    \   enum_decimal\n   signed_decimal:  [ '-' | '+' ] decimal_constant\n   enum_decimal:\
    \    [ letter | digit | '-' ]* '(' decimal_constant ')'\n   -- decimal_constant,\
    \ hex_constant, and octal_constant are defined\n   -- in the PolicyScript EBNF\
    \ described earlier.\n   Note that when the enum_decimal form is converted, the\
    \ sequence of\n   characters before the parenthesis and the pair of parenthesis\n\
    \   themselves are completely ignored, and the decimal_constant inside\n   the\
    \ parenthesis is converted.  Thus, \"frame-relay(32)\" translates to\n   the integer\
    \ 32.\n   Although this will make the script more readable than using the\n  \
    \ constant \"32\", the burden is on the code writer to be accurate, as\n   \"\
    ethernet-csmacd(32)\" and \"frame-relay(999)\" will also be accepted.\n   ToString\n\
    \   The operator ToString converts its argument to a value of type String\n  \
    \ according to the following table:\n      Integer           Return the string\
    \ containing the decimal\n                        representation of the input\
    \ argument in\n                        the form of signed_decimal, except that\n\
    \                        no leading '+' will be used.\n      String          \
    \  Return the input argument (no conversion)\n      integer_constant  Return the\
    \ string containing the decimal\n                        representation of the\
    \ input argument in the\n                        form of signed_decimal except\
    \ that no\n                        leading '+' will be used.\n      string_literal\
    \    Return the input argument (no conversion)\n      char_constant     Return\
    \ the string of length one containing\n                        the value of the\
    \ input argument.\n   ToBoolean\n   The operator ToBoolean converts its argument\
    \ to a value of type\n   Integer according to the following table:\n      Integer\
    \            The result is 0 if the argument is 0.\n                         Otherwise\
    \ the result is 1.\n      String             The results is 0 if the argument\
    \ is the\n                         empty string.  Otherwise the result is 1.\n\
    \      integer_constant   The result is 0 if the argument is 0.\n            \
    \             Otherwise the result is 1.\n      string_literal     The result\
    \ is 0 if the argument is the\n                         empty string.  Otherwise\
    \ the result is 1.\n      char_constant      The result is 1.\n   Operators\n\
    \   The rules below specify the type conversion rules for the various\n   operators.\n\
    \      A++:   A = ToInteger(A); A++;\n      A--:   A = ToInteger(A); A--;\n  \
    \    ++A:   A = ToInteger(A); ++A;\n      --A:   A = ToInteger(A); --A;\n    \
    \  +A:    ToInteger(A);\n      -A:     -1 * ToInteger(A);\n      ~A:    ToInteger(A);\n\
    \      !A:    !ToBoolean(A);\n      A * B, A - B, A & B, A ^ B , A | B, A << B,\
    \ A >> B:\n             ToInteger(A) <operator> ToInteger(B)\n      A / B, A %\
    \ B:\n             if (ToInteger(B) == 0)\n               RTE, terminate;\n  \
    \           else\n               ToInteger(A) <operator> ToInteger(B)\n      A\
    \ + B:\n             if (Type(A) == String || Type(B) == String)\n           \
    \    ToString(A) concatenated with ToString(B)\n             else\n          \
    \     A + B\n      Compound Assignment (<operator>=):\n              Simply follow\
    \ rules above.  Note that type of LHS (Left\n              Hand Side) may be changed\
    \ as a result.\n      A < B, A > B, A <= B, A >= B, A == B, A != B:\n        \
    \     if (Type(A) == String && Type(B) == String)\n                 lexically\
    \ compare strings with strcmp() logic\n             else\n                 ToInteger(A)\
    \ <operator> ToInteger(B)\n       A && B:\n              if (ToBoolean(A))\n \
    \                 ToBoolean(B);\n              else\n                  false;\n\
    \       A || B:\n              if (ToBoolean(A))\n                  true;\n  \
    \            else\n                  ToBoolean(B);\n       if(A):\n          \
    \    if (ToBoolean(A))\n       while(A):\n              while(ToBoolean(A))\n\
    \       for(...; A; ...):\n             for(...; ToBoolean(A); ...)\n       A[B]\
    \ as a RHS (Right Hand Side) value:\n             if (Type(A) != String\n    \
    \              || ToInteger(B) >= strlen(A))\n                RTE, terminate;\n\
    \             A[ ToInteger(B) ]\n             The contents are returned as a string\
    \ of length one\n        A[B] = C as a LHS value:\n             if (Type(A) !=\
    \ String\n                  || ToInteger(B) >= strlen(A))\n                RTE,\
    \ terminate;\n             if (strlen(ToString(C)) == 0)\n                RTE,\
    \ terminate\n             A[ ToInteger(B) ] = First octet of ToString(C)\n   \
    \          Note that this is only applicable in a simple assignment.\n   For example,\
    \ in the expression\n      \"getVar(\"ifSpeed.1\") < 128000\"\n   getVar always\
    \ returns a string and '128000' is implicitly an integer.\n   The rules for '<'\
    \ dictate that if either argument is an integer then\n   a 'numeric less than'\
    \ is performed on ToInteger(A) and ToInteger(B).\n   If \"getVar(\"ifSpeed.1\"\
    )\" returns \"64000\", the expression can be\n   translated to:\n        ToInteger(\"\
    64000\") < ToInteger(128000); or,\n        64000 < 128000; or,\n        True\n"
- title: 5.3.  PolicyScript QuickStart Guide
  contents:
  - "5.3.  PolicyScript QuickStart Guide\n   PolicyScript is designed so that programmers\
    \ fluent in other\n   languages can quickly begin to write scripts.\n   One way\
    \ to become familiar with a language is to see it in action.\n   The following\
    \ nonsensical script exercises most of the PolicyScript\n   constructs (though\
    \ it skips some usage options and many arithmetic\n   operators).\n      var x,\
    \ index = 7, str = \"Hello World\", oid = \"ifSpeed.\";\n      x = 0;\n      while(x\
    \ < 10){\n          if (str < \"Goodbye\") /* string comparison */\n         \
    \     continue;\n          else\n              break;\n          x++;\n      }\n\
    \      if (oidlen(oid) == 10)\n          oid += \".\" + index; // append index\
    \ to oid\n      for(x = 0; x < 7; x++){\n            str += \"a\";\n         \
    \   var y = 12;\n            index = ((x * 7) + y) % 3;\n            if (str[6]\
    \ == 'W')\n                return index;\n      }\n      return;\n   The following\
    \ examples are more practical:\n   For a condition:\n      // Return 1 if this\
    \ is an interface and it is tagged\n      // with the role \"gold\"\n      return\
    \ (inSubtree(elementName(), \"ifEntry\")\n          && roleMatch(\"gold\"))\n\
    \   A condition/action pair:\n   First, register the Host Resources MIB hrSWRunEntry\
    \ as a new element\n   in the pmElementTypeRegTable.  This will cause the policy\
    \ to run for\n   every process on the system.  The token '$*' will be replaced\
    \ by the\n   script interpreter with a process index (see Section 7 for a\n  \
    \ definition of the '$*' token).\n   The condition:\n      // if it's a process\
    \ and it's an application and it's\n      // consumed more than 5 minutes of CPU\
    \ time\n      return (inSubtree(elementName(), \"hrSWRunEntry\")\n           \
    \   && getVar(\"hrSWRunType.$*\") == 4  // app, not OS or driver\n           \
    \   && getVar(\"hrSWRunPerfCPU.$*\") > 30000) // 300 seconds\n   The action:\n\
    \      // Kill it\n      setVar(\"hrSWRunStatus.$*\", 4, Integer); // invalid(4)\
    \ kills it\n   A more substantial action to start an RMON2 host table on interfaces\n\
    \   that match the condition:\n      var pdu, index;\n      pdu = newPDU();\n\
    \      writeVar(pdu, 0, \"hlHostControlDataSource.*\",\n               \"ifIndex.\"\
    \ + ev(0), Oid);\n      writeVar(pdu, 1, \"hlHostControlNlMaxDesiredEntries.*\"\
    , 1000,\n               Integer);\n      writeVar(pdu, 2, \"hlHostControlAlMaxDesiredEntries.*\"\
    , 1000,\n               Integer);\n      writeVar(pdu, 3, \"hlHostControlOwner.*\"\
    , \"policy\", String);\n      writeVar(pdu, 4, \"hlHostControlStatus.*\", \"active(1)\"\
    , Integer);\n      if (createRow(pdu, 5, 4, 20, 65535, index) == 0\n         \
    \ || index == -1)\n          return;\n   Because PolicyScript is a least common\
    \ denominator, it contains\n   nothing that would astonish programmers familiar\
    \ with C, C++, Perl,\n   Tcl, JavaScript, or Python.  Although a new programmer\
    \ may attempt to\n   use language constructs that aren't available in PolicyScript,\
    \ s/he\n   should be able to understand any existing PolicyScript and will\n \
    \  likely know how to use anything that is valid in PolicyScript.  The\n   lists\
    \ below quickly enumerate the changes of note for programmers\n   coming from\
    \ some particular languages.  These lists won't describe\n   the unavailable constructs,\
    \ but it is easy to see from the definition\n   above what is available.\n"
- title: 5.3.1.  Quickstart for C Programmers
  contents:
  - "5.3.1.  Quickstart for C Programmers\n   - Character constants (i.e., 'c') are\
    \ treated as one-character\n     strings, not as integers.  So operations such\
    \ as ('M' - 'A') or (x\n     + 'A') will not perform as expected.\n   - Functions\
    \ can change the value of arguments even though they are\n     not pointers (or\
    \ called like '&arg').\n   - All variables are in the same scope.\n"
- title: 5.3.2.  Quickstart for Perl Programmers
  contents:
  - "5.3.2.  Quickstart for Perl Programmers\n   - Comments are '/* comment */' and\
    \ '// till end of line', not '#'.\n   - No need to put a '$' in front of variables.\n\
    \   - Strings are compared with ==, <=, <, etc. (details in Sec. 6.2.1).\n   -\
    \ Strings are concatenated with '+' (details in Sec. 6.2.1).\n   - No variable\
    \ substitution in \"\" strings.  '' strings are 1 char\n     only.\n   - Variables\
    \ must be declared before use (but no type is necessary).\n   - All variables\
    \ are in the same scope.\n"
- title: 5.3.3.  Quickstart for TCL Programmers
  contents:
  - "5.3.3.  Quickstart for TCL Programmers\n   - Comments are '/* comment */' and\
    \ '// till end of line', not '#'.\n   - No need to put a '$' in front of variables.\n\
    \   - Function calls are func-name(arg1, arg2, ...).\n   - Square braces [] don't\
    \ interpret their contents.\n   - Double quotes \"\" surround a string, but no\
    \ substitutions are\n     performed (\"\" is like { } in TCL ).\n   - Statements\
    \ are terminated by a semicolon (;).\n   - Instead of \"Set a b\", use \"b = a;\"\
    .\n   - Strings are concatenated with '+' (details in Sec. 6.2.1).\n   - All variables\
    \ are in the same scope.\n"
- title: 5.3.4.  Quickstart for Python Programmers
  contents:
  - "5.3.4.  Quickstart for Python Programmers\n   - Comments are '/* comment */'\
    \ and '// till end of line', not '#'.\n   - Single quotes can be used only for\
    \ single-character strings ('a').\n   - Indentation doesn't matter.  Braces {\
    \ } define blocks.\n   - Variables must be declared before use (but no type is\
    \ necessary).\n   - The expressions for if and while are always surrounded by\n\
    \     parenthesis, as in \"if (x < 5)\".\n   - 'for' syntax is \"for(expression;\
    \ expression; expression)\" (see\n     EBNF).\n   - All variables are in the same\
    \ scope.\n"
- title: 5.3.5.  Quickstart for JavaScript/ECMAScript/JScript Programmers
  contents:
  - "5.3.5.  Quickstart for JavaScript/ECMAScript/JScript Programmers\n   - Variables\
    \ must be declared before use.\n   - Functions can change the value of arguments.\n\
    \   - All variables are in the same scope.\n"
- title: 5.4.  PolicyScript Script Return Values
  contents:
  - "5.4.  PolicyScript Script Return Values\n   A PolicyScript script execution is\
    \ normally ended by the execution of\n   a return statement, or by having the\
    \ flow of execution reach the end\n   of the final statement in the script.  A\
    \ normal script execution\n   always returns a Boolean value.  If no explicit\
    \ value is specified in\n   the return statement, or if the flow of control proceeds\
    \ through the\n   end of the script, the return value is implicitly zero.  If\
    \ an\n   expression is provided with the return statement, the expression is\n\
    \   evaluated, and the result of the expression is implicitly converted\n   with\
    \ the ToBoolean operator before being returned to the script\n   execution environment.\n\
    \   The return value of a policyCondition script is used to determine\n   whether\
    \ the associated policyAction script is executed.  If the\n   returned value is\
    \ zero, the associated policyAction script is not\n   executed.  If the returned\
    \ value is one, the associated policyAction\n   script will be executed.\n   The\
    \ return value of a policyAction script is ignored.\n   An RTE or invocation of\
    \ the fail() function will cause the return\n   value of the script to be set\
    \ to zero.  Note however, that execution\n   of the defer() or fail() functions\
    \ may set the defer attribute so\n   that the lower precedence script may be executed.\
    \  This is\n   independent of the return value of the policy script execution.\n"
- title: 6.  Index Information for 'this element'
  contents:
  - "6.  Index Information for 'this element'\n   PolicyScript code needs a convenient\
    \ way to get the components of the\n   index for 'this element' so that they can\
    \ perform SNMP operations on\n   it or on related elements.\n   Two mechanisms\
    \ are provided.\n   1. For all OID input parameters to all SNMP Library Functions\
    \ (but\n      not OID utility functions), the token \"$n\" ('$' followed by an\n\
    \      integer between 0 and 128) can be used in place of any decimal\n      sub-identifier.\
    \  This token is expanded by the agent at execution\n      time to contain the\
    \ nth subid of the index for the current\n      element.  For example, if the\
    \ element is interface 7, and the\n      objectIdentifier is \"1.3.6.1.2.1.2.2.1.3.$0\"\
    , it will be expanded\n      to \"1.3.6.1.2.1.2.2.1.3.7\".  The special token\
    \ \"$*\" is expanded to\n      contain all of the subidentifiers of the index\
    \ of the current\n      element, separated by '.' characters.\n      It is an\
    \ RTE if a token is specified that is beyond the length of\n      the index for\
    \ the current element.\n      Note that the \"$n\" convention is only active within\
    \ strings.\n   2. The ec() and ev() functions allow access to the components of\
    \ the\n      index for 'this element'.  ec() takes no argument and returns the\n\
    \      number of index components that exist.  ev() takes an integer\n      argument\
    \ specifying which component of the index (numbered\n      starting at 0) and\
    \ returns an integer containing the value of the\n      n'th subidentifier.  Refer\
    \ to the Library functions section for\n      the complete definition of ec()\
    \ and ev().\n         For example, if 'this element' is frCircuitDLCI.5.57\n \
    \                                          (ifIndex = 5, DLCI = 57)\n        \
    \       then ec()  returns 2\n                    ev(0) returns 5\n          \
    \          ev(1) returns 57\n      This is helpful when one wishes to address\
    \ a related element.\n      Extending the previous example, to find the port speed\
    \ of the\n      port, the circuit (above) runs over:\n         portSpeed = getVar(\"\
    ifSpeed.\" + ev(0));\n      A script may check the type of 'this element' by calling\
    \ the\n      elementName() function.  Although it is possible to write a script\n\
    \      that will work with different types of elements, many scripts will\n  \
    \    assume a particular element type and will work incorrectly if used\n    \
    \  on different element types.\n"
- title: 7.  Library Functions
  contents:
  - "7.  Library Functions\n   Library functions are built-in functions available\
    \ primarily to\n   provide access to information on the local system or to manipulate\n\
    \   this information more efficiently.  A group of functions is organized\n  \
    \ into a library, the unit of conformance for function implementation.\n   In\
    \ order to claim conformance to a library, an implementation must\n   implement\
    \ all functions in a library to the specifications of the\n   library.\n   In\
    \ order for a management station or a condition or action to\n   understand whether\
    \ a certain library of functions is implemented,\n   each library will have a\
    \ name that it registers in the role table as\n   a characteristic of the system\
    \ element (\"0.0\") in the default SNMP\n   context.  Thus, conformance to a library\
    \ can be tested with the\n   roleMatch library function (in the base library)\
    \ with the call\n   roleMatch (\"libraryName\", \"0.0\").\n   Note that in the\
    \ descriptions of these functions below, the function\n   prototype describes\
    \ the type of argument expected.  Even though\n   variables are not declared with\
    \ a particular type, their contents\n   must be appropriate for each function\
    \ argument.  If the type is\n   variable, the keyword 'var' will be used.  If\
    \ only a string is\n   appropriate, the keyword 'string' will be used.  If only\
    \ an integer\n   is appropriate, the keyword 'integer' will be used.  If the argument\n\
    \   is declared as 'string' or 'integer' and a value of a different type\n   is\
    \ passed, the argument will be coerced with ToInteger() or\n   ToString().  Any\
    \ failure of this coercion will cause an RTE (in\n   particular for ToInteger(),\
    \ which will fail if its string-valued\n   argument is not a well-formed integer).\n\
    \   In the function prototype, if the '&' character precedes the\n   identifier\
    \ for an argument, that argument may be modified by the\n   function (e.g., \"\
    integer &result, ...)\").  Arguments without the '&'\n   character cannot be modified\
    \ by the function.  In a script,\n   modifiable arguments don't have to be preceded\
    \ by a '&'.  It is an\n   RTE if a constant is passed to a modifiable function\
    \ argument\n   (regardless of whether the function actually writes to the argument).\n\
    \   In the function prototype, the '[' and ']' characters surround\n   arguments\
    \ that are optional.  In PolicyScript code, the optional\n   argument may only\
    \ be included if all optional arguments to the left\n   of it are included.  The\
    \ function may place restrictions on when an\n   optional argument must, or must\
    \ not, be included.\n   In the function prototype, if a type is listed before\
    \ the name of the\n   function, the function returns a value of that type.  If\
    \ no type is\n   listed, the function returns no value.\n"
- title: 8.  Base Function Library
  contents:
  - "8.  Base Function Library\n   A standard base library of functions is available\
    \ to all systems that\n   implement this specification.  This library is registered\
    \ with the\n   name \"pmBaseFunctionLibrary\".  Although the specification of\
    \ this\n   library is modularized into 4 separate sections, conformance to the\n\
    \   library requires implementation of all functions in all sections.\n   The\
    \ sections are:\n      - SNMP library functions\n      - Policy library functions\n\
    \      - Utility functions\n      - Library Functions\n"
- title: 8.1.  SNMP Library Functions
  contents:
  - "8.1.  SNMP Library Functions\n   Two sets of SNMP Library functions are available\
    \ with different\n   situations in mind:\n   - Convenience SNMP Functions\n  \
    \   In an effort to keep simple things simple, these functions are easy\n    \
    \ to use and code that is easy to understand.  These functions will\n     suffice\
    \ for the majority of situations, where a single variable is\n     referenced\
    \ and the desired error recovery is simply (and\n     immediately) to give up\
    \ (and move to the next policy-element\n     combination).  In more complex cases,\
    \ the General SNMP Functions\n     can be used at the cost of several times the\
    \ code complexity.\n     The convenience SNMP functions are getVar, exists, setVar,\n\
    \     setRowStatus, createRow, counterRate, and searchColumn.\n   - General SNMP\
    \ Functions\n     The General SNMP functions allow nearly any legal SNMP Message\
    \ to\n     be generated, including those with multiple varbinds, getNext\n   \
    \  operations, notifications, and messages with explicit addressing or\n     security\
    \ specifications.\n     The general SNMP functions are writeVar, readVar, snmpSend,\n\
    \     readError, and writeBulkParameters.\n"
- title: 8.1.1.  SNMP Operations on Non-Local Systems
  contents:
  - "8.1.1.  SNMP Operations on Non-Local Systems\n   From time to time, a script\
    \ may have to perform an operation on a\n   different SNMP system than that on\
    \ which 'this element' resides.\n   Scripts may also have to specify the use of\
    \ alternate security\n   parameters.  In order to do this, the following optional\
    \ arguments\n   are provided for the SNMP library functions:\n   snmp-function(...[,\
    \ integer mPModel,\n                       string tDomain, string tAddress,\n\
    \                       integer secModel, string secName,\n                  \
    \     integer secLevel, string contextEngineID\n   ])\n   For example:\n     \
    \  getVar(\"sysDescr.0\", \"\", SNMPv3, \"transportDomainUdpIpv4\",\n        \
    \      \"192.168.1.1:161\", USM, \"joe\", NoAuthNoPriv);\n   The use of these\
    \ arguments is denoted in function definitions by the\n   keyword 'NonLocalArgs'.\
    \  The definitions of these arguments are as\n   follows:\n      'mPModel' is\
    \ the integer value of the SnmpMessageProcessingModel\n      to use for this operation.\n\
    \      'tDomain' is a string containing an ASCII dotted-decimal object\n     \
    \ identifier representing the transport domain to use for this\n      operation.\n\
    \      'tAddress' is a string containing the transport address formatted\n   \
    \   according to the 'tDomain' argument.  The ASCII formats for\n      various\
    \ values of 'tDomain' are defined by the DISPLAY-HINT for a\n      TEXTUAL-CONVENTION\
    \ that represents an address of that type.  The\n      DISPLAY-HINTs used are:\n\
    \         tDomain                    Source of DISPLAY-HINT [5] [11]\n       \
    \  -------                    ----------------------\n         transportDomainUdpIpv4\
    \     TransportAddressIPv4\n         transportDomainUdpIpv6     TransportAddressIPv6\n\
    \         transportDomainUdpDns      TransportAddressDns\n         snmpCLNSDomain\
    \             snmpOSIAddress\n         snmpCONSDomain             snmpOSIAddress\n\
    \         snmpDDPDomain              snmpNBPAddress\n         snmpIPXDomain  \
    \            snmpIPXAddress\n         rfc1157Domain              snmpUDPAddress\n\
    \         Other                      Use DISPLAY-HINT \"1x:\"\n      'secModel'\
    \ is the integer value of the SnmpSecurityModel to use\n      for this operation.\n\
    \      'secName' is a string value representing the SnmpSecurityName to\n    \
    \  use for this operation.\n      'secLevel' is the integer value of the SnmpSecurityLevel\
    \ to use\n      for this operation.\n      An SNMP operation will be sent to the\
    \ target system by using\n      security parameters retrieved from a local configuration\
    \ datastore\n      based on 'secModel', 'secName', and 'secLevel'.  It is the\n\
    \      responsibility of the agent to ensure that sensitive information\n    \
    \  in the local configuration datastore is used on behalf of the\n      correct\
    \ principals, as identified by the security credentials of\n      the last entity\
    \ to modify the pmPolicyAdminStatus for a policy.\n      To illustrate how this\
    \ must be configured, consider an example in\n      which 'joe' installs a policy\
    \ on 'PMAgent' that will periodically\n      configure objects on 'TargetAgent'\
    \ with the credentials of\n      'Operator'.  The following conditions must be\
    \ true for this policy\n      to execute with the proper privileges:\n      -\
    \ 'Operator's security credentials for TargetAgent must be\n        installed\
    \ in PMAgent's local configuration datastore (e.g.,\n        usmUserTable [6])\
    \ indexed by TargetAgent's engineID and\n        'Operator'.\n      - VACM [9]\
    \ must be configured on PMAgent so that 'joe' has access\n        to the above\
    \ entry in the appropriate MIB for the local\n        configuration datastore\
    \ (e.g., usmUserTable).\n      - 'joe' must be the last user to modify the pmPolicyAdminStatus\n\
    \        object for the policy.\n      See the Security Considerations section\
    \ for more information.\n      For convenience, constants for 'mPModel', 'secModel',\
    \ and\n      'secLevel' are defined in the \"Constants\" section below.\n    \
    \  'contextEngineID' is a string representing the contextEngineID of\n      the\
    \ SNMP entity targeted by this operation.  It is encoded as a\n      pair of hex\
    \ digits (upper- and lowercase are valid) for each octet\n      of the contextEngineID.\
    \  If 'tDomain' and 'tAddress' are provided\n      but 'contextEngineID' is not,\
    \ then the operation will be directed\n      to the SNMP entity reachable at 'tDomain'\
    \ and 'tAddress'.\n      In order for PolicyScript code to use any of these arguments,\
    \ all\n      optional arguments to the left must be included.  'mPModel',\n  \
    \    'tDomain', 'tAddress', 'secModel', 'secName', and 'secLevel' must\n     \
    \ be used as a group; if one is specified, they must all be.\n      'contextEngineID'\
    \ may only be specified if all others are\n      specified.\n      Note that a\
    \ function that uses NonLocalArgs must provide a\n      parameter for the contextName\
    \ that will be required when the\n      NonLocalArgs are present.  Many functions\
    \ will have the following\n      logic:\n      ContextName NonLocalArgs\n    \
    \  Supplied    Supplied\n      No          No            Addressed to default\
    \ context on\n                                local system.\n      Yes       \
    \  No            Addressed to named context on\n                             \
    \   local system.\n      Yes         Yes           Addressed to named context\
    \ on\n                                potentially remote system.\n      No   \
    \       Yes           Not allowed.\n"
- title: 8.1.2.  Form of SNMP Values
  contents:
  - "8.1.2.  Form of SNMP Values\n   Many of the library functions have input or output\
    \ parameters that\n   may be one of the many SMI data types.  The actual type\
    \ is not\n   encoded in the value but is specified elsewhere, possibly by nature\n\
    \   of the situation in which it is used.  The exact usage for input and\n   output\
    \ is as follows:\n   Any Integer value\n      (INTEGER, Integer32, Counter32,\
    \ Counter64, Gauge32, Unsigned32,\n      TimeTicks, Counter64):\n      On input:\n\
    \         An Integer or a String that can be successfully coerced to an\n    \
    \     Integer with the ToInteger() operator.  It is an RTE if a\n         string\
    \ is passed that cannot be converted by ToInteger() into\n         an integer.\n\
    \         A string of the form\n           enum_decimal: [ letter | digit | '-'\
    \ ]* '(' decimal_constant\n         ')'\n         will also be accepted.  In this\
    \ case the sequence of characters\n         before the parentheses and the parentheses\
    \ themselves are\n         completely ignored, and the decimal_constant inside\
    \ the\n         parentheses is converted.  Thus, \"frame-relay(32)\" translates\n\
    \         to the integer 32.\n      On output:\n         An Integer containing\
    \ the returned value.\n   Octet String\n      On input:\n         Either a String\
    \ or an Integer.  If an Integer, it will be\n         coerced to a String with\
    \ the ToString() function.  This string\n         will be used as an unencoded\
    \ representation of the octet string\n         value.\n      On output:\n    \
    \     A String containing the unencoded value of the octet string.\n   Object\
    \ Identifier\n      On input and on output:\n         A String containing a decimal\
    \ ASCII encoded object identifier\n         of the following form:\n         \
    \   oid:       subid [ '.' subid ]* [ '.' ]\n            subid:     '0' | decimal_constant\n\
    \      It is an RTE if an Object Identifier argument is not in the form\n    \
    \  above.  Note that a trailing '.' is acceptable and will simply be\n      ignored.\
    \  (Note, however, that a trailing dot could cause a\n      strncmp() comparison\
    \ of two otherwise-identical OIDs to fail;\n      instead, use oidncmp().)\n \
    \     Note that ASCII descriptors (e.g., \"ifIndex\") are never used in\n    \
    \  these encodings \"over the wire\".  They are never returned from\n      library\
    \ functions; nor are they ever accepted by them.  NMS user\n      interfaces are\
    \ encouraged to allow humans to view object\n      identifiers with ASCII descriptors,\
    \ but they must translate those\n      descriptors to dotted-decimal format before\
    \ sending them in MIB\n      objects to policy agents.\n   Null\n      On input:\n\
    \         The input is ignored.\n      On output:\n         A zero length string.\n"
- title: 8.1.3.  Convenience SNMP Functions
  contents:
  - '8.1.3.  Convenience SNMP Functions

    '
- title: 8.1.3.1.  getVar()
  contents:
  - "8.1.3.1.  getVar()\n   The getVar() function is used to retrieve the value of\
    \ an SNMP MIB\n   object instance.\n      string getVar(string oid [, string contextName,\
    \ NonLocalArgs])\n         'oid' is a string containing an ASCII dotted-decimal\n\
    \         representation of an object identifier (e.g.,\n         \"1.3.6.1.2.1.1.1.0\"\
    ).\n         The optional 'contextName' argument contains the SNMP context\n \
    \        on which to operate.  If 'contextName' is not present, the\n        \
    \ contextName of 'this element' will be used.  If 'contextName'\n         is the\
    \ zero-length string, the default context is used.\n         The optional 'NonLocalArgs'\
    \ provide addressing and security\n         information to perform an SNMP operation\
    \ on a system different\n         from that of 'this element'.\n         It is\
    \ an RTE if the queried object identifier value does not\n         exist.\n  \
    \       This function returns a string containing the returned value,\n      \
    \   encoded according to the returned type.  Note that no actual\n         SNMP\
    \ PDU has to be generated and parsed when the policy MIB\n         agent resides\
    \ on the same system as the managed elements.\n         It is recommended that\
    \ NMS user interfaces display and allow\n         input of MIB object names by\
    \ their descriptor values, followed\n         by the index in dotted-decimal form\
    \ (e.g., \"ifType.7\").\n"
- title: 8.1.3.2.  exists()
  contents:
  - "8.1.3.2.  exists()\n   The exists() function is used to verify the existence\
    \ of an SNMP MIB\n   object instance.\n      integer exists(string oid [, string\
    \ contextName, NonLocalArgs])\n         'oid' is a string containing an ASCII\
    \ dotted-decimal\n         representation of an object identifier (e.g.,\n   \
    \      \"1.3.6.1.2.1.1.1.0\").\n         The optional 'contextName' argument contains\
    \ the SNMP context\n         on which to operate.  If 'contextName' is not present,\
    \ the\n         contextName of 'this element' will be used.  If 'contextName'\n\
    \         is the zero-length string, the default context is used.\n         The\
    \ optional 'NonLocalArgs' provide addressing and security\n         information\
    \ to perform an SNMP operation on a system different\n         from that of 'this\
    \ element'.\n         This function returns the value 1 if the SNMP instance exists\n\
    \         and 0 if it doesn't exist.  Note that no actual SNMP PDU has to\n  \
    \       be generated and parsed when the policy MIB agent resides on\n       \
    \  the same system as the managed elements.\n         It is recommended that NMS\
    \ user interfaces display and allow\n         input of MIB object names by their\
    \ descriptor values, followed\n         by the index in dotted-decimal form (e.g.,\
    \ \"ifType.7\").\n"
- title: 8.1.3.3.  setVar()
  contents:
  - "8.1.3.3.  setVar()\n   The setVar() function is used to set a MIB object instance\
    \ to a\n   certain value.  The setVar() function is only valid in policyActions.\n\
    \      setVar(string oid, var value, integer type\n             [, string contextName,\
    \ NonLocalArgs] )\n         'oid' is a string containing an ASCII dotted-decimal\n\
    \         representation of an object identifier (e.g.,\n         \"1.3.6.1.2.1.1.1.0\"\
    ).\n         'value' is a string encoded in the format appropriate to the\n  \
    \       'type' parameter.  The agent will set the variable specified by\n    \
    \     'oid' to the value specified by 'value'.\n         'type' will be the type\
    \ of the 'value' parameter and will be\n         set to one of the values for\
    \ DataType Constants.\n         The optional 'contextName' argument contains the\
    \ SNMP context\n         on which to operate.   If 'contextName' is not present,\
    \ the\n         contextName of 'this element' will be used.  If 'contextName'\n\
    \         is the zero length string, the default context is used.\n         The\
    \ optional 'NonLocalArgs' provide addressing and security\n         information\
    \ to perform an SNMP operation on a system different\n         from that of 'this\
    \ element'.  Note that no actual SNMP PDU has\n         to be generated and parsed\
    \ when the policy MIB agent resides on\n         the same system as the managed\
    \ elements.\n         It is an RTE if the set encounters any error.\n        \
    \ It is recommended that NMS user interfaces display and allow\n         input\
    \ of MIB object names by their descriptor values, followed\n         by the index\
    \ in dotted-decimal form (e.g., \"ifType.7\").\n"
- title: 8.1.3.4.  searchColumn()
  contents:
  - "8.1.3.4.  searchColumn()\n      integer searchColumn(string columnoid, string\
    \ &oid,\n                           string pattern, integer mode\n           \
    \                [, string contextName, NonLocalArgs])\n         searchColumn\
    \ performs an SNMP walk on a portion of the MIB\n         searching for objects\
    \ with values equal to the 'pattern'\n         parameter.\n         'columnoid'\
    \ constrains the search to those variables that share\n         the same OID prefix\
    \ (i.e., those that are beneath it in the OID\n         tree).\n         A getnext\
    \ request will be sent requesting the object identifier\n         'oid'.  If 'oid'\
    \ is an empty string, the value of 'columnoid'\n         will be sent.\n     \
    \    The value returned in each response packet will be transformed\n        \
    \ to a string representation of the value of the returned\n         variable.\
    \  The string representation of the value will be\n         formed by putting\
    \ the value in the form dictated by the \"Form\n         of SNMP Values\" rules,\
    \ and then by performing the ToString()\n         function on this value, forming\
    \ 'SearchString'.\n         The 'mode' value controls what type of match to perform\
    \ on this\n         'SearchString' value.  There are 6 possibilities for mode:\n\
    \           Mode               Search Action\n           ExactMatch         Case\
    \ sensitive exact match of 'pattern'\n                              and 'SearchString'.\n\
    \           ExactCaseMatch     Case insensitive exact match of 'pattern'\n   \
    \                           and 'SearchString'.\n           SubstringMatch   \
    \  Case sensitive substring match, finding\n                              'pattern'\
    \ in 'SearchString'.\n           SubstringCaseMatch Case insensitive substring\
    \ match, finding\n                              'pattern' in 'SearchString'.\n\
    \           RegexpMatch        Case sensitive regular expression match,\n    \
    \                          searching 'SearchString' for the regular\n        \
    \                      expression given in 'pattern'.\n           RegexpCaseMatch\
    \    Case insensitive regular expression match,\n                            \
    \  searching 'SearchString' for the regular\n                              expression\
    \ given in 'pattern'.\n         Constants for the values of 'mode' are defined\
    \ in the\n         'Constants' section below.\n         searchColumn uses the\
    \ POSIX extended regular expressions\n         defined in POSIX 1003.2.\n    \
    \     The optional 'contextName' argument contains the SNMP context\n        \
    \ on which to operate.  If 'contextName' is not present, the\n         contextName\
    \ of 'this element' will be used.  If 'contextName'\n         is the zero-length\
    \ string, the default context is used.\n         The optional 'NonLocalArgs' provide\
    \ addressing and security\n         information to perform SNMP operations on\
    \ a system different\n         from that of 'this element'.\n         If a match\
    \ is found, 'oid' is set to the OID of the matched\n         value, and 1 is returned.\
    \  If the search traverses beyond\n         columnoid or returns an error without\
    \ finding a match, zero is\n         returned, and 'oid' isn't modified.\n   \
    \      To find the first match, the caller should set 'oid' to the\n         empty\
    \ string.  To find additional matches, subsequent calls to\n         searchColumn\
    \ should have 'oid' set to the OID of the last\n         match, an operation that\
    \ searchColumn performs automatically.\n         For example:\n             To\
    \ find an ethernet interface\n             oid = \"\";\n             searchColumn(\"\
    ifType\", oid, \"6\", 0);\n         This sends a getnext request for ifType and\
    \ continues to walk\n         the tree until a value matching 6 is found or a\
    \ variable\n         returns that is not in the 'ifType' subtree.\n         To\
    \ find the next ethernet interface, assuming that interface 3\n         was discovered\
    \ to be the first:\n             oid = \"ifType.3\";\n             searchColumn(\"\
    ifType\", oid, \"6\", 0);\n         In a loop to determine all the ethernet interfaces,\
    \ this looks\n         as follows:\n             oid = \"\";\n             while(searchColumn(\"\
    ifType\", oid, \"6\", 0)){\n               /* Do something with oid */\n     \
    \        }\n         Note that in the preceding examples, \"ifType\" is used as\
    \ a\n         notational convenience, and the actual code downloaded to the\n\
    \         policy MIB agent must use the string \"1.3.6.1.2.1.2.2.1.3\" as\n  \
    \       there may be no MIB compiler (or MIB file) available on the\n        \
    \ policy MIB agent.\n         Note that if the value of 'columnoid' is too short\
    \ and thus\n         references too much of the object identifier tree (e.g.,\n\
    \         \"1.3.6\"), 'columnoid' could end up searching a huge number of\n  \
    \       variables (if the value was \"1.3.6\", it would search ALL\n         variables\
    \ on the agent).  It is the responsibility of the\n         caller to make sure\
    \ that 'columnoid' is set appropriately.\n"
- title: 8.1.3.5.  setRowStatus()
  contents:
  - "8.1.3.5.  setRowStatus()\n      integer setRowStatus(string oid, integer maxTries\n\
    \                           [, integer freeOnException , integer seed\n      \
    \                      , string contextName, NonLocalArgs])\n         setRowStatus\
    \ is used to automate the process of finding an\n         unused row in a read-create\
    \ table that uses RowStatus whose\n         index contains an arbitrary integer\
    \ component for uniqueness.\n         'oid' is a string containing an ASCII dotted-decimal\n\
    \         representation of an object identifier, with one of the subids\n   \
    \      replaced with a '*' character (e.g.,\n         \"1.3.6.1.3.1.99.1.2.1.9.*\"\
    ).  'oid' must reference an\n         'instance' of the RowStatus object, and\
    \ the '*' must replace\n         any integer index item that may be set to some\
    \ random value.\n         setRowStatus will come up with a number for the selected\
    \ index\n         item and will attempt to create the instance with the\n    \
    \     createAndWait state.  If the attempt fails, it will retry with\n       \
    \  a different random index value.  It will attempt this no more\n         than\
    \ 'maxTries' times.\n         If the optional 'freeOnException' argument is present\
    \ and equal\n         to 1, the agent will free this row by setting RowStatus\
    \ to\n         'destroy' if, later in the same script invocation, this script\n\
    \         dies with a run-time exception or by a call to fail().  Note\n     \
    \    that this does not apply to exceptions experienced in\n         subsequent\
    \ invocations of the script.\n         If the optional 'seed' argument is present,\
    \ the initial index\n         will be set to 'seed'.  Otherwise it will be random.\
    \  'seed'\n         may not be present if the 'freeOnException' argument is not\n\
    \         present.\n         The optional 'contextName' argument contains the\
    \ SNMP context\n         on which to operate.  If 'contextName' is not present,\
    \ the\n         contextName of 'this element' will be used.  If 'contextName'\n\
    \         is the zero-length string, the default context is used.\n         The\
    \ optional 'NonLocalArgs' provide addressing and security\n         information\
    \ to perform an SNMP operation on a system different\n         from that of 'this\
    \ element'.\n         setRowStatus returns the successful integer value for the\n\
    \         index.  If it is unsuccessful after 'maxTries', or if zero or\n    \
    \     more than one '*' is in OID, -1 will be returned.\n         The createRow\
    \ function (below) can also be used when adding\n         rows to tables.  Although\
    \ createRow has more functionality,\n         setRowStatus may be preferable in\
    \ certain situations (for\n         example, to have the opportunity to inspect\
    \ default values\n         created by the agent).\n"
- title: 8.1.3.6.  createRow()
  contents:
  - "8.1.3.6.  createRow()\n      integer createRow(integer reqPDU, integer reqNumVarbinds,\n\
    \                        integer statusColumn, integer maxTries,\n           \
    \             integer indexRange,\n                        integer &respPDU, integer\
    \ &respNumVarbinds,\n                        integer &index\n                \
    \        [, integer freeOnException, string contextName,\n                   \
    \     NonLocalArgs])\n         createRow is used to automate the process of creating\
    \ a row in\n         a read-create table whose index contains an arbitrary integer\n\
    \         component for uniqueness.  In particular, it encapsulates the\n    \
    \     algorithm behind either the createAndWait or createAndGo\n         mechanism\
    \ and the algorithm for finding an unused row in the\n         table.  createRow\
    \ is not useful for creating rows in tables\n         whose indexes don't contain\
    \ an arbitrary integer component.\n         createRow will perform the operation\
    \ by sending 'reqPDU' and\n         returning the results in 'respPDU'.  Both\
    \ 'reqPDU' and\n         'respPDU' must previously have been allocated with newPDU.\n\
    \         'reqPDU' and 'respPDU' may both contain the same PDU handle, in\n  \
    \       which case the 'reqPDU' is sent and then replaced with the\n         contents\
    \ of the received PDU.\n         'reqNumVarbinds' is an integer greater than zero\
    \ that specifies\n         which varbinds in the PDU will be used in this operation.\
    \  The\n         first 'reqNumVarbinds' in the PDU are used.  Each such varbind\n\
    \         must be of a special form in which the object name must have\n     \
    \    one of its subids replaced with a '*' character (e.g.,\n         \"1.3.6.1.3.1.99.1.2.1.9.*\"\
    ).  The subid selected to be replaced\n         will be an integer index item\
    \ that may be set to some random\n         value.  The same subid should be selected\
    \ in each varbind in\n         the PDU.\n         'respNumVarbinds' will be modified\
    \ to contain the number of\n         varbinds received in the last response PDU.\n\
    \         'statusColumn' identifies which varbind in 'pdu' should be\n       \
    \  treated as the RowStatus column, where 0 identifies the 1st\n         varbind.\n\
    \         createRow will come up with a random integer index value and\n     \
    \    will substitute that value in place of the '*' subid in each\n         varbind.\
    \  It will then set the value of the RowStatus column to\n         select the\
    \ 'createAndGo' mechanism and execute the set.  If the\n         attempt fails\
    \ due to the unavailability of the 'createAndGo'\n         mechanism, it will\
    \ retry with the 'createAndWait' mechanism\n         selected.  If the attempt\
    \ fails because the chosen index value\n         is already in use, the operation\
    \ will be retried with a\n         different random index value.  It will continue\
    \ to retry\n         different index values until it succeeds, until it has made\n\
    \         'maxTries' attempts, or until it encounters an error.  The\n       \
    \  value of 'maxTries' should be chosen to be high enough to\n         minimize\
    \ the chance that as the table fills up an attempt to\n         create a new entry\
    \ will 'collide' too often and fail.\n         All random index values must be\
    \ between 1 and 'indexRange',\n         inclusive.  This is so that values are\
    \ not attempted for an\n         index that fall outside of that index's restricted\
    \ range (e.g.,\n         1..65535).\n         If the optional 'freeOnException'\
    \ argument is present and equal\n         to 1, the agent will free this row by\
    \ setting RowStatus to\n         'destroy' if, later in the same script invocation,\
    \ this script\n         dies with a run-time exception or by a call to fail().\
    \  Note\n         that this does not apply to exceptions experienced in\n    \
    \     subsequent invocations of the script.\n         The optional 'contextName'\
    \ argument contains the SNMP context\n         on which to operate.  If 'contextName'\
    \ is not present, the\n         contextName of 'this element' will be used.  If\
    \ 'contextName'\n         is the zero-length string, the default context is used.\n\
    \         The optional 'NonLocalArgs' provide addressing and security\n      \
    \   information to perform an SNMP operation on a system different\n         from\
    \ that of 'this element'.\n         Note that no actual SNMP PDU has to be generated\
    \ and parsed\n         when the policy MIB agent resides on the same system as\
    \ the\n         managed elements.  If no PDU is generated, the agent must\n  \
    \       correctly simulate the behavior of the SNMP Response PDU,\n         particularly\
    \ in case of an error.\n         This function returns zero unless an error occurs,\
    \ in which\n         case it returns the proper SNMP Error Constant.  If an error\n\
    \         occurred, respPDU will contain the last response PDU as\n         received\
    \ from the agent unless no response PDU was received, in\n         which case\
    \ respNumVarbinds will be 0.  In any event, readError\n         may be called\
    \ on the PDU to determine error information for the\n         transaction.\n \
    \        The 'index' parameter returns the chosen index.  If successful,\n   \
    \      'index' will be set to the successful integer index.  If no\n         SNMP\
    \ error occurs but the operation does not succeed due to the\n         following\
    \ reasons, 'index' will be set to -1:\n            1) Unsuccessful after 'maxTries'.\n\
    \            2) An object name had no '*' in it.\n            3) An object name\
    \ had more than one '*' in it.\n         For example, createRow() might be used\
    \ as follows:\n         var index, pdu = newPDU(), nVars = 0;\n         writeVar(pdu,\
    \ nVars++, \"hlHostControlDataSource.*\",\n                  \"ifIndex.\" + ev(0),\
    \ Oid);\n         writeVar(pdu, nVars++, \"hlHostControlNlMaxDesiredEntries.*\"\
    ,\n                  1000, Integer);\n         writeVar(pdu, nVars++, \"hlHostControlAlMaxDesiredEntries.*\"\
    ,\n                  1000, Integer);\n         writeVar(pdu, nVars++, \"hlHostControlOwner.*\"\
    , \"policy\",\n                  String);\n         writeVar(pdu, nVars++, \"\
    hlHostControlStatus.*\", \"active(1)\",\n                  Integer);\n       \
    \  if (createRow(pdu, nVars, 4, 20, 65535,\n                       pdu, nVars,\
    \ index) != 0\n             || index == -1)\n             return;\n         //\
    \ index now contains index of new row\n"
- title: 8.1.3.7.  counterRate()
  contents:
  - "8.1.3.7.  counterRate()\n   When a policy wishes to make a decision based on\
    \ the rate of a\n   counter, it faces a couple of problems:\n   1. It may have\
    \ to run every X minutes but have to make decisions on\n      rates calculated\
    \ over at least Y minutes, where Y > X.  This would\n      require the complexity\
    \ of managing a queue of old counter values.\n   2. The policy script has no control\
    \ over exactly when it will run.\n   The counterRate() function is designed to\
    \ surmount these problems\n   easily.\n      integer counterRate(string oid, integer\
    \ minInterval\n                          [, integer 64bit,\n                 \
    \         string discOid, integer discMethod,\n                          string\
    \ contextName, NonLocalArgs])\n         'counterRate' retrieves the variable specified\
    \ by oid once per\n         invocation.  It keeps track of timestamped values\
    \ retrieved on\n         previous invocations by this execution context so that\
    \ it can\n         calculate a rate over a period longer than that since the last\n\
    \         invocation.\n         'oid' is the object identifier of the counter\
    \ value that will\n         be retrieved.  The most recent previously saved value\
    \ of the\n         same object identifier that is at least 'minInterval' seconds\n\
    \         old will be subtracted from the newly retrieved value, yielding\n  \
    \       a delta.  If 'minInterval' is zero, this delta will be\n         returned.\
    \  Otherwise, this delta will be divided by the number\n         of seconds elapsed\
    \ between the two retrievals, and the\n         integer-valued result will be\
    \ returned (rounding down when\n         necessary).\n         If there was no\
    \ previously saved retrieval older than\n         'minInterval' seconds, then\
    \ -1 will be returned.  It is an RTE\n         if the query returns noSuchName,\
    \ noSuchInstance, or\n         noSuchObject or an object that is not of type Counter32\
    \ or\n         Counter64.\n         The delta calculation will allow for 32-bit\
    \ counter semantics\n         if it encounters rollover between the two retrievals,\
    \ unless\n         the optional argument '64bit' is present and equal to 1, in\n\
    \         which case it will allow for 64-bit counter semantics.\n         'discOid'\
    \ and 'discMethod' may only be present together.\n         'discOid' contains\
    \ an object identifier of a discontinuity\n         indicator value that will\
    \ be retrieved simultaneously with each\n         counter value:\n           \
    \ 1. If 'discMethod' is equal to 1 and the discontinuity\n               indicator\
    \ is less than the last one retrieved, then a\n               discontinuity is\
    \ indicated.\n            2. If 'discMethod' is equal to 2 and the discontinuity\n\
    \               indicated is different from the last one retrieved, then\n   \
    \            a discontinuity is indicated.\n         If this value indicates a\
    \ discontinuity, this counter value\n         (and its timestamp) will be stored,\
    \ but all previously stored\n         counter values will be invalidated and -1\
    \ will be returned.\n         The implementation will have to store a number of\
    \ timestamped\n         counter values.  The implementation must keep all values\
    \ that\n         are newer than minInterval seconds, plus the newest value that\n\
    \         is older than minInterval seconds.  Other than this one value\n    \
    \     that is older than minInterval seconds, the implementation\n         should\
    \ discard any older values.\n         For example:\n           Policy that executes\
    \ every 60 seconds:\n               rate = counterRate(\"ifInOctets.$*\", 300);\n\
    \               if (rate > 1000000)\n                   ...\n         Another\
    \ example, with a discontinuity indicator:\n           Policy that executes every\
    \ 60 seconds:\n               rate = counterRate(\"ifInOctets.$*\", 300, 0,\n\
    \                                  \"sysUpTime.0\", 1);\n               if (rate\
    \ > 1000000)\n                   ...\n         Another example, with zero minInterval:\n\
    \           Policy that executes every 60 seconds:\n               delta = counterRate(\"\
    ifInErrors.$*\", 0);\n               if (delta > 100)\n                   ...\n\
    \         The optional 'contextName' argument contains the SNMP context\n    \
    \     on which to operate.  If 'contextName' is not present, the\n         contextName\
    \ of 'this element' will be used.  If 'contextName'\n         is the zero-length\
    \ string, the default context is used.\n"
- title: 8.1.4.  General SNMP Functions
  contents:
  - "8.1.4.  General SNMP Functions\n   It is desirable that a general SNMP interface\
    \ have the ability to\n   perform SNMP operations on multiple variables at once\
    \ and that it\n   allow multiple varbind lists to exist at once.  The newPdu,\
    \ readVar,\n   and writeVar functions exist to provide these facilities in a\n\
    \   language without pointers, arrays, and memory allocators.\n   newPDU is called\
    \ to allocate a PDU and return an integer handle to\n   it.  As PDUs are automatically\
    \ freed when the script exits and can be\n   reused during execution, there is\
    \ no freePDU().\n   readVar and writeVar access a variable length varbind list\
    \ for a PDU.\n   The PDU handle and the index of the variable within that PDU\
    \ are\n   specified in every readVar and writeVar operation.  Once a PDU has\n\
    \   been fully specified by one or more calls to writeVar, it is passed\n   to\
    \ snmpSend (by referencing the PDU handle) and the number of\n   varbinds to be\
    \ included in the operation.  When a response is\n   returned, the contents of\
    \ the response are returned in another PDU\n   and may be read by one or more\
    \ calls to readVar.  Error information\n   may be read from the PDU with the readError\
    \ function.  Because\n   GetBulk PDUs send additional information in the SNMP\
    \ header, the\n   writeBulkParameters function is provided to configure these\n\
    \   parameters.\n   Varbinds in this data store are created automatically whenever\
    \ they\n   are written by any writeVar or snmpSend operation.\n   For example:\n\
    \     var pdu = newPDU();\n     var nVars = 0, oid, type, value;\n     writeVar(pdu,\
    \ nVars++, \"sysDescr.0\", \"\", Null);\n     writeVar(pdu, nVars++, \"sysOID.0\"\
    , \"\", Null);\n     writeVar(pdu, nVars++, \"ifNumber.0\", \"\", Null);\n   \
    \  if (snmpSend(pdu, nVars, Get, pdu, nVars))\n         return;\n     readVar(pdu,\
    \ 0, oid, value, type);\n     readVar(pdu, 1, oid, value, type);\n     readVar(pdu,\
    \ 2, oid, value, type);\n     ...\n   or,\n     var pdu = newPDU();\n     var\
    \ nVars = 0, oid1, oid2;\n     writeVar(pdu, nVars++, \"ifIndex\", \"\", Null);\n\
    \     writeVar(pdu, nVars++, \"ifType\", \"\", Null);\n     while(!done){\n  \
    \     if (snmpSend(pdu, nVars, Getnext, pdu, nVars))\n           continue;\n \
    \      readVar(pdu, 0, oid1, value, type);\n       readVar(pdu, 1, oid2, value,\
    \ type);\n       /* leave OIDs alone, now PDU #0 is set up for next step\n   \
    \       in table walk. */\n       if (oidncmp(oid1, \"ifIndex\", oidlen(\"ifIndex\"\
    )))\n         done = 0;\n       ...\n     }\n   Note that in the preceding examples,\
    \ descriptors such as ifType and\n   sysDescr are used in object identifiers solely\
    \ as a notational\n   convenience.  The actual code downloaded to the policy MIB\
    \ agent must\n   use a dotted decimal notation only, as there may be no MIB compiler\n\
    \   (or MIB file) available on the policy MIB agent.\n   To conform to this specification,\
    \ implementations must allow each\n   policy script invocation to allocate at\
    \ least 5 PDUs with at least 64\n   varbinds per list.  It is suggested that implementations\
    \ limit the\n   total number of PDUs per invocation to protect other script\n\
    \   invocations from a malfunctioning script (e.g., a script that calls\n   newPDU()\
    \ in a loop).\n"
- title: 8.1.4.1.  newPDU()
  contents:
  - "8.1.4.1.  newPDU()\n      integer newPDU()\n         newPDU will allocate a new\
    \ PDU and return a handle to the PDU.\n         If no PDU could be allocated,\
    \ -1 will be returned.  The PDU's\n         initial values of nonRepeaters and\
    \ maxRepetitions will be zero.\n"
- title: 8.1.4.2.  writeVar()
  contents:
  - "8.1.4.2.  writeVar()\n      writeVar(integer pdu, integer varBindIndex,\n   \
    \            string oid, var value, integer type)\n         writeVar will store\
    \ 'oid', 'value', and 'type' in the specified\n         varbind.\n         'pdu'\
    \ is the handle to a PDU allocated by newPDU().\n         'varBindIndex' is a\
    \ non-negative integer that identifies the\n         varbind within the specified\
    \ PDU modified by this call.  The\n         first varbind is number 0.\n     \
    \    'oid' is a string containing an ASCII dotted-decimal\n         representation\
    \ of an object identifier (e.g.,\n         \"1.3.6.1.2.1.1.1.0\").\n         'value'\
    \ is the value to be stored, of a type appropriate to the\n         'type' parameter.\n\
    \         'type' will be the type of the value parameter and will be set\n   \
    \      to one of the values for DataType Constants.\n         It is an RTE if\
    \ any of the parameters don't conform to the\n         rules above.\n"
- title: 8.1.4.3.  readVar()
  contents:
  - "8.1.4.3.  readVar()\n      readVar(integer pdu, integer varBindIndex, string\
    \ &oid,\n              var &value, integer &type)\n         readVar will retrieve\
    \ the oid, the value, and its type from the\n         specified varbind.\n   \
    \      'pdu' is the handle to a PDU allocated by newPDU().\n         'varBindIndex'\
    \ is a non-negative integer that identifies the\n         varbind within the specified\
    \ PDU read by this call.  The first\n         varbind is number 0.\n         The\
    \ object identifier value of the referenced varbind will be\n         copied into\
    \ the 'oid' parameter, formatted in an ASCII dotted-\n         decimal representation\
    \ (e.g., \"1.3.6.1.2.1.1.1.0\").\n         'value' is the value retrieved, of\
    \ a type appropriate to the\n         'type' parameter.\n         'type' is the\
    \ type of the value parameter and will be set to\n         one of the values for\
    \ DataType Constants.\n         It is an RTE if 'pdu' doesn't reference a valid\
    \ PDU or\n         'varBindIndex' doesn't reference a valid varbind.\n"
- title: 8.1.4.4.  snmpSend()
  contents:
  - "8.1.4.4.  snmpSend()\n      integer snmpSend(integer reqPDU, integer reqNumVarbinds,\n\
    \                       integer opcode,\n                       integer &respPDU,\
    \ integer &respNumVarbinds,\n                       [, string contextName , NonLocalArgs]\
    \ )\n         snmpSend will perform an SNMP operation by sending 'reqPDU' and\n\
    \         returning the results in 'respPDU'.  Both 'reqPDU' and\n         'respPDU'\
    \ must previously have been allocated with newPDU.\n         'reqPDU' and 'respPDU'\
    \ may both contain the same PDU handle, in\n         which case the 'reqPDU' is\
    \ sent and then replaced with the\n         contents of the received PDU.  If\
    \ the opcode specifies a Trap\n         or V2trap, 'respPDU' will not be modified.\n\
    \         'reqNumVarbinds' is an integer greater than zero that specifies\n  \
    \       which varbinds in the PDU will be used in this operation.  The\n     \
    \    first 'reqNumVarbinds' in the PDU are used.  'respNumVarbinds'\n        \
    \ will be modified to contain the number of varbinds received in\n         the\
    \ response PDU, which, in the case of GetBulk or an error,\n         may be substantially\
    \ different from reqNumVarbinds.\n         'opcode' is the type of SNMP operation\
    \ to perform and must be\n         one of the values for SNMP Operation Constants\
    \ listed in the\n         'Constants' section below.\n         The optional 'contextName'\
    \ argument contains the SNMP context\n         on which to operate.  If 'contextName'\
    \ is not present, the\n         contextName of 'this element' will be used.  If\
    \ 'contextName'\n         is the zero-length string, the default context is used.\n\
    \         Note that no actual SNMP PDU has to be generated and parsed\n      \
    \   when the policy MIB agent resides on the same system as the\n         managed\
    \ elements.  If no PDU is generated, the agent must\n         correctly simulate\
    \ the behavior of the SNMP Response PDU,\n         particularly in case of an\
    \ error.\n         This function returns zero unless an error occurs, in which\n\
    \         case it returns the proper SNMP Error Constant.  If an error\n     \
    \    occurred, respPDU will contain the response PDU as received\n         from\
    \ the agent, unless no response PDU was received, in which\n         case respNumVarbinds\
    \ will be 0.  In any event, readError may be\n         called on the PDU to determine\
    \ error information for the\n         transaction.\n         If an SNMP Version\
    \ 1 trap is requested (the opcode is Trap(4)),\n         then SNMP Version 2 trap\
    \ parameters are supplied and converted\n         according to the rules of RFC\
    \ 3584 [8], section 3.2.  The first\n         variable binding must be sysUpTime.0,\
    \ and the second must be\n         snmpTrapOID.0, as per RFC 3416 [7], section\
    \ 4.2.6.  Subsequent\n         variable bindings are copied to the SNMP Version\
    \ 1 trap PDU in\n         the usual fashion.\n"
- title: 8.1.4.5.  readError()
  contents:
  - "8.1.4.5.  readError()\n      readError(integer pdu, integer numVarbinds, integer\
    \ &errorStatus,\n                integer &errorIndex, integer &hasException)\n\
    \         Returns the error information in a PDU.\n         'errorStatus' contains\
    \ the error-status field from the response\n         PDU or a local error constant\
    \ if the error was generated\n         locally.  If no error was experienced or\
    \ no PDU was ever copied\n         into this PDU, this value will be 0.\n    \
    \     'errorIndex' contains the error-index field from the response\n        \
    \ PDU.  If no PDU was ever copied into this PDU, this value will\n         be\
    \ 0.\n         'hasException' will be 1 if any of the first 'numVarbinds'\n  \
    \       varbinds in the PDU contain an exception (Nosuchobject,\n         Nosuchinstance,\
    \ Endofmibview); otherwise it will be 0.\n         It is an RTE if 'pdu' does\
    \ not reference a valid PDU or if\n         'numVarbinds' references varbinds\
    \ that aren't valid.\n"
- title: 8.1.4.6.  writeBulkParameters()
  contents:
  - "8.1.4.6.  writeBulkParameters()\n      writeBulkParameters(integer pdu, integer\
    \ nonRepeaters,\n                          integer maxRepetitions)\n         Modifies\
    \ the parameters in a PDU in any subsequent GetBulk\n         operation sent by\
    \ the PDU.  'nonRepeaters' will be copied into\n         the PDU's non-repeaters\
    \ field, and 'maxRepetitions' into the\n         max-repetitions field.\n    \
    \     This function may be called before or after writeVar is called\n       \
    \  to add varbinds to the PDU, but it must be called before the\n         PDU\
    \ is sent; otherwise, it will have no effect.  A new PDU is\n         initialized\
    \ with nonRepeaters set to zero and maxRepetitions\n         set to zero.  If\
    \ a Bulk PDU is sent before writeBulkParameters\n         is called, these default\
    \ values will be used.  If\n         writeBulkParameters is called to modify a\
    \ PDU, it is acceptable\n         if this PDU is later sent as a type other than\
    \ bulk.  The\n         writeBulkParameters call will only affect subsequent sends\
    \ of\n         Bulk PDUs.  If a PDU is used to receive the contents of a\n   \
    \      response, the values of nonRepeaters and maxRepetitions are\n         never\
    \ modified.\n"
- title: 8.1.5.  Constants for SNMP Library Functions
  contents:
  - "8.1.5.  Constants for SNMP Library Functions\n   The following constants are\
    \ defined for use with all SNMP Library\n   Functions.  Policy code will be executed\
    \ in an environment where the\n   following constants are declared.  (Note that\
    \ the constant\n   declarations below will not be visible in the policyCondition\
    \ or\n   policyAction code.)  These constants are reserved words and cannot be\n\
    \   used for any variable or function name.\n   Although these declarations are\
    \ expressed here as C 'const's, the\n   'const' construct itself is not available\
    \ to be used in policy code.\n   // Datatype Constants\n   // From RFC 2578 [2]\n\
    \   const integer Integer       = 2;\n   const integer Integer32     = 2;\n  \
    \ const integer String        = 4;\n   const integer Bits          = 4;\n   const\
    \ integer Null          = 5;\n   const integer Oid           = 6;\n   const integer\
    \ IpAddress     = 64;\n   const integer Counter32     = 65;\n   const integer\
    \ Gauge32       = 66;\n   const integer Unsigned32    = 66;\n   const integer\
    \ TimeTicks     = 67;\n   const integer Opaque        = 68;\n   const integer\
    \ Counter64     = 70;\n   // SNMP Exceptions from RFC 3416 [7]\n   const integer\
    \ NoSuchObject         = 128;\n   const integer NoSuchInstance       = 129;\n\
    \   const integer EndOfMibView         = 130;\n   // SNMP Error Constants from\
    \ RFC 3416 [7]\n   const integer NoError              = 0;\n   const integer TooBig\
    \               = 1;\n   const integer NoSuchName           = 2;\n   const integer\
    \ BadValue             = 3;\n   const integer ReadOnly             = 4;\n   const\
    \ integer GenErr               = 5;\n   const integer NoAccess             = 6;\n\
    \   const integer WrongType            = 7;\n   const integer WrongLength    \
    \      = 8;\n   const integer WrongEncoding        = 9;\n   const integer WrongValue\
    \           = 10;\n   const integer NoCreation           = 11;\n   const integer\
    \ InconsistentValue    = 12;\n   const integer ResourceUnavailable  = 13;\n  \
    \ const integer CommitFailed         = 14;\n   const integer UndoFailed      \
    \     = 15;\n   const integer AuthorizationError   = 16;\n   const integer NotWritable\
    \          = 17;\n   const integer InconsistentName     = 18;\n   // \"Local\"\
    \ Errors\n   // These are also possible choices for errorStatus returns\n   //\
    \ For example: unknown PDU, maxVarbinds is bigger than number\n   // written with\
    \ writeVar, unknown opcode, etc.\n   const integer BadParameter         = 1000;\n\
    \   // Request would have created a PDU larger than local limitations\n   const\
    \ integer TooLong              = 1001;\n   // A response to the request was received\
    \ but errors were encountered\n   // when parsing it.\n   const integer ParseError\
    \           = 1002;\n   // Local system has complained of an authentication failure\n\
    \   const integer AuthFailure          = 1003;\n   // No valid response was received\
    \ in a timely fashion\n   const integer TimedOut             = 1004;\n   // General\
    \ local failure including lack of resources\n   const integer GeneralFailure \
    \      = 1005;\n   // SNMP Operation Constants from RFC 3416 [7]\n   const integer\
    \ Get                  = 0;\n   const integer Getnext              = 1;\n   const\
    \ integer Set                  = 3;\n   const integer Trap                 = 4;\n\
    \   const integer Getbulk              = 5;\n   const integer Inform         \
    \      = 6;\n   const integer V2trap               = 7;\n   // Constants from\
    \ RFC 3411 [1] for SnmpMessageProcessingModel\n   const integer SNMPv1       \
    \       = 0;\n   const integer SNMPv2c             = 1;\n   const integer SNMPv3\
    \              = 3;\n   // Constants from RFC 3411 [1] for SnmpSecurityModel\n\
    \   const integer SNMPv1              = 1;\n   const integer SNMPv2c         \
    \    = 2;\n   const integer USM                 = 3;\n   // SnmpSecurityLevel\
    \ Constants from RFC 3411 [1]\n   const integer NoAuthNoPriv        = 1;\n   const\
    \ integer AuthNoPriv          = 2;\n   const integer AuthPriv            = 3;\n\
    \   // Constants for use with searchColumn\n   const integer ExactMatch      \
    \    = 0;\n   const integer ExactCaseMatch      = 1;\n   const integer SubstringMatch\
    \      = 2;\n   const integer SubstringCaseMatch  = 3;\n   const integer RegexpMatch\
    \         = 4;\n   const integer RegexpCaseMatch     = 5;\n"
- title: 8.2.  Policy Library Functions
  contents:
  - "8.2.  Policy Library Functions\n   Policy Library Functions provide access to\
    \ information specifically\n   related to the execution of policies.\n"
- title: 8.2.1.  elementName()
  contents:
  - "8.2.1.  elementName()\n   The elementName() function is used to determine what\
    \ the current\n   element is and can be used to provide information about the\
    \ type of\n   element and how it is indexed.\n      string elementName()\n   \
    \      elementName returns a string containing an ASCII dotted-decimal\n     \
    \    representation of an object identifier (e.g.,\n         1.3.6.1.2.1.1.1.0).\
    \  This object identifier identifies an\n         instance of a MIB object that\
    \ is an attribute of 'this\n         element'.\n"
- title: 8.2.2.  elementAddress()
  contents:
  - "8.2.2.  elementAddress()\n      elementAddress(&tDomain, &tAddress)\n       \
    \  elementAddress finds a domain/address pair that can be used to\n         access\
    \ 'this element' and returns the values in 'tDomain' and\n         'tAddress'.\n"
- title: 8.2.3.  elementContext()
  contents:
  - "8.2.3.  elementContext()\n      string elementContext()\n         elementContext()\
    \ returns a string containing the SNMP\n         contextName of 'this element'.\n"
- title: 8.2.4.  ec()
  contents:
  - "8.2.4.  ec()\n   The ec() (element count) and ev() (element value) functions\
    \ provide\n   convenient access to the components of the index for 'this element'.\n\
    \   Typical uses will be in creating the index to other, related\n   elements.\n\
    \      integer ec()\n         ec() returns an integer count of the number of index\n\
    \         subidentifiers that exist in the index for 'this element'.\n"
- title: 8.2.5.  ev()
  contents:
  - "8.2.5.  ev()\n      integer ev(integer n)\n         ev() returns the value of\
    \ the nth subidentifier in the index\n         for 'this element'.  The first\
    \ subidentifier is indexed at 0.\n         It is an RTE if n specifies a subidentifier\
    \ beyond the last\n         subidentifier.\n"
- title: 8.2.6.  roleMatch()
  contents:
  - "8.2.6.  roleMatch()\n   The roleMatch() function is used to check whether an\
    \ element has been\n   assigned a particular role.\n      integer roleMatch(string\
    \ roleString [, string element,\n                        string contextName, string\
    \ contextEngineID])\n         'roleString' is a string.  The optional argument\
    \ 'element'\n         contains the OID name of an element, defaulting to the current\n\
    \         element if 'element' is not supplied.  If roleString exactly\n     \
    \    matches (content and length) any role assigned to the specified\n       \
    \  element, the function returns 1.  If no roles match, the\n         function\
    \ returns 0.\n         The optional 'contextName' argument contains the SNMP context\n\
    \         on which to operate.  If 'contextName' is not present, the\n       \
    \  contextName of 'this element' will be used.  If 'contextName'\n         is\
    \ the zero-length string, the default context is used.\n         'contextEngineID'\
    \ contains the contextEngineID of the remote\n         system on which 'element'\
    \ resides.  It is encoded as a pair of\n         hex digits (upper- and lowercase\
    \ are valid) for each octet of\n         the contextEngineID.  If 'contextEngineID'\
    \ is not present, the\n         contextEngineID of 'this element' will be used.\n\
    \         'contextEngineID' may only be present if the 'element' and\n       \
    \  'context' arguments are present.\n"
- title: 8.2.7.  Scratchpad Functions
  contents:
  - "8.2.7.  Scratchpad Functions\n   Every maxLatency time period, every policy runs\
    \ once for each\n   element.  When the setScratchpad function executes, it stores\
    \ a value\n   named by a string that can be retrieved with getScratchpad() even\n\
    \   after this policy execution code exits.  This allows sharing of data\n   between\
    \ a condition and an action, two conditions executing on\n   different elements,\
    \ or even different policies altogether.\n   The value of 'scope' controls which\
    \ policy/element combinations can\n   retrieve this 'varName'/'value' pair.  The\
    \ following are options for\n   'scope':\n      Global\n         The 'varName'/'value'\
    \ combination will be available in the\n         condition or action of any policy\
    \ while it is executing on any\n         element.  Note that any information placed\
    \ here will be visible\n         to all other scripts on this system regardless\
    \ of their\n         authority.  Sensitive information should not be placed in\n\
    \         global scratchpad variables.\n      Policy\n         The 'varName'/'value'\
    \ combination will be available in any\n         future execution of the condition\
    \ or action of the current\n         policy (regardless of what element the policy\
    \ is executing on).\n         If a policy is ever deleted, or if its condition\
    \ or action code\n         is modified, all values in its 'Policy' scope will\
    \ be deleted.\n      PolicyElement\n         The 'varName'/'value' combination\
    \ will be available in future\n         executions of the condition or action\
    \ of the current policy,\n         but only when the policy is executing on the\
    \ current element.\n         If a policy is ever deleted, or if its condition\
    \ or action code\n         is modified, all values in its 'PolicyElement' scope\
    \ will be\n         deleted.  The agent may also periodically delete values in\
    \ a\n         'PolicyElement' scope if the corresponding element does not\n  \
    \       exist (in other words, if an element disappears for a period\n       \
    \  and reappears, values in its 'PolicyElement' scope may or may\n         not\
    \ be deleted).\n   setScratchpad's 'storageType' argument allows the script to\
    \ control\n   the lifetime of a variable stored in the scratchpad.  If the\n \
    \  storageType is equal to the constant 'volatile', then this variable\n   must\
    \ be deleted on a reboot.  If it is equal to 'nonVolatile', then\n   this variable\
    \ should be stored in non-volatile storage, where it will\n   be available after\
    \ a reboot.  If the 'storageType' argument is not\n   present, the variable will\
    \ be volatile and will be erased on reboot.\n   If the optional 'freeOnException'\
    \ argument is present and equal to 1,\n   the agent will free this variable if,\
    \ later in the same script\n   invocation, this script dies with a run-time exception\
    \ or by a call\n   to fail().  (Note that this does not apply to exceptions experienced\n\
    \   in subsequent invocations of the script.)\n   Note that there may be implementation-specific\
    \ limits on the number\n   of scratchpad variables that can be allocated.  The\
    \ limit of unique\n   scratchpad variables may be different for each scope or\
    \ storageType.\n   It is suggested that implementations limit the total number\
    \ of\n   scratchpad variables per script to protect other scripts from a\n   malfunctioning\
    \ script.  In addition, compliant implementations must\n   support at least 50\
    \ Global variables, 5 Policy variables per policy,\n   and 5 PolicyElement variables\
    \ per policy-element pair.\n   Scratchpad Usage Examples\n   Policy  Element \
    \   Action\n   A       ifIndex.1  setScratchpad(Global, \"foo\", \"55\")\n   A\
    \       ifIndex.1  getScratchpad(Global, \"foo\", val) --> 55\n   A       ifIndex.2\
    \  getScratchpad(Global, \"foo\", val) --> 55\n   B       ifIndex.2  getScratchpad(Global,\
    \ \"foo\", val) --> 55\n   B       ifIndex.2  setScratchpad(Global, \"foo\", \"\
    16\")\n   A       ifIndex.1  getScratchpad(Global, \"foo\", val) --> 16\n   Policy\
    \  Element    Action\n   A       ifIndex.1  setScratchpad(Policy, \"bar\", \"\
    75\")\n   A       ifIndex.1  getScratchpad(Policy, \"bar\", val) --> 75\n   A\
    \       ifIndex.2  getScratchpad(Policy, \"bar\", val) --> 75\n   B       ifIndex.1\
    \  getScratchpad(Policy, \"bar\", val) not found\n   B       ifIndex.1  setScratchpad(Policy,\
    \ \"bar\", \"20\")\n   A       ifIndex.2  getScratchpad(Policy, \"bar\", val)\
    \ --> 75\n   B       ifIndex.2  getScratchpad(Policy, \"bar\", val) --> 20\n \
    \  Policy  Element    Action\n   A       ifIndex.1  setScratchpad(PolicyElement,\
    \ \"baz\", \"43\")\n   A       ifIndex.1  getScratchpad(PolicyElement, \"baz\"\
    , val) --> 43\n   A       ifIndex.2  getScratchpad(PolicyElement, \"baz\", val)\
    \ not found\n   B       ifIndex.1  getScratchpad(PolicyElement, \"baz\", val)\
    \ not found\n   A       ifIndex.2  setScratchpad(PolicyElement, \"baz\", \"54\"\
    )\n   B       ifIndex.1  setScratchpad(PolicyElement, \"baz\", \"65\")\n   A \
    \      ifIndex.1  getScratchpad(PolicyElement, \"baz\", val) --> 43\n   A    \
    \   ifIndex.2  getScratchpad(PolicyElement, \"baz\", val) --> 54\n   B       ifIndex.1\
    \  getScratchpad(PolicyElement, \"baz\", val) --> 65\n   Policy  Element    Action\n\
    \   A       ifIndex.1  setScratchpad(PolicyElement, \"foo\", \"11\")\n   A   \
    \    ifIndex.1  setScratchpad(Global,        \"foo\", \"22\")\n   A       ifIndex.1\
    \  getScratchpad(PolicyElement, \"foo\", val) --> 11\n   A       ifIndex.1  getScratchpad(Global,\
    \        \"foo\", val) --> 22\n   Constants\n   The following constants are defined\
    \ for use with the scratchpad\n   functions.  Policy code will be executed in\
    \ an environment where the\n   following constants are declared.  (Note that these\
    \ constant\n   declarations will not be visible in the policyCondition or\n  \
    \ policyAction MIB objects.)\n   Although these declarations are expressed here\
    \ as C 'const's, the\n   'const' construct itself is not available to be used\
    \ inside of policy\n   code.\n   // Scratchpad Constants\n   // Values of scope\n\
    \   const integer Global           = 0;\n   const integer Policy           = 1;\n\
    \   const integer PolicyElement    = 2;\n   // Values of storageType\n   const\
    \ integer Volatile         = 0;\n   const integer NonVolatile      = 1;\n"
- title: 8.2.8.  setScratchpad()
  contents:
  - "8.2.8.  setScratchpad()\n      setScratchpad(integer scope, string varName [,\
    \ string value,\n                    integer storageType, integer freeOnException\
    \ ])\n         The setScratchpad function stores a value that can be retrieved\n\
    \         even after this policy execution code exits.\n         The value of\
    \ 'scope' controls which policy/element combinations\n         can retrieve this\
    \ 'varName'/'value' pair.  The options for\n         'scope' are Global, Policy,\
    \ and PolicyElement.\n         'varName' is a string used to identify the value.\
    \  Subsequent\n         retrievals of the same 'varName' in the proper scope will\n\
    \         return the value stored.  Note that the namespace for 'varName'\n  \
    \       is distinct for each scope.  'varName' is case sensitive.\n         'value'\
    \ is a string containing the value to be stored.\n         ToString(value) is\
    \ called on 'value' to convert it to a string\n         before storage.\n    \
    \     If the 'value' argument is missing, the 'varName' in scope\n         'scope'\
    \ will be deleted if it exists.\n         If the optional 'storageType' argument\
    \ is present and is equal\n         to the constant 'Volatile', then this variable\
    \ must be deleted\n         on a reboot.  If it is equal to 'NonVolatile', then\
    \ this\n         variable should be stored in non-volatile storage, where it\n\
    \         will be available after a reboot.  If the 'storageType'\n         argument\
    \ is not present, the variable will be volatile and will\n         be erased on\
    \ reboot.  'storageType' may not be present if the\n         'value' argument\
    \ is not present.  If the variable already\n         existed, its previous storageType\
    \ is updated according to the\n         current 'storageType' argument.\n    \
    \     If the optional 'freeOnException' argument is present and equal\n      \
    \   to 1, the agent will free this variable if, later in the same\n         script\
    \ invocation, this script dies with a run-time exception\n         or by a call\
    \ to fail().  (Note that this does not apply to\n         exceptions experienced\
    \ in subsequent invocations of the\n         script.)\n"
- title: 8.2.9.  getScratchpad()
  contents:
  - "8.2.9.  getScratchpad()\n      integer getScratchpad(integer scope, string varName,\n\
    \                            string &value)\n         The getScratchpad function\
    \ allows the retrieval of values that\n         were stored previously in this\
    \ execution context or in other\n         execution contexts.  The value of 'scope'\
    \ controls which\n         execution contexts can pass a value to this execution\
    \ context.\n         The options for 'scope' are Global, Policy, and PolicyElement.\n\
    \         'varName' is a string used to identify the value.  Subsequent\n    \
    \     retrievals of the same 'varName' in the proper scope will\n         return\
    \ the value stored.  Note that the namespace for varName\n         is distinct\
    \ for each scope.  As a result, getScratchpad cannot\n         force access to\
    \ a variable in an inaccessible scope; it can\n         only retrieve variables\
    \ by referencing the proper scope in\n         which they were set.  'varName'\
    \ is case sensitive.\n         On successful return, 'value' will be set to the\
    \ value that was\n         previously stored; otherwise, 'value' will not be modified.\n\
    \         This function returns 1 if a value was previously stored and 0\n   \
    \      otherwise.\n"
- title: 8.2.10.  signalError()
  contents:
  - "8.2.10.  signalError()\n   The signalError() function is used by the script to\
    \ indicate to a\n   management station that it is experiencing abnormal behavior.\n\
    \   signalError() turns on the conditionUserSignal(3) or\n   actionUserSignal(5)\
    \ bit in the associated pmTrackingPEInfo object\n   (subsequent calls to signalError()\
    \ have no additional effect).  This\n   bit is initially cleared at the beginning\
    \ of each execution.  If,\n   upon a subsequent execution, the script finishes\
    \ without calling\n   signalError, the bit will be cleared.\n      signalError()\n\
    \         The signalException function takes no arguments and returns no\n   \
    \      value.\n"
- title: 8.2.11.  defer()
  contents:
  - "8.2.11.  defer()\n   Precedence groups enforce the rule that for each element,\
    \ of the\n   ready policies that match the condition, only the one with the\n\
    \   highest precedence value will be active.  Unfortunately, once the\n   winning\
    \ policy has been selected and the action begins running,\n   situations can occur\
    \ in which the policy script determines that it\n   cannot complete its task.\
    \  In many such cases, it is desirable that\n   the next runner-up ready policy\
    \ be executed.  In the previous\n   example, it would be desirable that at least\
    \ bronze behavior be\n   configured if gold is appropriate but gold isn't possible.\n\
    \   When a policy defers, it exits, and the ready, condition-matching\n   policy\
    \ with the next-highest precedence is immediately run.  Because\n   this might\
    \ also defer, the execution environment must remember where\n   it is in the precedence\
    \ chain so that it can continue going down the\n   chain until an action completes\
    \ without deferring, or until no\n   policies are left in the precedence group.\
    \  Once a policy finishes\n   successfully, the next iteration will begin at the\
    \ top of the\n   precedence chain.\n   There are two ways to defer.  A script\
    \ can exit by calling fail() and\n   specify that it should defer immediately.\
    \  Alternately, a script can\n   instruct the execution environment to defer automatically\
    \ in the\n   event of a run-time exception.\n      defer(integer deferOnRTE)\n\
    \         The defer function changes the run-time exception behavior of a\n  \
    \       script.  By default, a script will not defer when it encounters\n    \
    \     an RTE.  If defer(1) is called, the exit behavior is changed so\n      \
    \   that the script will defer when it is terminated due to an RTE.\n        \
    \ If defer(0) is called, the script is reset to its default\n         behavior\
    \ and will not defer.\n         Note that calling defer doesn't cause the script\
    \ to exit.\n         Defer only changes the default behavior if an RTE occurs\
    \ later\n         in this invocation.\n"
- title: 8.2.12.  fail()
  contents:
  - "8.2.12.  fail()\n      fail(integer defer, integer free [, string message] )\n\
    \         The fail function causes the script to optionally perform\n        \
    \ certain functions and then exit.\n         If 'defer' is 1, this script will\
    \ defer to the next lower\n         precedence ready policy in the same precedence\
    \ group whose\n         condition matches.  If 'defer' isn't 1, it will not defer.\n\
    \         Note that if a condition defers, it is functionally equivalent\n   \
    \      to the condition returning false.\n         If 'free' is 1, certain registered\
    \ resources will be freed.\n         If, earlier in this script invocation, any\
    \ rows were created by\n         createRow with the 'freeOnException' option,\
    \ the execution\n         environment will set the RowStatus of each row to 'destroy'\
    \ to\n         delete the row.  Further, if earlier in this script invocation\n\
    \         any scratchpad variables were created or modified with the\n       \
    \  'freeOnException' option, they will be deleted.\n         If the optional 'message'\
    \ argument is present, it will be\n         logged to the debugging table if pmPolicyDebugging\
    \ is turned on\n         for this policy.\n         This function does not return.\
    \  Instead, the script will\n         terminate.\n"
- title: 8.2.13.  getParameters()
  contents:
  - "8.2.13.  getParameters()\n   From time to time, policy scripts may be parameterized\
    \ so that they\n   are supplied with one or more parameters (e.g., site-specific\n\
    \   constants).  These parameters may be installed in the\n   pmPolicyParameters\
    \ object and are accessible to the script via the\n   getParameters() function.\
    \  If it is necessary for multiple parameters\n   to be passed to the script,\
    \ the script can choose whatever\n   encoding/delimiting mechanism is most appropriate\
    \ so that the\n   multiple parameters can be stored in the associated instance\
    \ of\n   pmPolicyParameters.\n      string getParameters()\n         The getParameters\
    \ function takes no arguments.  It returns a\n         string containing the value\
    \ of the pmPolicyParameters object\n         for the running policy.\n   For example,\
    \ if a policy is to apply to \"slow speed interfaces\" and\n   the cutoff point\
    \ for slow speed should be parameterized, the policy\n   filter should be:\n \
    \     getVar(\"ifSpeed.$*\") == getParameters()\n   In this example, one can store\
    \ the string \"128000\" in the policy's\n   pmPolicyParameters object to cause\
    \ this policy to act on all 128 Kbps\n   interfaces.\n"
- title: 8.3.  Utility Library Functions
  contents:
  - "8.3.  Utility Library Functions\n   Utility Library Functions are provided to\
    \ enable more efficient\n   policy scripts.\n"
- title: 8.3.1.  regexp()
  contents:
  - "8.3.1.  regexp()\n      integer regexp(string pattern, string str,\n        \
    \             integer case [, string &match])\n         regexp searches 'str'\
    \ for matches to the regular expression\n         given in `pattern`.  regexp\
    \ uses the POSIX extended regular\n         expressions defined in POSIX 1003.2.\n\
    \         If `case` is 0, the search will be case insensitive; otherwise,\n  \
    \       it will be case sensitive.\n         If a match is found, 1 is returned,\
    \ otherwise 0 is returned.\n         If the optional argument 'match' is provided\
    \ and a match is\n         found, 'match' will be replaced with the text of the\
    \ first\n         substring of 'str' that matches 'pattern'.  If no match is\n\
    \         found, it will be unchanged.\n"
- title: 8.3.2.  regexpReplace()
  contents:
  - "8.3.2.  regexpReplace()\n      string regexpReplace(string pattern, string replacement,\n\
    \                            string str, integer case)\n         regexpReplace\
    \ searches 'str' for matches to the regular\n         expression given in 'pattern',\
    \ replacing each occurrence of\n         matched text with 'replacement'.  regexpReplace\
    \ uses the POSIX\n         extended regular expressions defined in POSIX 1003.2.\n\
    \         If `case` is 0, the search will be case insensitive; otherwise,\n  \
    \       it will be case sensitive.\n         The modified string is returned (it\
    \ would be the same as the\n         original string if no matches were found).\n"
- title: 8.3.3.  oidlen()
  contents:
  - "8.3.3.  oidlen()\n      integer oidlen(string oid)\n         oidlen returns the\
    \ number of subidentifiers in 'oid'.  'oid' is\n         a string containing an\
    \ ASCII dotted-decimal representation of\n         an object identifier (e.g.,\
    \ \"1.3.6.1.2.1.1.1.0\").\n"
- title: 8.3.4.  oidncmp()
  contents:
  - "8.3.4.  oidncmp()\n      integer oidncmp(string oid1, string oid2, integer n)\n\
    \         Arguments 'oid1' and 'oid2' are strings containing ASCII\n         dotted-decimal\
    \ representations of object identifiers (e.g.,\n         \"1.3.6.1.2.1.1.1.0\"\
    ).\n         oidcmp compares not more than n subidentifiers of 'oid1' and\n  \
    \       'oid2' and returns -1 if 'oid1' is less than 'oid2', 0 if they\n     \
    \    are equal, and 1 if 'oid1' is greater than 'oid2'.\n"
- title: 8.3.5.  inSubtree()
  contents:
  - "8.3.5.  inSubtree()\n      integer inSubtree(string oid, string prefix)\n   \
    \      Arguments 'oid' and 'prefix' are strings containing ASCII\n         dotted-decimal\
    \ representations of object identifiers (e.g.,\n         \"1.3.6.1.2.1.1.1.0\"\
    ).\n         inSubtree returns 1 if every subidentifier in 'prefix' equals\n \
    \        the corresponding subidentifier in 'oid', otherwise it returns\n    \
    \     0.  The is equivalent to oidncmp(oid1, prefix, oidlen(prefix))\n       \
    \  is provided because this is an idiom and because it avoids\n         evaluating\
    \ 'prefix' twice if it is an expression.\n"
- title: 8.3.6.  subid()
  contents:
  - "8.3.6.  subid()\n      integer subid(string oid, integer n)\n         subid returns\
    \ the value of the nth (starting at zero)\n         subidentifier of 'oid'.  'oid'\
    \ is a string containing an ASCII\n         dotted-decimal representation of an\
    \ object identifier (e.g.,\n         \"1.3.6.1.2.1.1.1.0\").\n         If n specifies\
    \ a subidentifier beyond the length of 'oid', a\n         value of -1 is returned.\n"
- title: 8.3.7.  subidWrite()
  contents:
  - "8.3.7.  subidWrite()\n      integer subidWrite(string oid, integer n, integer\
    \ subid)\n         subidWrite sets the value of the nth (starting at zero)\n \
    \        subidentifier of 'oid' to 'subid'.  'oid' is a string\n         containing\
    \ an ASCII dotted-decimal representation of an object\n         identifier (e.g.,\
    \ \"1.3.6.1.2.1.1.1.0\").\n         If n specifies a subidentifier beyond the\
    \ length of 'oid', a\n         value of -1 is returned.  Note that appending subidentifiers\n\
    \         can be accomplished with the string concatenation '+' operator.\n  \
    \       If no error occurs, zero is returned.\n"
- title: 8.3.8.  oidSplice()
  contents:
  - "8.3.8.  oidSplice()\n      string oidSplice(string oid1, integer offset, integer\
    \ len, string\n         oid2)\n         oidSplice returns an OID formed by replacing\
    \ 'len'\n         subidentifiers in 'oid1' with all of the subidentifiers from\n\
    \         'oid2', starting at 'offset' in 'oid1' (the first subidentifier\n  \
    \       is at offset 0).  The OID length will be extended, if\n         necessary,\
    \ if 'offset' + 'len' extends beyond the end of\n         'oid1'.  If 'offset'\
    \ is larger than the length of oid1, then an\n         RTE will occur.\n     \
    \    The resulting OID is returned.\n         For example:\n             oidSplice(\"\
    1.3.6.1.2.1\", 5, 1, \"7\")     => \"1.3.6.1.2.7\"\n             oidSplice(\"\
    1.3.6.1.2.1\", 4, 2, \"7.7\")   => \"1.3.6.1.7.7\"\n             oidSplice(\"\
    1.3.6.1.2.1\", 4, 3, \"7.7.7\") => \"1.3.6.1.7.7.7\"\n"
- title: 8.3.9.  parseIndex()
  contents:
  - "8.3.9.  parseIndex()\n   ParseIndex is provided to make it easy to pull index\
    \ values from OIDs\n   into variables.\n      var parseIndex(string oid, integer\
    \ &index, integer type,\n                     integer len)\n         parseIndex\
    \ pulls values from the instance identification\n         portion of 'oid', encoded\
    \ as per Section 7.7, \"Mapping of the\n         INDEX Clause\", of the SMIv2\
    \ [2].\n         'oid' is the OID to be parsed.\n         'index' describes which\
    \ subid to begin parsing at.  'index'\n         will be modified to indicate the\
    \ subid after the last one\n         parsed (even if this points past the last\
    \ subid).  The first\n         subid is index 0.  If any error occurs, 'index'\
    \ will be set to\n         -1 on return.  If the input index is less than 0 or\
    \ refers past\n         the end of the OID, 'index' will be set to -1 on return\
    \ and the\n         function will return 0.\n         If 'type' is Integer, 'len'\
    \ will not be consulted.  The return\n         value is the integer value of the\
    \ next subid.\n         If 'type' is String and 'len' is greater than zero, 'len'\n\
    \         subids will be parsed.  For each subid parsed, the chr() value\n   \
    \      of the subid will be appended to the returned string.  If any\n       \
    \  subid is greater than 255, 'index' will be set to -1 on return,\n         and\
    \ an empty string will be returned.  If there are fewer than\n         'len' subids\
    \ left in 'oid', 'index' will be set to -1 on\n         return, but a string will\
    \ be returned containing a character\n         for each subid that was left.\n\
    \         If 'type' is String and 'len' is zero, the next subid will be\n    \
    \     parsed to find N, the length of the string.  Then, that many\n         subids\
    \ will be parsed.  For each subid parsed, the chr() value\n         of the subid\
    \ will be appended to the returned string.  If any\n         subid is greater\
    \ than 255, 'index' will be set to -1 on return,\n         and an empty string\
    \ will be returned.  If there are fewer than\n         N subids left in 'oid',\
    \ 'index' will be set to -1 on return,\n         but a string will be returned\
    \ containing a character for each\n         subid that was left.\n         If\
    \ 'type' is String and 'len' is -1, subids will be parsed\n         until the\
    \ end of 'oid'.  For each subid parsed, the chr() value\n         of the subid\
    \ will be appended to the returned string.  If any\n         subid is greater\
    \ than 255, 'index' will be set to -1 on return,\n         and an empty string\
    \ will be returned.\n         If 'type' is Oid and 'len' is greater than zero,\
    \ 'len' subids\n         will be parsed.  For each subid parsed, the decimal-encoded\n\
    \         value of the subid will be appended to the returned string,\n      \
    \   with a '.' character appended between each output subid, but\n         not\
    \ after the last subid.  If there are fewer than 'len' subids\n         left in\
    \ 'oid', 'index' will be set to -1 on return, but a\n         string will be returned\
    \ containing an encoding for each subid\n         that was left.\n         If\
    \ 'type' is Oid and 'len' is zero, the next subid will be\n         parsed to\
    \ find N, the number of subids to parse.  For each\n         subid parsed, the\
    \ decimal-encoded value of the subid will be\n         appended to the returned\
    \ string, with a '.' character appended\n         between each output subid but\
    \ not after the last subid.  If\n         there are fewer than N subids left in\
    \ 'oid', 'index' will be\n         set to -1 on return, but a string will be returned\
    \ containing\n         an encoding for each subid that was left.\n         If\
    \ 'type' is Oid and 'len' is -1, subids will be parsed until\n         the end\
    \ of 'oid'.  For each subid parsed, the decimal-encoded\n         value of the\
    \ subid will be appended to the returned string,\n         with a '.' character\
    \ appended between each output subid, but\n         not after the last subid.\n\
    \   For example, to decode the index component of an instance of the\n   ipForward\
    \ table:\n      oid = \"ipForwardIfIndex.0.0.0.0.13.0.192.168.1.1\";\n      index\
    \ = 11;\n      dest   =  parseIndex(oid, index, String, 4);\n      proto  =  parseIndex(oid,\
    \ index, Integer, 0);\n      policy =  parseIndex(oid, index, Integer, 0);\n \
    \     nextHop = parseIndex(oid, index, String, 4);\n      // proto and policy\
    \ now contain integer values\n      // dest and nextHop now contain 4 byte IP\
    \ addresses.  Use\n      // stringToDotted to get them to dotted decimal notation:\n\
    \      // e.g.: stringToDotted(nextHop) => \"192.168.1.1\"\n"
- title: 8.3.10.  stringToDotted()
  contents:
  - "8.3.10.  stringToDotted()\n   stringToDotted() is provided to encode strings\
    \ suitable for the index\n   portion of an OID or to convert the binary encoding\
    \ of an IP address\n   to a dotted-decimal encoding.\n      string stringToDotted(string\
    \ value)\n         If 'value' is the zero-length string, the zero-length string\
    \ is\n         returned.\n         The decimal encoding of the first byte of 'value'\
    \ is appended\n         to the output string.  Then, for each additional byte\
    \ in\n         'value', a '.' is appended to the output string, followed by\n\
    \         the decimal encoding of the additional byte.\n"
- title: 8.3.11.  integer()
  contents:
  - "8.3.11.  integer()\n      integer integer(var input)\n         integer converts\
    \ 'input' into an integer by using the rules\n         specified for ToInteger(),\
    \ returning the integer-typed results.\n"
- title: 8.3.12.  string()
  contents:
  - "8.3.12.  string()\n      string string(var input)\n         string converts 'input'\
    \ into a string by using the rules\n         specified for ToString(), returning\
    \ the string-typed results.\n"
- title: 8.3.13.  type()
  contents:
  - "8.3.13.  type()\n      string type(var variable)\n         type returns the type\
    \ of its argument as either the string\n         'String' or the string 'Integer'.\n"
- title: 8.3.14.  chr()
  contents:
  - "8.3.14.  chr()\n      string chr(integer char)\n         Returns a one-character\
    \ string containing the character\n         specified by the ASCII code contained\
    \ in 'char'.\n"
- title: 8.3.15.  ord()
  contents:
  - "8.3.15.  ord()\n      integer ord(string str)\n         Returns the ASCII value\
    \ of the first character of 'str'.  This\n         function complements chr().\n"
- title: 8.3.16.  substr()
  contents:
  - "8.3.16.  substr()\n      string substr(string &str, integer offset\n        \
    \            [, integer len, string replacement])\n         Extracts a substring\
    \ out of 'str' and returns it.  The first\n         octet is at offset 0.  If\
    \ the offset is negative, the returned\n         string starts that far from the\
    \ end of 'str'.  If 'len' is\n         positive, the returned string contains\
    \ up to 'len' octets, up\n         to the end of the string.  If 'len' is omitted,\
    \ the returned\n         string includes everything to the end of 'str'.  If 'len'\
    \ is\n         negative, abs(len) octets are left off the end of the string.\n\
    \         If a substring is specified that is partly outside the string,\n   \
    \      the part within the string is returned.  If the substring is\n        \
    \ totally outside the string, a zero-length string is produced.\n         If the\
    \ optional 'replacement' argument is included, 'str' is\n         modified.  'offset'\
    \ and 'len' act as above to select a range of\n         octets in 'str'.  These\
    \ octets are replaced with octets from\n         'replacement'.  If the replacement\
    \ string is shorter or longer\n         than the number of octets selected, 'str'\
    \ will shrink or grow,\n         respectively.  If 'replacement' is included,\
    \ the 'len' argument\n         must also be included.\n         Note that to replace\
    \ everything from offset to the end of the\n         string, substr() should be\
    \ called as follows:\n            substr(str, offset, strlen(str) - offset, replacement)\n"
- title: 8.4.  General Functions
  contents:
  - "8.4.  General Functions\n   The following POSIX standard library functions are\
    \ provided:\n       strncmp()\n       strncasecmp()\n       strlen()\n       random()\n\
    \       sprintf()\n       sscanf()\n"
- title: 9.  International String Library
  contents:
  - "9.  International String Library\n   This library is optional for systems that\
    \ wish to have support for\n   collating (sorting) and verifying equality of international\
    \ strings\n   in a manner that will be least surprising to humans.  International\n\
    \   strings are encoded in the UTF-8 transformation format described in\n   [14].\
    \  This library is registered with the name\n   \"pmInternationalStringLibrary\"\
    .\n   When verifying equality of international strings in the Unicode\n   character\
    \ set, it is recommended to normalize the strings with the\n   stringprep() function\
    \ before checking for equality.\n   When attempting to sort international strings\
    \ in the Unicode\n   character set, normalization should also be performed, but\
    \ note that\n   the result is highly context dependent and hard to implement\n\
    \   correctly.  Just ordering by Unicode Codepoint Value is in many cases\n  \
    \ not what the end user expects.  See Unicode technical note 9 for more\n   information\
    \ about sorting.\n"
- title: 9.1.  stringprep()
  contents:
  - "9.1.  stringprep()\n      integer stringprep(string utf8Input, string &utf8Output)\n\
    \         Performs the Stringprep [13] transformation for appropriate\n      \
    \   comparison of internationalized strings.  The transformation is\n        \
    \ performed on 'utf8Input'; if the transformation finishes\n         without error,\
    \ the resulting string is written to utf8Output.\n         The stringprep profile\
    \ used is specified below in Section 9.\n         If it is successful, the function\
    \ returns 1.\n         If the stringprep transformation encounters an error, 0\
    \ is\n         returned, and the utf8Output parameter remains unchanged.\n   \
    \      For example, to compare UTF8 strings 'one' and 'two':\n         if (stringprep(one,\
    \ a) && stringprep(two, b)){\n             if (a == b){\n                // strings\
    \ are identical\n             } else {\n                // strings are different\n\
    \             }\n         } else {\n             // strings couldn't be transformed\
    \ for comparison\n         }\n         See Stringprep [13] for more information.\n"
- title: 9.1.1.  Stringprep Profile
  contents:
  - "9.1.1.  Stringprep Profile\n   The Stringprep specification [13] describes a\
    \ framework for preparing\n   Unicode text strings in order to increase the likelihood\
    \ that string\n   input and string comparison work in ways that make sense for\
    \ typical\n   users throughout the world.  Specifications that specify stringprep\n\
    \   (as this one does) are required to fully specify stringprep's\n   processing\
    \ options by documenting a stringprep profile.\n   This profile defines the following,\
    \ as required by Stringprep:\n   - The intended applicability of the profile:\
    \ internationalized\n     network management information.\n   - The character\
    \ repertoire that is the input and output to\n     stringprep: Unicode 3.2, as\
    \ defined in Stringprep [13], Appendix\n     A.1.\n   - The mapping tables used:\
    \ Table B.1 from Stringprep [13].\n   - Any additional mapping tables specific\
    \ to the profile: None.\n   - The Unicode normalization used: Form KC, as described\
    \ in Stringprep\n     [13].\n   - The characters that are prohibited as output:\
    \ As specified in the\n     following tables from Stringprep [13]:\n       Table\
    \ C.2\n       Table C.3\n       Table C.4\n       Table C.5\n       Table C.6\n\
    \       Table C.7\n       Table C.8\n       Table C.9\n   - Bidirectional character\
    \ handling: not performed.\n   - Any additional characters that are prohibited\
    \ as output:  None.\n"
- title: 9.2.  utf8Strlen()
  contents:
  - "9.2.  utf8Strlen()\n      integer utf8Strlen(string str)\n         Returns the\
    \ number of UTF-8 characters in 'str', which may be\n         less than the number\
    \ of octets in 'str' if one or more\n         characters are multi-byte characters.\n"
- title: 9.3.  utf8Chr()
  contents:
  - "9.3.  utf8Chr()\n      string utf8Chr(integer utf8)\n         Returns a one-character\
    \ string containing the character\n         specified by the UTF-8 code contained\
    \ in 'utf8'.  Although it\n         contains only 1 UTF-8 character, the resulting\
    \ string may be\n         more than 1 octet in length.\n"
- title: 9.4.  utf8Ord()
  contents:
  - "9.4.  utf8Ord()\n      integer utf8Ord(string str)\n         Returns the UTF-8\
    \ code-point value of the first character of\n         'str'.  Note that the first\
    \ UTF-8 character in 'str' may be\n         more than 1 octet in length.  This\
    \ function complements chr().\n"
- title: 9.5.  utf8Substr()
  contents:
  - "9.5.  utf8Substr()\n      string utf8Substr(string &str, integer offset\n   \
    \                 [, integer len, string replacement])\n         Extracts a substring\
    \ out of 'str' and returns it, keeping track\n         of UTF-8 character boundaries\
    \ and using them, instead of\n         octets, as the basis for offset and length\
    \ calculations.  The\n         first character is at offset 0.  If offset is negative,\
    \ the\n         returned string starts that far from the end of 'str'.  If\n \
    \        'len' is positive, the returned string contains up to 'len'\n       \
    \  characters, up to the end of the string.  If 'len' is omitted,\n         the\
    \ returned string includes everything to the end of 'str'.\n         If 'len'\
    \ is negative, abs(len) characters are left off the end\n         of the string.\n\
    \         If you specify a substring that is partly outside the string,\n    \
    \     the part within the string is returned.  If the substring is\n         totally\
    \ outside the string, a zero-length string is produced.\n         If the optional\
    \ 'replacement' argument is included, 'str' is\n         modified.  'offset' and\
    \ 'len' act as above to select a range of\n         characters in 'str'.  These\
    \ characters are replaced with\n         characters from 'replacement'.  If the\
    \ replacement string is\n         shorter or longer than the number of characters\
    \ selected, 'str'\n         will shrink or grow, respectively.  If 'replacement'\
    \ is\n         included, the 'len' argument must also be included.\n         Note\
    \ that to replace everything from offset to the end of the\n         string, substr()\
    \ should be called as follows:\n            substr(str, offset, strlen(str) -\
    \ offset, replacement)\n"
- title: 10.  Schedule Table
  contents:
  - "10.  Schedule Table\n   This table is an adapted form of the policyTimePeriodCondition\
    \ class\n   defined in the Policy Core Information Model, RFC 3060 [18].  Some\
    \ of\n   the objects describing a schedule are expressed in formats defined in\n\
    \   the iCalendar specification [15].\n   The policy schedule table allows control\
    \ over when a valid policy\n   will be ready, based on the date and time.\n  \
    \ A policy's pmPolicySchedule variable refers to a group of one or more\n   schedules\
    \ in the schedule table.  At any given time, if any of these\n   schedules are\
    \ active, the policy will be ready (assuming that it is\n   enabled and thus valid),\
    \ and its conditions and actions will be\n   executed, as appropriate.  At times\
    \ when none of these schedules are\n   active, the policy will not be ready and\
    \ will have no effect.  A\n   policy will always be ready if its pmPolicySchedule\
    \ variable is 0.\n   If a policy has a non-zero pmPolicySchedule that doesn't\
    \ refer to a\n   group that includes an active schedule, then the policy will\
    \ not be\n   ready, even if this is due to a misconfiguration of the\n   pmPolicySchedule\
    \ object or the pmSchedTable.\n   A policy that is controlled by a schedule group\
    \ immediately executes\n   its policy condition (and conditionally the policyAction)\
    \ when the\n   schedule group becomes active, periodically re-executing these\n\
    \   scripts as appropriate until the schedule group becomes inactive\n   (i.e.,\
    \ all schedules are inactive).\n   An individual schedule item is active at those\
    \ times that match all\n   the variables that define the schedule:  pmSchedTimePeriod,\n\
    \   pmSchedMonth, pmSchedDay, pmSchedWeekDay, and pmSchedTimeOfDay.  It\n   is\
    \ possible to specify multiple values for each schedule item.  This\n   provides\
    \ a mechanism for defining complex schedules.  For example, a\n   schedule that\
    \ is active the entire workday each weekday could be\n   defined.\n   Months,\
    \ days, and weekdays are specified by using the objects\n   pmSchedMonth, pmSchedDay,\
    \ and pmSchedWeekDay of type BITS.  Setting\n   multiple bits in these objects\
    \ causes an OR operation.  For example,\n   setting the bits monday(1) and friday(5)\
    \ in pmSchedWeekDay restricts\n   the schedule to Mondays and Fridays.\n   The\
    \ matched times for pmSchedTimePeriod, pmSchedMonth, pmSchedDay\n   pmSchedWeekDay,\
    \ and pmSchedTimeOfDay are ANDed together to determine\n   the time periods when\
    \ the schedule will be active; in other words,\n   the schedule is only active\
    \ for those times when ALL of these\n   schedule attributes match.  For example,\
    \ a schedule with an overall\n   validity range of January 1, 2000, through December\
    \ 31, 2000; a month\n   mask that selects March and April; a day-of-the-week mask\
    \ that\n   selects Fridays; and a time-of-day range of 0800 through 1600 would\n\
    \   represent the following time periods:\n      Friday, March  5, 2000, from\
    \ 0800 through 1600\n      Friday, March 12, 2000, from 0800 through 1600\n  \
    \    Friday, March 19, 2000, from 0800 through 1600\n      Friday, March 26, 2000,\
    \ from 0800 through 1600\n      Friday, April  2, 2000, from 0800 through 1600\n\
    \      Friday, April  9, 2000, from 0800 through 1600\n      Friday, April 16,\
    \ 2000, from 0800 through 1600\n      Friday, April 23, 2000, from 0800 through\
    \ 1600\n      Friday, April 30, 2000, from 0800 through 1600\n   Wildcarding of\
    \ schedule attributes of type BITS is achieved by\n   setting all bits to one.\n\
    \   It is possible to define schedules that will never cause a policy to\n   be\
    \ activated.  For example, one can define a schedule that should be\n   active\
    \ on February 31st.\n"
- title: 11.  Definitions
  contents:
  - '11.  Definitions

    '
- title: POLICY-BASED-MANAGEMENT-MIB DEFINITIONS ::= BEGIN
  contents:
  - 'POLICY-BASED-MANAGEMENT-MIB DEFINITIONS ::= BEGIN

    '
- title: IMPORTS
  contents:
  - "IMPORTS\n    MODULE-IDENTITY, OBJECT-TYPE, NOTIFICATION-TYPE,\n    Counter32,\
    \ Gauge32, Unsigned32,\n    mib-2                                       FROM SNMPv2-SMI\n\
    \    RowStatus, RowPointer, TEXTUAL-CONVENTION,\n    DateAndTime, StorageType\
    \                    FROM SNMPv2-TC\n    MODULE-COMPLIANCE, OBJECT-GROUP,\n  \
    \  NOTIFICATION-GROUP                          FROM SNMPv2-CONF\n    SnmpAdminString\
    \                             FROM SNMP-FRAMEWORK-MIB;\n"
- title: --  Policy-Based Management MIB
  contents:
  - '--  Policy-Based Management MIB

    '
- title: pmMib MODULE-IDENTITY
  contents:
  - "pmMib MODULE-IDENTITY\n    LAST-UPDATED \"200502070000Z\"  -- February 7, 2005\n\
    \    ORGANIZATION \"IETF SNMP Configuration Working Group\"\n    CONTACT-INFO\n\
    \        \"\n        Steve Waldbusser\n        Phone: +1-650-948-6500\n      \
    \  Fax:   +1-650-745-0671\n        Email: waldbusser@nextbeacon.com\n        Jon\
    \ Saperia (WG Co-chair)\n        JDS Consulting, Inc.\n        84 Kettell Plain\
    \ Road.\n        Stow MA 01775\n        USA\n        Phone: +1-978-461-0249\n\
    \        Fax:   +1-617-249-0874\n        Email: saperia@jdscons.com\n        Thippanna\
    \ Hongal\n        Riverstone Networks, Inc.\n        5200 Great America Parkway\n\
    \        Santa Clara, CA, 95054\n        USA\n        Phone: +1-408-878-6562\n\
    \        Fax:   +1-408-878-6501\n        Email: hongal@riverstonenet.com\n   \
    \     David Partain (WG Co-chair)\n        Postal: Ericsson AB\n             \
    \   P.O. Box 1248\n                SE-581 12 Linkoping\n                Sweden\n\
    \        Tel: +46 13 28 41 44\n        E-mail: David.Partain@ericsson.com\n  \
    \      Any questions or comments about this document can also be\n        directed\
    \ to the working group at snmpconf@snmp.com.\"\n    DESCRIPTION\n        \"The\
    \ MIB module for policy-based configuration of SNMP\n        infrastructures.\n\
    \        Copyright (C) The Internet Society (2005).  This version of\n       \
    \ this MIB module is part of RFC 4011; see the RFC itself for\n        full legal\
    \ notices.\"\n    REVISION \"200502070000Z\"    -- February 7, 2005\n    DESCRIPTION\n\
    \        \"The original version of this MIB, published as RFC4011.\"\n    ::=\
    \ { mib-2 124 }\n"
- title: PmUTF8String ::= TEXTUAL-CONVENTION
  contents:
  - "PmUTF8String ::= TEXTUAL-CONVENTION\n    STATUS       current\n    DESCRIPTION\n\
    \        \"An octet string containing information typically in\n        human-readable\
    \ form.\n        To facilitate internationalization, this\n        information\
    \ is represented by using the ISO/IEC\n        IS 10646-1 character set, encoded\
    \ as an octet\n        string using the UTF-8 transformation format\n        described\
    \ in RFC 3629.\n        As additional code points are added by\n        amendments\
    \ to the 10646 standard from time\n        to time, implementations must be prepared\
    \ to\n        encounter any code point from 0x00000000 to\n        0x10FFFF. \
    \ Byte sequences that do not\n        correspond to the valid UTF-8 encoding of\
    \ a\n        code point or that are outside this range are\n        prohibited.\n\
    \        The use of control codes should be avoided.\n        When it is necessary\
    \ to represent a newline,\n        the control code sequence CR LF should be used.\n\
    \        For code points not directly supported by user\n        interface hardware\
    \ or software, an alternative\n        means of entry and display, such as hexadecimal,\n\
    \        may be provided.\n        For information encoded in 7-bit US-ASCII,\n\
    \        the UTF-8 encoding is identical to the\n        US-ASCII encoding.\n\
    \        UTF-8 may require multiple bytes to represent a\n        single character/code\
    \ point; thus, the length\n        of this object in octets may be different from\n\
    \        the number of characters encoded.  Similarly,\n        size constraints\
    \ refer to the number of encoded\n        octets, not the number of characters\
    \ represented\n        by an encoding.\n        Note that when this TC is used\
    \ for an object\n        used or envisioned to be used as an index, then\n   \
    \     a SIZE restriction MUST be specified so that the\n        number of sub-identifiers\
    \ for any object instance\n        does not exceed the limit of 128, as defined\
    \ by\n        RFC 3416.\n        Note that the size of PmUTF8String object is\n\
    \        measured in octets, not characters.\"\n       SYNTAX       OCTET STRING\
    \ (SIZE (0..65535))\n"
- title: -- The policy table
  contents:
  - '-- The policy table

    '
- title: pmPolicyTable OBJECT-TYPE
  contents:
  - "pmPolicyTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmPolicyEntry\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"The policy\
    \ table.  A policy is a pairing of a\n        policyCondition and a policyAction\
    \ that is used to apply the\n        action to a selected set of elements.\"\n\
    \    ::= { pmMib 1 }\n"
- title: pmPolicyEntry OBJECT-TYPE
  contents:
  - "pmPolicyEntry OBJECT-TYPE\n    SYNTAX      PmPolicyEntry\n    MAX-ACCESS  not-accessible\n\
    \    STATUS      current\n    DESCRIPTION\n        \"An entry in the policy table\
    \ representing one policy.\"\n    INDEX { pmPolicyAdminGroup, pmPolicyIndex }\n\
    \    ::= { pmPolicyTable 1 }\n"
- title: PmPolicyEntry ::= SEQUENCE {
  contents:
  - "PmPolicyEntry ::= SEQUENCE {\n    pmPolicyAdminGroup            PmUTF8String,\n\
    \    pmPolicyIndex                 Unsigned32,\n    pmPolicyPrecedenceGroup  \
    \     PmUTF8String,\n    pmPolicyPrecedence            Unsigned32,\n    pmPolicySchedule\
    \              Unsigned32,\n    pmPolicyElementTypeFilter     PmUTF8String,\n\
    \    pmPolicyConditionScriptIndex  Unsigned32,\n    pmPolicyActionScriptIndex\
    \     Unsigned32,\n    pmPolicyParameters            OCTET STRING,\n    pmPolicyConditionMaxLatency\
    \   Unsigned32,\n    pmPolicyActionMaxLatency      Unsigned32,\n    pmPolicyMaxIterations\
    \         Unsigned32,\n    pmPolicyDescription           PmUTF8String,\n    pmPolicyMatches\
    \               Gauge32,\n    pmPolicyAbnormalTerminations  Gauge32,\n    pmPolicyExecutionErrors\
    \       Counter32,\n    pmPolicyDebugging             INTEGER,\n    pmPolicyAdminStatus\
    \           INTEGER,\n    pmPolicyStorageType           StorageType,\n    pmPolicyRowStatus\
    \             RowStatus\n"
- title: '}'
  contents:
  - '}

    '
- title: pmPolicyAdminGroup OBJECT-TYPE
  contents:
  - "pmPolicyAdminGroup OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE(0..32))\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"An administratively assigned string that can be used to group\n     \
    \   policies for convenience, for readability, or to simplify\n        configuration\
    \ of access control.\n        The value of this string does not affect policy\
    \ processing in\n        any way.  If grouping is not desired or necessary, this\
    \ object\n        may be set to a zero-length string.\"\n    ::= { pmPolicyEntry\
    \ 1 }\n"
- title: pmPolicyIndex OBJECT-TYPE
  contents:
  - "pmPolicyIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"A unique\
    \ index for this policy entry, unique among all\n         policies regardless\
    \ of administrative group.\"\n    ::= { pmPolicyEntry 2 }\n"
- title: pmPolicyPrecedenceGroup OBJECT-TYPE
  contents:
  - "pmPolicyPrecedenceGroup OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (0..32))\n\
    \    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n     \
    \   \"An administratively assigned string that is used to group\n        policies.\
    \  For each element, only one policy in the same\n        precedence group may\
    \ be active on that element.  If multiple\n        policies would be active on\
    \ an element (because their\n        conditions return non-zero), the execution\
    \ environment will\n        only allow the policy with the highest value of\n\
    \        pmPolicyPrecedence to be active.\n        All values of this object must\
    \ have been successfully\n        transformed by Stringprep RFC 3454.  Management\
    \ stations\n        must perform this translation and must only set this object\
    \ to\n        string values that have been transformed.\"\n    ::= { pmPolicyEntry\
    \ 3 }\n"
- title: pmPolicyPrecedence OBJECT-TYPE
  contents:
  - "pmPolicyPrecedence OBJECT-TYPE\n    SYNTAX      Unsigned32 (0..65535)\n    MAX-ACCESS\
    \  read-create\n    STATUS      current\n    DESCRIPTION\n        \"If, while\
    \ checking to see which policy conditions match an\n        element, 2 or more\
    \ ready policies in the same precedence group\n        match the same element,\
    \ the pmPolicyPrecedence object provides\n        the rule to arbitrate which\
    \ single policy will be active on\n        'this element'.  Of policies in the\
    \ same precedence group, only\n        the ready and matching policy with the\
    \ highest precedence\n        value (e.g., 2 is higher than 1) will have its policy\
    \ action\n        periodically executed on 'this element'.\n        When a policy\
    \ is active on an element but the condition ceases\n        to match the element,\
    \ its action (if currently running) will\n        be allowed to finish and then\
    \ the condition-matching ready\n        policy with the next-highest precedence\
    \ will immediately\n        become active (and have its action run immediately).\
    \  If the\n        condition of a higher-precedence ready policy suddenly begins\n\
    \        matching an element, the previously-active policy's action (if\n    \
    \    currently running) will be allowed to finish and then the\n        higher\
    \ precedence policy will immediately become active.  Its\n        action will\
    \ run immediately, and any lower-precedence matching\n        policy will not\
    \ be active anymore.\n        In the case where multiple ready policies share\
    \ the highest\n        value, it is an implementation-dependent matter as to which\n\
    \        single policy action will be chosen.\n        Note that if it is necessary\
    \ to take certain actions after a\n        policy is no longer active on an element,\
    \ these actions should\n        be included in a lower-precedence policy that\
    \ is in the same\n        precedence group.\"\n    ::= { pmPolicyEntry 4 }\n"
- title: pmPolicySchedule OBJECT-TYPE
  contents:
  - "pmPolicySchedule OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n  \
    \  MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n       \
    \  \"This policy will be ready if any of the associated schedule\n         entries\
    \ are active.\n         If the value of this object is 0, this policy is always\n\
    \         ready.\n         If the value of this object is non-zero but doesn't\n\
    \         refer to a schedule group that includes an active schedule,\n      \
    \   then the policy will not be ready, even if this is due to a\n         misconfiguration\
    \ of this object or the pmSchedTable.\"\n    ::= { pmPolicyEntry 5 }\n"
- title: pmPolicyElementTypeFilter OBJECT-TYPE
  contents:
  - "pmPolicyElementTypeFilter OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (0..128))\n\
    \    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n     \
    \   \"This object specifies the element types for which this policy\n        can\
    \ be executed.\n        The format of this object will be a sequence of\n    \
    \    pmElementTypeRegOIDPrefix values, encoded in the following\n        BNF form:\n\
    \        elementTypeFilter:   oid [ ';' oid ]*\n                      oid:   subid\
    \ [ '.' subid ]*\n                    subid:   '0' | decimal_constant\n      \
    \  For example, to register for the policy to be run on all\n        interface\
    \ elements, the 'ifEntry' element type will be\n        registered as '1.3.6.1.2.1.2.2.1'.\n\
    \        If a value is included that does not represent a registered\n       \
    \ pmElementTypeRegOIDPrefix, then that value will be ignored.\"\n    ::= { pmPolicyEntry\
    \ 6 }\n"
- title: pmPolicyConditionScriptIndex OBJECT-TYPE
  contents:
  - "pmPolicyConditionScriptIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n\
    \    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n       \
    \  \"A pointer to the row or rows in the pmPolicyCodeTable that\n         contain\
    \ the condition code for this policy.  When a policy\n         entry is created,\
    \ a pmPolicyCodeIndex value unused by this\n         policy's adminGroup will\
    \ be assigned to this object.\n         A policy condition is one or more PolicyScript\
    \ statements\n         that result(s) in a boolean value that represents whether\n\
    \         an element is a member of a set of elements upon which an\n        \
    \ action is to be performed.  If a policy is ready and the\n         condition\
    \ returns true for an element of a proper element\n         type, and if no higher-precedence\
    \ policy should be active,\n         then the policy is active on that element.\n\
    \         Condition evaluation stops immediately when any run-time\n         exception\
    \ is detected, and the policyAction is not executed.\n         The policyCondition\
    \ is evaluated for various elements.  Any\n         element for which the policyCondition\
    \ returns any nonzero value\n         will match the condition and will have the\
    \ associated\n         policyAction executed on that element unless a\n      \
    \   higher-precedence policy in the same precedence group also\n         matches\
    \ 'this element'.\n         If the condition object is empty (contains no code)\
    \ or\n         otherwise does not return a value, the element will not be\n  \
    \       matched.\n         When this condition is executed, if SNMP requests are\
    \ made to\n         the local system and secModel/secName/secLevel aren't\n  \
    \       specified, access to objects is under the security\n         credentials\
    \ of the requester who most recently modified the\n         associated pmPolicyAdminStatus\
    \ object.  If SNMP requests are\n         made in which secModel/secName/secLevel\
    \ are specified, then\n         the specified credentials are retrieved from the\
    \ local\n         configuration datastore only if VACM is configured to\n    \
    \     allow access to the requester who most recently modified the\n         associated\
    \ pmPolicyAdminStatus object.  See the Security\n         Considerations section\
    \ for more information.\"\n    ::= { pmPolicyEntry 7 }\n"
- title: pmPolicyActionScriptIndex OBJECT-TYPE
  contents:
  - "pmPolicyActionScriptIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n\
    \    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n       \
    \  \"A pointer to the row or rows in the pmPolicyCodeTable that\n         contain\
    \ the action code for this policy.  When a policy entry\n         is created,\
    \ a pmPolicyCodeIndex value unused by this policy's\n         adminGroup will\
    \ be assigned to this object.\n         A PolicyAction is an operation performed\
    \ on a\n         set of elements for which the policy is active.\n         Action\
    \ evaluation stops immediately when any run-time\n         exception is detected.\n\
    \         When this condition is executed, if SNMP requests are made to\n    \
    \     the local system and secModel/secName/secLevel aren't\n         specified,\
    \ access to objects is under the security\n         credentials of the requester\
    \ who most recently modified the\n         associated pmPolicyAdminStatus object.\
    \  If SNMP requests are\n         made in which secModel/secName/secLevel are\
    \ specified, then\n         the specified credentials are retrieved from the local\n\
    \         configuration datastore only if VACM is configured to\n         allow\
    \ access to the requester who most recently modified the\n         associated\
    \ pmPolicyAdminStatus object.  See the Security\n         Considerations section\
    \ for more information.\"\n    ::= { pmPolicyEntry 8 }\n"
- title: pmPolicyParameters OBJECT-TYPE
  contents:
  - "pmPolicyParameters OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0..65535))\n\
    \    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n     \
    \   \"From time to time, policy scripts may seek one or more\n        parameters\
    \ (e.g., site-specific constants).  These parameters\n        may be installed\
    \ with the script in this object and are\n        accessible to the script via\
    \ the getParameters() function.  If\n        it is necessary for multiple parameters\
    \ to be passed to the\n        script, the script can choose whatever encoding/delimiting\n\
    \        mechanism is most appropriate.\"\n    ::= { pmPolicyEntry 9 }\n"
- title: pmPolicyConditionMaxLatency OBJECT-TYPE
  contents:
  - "pmPolicyConditionMaxLatency OBJECT-TYPE\n    SYNTAX      Unsigned32 (0..2147483647)\n\
    \    UNITS       \"milliseconds\"\n    MAX-ACCESS  read-create\n    STATUS   \
    \   current\n    DESCRIPTION\n        \"Every element under the control of this\
    \ agent is\n        re-checked periodically to see whether it is under control\n\
    \        of this policy by re-running the condition for this policy.\n       \
    \ This object lets the manager control the maximum amount of\n        time that\
    \ may pass before an element is re-checked.\n        In other words, in any given\
    \ interval of this duration, all\n        elements must be re-checked.  Note that\
    \ how the policy agent\n        schedules the checking of various elements within\
    \ this\n        interval is an implementation-dependent matter.\n        Implementations\
    \ may wish to re-run a condition more\n        quickly if they note a change to\
    \ the role strings for an\n        element.\"\n    ::= { pmPolicyEntry 10 }\n"
- title: pmPolicyActionMaxLatency OBJECT-TYPE
  contents:
  - "pmPolicyActionMaxLatency OBJECT-TYPE\n    SYNTAX      Unsigned32 (0..2147483647)\n\
    \    UNITS       \"milliseconds\"\n    MAX-ACCESS  read-create\n    STATUS   \
    \   current\n    DESCRIPTION\n        \"Every element that matches this policy's\
    \ condition and is\n        therefore under control of this policy will have this\
    \ policy's\n        action executed periodically to ensure that the element\n\
    \        remains in the state dictated by the policy.\n        This object lets\
    \ the manager control the maximum amount of\n        time that may pass before\
    \ an element has the action run on\n        it.\n        In other words, in any\
    \ given interval of this duration, all\n        elements under control of this\
    \ policy must have the action run\n        on them.  Note that how the policy\
    \ agent schedules the policy\n        action on various elements within this interval\
    \ is an\n        implementation-dependent matter.\"\n    ::= { pmPolicyEntry 11\
    \ }\n"
- title: pmPolicyMaxIterations OBJECT-TYPE
  contents:
  - "pmPolicyMaxIterations OBJECT-TYPE\n    SYNTAX      Unsigned32\n    MAX-ACCESS\
    \  read-create\n    STATUS      current\n    DESCRIPTION\n        \"If a condition\
    \ or action script iterates in loops too many\n        times in one invocation,\
    \ the execution environment may\n        consider it in an infinite loop or otherwise\
    \ not acting\n        as intended and may be terminated by the execution\n   \
    \     environment.  The execution environment will count the\n        cumulative\
    \ number of times all 'for' or 'while' loops iterated\n        and will apply\
    \ a threshold to determine when to terminate the\n        script.  What threshold\
    \ the execution environment uses is an\n        implementation-dependent manner,\
    \ but the value of\n        this object SHOULD be the basis for choosing the threshold\
    \ for\n        each script.  The value of this object represents a\n        policy-specific\
    \ threshold and can be tuned for policies of\n        varying workloads.  If this\
    \ value is zero, no\n        threshold will be enforced except for any\n     \
    \   implementation-dependent maximum.  Regardless of this value,\n        the\
    \ agent is allowed to terminate any script invocation that\n        exceeds a\
    \ local CPU or memory limitation.\n        Note that the condition and action\
    \ invocations are tracked\n        separately.\"\n    ::= { pmPolicyEntry 12 }\n"
- title: pmPolicyDescription OBJECT-TYPE
  contents:
  - "pmPolicyDescription OBJECT-TYPE\n    SYNTAX      PmUTF8String\n    MAX-ACCESS\
    \  read-create\n    STATUS      current\n    DESCRIPTION\n         \"A description\
    \ of this rule and its significance, typically\n         provided by a human.\"\
    \n    ::= { pmPolicyEntry 13 }\n"
- title: pmPolicyMatches OBJECT-TYPE
  contents:
  - "pmPolicyMatches OBJECT-TYPE\n    SYNTAX      Gauge32\n    UNITS       \"elements\"\
    \n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n      \
    \   \"The number of elements that, in their most recent execution\n         of\
    \ the associated condition, were matched by the condition.\"\n    ::= { pmPolicyEntry\
    \ 14 }\n"
- title: pmPolicyAbnormalTerminations OBJECT-TYPE
  contents:
  - "pmPolicyAbnormalTerminations OBJECT-TYPE\n    SYNTAX      Gauge32\n    UNITS\
    \       \"elements\"\n    MAX-ACCESS  read-only\n    STATUS      current\n   \
    \ DESCRIPTION\n         \"The number of elements that, in their most recent execution\n\
    \         of the associated condition or action, have experienced a\n        \
    \ run-time exception and terminated abnormally.  Note that if a\n         policy\
    \ was experiencing a run-time exception while processing\n         a particular\
    \ element but runs normally on a subsequent\n         invocation, this number\
    \ can decline.\"\n    ::= { pmPolicyEntry 15 }\n"
- title: pmPolicyExecutionErrors OBJECT-TYPE
  contents:
  - "pmPolicyExecutionErrors OBJECT-TYPE\n    SYNTAX      Counter32\n    UNITS   \
    \    \"errors\"\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n\
    \         \"The total number of times that execution of this policy's\n      \
    \   condition or action has been terminated due to run-time\n         exceptions.\"\
    \n    ::= { pmPolicyEntry 16 }\n"
- title: pmPolicyDebugging OBJECT-TYPE
  contents:
  - "pmPolicyDebugging OBJECT-TYPE\n    SYNTAX      INTEGER {\n                  \
    \  off(1),\n                    on(2)\n                }\n    MAX-ACCESS  read-create\n\
    \    STATUS      current\n    DESCRIPTION\n         \"The status of debugging\
    \ for this policy.  If this is turned\n         on(2), log entries will be created\
    \ in the pmDebuggingTable\n         for each run-time exception that is experienced\
    \ by this\n         policy.\"\n    DEFVAL { off }\n    ::= { pmPolicyEntry 17\
    \ }\n"
- title: pmPolicyAdminStatus OBJECT-TYPE
  contents:
  - "pmPolicyAdminStatus OBJECT-TYPE\n    SYNTAX      INTEGER {\n                \
    \    disabled(1),\n                    enabled(2),\n                    enabledAutoRemove(3)\n\
    \                }\n    MAX-ACCESS  read-create\n    STATUS      current\n   \
    \ DESCRIPTION\n         \"The administrative status of this policy.\n        \
    \ The policy will be valid only if the associated\n         pmPolicyRowStatus\
    \ is set to active(1) and this object is set\n         to enabled(2) or enabledAutoRemove(3).\n\
    \         If this object is set to enabledAutoRemove(3), the next time\n     \
    \    the associated schedule moves from the active state to the\n         inactive\
    \ state, this policy will immediately be deleted,\n         including any associated\
    \ entries in the pmPolicyCodeTable.\n         The following related objects may\
    \ not be changed unless this\n         object is set to disabled(1):\n       \
    \      pmPolicyPrecedenceGroup, pmPolicyPrecedence,\n             pmPolicySchedule,\
    \ pmPolicyElementTypeFilter,\n             pmPolicyConditionScriptIndex, pmPolicyActionScriptIndex,\n\
    \             pmPolicyParameters, and any pmPolicyCodeTable row\n            \
    \ referenced by this policy.\n         In order to change any of these parameters,\
    \ the policy must\n         be moved to the disabled(1) state, changed, and then\n\
    \         re-enabled.\n         When this policy moves to either enabled state\
    \ from the\n         disabled state, any cached values of policy condition must\
    \ be\n         erased, and any Policy or PolicyElement scratchpad values for\n\
    \         this policy should be removed.  Policy execution will begin by\n   \
    \      testing the policy condition on all appropriate elements.\"\n    ::= {\
    \ pmPolicyEntry 18 }\n"
- title: pmPolicyStorageType OBJECT-TYPE
  contents:
  - "pmPolicyStorageType OBJECT-TYPE\n    SYNTAX      StorageType\n    MAX-ACCESS\
    \  read-create\n    STATUS      current\n    DESCRIPTION\n        \"This object\
    \ defines whether this policy and any associated\n         entries in the pmPolicyCodeTable\
    \ are kept in volatile storage\n         and lost upon reboot or if this row is\
    \ backed up by\n         non-volatile or permanent storage.\n         If the value\
    \ of this object is 'permanent', the values for\n         the associated pmPolicyAdminStatus\
    \ object must remain\n         writable.\"\n    ::= { pmPolicyEntry 19 }\n"
- title: pmPolicyRowStatus OBJECT-TYPE
  contents:
  - "pmPolicyRowStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS  read-create\n\
    \    STATUS      current\n    DESCRIPTION\n         \"The row status of this pmPolicyEntry.\n\
    \         The status may not be set to active if any of the related\n        \
    \ entries in the pmPolicyCode table do not have a status of\n         active or\
    \ if any of the objects in this row are not set to\n         valid values.  Only\
    \ the following objects may be modified\n         while in the active state:\n\
    \             pmPolicyParameters\n             pmPolicyConditionMaxLatency\n \
    \            pmPolicyActionMaxLatency\n             pmPolicyDebugging\n      \
    \       pmPolicyAdminStatus\n         If this row is deleted, any associated entries\
    \ in the\n         pmPolicyCodeTable will be deleted as well.\"\n    ::= { pmPolicyEntry\
    \ 20 }\n"
- title: -- Policy Code Table
  contents:
  - '-- Policy Code Table

    '
- title: pmPolicyCodeTable OBJECT-TYPE
  contents:
  - "pmPolicyCodeTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmPolicyCodeEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"The pmPolicyCodeTable stores the code for policy conditions and\n   \
    \     actions.\n        An example of the relationships between the code table\
    \ and the\n        policy table follows:\n        pmPolicyTable\n            AdminGroup\
    \  Index   ConditionScriptIndex  ActionScriptIndex\n        A   ''          1\
    \       1                     2\n        B   'oper'      1       1           \
    \          2\n        C   'oper'      2       3                     4\n      \
    \  pmPolicyCodeTable\n        AdminGroup  ScriptIndex  Segment    Note\n     \
    \   ''          1            1          Filter for policy A\n        ''      \
    \    2            1          Action for policy A\n        'oper'      1      \
    \      1          Filter for policy B\n        'oper'      2            1    \
    \      Action 1/2 for policy B\n        'oper'      2            2          Action\
    \ 2/2 for policy B\n        'oper'      3            1          Filter for policy\
    \ C\n        'oper'      4            1          Action for policy C\n       \
    \ In this example, there are 3 policies: 1 in the '' adminGroup,\n        and\
    \ 2 in the 'oper' adminGroup.  Policy A has been assigned\n        script indexes\
    \ 1 and 2 (these script indexes are assigned out of\n        a separate pool per\
    \ adminGroup), with 1 code segment each for\n        the filter and the action.\
    \  Policy B has been assigned script\n        indexes 1 and 2 (out of the pool\
    \ for the 'oper' adminGroup).\n        While the filter has 1 segment, the action\
    \ is longer and is\n        loaded into 2 segments.  Finally, Policy C has been\
    \ assigned\n        script indexes 3 and 4, with 1 code segment each for the filter\n\
    \        and the action.\"\n    ::= { pmMib 2 }\n"
- title: pmPolicyCodeEntry OBJECT-TYPE
  contents:
  - "pmPolicyCodeEntry OBJECT-TYPE\n    SYNTAX      PmPolicyCodeEntry\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"An entry\
    \ in the policy code table representing one code\n        segment.  Entries that\
    \ share a common AdminGroup/ScriptIndex\n        pair make up a single script.\
    \  Valid values of ScriptIndex are\n        retrieved from pmPolicyConditionScriptIndex\
    \ and\n        pmPolicyActionScriptIndex after a pmPolicyEntry is\n        created.\
    \  Segments of code can then be written to this table\n        with the learned\
    \ ScriptIndex values.\n        The StorageType of this entry is determined by\
    \ the value of\n        the associated pmPolicyStorageType.\n        The pmPolicyAdminGroup\
    \ element of the index represents the\n        administrative group of the policy\
    \ of which this code entry is\n        a part.\"\n    INDEX { pmPolicyAdminGroup,\
    \ pmPolicyCodeScriptIndex,\n            pmPolicyCodeSegment }\n    ::= { pmPolicyCodeTable\
    \ 1 }\n"
- title: PmPolicyCodeEntry ::= SEQUENCE {
  contents:
  - "PmPolicyCodeEntry ::= SEQUENCE {\n    pmPolicyCodeScriptIndex    Unsigned32,\n\
    \    pmPolicyCodeSegment        Unsigned32,\n    pmPolicyCodeText           PmUTF8String,\n\
    \    pmPolicyCodeStatus         RowStatus\n"
- title: '}'
  contents:
  - '}

    '
- title: pmPolicyCodeScriptIndex OBJECT-TYPE
  contents:
  - "pmPolicyCodeScriptIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \       \"A unique index for each policy condition or action.  The code\n    \
    \     for each such condition or action may be composed of multiple\n        \
    \ entries in this table if the code cannot fit in one entry.\n         Values\
    \ of pmPolicyCodeScriptIndex may not be used unless\n         they have previously\
    \ been assigned in the\n         pmPolicyConditionScriptIndex or pmPolicyActionScriptIndex\n\
    \         objects.\"\n    ::= { pmPolicyCodeEntry 1 }\n"
- title: pmPolicyCodeSegment OBJECT-TYPE
  contents:
  - "pmPolicyCodeSegment OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \       \"A unique index for each segment of a policy condition or\n         action.\n\
    \         When a policy condition or action spans multiple entries in\n      \
    \   this table, the code of that policy starts from the\n         lowest-numbered\
    \ segment and continues with increasing segment\n         values until it ends\
    \ with the highest-numbered segment.\"\n    ::= { pmPolicyCodeEntry 2 }\n"
- title: pmPolicyCodeText OBJECT-TYPE
  contents:
  - "pmPolicyCodeText OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (1..1024))\n\
    \    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n     \
    \    \"A segment of policy code (condition or action).  Lengthy\n         Policy\
    \ conditions or actions may be stored in multiple\n         segments in this table\
    \ that share the same value of\n         pmPolicyCodeScriptIndex.  When multiple\
    \ segments are used, it\n         is recommended that each segment be as large\
    \ as is practical.\n         Entries in this table are associated with policies\
    \ by values\n         of the pmPolicyConditionScriptIndex and\n         pmPolicyActionScriptIndex\
    \ objects.  If the status of the\n         related policy is active, then this\
    \ object may not be\n         modified.\"\n    ::= { pmPolicyCodeEntry 3 }\n"
- title: pmPolicyCodeStatus OBJECT-TYPE
  contents:
  - "pmPolicyCodeStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS  read-create\n\
    \    STATUS      current\n    DESCRIPTION\n         \"The status of this code\
    \ entry.\n         Entries in this table are associated with policies by values\n\
    \         of the pmPolicyConditionScriptIndex and\n         pmPolicyActionScriptIndex\
    \ objects.  If the status of the\n         related policy is active, then this\
    \ object can not be\n         modified (i.e., deleted or set to notInService),\
    \ nor may new\n         entries be created.\n         If the status of this object\
    \ is active, no objects in this\n         row may be modified.\"\n    ::= { pmPolicyCodeEntry\
    \ 4 }\n"
- title: -- Element Type Registration Table
  contents:
  - '-- Element Type Registration Table

    '
- title: pmElementTypeRegTable OBJECT-TYPE
  contents:
  - "pmElementTypeRegTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmElementTypeRegEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"A registration table for element types managed by this\n        system.\n\
    \        The Element Type Registration table allows the manager to\n        learn\
    \ what element types are being managed by the system and\n        to register\
    \ new types, if necessary.  An element type is\n        registered by providing\
    \ the OID of an SNMP object (i.e.,\n        without the instance).  Each SNMP\
    \ instance that exists under\n        that object is a distinct element.  The\
    \ index of the element is\n        the index part of the discovered OID.  This\
    \ index will be\n        supplied to policy conditions and actions so that this\
    \ code\n        can inspect and configure the element.\n        For example, this\
    \ table might contain the following entries.\n        The first three are agent-installed,\
    \ and the 4th was\n        downloaded by a management station:\n  OIDPrefix  \
    \      MaxLatency  Description               StorageType\n  ifEntry          100\
    \ mS      interfaces - builtin      readOnly\n  0.0              100 mS      system\
    \ element - builtin  readOnly\n  frCircuitEntry   100 mS      FR Circuits - builtin\
    \     readOnly\n  hrSWRunEntry     60 sec      Running Processes         volatile\n\
    \        Note that agents may automatically configure elements in this\n     \
    \   table for frequently used element types (interfaces, circuits,\n        etc.).\
    \  In particular, it may configure elements for whom\n        discovery is optimized\
    \ in one or both of the following ways:\n        1. The agent may discover elements\
    \ by scanning internal data\n           structures as opposed to issuing local\
    \ SNMP requests.  It is\n           possible to recreate the exact semantics described\
    \ in this\n           table even if local SNMP requests are not issued.\n    \
    \    2. The agent may receive asynchronous notification of new\n           elements\
    \ (for example, 'card inserted') and use that\n           information to instantly\
    \ create elements rather than\n           through polling.  A similar feature\
    \ might be available for\n           the deletion of elements.\n        Note that\
    \ the disposition of agent-installed entries is\n        described by the pmPolicyStorageType\
    \ object.\"\n    ::= { pmMib 3 }\n"
- title: pmElementTypeRegEntry OBJECT-TYPE
  contents:
  - "pmElementTypeRegEntry OBJECT-TYPE\n    SYNTAX      PmElementTypeRegEntry\n  \
    \  MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n    \
    \    \"A registration of an element type.\n        Note that some values of this\
    \ table's index may result in an\n        instance name that exceeds a length\
    \ of 128 sub-identifiers,\n        which exceeds the maximum for the SNMP protocol.\n\
    \        Implementations should take care to avoid such values.\"\n    INDEX \
    \      { pmElementTypeRegOIDPrefix }\n    ::= { pmElementTypeRegTable 1 }\n"
- title: PmElementTypeRegEntry ::= SEQUENCE {
  contents:
  - "PmElementTypeRegEntry ::= SEQUENCE {\n    pmElementTypeRegOIDPrefix     OBJECT\
    \ IDENTIFIER,\n    pmElementTypeRegMaxLatency    Unsigned32,\n    pmElementTypeRegDescription\
    \   PmUTF8String,\n    pmElementTypeRegStorageType   StorageType,\n    pmElementTypeRegRowStatus\
    \     RowStatus\n"
- title: '}'
  contents:
  - '}

    '
- title: pmElementTypeRegOIDPrefix OBJECT-TYPE
  contents:
  - "pmElementTypeRegOIDPrefix OBJECT-TYPE\n    SYNTAX      OBJECT IDENTIFIER\n  \
    \  MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n    \
    \    \"This OBJECT IDENTIFIER value identifies a table in which all\n        elements\
    \ of this type will be found.  Every row in the\n        referenced table will\
    \ be treated as an element for the\n        period of time that it remains in\
    \ the table.  The agent will\n        then execute policy conditions and actions\
    \ as appropriate on\n        each of these elements.\n        This object identifier\
    \ value is specified down to the 'entry'\n        component (e.g., ifEntry) of\
    \ the identifier.\n        The index of each discovered row will be passed to\
    \ each\n        invocation of the policy condition and policy action.\n      \
    \  The actual mechanism by which instances are discovered is\n        implementation\
    \ dependent.  Periodic walks of the table to\n        discover the rows in the\
    \ table is one such mechanism.  This\n        mechanism has the advantage that\
    \ it can be performed by an\n        agent with no knowledge of the names, syntax,\
    \ or semantics\n        of the MIB objects in the table.  This mechanism also\
    \ serves as\n        the reference design.  Other implementation-dependent\n \
    \       mechanisms may be implemented that are more efficient (perhaps\n     \
    \   because they are hard coded) or that don't require polling.\n        These\
    \ mechanisms must discover the same elements as would the\n        table-walking\
    \ reference design.\n        This object can contain a OBJECT IDENTIFIER, '0.0'.\n\
    \        '0.0' represents the single instance of the system\n        itself and\
    \ provides an execution context for policies to\n        operate on the 'system\
    \ element' and on MIB objects\n        modeled as scalars.  For example, '0.0'\
    \ gives an execution\n        context for policy-based selection of the operating\
    \ system\n        code version (likely modeled as a scalar MIB object).  The\n\
    \        element type '0.0' always exists; as a consequence, no actual\n     \
    \   discovery will take place, and the pmElementTypeRegMaxLatency\n        object\
    \ will have no effect for the '0.0' element\n        type.  However, if the '0.0'\
    \ element type is not registered in\n        the table, policies will not be executed\
    \ on the '0.0' element.\n        When a policy is invoked on behalf of a '0.0'\
    \ entry in this\n        table, the element name will be '0.0', and there is no\
    \ index\n        of 'this element' (in other words, it has zero length).\n   \
    \     As this object is used in the index for the\n        pmElementTypeRegTable,\
    \ users of this table should be careful\n        not to create entries that would\
    \ result in instance names with\n        more than 128 sub-identifiers.\"\n  \
    \  ::= { pmElementTypeRegEntry 2 }\n"
- title: pmElementTypeRegMaxLatency OBJECT-TYPE
  contents:
  - "pmElementTypeRegMaxLatency OBJECT-TYPE\n    SYNTAX      Unsigned32\n    UNITS\
    \       \"milliseconds\"\n    MAX-ACCESS  read-create\n    STATUS      current\n\
    \    DESCRIPTION\n        \"The PM agent is responsible for discovering new elements\
    \ of\n        types that are registered.  This object lets the manager\n     \
    \   control the maximum amount of time that may pass between the\n        time\
    \ an element is created and when it is discovered.\n        In other words, in\
    \ any given interval of this duration, all\n        new elements must be discovered.\
    \  Note that how the policy\n        agent schedules the checking of various elements\
    \ within this\n        interval is an implementation-dependent matter.\"\n   \
    \ ::= { pmElementTypeRegEntry 3 }\n"
- title: pmElementTypeRegDescription OBJECT-TYPE
  contents:
  - "pmElementTypeRegDescription OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (0..64))\n\
    \    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n     \
    \   \"A descriptive label for this registered type.\"\n    ::= { pmElementTypeRegEntry\
    \ 4 }\n"
- title: pmElementTypeRegStorageType OBJECT-TYPE
  contents:
  - "pmElementTypeRegStorageType OBJECT-TYPE\n    SYNTAX      StorageType\n    MAX-ACCESS\
    \  read-create\n    STATUS      current\n    DESCRIPTION\n        \"This object\
    \ defines whether this row is kept\n         in volatile storage and lost upon\
    \ reboot or\n         backed up by non-volatile or permanent storage.\n      \
    \   If the value of this object is 'permanent', no values in the\n         associated\
    \ row have to be writable.\"\n    ::= { pmElementTypeRegEntry 5 }\n"
- title: pmElementTypeRegRowStatus OBJECT-TYPE
  contents:
  - "pmElementTypeRegRowStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS\
    \  read-create\n    STATUS      current\n    DESCRIPTION\n        \"The status\
    \ of this registration entry.\n        If the value of this object is active,\
    \ no objects in this row\n        may be modified.\"\n    ::= { pmElementTypeRegEntry\
    \ 6 }\n"
- title: -- Role Table
  contents:
  - '-- Role Table

    '
- title: pmRoleTable OBJECT-TYPE
  contents:
  - "pmRoleTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmRoleEntry\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"The pmRoleTable\
    \ is a read-create table that organizes role\n        strings sorted by element.\
    \  This table is used to create and\n        modify role strings and their associations,\
    \ as well as to allow\n        a management station to learn about the existence\
    \ of roles and\n        their associations.\n        It is the responsibility\
    \ of the agent to keep track of any\n        re-indexing of the underlying SNMP\
    \ elements and to continue to\n        associate role strings with the element\
    \ with which they were\n        initially configured.\n        Policy MIB agents\
    \ that have elements in multiple local SNMP\n        contexts have to allow some\
    \ roles to be assigned to elements\n        in particular contexts.  This is particularly\
    \ true when some\n        elements have the same names in different contexts and\
    \ the\n        context is required to disambiguate them.  In those situations,\n\
    \        a value for the pmRoleContextName may be provided.  When a\n        pmRoleContextName\
    \ value is not provided, the assignment is to\n        the element in the default\
    \ context.\n        Policy MIB agents that discover elements on other systems\
    \ and\n        execute policies on their behalf need to have access to role\n\
    \        information for these remote elements.  In such situations,\n       \
    \ role assignments for other systems can be stored in this table\n        by providing\
    \ values for the pmRoleContextEngineID parameters.\n    For example:\n    Example:\n\
    \    element       role    context ctxEngineID   #comment\n    ifindex.1     gold\
    \                          local, default context\n    ifindex.2     gold    \
    \                      local, default context\n    repeaterid.1  foo     rptr1\
    \                 local, rptr1 context\n    repeaterid.1  bar     rptr2      \
    \           local, rptr2 context\n    ifindex.1     gold    ''      A        \
    \     different system\n    ifindex.1     gold    ''      B             different\
    \ system\n         The agent must store role string associations in non-volatile\n\
    \         storage.\"\n    ::= { pmMib 4 }\n"
- title: pmRoleEntry OBJECT-TYPE
  contents:
  - "pmRoleEntry OBJECT-TYPE\n    SYNTAX      PmRoleEntry\n    MAX-ACCESS  not-accessible\n\
    \    STATUS      current\n    DESCRIPTION\n         \"A role string entry associates\
    \ a role string with an\n         individual element.\n         Note that some\
    \ combinations of index values may result in an\n         instance name that exceeds\
    \ a length of 128 sub-identifiers,\n         which exceeds the maximum for the\
    \ SNMP\n         protocol.  Implementations should take care to avoid such\n \
    \        combinations.\"\n    INDEX       { pmRoleElement, pmRoleContextName,\n\
    \                  pmRoleContextEngineID, pmRoleString }\n    ::= { pmRoleTable\
    \ 1 }\n"
- title: PmRoleEntry ::= SEQUENCE {
  contents:
  - "PmRoleEntry ::= SEQUENCE {\n    pmRoleElement          RowPointer,\n    pmRoleContextName\
    \      SnmpAdminString,\n    pmRoleContextEngineID  OCTET STRING,\n    pmRoleString\
    \           PmUTF8String,\n    pmRoleStatus           RowStatus\n"
- title: '}'
  contents:
  - '}

    '
- title: pmRoleElement OBJECT-TYPE
  contents:
  - "pmRoleElement OBJECT-TYPE\n    SYNTAX      RowPointer\n    MAX-ACCESS  not-accessible\n\
    \    STATUS      current\n    DESCRIPTION\n         \"The element with which this\
    \ role string is associated.\n         For example, if the element is interface\
    \ 3, then this object\n         will contain the OID for 'ifIndex.3'.\n      \
    \   If the agent assigns new indexes in the MIB table to\n         represent the\
    \ same underlying element (re-indexing), the\n         agent will modify this\
    \ value to contain the new index for the\n         underlying element.\n     \
    \    As this object is used in the index for the pmRoleTable,\n         users\
    \ of this table should be careful not to create entries\n         that would result\
    \ in instance names with more than 128\n         sub-identifiers.\"\n    ::= {\
    \ pmRoleEntry 1 }\n"
- title: pmRoleContextName OBJECT-TYPE
  contents:
  - "pmRoleContextName OBJECT-TYPE\n    SYNTAX      SnmpAdminString (SIZE (0..32))\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"If the associated element is not in the default SNMP context\n      \
    \  for the target system, this object is used to identify the\n        context.\
    \  If the element is in the default context, this object\n        is equal to\
    \ the empty string.\"\n    ::= { pmRoleEntry 2 }\n"
- title: pmRoleContextEngineID OBJECT-TYPE
  contents:
  - "pmRoleContextEngineID OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0 | 5..32))\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"If the associated element is on a remote system, this object\n      \
    \  is used to identify the remote system.  This object contains\n        the contextEngineID\
    \ of the system for which this role string\n        assignment is valid.  If the\
    \ element is on the local system\n        this object will be the empty string.\"\
    \n    ::= { pmRoleEntry 3 }\n"
- title: pmRoleString OBJECT-TYPE
  contents:
  - "pmRoleString OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (0..64))\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"The role\
    \ string that is associated with an element through\n         this table.  All\
    \ role strings must have been successfully\n         transformed by Stringprep\
    \ RFC 3454.  Management stations\n         must perform this translation and must\
    \ only set this object\n         to string values that have been transformed.\n\
    \         A role string is an administratively specified characteristic\n    \
    \     of a managed element (for example, an interface).  It is a\n         selector\
    \ for policy rules, that determines the applicability of\n         the rule to\
    \ a particular managed element.\"\n    ::= { pmRoleEntry 4 }\n"
- title: pmRoleStatus OBJECT-TYPE
  contents:
  - "pmRoleStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS  read-create\n\
    \    STATUS      current\n    DESCRIPTION\n         \"The status of this role\
    \ string.\n         If the value of this object is active, no object in this row\n\
    \         may be modified.\"\n    ::= { pmRoleEntry 5 }\n"
- title: -- Capabilities table
  contents:
  - '-- Capabilities table

    '
- title: pmCapabilitiesTable OBJECT-TYPE
  contents:
  - "pmCapabilitiesTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmCapabilitiesEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \       \"The pmCapabilitiesTable contains a description of\n         the inherent\
    \ capabilities of the system so that\n         management stations can learn of\
    \ an agent's capabilities and\n         differentially install policies based\
    \ on the capabilities.\n         Capabilities are expressed at the system level.\
    \  There can be\n         variation in how capabilities are realized from one\
    \ vendor or\n         model to the next.  Management systems should consider these\n\
    \         differences before selecting which policy to install in a\n        \
    \ system.\"\n    ::= { pmMib 5 }\n"
- title: pmCapabilitiesEntry OBJECT-TYPE
  contents:
  - "pmCapabilitiesEntry OBJECT-TYPE\n    SYNTAX      PmCapabilitiesEntry\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"A capabilities\
    \ entry holds an OID indicating support for a\n         particular capability.\
    \  Capabilities may include hardware and\n         software functions and the\
    \ implementation of MIB\n         Modules.  The semantics of the OID are defined\
    \ in the\n         description of pmCapabilitiesType.\n         Entries appear\
    \ in this table if any element in the system has\n         a specific capability.\
    \  A capability should appear in this\n         table only once, regardless of\
    \ the number of elements in the\n         system with that capability.  An entry\
    \ is removed from this\n         table when the last element in the system that\
    \ has the\n         capability is removed.  In some cases, capabilities are\n\
    \         dynamic and exist only in software.  This table should have an\n   \
    \      entry for the capability even if there are no current\n         instances.\
    \  Examples include systems with database or WEB\n         services.  While the\
    \ system has the ability to create new\n         databases or WEB services, the\
    \ entry should exist.  In these\n         cases, the ability to create these services\
    \ could come from\n         other processes that are running in the system, even\
    \ though\n         there are no currently open databases or WEB servers running.\n\
    \         Capabilities may include the implementation of MIB Modules\n       \
    \  but need not be limited to those that represent MIB Modules\n         with\
    \ one or more configurable objects.  It may also be\n         valuable to include\
    \ entries for capabilities that do not\n         include configuration objects,\
    \ as that information, in\n         combination with other entries in this table,\
    \ might be used\n         by the management software to determine whether to\n\
    \         install a policy.\n         Vendor software may also add entries in\
    \ this table to express\n         capabilities from their private branch.\n  \
    \       Note that some values of this table's index may result in an\n       \
    \  instance name that exceeds a length of 128 sub-identifiers,\n         which\
    \ exceeds the maximum for the SNMP\n         protocol.  Implementations should\
    \ take care to avoid such\n         values.\"\n    INDEX       { pmCapabilitiesType\
    \ }\n    ::= { pmCapabilitiesTable 1 }\n"
- title: PmCapabilitiesEntry ::= SEQUENCE {
  contents:
  - "PmCapabilitiesEntry ::= SEQUENCE {\n    pmCapabilitiesType               OBJECT\
    \ IDENTIFIER\n"
- title: '}'
  contents:
  - '}

    '
- title: pmCapabilitiesType OBJECT-TYPE
  contents:
  - "pmCapabilitiesType OBJECT-TYPE\n    SYNTAX      OBJECT IDENTIFIER\n    MAX-ACCESS\
    \  read-only\n    STATUS      current\n    DESCRIPTION\n         \"There are three\
    \ types of OIDs that may be present in the\n         pmCapabilitiesType object:\n\
    \         1) The OID of a MODULE-COMPLIANCE macro that represents the\n      \
    \   highest level of compliance realized by the agent for that\n         MIB Module.\
    \  For example, an agent that implements the OSPF\n         MIB Module at the\
    \ highest level of compliance would have the\n         value of '1.3.6.1.2.1.14.15.2'\
    \ in the pmCapabilitiesType\n         object.  For software that realizes standard\
    \ MIB\n         Modules that do not have compliance statements, the base OID\n\
    \         of the MIB Module should be used instead.  If the OSPF MIB\n       \
    \  Module had not been created with a compliance statement, then\n         the\
    \ correct value of the pmCapabilitiesType would be\n         '1.3.6.1.2.1.14'.\
    \  In the cases where multiple compliance\n         statements in a MIB Module\
    \ are supported by the agent, and\n         where one compliance statement does\
    \ not by definition include\n         the other, each of the compliance OIDs would\
    \ have entries in\n         this table.\n         MIB Documents can contain more\
    \ than one MIB Module.  In the\n         case of OSPF, there is a second MIB Module\n\
    \         that describes notifications for the OSPF Version 2 Protocol.\n    \
    \     If the agent also realizes these functions, an entry will\n         also\
    \ exist for those capabilities in this table.\n         2) Vendors should install\
    \ OIDs in this table that represent\n         vendor-specific capabilities.  These\
    \ capabilities can be\n         expressed just as those described above for MIB\
    \ Modules on\n         the standards track.  In addition, vendors may install\
    \ any\n         OID they desire from their registered branch.  The OIDs may be\n\
    \         at any level of granularity, from the root of their entire\n       \
    \  branch to an instance of a single OID.  There is no\n         restriction on\
    \ the number of registrations they may make,\n         though care should be taken\
    \ to avoid unnecessary entries.\n         3) OIDs that represent one capability\
    \ or a collection of\n         capabilities that could be any collection of MIB\
    \ Objects or\n         hardware or software functions may be created in working\n\
    \         groups and registered in a MIB Module.  Other entities (e.g.,\n    \
    \     vendors) may also make registrations.  Software will register\n        \
    \ these standard capability OIDs, as well as vendor specific\n         OIDs.\n\
    \         If the OID for a known capability is not present in the\n         table,\
    \ then it should be assumed that the capability is not\n         implemented.\n\
    \         As this object is used in the index for the\n         pmCapabilitiesTable,\
    \ users of this table should be careful\n         not to create entries that would\
    \ result in instance names\n         with more than 128 sub-identifiers.\"\n \
    \   ::= { pmCapabilitiesEntry 1 }\n"
- title: -- Capabilities override table
  contents:
  - '-- Capabilities override table

    '
- title: pmCapabilitiesOverrideTable OBJECT-TYPE
  contents:
  - "pmCapabilitiesOverrideTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmCapabilitiesOverrideEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \       \"The pmCapabilitiesOverrideTable allows management stations\n       \
    \  to override pmCapabilitiesTable entries that have been\n         registered\
    \ by the agent.  This facility can be used to avoid\n         situations in which\
    \ managers in the network send policies to\n         a system that has advertised\
    \ a capability in the\n         pmCapabilitiesTable but that should not be installed\
    \ on this\n         particular system.  One example could be newly deployed\n\
    \         equipment that is still in a trial state in a trial state or\n     \
    \    resources reserved for some other administrative reason.\n         This table\
    \ can also be used to override entries in the\n         pmCapabilitiesTable through\
    \ the use of the\n         pmCapabilitiesOverrideState object.  Capabilities can\
    \ also be\n         declared available in this table that were not registered\
    \ in\n         the pmCapabilitiesTable.  A management application can make\n \
    \        an entry in this table for any valid OID and declare the\n         capability\
    \ available by setting the\n         pmCapabilitiesOverrideState for that row\
    \ to valid(1).\"\n    ::= { pmMib 6 }\n"
- title: pmCapabilitiesOverrideEntry OBJECT-TYPE
  contents:
  - "pmCapabilitiesOverrideEntry OBJECT-TYPE\n    SYNTAX      PmCapabilitiesOverrideEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \       \"An entry in this table indicates whether a particular\n         capability\
    \ is valid or invalid.\n         Note that some values of this table's index may\
    \ result in an\n         instance name that exceeds a length of 128 sub-identifiers,\n\
    \         which exceeds the maximum for the SNMP\n         protocol.  Implementations\
    \ should take care to avoid such\n         values.\"\n    INDEX       { pmCapabilitiesOverrideType\
    \ }\n    ::= { pmCapabilitiesOverrideTable 1 }\n"
- title: PmCapabilitiesOverrideEntry ::= SEQUENCE {
  contents:
  - "PmCapabilitiesOverrideEntry ::= SEQUENCE {\n    pmCapabilitiesOverrideType  \
    \             OBJECT IDENTIFIER,\n    pmCapabilitiesOverrideState            \
    \  INTEGER,\n    pmCapabilitiesOverrideRowStatus          RowStatus\n"
- title: '}'
  contents:
  - '}

    '
- title: pmCapabilitiesOverrideType OBJECT-TYPE
  contents:
  - "pmCapabilitiesOverrideType OBJECT-TYPE\n    SYNTAX      OBJECT IDENTIFIER\n \
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n   \
    \      \"This is the OID of the capability that is declared valid or\n       \
    \  invalid by the pmCapabilitiesOverrideState value for this\n         row.  Any\
    \ valid OID, as described in the pmCapabilitiesTable,\n         is permitted in\
    \ the pmCapabilitiesOverrideType object.  This\n         means that capabilities\
    \ can be expressed at any level, from a\n         specific instance of an object\
    \ to a table or entire module.\n         There are no restrictions on whether\
    \ these objects are from\n         standards track MIB documents or in the private\
    \ branch of the\n         MIB.\n         If an entry exists in this table for\
    \ which there is a\n         corresponding entry in the pmCapabilitiesTable, then\
    \ this entry\n         shall have precedence over the entry in the\n         pmCapabilitiesTable.\
    \  All entries in this table must be\n         preserved across reboots.\n   \
    \      As this object is used in the index for the\n         pmCapabilitiesOverrideTable,\
    \ users of this table should be\n         careful not to create entries that would\
    \ result in instance\n         names with more than 128 sub-identifiers.\"\n \
    \   ::= { pmCapabilitiesOverrideEntry 1 }\n"
- title: pmCapabilitiesOverrideState OBJECT-TYPE
  contents:
  - "pmCapabilitiesOverrideState OBJECT-TYPE\n    SYNTAX      INTEGER {\n        \
    \            invalid(1),\n                    valid(2)\n                }\n  \
    \  MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n       \
    \  \"A pmCapabilitiesOverrideState of invalid indicates that\n         management\
    \ software should not send policies to this system\n         for the capability\
    \ identified in the\n         pmCapabilitiesOverrideType for this row of the table.\
    \  This\n         behavior is the same whether the capability represented by\n\
    \         the pmCapabilitiesOverrideType exists only in this table\n         (that\
    \ is, it was installed by an external management\n         application) or exists\
    \ in this table as well as the\n         pmCapabilitiesTable.  This would be the\
    \ case when a manager\n         wanted to disable a capability that the native\
    \ management\n         system found and registered in the pmCapabilitiesTable.\n\
    \         An entry in this table that has a pmCapabilitiesOverrideState\n    \
    \     of valid should be treated as though it appeared in the\n         pmCapabilitiesTable.\
    \  If the entry also exists in the\n         pmCapabilitiesTable in the pmCapabilitiesType\
    \ object, and if\n         the value of this object is valid, then the system\
    \ shall\n         operate as though this entry did not exist and policy\n    \
    \     installations and executions will continue in a normal\n         fashion.\"\
    \n    ::= { pmCapabilitiesOverrideEntry 2 }\n"
- title: pmCapabilitiesOverrideRowStatus OBJECT-TYPE
  contents:
  - "pmCapabilitiesOverrideRowStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS\
    \  read-create\n    STATUS      current\n    DESCRIPTION\n         \"The row status\
    \ of this pmCapabilitiesOverrideEntry.\n         If the value of this object is\
    \ active, no object in this row\n         may be modified.\"\n    ::= { pmCapabilitiesOverrideEntry\
    \ 3 }\n"
- title: -- The Schedule Group
  contents:
  - '-- The Schedule Group

    '
- title: pmSchedLocalTime OBJECT-TYPE
  contents:
  - "pmSchedLocalTime OBJECT-TYPE\n    SYNTAX      DateAndTime (SIZE (11))\n    MAX-ACCESS\
    \  read-only\n    STATUS      current\n    DESCRIPTION\n        \"The local time\
    \ used by the scheduler.  Schedules that\n         refer to calendar time will\
    \ use the local time indicated\n         by this object.  An implementation MUST\
    \ return all 11 bytes\n         of the DateAndTime textual-convention so that\
    \ a manager\n         may retrieve the offset from GMT time.\"\n    ::= { pmMib\
    \ 7 }\n"
- title: --
  contents:
  - '--

    '
- title: -- The schedule table that controls the scheduler.
  contents:
  - '-- The schedule table that controls the scheduler.

    '
- title: --
  contents:
  - '--

    '
- title: pmSchedTable OBJECT-TYPE
  contents:
  - "pmSchedTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmSchedEntry\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"This table\
    \ defines schedules for policies.\"\n    ::= { pmMib 8 }\n"
- title: pmSchedEntry OBJECT-TYPE
  contents:
  - "pmSchedEntry OBJECT-TYPE\n    SYNTAX      PmSchedEntry\n    MAX-ACCESS  not-accessible\n\
    \    STATUS      current\n    DESCRIPTION\n        \"An entry describing a particular\
    \ schedule.\n        Unless noted otherwise, writable objects of this row can\
    \ be\n        modified independently of the current value of pmSchedRowStatus,\n\
    \        pmSchedAdminStatus and pmSchedOperStatus.  In particular, it\n      \
    \  is legal to modify pmSchedWeekDay, pmSchedMonth, and\n        pmSchedDay when\
    \ pmSchedRowStatus is active.\"\n    INDEX { pmSchedIndex }\n    ::= { pmSchedTable\
    \ 1 }\n"
- title: PmSchedEntry ::= SEQUENCE {
  contents:
  - "PmSchedEntry ::= SEQUENCE {\n    pmSchedIndex          Unsigned32,\n    pmSchedGroupIndex\
    \     Unsigned32,\n    pmSchedDescr          PmUTF8String,\n    pmSchedTimePeriod\
    \     PmUTF8String,\n    pmSchedMonth          BITS,\n    pmSchedDay         \
    \   BITS,\n    pmSchedWeekDay        BITS,\n    pmSchedTimeOfDay      PmUTF8String,\n\
    \    pmSchedLocalOrUtc     INTEGER,\n    pmSchedStorageType    StorageType,\n\
    \    pmSchedRowStatus      RowStatus\n"
- title: '}'
  contents:
  - '}

    '
- title: pmSchedIndex OBJECT-TYPE
  contents:
  - "pmSchedIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"The locally\
    \ unique, administratively assigned index for this\n        scheduling entry.\"\
    \n    ::= { pmSchedEntry 1 }\n"
- title: pmSchedGroupIndex OBJECT-TYPE
  contents:
  - "pmSchedGroupIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n \
    \   MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n      \
    \  \"The locally unique, administratively assigned index for the\n        schedule\
    \ group this scheduling entry belongs to.\n        To assign multiple schedule\
    \ entries to the same group, the\n        pmSchedGroupIndex of each entry in the\
    \ group will be set to\n        the same value.  This pmSchedGroupIndex value\
    \ must be equal to\n        the pmSchedIndex of one of the entries in the group.\
    \  If the\n        entry whose pmSchedIndex equals the pmSchedGroupIndex\n   \
    \     for the group is deleted, the agent will assign a new\n        pmSchedGroupIndex\
    \ to all remaining members of the group.\n        If an entry is not a member\
    \ of a group, its pmSchedGroupIndex\n        must be assigned to the value of\
    \ its pmSchedIndex.\n        Policies that are controlled by a group of schedule\
    \ entries\n        are active when any schedule in the group is active.\"\n  \
    \  ::= { pmSchedEntry 2 }\n"
- title: pmSchedDescr OBJECT-TYPE
  contents:
  - "pmSchedDescr OBJECT-TYPE\n    SYNTAX      PmUTF8String\n    MAX-ACCESS  read-create\n\
    \    STATUS      current\n    DESCRIPTION\n        \"The human-readable description\
    \ of the purpose of this\n        scheduling entry.\"\n    DEFVAL { ''H }\n  \
    \  ::= { pmSchedEntry 3 }\n"
- title: pmSchedTimePeriod OBJECT-TYPE
  contents:
  - "pmSchedTimePeriod OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (0..31))\n\
    \    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n     \
    \   \"The overall range of calendar dates and times over which this\n        schedule\
    \ is active.  It is stored in a slightly extended version\n        of the format\
    \ for a 'period-explicit' defined in RFC 2445.\n        This format is expressed\
    \ as a string representing the\n        starting date and time, in which the character\
    \ 'T' indicates\n        the beginning of the time portion, followed by the solidus\n\
    \        character, '/', followed by a similar string representing an\n      \
    \  end date and time.  The start of the period MUST be before the\n        end\
    \ of the period.  Date-Time values are expressed as\n        substrings of the\
    \ form 'yyyymmddThhmmss'.  For example:\n            20000101T080000/20000131T130000\n\
    \              January 1, 2000, 0800 through January 31, 2000, 1PM\n        The\
    \ 'Date with UTC time' format defined in RFC 2445 in which\n        the Date-Time\
    \ string ends with the character 'Z' is not\n        allowed.\n        This 'period-explicit'\
    \ format is also extended to allow two\n        special cases in which one of\
    \ the Date-Time strings is\n        replaced with a special string defined in\
    \ RFC 2445:\n        1. If the first Date-Time value is replaced with the string\n\
    \           'THISANDPRIOR', then the value indicates that the schedule\n     \
    \      is active at any time prior to the Date-Time that appears\n           after\
    \ the '/'.\n        2. If the second Date-Time is replaced with the string\n \
    \          'THISANDFUTURE', then the value indicates that the schedule\n     \
    \      is active at any time after the Date-Time that appears\n           before\
    \ the '/'.\n        Note that although RFC 2445 defines these two strings, they\
    \ are\n        not specified for use in the 'period-explicit' format.  The use\n\
    \        of these strings represents an extension to the\n        'period-explicit'\
    \ format.\"\n    ::= { pmSchedEntry 4 }\n"
- title: pmSchedMonth OBJECT-TYPE
  contents:
  - "pmSchedMonth OBJECT-TYPE\n    SYNTAX      BITS {\n                    january(0),\n\
    \                    february(1),\n                    march(2),\n           \
    \         april(3),\n                    may(4),\n                    june(5),\n\
    \                    july(6),\n                    august(7),\n              \
    \      september(8),\n                    october(9),\n                    november(10),\n\
    \                    december(11)\n                }\n    MAX-ACCESS  read-create\n\
    \    STATUS      current\n    DESCRIPTION\n        \"Within the overall time period\
    \ specified in the\n        pmSchedTimePeriod object, the value of this object\
    \ specifies\n        the specific months within that time period when the schedule\n\
    \        is active.  Setting all bits will cause the schedule to act\n       \
    \ independently of the month.\"\n    DEFVAL { { january, february, march, april,\
    \ may, june, july,\n               august, september, october, november, december\
    \ } }\n    ::= { pmSchedEntry 5 }\n"
- title: pmSchedDay OBJECT-TYPE
  contents:
  - "pmSchedDay OBJECT-TYPE\n    SYNTAX      BITS {\n                    d1(0),  \
    \ d2(1),   d3(2),   d4(3),   d5(4),\n                    d6(5),   d7(6),   d8(7),\
    \   d9(8),   d10(9),\n                    d11(10), d12(11), d13(12), d14(13),\
    \ d15(14),\n                    d16(15), d17(16), d18(17), d19(18), d20(19),\n\
    \                    d21(20), d22(21), d23(22), d24(23), d25(24),\n          \
    \          d26(25), d27(26), d28(27), d29(28), d30(29),\n                    d31(30),\n\
    \                    r1(31),  r2(32),  r3(33),  r4(34),  r5(35),\n           \
    \         r6(36),  r7(37),  r8(38),  r9(39),  r10(40),\n                    r11(41),\
    \ r12(42), r13(43), r14(44), r15(45),\n                    r16(46), r17(47), r18(48),\
    \ r19(49), r20(50),\n                    r21(51), r22(52), r23(53), r24(54), r25(55),\n\
    \                    r26(56), r27(57), r28(58), r29(59), r30(60),\n          \
    \          r31(61)\n                }\n    MAX-ACCESS  read-create\n    STATUS\
    \      current\n    DESCRIPTION\n        \"Within the overall time period specified\
    \ in the\n        pmSchedTimePeriod object, the value of this object specifies\n\
    \        the specific days of the month within that time period when\n       \
    \ the schedule is active.\n        There are two sets of bits one can use to define\
    \ the day\n        within a month:\n        Enumerations starting with the letter\
    \ 'd' indicate a\n        day in a month relative to the first day of a month.\n\
    \        The first day of the month can therefore be specified\n        by setting\
    \ the bit d1(0), and d31(30) means the last\n        day of a month with 31 days.\n\
    \        Enumerations starting with the letter 'r' indicate a\n        day in\
    \ a month in reverse order, relative to the last\n        day of a month.  The\
    \ last day in the month can therefore\n        be specified by setting the bit\
    \ r1(31), and r31(61) means\n        the first day of a month with 31 days.\n\
    \        Setting multiple bits will include several days in the set\n        of\
    \ possible days for this schedule.  Setting all bits starting\n        with the\
    \ letter 'd' or all bits starting with the letter 'r'\n        will cause the\
    \ schedule to act independently of the day of the\n        month.\"\n    DEFVAL\
    \ { {  d1, d2, d3, d4, d5, d6, d7, d8, d9, d10,\n                d11, d12, d13,\
    \ d14, d15, d16, d17, d18, d19, d20,\n                d21, d22, d23, d24, d25,\
    \ d26, d27, d28, d29, d30,\n                d31, r1, r2, r3, r4, r5, r6, r7, r8,\
    \ r9, r10,\n                r11, r12, r13, r14, r15, r16, r17, r18, r19, r20,\n\
    \                r21, r22, r23, r24, r25, r26, r27, r28, r29, r30,\n         \
    \       r31 } }\n    ::= { pmSchedEntry 6 }\n"
- title: pmSchedWeekDay OBJECT-TYPE
  contents:
  - "pmSchedWeekDay OBJECT-TYPE\n    SYNTAX      BITS {\n                    sunday(0),\n\
    \                    monday(1),\n                    tuesday(2),\n           \
    \         wednesday(3),\n                    thursday(4),\n                  \
    \  friday(5),\n                    saturday(6)\n                }\n    MAX-ACCESS\
    \  read-create\n    STATUS      current\n    DESCRIPTION\n        \"Within the\
    \ overall time period specified in the\n        pmSchedTimePeriod object, the\
    \ value of this object specifies\n        the specific days of the week within\
    \ that time period when\n        the schedule is active.  Setting all bits will\
    \ cause the\n        schedule to act independently of the day of the week.\"\n\
    \    DEFVAL { { sunday, monday, tuesday, wednesday, thursday,\n              \
    \ friday, saturday } }\n    ::= { pmSchedEntry 7 }\n"
- title: pmSchedTimeOfDay OBJECT-TYPE
  contents:
  - "pmSchedTimeOfDay OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (0..15))\n \
    \   MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n      \
    \  \"Within the overall time period specified in the\n        pmSchedTimePeriod\
    \ object, the value of this object specifies\n        the range of times in a\
    \ day when the schedule is active.\n        This value is stored in a format based\
    \ on the RFC 2445 format\n        for 'time': The character 'T' followed by a\
    \ 'time' string,\n        followed by the solidus character, '/', followed by\
    \ the\n        character 'T', followed by a second time string.  The first time\n\
    \        indicates the beginning of the range, and the second time\n        indicates\
    \ the end.  Thus, this value takes the following\n        form:\n            'Thhmmss/Thhmmss'.\n\
    \        The second substring always identifies a later time than the\n      \
    \  first substring.  To allow for ranges that span midnight,\n        however,\
    \ the value of the second string may be smaller than\n        the value of the\
    \ first substring.  Thus, 'T080000/T210000'\n        identifies the range from\
    \ 0800 until 2100, whereas\n        'T210000/T080000' identifies the range from\
    \ 2100 until 0800 of\n        the following day.\n        When a range spans midnight,\
    \ by definition it includes parts\n        of two successive days.  When one of\
    \ these days is also\n        selected by either the MonthOfYearMask, DayOfMonthMask,\
    \ and/or\n        DayOfWeekMask, but the other day is not, then the policy is\n\
    \        active only during the portion of the range that falls on the\n     \
    \   selected day.  For example, if the range extends from 2100\n        until\
    \ 0800, and the day of week mask selects Monday and\n        Tuesday, then the\
    \ policy is active during the following three\n        intervals:\n          \
    \  From midnight Sunday until 0800 Monday\n            From 2100 Monday until\
    \ 0800 Tuesday\n            From 2100 Tuesday until 23:59:59 Tuesday\n       \
    \  Setting this value to 'T000000/T235959' will cause the\n         schedule to\
    \ act independently of the time of day.\"\n    DEFVAL { '543030303030302F54323335393539'H\
    \ } -- T000000/T235959\n    ::= { pmSchedEntry 8 }\n"
- title: pmSchedLocalOrUtc OBJECT-TYPE
  contents:
  - "pmSchedLocalOrUtc OBJECT-TYPE\n    SYNTAX      INTEGER {\n                  \
    \  localTime(1),\n                    utcTime(2)\n                }\n    MAX-ACCESS\
    \  read-create\n    STATUS      current\n    DESCRIPTION\n        \"This object\
    \ indicates whether the times represented in the\n        TimePeriod object and\
    \ in the various Mask objects represent\n        local times or UTC times.\"\n\
    \    DEFVAL { utcTime }\n    ::= { pmSchedEntry 9 }\n"
- title: pmSchedStorageType OBJECT-TYPE
  contents:
  - "pmSchedStorageType OBJECT-TYPE\n    SYNTAX      StorageType\n    MAX-ACCESS \
    \ read-create\n    STATUS      current\n    DESCRIPTION\n        \"This object\
    \ defines whether this schedule entry is kept\n         in volatile storage and\
    \ lost upon reboot or\n         backed up by non-volatile or permanent storage.\n\
    \         Conceptual rows having the value 'permanent' must allow write\n    \
    \     access to the columnar objects pmSchedDescr, pmSchedWeekDay,\n         pmSchedMonth,\
    \ and pmSchedDay.\n         If the value of this object is 'permanent', no values\
    \ in the\n         associated row have to be writable.\"\n    DEFVAL { volatile\
    \ }\n    ::= { pmSchedEntry 10 }\n"
- title: pmSchedRowStatus OBJECT-TYPE
  contents:
  - "pmSchedRowStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS  read-create\n\
    \    STATUS      current\n    DESCRIPTION\n        \"The status of this schedule\
    \ entry.\n         If the value of this object is active, no object in this row\n\
    \         may be modified.\"\n    ::= { pmSchedEntry 11 }\n"
- title: -- Policy Tracking
  contents:
  - '-- Policy Tracking

    '
- title: -- The "policy to element" (PE) table and the "element to policy" (EP)
  contents:
  - '-- The "policy to element" (PE) table and the "element to policy" (EP)

    '
- title: -- table track the status of execution contexts grouped by policy and
  contents:
  - '-- table track the status of execution contexts grouped by policy and

    '
- title: -- element respectively.
  contents:
  - '-- element respectively.

    '
- title: pmTrackingPETable OBJECT-TYPE
  contents:
  - "pmTrackingPETable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmTrackingPEEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \       \"The pmTrackingPETable describes what elements\n         are active (under\
    \ control of) a policy.  This table is indexed\n         in order to optimize\
    \ retrieval of the entire status for a\n         given policy.\"\n    ::= { pmMib\
    \ 9 }\n"
- title: pmTrackingPEEntry OBJECT-TYPE
  contents:
  - "pmTrackingPEEntry OBJECT-TYPE\n    SYNTAX      PmTrackingPEEntry\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"An entry\
    \ in the pmTrackingPETable.  The pmPolicyIndex in\n         the index specifies\
    \ the policy tracked by this entry.\n         Note that some combinations of index\
    \ values may result in an\n         instance name that exceeds a length of 128\
    \ sub-identifiers,\n         which exceeds the maximum for the SNMP\n        \
    \ protocol.  Implementations should take care to avoid such\n         combinations.\"\
    \n    INDEX       { pmPolicyIndex, pmTrackingPEElement,\n                  pmTrackingPEContextName,\
    \ pmTrackingPEContextEngineID }\n    ::= { pmTrackingPETable 1 }\n"
- title: PmTrackingPEEntry ::= SEQUENCE {
  contents:
  - "PmTrackingPEEntry ::= SEQUENCE {\n    pmTrackingPEElement          RowPointer,\n\
    \    pmTrackingPEContextName      SnmpAdminString,\n    pmTrackingPEContextEngineID\
    \  OCTET STRING,\n    pmTrackingPEInfo             BITS\n"
- title: '}'
  contents:
  - '}

    '
- title: pmTrackingPEElement OBJECT-TYPE
  contents:
  - "pmTrackingPEElement OBJECT-TYPE\n    SYNTAX      RowPointer\n    MAX-ACCESS \
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"The element\
    \ that is acted upon by the associated policy.\n         As this object is used\
    \ in the index for the\n         pmTrackingPETable, users of this table should\
    \ be careful not\n         to create entries that would result in instance names\
    \ with\n         more than 128 sub-identifiers.\"\n    ::= { pmTrackingPEEntry\
    \ 1 }\n"
- title: pmTrackingPEContextName OBJECT-TYPE
  contents:
  - "pmTrackingPEContextName OBJECT-TYPE\n    SYNTAX      SnmpAdminString (SIZE (0..32))\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"If the associated element is not in the default SNMP context\n      \
    \  for the target system, this object is used to identify the\n        context.\
    \  If the element is in the default context, this object\n        is equal to\
    \ the empty string.\"\n    ::= { pmTrackingPEEntry 2 }\n"
- title: pmTrackingPEContextEngineID OBJECT-TYPE
  contents:
  - "pmTrackingPEContextEngineID OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0\
    \ | 5..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n\
    \        \"If the associated element is on a remote system, this object\n    \
    \    is used to identify the remote system.  This object contains\n        the\
    \ contextEngineID of the system on which the associated\n        element resides.\
    \  If the element is on the local system,\n        this object will be the empty\
    \ string.\"\n    ::= { pmTrackingPEEntry 3 }\n"
- title: pmTrackingPEInfo OBJECT-TYPE
  contents:
  - "pmTrackingPEInfo OBJECT-TYPE\n    SYNTAX      BITS {\n                    actionSkippedDueToPrecedence(0),\n\
    \                    conditionRunTimeException(1),\n                    conditionUserSignal(2),\n\
    \                    actionRunTimeException(3),\n                    actionUserSignal(4)\n\
    \                }\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n\
    \         \"This object returns information about the previous policy\n      \
    \   script executions.\n         If the actionSkippedDueToPrecedence(1) bit is\
    \ set, the last\n         execution of the associated policy condition returned\
    \ non-zero,\n         but the action is not active, because it was trumped by\
    \ a\n         matching policy condition in the same precedence group with a\n\
    \         higher precedence value.\n         If the conditionRunTimeException(2)\
    \ bit is set, the last\n         execution of the associated policy condition\
    \ encountered a\n         run-time exception and aborted.\n         If the conditionUserSignal(3)\
    \ bit is set, the last\n         execution of the associated policy condition\
    \ called the\n         signalError() function.\n         If the actionRunTimeException(4)\
    \ bit is set, the last\n         execution of the associated policy action encountered\
    \ a\n         run-time exception and aborted.\n         If the actionUserSignal(5)\
    \ bit is set, the last\n         execution of the associated policy action called\
    \ the\n         signalError() function.\n         Entries will only exist in this\
    \ table of one or more bits are\n         set.  In particular, if an entry does\
    \ not exist for a\n         particular policy/element combination, it can be assumed\
    \ that\n         the policy's condition did not match 'this element'.\"\n    ::=\
    \ { pmTrackingPEEntry 4 }\n"
- title: -- Element to Policy Table
  contents:
  - '-- Element to Policy Table

    '
- title: pmTrackingEPTable OBJECT-TYPE
  contents:
  - "pmTrackingEPTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmTrackingEPEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \       \"The pmTrackingEPTable describes what policies\n         are controlling\
    \ an element.  This table is indexed in\n         order to optimize retrieval\
    \ of the status of all policies\n         active for a given element.\"\n    ::=\
    \ { pmMib 10 }\n"
- title: pmTrackingEPEntry OBJECT-TYPE
  contents:
  - "pmTrackingEPEntry OBJECT-TYPE\n    SYNTAX      PmTrackingEPEntry\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"An entry\
    \ in the pmTrackingEPTable.  Entries exist for all\n         element/policy combinations\
    \ for which the policy's condition\n         matches and only if the schedule\
    \ for the policy is active.\n         The pmPolicyIndex in the index specifies\
    \ the policy\n         tracked by this entry.\n         Note that some combinations\
    \ of index values may result in an\n         instance name that exceeds a length\
    \ of 128 sub-identifiers,\n         which exceeds the maximum for the SNMP protocol.\n\
    \         Implementations should take care to avoid such combinations.\"\n   \
    \ INDEX       { pmTrackingEPElement, pmTrackingEPContextName,\n              \
    \    pmTrackingEPContextEngineID, pmPolicyIndex }\n    ::= { pmTrackingEPTable\
    \ 1 }\n"
- title: PmTrackingEPEntry ::= SEQUENCE {
  contents:
  - "PmTrackingEPEntry ::= SEQUENCE {\n    pmTrackingEPElement          RowPointer,\n\
    \    pmTrackingEPContextName      SnmpAdminString,\n    pmTrackingEPContextEngineID\
    \  OCTET STRING,\n    pmTrackingEPStatus           INTEGER\n"
- title: '}'
  contents:
  - '}

    '
- title: pmTrackingEPElement OBJECT-TYPE
  contents:
  - "pmTrackingEPElement OBJECT-TYPE\n    SYNTAX      RowPointer\n    MAX-ACCESS \
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"The element\
    \ acted upon by the associated policy.\n         As this object is used in the\
    \ index for the\n         pmTrackingEPTable, users of this table should be careful\n\
    \         not to create entries that would result in instance names\n        \
    \ with more than 128 sub-identifiers.\"\n    ::= { pmTrackingEPEntry 1 }\n"
- title: pmTrackingEPContextName OBJECT-TYPE
  contents:
  - "pmTrackingEPContextName OBJECT-TYPE\n    SYNTAX      SnmpAdminString (SIZE (0..32))\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"If the associated element is not in the default SNMP context\n      \
    \  for the target system, this object is used to identify the\n        context.\
    \  If the element is in the default context, this object\n        is equal to\
    \ the empty string.\"\n    ::= { pmTrackingEPEntry 2 }\n"
- title: pmTrackingEPContextEngineID OBJECT-TYPE
  contents:
  - "pmTrackingEPContextEngineID OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0\
    \ | 5..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n\
    \        \"If the associated element is on a remote system, this object\n    \
    \    is used to identify the remote system.  This object contains\n        the\
    \ contextEngineID of the system on which the associated\n        element resides.\
    \  If the element is on the local system,\n        this object will be the empty\
    \ string.\"\n    ::= { pmTrackingEPEntry 3 }\n"
- title: pmTrackingEPStatus OBJECT-TYPE
  contents:
  - "pmTrackingEPStatus OBJECT-TYPE\n    SYNTAX      INTEGER {\n                 \
    \   on(1),\n                    forceOff(2)\n                }\n    MAX-ACCESS\
    \  read-write\n    STATUS      current\n    DESCRIPTION\n         \"This entry\
    \ will only exist if the calendar for the policy is\n         active and if the\
    \ associated policyCondition returned 1 for\n         'this element'.\n      \
    \   A policy can be forcibly disabled on a particular element\n         by setting\
    \ this value to forceOff(2).  The agent should then\n         act as though the\
    \ policyCondition failed for 'this element'.\n         The forceOff(2) state will\
    \ persist (even across reboots) until\n         this value is set to on(1) by\
    \ a management request.  The\n         forceOff(2) state may be set even if the\
    \ entry does not\n         previously exist so that future policy invocations\
    \ can be\n         avoided.\n         Unless forcibly disabled, if this entry\
    \ exists, its value\n         will be on(1).\"\n    ::= { pmTrackingEPEntry 4\
    \ }\n"
- title: -- Policy Debugging Table
  contents:
  - '-- Policy Debugging Table

    '
- title: pmDebuggingTable OBJECT-TYPE
  contents:
  - "pmDebuggingTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmDebuggingEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \       \"Policies that have debugging turned on will generate a log\n       \
    \  entry in the policy debugging table for every runtime\n         exception that\
    \ occurs in either the condition or action\n         code.\n         The pmDebuggingTable\
    \ logs debugging messages when\n         policies experience run-time exceptions\
    \ in either the condition\n         or action code and the associated pmPolicyDebugging\
    \ object\n         has been turned on.\n         The maximum number of debugging\
    \ entries that will be stored\n         and the maximum length of time an entry\
    \ will be kept are an\n         implementation-dependent manner.  If entries must\n\
    \         be discarded to make room for new entries, the oldest entries\n    \
    \     must be discarded first.\n         If the system restarts, all debugging\
    \ entries may be deleted.\"\n    ::= { pmMib 11 }\n"
- title: pmDebuggingEntry OBJECT-TYPE
  contents:
  - "pmDebuggingEntry OBJECT-TYPE\n    SYNTAX      PmDebuggingEntry\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"An entry\
    \ in the pmDebuggingTable.  The pmPolicyIndex in the\n         index specifies\
    \ the policy that encountered the exception\n         that led to this log entry.\n\
    \         Note that some combinations of index values may result in an\n     \
    \    instance name that exceeds a length of 128 sub-identifiers,\n         which\
    \ exceeds the maximum for the SNMP protocol.\n         Implementations should\
    \ take care to avoid such combinations.\"\n    INDEX       { pmPolicyIndex, pmDebuggingElement,\n\
    \                  pmDebuggingContextName, pmDebuggingContextEngineID,\n     \
    \             pmDebuggingLogIndex }\n    ::= { pmDebuggingTable 1 }\n"
- title: PmDebuggingEntry ::= SEQUENCE {
  contents:
  - "PmDebuggingEntry ::= SEQUENCE {\n    pmDebuggingElement          RowPointer,\n\
    \    pmDebuggingContextName      SnmpAdminString,\n    pmDebuggingContextEngineID\
    \  OCTET STRING,\n    pmDebuggingLogIndex         Unsigned32,\n    pmDebuggingMessage\
    \          PmUTF8String\n"
- title: '}'
  contents:
  - '}

    '
- title: pmDebuggingElement OBJECT-TYPE
  contents:
  - "pmDebuggingElement OBJECT-TYPE\n    SYNTAX      RowPointer\n    MAX-ACCESS  not-accessible\n\
    \    STATUS      current\n    DESCRIPTION\n         \"The element the policy was\
    \ executing on when it encountered\n         the error that led to this log entry.\n\
    \         For example, if the element is interface 3, then this object\n     \
    \    will contain the OID for 'ifIndex.3'.\n         As this object is used in\
    \ the index for the\n         pmDebuggingTable, users of this table should be\
    \ careful\n         not to create entries that would result in instance names\n\
    \         with more than 128 sub-identifiers.\"\n    ::= { pmDebuggingEntry 1\
    \ }\n"
- title: pmDebuggingContextName OBJECT-TYPE
  contents:
  - "pmDebuggingContextName OBJECT-TYPE\n    SYNTAX      SnmpAdminString (SIZE (0..32))\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"If the associated element is not in the default SNMP context\n      \
    \  for the target system, this object is used to identify the\n        context.\
    \  If the element is in the default context, this object\n        is equal to\
    \ the empty string.\"\n    ::= { pmDebuggingEntry 2 }\n"
- title: pmDebuggingContextEngineID OBJECT-TYPE
  contents:
  - "pmDebuggingContextEngineID OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0\
    \ | 5..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n\
    \        \"If the associated element is on a remote system, this object\n    \
    \    is used to identify the remote system.  This object contains\n        the\
    \ contextEngineID of the system on which the associated\n        element resides.\
    \  If the element is on the local system,\n        this object will be the empty\
    \ string.\"\n    ::= { pmDebuggingEntry 3 }\n"
- title: pmDebuggingLogIndex OBJECT-TYPE
  contents:
  - "pmDebuggingLogIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \       \"A unique index for this log entry among other log entries\n        \
    \ for this policy/element combination.\"\n    ::= { pmDebuggingEntry 4 }\n"
- title: pmDebuggingMessage OBJECT-TYPE
  contents:
  - "pmDebuggingMessage OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (0..128))\n\
    \    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n       \
    \  \"An error message generated by the policy execution\n         environment.\
    \  It is recommended that this message include the\n         time of day when\
    \ the message was generated, if known.\"\n    ::= { pmDebuggingEntry 5 }\n"
- title: -- Notifications
  contents:
  - '-- Notifications

    '
- title: pmNotifications OBJECT IDENTIFIER ::= { pmMib 0 }
  contents:
  - 'pmNotifications OBJECT IDENTIFIER ::= { pmMib 0 }

    '
- title: pmNewRoleNotification NOTIFICATION-TYPE
  contents:
  - "pmNewRoleNotification NOTIFICATION-TYPE\n    OBJECTS     { pmRoleStatus }\n \
    \   STATUS      current\n    DESCRIPTION\n        \"The pmNewRoleNotification\
    \ is sent when an agent is configured\n        with its first instance of a previously\
    \ unused role string\n        (not every time a new element is given a particular\
    \ role).\n        An instance of the pmRoleStatus object is sent containing\n\
    \        the new roleString in its index.  In the event that two or\n        more\
    \ elements are given the same role simultaneously, it is an\n        implementation-dependent\
    \ matter as to which pmRoleTable\n        instance will be included in the notification.\"\
    \n    ::= { pmNotifications 1 }\n"
- title: pmNewCapabilityNotification NOTIFICATION-TYPE
  contents:
  - "pmNewCapabilityNotification NOTIFICATION-TYPE\n    OBJECTS     { pmCapabilitiesType\
    \ }\n    STATUS      current\n    DESCRIPTION\n        \"The pmNewCapabilityNotification\
    \ is sent when an agent\n        gains a new capability that did not previously\
    \ exist in any\n        element on the system (not every time an element gains\
    \ a\n        particular capability).\n        An instance of the pmCapabilitiesType\
    \ object is sent containing\n        the identity of the new capability.  In the\
    \ event that two or\n        more elements gain the same capability simultaneously,\
    \ it is an\n        implementation-dependent matter as to which pmCapabilitiesType\n\
    \        instance will be included in the notification.\"\n    ::= { pmNotifications\
    \ 2 }\n"
- title: pmAbnormalTermNotification NOTIFICATION-TYPE
  contents:
  - "pmAbnormalTermNotification NOTIFICATION-TYPE\n    OBJECTS     { pmTrackingPEInfo\
    \ }\n    STATUS      current\n    DESCRIPTION\n        \"The pmAbnormalTermNotification\
    \ is sent when a policy's\n        pmPolicyAbnormalTerminations gauge value changes\
    \ from zero to\n        any value greater than zero and no such notification has\
    \ been\n        sent for that policy in the last 5 minutes.\n        The notification\
    \ contains an instance of the pmTrackingPEInfo\n        object where the pmPolicyIndex\
    \ component of the index\n        identifies the associated policy and the rest\
    \ of the index\n        identifies an element on which the policy failed.\"\n\
    \    ::= { pmNotifications 3 }\n"
- title: -- Compliance Statements
  contents:
  - "-- Compliance Statements\n    pmConformance   OBJECT IDENTIFIER ::= { pmMib 12\
    \ }\n    pmCompliances   OBJECT IDENTIFIER ::= { pmConformance 1 }\n    pmGroups\
    \        OBJECT IDENTIFIER ::= { pmConformance 2 }\n"
- title: pmCompliance MODULE-COMPLIANCE
  contents:
  - "pmCompliance MODULE-COMPLIANCE\n    STATUS  current\n    DESCRIPTION\n      \
    \  \"Describes the requirements for conformance to\n        the Policy-Based Management\
    \ MIB\"\n    MODULE  -- this module\n        MANDATORY-GROUPS { pmPolicyManagementGroup,\
    \ pmSchedGroup,\n                           pmNotificationGroup }\n    ::= { pmCompliances\
    \ 1 }\n"
- title: pmPolicyManagementGroup OBJECT-GROUP
  contents:
  - "pmPolicyManagementGroup OBJECT-GROUP\n    OBJECTS { pmPolicyPrecedenceGroup,\
    \ pmPolicyPrecedence,\n              pmPolicySchedule, pmPolicyElementTypeFilter,\n\
    \              pmPolicyConditionScriptIndex, pmPolicyActionScriptIndex,\n    \
    \          pmPolicyParameters,\n              pmPolicyConditionMaxLatency, pmPolicyActionMaxLatency,\n\
    \              pmPolicyMaxIterations,\n              pmPolicyDescription, pmPolicyMatches,\n\
    \              pmPolicyAbnormalTerminations,\n              pmPolicyExecutionErrors,\
    \ pmPolicyDebugging,\n              pmPolicyStorageType, pmPolicyAdminStatus,\n\
    \              pmPolicyRowStatus, pmPolicyCodeText, pmPolicyCodeStatus,\n    \
    \          pmElementTypeRegMaxLatency, pmElementTypeRegDescription,\n        \
    \      pmElementTypeRegStorageType, pmElementTypeRegRowStatus,\n             \
    \ pmRoleStatus,\n              pmCapabilitiesType, pmCapabilitiesOverrideState,\n\
    \              pmCapabilitiesOverrideRowStatus,\n              pmTrackingPEInfo,\n\
    \              pmTrackingEPStatus,\n              pmDebuggingMessage }\n    STATUS\
    \  current\n    DESCRIPTION\n        \"Objects that allow for the creation and\
    \ management of\n        configuration policies.\"\n    ::=  { pmGroups 1 }\n"
- title: pmSchedGroup OBJECT-GROUP
  contents:
  - "pmSchedGroup OBJECT-GROUP\n    OBJECTS { pmSchedLocalTime, pmSchedGroupIndex,\n\
    \              pmSchedDescr, pmSchedTimePeriod,\n              pmSchedMonth, pmSchedDay,\
    \ pmSchedWeekDay,\n              pmSchedTimeOfDay, pmSchedLocalOrUtc, pmSchedStorageType,\n\
    \              pmSchedRowStatus\n            }\n    STATUS current\n    DESCRIPTION\n\
    \        \"Objects that allow for the scheduling of policies.\"\n    ::= { pmGroups\
    \ 2 }\n"
- title: pmNotificationGroup NOTIFICATION-GROUP
  contents:
  - "pmNotificationGroup NOTIFICATION-GROUP\n    NOTIFICATIONS { pmNewRoleNotification,\n\
    \                    pmNewCapabilityNotification,\n                    pmAbnormalTermNotification\
    \ }\n    STATUS        current\n    DESCRIPTION\n        \"Notifications sent\
    \ by an Policy MIB agent.\"\n    ::= { pmGroups 3 }\n"
- title: pmBaseFunctionLibrary OBJECT IDENTIFIER ::= { pmGroups 4 }
  contents:
  - 'pmBaseFunctionLibrary OBJECT IDENTIFIER ::= { pmGroups 4 }

    '
- title: END
  contents:
  - 'END

    '
- title: 12.  Relationship to Other MIB Modules
  contents:
  - "12.  Relationship to Other MIB Modules\n   When policy-based management is used\
    \ specifically for (policy-based)\n   configuration, the \"Configuring Networks\
    \ and Devices With SNMP\" RFC\n   3512 [19] document describes configuration management\
    \ practices,\n   terminology, and an example of a MIB Module that may be helpful\
    \ to\n   those developing and using this technology.\n   The Policy MIB accesses\
    \ system instrumentation for the purposes of\n   policy evaluation, control, notification,\
    \ monitoring, and error\n   reporting.  This information is available to managers\
    \ in the form of\n   MIB objects.  Information about system configuration is modified\
    \ by\n   the Policy MIB through MIB objects defined in other MIB Modules.\n  \
    \ Details about the operational or configuration details of a system\n   are retrieved\
    \ by the manager via access to the specific MIB objects\n   available in a network\
    \ element.  As such, the Policy MIB can use any\n   standard or vendor-defined\
    \ object that exists on a managed system.\n   In particular, the Policy MIB may\
    \ access standard or vendor specific\n   objects that are instance-specific such\
    \ as BGP timeout parameters and\n   specific interface counters.\n"
- title: 13.  Security Considerations
  contents:
  - "13.  Security Considerations\n   This MIB contains no objects for which read\
    \ access would disclose\n   sensitive information.\n   There are a number of management\
    \ objects defined in this MIB that\n   have a MAX-ACCESS clause of read-write\
    \ and/or read-create.  Such\n   objects may be considered sensitive or vulnerable\
    \ in some network\n   environments.  The support for SET operations in a non-secure\n\
    \   environment without proper protection can have a negative effect on\n   network\
    \ operations.\n   With the exception of pmPolicyDescription, pmPolicyDebugging,\n\
    \   pmElementTypeRegDescription, and pmSchedDescr, EVERY read-create and\n   read-write\
    \ object in this MIB should be considered sensitive because\n   if an unauthorized\
    \ user could manipulate these objects, s/he could\n   cause the Policy MIB system\
    \ to use the stored credentials of an\n   authorized user to perform unauthorized\
    \ and potentially harmful\n   operations.\n   There are no read-only objects in\
    \ this MIB that contain sensitive\n   information.\n   SNMP versions prior to\
    \ SNMPv3 did not include adequate security.\n   Even if the network itself is\
    \ secure (for example by using IPSec),\n   even then, there is no control as to\
    \ who on the secure network is\n   allowed to access and GET/SET (read/change/create/delete)\
    \ the objects\n   in this MIB module.\n   It is RECOMMENDED that implementers\
    \ consider the security features as\n   provided by the SNMPv3 framework (see\
    \ [16], section 8), including\n   full support for the SNMPv3 cryptographic mechanisms\
    \ (for\n   authentication and privacy).\n   Further, deployment of SNMP versions\
    \ prior to SNMPv3 is NOT\n   RECOMMENDED.  Instead, it is RECOMMENDED to deploy\
    \ SNMPv3 and to\n   enable cryptographic security.  It is then a customer/operator\n\
    \   responsibility to ensure that the SNMP entity giving access to an\n   instance\
    \ of this MIB module is properly configured to give access to\n   the objects\
    \ only to those principals (users) that have legitimate\n   rights to indeed GET\
    \ or SET (change/create/delete) them.\n   An implementation must ensure that access\
    \ control rules are applied\n   when SNMP operations are performed in policy scripts.\
    \  To ensure\n   this, an implementation must record and maintain the security\n\
    \   credentials of the last entity to modify each policy's\n   pmPolicyAdminStatus\
    \ object.  The credentials to store are the\n   securityModel, securityName, and\
    \ securityLevel and will be used as\n   input parameters for isAccessAllowed from\
    \ the Architecture for\n   Describing SNMP Management Frameworks [1].  This mechanism\
    \ was first\n   introduced in the DISMAN-SCHEDULE-MIB [12].\n   SNMP requests\
    \ made when secModel, secName, and secLevel are specified\n   use credentials\
    \ stored in the local configuration datastore.  Access\n   to these credentials\
    \ depends on the security credentials of the last\n   entity to modify the policy's\
    \ pmPolicyAdminStatus object.  To\n   determine whether the credentials can be\
    \ accessed, the\n   isAccessAllowed abstract service interface defined in RFC\
    \ 3411 [1] is\n   called:\n      statusInformation =          -- success or errorIndication\n\
    \        isAccessAllowed(\n        IN   securityModel         -- Security Model\
    \ used\n        IN   securityName          -- principal who wants to access\n\
    \        IN   securityLevel         -- Level of Security used\n        IN   viewType\
    \              -- write\n        IN   contextName           -- context containing\
    \ variableName\n        IN   variableName          -- OID for an object in the\
    \ proper\n                                   -- LCD entry\n             )\n  \
    \    The securityModel, securityName, and securityLevel parameters are\n     \
    \ set to the values that were recorded when the policy was modified.\n      The\
    \ viewType is set to write, and the contextName and variableName\n      are set\
    \ to select any read-create object in the appropriate LCD\n      entry.\n   Proper\
    \ configuration of VACM requires that write access to an LCD\n   entry not be\
    \ given to entities that aren't authorized to use the\n   credentials therein.\n\
    \   Access control for SNMP requests made to the local system where\n   secModel,\
    \ secName, and secLevel aren't specified depends on the\n   security credentials\
    \ of the last entity to modify the policy's\n   pmPolicyAdminStatus object.  To\
    \ determine whether the operation\n   should succeed, the isAccessAllowed abstract\
    \ service interface\n   defined in RFC 3411 [1] is called:\n      statusInformation\
    \ =          -- success or errorIndication\n        isAccessAllowed(\n       \
    \ IN   securityModel         -- Security Model in use\n        IN   securityName\
    \          -- principal who wants to access\n        IN   securityLevel      \
    \   -- Level of Security\n        IN   viewType              -- read, write, or\
    \ notify view\n        IN   contextName           -- context as specified\n  \
    \      IN   variableName          -- OID for the managed object\n            \
    \ )\n      The securityModel, securityName, and securityLevel parameters are\n\
    \      set to the values that were recorded when the policy was modified.\n  \
    \    The viewType, contextName, and variableName parameters are set as\n     \
    \ appropriate for the requested SNMP operation.\n   Unless all users who have\
    \ write access to the pmPolicyTable and\n   pmPolicyCodeTable have equivalent\
    \ access to the managed system,\n   policy scripts could be used by a user to\
    \ gain the privileges of\n   another user.  Therefore, when policy users have\
    \ different access,\n   access control should be applied so that a user's policies\
    \ cannot be\n   modified by another user.  To make this more convenient, a user\
    \ can\n   place all of his or her policies in the same pmPolicyAdminGroup so\n\
    \   that a single access control view can apply to all of them.\n   Some policies\
    \ may be designed to ensure the security of a network.\n   If these policies have\
    \ not been installed pending the appearance of a\n   role or capability, some\
    \ delay will occur in their activation\n   policies when the role or capability\
    \ appears because a responsible\n   manager must notice the change and install\
    \ the policy.  This delay\n   may expose the device or the network to unacceptable\
    \ security\n   vulnerabilities during this delay.  If the role or capability appears\n\
    \   during a time of network stress or when the management station is\n   unavailable,\
    \ this delay could be extensive, further increasing the\n   exposure.  It is recommended\
    \ that management stations install any\n   security-related policies that might\
    \ ever be needed on a particular\n   managed device, even if a nonexistent role\
    \ or capability suggests\n   that it is not needed at a given time.\n   This MIB\
    \ allows the delegation of access rights so that a user\n   (\"Joe\") can instruct\
    \ a Policy MIB agent to execute remote operations\n   on his behalf that are authorized\
    \ by keys stored by \"Joe\" into the\n   usmUserTable.  Care needs to be taken\
    \ to ensure that unauthorized\n   users are unable to configure their policies\
    \ to use Joe's keys.\n   Although there are theoretically many ways to configure\
    \ SNMP\n   security, users are advised to follow the most straightforward way\n\
    \   outlined below to minimize complexity and the resulting opportunity\n   for\
    \ errors.\n      Assume that Joe has credentials that give him authority to manage\n\
    \      agents A, B, and C, as well as the Policy MIB agent \"P\".  Joe will\n\
    \      store credentials for Joe@A, Joe@B, and Joe@C in the usmUserTable\n   \
    \   of the Policy MIB agent.  Then the following VACM configuration\n      will\
    \ be used:\n         VACM securityToGroupTable\n         A single entry mapping\
    \ user Joe@P to group JoesGroup\n         VACM accessTable\n         A single\
    \ entry mapping group JoesGroup to write view JoesView\n         VACM viewTreeFamilyTable\n\
    \         ViewName        Subtree                             Type\n         JoesView\
    \        points to Joe@A in usmUserTable     included\n         JoesView     \
    \   points to Joe@B in usmUserTable     included\n         JoesView        points\
    \ to Joe@C in usmUserTable     included\n      In the preceding examples, the\
    \ notation Joe@A represents the entry\n      indexed by usmUserEngineID and usmUserName,\
    \ where the SnmpEngineID\n      is that of system A and the usmUserName is \"\
    Joe\".\n"
- title: 14.  IANA Considerations
  contents:
  - "14.  IANA Considerations\n   This is a profile of stringprep.  It has been registered\
    \ by the IANA\n   in the stringprep profile registry located at:\n      http://www.iana.org/assignments/stringprep-profiles\n\
    \      Name of this profile:\n         Policy MIB Stringprep.\n      RFC in which\
    \ the profile is defined:\n         This document.\n         Indicator whether\
    \ this is the newest version of the profile:\n            This is the first version\
    \ of Policy MIB Stringprep.\n"
- title: 15.  Acknowledgements
  contents:
  - "15.  Acknowledgements\n   The authors gratefully acknowledge the significant\
    \ contributions to\n   this work made by Jeff Case, Patrik Falstrom, Joel Halpern,\
    \ Pablo\n   Halpern, Bob Moore, Steve Moulton, David Partain, and Walter Weiss.\n\
    \   This MIB uses a security delegation mechanism that was first\n   introduced\
    \ in the DISMAN-SCHEDULE-MIB [12].  The Schedule table of\n   this MIB borrows\
    \ heavily from the PolicyTimePeriodCondition of the\n   Policy Core Information\
    \ Model (PCIM) [18] and from the DISMAN-\n   SCHEDULE-MIB [12].\n"
- title: 16.  References
  contents:
  - '16.  References

    '
- title: 16.1.  Normative References
  contents:
  - "16.1.  Normative References\n   [1]  Harrington, D., Presuhn, R., and B. Wijnen,\
    \ \"An Architecture for\n        Describing Simple Network Management Protocol\
    \ (SNMP) Management\n        Frameworks\", STD 62, RFC 3411, December 2002.\n\
    \   [2]  McCloghrie, K., Perkins, D., and J. Schoenwaelder, \"Structure of\n \
    \       Management Information Version 2 (SMIv2)\", STD 58, RFC 2578,\n      \
    \  April 1999.\n   [3]  McCloghrie, K., Perkins, D., and J. Schoenwaelder, \"\
    Textual\n        Conventions for SMIv2\", STD 58, RFC 2579, April 1999.\n   [4]\
    \  McCloghrie, K., Perkins, D., and J. Schoenwaelder, \"Conformance\n        Statements\
    \ for SMIv2\", STD 58, RFC 2580, April 1999.\n   [5]  Presuhn, R., \"Transport\
    \ Mappings for the Simple Network\n        Management Protocol (SNMP)\", STD 62,\
    \ RFC 3417, December 2002.\n   [6]  Blumenthal, U. and B. Wijnen, \"User-based\
    \ Security Model (USM)\n        for version 3 of the Simple Network Management\
    \ Protocol\n        (SNMPv3)\", STD 62, RFC 3414, December 2002.\n   [7]  Presuhn,\
    \ R., \"Version 2 of the Protocol Operations for the\n        Simple Network Management\
    \ Protocol (SNMP)\", STD 62, RFC 3416,\n        December 2002.\n   [8]  Frye,\
    \ R., Levi, D., Routhier, S., and B. Wijnen, \"Coexistence\n        between Version\
    \ 1, Version 2, and Version 3 of the Internet-\n        standard Network Management\
    \ Framework\", BCP 74, RFC 3584, August\n        2003.\n   [9]  Wijnen, B., Presuhn,\
    \ R., and K. McCloghrie, \"View-based Access\n        Control Model (VACM) for\
    \ the Simple Network Management Protocol\n        (SNMP)\", STD 62, RFC 3415,\
    \ December 2002.\n   [10] International Standards Organization, \"Information\
    \ Technology -\n        Programming Languages - C++\", ISO/IEC 14882-1998\n  \
    \ [11] Daniele, M. and J. Schoenwaelder, \"Textual Conventions for\n        Transport\
    \ Addresses\", RFC 3419, December 2002.\n   [12] Levi, D. and J. Schoenwaelder,\
    \ \"Definitions of Managed Objects\n        for Scheduling Management Operations\"\
    , RFC 3231, January 2002.\n   [13] Hoffman, P. and M. Blanchet, \"Preparation\
    \ of Internationalized\n        Strings (\"stringprep\")\", RFC 3454, December\
    \ 2002.\n   [14] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\"\
    , STD\n        63, RFC 3629, November 2003.\n   [15] Dawson, F. and D. Stenerson,\
    \ \"Internet Calendaring and\n        Scheduling Core Object Specification (iCalendar)\"\
    , RFC 2445,\n        November 1998.\n"
- title: 16.2.  Informative References
  contents:
  - "16.2.  Informative References\n   [16] Case, J., Mundy, R., Partain, D., and\
    \ B. Stewart, \"Introduction\n        and Applicability Statements for Internet-Standard\
    \ Management\n        Framework\", RFC 3410, December 2002.\n   [17] ECMA, \"\
    ECMAScript Language Specification\", ECMA-262, December\n        1999\n   [18]\
    \ Moore, B., Ellesson, E., Strassner, J., and A. Westerinen,\n        \"Policy\
    \ Core Information Model -- Version 1 Specification\", RFC\n        3060, February\
    \ 2001.\n   [19] MacFaden, M., Partain, D., Saperia, J., and W. Tackabury,\n \
    \       \"Configuring Networks and Devices with Simple Network Management\n  \
    \      Protocol (SNMP)\", RFC 3512, April 2003.\n"
- title: Author's Addresses
  contents:
  - "Author's Addresses\n   Steve Waldbusser\n   Phone: +1-650-948-6500\n   Fax: \
    \  +1-650-745-0671\n   EMail: waldbusser@nextbeacon.com\n   Jon Saperia (WG Co-chair)\n\
    \   JDS Consulting, Inc.\n   84 Kettell Plain Road.\n   Stow MA 01775\n   USA\n\
    \   Phone: +1-978-461--0249\n   Fax:   +1-617-249-0874\n   EMail: saperia@jdscons.com\n\
    \   Thippanna Hongal\n   Riverstone Networks, Inc.\n   5200 Great America Parkway\n\
    \   Santa Clara, CA, 95054\n   USA\n   Phone: +1-408-878-6562\n   Fax:   +1-408-878-6501\n\
    \   EMail: hongal@riverstonenet.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
