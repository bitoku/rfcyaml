- title: __initial_text__
  contents:
  - ''
- title: Internet Architecture Board (IAB)                            J. Peterson
  contents:
  - "Internet Architecture Board (IAB)                            J. Peterson\n  \
    \  Architectural Considerations on Application Features in the DNS\n"
- title: Abstract
  contents:
  - "Abstract\n   A number of Internet applications rely on the Domain Name System\n\
    \   (DNS) to support their operations.  Many applications use the DNS to\n   locate\
    \ services for a domain; some, for example, transform\n   identifiers other than\
    \ domain names into formats that the DNS can\n   process, and then fetch application\
    \ data or service location data\n   from the DNS.  Proposals incorporating sophisticated\
    \ application\n   behavior using DNS as a substrate have raised questions about\
    \ the\n   role of the DNS as an application platform.  This document explores\n\
    \   the architectural consequences of using the DNS to implement certain\n   application\
    \ features, and it provides guidance to future application\n   designers as to\
    \ the limitations of the DNS as a substrate and the\n   situations in which alternative\
    \ designs should be considered.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Architecture Board (IAB)\n   and represents information that\
    \ the IAB has deemed valuable to\n   provide for permanent record.  It represents\
    \ the consensus of the\n   Internet Architecture Board (IAB).  Documents approved\
    \ for\n   publication by the IAB are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6950.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Motivation ......................................................2\n\
    \   2. Overview of DNS Application Usages ..............................4\n  \
    \    2.1. Locating Services in a Domain ..............................5\n    \
    \  2.2. NAPTR and DDDS .............................................6\n      2.3.\
    \ Arbitrary Data in the DNS ..................................8\n   3. Challenges\
    \ for the DNS .........................................10\n      3.1. Compound\
    \ Queries ..........................................10\n           3.1.1. Responses\
    \ Tailored to the Originator ...............12\n      3.2. Using DNS as a Generic\
    \ Database ...........................14\n           3.2.1. Large Data in the\
    \ DNS ..............................14\n      3.3. Administrative Structures Misaligned\
    \ with the DNS .........16\n           3.3.1. Metadata about Tree Structure ......................18\n\
    \      3.4. Domain Redirection ........................................20\n  \
    \ 4. Private DNS and Split Horizon ..................................21\n   5.\
    \ Principles and Guidance ........................................23\n   6. Security\
    \ Considerations ........................................25\n   7. IAB Members\
    \ at the Time of Approval ............................26\n   8. Acknowledgements\
    \ ...............................................26\n   9. Informative References\
    \ .........................................27\n"
- title: 1.  Motivation
  contents:
  - "1.  Motivation\n   The Domain Name System (DNS) has long provided a general means\
    \ of\n   translating domain names into Internet Protocol addresses, which\n  \
    \ makes the Internet easier to use by providing a valuable layer of\n   indirection\
    \ between names and lower-layer protocol elements.\n   [RFC0974] documented a\
    \ further use of the DNS: to locate an\n   application service operating in a\
    \ domain, via the Mail Exchange (MX)\n   Resource Record; these records help email\
    \ addressed to the domain to\n   find a mail service for the domain sanctioned\
    \ by the zone\n   administrator.\n   The seminal MX record served as a prototype\
    \ for other DNS resource\n   records that supported applications associated with\
    \ a domain name.\n   The SRV Resource Record [RFC2052] provided a more general\
    \ mechanism\n   for locating services in a domain, complete with a weighting system\n\
    \   and selection among transports.  The Naming Authority Pointer (NAPTR)\n  \
    \ Resource Record (originally described in [RFC2168]), especially as it\n   evolved\
    \ into the more general Dynamic Delegation Discovery System\n   (DDDS) [RFC3401]\
    \ framework, added a generic mechanism for storing\n   application data in the\
    \ DNS.  Primarily, this involved a client-side\n   algorithm for transforming\
    \ a string into a domain name, which might\n   then be resolved by the DNS to\
    \ find NAPTR records.  This enabled the\n   resolution of identifiers that do\
    \ not have traditional host\n   components through the DNS; the best-known examples\
    \ of this are\n   telephone numbers, as resolved by the DDDS application ENUM.\
    \  Recent\n   work, such as DomainKeys Identified Mail (DKIM) [RFC6376], has\n\
    \   enabled security features of applications to be advertised through\n   the\
    \ DNS, via the TXT Resource Record.\n   The scope of application usage of the\
    \ DNS has thus increased over\n   time.  Applications in many environments require\
    \ features such as\n   confidentiality, and as the contexts in which applications\
    \ rely on\n   the DNS have increased, some application protocols have looked to\n\
    \   extend the DNS to include these sorts of capabilities.  However, some\n  \
    \ proposed usages of, and extensions to, the DNS have become misaligned\n   with\
    \ both the DNS architecture and the DNS protocol.  If we take the\n   example\
    \ of confidentiality, we see that in the global public DNS, the\n   resolution\
    \ of domain names to IP addresses is an exchange of public\n   information with\
    \ no expectation of confidentiality.  Thus, the\n   underlying query/response\
    \ protocol has no encryption mechanism;\n   typically, any security required by\
    \ an application or service is\n   invoked after the DNS query, when the resolved\
    \ service has been\n   contacted.  Only in private DNS environments (including\
    \ split-horizon\n   DNS) where the identity of the querier is assured through\
    \ some\n   external policy can the DNS maintain confidential records, by\n   providing\
    \ distinct answers to the private and public users of the\n   DNS.  In support\
    \ of load-balancing or other optimizations, a DNS\n   server may return different\
    \ addresses in response to queries from\n   different sources, or even no response\
    \ at all; see Section 3.1.1 for\n   details.\n   This document provides guidance\
    \ to application designers and\n   application protocol designers looking to use\
    \ the DNS to support\n   features in their applications.  It provides an overview\
    \ of past\n   application usage of the DNS as well as a review of proposed new\n\
    \   usages.  It identifies concerns and trade-offs and provides guidance\n   on\
    \ the question, \"Should I store this information in the DNS, or use\n   some\
    \ other means?\" when that question arises during protocol\n   development.  These\
    \ guidelines remind application protocol designers\n   of the strengths and weaknesses\
    \ of the DNS in order to make it easier\n   for designers to decide what features\
    \ the DNS should provide for\n   their application.\n   The guidance in this document\
    \ complements the guidance on extending\n   the DNS given in [RFC5507].  Whereas\
    \ [RFC5507] considers the\n   preferred ways to add new information to the underlying\
    \ syntax of the\n   DNS (such as defining new resource records or adding prefixes\
    \ or\n   suffixes to labels), the current document considers broader\n   implications\
    \ of applications that rely on the DNS for the\n   implementation of certain features,\
    \ be it through extending the DNS\n   or simply reusing existing protocol capabilities\
    \ -- implications that\n   may concern the invocation of the resolver by applications;\
    \ the\n   behavior of name servers, resolvers, or caches; extensions to the\n\
    \   underlying DNS protocol; the operational responsibilities of zone\n   administrators;\
    \ security; or the overall architecture of names.  When\n   existing DNS protocol\
    \ fields are used in ways that their designers\n   did not intend to handle new\
    \ applications, those applications may\n   demand further changes and extensions\
    \ that are fundamentally at odds\n   with the strengths of the DNS.\n"
- title: 2.  Overview of DNS Application Usages
  contents:
  - "2.  Overview of DNS Application Usages\n   [RFC0882] identifies the original\
    \ and fundamental connection between\n   the DNS and applications.  It begins\
    \ by describing how the\n   interdomain scope of applications creates \"formidable\
    \ problems when\n   we wish to create consistent methods for referencing particular\n\
    \   resources that are similar but scattered throughout the environment\".\n \
    \  This motivated transitioning the \"mapping between host names... and\n   ARPA\
    \ Internet addresses\" from a global table (the original \"hosts\"\n   file) to\
    \ a \"distributed database that performs the same function\".\n   [RFC0882] also\
    \ envisioned some ways to find the resources associated\n   with mailboxes in\
    \ a domain: without these extensions, a user trying\n   to send mail to a foreign\
    \ domain lacked a discovery mechanism to\n   locate the right host in the remote\
    \ domain to which to connect.\n   While a special-purpose service discovery mechanism\
    \ could be built\n   for each such application protocol that needed this functionality,\n\
    \   the universal support for the DNS encourages installing these\n   features\
    \ into its public tree rather than inventing something new.\n   Thus, over time,\
    \ several other applications leveraged DNS resource\n   records for locating services\
    \ in a domain or for storing application\n   data associated with a domain in\
    \ the DNS.  This section gives\n   examples of various types of DNS usage by applications\
    \ to date.\n"
- title: 2.1.  Locating Services in a Domain
  contents:
  - "2.1.  Locating Services in a Domain\n   The MX Resource Record provides the simplest\
    \ example of an\n   application advertising its domain-level resources in the\
    \ Domain Name\n   System.  The MX Resource Record contains the domain name of\
    \ a server\n   that receives mail on behalf of the administrative domain in\n\
    \   question; that domain name must itself be resolved to one or more\n   IP addresses\
    \ through the DNS in order to reach the mail server.\n   While naming conventions\
    \ for applications might serve a similar\n   purpose (a host might be named \"\
    mail.example.com\", for example),\n   approaching service location through the\
    \ creation of a new resource\n   record yields important benefits.  For example,\
    \ one can put multiple\n   MX records under the same name, in order to designate\
    \ backup\n   resources or to load-balance across several such servers (see\n \
    \  [RFC1794]); these properties could not easily be captured by naming\n   conventions\
    \ (see [RFC4367], though more recently DNS-based Service\n   Discovery (DNS-SD)\
    \ [RFC6763] codifies service instance naming\n   conventions for use across applications\
    \ to locate services in a\n   domain).\n   While the MX record represents a substantial\
    \ improvement over naming\n   conventions as a means of service location, it remains\
    \ specific to a\n   single application.  Thus, the general approach of the MX\
    \ record was\n   adapted to fit a broader class of applications through the Service\n\
    \   (SRV) Resource Record (originally described in [RFC2052]).  The SRV\n   record\
    \ allows DNS resolvers to query for particular services and\n   underlying transports\
    \ (for example, HTTP running over Transport Layer\n   Security (TLS) [RFC2818])\
    \ and to learn a host name and port where\n   that service resides in a given\
    \ domain.  It also provides a weighting\n   mechanism to allow load-balancing\
    \ across several instances of a\n   service.\n   The reliance of applications\
    \ on the existence of MX and SRV records\n   has important implications for the\
    \ way that applications manage\n   identifiers and the way that applications pass\
    \ domain names to\n   resolvers.  Email identifiers of the form \"user@domain\"\
    \ rely on MX\n   records to provide the convenience of simply specifying a \"\
    domain\"\n   component rather than requiring an application to guess which\n \
    \  particular host handles mail on behalf of the domain.  While naming\n   conventions\
    \ continue to abound (\"www.example.com\") for applications\n   like web browsing,\
    \ SRV records allow applications to query for an\n   application-specific protocol\
    \ and transport in the domain.  For the\n   Lightweight Directory Access Protocol\
    \ (LDAP), the SRV service name\n   corresponds to the URL scheme of the identifier\
    \ invoked by the\n   application (e.g., when \"ldap://example.com\" is the identifier,\
    \ the\n   SRV query passed to the resolver is for \"_ldap._tcp.example.com\");\n\
    \   for other applications, the SRV service name that the application\n   passes\
    \ to the resolver may be implicit in the identifier rather than\n   explicit.\
    \  In either case, the application delivers the service name\n   to the DNS to\
    \ find the location of the host of that service for the\n   domain, the port where\
    \ the service resides on that host, additional\n   locations or ports for load-balancing\
    \ and fault tolerance, and\n   related application features.\n   Locating specific\
    \ services for a domain was the first major function\n   for which applications\
    \ started using the DNS beyond simple name\n   resolution.  SRV broadened and\
    \ generalized the precedent of MX to\n   make service location available to any\
    \ application, rather than just\n   to mail.  As applications that acquire MX\
    \ (or SRV) records might need\n   to perform further queries or transformations\
    \ in order to arrive at\n   an eventual domain name that will resolve to the IP\
    \ addresses for the\n   service, [RFC1034] allowed that the Additional (data)\
    \ section of DNS\n   responses may contain the corresponding address records for\
    \ the names\n   of services designated by the MX record; this optimization, which\n\
    \   requires support in the authoritative server and the resolver, is an\n   initial\
    \ example of how support for application features requires\n   changes to DNS\
    \ operation.  At the same time, this is an example of an\n   extension of the\
    \ DNS that cannot be universally relied on: many DNS\n   resolver implementations\
    \ will ignore the addresses in the additional\n   section of the DNS answers because\
    \ of the trustworthiness issues\n   described in [RFC2181].\n"
- title: 2.2.  NAPTR and DDDS
  contents:
  - "2.2.  NAPTR and DDDS\n   The NAPTR Resource Record evolved to fulfill a need\
    \ in the transition\n   from Uniform Resource Locators (URLs) to the more mature\
    \ Uniform\n   Resource Identifier (URI) [RFC3986] framework, which incorporated\n\
    \   Uniform Resource Names (URNs).  Unlike URLs, URNs typically do not\n   convey\
    \ enough semantics internally to resolve them through the DNS,\n   and consequently\
    \ a separate URI-transformation mechanism is required\n   to convert these types\
    \ of URIs into domain names.  This allows\n   identifiers with no recognizable\
    \ domain component to be treated as\n   domain names for the purpose of name resolution.\
    \  Once these\n   transformations result in a domain name, applications can retrieve\n\
    \   NAPTR records under that name in the DNS.  NAPTR records contain a\n   far\
    \ more rich and complex structure than MX or SRV Resource Records.\n   A NAPTR\
    \ record contains two different weighting mechanisms (\"order\"\n   and \"preference\"\
    ), a \"service\" field to designate the application\n   that the NAPTR record\
    \ describes, and then two fields that can contain\n   translations: a \"replacement\"\
    \ field or a \"regexp\" (regular\n   expression) field, only one of which appears\
    \ in a given NAPTR record\n   (see [RFC2168]).  A \"replacement\", like NAPTR's\
    \ ancestor the PTR\n   record, simply designates another domain name where one\
    \ would look\n   for records associated with this service in the domain.  The\n\
    \   \"regexp\", on the other hand, allows regular expression\n   transformations\
    \ on the original URI intended to turn it into an\n   identifier that the DNS\
    \ can resolve.\n   As the abstract of [RFC2915] says, \"This allows the DNS to\
    \ be used to\n   lookup services for a wide variety of resource names (including\
    \ URIs)\n   which are not in domain name syntax\".  Any sort of hierarchical\n\
    \   identifier can potentially be encoded as a domain name, and thus\n   historically\
    \ the DNS has often been used to resolve identifiers that\n   were never devised\
    \ as a name for an Internet host.  A prominent early\n   example is found in the\
    \ in-addr domain [RFC0883], in which IPv4\n   addresses are encoded as domain\
    \ names by applying a string\n   preparation algorithm that required reversing\
    \ the octets and treating\n   each individual octet as a label in a domain name\
    \ -- thus, for\n   example, the address 192.0.2.1 became 1.2.0.192.in-addr.arpa.\
    \  This\n   allowed resolvers to query the DNS to learn name(s) associated with\n\
    \   an IPv4 address.  The same mechanism has been applied to IPv6\n   addresses\
    \ [RFC3596] and other sorts of identifiers that lack a domain\n   component. \
    \ Eventually, this idea connected with activities to create\n   a system for resolving\
    \ telephone numbers on the Internet, which\n   became known as ENUM (originally\
    \ described in [RFC2916]).  ENUM\n   borrowed from an earlier proposal, the \"\
    tpc.int\" domain [RFC1530],\n   which provided a means for encoding telephone\
    \ numbers as domain names\n   by applying a string preparation algorithm that\
    \ required reversing\n   the digits and treating each individual digit as a label\
    \ in a domain\n   name -- thus, for example, the number +15714345400 became\n\
    \   0.0.4.5.4.3.4.1.7.5.1.tpc.int.  In the ENUM system, in place of\n   \"tpc.int\"\
    \ the special domain \"e164.arpa\" was reserved for use.\n   In the more mature\
    \ form of the NAPTR standard, in the Dynamic\n   Delegation Discovery System (DDDS)\
    \ [RFC3401] framework, the initial\n   transformation of an identifier (such as\
    \ a telephone number) to a\n   domain name was called the \"First Well Known Rule\"\
    .  The address-\n   reversing mechanism, whereby a query name is formed by reversing\
    \ an\n   IPv4 address and prepending it to the in-addr.arpa domain, is\n   generalized\
    \ for the use of NAPTR: each application defines a \"First\n   Well Known Rule\"\
    \ that translates a specific resource into a query\n   name.  Its flexibility\
    \ has inspired a number of proposals beyond ENUM\n   to encode and resolve unorthodox\
    \ identifiers in the DNS.  Provided\n   that the identifiers transformed by the\
    \ \"First Well Known Rule\" have\n   some meaningful structure and are not overly\
    \ lengthy, virtually\n   anything can serve as an input for the DDDS structure:\
    \ for example,\n   civic addresses.  Though [RFC3402] stipulates regarding the\n\
    \   identifier that \"The lexical structure of this string must imply a\n   unique\
    \ delegation path\", there is no requirement that the identifier\n   be hierarchical\
    \ nor that the points of delegation in the domain name\n   created by the \"First\
    \ Well Known Rule\" correspond to any points of\n   administrative delegation\
    \ inherent in the structure of the\n   identifier.\n   While this ability to look\
    \ up names \"which are not in domain name\n   syntax\" does not change the underlying\
    \ DNS protocol -- the names\n   generated by the DDDS algorithm are still just\
    \ domain names -- it\n   does change the context in which applications pass name\
    \ to resolvers\n   and can potentially require very different operational practices\
    \ of\n   zone administrators (see Section 3.3).  In terms of the results of a\n\
    \   DNS query, the presence of the \"regexp\" field of NAPTR records\n   enabled\
    \ unprecedented flexibility in the types of identifiers that\n   applications\
    \ could resolve with the DNS.  Since the output of the\n   regular expression\
    \ frequently took the form of a URI (in ENUM\n   resolution, for example, a telephone\
    \ number might be converted into a\n   SIP URI [RFC3261]), anything that could\
    \ be encoded as a URI might be\n   the result of resolving a NAPTR record -- which,\
    \ as the next section\n   explores, essentially means arbitrary data.\n"
- title: 2.3.  Arbitrary Data in the DNS
  contents:
  - "2.3.  Arbitrary Data in the DNS\n   URI encoding has ways of encapsulating basically\
    \ arbitrary data: the\n   most extreme example is a data URL [RFC2397].  Thus,\
    \ the returned\n   NAPTR record might be interpreted to produce output other than\
    \ a\n   domain name that would subsequently be resolved to IP addresses and\n\
    \   contacted for a particular application -- it could give a literal\n   result\
    \ that would be consumed by the application.  Originally, as\n   discussed in\
    \ [RFC2168], the intended applicability of the regular\n   expression field in\
    \ NAPTR was narrower: the \"regexp\" field contained\n   a \"substitution expression\
    \ that is applied to the original URI in\n   order to construct the next domain\
    \ name to lookup\", in order to\n   \"change the host that is contacted to resolve\
    \ a URI\" or as a way of\n   \"changing the path or host once the URL has been\
    \ assigned\".  The\n   regular expression tools available to NAPTR record authors,\
    \ however,\n   grant much broader powers to alter the input string, and thus\n\
    \   applications began to rely on NAPTR to perform more radical\n   transformations\
    \ that did not serve any of those aforementioned needs.\n   According to [RFC3402],\
    \ the output of DDDS is wholly application-\n   specific: \"the Application must\
    \ define what the expected output of\n   the Terminal Rule should be\", and the\
    \ example given in the document\n   is one of identifying automobile parts by\
    \ inputting a part number and\n   receiving at the end of the process information\
    \ about the\n   manufacturer.\n   Historically speaking, NAPTR did not pioneer\
    \ the storage of arbitrary\n   data in the DNS.  At the start, [RFC0882] observed\
    \ that \"it is\n   unlikely that all users of domain names will be able to agree\
    \ on the\n   set of resources or resource information that names will be used\
    \ to\n   retrieve\", and consequently places little restriction on the\n   information\
    \ that DNS records might carry: it might be \"host\n   addresses, mailbox data,\
    \ and other as yet undetermined information\".\n   [RFC1035] defined the TXT record,\
    \ a means to store arbitrary strings\n   in the DNS; [RFC1035] also specifically\
    \ stipulates that a TXT\n   contains \"descriptive text\" and that \"the semantics\
    \ of the text\n   depends on the domain where it is found\".  The existence of\
    \ TXT\n   records has long provided new applications with a rapid way of\n   storing\
    \ data associated with a domain name in the DNS, as adding data\n   in this fashion\
    \ requires no registration process.  [RFC1464]\n   experimented with a means of\
    \ incorporating name/value pairs to the\n   TXT record structure, which allowed\
    \ applications to distinguish\n   different chunks of data stored in a TXT record\
    \ -- surely not just\n   \"descriptive text\" as the TXT originally specified.\
    \  In this fashion,\n   an application that wants to store additional data in\
    \ the DNS can do\n   so without registering a new resource record type, though\
    \ [RFC5507]\n   points out that it is \"difficult to reliably distinguish one\n\
    \   application's record from others, and for its parser to avoid\n   problems\
    \ when it encounters other TXT records\".\n   While open policies surrounding\
    \ the use of the TXT record have\n   resulted in a checkered past for standardizing\
    \ application usage of\n   TXT, TXT has been used as a technical solution for\
    \ many applications.\n   Recently, DKIM [RFC6376] sidestepped the problem of TXT\
    \ ambiguity by\n   storing keys under a specialized DNS naming structure that\
    \ includes\n   the component \"_domainkeys\", which serves to restrict the scope\
    \ of\n   that TXT solely to DKIM use.  Storing keys in the DNS became the\n  \
    \ preferred solution for DKIM for several reasons: notably, because\n   email\
    \ applications already queried the DNS in their ordinary\n   operations, because\
    \ the public keys associated with email required\n   wide public distribution,\
    \ and because email identifiers contain a\n   domain component that applications\
    \ can easily use to consult the DNS.\n   If the application had to negotiate support\
    \ for the DKIM mechanism\n   with mail servers, it would give rise to bid-down\
    \ attacks (where\n   attackers misrepresent that DKIM is unsupported on the originating\n\
    \   side) that are not possible if the DNS delivers the keys (provided\n   that\
    \ DNSSEC [RFC4033] guarantees authenticity of the data).  However,\n   there are\
    \ potential issues with storing large data in the DNS, as\n   discussed in Section\
    \ 3.2.1, as well as with the DKIM namespace\n   conventions that complicate the\
    \ use of DNS wildcards (as discussed in\n   Section 6.1.2 of [RFC6376] and in\
    \ more general terms in [RFC5507]).\n   If prefixes are used to identify TXT records\
    \ used by an application,\n   potentially the use of wildcards may furthermore\
    \ cause leakages that\n   other applications will need to detect.\n"
- title: 3.  Challenges for the DNS
  contents:
  - "3.  Challenges for the DNS\n   The methods discussed in the previous section\
    \ for transforming\n   arbitrary identifiers into domain names and returning arbitrary\
    \ data\n   in response to DNS queries both represent significant departures from\n\
    \   the basic function of translating host names to IP addresses, yet\n   neither\
    \ fundamentally alters the underlying semantics of the DNS.\n   When we consider,\
    \ however, that the URIs returned by DDDS might be\n   base-64-encoded binary\
    \ data in a data URL, the DNS could effectively\n   implement the entire application\
    \ feature set of any simple query-\n   response protocol.  Effectively, the DDDS\
    \ framework considers the DNS\n   a generic database -- indeed, the DDDS framework\
    \ was designed to work\n   with any sort of underlying database; as [RFC3403]\
    \ says, the DNS is\n   only one potential database for DDDS to use.  Whether the\
    \ DNS as an\n   underlying database can support the features that some applications\n\
    \   of DDDS require, however, is a more complicated question.\n   As the following\
    \ subsections will show, the potential for\n   applications to rely on the DNS\
    \ as a generic database gives rise to\n   additional requirements that one might\
    \ expect to find in a database\n   access protocol: authentication of the source\
    \ of queries for\n   comparison to access control lists, formulating complex relational\n\
    \   queries, and asking questions about the structure of the database\n   itself.\
    \  The global public DNS was not designed to provide these\n   sorts of properties,\
    \ and extending the DNS protocols to encompass\n   them could result in a fundamental\
    \ alteration to its model.\n   Ultimately, this document concludes that efforts\
    \ to retrofit these\n   capabilities into the DNS would be better invested in\
    \ selecting, or\n   if necessary inventing, other Internet services with broader\
    \ powers\n   than the DNS.  If an application protocol designer wants these\n\
    \   properties from a database, in general this is a good indication that\n  \
    \ the DNS cannot, or can only partly, meet the needs of the application\n   in\
    \ question.\n   Since many of these new requirements have emerged from the ENUM\n\
    \   space, the following sections use ENUM as an illustrative example;\n   however,\
    \ any application using the DNS as a feature-rich database\n   could easily end\
    \ up with similar requirements.\n"
- title: 3.1.  Compound Queries
  contents:
  - "3.1.  Compound Queries\n   Traditionally, DNS RRsets are uniquely identified\
    \ by domain name,\n   resource record type, and class.  DNS queries are based\
    \ on this\n   3-tuple, and the replies are resource record sets that are to be\n\
    \   treated as atomic data elements (see [RFC2181]); to applications, the\n  \
    \ behavior of the DNS has traditionally been that of an exact-match\n   query-response\
    \ lookup mechanism.  Outside of the DNS space, however,\n   there are plenty of\
    \ query-response applications that require a\n   compound or relational search,\
    \ one taking into account more than one\n   factor in formulating a response or\
    \ one that uses no single factor as\n   a key to the database.  For example, in\
    \ the telephony space,\n   telephone call routing often takes into account numerous\
    \ factors\n   aside from the dialed number, including originating trunk groups,\n\
    \   interexchange carrier selection, number portability data, time of\n   day,\
    \ and so on.  All are considered simultaneously in generating a\n   route.  While\
    \ in its original conception ENUM hoped to circumvent the\n   traditional Public\
    \ Switched Telephone Network (PSTN) and route\n   directly to Internet-enabled\
    \ devices, the infrastructure ENUM effort\n   to support the migration of traditional\
    \ carrier routing functions to\n   the Internet aspires to achieve feature parity\
    \ with traditional\n   number routing.  However, [RFC3402] explicitly states that\
    \ \"it is an\n   assumption of the DDDS that the lexical element used to make\
    \ a\n   delegation decision is simple enough to be contained within the\n   Application\
    \ Unique String itself.  The DDDS does not solve the case\n   where a delegation\
    \ decision is made using knowledge contained outside\n   the AUS and the Rule\
    \ (time of day, financial transactions, rights\n   management, etc.)\".  Consequently,\
    \ some consideration has been given\n   to ways to append additional data to ENUM\
    \ queries to give the DNS\n   server sufficient information to return a suitable\
    \ URI (see\n   Section 3.1.1).\n   From a sheer syntactical perspective, however,\
    \ domain names do not\n   admit of this sort of rich structure.  Several workarounds\
    \ have\n   attempted to instantiate these sorts of features in DNS queries.  For\n\
    \   example, the domain name itself could be compounded with the\n   additional\
    \ parameters: one could take a name like\n   0.0.4.5.4.3.4.1.7.5.1.e164.arpa and\
    \ append a trunk group identifier\n   to it, for example, of the form\n   tg011.0.0.4.5.4.3.4.1.7.5.1.e164.arpa.\
    \  While in this particular case\n   a DNS server can adhere to its traditional\
    \ behavior in locating\n   resource records, the syntactical viability of encoding\
    \ additional\n   parameters in this fashion is dubious, especially if more than\
    \ one\n   additional parameter is required and the presence of parameters is\n\
    \   optional so that the application needs multiple queries to assess the\n  \
    \ completeness of the information it needs to perform its function.\n   As an\
    \ alternative, it has been proposed that we piggyback additional\n   query parameters\
    \ as Extension Mechanisms for DNS (EDNS(0)) extensions\n   (see [RFC6891]).  This\
    \ might be problematic for three reasons.\n   First, supporting EDNS(0) extensions\
    \ requires significant changes to\n   name server behavior; these changes need\
    \ to be supported by the\n   authoritative and recursive name servers on which\
    \ the application\n   relies and might be very hard to realize on a global scale.\
    \  In\n   addition, the original stated applicability of the EDSN(0) mechanism,\n\
    \   as [RFC2671] states, was to \"a particular transport level message and\n \
    \  not to any actual DNS data\", and consequently the OPT Resource\n   Records\
    \ it specifies are never to be forwarded.  The use of EDNS(0)\n   for compound\
    \ queries, however, clearly is intended to discriminate\n   actual DNS data rather\
    \ than to facilitate transport-layer handling.\n   Finally, [RFC6891] also specifies\
    \ that \"OPT RRs MUST NOT be cached,\n   forwarded, or stored\" (see the next\
    \ paragraph).  For these reasons,\n   this memo recommends against crafting compound\
    \ DNS queries by using\n   EDNS(0).\n   The implications of these sorts of compound\
    \ queries for recursion and\n   caching are potentially serious.  The logic used\
    \ by the authoritative\n   server to respond to a compound query may not be understood\
    \ by any\n   recursive servers or caches; intermediaries that naively assume that\n\
    \   the response was selected based on the domain name, type, and class\n   alone\
    \ might serve responses to queries in a different way than the\n   authoritative\
    \ server intends.  Therefore, were EDNS(0) to be employed\n   this way, its attributes\
    \ would not be transitive, and if this were\n   not considered where intermediaries\
    \ are employed, as is normally the\n   case in the global DNS, brokenness might\
    \ occur.\n"
- title: 3.1.1.  Responses Tailored to the Originator
  contents:
  - "3.1.1.  Responses Tailored to the Originator\n   DNS responses tailored to the\
    \ identity of their originator, where\n   some sort of administrative identity\
    \ of the originator must be\n   conveyed to the DNS, constitute the most important\
    \ subcase of these\n   compound queries.  We must first distinguish this from\
    \ cases where\n   the originating IP address or a similar indication is used to\
    \ serve a\n   location-specific name.  For those sorts of applications, which\n\
    \   generally lack security implications, relying on factors like the\n   source\
    \ IP address introduces little harm; for example, when providing\n   a web portal\
    \ customized to the region of the client, it would not be\n   a security breach\
    \ if the client saw the localized portal of the wrong\n   country.  Because recursive\
    \ resolvers may obscure the origination\n   network of the DNS client, a recent\
    \ proposal suggested introducing a\n   new DNS query parameter to be populated\
    \ by DNS recursive resolvers in\n   order to preserve the originating IP address\
    \ (see [EDNS-CLIENT-IP]).\n   However, aside from purely cosmetic uses, these\
    \ approaches have known\n   limitations due to the prevalence of private IP addresses,\
    \ VPNs, and\n   so on, which obscure the source IP address and instead supply\
    \ the IP\n   address of an intermediary that may be very distant from the\n  \
    \ originating endpoint.  Implementing technology such as the one\n   described\
    \ by [EDNS-CLIENT-IP] would require significant changes in\n   the operation of\
    \ recursive resolvers and the authoritative servers\n   that would rely on the\
    \ original source IP address to select resource\n   records, and moreover a fundamental\
    \ change to caching behavior as\n   well.  As a result, such technology cannot\
    \ be rolled out in an\n   incremental, unilateral fashion but could only be successful\
    \ when\n   implemented bilaterally (by authoritative server and recursive\n  \
    \ resolver); this is a significant bar to deployment.\n   In other deployments\
    \ in use today, including those based on the BIND\n   \"views\" feature, the source\
    \ IP address is used to grant access to a\n   selected, and potentially sensitive,\
    \ set of resource records.  The\n   security implications of trusting the source\
    \ IP address of a DNS\n   query have prevented most solutions along these lines\
    \ from being\n   standardized (see [RFC6269]), though the practice remains widespread\n\
    \   in \"split horizon\" private DNS deployments (see Section 4), which\n   typically\
    \ rely on an underlying security layer, such as a physical\n   network, a clear\
    \ perimeter demarcation at a network perimeter point\n   (with network-layer anti-spoofing\
    \ countermeasures), or an IPsec VPN,\n   to prevent spoofing of the source IP\
    \ address.  These deployments do\n   have a confidentiality requirement to prevent\
    \ information intended\n   for a constrained audience (internal to an enterprise,\
    \ for example)\n   from leaking to the public Internet -- while these internal\
    \ network\n   resources may use private IP addresses that should not be useful\
    \ on\n   the public Internet anyway, in some cases this leakage would reveal\n\
    \   topology or other information that the name server administrator\n   hopes\
    \ to keep private.  More recently, TSIG [RFC2845] has been\n   employed as a way\
    \ of selecting among \"views\" in BIND; this provides a\n   stronger level of\
    \ security than merely relying on the source IP\n   address, but typically many\
    \ users share the same secret to access a\n   given view, and moreover TSIG does\
    \ not provide confidentiality\n   properties to DNS messages -- without network-layer\
    \ separation\n   between users of different views, eavesdroppers might capture\
    \ the DNS\n   queries and responses.\n   The use of source IP addresses as a discriminator\
    \ to select DNS\n   resource records, regardless of its lack of acceptance by\
    \ the\n   standards community, has widespread acceptance in the field.  Some\n\
    \   applications, however, go even further and propose extending the DNS\n   to\
    \ add an application-layer identifier of the originator; for\n   example, [EDNS-OPT-CODE]\
    \ provides a SIP URI in an EDNS(0) parameter.\n   Effectively, this conveyance\
    \ of application-layer information about\n   the administrative identity of the\
    \ originator through the DNS is a\n   weak authentication mechanism, on the basis\
    \ of which the DNS server\n   makes an authorization decision before sharing resource\
    \ records.\n   This can approximate a confidentiality mechanism per resource record,\n\
    \   where only a specific set of originators is permitted to see resource\n  \
    \ records, or a case where a query for the same name by different\n   entities\
    \ results in completely different resource record sets.\n   However, without any\
    \ underlying cryptographic security, this\n   mechanism must rely on external\
    \ layers for security (such as VPNs)\n   rather than any direct assurance.  Again,\
    \ caching, forwarding, and\n   recursion introduce significant challenges for\
    \ applications that\n   attempt to offload this responsibility to the DNS.  Achieving\
    \ feature\n   parity with even the simplest authentication mechanisms available\
    \ at\n   the application layer would likely require significant rearchitecture\n\
    \   of the DNS.\n"
- title: 3.2.  Using DNS as a Generic Database
  contents:
  - "3.2.  Using DNS as a Generic Database\n   As previously noted, applications can\
    \ use a method like the \"First\n   Well Known Rule\" of DDDS to transform an\
    \ arbitrary string into a\n   domain name and then receive from the DNS arbitrary\
    \ data stored in\n   TXT RRs, in the \"regexp\" of NAPTRs, or even in custom records.\
    \  Some\n   query-response applications, however, require queries and responses\n\
    \   that simply fall outside the syntactic capabilities of the DNS.  For\n   example,\
    \ domain names themselves must consist of labels that do not\n   exceed 63 octets,\
    \ while the total length of the encoded name may not\n   exceed 255 octets, and\
    \ applications that use label characters outside\n   the traditional ASCII set\
    \ may run into problems (however, see the\n   discussion in [RFC6055], Section\
    \ 3 for definitive guidance on the use\n   of non-ASCII in the DNS).  The DNS\
    \ therefore cannot be a completely\n   generic database.  Similar concerns apply\
    \ to the size of DNS\n   responses.\n"
- title: 3.2.1.  Large Data in the DNS
  contents:
  - "3.2.1.  Large Data in the DNS\n   While the \"data\" URL specification [RFC2397]\
    \ notes that it is \"only\n   useful for short values\", unfortunately it gives\
    \ no particular\n   guidance about what \"short\" might mean.  Some applications\
    \ today use\n   quite large data URLs (containing a megabyte or more of data)\
    \ as\n   workarounds in environments where only URIs can syntactically appear\n\
    \   (for example, in Apple iOS, to pass objects between applications).\n   The\
    \ meaning of \"short\" in an application context is probably very\n   different\
    \ from how we should understand it in a DNS message.\n   Referring to a typical\
    \ public DNS deployment, [RFC5507] observes that\n   \"there's a strong incentive\
    \ to keep DNS messages short enough to fit\n   in a UDP datagram, preferably a\
    \ UDP datagram short enough not to\n   require IP fragmentation\".  And while\
    \ EDNS(0) allows for mechanisms\n   to negotiate DNS message sizes larger than\
    \ the traditional 512\n   octets, there is a high risk that a long payload will\
    \ cause UDP\n   fragmentation, in particular when the DNS message already carries\n\
    \   DNSSEC information.  If EDNS(0) is not available, or the negotiated\n   EDNS(0)\
    \ packet size is too small to fit the data, or UDP fragments\n   are dropped,\
    \ the DNS may (eventually) resort to using TCP.  While TCP\n   allows DNS responses\
    \ to be quite long, this requires stateful\n   operation of servers, which can\
    \ be costly in deployments where\n   servers have only fleeting connections to\
    \ many clients.  Ultimately,\n   there are forms of data that an application might\
    \ store in the DNS\n   that exceed reasonable limits: in the ENUM context, for\
    \ example,\n   something like storing base-64-encoded mp3 files of custom ringtones.\n\
    \   Designs relying on storage of large amounts of data within DNS RRs\n   furthermore\
    \ need to minimize the potential damage achievable in a\n   reflection attack\
    \ (see [RFC4732], Section 3), in which the attacker\n   sends UDP-only DNS queries\
    \ with a forged source address, and the\n   victim receives the response.  The\
    \ attacker relies on amplification,\n   where a small query generates a large\
    \ response directed at the\n   victim.  Where the responder supports EDNS(0),\
    \ an attacker may set\n   the requester maximum payload size to a larger value\
    \ while querying\n   for a large resource record, such as a certificate [RFC4398].\
    \  Thus,\n   the combination of large data stored in DNS RRs and responders\n\
    \   supporting large payload sizes has the potential to increase the\n   potential\
    \ damage achievable in a reflection attack.\n   Since a reflection attack can\
    \ be launched from any network that does\n   not implement source address validation,\
    \ these attacks are difficult\n   to eliminate absent the ubiquitous deployment\
    \ of source address\n   validation or \"heavier\" transport protocols such as\
    \ TCP.  The\n   bandwidth that can be mustered in a reflective amplification attack\n\
    \   directed by a botnet reflecting off a recursive name server on a\n   high-bandwidth\
    \ network is sobering.  For example, if the responding\n   resolver could be directed\
    \ to generate a 10KB response in reply to a\n   50-octet query, then magnification\
    \ of 200:1 would be attainable.\n   This would enable a botnet controlling 10000\
    \ hosts with 1 Mbps of\n   bandwidth to focus 200 Gbps of traffic on the victim,\
    \ more than\n   sufficient to congest any site on today's Internet.\n   DNS reflection\
    \ attacks typically utilize UDP queries; it is\n   prohibitively difficult to\
    \ complete a TCP three-way handshake begun\n   from a forged source address for\
    \ DNS reflection attacks.  Unless the\n   attacker uses EDNS(0) [RFC6891] to enlarge\
    \ the requester's maximum\n   payload size, a response can only reach 576 octets\
    \ before the\n   truncate bit is set in the response.  This limits the maximum\n\
    \   magnification achievable from a DNS query that does not utilize\n   EDNS(0).\
    \  As the large disparity between the size of a query and size\n   of the response\
    \ creates this amplification, techniques for mitigating\n   this disparity should\
    \ be further studied, though this is beyond the\n   scope of this memo (for an\
    \ analysis of the effects of limiting\n   EDNS(0) responses while still accommodating\
    \ DNSSEC, see [Lindsay]).\n   For example, some implementations could limit EDNS(0)\
    \ responses to a\n   specific ratio compared to the request size, where the precise\
    \ ratio\n   can be configured on a per-deployment basis (taking into account\n\
    \   DNSSEC response sizes).  Without some means of mitigating the\n   potential\
    \ for amplification, EDNS(0) could cause significant harm.\n   In summary, there\
    \ are two operational forces that tend to drive the\n   practically available\
    \ EDNS(0) sizes down: possible UDP fragmentation\n   and minimizing amplification\
    \ in case of reflection attacks.  DNSSEC\n   data will use a significant fraction\
    \ of the available space in a DNS\n   packet.  Therefore -- appreciating that\
    \ given the current DNSSEC and\n   EDNS(0) deployment experience, precise numbers\
    \ are impossible to give\n   -- the generic payload available to other DNS data,\
    \ given the premise\n   that TCP fallback is to be minimized, is likely to be\
    \ closer to\n   several hundred octets than a few thousand octets.\n"
- title: 3.3.  Administrative Structures Misaligned with the DNS
  contents:
  - "3.3.  Administrative Structures Misaligned with the DNS\n   While the DDDS framework\
    \ enables any sort of alphanumeric data to\n   serve as a domain name through\
    \ the application of the \"First Well\n   Known Rule\", the delegative structure\
    \ of the resulting domain name\n   may not reflect any administrative division\
    \ of responsibilities\n   inherent in the original data.  While [RFC3402] requires\
    \ only that\n   the \"Application Unique String has some kind of regular, lexical\n\
    \   structure that the rules can be applied to\", DDDS is first and\n   foremost\
    \ a delegation system: its abstract stipulates that\n   \"Well-formed transformation\
    \ rules will reflect the delegation of\n   management of information associated\
    \ with the string\".  Telephone\n   numbers in the United States, for example,\
    \ are assigned and delegated\n   in a relatively complex manner.  Historically,\
    \ the first six digits\n   of a nationally specific number (called the \"NPA/NXX\"\
    ) reflected a\n   point of administrative delegation from the number assignment\
    \ agency\n   to a carrier; from these blocks of ten thousand numbers, the carrier\n\
    \   would in turn delegate individual assignments of the last four digits\n  \
    \ (the \"XXXX\" portion) to particular customers.  However, after the\n   rise\
    \ of North American telephone number portability in the 1990s, the\n   first point\
    \ of delegation went away: the delegation is effectively\n   from the number authority\
    \ to the carrier for each complete ten-digit\n   number (NPA/NXX-XXXX).  While\
    \ technical implementation details differ\n   from nation to nation, number portability\
    \ systems with similar\n   administrative delegations now exist worldwide.\n \
    \  To render these identifiers as domain names in accordance with the\n   DDDS\
    \ Rule for ENUM yields a large flat administrative domain with no\n   points of\
    \ administrative delegation from the country-code\n   administrator, e.g., 1.e164.arpa,\
    \ down to the ultimate assignee of a\n   number.  Under the assumption that one\
    \ administrative domain is\n   maintained within one DNS zone containing potentially\
    \ over five\n   billion names, scalability difficulties manifest in a number of\n\
    \   areas: the scalability that results from caching depends on these\n   points\
    \ of delegation, so that cached results for intermediate servers\n   take the\
    \ load off higher-tier servers.  If there are no such\n   delegations, then as\
    \ in the telephone number example the zone apex\n   server must bear the entire\
    \ load for queries.  Worse still, number\n   portability also introduces far more\
    \ dynamism in number assignment,\n   where in some regions updated assignees for\
    \ ported numbers must\n   propagate within fifteen minutes of a change in administration.\n\
    \   Jointly, these two problems make caching the zone extremely\n   problematic.\
    \  Moreover, traditional tools for DNS replication, such\n   as the zone transfer\
    \ protocols AXFR [RFC1034] and IXFR [RFC1995],\n   might not scale to accommodate\
    \ zones with these dimensions and\n   properties.\n   In practice, the maximum\
    \ sizes of telephone number administrative\n   domains are closer to 300M (the\
    \ current amount of allocated telephone\n   numbers in the United States today\
    \ -- still more than three times the\n   number of .com domain names), and one\
    \ can alleviate some of the\n   scalability issues mentioned above by artificially\
    \ dividing the\n   administrative domain into a hierarchy of DNS zones.  Still,\
    \ the fact\n   that traditional DNS management tools no longer apply to the\n\
    \   structures that an application tries to provision in the DNS is a\n   clue\
    \ that the DNS might not be the right place for an application to\n   store its\
    \ data.\n   While DDDS is the most obvious example of these concerns, the point\n\
    \   is more generic: for example, were address portability to be\n   implemented\
    \ for IP addresses and their administration thus to become\n   non-hierarchical,\
    \ the same concerns would apply to in-addr.arpa\n   names.  The difficulty of\
    \ mapping the DNS to administrative\n   structures can even occur with traditional\
    \ domain names, where\n   applications expect clients to infer or locate zone\
    \ cuts.  In the web\n   context, for example, it can be difficult for applications\
    \ to\n   determine whether two domains represent the same \"site\" when\n   comparing\
    \ security credentials with URLs (see Section 3.4 below for\n   more on this).\
    \  This has also caused known problems in determining\n   the scope of web cookies,\
    \ in contexts where applications must infer\n   where administrative domains end\
    \ in order to grant cookies that are\n   as narrowly scoped as possible.\n   In\
    \ summary, the \"First Well Known Rule\" of DDDS provides a capability\n   that\
    \ transforms arbitrary strings into domain names, but those names\n   play well\
    \ with the DNS only when the input strings have an\n   administrative structure\
    \ that maps to DNS delegations.  In the first\n   place, delegation implies some\
    \ sort of hierarchical structure.  Any\n   mechanism to map a hierarchical identifier\
    \ into a domain name should\n   be constructed such that the resulting domain\
    \ name does match the\n   natural hierarchy of the original identifier.  Although\
    \ telephone\n   numbers, even in North America, have some hierarchical qualities\n\
    \   (like the geographical areas corresponding to their first three\n   digits),\
    \ after the implementation of number portability these points\n   no longer mapped\
    \ onto an administrative delegation.  If the input\n   string to the DDDS does\
    \ not have a hierarchical structure\n   representing administrative delegations\
    \ that can map onto the DNS\n   distribution system, then that string probably\
    \ is not a good\n   candidate for translating into a domain name.\n"
- title: 3.3.1.  Metadata about Tree Structure
  contents:
  - "3.3.1.  Metadata about Tree Structure\n   There are also other ways in which\
    \ the delegative structure of an\n   identifier may not map well onto the DNS.\
    \  Traditionally, DNS\n   resolvers assume that when they receive a domain name\
    \ from an\n   application the name is complete -- that it is not a fragment of\
    \ a\n   domain name that a user is still in the middle of typing.  For some\n\
    \   communications systems, however, this assumption does not apply.\n   ENUM\
    \ use cases have surfaced a couple of optimization requirements to\n   reduce\
    \ unnecessary calls and queries; proposed solutions include\n   metadata in the\
    \ DNS that describes the contents and structure of ENUM\n   DNS trees to help\
    \ applications handle incomplete queries or queries\n   for domains not in use.\n\
    \   In particular, the \"send-n\" proposal [ENUM-Send-N] hoped to reduce\n   the\
    \ number of DNS queries sent in regions with variable-length\n   numbering plans.\
    \  When a dialed number potentially has a variable\n   length, a telephone switch\
    \ ordinarily cannot anticipate when a dialed\n   number is complete, as only the\
    \ numbering plan administrator (who may\n   be a national regulator, or even in\
    \ open number plans a private\n   branch exchange) knows how long a telephone\
    \ number needs to be.\n   Consequently, a switch trying to resolve such a number\
    \ through a\n   system like ENUM might send a query for a telephone number that\
    \ has\n   only partially been dialed in order to test its completeness.  The\n\
    \   send-n proposal installs in the DNS a hint informing the telephone\n   switch\
    \ of the minimum number of digits that must be collected by\n   placing in zones\
    \ corresponding to incomplete telephone numbers some\n   resource records that\
    \ state how many more digits are required --\n   effectively how many steps down\
    \ the DNS tree one must take before\n   querying the DNS again.  Unsurprisingly,\
    \ those boundaries reflect\n   points of administrative delegation, where the\
    \ parent in a number\n   plan yields authority to a child.  With this information,\
    \ the\n   application is not required to query the DNS every time a new digit\n\
    \   is dialed but can wait to collect sufficient digits to receive a\n   response.\
    \  As an optimization, this practice thus saves the resources\n   of the DNS server,\
    \ though the call cannot complete until all digits\n   are collected, so this\
    \ mechanism simply reduces the time the system\n   will wait before sending an\
    \ ENUM query after collecting the final\n   dialed digit.  A tangentially related\
    \ proposal, [ENUM-UNUSED],\n   similarly places resource records in the DNS that\
    \ tell the\n   application that it need not attempt to reach a number on the\n\
    \   telephone network, as the number is unassigned -- a comparable\n   general\
    \ DNS mechanism would identify, for a domain name with no\n   records available\
    \ in the DNS, whether or not the domain had been\n   allocated by a registry to\
    \ a registrant (which is a different\n   condition than a name merely being unresolvable,\
    \ per the semantics of\n   NXDOMAIN).\n   Both proposals optimize application\
    \ behavior by placing metadata in\n   the DNS that predicts the success of future\
    \ queries or application\n   invocation by identifying points of administrative\
    \ delegation or\n   assignment in the tree.  In some respects, marking a point\
    \ in the\n   tree where a zone begins or ends has some features in common with\
    \ the\n   traditional parent zone use of the NS record type, except that\n   instead\
    \ of pointing to a child zone these metadata proposals point to\n   distant grandchildren.\
    \  While this does not change resolver behavior\n   as such (instead, it changes\
    \ the way that applications invoke the\n   resolver), it does have implications\
    \ for the practices for zone\n   administrators.  Metadata in one administrative\
    \ domain would need to\n   remain synchronized with the state of the resources\
    \ it predicts in\n   another administrative domain in the DNS namespace, in a\
    \ case like\n   overlap dialing where the carrier delegates to a zone controlled\
    \ by\n   an enterprise.  When dealing with external resources associated with\n\
    \   other namespaces, like number assignments in the PSTN or the\n   databases\
    \ of a registry operator, other synchronization requirements\n   arise; maintaining\
    \ that synchronization requires that the DNS have\n   \"semi-real time\" updates\
    \ that may conflict with scale and caching\n   mechanisms of the DNS.\n   Placing\
    \ metadata in the DNS may also raise questions about the\n   authority and delegation\
    \ model.  Who gets to supply records for\n   unassigned names?  While in the original\
    \ but little-used e164.arpa\n   root of ENUM this would almost certainly be a\
    \ numbering plan\n   administrator, it is far less clear who that would be in\
    \ the more\n   common and successful \"infrastructure\" ENUM models (see Section\
    \ 4).\n   Ultimately, these metadata proposals share some qualities with DNS\n\
    \   redirection services offered by ISPs (for example, [DNS-REDIRECT])\n   that\
    \ \"help\" web users who try to browse to sites that do not exist.\n   Similarly,\
    \ metadata proposals like [ENUM-UNUSED] create DNS records\n   for unallocated\
    \ zones that redirect to a service provider's web page.\n   However, in the [DNS-REDIRECT]\
    \ cases, at least the existence or\n   non-existence of a domain name is a fact\
    \ about the Internet\n   namespace, rather than about an external namespace like\
    \ the telephony\n   E.164 namespace (which must be synchronized with the DNS tree\
    \ in the\n   metadata proposals).  In send-n, different leaf zones that administer\n\
    \   telephone numbers of different lengths can only provision their hints\n  \
    \ at their own apex, which provides an imperfect optimization: they\n   cannot\
    \ install it themselves in a parent, both because they lack the\n   authority\
    \ and because different zones would want to provision\n   contradictory data.\
    \  The later the hint appears in the tree, however,\n   the less optimization\
    \ will result.  An application protocol designer\n   managing identifiers whose\
    \ administrative model does not map well\n   onto the DNS namespace and delegations\
    \ structure would be better\n   served to implement such features outside the\
    \ DNS.\n"
- title: 3.4.  Domain Redirection
  contents:
  - "3.4.  Domain Redirection\n   Most Internet application services provide a redirection\
    \ feature --\n   when one attempts to contact a service, the service may refer\
    \ the\n   person to a different service instance, potentially in another\n   domain,\
    \ that is for whatever reason better suited to service a\n   request.  In HTTP\
    \ and SIP, for example, this feature is implemented\n   by the 300 class responses\
    \ containing one or more URIs, which may\n   indicate that a resource has moved\
    \ temporarily or permanently to\n   another service.  Several tools in the DNS,\
    \ including the SRV record,\n   can provide a similar feature at a DNS level,\
    \ and consequently some\n   applications as an optimization offload the responsibility\
    \ for\n   redirection to the DNS; NAPTR can also provide this capability on a\n\
    \   per-application basis, and numerous DNS resource records can provide\n   redirection\
    \ on a per-domain basis.  This can prevent the unnecessary\n   expenditure of\
    \ application resources on a function that could be\n   performed as a component\
    \ of a DNS lookup that is already a\n   prerequisite for contacting the service.\
    \  Consequently, in some\n   deployment architectures this DNS-layer redirection\
    \ is used for\n   virtual hosting services.\n   Implementing domain redirection\
    \ in the DNS, however, has important\n   consequences for application security.\
    \  In the absence of universal\n   DNSSEC, applications must blindly trust that\
    \ their request has not\n   been hijacked at the DNS layer and redirected to a\
    \ potentially\n   malicious domain, unless some subsequent application mechanism\
    \ can\n   provide the necessary assurance.  By way of contrast, application-\n\
    \   layer protocols supporting redirection, such as HTTP and SIP, have\n   available\
    \ security mechanisms, including TLS, that can use\n   certificates to attest\
    \ that a 300 response came from the domain that\n   the originator initially hoped\
    \ to contact.\n   A number of applications have attempted to provide an after-the-fact\n\
    \   security mechanism that verifies the authority of a DNS delegation in\n  \
    \ the absence of DNSSEC.  The specification for dereferencing SIP URIs\n   ([RFC3263],\
    \ reaffirmed in [RFC5922]), requires that during TLS\n   establishment the site\
    \ eventually reached by a SIP request present a\n   certificate corresponding\
    \ to the original URI expected by the user;\n   this requires a virtual hosting\
    \ service to possess a certificate\n   corresponding to the hosted domain.  (In\
    \ other words, if example.com\n   redirects to example.net in the DNS, this mechanism\
    \ expects that\n   example.net will supply a certificate for example.com in TLS,\
    \ per the\n   HTTP precedent in [RFC2818]).  This restriction rules out many styles\n\
    \   of hosting deployments common in the web world today, however.\n   [HARD-PROBLEM]\
    \ explores this problem space.  [RFC6125] proposes a\n   solution for all applications\
    \ that use TLS, which relies on new\n   application-specific identifiers in certificates,\
    \ as does [RFC4985]);\n   note, however, that support for such certificates would\
    \ require\n   changes to existing certificate authority practices as well as\n\
    \   application behavior.  With DNSSEC in place, DNS-based Authentication\n  \
    \ of Named Entities (DANE) [RFC6394] offers another way to bind\n   certificates\
    \ to particular applications and services.\n   All of these application-layer\
    \ measures attempt to mirror the\n   delegation of administrative authority in\
    \ the DNS, when the DNS\n   itself serves as the ultimate authority on how domains\
    \ are delegated.\n   (Note: changing the technical delegation structure by changing\
    \ NS\n   records in the DNS is not the same as administrative delegation,\n  \
    \ e.g., when a domain changes ownership.)  Synchronizing a static\n   instrument\
    \ like a certificate with a delegation in the DNS, however,\n   is problematic\
    \ because delegations are not static: revoking and\n   reissuing a certificate\
    \ every time an administrative delegation\n   changes is cumbersome operationally.\
    \  In environments where DNSSEC is\n   not available, the problems with securing\
    \ DNS-layer redirections\n   would be avoided by performing redirections in the\
    \ application layer.\n   This inevitably gives rise to various design trade-offs\
    \ involving\n   performance, load, and related factors, but in these application\n\
    \   environments, the security properties typically take priority.\n"
- title: 4.  Private DNS and Split Horizon
  contents:
  - "4.  Private DNS and Split Horizon\n   The classic view of the uniqueness of domain\
    \ names in the DNS is\n   given in [RFC2826]:\n      DNS names are designed to\
    \ be globally unique, that is, for any one\n      DNS name at any one time there\
    \ must be a single set of DNS records\n      uniquely describing protocol addresses,\
    \ network resources and\n      services associated with that DNS name.  All of\
    \ the applications\n      deployed on the Internet which use the DNS assume this,\
    \ and\n      Internet users expect such behavior from DNS names.\n   [RFC2826]\
    \ \"does not preclude private networks from operating their\n   own private name\
    \ spaces\" but notes that if private networks \"wish to\n   make use of names\
    \ uniquely defined for the global Internet, they have\n   to fetch that information\
    \ from the global DNS naming hierarchy\".\n   There are various DNS deployments\
    \ outside of the global public DNS,\n   including \"split horizon\" deployments\
    \ and DNS usages on private (or\n   virtual private) networks.  In a split horizon,\
    \ an authoritative\n   server gives different responses to queries from the public\
    \ Internet\n   than they do to internal resolvers; while some deployments\n  \
    \ differentiate internal queries from public queries by the source IP\n   address,\
    \ the concerns in Section 3.1.1 relating to trusting source IP\n   addresses apply\
    \ to such deployments.  When the internal address space\n   range is private [RFC1918],\
    \ this makes it both easier for the server\n   to discriminate public from private\
    \ and harder for public entities to\n   impersonate nodes in the private network.\
    \  Networks that are made\n   private physically, or logically by cryptographic\
    \ tunnels, make these\n   private deployments more secure.  The most complex deployments\
    \ along\n   these lines use multiple virtual private networks to serve different\n\
    \   answers for the same name to many distinct networks.\n   The use cases that\
    \ motivate split-horizon DNS typically involve\n   restricting access to some\
    \ network services -- intranet resources\n   such as internal web sites, development\
    \ servers, or directories, for\n   example -- while preserving the ease of use\
    \ offered by domain names\n   for internal users.  While for many of these resources\
    \ the split\n   horizon would not return answers to public resolvers for those\n\
    \   internal resources (those records are kept confidential from the\n   public),\
    \ in some cases the same name (e.g., \"mail.example.com\") might\n   resolve to\
    \ one host internally but another externally.  The\n   requirements for multiple-VPN\
    \ private deployments, however, are\n   different: in this case the authoritative\
    \ server gives different, and\n   confidential, answers to a set of resolvers\
    \ querying for the same\n   name.  While these sorts of use cases rarely arise\
    \ for traditional\n   domain names, where, as [RFC2826] says, users and applications\
    \ expect\n   a unique resolution for a name, they can easily arise when other\n\
    \   sorts of identifiers have been translated by a mechanism such as the\n   \"\
    First Well Known Rule\" of DDDS into \"domain name syntax\".  Telephone\n   calls,\
    \ for example, are traditionally routed through highly mediated\n   networks,\
    \ in which an attempt to find a route for a call often\n   requires finding an\
    \ appropriate intermediary based on the source\n   network and location rather\
    \ than finding an endpoint (see the\n   distinction between the Look-Up Function\
    \ and Location Routing\n   Function in [RFC5486]).  Moreover, the need for responses\
    \ tailored to\n   the originator, and for confidentiality, is easily motivated\
    \ when the\n   data returned by the DNS is no longer \"describing protocol addresses,\n\
    \   network resources and services\" [RFC2826] but instead is arbitrary\n   data.\
    \  Although, for example, ENUM was originally intended for\n   deployment in the\
    \ global public root of the DNS (under e164.arpa),\n   the requirements of maintaining\
    \ telephone identifiers in the DNS\n   quickly steered operators into private\
    \ deployments.\n   In private environments, it is also easier to deploy any necessary\n\
    \   extensions than it is in the public DNS: in the first place,\n   proprietary\
    \ non-standard extensions and parameters can more easily be\n   integrated into\
    \ DNS queries or responses, as the implementations of\n   resolvers and servers\
    \ can likely be controlled; secondly,\n   confidentiality and custom responses\
    \ can be provided by deploying,\n   respectively, underlying physical or virtual\
    \ private networks to\n   shield the private tree from public queries, and effectively\n\
    \   different virtual DNS trees for each administrative entity that might\n  \
    \ launch a query; thirdly, in these constrained environments, caching\n   and\
    \ recursive resolvers can be managed or eliminated in order to\n   prevent any\
    \ unexpected intermediary behavior.  While these private\n   deployments serve\
    \ an important role in the marketplace, there are\n   risks in using techniques\
    \ intended only for deployment in private and\n   constrained environments as\
    \ the basis of a standard solution.  When\n   proprietary parameters or extensions\
    \ are deployed in private\n   environments, experience teaches us that these implementations\
    \ will\n   begin to interact with the public DNS and that the private practices\n\
    \   will leak.\n   While such leakage is not a problem when using the mechanisms\n\
    \   described in Sections 3.1, 3.2, and 3.5 (with private RR types) of\n   [RFC5507],\
    \ other extension mechanisms might cause confusion or harm\n   if leaked.  The\
    \ use of a dedicated suffix (Section 3.3 of [RFC5507])\n   in a private environment\
    \ might cause confusion if leaked to the\n   public Internet, for example.\n \
    \  That this kind of leakage of protocol elements from private\n   deployments\
    \ to public deployments does happen has been demonstrated,\n   for example, with\
    \ SIP: SIP implemented a category of supposedly\n   private extensions ( the \"\
    P-\" headers) that saw widespread success\n   and use outside of the constrained\
    \ environments for which they were\n   specifically designed.  There is no reason\
    \ to think that\n   implementations with similar \"private\" extensions to the\
    \ DNS\n   protocols would not similarly end up in use in public environments.\n"
- title: 5.  Principles and Guidance
  contents:
  - "5.  Principles and Guidance\n   The success of the global public DNS relies on\
    \ the fact that it is a\n   distributed database, one that has the property that\
    \ it is loosely\n   coherent and offers lookup instead of search functionality.\
    \  Loose\n   coherency means that answers to queries are coherent within the\n\
    \   bounds of data replication between authoritative servers (as\n   controlled\
    \ by the administrator of the zone) and caching behavior by\n   recursive name\
    \ servers.  Today, this term increasingly must also\n   include load-balancing\
    \ or related features that rely on the source IP\n   address of the resolver.\
    \  It is critical that application designers\n   who intend to use the DNS to\
    \ support their applications consider the\n   implications that their uses have\
    \ for the behavior of resolvers;\n   intermediaries, including caches and recursive\
    \ resolvers; and\n   authoritative servers.\n   It is likely that the DNS provides\
    \ a good match whenever the needs of\n   applications are aligned with the following\
    \ properties:\n   o  Data stored in the DNS can be propagated and cached using\n\
    \      conventional DNS mechanisms, without intermediaries needing to\n      understand\
    \ exceptional logic (considerations beyond the name,\n      type, and class of\
    \ the query) used by the authoritative server to\n      formulate responses\n\
    \   o  Data stored in the DNS is indexed by keys that do not violate the\n   \
    \   syntax or semantics of domain names\n   o  Applications invoke the DNS to\
    \ resolve complete names, not\n      fragments\n   o  Answers do not depend on\
    \ an application-layer identity of the\n      entity doing the query\n   o  Ultimately,\
    \ applications invoke the DNS to assist in communicating\n      with a service\
    \ whose name is resolved through the DNS\n   Whenever one of the five properties\
    \ above does not apply to one's\n   data, one should seriously consider whether\
    \ the DNS is the best place\n   to store actual data.  On the other hand, if one\
    \ has to worry about\n   the following items, then these items are good indicators\
    \ that the\n   DNS is not the appropriate tool for solving problems:\n   o  Populating\
    \ metadata about domain boundaries within the tree -- the\n      points of administrative\
    \ delegation in the DNS are something that\n      applications are not in general\
    \ aware of\n   o  Domain names derived from identifiers that do not share a semantic\n\
    \      or administrative model compatible with the DNS\n   o  Selective disclosure\
    \ of data stored in and provided by the DNS\n   o  DNS responses not fitting into\
    \ UDP packets, unless EDNS(0) is\n      available, and only then with the caveats\
    \ discussed in\n      Section 3.2.1\n   In cases where applications require these\
    \ sorts of features, they are\n   likely better instantiated by independent application-layer\
    \ protocols\n   than the DNS.  For example, the objects that HTTP can carry in\
    \ both\n   queries and responses can easily contain the necessary structure to\n\
    \   manage compound queries.  Many applications already use HTTP because\n   of\
    \ widespread support for it in middleboxes.  Similarly, HTTP has\n   numerous\
    \ ways to provide the necessary authentication, authorization,\n   and confidentiality\
    \ properties that some features require, as well as\n   the redirection properties\
    \ discussed in Section 3.4.  These\n   differences highlight the fact that the\
    \ DNS and HTTP offer very\n   different services and have different applicabilities;\
    \ while both are\n   query-response protocols, HTTP should not be doing the job\
    \ of DNS,\n   and DNS should not be doing the job of HTTP.  Similarly, DNS should\n\
    \   not be doing the job of Diameter, LDAP, or other application-layer\n   protocols.\
    \  The overhead of using any application-layer protocol may\n   not be appropriate\
    \ for all environments, of course, but even in\n   environments where a more lightweight\
    \ protocol is appropriate, DNS is\n   usually not the only alternative.\n   Where\
    \ the administrative delegations of the DNS form a necessary\n   component in\
    \ the instantiation of an application feature, there are\n   various ways that\
    \ the DNS can bootstrap access to an independent\n   application-layer protocol\
    \ better suited to field the queries in\n   question.  For example, since NAPTR\
    \ or URI [URI-RR] Resource Records\n   can contain URIs, those URIs can in turn\
    \ point to an external query-\n   response service such as an HTTP service where\
    \ more syntactically and\n   semantically rich queries and answers might be exchanged.\
    \  Any\n   protocol designer considering where to implement features must\n  \
    \ perform their own gap analysis and determine whether or not\n   implementing\
    \ some features is worth the potential cost in increased\n   network state, latency,\
    \ and so on, but implementing some features\n   simply requires heavier structures\
    \ than others.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Many of the concerns about how applications use\
    \ the DNS discussed in\n   this document involve security.  The perceived need\
    \ to authenticate\n   the source of DNS queries (see Section 3.1.1) and authorize\
    \ access to\n   particular resource records also illustrates the fundamental security\n\
    \   principles that arise from offloading certain application features to\n  \
    \ the DNS.  As Section 3.2.1 observes, large data in the DNS can\n   provide a\
    \ means of generating reflection attacks, and without the\n   remedies discussed\
    \ in that section (regarding the use of EDNS(0) and\n   TCP) the presence of large\
    \ sets of records (e.g., ANY queries) is not\n   recommended.  Section 3.4 discusses\
    \ a security problem concerning\n   redirection that has surfaced in a number\
    \ of protocols (see\n   [HARD-PROBLEM]).\n   While DNSSEC, were it deployed universally,\
    \ can play an important\n   part in securing application redirection in the DNS,\
    \ DNSSEC does not\n   provide a means for a resolver to authenticate itself to\
    \ a server,\n   nor a framework for servers to return selective answers based\
    \ on the\n   authenticated identity of resolvers, nor a confidential mechanism.\n\
    \   Some implementations may support authenticating users through TSIG,\n   provided\
    \ that the security association with a compliant server has\n   been pre-established,\
    \ though authentication is typically not needed\n   for queries in the global\
    \ public DNS.  The existing feature set of\n   DNSSEC is, however, sufficient\
    \ for providing security for most of the\n   ways that applications traditionally\
    \ have used the DNS.  The\n   deployment of DNSSEC ([RFC4033] and related specifications)\
    \ is\n   heartily encouraged.  Nothing in this document is intended to\n   discourage\
    \ the implementation, deployment, or use of Secure DNS\n   Dynamic Updates [RFC3007],\
    \ though this document does recommend that\n   large data in the DNS be treated\
    \ in accordance with the guidance in\n   Section 3.2.1.\n"
- title: 7.  IAB Members at the Time of Approval
  contents:
  - "7.  IAB Members at the Time of Approval\n   Internet Architecture Board Members\
    \ at the time this document was\n   approved were:\n   Bernard Aboba\n   Jari\
    \ Arkko\n   Marc Blanchet\n   Ross Callon\n   Alissa Cooper\n   Spencer Dawkins\n\
    \   Joel Halpern\n   Russ Housley\n   David Kessens\n   Danny McPherson\n   Jon\
    \ Peterson\n   Dave Thaler\n   Hannes Tschofenig\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   The IAB appreciates the comments and often spirited\
    \ disagreements of\n   Eric Osterweil, John Levine, Stephane Bortzmeyer, Ed Lewis,\
    \ Dave\n   Crocker, Ray Bellis, Lawrence Conroy, Ran Atkinson, Patrik Faltstrom,\n\
    \   and Eliot Lear.\n"
- title: 9.  Informative References
  contents:
  - "9.  Informative References\n   [DNS-REDIRECT]\n              Creighton, T., Griffiths,\
    \ C., Livingood, J., and R. Weber,\n              \"DNS Redirect Use by Service\
    \ Providers\", Work in Progress,\n              October 2010.\n   [EDNS-CLIENT-IP]\n\
    \              Contavalli, C., van der Gaast, W., Leach, S., and D.\n        \
    \      Rodden, \"Client IP information in DNS requests\", Work in\n          \
    \    Progress, May 2010.\n   [EDNS-OPT-CODE]\n              Kaplan, H., Walter,\
    \ R., Gorman, P., and M. Maharishi,\n              \"EDNS Option Code for SIP\
    \ and PSTN Source Reference Info\",\n              Work in Progress, October 2011.\n\
    \   [ENUM-Send-N]\n              Bellis, R., \"IANA Registrations for the 'Send-N'\n\
    \              Enumservice\", Work in Progress, June 2008.\n   [ENUM-UNUSED]\n\
    \              Stastny, R., Conroy, L., and J. Reid, \"IANA Registration\n   \
    \           for Enumservice UNUSED\", Work in Progress, March 2008.\n   [HARD-PROBLEM]\n\
    \              Barnes, R. and P. Saint-Andre, \"High Assurance\n             \
    \ Re-Direction (HARD) Problem Statement\", Work in Progress,\n              July\
    \ 2010.\n   [Lindsay]  Lindsay, G., \"DNSSEC and DNS Amplification Attacks\",\n\
    \              April 2012.\n   [RFC0882]  Mockapetris, P., \"Domain names: Concepts\
    \ and facilities\",\n              RFC 882, November 1983.\n   [RFC0883]  Mockapetris,\
    \ P., \"Domain names: Implementation\n              specification\", RFC 883,\
    \ November 1983.\n   [RFC0974]  Partridge, C., \"Mail routing and the domain system\"\
    ,\n              STD 10, RFC 974, January 1986.\n   [RFC1034]  Mockapetris, P.,\
    \ \"Domain names - concepts and facilities\",\n              STD 13, RFC 1034,\
    \ November 1987.\n   [RFC1035]  Mockapetris, P., \"Domain names - implementation\
    \ and\n              specification\", STD 13, RFC 1035, November 1987.\n   [RFC1464]\
    \  Rosenbaum, R., \"Using the Domain Name System To Store\n              Arbitrary\
    \ String Attributes\", RFC 1464, May 1993.\n   [RFC1530]  Malamud, C. and M. Rose,\
    \ \"Principles of Operation for the\n              TPC.INT Subdomain: General\
    \ Principles and Policy\",\n              RFC 1530, October 1993.\n   [RFC1794]\
    \  Brisco, T., \"DNS Support for Load Balancing\", RFC 1794,\n              April\
    \ 1995.\n   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G.,\n\
    \              and E. Lear, \"Address Allocation for Private Internets\",\n  \
    \            BCP 5, RFC 1918, February 1996.\n   [RFC1995]  Ohta, M., \"Incremental\
    \ Zone Transfer in DNS\", RFC 1995,\n              August 1996.\n   [RFC2052]\
    \  Gulbrandsen, A. and P. Vixie, \"A DNS RR for specifying the\n             \
    \ location of services (DNS SRV)\", RFC 2052, October 1996.\n   [RFC2168]  Daniel,\
    \ R. and M. Mealling, \"Resolution of Uniform\n              Resource Identifiers\
    \ using the Domain Name System\",\n              RFC 2168, June 1997.\n   [RFC2181]\
    \  Elz, R. and R. Bush, \"Clarifications to the DNS\n              Specification\"\
    , RFC 2181, July 1997.\n   [RFC2397]  Masinter, L., \"The \"data\" URL scheme\"\
    , RFC 2397,\n              August 1998.\n   [RFC2671]  Vixie, P., \"Extension\
    \ Mechanisms for DNS (EDNS0)\",\n              RFC 2671, August 1999.\n   [RFC2818]\
    \  Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.\n   [RFC2826]  Internet\
    \ Architecture Board, \"IAB Technical Comment on the\n              Unique DNS\
    \ Root\", RFC 2826, May 2000.\n   [RFC2845]  Vixie, P., Gudmundsson, O., Eastlake\
    \ 3rd, D., and B.\n              Wellington, \"Secret Key Transaction Authentication\
    \ for DNS\n              (TSIG)\", RFC 2845, May 2000.\n   [RFC2915]  Mealling,\
    \ M. and R. Daniel, \"The Naming Authority Pointer\n              (NAPTR) DNS\
    \ Resource Record\", RFC 2915, September 2000.\n   [RFC2916]  Faltstrom, P., \"\
    E.164 number and DNS\", RFC 2916,\n              September 2000.\n   [RFC3007]\
    \  Wellington, B., \"Secure Domain Name System (DNS) Dynamic\n              Update\"\
    , RFC 3007, November 2000.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G., Johnston,\n              A., Peterson, J., Sparks, R., Handley, M., and\
    \ E.\n              Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n\
    \              June 2002.\n   [RFC3263]  Rosenberg, J. and H. Schulzrinne, \"\
    Session Initiation\n              Protocol (SIP): Locating SIP Servers\", RFC\
    \ 3263,\n              June 2002.\n   [RFC3401]  Mealling, M., \"Dynamic Delegation\
    \ Discovery System (DDDS)\n              Part One: The Comprehensive DDDS\", RFC\
    \ 3401, October 2002.\n   [RFC3402]  Mealling, M., \"Dynamic Delegation Discovery\
    \ System (DDDS)\n              Part Two: The Algorithm\", RFC 3402, October 2002.\n\
    \   [RFC3403]  Mealling, M., \"Dynamic Delegation Discovery System (DDDS)\n  \
    \            Part Three: The Domain Name System (DNS) Database\",\n          \
    \    RFC 3403, October 2002.\n   [RFC3596]  Thomson, S., Huitema, C., Ksinant,\
    \ V., and M. Souissi,\n              \"DNS Extensions to Support IP Version 6\"\
    , RFC 3596,\n              October 2003.\n   [RFC3986]  Berners-Lee, T., Fielding,\
    \ R., and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic\
    \ Syntax\", STD 66,\n              RFC 3986, January 2005.\n   [RFC4033]  Arends,\
    \ R., Austein, R., Larson, M., Massey, D., and S.\n              Rose, \"DNS Security\
    \ Introduction and Requirements\",\n              RFC 4033, March 2005.\n   [RFC4367]\
    \  Rosenberg, J., Ed., and IAB, \"What's in a Name: False\n              Assumptions\
    \ about DNS Names\", RFC 4367, February 2006.\n   [RFC4398]  Josefsson, S., \"\
    Storing Certificates in the Domain Name\n              System (DNS)\", RFC 4398,\
    \ March 2006.\n   [RFC4732]  Handley, M., Ed., Rescorla, E., Ed., and IAB, \"\
    Internet\n              Denial-of-Service Considerations\", RFC 4732,\n      \
    \        December 2006.\n   [RFC4985]  Santesson, S., \"Internet X.509 Public\
    \ Key Infrastructure\n              Subject Alternative Name for Expression of\
    \ Service Name\",\n              RFC 4985, August 2007.\n   [RFC5486]  Malas,\
    \ D., Ed., and D. Meyer, Ed., \"Session Peering for\n              Multimedia\
    \ Interconnect (SPEERMINT) Terminology\",\n              RFC 5486, March 2009.\n\
    \   [RFC5507]  IAB, Faltstrom, P., Ed., Austein, R., Ed., and P. Koch,\n     \
    \         Ed., \"Design Choices When Expanding the DNS\", RFC 5507,\n        \
    \      April 2009.\n   [RFC5922]  Gurbani, V., Lawrence, S., and A. Jeffrey, \"\
    Domain\n              Certificates in the Session Initiation Protocol (SIP)\"\
    ,\n              RFC 5922, June 2010.\n   [RFC6055]  Thaler, D., Klensin, J.,\
    \ and S. Cheshire, \"IAB Thoughts on\n              Encodings for Internationalized\
    \ Domain Names\", RFC 6055,\n              February 2011.\n   [RFC6125]  Saint-Andre,\
    \ P. and J. Hodges, \"Representation and\n              Verification of Domain-Based\
    \ Application Service Identity\n              within Internet Public Key Infrastructure\
    \ Using X.509\n              (PKIX) Certificates in the Context of Transport Layer\n\
    \              Security (TLS)\", RFC 6125, March 2011.\n   [RFC6269]  Ford, M.,\
    \ Ed., Boucadair, M., Durand, A., Levis, P., and\n              P. Roberts, \"\
    Issues with IP Address Sharing\", RFC 6269,\n              June 2011.\n   [RFC6376]\
    \  Crocker, D., Ed., Hansen, T., Ed., and M. Kucherawy, Ed.,\n              \"\
    DomainKeys Identified Mail (DKIM) Signatures\", RFC 6376,\n              September\
    \ 2011.\n   [RFC6394]  Barnes, R., \"Use Cases and Requirements for DNS-Based\n\
    \              Authentication of Named Entities (DANE)\", RFC 6394,\n        \
    \      October 2011.\n   [RFC6763]  Cheshire, S. and M. Krochmal, \"DNS-Based\
    \ Service\n              Discovery\", RFC 6763, February 2013.\n   [RFC6891] \
    \ Damas, J., Graff, M., and P. Vixie, \"Extension Mechanisms\n              for\
    \ DNS (EDNS(0))\", STD 75, RFC 6891, April 2013.\n   [URI-RR]   Faltstrom, P.\
    \ and O. Kolkman, \"The Uniform Resource\n              Identifier (URI) DNS Resource\
    \ Record\", Work in Progress,\n              July 2013.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jon Peterson\n   NeuStar, Inc.\n   EMail: jon.peterson@neustar.biz\n\
    \   Olaf Kolkman\n   NLnet Labs\n   EMail: olaf@nlnetlabs.nl\n   Hannes Tschofenig\n\
    \   Nokia Siemens Networks\n   EMail: Hannes.Tschofenig@gmx.net\n   Bernard Aboba\n\
    \   Skype\n   EMail: Bernard_aboba@hotmail.com\n"
