- title: __initial_text__
  contents:
  - "               Resolution of Uniform Resource Identifiers\n                 \
    \     using the Domain Name System\n"
- title: Status of this Memo
  contents:
  - 'Status of this Memo

    '
- title: ===================
  contents:
  - "===================\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  This memo does not specify an Internet standard of any\n   kind.\
    \  Discussion and suggestions for improvement are requested.\n   Distribution\
    \ of this memo is unlimited.\n"
- title: 'Abstract:'
  contents:
  - 'Abstract:

    '
- title: =========
  contents:
  - "=========\n   Uniform Resource Locators (URLs) are the foundation of the World\
    \ Wide\n   Web, and are a vital Internet technology. However, they have proven\n\
    \   to be brittle in practice. The basic problem is that URLs typically\n   identify\
    \ a particular path to a file on a particular host. There is\n   no graceful way\
    \ of changing the path or host once the URL has been\n   assigned. Neither is\
    \ there a graceful way of replicating the resource\n   located by the URL to achieve\
    \ better network utilization and/or fault\n   tolerance. Uniform Resource Names\
    \ (URNs) have been hypothesized as a\n   adjunct to URLs that would overcome such\
    \ problems. URNs and URLs are\n   both instances of a broader class of identifiers\
    \ known as Uniform\n   Resource Identifiers (URIs).\n   The requirements document\
    \ for URN resolution systems[15] defines the\n   concept of a \"resolver discovery\
    \ service\". This document describes\n   the first, experimental, RDS. It is implemented\
    \ by a new DNS Resource\n   Record, NAPTR (Naming Authority PoinTeR), that provides\
    \ rules for\n   mapping parts of URIs to domain names.  By changing the mapping\n\
    \   rules, we can change the host that is contacted to resolve a URI.\n   This\
    \ will allow a more graceful handling of URLs over long time\n   periods, and\
    \ forms the foundation for a new proposal for Uniform\n   Resource Names.\n  \
    \ In addition to locating resolvers, the NAPTR provides for other\n   naming systems\
    \ to be grandfathered into the URN world, provides\n   independence between the\
    \ name assignment system and the resolution\n   protocol system, and allows multiple\
    \ services (Name to Location, Name\n   to Description, Name to Resource, ...)\
    \ to be offered.  In conjunction\n   with the SRV RR, the NAPTR record allows\
    \ those services to be\n   replicated for the purposes of fault tolerance and\
    \ load balancing.\n"
- title: 'Introduction:'
  contents:
  - 'Introduction:

    '
- title: =============
  contents:
  - "=============\n   Uniform Resource Locators have been a significant advance in\n\
    \   retrieving Internet-accessible resources. However, their  brittle\n   nature\
    \ over time has been recognized for several years. The Uniform\n   Resource Identifier\
    \ working group proposed the development of Uniform\n   Resource Names to serve\
    \ as persistent, location-independent\n   identifiers for Internet resources in\
    \ order to overcome most of the\n   problems with URLs. RFC-1737 [1] sets forth\
    \ requirements on URNs.\n   During the lifetime of the URI-WG, a number of URN\
    \ proposals were\n   generated. The developers of several of those proposals met\
    \ in a\n   series of meetings, resulting in a compromise known as the Knoxville\n\
    \   framework.  The major principle behind the Knoxville framework is\n   that\
    \ the resolution system must be separate from the way names are\n   assigned.\
    \ This is in marked contrast to most URLs, which identify the\n   host to contact\
    \ and the protocol to use. Readers are referred to [2]\n   for background on the\
    \ Knoxville framework and for additional\n   information on the context and purpose\
    \ of this proposal.\n   Separating the way names are resolved from the way they\
    \ are\n   constructed provides several benefits. It allows multiple naming\n \
    \  approaches and resolution approaches to compete, as it allows\n   different\
    \ protocols and resolvers to be used. There is just one\n   problem with such\
    \ a separation - how do we resolve a name when it\n   can't give us directions\
    \ to its resolver?\n   For the short term, DNS is the obvious candidate for the\
    \ resolution\n   framework, since it is widely deployed and understood. However,\
    \ it is\n   not appropriate to use DNS to maintain information on a per-resource\n\
    \   basis. First of all, DNS was never intended to handle that many\n   records.\
    \ Second, the limited record size is inappropriate for catalog\n   information.\
    \ Third, domain names are not appropriate as URNs.\n   Therefore our approach\
    \ is to use DNS to locate \"resolvers\" that can\n   provide information on individual\
    \ resources, potentially including\n   the resource itself. To accomplish this,\
    \ we \"rewrite\" the URI into a\n   domain name following the rules provided in\
    \ NAPTR records. Rewrite\n   rules provide considerable power, which is important\
    \ when trying to\n   meet the goals listed above. However, collections of rules\
    \ can become\n   difficult to understand. To lessen this problem, the NAPTR rules\
    \ are\n   *always* applied to the original URI, *never* to the output of\n   previous\
    \ rules.\n   Locating a resolver through the rewrite procedure may take multiple\n\
    \   steps, but the beginning is always the same. The start of the URI is\n   scanned\
    \ to extract its colon-delimited prefix. (For URNs, the prefix\n   is always \"\
    urn:\" and we extract the following colon-delimited\n   namespace identifier [3]).\
    \ NAPTR resolution begins by taking the\n   extracted string, appending the well-known\
    \ suffix \".urn.net\", and\n   querying the DNS for NAPTR records at that domain\
    \ name.  Based on the\n   results of this query, zero or more additional DNS queries\
    \ may be\n   needed to locate resolvers for the URI. The details of the\n   conversation\
    \ between the client and the resolver thus located are\n   outside the bounds\
    \ of this draft. Three brief examples of this\n   procedure are given in the next\
    \ section.\n   The NAPTR RR provides the level of indirection needed to keep the\n\
    \   naming system independent of the resolution system, its protocols,\n   and\
    \ services.  Coupled with the new SRV resource record proposal[4]\n   there is\
    \ also the potential for replicating the resolver on multiple\n   hosts, overcoming\
    \ some of the most significant problems of URLs. This\n   is an important and\
    \ subtle point. Not only do the NAPTR and SRV\n   records allow us to replicate\
    \ the resource, we can replicate the\n   resolvers that know about the replicated\
    \ resource. Preventing a\n   single point of failure at the resolver level is\
    \ a significant\n   benefit. Separating the resolution procedure from the way\
    \ names are\n   constructed has additional benefits.  Different resolution procedures\n\
    \   can be used over time, and resolution procedures that are determined\n   to\
    \ be useful can be extended to deal with additional namespaces.\n"
- title: Caveats
  contents:
  - 'Caveats

    '
- title: =======
  contents:
  - "=======\n   The NAPTR proposal is the first resolution procedure to be considered\n\
    \   by the URN-WG. There are several concerns about the proposal which\n   have\
    \ motivated the group to recommend it for publication as an\n   Experimental rather\
    \ than a standards-track RFC.\n   First, URN resolution is new to the IETF and\
    \ we wish to gain\n   operational experience before recommending any procedure\
    \ for the\n   standards track. Second, the NAPTR proposal is based on DNS and\n\
    \   consequently inherits concerns about security and administration. The\n  \
    \ recent advancement of the DNSSEC and secure update drafts to Proposed\n   Standard\
    \ reduce these concerns, but we wish to experiment with those\n   new capabilities\
    \ in the context of URN administration.  A third area\n   of concern is the potential\
    \ for a noticeable impact on the DNS.  We\n   believe that the proposal makes\
    \ appropriate use of caching and\n   additional information, but it is best to\
    \ go slow where the potential\n   for impact on a core system like the DNS is\
    \ concerned. Fourth, the\n   rewrite rules in the NAPTR proposal are based on\
    \ regular expressions.\n   Since regular expressions are difficult for humans\
    \ to construct\n   correctly, concerns exist about the usability and maintainability\
    \ of\n   the rules. This is especially true where international character sets\n\
    \   are concerned. Finally, the URN-WG is developing a requirements\n   document\
    \ for URN Resolution Services[15], but that document is not\n   complete. That\
    \ document needs to precede any resolution service\n   proposals on the standards\
    \ track.\n"
- title: Terminology
  contents:
  - 'Terminology

    '
- title: ===========
  contents:
  - "===========\n   \"Must\" or \"Shall\" - Software that does not behave in the\
    \ manner that\n              this document says it must is not conformant to this\n\
    \              document.\n   \"Should\" - Software that does not follow the behavior\
    \ that this\n              document says it should may still be conformant, but\
    \ is\n              probably broken in some fundamental way.\n   \"May\" -   \
    \ Implementations may or may not provide the described\n              behavior,\
    \ while still remaining conformant to this\n              document.\n"
- title: 'Brief overview and examples of the NAPTR RR:'
  contents:
  - 'Brief overview and examples of the NAPTR RR:

    '
- title: ============================================
  contents:
  - "============================================\n   A detailed description of the\
    \ NAPTR RR will be given later, but to\n   give a flavor for the proposal we first\
    \ give a simple description of\n   the record and three examples of its use.\n\
    \   The key fields in the NAPTR RR are order, preference, service, flags,\n  \
    \ regexp, and replacement:\n   * The order field specifies the order in which\
    \ records MUST be\n     processed when multiple NAPTR records are returned in\
    \ response to a\n     single query.  A naming authority may have delegated a portion\
    \ of\n     its namespace to another agency. Evaluating the NAPTR records in\n\
    \     the correct order is necessary for delegation to work properly.\n   * The\
    \ preference field specifies the order in which records SHOULD be\n     processed\
    \ when multiple NAPTR records have the same value of\n     \"order\".  This field\
    \ lets a service provider specify the order in\n     which resolvers are contacted,\
    \ so that more capable machines are\n     contacted in preference to less capable\
    \ ones.\n   * The service field specifies the resolution protocol and resolution\n\
    \     service(s) that will be available if the rewrite specified by the\n    \
    \ regexp or replacement fields is applied. Resolution protocols are\n     the\
    \ protocols used to talk with a resolver. They will be specified\n     in other\
    \ documents, such as [5]. Resolution services are operations\n     such as N2R\
    \ (URN to Resource), N2L (URN to URL), N2C (URN to URC),\n     etc.  These will\
    \ be discussed in the URN Resolution Services\n     document[6], and their behavior\
    \ in a particular resolution protocol\n     will be given in the specification\
    \ for that protocol (see [5] for a\n     concrete example).\n   * The flags field\
    \ contains modifiers that affect what happens in the\n     next DNS lookup, typically\
    \ for optimizing the process. Flags may\n     also affect the interpretation of\
    \ the other fields in the record,\n     therefore, clients MUST skip NAPTR records\
    \ which contain an unknown\n     flag value.\n   * The regexp field is one of\
    \ two fields used for the rewrite rules,\n     and is the core concept of the\
    \ NAPTR record. The regexp field is a\n     String containing a sed-like substitution\
    \ expression. (The actual\n     grammar for the substitution expressions is given\
    \ later in this\n     draft). The substitution expression is applied to the original\
    \ URN\n     to determine the next domain name to be queried. The regexp field\n\
    \     should be used when the domain name to be generated is conditional\n   \
    \  on information in the URI. If the next domain name is always known,\n     which\
    \ is anticipated to be a common occurrence, the replacement\n     field should\
    \ be used instead.\n   * The replacement field is the other field that may be\
    \ used for the\n     rewrite rule. It is an optimization of the rewrite process\
    \ for the\n     case where the next domain name is fixed instead of being\n  \
    \   conditional on the content of the URI. The replacement field is a\n     domain\
    \ name (subject to compression if a DNS sender knows that a\n     given recipient\
    \ is able to decompress names in this RR type's RDATA\n     field). If the rewrite\
    \ is more complex than a simple substitution\n     of a domain name, the replacement\
    \ field should be set to . and the\n     regexp field used.\n   Note that the\
    \ client applies all the substitutions and performs all\n   lookups, they are\
    \ not performed in the DNS servers. Note also that it\n   is the belief of the\
    \ developers of this document that regexps should\n   rarely be used. The replacement\
    \ field seems adequate for the vast\n   majority of situations. Regexps are only\
    \ necessary when portions of a\n   namespace are to be delegated to different\
    \ resolvers. Finally, note\n   that the regexp and replacement fields are, at\
    \ present, mutually\n   exclusive. However, developers of client software should\
    \ be aware\n   that a new flag might be defined which requires values in both\n\
    \   fields.\n"
- title: Example 1
  contents:
  - 'Example 1

    '
- title: '---------'
  contents:
  - "---------\n   Consider a URN that uses the hypothetical DUNS namespace. DUNS\n\
    \   numbers are identifiers for approximately 30 million registered\n   businesses\
    \ around the world, assigned and maintained by Dunn and\n   Bradstreet. The URN\
    \ might look like:\n                   urn:duns:002372413:annual-report-1997\n\
    \   The first step in the resolution process is to find out about the\n   DUNS\
    \ namespace. The namespace identifier, \"duns\", is extracted from\n   the URN,\
    \ prepended to urn.net, and the NAPTRs for duns.urn.net looked\n   up. It might\
    \ return records of the form:\n"
- title: duns.urn.net
  contents:
  - 'duns.urn.net

    '
- title: ;;      order pref flags service          regexp        replacement
  contents:
  - ";;      order pref flags service          regexp        replacement\n IN NAPTR\
    \ 100  10  \"s\" \"dunslink+N2L+N2C\" \"\"  dunslink.udp.isi.dandb.com\n IN NAPTR\
    \ 100  20  \"s\" \"rcds+N2C\"         \"\"  rcds.udp.isi.dandb.com\n IN NAPTR\
    \ 100  30  \"s\" \"http+N2L+N2C+N2R\" \"\"  http.tcp.isi.dandb.com\n   The order\
    \ field contains equal values, indicating that no name\n   delegation order has\
    \ to be followed. The preference field indicates\n   that the provider would like\
    \ clients to use the special dunslink\n   protocol, followed by the RCDS protocol,\
    \ and that HTTP is offered as\n   a last resort. All the records specify the \"\
    s\" flag, which will be\n   explained momentarily.  The service fields say that\
    \ if we speak\n   dunslink, we will be able to issue either the N2L or N2C requests\
    \ to\n   obtain a URL or a URC (description) of the resource. The Resource\n \
    \  Cataloging and Distribution Service (RCDS)[7] could be used to get a\n   URC\
    \ for the resource, while HTTP could be used to get a URL, URC, or\n   the resource\
    \ itself.  All the records supply the next domain name to\n   query, none of them\
    \ need to be rewritten with the aid of regular\n   expressions.\n   The general\
    \ case might require multiple NAPTR rewrites to locate a\n   resolver, but eventually\
    \ we will come to the \"terminal NAPTR\". Once\n   we have the terminal NAPTR,\
    \ our next probe into the DNS will be for a\n   SRV or A record instead of another\
    \ NAPTR. Rather than probing for a\n   non-existent NAPTR record to terminate\
    \ the loop, the flags field is\n   used to indicate a terminal lookup. If it has\
    \ a value of \"s\", the\n   next lookup should be for SRV RRs, \"a\" denotes that\
    \ A records should\n   sought.  A \"p\" flag is also provided to indicate that\
    \ the next action\n   is Protocol-specific, but that looking up another NAPTR\
    \ will not be\n   part of it.\n   Since our example RR specified the \"s\" flag,\
    \ it was terminal.\n   Assuming our client does not know the dunslink protocol,\
    \ our next\n   action is to lookup SRV RRs for rcds.udp.isi.dandb.com, which will\n\
    \   tell us hosts that can provide the necessary resolution service. That\n  \
    \ lookup might return:\n    ;;                          Pref Weight Port Target\n\
    \    rcds.udp.isi.dandb.com IN SRV 0    0    1000 defduns.isi.dandb.com\n    \
    \                       IN SRV 0    0    1000 dbmirror.com.au\n              \
    \             IN SRV 0    0    1000 ukmirror.com.uk\n   telling us three hosts\
    \ that could actually do the resolution, and\n   giving us the port we should\
    \ use to talk to their RCDS server.  (The\n   reader is referred to the SRV proposal\
    \ [4] for the interpretation of\n   the fields above).\n   There is opportunity\
    \ for significant optimization here. We can return\n   the SRV records as additional\
    \ information for terminal NAPTRs (and\n   the A records as additional information\
    \ for those SRVs). While this\n   recursive provision of additional information\
    \ is not explicitly\n   blessed in the DNS specifications, it is not forbidden,\
    \ and BIND does\n   take advantage of it [8]. This is a significant optimization.\
    \ In\n   conjunction with a long TTL for *.urn.net records, the average number\n\
    \   of probes to DNS for resolving DUNS URNs would approach one.\n   Therefore,\
    \ DNS server implementors SHOULD provide additional\n   information with NAPTR\
    \ responses. The additional information will be\n   either SRV or A records. \
    \ If SRV records are available, their A\n   records should be provided as recursive\
    \ additional information.\n   Note that the example NAPTR records above are intended\
    \ to represent\n   the reply the client will see. They are not quite identical\
    \ to what\n   the domain administrator would put into the zone files. For one\n\
    \   thing, the administrator should supply the trailing '.' character on\n   any\
    \ FQDNs.\n"
- title: Example 2
  contents:
  - 'Example 2

    '
- title: '---------'
  contents:
  - "---------\n   Consider a URN namespace based on MIME Content-Ids. The URN might\n\
    \   look like this:\n                 urn:cid:199606121851.1@mordred.gatech.edu\n\
    \   (Note that this example is chosen for pedagogical purposes, and does\n   not\
    \ conform to the recently-approved CID URL scheme.)\n   The first step in the\
    \ resolution process is to find out about the CID\n   namespace. The namespace\
    \ identifier, cid, is extracted from the URN,\n   prepended to urn.net, and the\
    \ NAPTR for cid.urn.net looked up. It\n   might return records of the form:\n\
    \ cid.urn.net\n  ;;       order pref flags service        regexp           replacement\n\
    \   IN NAPTR 100   10   \"\"  \"\"  \"/urn:cid:.+@([^\\.]+\\.)(.*)$/\\2/i\"  \
    \  .\n   We have only one NAPTR response, so ordering the responses is not a\n\
    \   problem.  The replacement field is empty, so we check the regexp\n   field\
    \ and use the pattern provided there. We apply that regexp to the\n   entire URN\
    \ to see if it matches, which it does.  The \\2 part of the\n   substitution expression\
    \ returns the string \"gatech.edu\". Since the\n   flags field does not contain\
    \ \"s\" or \"a\", the lookup is not terminal\n   and our next probe to DNS is\
    \ for more NAPTR records:\n   lookup(query=NAPTR, \"gatech.edu\").\n   Note that\
    \ the rule does not extract the full domain name from the\n   CID, instead it\
    \ assumes the CID comes from a host and extracts its\n   domain.  While all hosts,\
    \ such as mordred, could have their very own\n   NAPTR, maintaining those records\
    \ for all the machines at a site as\n   large as Georgia Tech would be an intolerable\
    \ burden. Wildcards are\n   not appropriate here since they only return results\
    \ when there is no\n   exactly matching names already in the system.\n   The record\
    \ returned from the query on \"gatech.edu\" might look like:\n"
- title: gatech.edu IN NAPTR
  contents:
  - 'gatech.edu IN NAPTR

    '
- title: ;;       order pref flags service           regexp  replacement
  contents:
  - ";;       order pref flags service           regexp  replacement\n  IN NAPTR 100\
    \  50  \"s\"  \"z3950+N2L+N2C\"     \"\"    z3950.tcp.gatech.edu\n  IN NAPTR 100\
    \  50  \"s\"  \"rcds+N2C\"          \"\"    rcds.udp.gatech.edu\n  IN NAPTR 100\
    \  50  \"s\"  \"http+N2L+N2C+N2R\"  \"\"    http.tcp.gatech.edu\n   Continuing\
    \ with our example, we note that the values of the order and\n   preference fields\
    \ are equal in all records, so the client is free to\n   pick any record. The\
    \ flags field tells us that these are the last\n   NAPTR patterns we should see,\
    \ and after the rewrite (a simple\n   replacement in this case) we should look\
    \ up SRV records to get\n   information on the hosts that can provide the necessary\
    \ service.\n   Assuming we prefer the Z39.50 protocol, our lookup might return:\n\
    \   ;;                        Pref Weight   Port Target\n   z3950.tcp.gatech.edu\
    \ IN SRV 0    0      1000 z3950.gatech.edu\n                        IN SRV 0 \
    \   0      1000 z3950.cc.gatech.edu\n                        IN SRV 0    0   \
    \   1000 z3950.uga.edu\n   telling us three hosts that could actually do the resolution,\
    \ and\n   giving us the port we should use to talk to their Z39.50 server.\n \
    \  Recall that the regular expression used \\2 to extract a domain name\n   from\
    \ the CID, and \\. for matching the literal '.' characters\n   seperating the\
    \ domain name components. Since '\\' is the escape\n   character, literal occurances\
    \ of a backslash must be escaped by\n   another backslash. For the case of the\
    \ cid.urn.net record above, the\n   regular expression entered into the zone file\
    \ should be\n   \"/urn:cid:.+@([^\\\\.]+\\\\.)(.*)$/\\\\2/i\".  When the client\
    \ code actually\n   receives the record, the pattern will have been converted\
    \ to\n   \"/urn:cid:.+@([^.]+\\.)(.*)$/\\2/i\".\n"
- title: Example 3
  contents:
  - 'Example 3

    '
- title: '---------'
  contents:
  - "---------\n   Even if URN systems were in place now, there would still be a\n\
    \   tremendous number of URLs.  It should be possible to develop a URN\n   resolution\
    \ system that can also provide location independence for\n   those URLs.  This\
    \ is related to the requirement in [1] to be able to\n   grandfather in names\
    \ from other naming systems, such as ISO Formal\n   Public Identifiers, Library\
    \ of Congress Call Numbers, ISBNs, ISSNs,\n   etc.\n   The NAPTR RR could also\
    \ be used for URLs that have already been\n   assigned.  Assume we have the URL\
    \ for a very popular piece of\n   software that the publisher wishes to mirror\
    \ at multiple sites around\n   the world:\n        http://www.foo.com/software/latest-beta.exe\n\
    \   We extract the prefix, \"http\", and lookup NAPTR records for\n   http.urn.net.\
    \ This might return a record of the form\n   http.urn.net IN NAPTR\n   ;;  order\
    \   pref flags service      regexp             replacement\n        100     90\
    \   \"\"      \"\"   \"!http://([^/:]+)!\\1!i\"       .\n   This expression returns\
    \ everything after the first double slash and\n   before the next slash or colon.\
    \ (We use the '!' character to delimit\n   the parts of the substitution expression.\
    \ Otherwise we would have to\n   use backslashes to escape the forward slashes,\
    \ and would have a\n   regexp in the zone file that looked like\n   \"/http:\\\
    \\/\\\\/([^\\\\/:]+)/\\\\1/i\".).\n   Applying this pattern to the URL extracts\
    \ \"www.foo.com\". Looking up\n   NAPTR records for that might return:\n   www.foo.com\n\
    \   ;;       order pref flags   service  regexp     replacement\n    IN NAPTR\
    \ 100  100  \"s\"   \"http+L2R\"   \"\"    http.tcp.foo.com\n    IN NAPTR 100\
    \  100  \"s\"   \"ftp+L2R\"    \"\"    ftp.tcp.foo.com\n   Looking up SRV records\
    \ for http.tcp.foo.com would return information\n   on the hosts that foo.com\
    \ has designated to be its mirror sites. The\n   client can then pick one for\
    \ the user.\n"
- title: NAPTR RR Format
  contents:
  - 'NAPTR RR Format

    '
- title: ===============
  contents:
  - "===============\n   The format of the NAPTR RR is given below. The DNS type code\
    \ for\n   NAPTR is 35.\n       Domain TTL Class Order Preference Flags Service\
    \ Regexp\n       Replacement\n   where:\n   Domain\n          The domain name\
    \ this resource record refers to.\n   TTL\n          Standard DNS Time To Live\
    \ field\n   Class\n          Standard DNS meaning\n   Order\n          A 16-bit\
    \ integer specifying the order in which the NAPTR\n          records MUST be processed\
    \ to ensure correct delegation of\n          portions of the namespace over time.\
    \ Low numbers are processed\n          before high numbers, and once a NAPTR is\
    \ found that \"matches\"\n          a URN, the client MUST NOT consider any NAPTRs\
    \ with a higher\n          value for order.\n   Preference\n          A 16-bit\
    \ integer which specifies the order in which NAPTR\n          records with equal\
    \ \"order\" values SHOULD be processed, low\n          numbers being processed\
    \ before high numbers.  This is similar\n          to the preference field in\
    \ an MX record, and is used so domain\n          administrators can direct clients\
    \ towards more capable hosts\n          or lighter weight protocols.\n   Flags\n\
    \          A String giving flags to control aspects of the rewriting and\n   \
    \       interpretation of the fields in the record. Flags are single\n       \
    \   characters from the set [A-Z0-9]. The case of the alphabetic\n          characters\
    \ is not significant.\n          At this time only three flags, \"S\", \"A\",\
    \ and \"P\", are defined.\n          \"S\" means that the next lookup should be\
    \ for SRV records\n          instead of NAPTR records. \"A\" means that the next\
    \ lookup\n          should be for A records. The \"P\" flag says that the remainder\n\
    \          of the resolution shall be carried out in a Protocol-specific\n   \
    \       fashion, and we should not do any more DNS queries.\n          The remaining\
    \ alphabetic flags are reserved. The numeric flags\n          may be used for\
    \ local experimentation. The S, A, and P flags\n          are all mutually exclusive,\
    \ and resolution libraries MAY\n          signal an error if more than one is\
    \ given. (Experimental code\n          and code for assisting in the creation\
    \ of NAPTRs would be more\n          likely to signal such an error than a client\
    \ such as a\n          browser). We anticipate that multiple flags will be allowed\
    \ in\n          the future, so implementers MUST NOT assume that the flags\n \
    \         field can only contain 0 or 1 characters. Finally, if a client\n   \
    \       encounters a record with an unknown flag, it MUST ignore it\n        \
    \  and move to the next record. This test takes precedence even\n          over\
    \ the \"order\" field. Since flags can control the\n          interpretation placed\
    \ on fields, a novel flag might change the\n          interpretation of the regexp\
    \ and/or replacement fields such\n          that it is impossible to determine\
    \ if a record matched a URN.\n   Service\n          Specifies the resolution service(s)\
    \ available down this\n          rewrite path. It may also specify the particular\
    \ protocol that\n          is used to talk with a resolver. A protocol MUST be\
    \ specified\n          if the flags field states that the NAPTR is terminal. If\
    \ a\n          protocol is specified, but the flags field does not state that\n\
    \          the NAPTR is terminal, the next lookup MUST be for a NAPTR.\n     \
    \     The client MAY choose not to perform the next lookup if the\n          protocol\
    \ is unknown, but that behavior MUST NOT be relied\n          upon.\n        \
    \  The service field may take any of the values below (using the\n          Augmented\
    \ BNF of RFC 822[9]):\n           service_field = [ [protocol] *(\"+\" rs)]\n\
    \           protocol      = ALPHA *31ALPHANUM\n           rs            = ALPHA\
    \ *31ALPHANUM\n        // The protocol and rs fields are limited to 32\n     \
    \   // characters and must start with an alphabetic.\n        // The current set\
    \ of \"known\" strings are:\n        // protocol      = \"rcds\" / \"thttp\" /\
    \ \"hdl\" / \"rwhois\" / \"z3950\"\n        // rs            = \"N2L\" / \"N2Ls\"\
    \ / \"N2R\" / \"N2Rs\" / \"N2C\"\n        //               / \"N2Ns\" / \"L2R\"\
    \ / \"L2Ns\" / \"L2Ls\" / \"L2C\"\n          i.e. an optional protocol specification\
    \ followed by 0 or more\n          resolution services. Each resolution service\
    \ is indicated by\n          an initial '+' character.\n          Note that the\
    \ empty string is also a valid service field. This\n          will typically be\
    \ seen at the top levels of a namespace, when\n          it is impossible to know\
    \ what services and protocols will be\n          offered by a particular publisher\
    \ within that name space.\n          At this time the known protocols are rcds[7],\
    \ hdl[10] (binary,\n          UDP-based protocols),  thttp[5] (a textual, TCP-based\n\
    \          protocol), rwhois[11] (textual, UDP or TCP based), and\n          Z39.50[12]\
    \ (binary, TCP-based). More will be allowed later.\n          The names of the\
    \ protocols must be formed from the characters\n          [a-Z0-9]. Case of the\
    \ characters is not significant.\n          The service requests currently allowed\
    \ will be described in\n          more detail in [6], but in brief they are:\n\
    \                N2L  - Given a URN, return a URL\n                N2Ls - Given\
    \ a URN, return a set of URLs\n                N2R  - Given a URN, return an instance\
    \ of the resource.\n                N2Rs - Given a URN, return multiple instances\
    \ of the\n                       resource, typically encoded using\n         \
    \              multipart/alternative.\n                N2C  - Given a URN, return\
    \ a collection of meta-\n                       information on the named resource.\
    \ The format of\n                       this response is the subject of another\
    \ document.\n                N2Ns - Given a URN, return all URNs that are also\n\
    \                       identifers for the resource.\n                L2R  - Given\
    \ a URL, return the resource.\n                L2Ns - Given a URL, return all\
    \ the URNs that are\n                       identifiers for the resource.\n  \
    \              L2Ls - Given a URL, return all the URLs for instances of\n    \
    \                   of the same resource.\n                L2C  - Given a URL,\
    \ return a description of the\n                       resource.\n          The\
    \ actual format of the service request and response will be\n          determined\
    \ by the resolution protocol, and is the subject for\n          other documents\
    \ (e.g. [5]). Protocols need not offer all\n          services. The labels for\
    \ service requests shall be formed from\n          the set of characters [A-Z0-9].\
    \ The case of the alphabetic\n          characters is not significant.\n   Regexp\n\
    \          A STRING containing a substitution expression that is applied\n   \
    \       to the original URI in order to construct the next domain name\n     \
    \     to lookup. The grammar of the substitution expression is given\n       \
    \   in the next section.\n   Replacement\n          The next NAME to query for\
    \ NAPTR, SRV, or A records depending\n          on the value of the flags field.\
    \ As mentioned above, this may\n          be compressed.\n"
- title: 'Substitution Expression Grammar:'
  contents:
  - 'Substitution Expression Grammar:

    '
- title: ================================
  contents:
  - "================================\n   The content of the regexp field is a substitution\
    \ expression. True\n   sed(1) substitution expressions are not appropriate for\
    \ use in this\n   application for a variety of reasons, therefore the contents\
    \ of the\n   regexp field MUST follow the grammar below:\n"
- title: subst_expr   = delim-char  ere  delim-char  repl  delim-char  *flags
  contents:
  - 'subst_expr   = delim-char  ere  delim-char  repl  delim-char  *flags

    '
- title: delim-char   = "/" / "!" / ... (Any non-digit or non-flag character other
  contents:
  - "delim-char   = \"/\" / \"!\" / ... (Any non-digit or non-flag character other\n\
    \               than backslash '\\'. All occurances of a delim_char in a\n   \
    \            subst_expr must be the same character.)\n"
- title: ere          = POSIX Extended Regular Expression (see [13], section
  contents:
  - "ere          = POSIX Extended Regular Expression (see [13], section\n       \
    \        2.8.4)\n"
- title: repl         = dns_str /  backref / repl dns_str  / repl backref
  contents:
  - 'repl         = dns_str /  backref / repl dns_str  / repl backref

    '
- title: dns_str      = 1*DNS_CHAR
  contents:
  - 'dns_str      = 1*DNS_CHAR

    '
- title: backref      = "\" 1POS_DIGIT
  contents:
  - 'backref      = "\" 1POS_DIGIT

    '
- title: flags        = "i"
  contents:
  - 'flags        = "i"

    '
- title: DNS_CHAR     = "-" / "0" / ... / "9" / "a" / ... / "z" / "A" / ... / "Z"
  contents:
  - 'DNS_CHAR     = "-" / "0" / ... / "9" / "a" / ... / "z" / "A" / ... / "Z"

    '
- title: POS_DIGIT    = "1" / "2" / ... / "9"  ; 0 is not an allowed backref
  contents:
  - 'POS_DIGIT    = "1" / "2" / ... / "9"  ; 0 is not an allowed backref

    '
- title: value domain name (see RFC-1123 [14]).
  contents:
  - "value domain name (see RFC-1123 [14]).\n   The result of applying the substitution\
    \ expression to the original\n   URI MUST result in a string that obeys the syntax\
    \ for DNS host names\n   [14]. Since it is possible for the regexp field to be\
    \ improperly\n   specified, such that a non-conforming host name can be constructed,\n\
    \   client software SHOULD verify that the result is a legal host name\n   before\
    \ making queries on it.\n   Backref expressions in the repl portion of the substitution\n\
    \   expression are replaced by the (possibly empty) string of characters\n   enclosed\
    \ by '(' and ')' in the ERE portion of the substitution\n   expression. N is a\
    \ single digit from 1 through 9, inclusive. It\n   specifies the N'th backref\
    \ expression, the one that begins with the\n   N'th '(' and continues to the matching\
    \ ')'.  For example, the ERE\n                      (A(B(C)DE)(F)G)\n   has backref\
    \ expressions:\n                      \\1  = ABCDEFG\n                      \\\
    2  = BCDE\n                      \\3  = C\n                      \\4  = F\n  \
    \               \\5..\\9  = error - no matching subexpression\n   The \"i\" flag\
    \ indicates that the ERE matching SHALL be performed in a\n   case-insensitive\
    \ fashion. Furthermore, any backref replacements MAY\n   be normalized to lower\
    \ case when the \"i\" flag is given.\n   The first character in the substitution\
    \ expression shall be used as\n   the character that delimits the components of\
    \ the substitution\n   expression.  There must be exactly three non-escaped occurrences\
    \ of\n   the delimiter character in a substitution expression. Since escaped\n\
    \   occurrences of the delimiter character will be interpreted as\n   occurrences\
    \ of that character, digits MUST NOT be used as delimiters.\n   Backrefs would\
    \ be confused with literal digits were this allowed.\n   Similarly, if flags are\
    \ specified in the substitution expression, the\n   delimiter character must not\
    \ also be a flag character.\n"
- title: 'Advice to domain administrators:'
  contents:
  - 'Advice to domain administrators:

    '
- title: ================================
  contents:
  - "================================\n   Beware of regular expressions. Not only\
    \ are they a pain to get\n   correct on their own, but there is the previously\
    \ mentioned\n   interaction with DNS. Any backslashes in a regexp must be entered\n\
    \   twice in a zone file in order to appear once in a query response.\n   More\
    \ seriously, the need for double backslashes has probably not been\n   tested\
    \ by all implementors of DNS servers. We anticipate that urn.net\n   will be the\
    \ heaviest user of regexps. Only when delegating portions\n   of namespaces should\
    \ the typical domain administrator need to use\n   regexps.\n   On a related note,\
    \ beware of interactions with the shell when\n   manipulating regexps from the\
    \ command line. Since '\\' is a common\n   escape character in shells, there is\
    \ a good chance that when you\n   think you are saying \"\\\\\" you are actually\
    \ saying \"\\\".  Similar\n   caveats apply to characters such as\n   The \"a\"\
    \ flag allows the next lookup to be for A records rather than\n   SRV records.\
    \ Since there is no place for a port specification in the\n   NAPTR record, when\
    \ the \"A\" flag is used the specified protocol must\n   be running on its default\
    \ port.\n   The URN Sytnax draft defines a canonical form for each URN, which\n\
    \   requires %encoding characters outside a limited repertoire. The\n   regular\
    \ expressions MUST be written to operate on that canonical\n   form. Since international\
    \ character sets will end up with extensive\n   use of %encoded characters, regular\
    \ expressions operating on them\n   will be essentially impossible to read or\
    \ write by hand.\n"
- title: Usage
  contents:
  - 'Usage

    '
- title: =====
  contents:
  - "=====\n   For the edification of implementers, pseudocode for a client routine\n\
    \   using NAPTRs is given below. This code is provided merely as a\n   convience,\
    \ it does not have any weight as a standard way to process\n   NAPTR records.\
    \ Also, as is the case with pseudocode, it has never\n   been executed and may\
    \ contain logical errors. You have been warned.\n    //\n    // findResolver(URN)\n\
    \    // Given a URN, find a host that can resolve it.\n    //\n    findResolver(string\
    \ URN) {\n      // prepend prefix to urn.net\n      sprintf(key, \"%s.urn.net\"\
    , extractNS(URN));\n      do {\n        rewrite_flag = false;\n        terminal\
    \ = false;\n        if (key has been seen) {\n          quit with a loop detected\
    \ error\n        }\n        add key to list of \"seens\"\n        records = lookup(type=NAPTR,\
    \ key); // get all NAPTR RRs for 'key'\n        discard any records with an unknown\
    \ value in the \"flags\" field.\n        sort NAPTR records by \"order\" field\
    \ and \"preference\" field\n            (with \"order\" being more significant\
    \ than \"preference\").\n        n_naptrs = number of NAPTR records in response.\n\
    \        curr_order = records[0].order;\n        max_order = records[n_naptrs-1].order;\n\
    \        // Process current batch of NAPTRs according to \"order\" field.\n  \
    \      for (j=0; j < n_naptrs && records[j].order <= max_order; j++) {\n     \
    \     if (unknown_flag) // skip this record and go to next one\n             continue;\n\
    \          newkey = rewrite(URN, naptr[j].replacement, naptr[j].regexp);\n   \
    \       if (!newkey) // Skip to next record if the rewrite didn't\n          \
    \   match continue;\n          // We did do a rewrite, shrink max_order to current\
    \ value\n          // so that delegation works properly\n          max_order =\
    \ naptr[j].order;\n          // Will we know what to do with the protocol and\
    \ services\n          // specified in the NAPTR? If not, try next record.\n  \
    \        if(!isKnownProto(naptr[j].services)) {\n            continue;\n     \
    \     }\n          if(!isKnownService(naptr[j].services)) {\n            continue;\n\
    \          }\n          // At this point we have a successful rewrite and we will\n\
    \          // know how to speak the protocol and request a known\n          //\
    \ resolution service. Before we do the next lookup, check\n          // some optimization\
    \ possibilities.\n          if (strcasecmp(flags, \"S\")\n           || strcasecmp(flags,\
    \ \"P\"))\n           || strcasecmp(flags, \"A\")) {\n             terminal =\
    \ true;\n             services = naptr[j].services;\n             addnl = any\
    \ SRV and/or A records returned as additional\n                     info for naptr[j].\n\
    \          }\n          key = newkey;\n          rewriteflag = true;\n       \
    \   break;\n        }\n      } while (rewriteflag && !terminal);\n      // Did\
    \ we not find our way to a resolver?\n      if (!rewrite_flag) {\n         report\
    \ an error\n         return NULL;\n      }\n      // Leave rest to another protocol?\n\
    \      if (strcasecmp(flags, \"P\")) {\n         return key as host to talk to;\n\
    \      }\n      // If not, keep plugging\n      if (!addnl) { // No SRVs came\
    \ in as additional info, look them up\n        srvs = lookup(type=SRV, key);\n\
    \      }\n      sort SRV records by preference, weight, ...\n      foreach (SRV\
    \ record) { // in order of preference\n        try contacting srv[j].target using\
    \ the protocol and one of the\n            resolution service requests from the\
    \ \"services\" field of the\n            last NAPTR record.\n        if (successful)\n\
    \          return (target, protocol, service);\n          // Actually we would\
    \ probably return a result, but this\n          // code was supposed to just tell\
    \ us a good host to talk to.\n      }\n      die with an \"unable to find a host\"\
    \ error;\n    }\n"
- title: 'Notes:'
  contents:
  - 'Notes:

    '
- title: ======
  contents:
  - "======\n     -  A client MUST process multiple NAPTR records in the order\n \
    \       specified by the \"order\" field, it MUST NOT simply use the first\n \
    \       record that provides a known protocol and service combination.\n     -\
    \  If a record at a particular order matches the URI, but the\n        client\
    \ doesn't know the specified protocol and service, the\n        client SHOULD\
    \ continue to examine records that have the same\n        order. The client MUST\
    \ NOT consider records with a higher value\n        of order. This is necessary\
    \ to make delegation of portions of\n        the namespace work.  The order field\
    \ is what lets site\n        administrators say \"all requests for URIs matching\
    \ pattern x go\n        to server 1, all others go to server 2\".\n        (A\
    \ match is defined as:\n          1)  The NAPTR provides a replacement domain\
    \ name\n          or\n          2) The regular expression matches the URN\n  \
    \         )\n     -  When multiple RRs have the same \"order\", the client should\
    \ use\n        the value of the preference field to select the next NAPTR to\n\
    \        consider. However, because of preferred protocols or services,\n    \
    \    estimates of network distance and bandwidth, etc. clients may\n        use\
    \ different criteria to sort the records.\n     -  If the lookup after a rewrite\
    \ fails, clients are strongly\n        encouraged to report a failure, rather\
    \ than backing up to pursue\n        other rewrite paths.\n     -  When a namespace\
    \ is to be delegated among a set of resolvers,\n        regexps must be used.\
    \ Each regexp appears in a separate NAPTR\n        RR.  Administrators should\
    \ do as little delegation as possible,\n        because of limitations on the\
    \ size of DNS responses.\n     -  Note that SRV RRs impose additional requirements\
    \ on clients.\n"
- title: 'Acknowledgments:'
  contents:
  - 'Acknowledgments:

    '
- title: =================
  contents:
  - "=================\n   The editors would like to thank Keith Moore for all his\
    \ consultations\n   during the development of this draft. We would also like to\
    \ thank\n   Paul Vixie for his assistance in debugging our implementation, and\n\
    \   his answers on our questions. Finally, we would like to acknowledge\n   our\
    \ enormous intellectual debt to the participants in the Knoxville\n   series of\
    \ meetings, as well as to the participants in the URI and URN\n   working groups.\n"
- title: 'References:'
  contents:
  - 'References:

    '
- title: ===========
  contents:
  - "===========\n   [1]  Sollins, Karen and Larry Masinter, \"Functional Requirements\n\
    \        for Uniform Resource Names\", RFC-1737, Dec. 1994.\n   [2]  The URN Implementors,\
    \ Uniform Resource Names: A Progress Report,\n        http://www.dlib.org/dlib/february96/02arms.html,\
    \ D-Lib Magazine,\n        February 1996.\n   [3]  Moats, Ryan, \"URN Syntax\"\
    , RFC-2141, May 1997.\n   [4]  Gulbrandsen, A. and P. Vixie, \"A DNS RR for specifying\n\
    \        the location of services (DNS SRV)\", RFC-2052, October 1996.\n   [5]\
    \  Daniel, Jr., Ron, \"A Trivial Convention for using HTTP in URN\n        Resolution\"\
    , RFC-2169, June 1997.\n   [6]  URN-WG, \"URN Resolution Services\", Work in Progress.\n\
    \   [7]  Moore, Keith,  Shirley Browne, Jason Cox, and Jonathan Gettler,\n   \
    \     Resource Cataloging and Distribution System, Technical Report\n        CS-97-346,\
    \ University of Tennessee, Knoxville, December 1996\n   [8]  Paul Vixie, personal\
    \ communication.\n   [9]  Crocker, Dave H. \"Standard for the Format of ARPA Internet\
    \ Text\n        Messages\", RFC-822, August 1982.\n   [10] Orth, Charles and Bill\
    \ Arms; Handle Resolution Protocol\n        Specification, http://www.handle.net/docs/client_spec.html\n\
    \   [11] Williamson, S., M. Kosters, D. Blacka, J. Singh, K. Zeilstra,\n     \
    \   \"Referral Whois Protocol (RWhois)\", RFC-2167, June 1997.\n   [12] Information\
    \ Retrieval (Z39.50): Application Service Definition\n        and Protocol Specification,\
    \ ANSI/NISO Z39.50-1995, July 1995.\n   [13] IEEE Standard for Information Technology\
    \ - Portable Operating\n        System Interface (POSIX) - Part 2: Shell and Utilities\
    \ (Vol. 1);\n        IEEE Std 1003.2-1992; The Institute of Electrical and\n \
    \       Electronics Engineers; New York; 1993. ISBN:1-55937-255-9\n   [14] Braden,\
    \ R., \"Requirements for Internet Hosts - Application and\n        and Support\"\
    , RFC-1123, Oct. 1989.\n   [15] Sollins, Karen, \"Requirements and a Framework\
    \ for URN Resolution\n        Systems\", November 1996, Work in Progress.\n"
- title: Security Considerations
  contents:
  - 'Security Considerations

    '
- title: =======================
  contents:
  - "=======================\n   The use of \"urn.net\" as the registry for URN namespaces\
    \ is subject to\n   denial of service attacks, as well as other DNS spoofing attacks.\
    \ The\n   interactions with DNSSEC are currently being studied. It is expected\n\
    \   that NAPTR records will be signed with SIG records once the DNSSEC\n   work\
    \ is deployed.\n   The rewrite rules make identifiers from other namespaces subject\
    \ to\n   the same attacks as normal domain names. Since they have not been\n \
    \  easily resolvable before, this may or may not be considered a\n   problem.\n\
    \   Regular expressions should be checked for sanity, not blindly passed\n   to\
    \ something like PERL.\n   This document has discussed a way of locating a resolver,\
    \ but has not\n   discussed any detail of how the communication with the resolver\
    \ takes\n   place. There are significant security considerations attached to the\n\
    \   communication with a resolver. Those considerations are outside the\n   scope\
    \ of this document, and must be addressed by the specifications\n   for particular\
    \ resolver communication protocols.\n"
- title: 'Author Contact Information:'
  contents:
  - 'Author Contact Information:

    '
- title: ===========================
  contents:
  - "===========================\n   Ron Daniel\n   Los Alamos National Laboratory\n\
    \   MS B287\n   Los Alamos, NM, USA, 87545\n   voice:  +1 505 665 0597\n   fax:\
    \    +1 505 665 4939\n   email:  rdaniel@lanl.gov\n   Michael Mealling\n   Network\
    \ Solutions\n   505 Huntmar Park Drive\n   Herndon, VA  22070\n   voice: (703)\
    \ 742-0400\n   fax: (703) 742-9552\n   email: michaelm@internic.net\n   URL: http://www.netsol.com/\n"
