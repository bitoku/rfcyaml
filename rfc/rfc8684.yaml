- title: __initial_text__
  contents:
  - '     TCP Extensions for Multipath Operation with Multiple Addresses

    '
- title: Abstract
  contents:
  - "Abstract\n   TCP/IP communication is currently restricted to a single path per\n\
    \   connection, yet multiple paths often exist between peers.  The\n   simultaneous\
    \ use of these multiple paths for a TCP/IP session would\n   improve resource\
    \ usage within the network and thus improve user\n   experience through higher\
    \ throughput and improved resilience to\n   network failure.\n   Multipath TCP\
    \ provides the ability to simultaneously use multiple\n   paths between peers.\
    \  This document presents a set of extensions to\n   traditional TCP to support\
    \ multipath operation.  The protocol offers\n   the same type of service to applications\
    \ as TCP (i.e., a reliable\n   bytestream), and it provides the components necessary\
    \ to establish\n   and use multiple TCP flows across potentially disjoint paths.\n\
    \   This document specifies v1 of Multipath TCP, obsoleting v0 as\n   specified\
    \ in RFC 6824, through clarifications and modifications\n   primarily driven by\
    \ deployment experience.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8684.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n     1.1.  Design Assumptions\n     1.2.\
    \  Multipath TCP in the Networking Stack\n     1.3.  Terminology\n     1.4.  MPTCP\
    \ Concept\n     1.5.  Requirements Language\n   2.  Operation Overview\n     2.1.\
    \  Initiating an MPTCP Connection\n     2.2.  Associating a New Subflow with an\
    \ Existing MPTCP Connection\n     2.3.  Informing the Other Host about Another\
    \ Potential Address\n     2.4.  Data Transfer Using MPTCP\n     2.5.  Requesting\
    \ a Change in a Path's Priority\n     2.6.  Closing an MPTCP Connection\n    \
    \ 2.7.  Notable Features\n   3.  MPTCP Operations: An Overview\n     3.1.  Connection\
    \ Initiation\n     3.2.  Starting a New Subflow\n     3.3.  MPTCP Operation and\
    \ Data Transfer\n       3.3.1.  Data Sequence Mapping\n       3.3.2.  Data Acknowledgments\n\
    \       3.3.3.  Closing a Connection\n       3.3.4.  Receiver Considerations\n\
    \       3.3.5.  Sender Considerations\n       3.3.6.  Reliability and Retransmissions\n\
    \       3.3.7.  Congestion Control Considerations\n       3.3.8.  Subflow Policy\n\
    \     3.4.  Address Knowledge Exchange (Path Management)\n       3.4.1.  Address\
    \ Advertisement\n       3.4.2.  Remove Address\n     3.5.  Fast Close\n     3.6.\
    \  Subflow Reset\n     3.7.  Fallback\n     3.8.  Error Handling\n     3.9.  Heuristics\n\
    \       3.9.1.  Port Usage\n       3.9.2.  Delayed Subflow Start and Subflow Symmetry\n\
    \       3.9.3.  Failure Handling\n   4.  Semantic Issues\n   5.  Security Considerations\n\
    \   6.  Interactions with Middleboxes\n   7.  IANA Considerations\n     7.1. \
    \ TCP Option Kind Numbers\n     7.2.  MPTCP Option Subtypes\n     7.3.  MPTCP\
    \ Handshake Algorithms\n     7.4.  MP_TCPRST Reason Codes\n   8.  References\n\
    \     8.1.  Normative References\n     8.2.  Informative References\n   Appendix\
    \ A.  Notes on Use of TCP Options\n   Appendix B.  TCP Fast Open and MPTCP\n \
    \    B.1.  TFO Cookie Request with MPTCP\n     B.2.  Data Sequence Mapping under\
    \ TFO\n     B.3.  Connection Establishment Examples\n   Appendix C.  Control Blocks\n\
    \     C.1.  MPTCP Control Block\n       C.1.1.  Authentication and Metadata\n\
    \       C.1.2.  Sending Side\n       C.1.3.  Receiving Side\n     C.2.  TCP Control\
    \ Blocks\n       C.2.1.  Sending Side\n       C.2.2.  Receiving Side\n   Appendix\
    \ D.  Finite State Machine\n   Appendix E.  Changes from RFC 6824\n   Acknowledgments\n\
    \   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Multipath TCP (MPTCP) is a set of extensions to regular\
    \ TCP [RFC0793]\n   to provide a Multipath TCP service [RFC6182], which enables\
    \ a\n   transport connection to operate across multiple paths simultaneously.\n\
    \   This document presents the protocol changes required to add multipath\n  \
    \ capability to TCP -- specifically, those for signaling and setting up\n   multiple\
    \ paths (\"subflows\"), managing these subflows, reassembly of\n   data, and termination\
    \ of sessions.  This is not the only information\n   required to create a Multipath\
    \ TCP implementation, however.  This\n   document is complemented by three others:\n\
    \   *  [RFC6182] (MPTCP architecture), which explains the motivations\n      behind\
    \ Multipath TCP, contains a discussion of high-level design\n      decisions on\
    \ which this design is based, and provides an\n      explanation of a functional\
    \ separation through which an extensible\n      MPTCP implementation can be developed.\n\
    \   *  [RFC6356] (congestion control), which presents a safe congestion\n    \
    \  control algorithm for coupling the behavior of the multiple paths\n      in\
    \ order to \"do no harm\" to other network users.\n   *  [RFC6897] (application\
    \ considerations), which discusses what\n      impact MPTCP will have on applications,\
    \ what applications will\n      want to do with MPTCP, and as a consequence of\
    \ these factors, what\n      API extensions an MPTCP implementation should present.\n\
    \   This document obsoletes the v0 specification of Multipath TCP\n   [RFC6824].\
    \  This document specifies MPTCP v1, which is not backward\n   compatible with\
    \ MPTCP v0.  This document additionally defines version\n   negotiation procedures\
    \ for implementations that support both\n   versions.\n"
- title: 1.1.  Design Assumptions
  contents:
  - "1.1.  Design Assumptions\n   In order to limit the potentially huge design space,\
    \ the MPTCP\n   Working Group imposed two key constraints on the Multipath TCP\
    \ design\n   presented in this document:\n   *  It must be backward compatible\
    \ with current, regular TCP, to\n      increase its chances of deployment.\n \
    \  *  It can be assumed that one or both hosts are multihomed and\n      multiaddressed.\n\
    \   To simplify the design, we assume that the presence of multiple\n   addresses\
    \ at a host is sufficient to indicate the existence of\n   multiple paths.  These\
    \ paths need not be entirely disjoint: they may\n   share one or many routers\
    \ between them.  Even in such a situation,\n   making use of multiple paths is\
    \ beneficial, improving resource\n   utilization and resilience to a subset of\
    \ node failures.  The\n   congestion control algorithm defined in [RFC6356] ensures\
    \ that the\n   use of multiple paths does not act detrimentally.  Furthermore,\
    \ there\n   may be some scenarios where different TCP ports on a single host can\n\
    \   provide disjoint paths (such as through certain Equal-Cost Multipath\n   (ECMP)\
    \ implementations [RFC2992]), and so the MPTCP design also\n   supports the use\
    \ of ports in path identifiers.\n   There are three aspects to the backward compatibility\
    \ listed above\n   (discussed in more detail in [RFC6182]):\n   External Constraints:\
    \  The protocol must function through the vast\n      majority of existing middleboxes\
    \ such as NATs, firewalls, and\n      proxies, and as such must resemble existing\
    \ TCP as far as possible\n      on the wire.  Furthermore, the protocol must not\
    \ assume that the\n      segments it sends on the wire arrive unmodified at the\n\
    \      destination: they may be split or coalesced; TCP options may be\n     \
    \ removed or duplicated.\n   Application Constraints:  The protocol must be usable\
    \ with no change\n      to existing applications that use the common TCP API (although\
    \ it\n      is reasonable that not all features would be available to such\n \
    \     legacy applications).  Furthermore, the protocol must provide the\n    \
    \  same service model as regular TCP to the application.\n   Fallback:  The protocol\
    \ should be able to fall back to standard TCP\n      with no interference from\
    \ the user, to be able to communicate with\n      legacy hosts.\n   The complementary\
    \ application considerations document [RFC6897]\n   discusses the necessary features\
    \ of an API to provide backward\n   compatibility, as well as API extensions to\
    \ convey the behavior of\n   MPTCP at a level of control and information equivalent\
    \ to that\n   available with regular, single-path TCP.\n   Further discussion\
    \ of the design constraints and associated design\n   decisions is given in the\
    \ MPTCP architecture document [RFC6182] and\n   in [howhard].\n"
- title: 1.2.  Multipath TCP in the Networking Stack
  contents:
  - "1.2.  Multipath TCP in the Networking Stack\n   MPTCP operates at the transport\
    \ layer and aims to be transparent to\n   both higher and lower layers.  It is\
    \ a set of additional features on\n   top of standard TCP; Figure 1 illustrates\
    \ this layering.  MPTCP is\n   designed to be usable by legacy applications with\
    \ no changes;\n   detailed discussion of its interactions with applications is\
    \ given in\n   [RFC6897].\n      |  Application  |            |             MPTCP\
    \             |\n      |      TCP      |            | Subflow (TCP) | Subflow\
    \ (TCP) |\n      |      IP       |            |       IP      |      IP      \
    \ |\n       Figure 1: Comparison of Standard TCP and MPTCP Protocol Stacks\n"
- title: 1.3.  Terminology
  contents:
  - "1.3.  Terminology\n   This document makes use of a number of terms that are either\
    \ MPTCP\n   specific or have defined meaning in the context of MPTCP, as follows:\n\
    \   Path:  A sequence of links between a sender and a receiver, defined\n    \
    \  in this context by a 4-tuple of source and destination\n      address/port\
    \ pairs.\n   Subflow:  A flow of TCP segments operating over an individual path,\n\
    \      which forms part of a larger MPTCP connection.  A subflow is\n      started\
    \ and terminated similarly to a regular TCP connection.\n   (MPTCP) Connection:\
    \  A set of one or more subflows, over which an\n      application can communicate\
    \ between two hosts.  There is a\n      one-to-one mapping between a connection\
    \ and an application socket.\n   Data-level:  The payload data is nominally transferred\
    \ over a\n      connection, which in turn is transported over subflows.  Thus,\
    \ the\n      term \"data-level\" is synonymous with \"connection-level\", in\n\
    \      contrast to \"subflow-level\", which refers to properties of an\n     \
    \ individual subflow.\n   Token:  A locally unique identifier given to a multipath\
    \ connection\n      by a host.  May also be referred to as a \"Connection ID\"\
    .\n   Host:  An end host operating an MPTCP implementation, and either\n     \
    \ initiating or accepting an MPTCP connection.\n   In addition to these terms,\
    \ note that MPTCP's interpretation of, and\n   effect on, regular single-path\
    \ TCP semantics are discussed in\n   Section 4.\n"
- title: 1.4.  MPTCP Concept
  contents:
  - "1.4.  MPTCP Concept\n   This section provides a high-level summary of normal\
    \ operation of\n   MPTCP; this type of scenario is illustrated in Figure 2.  A\
    \ detailed\n   description of how MPTCP operates is given in Section 3.\n    \
    \           Host A                               Host B\n      Address A1    Address\
    \ A2             Address B1    Address B2\n          |     (initial connection\
    \ setup)     |             |\n          |            (additional subflow setup)\
    \            |\n                   Figure 2: Example MPTCP Usage Scenario\n  \
    \ *  To a non-MPTCP-aware application, MPTCP will behave the same as\n      normal\
    \ TCP.  Extended APIs could provide additional control to\n      MPTCP-aware applications\
    \ [RFC6897].  An application begins by\n      opening a TCP socket in the normal\
    \ way.  MPTCP signaling and\n      operation are handled by the MPTCP implementation.\n\
    \   *  An MPTCP connection begins similarly to a regular TCP connection.\n   \
    \   This is illustrated in Figure 2, where an MPTCP connection is\n      established\
    \ between addresses A1 and B1 on Hosts A and B,\n      respectively.\n   *  If\
    \ extra paths are available, additional TCP sessions (termed\n      MPTCP \"subflows\"\
    ) are created on these paths and are combined with\n      the existing session,\
    \ which continues to appear as a single\n      connection to the applications\
    \ at both ends.  The creation of the\n      additional TCP session is illustrated\
    \ between Address A2 on Host A\n      and Address B1 on Host B.\n   *  MPTCP identifies\
    \ multiple paths by the presence of multiple\n      addresses at hosts.  Combinations\
    \ of these multiple addresses\n      equate to the additional paths.  In the example,\
    \ other potential\n      paths that could be set up are A1<->B2 and A2<->B2. \
    \ Although this\n      additional session is shown as being initiated from A2,\
    \ it could\n      equally have been initiated from B1 or B2.\n   *  The discovery\
    \ and setup of additional subflows will be achieved\n      through a path management\
    \ method; this document describes a\n      mechanism by which a host can initiate\
    \ new subflows by using its\n      own additional addresses or by signaling its\
    \ available addresses\n      to the other host.\n   *  MPTCP adds connection-level\
    \ sequence numbers to allow the\n      reassembly of segments arriving on multiple\
    \ subflows with\n      differing network delays.\n   *  Subflows are terminated\
    \ as regular TCP connections, with a\n      four-way FIN handshake.  The MPTCP\
    \ connection is terminated by a\n      connection-level FIN.\n"
- title: 1.5.  Requirements Language
  contents:
  - "1.5.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 2.  Operation Overview
  contents:
  - "2.  Operation Overview\n   This section presents a single description of common\
    \ MPTCP operation,\n   with reference to the protocol operation.  This is a high-level\n\
    \   overview of the key functions; the full specification follows in\n   Section\
    \ 3.  Extensibility and negotiated features are not discussed\n   here.  Considerable\
    \ reference is made to symbolic names of MPTCP\n   options throughout this section\
    \ -- these are subtypes of the\n   IANA-assigned MPTCP option (see Section 7),\
    \ and their formats are\n   defined in the detailed protocol specification provided\
    \ in Section 3.\n   A Multipath TCP connection provides a bidirectional bytestream\n\
    \   between two hosts communicating like normal TCP and thus does not\n   require\
    \ any change to the applications.  However, Multipath TCP\n   enables the hosts\
    \ to use different paths with different IP addresses\n   to exchange packets belonging\
    \ to the MPTCP connection.  A Multipath\n   TCP connection appears like a normal\
    \ TCP connection to an\n   application.  However, to the network layer, each MPTCP\
    \ subflow looks\n   like a regular TCP flow whose segments carry a new TCP option\
    \ type.\n   Multipath TCP manages the creation, removal, and utilization of these\n\
    \   subflows to send data.  The number of subflows that are managed\n   within\
    \ a Multipath TCP connection is not fixed, and it can fluctuate\n   during the\
    \ lifetime of the Multipath TCP connection.\n   All MPTCP operations are signaled\
    \ with a TCP option -- a single\n   numerical type for MPTCP, with \"subtypes\"\
    \ for each MPTCP message.\n   What follows is a summary of the purpose and rationale\
    \ of these\n   messages.\n"
- title: 2.1.  Initiating an MPTCP Connection
  contents:
  - "2.1.  Initiating an MPTCP Connection\n   This is the same signaling as for initiating\
    \ a normal TCP connection,\n   but the SYN, SYN/ACK, and initial ACK (and data)\
    \ packets also carry\n   the MP_CAPABLE option.  This option has a variable length\
    \ and serves\n   multiple purposes.  Firstly, it verifies whether the remote host\n\
    \   supports Multipath TCP; secondly, this option allows the hosts to\n   exchange\
    \ some information to authenticate the establishment of\n   additional subflows.\
    \  Further details are given in Section 3.1.\n      Host A                   \
    \               Host B\n      MP_CAPABLE                ->\n      [flags]\n  \
    \    ACK + MP_CAPABLE (+ data) ->\n      [A's key, B's key, flags, (data-level\
    \ details)]\n   Retransmission of the ACK + MP_CAPABLE can occur if it is not\
    \ known\n   if it has been received.  The following diagrams show all possible\n\
    \   exchanges for the initial subflow setup to ensure this reliability.\n    \
    \  Host A (with data to send immediately)  Host B\n      MP_CAPABLE          \
    \      ->\n      [flags]\n      ACK + MP_CAPABLE + data   ->\n      [A's key,\
    \ B's key, flags, data-level details]\n      Host A (with data to send later)\
    \        Host B\n      MP_CAPABLE                ->\n      [flags]\n      ACK\
    \ + MP_CAPABLE          ->\n      [A's key, B's key, flags]\n      ACK + MP_CAPABLE\
    \ + data   ->\n      [A's key, B's key, flags, data-level details]\n      Host\
    \ A                                  Host B (sending first)\n      MP_CAPABLE\
    \                ->\n      [flags]\n      ACK + MP_CAPABLE          ->\n     \
    \ [A's key, B's key, flags]\n"
- title: 2.2.  Associating a New Subflow with an Existing MPTCP Connection
  contents:
  - "2.2.  Associating a New Subflow with an Existing MPTCP Connection\n   The exchange\
    \ of keys in the MP_CAPABLE handshake provides material\n   that can be used to\
    \ authenticate the endpoints when new subflows will\n   be set up.  Additional\
    \ subflows begin in the same way as initiating a\n   normal TCP connection, but\
    \ the SYN, SYN/ACK, and ACK packets also\n   carry the MP_JOIN option.\n   Host\
    \ A initiates a new subflow between one of its addresses and one\n   of Host B's\
    \ addresses.  The token -- generated from the key -- is\n   used to identify which\
    \ MPTCP connection it is joining, and the\n   Hash-based Message Authentication\
    \ Code (HMAC) is used for\n   authentication.  The HMAC uses the keys exchanged\
    \ in the MP_CAPABLE\n   handshake and the random numbers (nonces) exchanged in\
    \ these MP_JOIN\n   options.  MP_JOIN also contains flags and an Address ID that\
    \ can be\n   used to refer to the source address without the sender needing to\n\
    \   know if it has been changed by a NAT.  Further details are given in\n   Section\
    \ 3.2.\n      Host A                                  Host B\n      MP_JOIN  \
    \             ->\n      [B's token, A's nonce,\n       A's Address ID, flags]\n\
    \      ACK + MP_JOIN         ->\n      [A's HMAC]\n"
- title: 2.3.  Informing the Other Host about Another Potential Address
  contents:
  - "2.3.  Informing the Other Host about Another Potential Address\n   The set of\
    \ IP addresses associated to a multihomed host may change\n   during the lifetime\
    \ of an MPTCP connection.  MPTCP supports the\n   addition and removal of addresses\
    \ on a host both implicitly and\n   explicitly.  If Host A has established a subflow\
    \ starting at\n   address/port pair IP#-A1 and wants to open a second subflow\
    \ starting\n   at address/port pair IP#-A2, it simply initiates the establishment\
    \ of\n   the subflow as explained above.  The remote host will then be\n   implicitly\
    \ informed about the new address.\n   In some circumstances, a host may want to\
    \ advertise to the remote\n   host the availability of an address without establishing\
    \ a new\n   subflow -- for example, when a NAT prevents setup in one direction.\n\
    \   In the example below, Host A informs Host B about its alternative\n   IP address/port\
    \ pair (IP#-A2).  Host B may later send an MP_JOIN to\n   this new address.  The\
    \ ADD_ADDR option contains an HMAC to\n   authenticate the address as having been\
    \ sent from the originator of\n   the connection.  The receiver of this option\
    \ echoes it back to the\n   client to indicate successful receipt.  Further details\
    \ are given in\n   Section 3.4.1.\n      Host A                              \
    \   Host B\n      ADD_ADDR                  ->\n      [Echo-flag=0,\n       IP#-A2,\n\
    \       IP#-A2's Address ID,\n       HMAC of IP#-A2]\n   There is a corresponding\
    \ signal for address removal, making use of\n   the Address ID that is signaled\
    \ in the ADD_ADDR handshake.  Further\n   details are given in Section 3.4.2.\n\
    \      Host A                                 Host B\n      REMOVE_ADDR      \
    \         ->\n      [IP#-A2's Address ID]\n"
- title: 2.4.  Data Transfer Using MPTCP
  contents:
  - "2.4.  Data Transfer Using MPTCP\n   To ensure reliable, in-order delivery of\
    \ data over subflows that may\n   appear and disappear at any time, MPTCP uses\
    \ a 64-bit Data Sequence\n   Number (DSN) to number all data sent over the MPTCP\
    \ connection.  Each\n   subflow has its own 32-bit sequence number space, utilizing\
    \ the\n   regular TCP sequence number header, and an MPTCP option maps the\n \
    \  subflow sequence space to the data sequence space.  In this way, data\n   can\
    \ be retransmitted on different subflows (mapped to the same DSN)\n   in the event\
    \ of failure.\n   The Data Sequence Signal (DSS) carries the Data Sequence Mapping.\n\
    \   The Data Sequence Mapping consists of the subflow sequence number,\n   data\
    \ sequence number, and length for which this mapping is valid.\n   This option\
    \ can also carry a connection-level acknowledgment (the\n   \"Data ACK\") for\
    \ the received DSN.\n   With MPTCP, all subflows share the same receive buffer\
    \ and advertise\n   the same receive window.  There are two levels of acknowledgment\
    \ in\n   MPTCP.  Regular TCP acknowledgments are used on each subflow to\n   acknowledge\
    \ the reception of the segments sent over the subflow\n   independently of their\
    \ DSN.  In addition, there are connection-level\n   acknowledgments for the data\
    \ sequence space.  These acknowledgments\n   track the advancement of the bytestream\
    \ and slide the receive window.\n   Further details are given in Section 3.3.\n\
    \      Host A                                 Host B\n      DSS              \
    \         ->\n      [Data Sequence Mapping]\n      [Data ACK]\n      [Checksum]\n"
- title: 2.5.  Requesting a Change in a Path's Priority
  contents:
  - "2.5.  Requesting a Change in a Path's Priority\n   Hosts can indicate at initial\
    \ subflow setup whether they wish the\n   subflow to be used as a regular or backup\
    \ path -- a backup path only\n   being used if there are no regular paths available.\
    \  During a\n   connection, Host A can request a change in the priority of a subflow\n\
    \   through the MP_PRIO signal to Host B.  Further details are given in\n   Section\
    \ 3.3.8.\n      Host A                                 Host B\n      MP_PRIO \
    \                  ->\n"
- title: 2.6.  Closing an MPTCP Connection
  contents:
  - "2.6.  Closing an MPTCP Connection\n   When a host wants to close an existing\
    \ subflow but not the whole\n   connection, it can initiate a regular TCP FIN/ACK\
    \ exchange.\n   When Host A wants to inform Host B that it has no more data to\
    \ send,\n   it signals this \"Data FIN\" as part of the DSS (see above).  It has\n\
    \   the same semantics and behavior as a regular TCP FIN, but at the\n   connection\
    \ level.  Once all the data on the MPTCP connection has been\n   successfully\
    \ received, this message is acknowledged at the connection\n   level with a Data\
    \ ACK.  Further details are given in Section 3.3.3.\n      Host A            \
    \                     Host B\n      DSS                       ->\n      [Data\
    \ FIN]\n   There is an additional method of connection closure, referred to as\n\
    \   \"Fast Close\", which is analogous to closing a single-path TCP\n   connection\
    \ with a RST signal.  The MP_FASTCLOSE signal is used to\n   indicate to the peer\
    \ that the connection will be abruptly closed and\n   no data will be accepted\
    \ anymore.  This can be used on an ACK (which\n   ensures reliability of the signal)\
    \ or a RST (which does not).  Both\n   examples are shown in the following diagrams.\
    \  Further details are\n   given in Section 3.5.\n      Host A               \
    \                  Host B\n      ACK + MP_FASTCLOSE          ->\n      [B's key]\n\
    \      [RST on all other subflows] ->\n      Host A                          \
    \       Host B\n      RST + MP_FASTCLOSE          ->\n      [B's key] [on all\
    \ subflows]\n"
- title: 2.7.  Notable Features
  contents:
  - "2.7.  Notable Features\n   It is worth highlighting that MPTCP's signaling has\
    \ been designed\n   with several key requirements in mind:\n   *  To cope with\
    \ NATs on the path, addresses are referred to by\n      Address IDs, in case the\
    \ IP packet's source address gets changed\n      by a NAT.  Setting up a new TCP\
    \ flow is not possible if the\n      receiver of the SYN is behind a NAT; to allow\
    \ subflows to be\n      created when either end is behind a NAT, MPTCP uses the\
    \ ADD_ADDR\n      message.\n   *  MPTCP falls back to ordinary TCP if MPTCP operation\
    \ is not\n      possible -- for example, if one host is not MPTCP capable or if\
    \ a\n      middlebox alters the payload.  This is discussed in Section 3.7.\n\
    \   *  To address the threats identified in [RFC6181], the following\n      steps\
    \ are taken: keys are sent in the clear in the MP_CAPABLE\n      messages; MP_JOIN\
    \ messages are secured with HMAC-SHA256 ([RFC2104]\n      using the algorithm\
    \ in [RFC6234]) using those keys; and standard\n      TCP validity checks are\
    \ made on the other messages (ensuring that\n      sequence numbers are in-window\
    \ [RFC5961]).  Residual threats to\n      MPTCP v0 were identified in [RFC7430],\
    \ and those affecting the\n      protocol (i.e., modifications to ADD_ADDR) have\
    \ been incorporated\n      in this document.  Further discussion of security can\
    \ be found in\n      Section 5.\n"
- title: '3.  MPTCP Operations: An Overview'
  contents:
  - "3.  MPTCP Operations: An Overview\n   This section describes the operation of\
    \ MPTCP.  The subsections below\n   discuss each key part of the protocol operation.\n\
    \   All MPTCP operations are signaled using optional TCP header fields.\n   A\
    \ single TCP option number (\"Kind\") has been assigned by IANA for\n   MPTCP\
    \ (see Section 7), and then individual messages will be\n   determined by a \"\
    subtype\", the values of which are also stored in an\n   IANA registry (and are\
    \ also listed in Section 7).  As with all TCP\n   options, the Length field is\
    \ specified in bytes and includes the\n   2 bytes of Kind and Length.\n   Throughout\
    \ this document, when reference is made to an MPTCP option\n   by symbolic name,\
    \ such as \"MP_CAPABLE\", this refers to a TCP option\n   with the single MPTCP\
    \ option type, and with the subtype value of the\n   symbolic name as defined\
    \ in Section 7.  This subtype is a 4-bit field\n   -- the first 4 bits of the\
    \ option payload, as shown in Figure 3.  The\n   MPTCP messages are defined in\
    \ the following sections.\n                          1                   2   \
    \                3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n     |     Kind      |    Length     |Subtype|                \
    \       |\n     |                     Subtype-specific data                  \
    \   |\n     |                       (variable length)                       |\n\
    \                       Figure 3: MPTCP Option Format\n   Those MPTCP options\
    \ associated with subflow initiation are used on\n   packets with the SYN flag\
    \ set.  Additionally, there is one MPTCP\n   option for signaling metadata to\
    \ ensure that segmented data can be\n   recombined for delivery to the application.\n\
    \   The remaining options, however, are signals that do not need to be on\n  \
    \ a specific packet, such as those for signaling additional addresses.\n   While\
    \ an implementation may desire to send MPTCP options as soon as\n   possible,\
    \ it may not be possible to combine all desired options (both\n   those for MPTCP\
    \ and for regular TCP, such as SACK (selective\n   acknowledgment) [RFC2018])\
    \ on a single packet.  Therefore, an\n   implementation may choose to send duplicate\
    \ ACKs containing the\n   additional signaling information.  This changes the\
    \ semantics of a\n   duplicate ACK; these are usually only sent as a signal of\
    \ a lost\n   segment [RFC5681] in regular TCP.  Therefore, an MPTCP implementation\n\
    \   receiving a duplicate ACK that contains an MPTCP option MUST NOT\n   treat\
    \ it as a signal of congestion.  Additionally, an MPTCP\n   implementation SHOULD\
    \ NOT send more than two duplicate ACKs in a row\n   for the purposes of sending\
    \ MPTCP options alone, in order to ensure\n   that no middleboxes misinterpret\
    \ this as a sign of congestion.\n   Furthermore, standard TCP validity checks\
    \ (such as ensuring that the\n   sequence number and acknowledgment number are\
    \ within the window) MUST\n   be undertaken before processing any MPTCP signals,\
    \ as described in\n   [RFC5961], and initial subflow sequence numbers SHOULD be\
    \ generated\n   according to the recommendations in [RFC6528].\n"
- title: 3.1.  Connection Initiation
  contents:
  - "3.1.  Connection Initiation\n   Connection initiation begins with a SYN, SYN/ACK,\
    \ ACK exchange on a\n   single path.  Each packet contains the Multipath Capable\
    \ (MP_CAPABLE)\n   MPTCP option (Figure 4).  This option declares its sender capable\
    \ of\n   performing Multipath TCP and wishes to do so on this particular\n   connection.\n\
    \                          1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     |     Kind\
    \      |    Length     |Subtype|Version|A|B|C|D|E|F|G|H|\n     |             \
    \      Option Sender's Key (64 bits)               |\n     |                 \
    \     (if option Length > 4)                   |\n     |                  Option\
    \ Receiver's Key (64 bits)              |\n     |                      (if option\
    \ Length > 12)                  |\n     |  Data-Level Length (16 bits)  |  Checksum\
    \ (16 bits, optional) |\n              Figure 4: Multipath Capable (MP_CAPABLE)\
    \ Option\n   The MP_CAPABLE exchange in this specification (v1) is different than\n\
    \   that specified in v0.  If a host supports multiple versions of MPTCP,\n  \
    \ the sender of the MP_CAPABLE option SHOULD signal the highest version\n   number\
    \ it supports.  In return, in its MP_CAPABLE option, the\n   receiver will signal\
    \ the version number it wishes to use, which MUST\n   be equal to or lower than\
    \ the version number indicated in the initial\n   MP_CAPABLE.  There is a caveat,\
    \ though, with respect to this version\n   negotiation with old listeners that\
    \ only support v0.  A listener that\n   supports v0 expects that the MP_CAPABLE\
    \ option in the SYN segment\n   will include the initiator's key.  If, however,\
    \ the initiator already\n   upgraded to v1, it won't include the key in the SYN\
    \ segment.  Thus,\n   the listener will ignore the MP_CAPABLE of this SYN segment\
    \ and reply\n   with a SYN/ACK that does not include an MP_CAPABLE.  The initiator\n\
    \   MAY choose to immediately fall back to TCP or MAY choose to attempt a\n  \
    \ connection using MPTCP v0 (if the initiator supports v0), in order to\n   discover\
    \ whether the listener supports the earlier version of MPTCP.\n   In general,\
    \ an MPTCP v0 connection will likely be preferred over a\n   TCP connection; however,\
    \ in a particular deployment scenario, it may\n   be known that the listener is\
    \ unlikely to support MPTCP v0 and so the\n   initiator may prefer not to attempt\
    \ a v0 connection.  An initiator\n   MAY cache information for a peer about what\
    \ version of MPTCP it\n   supports, if any, and use this information for future\
    \ connection\n   attempts.\n   The MP_CAPABLE option is of variable length, with\
    \ different fields\n   included, depending on which packet the option is used\
    \ on.  The full\n   MP_CAPABLE option is shown in Figure 4.\n   The MP_CAPABLE\
    \ option is carried on the SYN, SYN/ACK, and ACK packets\n   that start the first\
    \ subflow of an MPTCP connection, as well as the\n   first packet that carries\
    \ data, if the initiator wishes to send\n   first.  The data carried by each option\
    \ is as follows, where\n   A = initiator and B = listener.\n   *  SYN (A->B):\
    \ only the first 4 octets (Length = 4).\n   *  SYN/ACK (B->A): B's key for this\
    \ connection (Length = 12).\n   *  ACK (no data) (A->B): A's key followed by B's\
    \ key (Length = 20).\n   *  ACK (with first data) (A->B): A's key followed by\
    \ B's key followed\n      by Data-Level Length, and optional Checksum (Length\
    \ = 22 or 24).\n   The contents of the option are determined by the SYN and ACK\
    \ flags of\n   the packet, along with the option's Length field.  In Figure 4,\n\
    \   \"Sender\" and \"Receiver\" refer to the sender or receiver of the TCP\n \
    \  packet (which can be either host).\n   The initial SYN, containing just the\
    \ MP_CAPABLE header, is used to\n   define the version of MPTCP being requested\
    \ and also to exchange\n   flags to negotiate connection features, as described\
    \ later.\n   This option is used to declare the 64-bit keys that the end hosts\n\
    \   have generated for this MPTCP connection.  These keys are used to\n   authenticate\
    \ the addition of future subflows to this connection.\n   This is the only time\
    \ the key will be sent in the clear on the wire\n   (unless \"Fast Close\" (Section\
    \ 3.5) is used); all future subflows will\n   identify the connection using a\
    \ 32-bit \"token\".  This token is a\n   cryptographic hash of this key.  The\
    \ algorithm for this process is\n   dependent on the authentication algorithm\
    \ selected; the method of\n   selection is defined later in this section.\n  \
    \ Upon reception of the initial SYN segment, a stateful server\n   generates a\
    \ random key and replies with a SYN/ACK.  The key's method\n   of generation is\
    \ implementation specific.  The key MUST be hard to\n   guess, and it MUST be\
    \ unique for the sending host across all its\n   current MPTCP connections.  Recommendations\
    \ for generating random\n   numbers for use in keys are given in [RFC4086].  Connections\
    \ will be\n   indexed at each host by the token (a one-way hash of the key).\n\
    \   Therefore, an implementation will require a mapping from each token\n   to\
    \ the corresponding connection, and in turn to the keys for the\n   connection.\n\
    \   There is a risk that two different keys will hash to the same token.\n   The\
    \ risk of hash collisions is usually small, unless the host is\n   handling many\
    \ tens of thousands of connections.  Therefore, an\n   implementation SHOULD check\
    \ its list of connection tokens to ensure\n   that there is no collision before\
    \ sending its key, and if there is,\n   then it should generate a new key.  This\
    \ would, however, be costly\n   for a server with thousands of connections.  The\
    \ subflow handshake\n   mechanism (Section 3.2) will ensure that new subflows\
    \ only join the\n   correct connection, however, through the cryptographic handshake,\
    \ as\n   well as checking the connection tokens in both directions, and\n   ensuring\
    \ that sequence numbers are in-window.  So, in the worst case,\n   if there was\
    \ a token collision, the new subflow would not succeed,\n   but the MPTCP connection\
    \ would continue to provide a regular TCP\n   service.\n   Since key generation\
    \ is implementation specific, there is no\n   requirement that they simply be\
    \ random numbers.  An implementation is\n   free to exchange cryptographic material\
    \ out of band and generate\n   these keys from this material, in order to provide\
    \ additional\n   mechanisms by which to verify the identity of the communicating\n\
    \   entities.  For example, an implementation could choose to link its\n   MPTCP\
    \ keys to those used in higher-layer TLS or SSH connections.\n   If the server\
    \ behaves in a stateless manner, it has to generate its\n   own key in a verifiable\
    \ fashion.  This verifiable way of generating\n   the key can be done by using\
    \ a hash of the 4-tuple, sequence number,\n   and a local secret (similar to what\
    \ is done for the TCP sequence\n   number [RFC4987]).  It will thus be able to\
    \ verify whether it is\n   indeed the originator of the key echoed back in the\
    \ subsequent\n   MP_CAPABLE option.  As for a stateful server, the tokens SHOULD\
    \ be\n   checked for uniqueness; however, if uniqueness is not met and there\n\
    \   is no way to generate an alternative verifiable key, then the\n   connection\
    \ MUST fall back to using regular TCP by not sending an\n   MP_CAPABLE in the\
    \ SYN/ACK.\n   The ACK carries both A's key and B's key.  This is the first time\n\
    \   that A's key is seen on the wire, although it is expected that A will\n  \
    \ have generated a key locally before the initial SYN.  The echoing of\n   B's\
    \ key allows B to operate statelessly, as described above.\n   Therefore, A's\
    \ key must be delivered reliably to B, and in order to\n   do this, the transmission\
    \ of this packet must be made reliable.\n   If B has data to send first, then\
    \ the reliable delivery of the\n   ACK + MP_CAPABLE is ensured by the receipt\
    \ of this data with an MPTCP\n   Data Sequence Signal (DSS) option (Section 3.3)\
    \ containing a DATA_ACK\n   for the MP_CAPABLE (which is the first octet of the\
    \ data sequence\n   space).  If, however, A wishes to send data first, it has\
    \ two options\n   to ensure the reliable delivery of the ACK + MP_CAPABLE.  If\
    \ it\n   immediately has data to send, then the first ACK (with data) would\n\
    \   also contain an MP_CAPABLE option with additional data parameters\n   (the\
    \ Data-Level Length and optional Checksum as shown in Figure 4).\n   If A does\
    \ not immediately have data to send, it MUST include the\n   MP_CAPABLE on the\
    \ first ACK, but without the additional data\n   parameters.  When A does have\
    \ data to send, it must repeat the\n   sending of the MP_CAPABLE option from the\
    \ first ACK, with additional\n   data parameters.  This MP_CAPABLE option is used\
    \ in place of the DSS\n   and simply specifies (1) the Data-Level Length of the\
    \ payload and\n   (2) the checksum (if the use of checksums is negotiated).  This\
    \ is\n   the minimal data required to establish an MPTCP connection -- it\n  \
    \ allows validation of the payload, and given that it is the first\n   data, the\
    \ Initial Data Sequence Number (IDSN) is also known (as it is\n   generated from\
    \ the key, as described below).  Conveying the keys on\n   the first data packet\
    \ allows the TCP reliability mechanisms to ensure\n   that the packet is successfully\
    \ delivered.  The receiver will\n   acknowledge this data at the connection level\
    \ with a Data ACK, as if\n   a DSS option has been received.\n   There could be\
    \ situations where both A and B attempt to transmit\n   initial data at the same\
    \ time.  For example, if A did not initially\n   have data to send but then needed\
    \ to transmit data before it had\n   received anything from B, it would use an\
    \ MP_CAPABLE option with data\n   parameters (since it would not know if the MP_CAPABLE\
    \ on the ACK was\n   received).  In such a situation, B may also have transmitted\
    \ data\n   with a DSS option, but it had not yet been received at A.  Therefore,\n\
    \   B has received data with an MP_CAPABLE mapping after it has sent data\n  \
    \ with a DSS option.  To ensure that these situations can be handled,\n   it follows\
    \ that the data parameters in an MP_CAPABLE are semantically\n   equivalent to\
    \ those in a DSS option and can be used interchangeably.\n   Similar situations\
    \ could occur when the MP_CAPABLE with data is lost\n   and retransmitted.  Furthermore,\
    \ in the case of TCP segmentation\n   offloading, the MP_CAPABLE with data parameters\
    \ may be duplicated\n   across multiple packets, and implementations must also\
    \ be able to\n   cope with duplicate MP_CAPABLE mappings as well as duplicate\
    \ DSS\n   mappings.\n   Additionally, the MP_CAPABLE exchange allows the safe\
    \ passage of\n   MPTCP options on SYN packets to be determined.  If any of these\n\
    \   options are dropped, MPTCP will gracefully fall back to regular\n   single-path\
    \ TCP, as documented in Section 3.7.  If at any point in\n   the handshake either\
    \ party thinks the MPTCP negotiation is\n   compromised -- for example, by a middlebox\
    \ corrupting the TCP options\n   or by unexpected ACK numbers being present --\
    \ the host MUST stop\n   using MPTCP and no longer include MPTCP options in future\
    \ TCP\n   packets.  The other host will then also fall back to regular TCP\n \
    \  using the fallback mechanism.  Note that new subflows MUST NOT be\n   established\
    \ (using the process documented in Section 3.2) until a DSS\n   option has been\
    \ successfully received across the path (as documented\n   in Section 3.3).\n\
    \   Like all MPTCP options, the MP_CAPABLE option starts with the Kind\n   and\
    \ Length to specify the TCP option's kind and length.  This\n   information is\
    \ followed by the MP_CAPABLE option.  The first 4 bits\n   of the first octet\
    \ in the MP_CAPABLE option (Figure 4) define the\n   MPTCP Option Subtype (see\
    \ Section 7; for MP_CAPABLE, this value is\n   0x0), and the remaining 4 bits\
    \ of this octet specify the MPTCP\n   version in use (for this specification,\
    \ this value is 1).\n   The second octet is reserved for flags, allocated as follows:\n\
    \   A:            The leftmost bit, labeled \"A\", SHOULD be set to 1 to\n   \
    \              indicate \"Checksum required\", unless the system\n           \
    \      administrator has decided that checksums are not\n                 required\
    \ (for example, if the environment is controlled\n                 and no middleboxes\
    \ exist that might adjust the\n                 payload).\n   B:            The\
    \ second bit, labeled \"B\", is an extensibility flag.\n                 It MUST\
    \ be set to 0 for current implementations.  This\n                 flag will be\
    \ used for an extensibility mechanism in a\n                 future specification,\
    \ and the impact of this flag will\n                 be defined at a later date.\
    \  It is expected, but not\n                 mandated, that this flag would be\
    \ used as part of an\n                 alternative security mechanism that does\
    \ not require a\n                 full version upgrade of the protocol but does\
    \ require\n                 redefining some elements of the handshake.  If\n \
    \                receiving a message with the \"B\" flag set to 1 and this\n \
    \                is not understood, then the MP_CAPABLE in this SYN MUST\n   \
    \              be silently ignored, which triggers a fallback to\n           \
    \      regular TCP; the sender is expected to retry with a\n                 format\
    \ compatible with this legacy specification.  Note\n                 that the\
    \ length of the MP_CAPABLE option, and the\n                 meanings of bits\
    \ \"D\" through \"H\", may be altered by\n                 setting B=1.\n   C:\
    \            The third bit, labeled \"C\", is set to 1 to indicate\n         \
    \        that the sender of this option will not accept\n                 additional\
    \ MPTCP subflows to the source address and\n                 port, and therefore\
    \ the receiver MUST NOT try to open\n                 any additional subflows\
    \ toward this address and port.\n                 This improves efficiency in\
    \ situations where the sender\n                 knows a restriction is in place\
    \ -- for example, if the\n                 sender is behind a strict NAT or operating\
    \ behind a\n                 legacy Layer 4 load balancer.\n   D through H:  The\
    \ remaining bits, labeled \"D\" through \"H\", are used\n                 for\
    \ crypto algorithm negotiation.  In this\n                 specification, only\
    \ the rightmost bit, labeled \"H\", is\n                 assigned.  Bit \"H\"\
    \ indicates the use of HMAC-SHA256 (as\n                 defined in Section 3.2).\
    \  An implementation that only\n                 supports this method MUST set\
    \ bit \"H\" to 1 and bits \"D\"\n                 through \"G\" to 0.\n   A crypto\
    \ algorithm MUST be specified.  If flag bits \"D\" through \"H\"\n   are all 0,\
    \ the MP_CAPABLE option MUST be treated as invalid and\n   ignored (that is, it\
    \ must be treated as a regular TCP handshake).\n   The selection of the authentication\
    \ algorithm also impacts the\n   algorithm used to generate the token and the\
    \ IDSN.  In this\n   specification, with only the SHA-256 algorithm (bit \"H\"\
    ) specified\n   and selected, the token MUST be a truncated (most significant\n\
    \   32 bits) SHA-256 hash [RFC6234] of the key.  A different, 64-bit\n   truncation\
    \ (the least significant 64 bits) of the SHA-256 hash of the\n   key MUST be used\
    \ as the IDSN.  Note that the key MUST be hashed in\n   network byte order.  Also\
    \ note that the \"least significant\" bits MUST\n   be the rightmost bits of the\
    \ SHA-256 digest, as per [RFC6234].\n   Future specifications of the use of the\
    \ crypto bits may choose to\n   specify different algorithms for token and IDSN\
    \ generation.\n   Both the crypto and checksum bits negotiate capabilities in\
    \ similar\n   ways.  For the \"Checksum required\" bit (labeled \"A\"), if either\
    \ host\n   requires the use of checksums, checksums MUST be used.  In other\n\
    \   words, the only way for checksums not to be used is if both hosts in\n   their\
    \ SYNs set A=0.  This decision is confirmed by the setting of the\n   \"A\" bit\
    \ in the third packet (the ACK) of the handshake.  For example,\n   if the initiator\
    \ sets A=0 in the SYN but the responder sets A=1 in\n   the SYN/ACK, checksums\
    \ MUST be used in both directions, and the\n   initiator will set A=1 in the ACK.\
    \  The decision regarding whether to\n   use checksums will be stored by an implementation\
    \ in a per-connection\n   binary state variable.  If A=1 is received by a host\
    \ that does not\n   want to use checksums, it MUST fall back to regular TCP by\
    \ ignoring\n   the MP_CAPABLE option as if it was invalid.\n   For crypto negotiation,\
    \ the responder has the choice.  The initiator\n   creates a proposal setting\
    \ a bit for each algorithm it supports to 1\n   (in this version of the specification,\
    \ there is only one proposal, so\n   bit \"H\" will always be set to 1).  The\
    \ responder responds with only\n   1 bit set -- this is the chosen algorithm.\
    \  The rationale for this\n   behavior is that the responder will typically be\
    \ a server with\n   potentially many thousands of connections, so it may wish\
    \ to choose\n   an algorithm with minimal computational complexity, depending\
    \ on the\n   load.  If a responder does not support (or does not want to support)\n\
    \   any of the initiator's proposals, it MUST respond without an\n   MP_CAPABLE\
    \ option, thus forcing a fallback to regular TCP.\n   The MP_CAPABLE option is\
    \ only used in the first subflow of a\n   connection, in order to identify the\
    \ connection; all subsequent\n   subflows will use the MP_JOIN option (see Section\
    \ 3.2) to join the\n   existing connection.\n   If a SYN contains an MP_CAPABLE\
    \ option but the SYN/ACK does not, it\n   is assumed that the sender of the SYN/ACK\
    \ is not multipath capable;\n   thus, the MPTCP session MUST operate as a regular,\
    \ single-path TCP\n   session.  If a SYN does not contain an MP_CAPABLE option,\
    \ the SYN/ACK\n   MUST NOT contain one in response.  If the third packet (the\
    \ ACK) does\n   not contain the MP_CAPABLE option, then the session MUST fall\
    \ back to\n   operating as a regular, single-path TCP session.  This is done to\n\
    \   maintain compatibility with middleboxes on the path that drop some or\n  \
    \ all TCP options.  Note that an implementation MAY choose to attempt\n   sending\
    \ MPTCP options more than one time before making this decision\n   to operate\
    \ as regular TCP (see Section 3.9).\n   If the SYN packets are unacknowledged,\
    \ it is up to local policy to\n   decide how to respond.  It is expected that\
    \ a sender will eventually\n   fall back to single-path TCP (i.e., without the\
    \ MP_CAPABLE option) in\n   order to work around middleboxes that may drop packets\
    \ with unknown\n   options; however, the number of multipath-capable attempts\
    \ that are\n   made first will be up to local policy.  It is possible that MPTCP\
    \ and\n   non-MPTCP SYNs could get reordered in the network.  Therefore, the\n\
    \   final state is inferred from the presence or absence of the\n   MP_CAPABLE\
    \ option in the third packet of the TCP handshake.  If this\n   option is not\
    \ present, the connection SHOULD fall back to regular\n   TCP, as documented in\
    \ Section 3.7.\n   The IDSN on an MPTCP connection is generated from the key.\
    \  The\n   algorithm for IDSN generation is also determined from the negotiated\n\
    \   authentication algorithm.  In this specification, with only the\n   SHA-256\
    \ algorithm specified and selected, the IDSN of a host MUST be\n   the least significant\
    \ 64 bits of the SHA-256 hash of its key, i.e.,\n   IDSN-A = Hash(Key-A) and IDSN-B\
    \ = Hash(Key-B).  This deterministic\n   generation of the IDSN allows a receiver\
    \ to ensure that there are no\n   gaps in sequence space at the start of the connection.\
    \  The SYN with\n   MP_CAPABLE occupies the first octet of data sequence space,\
    \ although\n   this does not need to be acknowledged at the connection level until\n\
    \   the first data is sent (see Section 3.3).\n"
- title: 3.2.  Starting a New Subflow
  contents:
  - "3.2.  Starting a New Subflow\n   Once an MPTCP connection has begun with the\
    \ MP_CAPABLE exchange,\n   further subflows can be added to the connection.  Hosts\
    \ have\n   knowledge of their own address(es) and can become aware of the other\n\
    \   host's addresses through signaling exchanges as described in\n   Section 3.4.\
    \  Using this knowledge, a host can initiate a new subflow\n   over a currently\
    \ unused pair of addresses.  It is permissible for\n   either host in a connection\
    \ to initiate the creation of a new\n   subflow, but it is expected that this\
    \ will normally be the original\n   connection initiator (see Section 3.9 for\
    \ heuristics).\n   A new subflow is started as a normal TCP SYN/ACK exchange.\
    \  The Join\n   Connection (MP_JOIN) MPTCP option is used to identify the connection\n\
    \   to be joined by the new subflow.  It uses keying material that was\n   exchanged\
    \ in the initial MP_CAPABLE handshake (Section 3.1), and that\n   handshake also\
    \ negotiates the crypto algorithm in use for the MP_JOIN\n   handshake.\n   This\
    \ section specifies the behavior of MP_JOIN using the HMAC-SHA256\n   algorithm.\
    \  An MP_JOIN option is present in the SYN, SYN/ACK, and ACK\n   of the three-way\
    \ handshake, although in each case with a different\n   format.\n   In the first\
    \ MP_JOIN on the SYN packet, illustrated in Figure 5, the\n   initiator sends\
    \ a token, random number, and Address ID.\n                          1       \
    \            2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     |     Kind      |  Length = 12  |Subtype|(rsv)|B|\
    \   Address ID  |\n     |                   Receiver's Token (32 bits)       \
    \           |\n     |                Sender's Random Number (32 bits)        \
    \       |\n        Figure 5: Join Connection (MP_JOIN) Option (for Initial SYN)\n\
    \   The token is used to identify the MPTCP connection and is a\n   cryptographic\
    \ hash of the receiver's key, as exchanged in the initial\n   MP_CAPABLE handshake\
    \ (Section 3.1).  In this specification, the\n   tokens presented in this option\
    \ are generated by the SHA-256\n   algorithm [RFC6234], truncated to the most\
    \ significant 32 bits.  The\n   token included in the MP_JOIN option is the token\
    \ that the receiver\n   of the packet uses to identify this connection; i.e.,\
    \ Host A will\n   send Token-B (which is generated from Key-B).  Note that the\
    \ hash\n   generation algorithm can be overridden by the choice of cryptographic\n\
    \   handshake algorithm, as defined in Section 3.1.\n   The MP_JOIN SYN sends\
    \ not only the token (which is static for a\n   connection) but also random numbers\
    \ (nonces) that are used to prevent\n   replay attacks on the authentication method.\
    \  Recommendations for the\n   generation of random numbers for this purpose are\
    \ given in [RFC4086].\n   The MP_JOIN option includes an \"Address ID\".  This\
    \ is an identifier\n   generated by the sender of the option, used to identify\
    \ the source\n   address of this packet, even if the IP header has been changed\
    \ in\n   transit by a middlebox.  The numeric value of this field is generated\n\
    \   by the sender and must map uniquely to a source IP address for the\n   sending\
    \ host.  The Address ID allows address removal (Section 3.4.2)\n   without needing\
    \ to know what the source address at the receiver is,\n   thus allowing address\
    \ removal through NATs.  The Address ID also\n   allows correlation between new\
    \ subflow setup attempts and address\n   signaling (Section 3.4.1), to prevent\
    \ setting up duplicate subflows\n   on the same path, if an MP_JOIN and ADD_ADDR\
    \ are sent at the same\n   time.\n   The Address IDs of the subflow used in the\
    \ initial SYN exchange of\n   the first subflow in the connection are implicit\
    \ and have the value\n   zero.  A host MUST store the mappings between Address\
    \ IDs and\n   addresses both for itself and the remote host.  An implementation\n\
    \   will also need to know which local and remote Address IDs are\n   associated\
    \ with which established subflows, for when addresses are\n   removed from a local\
    \ or remote host.\n   The MP_JOIN option on packets with the SYN flag set also\
    \ includes\n   4 bits of flags, 3 of which are currently reserved and MUST be\
    \ set to\n   0 by the sender.  The final bit, labeled \"B\", indicates whether\
    \ the\n   sender of this option (1) wishes this subflow to be used as a backup\n\
    \   path (B=1) in the event of failure of other paths or (2) wants the\n   subflow\
    \ to be used as part of the connection immediately.  By setting\n   B=1, the sender\
    \ of the option is requesting that the other host only\n   send data on this subflow\
    \ if there are no available subflows where\n   B=0.  Subflow policy is discussed\
    \ in more detail in Section 3.3.8.\n   When receiving a SYN with an MP_JOIN option\
    \ that contains a valid\n   token for an existing MPTCP connection, the recipient\
    \ SHOULD respond\n   with a SYN/ACK also containing an MP_JOIN option containing\
    \ a random\n   number and a truncated (leftmost 64 bits) HMAC.  This version of\
    \ the\n   option is shown in Figure 6.  If the token is unknown or the host\n\
    \   wants to refuse subflow establishment (for example, due to a limit on\n  \
    \ the number of subflows it will permit), the receiver will send back a\n   reset\
    \ (RST) signal, analogous to an unknown port in TCP, containing\n   an MP_TCPRST\
    \ option (Section 3.6) with an \"MPTCP specific error\"\n   reason code.  Although\
    \ calculating an HMAC requires cryptographic\n   operations, it is believed that\
    \ the 32-bit token in the MP_JOIN SYN\n   gives sufficient protection against\
    \ blind state exhaustion attacks;\n   therefore, there is no need to provide mechanisms\
    \ to allow a\n   responder to operate statelessly at the MP_JOIN stage.\n    \
    \                      1                   2                   3\n      0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     |     Kind \
    \     |  Length = 16  |Subtype|(rsv)|B|   Address ID  |\n     |              \
    \  Sender's Truncated HMAC (64 bits)              |\n     |                Sender's\
    \ Random Number (32 bits)               |\n    Figure 6: Join Connection (MP_JOIN)\
    \ Option (for Responding SYN/ACK)\n   An HMAC is sent by both hosts -- by the\
    \ initiator (Host A) in the\n   third packet (the ACK) and by the responder (Host\
    \ B) in the second\n   packet (the SYN/ACK).  Doing the HMAC exchange at this\
    \ stage allows\n   both hosts to have first exchanged random data (in the first\
    \ two SYN\n   packets) that is used as the \"message\".  This specification defines\n\
    \   that HMAC as defined in [RFC2104] is used, along with the SHA-256\n   hash\
    \ algorithm [RFC6234], and that the output is truncated to the\n   leftmost 160\
    \ bits (20 octets).  Due to option space limitations, the\n   HMAC included in\
    \ the SYN/ACK is truncated to the leftmost 64 bits,\n   but this is acceptable,\
    \ since random numbers are used; thus, an\n   attacker only has one chance to\
    \ correctly guess the HMAC that matches\n   the random number previously sent\
    \ by the peer (if the HMAC is\n   incorrect, the TCP connection is closed, so\
    \ a new MP_JOIN negotiation\n   with a new random number is required).\n   The\
    \ initiator's authentication information is sent in its first ACK\n   (the third\
    \ packet of the handshake), as shown in Figure 7.  This data\n   needs to be sent\
    \ reliably, since it is the only time this HMAC is\n   sent; therefore, receipt\
    \ of this packet MUST trigger a regular TCP\n   ACK in response, and the packet\
    \ MUST be retransmitted if this ACK is\n   not received.  In other words, sending\
    \ the ACK/MP_JOIN packet places\n   the subflow in the PRE_ESTABLISHED state,\
    \ and it moves to the\n   ESTABLISHED state only on receipt of an ACK from the\
    \ receiver.  It is\n   not permissible to send data while in the PRE_ESTABLISHED\
    \ state.  The\n   reserved bits in this option MUST be set to 0 by the sender.\n\
    \                          1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     |     Kind\
    \      |  Length = 24  |Subtype|      (reserved)       |\n     |             \
    \ Sender's Truncated HMAC (160 bits)               |\n                 Figure\
    \ 7: Join Connection (MP_JOIN) Option\n                        (for Initiator's\
    \ First ACK)\n   The key for the HMAC algorithm, in the case of the message\n\
    \   transmitted by Host A, will be Key-A followed by Key-B; and in the\n   case\
    \ of Host B, Key-B followed by Key-A.  These are the keys that\n   were exchanged\
    \ in the original MP_CAPABLE handshake.  The \"message\"\n   for the HMAC algorithm\
    \ in each case is the concatenations of random\n   numbers for each host (denoted\
    \ by R): for Host A, R-A followed by\n   R-B; and for Host B, R-B followed by\
    \ R-A.\n   These various MPTCP options fit together to enable authenticated\n\
    \   subflow setup as illustrated in Figure 8.\n                   Host A     \
    \                             Host B\n          Address A1    Address A2     \
    \                  Address B1\n              |             |  SYN + MP_CAPABLE\
    \              |\n              |          SYN/ACK + MP_CAPABLE(Key-B)       \
    \  |\n              |        ACK + MP_CAPABLE(Key-A, Key-B)        |\n       \
    \       |             | SYN/ACK + MP_JOIN(HMAC-B, R-B) |\n          HMAC-A = HMAC(Key=(Key-A\
    \ + Key-B), Msg=(R-A + R-B))\n          HMAC-B = HMAC(Key=(Key-B + Key-A), Msg=(R-B\
    \ + R-A))\n               Figure 8: Example Use of MPTCP Authentication\n   If\
    \ the token received at Host B is unknown or local policy prohibits\n   the acceptance\
    \ of the new subflow, the recipient MUST respond with a\n   TCP RST for the subflow.\
    \  If appropriate, an MP_TCPRST option with an\n   \"Administratively prohibited\"\
    \ reason code (Section 3.6) should be\n   included.\n   If the token is accepted\
    \ at Host B but the HMAC returned to Host A\n   does not match the one expected,\
    \ Host A MUST close the subflow with a\n   TCP RST.  In this and all subsequent\
    \ cases of sending a RST as\n   described in this section, the sender SHOULD send\
    \ an MP_TCPRST option\n   (Section 3.6) on this RST packet with the reason code\
    \ for an \"MPTCP-\n   specific error\".\n   If Host B does not receive the expected\
    \ HMAC or the MP_JOIN option is\n   missing from the ACK, it MUST close the subflow\
    \ with a TCP RST.\n   If the HMACs are verified as correct, then both hosts have\
    \ verified\n   each other as being the same peers as those that existed at the\
    \ start\n   of the connection, and they have agreed of which connection this\n\
    \   subflow will become a part.\n   If the SYN/ACK as received at Host A does\
    \ not have an MP_JOIN option,\n   Host A MUST close the subflow with a TCP RST.\n\
    \   This covers all cases of the loss of an MP_JOIN.  In more detail, if\n   an\
    \ MP_JOIN is stripped from the SYN on the path from A to B and\n   Host B does\
    \ not have a listener on the relevant port, it will respond\n   with a RST in\
    \ the normal way.  If in response to a SYN with an\n   MP_JOIN option a SYN/ACK\
    \ is received without the MP_JOIN option\n   (because it was either stripped on\
    \ the return path, or stripped on\n   the outgoing path leading to Host B responding\
    \ as if it was a new\n   regular TCP session), then the subflow is unusable and\
    \ Host A MUST\n   close it with a RST.\n   Note that additional subflows can be\
    \ created between any pair of\n   ports (but see Section 3.9 for heuristics);\
    \ no explicit application-\n   level accept calls or bind calls are required to\
    \ open additional\n   subflows.  To associate a new subflow with an existing connection,\n\
    \   the token supplied in the subflow's SYN exchange is used for\n   demultiplexing.\
    \  This then binds the 5-tuple of the TCP subflow to\n   the local token of the\
    \ connection.  One consequence is that it is\n   possible to allow any port pairs\
    \ to be used for a connection.\n   Demultiplexing subflow SYNs MUST be done using\
    \ the token; this is\n   unlike traditional TCP, where the destination port is\
    \ used for\n   demultiplexing SYN packets.  Once a subflow is set up, demultiplexing\n\
    \   packets is done using the 5-tuple, as in traditional TCP.  The\n   5-tuples\
    \ will be mapped to the local connection identifier (token).\n   Note that Host\
    \ A will know its local token for the subflow even\n   though it is not sent on\
    \ the wire -- only the responder's token is\n   sent.\n"
- title: 3.3.  MPTCP Operation and Data Transfer
  contents:
  - "3.3.  MPTCP Operation and Data Transfer\n   This section discusses the operation\
    \ of MPTCP for data transfer.  At\n   a high level, an MPTCP implementation will\
    \ take one input data stream\n   from an application and split it into one or\
    \ more subflows, with\n   sufficient control information to allow it to be reassembled\
    \ and\n   delivered reliably and in order to the recipient application.  The\n\
    \   following subsections define this behavior in detail.\n   The Data Sequence\
    \ Mapping and the Data ACK are signaled in the DSS\n   option (Figure 9).  Either\
    \ or both can be signaled in one DSS,\n   depending on the flags set.  The Data\
    \ Sequence Mapping defines how\n   the sequence space on the subflow maps to the\
    \ connection level, and\n   the Data ACK acknowledges receipt of data at the connection\
    \ level.\n   These functions are described in more detail in the following two\n\
    \   subsections.\n                          1                   2            \
    \       3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n     |     Kind      |    Length     |Subtype| (reserved) |F|m|M|a|A|\n \
    \    |           Data ACK (4 or 8 octets, depending on flags)       |\n     |\
    \   Data Sequence Number (4 or 8 octets, depending on flags)   |\n     |     \
    \         Subflow Sequence Number (4 octets)              |\n     |  Data-Level\
    \ Length (2 octets) |      Checksum (2 octets)     |\n                Figure 9:\
    \ Data Sequence Signal (DSS) Option\n   The flags, when set, define the contents\
    \ of this option, as follows:\n   *  A = Data ACK present\n   *  a = Data ACK\
    \ is 8 octets (if not set, Data ACK is 4 octets)\n   *  M = Data Sequence Number\
    \ (DSN), Subflow Sequence Number (SSN),\n      Data-Level Length, and Checksum\
    \ (if negotiated) present\n   *  m = Data Sequence Number is 8 octets (if not\
    \ set, DSN is 4 octets)\n   The flags \"a\" and \"m\" only have meaning if the\
    \ corresponding \"A\" or\n   \"M\" flags are set; otherwise, they will be ignored.\
    \  The maximum\n   length of this option, with all flags set, is 28 octets.\n\
    \   The \"F\" flag indicates \"Data FIN\".  If present, this means that this\n\
    \   mapping covers the final data from the sender.  This is the\n   connection-level\
    \ equivalent of the FIN flag in single-path TCP.  A\n   connection is not closed\
    \ unless there has been a Data FIN exchange,\n   an MP_FASTCLOSE (Section 3.5)\
    \ message, or an implementation-specific\n   connection-level send timeout.  The\
    \ purpose of the Data FIN and the\n   interactions between this flag, the subflow-level\
    \ FIN flag, and the\n   Data Sequence Mapping are described in Section 3.3.3.\
    \  The remaining\n   reserved bits MUST be set to 0 by an implementation of this\n\
    \   specification.\n   Note that the checksum is only present in this option if\
    \ the use of\n   MPTCP checksumming has been negotiated at the MP_CAPABLE handshake\n\
    \   (see Section 3.1).  The presence of the checksum can be inferred from\n  \
    \ the length of the option.  If a checksum is present but its use had\n   not\
    \ been negotiated in the MP_CAPABLE handshake, the receiver MUST\n   close the\
    \ subflow with a RST, as it is not behaving as negotiated.\n   If a checksum is\
    \ not present when its use has been negotiated, the\n   receiver MUST close the\
    \ subflow with a RST, as it is considered\n   broken.  In both cases, this RST\
    \ SHOULD be accompanied by an\n   MP_TCPRST option (Section 3.6) with the reason\
    \ code for an \"MPTCP-\n   specific error\".\n"
- title: 3.3.1.  Data Sequence Mapping
  contents:
  - "3.3.1.  Data Sequence Mapping\n   The data stream as a whole can be reassembled\
    \ through the use of the\n   Data Sequence Mapping components of the DSS option\
    \ (Figure 9), which\n   define the mapping from the subflow sequence number to\
    \ the data\n   sequence number.  This is used by the receiver to ensure in-order\n\
    \   delivery to the application layer.  Meanwhile, the subflow-level\n   sequence\
    \ numbers (i.e., the regular sequence numbers in the TCP\n   header) are only\
    \ relevant to the subflow.  It is expected (but not\n   mandated) that SACK [RFC2018]\
    \ will be used at the subflow level to\n   improve efficiency.\n   The Data Sequence\
    \ Mapping specifies a mapping from the subflow\n   sequence space to the data\
    \ sequence space.  This is expressed in\n   terms of starting sequence numbers\
    \ for the subflow and the data\n   level, and a length of bytes for which this\
    \ mapping is valid.  This\n   explicit mapping for a range of data, rather than\
    \ per-packet\n   signaling, was chosen to assist with compatibility with situations\n\
    \   where TCP/IP segmentation or coalescing is undertaken separately from\n  \
    \ the stack that is generating the data flow (e.g., through the use of\n   TCP\
    \ segmentation offloading on network interface cards, or by\n   middleboxes such\
    \ as Performance Enhancing Proxies (PEPs) [RFC3135]).\n   It also allows a single\
    \ mapping to cover many packets; this may be\n   useful in bulk-transfer situations.\n\
    \   A mapping is fixed, in that the subflow sequence number is bound to\n   the\
    \ data sequence number after the mapping has been processed.  A\n   sender MUST\
    \ NOT change this mapping after it has been declared;\n   however, the same data\
    \ sequence number can be mapped to by different\n   subflows for retransmission\
    \ purposes (see Section 3.3.6).  This would\n   also permit the same data to be\
    \ sent simultaneously on multiple\n   subflows for resilience or efficiency purposes,\
    \ especially in the\n   case of lossy links.  Although the detailed specification\
    \ of such\n   operation is outside the scope of this document, an implementation\n\
    \   SHOULD treat the first data that is received at a subflow for the\n   data\
    \ sequence space as the data that should be delivered to the\n   application,\
    \ and any subsequent data for that sequence space SHOULD\n   be ignored.\n   The\
    \ data sequence number is specified as an absolute value, whereas\n   the subflow\
    \ sequence numbering is relative (the SYN at the start of\n   the subflow has\
    \ a relative subflow sequence number of 0).  This is\n   done to allow middleboxes\
    \ to change the Initial Sequence Number (ISN)\n   of a subflow, such as firewalls\
    \ that undertake ISN randomization.\n   The Data Sequence Mapping also contains\
    \ a checksum of the data that\n   this mapping covers, if the use of checksums\
    \ has been negotiated at\n   the MP_CAPABLE exchange.  Checksums are used to detect\
    \ if the payload\n   has been adjusted in any way by a non-MPTCP-aware middlebox.\
    \  If this\n   checksum fails, it will trigger a failure of the subflow, or a\n\
    \   fallback to regular TCP, as documented in Section 3.7, since MPTCP\n   can\
    \ no longer reliably know the subflow sequence space at the\n   receiver to build\
    \ Data Sequence Mappings.  Without checksumming\n   enabled, corrupt data may\
    \ be delivered to the application if a\n   middlebox alters segment boundaries,\
    \ alters content, or does not\n   deliver all segments covered by a Data Sequence\
    \ Mapping.  It is\n   therefore RECOMMENDED that checksumming be used, unless\
    \ it is known\n   that the network path contains no such devices.\n   The checksum\
    \ algorithm used is the standard TCP checksum [RFC0793],\n   operating over the\
    \ data covered by this mapping, along with a\n   pseudo-header as shown in Figure\
    \ 10.\n                          1                   2                   3\n \
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     |\
    \                Data Sequence Number (8 octets)               |\n     |     \
    \         Subflow Sequence Number (4 octets)              |\n     |  Data-Level\
    \ Length (2 octets) |        Zeros (2 octets)      |\n                 Figure\
    \ 10: Pseudo-Header for DSS Checksum\n   Note that the data sequence number used\
    \ in the pseudo-header is\n   always the 64-bit value, irrespective of what length\
    \ is used in the\n   DSS option itself.  The standard TCP checksum algorithm has\
    \ been\n   chosen, since it will be calculated anyway for the TCP subflow, and\n\
    \   if calculated first over the data before adding the pseudo-headers,\n   it\
    \ only needs to be calculated once.  Furthermore, since the TCP\n   checksum is\
    \ additive, the checksum for a DSN_MAP can be constructed\n   by simply adding\
    \ together the checksums for the data of each\n   constituent TCP segment and\
    \ adding the checksum for the DSS\n   pseudo-header.\n   Note that checksumming\
    \ relies on the TCP subflow containing\n   contiguous data; therefore, a TCP subflow\
    \ MUST NOT use the Urgent\n   Pointer to interrupt an existing mapping.  Further\
    \ note, however,\n   that if Urgent data is received on a subflow, it SHOULD be\
    \ mapped to\n   the data sequence space and delivered to the application, analogous\n\
    \   to Urgent data in regular TCP.\n   To avoid possible deadlock scenarios, subflow-level\
    \ processing should\n   be undertaken separately from processing at the connection\
    \ level.\n   Therefore, even if a mapping does not exist from the subflow space\
    \ to\n   the data-level space, the data SHOULD still be ACKed at the subflow\n\
    \   (if it is in-window).  This data cannot, however, be acknowledged at\n   the\
    \ data level (Section 3.3.2) because its data sequence numbers are\n   unknown.\
    \  Implementations MAY hold onto such unmapped data for a\n   short while, in\
    \ the expectation that a mapping will arrive shortly.\n   Such unmapped data cannot\
    \ be counted as being within the connection-\n   level receive window because\
    \ this is relative to the data sequence\n   numbers, so if the receiver runs out\
    \ of memory to hold this data, it\n   will have to be discarded.  If a mapping\
    \ for that subflow-level\n   sequence space does not arrive within a receive window\
    \ of data, that\n   subflow SHOULD be treated as broken, closed with a RST, and\
    \ any\n   unmapped data silently discarded.\n   Data sequence numbers are always\
    \ 64-bit quantities and MUST be\n   maintained as such in implementations.  If\
    \ a connection is\n   progressing at a slow rate, so protection against wrapped\
    \ sequence\n   numbers is not required, then an implementation MAY include just\
    \ the\n   lower 32 bits of the data sequence number in the Data Sequence\n   Mapping\
    \ and/or Data ACK as an optimization, and an implementation can\n   make this\
    \ choice independently for each packet.  An implementation\n   MUST be able to\
    \ receive and process both 64-bit and 32-bit sequence\n   number values, but it\
    \ is not required that an implementation be able\n   to send both.\n   An implementation\
    \ MUST send the full 64-bit data sequence number if\n   it is transmitting at\
    \ a sufficiently high rate that the 32-bit value\n   could wrap within the Maximum\
    \ Segment Lifetime (MSL) [RFC7323].  The\n   lengths of the DSNs used in these\
    \ values (which may be different) are\n   declared with flags in the DSS option.\
    \  Implementations MUST accept a\n   32-bit DSN and implicitly promote it to a\
    \ 64-bit quantity by\n   incrementing the upper 32 bits of the sequence number\
    \ each time the\n   lower 32 bits wrap.  A sanity check MUST be implemented to\
    \ ensure\n   that a wrap occurs at an expected time (e.g., the sequence number\n\
    \   jumps from a very high number to a very low number) and is not\n   triggered\
    \ by out-of-order packets.\n   As with the standard TCP sequence number, the data\
    \ sequence number\n   should not start at zero, but at a random value to make\
    \ blind session\n   hijacking harder.  This specification requires setting the\
    \ IDSN of\n   each host to the least significant 64 bits of the SHA-256 hash of\
    \ the\n   host's key, as described in Section 3.1.  This is also required in\n\
    \   order for the receiver to know what the expected IDSN is and thus\n   determine\
    \ if any initial connection-level packets are missing; this\n   is particularly\
    \ relevant if two subflows start transmitting\n   simultaneously.\n   The mapping\
    \ provided by a Data Sequence Mapping MUST apply to some or\n   all of the subflow\
    \ sequence space in the TCP segment that carries the\n   option.  It does not\
    \ need to be included in every MPTCP packet, as\n   long as the subflow sequence\
    \ space in that packet is covered by a\n   mapping known at the receiver.  This\
    \ can be used to reduce overhead\n   in cases where the mapping is known in advance.\
    \  One such case is\n   when there is a single subflow between the hosts, and\
    \ another is when\n   segments of data are scheduled in larger-than-packet-sized\
    \ chunks.\n   An \"infinite\" mapping can be used to fall back to regular TCP\
    \ by\n   mapping the subflow-level data to the connection-level data for the\n\
    \   remainder of the connection (see Section 3.7).  This is achieved by\n   setting\
    \ the Data-Level Length field of the DSS option to the reserved\n   value of 0.\
    \  The checksum, in such a case, will also be set to 0.\n"
- title: 3.3.2.  Data Acknowledgments
  contents:
  - "3.3.2.  Data Acknowledgments\n   To provide full end-to-end resilience, MPTCP\
    \ provides a connection-\n   level acknowledgment, to act as a cumulative ACK\
    \ for the connection\n   as a whole.  This is done via the \"Data ACK\" field\
    \ of the DSS option\n   (Figure 9).  The Data ACK is analogous to the behavior\
    \ of the\n   standard TCP cumulative ACK -- indicating how much data has been\n\
    \   successfully received (with no holes).  This can be compared to the\n   subflow-level\
    \ ACK, which acts in a fashion analogous to TCP SACK,\n   given that there may\
    \ still be holes in the data stream at the\n   connection level.  The Data ACK\
    \ specifies the next data sequence\n   number it expects to receive.\n   The Data\
    \ ACK, as for the DSN, can be sent as the full 64-bit value or\n   as the lower\
    \ 32 bits.  If data is received with a 64-bit DSN, it MUST\n   be acknowledged\
    \ with a 64-bit Data ACK.  If the DSN received is\n   32 bits, an implementation\
    \ can choose whether to send a 32-bit or\n   64-bit Data ACK, and an implementation\
    \ MUST accept either in this\n   situation.\n   The Data ACK proves that the data,\
    \ and all required MPTCP signaling,\n   have been received and accepted by the\
    \ remote end.  One key use of\n   the Data ACK signal is that it is used to indicate\
    \ the left edge of\n   the advertised receive window.  As explained in Section\
    \ 3.3.4, the\n   receive window is shared by all subflows and is relative to the\
    \ Data\n   ACK.  Because of this, an implementation MUST NOT use the RCV.WND\n\
    \   field of a TCP segment at the connection level if it does not also\n   carry\
    \ a DSS option with a Data ACK field.  Furthermore, separating\n   the connection-level\
    \ acknowledgments from the subflow level allows\n   processing to be done separately,\
    \ and a receiver has the freedom to\n   drop segments after acknowledgment at\
    \ the subflow level -- for\n   example, due to memory constraints when many segments\
    \ arrive out of\n   order.\n   An MPTCP sender MUST NOT free data from the send\
    \ buffer until it has\n   been acknowledged by both a Data ACK received on any\
    \ subflow and at\n   the subflow level by all subflows on which the data was sent.\
    \  The\n   former condition ensures liveness of the connection, and the latter\n\
    \   condition ensures liveness and self-consistence of a subflow when\n   data\
    \ needs to be retransmitted.  Note, however, that if some data\n   needs to be\
    \ retransmitted multiple times over a subflow, there is a\n   risk of blocking\
    \ the send window.  In this case, the MPTCP sender can\n   decide to terminate\
    \ the subflow that is behaving badly by sending a\n   RST, using an appropriate\
    \ MP_TCPRST (Section 3.6) error code.\n   The Data ACK MAY be included in all\
    \ segments; however, optimizations\n   SHOULD be considered in more advanced implementations,\
    \ where the Data\n   ACK is present in segments only when the Data ACK value advances,\
    \ and\n   this behavior MUST be treated as valid.  This behavior ensures that\n\
    \   the send buffer is freed, while reducing overhead when the data\n   transfer\
    \ is unidirectional.\n"
- title: 3.3.3.  Closing a Connection
  contents:
  - "3.3.3.  Closing a Connection\n   In regular TCP, a FIN announces to the receiver\
    \ that the sender has\n   no more data to send.  In order to allow subflows to\
    \ operate\n   independently and to keep the appearance of TCP over the wire, a\
    \ FIN\n   in MPTCP only affects the subflow on which it is sent.  This allows\n\
    \   nodes to exercise considerable freedom over which paths are in use at\n  \
    \ any one time.  The semantics of a FIN remain as for regular TCP;\n   i.e., it\
    \ is not until both sides have ACKed each other's FINs that\n   the subflow is\
    \ fully closed.\n   When an application calls close() on a socket, this indicates\
    \ that it\n   has no more data to send; for regular TCP, this would result in\
    \ a FIN\n   on the connection.  For MPTCP, an equivalent mechanism is needed;\n\
    \   this is referred to as the DATA_FIN.\n   A DATA_FIN is an indication that\
    \ the sender has no more data to send,\n   and as such it can be used to verify\
    \ that all data has been\n   successfully received.  A DATA_FIN, as with the FIN\
    \ on a regular TCP\n   connection, is a unidirectional signal.\n   The DATA_FIN\
    \ is signaled by setting the \"F\" flag in the DSS option\n   (Figure 9) to 1.\
    \  A DATA_FIN occupies 1 octet (the final octet) of\n   the connection-level sequence\
    \ space.  Note that the DATA_FIN is\n   included in the Data-Level Length but\
    \ not at the subflow level: for\n   example, a segment with a DSN value of 80\
    \ and a Data-Level Length of\n   11, with DATA_FIN set, would map 10 octets from\
    \ the subflow into data\n   sequence space 80-89, and the DATA_FIN would be DSN\
    \ 90; therefore,\n   this segment, including DATA_FIN, would be acknowledged with\
    \ a\n   DATA_ACK of 91.\n   Note that when the DATA_FIN is not attached to a TCP\
    \ segment\n   containing data, the DSS MUST have a subflow sequence number of\
    \ 0, a\n   Data-Level Length of 1, and the data sequence number that corresponds\n\
    \   with the DATA_FIN itself.  The checksum in this case will only cover\n   the\
    \ pseudo-header.\n   A DATA_FIN has the same semantics and behavior as a regular\
    \ TCP FIN,\n   but at the connection level.  Notably, it is only DATA_ACKed once\
    \ all\n   data has been successfully received at the connection level.  Note,\n\
    \   therefore, that a DATA_FIN is decoupled from a subflow FIN.  It is\n   only\
    \ permissible to combine these signals on one subflow if there is\n   no data\
    \ outstanding on other subflows.  Otherwise, it may be\n   necessary to retransmit\
    \ data on different subflows.  Essentially, a\n   host MUST NOT close all functioning\
    \ subflows unless it is safe to do\n   so, i.e., until all outstanding data has\
    \ been DATA_ACKed or until the\n   segment with the DATA_FIN flag set is the only\
    \ outstanding segment.\n   Once a DATA_FIN has been acknowledged, all remaining\
    \ subflows MUST be\n   closed with standard FIN exchanges.  Both hosts SHOULD\
    \ send FINs on\n   all subflows, as a courtesy, to allow middleboxes to clean\
    \ up state\n   even if an individual subflow has failed.  Reducing the timeouts\n\
    \   (MSL) on subflows at end hosts after receiving a DATA_FIN is also\n   encouraged.\
    \  In particular, any subflows where there is still\n   outstanding data queued\
    \ (which has been retransmitted on other\n   subflows in order to get the DATA_FIN\
    \ acknowledged) MAY be closed\n   with a RST with an MP_TCPRST (Section 3.6) error\
    \ code for \"too much\n   outstanding data\".\n   A connection is considered closed\
    \ once both hosts' DATA_FINs have\n   been acknowledged by DATA_ACKs.\n   As specified\
    \ above, a standard TCP FIN on an individual subflow only\n   shuts down the subflow\
    \ on which it was sent.  If all subflows have\n   been closed with a FIN exchange\
    \ but no DATA_FIN has been received and\n   acknowledged, the MPTCP connection\
    \ is treated as closed only after a\n   timeout.  This implies that an implementation\
    \ will have TIME_WAIT\n   states at both the subflow level and the connection\
    \ level (see\n   Appendix D).  This permits \"break-before-make\" scenarios where\n\
    \   connectivity is lost on all subflows before a new one can be\n   re-established.\n"
- title: 3.3.4.  Receiver Considerations
  contents:
  - "3.3.4.  Receiver Considerations\n   Regular TCP advertises a receive window in\
    \ each packet, telling the\n   sender how much data the receiver is willing to\
    \ accept past the\n   cumulative ACK.  The receive window is used to implement\
    \ flow\n   control, throttling down fast senders when receivers cannot keep up.\n\
    \   MPTCP also uses a unique receive window, shared between the subflows.\n  \
    \ The idea is to allow any subflow to send data as long as the receiver\n   is\
    \ willing to accept it.  The alternative -- maintaining per-subflow\n   receive\
    \ windows -- could end up stalling some subflows while others\n   would not use\
    \ up their window.\n   The receive window is relative to the DATA_ACK.  As in\
    \ TCP, a\n   receiver MUST NOT shrink the right edge of the receive window (i.e.,\n\
    \   DATA_ACK + receive window).  The receiver will use the data sequence\n   number\
    \ to tell if a packet should be accepted at the connection\n   level.\n   When\
    \ deciding to accept packets at the subflow level, regular TCP\n   checks the\
    \ sequence number in the packet against the allowed receive\n   window.  With\
    \ MPTCP, such a check is done using only the connection-\n   level window.  A\
    \ sanity check SHOULD be performed at the subflow\n   level to ensure that the\
    \ subflow and mapped sequence numbers meet the\n   following test: SSN - SUBFLOW_ACK\
    \ <= DSN - DATA_ACK, where SSN is the\n   subflow sequence number of the received\
    \ packet and SUBFLOW_ACK is the\n   RCV.NXT (next expected sequence number) of\
    \ the subflow (with the\n   equivalent connection-level definitions for DSN and\
    \ DATA_ACK).\n   In regular TCP, once a segment is deemed in-window, it is put\
    \ in\n   either the in-order receive queue or the out-of-order queue.  In\n  \
    \ Multipath TCP, the same thing happens, but at the connection level: a\n   segment\
    \ is placed in the connection-level in-order or out-of-order\n   queue if it is\
    \ in-window at both the connection level and the subflow\n   level.  The stack\
    \ still has to remember, for each subflow, which\n   segments were received successfully\
    \ so that it can ACK them at the\n   subflow level appropriately.  Typically,\
    \ this will be implemented by\n   keeping per-subflow out-of-order queues (containing\
    \ only message\n   headers -- not the payloads) and remembering the value of the\n\
    \   cumulative ACK.\n   It is important for implementers to understand how large\
    \ a receive\n   buffer is appropriate.  The lower bound for full network utilization\n\
    \   is the maximum bandwidth-delay product of any one of the paths.\n   However,\
    \ this might be insufficient when a packet is lost on a slower\n   subflow and\
    \ needs to be retransmitted (see Section 3.3.6).  A tight\n   upper bound would\
    \ be the maximum round-trip time (RTT) of any path\n   multiplied by the total\
    \ bandwidth available across all paths.  This\n   permits all subflows to continue\
    \ at full speed while a packet is\n   fast-retransmitted on the maximum RTT path.\
    \  Even this might be\n   insufficient to maintain full performance in the event\
    \ of a\n   retransmit timeout on the maximum RTT path.  Determining the\n   relationship\
    \ between retransmission strategies and receive buffer\n   sizing is left for\
    \ future study.\n"
- title: 3.3.5.  Sender Considerations
  contents:
  - "3.3.5.  Sender Considerations\n   The sender remembers receive window advertisements\
    \ from the receiver.\n   It should only update its local receive window values\
    \ when the\n   largest sequence number allowed (i.e., DATA_ACK + receive window)\n\
    \   increases on the receipt of a DATA_ACK.  This is important for\n   allowing\
    \ the use of paths with different RTTs and thus different\n   feedback loops.\n\
    \   MPTCP uses a single receive window across all subflows, and if the\n   receive\
    \ window was guaranteed to be unchanged end to end, a host\n   could always read\
    \ the most recent receive window value.  However,\n   some classes of middleboxes\
    \ may alter the TCP-level receive window.\n   Typically, these will shrink the\
    \ offered window, although for short\n   periods of time it may be possible for\
    \ the window to be larger\n   (however, note that this would not continue for\
    \ long periods, since\n   ultimately the middlebox must keep up with delivering\
    \ data to the\n   receiver).  Therefore, if receive window sizes differ on multiple\n\
    \   subflows, when sending data MPTCP SHOULD take the largest of the most\n  \
    \ recent window sizes as the one to use in calculations.  This rule is\n   implicit\
    \ in the requirement not to reduce the right edge of the\n   window.\n   The sender\
    \ MUST also remember the receive windows advertised by each\n   subflow.  The\
    \ allowed window for subflow i is (ack_i, ack_i +\n   rcv_wnd_i), where ack_i\
    \ is the subflow-level cumulative ACK of\n   subflow i.  This ensures that data\
    \ will not be sent to a middlebox\n   unless there is enough buffering for the\
    \ data.\n   Putting the two rules together, we get the following: a sender is\n\
    \   allowed to send data segments with data-level sequence numbers\n   between\
    \ (DATA_ACK, DATA_ACK + receive_window).  Each of these\n   segments will be mapped\
    \ onto subflows, as long as subflow sequence\n   numbers are in the allowed windows\
    \ for those subflows.  Note that\n   subflow sequence numbers do not generally\
    \ affect flow control if the\n   same receive window is advertised across all\
    \ subflows.  They will\n   perform flow control for those subflows with a smaller\
    \ advertised\n   receive window.\n   The send buffer MUST, at a minimum, be as\
    \ big as the receive buffer,\n   to enable the sender to reach maximum throughput.\n"
- title: 3.3.6.  Reliability and Retransmissions
  contents:
  - "3.3.6.  Reliability and Retransmissions\n   The Data Sequence Mapping allows\
    \ senders to resend data with the same\n   data sequence number on a different\
    \ subflow.  When doing this, a host\n   MUST still retransmit the original data\
    \ on the original subflow, in\n   order to preserve the subflow's integrity (middleboxes\
    \ could replay\n   old data and/or could reject holes in subflows), and a receiver\
    \ will\n   ignore these retransmissions.  While this is clearly suboptimal, for\n\
    \   compatibility reasons this is sensible behavior.  Optimizations could\n  \
    \ be negotiated in future versions of this protocol.  Note also that\n   this\
    \ property would also permit a sender to always send the same\n   data, with the\
    \ same data sequence number, on multiple subflows, if\n   desired for reliability\
    \ reasons.\n   This protocol specification does not mandate any mechanisms for\n\
    \   handling retransmissions, and much will be dependent upon local\n   policy\
    \ (as discussed in Section 3.3.8).  One can imagine aggressive\n   connection-level\
    \ retransmission policies where every packet lost at\n   the subflow level is\
    \ retransmitted on a different subflow (hence\n   wasting bandwidth but possibly\
    \ reducing application-to-application\n   delays) or conservative retransmission\
    \ policies where connection-\n   level retransmissions are only used after a few\
    \ subflow-level\n   retransmission timeouts occur.\n   It is envisaged that a\
    \ standard connection-level retransmission\n   mechanism would be implemented\
    \ around a connection-level data queue:\n   all segments that haven't been DATA_ACKed\
    \ are stored.  A timer is set\n   when the head of the connection level is ACKed\
    \ at the subflow level\n   but is not DATA_ACKed at the data level.  This timer\
    \ will guard\n   against retransmission failures by middleboxes that proactively\
    \ ACK\n   data.\n   The sender MUST keep data in its send buffer as long as the\
    \ data has\n   not been acknowledged both (1) at the connection level and (2)\
    \ on all\n   subflows on which it has been sent.  In this way, the sender can\n\
    \   always retransmit the data if needed, on the same subflow or on a\n   different\
    \ one.  A special case is when a subflow fails: the sender\n   will typically\
    \ resend the data on other working subflows after a\n   timeout and will keep\
    \ trying to retransmit the data on the failed\n   subflow too.  The sender will\
    \ declare the subflow failed after a\n   predefined upper bound on retransmissions\
    \ is reached (which MAY be\n   lower than the usual TCP limits of the MSL) or\
    \ on the receipt of an\n   ICMP error, and only then delete the outstanding data\
    \ segments.\n   If multiple retransmissions that indicate that a subflow is\n\
    \   performing badly are triggered, this MAY lead to a host resetting the\n  \
    \ subflow with a RST.  However, additional research is required to\n   understand\
    \ the heuristics of how and when to reset underperforming\n   subflows.  For example,\
    \ a highly asymmetric path may be misdiagnosed\n   as underperforming.  A RST\
    \ for this purpose SHOULD be accompanied by\n   an \"Unacceptable performance\"\
    \ MP_TCPRST option (Section 3.6).\n"
- title: 3.3.7.  Congestion Control Considerations
  contents:
  - "3.3.7.  Congestion Control Considerations\n   Different subflows in an MPTCP\
    \ connection have different congestion\n   windows.  To achieve fairness at bottlenecks\
    \ and resource pooling, it\n   is necessary to couple the congestion windows in\
    \ use on each subflow,\n   in order to push most traffic to uncongested links.\
    \  One algorithm\n   for achieving this is presented in [RFC6356]; the algorithm\
    \ does not\n   achieve perfect resource pooling but is \"safe\" in that it is\
    \ readily\n   deployable in the current Internet.  By this we mean that it does\
    \ not\n   take up more capacity on any one path than if it was a single path\n\
    \   flow using only that route, so this ensures fair coexistence with\n   single-path\
    \ TCP at shared bottlenecks.\n   It is foreseeable that different congestion controllers\
    \ will be\n   implemented for MPTCP, each aiming to achieve different properties\
    \ in\n   the resource pooling / fairness / stability design space, as well as\n\
    \   those for achieving different properties in quality of service,\n   reliability,\
    \ and resilience.\n   Regardless of the algorithm used, the design of MPTCP aims\
    \ to provide\n   the congestion control implementations with sufficient information\
    \ to\n   make the right decisions; this information includes, for each\n   subflow,\
    \ which packets were lost and when.\n"
- title: 3.3.8.  Subflow Policy
  contents:
  - "3.3.8.  Subflow Policy\n   Within a local MPTCP implementation, a host may use\
    \ any local policy\n   it wishes to decide how to share the traffic to be sent\
    \ over the\n   available paths.\n   In the typical use case, where the goal is\
    \ to maximize throughput,\n   all available paths will be used simultaneously\
    \ for data transfer,\n   using coupled congestion control as described in [RFC6356].\
    \  It is\n   expected, however, that other use cases will appear.\n   For instance,\
    \ one possibility is an \"all-or-nothing\" approach, i.e.,\n   have a second path\
    \ ready for use in the event of failure of the first\n   path, but alternatives\
    \ could include entirely saturating one path\n   before using an additional path\
    \ (the \"overflow\" case).  Such choices\n   would be most likely based on the\
    \ monetary cost of links but may also\n   be based on properties such as the delay\
    \ or jitter of links, where\n   stability (of delay or bandwidth) is more important\
    \ than throughput.\n   Application requirements such as these are discussed in\
    \ detail in\n   [RFC6897].\n   The ability to make effective choices at the sender\
    \ requires full\n   knowledge of the path \"cost\", which is unlikely to be the\
    \ case.  It\n   would be desirable for a receiver to be able to signal their own\n\
    \   preferences for paths, since they will often be the multihomed party\n   and\
    \ may have to pay for metered incoming bandwidth.\n   To enable this behavior,\
    \ the MP_JOIN option (see Section 3.2)\n   contains the \"B\" bit, which allows\
    \ a host to indicate to its peer\n   that this path should be treated as a backup\
    \ path to use only in the\n   event of failure of other working subflows (i.e.,\
    \ a subflow where the\n   receiver has indicated that B=1 SHOULD NOT be used to\
    \ send data\n   unless there are no usable subflows where B=0).\n   In the event\
    \ that the available set of paths changes, a host may wish\n   to signal a change\
    \ in priority of subflows to the peer (e.g., a\n   subflow that was previously\
    \ set as a backup should now take priority\n   over all remaining subflows). \
    \ Therefore, the MP_PRIO option, shown\n   in Figure 11, can be used to change\
    \ the \"B\" flag of the subflow on\n   which it is sent.\n                   \
    \       1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     |     Kind      |     Length\
    \    |Subtype|(rsv)|B|\n            Figure 11: Change Subflow Priority (MP_PRIO)\
    \ Option\n   Another use of the MP_PRIO option is to set the \"B\" flag on a subflow\n\
    \   to cleanly \"retire\" its use before closing it and removing it with\n   REMOVE_ADDR\
    \ (Section 3.4.2) -- for example, to support make-before-\n   break session continuity,\
    \ where new subflows are added before the\n   previously used subflows are closed.\n\
    \   It should be noted that the backup flag is a request from a data\n   receiver\
    \ to a data sender only, and the data sender SHOULD adhere to\n   these requests.\
    \  A host cannot assume that the data sender will do\n   so, however, since local\
    \ policies -- or technical difficulties -- may\n   override MP_PRIO requests.\
    \  Note also that this signal applies to a\n   single direction, and so the sender\
    \ of this option could choose to\n   continue using the subflow to send data even\
    \ if it has signaled B=1\n   to the other host.\n"
- title: 3.4.  Address Knowledge Exchange (Path Management)
  contents:
  - "3.4.  Address Knowledge Exchange (Path Management)\n   We use the term \"path\
    \ management\" to refer to the exchange of\n   information about additional paths\
    \ between hosts, which in this\n   design is managed by multiple addresses at\
    \ hosts.  For more details\n   regarding the architectural thinking behind this\
    \ design, see the\n   MPTCP architecture document [RFC6182].\n   This design makes\
    \ use of two methods of sharing such information, and\n   both can be used on\
    \ a connection.  The first is the direct setup of\n   new subflows (described\
    \ in Section 3.2), where the initiator has an\n   additional address.  The second\
    \ method (described in the following\n   subsections) signals addresses explicitly\
    \ to the other host to allow\n   it to initiate new subflows.  The two mechanisms\
    \ are complementary:\n   the first is implicit and simple, while the second (explicit)\
    \ is more\n   complex but is more robust.  Together, these mechanisms allow\n\
    \   addresses to change in flight (and thus support operation through\n   NATs,\
    \ since the source address need not be known); they also allow\n   the signaling\
    \ of previously unknown addresses and of addresses\n   belonging to other address\
    \ families (e.g., both IPv4 and IPv6).\n   Here is an example of typical operation\
    \ of the protocol:\n   *  An MPTCP connection is initially set up between address/port\
    \ A1 of\n      Host A and address/port B1 of Host B.  If Host A is multihomed\
    \ and\n      multiaddressed, it can start an additional subflow from its\n   \
    \   address A2 to B1, by sending a SYN with an MP_JOIN option from A2\n      to\
    \ B1, using B's previously declared token for this connection.\n      Alternatively,\
    \ if B is multihomed, it can try to set up a new\n      subflow from B2 to A1,\
    \ using A's previously declared token.  In\n      either case, the SYN will be\
    \ sent to the port already in use for\n      the original subflow on the receiving\
    \ host.\n   *  Simultaneously (or after a timeout), an ADD_ADDR option\n     \
    \ (Section 3.4.1) is sent on an existing subflow, informing the\n      receiver\
    \ of the sender's alternative address(es).  The recipient\n      can use this\
    \ information to open a new subflow to the sender's\n      additional address(es).\
    \  In our example, A will send the ADD_ADDR\n      option informing B of address/port\
    \ A2.  The mix of using the\n      SYN-based option and the ADD_ADDR option, including\
    \ timeouts, is\n      implementation specific and can be tailored to agree with\
    \ local\n      policy.\n   *  If subflow A2-B1 is successfully set up, Host B\
    \ can use the\n      Address ID in the MP_JOIN option to correlate this source\
    \ address\n      with the ADD_ADDR option that will also arrive on an existing\n\
    \      subflow; now B knows not to open A2-B1, ignoring the ADD_ADDR.\n      Otherwise,\
    \ if B has not received the A2-B1 MP_JOIN SYN but\n      received the ADD_ADDR,\
    \ it can try to initiate a new subflow from\n      one or more of its addresses\
    \ to address A2.  This permits new\n      sessions to be opened if one host is\
    \ behind a NAT.\n   Other ways of using the two signaling mechanisms are possible;\
    \ for\n   instance, signaling addresses in other address families can only be\n\
    \   done explicitly using the Add Address (ADD_ADDR) option.\n"
- title: 3.4.1.  Address Advertisement
  contents:
  - "3.4.1.  Address Advertisement\n   The ADD_ADDR MPTCP option announces additional\
    \ addresses (and,\n   optionally, ports) on which a host can be reached (Figure\
    \ 12).  This\n   option can be used at any time during a connection, depending\
    \ on when\n   the sender wishes to enable multiple paths and/or when paths become\n\
    \   available.  As with all MPTCP signals, the receiver MUST undertake\n   standard\
    \ TCP validity checks, e.g., per [RFC5961], before acting\n   upon it.\n     \
    \                     1                   2                   3\n      0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     |     Kind   \
    \   |     Length    |Subtype|(rsv)|E|  Address ID   |\n     |           Address\
    \ (IPv4: 4 octets / IPv6: 16 octets)          |\n     |   Port (2 octets, optional)\
    \   |                               |\n     |                Truncated HMAC (8\
    \ octets, if E=0)              |\n                  Figure 12: Add Address (ADD_ADDR)\
    \ Option\n   Every address has an Address ID that can be used for uniquely\n \
    \  identifying the address within a connection for address removal.  The\n   Address\
    \ ID is also used to identify MP_JOIN options (see Section 3.2)\n   relating to\
    \ the same address, even when address translators are in\n   use.  The Address\
    \ ID MUST uniquely identify the address for the\n   sender of the option (within\
    \ the scope of the connection); the\n   mechanism for allocating such IDs is implementation\
    \ specific.\n   All Address IDs learned via either MP_JOIN or ADD_ADDR SHOULD\
    \ be\n   stored by the receiver in a data structure that gathers all the\n   Address-ID-to-address\
    \ mappings for a connection (identified by a\n   token pair).  In this way, there\
    \ is a stored mapping between the\n   Address ID, observed source address, and\
    \ token pair for future\n   processing of control information for a connection.\
    \  Note that an\n   implementation MAY discard incoming address advertisements\
    \ at will --\n   for example, to avoid updating mapping state or because advertised\n\
    \   addresses are of no use to it (for example, IPv6 addresses when it\n   has\
    \ IPv4 only).  Therefore, a host MUST treat address advertisements\n   as soft\
    \ state, and it MAY choose to refresh advertisements\n   periodically.  Note also\
    \ that an implementation MAY choose to cache\n   these address advertisements\
    \ even if they are not currently relevant\n   but may be relevant in the future,\
    \ such as IPv4 addresses when IPv6\n   connectivity is available but IPv4 is awaiting\
    \ DHCP.\n   This option is shown in Figure 12.  The illustration is sized for\n\
    \   IPv4 addresses.  For IPv6, the length of the address will be\n   16 octets\
    \ (instead of 4).\n   The 2 octets that specify the TCP port number to use are\
    \ optional,\n   and their presence can be inferred from the length of the option.\n\
    \   Although it is expected that the majority of use cases will use the\n   same\
    \ port pairs as those used for the initial subflow (e.g., port 80\n   remains\
    \ port 80 on all subflows, as does the ephemeral port at the\n   client), there\
    \ may be cases (such as port-based load balancing) where\n   the explicit specification\
    \ of a different port is required.  If no\n   port is specified, MPTCP SHOULD\
    \ attempt to connect to the specified\n   address on the same port as the port\
    \ that is already in use by the\n   subflow on which the ADD_ADDR signal was sent;\
    \ this is discussed in\n   more detail in Section 3.9.\n   The Truncated HMAC\
    \ parameter present in this option is the rightmost\n   64 bits of an HMAC, negotiated\
    \ and calculated in the same way as for\n   MP_JOIN as described in Section 3.2.\
    \  For this specification of\n   MPTCP, as there is only one hash algorithm option\
    \ specified, this\n   will be HMAC as defined in [RFC2104], using the SHA-256\
    \ hash\n   algorithm [RFC6234].  In the same way as for MP_JOIN, the key for the\n\
    \   HMAC algorithm, in the case of the message transmitted by Host A,\n   will\
    \ be Key-A followed by Key-B, and in the case of Host B, Key-B\n   followed by\
    \ Key-A.  These are the keys that were exchanged in the\n   original MP_CAPABLE\
    \ handshake.  The message for the HMAC is the\n   Address ID, IP address, and\
    \ port that precede the HMAC in the\n   ADD_ADDR option.  If the port is not present\
    \ in the ADD_ADDR option,\n   the HMAC message will nevertheless include 2 octets\
    \ of value zero.\n   The rationale for the HMAC is to prevent unauthorized entities\
    \ from\n   injecting ADD_ADDR signals in an attempt to hijack a connection.\n\
    \   Note that, additionally, the presence of this HMAC prevents the\n   address\
    \ from being changed in flight unless the key is known by an\n   intermediary.\
    \  If a host receives an ADD_ADDR option for which it\n   cannot validate the\
    \ HMAC, it SHOULD silently ignore the option.\n   A set of four flags is present\
    \ after the subtype and before the\n   Address ID.  Only the rightmost bit --\
    \ labeled \"E\" -- is assigned in\n   this specification.  The other bits are\
    \ currently unassigned; they\n   MUST be set to 0 by a sender and MUST be ignored\
    \ by the receiver.\n   The \"E\" flag exists to provide reliability for this option.\
    \  Because\n   this option will often be sent on pure ACKs, there is no guarantee\
    \ of\n   reliability.  Therefore, a receiver receiving a fresh ADD_ADDR option\n\
    \   (where E=0) will send the same option back to the sender, but not\n   including\
    \ the HMAC and with E=1, to indicate receipt.  According to\n   local policy,\
    \ the lack of this type of \"echo\" can indicate to the\n   initial ADD_ADDR sender\
    \ that the ADD_ADDR needs to be retransmitted.\n   Due to the proliferation of\
    \ NATs, it is reasonably likely that one\n   host may attempt to advertise private\
    \ addresses [RFC1918].  It is not\n   desirable to prohibit this behavior, since\
    \ there may be cases where\n   both hosts have additional interfaces on the same\
    \ private network,\n   and a host MAY advertise such addresses.  The MP_JOIN handshake\
    \ to\n   create a new subflow (Section 3.2) provides mechanisms to minimize\n\
    \   security risks.  The MP_JOIN message contains a 32-bit token that\n   uniquely\
    \ identifies the connection to the receiving host.  If the\n   token is unknown,\
    \ the host will respond with a RST.  In the unlikely\n   event that the token\
    \ is valid at the receiving host, subflow setup\n   will continue, but the HMAC\
    \ exchange must occur for authentication.\n   The HMAC exchange will fail and\
    \ will provide sufficient protection\n   against two unconnected hosts accidentally\
    \ setting up a new subflow\n   upon the signal of a private address.  Further\
    \ security\n   considerations around the issue of ADD_ADDR messages that\n   accidentally\
    \ misdirect, or maliciously direct, new MP_JOIN attempts\n   are discussed in\
    \ Section 5.\n   A host that receives an ADD_ADDR but finds that a connection\
    \ set up\n   to that IP address and port number is unsuccessful SHOULD NOT perform\n\
    \   further connection attempts to this address/port combination for this\n  \
    \ connection.  A sender that wants to trigger a new incoming connection\n   attempt\
    \ on a previously advertised address/port combination can\n   therefore refresh\
    \ ADD_ADDR information by sending the option again.\n   A host can therefore send\
    \ an ADD_ADDR message with an already-\n   assigned Address ID, but the address\
    \ MUST be the same as the address\n   previously assigned to this Address ID.\
    \  A new ADD_ADDR may have the\n   same port number or a different port number.\
    \  If the port number is\n   different, the receiving host SHOULD try to set up\
    \ a new subflow to\n   this new address/port combination.\n   A host wishing to\
    \ replace an existing Address ID MUST first remove\n   the existing one (Section\
    \ 3.4.2).\n   During normal MPTCP operation, it is unlikely that there will be\n\
    \   sufficient TCP option space for ADD_ADDR to be included along with\n   those\
    \ for data sequence numbering (Section 3.3.1).  Therefore, it is\n   expected\
    \ that an MPTCP implementation will send the ADD_ADDR option\n   on separate ACKs.\
    \  As discussed earlier, however, an MPTCP\n   implementation MUST NOT treat duplicate\
    \ ACKs with any MPTCP option,\n   with the exception of the DSS option, as indications\
    \ of congestion\n   [RFC5681], and an MPTCP implementation SHOULD NOT send more\
    \ than two\n   duplicate ACKs in a row for signaling purposes.\n"
- title: 3.4.2.  Remove Address
  contents:
  - "3.4.2.  Remove Address\n   If, during the lifetime of an MPTCP connection, a\
    \ previously\n   announced address becomes invalid (e.g., if the interface disappears\n\
    \   or an IPv6 address is no longer preferred), the affected host SHOULD\n   announce\
    \ this situation so that the peer can remove subflows related\n   to this address.\
    \  Even if an address is not in use by an MPTCP\n   connection, if it has been\
    \ previously announced, an implementation\n   SHOULD announce its removal.  A\
    \ host MAY also choose to announce that\n   a valid IP address should not be used\
    \ any longer -- for example, for\n   make-before-break session continuity.\n \
    \  This is achieved through the Remove Address (REMOVE_ADDR) option\n   (Figure\
    \ 13), which will remove a previously added address (or list of\n   addresses)\
    \ from a connection and terminate any subflows currently\n   using that address.\n\
    \                        1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   |     Kind   \
    \   |Length = 3 + n |Subtype|(resvd)|   Address ID  | ...\n                  \
    \            (followed by n-1 Address IDs, if required)\n               Figure\
    \ 13: Remove Address (REMOVE_ADDR) Option\n   For security purposes, if a host\
    \ receives a REMOVE_ADDR option, it\n   must ensure that the affected path or\
    \ paths are no longer in use\n   before it instigates closure.  The receipt of\
    \ REMOVE_ADDR SHOULD\n   first trigger the sending of a TCP keepalive [RFC1122]\
    \ on the path,\n   and if a response is received, the path SHOULD NOT be removed.\
    \  If\n   the path is found to still be alive, the receiving host SHOULD no\n\
    \   longer use the specified address for future connections, but it is\n   the\
    \ responsibility of the host that sent the REMOVE_ADDR to shut down\n   the subflow.\
    \  Before the address is removed, the requesting host MAY\n   also use MP_PRIO\
    \ (Section 3.3.8) to request that a path no longer be\n   used.  Typical TCP validity\
    \ tests on the subflow (e.g., ensuring that\n   sequence and ACK numbers are correct)\
    \ MUST also be undertaken.  An\n   implementation can use indications of these\
    \ test failures as part of\n   intrusion detection or error logging.\n   The sending\
    \ and receipt (if no keepalive response was received) of\n   this message SHOULD\
    \ trigger the sending of RSTs by both hosts on the\n   affected subflow(s) (if\
    \ possible), as a courtesy, to allow the\n   cleanup of middlebox state before\
    \ cleaning up any local state.\n   Address removal is undertaken according to\
    \ the Address ID, so as to\n   permit the use of NATs and other middleboxes that\
    \ rewrite source\n   addresses.  If an Address ID is not known, the receiver will\
    \ silently\n   ignore the request.\n   A subflow that is still functioning MUST\
    \ be closed with a FIN\n   exchange as in regular TCP, rather than using this\
    \ option.  For more\n   information, see Section 3.3.3.\n"
- title: 3.5.  Fast Close
  contents:
  - "3.5.  Fast Close\n   Regular TCP has the means of sending a RST signal to abruptly\
    \ close a\n   connection.  With MPTCP, a regular RST only has the scope of the\n\
    \   subflow; it will only close the applicable subflow and will not\n   affect\
    \ the remaining subflows.  MPTCP's connection will stay alive at\n   the data\
    \ level, in order to permit break-before-make handover between\n   subflows. \
    \ It is therefore necessary to provide an MPTCP-level\n   \"reset\" to allow the\
    \ abrupt closure of the whole MPTCP connection;\n   this is done via the MP_FASTCLOSE\
    \ option.\n   MP_FASTCLOSE is used to indicate to the peer that the connection\
    \ will\n   be abruptly closed and no data will be accepted anymore.  The reasons\n\
    \   for triggering an MP_FASTCLOSE are implementation specific.  Regular\n   TCP\
    \ does not allow the sending of a RST while the connection is in a\n   synchronized\
    \ state [RFC0793].  Nevertheless, implementations allow\n   the sending of a RST\
    \ in this state if, for example, the operating\n   system is running out of resources.\
    \  In these cases, MPTCP should\n   send the MP_FASTCLOSE.  This option is illustrated\
    \ in Figure 14.\n                          1                   2             \
    \      3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n     |     Kind      |    Length     |Subtype|      (reserved)       |\n\
    \     |                      Option Receiver's Key                    |\n    \
    \            Figure 14: Fast Close (MP_FASTCLOSE) Option\n   If Host A wants to\
    \ force the closure of an MPTCP connection, it can\n   do so via two options:\n\
    \   *  Option A (ACK): Host A sends an ACK containing the MP_FASTCLOSE\n     \
    \ option on one subflow, containing the key of Host B as declared in\n      the\
    \ initial connection handshake.  On all the other subflows,\n      Host A sends\
    \ a regular TCP RST to close these subflows and tears\n      them down.  Host\
    \ A now enters FASTCLOSE_WAIT state.\n   *  Option R (RST): Host A sends a RST\
    \ containing the MP_FASTCLOSE\n      option on all subflows, containing the key\
    \ of Host B as declared\n      in the initial connection handshake.  Host A can\
    \ tear down the\n      subflows and the connection immediately.\n   If Host A\
    \ decides to force the closure by using Option A and sending\n   an ACK with the\
    \ MP_FASTCLOSE option, the connection shall proceed as\n   follows:\n   *  Upon\
    \ receipt of an ACK with MP_FASTCLOSE by Host B, containing the\n      valid key,\
    \ Host B answers on the same subflow with a TCP RST and\n      tears down all\
    \ subflows also through sending TCP RST signals.\n      Host B can now close the\
    \ whole MPTCP connection (it transitions\n      directly to CLOSED state).\n \
    \  *  As soon as Host A has received the TCP RST on the remaining\n      subflow,\
    \ it can close this subflow and tear down the whole\n      connection (transition\
    \ from FASTCLOSE_WAIT state to CLOSED state).\n      If Host A receives an MP_FASTCLOSE\
    \ instead of a TCP RST, both\n      hosts attempted fast closure simultaneously.\
    \  Host A should reply\n      with a TCP RST and tear down the connection.\n \
    \  *  If Host A does not receive a TCP RST in reply to its MP_FASTCLOSE\n    \
    \  after one retransmission timeout (RTO) (the RTO of the subflow\n      where\
    \ the MP_FASTCLOSE has been sent), it SHOULD retransmit the\n      MP_FASTCLOSE.\
    \  To keep this connection from being retained for a\n      long time, the number\
    \ of retransmissions SHOULD be limited; this\n      limit is implementation specific.\
    \  A RECOMMENDED number is 3.  If\n      no TCP RST is received in response, Host\
    \ A SHOULD send a TCP RST\n      with the MP_FASTCLOSE option itself when it releases\
    \ state in\n      order to clear any remaining state at middleboxes.\n   If, however,\
    \ Host A decides to force the closure by using Option R\n   and sending a RST\
    \ with the MP_FASTCLOSE option, Host B will act as\n   follows: upon receipt of\
    \ a RST with MP_FASTCLOSE, containing the\n   valid key, Host B tears down all\
    \ subflows by sending a TCP RST.\n   Host B can now close the whole MPTCP connection\
    \ (it transitions\n   directly to CLOSED state).\n"
- title: 3.6.  Subflow Reset
  contents:
  - "3.6.  Subflow Reset\n   An implementation of MPTCP may also need to send a regular\
    \ TCP RST to\n   force the closure of a subflow.  A host sends a TCP RST in order\
    \ to\n   close a subflow or reject an attempt to open a subflow (MP_JOIN).  In\n\
    \   order to let the receiving host know why a subflow is being closed or\n  \
    \ rejected, the TCP RST packet MAY include the MP_TCPRST option\n   (Figure 15).\
    \  The host MAY use this information to decide, for\n   example, whether it tries\
    \ to re-establish the subflow immediately,\n   later, or never.\n            \
    \              1                   2                   3\n      0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     |     Kind      |  \
    \  Length     |Subtype|U|V|W|T|    Reason     |\n                Figure 15: TCP\
    \ RST Reason (MP_TCPRST) Option\n   The MP_TCPRST option contains a reason code\
    \ that allows the sender of\n   the option to provide more information about the\
    \ reason for the\n   termination of the subflow.  Using 12 bits of option space,\
    \ the first\n   4 bits are reserved for flags (only one of which is currently\n\
    \   defined), and the remaining octet is used to express a reason code\n   for\
    \ this subflow termination, from which a receiver MAY infer\n   information about\
    \ the usability of this path.\n   The \"T\" flag is used by the sender to indicate\
    \ whether the error\n   condition that is reported is Transient (\"T\" bit set\
    \ to 1) or\n   Permanent (\"T\" bit set to 0).  If the error condition is considered\n\
    \   to be Transient by the sender of the RST segment, the recipient of\n   this\
    \ segment MAY try to re-establish a subflow for this connection\n   over the failed\
    \ path.  The time at which a receiver may try to\n   re-establish this subflow\
    \ is implementation specific but SHOULD take\n   into account the properties of\
    \ the failure as defined by the provided\n   reason code.  If the error condition\
    \ is considered to be Permanent,\n   the receiver of the RST segment SHOULD NOT\
    \ try to re-establish a\n   subflow for this connection over this path.  The \"\
    U\", \"V\", and \"W\"\n   flags are not defined by this specification and are\
    \ reserved for\n   future use.  An implementation of this specification MUST set\
    \ these\n   flags to 0, and a receiver MUST ignore them.\n   \"Reason\" is an\
    \ 8-bit field that indicates the reason code for the\n   termination of the subflow.\
    \  The following codes are defined in this\n   document:\n   *  Unspecified error\
    \ (code 0x00).  This is the default error; it\n      implies that the subflow\
    \ is no longer available.  The presence of\n      this option shows that the RST\
    \ was generated by an MPTCP-aware\n      device.\n   *  MPTCP-specific error (code\
    \ 0x01).  An error has been detected in\n      the processing of MPTCP options.\
    \  This is the usual reason code to\n      return in the cases where a RST is\
    \ being sent to close a subflow\n      because of an invalid response.\n   * \
    \ Lack of resources (code 0x02).  This code indicates that the\n      sending\
    \ host does not have enough resources to support the\n      terminated subflow.\n\
    \   *  Administratively prohibited (code 0x03).  This code indicates that\n  \
    \    the requested subflow is prohibited by the policies of the sending\n    \
    \  host.\n   *  Too much outstanding data (code 0x04).  This code indicates that\n\
    \      there is an excessive amount of data that needs to be transmitted\n   \
    \   over the terminated subflow while having already been acknowledged\n     \
    \ over one or more other subflows.  This may occur if a path has\n      been unavailable\
    \ for a short period and it is more efficient to\n      reset and start again\
    \ than it is to retransmit the queued data.\n   *  Unacceptable performance (code\
    \ 0x05).  This code indicates that\n      the performance of this subflow was\
    \ too low compared to the other\n      subflows of this Multipath TCP connection.\n\
    \   *  Middlebox interference (code 0x06).  Middlebox interference has\n     \
    \ been detected over this subflow, making MPTCP signaling invalid.\n      For\
    \ example, this may be sent if the checksum does not validate.\n"
- title: 3.7.  Fallback
  contents:
  - "3.7.  Fallback\n   Sometimes, middleboxes will exist on a path that could prevent\
    \ the\n   operation of MPTCP.  MPTCP has been designed to cope with many\n   middlebox\
    \ modifications (see Section 6), but there are still some\n   cases where a subflow\
    \ could fail to operate within the MPTCP\n   requirements.  Notably, these cases\
    \ are the following: the loss of\n   MPTCP options on a path and the modification\
    \ of payload data.  If\n   such an event occurs, it is necessary to \"fall back\"\
    \ to the previous,\n   safe operation.  This may be either falling back to regular\
    \ TCP or\n   removing a problematic subflow.\n   At the start of an MPTCP connection\
    \ (i.e., the first subflow), it is\n   important to ensure that the path is fully\
    \ MPTCP capable and the\n   necessary MPTCP options can reach each host.  The\
    \ handshake as\n   described in Section 3.1 SHOULD fall back to regular TCP if\
    \ either of\n   the SYN messages does not have the MPTCP options: this is the\
    \ same,\n   and desired, behavior in the case where a host is not MPTCP capable\n\
    \   or the path does not support the MPTCP options.  When attempting to\n   join\
    \ an existing MPTCP connection (Section 3.2), if a path is not\n   MPTCP capable\
    \ and the MPTCP options do not get through on the SYNs,\n   the subflow will be\
    \ closed according to the MP_JOIN logic.\n   There is, however, another corner\
    \ case that should be addressed: the\n   case where MPTCP options get through\
    \ on the SYN but not on regular\n   packets.  If the subflow is the first subflow\
    \ and thus all data in\n   flight is contiguous, this situation can be resolved\
    \ by using the\n   following rules:\n   *  A sender MUST include a DSS option\
    \ with Data Sequence Mapping in\n      every segment until one of the sent segments\
    \ has been acknowledged\n      with a DSS option containing a Data ACK.  Upon\
    \ reception of the\n      acknowledgment, the sender has the confirmation that\
    \ the DSS\n      option passes in both directions and may choose to send fewer\
    \ DSS\n      options than once per segment.\n   *  If, however, an ACK is received\
    \ for data (not just for the SYN)\n      without a DSS option containing a Data\
    \ ACK, the sender determines\n      that the path is not MPTCP capable.  In the\
    \ case of this occurring\n      on an additional subflow (i.e., one started with\
    \ MP_JOIN), the\n      host MUST close the subflow with a RST, which SHOULD contain\
    \ an\n      MP_TCPRST option (Section 3.6) with a \"Middlebox interference\"\n\
    \      reason code.\n   *  In the case of such an ACK being received on the first\
    \ subflow\n      (i.e., that started with MP_CAPABLE), before any additional\n\
    \      subflows are added, the implementation MUST drop out of MPTCP mode\n  \
    \    and fall back to regular TCP.  The sender will send one final Data\n    \
    \  Sequence Mapping, with the Data-Level Length value of 0 indicating\n      an\
    \ infinite mapping (to inform the other end in case the path\n      drops options\
    \ in one direction only), and then revert to sending\n      data on the single\
    \ subflow without any MPTCP options.\n   *  If a subflow breaks during operation,\
    \ e.g., if it is rerouted and\n      MPTCP options are no longer permitted, then\
    \ once this is detected\n      (by the subflow-level receive buffer filling up,\
    \ since there is no\n      mapping available in order to DATA_ACK this data),\
    \ the subflow\n      SHOULD be treated as broken and closed with a RST, since\
    \ no data\n      can be delivered to the application layer and no fallback signal\n\
    \      can be reliably sent.  This RST SHOULD include the MP_TCPRST\n      option\
    \ (Section 3.6) with a \"Middlebox interference\" reason code.\n   These rules\
    \ should cover all cases where such a failure could happen\n   -- whether it's\
    \ on the forward or reverse path and whether the server\n   or the client first\
    \ sends data.\n   So far, this section has discussed the loss of MPTCP options,\
    \ either\n   initially or during the course of the connection.  As described in\n\
    \   Section 3.3, each portion of data for which there is a mapping is\n   protected\
    \ by a checksum, if checksums have been negotiated.  This\n   mechanism is used\
    \ to detect if middleboxes have made any adjustments\n   to the payload (added,\
    \ removed, or changed data).  A checksum will\n   fail if the data has been changed\
    \ in any way.  The use of a checksum\n   will also detect whether the length of\
    \ data on the subflow is\n   increased or decreased, and this means the Data Sequence\
    \ Mapping is\n   no longer valid.  The sender no longer knows what subflow-level\n\
    \   sequence number the receiver is genuinely operating at (the middlebox\n  \
    \ will be faking ACKs in return), and it cannot signal any further\n   mappings.\
    \  Furthermore, in addition to the possibility of payload\n   modifications that\
    \ are valid at the application layer, it is possible\n   that such modifications\
    \ could be triggered across MPTCP segment\n   boundaries, corrupting the data.\
    \  Therefore, all data from the start\n   of the segment that failed the checksum\
    \ onward is not trustworthy.\n   Note that if checksum usage has not been negotiated,\
    \ this fallback\n   mechanism cannot be used unless there is some higher-layer\
    \ or\n   lower-layer signal to inform the MPTCP implementation that the\n   payload\
    \ has been tampered with.\n   When multiple subflows are in use, the data in flight\
    \ on a subflow\n   will likely involve data that is not contiguously part of the\n\
    \   connection-level stream, since segments will be spread across the\n   multiple\
    \ subflows.  Due to the problems identified above, it is not\n   possible to determine\
    \ what adjustments have been done to the data\n   (notably, any changes to the\
    \ subflow sequence numbering).  Therefore,\n   it is not possible to recover the\
    \ subflow, and the affected subflow\n   must be immediately closed with a RST\
    \ that includes an MP_FAIL option\n   (Figure 16), which defines the data sequence\
    \ number at the start of\n   the segment (defined by the Data Sequence Mapping)\
    \ that had the\n   checksum failure.  Note that the MP_FAIL option requires the\
    \ use of\n   the full 64-bit sequence number, even if 32-bit sequence numbers\
    \ are\n   normally in use in the DSS signals on the path.\n                  \
    \        1                   2                   3\n      0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     |     Kind      |   Length=12\
    \   |Subtype|      (reserved)      |\n     |                 Data Sequence Number\
    \ (8 octets)              |\n                    Figure 16: Fallback (MP_FAIL)\
    \ Option\n   The receiver of this option MUST discard all data following the data\n\
    \   sequence number specified.  Failed data MUST NOT be DATA_ACKed and so\n  \
    \ will be retransmitted on other subflows (Section 3.3.6).\n   A special case\
    \ is when there is a single subflow and it fails with a\n   checksum error.  If\
    \ it is known that all unacknowledged data in\n   flight is contiguous (which\
    \ will usually be the case with a single\n   subflow), an infinite mapping can\
    \ be applied to the subflow without\n   the need to close it first, essentially\
    \ turning off all further MPTCP\n   signaling.  In this case, if a receiver identifies\
    \ a checksum failure\n   when there is only one path, it will send back an MP_FAIL\
    \ option on\n   the subflow-level ACK, referring to the data-level sequence number\
    \ of\n   the start of the segment on which the checksum error was detected.\n\
    \   The sender will receive this information and, if all unacknowledged\n   data\
    \ in flight is contiguous, will signal an infinite mapping.  This\n   infinite\
    \ mapping will be a DSS option (Section 3.3) on the first new\n   packet, containing\
    \ a Data Sequence Mapping that acts retroactively,\n   referring to the start\
    \ of the subflow sequence number of the most\n   recent segment that was known\
    \ to be delivered intact (i.e., was\n   successfully DATA_ACKed).  From that point\
    \ onward, data can be\n   altered by a middlebox without affecting MPTCP, as the\
    \ data stream is\n   equivalent to a regular, legacy TCP session.  While in theory\
    \ paths\n   may only be damaged in one direction -- and the MP_FAIL signal\n \
    \  affects only one direction of traffic -- for simplicity of\n   implementation,\
    \ the receiver of an MP_FAIL MUST also respond with an\n   MP_FAIL in the reverse\
    \ direction and entirely revert to a regular TCP\n   session.\n   In the rare\
    \ case that the data is not contiguous (which could happen\n   when there is only\
    \ one subflow but it is retransmitting data from a\n   subflow that has recently\
    \ been uncleanly closed), the receiver MUST\n   close the subflow with a RST with\
    \ MP_FAIL.  The receiver MUST discard\n   all data that follows the data sequence\
    \ number specified.  The sender\n   MAY attempt to create a new subflow belonging\
    \ to the same connection\n   and, if it chooses to do so, SHOULD immediately place\
    \ the single\n   subflow in single-path mode by setting an infinite Data Sequence\n\
    \   Mapping.  This mapping will begin from the data-level sequence number\n  \
    \ that was declared in the MP_FAIL.\n   After a sender signals an infinite mapping,\
    \ it MUST only use subflow\n   ACKs to clear its send buffer.  This is because\
    \ Data ACKs may become\n   misaligned with the subflow ACKs when middleboxes insert\
    \ or delete\n   data.  The receiver SHOULD stop generating Data ACKs after it\n\
    \   receives an infinite mapping.\n   When a connection has fallen back with an\
    \ infinite mapping, only one\n   subflow can send data; otherwise, the receiver\
    \ would not know how to\n   reorder the data.  In practice, this means that all\
    \ MPTCP subflows\n   will have to be terminated except one.  Once MPTCP falls\
    \ back to\n   regular TCP, it MUST NOT revert to MPTCP later in the connection.\n\
    \   It should be emphasized that MPTCP is not attempting to prevent the\n   use\
    \ of middleboxes that want to adjust the payload.  An MPTCP-aware\n   middlebox\
    \ could provide such functionality by also rewriting\n   checksums.\n"
- title: 3.8.  Error Handling
  contents:
  - "3.8.  Error Handling\n   In addition to the fallback mechanism described above,\
    \ the standard\n   classes of TCP errors may need to be handled in an MPTCP-specific\n\
    \   way.  Note that changing semantics -- such as the relevance of a RST\n   --\
    \ are covered in Section 4.  Where possible, we do not want to\n   deviate from\
    \ regular TCP behavior.\n   The following list covers possible errors and the\
    \ appropriate MPTCP\n   behavior:\n   *  Unknown token in MP_JOIN (or HMAC failure\
    \ in MP_JOIN ACK, or\n      missing MP_JOIN in SYN/ACK response): send RST (analogous\
    \ to TCP's\n      behavior on an unknown port)\n   *  DSN out of window (during\
    \ normal operation): drop the data; do not\n      send Data ACKs\n   *  Remove\
    \ request for unknown Address ID: silently ignore\n"
- title: 3.9.  Heuristics
  contents:
  - "3.9.  Heuristics\n   There are a number of heuristics that are needed for performance\
    \ or\n   deployment but that are not required for protocol correctness.  In\n\
    \   this section, we detail such heuristics.  Note that discussions of\n   buffering\
    \ and certain sender and receiver window behaviors are\n   presented in Sections\
    \ 3.3.4 and 3.3.5, and retransmission is\n   discussed in Section 3.3.6.\n"
- title: 3.9.1.  Port Usage
  contents:
  - "3.9.1.  Port Usage\n   Under typical operation, an MPTCP implementation SHOULD\
    \ use the same\n   ports as the ports that are already in use.  In other words,\
    \ the\n   destination port of a SYN containing an MP_JOIN option SHOULD be the\n\
    \   same as the remote port of the first subflow in the connection.  The\n   local\
    \ port for such SYNs SHOULD also be the same as the port for the\n   first subflow\
    \ (and as such, an implementation SHOULD reserve\n   ephemeral ports across all\
    \ local IP addresses), although there may be\n   cases where this is infeasible.\
    \  This strategy is intended to\n   maximize the probability of the SYN being\
    \ permitted by a firewall or\n   NAT at the recipient and to avoid confusing any\
    \ network-monitoring\n   software.\n   There may also be cases, however, where\
    \ a host wishes to signal that\n   a specific port should be used; this facility\
    \ is provided in the\n   ADD_ADDR option as documented in Section 3.4.1.  It is\
    \ therefore\n   feasible to allow multiple subflows between the same two addresses\n\
    \   but using different port pairs, and such a facility could be used to\n   allow\
    \ load balancing within the network based on 5-tuples (e.g., some\n   ECMP implementations\
    \ [RFC2992]).\n"
- title: 3.9.2.  Delayed Subflow Start and Subflow Symmetry
  contents:
  - "3.9.2.  Delayed Subflow Start and Subflow Symmetry\n   Many TCP connections are\
    \ short-lived and consist only of a few\n   segments, and so the overhead of using\
    \ MPTCP outweighs any benefits.\n   A heuristic is required, therefore, to decide\
    \ when to start using\n   additional subflows in an MPTCP connection.  Experimental\
    \ deployments\n   have shown that MPTCP can be applied in a range of scenarios,\
    \ so an\n   implementation will likely need to take into account such factors\
    \ as\n   the type of traffic being sent and the duration of the session; this\n\
    \   information MAY be signaled by the application layer.\n   However, for standard\
    \ TCP traffic, a suggested general-purpose\n   heuristic that an implementation\
    \ MAY choose to employ is as follows.\n   If a host has data buffered for its\
    \ peer (which implies that the\n   application has received a request for data),\
    \ the host opens one\n   subflow for each initial window's worth of data that\
    \ is buffered.\n   Consideration should also be given to limiting the rate of\
    \ adding new\n   subflows, as well as limiting the total number of subflows open\
    \ for a\n   particular connection.  A host may choose to vary these values based\n\
    \   on its load or knowledge of traffic and path characteristics.\n   Note that\
    \ this heuristic alone is probably insufficient.  Traffic for\n   many common\
    \ applications, such as downloads, is highly asymmetric,\n   and the host that\
    \ is multihomed may well be the client that will\n   never fill its buffers and\
    \ thus never use MPTCP according to this\n   heuristic.  Advanced APIs that allow\
    \ an application to signal its\n   traffic requirements would aid in these decisions.\n\
    \   An additional time-based heuristic could be applied, opening\n   additional\
    \ subflows after a given period of time has passed.  This\n   would alleviate\
    \ the above issue and also provide resilience for\n   low-bandwidth but long-lived\
    \ applications.\n   Another issue is that both communicating hosts may simultaneously\
    \ try\n   to set up a subflow between the same pair of addresses.  This leads\n\
    \   to an inefficient use of resources.\n   If the same ports are used on all\
    \ subflows, as recommended above,\n   then standard TCP simultaneous-open logic\
    \ should take care of this\n   situation and only one subflow will be established\
    \ between the\n   address pairs.  However, this relies on the same ports being\
    \ used at\n   both end hosts.  If a host does not support TCP simultaneous open,\
    \ it\n   is RECOMMENDED that some element of randomization be applied to the\n\
    \   time to wait before opening new subflows, so that only one subflow is\n  \
    \ created between a given address pair.  If, however, hosts signal\n   additional\
    \ ports to use (for example, for leveraging ECMP on-path),\n   this heuristic\
    \ is not appropriate.\n   This section has shown some of the factors that an implementer\
    \ should\n   consider when developing MPTCP heuristics, but it is not intended\
    \ to\n   be prescriptive.\n"
- title: 3.9.3.  Failure Handling
  contents:
  - "3.9.3.  Failure Handling\n   Requirements for MPTCP's handling of unexpected\
    \ signals are given in\n   Section 3.8.  There are other failure cases, however,\
    \ where hosts can\n   choose appropriate behavior.\n   For example, Section 3.1\
    \ suggests that a host SHOULD fall back to\n   trying regular TCP SYNs after one\
    \ or more failures of MPTCP SYNs for\n   a connection.  A host may keep a system-wide\
    \ cache of such\n   information, so that it can back off from using MPTCP, firstly\
    \ for\n   that particular destination host and, eventually, on a whole\n   interface,\
    \ if MPTCP connections continue to fail.  The duration of\n   such a cache would\
    \ be implementation specific.\n   Another failure could occur when the MP_JOIN\
    \ handshake fails.\n   Section 3.8 specifies that an incorrect handshake MUST\
    \ lead to the\n   subflow being closed with a RST.  A host operating an active\n\
    \   intrusion-detection system may choose to start blocking MP_JOIN\n   packets\
    \ from the source host if multiple failed MP_JOIN attempts are\n   seen.  From\
    \ the connection initiator's point of view, if an MP_JOIN\n   fails, it SHOULD\
    \ NOT attempt to connect to the same IP address and\n   port during the lifetime\
    \ of the connection, unless the other host\n   refreshes the information with\
    \ another ADD_ADDR option.  Note that\n   the ADD_ADDR option is informational\
    \ only and does not guarantee that\n   the other host will attempt a connection.\n\
    \   In addition, an implementation may learn, over a number of\n   connections,\
    \ that certain interfaces or destination addresses\n   consistently fail and may\
    \ default to not trying to use MPTCP for such\n   interfaces or addresses.  The\
    \ behavior of subflows that perform\n   particularly badly or subflows that regularly\
    \ fail during use could\n   also be learned, so that an implementation can temporarily\
    \ choose not\n   to use these paths.\n"
- title: 4.  Semantic Issues
  contents:
  - "4.  Semantic Issues\n   In order to support multipath operation, the semantics\
    \ of some TCP\n   components have changed.  To help clarify, this section lists\
    \ these\n   semantic changes as a point of reference.\n   Sequence number:  The\
    \ (in-header) TCP sequence number is specific to\n      the subflow.  To allow\
    \ the receiver to reorder application data,\n      an additional data-level sequence\
    \ space is used.  In this\n      data-level sequence space, the initial SYN and\
    \ the final DATA_FIN\n      occupy 1 octet of sequence space.  This is done to\
    \ ensure that\n      these signals are acknowledged at the connection level. \
    \ There is\n      an explicit mapping of data sequence space to subflow sequence\n\
    \      space, which is signaled through TCP options in data packets.\n   ACK:\
    \  The ACK field in the TCP header acknowledges only the subflow\n      sequence\
    \ number -- not the data-level sequence space.\n      Implementations SHOULD NOT\
    \ attempt to infer a data-level\n      acknowledgment from the subflow ACKs. \
    \ This separates subflow-\n      level and connection-level processing at an end\
    \ host.\n   Duplicate ACK:  A duplicate ACK that includes any MPTCP signaling\n\
    \      (with the exception of the DSS option) MUST NOT be treated as a\n     \
    \ signal of congestion.  To limit the chances of non-MPTCP-aware\n      entities\
    \ mistakenly interpreting duplicate ACKs as a signal of\n      congestion, MPTCP\
    \ SHOULD NOT send more than two duplicate ACKs\n      containing (non-DSS) MPTCP\
    \ signals in a row.\n   Receive Window:  The receive window in the TCP header\
    \ indicates the\n      amount of free buffer space for the whole data-level connection\n\
    \      (as opposed to the amount of space for this subflow) that is\n      available\
    \ at the receiver.  The semantics are the same as for\n      regular TCP, but\
    \ to maintain these semantics the receive window\n      must be interpreted at\
    \ the sender as relative to the sequence\n      number given in the DATA_ACK rather\
    \ than the subflow ACK in the\n      TCP header.  In this way, the original role\
    \ of flow control is\n      preserved.  Note that some middleboxes may change\
    \ the receive\n      window, and so a host SHOULD use the maximum value of those\n\
    \      recently seen on the constituent subflows for the connection-level\n  \
    \    receive window and also needs to maintain a subflow-level window\n      for\
    \ subflow-level processing.\n   FIN:  The FIN flag in the TCP header applies only\
    \ to the subflow it\n      is sent on -- not to the whole connection.  For connection-level\n\
    \      FIN semantics, the DATA_FIN option is used.\n   RST:  The RST flag in the\
    \ TCP header applies only to the subflow it\n      is sent on -- not to the whole\
    \ connection.  The MP_FASTCLOSE\n      option provides the Fast Close functionality\
    \ of a RST at the MPTCP\n      connection level.\n   Address List:  Address list\
    \ management (i.e., knowledge of the local\n      and remote hosts' lists of available\
    \ IP addresses) is handled on a\n      per-connection basis (as opposed to per\
    \ subflow, per host, or per\n      pair of communicating hosts).  This permits\
    \ the application of\n      per-connection local policy.  Adding an address to\
    \ one connection\n      (either explicitly through an ADD_ADDR message or implicitly\n\
    \      through an MP_JOIN) has no implications for other connections\n      between\
    \ the same pair of hosts.\n   5-tuple:  The 5-tuple (protocol, local address,\
    \ local port, remote\n      address, remote port) presented by kernel APIs to\
    \ the application\n      layer in a non-multipath-aware application is that of\
    \ the first\n      subflow, even if the subflow has since been closed and removed\n\
    \      from the connection.  This decision, and other related API issues,\n  \
    \    are discussed in more detail in [RFC6897].\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   As identified in [RFC6181], the addition of multipath\
    \ capability to\n   TCP will bring with it a number of new classes of threats.\
    \  In order\n   to prevent these threats, [RFC6182] presents a set of requirements\n\
    \   for a security solution for MPTCP.  The fundamental goal is for the\n   security\
    \ of MPTCP to be \"no worse\" than regular TCP today.  The key\n   security requirements\
    \ are as follows:\n   *  Provide a mechanism to confirm that the parties in a\
    \ subflow\n      handshake are the same as the parties in the original connection\n\
    \      setup.\n   *  Provide verification that the peer can receive traffic at\
    \ a new\n      address before using it as part of a connection.\n   *  Provide\
    \ replay protection, i.e., ensure that a request to\n      add/remove a subflow\
    \ is \"fresh\".\n   In order to achieve these goals, MPTCP includes a hash-based\n\
    \   handshake algorithm, as documented in Sections 3.1 and 3.2.\n   The security\
    \ of the MPTCP connection hangs on the use of keys that\n   are shared once at\
    \ the start of the first subflow and are never sent\n   again over the network\
    \ (unless used in the Fast Close mechanism\n   (Section 3.5)).  To ease demultiplexing\
    \ while not giving away any\n   cryptographic material, future subflows use a\
    \ truncated cryptographic\n   hash of this key as the connection identification\
    \ \"token\".  The keys\n   are concatenated and used as keys for creating Hash-based\
    \ Message\n   Authentication Codes (HMACs) used on subflow setup, in order to\n\
    \   verify that the parties in the handshake are the same as the parties\n   in\
    \ the original connection setup.  It also provides verification that\n   the peer\
    \ can receive traffic at this new address.  Replay attacks\n   would still be\
    \ possible when only keys are used; therefore, the\n   handshakes use single-use\
    \ random numbers (nonces) at both ends --\n   this ensures that the HMAC will\
    \ never be the same on two handshakes.\n   Guidance on generating random numbers\
    \ suitable for use as keys is\n   given in [RFC4086] and discussed in Section\
    \ 3.1.  The nonces are\n   valid for the lifetime of the TCP connection attempt.\
    \  HMAC is also\n   used to secure the ADD_ADDR option, due to the threats identified\
    \ in\n   [RFC7430].\n   The use of crypto capability bits in the initial connection\
    \ handshake\n   to negotiate the use of a particular algorithm allows the deployment\n\
    \   of additional crypto mechanisms in the future.  This negotiation\n   would\
    \ nevertheless be susceptible to a bid-down attack by an on-path\n   active attacker\
    \ who could modify the crypto capability bits in the\n   response from the receiver\
    \ to use a less secure crypto mechanism.\n   The security mechanism presented\
    \ in this document should therefore\n   protect against all forms of flooding\
    \ and hijacking attacks discussed\n   in [RFC6181].\n   The version negotiation\
    \ specified in Section 3.1, if differing MPTCP\n   versions shared a common negotiation\
    \ format, would allow an on-path\n   attacker to apply a theoretical bid-down\
    \ attack.  Since the v1 and v0\n   protocols have a different handshake, such\
    \ an attack would require\n   that the client re-establish the connection using\
    \ v0 and that the\n   server support v0.  Note that an on-path attacker would\
    \ have access\n   to the raw data, negating any other TCP-level security mechanisms.\n\
    \   As also noted in Appendix E, this document specifies the removal of\n   the\
    \ AddrID field [RFC6824] in the MP_PRIO option (Section 3.3.8).\n   This change\
    \ eliminates the possibility of a theoretical attack where\n   a subflow could\
    \ be placed in \"backup\" mode by an attacker.\n   During normal operation, regular\
    \ TCP protection mechanisms (such as\n   ensuring that sequence numbers are in-window)\
    \ will provide the same\n   level of protection against attacks on individual\
    \ TCP subflows as the\n   level of protection that exists for regular TCP today.\n\
    \   Implementations will introduce additional buffers compared to regular\n  \
    \ TCP, to reassemble data at the connection level.  The application of\n   window\
    \ sizing will minimize the risk of denial-of-service attacks\n   consuming resources.\n\
    \   As discussed in Section 3.4.1, a host may advertise its private\n   addresses,\
    \ but these might point to different hosts in the receiver's\n   network.  The\
    \ MP_JOIN handshake (Section 3.2) will ensure that this\n   does not succeed in\
    \ setting up a subflow to the incorrect host.\n   However, it could still create\
    \ unwanted TCP handshake traffic.  This\n   feature of MPTCP could be a target\
    \ for denial-of-service exploits,\n   with malicious participants in MPTCP connections\
    \ encouraging the\n   recipient to target other hosts in the network.  Therefore,\n\
    \   implementations should consider heuristics (Section 3.9) at both the\n   sender\
    \ and receiver to reduce the impact of this.\n   To further protect against malicious\
    \ ADD_ADDR messages sent by an\n   off-path attacker, the ADD_ADDR includes an\
    \ HMAC using the keys\n   negotiated during the handshake.  This effectively prevents\
    \ an\n   attacker from diverting an MPTCP connection through an off-path\n   ADD_ADDR\
    \ injection into the stream.\n   A small security risk could theoretically exist\
    \ with key reuse, but\n   in order to accomplish a replay attack, both the sender\
    \ and receiver\n   keys, and the sender and receiver random numbers, in the MP_JOIN\n\
    \   handshake (Section 3.2) would have to match.\n   While this specification\
    \ defines a \"medium\" security solution,\n   meeting the criteria specified at\
    \ the start of this section and in\n   the threat analysis document [RFC6181],\
    \ since attacks only ever get\n   worse, it is likely that a future version of\
    \ MPTCP would need to be\n   able to support stronger security.  There are several\
    \ ways the\n   security of MPTCP could potentially be improved; some of these\
    \ would\n   be compatible with MPTCP as defined in this document, while others\n\
    \   may not be.  For now, the best approach is to gain experience with\n   the\
    \ current approach, establish what might work, and check that the\n   threat analysis\
    \ is still accurate.\n   Possible ways of improving MPTCP security could include:\n\
    \   *  defining a new MPTCP cryptographic algorithm, as negotiated in\n      MP_CAPABLE.\
    \  If an implementation was being deployed in a\n      controlled environment\
    \ where additional assumptions could be made,\n      such as the ability for the\
    \ servers to store state during the TCP\n      handshake, then it may be possible\
    \ to use a stronger cryptographic\n      algorithm than would otherwise be possible.\n\
    \   *  defining how to secure data transfer with MPTCP, while not\n      changing\
    \ the signaling part of the protocol.\n   *  defining security that requires more\
    \ option space, perhaps in\n      conjunction with a \"long options\" proposal\
    \ for extending the TCP\n      option space (such as those surveyed in [TCPLO]),\
    \ or perhaps\n      building on the current approach with a second stage of security\n\
    \      based on MPTCP options.\n   *  revisiting the working group's decision\
    \ to exclusively use TCP\n      options for MPTCP signaling and instead looking\
    \ at the possibility\n      of using TCP payloads as well.\n   MPTCP has been\
    \ designed with several methods available to indicate a\n   new security mechanism,\
    \ including:\n   *  available flags in MP_CAPABLE (Figure 4).\n   *  available\
    \ subtypes in the MPTCP option (Figure 3).\n   *  the Version field in MP_CAPABLE\
    \ (Figure 4).\n"
- title: 6.  Interactions with Middleboxes
  contents:
  - "6.  Interactions with Middleboxes\n   Multipath TCP was designed to be deployable\
    \ in the present world.\n   Its design takes into account \"reasonable\" existing\
    \ middlebox\n   behavior.  In this section, we outline a few representative\n\
    \   middlebox-related failure scenarios and show how Multipath TCP\n   handles\
    \ them.  Next, we list the design decisions Multipath TCP has\n   made to accommodate\
    \ the different middleboxes.\n   A primary concern is our use of a new TCP option.\
    \  Middleboxes should\n   forward packets with unknown options unchanged, yet\
    \ there are some\n   that don't.  We expect these middleboxes to strip options\
    \ and pass\n   the data, drop packets with new options, copy the same option into\n\
    \   multiple segments (e.g., when doing segmentation), or drop options\n   during\
    \ segment coalescing.\n   MPTCP uses a single new TCP option called \"Kind\",\
    \ and all message\n   types are defined by \"subtype\" values (see Section 7).\
    \  This should\n   reduce the chances of only some types of MPTCP options being\
    \ passed;\n   instead, the key differing characteristics are different paths and\n\
    \   the presence of the SYN flag.\n   MPTCP SYN packets on the first subflow of\
    \ a connection contain the\n   MP_CAPABLE option (Section 3.1).  If this is dropped,\
    \ MPTCP SHOULD\n   fall back to regular TCP.  If packets with the MP_JOIN option\n\
    \   (Section 3.2) are dropped, the paths will simply not be used.\n   If a middlebox\
    \ strips options but otherwise passes the packets\n   unchanged, MPTCP will behave\
    \ safely.  If an MP_CAPABLE option is\n   dropped on either the outgoing path\
    \ or the return path, the\n   initiating host can fall back to regular TCP, as\
    \ illustrated in\n   Figure 17 and discussed in Section 3.1.\n               \
    \ Host A                              Host B\n                  | SYN (MP_CAPABLE)\
    \  |        SYN      |\n              a) MP_CAPABLE option stripped on outgoing\
    \ path\n                Host A                                Host B\n       \
    \           |           SYN (MP_CAPABLE)            |\n                  |   \
    \ SYN/ACK       |SYN/ACK (MP_CAPABLE)|\n              b) MP_CAPABLE option stripped\
    \ on return path\n      Figure 17: Connection Setup with Middleboxes That Strip\
    \ Options\n   Subflow SYNs contain the MP_JOIN option.  If this option is stripped\n\
    \   on the outgoing path, the SYN will appear to be a regular SYN to\n   Host\
    \ B.  Depending on whether there is a listening socket on the\n   target port,\
    \ Host B will reply with either a SYN/ACK or a RST\n   (subflow connection fails).\
    \  When Host A receives the SYN/ACK, it\n   sends a RST because the SYN/ACK does\
    \ not contain the MP_JOIN option\n   and its token.  Either way, the subflow setup\
    \ fails but otherwise\n   does not affect the MPTCP connection as a whole.\n \
    \  We now examine data flow with MPTCP, assuming that the flow is\n   correctly\
    \ set up, which implies that the options in the SYN packets\n   were allowed through\
    \ by the relevant middleboxes.  If options are\n   allowed through and there is\
    \ no resegmentation or coalescing to TCP\n   segments, Multipath TCP flows can\
    \ proceed without problems.\n   The case when options get stripped on data packets\
    \ is discussed in\n   Section 3.7.  If only some MPTCP options are stripped, behavior\
    \ is\n   not deterministic.  If some Data Sequence Mappings are lost, the\n  \
    \ connection can continue so long as mappings exist for the subflow-\n   level\
    \ data (e.g., if multiple maps have been sent that reinforce each\n   other).\
    \  If some subflow-level space is left unmapped, however, the\n   subflow is treated\
    \ as broken and is closed, using the process\n   described in Section 3.7.  MPTCP\
    \ should survive with a loss of some\n   Data ACKs, but performance will degrade\
    \ as the fraction of stripped\n   options increases.  We do not expect such cases\
    \ to appear in\n   practice, though: most middleboxes will either strip all options\
    \ or\n   let them all through.\n   We end this section with a list of middlebox\
    \ classes, their behavior,\n   and the elements in the MPTCP design that allow\
    \ operation through\n   such middleboxes.  Issues surrounding dropping packets\
    \ with options\n   or stripping options were discussed above and are not included\
    \ here:\n   *  NATs (Network Address (and port) Translators) [RFC3022] change\
    \ the\n      source address (and often the source port) of packets.  This means\n\
    \      that a host will not know its public-facing address for signaling\n   \
    \   in MPTCP.  Therefore, MPTCP permits implicit address addition via\n      the\
    \ MP_JOIN option, and the handshake mechanism ensures that\n      connection attempts\
    \ to private addresses [RFC1918], since they are\n      authenticated, will only\
    \ set up subflows to the correct hosts.\n      Explicit address removal is undertaken\
    \ by an Address ID to allow\n      no knowledge of the source address.\n   * \
    \ Performance Enhancing Proxies (PEPs) [RFC3135] might proactively\n      ACK\
    \ data to increase performance.  MPTCP, however, relies on\n      accurate congestion\
    \ control signals from the end host, and\n      non-MPTCP-aware PEPs will not\
    \ be able to provide such signals.\n      MPTCP will, therefore, fall back to\
    \ single-path TCP or close the\n      problematic subflow (see Section 3.7).\n\
    \   *  Traffic normalizers [norm] may not allow holes in sequence\n      numbers,\
    \ and they may cache packets and retransmit the same data.\n      MPTCP looks\
    \ like standard TCP on the wire and will not retransmit\n      different data\
    \ on the same subflow sequence number.  In the event\n      of a retransmission,\
    \ the same data will be retransmitted on the\n      original TCP subflow even\
    \ if it is additionally retransmitted at\n      the connection level on a different\
    \ subflow.\n   *  Firewalls [RFC2979] might perform Initial Sequence Number (ISN)\n\
    \      randomization on TCP connections.  MPTCP uses relative sequence\n     \
    \ numbers in Data Sequence Mappings to cope with this.  Like NATs,\n      firewalls\
    \ will not permit many incoming connections, so MPTCP\n      supports address\
    \ signaling (ADD_ADDR) so that a multiaddressed\n      host can invite its peer\
    \ behind the firewall/NAT to connect out to\n      its additional interface.\n\
    \   *  Intrusion Detection Systems / Intrusion Prevention Systems\n      (IDSs/IPSs)\
    \ observe packet streams for patterns and content that\n      could threaten a\
    \ network.  MPTCP may require the instrumentation\n      of additional paths,\
    \ and an MPTCP-aware IDS or IPS would need to\n      read MPTCP tokens to correlate\
    \ data from multiple subflows to\n      maintain comparable visibility into all\
    \ of the traffic between\n      devices.  Without such changes, an IDS would get\
    \ an incomplete\n      view of the traffic, increasing the risk of missing traffic\
    \ of\n      interest (false negatives) and increasing the chances of\n      erroneously\
    \ identifying a subflow as a risk due to only seeing\n      partial data (false\
    \ positives).\n   *  Application-level middleboxes such as content-aware firewalls\
    \ may\n      alter the payload within a subflow -- for example, rewriting URIs\n\
    \      in HTTP traffic.  MPTCP will detect such changes using the\n      checksum\
    \ and close the affected subflow(s), if there are other\n      subflows that can\
    \ be used.  If all subflows are affected, MPTCP\n      will fall back to TCP,\
    \ allowing such middleboxes to change the\n      payload.  MPTCP-aware middleboxes\
    \ should be able to adjust the\n      payload and MPTCP metadata in order not\
    \ to break the connection.\n   In addition, all classes of middleboxes may affect\
    \ TCP traffic in the\n   following ways:\n   *  TCP options may be removed, or\
    \ packets with unknown options\n      dropped, by many classes of middleboxes.\
    \  It is intended that the\n      initial SYN exchange, with a TCP option, will\
    \ be sufficient to\n      identify the path's capabilities.  If such a packet\
    \ does not get\n      through, MPTCP will end up falling back to regular TCP.\n\
    \   *  Segmentation/coalescing (e.g., TCP segmentation offloading) might\n   \
    \   copy options between packets and might strip some options.\n      MPTCP's\
    \ Data Sequence Mapping includes the relative subflow\n      sequence number instead\
    \ of using the sequence number in the\n      segment.  In this way, the mapping\
    \ is independent of the packets\n      that carry it.\n   *  The receive window\
    \ may be shrunk by some middleboxes at the\n      subflow level.  MPTCP will use\
    \ the maximum window at the data\n      level but will also obey subflow-specific\
    \ windows.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   This document obsoletes [RFC6824].  As such, IANA\
    \ has updated several\n   registries to point to this document.  In addition,\
    \ this document\n   creates one new registry.  These topics are described in the\n\
    \   following subsections.\n"
- title: 7.1.  TCP Option Kind Numbers
  contents:
  - "7.1.  TCP Option Kind Numbers\n   IANA has updated the \"TCP Option Kind Numbers\"\
    \ registry to point to\n   this document for Multipath TCP, as shown in Table\
    \ 1:\n           | Kind | Length |        Meaning        | Reference |\n     \
    \      |  30  |   N    | Multipath TCP (MPTCP) |  RFC 8684 |\n               \
    \       Table 1: TCP Option Kind Numbers\n"
- title: 7.2.  MPTCP Option Subtypes
  contents:
  - "7.2.  MPTCP Option Subtypes\n   The 4-bit MPTCP subtype in the \"MPTCP Option\
    \ Subtypes\" subregistry\n   under the \"Transmission Control Protocol (TCP) Parameters\"\
    \ registry\n   was defined in [RFC6824].  Since [RFC6824] is an Experimental RFC\
    \ and\n   not a Standards Track RFC, and since no further entries have occurred\n\
    \   beyond those pointing to [RFC6824], IANA has replaced the existing\n   registry\
    \ with the contents of Table 2 and with the following\n   explanatory note.\n\
    \   Note: This registry specifies the MPTCP Option Subtypes for MPTCP v1,\n  \
    \ which obsoletes the Experimental MPTCP v0.  For the MPTCP v0\n   subtypes, please\
    \ refer to [RFC6824].\n     | Value |      Symbol     |         Name         |\
    \  Reference  |\n     |  0x0  |    MP_CAPABLE   |  Multipath Capable   |  RFC\
    \ 8684,  |\n     |  0x1  |     MP_JOIN     |   Join Connection    |  RFC 8684,\
    \  |\n     |  0x2  |       DSS       | Data Sequence Signal |  RFC 8684,  |\n\
    \     |  0x3  |     ADD_ADDR    |     Add Address      |  RFC 8684,  |\n     |\
    \  0x4  |   REMOVE_ADDR   |    Remove Address    |  RFC 8684,  |\n     |  0x5\
    \  |     MP_PRIO     |    Change Subflow    |  RFC 8684,  |\n     |  0x6  |  \
    \   MP_FAIL     |       Fallback       |  RFC 8684,  |\n     |  0x7  |   MP_FASTCLOSE\
    \  |      Fast Close      |  RFC 8684,  |\n     |  0x8  |    MP_TCPRST    |  \
    \  Subflow Reset     |  RFC 8684,  |\n     |  0xf  | MP_EXPERIMENTAL | Reserved\
    \ for Private |             |\n                      Table 2: MPTCP Option Subtypes\n\
    \   Values 0x9 through 0xe are currently unassigned.  Option 0xf is\n   reserved\
    \ for use by private experiments.  Its use may be formalized\n   in a future specification.\
    \  Future assignments in this registry are\n   to be defined by Standards Action\
    \ as defined by [RFC8126].\n   Assignments consist of the MPTCP subtype's symbolic\
    \ name, its\n   associated value, and a reference to its specification.\n"
- title: 7.3.  MPTCP Handshake Algorithms
  contents:
  - "7.3.  MPTCP Handshake Algorithms\n   The \"MPTCP Handshake Algorithms\" subregistry\
    \ under the \"Transmission\n   Control Protocol (TCP) Parameters\" registry was\
    \ defined in [RFC6824].\n   Since [RFC6824] is an Experimental RFC and not a Standards\
    \ Track RFC,\n   and since no further entries have occurred beyond those pointing\
    \ to\n   [RFC6824], IANA has replaced the existing registry with the contents\n\
    \   of Table 3 and with the following explanatory note.\n   Note: This registry\
    \ specifies the MPTCP Handshake Algorithms for\n   MPTCP v1, which obsoletes the\
    \ Experimental MPTCP v0.  For the MPTCP\n   v0 subtypes, please refer to [RFC6824].\n\
    \       | Flag Bit |             Meaning             |  Reference  |\n       |\
    \    A     |        Checksum required        |  RFC 8684,  |\n       |    B  \
    \   |          Extensibility          |  RFC 8684,  |\n       |    C     | Do\
    \ not attempt to establish new |  RFC 8684,  |\n       |          | subflows to\
    \ the source address. | Section 3.1 |\n       |   D-G    |            Unassigned\
    \           |             |\n       |    H     |           HMAC-SHA256       \
    \    |  RFC 8684,  |\n                   Table 3: MPTCP Handshake Algorithms\n\
    \   Note that the meanings of bits \"D\" through \"H\" can be dependent upon\n\
    \   bit \"B\", depending on how the Extensibility parameter is defined in\n  \
    \ future specifications; see Section 3.1 for more information.\n   Future assignments\
    \ in this registry are also to be defined by\n   Standards Action as defined by\
    \ [RFC8126].  Assignments consist of the\n   value of the flags, a symbolic name\
    \ for the algorithm, and a\n   reference to its specification.\n"
- title: 7.4.  MP_TCPRST Reason Codes
  contents:
  - "7.4.  MP_TCPRST Reason Codes\n   IANA has created a further subregistry, \"MPTCP\
    \ MP_TCPRST Reason\n   Codes\" under the \"Transmission Control Protocol (TCP)\
    \ Parameters\"\n   registry, based on the reason code in the MP_TCPRST (Section\
    \ 3.6)\n   message.  Initial values for this registry are given in Table 4;\n\
    \   future assignments are to be defined by Specification Required as\n   defined\
    \ by [RFC8126].  Assignments consist of the value of the code,\n   a short description\
    \ of its meaning, and a reference to its\n   specification.  The maximum value\
    \ is 0xff.\n      | Code |           Meaning           |       Reference     \
    \  |\n      | 0x00 |      Unspecified error      | RFC 8684, Section 3.6 |\n \
    \     | 0x01 |     MPTCP-specific error    | RFC 8684, Section 3.6 |\n      |\
    \ 0x02 |      Lack of resources      | RFC 8684, Section 3.6 |\n      | 0x03 |\
    \ Administratively prohibited | RFC 8684, Section 3.6 |\n      | 0x04 |  Too much\
    \ outstanding data  | RFC 8684, Section 3.6 |\n      | 0x05 |   Unacceptable performance\
    \  | RFC 8684, Section 3.6 |\n      | 0x06 |    Middlebox interference   | RFC\
    \ 8684, Section 3.6 |\n                  Table 4: MPTCP MP_TCPRST Reason Codes\n\
    \   As guidance to the designated expert [RFC8126], assignments should\n   not\
    \ normally be refused unless codepoint space is becoming scarce,\n   provided\
    \ that there is a clear distinction from other, already-\n   existing codes and\
    \ also provided that there is sufficient guidance\n   for implementers both sending\
    \ and receiving these codes.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC0793]  Postel, J., \"Transmission Control\
    \ Protocol\", STD 7,\n              RFC 793, DOI 10.17487/RFC0793, September 1981,\n\
    \              <https://www.rfc-editor.org/info/rfc793>.\n   [RFC2104]  Krawczyk,\
    \ H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n              Hashing for Message\
    \ Authentication\", RFC 2104,\n              DOI 10.17487/RFC2104, February 1997,\n\
    \              <https://www.rfc-editor.org/info/rfc2104>.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n       \
    \       <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC5961]  Ramaiah, A.,\
    \ Stewart, R., and M. Dalal, \"Improving TCP's\n              Robustness to Blind\
    \ In-Window Attacks\", RFC 5961,\n              DOI 10.17487/RFC5961, August 2010,\n\
    \              <https://www.rfc-editor.org/info/rfc5961>.\n   [RFC6234]  Eastlake\
    \ 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n              (SHA and SHA-based\
    \ HMAC and HKDF)\", RFC 6234,\n              DOI 10.17487/RFC6234, May 2011,\n\
    \              <https://www.rfc-editor.org/info/rfc6234>.\n   [RFC8174]  Leiba,\
    \ B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words\"\
    , BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [deployments]\n              Bonaventure, O.\
    \ and S. Seo, \"Multipath TCP Deployments\",\n              IETF Journal 2016,\
    \ November 2016,\n              <https://www.ietfjournal.org/multipath-tcp-deployments/>.\n\
    \   [howhard]  Raiciu, C., Paasch, C., Barre, S., Ford, A., Honda, M.,\n     \
    \         Duchene, F., Bonaventure, O., and M. Handley, \"How Hard\n         \
    \     Can It Be? Designing and Implementing a Deployable\n              Multipath\
    \ TCP\", Usenix Symposium on Networked Systems\n              Design and Implementation\
    \ 2012, April 2012,\n              <https://www.usenix.org/conference/nsdi12/technical-\n\
    \              sessions/presentation/raiciu>.\n   [norm]     Handley, M., Paxson,\
    \ V., and C. Kreibich, \"Network\n              Intrusion Detection: Evasion,\
    \ Traffic Normalization, and\n              End-to-End Protocol Semantics\", Usenix\
    \ Security\n              Symposium 2001, August 2001,\n              <https://www.usenix.org/legacy/events/sec01/full_papers/\n\
    \              handley/handley.pdf>.\n   [RFC1122]  Braden, R., Ed., \"Requirements\
    \ for Internet Hosts -\n              Communication Layers\", STD 3, RFC 1122,\n\
    \              DOI 10.17487/RFC1122, October 1989,\n              <https://www.rfc-editor.org/info/rfc1122>.\n\
    \   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G.\n    \
    \          J., and E. Lear, \"Address Allocation for Private\n              Internets\"\
    , BCP 5, RFC 1918, DOI 10.17487/RFC1918,\n              February 1996, <https://www.rfc-editor.org/info/rfc1918>.\n\
    \   [RFC2018]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP\n   \
    \           Selective Acknowledgment Options\", RFC 2018,\n              DOI 10.17487/RFC2018,\
    \ October 1996,\n              <https://www.rfc-editor.org/info/rfc2018>.\n  \
    \ [RFC2979]  Freed, N., \"Behavior of and Requirements for Internet\n        \
    \      Firewalls\", RFC 2979, DOI 10.17487/RFC2979, October 2000,\n          \
    \    <https://www.rfc-editor.org/info/rfc2979>.\n   [RFC2992]  Hopps, C., \"Analysis\
    \ of an Equal-Cost Multi-Path\n              Algorithm\", RFC 2992, DOI 10.17487/RFC2992,\
    \ November 2000,\n              <https://www.rfc-editor.org/info/rfc2992>.\n \
    \  [RFC3022]  Srisuresh, P. and K. Egevang, \"Traditional IP Network\n       \
    \       Address Translator (Traditional NAT)\", RFC 3022,\n              DOI 10.17487/RFC3022,\
    \ January 2001,\n              <https://www.rfc-editor.org/info/rfc3022>.\n  \
    \ [RFC3135]  Border, J., Kojo, M., Griner, J., Montenegro, G., and Z.\n      \
    \        Shelby, \"Performance Enhancing Proxies Intended to\n              Mitigate\
    \ Link-Related Degradations\", RFC 3135,\n              DOI 10.17487/RFC3135,\
    \ June 2001,\n              <https://www.rfc-editor.org/info/rfc3135>.\n   [RFC4086]\
    \  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n              \"Randomness\
    \ Requirements for Security\", BCP 106, RFC 4086,\n              DOI 10.17487/RFC4086,\
    \ June 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n   [RFC4987]\
    \  Eddy, W., \"TCP SYN Flooding Attacks and Common\n              Mitigations\"\
    , RFC 4987, DOI 10.17487/RFC4987, August 2007,\n              <https://www.rfc-editor.org/info/rfc4987>.\n\
    \   [RFC5681]  Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion\n    \
    \          Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009,\n      \
    \        <https://www.rfc-editor.org/info/rfc5681>.\n   [RFC6181]  Bagnulo, M.,\
    \ \"Threat Analysis for TCP Extensions for\n              Multipath Operation\
    \ with Multiple Addresses\", RFC 6181,\n              DOI 10.17487/RFC6181, March\
    \ 2011,\n              <https://www.rfc-editor.org/info/rfc6181>.\n   [RFC6182]\
    \  Ford, A., Raiciu, C., Handley, M., Barre, S., and J.\n              Iyengar,\
    \ \"Architectural Guidelines for Multipath TCP\n              Development\", RFC\
    \ 6182, DOI 10.17487/RFC6182, March 2011,\n              <https://www.rfc-editor.org/info/rfc6182>.\n\
    \   [RFC6356]  Raiciu, C., Handley, M., and D. Wischik, \"Coupled\n          \
    \    Congestion Control for Multipath Transport Protocols\",\n              RFC\
    \ 6356, DOI 10.17487/RFC6356, October 2011,\n              <https://www.rfc-editor.org/info/rfc6356>.\n\
    \   [RFC6528]  Gont, F. and S. Bellovin, \"Defending against Sequence\n      \
    \        Number Attacks\", RFC 6528, DOI 10.17487/RFC6528, February\n        \
    \      2012, <https://www.rfc-editor.org/info/rfc6528>.\n   [RFC6824]  Ford, A.,\
    \ Raiciu, C., Handley, M., and O. Bonaventure,\n              \"TCP Extensions\
    \ for Multipath Operation with Multiple\n              Addresses\", RFC 6824,\
    \ DOI 10.17487/RFC6824, January 2013,\n              <https://www.rfc-editor.org/info/rfc6824>.\n\
    \   [RFC6897]  Scharf, M. and A. Ford, \"Multipath TCP (MPTCP) Application\n \
    \             Interface Considerations\", RFC 6897, DOI 10.17487/RFC6897,\n  \
    \            March 2013, <https://www.rfc-editor.org/info/rfc6897>.\n   [RFC7323]\
    \  Borman, D., Braden, B., Jacobson, V., and R.\n              Scheffenegger,\
    \ Ed., \"TCP Extensions for High Performance\",\n              RFC 7323, DOI 10.17487/RFC7323,\
    \ September 2014,\n              <https://www.rfc-editor.org/info/rfc7323>.\n\
    \   [RFC7413]  Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, \"TCP\n   \
    \           Fast Open\", RFC 7413, DOI 10.17487/RFC7413, December 2014,\n    \
    \          <https://www.rfc-editor.org/info/rfc7413>.\n   [RFC7430]  Bagnulo,\
    \ M., Paasch, C., Gont, F., Bonaventure, O., and C.\n              Raiciu, \"\
    Analysis of Residual Threats and Possible Fixes\n              for Multipath TCP\
    \ (MPTCP)\", RFC 7430,\n              DOI 10.17487/RFC7430, July 2015,\n     \
    \         <https://www.rfc-editor.org/info/rfc7430>.\n   [RFC8041]  Bonaventure,\
    \ O., Paasch, C., and G. Detal, \"Use Cases and\n              Operational Experience\
    \ with Multipath TCP\", RFC 8041,\n              DOI 10.17487/RFC8041, January\
    \ 2017,\n              <https://www.rfc-editor.org/info/rfc8041>.\n   [RFC8126]\
    \  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing\
    \ an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI\
    \ 10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n\
    \   [TCPLO]    Ramaiah, A., \"TCP option space extension\", Work in\n        \
    \      Progress, Internet-Draft, draft-ananth-tcpm-tcpoptext-00,\n           \
    \   26 March 2012, <https://tools.ietf.org/html/draft-ananth-\n              tcpm-tcpoptext-00>.\n"
- title: Appendix A.  Notes on Use of TCP Options
  contents:
  - "Appendix A.  Notes on Use of TCP Options\n   The TCP option space is limited\
    \ due to the length of the Data Offset\n   field in the TCP header (4 bits), which\
    \ defines the TCP header length\n   in 32-bit words.  With the standard TCP header\
    \ being 20 bytes, this\n   leaves a maximum of 40 bytes for options, and many\
    \ of these may\n   already be used by options such as timestamp and SACK.\n  \
    \ We performed a brief study on the commonly used TCP options in SYN,\n   data,\
    \ and pure ACK packets and found that there is enough room to fit\n   all the\
    \ options discussed in this document.\n   SYN packets typically include the following\
    \ options: Maximum Segment\n   Size (MSS) (4 bytes), window scale (3 bytes), SACK\
    \ permitted\n   (2 bytes), and timestamp (10 bytes).  The sum of these options\
    \ is\n   19 bytes.  Some operating systems appear to pad each option up to a\n\
    \   word boundary, thus using 24 bytes (a brief survey suggests that\n   Windows\
    \ XP and Mac OS X do this, whereas Linux does not).\n   Optimistically, therefore,\
    \ we have 21 bytes available, or 16 if\n   options have to be word-aligned.  In\
    \ either case, however, the SYN\n   versions of MP_CAPABLE (12 bytes) and MP_JOIN\
    \ (12 or 16 bytes) will\n   fit in this remaining space.\n   Note that due to\
    \ the use of a 64-bit data-level sequence space, it is\n   feasible that MPTCP\
    \ will not require the timestamp option for\n   protection against wrapped sequence\
    \ numbers (per the Protection\n   Against Wrapped Sequences (PAWS) mechanism,\
    \ as described in\n   [RFC7323]), since the data-level sequence space has far\
    \ less chance\n   of wrapping.  Confirmation of the validity of this optimization\
    \ is\n   left for further study.\n   TCP data packets typically carry timestamp\
    \ options in every packet,\n   taking 10 bytes (or 12, with padding).  That leaves\
    \ 30 bytes (or 28,\n   if word-aligned).  The DSS option varies in length, depending\
    \ on\n   (1) whether the Data Sequence Mapping, DATA_ACK, or both are\n   included,\
    \ (2) whether the sequence numbers in use are 4 or 8 octets,\n   and (3) whether\
    \ the checksum is present.  The maximum size of the DSS\n   option is 28 bytes,\
    \ so even that will fit in the available space.\n   But unless a connection is\
    \ both bidirectional and high-bandwidth, it\n   is unlikely that all that option\
    \ space will be required on each DSS\n   option.\n   Within the DSS option, it\
    \ is not necessary to include the Data\n   Sequence Mapping and DATA_ACK in each\
    \ packet, and in many cases it\n   may be possible to alternate their presence\
    \ (so long as the mapping\n   covers the data being sent in the subsequent packet).\
    \  It would also\n   be possible to alternate between 4-byte and 8-byte sequence\
    \ numbers\n   in each option.\n   On subflow and connection setup, an MPTCP option\
    \ is also set on the\n   third packet (an ACK).  These are 20 bytes (for MP_CAPABLE)\
    \ and\n   24 bytes (for MP_JOIN), both of which will fit in the available\n  \
    \ option space.\n   Pure ACKs in TCP typically contain only timestamps (10 bytes).\
    \  Here,\n   Multipath TCP typically needs to encode only the DATA_ACK (maximum\
    \ of\n   12 bytes).  Occasionally, ACKs will contain SACK information.\n   Depending\
    \ on the number of lost packets, SACK may utilize the entire\n   option space.\
    \  If a DATA_ACK had to be included, then it is probably\n   necessary to reduce\
    \ the number of SACK blocks to accommodate the\n   DATA_ACK.  However, the presence\
    \ of the DATA_ACK is unlikely to be\n   necessary in a case where SACK is in use,\
    \ since until at least some\n   of the SACK blocks have been retransmitted, the\
    \ cumulative data-level\n   ACK will not be moving forward (or if it does, due\
    \ to retransmissions\n   on another path, then that path can also be used to transmit\
    \ the new\n   DATA_ACK).\n   The ADD_ADDR option can be between 16 and 30 bytes,\
    \ depending on\n   (1) whether IPv4 or IPv6 is used and (2) whether or not the\
    \ port\n   number is present.  It is unlikely that such signaling would fit in\
    \ a\n   data packet (although if there is space, it is fine to include it).\n\
    \   It is recommended that duplicate ACKs not be used with any other\n   payload\
    \ or options, in order to transmit these rare signals.  Note\n   that this is\
    \ the reason for mandating that duplicate ACKs with MPTCP\n   options not be taken\
    \ as a signal of congestion.\n"
- title: Appendix B.  TCP Fast Open and MPTCP
  contents:
  - "Appendix B.  TCP Fast Open and MPTCP\n   TCP Fast Open (TFO) is an experimental\
    \ TCP extension, described in\n   [RFC7413], which has been introduced to allow\
    \ the sending of data one\n   RTT earlier than with regular TCP.  This is considered\
    \ a valuable\n   gain, as very short connections are very common, especially for\
    \ HTTP\n   request/response schemes.  It achieves this by sending the SYN\n  \
    \ segment together with the application's data and allowing the\n   listener to\
    \ reply immediately with data after the SYN/ACK.  [RFC7413]\n   secures this mechanism\
    \ by using a new TCP option that includes a\n   cookie that is negotiated in a\
    \ preceding connection.\n   When using TFO in conjunction with MPTCP, there are\
    \ two key points to\n   take into account, as detailed below.\n"
- title: B.1.  TFO Cookie Request with MPTCP
  contents:
  - "B.1.  TFO Cookie Request with MPTCP\n   When a TFO initiator first connects to\
    \ a listener, it cannot\n   immediately include data in the SYN for security reasons\
    \ [RFC7413].\n   Instead, it requests a cookie that will be used in subsequent\n\
    \   connections.  This is done with the TCP cookie request/response\n   options,\
    \ of 2 bytes and 6-18 bytes, respectively (depending on the\n   chosen cookie\
    \ length).\n   TFO and MPTCP can be combined, provided that the total length of\
    \ all\n   the options does not exceed the maximum 40 bytes possible in TCP:\n\
    \   *  In the SYN: MPTCP uses a 4-byte MP_CAPABLE option.  The sum of the\n  \
    \    MPTCP and TFO options is 6 bytes.  With typical TCP options using\n     \
    \ up to 19 bytes in the SYN (24 bytes if options are padded at a\n      word boundary),\
    \ there is enough space to combine the MP_CAPABLE\n      with the TFO cookie request.\n\
    \   *  In the SYN + ACK: MPTCP uses a 12-byte MP_CAPABLE option, but now\n   \
    \   the TFO option can be as long as 18 bytes.  Since the maximum\n      option\
    \ length may be exceeded, it is up to the listener to avoid\n      this problem\
    \ by using a shorter cookie.  As an example, if we\n      consider that 19 bytes\
    \ are used for classical TCP options, the\n      maximum possible cookie length\
    \ would be 7 bytes.  Note that, for\n      the SYN packet, the same limitation\
    \ applies to subsequent\n      connections (because the initiator then echoes\
    \ the cookie back to\n      the listener).  Finally, if the security impact of\
    \ reducing the\n      cookie size is not deemed acceptable, the listener can reduce\
    \ the\n      amount of space used by other TCP options by omitting the TCP\n \
    \     timestamps (as outlined in Appendix A).\n"
- title: B.2.  Data Sequence Mapping under TFO
  contents:
  - "B.2.  Data Sequence Mapping under TFO\n   In the TCP establishment phase, MPTCP\
    \ uses a key exchange that is\n   used to generate the Initial Data Sequence Numbers\
    \ (IDSNs).  In\n   particular, the SYN with MP_CAPABLE occupies the first octet\
    \ of data\n   sequence space.  With TFO, one way to handle the data sent together\n\
    \   with the SYN would be to consider an implicit DSS mapping that covers\n  \
    \ that SYN segment (since there is not enough space in the SYN to\n   include\
    \ a DSS option).  The problem with that approach is that if a\n   middlebox modifies\
    \ the TFO data, this will not be noticed by MPTCP\n   because of the absence of\
    \ a DSS checksum.  For example, a TCP-aware\n   (but not MPTCP-aware) middlebox\
    \ could insert bytes at the beginning\n   of the stream and adapt the TCP checksum\
    \ and sequence numbers\n   accordingly.  With an implicit mapping, this information\
    \ would give\n   to the initiator and listener a different view of the DSS mapping;\n\
    \   there would be no way to detect this inconsistency, because the DSS\n   checksum\
    \ is not present.\n   To solve this issue, the TFO data must not be considered\
    \ part of the\n   data sequence number space: the SYN with MP_CAPABLE still occupies\n\
    \   the first octet of data sequence space, but then the first non-TFO\n   data\
    \ byte occupies the second octet.  This guarantees that, if the\n   use of the\
    \ DSS checksum is negotiated, all data in the data sequence\n   number space is\
    \ checksummed.  We also note that this does not entail\n   a loss of functionality,\
    \ because TFO data is always only sent on the\n   initial subflow, before any\
    \ attempt to create additional subflows.\n"
- title: B.3.  Connection Establishment Examples
  contents:
  - "B.3.  Connection Establishment Examples\n   A few examples of possible \"TFO\
    \ + MPTCP\" establishment scenarios are\n   shown below.\n   Before an initiator\
    \ can send data together with the SYN, it must\n   request a cookie from the listener,\
    \ as shown in Figure 18.  (Note:\n   The sequence number and length are annotated\
    \ in Figure 18 as\n   Seq(Length) (e.g., \"S. 0(0)\") and used as such in the\
    \ subsequent\n   figures (e.g., \"S  0(20)\" in Figure 19).)  This is done by\
    \ simply\n   combining the TFO and MPTCP options.\n   initiator              \
    \                                      listener\n       |   S Seq=0(Length=0)\
    \ <MP_CAPABLE>, <TFO cookie request>    |\n       |   S. 0(0) ack 1 <MP_CAPABLE>,\
    \ <TFO cookie>                |\n       |   .  0(0) ack 1 <MP_CAPABLE>       \
    \                       |\n                         Figure 18: Cookie Request\n\
    \   Once this is done, the received cookie can be used for TFO, as shown\n   in\
    \ Figure 19.  In this example, the initiator first sends 20 bytes in\n   the SYN.\
    \  The listener immediately replies with 100 bytes following\n   the SYN-ACK,\
    \ to which the initiator replies with 20 more bytes.  Note\n   that the last segment\
    \ in the figure has a TCP sequence number of 21,\n   while the DSS subflow sequence\
    \ number is 1 (because the TFO data is\n   not part of the data sequence number\
    \ space, as explained in\n   Appendix B.2.\n   initiator                     \
    \                               listener\n       |    S  0(20) <MP_CAPABLE>, <TFO\
    \ cookie>                    |\n       |    S. 0(0) ack 21 <MP_CAPABLE>      \
    \                      |\n       |    .  1(100) ack 21 <DSS ack=1 seq=1 ssn=1\
    \ dlen=100>      |\n       |    .  21(0) ack 1 <MP_CAPABLE>                  \
    \          |\n       |    .  21(20) ack 101 <DSS ack=101 seq=1 ssn=1 dlen=20>\
    \    |\n                    Figure 19: The Listener Supports TFO\n   In Figure\
    \ 20, the listener does not support TFO.  The initiator\n   detects that no state\
    \ is created in the listener (as no data is\n   ACKed) and now sends the MP_CAPABLE\
    \ in the third packet, in order for\n   the listener to build its MPTCP context\
    \ at the end of the\n   establishment.  Now, the TFO data, when retransmitted,\
    \ becomes part\n   of the Data Sequence Mapping because it is effectively sent\
    \ (in fact\n   re-sent) after the establishment.\n   initiator               \
    \                                     listener\n       |    S  0(20) <MP_CAPABLE>,\
    \ <TFO cookie>                    |\n       |    S. 0(0) ack 1 <MP_CAPABLE>  \
    \                           |\n       |    .  1(0) ack 1 <MP_CAPABLE>        \
    \                     |\n       |    .  1(20) ack 1 <DSS ack=1 seq=1 ssn=1 dlen=20>\
    \         |\n       |    .  0(0) ack 21 <DSS ack=21 seq=1 ssn=1 dlen=0>      \
    \   |\n                Figure 20: The Listener Does Not Support TFO\n   It is\
    \ also possible that the listener acknowledges only part of the\n   TFO data,\
    \ as illustrated in Figure 21.  The initiator will simply\n   retransmit the missing\
    \ data together with a DSS mapping.\n   initiator                            \
    \                        listener\n       |    S  0(1000) <MP_CAPABLE>, <TFO cookie>\
    \                  |\n       |    S. 0(0) ack 501 <MP_CAPABLE>               \
    \            |\n       |    .  501(0) ack 1 <MP_CAPABLE>                     \
    \      |\n       |    .  501(500) ack 1 <DSS ack=1 seq=1 ssn=1 dlen=500>     |\n\
    \                   Figure 21: Partial Data Acknowledgment\n"
- title: Appendix C.  Control Blocks
  contents:
  - "Appendix C.  Control Blocks\n   Conceptually, an MPTCP connection can be represented\
    \ as an MPTCP\n   protocol control block (PCB) that contains several variables\
    \ that\n   track the progress and the state of the MPTCP connection and a set\
    \ of\n   linked TCP control blocks that correspond to the subflows that have\n\
    \   been established.\n   RFC 793 [RFC0793] specifies several state variables.\
    \  Whenever\n   possible, we reuse the same terminology as RFC 793 to describe\
    \ the\n   state variables that are maintained by MPTCP.\n"
- title: C.1.  MPTCP Control Block
  contents:
  - "C.1.  MPTCP Control Block\n   The MPTCP control block contains the following\
    \ variables per\n   connection.\n"
- title: C.1.1.  Authentication and Metadata
  contents:
  - "C.1.1.  Authentication and Metadata\n   Local.Token (32 bits):  This is the token\
    \ chosen by the local host on\n      this MPTCP connection.  The token must be\
    \ unique among all\n      established MPTCP connections and is generated from\
    \ the local key.\n   Local.Key (64 bits):  This is the key sent by the local host\
    \ on this\n      MPTCP connection.\n   Remote.Token (32 bits):  This is the token\
    \ chosen by the remote host\n      on this MPTCP connection, generated from the\
    \ remote key.\n   Remote.Key (64 bits):  This is the key chosen by the remote\
    \ host on\n      this MPTCP connection.\n   MPTCP.Checksum (flag):  This flag\
    \ is set to true if at least one of\n      the hosts has set the \"A\" bit in\
    \ the MP_CAPABLE options exchanged\n      during connection establishment; otherwise,\
    \ it is set to false.\n      If this flag is set, the checksum must be computed\
    \ in all DSS\n      options.\n"
- title: C.1.2.  Sending Side
  contents:
  - "C.1.2.  Sending Side\n   SND.UNA (64 bits):  This is the data sequence number\
    \ of the next byte\n      to be acknowledged, at the MPTCP connection level. \
    \ This variable\n      is updated upon reception of a DSS option containing a\
    \ DATA_ACK.\n   SND.NXT (64 bits):  This is the data sequence number of the next\
    \ byte\n      to be sent.  SND.NXT is used to determine the value of the DSN in\n\
    \      the DSS option.\n   SND.WND (32 bits):  This is the send window.  32 bits\
    \ if the features\n      in RFC 7323 are used; 16 bits otherwise.  MPTCP maintains\
    \ the send\n      window at the MPTCP connection level, and the same window is\n\
    \      shared by all subflows.  All subflows use the MPTCP connection-\n     \
    \ level SND.WND to compute the SEQ.WND value that is sent in each\n      transmitted\
    \ segment.\n"
- title: C.1.3.  Receiving Side
  contents:
  - "C.1.3.  Receiving Side\n   RCV.NXT (64 bits):  This is the data sequence number\
    \ of the next byte\n      that is expected on the MPTCP connection.  This state\
    \ variable is\n      modified upon reception of in-order data.  The value of RCV.NXT\
    \ is\n      used to specify the DATA_ACK that is sent in the DSS option on all\n\
    \      subflows.\n   RCV.WND (32 bits):  This is the connection-level receive\
    \ window,\n      which is the maximum of the RCV.WND on all the subflows.  32\
    \ bits\n      if the features in RFC 7323 are used; 16 bits otherwise.\n"
- title: C.2.  TCP Control Blocks
  contents:
  - "C.2.  TCP Control Blocks\n   The MPTCP control block also contains a list of\
    \ the TCP control\n   blocks that are associated with the MPTCP connection.\n\
    \   Note that the TCP control block on the TCP subflows does not contain\n   the\
    \ RCV.WND and SND.WND state variables, as these are maintained at\n   the MPTCP\
    \ connection level and not at the subflow level.\n   Inside each TCP control block,\
    \ the following state variables are\n   defined.\n"
- title: C.2.1.  Sending Side
  contents:
  - "C.2.1.  Sending Side\n   SND.UNA (32 bits):  This is the sequence number of the\
    \ next byte to\n      be acknowledged on the subflow.  This variable is updated\
    \ upon\n      reception of each TCP acknowledgment on the subflow.\n   SND.NXT\
    \ (32 bits):  This is the sequence number of the next byte to\n      be sent on\
    \ the subflow.  SND.NXT is used to set the value of\n      SEG.SEQ upon transmission\
    \ of the next segment.\n"
- title: C.2.2.  Receiving Side
  contents:
  - "C.2.2.  Receiving Side\n   RCV.NXT (32 bits):  This is the sequence number of\
    \ the next byte that\n      is expected on the subflow.  This state variable is\
    \ modified upon\n      reception of in-order segments.  The value of RCV.NXT is\
    \ copied to\n      the SEG.ACK field of the next segments transmitted on the subflow.\n\
    \   RCV.WND (32 bits):  This is the subflow-level receive window that is\n   \
    \   updated with the window field from the segments received on this\n      subflow.\
    \  32 bits if the features in RFC 7323 are used; 16 bits\n      otherwise.\n"
- title: Appendix D.  Finite State Machine
  contents:
  - "Appendix D.  Finite State Machine\n   The diagram in Figure 22 shows the Finite\
    \ State Machine for\n   connection-level closure.  This illustrates how the DATA_FIN\n\
    \   connection-level signal (indicated in the diagram as the DFIN flag on\n  \
    \ a DATA_ACK) (1) interacts with subflow-level FINs and (2) permits\n   break-before-make\
    \ handover between subflows.\n                       M_CLOSE    |     |    rcv\
    \ DATA_FIN\n   +---------+       snd DATA_FIN /       \\ snd DATA_ACK[DFIN] +-------+\n\
    \   |  M_FIN  |<-----------------           ------------------->|M_CLOSE|\n  \
    \ | WAIT-1  |---------------------------                      |  WAIT |\n   +---------+\
    \               rcv DATA_FIN \\                    +-------+\n     | rcv DATA_ACK[DFIN]\
    \         ------- |                   M_CLOSE |\n     | --------------       \
    \ snd DATA_ACK |                   ------- |\n     | CLOSE all subflows      \
    \           |              snd DATA_FIN |\n     V                            \
    \        V                           V\n   |M_FINWAIT-2|              | M_CLOSING\
    \ |                 |M_LAST-ACK|\n     |              rcv DATA_ACK[DFIN] |   \
    \        rcv DATA_ACK[DFIN] |\n     | rcv DATA_FIN     -------------- |      \
    \         -------------- |\n     |  -------     CLOSE all subflows |         \
    \  CLOSE all subflows |\n     | snd DATA_ACK[DFIN]              V            delete\
    \ MPTCP PCB  V\n           Figure 22: Finite State Machine for Connection Closure\n"
- title: Appendix E.  Changes from RFC 6824
  contents:
  - "Appendix E.  Changes from RFC 6824\n   This appendix lists the key technical\
    \ changes between [RFC6824],\n   which specifies MPTCP v0; and this document,\
    \ which obsoletes\n   [RFC6824] and specifies MPTCP v1.  Note that this specification\
    \ is\n   not backward compatible with [RFC6824].\n   *  This document incorporates\
    \ lessons learned from the various\n      implementations, deployments, and experiments\
    \ gathered in the\n      documents \"Use Cases and Operational Experience with\
    \ Multipath\n      TCP\" [RFC8041] and the IETF Journal article \"Multipath TCP\n\
    \      Deployments\" [deployments].\n   *  Connection initiation, through the\
    \ exchange of the MP_CAPABLE\n      MPTCP option, is different from [RFC6824].\
    \  The SYN no longer\n      includes the initiator's key, to allow the MP_CAPABLE\
    \ option on\n      the SYN to be shorter in length and to avoid duplicating the\n\
    \      sending of keying material.\n   *  This also ensures reliable delivery\
    \ of the key on the MP_CAPABLE\n      option by allowing its transmission to be\
    \ combined with data and\n      thus using TCP's built-in reliability mechanism.\
    \  If the initiator\n      does not immediately have data to send, the MP_CAPABLE\
    \ option with\n      the keys will be repeated on the first data packet.  If the\
    \ other\n      end is the first to send, then the presence of the DSS option\n\
    \      implicitly confirms the receipt of the MP_CAPABLE.\n   *  In the Flags\
    \ field of MP_CAPABLE, \"C\" is now assigned to mean that\n      the sender of\
    \ this option will not accept additional MPTCP\n      subflows to the source address\
    \ and port.  This improves efficiency\n      -- for example, in cases where the\
    \ sender is behind a strict NAT.\n   *  In the Flags field of MP_CAPABLE, \"H\"\
    \ now indicates the use of\n      HMAC-SHA256 (rather than HMAC-SHA1).\n   * \
    \ Connection initiation also defines the procedure for version\n      negotiation,\
    \ for implementations that support both v0 [RFC6824]\n      and v1 (this document).\n\
    \   *  The HMAC-SHA256 (rather than HMAC-SHA1) algorithm is used, as it\n    \
    \  provides better security.  It is used to generate the token in the\n      MP_JOIN\
    \ and ADD_ADDR messages and to set the IDSN.\n   *  A new subflow-level option\
    \ exists to signal reasons for sending a\n      RST on a subflow (MP_TCPRST (Section\
    \ 3.6)); this can help an\n      implementation decide whether to attempt later\
    \ reconnection.\n   *  The MP_PRIO option (Section 3.3.8), which is used to signal\
    \ a\n      change of priority for a subflow, no longer includes the AddrID\n \
    \     field.  Its purpose was to allow the changed priority to be\n      applied\
    \ on a subflow other than the one it was sent on.  However,\n      it was determined\
    \ that this could be used by a man-in-the-middle\n      to divert all traffic\
    \ onto its own path, and MP_PRIO does not\n      include a token or other type\
    \ of security mechanism.\n   *  The ADD_ADDR option (Section 3.4.1), which is\
    \ used to inform the\n      other host about another potential address, is different\
    \ in\n      several ways.  It now includes an HMAC of the added address, for\n\
    \      enhanced security.  In addition, reliability for the ADD_ADDR\n      option\
    \ has been added: the IPVer field is replaced with a flag\n      field, and one\
    \ flag is assigned (\"E\") that is used as an \"echo\" so\n      a host can indicate\
    \ that it has received the option.\n   *  This document describes an additional\
    \ way of performing a Fast\n      Close -- by sending an MP_FASTCLOSE option on\
    \ a RST on all\n      subflows.  This allows the host to tear down the subflows\
    \ and the\n      connection immediately.\n   *  IANA has reserved the MPTCP option\
    \ subtype of value 0xf for\n      Private Use (Section 7.2).  This document doesn't\
    \ define how to\n      use that value.\n   *  This document adds a new appendix\
    \ (Appendix B), which discusses\n      the usage of both MPTCP options and TFO\
    \ options on the same\n      packet.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors gratefully acknowledge significant input into\
    \ this\n   document from Sebastien Barre and Andrew McDonald.\n   The authors\
    \ also wish to acknowledge reviews and contributions from\n   Iljitsch van Beijnum,\
    \ Lars Eggert, Marcelo Bagnulo, Robert Hancock,\n   Pasi Sarolahti, Toby Moncaster,\
    \ Philip Eardley, Sergio Lembo,\n   Lawrence Conroy, Yoshifumi Nishida, Bob Briscoe,\
    \ Stein Gjessing,\n   Andrew McGregor, Georg Hampel, Anumita Biswas, Wes Eddy,\
    \ Alexey\n   Melnikov, Francis Dupont, Adrian Farrel, Barry Leiba, Robert Sparks,\n\
    \   Sean Turner, Stephen Farrell, Martin Stiemerling, Gregory Detal,\n   Fabien\
    \ Duchene, Xavier de Foy, Rahul Jadhav, Klemens Schragel, Mirja\n   K\xFChlewind,\
    \ Sheng Jiang, Alissa Cooper, Ines Robles, Roman Danyliw,\n   Adam Roach, Eric\
    \ Vyncke, and Ben Kaduk.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Alan Ford\n   Pexip\n   Email: alan.ford@gmail.com\n \
    \  Costin Raiciu\n   University Politehnica of Bucharest\n   Splaiul Independentei\
    \ 313\n   Bucharest\n   Romania\n   Email: costin.raiciu@cs.pub.ro\n   Mark Handley\n\
    \   University College London\n   Gower Street\n   London\n   WC1E 6BT\n   United\
    \ Kingdom\n   Email: m.handley@cs.ucl.ac.uk\n   Olivier Bonaventure\n   Universit\xE9\
    \ catholique de Louvain\n   Pl. Ste Barbe, 2\n   1348 Louvain-la-Neuve\n   Belgium\n\
    \   Email: olivier.bonaventure@uclouvain.be\n   Christoph Paasch\n   Apple, Inc.\n\
    \   Cupertino, CA\n"
