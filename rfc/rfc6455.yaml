- title: __initial_text__
  contents:
  - '                         The WebSocket Protocol

    '
- title: Abstract
  contents:
  - "Abstract\n   The WebSocket Protocol enables two-way communication between a client\n\
    \   running untrusted code in a controlled environment to a remote host\n   that\
    \ has opted-in to communications from that code.  The security\n   model used\
    \ for this is the origin-based security model commonly used\n   by web browsers.\
    \  The protocol consists of an opening handshake\n   followed by basic message\
    \ framing, layered over TCP.  The goal of\n   this technology is to provide a\
    \ mechanism for browser-based\n   applications that need two-way communication\
    \ with servers that does\n   not rely on opening multiple HTTP connections (e.g.,\
    \ using\n   XMLHttpRequest or <iframe>s and long polling).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6455.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n     1.1.  Background . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n     1.2.  Protocol Overview  . . . . . . . . . . . . . . . .\
    \ . . . .  5\n     1.3.  Opening Handshake  . . . . . . . . . . . . . . . . .\
    \ . . .  6\n     1.4.  Closing Handshake  . . . . . . . . . . . . . . . . . .\
    \ . .  9\n     1.5.  Design Philosophy  . . . . . . . . . . . . . . . . . . .\
    \ .  9\n     1.6.  Security Model . . . . . . . . . . . . . . . . . . . . . .\
    \ 10\n     1.7.  Relationship to TCP and HTTP . . . . . . . . . . . . . . . 11\n\
    \     1.8.  Establishing a Connection  . . . . . . . . . . . . . . . . 11\n  \
    \   1.9.  Subprotocols Using the WebSocket Protocol  . . . . . . . . 12\n   2.\
    \  Conformance Requirements . . . . . . . . . . . . . . . . . . . 12\n     2.1.\
    \  Terminology and Other Conventions  . . . . . . . . . . . . 13\n   3.  WebSocket\
    \ URIs . . . . . . . . . . . . . . . . . . . . . . . . 14\n   4.  Opening Handshake\
    \  . . . . . . . . . . . . . . . . . . . . . . 14\n     4.1.  Client Requirements\
    \  . . . . . . . . . . . . . . . . . . . 14\n     4.2.  Server-Side Requirements\
    \ . . . . . . . . . . . . . . . . . 20\n       4.2.1.  Reading the Client's Opening\
    \ Handshake . . . . . . . . 21\n       4.2.2.  Sending the Server's Opening Handshake\
    \ . . . . . . . . 22\n     4.3.  Collected ABNF for New Header Fields Used in\
    \ Handshake . . 25\n     4.4.  Supporting Multiple Versions of WebSocket Protocol\
    \ . . . . 26\n   5.  Data Framing . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 27\n     5.1.  Overview . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 27\n     5.2.  Base Framing Protocol  . . . . . . . . . . . . . . . . .\
    \ . 28\n     5.3.  Client-to-Server Masking . . . . . . . . . . . . . . . . .\
    \ 32\n     5.4.  Fragmentation  . . . . . . . . . . . . . . . . . . . . . . 33\n\
    \     5.5.  Control Frames . . . . . . . . . . . . . . . . . . . . . . 36\n  \
    \     5.5.1.  Close  . . . . . . . . . . . . . . . . . . . . . . . . 36\n    \
    \   5.5.2.  Ping . . . . . . . . . . . . . . . . . . . . . . . . . 37\n      \
    \ 5.5.3.  Pong . . . . . . . . . . . . . . . . . . . . . . . . . 37\n     5.6.\
    \  Data Frames  . . . . . . . . . . . . . . . . . . . . . . . 38\n     5.7.  Examples\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . 38\n     5.8.  Extensibility\
    \  . . . . . . . . . . . . . . . . . . . . . . 39\n   6.  Sending and Receiving\
    \ Data . . . . . . . . . . . . . . . . . . 39\n     6.1.  Sending Data . . . .\
    \ . . . . . . . . . . . . . . . . . . . 39\n     6.2.  Receiving Data . . . .\
    \ . . . . . . . . . . . . . . . . . . 40\n   7.  Closing the Connection . . .\
    \ . . . . . . . . . . . . . . . . . 41\n     7.1.  Definitions  . . . . . . .\
    \ . . . . . . . . . . . . . . . . 41\n       7.1.1.  Close the WebSocket Connection\
    \ . . . . . . . . . . . . 41\n       7.1.2.  Start the WebSocket Closing Handshake\
    \  . . . . . . . . 42\n       7.1.3.  The WebSocket Closing Handshake is Started\
    \ . . . . . . 42\n       7.1.4.  The WebSocket Connection is Closed . . . . .\
    \ . . . . . 42\n       7.1.5.  The WebSocket Connection Close Code  . . . . .\
    \ . . . . 42\n       7.1.6.  The WebSocket Connection Close Reason  . . . . .\
    \ . . . 43\n       7.1.7.  Fail the WebSocket Connection  . . . . . . . . . .\
    \ . . 43\n     7.2.  Abnormal Closures  . . . . . . . . . . . . . . . . . . .\
    \ . 44\n       7.2.1.  Client-Initiated Closure . . . . . . . . . . . . . . .\
    \ 44\n       7.2.2.  Server-Initiated Closure . . . . . . . . . . . . . . . 44\n\
    \       7.2.3.  Recovering from Abnormal Closure . . . . . . . . . . . 44\n  \
    \   7.3.  Normal Closure of Connections  . . . . . . . . . . . . . . 45\n    \
    \ 7.4.  Status Codes . . . . . . . . . . . . . . . . . . . . . . . 45\n      \
    \ 7.4.1.  Defined Status Codes . . . . . . . . . . . . . . . . . 45\n       7.4.2.\
    \  Reserved Status Code Ranges  . . . . . . . . . . . . . 47\n   8.  Error Handling\
    \ . . . . . . . . . . . . . . . . . . . . . . . . 48\n     8.1.  Handling Errors\
    \ in UTF-8-Encoded Data  . . . . . . . . . . 48\n   9.  Extensions . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . 48\n     9.1.  Negotiating Extensions\
    \ . . . . . . . . . . . . . . . . . . 48\n     9.2.  Known Extensions . . . .\
    \ . . . . . . . . . . . . . . . . . 50\n   10. Security Considerations  . . .\
    \ . . . . . . . . . . . . . . . . 50\n     10.1. Non-Browser Clients  . . . .\
    \ . . . . . . . . . . . . . . . 50\n     10.2. Origin Considerations  . . . .\
    \ . . . . . . . . . . . . . . 50\n     10.3. Attacks On Infrastructure (Masking)\
    \  . . . . . . . . . . . 51\n     10.4. Implementation-Specific Limits . . . .\
    \ . . . . . . . . . . 52\n     10.5. WebSocket Client Authentication  . . . .\
    \ . . . . . . . . . 53\n     10.6. Connection Confidentiality and Integrity .\
    \ . . . . . . . . 53\n     10.7. Handling of Invalid Data . . . . . . . . . .\
    \ . . . . . . . 53\n     10.8. Use of SHA-1 by the WebSocket Handshake  . . .\
    \ . . . . . . 54\n   11. IANA Considerations  . . . . . . . . . . . . . . . .\
    \ . . . . . 54\n     11.1. Registration of New URI Schemes  . . . . . . . . .\
    \ . . . . 54\n       11.1.1. Registration of \"ws\" Scheme  . . . . . . . . .\
    \ . . . . 54\n       11.1.2. Registration of \"wss\" Scheme . . . . . . . . .\
    \ . . . . 55\n     11.2. Registration of the \"WebSocket\" HTTP Upgrade Keyword\
    \ . . . 56\n     11.3. Registration of New HTTP Header Fields . . . . . . . .\
    \ . . 57\n       11.3.1. Sec-WebSocket-Key  . . . . . . . . . . . . . . . . .\
    \ . 57\n       11.3.2. Sec-WebSocket-Extensions . . . . . . . . . . . . . . .\
    \ 58\n       11.3.3. Sec-WebSocket-Accept . . . . . . . . . . . . . . . . . 58\n\
    \       11.3.4. Sec-WebSocket-Protocol . . . . . . . . . . . . . . . . 59\n  \
    \     11.3.5. Sec-WebSocket-Version  . . . . . . . . . . . . . . . . 60\n    \
    \ 11.4. WebSocket Extension Name Registry  . . . . . . . . . . . . 61\n     11.5.\
    \ WebSocket Subprotocol Name Registry  . . . . . . . . . . . 61\n     11.6. WebSocket\
    \ Version Number Registry  . . . . . . . . . . . . 62\n     11.7. WebSocket Close\
    \ Code Number Registry . . . . . . . . . . . 64\n     11.8. WebSocket Opcode Registry\
    \  . . . . . . . . . . . . . . . . 65\n     11.9. WebSocket Framing Header Bits\
    \ Registry . . . . . . . . . . 66\n   12. Using the WebSocket Protocol from Other\
    \ Specifications . . . . 66\n   13. Acknowledgements . . . . . . . . . . . . .\
    \ . . . . . . . . . . 67\n   14. References . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . 68\n     14.1. Normative References . . . . . . . . . . .\
    \ . . . . . . . . 68\n     14.2. Informative References . . . . . . . . . . .\
    \ . . . . . . . 69\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Background
  contents:
  - "1.1.  Background\n   _This section is non-normative._\n   Historically, creating\
    \ web applications that need bidirectional\n   communication between a client\
    \ and a server (e.g., instant messaging\n   and gaming applications) has required\
    \ an abuse of HTTP to poll the\n   server for updates while sending upstream notifications\
    \ as distinct\n   HTTP calls [RFC6202].\n   This results in a variety of problems:\n\
    \   o  The server is forced to use a number of different underlying TCP\n    \
    \  connections for each client: one for sending information to the\n      client\
    \ and a new one for each incoming message.\n   o  The wire protocol has a high\
    \ overhead, with each client-to-server\n      message having an HTTP header.\n\
    \   o  The client-side script is forced to maintain a mapping from the\n     \
    \ outgoing connections to the incoming connection to track replies.\n   A simpler\
    \ solution would be to use a single TCP connection for\n   traffic in both directions.\
    \  This is what the WebSocket Protocol\n   provides.  Combined with the WebSocket\
    \ API [WSAPI], it provides an\n   alternative to HTTP polling for two-way communication\
    \ from a web page\n   to a remote server.\n   The same technique can be used for\
    \ a variety of web applications:\n   games, stock tickers, multiuser applications\
    \ with simultaneous\n   editing, user interfaces exposing server-side services\
    \ in real time,\n   etc.\n   The WebSocket Protocol is designed to supersede existing\n\
    \   bidirectional communication technologies that use HTTP as a transport\n  \
    \ layer to benefit from existing infrastructure (proxies, filtering,\n   authentication).\
    \  Such technologies were implemented as trade-offs\n   between efficiency and\
    \ reliability because HTTP was not initially\n   meant to be used for bidirectional\
    \ communication (see [RFC6202] for\n   further discussion).  The WebSocket Protocol\
    \ attempts to address the\n   goals of existing bidirectional HTTP technologies\
    \ in the context of\n   the existing HTTP infrastructure; as such, it is designed\
    \ to work\n   over HTTP ports 80 and 443 as well as to support HTTP proxies and\n\
    \   intermediaries, even if this implies some complexity specific to the\n   current\
    \ environment.  However, the design does not limit WebSocket to\n   HTTP, and\
    \ future implementations could use a simpler handshake over a\n   dedicated port\
    \ without reinventing the entire protocol.  This last\n   point is important because\
    \ the traffic patterns of interactive\n   messaging do not closely match standard\
    \ HTTP traffic and can induce\n   unusual loads on some components.\n"
- title: 1.2.  Protocol Overview
  contents:
  - "1.2.  Protocol Overview\n   _This section is non-normative._\n   The protocol\
    \ has two parts: a handshake and the data transfer.\n   The handshake from the\
    \ client looks as follows:\n        GET /chat HTTP/1.1\n        Host: server.example.com\n\
    \        Upgrade: websocket\n        Connection: Upgrade\n        Sec-WebSocket-Key:\
    \ dGhlIHNhbXBsZSBub25jZQ==\n        Origin: http://example.com\n        Sec-WebSocket-Protocol:\
    \ chat, superchat\n        Sec-WebSocket-Version: 13\n   The handshake from the\
    \ server looks as follows:\n        HTTP/1.1 101 Switching Protocols\n       \
    \ Upgrade: websocket\n        Connection: Upgrade\n        Sec-WebSocket-Accept:\
    \ s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n        Sec-WebSocket-Protocol: chat\n   The leading\
    \ line from the client follows the Request-Line format.\n   The leading line from\
    \ the server follows the Status-Line format.  The\n   Request-Line and Status-Line\
    \ productions are defined in [RFC2616].\n   An unordered set of header fields\
    \ comes after the leading line in\n   both cases.  The meaning of these header\
    \ fields is specified in\n   Section 4 of this document.  Additional header fields\
    \ may also be\n   present, such as cookies [RFC6265].  The format and parsing\
    \ of\n   headers is as defined in [RFC2616].\n   Once the client and server have\
    \ both sent their handshakes, and if\n   the handshake was successful, then the\
    \ data transfer part starts.\n   This is a two-way communication channel where\
    \ each side can,\n   independently from the other, send data at will.\n   After\
    \ a successful handshake, clients and servers transfer data back\n   and forth\
    \ in conceptual units referred to in this specification as\n   \"messages\". \
    \ On the wire, a message is composed of one or more\n   frames.  The WebSocket\
    \ message does not necessarily correspond to a\n   particular network layer framing,\
    \ as a fragmented message may be\n   coalesced or split by an intermediary.\n\
    \   A frame has an associated type.  Each frame belonging to the same\n   message\
    \ contains the same type of data.  Broadly speaking, there are\n   types for textual\
    \ data (which is interpreted as UTF-8 [RFC3629]\n   text), binary data (whose\
    \ interpretation is left up to the\n   application), and control frames (which\
    \ are not intended to carry\n   data for the application but instead for protocol-level\
    \ signaling,\n   such as to signal that the connection should be closed).  This\n\
    \   version of the protocol defines six frame types and leaves ten\n   reserved\
    \ for future use.\n"
- title: 1.3.  Opening Handshake
  contents:
  - "1.3.  Opening Handshake\n   _This section is non-normative._\n   The opening\
    \ handshake is intended to be compatible with HTTP-based\n   server-side software\
    \ and intermediaries, so that a single port can be\n   used by both HTTP clients\
    \ talking to that server and WebSocket\n   clients talking to that server.  To\
    \ this end, the WebSocket client's\n   handshake is an HTTP Upgrade request:\n\
    \        GET /chat HTTP/1.1\n        Host: server.example.com\n        Upgrade:\
    \ websocket\n        Connection: Upgrade\n        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n\
    \        Origin: http://example.com\n        Sec-WebSocket-Protocol: chat, superchat\n\
    \        Sec-WebSocket-Version: 13\n   In compliance with [RFC2616], header fields\
    \ in the handshake may be\n   sent by the client in any order, so the order in\
    \ which different\n   header fields are received is not significant.\n   The \"\
    Request-URI\" of the GET method [RFC2616] is used to identify the\n   endpoint\
    \ of the WebSocket connection, both to allow multiple domains\n   to be served\
    \ from one IP address and to allow multiple WebSocket\n   endpoints to be served\
    \ by a single server.\n   The client includes the hostname in the |Host| header\
    \ field of its\n   handshake as per [RFC2616], so that both the client and the\
    \ server\n   can verify that they agree on which host is in use.\n   Additional\
    \ header fields are used to select options in the WebSocket\n   Protocol.  Typical\
    \ options available in this version are the\n   subprotocol selector (|Sec-WebSocket-Protocol|),\
    \ list of extensions\n   support by the client (|Sec-WebSocket-Extensions|), |Origin|\
    \ header\n   field, etc.  The |Sec-WebSocket-Protocol| request-header field can\
    \ be\n   used to indicate what subprotocols (application-level protocols\n   layered\
    \ over the WebSocket Protocol) are acceptable to the client.\n   The server selects\
    \ one or none of the acceptable protocols and echoes\n   that value in its handshake\
    \ to indicate that it has selected that\n   protocol.\n        Sec-WebSocket-Protocol:\
    \ chat\n   The |Origin| header field [RFC6454] is used to protect against\n  \
    \ unauthorized cross-origin use of a WebSocket server by scripts using\n   the\
    \ WebSocket API in a web browser.  The server is informed of the\n   script origin\
    \ generating the WebSocket connection request.  If the\n   server does not wish\
    \ to accept connections from this origin, it can\n   choose to reject the connection\
    \ by sending an appropriate HTTP error\n   code.  This header field is sent by\
    \ browser clients; for non-browser\n   clients, this header field may be sent\
    \ if it makes sense in the\n   context of those clients.\n   Finally, the server\
    \ has to prove to the client that it received the\n   client's WebSocket handshake,\
    \ so that the server doesn't accept\n   connections that are not WebSocket connections.\
    \  This prevents an\n   attacker from tricking a WebSocket server by sending it\
    \ carefully\n   crafted packets using XMLHttpRequest [XMLHttpRequest] or a form\n\
    \   submission.\n   To prove that the handshake was received, the server has to\
    \ take two\n   pieces of information and combine them to form a response.  The\
    \ first\n   piece of information comes from the |Sec-WebSocket-Key| header field\n\
    \   in the client handshake:\n        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n\
    \   For this header field, the server has to take the value (as present\n   in\
    \ the header field, e.g., the base64-encoded [RFC4648] version minus\n   any leading\
    \ and trailing whitespace) and concatenate this with the\n   Globally Unique Identifier\
    \ (GUID, [RFC4122]) \"258EAFA5-E914-47DA-\n   95CA-C5AB0DC85B11\" in string form,\
    \ which is unlikely to be used by\n   network endpoints that do not understand\
    \ the WebSocket Protocol.  A\n   SHA-1 hash (160 bits) [FIPS.180-3], base64-encoded\
    \ (see Section 4 of\n   [RFC4648]), of this concatenation is then returned in\
    \ the server's\n   handshake.\n   Concretely, if as in the example above, the\
    \ |Sec-WebSocket-Key|\n   header field had the value \"dGhlIHNhbXBsZSBub25jZQ==\"\
    , the server\n   would concatenate the string \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\
    \n   to form the string \"dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-\n \
    \  C5AB0DC85B11\".  The server would then take the SHA-1 hash of this,\n   giving\
    \ the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6\n   0x46 0x06 0xcf\
    \ 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea.  This value is\n   then base64-encoded (see\
    \ Section 4 of [RFC4648]), to give the value\n   \"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\"\
    .  This value would then be echoed in\n   the |Sec-WebSocket-Accept| header field.\n\
    \   The handshake from the server is much simpler than the client\n   handshake.\
    \  The first line is an HTTP Status-Line, with the status\n   code 101:\n    \
    \    HTTP/1.1 101 Switching Protocols\n   Any status code other than 101 indicates\
    \ that the WebSocket handshake\n   has not completed and that the semantics of\
    \ HTTP still apply.  The\n   headers follow the status code.\n   The |Connection|\
    \ and |Upgrade| header fields complete the HTTP\n   Upgrade.  The |Sec-WebSocket-Accept|\
    \ header field indicates whether\n   the server is willing to accept the connection.\
    \  If present, this\n   header field must include a hash of the client's nonce\
    \ sent in\n   |Sec-WebSocket-Key| along with a predefined GUID.  Any other value\n\
    \   must not be interpreted as an acceptance of the connection by the\n   server.\n\
    \        HTTP/1.1 101 Switching Protocols\n        Upgrade: websocket\n      \
    \  Connection: Upgrade\n        Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n\
    \   These fields are checked by the WebSocket client for scripted pages.\n   If\
    \ the |Sec-WebSocket-Accept| value does not match the expected\n   value, if the\
    \ header field is missing, or if the HTTP status code is\n   not 101, the connection\
    \ will not be established, and WebSocket frames\n   will not be sent.\n   Option\
    \ fields can also be included.  In this version of the protocol,\n   the main\
    \ option field is |Sec-WebSocket-Protocol|, which indicates\n   the subprotocol\
    \ that the server has selected.  WebSocket clients\n   verify that the server\
    \ included one of the values that was specified\n   in the WebSocket client's\
    \ handshake.  A server that speaks multiple\n   subprotocols has to make sure\
    \ it selects one based on the client's\n   handshake and specifies it in its handshake.\n\
    \        Sec-WebSocket-Protocol: chat\n   The server can also set cookie-related\
    \ option fields to _set_\n   cookies, as described in [RFC6265].\n"
- title: 1.4.  Closing Handshake
  contents:
  - "1.4.  Closing Handshake\n   _This section is non-normative._\n   The closing\
    \ handshake is far simpler than the opening handshake.\n   Either peer can send\
    \ a control frame with data containing a specified\n   control sequence to begin\
    \ the closing handshake (detailed in\n   Section 5.5.1).  Upon receiving such\
    \ a frame, the other peer sends a\n   Close frame in response, if it hasn't already\
    \ sent one.  Upon\n   receiving _that_ control frame, the first peer then closes\
    \ the\n   connection, safe in the knowledge that no further data is\n   forthcoming.\n\
    \   After sending a control frame indicating the connection should be\n   closed,\
    \ a peer does not send any further data; after receiving a\n   control frame indicating\
    \ the connection should be closed, a peer\n   discards any further data received.\n\
    \   It is safe for both peers to initiate this handshake simultaneously.\n   The\
    \ closing handshake is intended to complement the TCP closing\n   handshake (FIN/ACK),\
    \ on the basis that the TCP closing handshake is\n   not always reliable end-to-end,\
    \ especially in the presence of\n   intercepting proxies and other intermediaries.\n\
    \   By sending a Close frame and waiting for a Close frame in response,\n   certain\
    \ cases are avoided where data may be unnecessarily lost.  For\n   instance, on\
    \ some platforms, if a socket is closed with data in the\n   receive queue, a\
    \ RST packet is sent, which will then cause recv() to\n   fail for the party that\
    \ received the RST, even if there was data\n   waiting to be read.\n"
- title: 1.5.  Design Philosophy
  contents:
  - "1.5.  Design Philosophy\n   _This section is non-normative._\n   The WebSocket\
    \ Protocol is designed on the principle that there should\n   be minimal framing\
    \ (the only framing that exists is to make the\n   protocol frame-based instead\
    \ of stream-based and to support a\n   distinction between Unicode text and binary\
    \ frames).  It is expected\n   that metadata would be layered on top of WebSocket\
    \ by the application\n   layer, in the same way that metadata is layered on top\
    \ of TCP by the\n   application layer (e.g., HTTP).\n   Conceptually, WebSocket\
    \ is really just a layer on top of TCP that\n   does the following:\n   o  adds\
    \ a web origin-based security model for browsers\n   o  adds an addressing and\
    \ protocol naming mechanism to support\n      multiple services on one port and\
    \ multiple host names on one IP\n      address\n   o  layers a framing mechanism\
    \ on top of TCP to get back to the IP\n      packet mechanism that TCP is built\
    \ on, but without length limits\n   o  includes an additional closing handshake\
    \ in-band that is designed\n      to work in the presence of proxies and other\
    \ intermediaries\n   Other than that, WebSocket adds nothing.  Basically it is\
    \ intended to\n   be as close to just exposing raw TCP to script as possible given\
    \ the\n   constraints of the Web.  It's also designed in such a way that its\n\
    \   servers can share a port with HTTP servers, by having its handshake\n   be\
    \ a valid HTTP Upgrade request.  One could conceptually use other\n   protocols\
    \ to establish client-server messaging, but the intent of\n   WebSockets is to\
    \ provide a relatively simple protocol that can\n   coexist with HTTP and deployed\
    \ HTTP infrastructure (such as proxies)\n   and that is as close to TCP as is\
    \ safe for use with such\n   infrastructure given security considerations, with\
    \ targeted additions\n   to simplify usage and keep simple things simple (such\
    \ as the addition\n   of message semantics).\n   The protocol is intended to be\
    \ extensible; future versions will\n   likely introduce additional concepts such\
    \ as multiplexing.\n"
- title: 1.6.  Security Model
  contents:
  - "1.6.  Security Model\n   _This section is non-normative._\n   The WebSocket Protocol\
    \ uses the origin model used by web browsers to\n   restrict which web pages can\
    \ contact a WebSocket server when the\n   WebSocket Protocol is used from a web\
    \ page.  Naturally, when the\n   WebSocket Protocol is used by a dedicated client\
    \ directly (i.e., not\n   from a web page through a web browser), the origin model\
    \ is not\n   useful, as the client can provide any arbitrary origin string.\n\
    \   This protocol is intended to fail to establish a connection with\n   servers\
    \ of pre-existing protocols like SMTP [RFC5321] and HTTP, while\n   allowing HTTP\
    \ servers to opt-in to supporting this protocol if\n   desired.  This is achieved\
    \ by having a strict and elaborate handshake\n   and by limiting the data that\
    \ can be inserted into the connection\n   before the handshake is finished (thus\
    \ limiting how much the server\n   can be influenced).\n   It is similarly intended\
    \ to fail to establish a connection when data\n   from other protocols, especially\
    \ HTTP, is sent to a WebSocket server,\n   for example, as might happen if an\
    \ HTML \"form\" were submitted to a\n   WebSocket server.  This is primarily achieved\
    \ by requiring that the\n   server prove that it read the handshake, which it\
    \ can only do if the\n   handshake contains the appropriate parts, which can only\
    \ be sent by a\n   WebSocket client.  In particular, at the time of writing of\
    \ this\n   specification, fields starting with |Sec-| cannot be set by an\n  \
    \ attacker from a web browser using only HTML and JavaScript APIs such\n   as\
    \ XMLHttpRequest [XMLHttpRequest].\n"
- title: 1.7.  Relationship to TCP and HTTP
  contents:
  - "1.7.  Relationship to TCP and HTTP\n   _This section is non-normative._\n   The\
    \ WebSocket Protocol is an independent TCP-based protocol.  Its\n   only relationship\
    \ to HTTP is that its handshake is interpreted by\n   HTTP servers as an Upgrade\
    \ request.\n   By default, the WebSocket Protocol uses port 80 for regular WebSocket\n\
    \   connections and port 443 for WebSocket connections tunneled over\n   Transport\
    \ Layer Security (TLS) [RFC2818].\n"
- title: 1.8.  Establishing a Connection
  contents:
  - "1.8.  Establishing a Connection\n   _This section is non-normative._\n   When\
    \ a connection is to be made to a port that is shared by an HTTP\n   server (a\
    \ situation that is quite likely to occur with traffic to\n   ports 80 and 443),\
    \ the connection will appear to the HTTP server to\n   be a regular GET request\
    \ with an Upgrade offer.  In relatively simple\n   setups with just one IP address\
    \ and a single server for all traffic\n   to a single hostname, this might allow\
    \ a practical way for systems\n   based on the WebSocket Protocol to be deployed.\
    \  In more elaborate\n   setups (e.g., with load balancers and multiple servers),\
    \ a dedicated\n   set of hosts for WebSocket connections separate from the HTTP\
    \ servers\n   is probably easier to manage.  At the time of writing of this\n\
    \   specification, it should be noted that connections on ports 80 and\n   443\
    \ have significantly different success rates, with connections on\n   port 443\
    \ being significantly more likely to succeed, though this may\n   change with\
    \ time.\n"
- title: 1.9.  Subprotocols Using the WebSocket Protocol
  contents:
  - "1.9.  Subprotocols Using the WebSocket Protocol\n   _This section is non-normative._\n\
    \   The client can request that the server use a specific subprotocol by\n   including\
    \ the |Sec-WebSocket-Protocol| field in its handshake.  If it\n   is specified,\
    \ the server needs to include the same field and one of\n   the selected subprotocol\
    \ values in its response for the connection to\n   be established.\n   These subprotocol\
    \ names should be registered as per Section 11.5.  To\n   avoid potential collisions,\
    \ it is recommended to use names that\n   contain the ASCII version of the domain\
    \ name of the subprotocol's\n   originator.  For example, if Example Corporation\
    \ were to create a\n   Chat subprotocol to be implemented by many servers around\
    \ the Web,\n   they could name it \"chat.example.com\".  If the Example Organization\n\
    \   called their competing subprotocol \"chat.example.org\", then the two\n  \
    \ subprotocols could be implemented by servers simultaneously, with the\n   server\
    \ dynamically selecting which subprotocol to use based on the\n   value sent by\
    \ the client.\n   Subprotocols can be versioned in backward-incompatible ways\
    \ by\n   changing the subprotocol name, e.g., going from\n   \"bookings.example.net\"\
    \ to \"v2.bookings.example.net\".  These\n   subprotocols would be considered\
    \ completely separate by WebSocket\n   clients.  Backward-compatible versioning\
    \ can be implemented by\n   reusing the same subprotocol string but carefully\
    \ designing the\n   actual subprotocol to support this kind of extensibility.\n"
- title: 2.  Conformance Requirements
  contents:
  - "2.  Conformance Requirements\n   All diagrams, examples, and notes in this specification\
    \ are non-\n   normative, as are all sections explicitly marked non-normative.\n\
    \   Everything else in this specification is normative.\n   The key words \"MUST\"\
    , \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to\
    \ be interpreted as described in [RFC2119].\n   Requirements phrased in the imperative\
    \ as part of algorithms (such as\n   \"strip any leading space characters\" or\
    \ \"return false and abort these\n   steps\") are to be interpreted with the meaning\
    \ of the key word\n   (\"MUST\", \"SHOULD\", \"MAY\", etc.) used in introducing\
    \ the algorithm.\n   Conformance requirements phrased as algorithms or specific\
    \ steps MAY\n   be implemented in any manner, so long as the end result is\n \
    \  equivalent.  (In particular, the algorithms defined in this\n   specification\
    \ are intended to be easy to follow and not intended to\n   be performant.)\n"
- title: 2.1.  Terminology and Other Conventions
  contents:
  - "2.1.  Terminology and Other Conventions\n   _ASCII_ shall mean the character-encoding\
    \ scheme defined in\n   [ANSI.X3-4.1986].\n   This document makes reference to\
    \ UTF-8 values and uses UTF-8\n   notational formats as defined in STD 63 [RFC3629].\n\
    \   Key terms such as named algorithms or definitions are indicated like\n   _this_.\n\
    \   Names of header fields or variables are indicated like |this|.\n   Variable\
    \ values are indicated like /this/.\n   This document references the procedure\
    \ to _Fail the WebSocket\n   Connection_.  This procedure is defined in Section\
    \ 7.1.7.\n   _Converting a string to ASCII lowercase_ means replacing all\n  \
    \ characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER\n   A to\
    \ LATIN CAPITAL LETTER Z) with the corresponding characters in the\n   range U+0061\
    \ to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL\n   LETTER Z).\n   Comparing\
    \ two strings in an _ASCII case-insensitive_ manner means\n   comparing them exactly,\
    \ code point for code point, except that the\n   characters in the range U+0041\
    \ to U+005A (i.e., LATIN CAPITAL LETTER\n   A to LATIN CAPITAL LETTER Z) and the\
    \ corresponding characters in the\n   range U+0061 to U+007A (i.e., LATIN SMALL\
    \ LETTER A to LATIN SMALL\n   LETTER Z) are considered to also match.\n   The\
    \ term \"URI\" is used in this document as defined in [RFC3986].\n   When an implementation\
    \ is required to _send_ data as part of the\n   WebSocket Protocol, the implementation\
    \ MAY delay the actual\n   transmission arbitrarily, e.g., buffering data so as\
    \ to send fewer IP\n   packets.\n   Note that this document uses both [RFC5234]\
    \ and [RFC2616] variants of\n   ABNF in different sections.\n"
- title: 3.  WebSocket URIs
  contents:
  - "3.  WebSocket URIs\n   This specification defines two URI schemes, using the\
    \ ABNF syntax\n   defined in RFC 5234 [RFC5234], and terminology and ABNF productions\n\
    \   defined by the URI specification RFC 3986 [RFC3986].\n          ws-URI = \"\
    ws:\" \"//\" host [ \":\" port ] path [ \"?\" query ]\n          wss-URI = \"\
    wss:\" \"//\" host [ \":\" port ] path [ \"?\" query ]\n          host = <host,\
    \ defined in [RFC3986], Section 3.2.2>\n          port = <port, defined in [RFC3986],\
    \ Section 3.2.3>\n          path = <path-abempty, defined in [RFC3986], Section\
    \ 3.3>\n          query = <query, defined in [RFC3986], Section 3.4>\n   The port\
    \ component is OPTIONAL; the default for \"ws\" is port 80,\n   while the default\
    \ for \"wss\" is port 443.\n   The URI is called \"secure\" (and it is said that\
    \ \"the secure flag is\n   set\") if the scheme component matches \"wss\" case-insensitively.\n\
    \   The \"resource-name\" (also known as /resource name/ in Section 4.1)\n   can\
    \ be constructed by concatenating the following:\n   o  \"/\" if the path component\
    \ is empty\n   o  the path component\n   o  \"?\" if the query component is non-empty\n\
    \   o  the query component\n   Fragment identifiers are meaningless in the context\
    \ of WebSocket URIs\n   and MUST NOT be used on these URIs.  As with any URI scheme,\
    \ the\n   character \"#\", when not indicating the start of a fragment, MUST be\n\
    \   escaped as %23.\n"
- title: 4.  Opening Handshake
  contents:
  - '4.  Opening Handshake

    '
- title: 4.1.  Client Requirements
  contents:
  - "4.1.  Client Requirements\n   To _Establish a WebSocket Connection_, a client\
    \ opens a connection\n   and sends a handshake as defined in this section.  A\
    \ connection is\n   defined to initially be in a CONNECTING state.  A client will\
    \ need to\n   supply a /host/, /port/, /resource name/, and a /secure/ flag, which\n\
    \   are the components of a WebSocket URI as discussed in Section 3,\n   along\
    \ with a list of /protocols/ and /extensions/ to be used.\n   Additionally, if\
    \ the client is a web browser, it supplies /origin/.\n   Clients running in controlled\
    \ environments, e.g., browsers on mobile\n   handsets tied to specific carriers,\
    \ MAY offload the management of the\n   connection to another agent on the network.\
    \  In such a situation, the\n   client for the purposes of this specification\
    \ is considered to\n   include both the handset software and any such agents.\n\
    \   When the client is to _Establish a WebSocket Connection_ given a set\n   of\
    \ (/host/, /port/, /resource name/, and /secure/ flag), along with a\n   list\
    \ of /protocols/ and /extensions/ to be used, and an /origin/ in\n   the case\
    \ of web browsers, it MUST open a connection, send an opening\n   handshake, and\
    \ read the server's handshake in response.  The exact\n   requirements of how\
    \ the connection should be opened, what should be\n   sent in the opening handshake,\
    \ and how the server's response should\n   be interpreted are as follows in this\
    \ section.  In the following\n   text, we will use terms from Section 3, such\
    \ as \"/host/\" and\n   \"/secure/ flag\" as defined in that section.\n   1. \
    \ The components of the WebSocket URI passed into this algorithm\n       (/host/,\
    \ /port/, /resource name/, and /secure/ flag) MUST be\n       valid according\
    \ to the specification of WebSocket URIs specified\n       in Section 3.  If any\
    \ of the components are invalid, the client\n       MUST _Fail the WebSocket Connection_\
    \ and abort these steps.\n   2.  If the client already has a WebSocket connection\
    \ to the remote\n       host (IP address) identified by /host/ and port /port/\
    \ pair, even\n       if the remote host is known by another name, the client MUST\
    \ wait\n       until that connection has been established or for that connection\n\
    \       to have failed.  There MUST be no more than one connection in a\n    \
    \   CONNECTING state.  If multiple connections to the same IP address\n      \
    \ are attempted simultaneously, the client MUST serialize them so\n       that\
    \ there is no more than one connection at a time running\n       through the following\
    \ steps.\n       If the client cannot determine the IP address of the remote host\n\
    \       (for example, because all communication is being done through a\n    \
    \   proxy server that performs DNS queries itself), then the client\n       MUST\
    \ assume for the purposes of this step that each host name\n       refers to a\
    \ distinct remote host, and instead the client SHOULD\n       limit the total\
    \ number of simultaneous pending connections to a\n       reasonably low number\
    \ (e.g., the client might allow simultaneous\n       pending connections to a.example.com\
    \ and b.example.com, but if\n       thirty simultaneous connections to a single\
    \ host are requested,\n       that may not be allowed).  For example, in a web\
    \ browser context,\n       the client needs to consider the number of tabs the\
    \ user has open\n       in setting a limit to the number of simultaneous pending\n\
    \       connections.\n       NOTE: This makes it harder for a script to perform\
    \ a denial-of-\n       service attack by just opening a large number of WebSocket\n\
    \       connections to a remote host.  A server can further reduce the\n     \
    \  load on itself when attacked by pausing before closing the\n       connection,\
    \ as that will reduce the rate at which the client\n       reconnects.\n     \
    \  NOTE: There is no limit to the number of established WebSocket\n       connections\
    \ a client can have with a single remote host.  Servers\n       can refuse to\
    \ accept connections from hosts/IP addresses with an\n       excessive number\
    \ of existing connections or disconnect resource-\n       hogging connections\
    \ when suffering high load.\n   3.  _Proxy Usage_: If the client is configured\
    \ to use a proxy when\n       using the WebSocket Protocol to connect to host\
    \ /host/ and port\n       /port/, then the client SHOULD connect to that proxy\
    \ and ask it\n       to open a TCP connection to the host given by /host/ and\
    \ the port\n       given by /port/.\n          EXAMPLE: For example, if the client\
    \ uses an HTTP proxy for all\n          traffic, then if it was to try to connect\
    \ to port 80 on server\n          example.com, it might send the following lines\
    \ to the proxy\n          server:\n              CONNECT example.com:80 HTTP/1.1\n\
    \              Host: example.com\n          If there was a password, the connection\
    \ might look like:\n              CONNECT example.com:80 HTTP/1.1\n          \
    \    Host: example.com\n              Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=\n\
    \       If the client is not configured to use a proxy, then a direct TCP\n  \
    \     connection SHOULD be opened to the host given by /host/ and the\n      \
    \ port given by /port/.\n       NOTE: Implementations that do not expose explicit\
    \ UI for\n       selecting a proxy for WebSocket connections separate from other\n\
    \       proxies are encouraged to use a SOCKS5 [RFC1928] proxy for\n       WebSocket\
    \ connections, if available, or failing that, to prefer\n       the proxy configured\
    \ for HTTPS connections over the proxy\n       configured for HTTP connections.\n\
    \       For the purpose of proxy autoconfiguration scripts, the URI to\n     \
    \  pass the function MUST be constructed from /host/, /port/,\n       /resource\
    \ name/, and the /secure/ flag using the definition of a\n       WebSocket URI\
    \ as given in Section 3.\n       NOTE: The WebSocket Protocol can be identified\
    \ in proxy\n       autoconfiguration scripts from the scheme (\"ws\" for unencrypted\n\
    \       connections and \"wss\" for encrypted connections).\n   4.  If the connection\
    \ could not be opened, either because a direct\n       connection failed or because\
    \ any proxy used returned an error,\n       then the client MUST _Fail the WebSocket\
    \ Connection_ and abort\n       the connection attempt.\n   5.  If /secure/ is\
    \ true, the client MUST perform a TLS handshake over\n       the connection after\
    \ opening the connection and before sending\n       the handshake data [RFC2818].\
    \  If this fails (e.g., the server's\n       certificate could not be verified),\
    \ then the client MUST _Fail\n       the WebSocket Connection_ and abort the connection.\
    \  Otherwise,\n       all further communication on this channel MUST run through\
    \ the\n       encrypted tunnel [RFC5246].\n       Clients MUST use the Server\
    \ Name Indication extension in the TLS\n       handshake [RFC6066].\n   Once a\
    \ connection to the server has been established (including a\n   connection via\
    \ a proxy or over a TLS-encrypted tunnel), the client\n   MUST send an opening\
    \ handshake to the server.  The handshake consists\n   of an HTTP Upgrade request,\
    \ along with a list of required and\n   optional header fields.  The requirements\
    \ for this handshake are as\n   follows.\n   1.   The handshake MUST be a valid\
    \ HTTP request as specified by\n        [RFC2616].\n   2.   The method of the\
    \ request MUST be GET, and the HTTP version MUST\n        be at least 1.1.\n \
    \       For example, if the WebSocket URI is \"ws://example.com/chat\",\n    \
    \    the first line sent should be \"GET /chat HTTP/1.1\".\n   3.   The \"Request-URI\"\
    \ part of the request MUST match the /resource\n        name/ defined in Section\
    \ 3 (a relative URI) or be an absolute\n        http/https URI that, when parsed,\
    \ has a /resource name/, /host/,\n        and /port/ that match the corresponding\
    \ ws/wss URI.\n   4.   The request MUST contain a |Host| header field whose value\n\
    \        contains /host/ plus optionally \":\" followed by /port/ (when not\n\
    \        using the default port).\n   5.   The request MUST contain an |Upgrade|\
    \ header field whose value\n        MUST include the \"websocket\" keyword.\n\
    \   6.   The request MUST contain a |Connection| header field whose value\n  \
    \      MUST include the \"Upgrade\" token.\n   7.   The request MUST include a\
    \ header field with the name\n        |Sec-WebSocket-Key|.  The value of this\
    \ header field MUST be a\n        nonce consisting of a randomly selected 16-byte\
    \ value that has\n        been base64-encoded (see Section 4 of [RFC4648]).  The\
    \ nonce\n        MUST be selected randomly for each connection.\n        NOTE:\
    \ As an example, if the randomly selected value was the\n        sequence of bytes\
    \ 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09\n        0x0a 0x0b 0x0c 0x0d 0x0e\
    \ 0x0f 0x10, the value of the header\n        field would be \"AQIDBAUGBwgJCgsMDQ4PEC==\"\
    \n   8.   The request MUST include a header field with the name |Origin|\n   \
    \     [RFC6454] if the request is coming from a browser client.  If\n        the\
    \ connection is from a non-browser client, the request MAY\n        include this\
    \ header field if the semantics of that client match\n        the use-case described\
    \ here for browser clients.  The value of\n        this header field is the ASCII\
    \ serialization of origin of the\n        context in which the code establishing\
    \ the connection is\n        running.  See [RFC6454] for the details of how this\
    \ header field\n        value is constructed.\n        As an example, if code\
    \ downloaded from www.example.com attempts\n        to establish a connection\
    \ to ww2.example.com, the value of the\n        header field would be \"http://www.example.com\"\
    .\n   9.   The request MUST include a header field with the name\n        |Sec-WebSocket-Version|.\
    \  The value of this header field MUST be\n        13.\n        NOTE: Although\
    \ draft versions of this document (-09, -10, -11,\n        and -12) were posted\
    \ (they were mostly comprised of editorial\n        changes and clarifications\
    \ and not changes to the wire\n        protocol), values 9, 10, 11, and 12 were\
    \ not used as valid\n        values for Sec-WebSocket-Version.  These values were\
    \ reserved in\n        the IANA registry but were not and will not be used.\n\
    \   10.  The request MAY include a header field with the name\n        |Sec-WebSocket-Protocol|.\
    \  If present, this value indicates one\n        or more comma-separated subprotocol\
    \ the client wishes to speak,\n        ordered by preference.  The elements that\
    \ comprise this value\n        MUST be non-empty strings with characters in the\
    \ range U+0021 to\n        U+007E not including separator characters as defined\
    \ in\n        [RFC2616] and MUST all be unique strings.  The ABNF for the\n  \
    \      value of this header field is 1#token, where the definitions of\n     \
    \   constructs and rules are as given in [RFC2616].\n   11.  The request MAY include\
    \ a header field with the name\n        |Sec-WebSocket-Extensions|.  If present,\
    \ this value indicates\n        the protocol-level extension(s) the client wishes\
    \ to speak.  The\n        interpretation and format of this header field is described\
    \ in\n        Section 9.1.\n   12.  The request MAY include any other header fields,\
    \ for example,\n        cookies [RFC6265] and/or authentication-related header\
    \ fields\n        such as the |Authorization| header field [RFC2616], which are\n\
    \        processed according to documents that define them.\n   Once the client's\
    \ opening handshake has been sent, the client MUST\n   wait for a response from\
    \ the server before sending any further data.\n   The client MUST validate the\
    \ server's response as follows:\n   1.  If the status code received from the server\
    \ is not 101, the\n       client handles the response per HTTP [RFC2616] procedures.\
    \  In\n       particular, the client might perform authentication if it\n    \
    \   receives a 401 status code; the server might redirect the client\n       using\
    \ a 3xx status code (but clients are not required to follow\n       them), etc.\
    \  Otherwise, proceed as follows.\n   2.  If the response lacks an |Upgrade| header\
    \ field or the |Upgrade|\n       header field contains a value that is not an\
    \ ASCII case-\n       insensitive match for the value \"websocket\", the client\
    \ MUST\n       _Fail the WebSocket Connection_.\n   3.  If the response lacks\
    \ a |Connection| header field or the\n       |Connection| header field doesn't\
    \ contain a token that is an\n       ASCII case-insensitive match for the value\
    \ \"Upgrade\", the client\n       MUST _Fail the WebSocket Connection_.\n   4.\
    \  If the response lacks a |Sec-WebSocket-Accept| header field or\n       the\
    \ |Sec-WebSocket-Accept| contains a value other than the\n       base64-encoded\
    \ SHA-1 of the concatenation of the |Sec-WebSocket-\n       Key| (as a string,\
    \ not base64-decoded) with the string \"258EAFA5-\n       E914-47DA-95CA-C5AB0DC85B11\"\
    \ but ignoring any leading and\n       trailing whitespace, the client MUST _Fail\
    \ the WebSocket\n       Connection_.\n   5.  If the response includes a |Sec-WebSocket-Extensions|\
    \ header\n       field and this header field indicates the use of an extension\n\
    \       that was not present in the client's handshake (the server has\n     \
    \  indicated an extension not requested by the client), the client\n       MUST\
    \ _Fail the WebSocket Connection_.  (The parsing of this\n       header field\
    \ to determine which extensions are requested is\n       discussed in Section\
    \ 9.1.)\n   6.  If the response includes a |Sec-WebSocket-Protocol| header field\n\
    \       and this header field indicates the use of a subprotocol that was\n  \
    \     not present in the client's handshake (the server has indicated a\n    \
    \   subprotocol not requested by the client), the client MUST _Fail\n       the\
    \ WebSocket Connection_.\n   If the server's response does not conform to the\
    \ requirements for the\n   server's handshake as defined in this section and in\
    \ Section 4.2.2,\n   the client MUST _Fail the WebSocket Connection_.\n   Please\
    \ note that according to [RFC2616], all header field names in\n   both HTTP requests\
    \ and HTTP responses are case-insensitive.\n   If the server's response is validated\
    \ as provided for above, it is\n   said that _The WebSocket Connection is Established_\
    \ and that the\n   WebSocket Connection is in the OPEN state.  The _Extensions\
    \ In Use_\n   is defined to be a (possibly empty) string, the value of which is\n\
    \   equal to the value of the |Sec-WebSocket-Extensions| header field\n   supplied\
    \ by the server's handshake or the null value if that header\n   field was not\
    \ present in the server's handshake.  The _Subprotocol In\n   Use_ is defined\
    \ to be the value of the |Sec-WebSocket-Protocol|\n   header field in the server's\
    \ handshake or the null value if that\n   header field was not present in the\
    \ server's handshake.\n   Additionally, if any header fields in the server's handshake\
    \ indicate\n   that cookies should be set (as defined by [RFC6265]), these cookies\n\
    \   are referred to as _Cookies Set During the Server's Opening\n   Handshake_.\n"
- title: 4.2.  Server-Side Requirements
  contents:
  - "4.2.  Server-Side Requirements\n   Servers MAY offload the management of the\
    \ connection to other agents\n   on the network, for example, load balancers and\
    \ reverse proxies.  In\n   such a situation, the server for the purposes of this\
    \ specification\n   is considered to include all parts of the server-side infrastructure\n\
    \   from the first device to terminate the TCP connection all the way to\n   the\
    \ server that processes requests and sends responses.\n   EXAMPLE: A data center\
    \ might have a server that responds to WebSocket\n   requests with an appropriate\
    \ handshake and then passes the connection\n   to another server to actually process\
    \ the data frames.  For the\n   purposes of this specification, the \"server\"\
    \ is the combination of\n   both computers.\n"
- title: 4.2.1.  Reading the Client's Opening Handshake
  contents:
  - "4.2.1.  Reading the Client's Opening Handshake\n   When a client starts a WebSocket\
    \ connection, it sends its part of the\n   opening handshake.  The server must\
    \ parse at least part of this\n   handshake in order to obtain the necessary information\
    \ to generate\n   the server part of the handshake.\n   The client's opening handshake\
    \ consists of the following parts.  If\n   the server, while reading the handshake,\
    \ finds that the client did\n   not send a handshake that matches the description\
    \ below (note that as\n   per [RFC2616], the order of the header fields is not\
    \ important),\n   including but not limited to any violations of the ABNF grammar\n\
    \   specified for the components of the handshake, the server MUST stop\n   processing\
    \ the client's handshake and return an HTTP response with an\n   appropriate error\
    \ code (such as 400 Bad Request).\n   1.   An HTTP/1.1 or higher GET request,\
    \ including a \"Request-URI\"\n        [RFC2616] that should be interpreted as\
    \ a /resource name/\n        defined in Section 3 (or an absolute HTTP/HTTPS URI\
    \ containing\n        the /resource name/).\n   2.   A |Host| header field containing\
    \ the server's authority.\n   3.   An |Upgrade| header field containing the value\
    \ \"websocket\",\n        treated as an ASCII case-insensitive value.\n   4. \
    \  A |Connection| header field that includes the token \"Upgrade\",\n        treated\
    \ as an ASCII case-insensitive value.\n   5.   A |Sec-WebSocket-Key| header field\
    \ with a base64-encoded (see\n        Section 4 of [RFC4648]) value that, when\
    \ decoded, is 16 bytes in\n        length.\n   6.   A |Sec-WebSocket-Version|\
    \ header field, with a value of 13.\n   7.   Optionally, an |Origin| header field.\
    \  This header field is sent\n        by all browser clients.  A connection attempt\
    \ lacking this\n        header field SHOULD NOT be interpreted as coming from\
    \ a browser\n        client.\n   8.   Optionally, a |Sec-WebSocket-Protocol| header\
    \ field, with a list\n        of values indicating which protocols the client\
    \ would like to\n        speak, ordered by preference.\n   9.   Optionally, a\
    \ |Sec-WebSocket-Extensions| header field, with a\n        list of values indicating\
    \ which extensions the client would like\n        to speak.  The interpretation\
    \ of this header field is discussed\n        in Section 9.1.\n   10.  Optionally,\
    \ other header fields, such as those used to send\n        cookies or request\
    \ authentication to a server.  Unknown header\n        fields are ignored, as\
    \ per [RFC2616].\n"
- title: 4.2.2.  Sending the Server's Opening Handshake
  contents:
  - "4.2.2.  Sending the Server's Opening Handshake\n   When a client establishes\
    \ a WebSocket connection to a server, the\n   server MUST complete the following\
    \ steps to accept the connection and\n   send the server's opening handshake.\n\
    \   1.  If the connection is happening on an HTTPS (HTTP-over-TLS) port,\n   \
    \    perform a TLS handshake over the connection.  If this fails\n       (e.g.,\
    \ the client indicated a host name in the extended client\n       hello \"server_name\"\
    \ extension that the server does not host),\n       then close the connection;\
    \ otherwise, all further communication\n       for the connection (including the\
    \ server's handshake) MUST run\n       through the encrypted tunnel [RFC5246].\n\
    \   2.  The server can perform additional client authentication, for\n       example,\
    \ by returning a 401 status code with the corresponding\n       |WWW-Authenticate|\
    \ header field as described in [RFC2616].\n   3.  The server MAY redirect the\
    \ client using a 3xx status code\n       [RFC2616].  Note that this step can happen\
    \ together with, before,\n       or after the optional authentication step described\
    \ above.\n   4.  Establish the following information:\n       /origin/\n     \
    \     The |Origin| header field in the client's handshake indicates\n        \
    \  the origin of the script establishing the connection.  The\n          origin\
    \ is serialized to ASCII and converted to lowercase.  The\n          server MAY\
    \ use this information as part of a determination of\n          whether to accept\
    \ the incoming connection.  If the server does\n          not validate the origin,\
    \ it will accept connections from\n          anywhere.  If the server does not\
    \ wish to accept this\n          connection, it MUST return an appropriate HTTP\
    \ error code\n          (e.g., 403 Forbidden) and abort the WebSocket handshake\n\
    \          described in this section.  For more detail, refer to\n          Section\
    \ 10.\n       /key/\n          The |Sec-WebSocket-Key| header field in the client's\
    \ handshake\n          includes a base64-encoded value that, if decoded, is 16\
    \ bytes\n          in length.  This (encoded) value is used in the creation of\n\
    \          the server's handshake to indicate an acceptance of the\n         \
    \ connection.  It is not necessary for the server to base64-\n          decode\
    \ the |Sec-WebSocket-Key| value.\n       /version/\n          The |Sec-WebSocket-Version|\
    \ header field in the client's\n          handshake includes the version of the\
    \ WebSocket Protocol with\n          which the client is attempting to communicate.\
    \  If this\n          version does not match a version understood by the server,\
    \ the\n          server MUST abort the WebSocket handshake described in this\n\
    \          section and instead send an appropriate HTTP error code (such\n   \
    \       as 426 Upgrade Required) and a |Sec-WebSocket-Version| header\n      \
    \    field indicating the version(s) the server is capable of\n          understanding.\n\
    \       /resource name/\n          An identifier for the service provided by the\
    \ server.  If the\n          server provides multiple services, then the value\
    \ should be\n          derived from the resource name given in the client's handshake\n\
    \          in the \"Request-URI\" [RFC2616] of the GET method.  If the\n     \
    \     requested service is not available, the server MUST send an\n          appropriate\
    \ HTTP error code (such as 404 Not Found) and abort\n          the WebSocket handshake.\n\
    \       /subprotocol/\n          Either a single value representing the subprotocol\
    \ the server\n          is ready to use or null.  The value chosen MUST be derived\n\
    \          from the client's handshake, specifically by selecting one of\n   \
    \       the values from the |Sec-WebSocket-Protocol| field that the\n        \
    \  server is willing to use for this connection (if any).  If the\n          client's\
    \ handshake did not contain such a header field or if\n          the server does\
    \ not agree to any of the client's requested\n          subprotocols, the only\
    \ acceptable value is null.  The absence\n          of such a field is equivalent\
    \ to the null value (meaning that\n          if the server does not wish to agree\
    \ to one of the suggested\n          subprotocols, it MUST NOT send back a |Sec-WebSocket-Protocol|\n\
    \          header field in its response).  The empty string is not the\n     \
    \     same as the null value for these purposes and is not a legal\n         \
    \ value for this field.  The ABNF for the value of this header\n          field\
    \ is (token), where the definitions of constructs and\n          rules are as\
    \ given in [RFC2616].\n       /extensions/\n          A (possibly empty) list\
    \ representing the protocol-level\n          extensions the server is ready to\
    \ use.  If the server supports\n          multiple extensions, then the value\
    \ MUST be derived from the\n          client's handshake, specifically by selecting\
    \ one or more of\n          the values from the |Sec-WebSocket-Extensions| field.\
    \  The\n          absence of such a field is equivalent to the null value.  The\n\
    \          empty string is not the same as the null value for these\n        \
    \  purposes.  Extensions not listed by the client MUST NOT be\n          listed.\
    \  The method by which these values should be selected\n          and interpreted\
    \ is discussed in Section 9.1.\n   5.  If the server chooses to accept the incoming\
    \ connection, it MUST\n       reply with a valid HTTP response indicating the\
    \ following.\n       1.  A Status-Line with a 101 response code as per RFC 2616\n\
    \           [RFC2616].  Such a response could look like \"HTTP/1.1 101\n     \
    \      Switching Protocols\".\n       2.  An |Upgrade| header field with value\
    \ \"websocket\" as per RFC\n           2616 [RFC2616].\n       3.  A |Connection|\
    \ header field with value \"Upgrade\".\n       4.  A |Sec-WebSocket-Accept| header\
    \ field.  The value of this\n           header field is constructed by concatenating\
    \ /key/, defined\n           above in step 4 in Section 4.2.2, with the string\
    \ \"258EAFA5-\n           E914-47DA-95CA-C5AB0DC85B11\", taking the SHA-1 hash\
    \ of this\n           concatenated value to obtain a 20-byte value and base64-\n\
    \           encoding (see Section 4 of [RFC4648]) this 20-byte hash.\n       \
    \    The ABNF [RFC2616] of this header field is defined as\n           follows:\n\
    \           Sec-WebSocket-Accept     = base64-value-non-empty\n           base64-value-non-empty\
    \ = (1*base64-data [ base64-padding ]) |\n                                   \
    \ base64-padding\n           base64-data      = 4base64-character\n          \
    \ base64-padding   = (2base64-character \"==\") |\n                          \
    \    (3base64-character \"=\")\n           base64-character = ALPHA | DIGIT |\
    \ \"+\" | \"/\"\n   NOTE: As an example, if the value of the |Sec-WebSocket-Key|\
    \ header\n   field in the client's handshake were \"dGhlIHNhbXBsZSBub25jZQ==\"\
    , the\n   server would append the string \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\
    \n   to form the string \"dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-\n \
    \  C5AB0DC85B11\".  The server would then take the SHA-1 hash of this\n   string,\
    \ giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90\n   0xf6 0x46\
    \ 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea.  This value\n   is then base64-encoded,\
    \ to give the value\n   \"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\", which would be returned\
    \ in the\n   |Sec-WebSocket-Accept| header field.\n       5.  Optionally, a |Sec-WebSocket-Protocol|\
    \ header field, with a\n           value /subprotocol/ as defined in step 4 in\
    \ Section 4.2.2.\n       6.  Optionally, a |Sec-WebSocket-Extensions| header field,\
    \ with a\n           value /extensions/ as defined in step 4 in Section 4.2.2.\
    \  If\n           multiple extensions are to be used, they can all be listed in\n\
    \           a single |Sec-WebSocket-Extensions| header field or split\n      \
    \     between multiple instances of the |Sec-WebSocket-Extensions|\n         \
    \  header field.\n   This completes the server's handshake.  If the server finishes\
    \ these\n   steps without aborting the WebSocket handshake, the server considers\n\
    \   the WebSocket connection to be established and that the WebSocket\n   connection\
    \ is in the OPEN state.  At this point, the server may begin\n   sending (and\
    \ receiving) data.\n"
- title: 4.3.  Collected ABNF for New Header Fields Used in Handshake
  contents:
  - "4.3.  Collected ABNF for New Header Fields Used in Handshake\n   This section\
    \ is using ABNF syntax/rules from Section 2.1 of\n   [RFC2616], including the\
    \ \"implied *LWS rule\".\n   Note that the following ABNF conventions are used\
    \ in this section.\n   Some names of the rules correspond to names of the corresponding\n\
    \   header fields.  Such rules express values of the corresponding header\n  \
    \ fields, for example, the Sec-WebSocket-Key ABNF rule describes syntax\n   of\
    \ the |Sec-WebSocket-Key| header field value.  ABNF rules with the\n   \"-Client\"\
    \ suffix in the name are only used in requests sent by the\n   client to the server;\
    \ ABNF rules with the \"-Server\" suffix in the\n   name are only used in responses\
    \ sent by the server to the client.\n   For example, the ABNF rule Sec-WebSocket-Protocol-Client\
    \ describes\n   syntax of the |Sec-WebSocket-Protocol| header field value sent\
    \ by the\n   client to the server.\n   The following new header fields can be\
    \ sent during the handshake from\n   the client to the server:\n      Sec-WebSocket-Key\
    \ = base64-value-non-empty\n      Sec-WebSocket-Extensions = extension-list\n\
    \      Sec-WebSocket-Protocol-Client = 1#token\n      Sec-WebSocket-Version-Client\
    \ = version\n      base64-value-non-empty = (1*base64-data [ base64-padding ])\
    \ |\n                                base64-padding\n      base64-data      =\
    \ 4base64-character\n      base64-padding   = (2base64-character \"==\") |\n \
    \                        (3base64-character \"=\")\n      base64-character = ALPHA\
    \ | DIGIT | \"+\" | \"/\"\n      extension-list = 1#extension\n      extension\
    \ = extension-token *( \";\" extension-param )\n      extension-token = registered-token\n\
    \      registered-token = token\n      extension-param = token [ \"=\" (token\
    \ | quoted-string) ]\n           ; When using the quoted-string syntax variant,\
    \ the value\n           ; after quoted-string unescaping MUST conform to the\n\
    \           ; 'token' ABNF.\n      NZDIGIT       =  \"1\" | \"2\" | \"3\" | \"\
    4\" | \"5\" | \"6\" |\n                       \"7\" | \"8\" | \"9\"\n      version\
    \ = DIGIT | (NZDIGIT DIGIT) |\n                (\"1\" DIGIT DIGIT) | (\"2\" DIGIT\
    \ DIGIT)\n                ; Limited to 0-255 range, with no leading zeros\n  \
    \ The following new header fields can be sent during the handshake from\n   the\
    \ server to the client:\n      Sec-WebSocket-Extensions = extension-list\n   \
    \   Sec-WebSocket-Accept     = base64-value-non-empty\n      Sec-WebSocket-Protocol-Server\
    \ = token\n      Sec-WebSocket-Version-Server = 1#version\n"
- title: 4.4.  Supporting Multiple Versions of WebSocket Protocol
  contents:
  - "4.4.  Supporting Multiple Versions of WebSocket Protocol\n   This section provides\
    \ some guidance on supporting multiple versions\n   of the WebSocket Protocol\
    \ in clients and servers.\n   Using the WebSocket version advertisement capability\
    \ (the\n   |Sec-WebSocket-Version| header field), a client can initially request\n\
    \   the version of the WebSocket Protocol that it prefers (which doesn't\n   necessarily\
    \ have to be the latest supported by the client).  If the\n   server supports\
    \ the requested version and the handshake message is\n   otherwise valid, the\
    \ server will accept that version.  If the server\n   doesn't support the requested\
    \ version, it MUST respond with a\n   |Sec-WebSocket-Version| header field (or\
    \ multiple\n   |Sec-WebSocket-Version| header fields) containing all versions\
    \ it is\n   willing to use.  At this point, if the client supports one of the\n\
    \   advertised versions, it can repeat the WebSocket handshake using a\n   new\
    \ version value.\n   The following example demonstrates version negotiation described\n\
    \   above:\n      GET /chat HTTP/1.1\n      Host: server.example.com\n      Upgrade:\
    \ websocket\n      Connection: Upgrade\n      ...\n      Sec-WebSocket-Version:\
    \ 25\n   The response from the server might look as follows:\n      HTTP/1.1 400\
    \ Bad Request\n      ...\n      Sec-WebSocket-Version: 13, 8, 7\n   Note that\
    \ the last response from the server might also look like:\n      HTTP/1.1 400\
    \ Bad Request\n      ...\n      Sec-WebSocket-Version: 13\n      Sec-WebSocket-Version:\
    \ 8, 7\n   The client now repeats the handshake that conforms to version 13:\n\
    \      GET /chat HTTP/1.1\n      Host: server.example.com\n      Upgrade: websocket\n\
    \      Connection: Upgrade\n      ...\n      Sec-WebSocket-Version: 13\n"
- title: 5.  Data Framing
  contents:
  - '5.  Data Framing

    '
- title: 5.1.  Overview
  contents:
  - "5.1.  Overview\n   In the WebSocket Protocol, data is transmitted using a sequence\
    \ of\n   frames.  To avoid confusing network intermediaries (such as\n   intercepting\
    \ proxies) and for security reasons that are further\n   discussed in Section\
    \ 10.3, a client MUST mask all frames that it\n   sends to the server (see Section\
    \ 5.3 for further details).  (Note\n   that masking is done whether or not the\
    \ WebSocket Protocol is running\n   over TLS.)  The server MUST close the connection\
    \ upon receiving a\n   frame that is not masked.  In this case, a server MAY send\
    \ a Close\n   frame with a status code of 1002 (protocol error) as defined in\n\
    \   Section 7.4.1.  A server MUST NOT mask any frames that it sends to\n   the\
    \ client.  A client MUST close a connection if it detects a masked\n   frame.\
    \  In this case, it MAY use the status code 1002 (protocol\n   error) as defined\
    \ in Section 7.4.1.  (These rules might be relaxed in\n   a future specification.)\n\
    \   The base framing protocol defines a frame type with an opcode, a\n   payload\
    \ length, and designated locations for \"Extension data\" and\n   \"Application\
    \ data\", which together define the \"Payload data\".\n   Certain bits and opcodes\
    \ are reserved for future expansion of the\n   protocol.\n   A data frame MAY\
    \ be transmitted by either the client or the server at\n   any time after opening\
    \ handshake completion and before that endpoint\n   has sent a Close frame (Section\
    \ 5.5.1).\n"
- title: 5.2.  Base Framing Protocol
  contents:
  - "5.2.  Base Framing Protocol\n   This wire format for the data transfer part is\
    \ described by the ABNF\n   [RFC5234] given in detail in this section.  (Note\
    \ that, unlike in\n   other sections of this document, the ABNF in this section\
    \ is\n   operating on groups of bits.  The length of each group of bits is\n \
    \  indicated in a comment.  When encoded on the wire, the most\n   significant\
    \ bit is the leftmost in the ABNF).  A high-level overview\n   of the framing\
    \ is given in the following figure.  In a case of\n   conflict between the figure\
    \ below and the ABNF specified later in\n   this section, the figure is authoritative.\n\
    \      0                   1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-------+-+-------------+-------------------------------+\n\
    \     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n    \
    \ |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n     |N|V|V|V|\
    \       |S|             |   (if payload len==126/127)   |\n     | |1|2|3|    \
    \   |K|             |                               |\n     +-+-+-+-+-------+-+-------------+\
    \ - - - - - - - - - - - - - - - +\n     |     Extended payload length continued,\
    \ if payload len == 127  |\n     + - - - - - - - - - - - - - - - +-------------------------------+\n\
    \     |                               |Masking-key, if MASK set to 1  |\n    \
    \ +-------------------------------+-------------------------------+\n     | Masking-key\
    \ (continued)       |          Payload Data         |\n     +--------------------------------\
    \ - - - - - - - - - - - - - - - +\n     :                     Payload Data continued\
    \ ...                :\n     + - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - - - - - +\n     |                     Payload Data continued ...     \
    \           |\n     +---------------------------------------------------------------+\n\
    \   FIN:  1 bit\n      Indicates that this is the final fragment in a message.\
    \  The first\n      fragment MAY also be the final fragment.\n   RSV1, RSV2, RSV3:\
    \  1 bit each\n      MUST be 0 unless an extension is negotiated that defines\
    \ meanings\n      for non-zero values.  If a nonzero value is received and none\
    \ of\n      the negotiated extensions defines the meaning of such a nonzero\n\
    \      value, the receiving endpoint MUST _Fail the WebSocket\n      Connection_.\n\
    \   Opcode:  4 bits\n      Defines the interpretation of the \"Payload data\"\
    .  If an unknown\n      opcode is received, the receiving endpoint MUST _Fail\
    \ the\n      WebSocket Connection_.  The following values are defined.\n     \
    \ *  %x0 denotes a continuation frame\n      *  %x1 denotes a text frame\n   \
    \   *  %x2 denotes a binary frame\n      *  %x3-7 are reserved for further non-control\
    \ frames\n      *  %x8 denotes a connection close\n      *  %x9 denotes a ping\n\
    \      *  %xA denotes a pong\n      *  %xB-F are reserved for further control\
    \ frames\n   Mask:  1 bit\n      Defines whether the \"Payload data\" is masked.\
    \  If set to 1, a\n      masking key is present in masking-key, and this is used\
    \ to unmask\n      the \"Payload data\" as per Section 5.3.  All frames sent from\n\
    \      client to server have this bit set to 1.\n   Payload length:  7 bits, 7+16\
    \ bits, or 7+64 bits\n      The length of the \"Payload data\", in bytes: if 0-125,\
    \ that is the\n      payload length.  If 126, the following 2 bytes interpreted\
    \ as a\n      16-bit unsigned integer are the payload length.  If 127, the\n \
    \     following 8 bytes interpreted as a 64-bit unsigned integer (the\n      most\
    \ significant bit MUST be 0) are the payload length.  Multibyte\n      length\
    \ quantities are expressed in network byte order.  Note that\n      in all cases,\
    \ the minimal number of bytes MUST be used to encode\n      the length, for example,\
    \ the length of a 124-byte-long string\n      can't be encoded as the sequence\
    \ 126, 0, 124.  The payload length\n      is the length of the \"Extension data\"\
    \ + the length of the\n      \"Application data\".  The length of the \"Extension\
    \ data\" may be\n      zero, in which case the payload length is the length of\
    \ the\n      \"Application data\".\n   Masking-key:  0 or 4 bytes\n      All frames\
    \ sent from the client to the server are masked by a\n      32-bit value that\
    \ is contained within the frame.  This field is\n      present if the mask bit\
    \ is set to 1 and is absent if the mask bit\n      is set to 0.  See Section 5.3\
    \ for further information on client-\n      to-server masking.\n   Payload data:\
    \  (x+y) bytes\n      The \"Payload data\" is defined as \"Extension data\" concatenated\n\
    \      with \"Application data\".\n   Extension data:  x bytes\n      The \"Extension\
    \ data\" is 0 bytes unless an extension has been\n      negotiated.  Any extension\
    \ MUST specify the length of the\n      \"Extension data\", or how that length\
    \ may be calculated, and how\n      the extension use MUST be negotiated during\
    \ the opening handshake.\n      If present, the \"Extension data\" is included\
    \ in the total payload\n      length.\n   Application data:  y bytes\n      Arbitrary\
    \ \"Application data\", taking up the remainder of the frame\n      after any\
    \ \"Extension data\".  The length of the \"Application data\"\n      is equal\
    \ to the payload length minus the length of the \"Extension\n      data\".\n \
    \  The base framing protocol is formally defined by the following ABNF\n   [RFC5234].\
    \  It is important to note that the representation of this\n   data is binary,\
    \ not ASCII characters.  As such, a field with a length\n   of 1 bit that takes\
    \ values %x0 / %x1 is represented as a single bit\n   whose value is 0 or 1, not\
    \ a full byte (octet) that stands for the\n   characters \"0\" or \"1\" in the\
    \ ASCII encoding.  A field with a length\n   of 4 bits with values between %x0-F\
    \ again is represented by 4 bits,\n   again NOT by an ASCII character or full\
    \ byte (octet) with these\n   values.  [RFC5234] does not specify a character\
    \ encoding: \"Rules\n   resolve into a string of terminal values, sometimes called\n\
    \   characters.  In ABNF, a character is merely a non-negative integer.\n   In\
    \ certain contexts, a specific mapping (encoding) of values into a\n   character\
    \ set (such as ASCII) will be specified.\"  Here, the\n   specified encoding is\
    \ a binary encoding where each terminal value is\n   encoded in the specified\
    \ number of bits, which varies for each field.\n    ws-frame                =\
    \ frame-fin           ; 1 bit in length\n                              frame-rsv1\
    \          ; 1 bit in length\n                              frame-rsv2       \
    \   ; 1 bit in length\n                              frame-rsv3          ; 1 bit\
    \ in length\n                              frame-opcode        ; 4 bits in length\n\
    \                              frame-masked        ; 1 bit in length\n       \
    \                       frame-payload-length   ; either 7, 7+16,\n           \
    \                                          ; or 7+64 bits in\n               \
    \                                      ; length\n                            \
    \  [ frame-masking-key ]  ; 32 bits in length\n                              frame-payload-data\
    \     ; n*8 bits in\n                                                     ; length,\
    \ where\n                                                     ; n >= 0\n    frame-fin\
    \               = %x0 ; more frames of this message follow\n                 \
    \           / %x1 ; final frame of this message\n                            \
    \      ; 1 bit in length\n    frame-rsv1              = %x0 / %x1\n          \
    \                    ; 1 bit in length, MUST be 0 unless\n                   \
    \           ; negotiated otherwise\n    frame-rsv2              = %x0 / %x1\n\
    \                              ; 1 bit in length, MUST be 0 unless\n         \
    \                     ; negotiated otherwise\n    frame-rsv3              = %x0\
    \ / %x1\n                              ; 1 bit in length, MUST be 0 unless\n \
    \                             ; negotiated otherwise\n    frame-opcode       \
    \     = frame-opcode-non-control /\n                              frame-opcode-control\
    \ /\n                              frame-opcode-cont\n    frame-opcode-cont  \
    \     = %x0 ; frame continuation\n    frame-opcode-non-control= %x1 ; text frame\n\
    \                            / %x2 ; binary frame\n                          \
    \  / %x3-7\n                            ; 4 bits in length,\n                \
    \            ; reserved for further non-control frames\n    frame-opcode-control\
    \    = %x8 ; connection close\n                            / %x9 ; ping\n    \
    \                        / %xA ; pong\n                            / %xB-F ; reserved\
    \ for further control\n                                    ; frames\n        \
    \                            ; 4 bits in length\n    frame-masked            =\
    \ %x0\n                            ; frame is not masked, no frame-masking-key\n\
    \                            / %x1\n                            ; frame is masked,\
    \ frame-masking-key present\n                            ; 1 bit in length\n \
    \   frame-payload-length    = ( %x00-7D )\n                            / ( %x7E\
    \ frame-payload-length-16 )\n                            / ( %x7F frame-payload-length-63\
    \ )\n                            ; 7, 7+16, or 7+64 bits in length,\n        \
    \                    ; respectively\n    frame-payload-length-16 = %x0000-FFFF\
    \ ; 16 bits in length\n    frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF\n\
    \                            ; 64 bits in length\n    frame-masking-key      \
    \ = 4( %x00-FF )\n                              ; present only if frame-masked\
    \ is 1\n                              ; 32 bits in length\n    frame-payload-data\
    \      = (frame-masked-extension-data\n                               frame-masked-application-data)\n\
    \                            ; when frame-masked is 1\n                      \
    \        / (frame-unmasked-extension-data\n                                frame-unmasked-application-data)\n\
    \                            ; when frame-masked is 0\n    frame-masked-extension-data\
    \     = *( %x00-FF )\n                            ; reserved for future extensibility\n\
    \                            ; n*8 bits in length, where n >= 0\n    frame-masked-application-data\
    \   = *( %x00-FF )\n                            ; n*8 bits in length, where n\
    \ >= 0\n    frame-unmasked-extension-data   = *( %x00-FF )\n                 \
    \           ; reserved for future extensibility\n                            ;\
    \ n*8 bits in length, where n >= 0\n    frame-unmasked-application-data = *( %x00-FF\
    \ )\n                            ; n*8 bits in length, where n >= 0\n"
- title: 5.3.  Client-to-Server Masking
  contents:
  - "5.3.  Client-to-Server Masking\n   A masked frame MUST have the field frame-masked\
    \ set to 1, as defined\n   in Section 5.2.\n   The masking key is contained completely\
    \ within the frame, as defined\n   in Section 5.2 as frame-masking-key.  It is\
    \ used to mask the \"Payload\n   data\" defined in the same section as frame-payload-data,\
    \ which\n   includes \"Extension data\" and \"Application data\".\n   The masking\
    \ key is a 32-bit value chosen at random by the client.\n   When preparing a masked\
    \ frame, the client MUST pick a fresh masking\n   key from the set of allowed\
    \ 32-bit values.  The masking key needs to\n   be unpredictable; thus, the masking\
    \ key MUST be derived from a strong\n   source of entropy, and the masking key\
    \ for a given frame MUST NOT\n   make it simple for a server/proxy to predict\
    \ the masking key for a\n   subsequent frame.  The unpredictability of the masking\
    \ key is\n   essential to prevent authors of malicious applications from selecting\n\
    \   the bytes that appear on the wire.  RFC 4086 [RFC4086] discusses what\n  \
    \ entails a suitable source of entropy for security-sensitive\n   applications.\n\
    \   The masking does not affect the length of the \"Payload data\".  To\n   convert\
    \ masked data into unmasked data, or vice versa, the following\n   algorithm is\
    \ applied.  The same algorithm applies regardless of the\n   direction of the\
    \ translation, e.g., the same steps are applied to\n   mask the data as to unmask\
    \ the data.\n   Octet i of the transformed data (\"transformed-octet-i\") is the\
    \ XOR of\n   octet i of the original data (\"original-octet-i\") with octet at\
    \ index\n   i modulo 4 of the masking key (\"masking-key-octet-j\"):\n     j \
    \                  = i MOD 4\n     transformed-octet-i = original-octet-i XOR\
    \ masking-key-octet-j\n   The payload length, indicated in the framing as frame-payload-length,\n\
    \   does NOT include the length of the masking key.  It is the length of\n   the\
    \ \"Payload data\", e.g., the number of bytes following the masking\n   key.\n"
- title: 5.4.  Fragmentation
  contents:
  - "5.4.  Fragmentation\n   The primary purpose of fragmentation is to allow sending\
    \ a message\n   that is of unknown size when the message is started without having\
    \ to\n   buffer that message.  If messages couldn't be fragmented, then an\n \
    \  endpoint would have to buffer the entire message so its length could\n   be\
    \ counted before the first byte is sent.  With fragmentation, a\n   server or\
    \ intermediary may choose a reasonable size buffer and, when\n   the buffer is\
    \ full, write a fragment to the network.\n   A secondary use-case for fragmentation\
    \ is for multiplexing, where it\n   is not desirable for a large message on one\
    \ logical channel to\n   monopolize the output channel, so the multiplexing needs\
    \ to be free\n   to split the message into smaller fragments to better share the\n\
    \   output channel.  (Note that the multiplexing extension is not\n   described\
    \ in this document.)\n   Unless specified otherwise by an extension, frames have\
    \ no semantic\n   meaning.  An intermediary might coalesce and/or split frames,\
    \ if no\n   extensions were negotiated by the client and the server or if some\n\
    \   extensions were negotiated, but the intermediary understood all the\n   extensions\
    \ negotiated and knows how to coalesce and/or split frames\n   in the presence\
    \ of these extensions.  One implication of this is that\n   in absence of extensions,\
    \ senders and receivers must not depend on\n   the presence of specific frame\
    \ boundaries.\n   The following rules apply to fragmentation:\n   o  An unfragmented\
    \ message consists of a single frame with the FIN\n      bit set (Section 5.2)\
    \ and an opcode other than 0.\n   o  A fragmented message consists of a single\
    \ frame with the FIN bit\n      clear and an opcode other than 0, followed by\
    \ zero or more frames\n      with the FIN bit clear and the opcode set to 0, and\
    \ terminated by\n      a single frame with the FIN bit set and an opcode of 0.\
    \  A\n      fragmented message is conceptually equivalent to a single larger\n\
    \      message whose payload is equal to the concatenation of the\n      payloads\
    \ of the fragments in order; however, in the presence of\n      extensions, this\
    \ may not hold true as the extension defines the\n      interpretation of the\
    \ \"Extension data\" present.  For instance,\n      \"Extension data\" may only\
    \ be present at the beginning of the first\n      fragment and apply to subsequent\
    \ fragments, or there may be\n      \"Extension data\" present in each of the\
    \ fragments that applies\n      only to that particular fragment.  In the absence\
    \ of \"Extension\n      data\", the following example demonstrates how fragmentation\
    \ works.\n      EXAMPLE: For a text message sent as three fragments, the first\n\
    \      fragment would have an opcode of 0x1 and a FIN bit clear, the\n      second\
    \ fragment would have an opcode of 0x0 and a FIN bit clear,\n      and the third\
    \ fragment would have an opcode of 0x0 and a FIN bit\n      that is set.\n   o\
    \  Control frames (see Section 5.5) MAY be injected in the middle of\n      a\
    \ fragmented message.  Control frames themselves MUST NOT be\n      fragmented.\n\
    \   o  Message fragments MUST be delivered to the recipient in the order\n   \
    \   sent by the sender.\n   o  The fragments of one message MUST NOT be interleaved\
    \ between the\n      fragments of another message unless an extension has been\n\
    \      negotiated that can interpret the interleaving.\n   o  An endpoint MUST\
    \ be capable of handling control frames in the\n      middle of a fragmented message.\n\
    \   o  A sender MAY create fragments of any size for non-control\n      messages.\n\
    \   o  Clients and servers MUST support receiving both fragmented and\n      unfragmented\
    \ messages.\n   o  As control frames cannot be fragmented, an intermediary MUST\
    \ NOT\n      attempt to change the fragmentation of a control frame.\n   o  An\
    \ intermediary MUST NOT change the fragmentation of a message if\n      any reserved\
    \ bit values are used and the meaning of these values\n      is not known to the\
    \ intermediary.\n   o  An intermediary MUST NOT change the fragmentation of any\
    \ message\n      in the context of a connection where extensions have been\n \
    \     negotiated and the intermediary is not aware of the semantics of\n     \
    \ the negotiated extensions.  Similarly, an intermediary that didn't\n      see\
    \ the WebSocket handshake (and wasn't notified about its\n      content) that\
    \ resulted in a WebSocket connection MUST NOT change\n      the fragmentation\
    \ of any message of such connection.\n   o  As a consequence of these rules, all\
    \ fragments of a message are of\n      the same type, as set by the first fragment's\
    \ opcode.  Since\n      control frames cannot be fragmented, the type for all\
    \ fragments in\n      a message MUST be either text, binary, or one of the reserved\n\
    \      opcodes.\n   NOTE: If control frames could not be interjected, the latency\
    \ of a\n   ping, for example, would be very long if behind a large message.\n\
    \   Hence, the requirement of handling control frames in the middle of a\n   fragmented\
    \ message.\n   IMPLEMENTATION NOTE: In the absence of any extension, a receiver\n\
    \   doesn't have to buffer the whole frame in order to process it.  For\n   example,\
    \ if a streaming API is used, a part of a frame can be\n   delivered to the application.\
    \  However, note that this assumption\n   might not hold true for all future WebSocket\
    \ extensions.\n"
- title: 5.5.  Control Frames
  contents:
  - "5.5.  Control Frames\n   Control frames are identified by opcodes where the most\
    \ significant\n   bit of the opcode is 1.  Currently defined opcodes for control\
    \ frames\n   include 0x8 (Close), 0x9 (Ping), and 0xA (Pong).  Opcodes 0xB-0xF\
    \ are\n   reserved for further control frames yet to be defined.\n   Control frames\
    \ are used to communicate state about the WebSocket.\n   Control frames can be\
    \ interjected in the middle of a fragmented\n   message.\n   All control frames\
    \ MUST have a payload length of 125 bytes or less\n   and MUST NOT be fragmented.\n"
- title: 5.5.1.  Close
  contents:
  - "5.5.1.  Close\n   The Close frame contains an opcode of 0x8.\n   The Close frame\
    \ MAY contain a body (the \"Application data\" portion of\n   the frame) that\
    \ indicates a reason for closing, such as an endpoint\n   shutting down, an endpoint\
    \ having received a frame too large, or an\n   endpoint having received a frame\
    \ that does not conform to the format\n   expected by the endpoint.  If there\
    \ is a body, the first two bytes of\n   the body MUST be a 2-byte unsigned integer\
    \ (in network byte order)\n   representing a status code with value /code/ defined\
    \ in Section 7.4.\n   Following the 2-byte integer, the body MAY contain UTF-8-encoded\
    \ data\n   with value /reason/, the interpretation of which is not defined by\n\
    \   this specification.  This data is not necessarily human readable but\n   may\
    \ be useful for debugging or passing information relevant to the\n   script that\
    \ opened the connection.  As the data is not guaranteed to\n   be human readable,\
    \ clients MUST NOT show it to end users.\n   Close frames sent from client to\
    \ server must be masked as per\n   Section 5.3.\n   The application MUST NOT send\
    \ any more data frames after sending a\n   Close frame.\n   If an endpoint receives\
    \ a Close frame and did not previously send a\n   Close frame, the endpoint MUST\
    \ send a Close frame in response.  (When\n   sending a Close frame in response,\
    \ the endpoint typically echos the\n   status code it received.)  It SHOULD do\
    \ so as soon as practical.  An\n   endpoint MAY delay sending a Close frame until\
    \ its current message is\n   sent (for instance, if the majority of a fragmented\
    \ message is\n   already sent, an endpoint MAY send the remaining fragments before\n\
    \   sending a Close frame).  However, there is no guarantee that the\n   endpoint\
    \ that has already sent a Close frame will continue to process\n   data.\n   After\
    \ both sending and receiving a Close message, an endpoint\n   considers the WebSocket\
    \ connection closed and MUST close the\n   underlying TCP connection.  The server\
    \ MUST close the underlying TCP\n   connection immediately; the client SHOULD\
    \ wait for the server to\n   close the connection but MAY close the connection\
    \ at any time after\n   sending and receiving a Close message, e.g., if it has\
    \ not received a\n   TCP Close from the server in a reasonable time period.\n\
    \   If a client and server both send a Close message at the same time,\n   both\
    \ endpoints will have sent and received a Close message and should\n   consider\
    \ the WebSocket connection closed and close the underlying TCP\n   connection.\n"
- title: 5.5.2.  Ping
  contents:
  - "5.5.2.  Ping\n   The Ping frame contains an opcode of 0x9.\n   A Ping frame MAY\
    \ include \"Application data\".\n   Upon receipt of a Ping frame, an endpoint\
    \ MUST send a Pong frame in\n   response, unless it already received a Close frame.\
    \  It SHOULD\n   respond with Pong frame as soon as is practical.  Pong frames\
    \ are\n   discussed in Section 5.5.3.\n   An endpoint MAY send a Ping frame any\
    \ time after the connection is\n   established and before the connection is closed.\n\
    \   NOTE: A Ping frame may serve either as a keepalive or as a means to\n   verify\
    \ that the remote endpoint is still responsive.\n"
- title: 5.5.3.  Pong
  contents:
  - "5.5.3.  Pong\n   The Pong frame contains an opcode of 0xA.\n   Section 5.5.2\
    \ details requirements that apply to both Ping and Pong\n   frames.\n   A Pong\
    \ frame sent in response to a Ping frame must have identical\n   \"Application\
    \ data\" as found in the message body of the Ping frame\n   being replied to.\n\
    \   If an endpoint receives a Ping frame and has not yet sent Pong\n   frame(s)\
    \ in response to previous Ping frame(s), the endpoint MAY\n   elect to send a\
    \ Pong frame for only the most recently processed Ping\n   frame.\n   A Pong frame\
    \ MAY be sent unsolicited.  This serves as a\n   unidirectional heartbeat.  A\
    \ response to an unsolicited Pong frame is\n   not expected.\n"
- title: 5.6.  Data Frames
  contents:
  - "5.6.  Data Frames\n   Data frames (e.g., non-control frames) are identified by\
    \ opcodes\n   where the most significant bit of the opcode is 0.  Currently defined\n\
    \   opcodes for data frames include 0x1 (Text), 0x2 (Binary).  Opcodes\n   0x3-0x7\
    \ are reserved for further non-control frames yet to be\n   defined.\n   Data\
    \ frames carry application-layer and/or extension-layer data.  The\n   opcode\
    \ determines the interpretation of the data:\n   Text\n      The \"Payload data\"\
    \ is text data encoded as UTF-8.  Note that a\n      particular text frame might\
    \ include a partial UTF-8 sequence;\n      however, the whole message MUST contain\
    \ valid UTF-8.  Invalid\n      UTF-8 in reassembled messages is handled as described\
    \ in\n      Section 8.1.\n   Binary\n      The \"Payload data\" is arbitrary binary\
    \ data whose interpretation\n      is solely up to the application layer.\n"
- title: 5.7.  Examples
  contents:
  - "5.7.  Examples\n   o  A single-frame unmasked text message\n      *  0x81 0x05\
    \ 0x48 0x65 0x6c 0x6c 0x6f (contains \"Hello\")\n   o  A single-frame masked text\
    \ message\n      *  0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58\n \
    \        (contains \"Hello\")\n   o  A fragmented unmasked text message\n    \
    \  *  0x01 0x03 0x48 0x65 0x6c (contains \"Hel\")\n      *  0x80 0x02 0x6c 0x6f\
    \ (contains \"lo\")\n   o  Unmasked Ping request and masked Ping response\n  \
    \    *  0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of \"Hello\",\n  \
    \       but the contents of the body are arbitrary)\n      *  0x8a 0x85 0x37 0xfa\
    \ 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58\n         (contains a body of \"Hello\",\
    \ matching the body of the ping)\n   o  256 bytes binary message in a single unmasked\
    \ frame\n      *  0x82 0x7E 0x0100 [256 bytes of binary data]\n   o  64KiB binary\
    \ message in a single unmasked frame\n      *  0x82 0x7F 0x0000000000010000 [65536\
    \ bytes of binary data]\n"
- title: 5.8.  Extensibility
  contents:
  - "5.8.  Extensibility\n   The protocol is designed to allow for extensions, which\
    \ will add\n   capabilities to the base protocol.  The endpoints of a connection\n\
    \   MUST negotiate the use of any extensions during the opening\n   handshake.\
    \  This specification provides opcodes 0x3 through 0x7 and\n   0xB through 0xF,\
    \ the \"Extension data\" field, and the frame-rsv1,\n   frame-rsv2, and frame-rsv3\
    \ bits of the frame header for use by\n   extensions.  The negotiation of extensions\
    \ is discussed in further\n   detail in Section 9.1.  Below are some anticipated\
    \ uses of\n   extensions.  This list is neither complete nor prescriptive.\n \
    \  o  \"Extension data\" may be placed in the \"Payload data\" before the\n  \
    \    \"Application data\".\n   o  Reserved bits can be allocated for per-frame\
    \ needs.\n   o  Reserved opcode values can be defined.\n   o  Reserved bits can\
    \ be allocated to the opcode field if more opcode\n      values are needed.\n\
    \   o  A reserved bit or an \"extension\" opcode can be defined that\n      allocates\
    \ additional bits out of the \"Payload data\" to define\n      larger opcodes\
    \ or more per-frame bits.\n"
- title: 6.  Sending and Receiving Data
  contents:
  - '6.  Sending and Receiving Data

    '
- title: 6.1.  Sending Data
  contents:
  - "6.1.  Sending Data\n   To _Send a WebSocket Message_ comprising of /data/ over\
    \ a WebSocket\n   connection, an endpoint MUST perform the following steps.\n\
    \   1.  The endpoint MUST ensure the WebSocket connection is in the OPEN\n   \
    \    state (cf. Sections 4.1 and 4.2.2.)  If at any point the state of\n     \
    \  the WebSocket connection changes, the endpoint MUST abort the\n       following\
    \ steps.\n   2.  An endpoint MUST encapsulate the /data/ in a WebSocket frame\
    \ as\n       defined in Section 5.2.  If the data to be sent is large or if\n\
    \       the data is not available in its entirety at the point the\n       endpoint\
    \ wishes to begin sending the data, the endpoint MAY\n       alternately encapsulate\
    \ the data in a series of frames as defined\n       in Section 5.4.\n   3.  The\
    \ opcode (frame-opcode) of the first frame containing the data\n       MUST be\
    \ set to the appropriate value from Section 5.2 for data\n       that is to be\
    \ interpreted by the recipient as text or binary\n       data.\n   4.  The FIN\
    \ bit (frame-fin) of the last frame containing the data\n       MUST be set to\
    \ 1 as defined in Section 5.2.\n   5.  If the data is being sent by the client,\
    \ the frame(s) MUST be\n       masked as defined in Section 5.3.\n   6.  If any\
    \ extensions (Section 9) have been negotiated for the\n       WebSocket connection,\
    \ additional considerations may apply as per\n       the definition of those extensions.\n\
    \   7.  The frame(s) that have been formed MUST be transmitted over the\n    \
    \   underlying network connection.\n"
- title: 6.2.  Receiving Data
  contents:
  - "6.2.  Receiving Data\n   To receive WebSocket data, an endpoint listens on the\
    \ underlying\n   network connection.  Incoming data MUST be parsed as WebSocket\
    \ frames\n   as defined in Section 5.2.  If a control frame (Section 5.5) is\n\
    \   received, the frame MUST be handled as defined by Section 5.5.  Upon\n   receiving\
    \ a data frame (Section 5.6), the endpoint MUST note the\n   /type/ of the data\
    \ as defined by the opcode (frame-opcode) from\n   Section 5.2.  The \"Application\
    \ data\" from this frame is defined as\n   the /data/ of the message.  If the\
    \ frame comprises an unfragmented\n   message (Section 5.4), it is said that _A\
    \ WebSocket Message Has Been\n   Received_ with type /type/ and data /data/. \
    \ If the frame is part of\n   a fragmented message, the \"Application data\" of\
    \ the subsequent data\n   frames is concatenated to form the /data/.  When the\
    \ last fragment is\n   received as indicated by the FIN bit (frame-fin), it is\
    \ said that _A\n   WebSocket Message Has Been Received_ with data /data/ (comprised\
    \ of\n   the concatenation of the \"Application data\" of the fragments) and\n\
    \   type /type/ (noted from the first frame of the fragmented message).\n   Subsequent\
    \ data frames MUST be interpreted as belonging to a new\n   WebSocket message.\n\
    \   Extensions (Section 9) MAY change the semantics of how data is read,\n   specifically\
    \ including what comprises a message boundary.\n   Extensions, in addition to\
    \ adding \"Extension data\" before the\n   \"Application data\" in a payload,\
    \ MAY also modify the \"Application\n   data\" (such as by compressing it).\n\
    \   A server MUST remove masking for data frames received from a client\n   as\
    \ described in Section 5.3.\n"
- title: 7.  Closing the Connection
  contents:
  - '7.  Closing the Connection

    '
- title: 7.1.  Definitions
  contents:
  - '7.1.  Definitions

    '
- title: 7.1.1.  Close the WebSocket Connection
  contents:
  - "7.1.1.  Close the WebSocket Connection\n   To _Close the WebSocket Connection_,\
    \ an endpoint closes the\n   underlying TCP connection.  An endpoint SHOULD use\
    \ a method that\n   cleanly closes the TCP connection, as well as the TLS session,\
    \ if\n   applicable, discarding any trailing bytes that may have been\n   received.\
    \  An endpoint MAY close the connection via any means\n   available when necessary,\
    \ such as when under attack.\n   The underlying TCP connection, in most normal\
    \ cases, SHOULD be closed\n   first by the server, so that it holds the TIME_WAIT\
    \ state and not the\n   client (as this would prevent it from re-opening the connection\
    \ for 2\n   maximum segment lifetimes (2MSL), while there is no corresponding\n\
    \   server impact as a TIME_WAIT connection is immediately reopened upon\n   a\
    \ new SYN with a higher seq number).  In abnormal cases (such as not\n   having\
    \ received a TCP Close from the server after a reasonable amount\n   of time)\
    \ a client MAY initiate the TCP Close.  As such, when a server\n   is instructed\
    \ to _Close the WebSocket Connection_ it SHOULD initiate\n   a TCP Close immediately,\
    \ and when a client is instructed to do the\n   same, it SHOULD wait for a TCP\
    \ Close from the server.\n   As an example of how to obtain a clean closure in\
    \ C using Berkeley\n   sockets, one would call shutdown() with SHUT_WR on the\
    \ socket, call\n   recv() until obtaining a return value of 0 indicating that\
    \ the peer\n   has also performed an orderly shutdown, and finally call close()\
    \ on\n   the socket.\n"
- title: 7.1.2.  Start the WebSocket Closing Handshake
  contents:
  - "7.1.2.  Start the WebSocket Closing Handshake\n   To _Start the WebSocket Closing\
    \ Handshake_ with a status code\n   (Section 7.4) /code/ and an optional close\
    \ reason (Section 7.1.6)\n   /reason/, an endpoint MUST send a Close control frame,\
    \ as described\n   in Section 5.5.1, whose status code is set to /code/ and whose\
    \ close\n   reason is set to /reason/.  Once an endpoint has both sent and\n \
    \  received a Close control frame, that endpoint SHOULD _Close the\n   WebSocket\
    \ Connection_ as defined in Section 7.1.1.\n"
- title: 7.1.3.  The WebSocket Closing Handshake is Started
  contents:
  - "7.1.3.  The WebSocket Closing Handshake is Started\n   Upon either sending or\
    \ receiving a Close control frame, it is said\n   that _The WebSocket Closing\
    \ Handshake is Started_ and that the\n   WebSocket connection is in the CLOSING\
    \ state.\n"
- title: 7.1.4.  The WebSocket Connection is Closed
  contents:
  - "7.1.4.  The WebSocket Connection is Closed\n   When the underlying TCP connection\
    \ is closed, it is said that _The\n   WebSocket Connection is Closed_ and that\
    \ the WebSocket connection is\n   in the CLOSED state.  If the TCP connection\
    \ was closed after the\n   WebSocket closing handshake was completed, the WebSocket\
    \ connection\n   is said to have been closed _cleanly_.\n   If the WebSocket connection\
    \ could not be established, it is also said\n   that _The WebSocket Connection\
    \ is Closed_, but not _cleanly_.\n"
- title: 7.1.5.  The WebSocket Connection Close Code
  contents:
  - "7.1.5.  The WebSocket Connection Close Code\n   As defined in Sections 5.5.1\
    \ and 7.4, a Close control frame may\n   contain a status code indicating a reason\
    \ for closure.  A closing of\n   the WebSocket connection may be initiated by\
    \ either endpoint,\n   potentially simultaneously. _The WebSocket Connection Close\
    \ Code_ is\n   defined as the status code (Section 7.4) contained in the first\
    \ Close\n   control frame received by the application implementing this protocol.\n\
    \   If this Close control frame contains no status code, _The WebSocket\n   Connection\
    \ Close Code_ is considered to be 1005.  If _The WebSocket\n   Connection is Closed_\
    \ and no Close control frame was received by the\n   endpoint (such as could occur\
    \ if the underlying transport connection\n   is lost), _The WebSocket Connection\
    \ Close Code_ is considered to be\n   1006.\n   NOTE: Two endpoints may not agree\
    \ on the value of _The WebSocket\n   Connection Close Code_.  As an example, if\
    \ the remote endpoint sent a\n   Close frame but the local application has not\
    \ yet read the data\n   containing the Close frame from its socket's receive buffer,\
    \ and the\n   local application independently decided to close the connection\
    \ and\n   send a Close frame, both endpoints will have sent and received a\n \
    \  Close frame and will not send further Close frames.  Each endpoint\n   will\
    \ see the status code sent by the other end as _The WebSocket\n   Connection Close\
    \ Code_.  As such, it is possible that the two\n   endpoints may not agree on\
    \ the value of _The WebSocket Connection\n   Close Code_ in the case that both\
    \ endpoints _Start the WebSocket\n   Closing Handshake_ independently and at roughly\
    \ the same time.\n"
- title: 7.1.6.  The WebSocket Connection Close Reason
  contents:
  - "7.1.6.  The WebSocket Connection Close Reason\n   As defined in Sections 5.5.1\
    \ and 7.4, a Close control frame may\n   contain a status code indicating a reason\
    \ for closure, followed by\n   UTF-8-encoded data, the interpretation of said\
    \ data being left to the\n   endpoints and not defined by this protocol.  A closing\
    \ of the\n   WebSocket connection may be initiated by either endpoint, potentially\n\
    \   simultaneously. _The WebSocket Connection Close Reason_ is defined as\n  \
    \ the UTF-8-encoded data following the status code (Section 7.4)\n   contained\
    \ in the first Close control frame received by the\n   application implementing\
    \ this protocol.  If there is no such data in\n   the Close control frame, _The\
    \ WebSocket Connection Close Reason_ is\n   the empty string.\n   NOTE: Following\
    \ the same logic as noted in Section 7.1.5, two\n   endpoints may not agree on\
    \ _The WebSocket Connection Close Reason_.\n"
- title: 7.1.7.  Fail the WebSocket Connection
  contents:
  - "7.1.7.  Fail the WebSocket Connection\n   Certain algorithms and specifications\
    \ require an endpoint to _Fail\n   the WebSocket Connection_.  To do so, the client\
    \ MUST _Close the\n   WebSocket Connection_, and MAY report the problem to the\
    \ user (which\n   would be especially useful for developers) in an appropriate\
    \ manner.\n   Similarly, to do so, the server MUST _Close the WebSocket\n   Connection_,\
    \ and SHOULD log the problem.\n   If _The WebSocket Connection is Established_\
    \ prior to the point where\n   the endpoint is required to _Fail the WebSocket\
    \ Connection_, the\n   endpoint SHOULD send a Close frame with an appropriate\
    \ status code\n   (Section 7.4) before proceeding to _Close the WebSocket Connection_.\n\
    \   An endpoint MAY omit sending a Close frame if it believes the other\n   side\
    \ is unlikely to be able to receive and process the Close frame,\n   due to the\
    \ nature of the error that led the WebSocket connection to\n   fail in the first\
    \ place.  An endpoint MUST NOT continue to attempt to\n   process data (including\
    \ a responding Close frame) from the remote\n   endpoint after being instructed\
    \ to _Fail the WebSocket Connection_.\n   Except as indicated above or as specified\
    \ by the application layer\n   (e.g., a script using the WebSocket API), clients\
    \ SHOULD NOT close\n   the connection.\n"
- title: 7.2.  Abnormal Closures
  contents:
  - '7.2.  Abnormal Closures

    '
- title: 7.2.1.  Client-Initiated Closure
  contents:
  - "7.2.1.  Client-Initiated Closure\n   Certain algorithms, in particular during\
    \ the opening handshake,\n   require the client to _Fail the WebSocket Connection_.\
    \  To do so, the\n   client MUST _Fail the WebSocket Connection_ as defined in\n\
    \   Section 7.1.7.\n   If at any point the underlying transport layer connection\
    \ is\n   unexpectedly lost, the client MUST _Fail the WebSocket Connection_.\n\
    \   Except as indicated above or as specified by the application layer\n   (e.g.,\
    \ a script using the WebSocket API), clients SHOULD NOT close\n   the connection.\n"
- title: 7.2.2.  Server-Initiated Closure
  contents:
  - "7.2.2.  Server-Initiated Closure\n   Certain algorithms require or recommend\
    \ that the server _Abort the\n   WebSocket Connection_ during the opening handshake.\
    \  To do so, the\n   server MUST simply _Close the WebSocket Connection_ (Section\
    \ 7.1.1).\n"
- title: 7.2.3.  Recovering from Abnormal Closure
  contents:
  - "7.2.3.  Recovering from Abnormal Closure\n   Abnormal closures may be caused\
    \ by any number of reasons.  Such\n   closures could be the result of a transient\
    \ error, in which case\n   reconnecting may lead to a good connection and a resumption\
    \ of normal\n   operations.  Such closures may also be the result of a nontransient\n\
    \   problem, in which case if each deployed client experiences an\n   abnormal\
    \ closure and immediately and persistently tries to reconnect,\n   the server\
    \ may experience what amounts to a denial-of-service attack\n   by a large number\
    \ of clients trying to reconnect.  The end result of\n   such a scenario could\
    \ be that the service is unable to recover in a\n   timely manner or recovery\
    \ is made much more difficult.\n   To prevent this, clients SHOULD use some form\
    \ of backoff when trying\n   to reconnect after abnormal closures as described\
    \ in this section.\n   The first reconnect attempt SHOULD be delayed by a random\
    \ amount of\n   time.  The parameters by which this random delay is chosen are\
    \ left\n   to the client to decide; a value chosen randomly between 0 and 5\n\
    \   seconds is a reasonable initial delay though clients MAY choose a\n   different\
    \ interval from which to select a delay length based on\n   implementation experience\
    \ and particular application.\n   Should the first reconnect attempt fail, subsequent\
    \ reconnect\n   attempts SHOULD be delayed by increasingly longer amounts of time,\n\
    \   using a method such as truncated binary exponential backoff.\n"
- title: 7.3.  Normal Closure of Connections
  contents:
  - "7.3.  Normal Closure of Connections\n   Servers MAY close the WebSocket connection\
    \ whenever desired.  Clients\n   SHOULD NOT close the WebSocket connection arbitrarily.\
    \  In either\n   case, an endpoint initiates a closure by following the procedures\
    \ to\n   _Start the WebSocket Closing Handshake_ (Section 7.1.2).\n"
- title: 7.4.  Status Codes
  contents:
  - "7.4.  Status Codes\n   When closing an established connection (e.g., when sending\
    \ a Close\n   frame, after the opening handshake has completed), an endpoint MAY\n\
    \   indicate a reason for closure.  The interpretation of this reason by\n   an\
    \ endpoint, and the action an endpoint should take given this\n   reason, are\
    \ left undefined by this specification.  This specification\n   defines a set\
    \ of pre-defined status codes and specifies which ranges\n   may be used by extensions,\
    \ frameworks, and end applications.  The\n   status code and any associated textual\
    \ message are optional\n   components of a Close frame.\n"
- title: 7.4.1.  Defined Status Codes
  contents:
  - "7.4.1.  Defined Status Codes\n   Endpoints MAY use the following pre-defined\
    \ status codes when sending\n   a Close frame.\n   1000\n      1000 indicates\
    \ a normal closure, meaning that the purpose for\n      which the connection was\
    \ established has been fulfilled.\n   1001\n      1001 indicates that an endpoint\
    \ is \"going away\", such as a server\n      going down or a browser having navigated\
    \ away from a page.\n   1002\n      1002 indicates that an endpoint is terminating\
    \ the connection due\n      to a protocol error.\n   1003\n      1003 indicates\
    \ that an endpoint is terminating the connection\n      because it has received\
    \ a type of data it cannot accept (e.g., an\n      endpoint that understands only\
    \ text data MAY send this if it\n      receives a binary message).\n   1004\n\
    \      Reserved.  The specific meaning might be defined in the future.\n   1005\n\
    \      1005 is a reserved value and MUST NOT be set as a status code in a\n  \
    \    Close control frame by an endpoint.  It is designated for use in\n      applications\
    \ expecting a status code to indicate that no status\n      code was actually\
    \ present.\n   1006\n      1006 is a reserved value and MUST NOT be set as a status\
    \ code in a\n      Close control frame by an endpoint.  It is designated for use\
    \ in\n      applications expecting a status code to indicate that the\n      connection\
    \ was closed abnormally, e.g., without sending or\n      receiving a Close control\
    \ frame.\n   1007\n      1007 indicates that an endpoint is terminating the connection\n\
    \      because it has received data within a message that was not\n      consistent\
    \ with the type of the message (e.g., non-UTF-8 [RFC3629]\n      data within a\
    \ text message).\n   1008\n      1008 indicates that an endpoint is terminating\
    \ the connection\n      because it has received a message that violates its policy.\
    \  This\n      is a generic status code that can be returned when there is no\n\
    \      other more suitable status code (e.g., 1003 or 1009) or if there\n    \
    \  is a need to hide specific details about the policy.\n   1009\n      1009 indicates\
    \ that an endpoint is terminating the connection\n      because it has received\
    \ a message that is too big for it to\n      process.\n   1010\n      1010 indicates\
    \ that an endpoint (client) is terminating the\n      connection because it has\
    \ expected the server to negotiate one or\n      more extension, but the server\
    \ didn't return them in the response\n      message of the WebSocket handshake.\
    \  The list of extensions that\n      are needed SHOULD appear in the /reason/\
    \ part of the Close frame.\n      Note that this status code is not used by the\
    \ server, because it\n      can fail the WebSocket handshake instead.\n   1011\n\
    \      1011 indicates that a server is terminating the connection because\n  \
    \    it encountered an unexpected condition that prevented it from\n      fulfilling\
    \ the request.\n   1015\n      1015 is a reserved value and MUST NOT be set as\
    \ a status code in a\n      Close control frame by an endpoint.  It is designated\
    \ for use in\n      applications expecting a status code to indicate that the\n\
    \      connection was closed due to a failure to perform a TLS handshake\n   \
    \   (e.g., the server certificate can't be verified).\n"
- title: 7.4.2.  Reserved Status Code Ranges
  contents:
  - "7.4.2.  Reserved Status Code Ranges\n   0-999\n      Status codes in the range\
    \ 0-999 are not used.\n   1000-2999\n      Status codes in the range 1000-2999\
    \ are reserved for definition by\n      this protocol, its future revisions, and\
    \ extensions specified in a\n      permanent and readily available public specification.\n\
    \   3000-3999\n      Status codes in the range 3000-3999 are reserved for use\
    \ by\n      libraries, frameworks, and applications.  These status codes are\n\
    \      registered directly with IANA.  The interpretation of these codes\n   \
    \   is undefined by this protocol.\n   4000-4999\n      Status codes in the range\
    \ 4000-4999 are reserved for private use\n      and thus can't be registered.\
    \  Such codes can be used by prior\n      agreements between WebSocket applications.\
    \  The interpretation of\n      these codes is undefined by this protocol.\n"
- title: 8.  Error Handling
  contents:
  - '8.  Error Handling

    '
- title: 8.1.  Handling Errors in UTF-8-Encoded Data
  contents:
  - "8.1.  Handling Errors in UTF-8-Encoded Data\n   When an endpoint is to interpret\
    \ a byte stream as UTF-8 but finds\n   that the byte stream is not, in fact, a\
    \ valid UTF-8 stream, that\n   endpoint MUST _Fail the WebSocket Connection_.\
    \  This rule applies\n   both during the opening handshake and during subsequent\
    \ data\n   exchange.\n"
- title: 9.  Extensions
  contents:
  - "9.  Extensions\n   WebSocket clients MAY request extensions to this specification,\
    \ and\n   WebSocket servers MAY accept some or all extensions requested by the\n\
    \   client.  A server MUST NOT respond with any extension not requested\n   by\
    \ the client.  If extension parameters are included in negotiations\n   between\
    \ the client and the server, those parameters MUST be chosen in\n   accordance\
    \ with the specification of the extension to which the\n   parameters apply.\n"
- title: 9.1.  Negotiating Extensions
  contents:
  - "9.1.  Negotiating Extensions\n   A client requests extensions by including a\
    \ |Sec-WebSocket-\n   Extensions| header field, which follows the normal rules\
    \ for HTTP\n   header fields (see [RFC2616], Section 4.2) and the value of the\n\
    \   header field is defined by the following ABNF [RFC2616].  Note that\n   this\
    \ section is using ABNF syntax/rules from [RFC2616], including the\n   \"implied\
    \ *LWS rule\".  If a value is received by either the client or\n   the server\
    \ during negotiation that does not conform to the ABNF\n   below, the recipient\
    \ of such malformed data MUST immediately _Fail\n   the WebSocket Connection_.\n\
    \         Sec-WebSocket-Extensions = extension-list\n         extension-list =\
    \ 1#extension\n         extension = extension-token *( \";\" extension-param )\n\
    \         extension-token = registered-token\n         registered-token = token\n\
    \         extension-param = token [ \"=\" (token | quoted-string) ]\n        \
    \     ;When using the quoted-string syntax variant, the value\n             ;after\
    \ quoted-string unescaping MUST conform to the\n             ;'token' ABNF.\n\
    \   Note that like other HTTP header fields, this header field MAY be\n   split\
    \ or combined across multiple lines.  Ergo, the following are\n   equivalent:\n\
    \         Sec-WebSocket-Extensions: foo\n         Sec-WebSocket-Extensions: bar;\
    \ baz=2\n   is exactly equivalent to\n         Sec-WebSocket-Extensions: foo,\
    \ bar; baz=2\n   Any extension-token used MUST be a registered token (see\n  \
    \ Section 11.4).  The parameters supplied with any given extension MUST\n   be\
    \ defined for that extension.  Note that the client is only offering\n   to use\
    \ any advertised extensions and MUST NOT use them unless the\n   server indicates\
    \ that it wishes to use the extension.\n   Note that the order of extensions is\
    \ significant.  Any interactions\n   between multiple extensions MAY be defined\
    \ in the documents defining\n   the extensions.  In the absence of such definitions,\
    \ the\n   interpretation is that the header fields listed by the client in its\n\
    \   request represent a preference of the header fields it wishes to use,\n  \
    \ with the first options listed being most preferable.  The extensions\n   listed\
    \ by the server in response represent the extensions actually in\n   use for the\
    \ connection.  Should the extensions modify the data and/or\n   framing, the order\
    \ of operations on the data should be assumed to be\n   the same as the order\
    \ in which the extensions are listed in the\n   server's response in the opening\
    \ handshake.\n   For example, if there are two extensions \"foo\" and \"bar\"\
    \ and if the\n   header field |Sec-WebSocket-Extensions| sent by the server has\
    \ the\n   value \"foo, bar\", then operations on the data will be made as\n  \
    \ bar(foo(data)), be those changes to the data itself (such as\n   compression)\
    \ or changes to the framing that may \"stack\".\n   Non-normative examples of\
    \ acceptable extension header fields (note\n   that long lines are folded for\
    \ readability):\n         Sec-WebSocket-Extensions: deflate-stream\n         Sec-WebSocket-Extensions:\
    \ mux; max-channels=4; flow-control,\n          deflate-stream\n         Sec-WebSocket-Extensions:\
    \ private-extension\n   A server accepts one or more extensions by including a\n\
    \   |Sec-WebSocket-Extensions| header field containing one or more\n   extensions\
    \ that were requested by the client.  The interpretation of\n   any extension\
    \ parameters, and what constitutes a valid response by a\n   server to a requested\
    \ set of parameters by a client, will be defined\n   by each such extension.\n"
- title: 9.2.  Known Extensions
  contents:
  - "9.2.  Known Extensions\n   Extensions provide a mechanism for implementations\
    \ to opt-in to\n   additional protocol features.  This document doesn't define\
    \ any\n   extension, but implementations MAY use extensions defined separately.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   This section describes some security considerations\
    \ applicable to the\n   WebSocket Protocol.  Specific security considerations\
    \ are described\n   in subsections of this section.\n"
- title: 10.1.  Non-Browser Clients
  contents:
  - "10.1.  Non-Browser Clients\n   The WebSocket Protocol protects against malicious\
    \ JavaScript running\n   inside a trusted application such as a web browser, for\
    \ example, by\n   checking of the |Origin| header field (see below).  See Section\
    \ 1.6\n   for additional details.  Such assumptions don't hold true in the case\n\
    \   of a more-capable client.\n   While this protocol is intended to be used by\
    \ scripts in web pages,\n   it can also be used directly by hosts.  Such hosts\
    \ are acting on\n   their own behalf and can therefore send fake |Origin| header\
    \ fields,\n   misleading the server.  Servers should therefore be careful about\n\
    \   assuming that they are talking directly to scripts from known origins\n  \
    \ and must consider that they might be accessed in unexpected ways.  In\n   particular,\
    \ a server should not trust that any input is valid.\n   EXAMPLE: If the server\
    \ uses input as part of SQL queries, all input\n   text should be escaped before\
    \ being passed to the SQL server, lest\n   the server be susceptible to SQL injection.\n"
- title: 10.2.  Origin Considerations
  contents:
  - "10.2.  Origin Considerations\n   Servers that are not intended to process input\
    \ from any web page but\n   only for certain sites SHOULD verify the |Origin|\
    \ field is an origin\n   they expect.  If the origin indicated is unacceptable\
    \ to the server,\n   then it SHOULD respond to the WebSocket handshake with a\
    \ reply\n   containing HTTP 403 Forbidden status code.\n   The |Origin| header\
    \ field protects from the attack cases when the\n   untrusted party is typically\
    \ the author of a JavaScript application\n   that is executing in the context\
    \ of the trusted client.  The client\n   itself can contact the server and, via\
    \ the mechanism of the |Origin|\n   header field, determine whether to extend\
    \ those communication\n   privileges to the JavaScript application.  The intent\
    \ is not to\n   prevent non-browsers from establishing connections but rather\
    \ to\n   ensure that trusted browsers under the control of potentially\n   malicious\
    \ JavaScript cannot fake a WebSocket handshake.\n"
- title: 10.3.  Attacks On Infrastructure (Masking)
  contents:
  - "10.3.  Attacks On Infrastructure (Masking)\n   In addition to endpoints being\
    \ the target of attacks via WebSockets,\n   other parts of web infrastructure,\
    \ such as proxies, may be the\n   subject of an attack.\n   As this protocol was\
    \ being developed, an experiment was conducted to\n   demonstrate a class of attacks\
    \ on proxies that led to the poisoning\n   of caching proxies deployed in the\
    \ wild [TALKING].  The general form\n   of the attack was to establish a connection\
    \ to a server under the\n   \"attacker's\" control, perform an UPGRADE on the\
    \ HTTP connection\n   similar to what the WebSocket Protocol does to establish\
    \ a\n   connection, and subsequently send data over that UPGRADEd connection\n\
    \   that looked like a GET request for a specific known resource (which\n   in\
    \ an attack would likely be something like a widely deployed script\n   for tracking\
    \ hits or a resource on an ad-serving network).  The\n   remote server would respond\
    \ with something that looked like a\n   response to the fake GET request, and\
    \ this response would be cached\n   by a nonzero percentage of deployed intermediaries,\
    \ thus poisoning\n   the cache.  The net effect of this attack would be that if\
    \ a user\n   could be convinced to visit a website the attacker controlled, the\n\
    \   attacker could potentially poison the cache for that user and other\n   users\
    \ behind the same cache and run malicious script on other\n   origins, compromising\
    \ the web security model.\n   To avoid such attacks on deployed intermediaries,\
    \ it is not\n   sufficient to prefix application-supplied data with framing that\
    \ is\n   not compliant with HTTP, as it is not possible to exhaustively\n   discover\
    \ and test that each nonconformant intermediary does not skip\n   such non-HTTP\
    \ framing and act incorrectly on the frame payload.\n   Thus, the defense adopted\
    \ is to mask all data from the client to the\n   server, so that the remote script\
    \ (attacker) does not have control\n   over how the data being sent appears on\
    \ the wire and thus cannot\n   construct a message that could be misinterpreted\
    \ by an intermediary\n   as an HTTP request.\n   Clients MUST choose a new masking\
    \ key for each frame, using an\n   algorithm that cannot be predicted by end applications\
    \ that provide\n   data.  For example, each masking could be drawn from a\n  \
    \ cryptographically strong random number generator.  If the same key is\n   used\
    \ or a decipherable pattern exists for how the next key is chosen,\n   the attacker\
    \ can send a message that, when masked, could appear to be\n   an HTTP request\
    \ (by taking the message the attacker wishes to see on\n   the wire and masking\
    \ it with the next masking key to be used, the\n   masking key will effectively\
    \ unmask the data when the client applies\n   it).\n   It is also necessary that\
    \ once the transmission of a frame from a\n   client has begun, the payload (application-supplied\
    \ data) of that\n   frame must not be capable of being modified by the application.\n\
    \   Otherwise, an attacker could send a long frame where the initial data\n  \
    \ was a known value (such as all zeros), compute the masking key being\n   used\
    \ upon receipt of the first part of the data, and then modify the\n   data that\
    \ is yet to be sent in the frame to appear as an HTTP request\n   when masked.\
    \  (This is essentially the same problem described in the\n   previous paragraph\
    \ with using a known or predictable masking key.)\n   If additional data is to\
    \ be sent or data to be sent is somehow\n   changed, that new or changed data\
    \ must be sent in a new frame and\n   thus with a new masking key.  In short,\
    \ once transmission of a frame\n   begins, the contents must not be modifiable\
    \ by the remote script\n   (application).\n   The threat model being protected\
    \ against is one in which the client\n   sends data that appears to be an HTTP\
    \ request.  As such, the channel\n   that needs to be masked is the data from\
    \ the client to the server.\n   The data from the server to the client can be\
    \ made to look like a\n   response, but to accomplish this request, the client\
    \ must also be\n   able to forge a request.  As such, it was not deemed necessary\
    \ to\n   mask data in both directions (the data from the server to the client\n\
    \   is not masked).\n   Despite the protection provided by masking, non-compliant\
    \ HTTP\n   proxies will still be vulnerable to poisoning attacks of this type\
    \ by\n   clients and servers that do not apply masking.\n"
- title: 10.4.  Implementation-Specific Limits
  contents:
  - "10.4.  Implementation-Specific Limits\n   Implementations that have implementation-\
    \ and/or platform-specific\n   limitations regarding the frame size or total message\
    \ size after\n   reassembly from multiple frames MUST protect themselves against\n\
    \   exceeding those limits.  (For example, a malicious endpoint can try\n   to\
    \ exhaust its peer's memory or mount a denial-of-service attack by\n   sending\
    \ either a single big frame (e.g., of size 2**60) or by sending\n   a long stream\
    \ of small frames that are a part of a fragmented\n   message.)  Such an implementation\
    \ SHOULD impose a limit on frame\n   sizes and the total message size after reassembly\
    \ from multiple\n   frames.\n"
- title: 10.5.  WebSocket Client Authentication
  contents:
  - "10.5.  WebSocket Client Authentication\n   This protocol doesn't prescribe any\
    \ particular way that servers can\n   authenticate clients during the WebSocket\
    \ handshake.  The WebSocket\n   server can use any client authentication mechanism\
    \ available to a\n   generic HTTP server, such as cookies, HTTP authentication,\
    \ or TLS\n   authentication.\n"
- title: 10.6.  Connection Confidentiality and Integrity
  contents:
  - "10.6.  Connection Confidentiality and Integrity\n   Connection confidentiality\
    \ and integrity is provided by running the\n   WebSocket Protocol over TLS (wss\
    \ URIs).  WebSocket implementations\n   MUST support TLS and SHOULD employ it\
    \ when communicating with their\n   peers.\n   For connections using TLS, the\
    \ amount of benefit provided by TLS\n   depends greatly on the strength of the\
    \ algorithms negotiated during\n   the TLS handshake.  For example, some TLS cipher\
    \ mechanisms don't\n   provide connection confidentiality.  To achieve reasonable\
    \ levels of\n   protection, clients should use only Strong TLS algorithms.  \"\
    Web\n   Security Context: User Interface Guidelines\"\n   [W3C.REC-wsc-ui-20100812]\
    \ discusses what constitutes Strong TLS\n   algorithms.  [RFC5246] provides additional\
    \ guidance in Appendix A.5\n   and Appendix D.3.\n"
- title: 10.7.  Handling of Invalid Data
  contents:
  - "10.7.  Handling of Invalid Data\n   Incoming data MUST always be validated by\
    \ both clients and servers.\n   If, at any time, an endpoint is faced with data\
    \ that it does not\n   understand or that violates some criteria by which the\
    \ endpoint\n   determines safety of input, or when the endpoint sees an opening\n\
    \   handshake that does not correspond to the values it is expecting\n   (e.g.,\
    \ incorrect path or origin in the client request), the endpoint\n   MAY drop the\
    \ TCP connection.  If the invalid data was received after\n   a successful WebSocket\
    \ handshake, the endpoint SHOULD send a Close\n   frame with an appropriate status\
    \ code (Section 7.4) before proceeding\n   to _Close the WebSocket Connection_.\
    \  Use of a Close frame with an\n   appropriate status code can help in diagnosing\
    \ the problem.  If the\n   invalid data is sent during the WebSocket handshake,\
    \ the server\n   SHOULD return an appropriate HTTP [RFC2616] status code.\n  \
    \ A common class of security problems arises when sending text data\n   using\
    \ the wrong encoding.  This protocol specifies that messages with\n   a Text data\
    \ type (as opposed to Binary or other types) contain UTF-8-\n   encoded data.\
    \  Although the length is still indicated and\n   applications implementing this\
    \ protocol should use the length to\n   determine where the frame actually ends,\
    \ sending data in an improper\n   encoding may still break assumptions that applications\
    \ built on top\n   of this protocol may make, leading to anything from misinterpretation\n\
    \   of data to loss of data or potential security bugs.\n"
- title: 10.8.  Use of SHA-1 by the WebSocket Handshake
  contents:
  - "10.8.  Use of SHA-1 by the WebSocket Handshake\n   The WebSocket handshake described\
    \ in this document doesn't depend on\n   any security properties of SHA-1, such\
    \ as collision resistance or\n   resistance to the second pre-image attack (as\
    \ described in\n   [RFC4270]).\n"
- title: 11.  IANA Considerations
  contents:
  - '11.  IANA Considerations

    '
- title: 11.1.  Registration of New URI Schemes
  contents:
  - '11.1.  Registration of New URI Schemes

    '
- title: 11.1.1.  Registration of "ws" Scheme
  contents:
  - "11.1.1.  Registration of \"ws\" Scheme\n   A |ws| URI identifies a WebSocket\
    \ server and resource name.\n   URI scheme name\n      ws\n   Status\n      Permanent\n\
    \   URI scheme syntax\n      Using the ABNF [RFC5234] syntax and ABNF terminals\
    \ from the URI\n      specification [RFC3986]:\n           \"ws:\" \"//\" authority\
    \ path-abempty [ \"?\" query ]\n   The <path-abempty> and <query> [RFC3986] components\
    \ form the resource\n   name sent to the server to identify the kind of service\
    \ desired.\n   Other components have the meanings described in [RFC3986].\n  \
    \ URI scheme semantics\n      The only operation for this scheme is to open a\
    \ connection using\n      the WebSocket Protocol.\n   Encoding considerations\n\
    \      Characters in the host component that are excluded by the syntax\n    \
    \  defined above MUST be converted from Unicode to ASCII as specified\n      in\
    \ [RFC3987] or its replacement.  For the purposes of scheme-based\n      normalization,\
    \ Internationalized Domain Name (IDN) forms of the\n      host component and their\
    \ conversions to punycode are considered\n      equivalent (see Section 5.3.3\
    \ of [RFC3987]).\n      Characters in other components that are excluded by the\
    \ syntax\n      defined above MUST be converted from Unicode to ASCII by first\n\
    \      encoding the characters as UTF-8 and then replacing the\n      corresponding\
    \ bytes using their percent-encoded form as defined in\n      the URI [RFC3986]\
    \ and Internationalized Resource Identifier (IRI)\n      [RFC3987] specifications.\n\
    \   Applications/protocols that use this URI scheme name\n      WebSocket Protocol\n\
    \   Interoperability considerations\n      Use of WebSocket requires use of HTTP\
    \ version 1.1 or higher.\n   Security considerations\n      See \"Security Considerations\"\
    \ section.\n   Contact\n      HYBI WG <hybi@ietf.org>\n   Author/Change controller\n\
    \      IETF <iesg@ietf.org>\n   References\n      RFC 6455\n"
- title: 11.1.2.  Registration of "wss" Scheme
  contents:
  - "11.1.2.  Registration of \"wss\" Scheme\n   A |wss| URI identifies a WebSocket\
    \ server and resource name and\n   indicates that traffic over that connection\
    \ is to be protected via\n   TLS (including standard benefits of TLS such as data\
    \ confidentiality\n   and integrity and endpoint authentication).\n   URI scheme\
    \ name\n      wss\n   Status\n      Permanent\n   URI scheme syntax\n      Using\
    \ the ABNF [RFC5234] syntax and ABNF terminals from the URI\n      specification\
    \ [RFC3986]:\n           \"wss:\" \"//\" authority path-abempty [ \"?\" query\
    \ ]\n   The <path-abempty> and <query> components form the resource name sent\n\
    \   to the server to identify the kind of service desired.  Other\n   components\
    \ have the meanings described in [RFC3986].\n   URI scheme semantics\n      The\
    \ only operation for this scheme is to open a connection using\n      the WebSocket\
    \ Protocol, encrypted using TLS.\n   Encoding considerations\n      Characters\
    \ in the host component that are excluded by the syntax\n      defined above MUST\
    \ be converted from Unicode to ASCII as specified\n      in [RFC3987] or its replacement.\
    \  For the purposes of scheme-based\n      normalization IDN forms of the host\
    \ component and their\n      conversions to punycode are considered equivalent\
    \ (see Section\n      5.3.3 of [RFC3987]).\n      Characters in other components\
    \ that are excluded by the syntax\n      defined above MUST be converted from\
    \ Unicode to ASCII by first\n      encoding the characters as UTF-8 and then replacing\
    \ the\n      corresponding bytes using their percent-encoded form as defined in\n\
    \      the URI [RFC3986] and IRI [RFC3987] specifications.\n   Applications/protocols\
    \ that use this URI scheme name\n      WebSocket Protocol over TLS\n   Interoperability\
    \ considerations\n      Use of WebSocket requires use of HTTP version 1.1 or higher.\n\
    \   Security considerations\n      See \"Security Considerations\" section.\n\
    \   Contact\n      HYBI WG <hybi@ietf.org>\n   Author/Change controller\n    \
    \  IETF <iesg@ietf.org>\n   References\n      RFC 6455\n"
- title: 11.2.  Registration of the "WebSocket" HTTP Upgrade Keyword
  contents:
  - "11.2.  Registration of the \"WebSocket\" HTTP Upgrade Keyword\n   This section\
    \ defines a keyword registered in the HTTP Upgrade Tokens\n   Registry as per\
    \ RFC 2817 [RFC2817].\n   Name of token\n      WebSocket\n   Author/Change controller\n\
    \      IETF <iesg@ietf.org>\n   Contact\n      HYBI <hybi@ietf.org>\n   References\n\
    \      RFC 6455\n"
- title: 11.3.  Registration of New HTTP Header Fields
  contents:
  - '11.3.  Registration of New HTTP Header Fields

    '
- title: 11.3.1.  Sec-WebSocket-Key
  contents:
  - "11.3.1.  Sec-WebSocket-Key\n   This section describes a header field registered\
    \ in the Permanent\n   Message Header Field Names registry [RFC3864].\n   Header\
    \ field name\n      Sec-WebSocket-Key\n   Applicable protocol\n      http\n  \
    \ Status\n      standard\n   Author/Change controller\n      IETF\n   Specification\
    \ document(s)\n      RFC 6455\n   Related information\n      This header field\
    \ is only used for WebSocket opening handshake.\n   The |Sec-WebSocket-Key| header\
    \ field is used in the WebSocket opening\n   handshake.  It is sent from the client\
    \ to the server to provide part\n   of the information used by the server to prove\
    \ that it received a\n   valid WebSocket opening handshake.  This helps ensure\
    \ that the server\n   does not accept connections from non-WebSocket clients (e.g.,\
    \ HTTP\n   clients) that are being abused to send data to unsuspecting WebSocket\n\
    \   servers.\n   The |Sec-WebSocket-Key| header field MUST NOT appear more than\
    \ once\n   in an HTTP request.\n"
- title: 11.3.2.  Sec-WebSocket-Extensions
  contents:
  - "11.3.2.  Sec-WebSocket-Extensions\n   This section describes a header field for\
    \ registration in the\n   Permanent Message Header Field Names registry [RFC3864].\n\
    \   Header field name\n      Sec-WebSocket-Extensions\n   Applicable protocol\n\
    \      http\n   Status\n      standard\n   Author/Change controller\n      IETF\n\
    \   Specification document(s)\n      RFC 6455\n   Related information\n      This\
    \ header field is only used for WebSocket opening handshake.\n   The |Sec-WebSocket-Extensions|\
    \ header field is used in the WebSocket\n   opening handshake.  It is initially\
    \ sent from the client to the\n   server, and then subsequently sent from the\
    \ server to the client, to\n   agree on a set of protocol-level extensions to\
    \ use for the duration\n   of the connection.\n   The |Sec-WebSocket-Extensions|\
    \ header field MAY appear multiple times\n   in an HTTP request (which is logically\
    \ the same as a single\n   |Sec-WebSocket-Extensions| header field that contains\
    \ all values.\n   However, the |Sec-WebSocket-Extensions| header field MUST NOT\
    \ appear\n   more than once in an HTTP response.\n"
- title: 11.3.3.  Sec-WebSocket-Accept
  contents:
  - "11.3.3.  Sec-WebSocket-Accept\n   This section describes a header field registered\
    \ in the Permanent\n   Message Header Field Names registry [RFC3864].\n   Header\
    \ field name\n      Sec-WebSocket-Accept\n   Applicable protocol\n      http\n\
    \   Status\n      standard\n   Author/Change controller\n      IETF\n   Specification\
    \ document(s)\n      RFC 6455\n   Related information\n      This header field\
    \ is only used for the WebSocket opening\n      handshake.\n   The |Sec-WebSocket-Accept|\
    \ header field is used in the WebSocket\n   opening handshake.  It is sent from\
    \ the server to the client to\n   confirm that the server is willing to initiate\
    \ the WebSocket\n   connection.\n   The |Sec-WebSocket-Accept| header MUST NOT\
    \ appear more than once in\n   an HTTP response.\n"
- title: 11.3.4.  Sec-WebSocket-Protocol
  contents:
  - "11.3.4.  Sec-WebSocket-Protocol\n   This section describes a header field registered\
    \ in the Permanent\n   Message Header Field Names registry [RFC3864].\n   Header\
    \ field name\n      Sec-WebSocket-Protocol\n   Applicable protocol\n      http\n\
    \   Status\n      standard\n   Author/Change controller\n      IETF\n   Specification\
    \ document(s)\n      RFC 6455\n   Related information\n      This header field\
    \ is only used for the WebSocket opening\n      handshake.\n   The |Sec-WebSocket-Protocol|\
    \ header field is used in the WebSocket\n   opening handshake.  It is sent from\
    \ the client to the server and back\n   from the server to the client to confirm\
    \ the subprotocol of the\n   connection.  This enables scripts to both select\
    \ a subprotocol and be\n   sure that the server agreed to serve that subprotocol.\n\
    \   The |Sec-WebSocket-Protocol| header field MAY appear multiple times\n   in\
    \ an HTTP request (which is logically the same as a single\n   |Sec-WebSocket-Protocol|\
    \ header field that contains all values).\n   However, the |Sec-WebSocket-Protocol|\
    \ header field MUST NOT appear\n   more than once in an HTTP response.\n"
- title: 11.3.5.  Sec-WebSocket-Version
  contents:
  - "11.3.5.  Sec-WebSocket-Version\n   This section describes a header field registered\
    \ in the Permanent\n   Message Header Field Names registry [RFC3864].\n   Header\
    \ field name\n      Sec-WebSocket-Version\n   Applicable protocol\n      http\n\
    \   Status\n      standard\n   Author/Change controller\n      IETF\n   Specification\
    \ document(s)\n      RFC 6455\n   Related information\n      This header field\
    \ is only used for the WebSocket opening\n      handshake.\n   The |Sec-WebSocket-Version|\
    \ header field is used in the WebSocket\n   opening handshake.  It is sent from\
    \ the client to the server to\n   indicate the protocol version of the connection.\
    \  This enables\n   servers to correctly interpret the opening handshake and subsequent\n\
    \   data being sent from the data, and close the connection if the server\n  \
    \ cannot interpret that data in a safe manner.  The |Sec-WebSocket-\n   Version|\
    \ header field is also sent from the server to the client on\n   WebSocket handshake\
    \ error, when the version received from the client\n   does not match a version\
    \ understood by the server.  In such a case,\n   the header field includes the\
    \ protocol version(s) supported by the\n   server.\n   Note that there is no expectation\
    \ that higher version numbers are\n   necessarily backward compatible with lower\
    \ version numbers.\n   The |Sec-WebSocket-Version| header field MAY appear multiple\
    \ times in\n   an HTTP response (which is logically the same as a single\n   |Sec-WebSocket-Version|\
    \ header field that contains all values).\n   However, the |Sec-WebSocket-Version|\
    \ header field MUST NOT appear\n   more than once in an HTTP request.\n"
- title: 11.4.  WebSocket Extension Name Registry
  contents:
  - "11.4.  WebSocket Extension Name Registry\n   This specification creates a new\
    \ IANA registry for WebSocket\n   Extension names to be used with the WebSocket\
    \ Protocol in accordance\n   with the principles set out in RFC 5226 [RFC5226].\n\
    \   As part of this registry, IANA maintains the following information:\n   Extension\
    \ Identifier\n      The identifier of the extension, as will be used in the\n\
    \      |Sec-WebSocket-Extensions| header field registered in\n      Section 11.3.2\
    \ of this specification.  The value must conform to\n      the requirements for\
    \ an extension-token as defined in Section 9.1\n      of this specification.\n\
    \   Extension Common Name\n      The name of the extension, as the extension is\
    \ generally referred\n      to.\n   Extension Definition\n      A reference to\
    \ the document in which the extension being used with\n      the WebSocket Protocol\
    \ is defined.\n   Known Incompatible Extensions\n      A list of extension identifiers\
    \ with which this extension is known\n      to be incompatible.\n   WebSocket\
    \ Extension names are to be subject to the \"First Come First\n   Served\" IANA\
    \ registration policy [RFC5226].\n   There are no initial values in this registry.\n"
- title: 11.5.  WebSocket Subprotocol Name Registry
  contents:
  - "11.5.  WebSocket Subprotocol Name Registry\n   This specification creates a new\
    \ IANA registry for WebSocket\n   Subprotocol names to be used with the WebSocket\
    \ Protocol in\n   accordance with the principles set out in RFC 5226 [RFC5226].\n\
    \   As part of this registry, IANA maintains the following information:\n   Subprotocol\
    \ Identifier\n      The identifier of the subprotocol, as will be used in the\n\
    \      |Sec-WebSocket-Protocol| header field registered in Section 11.3.4\n  \
    \    of this specification.  The value must conform to the requirements\n    \
    \  given in item 10 of Section 4.1 of this specification -- namely,\n      the\
    \ value must be a token as defined by RFC 2616 [RFC2616].\n   Subprotocol Common\
    \ Name\n      The name of the subprotocol, as the subprotocol is generally\n \
    \     referred to.\n   Subprotocol Definition\n      A reference to the document\
    \ in which the subprotocol being used\n      with the WebSocket Protocol is defined.\n\
    \   WebSocket Subprotocol names are to be subject to the \"First Come\n   First\
    \ Served\" IANA registration policy [RFC5226].\n"
- title: 11.6.  WebSocket Version Number Registry
  contents:
  - "11.6.  WebSocket Version Number Registry\n   This specification creates a new\
    \ IANA registry for WebSocket Version\n   Numbers to be used with the WebSocket\
    \ Protocol in accordance with the\n   principles set out in RFC 5226 [RFC5226].\n\
    \   As part of this registry, IANA maintains the following information:\n   Version\
    \ Number\n      The version number to be used in the |Sec-WebSocket-Version| is\n\
    \      specified in Section 4.1 of this specification.  The value must be\n  \
    \    a non-negative integer in the range between 0 and 255 (inclusive).\n   Reference\n\
    \      The RFC requesting a new version number or a draft name with\n      version\
    \ number (see below).\n   Status\n      Either \"Interim\" or \"Standard\".  See\
    \ below for description.\n   A version number is designated as either \"Interim\"\
    \ or \"Standard\".\n   A \"Standard\" version number is documented in an RFC and\
    \ used to\n   identify a major, stable version of the WebSocket protocol, such\
    \ as\n   the version defined by this RFC.  \"Standard\" version numbers are\n\
    \   subject to the \"IETF Review\" IANA registration policy [RFC5226].\n   An\
    \ \"Interim\" version number is documented in an Internet-Draft and\n   used to\
    \ help implementors identify and interoperate with deployed\n   versions of the\
    \ WebSocket protocol, such as versions developed before\n   the publication of\
    \ this RFC.  \"Interim\" version numbers are subject\n   to the \"Expert Review\"\
    \ IANA registration policy [RFC5226], with the\n   chairs of the HYBI Working\
    \ Group (or, if the working group closes,\n   the Area Directors for the IETF\
    \ Applications Area) being the initial\n   Designated Experts.\n   IANA has added\
    \ initial values to the registry as follows.\n   +--------+-----------------------------------------+----------+\n\
    \   |Version |                Reference                |  Status  |\n   | Number\
    \ |                                         |          |\n   +--------+-----------------------------------------+----------+\n\
    \   | 0      + draft-ietf-hybi-thewebsocketprotocol-00 | Interim  |\n   +--------+-----------------------------------------+----------+\n\
    \   | 1      + draft-ietf-hybi-thewebsocketprotocol-01 | Interim  |\n   +--------+-----------------------------------------+----------+\n\
    \   | 2      + draft-ietf-hybi-thewebsocketprotocol-02 | Interim  |\n   +--------+-----------------------------------------+----------+\n\
    \   | 3      + draft-ietf-hybi-thewebsocketprotocol-03 | Interim  |\n   +--------+-----------------------------------------+----------+\n\
    \   | 4      + draft-ietf-hybi-thewebsocketprotocol-04 | Interim  |\n   +--------+-----------------------------------------+----------+\n\
    \   | 5      + draft-ietf-hybi-thewebsocketprotocol-05 | Interim  |\n   +--------+-----------------------------------------+----------+\n\
    \   | 6      + draft-ietf-hybi-thewebsocketprotocol-06 | Interim  |\n   +--------+-----------------------------------------+----------+\n\
    \   | 7      + draft-ietf-hybi-thewebsocketprotocol-07 | Interim  |\n   +--------+-----------------------------------------+----------+\n\
    \   | 8      + draft-ietf-hybi-thewebsocketprotocol-08 | Interim  |\n   +--------+-----------------------------------------+----------+\n\
    \   | 9      +                Reserved                 |          |\n   +--------+-----------------------------------------+----------+\n\
    \   | 10     +                Reserved                 |          |\n   +--------+-----------------------------------------+----------+\n\
    \   | 11     +                Reserved                 |          |\n   +--------+-----------------------------------------+----------+\n\
    \   | 12     +                Reserved                 |          |\n   +--------+-----------------------------------------+----------+\n\
    \   | 13     +                RFC 6455                 | Standard |\n   +--------+-----------------------------------------+----------+\n"
- title: 11.7.  WebSocket Close Code Number Registry
  contents:
  - "11.7.  WebSocket Close Code Number Registry\n   This specification creates a\
    \ new IANA registry for WebSocket\n   Connection Close Code Numbers in accordance\
    \ with the principles set\n   out in RFC 5226 [RFC5226].\n   As part of this registry,\
    \ IANA maintains the following information:\n   Status Code\n      The Status\
    \ Code denotes a reason for a WebSocket connection\n      closure as per Section\
    \ 7.4 of this document.  The status code is\n      an integer number between 1000\
    \ and 4999 (inclusive).\n   Meaning\n      The meaning of the status code.  Each\
    \ status code has to have a\n      unique meaning.\n   Contact\n      A contact\
    \ for the entity reserving the status code.\n   Reference\n      The stable document\
    \ requesting the status codes and defining their\n      meaning.  This is required\
    \ for status codes in the range 1000-2999\n      and recommended for status codes\
    \ in the range 3000-3999.\n   WebSocket Close Code Numbers are subject to different\
    \ registration\n   requirements depending on their range.  Requests for status\
    \ codes for\n   use by this protocol and its subsequent versions or extensions\
    \ are\n   subject to any one of the \"Standards Action\", \"Specification\n  \
    \ Required\" (which implies \"Designated Expert\"), or \"IESG Review\" IANA\n\
    \   registration policies and should be granted in the range 1000-2999.\n   Requests\
    \ for status codes for use by libraries, frameworks, and\n   applications are\
    \ subject to the \"First Come First Served\" IANA\n   registration policy and\
    \ should be granted in the range 3000-3999.\n   The range of status codes from\
    \ 4000-4999 is designated for Private\n   Use.  Requests should indicate whether\
    \ they are requesting status\n   codes for use by the WebSocket Protocol (or a\
    \ future version of the\n   protocol), by extensions, or by libraries/frameworks/applications.\n\
    \   IANA has added initial values to the registry as follows.\n     |Status Code\
    \ | Meaning         | Contact       | Reference |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1000       | Normal Closure  | hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1001       | Going Away      | hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1002       | Protocol error  | hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1003       | Unsupported Data| hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1004       | ---Reserved---- | hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1005       | No Status Rcvd  | hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1006       | Abnormal Closure| hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1007       | Invalid frame   | hybi@ietf.org | RFC 6455  |\n     |   \
    \         | payload data    |               |           |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1008       | Policy Violation| hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1009       | Message Too Big | hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1010       | Mandatory Ext.  | hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1011       | Internal Server | hybi@ietf.org | RFC 6455  |\n     |   \
    \         | Error           |               |           |\n    -+------------+-----------------+---------------+-----------|\n\
    \     | 1015       | TLS handshake   | hybi@ietf.org | RFC 6455  |\n    -+------------+-----------------+---------------+-----------|\n"
- title: 11.8.  WebSocket Opcode Registry
  contents:
  - "11.8.  WebSocket Opcode Registry\n   This specification creates a new IANA registry\
    \ for WebSocket Opcodes\n   in accordance with the principles set out in RFC 5226\
    \ [RFC5226].\n   As part of this registry, IANA maintains the following information:\n\
    \   Opcode\n      The opcode denotes the frame type of the WebSocket frame, as\n\
    \      defined in Section 5.2.  The opcode is an integer number between 0\n  \
    \    and 15, inclusive.\n   Meaning\n      The meaning of the opcode value.\n\
    \   Reference\n      The specification requesting the opcode.\n   WebSocket Opcode\
    \ numbers are subject to the \"Standards Action\" IANA\n   registration policy\
    \ [RFC5226].\n   IANA has added initial values to the registry as follows.\n \
    \    |Opcode  | Meaning                             | Reference |\n    -+--------+-------------------------------------+-----------|\n\
    \     | 0      | Continuation Frame                  | RFC 6455  |\n    -+--------+-------------------------------------+-----------|\n\
    \     | 1      | Text Frame                          | RFC 6455  |\n    -+--------+-------------------------------------+-----------|\n\
    \     | 2      | Binary Frame                        | RFC 6455  |\n    -+--------+-------------------------------------+-----------|\n\
    \     | 8      | Connection Close Frame              | RFC 6455  |\n    -+--------+-------------------------------------+-----------|\n\
    \     | 9      | Ping Frame                          | RFC 6455  |\n    -+--------+-------------------------------------+-----------|\n\
    \     | 10     | Pong Frame                          | RFC 6455  |\n    -+--------+-------------------------------------+-----------|\n"
- title: 11.9.  WebSocket Framing Header Bits Registry
  contents:
  - "11.9.  WebSocket Framing Header Bits Registry\n   This specification creates\
    \ a new IANA registry for WebSocket Framing\n   Header Bits in accordance with\
    \ the principles set out in RFC 5226\n   [RFC5226].  This registry controls assignment\
    \ of the bits marked\n   RSV1, RSV2, and RSV3 in Section 5.2.\n   These bits are\
    \ reserved for future versions or extensions of this\n   specification.\n   WebSocket\
    \ Framing Header Bits assignments are subject to the\n   \"Standards Action\"\
    \ IANA registration policy [RFC5226].\n"
- title: 12.  Using the WebSocket Protocol from Other Specifications
  contents:
  - "12.  Using the WebSocket Protocol from Other Specifications\n   The WebSocket\
    \ Protocol is intended to be used by another\n   specification to provide a generic\
    \ mechanism for dynamic author-\n   defined content, e.g., in a specification\
    \ defining a scripted API.\n   Such a specification first needs to _Establish\
    \ a WebSocket\n   Connection_, providing that algorithm with:\n   o  The destination,\
    \ consisting of a /host/ and a /port/.\n   o  A /resource name/, which allows\
    \ for multiple services to be\n      identified at one host and port.\n   o  A\
    \ /secure/ flag, which is true if the connection is to be\n      encrypted and\
    \ false otherwise.\n   o  An ASCII serialization of an origin [RFC6454] that is\
    \ being made\n      responsible for the connection.\n   o  Optionally, a string\
    \ identifying a protocol that is to be layered\n      over the WebSocket connection.\n\
    \   The /host/, /port/, /resource name/, and /secure/ flag are usually\n   obtained\
    \ from a URI using the steps to parse a WebSocket URI's\n   components.  These\
    \ steps fail if the URI does not specify a\n   WebSocket.\n   If at any time the\
    \ connection is to be closed, then the specification\n   needs to use the _Close\
    \ the WebSocket Connection_ algorithm\n   (Section 7.1.1).\n   Section 7.1.4 defines\
    \ when _The WebSocket Connection is Closed_.\n   While a connection is open, the\
    \ specification will need to handle the\n   cases when _A WebSocket Message Has\
    \ Been Received_ (Section 6.2).\n   To send some data /data/ to an open connection,\
    \ the specification\n   needs to _Send a WebSocket Message_ (Section 6.1).\n"
- title: 13.  Acknowledgements
  contents:
  - "13.  Acknowledgements\n   Special thanks are due to Ian Hickson, who was the\
    \ original author\n   and editor of this protocol.  The initial design of this\n\
    \   specification benefitted from the participation of many people in the\n  \
    \ WHATWG and WHATWG mailing list.  Contributions to that specification\n   are\
    \ not tracked by section, but a list of all who contributed to that\n   specification\
    \ is given in the WHATWG HTML specification at\n   http://whatwg.org/html5.\n\
    \   Special thanks also to John Tamplin for providing a significant\n   amount\
    \ of text for the \"Data Framing\" section of this specification.\n   Special\
    \ thanks also to Adam Barth for providing a significant amount\n   of text and\
    \ background research for the \"Data Masking\" section of\n   this specification.\n\
    \   Special thanks to Lisa Dusseault for the Apps Area review (and for\n   helping\
    \ to start this work), Richard Barnes for the Gen-Art review,\n   and Magnus Westerlund\
    \ for the Transport Area Review.  Special thanks\n   to HYBI WG past and present\
    \ WG chairs who tirelessly worked behind\n   the scene to move this work toward\
    \ completion: Joe Hildebrand,\n   Salvatore Loreto, and Gabriel Montenegro.  And\
    \ last but not least,\n   special thank you to the responsible Area Director Peter\
    \ Saint-Andre.\n   Thank you to the following people who participated in discussions\
    \ on\n   the HYBI WG mailing list and contributed ideas and/or provided\n   detailed\
    \ reviews (the list is likely to be incomplete): Greg Wilkins,\n   John Tamplin,\
    \ Willy Tarreau, Maciej Stachowiak, Jamie Lokier, Scott\n   Ferguson, Bjoern Hoehrmann,\
    \ Julian Reschke, Dave Cridland, Andy\n   Green, Eric Rescorla, Inaki Baz Castillo,\
    \ Martin Thomson, Roberto\n   Peon, Patrick McManus, Zhong Yu, Bruce Atherton,\
    \ Takeshi Yoshino,\n   Martin J. Duerst, James Graham, Simon Pieters, Roy T. Fielding,\n\
    \   Mykyta Yevstifeyev, Len Holgate, Paul Colomiets, Piotr Kulaga, Brian\n   Raymor,\
    \ Jan Koehler, Joonas Lehtolahti, Sylvain Hellegouarch, Stephen\n   Farrell, Sean\
    \ Turner, Pete Resnick, Peter Thorson, Joe Mason, John\n   Fallows, and Alexander\
    \ Philippou.  Note that people listed above\n   didn't necessarily endorse the\
    \ end result of this work.\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [ANSI.X3-4.1986]\n              American National\
    \ Standards Institute, \"Coded Character\n              Set - 7-bit American Standard\
    \ Code for Information\n              Interchange\", ANSI X3.4, 1986.\n   [FIPS.180-3]\n\
    \              National Institute of Standards and Technology, \"Secure\n    \
    \          Hash Standard\", FIPS PUB 180-3, October 2008,\n              <http://csrc.nist.gov/publications/fips/fips180-3/\n\
    \              fips180-3_final.pdf>.\n   [RFC1928]  Leech, M., Ganis, M., Lee,\
    \ Y., Kuris, R., Koblas, D., and\n              L. Jones, \"SOCKS Protocol Version\
    \ 5\", RFC 1928,\n              March 1996.\n   [RFC2119]  Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,\
    \ RFC 2119, March 1997.\n   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk,\
    \ H.,\n              Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n\
    \              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n   [RFC2817]\
    \  Khare, R. and S. Lawrence, \"Upgrading to TLS Within\n              HTTP/1.1\"\
    , RFC 2817, May 2000.\n   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818,\
    \ May 2000.\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n\
    \              10646\", STD 63, RFC 3629, November 2003.\n   [RFC3864]  Klyne,\
    \ G., Nottingham, M., and J. Mogul, \"Registration\n              Procedures for\
    \ Message Header Fields\", BCP 90, RFC 3864,\n              September 2004.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66,\n           \
    \   RFC 3986, January 2005.\n   [RFC3987]  Duerst, M. and M. Suignard, \"Internationalized\
    \ Resource\n              Identifiers (IRIs)\", RFC 3987, January 2005.\n   [RFC4086]\
    \  Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n              Requirements\
    \ for Security\", BCP 106, RFC 4086, June 2005.\n   [RFC4648]  Josefsson, S.,\
    \ \"The Base16, Base32, and Base64 Data\n              Encodings\", RFC 4648,\
    \ October 2006.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for\
    \ Writing an\n              IANA Considerations Section in RFCs\", BCP 26, RFC\
    \ 5226,\n              May 2008.\n   [RFC5234]  Crocker, D. and P. Overell, \"\
    Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234,\
    \ January 2008.\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer\
    \ Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n\
    \   [RFC6066]  Eastlake, D., \"Transport Layer Security (TLS) Extensions:\n  \
    \            Extension Definitions\", RFC 6066, January 2011.\n   [RFC6454]  Barth,\
    \ A., \"The Web Origin Concept\", RFC 6454,\n              December 2011.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [RFC4122]  Leach, P., Mealling, M., and R.\
    \ Salz, \"A Universally\n              Unique IDentifier (UUID) URN Namespace\"\
    , RFC 4122,\n              July 2005.\n   [RFC4270]  Hoffman, P. and B. Schneier,\
    \ \"Attacks on Cryptographic\n              Hashes in Internet Protocols\", RFC\
    \ 4270, November 2005.\n   [RFC5321]  Klensin, J., \"Simple Mail Transfer Protocol\"\
    , RFC 5321,\n              October 2008.\n   [RFC6202]  Loreto, S., Saint-Andre,\
    \ P., Salsano, S., and G. Wilkins,\n              \"Known Issues and Best Practices\
    \ for the Use of Long\n              Polling and Streaming in Bidirectional HTTP\"\
    , RFC 6202,\n              April 2011.\n   [RFC6265]  Barth, A., \"HTTP State\
    \ Management Mechanism\", RFC 6265,\n              April 2011.\n   [TALKING] \
    \ Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C.\n              Jackson,\
    \ \"Talking to Yourself for Fun and Profit\", 2010,\n              <http://w2spconf.com/2011/papers/websocket.pdf>.\n\
    \   [W3C.REC-wsc-ui-20100812]\n              Roessler, T. and A. Saldhana, \"\
    Web Security Context: User\n              Interface Guidelines\", World Wide Web\
    \ Consortium\n              Recommendation REC-wsc-ui-20100812, August 2010,\n\
    \              <http://www.w3.org/TR/2010/REC-wsc-ui-20100812/>.\n           \
    \   Latest version available at\n              <http://www.w3.org/TR/wsc-ui/>.\n\
    \   [WSAPI]    Hickson, I., \"The WebSocket API\", W3C Working Draft WD-\n   \
    \           websockets-20110929, September 2011,\n              <http://www.w3.org/TR/2011/WD-websockets-20110929/>.\n\
    \              Latest version available at\n              <http://www.w3.org/TR/websockets/>.\n\
    \   [XMLHttpRequest]\n              van Kesteren, A., Ed., \"XMLHttpRequest\"\
    , W3C Candidate\n              Recommendation CR-XMLHttpRequest-20100803, August\
    \ 2010,\n              <http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/>.\n\
    \              Latest version available at\n              <http://www.w3.org/TR/XMLHttpRequest/>.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Ian Fette\n   Google, Inc.\n   EMail: ifette+ietf@google.com\n\
    \   URI:   http://www.ianfette.com/\n   Alexey Melnikov\n   Isode Ltd.\n   5 Castle\
    \ Business Village\n   36 Station Road\n   Hampton, Middlesex  TW12 2BX\n   UK\n\
    \   EMail: Alexey.Melnikov@isode.com\n"
