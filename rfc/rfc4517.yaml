- contents:
  - "             Lightweight Directory Access Protocol (LDAP):\n                      Syntaxes
    and Matching Rules\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   Each attribute stored in a Lightweight Directory Access Protocol\n
    \  (LDAP) directory, whose values may be transferred in the LDAP\n   protocol,
    has a defined syntax that constrains the structure and\n   format of its values.
    \ The comparison semantics for values of a\n   syntax are not part of the syntax
    definition but are instead provided\n   through separately defined matching rules.
    \ Matching rules specify an\n   argument, an assertion value, which also has a
    defined syntax.  This\n   document defines a base set of syntaxes and matching
    rules for use in\n   defining attributes for LDAP directories.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Conventions .....................................................4\n   3.
    Syntaxes ........................................................4\n      3.1.
    General Considerations .....................................5\n      3.2. Common
    Definitions .........................................5\n      3.3. Syntax Definitions
    .........................................6\n           3.3.1. Attribute Type Description
    ..........................6\n           3.3.2. Bit String ..........................................6\n
    \          3.3.3. Boolean .............................................7\n           3.3.4.
    Country String ......................................7\n           3.3.5. Delivery
    Method .....................................8\n           3.3.6. Directory String
    ....................................8\n           3.3.7. DIT Content Rule Description
    ........................9\n           3.3.8. DIT Structure Rule Description .....................10\n
    \          3.3.9. DN .................................................10\n           3.3.10.
    Enhanced Guide ....................................11\n           3.3.11. Facsimile
    Telephone Number ........................12\n           3.3.12. Fax ...............................................12\n
    \          3.3.13. Generalized Time ..................................13\n           3.3.14.
    Guide .............................................14\n           3.3.15. IA5
    String ........................................15\n           3.3.16. Integer
    ...........................................15\n           3.3.17. JPEG ..............................................15\n
    \          3.3.18. LDAP Syntax Description ...........................16\n           3.3.19.
    Matching Rule Description .........................16\n           3.3.20. Matching
    Rule Use Description .....................17\n           3.3.21. Name and Optional
    UID .............................17\n           3.3.22. Name Form Description
    .............................18\n           3.3.23. Numeric String ....................................18\n
    \          3.3.24. Object Class Description ..........................18\n           3.3.25.
    Octet String ......................................19\n           3.3.26. OID
    ...............................................19\n           3.3.27. Other Mailbox
    .....................................20\n           3.3.28. Postal Address ....................................20\n
    \          3.3.29. Printable String ..................................21\n           3.3.30.
    Substring Assertion ...............................22\n           3.3.31. Telephone
    Number ..................................23\n           3.3.32. Teletex Terminal
    Identifier .......................23\n           3.3.33. Telex Number ......................................24\n
    \          3.3.34. UTC Time ..........................................24\n   4.
    Matching Rules .................................................25\n      4.1.
    General Considerations ....................................25\n      4.2. Matching
    Rule Definitions .................................27\n           4.2.1. bitStringMatch
    .....................................27\n           4.2.2. booleanMatch .......................................28\n
    \          4.2.3. caseExactIA5Match ..................................28\n           4.2.4.
    caseExactMatch .....................................29\n           4.2.5. caseExactOrderingMatch
    .............................29\n           4.2.6. caseExactSubstringsMatch ...........................30\n
    \          4.2.7. caseIgnoreIA5Match .................................30\n           4.2.8.
    caseIgnoreIA5SubstringsMatch .......................31\n           4.2.9. caseIgnoreListMatch
    ................................31\n           4.2.10. caseIgnoreListSubstringsMatch
    .....................32\n           4.2.11. caseIgnoreMatch ...................................33\n
    \          4.2.12. caseIgnoreOrderingMatch ...........................33\n           4.2.13.
    caseIgnoreSubstringsMatch .........................34\n           4.2.14. directoryStringFirstComponentMatch
    ................34\n           4.2.15. distinguishedNameMatch ............................35\n
    \          4.2.16. generalizedTimeMatch ..............................36\n           4.2.17.
    generalizedTimeOrderingMatch ......................36\n           4.2.18. integerFirstComponentMatch
    ........................36\n           4.2.19. integerMatch ......................................37\n
    \          4.2.20. integerOrderingMatch ..............................37\n           4.2.21.
    keywordMatch ......................................38\n           4.2.22. numericStringMatch
    ................................38\n           4.2.23. numericStringOrderingMatch
    ........................39\n           4.2.24. numericStringSubstringsMatch ......................39\n
    \          4.2.25. objectIdentifierFirstComponentMatch ...............40\n           4.2.26.
    objectIdentifierMatch .............................40\n           4.2.27. octetStringMatch
    ..................................41\n           4.2.28. octetStringOrderingMatch
    ..........................41\n           4.2.29. telephoneNumberMatch ..............................42\n
    \          4.2.30. telephoneNumberSubstringsMatch ....................42\n           4.2.31.
    uniqueMemberMatch .................................43\n           4.2.32. wordMatch
    .........................................44\n   5. Security Considerations ........................................44\n
    \  6. Acknowledgements ...............................................44\n   7.
    IANA Considerations ............................................45\n   8. References
    .....................................................46\n      8.1. Normative
    References ......................................46\n      8.2. Informative References
    ....................................48\n   Appendix A. Summary of Syntax Object
    Identifiers ..................49\n   Appendix B. Changes from RFC 2252 .................................49\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Each attribute stored in a Lightweight Directory Access
    Protocol\n   (LDAP) directory [RFC4510], whose values may be transferred in the\n
    \  LDAP protocol [RFC4511], has a defined syntax (i.e., data type) that\n   constrains
    the structure and format of its values.  The comparison\n   semantics for values
    of a syntax are not part of the syntax\n   definition but are instead provided
    through separately defined\n   matching rules.  Matching rules specify an argument,
    an assertion\n   value, which also has a defined syntax.  This document defines
    a base\n   set of syntaxes and matching rules for use in defining attributes for\n
    \  LDAP directories.\n   Readers are advised to familiarize themselves with the
    Directory\n   Information Models [RFC4512] before reading the rest of this\n   document.
    \ Section 3 provides definitions for the base set of LDAP\n   syntaxes.  Section
    4 provides definitions for the base set of\n   matching rules for LDAP.\n   This
    document is an integral part of the LDAP technical specification\n   [RFC4510],
    which obsoletes the previously defined LDAP technical\n   specification, RFC 3377,
    in its entirety.\n   Sections 4, 5, and 7 of RFC 2252 are obsoleted by [RFC4512].
    \ The\n   remainder of RFC 2252 is obsoleted by this document.  Sections 6 and\n
    \  8 of RFC 2256 are obsoleted by this document.  The remainder of RFC\n   2256
    is obsoleted by [RFC4519] and [RFC4512].  All but Section 2.11\n   of RFC 3698
    is obsoleted by this document.\n   A number of schema elements that were included
    in the previous\n   revision of the LDAP technical specification are not included
    in this\n   revision of LDAP.  Public Key Infrastructure schema elements are now\n
    \  specified in [RFC4523].  Unless reintroduced in future technical\n   specifications,
    the remainder are to be considered Historic.\n   The changes with respect to RFC
    2252 are described in Appendix B of\n   this document.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions\n   In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\",\n
    \  \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",\n
    \  and \"OPTIONAL\" are to be interpreted as described in BCP 14, RFC 2119\n   [RFC2119].\n
    \  Syntax definitions are written according to the <SyntaxDescription>\n   ABNF
    [RFC4234] rule specified in [RFC4512], and matching rule\n   definitions are written
    according to the <MatchingRuleDescription>\n   ABNF rule specified in [RFC4512],
    except that the syntax and matching\n   rule definitions provided in this document
    are line-wrapped for\n   readability.  When such definitions are transferred as
    attribute\n   values in the LDAP protocol (e.g., as values of the ldapSyntaxes
    and\n   matchingRules attributes [RFC4512], respectively), then those values\n
    \  would not contain line breaks.\n"
  title: 2.  Conventions
- contents:
  - "3.  Syntaxes\n   Syntax definitions constrain the structure of attribute values
    stored\n   in an LDAP directory, and determine the representation of attribute\n
    \  and assertion values transferred in the LDAP protocol.\n   Syntaxes that are
    required for directory operation, or that are in\n   common use, are specified
    in this section.  Servers SHOULD recognize\n   all the syntaxes listed in this
    document, but are not required to\n   otherwise support them, and MAY recognise
    or support other syntaxes.\n   However, the definition of additional arbitrary
    syntaxes is\n   discouraged since it will hinder interoperability.  Client and
    server\n   implementations typically do not have the ability to dynamically\n
    \  recognize new syntaxes.\n"
  - contents:
    - "3.1.  General Considerations\n   The description of each syntax specifies how
      attribute or assertion\n   values conforming to the syntax are to be represented
      when\n   transferred in the LDAP protocol [RFC4511].  This representation is\n
      \  referred to as the LDAP-specific encoding to distinguish it from\n   other
      methods of encoding attribute values (e.g., the Basic Encoding\n   Rules (BER)
      encoding [BER] used by X.500 [X.500] directories).\n   The LDAP-specific encoding
      of a given attribute syntax always\n   produces octet-aligned values.  To the
      greatest extent possible,\n   encoding rules for LDAP syntaxes should produce
      character strings\n   that can be displayed with little or no translation by
      clients\n   implementing LDAP.  However, clients MUST NOT assume that the LDAP-\n
      \  specific encoding of a value of an unrecognized syntax is a human-\n   readable
      character string.  There are a few cases (e.g., the JPEG\n   syntax) when it
      is not reasonable to produce a human-readable\n   representation.\n   Each LDAP
      syntax is uniquely identified with an object identifier\n   [ASN.1] represented
      in the dotted-decimal format (short descriptive\n   names are not defined for
      syntaxes).  These object identifiers are\n   not intended to be displayed to
      users.  The object identifiers for\n   the syntaxes defined in this document
      are summarized in Appendix A.\n   A suggested minimum upper bound on the number
      of characters in an\n   attribute value with a string-based syntax, or the number
      of octets\n   in a value for all other syntaxes, MAY be indicated by appending
      the\n   bound inside of curly braces following the syntax's OBJECT IDENTIFIER\n
      \  in an attribute type definition (see the <noidlen> rule in\n   [RFC4512]).
      \ Such a bound is not considered part of the syntax\n   identifier.\n   For
      example, \"1.3.6.1.4.1.1466.115.121.1.15{64}\" in an attribute\n   definition
      suggests that the directory server will allow a value of\n   the attribute to
      be up to 64 characters long, although it may allow\n   longer character strings.
      \ Note that a single character of the\n   Directory String syntax can be encoded
      in more than one octet, since\n   UTF-8 [RFC3629] is a variable-length encoding.
      \ Therefore, a 64-\n   character string may be more than 64 octets in length.\n"
    title: 3.1.  General Considerations
  - contents:
    - "3.2.  Common Definitions\n   The following ABNF rules are used in a number
      of the syntax\n   definitions in Section 3.3.\n      PrintableCharacter = ALPHA
      / DIGIT / SQUOTE / LPAREN / RPAREN /\n                           PLUS / COMMA
      / HYPHEN / DOT / EQUALS /\n                           SLASH / COLON / QUESTION
      / SPACE\n      PrintableString    = 1*PrintableCharacter\n      IA5String          =
      *(%x00-7F)\n      SLASH              = %x2F  ; forward slash (\"/\")\n      COLON
      \             = %x3A  ; colon (\":\")\n      QUESTION           = %x3F  ; question
      mark (\"?\")\n   The <ALPHA>, <DIGIT>, <SQUOTE>, <LPAREN>, <RPAREN>, <PLUS>,
      <COMMA>,\n   <HYPHEN>, <DOT>, <EQUALS>, and <SPACE> rules are defined in\n   [RFC4512].\n"
    title: 3.2.  Common Definitions
  - contents:
    - '3.3.  Syntax Definitions

      '
    - contents:
      - "3.3.1.  Attribute Type Description\n   A value of the Attribute Type Description
        syntax is the definition of\n   an attribute type.  The LDAP-specific encoding
        of a value of this\n   syntax is defined by the <AttributeTypeDescription>
        rule in\n   [RFC4512].\n      For example, the following definition of the
        createTimestamp\n      attribute type from [RFC4512] is also a value of the
        Attribute\n      Type Description syntax.  (Note: Line breaks have been added
        for\n      readability; they are not part of the value when transferred in\n
        \     protocol.)\n         ( 2.5.18.1 NAME 'createTimestamp'\n            EQUALITY
        generalizedTimeMatch\n            ORDERING generalizedTimeOrderingMatch\n
        \           SYNTAX 1.3.6.1.4.1.1466.115.121.1.24\n            SINGLE-VALUE
        NO-USER-MODIFICATION\n            USAGE directoryOperation )\n   The LDAP
        definition for the Attribute Type Description syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.3
        DESC 'Attribute Type Description' )\n   This syntax corresponds to the AttributeTypeDescription
        ASN.1 type\n   from [X.501].\n"
      title: 3.3.1.  Attribute Type Description
    - contents:
      - "3.3.2.  Bit String\n   A value of the Bit String syntax is a sequence of
        binary digits.  The\n   LDAP-specific encoding of a value of this syntax is
        defined by the\n   following ABNF:\n      BitString    = SQUOTE *binary-digit
        SQUOTE \"B\"\n      binary-digit = \"0\" / \"1\"\n   The <SQUOTE> rule is
        defined in [RFC4512].\n      Example:\n         '0101111101'B\n   The LDAP
        definition for the Bit String syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.6
        DESC 'Bit String' )\n   This syntax corresponds to the BIT STRING ASN.1 type
        from [ASN.1].\n"
      title: 3.3.2.  Bit String
    - contents:
      - "3.3.3.  Boolean\n   A value of the Boolean syntax is one of the Boolean values,
        true or\n   false.  The LDAP-specific encoding of a value of this syntax is\n
        \  defined by the following ABNF:\n      Boolean = \"TRUE\" / \"FALSE\"\n
        \  The LDAP definition for the Boolean syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.7
        DESC 'Boolean' )\n   This syntax corresponds to the BOOLEAN ASN.1 type from
        [ASN.1].\n"
      title: 3.3.3.  Boolean
    - contents:
      - "3.3.4.  Country String\n   A value of the Country String syntax is one of
        the two-character\n   codes from ISO 3166 [ISO3166] for representing a country.
        \ The LDAP-\n   specific encoding of a value of this syntax is defined by
        the\n   following ABNF:\n      CountryString  = 2(PrintableCharacter)\n   The
        <PrintableCharacter> rule is defined in Section 3.2.\n      Examples:\n         US\n
        \        AU\n   The LDAP definition for the Country String syntax is:\n      (
        1.3.6.1.4.1.1466.115.121.1.11 DESC 'Country String' )\n   This syntax corresponds
        to the following ASN.1 type from [X.520]:\n      PrintableString (SIZE (2))
        -- ISO 3166 codes only\n"
      title: 3.3.4.  Country String
    - contents:
      - "3.3.5.  Delivery Method\n   A value of the Delivery Method syntax is a sequence
        of items that\n   indicate, in preference order, the service(s) by which an
        entity is\n   willing and/or capable of receiving messages.  The LDAP-specific\n
        \  encoding of a value of this syntax is defined by the following ABNF:\n
        \     DeliveryMethod = pdm *( WSP DOLLAR WSP pdm )\n      pdm = \"any\" /
        \"mhs\" / \"physical\" / \"telex\" / \"teletex\" /\n            \"g3fax\"
        / \"g4fax\" / \"ia5\" / \"videotex\" / \"telephone\"\n   The <WSP> and <DOLLAR>
        rules are defined in [RFC4512].\n      Example:\n         telephone $ videotex\n
        \  The LDAP definition for the Delivery Method syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.14
        DESC 'Delivery Method' )\n   This syntax corresponds to the following ASN.1
        type from [X.520]:\n      SEQUENCE OF INTEGER {\n          any-delivery-method
        \    (0),\n          mhs-delivery            (1),\n          physical-delivery
        \      (2),\n          telex-delivery          (3),\n          teletex-delivery
        \       (4),\n          g3-facsimile-delivery   (5),\n          g4-facsimile-delivery
        \  (6),\n          ia5-terminal-delivery   (7),\n          videotex-delivery
        \      (8),\n          telephone-delivery      (9) }\n"
      title: 3.3.5.  Delivery Method
    - contents:
      - "3.3.6.  Directory String\n   A value of the Directory String syntax is a
        string of one or more\n   arbitrary characters from the Universal Character
        Set (UCS) [UCS].  A\n   zero-length character string is not permitted.  The
        LDAP-specific\n   encoding of a value of this syntax is the UTF-8 encoding
        [RFC3629] of\n   the character string.  Such encodings conform to the following
        ABNF:\n      DirectoryString = 1*UTF8\n   The <UTF8> rule is defined in [RFC4512].\n
        \     Example:\n         This is a value of Directory String containing #!%#@.\n
        \  Servers and clients MUST be prepared to receive arbitrary UCS code\n   points,
        including code points outside the range of printable ASCII\n   and code points
        not presently assigned to any character.\n   Attribute type definitions using
        the Directory String syntax should\n   not restrict the format of Directory
        String values, e.g., by\n   requiring that the character string conforms to
        specific patterns\n   described by ABNF.  A new syntax should be defined in
        such cases.\n   The LDAP definition for the Directory String syntax is:\n
        \     ( 1.3.6.1.4.1.1466.115.121.1.15 DESC 'Directory String' )\n   This syntax
        corresponds to the DirectoryString parameterized ASN.1\n   type from [X.520].\n
        \  The DirectoryString ASN.1 type allows a choice between the\n   TeletexString,
        PrintableString, or UniversalString ASN.1 types from\n   [ASN.1].  However,
        note that the chosen alternative is not indicated\n   in the LDAP-specific
        encoding of a Directory String value.\n   Implementations that convert Directory
        String values from the LDAP-\n   specific encoding to the BER encoding used
        by X.500 must choose an\n   alternative that permits the particular characters
        in the string and\n   must convert the characters from the UTF-8 encoding
        into the\n   character encoding of the chosen alternative.  When converting\n
        \  Directory String values from the BER encoding to the LDAP-specific\n   encoding,
        the characters must be converted from the character\n   encoding of the chosen
        alternative into the UTF-8 encoding.  These\n   conversions SHOULD be done
        in a manner consistent with the Transcode\n   step of the string preparation
        algorithms [RFC4518] for LDAP.\n"
      title: 3.3.6.  Directory String
    - contents:
      - "3.3.7.  DIT Content Rule Description\n   A value of the DIT Content Rule
        Description syntax is the definition\n   of a DIT (Directory Information Tree)
        content rule.  The LDAP-\n   specific encoding of a value of this syntax is
        defined by the\n   <DITContentRuleDescription> rule in [RFC4512].\n      Example:\n
        \        ( 2.5.6.4 DESC 'content rule for organization'\n            NOT (
        x121Address $ telexNumber ) )\n      Note: A line break has been added for
        readability; it is not part\n      of the value.\n   The LDAP definition for
        the DIT Content Rule Description syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.16\n
        \        DESC 'DIT Content Rule Description' )\n   This syntax corresponds
        to the DITContentRuleDescription ASN.1 type\n   from [X.501].\n"
      title: 3.3.7.  DIT Content Rule Description
    - contents:
      - "3.3.8.  DIT Structure Rule Description\n   A value of the DIT Structure Rule
        Description syntax is the\n   definition of a DIT structure rule.  The LDAP-specific
        encoding of a\n   value of this syntax is defined by the <DITStructureRuleDescription>\n
        \  rule in [RFC4512].\n      Example:\n         ( 2 DESC 'organization structure
        rule' FORM 2.5.15.3 )\n   The LDAP definition for the DIT Structure Rule Description
        syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.17\n         DESC 'DIT Structure
        Rule Description' )\n   This syntax corresponds to the DITStructureRuleDescription
        ASN.1 type\n   from [X.501].\n"
      title: 3.3.8.  DIT Structure Rule Description
    - contents:
      - "3.3.9.  DN\n   A value of the DN syntax is the (purported) distinguished
        name (DN)\n   of an entry [RFC4512].  The LDAP-specific encoding of a value
        of this\n   syntax is defined by the <distinguishedName> rule from the string\n
        \  representation of distinguished names [RFC4514].\n      Examples (from
        [RFC4514]):\n         UID=jsmith,DC=example,DC=net\n         OU=Sales+CN=J.
        Smith,DC=example,DC=net\n         CN=John Smith\\, III,DC=example,DC=net\n
        \        CN=Before\\0dAfter,DC=example,DC=net\n         1.3.6.1.4.1.1466.0=#04024869,DC=example,DC=com\n
        \        CN=Lu\\C4\\8Di\\C4\\87\n   The LDAP definition for the DN syntax
        is:\n      ( 1.3.6.1.4.1.1466.115.121.1.12 DESC 'DN' )\n   The DN syntax corresponds
        to the DistinguishedName ASN.1 type from\n   [X.501].  Note that a BER encoded
        distinguished name (as used by\n   X.500) re-encoded into the LDAP-specific
        encoding is not necessarily\n   reversible to the original BER encoding since
        the chosen string type\n   in any DirectoryString components of the distinguished
        name is not\n   indicated in the LDAP-specific encoding of the distinguished
        name\n   (see Section 3.3.6).\n"
      title: 3.3.9.  DN
    - contents:
      - "3.3.10.  Enhanced Guide\n   A value of the Enhanced Guide syntax suggests
        criteria, which consist\n   of combinations of attribute types and filter
        operators, to be used\n   in constructing filters to search for entries of
        particular object\n   classes.  The Enhanced Guide syntax improves upon the
        Guide syntax by\n   allowing the recommended depth of the search to be specified.\n
        \  The LDAP-specific encoding of a value of this syntax is defined by\n   the
        following ABNF:\n      EnhancedGuide = object-class SHARP WSP criteria WSP\n
        \                        SHARP WSP subset\n      object-class  = WSP oid WSP\n
        \     subset        = \"baseobject\" / \"oneLevel\" / \"wholeSubtree\"\n      criteria
        \  = and-term *( BAR and-term )\n      and-term   = term *( AMPERSAND term
        )\n      term       = EXCLAIM term /\n                   attributetype DOLLAR
        match-type /\n                   LPAREN criteria RPAREN /\n                   true
        /\n                   false\n      match-type = \"EQ\" / \"SUBSTR\" / \"GE\"
        / \"LE\" / \"APPROX\"\n      true       = \"?true\"\n      false      = \"?false\"\n
        \     BAR        = %x7C  ; vertical bar (\"|\")\n      AMPERSAND  = %x26  ;
        ampersand (\"&\")\n      EXCLAIM    = %x21  ; exclamation mark (\"!\")\n   The
        <SHARP>, <WSP>, <oid>, <LPAREN>, <RPAREN>, <attributetype>, and\n   <DOLLAR>
        rules are defined in [RFC4512].\n   The LDAP definition for the Enhanced Guide
        syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.21 DESC 'Enhanced Guide' )\n
        \     Example:\n         person#(sn$EQ)#oneLevel\n   The Enhanced Guide syntax
        corresponds to the EnhancedGuide ASN.1 type\n   from [X.520].  The EnhancedGuide
        type references the Criteria ASN.1\n   type, also from [X.520].  The <true>
        rule, above, represents an empty\n   \"and\" expression in a value of the
        Criteria type.  The <false> rule,\n   above, represents an empty \"or\" expression
        in a value of the Criteria\n   type.\n"
      title: 3.3.10.  Enhanced Guide
    - contents:
      - "3.3.11.  Facsimile Telephone Number\n   A value of the Facsimile Telephone
        Number syntax is a subscriber\n   number of a facsimile device on the public
        switched telephone\n   network.  The LDAP-specific encoding of a value of
        this syntax is\n   defined by the following ABNF:\n      fax-number       =
        telephone-number *( DOLLAR fax-parameter )\n      telephone-number = PrintableString\n
        \     fax-parameter    = \"twoDimensional\" /\n                         \"fineResolution\"
        /\n                         \"unlimitedLength\" /\n                         \"b4Length\"
        /\n                         \"a3Width\" /\n                         \"b4Width\"
        /\n                         \"uncompressed\"\n   The <telephone-number> is
        a string of printable characters that\n   complies with the internationally
        agreed format for representing\n   international telephone numbers [E.123].
        \ The <PrintableString> rule\n   is defined in Section 3.2.  The <DOLLAR>
        rule is defined in\n   [RFC4512].\n   The LDAP definition for the Facsimile
        Telephone Number syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.22 DESC 'Facsimile
        Telephone Number')\n   The Facsimile Telephone Number syntax corresponds to
        the\n   FacsimileTelephoneNumber ASN.1 type from [X.520].\n"
      title: 3.3.11.  Facsimile Telephone Number
    - contents:
      - "3.3.12.  Fax\n   A value of the Fax syntax is an image that is produced using
        the\n   Group 3 facsimile process [FAX] to duplicate an object, such as a\n
        \  memo.  The LDAP-specific encoding of a value of this syntax is the\n   string
        of octets for a Group 3 Fax image as defined in [FAX].\n   The LDAP definition
        for the Fax syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.23 DESC 'Fax' )\n
        \  The ASN.1 type corresponding to the Fax syntax is defined as follows,\n
        \  assuming EXPLICIT TAGS:\n      Fax ::= CHOICE {\n        g3-facsimile  [3]
        G3FacsimileBodyPart\n      }\n   The G3FacsimileBodyPart ASN.1 type is defined
        in [X.420].\n"
      title: 3.3.12.  Fax
    - contents:
      - "3.3.13.  Generalized Time\n   A value of the Generalized Time syntax is a
        character string\n   representing a date and time.  The LDAP-specific encoding
        of a value\n   of this syntax is a restriction of the format defined in [ISO8601],\n
        \  and is described by the following ABNF:\n      GeneralizedTime = century
        year month day hour\n                           [ minute [ second / leap-second
        ] ]\n                           [ fraction ]\n                           g-time-zone\n
        \     century = 2(%x30-39) ; \"00\" to \"99\"\n      year    = 2(%x30-39)
        ; \"00\" to \"99\"\n      month   =   ( %x30 %x31-39 ) ; \"01\" (January)
        to \"09\"\n                / ( %x31 %x30-32 ) ; \"10\" to \"12\"\n      day
        \    =   ( %x30 %x31-39 )    ; \"01\" to \"09\"\n                / ( %x31-32
        %x30-39 ) ; \"10\" to \"29\"\n                / ( %x33 %x30-31 )    ; \"30\"
        to \"31\"\n      hour    = ( %x30-31 %x30-39 ) / ( %x32 %x30-33 ) ; \"00\"
        to \"23\"\n      minute  = %x30-35 %x30-39                        ; \"00\"
        to \"59\"\n      second      = ( %x30-35 %x30-39 ) ; \"00\" to \"59\"\n      leap-second
        = ( %x36 %x30 )       ; \"60\"\n      fraction        = ( DOT / COMMA ) 1*(%x30-39)\n
        \     g-time-zone     = %x5A  ; \"Z\"\n                        / g-differential\n
        \     g-differential  = ( MINUS / PLUS ) hour [ minute ]\n      MINUS           =
        %x2D  ; minus sign (\"-\")\n   The <DOT>, <COMMA>, and <PLUS> rules are defined
        in [RFC4512].\n   The above ABNF allows character strings that do not represent
        valid\n   dates (in the Gregorian calendar) and/or valid times (e.g., February\n
        \  31, 1994).  Such character strings SHOULD be considered invalid for\n   this
        syntax.\n   The time value represents coordinated universal time (equivalent
        to\n   Greenwich Mean Time) if the \"Z\" form of <g-time-zone> is used;\n
        \  otherwise, the value represents a local time in the time zone\n   indicated
        by <g-differential>.  In the latter case, coordinated\n   universal time can
        be calculated by subtracting the differential from\n   the local time.  The
        \"Z\" form of <g-time-zone> SHOULD be used in\n   preference to <g-differential>.\n
        \  If <minute> is omitted, then <fraction> represents a fraction of an\n   hour;
        otherwise, if <second> and <leap-second> are omitted, then\n   <fraction>
        represents a fraction of a minute; otherwise, <fraction>\n   represents a
        fraction of a second.\n      Examples:\n         199412161032Z\n         199412160532-0500\n
        \  Both example values represent the same coordinated universal time:\n   10:32
        AM, December 16, 1994.\n   The LDAP definition for the Generalized Time syntax
        is:\n      ( 1.3.6.1.4.1.1466.115.121.1.24 DESC 'Generalized Time' )\n   This
        syntax corresponds to the GeneralizedTime ASN.1 type from\n   [ASN.1], with
        the constraint that local time without a differential\n   SHALL NOT be used.\n"
      title: 3.3.13.  Generalized Time
    - contents:
      - "3.3.14.  Guide\n   A value of the Guide syntax suggests criteria, which consist
        of\n   combinations of attribute types and filter operators, to be used in\n
        \  constructing filters to search for entries of particular object\n   classes.
        \ The Guide syntax is obsolete and should not be used for\n   defining new
        attribute types.\n   The LDAP-specific encoding of a value of this syntax
        is defined by\n   the following ABNF:\n      Guide = [ object-class SHARP
        ] criteria\n   The <object-class> and <criteria> rules are defined in Section\n
        \  3.3.10.  The <SHARP> rule is defined in [RFC4512].\n   The LDAP definition
        for the Guide syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.25 DESC 'Guide'
        )\n   The Guide syntax corresponds to the Guide ASN.1 type from [X.520].\n"
      title: 3.3.14.  Guide
    - contents:
      - "3.3.15.  IA5 String\n   A value of the IA5 String syntax is a string of zero,
        one, or more\n   characters from International Alphabet 5 (IA5) [T.50], the\n
        \  international version of the ASCII character set.  The LDAP-specific\n
        \  encoding of a value of this syntax is the unconverted string of\n   characters,
        which conforms to the <IA5String> rule in Section 3.2.\n   The LDAP definition
        for the IA5 String syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.26 DESC
        'IA5 String' )\n   This syntax corresponds to the IA5String ASN.1 type from
        [ASN.1].\n"
      title: 3.3.15.  IA5 String
    - contents:
      - "3.3.16.  Integer\n   A value of the Integer syntax is a whole number of unlimited\n
        \  magnitude.  The LDAP-specific encoding of a value of this syntax is\n   the
        optionally signed decimal digit character string representation\n   of the
        number (for example, the number 1321 is represented by the\n   character string
        \"1321\").  The encoding is defined by the following\n   ABNF:\n      Integer
        = ( HYPHEN LDIGIT *DIGIT ) / number\n   The <HYPHEN>, <LDIGIT>, <DIGIT>, and
        <number> rules are defined in\n   [RFC4512].\n   The LDAP definition for the
        Integer syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.27 DESC 'INTEGER' )\n
        \  This syntax corresponds to the INTEGER ASN.1 type from [ASN.1].\n"
      title: 3.3.16.  Integer
    - contents:
      - "3.3.17.  JPEG\n   A value of the JPEG syntax is an image in the JPEG File
        Interchange\n   Format (JFIF), as described in [JPEG].  The LDAP-specific
        encoding of\n   a value of this syntax is the sequence of octets of the JFIF
        encoding\n   of the image.\n   The LDAP definition for the JPEG syntax is:\n
        \     ( 1.3.6.1.4.1.1466.115.121.1.28 DESC 'JPEG' )\n   The JPEG syntax corresponds
        to the following ASN.1 type:\n      JPEG ::= OCTET STRING (CONSTRAINED BY\n
        \                  { -- contents octets are an image in the --\n                     --
        JPEG File Interchange Format -- })\n"
      title: 3.3.17.  JPEG
    - contents:
      - "3.3.18.  LDAP Syntax Description\n   A value of the LDAP Syntax Description
        syntax is the description of\n   an LDAP syntax.  The LDAP-specific encoding
        of a value of this syntax\n   is defined by the <SyntaxDescription> rule in
        [RFC4512].\n   The LDAP definition for the LDAP Syntax Description syntax
        is:\n      ( 1.3.6.1.4.1.1466.115.121.1.54 DESC 'LDAP Syntax Description'
        )\n   The above LDAP definition for the LDAP Syntax Description syntax is\n
        \  itself a legal value of the LDAP Syntax Description syntax.\n   The ASN.1
        type corresponding to the LDAP Syntax Description syntax is\n   defined as
        follows, assuming EXPLICIT TAGS:\n      LDAPSyntaxDescription ::= SEQUENCE
        {\n          identifier      OBJECT IDENTIFIER,\n          description     DirectoryString
        { ub-schema } OPTIONAL }\n   The DirectoryString parameterized ASN.1 type
        is defined in [X.520].\n   The value of ub-schema (an integer) is implementation
        defined.  A\n   non-normative definition appears in [X.520].\n"
      title: 3.3.18.  LDAP Syntax Description
    - contents:
      - "3.3.19.  Matching Rule Description\n   A value of the Matching Rule Description
        syntax is the definition of\n   a matching rule.  The LDAP-specific encoding
        of a value of this\n   syntax is defined by the <MatchingRuleDescription>
        rule in [RFC4512].\n      Example:\n         ( 2.5.13.2 NAME 'caseIgnoreMatch'\n
        \           SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )\n   Note: A line break
        has been added for readability; it is not part of\n   the syntax.\n   The
        LDAP definition for the Matching Rule Description syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.30
        DESC 'Matching Rule Description' )\n   This syntax corresponds to the MatchingRuleDescription
        ASN.1 type\n   from [X.501].\n"
      title: 3.3.19.  Matching Rule Description
    - contents:
      - "3.3.20.  Matching Rule Use Description\n   A value of the Matching Rule Use
        Description syntax indicates the\n   attribute types to which a matching rule
        may be applied in an\n   extensibleMatch search filter [RFC4511].  The LDAP-specific
        encoding\n   of a value of this syntax is defined by the\n   <MatchingRuleUseDescription>
        rule in [RFC4512].\n      Example:\n         ( 2.5.13.16 APPLIES ( givenName
        $ surname ) )\n   The LDAP definition for the Matching Rule Use Description
        syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.31\n         DESC 'Matching
        Rule Use Description' )\n   This syntax corresponds to the MatchingRuleUseDescription
        ASN.1 type\n   from [X.501].\n"
      title: 3.3.20.  Matching Rule Use Description
    - contents:
      - "3.3.21.  Name and Optional UID\n   A value of the Name and Optional UID syntax
        is the distinguished name\n   [RFC4512] of an entity optionally accompanied
        by a unique identifier\n   that serves to differentiate the entity from others
        with an identical\n   distinguished name.\n   The LDAP-specific encoding of
        a value of this syntax is defined by\n   the following ABNF:\n      NameAndOptionalUID
        = distinguishedName [ SHARP BitString ]\n   The <BitString> rule is defined
        in Section 3.3.2.  The\n   <distinguishedName> rule is defined in [RFC4514].
        \ The <SHARP> rule\n   is defined in [RFC4512].\n   Note that although the
        '#' character may occur in the string\n   representation of a distinguished
        name, no additional escaping of\n   this character is performed when a <distinguishedName>
        is encoded in\n   a <NameAndOptionalUID>.\n      Example:\n         1.3.6.1.4.1.1466.0=#04024869,O=Test,C=GB#'0101'B\n
        \  The LDAP definition for the Name and Optional UID syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.34
        DESC 'Name And Optional UID' )\n   This syntax corresponds to the NameAndOptionalUID
        ASN.1 type from\n   [X.520].\n"
      title: 3.3.21.  Name and Optional UID
    - contents:
      - "3.3.22.  Name Form Description\n   A value of the Name Form Description syntax
        is the definition of a\n   name form, which regulates how entries may be named.
        \ The LDAP-\n   specific encoding of a value of this syntax is defined by
        the\n   <NameFormDescription> rule in [RFC4512].\n      Example:\n         (
        2.5.15.3 NAME 'orgNameForm' OC organization MUST o )\n   The LDAP definition
        for the Name Form Description syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.35
        DESC 'Name Form Description' )\n   This syntax corresponds to the NameFormDescription
        ASN.1 type from\n   [X.501].\n"
      title: 3.3.22.  Name Form Description
    - contents:
      - "3.3.23.  Numeric String\n   A value of the Numeric String syntax is a sequence
        of one or more\n   numerals and spaces.  The LDAP-specific encoding of a value
        of this\n   syntax is the unconverted string of characters, which conforms
        to the\n   following ABNF:\n      NumericString = 1*(DIGIT / SPACE)\n   The
        <DIGIT> and <SPACE> rules are defined in [RFC4512].\n      Example:\n         15
        079 672 281\n   The LDAP definition for the Numeric String syntax is:\n      (
        1.3.6.1.4.1.1466.115.121.1.36 DESC 'Numeric String' )\n   This syntax corresponds
        to the NumericString ASN.1 type from [ASN.1].\n"
      title: 3.3.23.  Numeric String
    - contents:
      - "3.3.24.  Object Class Description\n   A value of the Object Class Description
        syntax is the definition of\n   an object class.  The LDAP-specific encoding
        of a value of this\n   syntax is defined by the <ObjectClassDescription> rule
        in [RFC4512].\n      Example:\n         ( 2.5.6.2 NAME 'country' SUP top STRUCTURAL
        MUST c\n            MAY ( searchGuide $ description ) )\n   Note: A line break
        has been added for readability; it is not part of\n   the syntax.\n   The
        LDAP definition for the Object Class Description syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.37
        DESC 'Object Class Description' )\n   This syntax corresponds to the ObjectClassDescription
        ASN.1 type from\n   [X.501].\n"
      title: 3.3.24.  Object Class Description
    - contents:
      - "3.3.25.  Octet String\n   A value of the Octet String syntax is a sequence
        of zero, one, or\n   more arbitrary octets.  The LDAP-specific encoding of
        a value of this\n   syntax is the unconverted sequence of octets, which conforms
        to the\n   following ABNF:\n      OctetString = *OCTET\n   The <OCTET> rule
        is defined in [RFC4512].  Values of this syntax are\n   not generally human-readable.\n
        \  The LDAP definition for the Octet String syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.40
        DESC 'Octet String' )\n   This syntax corresponds to the OCTET STRING ASN.1
        type from [ASN.1].\n"
      title: 3.3.25.  Octet String
    - contents:
      - "3.3.26.  OID\n   A value of the OID syntax is an object identifier: a sequence
        of two\n   or more non-negative integers that uniquely identify some object
        or\n   item of specification.  Many of the object identifiers used in LDAP\n
        \  also have IANA registered names [RFC4520].\n   The LDAP-specific encoding
        of a value of this syntax is defined by\n   the <oid> rule in [RFC4512].\n
        \     Examples:\n         1.2.3.4\n         cn\n   The LDAP definition for
        the OID syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.38 DESC 'OID' )\n   This
        syntax corresponds to the OBJECT IDENTIFIER ASN.1 type from\n   [ASN.1].\n"
      title: 3.3.26.  OID
    - contents:
      - "3.3.27.  Other Mailbox\n   A value of the Other Mailbox syntax identifies
        an electronic mailbox,\n   in a particular named mail system.  The LDAP-specific
        encoding of a\n   value of this syntax is defined by the following ABNF:\n
        \     OtherMailbox = mailbox-type DOLLAR mailbox\n      mailbox-type = PrintableString\n
        \     mailbox      = IA5String\n   The <mailbox-type> rule represents the
        type of mail system in which\n   the mailbox resides (for example, \"MCIMail\"),
        and <mailbox> is the\n   actual mailbox in the mail system described by <mailbox-type>.
        \ The\n   <PrintableString> and <IA5String> rules are defined in Section 3.2.\n
        \  The <DOLLAR> rule is defined in [RFC4512].\n   The LDAP definition for
        the Other Mailbox syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.39 DESC 'Other
        Mailbox' )\n   The ASN.1 type corresponding to the Other Mailbox syntax is
        defined\n   as follows, assuming EXPLICIT TAGS:\n      OtherMailbox ::= SEQUENCE
        {\n          mailboxType  PrintableString,\n          mailbox      IA5String\n
        \     }\n"
      title: 3.3.27.  Other Mailbox
    - contents:
      - "3.3.28.  Postal Address\n   A value of the Postal Address syntax is a sequence
        of strings of one\n   or more arbitrary UCS characters, which form an address
        in a physical\n   mail system.\n   The LDAP-specific encoding of a value of
        this syntax is defined by\n   the following ABNF:\n      PostalAddress = line
        *( DOLLAR line )\n      line          = 1*line-char\n      line-char     =
        %x00-23\n                      / (%x5C \"24\")  ; escaped \"$\"\n                      /
        %x25-5B\n                      / (%x5C \"5C\")  ; escaped \"\\\"\n                      /
        %x5D-7F\n                      / UTFMB\n   Each character string (i.e., <line>)
        of a postal address value is\n   encoded as a UTF-8 [RFC3629] string, except
        that \"\\\" and \"$\"\n   characters, if they occur in the string, are escaped
        by a \"\\\"\n   character followed by the two hexadecimal digit code for the\n
        \  character.  The <DOLLAR> and <UTFMB> rules are defined in [RFC4512].\n
        \  Many servers limit the postal address to no more than six lines of no\n
        \  more than thirty characters each.\n      Example:\n         1234 Main St.$Anytown,
        CA 12345$USA\n         \\241,000,000 Sweepstakes$PO Box 1000000$Anytown, CA
        12345$USA\n   The LDAP definition for the Postal Address syntax is:\n      (
        1.3.6.1.4.1.1466.115.121.1.41 DESC 'Postal Address' )\n   This syntax corresponds
        to the PostalAddress ASN.1 type from [X.520];\n   that is\n      PostalAddress
        ::= SEQUENCE SIZE(1..ub-postal-line) OF\n          DirectoryString { ub-postal-string
        }\n   The values of ub-postal-line and ub-postal-string (both integers) are\n
        \  implementation defined.  Non-normative definitions appear in [X.520].\n"
      title: 3.3.28.  Postal Address
    - contents:
      - "3.3.29.  Printable String\n   A value of the Printable String syntax is a
        string of one or more\n   latin alphabetic, numeric, and selected punctuation
        characters as\n   specified by the <PrintableCharacter> rule in Section 3.2.\n
        \  The LDAP-specific encoding of a value of this syntax is the\n   unconverted
        string of characters, which conforms to the\n   <PrintableString> rule in
        Section 3.2.\n      Example:\n         This is a PrintableString.\n   The
        LDAP definition for the PrintableString syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.44
        DESC 'Printable String' )\n   This syntax corresponds to the PrintableString
        ASN.1 type from\n   [ASN.1].\n"
      title: 3.3.29.  Printable String
    - contents:
      - "3.3.30.  Substring Assertion\n   A value of the Substring Assertion syntax
        is a sequence of zero, one,\n   or more character substrings used as an argument
        for substring\n   extensible matching of character string attribute values;
        i.e., as\n   the matchValue of a MatchingRuleAssertion [RFC4511].  Each substring\n
        \  is a string of one or more arbitrary characters from the Universal\n   Character
        Set (UCS) [UCS].  A zero-length substring is not permitted.\n   The LDAP-specific
        encoding of a value of this syntax is defined by\n   the following ABNF:\n
        \     SubstringAssertion = [ initial ] any [ final ]\n      initial  = substring\n
        \     any      = ASTERISK *(substring ASTERISK)\n      final    = substring\n
        \     ASTERISK = %x2A  ; asterisk (\"*\")\n      substring           = 1*substring-character\n
        \     substring-character = %x00-29\n                            / (%x5C \"2A\")
        \ ; escaped \"*\"\n                            / %x2B-5B\n                            /
        (%x5C \"5C\")  ; escaped \"\\\"\n                            / %x5D-7F\n                            /
        UTFMB\n   Each <substring> of a Substring Assertion value is encoded as a
        UTF-8\n   [RFC3629] string, except that \"\\\" and \"*\" characters, if they
        occur\n   in the substring, are escaped by a \"\\\" character followed by
        the two\n   hexadecimal digit code for the character.\n   The Substring Assertion
        syntax is used only as the syntax of\n   assertion values in the extensible
        match.  It is not used as an\n   attribute syntax, or in the SubstringFilter
        [RFC4511].\n   The LDAP definition for the Substring Assertion syntax is:\n
        \     ( 1.3.6.1.4.1.1466.115.121.1.58 DESC 'Substring Assertion' )\n   This
        syntax corresponds to the SubstringAssertion ASN.1 type from\n   [X.520].\n"
      title: 3.3.30.  Substring Assertion
    - contents:
      - "3.3.31.  Telephone Number\n   A value of the Telephone Number syntax is a
        string of printable\n   characters that complies with the internationally
        agreed format for\n   representing international telephone numbers [E.123].\n
        \  The LDAP-specific encoding of a value of this syntax is the\n   unconverted
        string of characters, which conforms to the\n   <PrintableString> rule in
        Section 3.2.\n      Examples:\n         +1 512 315 0280\n         +1-512-315-0280\n
        \        +61 3 9896 7830\n   The LDAP definition for the Telephone Number
        syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.50 DESC 'Telephone Number'
        )\n   The Telephone Number syntax corresponds to the following ASN.1 type\n
        \  from [X.520]:\n      PrintableString (SIZE(1..ub-telephone-number))\n   The
        value of ub-telephone-number (an integer) is implementation\n   defined.  A
        non-normative definition appears in [X.520].\n"
      title: 3.3.31.  Telephone Number
    - contents:
      - "3.3.32.  Teletex Terminal Identifier\n   A value of this syntax specifies
        the identifier and (optionally)\n   parameters of a teletex terminal.\n   The
        LDAP-specific encoding of a value of this syntax is defined by\n   the following
        ABNF:\n      teletex-id = ttx-term *(DOLLAR ttx-param)\n      ttx-term   =
        PrintableString          ; terminal identifier\n      ttx-param  = ttx-key
        COLON ttx-value  ; parameter\n      ttx-key    = \"graphic\" / \"control\"
        / \"misc\" / \"page\" / \"private\"\n      ttx-value  = *ttx-value-octet\n
        \     ttx-value-octet = %x00-23\n                        / (%x5C \"24\")  ;
        escaped \"$\"\n                        / %x25-5B\n                        /
        (%x5C \"5C\")  ; escaped \"\\\"\n                        / %x5D-FF\n   The
        <PrintableString> and <COLON> rules are defined in Section 3.2.\n   The <DOLLAR>
        rule is defined in [RFC4512].\n   The LDAP definition for the Teletex Terminal
        Identifier syntax is:\n      ( 1.3.6.1.4.1.1466.115.121.1.51\n         DESC
        'Teletex Terminal Identifier' )\n   This syntax corresponds to the TeletexTerminalIdentifier
        ASN.1 type\n   from [X.520].\n"
      title: 3.3.32.  Teletex Terminal Identifier
    - contents:
      - "3.3.33.  Telex Number\n   A value of the Telex Number syntax specifies the
        telex number,\n   country code, and answerback code of a telex terminal.\n
        \  The LDAP-specific encoding of a value of this syntax is defined by\n   the
        following ABNF:\n      telex-number  = actual-number DOLLAR country-code\n
        \                        DOLLAR answerback\n      actual-number = PrintableString\n
        \     country-code  = PrintableString\n      answerback    = PrintableString\n
        \  The <PrintableString> rule is defined in Section 3.2.  The <DOLLAR>\n   rule
        is defined in [RFC4512].\n   The LDAP definition for the Telex Number syntax
        is:\n      ( 1.3.6.1.4.1.1466.115.121.1.52 DESC 'Telex Number' )\n   This
        syntax corresponds to the TelexNumber ASN.1 type from [X.520].\n"
      title: 3.3.33.  Telex Number
    - contents:
      - "3.3.34.  UTC Time\n   A value of the UTC Time syntax is a character string
        representing a\n   date and time to a precision of one minute or one second.
        \ The year\n   is given as a two-digit number.  The LDAP-specific encoding
        of a\n   value of this syntax follows the format defined in [ASN.1] for the\n
        \  UTCTime type and is described by the following ABNF:\n      UTCTime         =
        year month day hour minute [ second ]\n                           [ u-time-zone
        ]\n      u-time-zone     = %x5A  ; \"Z\"\n                        / u-differential\n
        \     u-differential  = ( MINUS / PLUS ) hour minute\n   The <year>, <month>,
        <day>, <hour>, <minute>, <second>, and <MINUS>\n   rules are defined in Section
        3.3.13.  The <PLUS> rule is defined in\n   [RFC4512].\n   The above ABNF allows
        character strings that do not represent valid\n   dates (in the Gregorian
        calendar) and/or valid times.  Such character\n   strings SHOULD be considered
        invalid for this syntax.\n   The time value represents coordinated universal
        time if the \"Z\" form\n   of <u-time-zone> is used; otherwise, the value
        represents a local\n   time.  In the latter case, if <u-differential> is provided,
        then\n   coordinated universal time can be calculated by subtracting the\n
        \  differential from the local time.  The <u-time-zone> SHOULD be\n   present
        in time values, and the \"Z\" form of <u-time-zone> SHOULD be\n   used in
        preference to <u-differential>.\n   The LDAP definition for the UTC Time syntax
        is:\n      ( 1.3.6.1.4.1.1466.115.121.1.53 DESC 'UTC Time' )\n   Note: This
        syntax is deprecated in favor of the Generalized Time\n   syntax.\n   The
        UTC Time syntax corresponds to the UTCTime ASN.1 type from\n   [ASN.1].\n"
      title: 3.3.34.  UTC Time
    title: 3.3.  Syntax Definitions
  title: 3.  Syntaxes
- contents:
  - "4.  Matching Rules\n   Matching rules are used by directory implementations to
    compare\n   attribute values against assertion values when performing Search and\n
    \  Compare operations [RFC4511].  They are also used when comparing a\n   purported
    distinguished name [RFC4512] with the name of an entry.\n   When modifying entries,
    matching rules are used to identify values to\n   be deleted and to prevent an
    attribute from containing two equal\n   values.\n   Matching rules that are required
    for directory operation, or that are\n   in common use, are specified in this
    section.\n"
  - contents:
    - "4.1.  General Considerations\n   A matching rule is applied to attribute values
      through an\n   AttributeValueAssertion or MatchingRuleAssertion [RFC4511].  The\n
      \  conditions under which an AttributeValueAssertion or\n   MatchingRuleAssertion
      evaluates to Undefined are specified elsewhere\n   [RFC4511].  If an assertion
      is not Undefined, then the result of the\n   assertion is the result of applying
      the selected matching rule.  A\n   matching rule evaluates to TRUE, and in some
      cases Undefined, as\n   specified in the description of the matching rule; otherwise,
      it\n   evaluates to FALSE.\n   Each assertion contains an assertion value.  The
      definition of each\n   matching rule specifies the syntax for the assertion
      value.  The\n   syntax of the assertion value is typically, but not necessarily,
      the\n   same as the syntax of the attribute values to which the matching rule\n
      \  may be applied.  Note that an AssertionValue in a SubstringFilter\n   [RFC4511]
      conforms to the assertion syntax of the equality matching\n   rule for the attribute
      type rather than to the assertion syntax of\n   the substrings matching rule
      for the attribute type.  Conceptually,\n   the entire SubstringFilter is converted
      into an assertion value of\n   the substrings matching rule prior to applying
      the rule.\n   The definition of each matching rule indicates the attribute syntaxes\n
      \  to which the rule may be applied, by specifying conditions the\n   corresponding
      ASN.1 type of a candidate attribute syntax must\n   satisfy.  These conditions
      are also satisfied if the corresponding\n   ASN.1 type is a tagged or constrained
      derivative of the ASN.1 type\n   explicitly mentioned in the rule description
      (i.e., ASN.1 tags and\n   constraints are ignored in checking applicability),
      or is an\n   alternative reference notation for the explicitly mentioned type.\n
      \  Each rule description lists, as examples of applicable attribute\n   syntaxes,
      the complete list of the syntaxes defined in this document\n   to which the
      matching rule applies.  A matching rule may be\n   applicable to additional
      syntaxes defined in other documents if those\n   syntaxes satisfy the conditions
      on the corresponding ASN.1 type.\n   The description of each matching rule indicates
      whether the rule is\n   suitable for use as the equality matching rule (EQUALITY),
      ordering\n   matching rule (ORDERING), or substrings matching rule (SUBSTR)
      in an\n   attribute type definition [RFC4512].\n   Each matching rule is uniquely
      identified with an object identifier.\n   The definition of a matching rule
      should not subsequently be changed.\n   If a change is desirable, then a new
      matching rule with a different\n   object identifier should be defined instead.\n
      \  Servers MAY implement the wordMatch and keywordMatch matching rules,\n   but
      they SHOULD implement the other matching rules in Section 4.2.\n   Servers MAY
      implement additional matching rules.\n   Servers that implement the extensibleMatch
      filter SHOULD allow the\n   matching rules listed in Section 4.2 to be used
      in the\n   extensibleMatch filter and SHOULD allow matching rules to be used\n
      \  with all attribute types known to the server, where the assertion\n   syntax
      of the matching rule is the same as the value syntax of the\n   attribute.\n
      \  Servers MUST publish, in the matchingRules attribute, the definitions\n   of
      matching rules referenced by values of the attributeTypes and\n   matchingRuleUse
      attributes in the same subschema entry.  Other\n   unreferenced matching rules
      MAY be published in the matchingRules\n   attribute.\n   If the server supports
      the extensibleMatch filter, then the server\n   MAY use the matchingRuleUse
      attribute to indicate the applicability\n   (in an extensibleMatch filter) of
      selected matching rules to\n   nominated attribute types.\n"
    title: 4.1.  General Considerations
  - contents:
    - "4.2.  Matching Rule Definitions\n   Nominated character strings in assertion
      and attribute values are\n   prepared according to the string preparation algorithms
      [RFC4518] for\n   LDAP when evaluating the following matching rules:\n      numericStringMatch,\n
      \     numericStringSubstringsMatch,\n      caseExactMatch,\n      caseExactOrderingMatch,\n
      \     caseExactSubstringsMatch,\n      caseExactIA5Match,\n      caseIgnoreIA5Match,\n
      \     caseIgnoreIA5SubstringsMatch,\n      caseIgnoreListMatch,\n      caseIgnoreListSubstringsMatch,\n
      \     caseIgnoreMatch,\n      caseIgnoreOrderingMatch,\n      caseIgnoreSubstringsMatch,\n
      \     directoryStringFirstComponentMatch,\n      telephoneNumberMatch,\n      telephoneNumberSubstringsMatch
      and\n      wordMatch.\n   The Transcode, Normalize, Prohibit, and Check bidi
      steps are the same\n   for each of the matching rules.  However, the Map and
      Insignificant\n   Character Handling steps depend on the specific rule, as detailed
      in\n   the description of these matching rules in the sections that follow.\n"
    - contents:
      - "4.2.1.  bitStringMatch\n   The bitStringMatch rule compares an assertion
        value of the Bit String\n   syntax to an attribute value of a syntax (e.g.,
        the Bit String\n   syntax) whose corresponding ASN.1 type is BIT STRING.\n
        \  If the corresponding ASN.1 type of the attribute syntax does not have\n
        \  a named bit list [ASN.1] (which is the case for the Bit String\n   syntax),
        then the rule evaluates to TRUE if and only if the attribute\n   value has
        the same number of bits as the assertion value and the bits\n   match on a
        bitwise basis.\n   If the corresponding ASN.1 type does have a named bit list,
        then\n   bitStringMatch operates as above, except that trailing zero bits
        in\n   the attribute and assertion values are treated as absent.\n   The LDAP
        definition for the bitStringMatch rule is:\n      ( 2.5.13.16 NAME 'bitStringMatch'\n
        \        SYNTAX 1.3.6.1.4.1.1466.115.121.1.6 )\n   The bitStringMatch rule
        is an equality matching rule.\n"
      title: 4.2.1.  bitStringMatch
    - contents:
      - "4.2.2.  booleanMatch\n   The booleanMatch rule compares an assertion value
        of the Boolean\n   syntax to an attribute value of a syntax (e.g., the Boolean
        syntax)\n   whose corresponding ASN.1 type is BOOLEAN.\n   The rule evaluates
        to TRUE if and only if the attribute value and the\n   assertion value are
        both TRUE or both FALSE.\n   The LDAP definition for the booleanMatch rule
        is:\n      ( 2.5.13.13 NAME 'booleanMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        )\n   The booleanMatch rule is an equality matching rule.\n"
      title: 4.2.2.  booleanMatch
    - contents:
      - "4.2.3.  caseExactIA5Match\n   The caseExactIA5Match rule compares an assertion
        value of the IA5\n   String syntax to an attribute value of a syntax (e.g.,
        the IA5 String\n   syntax) whose corresponding ASN.1 type is IA5String.\n
        \  The rule evaluates to TRUE if and only if the prepared attribute\n   value
        character string and the prepared assertion value character\n   string have
        the same number of characters and corresponding\n   characters have the same
        code point.\n   In preparing the attribute value and assertion value for comparison,\n
        \  characters are not case folded in the Map preparation step, and only\n
        \  Insignificant Space Handling is applied in the Insignificant\n   Character
        Handling step.\n   The LDAP definition for the caseExactIA5Match rule is:\n
        \     ( 1.3.6.1.4.1.1466.109.114.1 NAME 'caseExactIA5Match'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.26 )\n   The caseExactIA5Match rule is an equality
        matching rule.\n"
      title: 4.2.3.  caseExactIA5Match
    - contents:
      - "4.2.4.  caseExactMatch\n   The caseExactMatch rule compares an assertion
        value of the Directory\n   String syntax to an attribute value of a syntax
        (e.g., the Directory\n   String, Printable String, Country String, or Telephone
        Number syntax)\n   whose corresponding ASN.1 type is DirectoryString or one
        of the\n   alternative string types of DirectoryString, such as PrintableString\n
        \  (the other alternatives do not correspond to any syntax defined in\n   this
        document).\n   The rule evaluates to TRUE if and only if the prepared attribute\n
        \  value character string and the prepared assertion value character\n   string
        have the same number of characters and corresponding\n   characters have the
        same code point.\n   In preparing the attribute value and assertion value
        for comparison,\n   characters are not case folded in the Map preparation
        step, and only\n   Insignificant Space Handling is applied in the Insignificant\n
        \  Character Handling step.\n   The LDAP definition for the caseExactMatch
        rule is:\n      ( 2.5.13.5 NAME 'caseExactMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
        )\n   The caseExactMatch rule is an equality matching rule.\n"
      title: 4.2.4.  caseExactMatch
    - contents:
      - "4.2.5.  caseExactOrderingMatch\n   The caseExactOrderingMatch rule compares
        an assertion value of the\n   Directory String syntax to an attribute value
        of a syntax (e.g., the\n   Directory String, Printable String, Country String,
        or Telephone\n   Number syntax) whose corresponding ASN.1 type is DirectoryString
        or\n   one of its alternative string types.\n   The rule evaluates to TRUE
        if and only if, in the code point\n   collation order, the prepared attribute
        value character string\n   appears earlier than the prepared assertion value
        character string;\n   i.e., the attribute value is \"less than\" the assertion
        value.\n   In preparing the attribute value and assertion value for comparison,\n
        \  characters are not case folded in the Map preparation step, and only\n
        \  Insignificant Space Handling is applied in the Insignificant\n   Character
        Handling step.\n   The LDAP definition for the caseExactOrderingMatch rule
        is:\n      ( 2.5.13.6 NAME 'caseExactOrderingMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
        )\n   The caseExactOrderingMatch rule is an ordering matching rule.\n"
      title: 4.2.5.  caseExactOrderingMatch
    - contents:
      - "4.2.6.  caseExactSubstringsMatch\n   The caseExactSubstringsMatch rule compares
        an assertion value of the\n   Substring Assertion syntax to an attribute value
        of a syntax (e.g.,\n   the Directory String, Printable String, Country String,
        or Telephone\n   Number syntax) whose corresponding ASN.1 type is DirectoryString
        or\n   one of its alternative string types.\n   The rule evaluates to TRUE
        if and only if (1) the prepared substrings\n   of the assertion value match
        disjoint portions of the prepared\n   attribute value character string in
        the order of the substrings in\n   the assertion value, (2) an <initial> substring,
        if present, matches\n   the beginning of the prepared attribute value character
        string, and\n   (3) a <final> substring, if present, matches the end of the
        prepared\n   attribute value character string.  A prepared substring matches
        a\n   portion of the prepared attribute value character string if\n   corresponding
        characters have the same code point.\n   In preparing the attribute value
        and assertion value substrings for\n   comparison, characters are not case
        folded in the Map preparation\n   step, and only Insignificant Space Handling
        is applied in the\n   Insignificant Character Handling step.\n   The LDAP
        definition for the caseExactSubstringsMatch rule is:\n      ( 2.5.13.7 NAME
        'caseExactSubstringsMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.58
        )\n   The caseExactSubstringsMatch rule is a substrings matching rule.\n"
      title: 4.2.6.  caseExactSubstringsMatch
    - contents:
      - "4.2.7.  caseIgnoreIA5Match\n   The caseIgnoreIA5Match rule compares an assertion
        value of the IA5\n   String syntax to an attribute value of a syntax (e.g.,
        the IA5 String\n   syntax) whose corresponding ASN.1 type is IA5String.\n
        \  The rule evaluates to TRUE if and only if the prepared attribute\n   value
        character string and the prepared assertion value character\n   string have
        the same number of characters and corresponding\n   characters have the same
        code point.\n   In preparing the attribute value and assertion value for comparison,\n
        \  characters are case folded in the Map preparation step, and only\n   Insignificant
        Space Handling is applied in the Insignificant\n   Character Handling step.\n
        \  The LDAP definition for the caseIgnoreIA5Match rule is:\n      ( 1.3.6.1.4.1.1466.109.114.2
        NAME 'caseIgnoreIA5Match'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )\n
        \  The caseIgnoreIA5Match rule is an equality matching rule.\n"
      title: 4.2.7.  caseIgnoreIA5Match
    - contents:
      - "4.2.8.  caseIgnoreIA5SubstringsMatch\n   The caseIgnoreIA5SubstringsMatch
        rule compares an assertion value of\n   the Substring Assertion syntax to
        an attribute value of a syntax\n   (e.g., the IA5 String syntax) whose corresponding
        ASN.1 type is\n   IA5String.\n   The rule evaluates to TRUE if and only if
        (1) the prepared substrings\n   of the assertion value match disjoint portions
        of the prepared\n   attribute value character string in the order of the substrings
        in\n   the assertion value, (2) an <initial> substring, if present, matches\n
        \  the beginning of the prepared attribute value character string, and\n   (3)
        a <final> substring, if present, matches the end of the prepared\n   attribute
        value character string.  A prepared substring matches a\n   portion of the
        prepared attribute value character string if\n   corresponding characters
        have the same code point.\n   In preparing the attribute value and assertion
        value substrings for\n   comparison, characters are case folded in the Map
        preparation step,\n   and only Insignificant Space Handling is applied in
        the Insignificant\n   Character Handling step.\n      ( 1.3.6.1.4.1.1466.109.114.3
        NAME 'caseIgnoreIA5SubstringsMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.58
        )\n   The caseIgnoreIA5SubstringsMatch rule is a substrings matching rule.\n"
      title: 4.2.8.  caseIgnoreIA5SubstringsMatch
    - contents:
      - "4.2.9.  caseIgnoreListMatch\n   The caseIgnoreListMatch rule compares an
        assertion value that is a\n   sequence of strings to an attribute value of
        a syntax (e.g., the\n   Postal Address syntax) whose corresponding ASN.1 type
        is a SEQUENCE\n   OF the DirectoryString ASN.1 type.\n   The rule evaluates
        to TRUE if and only if the attribute value and the\n   assertion value have
        the same number of strings and corresponding\n   strings (by position) match
        according to the caseIgnoreMatch matching\n   rule.\n   In [X.520], the assertion
        syntax for this matching rule is defined to\n   be:\n      SEQUENCE OF DirectoryString
        {ub-match}\n   That is, it is different from the corresponding type for the
        Postal\n   Address syntax.  The choice of the Postal Address syntax for the\n
        \  assertion syntax of the caseIgnoreListMatch in LDAP should not be\n   seen
        as limiting the matching rule to apply only to attributes with\n   the Postal
        Address syntax.\n   The LDAP definition for the caseIgnoreListMatch rule is:\n
        \     ( 2.5.13.11 NAME 'caseIgnoreListMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.41
        )\n   The caseIgnoreListMatch rule is an equality matching rule.\n"
      title: 4.2.9.  caseIgnoreListMatch
    - contents:
      - "4.2.10.  caseIgnoreListSubstringsMatch\n   The caseIgnoreListSubstringsMatch
        rule compares an assertion value of\n   the Substring Assertion syntax to
        an attribute value of a syntax\n   (e.g., the Postal Address syntax) whose
        corresponding ASN.1 type is a\n   SEQUENCE OF the DirectoryString ASN.1 type.\n
        \  The rule evaluates to TRUE if and only if the assertion value\n   matches,
        per the caseIgnoreSubstringsMatch rule, the character string\n   formed by
        concatenating the strings of the attribute value, except\n   that none of
        the <initial>, <any>, or <final> substrings of the\n   assertion value are
        considered to match a substring of the\n   concatenated string which spans
        more than one of the original strings\n   of the attribute value.\n   Note
        that, in terms of the LDAP-specific encoding of the Postal\n   Address syntax,
        the concatenated string omits the <DOLLAR> line\n   separator and the escaping
        of \"\\\" and \"$\" characters.\n   The LDAP definition for the caseIgnoreListSubstringsMatch
        rule is:\n      ( 2.5.13.12 NAME 'caseIgnoreListSubstringsMatch'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.58 )\n   The caseIgnoreListSubstringsMatch rule
        is a substrings matching rule.\n"
      title: 4.2.10.  caseIgnoreListSubstringsMatch
    - contents:
      - "4.2.11.  caseIgnoreMatch\n   The caseIgnoreMatch rule compares an assertion
        value of the Directory\n   String syntax to an attribute value of a syntax
        (e.g., the Directory\n   String, Printable String, Country String, or Telephone
        Number syntax)\n   whose corresponding ASN.1 type is DirectoryString or one
        of its\n   alternative string types.\n   The rule evaluates to TRUE if and
        only if the prepared attribute\n   value character string and the prepared
        assertion value character\n   string have the same number of characters and
        corresponding\n   characters have the same code point.\n   In preparing the
        attribute value and assertion value for comparison,\n   characters are case
        folded in the Map preparation step, and only\n   Insignificant Space Handling
        is applied in the Insignificant\n   Character Handling step.\n   The LDAP
        definition for the caseIgnoreMatch rule is:\n      ( 2.5.13.2 NAME 'caseIgnoreMatch'\n
        \        SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )\n   The caseIgnoreMatch rule
        is an equality matching rule.\n"
      title: 4.2.11.  caseIgnoreMatch
    - contents:
      - "4.2.12.  caseIgnoreOrderingMatch\n   The caseIgnoreOrderingMatch rule compares
        an assertion value of the\n   Directory String syntax to an attribute value
        of a syntax (e.g., the\n   Directory String, Printable String, Country String,
        or Telephone\n   Number syntax) whose corresponding ASN.1 type is DirectoryString
        or\n   one of its alternative string types.\n   The rule evaluates to TRUE
        if and only if, in the code point\n   collation order, the prepared attribute
        value character string\n   appears earlier than the prepared assertion value
        character string;\n   i.e., the attribute value is \"less than\" the assertion
        value.\n   In preparing the attribute value and assertion value for comparison,\n
        \  characters are case folded in the Map preparation step, and only\n   Insignificant
        Space Handling is applied in the Insignificant\n   Character Handling step.\n
        \  The LDAP definition for the caseIgnoreOrderingMatch rule is:\n      ( 2.5.13.3
        NAME 'caseIgnoreOrderingMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
        )\n   The caseIgnoreOrderingMatch rule is an ordering matching rule.\n"
      title: 4.2.12.  caseIgnoreOrderingMatch
    - contents:
      - "4.2.13.  caseIgnoreSubstringsMatch\n   The caseIgnoreSubstringsMatch rule
        compares an assertion value of the\n   Substring Assertion syntax to an attribute
        value of a syntax (e.g.,\n   the Directory String, Printable String, Country
        String, or Telephone\n   Number syntax) whose corresponding ASN.1 type is
        DirectoryString or\n   one of its alternative string types.\n   The rule evaluates
        to TRUE if and only if (1) the prepared substrings\n   of the assertion value
        match disjoint portions of the prepared\n   attribute value character string
        in the order of the substrings in\n   the assertion value, (2) an <initial>
        substring, if present, matches\n   the beginning of the prepared attribute
        value character string, and\n   (3) a <final> substring, if present, matches
        the end of the prepared\n   attribute value character string.  A prepared
        substring matches a\n   portion of the prepared attribute value character
        string if\n   corresponding characters have the same code point.\n   In preparing
        the attribute value and assertion value substrings for\n   comparison, characters
        are case folded in the Map preparation step,\n   and only Insignificant Space
        Handling is applied in the Insignificant\n   Character Handling step.\n   The
        LDAP definition for the caseIgnoreSubstringsMatch rule is:\n      ( 2.5.13.4
        NAME 'caseIgnoreSubstringsMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.58
        )\n   The caseIgnoreSubstringsMatch rule is a substrings matching rule.\n"
      title: 4.2.13.  caseIgnoreSubstringsMatch
    - contents:
      - "4.2.14.  directoryStringFirstComponentMatch\n   The directoryStringFirstComponentMatch
        rule compares an assertion\n   value of the Directory String syntax to an
        attribute value of a\n   syntax whose corresponding ASN.1 type is a SEQUENCE
        with a mandatory\n   first component of the DirectoryString ASN.1 type.\n
        \  Note that the assertion syntax of this matching rule differs from the\n
        \  attribute syntax of attributes for which this is the equality\n   matching
        rule.\n   The rule evaluates to TRUE if and only if the assertion value matches\n
        \  the first component of the attribute value using the rules of\n   caseIgnoreMatch.\n
        \  The LDAP definition for the directoryStringFirstComponentMatch\n   matching
        rule is:\n      ( 2.5.13.31 NAME 'directoryStringFirstComponentMatch'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.15 )\n   The directoryStringFirstComponentMatch
        rule is an equality matching\n   rule.  When using directoryStringFirstComponentMatch
        to compare two\n   attribute values (of an applicable syntax), an assertion
        value must\n   first be derived from one of the attribute values.  An assertion\n
        \  value can be derived from an attribute value by taking the first\n   component
        of that attribute value.\n"
      title: 4.2.14.  directoryStringFirstComponentMatch
    - contents:
      - "4.2.15.  distinguishedNameMatch\n   The distinguishedNameMatch rule compares
        an assertion value of the DN\n   syntax to an attribute value of a syntax
        (e.g., the DN syntax) whose\n   corresponding ASN.1 type is DistinguishedName.\n
        \  The rule evaluates to TRUE if and only if the attribute value and the\n
        \  assertion value have the same number of relative distinguished names\n
        \  and corresponding relative distinguished names (by position) are the\n
        \  same.  A relative distinguished name (RDN) of the assertion value is\n
        \  the same as an RDN of the attribute value if and only if they have\n   the
        same number of attribute value assertions and each attribute\n   value assertion
        (AVA) of the first RDN is the same as the AVA of the\n   second RDN with the
        same attribute type.  The order of the AVAs is\n   not significant.  Also
        note that a particular attribute type may\n   appear in at most one AVA in
        an RDN.  Two AVAs with the same\n   attribute type are the same if their values
        are equal according to\n   the equality matching rule of the attribute type.
        \ If one or more of\n   the AVA comparisons evaluate to Undefined and the
        remaining AVA\n   comparisons return TRUE then the distinguishedNameMatch
        rule\n   evaluates to Undefined.\n   The LDAP definition for the distinguishedNameMatch
        rule is:\n      ( 2.5.13.1 NAME 'distinguishedNameMatch'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.12 )\n   The distinguishedNameMatch rule is an
        equality matching rule.\n"
      title: 4.2.15.  distinguishedNameMatch
    - contents:
      - "4.2.16.  generalizedTimeMatch\n   The generalizedTimeMatch rule compares
        an assertion value of the\n   Generalized Time syntax to an attribute value
        of a syntax (e.g., the\n   Generalized Time syntax) whose corresponding ASN.1
        type is\n   GeneralizedTime.\n   The rule evaluates to TRUE if and only if
        the attribute value\n   represents the same universal coordinated time as
        the assertion\n   value.  If a time is specified with the minutes or seconds
        absent,\n   then the number of minutes or seconds (respectively) is assumed
        to be\n   zero.\n   The LDAP definition for the generalizedTimeMatch rule
        is:\n      ( 2.5.13.27 NAME 'generalizedTimeMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.24
        )\n   The generalizedTimeMatch rule is an equality matching rule.\n"
      title: 4.2.16.  generalizedTimeMatch
    - contents:
      - "4.2.17.  generalizedTimeOrderingMatch\n   The generalizedTimeOrderingMatch
        rule compares the time ordering of\n   an assertion value of the Generalized
        Time syntax to an attribute\n   value of a syntax (e.g., the Generalized Time
        syntax) whose\n   corresponding ASN.1 type is GeneralizedTime.\n   The rule
        evaluates to TRUE if and only if the attribute value\n   represents a universal
        coordinated time that is earlier than the\n   universal coordinated time represented
        by the assertion value.\n   The LDAP definition for the generalizedTimeOrderingMatch
        rule is:\n      ( 2.5.13.28 NAME 'generalizedTimeOrderingMatch'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.24 )\n   The generalizedTimeOrderingMatch rule
        is an ordering matching rule.\n"
      title: 4.2.17.  generalizedTimeOrderingMatch
    - contents:
      - "4.2.18.  integerFirstComponentMatch\n   The integerFirstComponentMatch rule
        compares an assertion value of\n   the Integer syntax to an attribute value
        of a syntax (e.g., the DIT\n   Structure Rule Description syntax) whose corresponding
        ASN.1 type is\n   a SEQUENCE with a mandatory first component of the INTEGER
        ASN.1\n   type.\n   Note that the assertion syntax of this matching rule differs
        from the\n   attribute syntax of attributes for which this is the equality\n
        \  matching rule.\n   The rule evaluates to TRUE if and only if the assertion
        value and the\n   first component of the attribute value are the same integer
        value.\n   The LDAP definition for the integerFirstComponentMatch matching
        rule\n   is:\n      ( 2.5.13.29 NAME 'integerFirstComponentMatch'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.27 )\n   The integerFirstComponentMatch rule is
        an equality matching rule.\n   When using integerFirstComponentMatch to compare
        two attribute values\n   (of an applicable syntax), an assertion value must
        first be derived\n   from one of the attribute values.  An assertion value
        can be derived\n   from an attribute value by taking the first component of
        that\n   attribute value.\n"
      title: 4.2.18.  integerFirstComponentMatch
    - contents:
      - "4.2.19.  integerMatch\n   The integerMatch rule compares an assertion value
        of the Integer\n   syntax to an attribute value of a syntax (e.g., the Integer
        syntax)\n   whose corresponding ASN.1 type is INTEGER.\n   The rule evaluates
        to TRUE if and only if the attribute value and the\n   assertion value are
        the same integer value.\n   The LDAP definition for the integerMatch matching
        rule is:\n      ( 2.5.13.14 NAME 'integerMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        )\n   The integerMatch rule is an equality matching rule.\n"
      title: 4.2.19.  integerMatch
    - contents:
      - "4.2.20.  integerOrderingMatch\n   The integerOrderingMatch rule compares
        an assertion value of the\n   Integer syntax to an attribute value of a syntax
        (e.g., the Integer\n   syntax) whose corresponding ASN.1 type is INTEGER.\n
        \  The rule evaluates to TRUE if and only if the integer value of the\n   attribute
        value is less than the integer value of the assertion\n   value.\n   The LDAP
        definition for the integerOrderingMatch matching rule is:\n      ( 2.5.13.15
        NAME 'integerOrderingMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        )\n   The integerOrderingMatch rule is an ordering matching rule.\n"
      title: 4.2.20.  integerOrderingMatch
    - contents:
      - "4.2.21.  keywordMatch\n   The keywordMatch rule compares an assertion value
        of the Directory\n   String syntax to an attribute value of a syntax (e.g.,
        the Directory\n   String syntax) whose corresponding ASN.1 type is DirectoryString.\n
        \  The rule evaluates to TRUE if and only if the assertion value\n   character
        string matches any keyword in the attribute value.  The\n   identification
        of keywords in the attribute value and the exactness\n   of the match are
        both implementation specific.\n   The LDAP definition for the keywordMatch
        rule is:\n      ( 2.5.13.33 NAME 'keywordMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
        )\n"
      title: 4.2.21.  keywordMatch
    - contents:
      - "4.2.22.  numericStringMatch\n   The numericStringMatch rule compares an assertion
        value of the\n   Numeric String syntax to an attribute value of a syntax (e.g.,
        the\n   Numeric String syntax) whose corresponding ASN.1 type is\n   NumericString.\n
        \  The rule evaluates to TRUE if and only if the prepared attribute\n   value
        character string and the prepared assertion value character\n   string have
        the same number of characters and corresponding\n   characters have the same
        code point.\n   In preparing the attribute value and assertion value for comparison,\n
        \  characters are not case folded in the Map preparation step, and only\n
        \  numericString Insignificant Character Handling is applied in the\n   Insignificant
        Character Handling step.\n   The LDAP definition for the numericStringMatch
        matching rule is:\n      ( 2.5.13.8 NAME 'numericStringMatch'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.36 )\n   The numericStringMatch rule is an equality
        matching rule.\n"
      title: 4.2.22.  numericStringMatch
    - contents:
      - "4.2.23.  numericStringOrderingMatch\n   The numericStringOrderingMatch rule
        compares an assertion value of\n   the Numeric String syntax to an attribute
        value of a syntax (e.g.,\n   the Numeric String syntax) whose corresponding
        ASN.1 type is\n   NumericString.\n   The rule evaluates to TRUE if and only
        if, in the code point\n   collation order, the prepared attribute value character
        string\n   appears earlier than the prepared assertion value character string;\n
        \  i.e., the attribute value is \"less than\" the assertion value.\n   In
        preparing the attribute value and assertion value for comparison,\n   characters
        are not case folded in the Map preparation step, and only\n   numericString
        Insignificant Character Handling is applied in the\n   Insignificant Character
        Handling step.\n   The rule is identical to the caseIgnoreOrderingMatch rule
        except that\n   all space characters are skipped during comparison (case is\n
        \  irrelevant as the characters are numeric).\n   The LDAP definition for
        the numericStringOrderingMatch matching rule\n   is:\n      ( 2.5.13.9 NAME
        'numericStringOrderingMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.36
        )\n   The numericStringOrderingMatch rule is an ordering matching rule.\n"
      title: 4.2.23.  numericStringOrderingMatch
    - contents:
      - "4.2.24.  numericStringSubstringsMatch\n   The numericStringSubstringsMatch
        rule compares an assertion value of\n   the Substring Assertion syntax to
        an attribute value of a syntax\n   (e.g., the Numeric String syntax) whose
        corresponding ASN.1 type is\n   NumericString.\n   The rule evaluates to TRUE
        if and only if (1) the prepared substrings\n   of the assertion value match
        disjoint portions of the prepared\n   attribute value character string in
        the order of the substrings in\n   the assertion value, (2) an <initial> substring,
        if present, matches\n   the beginning of the prepared attribute value character
        string, and\n   (3) a <final> substring, if present, matches the end of the
        prepared\n   attribute value character string.  A prepared substring matches
        a\n   portion of the prepared attribute value character string if\n   corresponding
        characters have the same code point.\n   In preparing the attribute value
        and assertion value for comparison,\n   characters are not case folded in
        the Map preparation step, and only\n   numericString Insignificant Character
        Handling is applied in the\n   Insignificant Character Handling step.\n   The
        LDAP definition for the numericStringSubstringsMatch matching\n   rule is:\n
        \     ( 2.5.13.10 NAME 'numericStringSubstringsMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.58
        )\n   The numericStringSubstringsMatch rule is a substrings matching rule.\n"
      title: 4.2.24.  numericStringSubstringsMatch
    - contents:
      - "4.2.25.  objectIdentifierFirstComponentMatch\n   The objectIdentifierFirstComponentMatch
        rule compares an assertion\n   value of the OID syntax to an attribute value
        of a syntax (e.g., the\n   Attribute Type Description, DIT Content Rule Description,
        LDAP Syntax\n   Description, Matching Rule Description, Matching Rule Use\n
        \  Description, Name Form Description, or Object Class Description\n   syntax)
        whose corresponding ASN.1 type is a SEQUENCE with a mandatory\n   first component
        of the OBJECT IDENTIFIER ASN.1 type.\n   Note that the assertion syntax of
        this matching rule differs from the\n   attribute syntax of attributes for
        which this is the equality\n   matching rule.\n   The rule evaluates to TRUE
        if and only if the assertion value matches\n   the first component of the
        attribute value using the rules of\n   objectIdentifierMatch.\n   The LDAP
        definition for the objectIdentifierFirstComponentMatch\n   matching rule is:\n
        \     ( 2.5.13.30 NAME 'objectIdentifierFirstComponentMatch'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.38 )\n   The objectIdentifierFirstComponentMatch
        rule is an equality matching\n   rule.  When using objectIdentifierFirstComponentMatch
        to compare two\n   attribute values (of an applicable syntax), an assertion
        value must\n   first be derived from one of the attribute values.  An assertion\n
        \  value can be derived from an attribute value by taking the first\n   component
        of that attribute value.\n"
      title: 4.2.25.  objectIdentifierFirstComponentMatch
    - contents:
      - "4.2.26.  objectIdentifierMatch\n   The objectIdentifierMatch rule compares
        an assertion value of the OID\n   syntax to an attribute value of a syntax
        (e.g., the OID syntax) whose\n   corresponding ASN.1 type is OBJECT IDENTIFIER.\n
        \  The rule evaluates to TRUE if and only if the assertion value and the\n
        \  attribute value represent the same object identifier; that is, the\n   same
        sequence of integers, whether represented explicitly in the\n   <numericoid>
        form of <oid> or implicitly in the <descr> form (see\n   [RFC4512]).\n   If
        an LDAP client supplies an assertion value in the <descr> form and\n   the
        chosen descriptor is not recognized by the server, then the\n   objectIdentifierMatch
        rule evaluates to Undefined.\n   The LDAP definition for the objectIdentifierMatch
        matching rule is:\n      ( 2.5.13.0 NAME 'objectIdentifierMatch'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.38 )\n   The objectIdentifierMatch rule is an equality
        matching rule.\n"
      title: 4.2.26.  objectIdentifierMatch
    - contents:
      - "4.2.27.  octetStringMatch\n   The octetStringMatch rule compares an assertion
        value of the Octet\n   String syntax to an attribute value of a syntax (e.g.,
        the Octet\n   String or JPEG syntax) whose corresponding ASN.1 type is the
        OCTET\n   STRING ASN.1 type.\n   The rule evaluates to TRUE if and only if
        the attribute value and the\n   assertion value are the same length and corresponding
        octets (by\n   position) are the same.\n   The LDAP definition for the octetStringMatch
        matching rule is:\n      ( 2.5.13.17 NAME 'octetStringMatch'\n         SYNTAX
        1.3.6.1.4.1.1466.115.121.1.40 )\n   The octetStringMatch rule is an equality
        matching rule.\n"
      title: 4.2.27.  octetStringMatch
    - contents:
      - "4.2.28.  octetStringOrderingMatch\n   The octetStringOrderingMatch rule compares
        an assertion value of the\n   Octet String syntax to an attribute value of
        a syntax (e.g., the\n   Octet String or JPEG syntax) whose corresponding ASN.1
        type is the\n   OCTET STRING ASN.1 type.\n   The rule evaluates to TRUE if
        and only if the attribute value appears\n   earlier in the collation order
        than the assertion value.  The rule\n   compares octet strings from the first
        octet to the last octet, and\n   from the most significant bit to the least
        significant bit within the\n   octet.  The first occurrence of a different
        bit determines the\n   ordering of the strings.  A zero bit precedes a one
        bit.  If the\n   strings contain different numbers of octets but the longer
        string is\n   identical to the shorter string up to the length of the shorter\n
        \  string, then the shorter string precedes the longer string.\n   The LDAP
        definition for the octetStringOrderingMatch matching rule\n   is:\n      (
        2.5.13.18 NAME 'octetStringOrderingMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.40
        )\n   The octetStringOrderingMatch rule is an ordering matching rule.\n"
      title: 4.2.28.  octetStringOrderingMatch
    - contents:
      - "4.2.29.  telephoneNumberMatch\n   The telephoneNumberMatch rule compares
        an assertion value of the\n   Telephone Number syntax to an attribute value
        of a syntax (e.g., the\n   Telephone Number syntax) whose corresponding ASN.1
        type is a\n   PrintableString representing a telephone number.\n   The rule
        evaluates to TRUE if and only if the prepared attribute\n   value character
        string and the prepared assertion value character\n   string have the same
        number of characters and corresponding\n   characters have the same code point.\n
        \  In preparing the attribute value and assertion value for comparison,\n
        \  characters are case folded in the Map preparation step, and only\n   telephoneNumber
        Insignificant Character Handling is applied in the\n   Insignificant Character
        Handling step.\n   The LDAP definition for the telephoneNumberMatch matching
        rule is:\n      ( 2.5.13.20 NAME 'telephoneNumberMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.50
        )\n   The telephoneNumberMatch rule is an equality matching rule.\n"
      title: 4.2.29.  telephoneNumberMatch
    - contents:
      - "4.2.30.  telephoneNumberSubstringsMatch\n   The telephoneNumberSubstringsMatch
        rule compares an assertion value\n   of the Substring Assertion syntax to
        an attribute value of a syntax\n   (e.g., the Telephone Number syntax) whose
        corresponding ASN.1 type is\n   a PrintableString representing a telephone
        number.\n   The rule evaluates to TRUE if and only if (1) the prepared substrings\n
        \  of the assertion value match disjoint portions of the prepared\n   attribute
        value character string in the order of the substrings in\n   the assertion
        value, (2) an <initial> substring, if present, matches\n   the beginning of
        the prepared attribute value character string, and\n   (3) a <final> substring,
        if present, matches the end of the prepared\n   attribute value character
        string.  A prepared substring matches a\n   portion of the prepared attribute
        value character string if\n   corresponding characters have the same code
        point.\n   In preparing the attribute value and assertion value substrings
        for\n   comparison, characters are case folded in the Map preparation step,\n
        \  and only telephoneNumber Insignificant Character Handling is applied\n
        \  in the Insignificant Character Handling step.\n   The LDAP definition for
        the telephoneNumberSubstringsMatch matching\n   rule is:\n      ( 2.5.13.21
        NAME 'telephoneNumberSubstringsMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.58
        )\n   The telephoneNumberSubstringsMatch rule is a substrings matching\n   rule.\n"
      title: 4.2.30.  telephoneNumberSubstringsMatch
    - contents:
      - "4.2.31.  uniqueMemberMatch\n   The uniqueMemberMatch rule compares an assertion
        value of the Name\n   And Optional UID syntax to an attribute value of a syntax
        (e.g., the\n   Name And Optional UID syntax) whose corresponding ASN.1 type
        is\n   NameAndOptionalUID.\n   The rule evaluates to TRUE if and only if the
        <distinguishedName>\n   components of the assertion value and attribute value
        match according\n   to the distinguishedNameMatch rule and either, (1) the
        <BitString>\n   component is absent from both the attribute value and assertion\n
        \  value, or (2) the <BitString> component is present in both the\n   attribute
        value and the assertion value and the <BitString> component\n   of the assertion
        value matches the <BitString> component of the\n   attribute value according
        to the bitStringMatch rule.\n   Note that this matching rule has been altered
        from its description in\n   X.520 [X.520] in order to make the matching rule
        commutative.  Server\n   implementors should consider using the original X.520
        semantics\n   (where the matching was less exact) for approximate matching
        of\n   attributes with uniqueMemberMatch as the equality matching rule.\n
        \  The LDAP definition for the uniqueMemberMatch matching rule is:\n      (
        2.5.13.23 NAME 'uniqueMemberMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.34
        )\n   The uniqueMemberMatch rule is an equality matching rule.\n"
      title: 4.2.31.  uniqueMemberMatch
    - contents:
      - "4.2.32.  wordMatch\n   The wordMatch rule compares an assertion value of
        the Directory\n   String syntax to an attribute value of a syntax (e.g., the
        Directory\n   String syntax) whose corresponding ASN.1 type is DirectoryString.\n
        \  The rule evaluates to TRUE if and only if the assertion value word\n   matches,
        according to the semantics of caseIgnoreMatch, any word in\n   the attribute
        value.  The precise definition of a word is\n   implementation specific.\n
        \  The LDAP definition for the wordMatch rule is:\n      ( 2.5.13.32 NAME
        'wordMatch'\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )\n"
      title: 4.2.32.  wordMatch
    title: 4.2.  Matching Rule Definitions
  title: 4.  Matching Rules
- contents:
  - "5.  Security Considerations\n   In general, the LDAP-specific encodings for syntaxes
    defined in this\n   document do not define canonical encodings.  That is, a\n
    \  transformation from an LDAP-specific encoding into some other\n   encoding
    (e.g., BER) and back into the LDAP-specific encoding will\n   not necessarily
    reproduce exactly the original octets of the LDAP-\n   specific encoding.  Therefore,
    an LDAP-specific encoding should not\n   be used where a canonical encoding is
    required.\n   Furthermore, the LDAP-specific encodings do not necessarily enable
    an\n   alternative encoding of values of the Directory String and DN\n   syntaxes
    to be reconstructed; e.g., a transformation from a\n   Distinguished Encoding
    Rules (DER) [BER] encoding to an LDAP-specific\n   encoding and back to a DER
    encoding may not reproduce the original\n   DER encoding.  Therefore, LDAP-specific
    encodings should not be used\n   where reversibility to DER is needed; e.g., for
    the verification of\n   digital signatures.  Instead, DER or a DER-reversible
    encoding should\n   be used.\n   When interpreting security-sensitive fields (in
    particular, fields\n   used to grant or deny access), implementations MUST ensure
    that any\n   matching rule comparisons are done on the underlying abstract value,\n
    \  regardless of the particular encoding used.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  Acknowledgements\n   This document is primarily a revision of RFC 2252 by
    M. Wahl, A.\n   Coulbeck, T. Howes, and S. Kille.  RFC 2252 was a product of the
    IETF\n   ASID Working Group.\n   This document is based on input from the IETF
    LDAPBIS working group.\n   The author would like to thank Kathy Dally for editing
    the early\n   drafts of this document, and Jim Sermersheim and Kurt Zeilenga for\n
    \  their significant contributions to this revision.\n"
  title: 6.  Acknowledgements
- contents:
  - "7.  IANA Considerations\n   The Internet Assigned Numbers Authority (IANA) has
    updated the LDAP\n   descriptors registry [BCP64] as indicated by the following
    templates:\n      Subject: Request for LDAP Descriptor Registration Update\n      Descriptor
    (short name): see comment\n      Object Identifier: see comment\n      Person
    & email address to contact for further information:\n        Steven Legg <steven.legg@eb2bcom.com>\n
    \     Usage: see comment\n      Specification: RFC 4517\n      Author/Change Controller:
    IESG\n      NAME                              Type  OID\n      ------------------------------------------------------------------\n
    \     bitStringMatch                       M  2.5.13.16\n      booleanMatch                         M
    \ 2.5.13.13\n      caseExactIA5Match                    M  1.3.6.1.4.1.1466.109.114.1\n
    \     caseExactMatch                       M  2.5.13.5\n      caseExactOrderingMatch
    \              M  2.5.13.6\n      caseExactSubstringsMatch             M  2.5.13.7\n
    \     caseIgnoreIA5Match                   M  1.3.6.1.4.1.1466.109.114.2\n      caseIgnoreListMatch
    \                 M  2.5.13.11\n      caseIgnoreListSubstringsMatch        M  2.5.13.12\n
    \     caseIgnoreMatch                      M  2.5.13.2\n      caseIgnoreOrderingMatch
    \             M  2.5.13.3\n      caseIgnoreSubstringsMatch            M  2.5.13.4\n
    \     directoryStringFirstComponentMatch   M  2.5.13.31\n      distinguishedNameMatch
    \              M  2.5.13.1\n      generalizedTimeMatch                 M  2.5.13.27\n
    \     generalizedTimeOrderingMatch         M  2.5.13.28\n      integerFirstComponentMatch
    \          M  2.5.13.29\n      integerMatch                         M  2.5.13.14\n
    \     integerOrderingMatch                 M  2.5.13.15\n      keywordMatch                         M
    \ 2.5.13.33\n      numericStringMatch                   M  2.5.13.8\n      numericStringOrderingMatch
    \          M  2.5.13.9\n      numericStringSubstringsMatch         M  2.5.13.10\n
    \     objectIdentifierFirstComponentMatch  M  2.5.13.30\n      octetStringMatch
    \                    M  2.5.13.17\n      octetStringOrderingMatch             M
    \ 2.5.13.18\n      telephoneNumberMatch                 M  2.5.13.20\n      telephoneNumberSubstringsMatch
    \      M  2.5.13.21\n      uniqueMemberMatch                    M  2.5.13.23\n
    \     wordMatch                            M  2.5.13.32\n      The descriptor
    for the object identifier 2.5.13.0 was incorrectly\n      registered as objectIdentifiersMatch
    (extraneous \\`s') in BCP 64.\n      It has been changed to the following, with
    a reference to\n      RFC 4517.\n      NAME                              Type
    \ OID\n      ------------------------------------------------------------------\n
    \     objectIdentifierMatch                M  2.5.13.0\n      Subject: Request
    for LDAP Descriptor Registration\n      Descriptor (short name): caseIgnoreIA5SubstringsMatch\n
    \     Object Identifier: 1.3.6.1.4.1.1466.109.114.3\n      Person & email address
    to contact for further information:\n        Steven Legg <steven.legg@eb2bcom.com>\n
    \     Usage: other (M)\n      Specification: RFC 4517\n      Author/Change Controller:
    IESG\n"
  title: 7.  IANA Considerations
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n
      \             10646\", STD 63, RFC 3629, November 2003.\n   [RFC4234]  Crocker,
      D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:
      ABNF\", RFC 4234, October 2005.\n   [RFC4510]  Zeilenga, K., Ed., \"Lightweight
      Directory Access Protocol\n              (LDAP): Technical Specification Road
      Map\", RFC 4510, June\n              2006.\n   [RFC4511]  Sermersheim, J., Ed.,
      \"Lightweight Directory Access\n              Protocol (LDAP): The Protocol\",
      RFC 4511, June 2006.\n   [RFC4512]  Zeilenga, K., \"Lightweight Directory Access
      Protocol\n              (LDAP): Directory Information Models\", RFC 4512, June\n
      \             2006.\n   [RFC4514]  Zeilenga, K., Ed., \"Lightweight Directory
      Access Protocol\n              (LDAP): String Representation of Distinguished
      Names\", RFC\n              4514, June 2006.\n   [RFC4518]  Zeilenga, K., \"Lightweight
      Directory Access Protocol\n              (LDAP): Internationalized String Preparation\",
      RFC 4518,\n              June 2006.\n   [RFC4520]  Zeilenga, K., \"Internet
      Assigned Numbers Authority (IANA)\n              Considerations for the Lightweight
      Directory Access\n              Protocol (LDAP)\", BCP 64, RFC 4520, June 2006.\n
      \  [E.123]    Notation for national and international telephone numbers,\n              ITU-T
      Recommendation E.123, 1988.\n   [FAX]      Standardization of Group 3 facsimile
      apparatus for\n              document transmission - Terminal Equipment and
      Protocols\n              for Telematic Services, ITU-T Recommendation T.4, 1993\n
      \  [T.50]     International Reference Alphabet (IRA) (Formerly\n              International
      Alphabet No. 5 or IA5) Information\n              Technology - 7-Bit Coded Character
      Set for Information\n              Interchange, ITU-T Recommendation T.50, 1992\n
      \  [X.420]    ITU-T Recommendation X.420 (1996) | ISO/IEC 10021-7:1997,\n              Information
      Technology - Message Handling Systems (MHS):\n              Interpersonal messaging
      system\n   [X.501]    ITU-T Recommendation X.501 (1993) | ISO/IEC 9594-2:1994,\n
      \             Information Technology - Open Systems Interconnection -\n              The
      Directory: Models\n   [X.520]    ITU-T Recommendation X.520 (1993) | ISO/IEC
      9594-6:1994,\n              Information Technology - Open Systems Interconnection
      -\n              The Directory: Selected attribute types\n   [ASN.1]    ITU-T
      Recommendation X.680 (07/02) | ISO/IEC 8824-1:2002,\n              Information
      technology - Abstract Syntax Notation One\n              (ASN.1): Specification
      of basic notation\n   [ISO3166]  ISO 3166, \"Codes for the representation of
      names of\n              countries\".\n   [ISO8601]  ISO 8601:2004, \"Data elements
      and interchange formats --\n              Information interchange -- Representation
      of dates and\n              times\".\n   [UCS]      Universal Multiple-Octet
      Coded Character Set (UCS) -\n              Architecture and Basic Multilingual
      Plane, ISO/IEC 10646-\n              1:  1993 (with amendments).\n   [JPEG]
      \    JPEG File Interchange Format (Version 1.02).  Eric\n              Hamilton,
      C-Cube Microsystems, Milpitas, CA, September 1,\n              1992.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [RFC4519]  Sciberras, A., Ed., \"Lightweight
      Directory Access Protocol\n              (LDAP): Schema for User Applications\",
      RFC 4519, June\n              2006.\n   [RFC4523]  Zeilenga, K., \"Lightweight
      Directory Access Protocol\n              (LDAP) Schema Definitions for X.509
      Certificates\", RFC\n              4523, June 2006.\n   [X.500]    ITU-T Recommendation
      X.500 (1993) | ISO/IEC 9594-1:1994,\n              Information Technology -
      Open Systems Interconnection -\n              The Directory: Overview of concepts,
      models and services\n   [BER]      ITU-T Recommendation X.690 (07/02) | ISO/IEC
      8825-1:2002,\n              Information technology - ASN.1 encoding rules:\n
      \             Specification of Basic Encoding Rules (BER), Canonical\n              Encoding
      Rules (CER) and Distinguished Encoding Rules\n              (DER)\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "Appendix A. Summary of Syntax Object Identifiers\n   The following list summarizes
    the object identifiers assigned to the\n   syntaxes defined in this document.\n
    \     Syntax                           OBJECT IDENTIFIER\n      ==============================================================\n
    \     Attribute Type Description       1.3.6.1.4.1.1466.115.121.1.3\n      Bit
    String                       1.3.6.1.4.1.1466.115.121.1.6\n      Boolean                          1.3.6.1.4.1.1466.115.121.1.7\n
    \     Country String                   1.3.6.1.4.1.1466.115.121.1.11\n      Delivery
    Method                  1.3.6.1.4.1.1466.115.121.1.14\n      Directory String
    \                1.3.6.1.4.1.1466.115.121.1.15\n      DIT Content Rule Description
    \    1.3.6.1.4.1.1466.115.121.1.16\n      DIT Structure Rule Description   1.3.6.1.4.1.1466.115.121.1.17\n
    \     DN                               1.3.6.1.4.1.1466.115.121.1.12\n      Enhanced
    Guide                   1.3.6.1.4.1.1466.115.121.1.21\n      Facsimile Telephone
    Number       1.3.6.1.4.1.1466.115.121.1.22\n      Fax                              1.3.6.1.4.1.1466.115.121.1.23\n
    \     Generalized Time                 1.3.6.1.4.1.1466.115.121.1.24\n      Guide
    \                           1.3.6.1.4.1.1466.115.121.1.25\n      IA5 String                       1.3.6.1.4.1.1466.115.121.1.26\n
    \     Integer                          1.3.6.1.4.1.1466.115.121.1.27\n      JPEG
    \                            1.3.6.1.4.1.1466.115.121.1.28\n      LDAP Syntax
    Description          1.3.6.1.4.1.1466.115.121.1.54\n      Matching Rule Description
    \       1.3.6.1.4.1.1466.115.121.1.30\n      Matching Rule Use Description    1.3.6.1.4.1.1466.115.121.1.31\n
    \     Name And Optional UID            1.3.6.1.4.1.1466.115.121.1.34\n      Name
    Form Description            1.3.6.1.4.1.1466.115.121.1.35\n      Numeric String
    \                  1.3.6.1.4.1.1466.115.121.1.36\n      Object Class Description
    \        1.3.6.1.4.1.1466.115.121.1.37\n      Octet String                     1.3.6.1.4.1.1466.115.121.1.40\n
    \     OID                              1.3.6.1.4.1.1466.115.121.1.38\n      Other
    Mailbox                    1.3.6.1.4.1.1466.115.121.1.39\n      Postal Address
    \                  1.3.6.1.4.1.1466.115.121.1.41\n      Printable String                 1.3.6.1.4.1.1466.115.121.1.44\n
    \     Substring Assertion              1.3.6.1.4.1.1466.115.121.1.58\n      Telephone
    Number                 1.3.6.1.4.1.1466.115.121.1.50\n      Teletex Terminal Identifier
    \     1.3.6.1.4.1.1466.115.121.1.51\n      Telex Number                     1.3.6.1.4.1.1466.115.121.1.52\n
    \     UTC Time                         1.3.6.1.4.1.1466.115.121.1.53\n"
  title: Appendix A. Summary of Syntax Object Identifiers
- contents:
  - "Appendix B. Changes from RFC 2252\n   This annex lists the significant differences
    between this\n   specification and RFC 2252.\n   This annex is provided for informational
    purposes only.  It is not a\n   normative part of this specification.\n   1.  The
    IESG Note has been removed.\n   2.  The major part of Sections 4, 5 and 7 has
    been moved to [RFC4512]\n       and revised.  Changes to the parts of these sections
    moved to\n       [RFC4512] are detailed in [RFC4512].\n   3.  BNF descriptions
    of syntax formats have been replaced by ABNF\n       [RFC4234] specifications.\n
    \  4.  The ambiguous statement in RFC 2252, Section 4.3 regarding the\n       use
    of a backslash quoting mechanism to escape separator symbols\n       has been
    removed.  The escaping mechanism is now explicitly\n       represented in the
    ABNF for the syntaxes where this provision\n       applies.\n   5.  The description
    of each of the LDAP syntaxes has been expanded so\n       that they are less dependent
    on knowledge of X.500 for\n       interpretation.\n   6.  The relationship of
    LDAP syntaxes to corresponding ASN.1 type\n       definitions has been made explicit.\n
    \  7.  The set of characters allowed in a <PrintableString> (formerly\n       <printablestring>)
    has been corrected to align with the\n       PrintableString ASN.1 type in [ASN.1].
    \ Specifically, the double\n       quote character has been removed and the single
    quote character\n       and equals sign have been added.\n   8.  Values of the
    Directory String, Printable String and Telephone\n       Number syntaxes are now
    required to have at least one character.\n   9.  The <DITContentRuleDescription>,
    <NameFormDescription> and\n       <DITStructureRuleDescription> rules have been
    moved to [RFC4512].\n   10. The corresponding ASN.1 type for the Other Mailbox
    syntax has\n       been incorporated from RFC 1274.\n   11. A corresponding ASN.1
    type for the LDAP Syntax Description syntax\n       has been invented.\n   12.
    The Binary syntax has been removed because it was not adequately\n       specified,
    implementations with different incompatible\n       interpretations exist, and
    it was confused with the ;binary\n       transfer encoding.\n   13. All discussion
    of transfer options, including the \";binary\"\n       option, has been removed.
    \ All imperatives regarding binary\n       transfer of values have been removed.\n
    \  14. The Delivery Method, Enhanced Guide, Guide, Octet String, Teletex\n       Terminal
    Identifier and Telex Number syntaxes from RFC 2256 have\n       been incorporated.\n
    \  15. The <criteria> rule for the Enhanced Guide and Guide syntaxes has\n       been
    extended to accommodate empty \"and\" and \"or\" expressions.\n   16. An encoding
    for the <ttx-value> rule in the Teletex Terminal\n       Identifier syntax has
    been defined.\n   17. The PKI-related syntaxes (Certificate, Certificate List
    and\n       Certificate Pair) have been removed.  They are reintroduced in\n       [RFC4523]
    (as is the Supported Algorithm syntax from RFC 2256).\n   18. The MHS OR Address
    syntax has been removed since its\n       specification (in RFC 2156) is not at
    draft standard maturity.\n   19. The DL Submit Permission syntax has been removed
    as it depends on\n       the MHS OR Address syntax.\n   20. The Presentation Address
    syntax has been removed since its\n       specification (in RFC 1278) is not at
    draft standard maturity.\n   21. The ACI Item, Access Point, Audio, Data Quality,
    DSA Quality, DSE\n       Type, LDAP Schema Description, Master And Shadow Access
    Points,\n       Modify Rights, Protocol Information, Subtree Specification,\n
    \      Supplier Information, Supplier Or Consumer and Supplier And\n       Consumer
    syntaxes have been removed.  These syntaxes are\n       referenced in RFC 2252,
    but not defined.\n   22. The LDAP Schema Definition syntax (defined in RFC 2927)
    and the\n       Mail Preference syntax have been removed on the grounds that they\n
    \      are out of scope for the core specification.\n   23. The description of
    each of the matching rules has been expanded\n       so that they are less dependent
    on knowledge of X.500 for\n       interpretation.\n   24. The caseIgnoreIA5SubstringsMatch
    matching rule from RFC 2798 has\n       been added.\n   25. The caseIgnoreListSubstringsMatch,
    caseIgnoreOrderingMatch and\n       caseIgnoreSubstringsMatch matching rules have
    been added to the\n       list of matching rules for which the provisions for
    handling\n       leading, trailing and multiple adjoining whitespace characters\n
    \      apply (now through string preparation).  This is consistent with\n       the
    definitions of these matching rules in X.500.  The\n       caseIgnoreIA5SubstringsMatch
    rule has also been added to the\n       list.\n   26. The specification of the
    octetStringMatch matching rule from\n       RFC 2256 has been added to this document.\n
    \  27. The presentationAddressMatch matching rule has been removed as it\n       depends
    on an assertion syntax (Presentation Address) that is not\n       at draft standard
    maturity.\n   28. The protocolInformationMatch matching rule has been removed
    as it\n       depends on an undefined assertion syntax (Protocol Information).\n
    \  29. The definitive reference for ASN.1 has been changed from X.208 to\n       X.680
    since X.680 is the version of ASN.1 referred to by X.500.\n   30. The specification
    of the caseIgnoreListSubstringsMatch matching\n       rule from RFC 2798 & X.520
    has been added.\n   31. String preparation algorithms have been applied to the
    character\n       string matching rules.\n   32. The specifications of the booleanMatch,
    caseExactMatch,\n       caseExactOrderingMatch, caseExactSubstringsMatch,\n       directoryStringFirstComponentMatch,
    integerOrderingMatch,\n       keywordMatch, numericStringOrderingMatch,\n       octetStringOrderingMatch
    and wordMatch matching rules from\n       RFC 3698 & X.520 have been added.\n"
  title: Appendix B. Changes from RFC 2252
- contents:
  - "Author's Address\n   Steven Legg\n   eB2Bcom\n   Suite3, Woodhouse Corporate
    Centre\n   935 Station Street\n   Box Hill North, Victoria 3129\n   AUSTRALIA\n
    \  Phone: +61 3 9896 7830\n   Fax: +61 3 9896 7801\n   EMail: steven.legg@eb2bcom.com\n"
  title: Author's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n
    \  Administrative Support Activity (IASA).\n"
  title: Acknowledgement
