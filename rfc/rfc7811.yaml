- title: __initial_text__
  contents:
  - "             An Algorithm for Computing IP/LDP Fast Reroute\n               Using\
    \ Maximally Redundant Trees (MRT-FRR)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document supports the solution put forth in \"An Architecture\
    \ for\n   IP/LDP Fast Reroute Using Maximally Redundant Trees (MRT-FRR)\"\n  \
    \ (RFC 7812) by defining the associated MRT Lowpoint algorithm that is\n   used\
    \ in the Default MRT Profile to compute both the necessary\n   Maximally Redundant\
    \ Trees with their associated next hops and the\n   alternates to select for MRT-FRR.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7811.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Requirements Language . . . . . . . . . . . . . . . .\
    \ . . . .   5\n   3.  Terminology and Definitions . . . . . . . . . . . . . .\
    \ . . .   5\n   4.  Algorithm Key Concepts  . . . . . . . . . . . . . . . . .\
    \ . .   6\n     4.1.  Partial Ordering for Disjoint Paths . . . . . . . . . .\
    \ .   7\n     4.2.  Finding an Ear and the Correct Direction  . . . . . . . .\
    \   8\n     4.3.  Lowpoint Values and Their Uses  . . . . . . . . . . . . .  11\n\
    \     4.4.  Blocks in a Graph . . . . . . . . . . . . . . . . . . . .  14\n  \
    \   4.5.  Determining Localroot and Assigning Block-ID  . . . . . .  16\n   5.\
    \  MRT Lowpoint Algorithm Specification  . . . . . . . . . . . .  18\n     5.1.\
    \  Interface Ordering  . . . . . . . . . . . . . . . . . . .  18\n     5.2.  MRT\
    \ Island Identification . . . . . . . . . . . . . . . .  21\n     5.3.  GADAG\
    \ Root Selection  . . . . . . . . . . . . . . . . . .  21\n     5.4.  Initialization\
    \  . . . . . . . . . . . . . . . . . . . . .  22\n     5.5.  Constructing the\
    \ GADAG Using Lowpoint Inheritance . . . .  23\n     5.6.  Augmenting the GADAG\
    \ by Directing All Links . . . . . . .  25\n     5.7.  Compute MRT Next Hops .\
    \ . . . . . . . . . . . . . . . . .  29\n       5.7.1.  MRT Next Hops to All Nodes\
    \ Ordered with Respect to\n               the Computing Node  . . . . . . . .\
    \ . . . . . . . . .  29\n       5.7.2.  MRT Next Hops to All Nodes Not Ordered\
    \ with Respect\n               to the Computing Node . . . . . . . . . . . . .\
    \ . . .  30\n       5.7.3.  Computing Redundant Tree Next Hops in a 2-Connected\n\
    \               Graph . . . . . . . . . . . . . . . . . . . . . . . .  31\n  \
    \     5.7.4.  Generalizing for a Graph That Isn't 2-Connected . . .  33\n    \
    \   5.7.5.  Complete Algorithm to Compute MRT Next Hops . . . . .  34\n     5.8.\
    \  Identify MRT Alternates . . . . . . . . . . . . . . . . .  36\n     5.9.  Named\
    \ Proxy-Nodes . . . . . . . . . . . . . . . . . . . .  44\n       5.9.1.  Determining\
    \ Proxy-Node Attachment Routers . . . . . .  45\n       5.9.2.  Computing If an\
    \ Island Neighbor (IN) Is Loop-Free . .  45\n       5.9.3.  Computing MRT Next\
    \ Hops for Proxy-Nodes . . . . . . .  47\n       5.9.4.  Computing MRT Alternates\
    \ for Proxy-Nodes  . . . . . .  53\n   6.  MRT Lowpoint Algorithm: Next-Hop Conformance\
    \  . . . . . . . .  61\n   7.  Broadcast Interfaces  . . . . . . . . . . . . .\
    \ . . . . . . .  61\n     7.1.  Computing MRT Next Hops on Broadcast Networks\
    \ . . . . . .  62\n     7.2.  Using MRT Next Hops as Alternates in the Event of\n\
    \           Failures on Broadcast Networks  . . . . . . . . . . . . .  63\n  \
    \ 8.  Evaluation of Alternative Methods for Constructing GADAGs . .  64\n   9.\
    \  Operational Considerations  . . . . . . . . . . . . . . . . .  66\n     9.1.\
    \  GADAG Root Selection  . . . . . . . . . . . . . . . . . .  67\n     9.2.  Destination-Rooted\
    \ GADAGs . . . . . . . . . . . . . . . .  67\n   10. Security Considerations .\
    \ . . . . . . . . . . . . . . . . . .  67\n   11. References  . . . . . . . .\
    \ . . . . . . . . . . . . . . . . .  68\n     11.1.  Normative References . .\
    \ . . . . . . . . . . . . . . . .  68\n     11.2.  Informative References . .\
    \ . . . . . . . . . . . . . . .  68\n   Appendix A.  Python Implementation of\
    \ MRT Lowpoint Algorithm  . .  70\n   Appendix B.  Constructing a GADAG Using\
    \ SPFs  . . . . . . . . . . 110\n   Appendix C.  Constructing a GADAG Using a\
    \ Hybrid Method . . . . . 115\n   Acknowledgements  . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 117\n   Authors' Addresses  . . . . . . . . . . . . .\
    \ . . . . . . . . . . 118\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   MRT Fast Reroute requires that packets can be forwarded\
    \ not only on\n   the shortest-path tree, but also on two Maximally Redundant\
    \ Trees\n   (MRTs), referred to as the MRT-Blue and the MRT-Red.  A router that\n\
    \   experiences a local failure must also have predetermined which\n   alternate\
    \ to use.  This document defines how to compute these three\n   things for use\
    \ in MRT-FRR and describes the algorithm design\n   decisions and rationale. \
    \ The algorithm is based on those presented\n   in [MRTLinear] and expanded in\
    \ [EnyediThesis].  The MRT Lowpoint\n   algorithm is required for implementation\
    \ when the Default MRT Profile\n   is implemented.\n   The MRT Lowpoint Algorithm\
    \ defined in this document, when used for\n   MRT Fast-Reroute as described in\
    \ [RFC7812], guarantees 100% recovery\n   for single failures when the network\
    \ is 2-connected.  This guaranteed\n   coverage does not depend on the link metrics,\
    \ which an operator may\n   be using to traffic-engineer the IP network.  Thus,\
    \ the link metrics\n   and general network topology are largely decoupled from\
    \ the\n   guaranteed coverage.\n   Just as packets routed on a hop-by-hop basis\
    \ require that each router\n   compute a shortest-path tree that is consistent,\
    \ it is necessary for\n   each router to compute the MRT-Blue next hops and MRT-Red\
    \ next hops\n   in a consistent fashion.  This document defines the MRT Lowpoint\n\
    \   algorithm to be used as a standard in the Default MRT Profile for\n   MRT-FRR.\n\
    \   A router's Forwarding Information Base (FIB) will continue to contain\n  \
    \ primary next hops for the current shortest-path tree for forwarding\n   traffic.\
    \  In addition, a router's FIB will contain primary next hops\n   for the MRT-Blue\
    \ for forwarding received traffic on the MRT-Blue and\n   primary next hops for\
    \ the MRT-Red for forwarding received traffic on\n   the MRT-Red.\n   What alternate\
    \ next hops a Point of Local Repair (PLR) selects need\n   not be consistent --\
    \ but loops must be prevented.  To reduce\n   congestion, it is possible for multiple\
    \ alternate next hops to be\n   selected; in the context of MRT alternates, each\
    \ of those alternate\n   next hops would be equal-cost paths.\n   This document\
    \ defines an algorithm for selecting an appropriate MRT\n   alternate for consideration.\
    \  Other alternates, e.g., Loop-Free\n   Alternates (LFAs) that are downstream\
    \ paths, may be preferred when\n   available.  See the \"Operational Considerations\"\
    \ section of [RFC7812]\n   for a more detailed discussion of combining MRT alternates\
    \ with those\n   produced by other FRR technologies.\n   [E]---[D]---|       \
    \    [E]<--[D]<--|                [E]-->[D]---|\n    |     |    |            |\
    \     ^    |                       |    |\n    |     |    |            V     |\
    \    |                       V    V\n   [R]   [F]  [C]          [R]   [F]  [C]\
    \               [R]   [F]  [C]\n    |     |    |                  ^    ^     \
    \            ^     |    |\n    |     |    |                  |    |          \
    \       |     V    |\n   [A]---[B]---|           [A]-->[B]---|               \
    \ [A]<--[B]<--|\n         (a)                     (b)                        \
    \ (c)\n   A 2-connected graph     MRT-Blue towards R          MRT-Red towards\
    \ R\n                                 Figure 1\n   The MRT Lowpoint algorithm\
    \ can handle arbitrary network topologies\n   where the whole network graph is\
    \ not 2-connected, as in Figure 2, as\n   well as the easier case where the network\
    \ graph is 2-connected\n   (Figure 1).  Each MRT is a spanning tree.  The pair\
    \ of MRTs provide\n   two paths from every node X to the root of the MRTs.  Those\
    \ paths\n   share the minimum number of nodes and the minimum number of links.\n\
    \   Each such shared node is a cut-vertex.  Any shared links are cut-\n   links.\n\
    \                        [E]---[D]---|     |---[J]\n                         |\
    \     |    |     |    |\n                         |     |    |     |    |\n  \
    \                      [R]   [F]  [C]---[G]   |\n                         |  \
    \   |    |     |    |\n                         |     |    |     |    |\n    \
    \                    [A]---[B]---|     |---[H]\n                       (a) a graph\
    \ that is not 2-connected\n         [E]<--[D]<--|         [J]        [E]-->[D]---|\
    \     |---[J]\n          |     ^    |          |                |    |     | \
    \   ^\n          V     |    |          |                V    V     V    |\n  \
    \       [R]   [F]  [C]<--[G]   |         [R]   [F]  [C]<--[G]   |\n          \
    \      ^    ^     ^    |          ^     |    |          |\n                | \
    \   |     |    V          |     V    |          |\n         [A]-->[B]---|    \
    \ |---[H]        [A]<--[B]<--|         [H]\n          (b) MRT-Blue towards R \
    \         (c) MRT-Red towards R\n                Figure 2: A Network That Is Not\
    \ 2-Connected\n"
- title: 2.  Requirements Language
  contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  Terminology and Definitions
  contents:
  - "3.  Terminology and Definitions\n   Please see the Terminology section of [RFC7812]\
    \ for a complete list\n   of terminology relevant to this document.  The list\
    \ below does not\n   repeat terminology introduced in that RFC.\n   spanning tree:\
    \  A tree that contains links and that connects all\n      nodes in the network\
    \ graph.\n   back-edge:  In the context of a spanning tree computed via a depth-\n\
    \      first search, a back-edge is a link that connects a descendant of\n   \
    \   a node x with an ancestor of x.\n   partial ADAG:  A subset of an Almost Directed\
    \ Acyclic Graph (ADAG)\n      that doesn't yet contain all the nodes in the block.\
    \  A partial\n      ADAG is created during the MRT Lowpoint algorithm and then\n\
    \      expanded until all nodes in the block are included and it becomes\n   \
    \   an ADAG.\n   DFS:  Depth-First Search\n   DFS ancestor:  A node n is a DFS\
    \ ancestor of x if n is on the DFS-\n      tree path from the DFS root to x.\n\
    \   DFS descendant:  A node n is a DFS descendant of x if x is on the\n      DFS-tree\
    \ path from the DFS root to n.\n   ear:  A path along nodes that are not yet included\
    \ in the Generalized\n      ADAG (GADAG) that starts at a node that is already\
    \ included in the\n      GADAG and that ends at a node that is already included\
    \ in the\n      GADAG.  The starting and ending nodes may be the same node if\
    \ it\n      is a cut-vertex.\n   X>>Y or Y<<X:  Indicates the relationship between\
    \ X and Y in a\n      partial order, such as found in a GADAG.  X>>Y means that\
    \ X is\n      higher in the partial order than Y.  Y<<X means that Y is lower\
    \ in\n      the partial order than X.\n   X>Y or Y<X:   Indicates the relationship\
    \ between X and Y in the total\n      order, such as found via a topological sort.\
    \  X>Y means that X is\n      higher in the total order than Y.  Y<X means that\
    \ Y is lower in\n      the total order than X.\n   X ?? Y:   Indicates that X\
    \ is unordered with respect to Y in the\n      partial order.\n   UNDIRECTED:\
    \  In the GADAG, each link is marked as OUTGOING, INCOMING,\n      or both.  Until\
    \ the directionality of the link is determined, the\n      link is marked as UNDIRECTED\
    \ to indicate that its direction hasn't\n      been determined.\n   OUTGOING:\
    \  A link marked as OUTGOING has direction in the GADAG from\n      the interface's\
    \ router to the remote end.\n   INCOMING:  A link marked as INCOMING has direction\
    \ in the GADAG from\n      the remote end to the interface's router.\n"
- title: 4.  Algorithm Key Concepts
  contents:
  - "4.  Algorithm Key Concepts\n   There are five key concepts that are critical\
    \ for understanding the\n   MRT Lowpoint algorithm.  The first is the idea of\
    \ partially ordering\n   the nodes in a network graph with regard to each other\
    \ and to the\n   GADAG root.  The second is the idea of finding an ear of nodes\
    \ and\n   adding them in the correct direction.  The third is the idea of a\n\
    \   Lowpoint value and how it can be used to identify cut-vertices and to\n  \
    \ find a second path towards the root.  The fourth is the idea that a\n   non-2-connected\
    \ graph is made up of blocks, where a block is a\n   2-connected cluster, a cut-link\
    \ or an isolated node.  The fifth is\n   the idea of a localroot for each node;\
    \ this is used to compute ADAGs\n   in each block.\n"
- title: 4.1.  Partial Ordering for Disjoint Paths
  contents:
  - "4.1.  Partial Ordering for Disjoint Paths\n   Given any two nodes X and Y in\
    \ a graph, a particular total order\n   means that either X<Y or X>Y in that total\
    \ order.  An example would\n   be a graph where the nodes are ranked based upon\
    \ their unique IP\n   loopback addresses.  In a partial order, there may be some\
    \ nodes for\n   which it can't be determined whether X<<Y or X>>Y.  A partial\
    \ order\n   can be captured in a directed graph, as shown in Figure 3.  In a\n\
    \   graphical representation, a link directed from X to Y indicates that\n   X\
    \ is a neighbor of Y in the network graph and X<<Y.\n         [A]<---[R]    [E]\
    \       R << A << B << C << D << E\n          |             ^        R << A <<\
    \ B << F << G << H << D << E\n          |             |\n          V         \
    \    |        Unspecified Relationships:\n         [B]--->[C]--->[D]         \
    \    C and F\n          |             ^              C and G\n          |    \
    \         |              C and H\n          V             |\n         [F]--->[G]--->[H]\n\
    \             Figure 3: Directed Graph Showing a Partial Order\n   To compute\
    \ MRTs, the root of the MRTs is at both the very bottom and\n   the very top of\
    \ the partial ordering.  This means that from any node\n   X, one can pick nodes\
    \ higher in the order until the root is reached.\n   Similarly, from any node\
    \ X, one can pick nodes lower in the order\n   until the root is reached.  For\
    \ instance, in Figure 4, from G the\n   higher nodes picked can be traced by following\
    \ the directed links and\n   are H, D, E, and R.  Similarly, from G the lower\
    \ nodes picked can be\n   traced by reversing the directed links and are F, B,\
    \ A, and R.  A\n   graph that represents this modified partial order is no longer\
    \ a DAG;\n   it is termed an Almost DAG (ADAG) because if the links directed to\n\
    \   the root were removed, it would be a DAG.\n     [A]<---[R]<---[E]      R <<\
    \ A << B << C << R\n      |      ^      ^       R << A << B << C << D << E <<\
    \ R\n      |      |      |       R << A << B << F << G << H << D << E << R\n \
    \     V      |      |\n     [B]--->[C]--->[D]      Unspecified Relationships:\n\
    \      |             ^              C and F\n      |             |           \
    \   C and G\n      V             |              C and H\n     [F]--->[G]--->[H]\n\
    \     Figure 4: ADAG Showing a Partial Order with R Lowest and Highest\n   Most\
    \ importantly, if a node Y>>X, then Y can only appear on the\n   increasing path\
    \ from X to the root and never on the decreasing path.\n   Similarly, if a node\
    \ Z<<X, then Z can only appear on the decreasing\n   path from X to the root and\
    \ never on the increasing path.\n   When following the increasing paths, it is\
    \ possible to pick multiple\n   higher nodes and still have the certainty that\
    \ those paths will be\n   disjoint from the decreasing paths.  For example, in\
    \ the previous\n   example, node B has multiple possibilities to forward packets\
    \ along\n   an increasing path: it can either forward packets to C or F.\n"
- title: 4.2.  Finding an Ear and the Correct Direction
  contents:
  - "4.2.  Finding an Ear and the Correct Direction\n   For simplicity, the basic\
    \ idea of creating a GADAG by adding ears is\n   described assuming that the network\
    \ graph is a single 2-connected\n   cluster so that an ADAG is sufficient.  Generalizing\
    \ to multiple\n   blocks is done by considering the block-roots instead of the\
    \ GADAG\n   root -- and the actual algorithm is given in Section 5.5.\n   In order\
    \ to understand the basic idea of finding an ADAG, first\n   suppose that we have\
    \ already a partial ADAG, which doesn't contain\n   all the nodes in the block\
    \ yet, and we want to extend it to cover all\n   the nodes.  Suppose that we find\
    \ a path from a node X to Y such that\n   X and Y are already contained by our\
    \ partial ADAG, but all the\n   remaining nodes along the path are not added to\
    \ the ADAG yet.  We\n   refer to such a path as an \"ear\".\n   Recall that our\
    \ ADAG is closely related to a partial order.  More\n   precisely, if we remove\
    \ root R, the remaining DAG describes a partial\n   order of the nodes.  If we\
    \ suppose that neither X nor Y is the root,\n   we may be able to compare them.\
    \  If one of them is definitely lesser\n   with respect to our partial order (say\
    \ X<<Y), we can add the new path\n   to the ADAG in a direction from X to Y. \
    \ As an example, consider\n   Figure 5.\n           E---D---|              E<--D---|\
    \           E<--D<--|\n           |   |   |              |   ^   |           |\
    \   ^   |\n           |   |   |              V   |   |           V   |   |\n \
    \          R   F   C              R   F   C           R   F   C\n           |\
    \   |   |              |   ^   |           |   ^   ^\n           |   |   |   \
    \           V   |   |           V   |   |\n           A---B---|              A-->B---|\
    \           A-->B---|\n              (a)                    (b)              \
    \   (c)\n           (a) A 2-connected graph\n           (b) Partial ADAG (C is\
    \ not included)\n           (c) Resulting ADAG after adding path (or ear) B-C-D\n\
    \                                 Figure 5\n   In this partial ADAG, node C is\
    \ not yet included.  However, we can\n   find path B-C-D, where both endpoints\
    \ are contained by this partial\n   ADAG (we say those nodes are \"ready\" in\
    \ the following text), and the\n   remaining node (node C) is not contained yet.\
    \  If we remove R, the\n   remaining DAG defines a partial order, and with respect\
    \ to this\n   partial order, we can say that B<<D; so, we can add the path to\
    \ the\n   ADAG in the direction from B to D (arcs B->C and C->D are added).  If\n\
    \   B>>D, we would add the same path in reverse direction.\n   If, in the partial\
    \ order where an ear's two ends are X and Y, X<<Y,\n   then there must already\
    \ be a directed path from X to Y in the ADAG.\n   The ear must be added in a direction\
    \ such that it doesn't create a\n   cycle; therefore, the ear must go from X to\
    \ Y.\n   In the case when X and Y are not ordered with each other, we can\n  \
    \ select either direction for the ear.  We have no restriction since\n   neither\
    \ of the directions can result in a cycle.  In the corner case\n   when one of\
    \ the endpoints of an ear, say X, is the root (recall that\n   the two endpoints\
    \ must be different), we could use both directions\n   again for the ear because\
    \ the root can be considered both as smaller\n   and as greater than Y.  However,\
    \ we strictly pick that direction in\n   which the root is lower than Y.  The\
    \ logic for this decision is\n   explained in Section 5.7\n   A partial ADAG is\
    \ started by finding a cycle from the root R back to\n   itself.  This can be\
    \ done by selecting a non-ready neighbor N of R\n   and then finding a path from\
    \ N to R that doesn't use any links\n   between R and N.  The direction of the\
    \ cycle can be assigned either\n   way since it is starting the ordering.\n  \
    \ Once a partial ADAG is already present, it will always have a node\n   that\
    \ is not the root R in it.  The following is a brief proof that a\n   partial\
    \ ADAG can always have ears added to it: just select a non-\n   ready neighbor\
    \ N of a ready node Q, such that Q is not the root R,\n   find a path from N to\
    \ the root R in the graph with Q removed.  This\n   path is an ear where the first\
    \ node of the ear is Q, the next is N,\n   then the path until the first ready\
    \ node the path reached (that ready\n   node is the other endpoint of the path).\
    \  Since the graph is\n   2-connected, there must be a path from N to R without\
    \ Q.\n   It is always possible to select a non-ready neighbor N of a ready\n \
    \  node Q so that Q is not the root R.  Because the network is\n   2-connected,\
    \ N must be connected to two different nodes and only one\n   can be R.  Because\
    \ the initial cycle has already been added to the\n   ADAG, there are ready nodes\
    \ that are not R.  Since the graph is\n   2-connected, while there are non-ready\
    \ nodes, there must be a non-\n   ready neighbor N of a ready node that is not\
    \ R.\n    Generic_Find_Ears_ADAG(root)\n       Create an empty ADAG.  Add root\
    \ to the ADAG.\n       Mark root as IN_GADAG.\n       Select an arbitrary cycle\
    \ containing root.\n       Add the arbitrary cycle to the ADAG.\n       Mark cycle's\
    \ nodes as IN_GADAG.\n       Add cycle's non-root nodes to process_list.\n   \
    \    While there exist connected nodes in graph that are not IN_GADAG\n      \
    \    Select a new ear.  Let its endpoints be X and Y.\n          If Y is root\
    \ or (Y<<X)\n             Add the ear towards X to the ADAG\n          Else //\
    \ (a) X is root, or (b) X<<Y, or (c) X, Y not ordered\n             Add the ear\
    \ towards Y to the ADAG\n      Figure 6: Generic Algorithm to Find Ears and Their\
    \ Direction in\n                             2-Connected Graph\n   The algorithm\
    \ in Figure 6 merely requires that a cycle or ear be\n   selected without specifying\
    \ how.  Regardless of the method for\n   selecting the path, we will get an ADAG.\
    \  The method used for finding\n   and selecting the ears is important; shorter\
    \ ears result in shorter\n   paths along the MRTs.  The MRT Lowpoint algorithm\
    \ uses the Lowpoint\n   Inheritance method for constructing an ADAG (and ultimately\
    \ a GADAG).\n   This method is defined in Section 5.5.  Other methods for\n  \
    \ constructing GADAGs are described in Appendices B and C.  An\n   evaluation\
    \ of these different methods is given in Section 8.\n   As an example, consider\
    \ Figure 5 again.  First, we select the\n   shortest cycle containing R, which\
    \ can be R-A-B-F-D-E (uniform link\n   costs were assumed), so we get to the situation\
    \ depicted in\n   Figure 5(b).  Finally, we find a node next to a ready node;\
    \ that must\n   be node C and assume we reached it from ready node B.  We search\
    \ a\n   path from C to R without B in the original graph.  The first ready\n \
    \  node along this is node D, so the open ear is B-C-D.  Since B<<D, we\n   add\
    \ arc B->C and C->D to the ADAG.  Since all the nodes are ready, we\n   stop at\
    \ this point.\n"
- title: 4.3.  Lowpoint Values and Their Uses
  contents:
  - "4.3.  Lowpoint Values and Their Uses\n   A basic way of computing a spanning\
    \ tree on a network graph is to run\n   a DFS, such as given in Figure 7.  This\
    \ tree has the important\n   property that if there is a link (x, n), then either\
    \ n is a DFS\n   ancestor of x or n is a DFS descendant of x.  In other words,\
    \ either\n   n is on the path from the root to x or x is on the path from the\
    \ root\n   to n.\n                        global_variable: dfs_number\n      \
    \                  DFS_Visit(node x, node parent)\n                          \
    \ D(x) = dfs_number\n                           dfs_number += 1\n            \
    \               x.dfs_parent = parent\n                           for each link\
    \ (x, w)\n                             if D(w) is not set\n                  \
    \             DFS_Visit(w, x)\n                        Run_DFS(node gadag_root)\n\
    \                           dfs_number = 0\n                           DFS_Visit(gadag_root,\
    \ NONE)\n                       Figure 7: Basic DFS Algorithm\n   Given a node\
    \ x, one can compute the minimal DFS number of the\n   neighbors of x, i.e., min(\
    \ D(w) if (x,w) is a link).  This gives the\n   earliest attachment point neighboring\
    \ x.  What is interesting,\n   though, is the earliest attachment point from x\
    \ and x's descendants.\n   This is what is determined by computing the Lowpoint\
    \ value.\n   In order to compute the low point value, the network is traversed\n\
    \   using DFS and the vertices are numbered based on the DFS walk.  Let\n   this\
    \ number be represented as DFS(x).  All the edges that lead to\n   already-visited\
    \ nodes during DFS walk are back-edges.  The back-edges\n   are important because\
    \ they give information about reachability of a\n   node via another path.\n \
    \  The low point number is calculated by finding:\n   Low(x) = Minimum of (  (DFS(x),\n\
    \      Lowest DFS(n, x->n is a back-edge),\n      Lowest Low(n, x->n is tree edge\
    \ in DFS walk) ).\n   A detailed algorithm for computing the lowpoint value is\
    \ given in\n   Figure 8.  Figure 9 illustrates how the Lowpoint algorithm applies\
    \ to\n   an example graph.\n            global_variable: dfs_number\n        \
    \    Lowpoint_Visit(node x, node parent, interface p_to_x)\n               D(x)\
    \ = dfs_number\n               L(x) = D(x)\n               dfs_number += 1\n \
    \              x.dfs_parent = parent\n               x.dfs_parent_intf = p_to_x.remote_intf\n\
    \               x.lowpoint_parent = NONE\n               for each ordered_interface\
    \ intf of x\n                 if D(intf.remote_node) is not set\n            \
    \       Lowpoint_Visit(intf.remote_node, x, intf)\n                   if L(intf.remote_node)\
    \ < L(x)\n                      L(x) = L(intf.remote_node)\n                 \
    \     x.lowpoint_parent = intf.remote_node\n                      x.lowpoint_parent_intf\
    \ = intf\n                 else if intf.remote_node is not parent\n          \
    \         if D(intf.remote_node) < L(x)\n                      L(x) = D(intf.remote_node)\n\
    \                      x.lowpoint_parent = intf.remote_node\n                \
    \      x.lowpoint_parent_intf = intf\n            Run_Lowpoint(node gadag_root)\n\
    \               dfs_number = 0\n               Lowpoint_Visit(gadag_root, NONE,\
    \ NONE)\n                    Figure 8: Computing Lowpoint Value\n            [E]---|\
    \    [J]-------[I]   [P]---[O]\n             |    |     |         |     |    \
    \ |\n             |    |     |         |     |     |\n            [R]  [D]---[C]--[F]\
    \  [H]---[K]   [N]\n             |          |    |    |     |     |\n        \
    \     |          |    |    |     |     |\n            [A]--------[B]  [G]---|\
    \    [L]---[M]\n               (a) a non-2-connected graph\n             [E]----|\
    \    [J]---------[I]    [P]------[O]\n            (5, )   |  (10, )       (9,\
    \ ) (16,  ) (15,  )\n              |     |     |           |      |        |\n\
    \              |     |     |           |      |        |\n             [R]   [D]---[C]---[F]\
    \   [H]----[K]      [N]\n            (0, ) (4, ) (3, ) (6, ) (8, ) (11, )  (14,\
    \ )\n              |           |     |     |      |        |\n              |\
    \           |     |     |      |        |\n             [A]---------[B]   [G]----|\
    \     [L]------[M]\n            (1, )       (2, ) (7, )       (12,  )  (13,  )\n\
    \               (b) with DFS values assigned   (D(x), L(x))\n             [E]----|\
    \    [J]---------[I]    [P]------[O]\n            (5,0)   |  (10,3)       (9,3)\
    \ (16,11) (15,11)\n              |     |     |           |      |        |\n \
    \             |     |     |           |      |        |\n             [R]   [D]---[C]---[F]\
    \   [H]----[K]      [N]\n            (0,0) (4,0) (3,0) (6,3) (8,3) (11,11) (14,11)\n\
    \              |           |     |     |      |        |\n              |    \
    \       |     |     |      |        |\n             [A]---------[B]   [G]----|\
    \     [L]------[M]\n            (1,0)       (2,0) (7,3)       (12,11)  (13,11)\n\
    \                (c) with lowpoint values assigned (D(x), L(x))\n            \
    \   Figure 9: Example Lowpoint Value Computation\n   From the lowpoint value and\
    \ lowpoint parent, there are three very\n   useful things that motivate our computation.\n\
    \   First, if there is a child c of x such that L(c) >= D(x), then there\n   are\
    \ no paths in the network graph that go from c or its descendants\n   to an ancestor\
    \ of x; therefore, x is a cut-vertex.  In Figure 9, this\n   can be seen by looking\
    \ at the DFS children of C.  C has two children,\n   D and F and L(F) = 3 = D(C);\
    \ so, it is clear that C is a cut-vertex\n   and F is in a block where C is the\
    \ block's root.  L(D) = 0<3 = D(C),\n   so D has a path to the ancestors of C;\
    \ in this case, D can go via E\n   to reach R.  Comparing the lowpoint values\
    \ of all a node's DFS-\n   children with the node's DFS-value is very useful because\
    \ it allows\n   identification of the cut-vertices and thus the blocks.\n   Second,\
    \ by repeatedly following the path given by lowpoint_parent,\n   there is a path\
    \ from x back to an ancestor of x that does not use the\n   link [x, x.dfs_parent]\
    \ in either direction.  The full path need not\n   be taken, but this gives a\
    \ way of finding an initial cycle and then\n   ears.\n   Third, as seen in Figure\
    \ 9, even if L(x)<D(x), there may be a block\n   that contains both the root and\
    \ a DFS-child of a node while other\n   DFS-children might be in different blocks.\
    \  In this example, C's\n   child D is in the same block as R while F is not.\
    \  It is important to\n   realize that the root of a block may also be the root\
    \ of another\n   block.\n"
- title: 4.4.  Blocks in a Graph
  contents:
  - "4.4.  Blocks in a Graph\n   A key idea for the MRT Lowpoint algorithm is that\
    \ any non-2-connected\n   graph is made up by blocks (e.g., 2-connected clusters,\
    \ cut-links,\n   and/or isolated nodes).  To compute GADAGs and thus MRTs, computation\n\
    \   is done in each block to compute ADAGs or Redundant Trees and then\n   those\
    \ ADAGs or Redundant Trees are combined into a GADAG or MRT.\n               \
    \   [E]---|    [J]-------[I]   [P]---[O]\n                   |    |     |    \
    \     |     |     |\n                   |    |     |         |     |     |\n \
    \                 [R]  [D]---[C]--[F]  [H]---[K]   [N]\n                   | \
    \         |    |    |     |     |\n                   |          |    |    | \
    \    |     |\n                  [A]--------[B]  [G]---|    [L]---[M]\n       \
    \           (a)  A graph with four blocks:\n                       three 2-connected\
    \ clusters\n                       and one cut-link\n                  [E]<--|\
    \    [J]<------[I]   [P]<--[O]\n                   |    |     |         ^    \
    \ |     ^\n                   V    |     V         |     V     |\n           \
    \       [R]  [D]<--[C]  [F]  [H]<---[K]  [N]\n                              ^\
    \    |    ^           ^\n                              |    V    |           |\n\
    \                  [A]------->[B]  [G]---|     [L]-->[M]\n                   \
    \ (b) MRT-Blue for destination R\n                  [E]---|    [J]-------->[I]\
    \    [P]-->[O]\n                        |                 |            |\n   \
    \                     V                 V            V\n                  [R]\
    \  [D]-->[C]<---[F]  [H]<---[K]   [N]\n                   ^          |      ^\
    \    |      ^     |\n                   |          V      |    |      |     V\n\
    \                  [A]<-------[B]    [G]<--|     [L]<--[M]\n                 \
    \    (c) MRT-Red for destination R\n                                 Figure 10\n\
    \   Consider the example depicted in Figure 10 (a).  In this figure, a\n   special\
    \ graph is presented, showing us all the ways 2-connected\n   clusters can be\
    \ connected.  It has four blocks: block 1 contains R,\n   A, B, C, D, E; block\
    \ 2 contains C, F, G, H, I, J; block 3 contains K,\n   L, M, N, O, P; and block\
    \ 4 is a cut-link containing H and K.  As can\n   be observed, the first two blocks\
    \ have one common node (node C) and\n   blocks 2 and 3 do not have any common\
    \ node, but they are connected\n   through a cut-link that is block 4.  No two\
    \ blocks can have more than\n   one common node, since two blocks with at least\
    \ two common nodes\n   would qualify as a single 2-connected cluster.\n   Moreover,\
    \ observe that if we want to get from one block to another,\n   we must use a\
    \ cut-vertex (the cut-vertices in this graph are C, H,\n   K), regardless of the\
    \ path selected, so we can say that all the paths\n   from block 3 along the MRTs\
    \ rooted at R will cross K first.  This\n   observation means that if we want\
    \ to find a pair of MRTs rooted at R,\n   then we need to build up a pair of RTs\
    \ in block 3 with K as a root.\n   Similarly, we need to find another pair of\
    \ RTs in block 2 with C as a\n   root, and finally, we need the last pair of RTs\
    \ in block 1 with R as\n   a root.  When all the trees are selected, we can simply\
    \ combine them;\n   when a block is a cut-link (as in block 4), that cut-link\
    \ is added in\n   the same direction to both of the trees.  The resulting trees\
    \ are\n   depicted in Figure 10 (b) and (c).\n   Similarly, to create a GADAG\
    \ it is sufficient to compute ADAGs in\n   each block and connect them.\n   It\
    \ is necessary, therefore, to identify the cut-vertices, the blocks\n   and identify\
    \ the appropriate localroot to use for each block.\n"
- title: 4.5.  Determining Localroot and Assigning Block-ID
  contents:
  - "4.5.  Determining Localroot and Assigning Block-ID\n   Each node in a network\
    \ graph has a localroot, which is the cut-vertex\n   (or root) in the same block\
    \ that is closest to the root.  The\n   localroot is used to determine whether\
    \ two nodes share a common\n   block.\n               Compute_Localroot(node x,\
    \ node localroot)\n                   x.localroot = localroot\n              \
    \     for each DFS child node c of x\n                       if L(c) < D(x)  \
    \ //x is not a cut-vertex\n                           Compute_Localroot(c, x.localroot)\n\
    \                       else\n                           mark x as cut-vertex\n\
    \                           Compute_Localroot(c, x)\n               Compute_Localroot(gadag_root,\
    \ gadag_root)\n               Figure 11: A Method for Computing Localroots\n \
    \  There are two different ways of computing the localroot for each\n   node.\
    \  The stand-alone method is given in Figure 11 and better\n   illustrates the\
    \ concept; it is used by the GADAG construction methods\n   given in Appendices\
    \ B and C.  The MRT Lowpoint algorithm computes the\n   localroot for a block\
    \ as part of computing the GADAG using lowpoint\n   inheritance; the essence of\
    \ this computation is given in Figure 12.\n   Both methods for computing the localroot\
    \ produce the same results.\n            Get the current node, s.\n          \
    \  Compute an ear (either through lowpoint inheritance\n            or by following\
    \ dfs parents) from s to a ready node e.\n            (Thus, s is not e, if there\
    \ is such ear.)\n            if s is e\n               for each node x in the\
    \ ear that is not s\n                   x.localroot = s\n            else\n  \
    \             for each node x in the ear that is not s or e\n                \
    \   x.localroot = e.localroot\n           Figure 12: Ear-Based Method for Computing\
    \ Localroots\n   Once the localroots are known, two nodes X and Y are in a common\n\
    \   block if and only if one of the following three conditions apply.\n   o  Y's\
    \ localroot is X's localroot : They are in the same block and\n      neither is\
    \ the cut-vertex closest to the root.\n   o  Y's localroot is X: X is the cut-vertex\
    \ closest to the root for\n      Y's block\n   o  Y is X's localroot: Y is the\
    \ cut-vertex closest to the root for\n      X's block\n   Once we have computed\
    \ the localroot for each node in the network\n   graph, we can assign for each\
    \ node, a Block-ID that represents the\n   block in which the node is present.\
    \  This computation is shown in\n   Figure 13.\n                 global_var: max_block_id\n\
    \                 Assign_Block_ID(x, cur_block_id)\n                   x.block_id\
    \ = cur_block_id\n                   foreach DFS child c of x\n              \
    \        if (c.local_root is x)\n                         max_block_id += 1\n\
    \                         Assign_Block_ID(c, max_block_id)\n                 \
    \     else\n                        Assign_Block_ID(c, cur_block_id)\n       \
    \          max_block_id = 0\n                 Assign_Block_ID(gadag_root, max_block_id)\n\
    \             Figure 13: Assigning Block-ID to Identify Blocks\n"
- title: 5.  MRT Lowpoint Algorithm Specification
  contents:
  - "5.  MRT Lowpoint Algorithm Specification\n   The MRT Lowpoint algorithm computes\
    \ one GADAG that is then used by a\n   router to determine its MRT-Blue and MRT-Red\
    \ next hops to all\n   destinations.  Finally, based upon that information, alternates\
    \ are\n   selected for each next hop to each destination.  The different parts\n\
    \   of this algorithm are described below.\n   o  Order the interfaces in the\
    \ network graph.  See Section 5.1.\n   o  Compute the local MRT Island for the\
    \ particular MRT Profile.  See\n      Section 5.2.\n   o  Select the root to use\
    \ for the GADAG.  See Section 5.3.\n   o  Initialize all interfaces to UNDIRECTED.\
    \  See Section 5.4.\n   o  Compute the DFS value, e.g., D(x), and lowpoint value,\
    \ L(x).  See\n      Figure 8.\n   o  Construct the GADAG.  See Section 5.5.\n\
    \   o  Assign directions to all interfaces that are still UNDIRECTED.\n      See\
    \ Section 5.6.\n   o  From the computing router x, compute the next hops for the\
    \ MRT-\n      Blue and MRT-Red.  See Section 5.7.\n   o  Identify alternates for\
    \ each next hop to each destination by\n      determining which one of the MRT-Blue\
    \ and the MRT-Red the\n      computing router x should select.  See Section 5.8.\n\
    \   A Python implementation of this algorithm is given in Appendix A.\n"
- title: 5.1.  Interface Ordering
  contents:
  - "5.1.  Interface Ordering\n   To ensure consistency in computation, all routers\
    \ MUST order\n   interfaces identically down to the set of links with the same\
    \ metric\n   to the same neighboring node.  This is necessary for the DFS in\n\
    \   Lowpoint_Visit in Section 4.3, where the selection order of the\n   interfaces\
    \ to explore results in different trees.  Consistent\n   interface ordering is\
    \ also necessary for computing the GADAG, where\n   the selection order of the\
    \ interfaces to use to form ears can result\n   in different GADAGs.  It is also\
    \ necessary for the topological sort\n   described in Section 5.8, where different\
    \ topological sort orderings\n   can result in undirected links being added to\
    \ the GADAG in different\n   directions.\n   The required ordering between two\
    \ interfaces from the same router x\n   is given in Figure 14.\n      Interface_Compare(interface\
    \ a, interface b)\n        if a.metric < b.metric\n           return A_LESS_THAN_B\n\
    \        if b.metric < a.metric\n           return B_LESS_THAN_A\n        if a.neighbor.mrt_node_id\
    \ < b.neighbor.mrt_node_id\n           return A_LESS_THAN_B\n        if b.neighbor.mrt_node_id\
    \ < a.neighbor.mrt_node_id\n           return B_LESS_THAN_A\n        // Same metric\
    \ to same node, so the order doesn't matter for\n        // interoperability.\n\
    \        return A_EQUAL_TO_B\n    Figure 14: Rules for Ranking Multiple Interfaces\
    \ (Order Is from Low\n                                 to High)\n   In Figure\
    \ 14, if two interfaces on a router connect to the same\n   remote router with\
    \ the same metric, the Interface_Compare function\n   returns A_EQUAL_TO_B.  This\
    \ is because the order in which those\n   interfaces are initially explored does\
    \ not affect the final GADAG\n   produced by the algorithm described here.  While\
    \ only one of the\n   links will be added to the GADAG in the initial traversal,\
    \ the other\n   parallel links will be added to the GADAG with the same direction\n\
    \   assigned during the procedure for assigning direction to UNDIRECTED\n   links\
    \ described in Section 5.6.  An implementation is free to apply\n   some additional\
    \ criteria to break ties in interface ordering in this\n   situation, but those\
    \ criteria are not specified here since they will\n   not affect the final GADAG\
    \ produced by the algorithm.\n   The Interface_Compare function in Figure 14 relies\
    \ on the\n   interface.metric and the interface.neighbor.mrt_node_id values to\n\
    \   order interfaces.  The exact source of these values for different\n   IGPs\
    \ and applications is specified in Figure 15.  The metric and\n   mrt_node_id\
    \ values for OSPFv2, OSPFv3, and IS-IS provided here is\n   normative.  The metric\
    \ and mrt_node_id values for IS-IS Path Control\n   and Reservation (PCR) in this\
    \ table should be considered\n   informational.  The normative values are specified\
    \ in [IEEE8021Qca].\n  +--------------+-----------------------+-----------------------------+\n\
    \  | IGP/flooding | mrt_node_id           | metric of                   |\n  |\
    \ protocol     | of neighbor           | interface                   |\n  | and\
    \          | on interface          |                             |\n  | application\
    \  |                       |                             |\n  +--------------+-----------------------+-----------------------------+\n\
    \  | OSPFv2 for   | 4-octet Neighbor      | 2-octet Metric field        |\n  |\
    \ IP/LDP FRR   | Router ID in          | for corresponding           |\n  |  \
    \            | Link ID field for     | point-to-point link         |\n  |    \
    \          | corresponding         | in Router-LSA               |\n  |      \
    \        | point-to-point link   |                             |\n  |        \
    \      | in Router-LSA         |                             |\n  +--------------+-----------------------+-----------------------------+\n\
    \  | OSPFv3 for   | 4-octet Neighbor      | 2-octet Metric field        |\n  |\
    \ IP/LDP FRR   | Router ID field       | for corresponding           |\n  |  \
    \            | for corresponding     | point-to-point link         |\n  |    \
    \          | point-to-point link   | in Router-LSA               |\n  |      \
    \        | in Router-LSA         |                             |\n  +--------------+-----------------------+-----------------------------+\n\
    \  | IS-IS for    | 7-octet neighbor      | 3-octet metric field        |\n  |\
    \ IP/LDP FRR   | system ID and         | in Extended IS              |\n  |  \
    \            | pseudonode number     | Reachability TLV (type 22)  |\n  |    \
    \          | in Extended IS        | or Multi-Topology           |\n  |      \
    \        | Reachability TLV (type| IS Neighbor TLV (type 222)  |\n  |        \
    \      | 22) or Multi-Topology |                             |\n  |          \
    \    | IS Neighbor TLV (type |                             |\n  |            \
    \  | 222)                  |                             |\n  +--------------+-----------------------+-----------------------------+\n\
    \  | IS-IS PCR for| 8-octet Bridge ID     | 3-octet SPB-LINK-METRIC in  |\n  |\
    \ protection   | created from  2-octet | SPB-Metric sub-TLV (type 29)|\n  | of\
    \ traffic   | Bridge Priority in    | in Extended IS Reachability |\n  | in bridged\
    \   | Shortest Path Bridging| TLV (type 22) or            |\n  |             \
    \ |SPB Instance sub-TLV   | Multi-Topology              |\n  | networks     |\
    \ (type 1) carried in   | Intermediate Systems        |\n  |              | MT-Capability\
    \ TLV     | TLV (type 222).  In the case|\n  |              | (type 144) and 6-octet|\
    \ of asymmetric link metrics, |\n  |              | neighbor system ID in | the\
    \ larger link metric      |\n  |              | Extended IS           | is used\
    \ for both link       |\n  |              | Reachability TLV (type| directions.\
    \                 |\n  |              | 22) or Multi-Topology | (informational)\
    \             |\n  |              | Intermediate Systems  |                  \
    \           |\n  |              | TLV (type 222)        |                    \
    \         |\n  |              | (informational)       |                      \
    \       |\n  +--------------+-----------------------+-----------------------------+\n\
    \          Figure 15: Value of interface.neighbor.mrt_node_id and\n     interface.metric\
    \ to Be Used for Ranking Interfaces, for Different\n                    Flooding\
    \ Protocols and Applications\n   The metrics are unsigned integers and MUST be\
    \ compared as unsigned\n   integers.  The results of mrt_node_id comparisons MUST\
    \ be the same as\n   would be obtained by converting the mrt_node_ids to unsigned\
    \ integers\n   using network byte order and performing the comparison as unsigned\n\
    \   integers.  In the case of IS-IS for IP/LDP FRR with point-to-point\n   links,\
    \ the pseudonode number (the 7th octet) is zero.  Broadcast\n   interfaces will\
    \ be discussed in Section 7.\n"
- title: 5.2.  MRT Island Identification
  contents:
  - "5.2.  MRT Island Identification\n   The local MRT Island for a particular MRT\
    \ profile can be determined\n   by starting from the computing router in the network\
    \ graph and doing\n   a breadth-first-search (BFS).  The BFS explores only links\
    \ that are\n   in the same area/level, are not IGP-excluded, and are not MRT-\n\
    \   ineligible.  The BFS explores only nodes that support the particular\n   MRT\
    \ profile.  See Section 7 of [RFC7812] for more-precise definitions\n   of these\
    \ criteria.\n   MRT_Island_Identification(topology, computing_rtr, profile_id,\
    \ area)\n     for all routers in topology\n         rtr.IN_MRT_ISLAND = FALSE\n\
    \     computing_rtr.IN_MRT_ISLAND = TRUE\n     explore_list = { computing_rtr\
    \ }\n     while (explore_list is not empty)\n        next_rtr = remove_head(explore_list)\n\
    \        for each intf in next_rtr\n           if (not intf.IN_MRT_ISLAND\n  \
    \            and not intf.MRT-ineligible\n              and not intf.remote_intf.MRT-ineligible\n\
    \              and not intf.IGP-excluded and (intf in area)\n              and\
    \ (intf.remote_node supports profile_id) )\n              intf.IN_MRT_ISLAND =\
    \ TRUE\n              intf.remote_intf.IN_MRT_ISLAND = TRUE\n              if\
    \ (not intf.remote_node.IN_MRT_ISLAND))\n                 intf.remote_node.IN_MRT_ISLAND\
    \ = TRUE\n                 add_to_tail(explore_list, intf.remote_node)\n     \
    \              Figure 16: MRT Island Identification\n"
- title: 5.3.  GADAG Root Selection
  contents:
  - "5.3.  GADAG Root Selection\n   In Section 8.3 of [RFC7812], the GADAG Root Selection\
    \ Policy is\n   described for the Default MRT Profile.  This selection policy\
    \ allows\n   routers to consistently select a common GADAG Root inside the local\n\
    \   MRT Island, based on advertised priority values.  The MRT Lowpoint\n   algorithm\
    \ simply requires that all routers in the MRT Island MUST\n   select the same\
    \ GADAG Root; the mechanism can vary based upon the MRT\n   profile description.\
    \  Before beginning computation, the network graph\n   is reduced to contain only\
    \ the set of routers that support the\n   specific MRT profile whose MRTs are\
    \ being computed.\n   As noted in Section 7, pseudonodes MUST NOT be considered\
    \ for GADAG\n   root selection.\n   It is expected that an operator will designate\
    \ a set of routers as\n   good choices for selection as GADAG root by setting\
    \ the GADAG Root\n   Selection Priority for that set of routers to lower (more\
    \ preferred)\n   numerical values.  For guidance on setting the GADAG Root Selection\n\
    \   Priority values, refer to Section 9.1.\n"
- title: 5.4.  Initialization
  contents:
  - "5.4.  Initialization\n   Before running the algorithm, there is the standard\
    \ type of\n   initialization to be done, such as clearing any computed DFS-values,\n\
    \   lowpoint-values, DFS parents, lowpoint-parents, any MRT-computed next\n  \
    \ hops, and flags associated with algorithm.\n   It is assumed that a regular\
    \ SPF computation has been run so that the\n   primary next hops from the computing\
    \ router to each destination are\n   known.  This is required for determining\
    \ alternates at the last step.\n   Initially, all interfaces MUST be initialized\
    \ to UNDIRECTED.  Whether\n   they are OUTGOING, INCOMING, or both is determined\
    \ when the GADAG is\n   constructed and augmented.\n   It is possible that some\
    \ links and nodes will be marked using\n   standard IGP mechanisms to discourage\
    \ or prevent transit traffic.\n   Section 7.3.1 of [RFC7812] describes how those\
    \ links and nodes are\n   excluded from MRT Island formation.\n   MRT-FRR also\
    \ has the ability to advertise links MRT-Ineligible, as\n   described in Section\
    \ 7.3.2 of [RFC7812].  These links are excluded\n   from the MRT Island and the\
    \ GADAG.  Computation of MRT next hops will\n   therefore not use any MRT-ineligible\
    \ links.  The MRT Lowpoint\n   algorithm does still need to consider MRT-ineligible\
    \ links when\n   computing FRR alternates, because an MRT-ineligible link can\
    \ still be\n   the shortest-path next hop to reach a destination.\n   When a broadcast\
    \ interface is advertised as MRT-ineligible, then the\n   pseudonode representing\
    \ the entire broadcast network MUST NOT be\n   included in the MRT Island.  This\
    \ is equivalent to excluding all of\n   the broadcast interfaces on that broadcast\
    \ network from the MRT\n   Island.\n"
- title: 5.5.  Constructing the GADAG Using Lowpoint Inheritance
  contents:
  - "5.5.  Constructing the GADAG Using Lowpoint Inheritance\n   As discussed in Section\
    \ 4.2, it is necessary to find ears from a node\n   x that is already in the GADAG\
    \ (known as IN_GADAG).  Two different\n   methods are used to find ears in the\
    \ algorithm.  The first is by\n   going to a DFS-child that is not IN_GADAG and\
    \ then following the\n   chain of lowpoint parents until an IN_GADAG node is found.\
    \  The\n   second is by going to a neighbor that is not IN_GADAG and then\n  \
    \ following the chain of DFS parents until an IN_GADAG node is found.\n   As an\
    \ ear is found, the associated interfaces are marked based on the\n   direction\
    \ taken.  The nodes in the ear are marked as IN_GADAG.  In\n   the algorithm,\
    \ first the ears via DFS-children are found and then the\n   ears via DFS-neighbors\
    \ are found.\n   By adding both types of ears when an IN_GADAG node is processed,\
    \ all\n   ears that connect to that node are found.  The order in which the\n\
    \   IN_GADAG nodes are processed is, of course, key to the algorithm.\n   The\
    \ order is a stack of ears so the most recent ear is found at the\n   top of the\
    \ stack.  Of course, the stack stores nodes and not ears, so\n   an ordered list\
    \ of nodes, from the first node in the ear to the last\n   node in the ear, is\
    \ created as the ear is explored and then that list\n   is pushed onto the stack.\n\
    \   Each ear represents a partial order (see Figure 4) and processing the\n  \
    \ nodes in order along each ear ensures that all ears connecting to a\n   node\
    \ are found before a node higher in the partial order has its ears\n   explored.\
    \  This means that the direction of the links in the ear is\n   always from the\
    \ node x being processed towards the other end of the\n   ear.  Additionally,\
    \ by using a stack of ears, this means that any\n   unprocessed nodes in previous\
    \ ears can only be ordered higher than\n   nodes in the ears below it on the stack.\n\
    \   In this algorithm that depends upon Lowpoint inheritance, it is\n   necessary\
    \ that every node has a lowpoint parent that is not itself.\n   If a node is a\
    \ cut-vertex, that may not yet be the case.  Therefore,\n   any nodes without\
    \ a lowpoint parent will have their lowpoint parent\n   set to their DFS parent\
    \ and their lowpoint value set to the DFS-value\n   of their parent.  This assignment\
    \ also properly allows an ear between\n   two cut-vertices.\n   Finally, the algorithm\
    \ simultaneously computes each node's localroot,\n   as described in Figure 12.\
    \  This is further elaborated as follows.\n   The localroot can be inherited from\
    \ the node at the end of the ear\n   unless the end of the ear is x itself, in\
    \ which case the localroot\n   for all the nodes in the ear would be x.  This\
    \ is because whenever\n   the first cycle is found in a block, or an ear involving\
    \ a bridge is\n   computed, the cut-vertex closest to the root would be x itself.\
    \  In\n   all other scenarios, the properties of lowpoint/dfs parents ensure\n\
    \   that the end of the ear will be in the same block, and thus\n   inheriting\
    \ its localroot would be the correct localroot for all newly\n   added nodes.\n\
    \   The pseudocode for the GADAG algorithm (assuming that the adjustment\n   of\
    \ lowpoint for cut-vertices has been made) is shown in Figure 17.\n          \
    \ Construct_Ear(x, Stack, intf, ear_type)\n              ear_list = empty\n  \
    \            cur_node = intf.remote_node\n              cur_intf = intf\n    \
    \          not_done = true\n              while not_done\n                 cur_intf.UNDIRECTED\
    \ = false\n                 cur_intf.OUTGOING = true\n                 cur_intf.remote_intf.UNDIRECTED\
    \ = false\n                 cur_intf.remote_intf.INCOMING = true\n           \
    \      if cur_node.IN_GADAG is false\n                    cur_node.IN_GADAG =\
    \ true\n                    add_to_list_end(ear_list, cur_node)\n            \
    \        if ear_type is CHILD\n                       cur_intf = cur_node.lowpoint_parent_intf\n\
    \                       cur_node = cur_node.lowpoint_parent\n                \
    \    else  // ear_type must be NEIGHBOR\n                       cur_intf = cur_node.dfs_parent_intf\n\
    \                       cur_node = cur_node.dfs_parent\n                 else\n\
    \                    not_done = false\n              if (ear_type is CHILD) and\
    \ (cur_node is x)\n                 // x is a cut-vertex and the local root for\n\
    \                 // the block in which the ear is computed\n                \
    \ x.IS_CUT_VERTEX = true\n                 localroot = x\n              else\n\
    \                 // Inherit localroot from the end of the ear\n             \
    \    localroot = cur_node.localroot\n              while ear_list is not empty\n\
    \                 y = remove_end_item_from_list(ear_list)\n                 y.localroot\
    \ = localroot\n                 push(Stack, y)\n           Construct_GADAG_via_Lowpoint(topology,\
    \ gadag_root)\n             gadag_root.IN_GADAG = true\n             gadag_root.localroot\
    \ = None\n             Initialize Stack to empty\n             push gadag_root\
    \ onto Stack\n             while (Stack is not empty)\n                x = pop(Stack)\n\
    \                foreach ordered_interface intf of x\n                   if ((intf.remote_node.IN_GADAG\
    \ == false) and\n                       (intf.remote_node.dfs_parent is x))\n\
    \                       Construct_Ear(x, Stack, intf, CHILD)\n               \
    \ foreach ordered_interface intf of x\n                   if ((intf.remote_node.IN_GADAG\
    \ == false) and\n                       (intf.remote_node.dfs_parent is not x))\n\
    \                       Construct_Ear(x, Stack, intf, NEIGHBOR)\n           Construct_GADAG_via_Lowpoint(topology,\
    \ gadag_root)\n              Figure 17: Lowpoint Inheritance GADAG Algorithm\n"
- title: 5.6.  Augmenting the GADAG by Directing All Links
  contents:
  - "5.6.  Augmenting the GADAG by Directing All Links\n   The GADAG, regardless of\
    \ the method used to construct it, at this\n   point could be used to find MRTs,\
    \ but the topology does not include\n   all links in the network graph.  That\
    \ has two impacts.  First, there\n   might be shorter paths that respect the GADAG\
    \ partial ordering and so\n   the alternate paths would not be as short as possible.\
    \  Second, there\n   may be additional paths between a router x and the root that\
    \ are not\n   included in the GADAG.  Including those provides potentially more\n\
    \   bandwidth to traffic flowing on the alternates and may reduce\n   congestion\
    \ compared to just using the GADAG as currently constructed.\n   The goal is thus\
    \ to assign direction to every remaining link marked\n   as UNDIRECTED to improve\
    \ the paths and number of paths found when the\n   MRTs are computed.\n   To do\
    \ this, we need to establish a total order that respects the\n   partial order\
    \ described by the GADAG.  This can be done using Kahn's\n   topological sort\
    \ [Kahn_1962_topo_sort], which essentially assigns a\n   number to a node x only\
    \ after all nodes before it (e.g., with a link\n   incoming to x) have had their\
    \ numbers assigned.  The only issue with\n   the topological sort is that it works\
    \ on DAGs and not ADAGs or\n   GADAGs.\n   To convert a GADAG to a DAG, it is\
    \ necessary to remove all links that\n   point to a root of block from within\
    \ that block.  That provides the\n   necessary conversion to a DAG and then a\
    \ topological sort can be\n   done.  When adding undirected links to the GADAG,\
    \ links connecting\n   the block root to other nodes in that block need special\
    \ handling\n   because the topological order will not always give the right answer\n\
    \   for those links.  There are three cases to consider.  If the\n   undirected\
    \ link in question has another parallel link between the\n   same two nodes that\
    \ is already directed, then the direction of the\n   undirected link can be inherited\
    \ from the previously directed link.\n   In the case of parallel cut links, we\
    \ set all of the parallel links\n   to both INCOMING and OUTGOING.  Otherwise,\
    \ the undirected link in\n   question is set to OUTGOING from the block root node.\
    \  A cut-link can\n   then be identified by the fact that it will be directed\
    \ both INCOMING\n   and OUTGOING in the GADAG.  The exact details of this whole\
    \ process\n   are captured in Figure 18.\n     Add_Undirected_Block_Root_Links(topo,\
    \ gadag_root)\n         foreach node x in topo\n             if x.IS_CUT_VERTEX\
    \ or x is gadag_root\n                 foreach interface i of x\n            \
    \         if (i.remote_node.localroot is not x\n                             \
    \            or i.PROCESSED )\n                         continue\n           \
    \          Initialize bundle_list to empty\n                     bundle.UNDIRECTED\
    \ = true\n                     bundle.OUTGOING = false\n                     bundle.INCOMING\
    \ = false\n                     foreach interface i2 in x\n                  \
    \       if i2.remote_node is i.remote_node\n                             add_to_list_end(bundle_list,\
    \ i2)\n                             if not i2.UNDIRECTED:\n                  \
    \               bundle.UNDIRECTED = false\n                                 if\
    \ i2.INCOMING:\n                                     bundle.INCOMING = true\n\
    \                                 if i2.OUTGOING:\n                          \
    \           bundle.OUTGOING = true\n                     if bundle.UNDIRECTED\n\
    \                         foreach interface i3 in bundle_list\n              \
    \               i3.UNDIRECTED = false\n                             i3.remote_intf.UNDIRECTED\
    \ = false\n                             i3.PROCESSED = true\n                \
    \             i3.remote_intf.PROCESSED = true\n                             i3.OUTGOING\
    \ = true\n                             i3.remote_intf.INCOMING = true\n      \
    \               else\n                         if (bundle.OUTGOING and bundle.INCOMING)\n\
    \                             foreach interface i3 in bundle_list\n          \
    \                       i3.UNDIRECTED = false\n                              \
    \   i3.remote_intf.UNDIRECTED = false\n                                 i3.PROCESSED\
    \ = true\n                                 i3.remote_intf.PROCESSED = true\n \
    \                                i3.OUTGOING = true\n                        \
    \         i3.INCOMING = true\n                                 i3.remote_intf.INCOMING\
    \ = true\n                                 i3.remote_intf.OUTGOING = true\n  \
    \                       else if bundle.OUTGOING\n                            \
    \ foreach interface i3 in bundle_list\n                                 i3.UNDIRECTED\
    \ = false\n                                 i3.remote_intf.UNDIRECTED = false\n\
    \                                 i3.PROCESSED = true\n                      \
    \           i3.remote_intf.PROCESSED = true\n                                \
    \ i3.OUTGOING = true\n                                 i3.remote_intf.INCOMING\
    \ = true\n                         else if bundle.INCOMING\n                 \
    \            foreach interface i3 in bundle_list\n                           \
    \      i3.UNDIRECTED = false\n                                 i3.remote_intf.UNDIRECTED\
    \ = false\n                                 i3.PROCESSED = true\n            \
    \                     i3.remote_intf.PROCESSED = true\n                      \
    \           i3.INCOMING = true\n                                 i3.remote_intf.OUTGOING\
    \ = true\n     Modify_Block_Root_Incoming_Links(topo, gadag_root)\n         foreach\
    \ node x in topo\n             if x.IS_CUT_VERTEX or x is gadag_root\n       \
    \          foreach interface i of x\n                     if i.remote_node.localroot\
    \ is x\n                         if i.INCOMING:\n                            \
    \ i.INCOMING = false\n                             i.INCOMING_STORED = true\n\
    \                             i.remote_intf.OUTGOING = false\n               \
    \              i.remote_intf.OUTGOING_STORED = true\n     Revert_Block_Root_Incoming_Links(topo,\
    \ gadag_root)\n         foreach node x in topo\n             if x.IS_CUT_VERTEX\
    \ or x is gadag_root\n                 foreach interface i of x\n            \
    \         if i.remote_node.localroot is x\n                         if i.INCOMING_STORED\n\
    \                             i.INCOMING = true\n                            \
    \ i.remote_intf.OUTGOING = true\n                             i.INCOMING_STORED\
    \ = false\n                             i.remote_intf.OUTGOING_STORED = false\n\
    \     Run_Topological_Sort_GADAG(topo, gadag_root)\n         Modify_Block_Root_Incoming_Links(topo,\
    \ gadag_root)\n         foreach node x in topo\n             node.unvisited =\
    \ 0\n             foreach interface i of x\n                 if (i.INCOMING)\n\
    \                     node.unvisited += 1\n         Initialize working_list to\
    \ empty\n         Initialize topo_order_list to empty\n         add_to_list_end(working_list,\
    \ gadag_root)\n         while working_list is not empty\n             y = remove_start_item_from_list(working_list)\n\
    \             add_to_list_end(topo_order_list, y)\n             foreach ordered_interface\
    \ i of y\n                 if intf.OUTGOING\n                     i.remote_node.unvisited\
    \ -= 1\n                     if i.remote_node.unvisited is 0\n               \
    \          add_to_list_end(working_list, i.remote_node)\n         next_topo_order\
    \ = 1\n         while topo_order_list is not empty\n             y = remove_start_item_from_list(topo_order_list)\n\
    \             y.topo_order = next_topo_order\n             next_topo_order +=\
    \ 1\n         Revert_Block_Root_Incoming_Links(topo, gadag_root)\n     def Set_Other_Undirected_Links_Based_On_Topo_Order(topo)\n\
    \         foreach node x in topo\n             foreach interface i of x\n    \
    \             if i.UNDIRECTED:\n                     if x.topo_order < i.remote_node.topo_order\n\
    \                         i.OUTGOING = true\n                         i.UNDIRECTED\
    \ = false\n                         i.remote_intf.INCOMING = true\n          \
    \               i.remote_intf.UNDIRECTED = false\n                     else\n\
    \                         i.INCOMING = true\n                         i.UNDIRECTED\
    \ = false\n                         i.remote_intf.OUTGOING = true\n          \
    \               i.remote_intf.UNDIRECTED = false\n     Add_Undirected_Links(topo,\
    \ gadag_root)\n         Add_Undirected_Block_Root_Links(topo, gadag_root)\n  \
    \       Run_Topological_Sort_GADAG(topo, gadag_root)\n         Set_Other_Undirected_Links_Based_On_Topo_Order(topo)\n\
    \     Add_Undirected_Links(topo, gadag_root)\n            Figure 18: Assigning\
    \ Direction to UNDIRECTED Links\n   Proxy-nodes do not need to be added to the\
    \ network graph.  They\n   cannot be transited and do not affect the MRTs that\
    \ are computed.\n   The details of how the MRT-Blue and MRT-Red next hops are\
    \ computed\n   for proxy-nodes and how the appropriate alternate next hops are\n\
    \   selected is given in Section 5.9.\n"
- title: 5.7.  Compute MRT Next Hops
  contents:
  - "5.7.  Compute MRT Next Hops\n   As was discussed in Section 4.1, once an ADAG\
    \ is found, it is\n   straightforward to find the next hops from any node X to\
    \ the ADAG\n   root.  However, in this algorithm, we will reuse the common GADAG\
    \ and\n   find not only the one pair of MRTs rooted at the GADAG root with it,\n\
    \   but find a pair rooted at each node.  This is useful since it is\n   significantly\
    \ faster to compute.\n   The method for computing differently rooted MRTs from\
    \ the common\n   GADAG is based on two ideas.  First, if two nodes X and Y are\
    \ ordered\n   with respect to each other in the partial order, then an SPF along\n\
    \   OUTGOING links (an increasing-SPF) and an SPF along INCOMING links (a\n  \
    \ decreasing-SPF) can be used to find the increasing and decreasing\n   paths.\
    \  Second, if two nodes X and Y aren't ordered with respect to\n   each other\
    \ in the partial order, then intermediary nodes can be used\n   to create the\
    \ paths by increasing/decreasing to the intermediary and\n   then decreasing/increasing\
    \ to reach Y.\n   As usual, the two basic ideas will be discussed assuming the\
    \ network\n   is 2-connected.  The generalization to multiple blocks is discussed\n\
    \   in Section 5.7.4.  The full algorithm is given in Section 5.7.5.\n"
- title: 5.7.1.  MRT Next Hops to All Nodes Ordered with Respect to the Computing
  contents:
  - "5.7.1.  MRT Next Hops to All Nodes Ordered with Respect to the Computing\n  \
    \      Node\n   Finding two node-disjoint paths from the computing router X to\
    \ any\n   node Y depends upon whether Y>>X or Y<<X.  As shown in Figure 19, if\n\
    \   Y>>X, then there is an increasing path that goes from X to Y without\n   crossing\
    \ R; this contains nodes in the interval [X,Y].  There is also\n   a decreasing\
    \ path that decreases towards R and then decreases from R\n   to Y; this contains\
    \ nodes in the interval [X,R-small] or [R-great,Y].\n   The two paths cannot have\
    \ common nodes other than X and Y.\n                     [Y]<---(Cloud 2)<---\
    \ [X]\n                      |                    ^\n                      | \
    \                   |\n                      V                    |\n        \
    \           (Cloud 3)--->[R]--->(Cloud 1)\n                  MRT-Blue path: X->Cloud\
    \ 2->Y\n                  MRT-Red path: X->Cloud 1->R->Cloud 3->Y\n          \
    \                    Figure 19: Y>>X\n   Similar logic applies if Y<<X, as shown\
    \ in Figure 20.  In this case,\n   the increasing path from X increases to R and\
    \ then increases from R\n   to Y to use nodes in the intervals [X,R-great] and\
    \ [R-small, Y].  The\n   decreasing path from X reaches Y without crossing R and\
    \ uses nodes in\n   the interval [Y,X].\n                    [X]<---(Cloud 2)<---\
    \ [Y]\n                     |                    ^\n                     |   \
    \                 |\n                     V                    |\n           \
    \       (Cloud 3)--->[R]--->(Cloud 1)\n                 MRT-Blue path: X->Cloud\
    \ 3->R->Cloud 1->Y\n                 MRT-Red path: X->Cloud 2->Y\n           \
    \                   Figure 20: Y<<X\n"
- title: 5.7.2.  MRT Next Hops to All Nodes Not Ordered with Respect to the
  contents:
  - "5.7.2.  MRT Next Hops to All Nodes Not Ordered with Respect to the\n        Computing\
    \ Node\n   When X and Y are not ordered, the first path should increase until\
    \ we\n   get to a node G, where G>>Y.  At G, we need to decrease to Y.  The\n\
    \   other path should be just the opposite: we must decrease until we get\n  \
    \ to a node H, where H<<Y, and then increase.  Since R is smaller and\n   greater\
    \ than Y, such G and H must exist.  It is also easy to see that\n   these two\
    \ paths must be node disjoint: the first path contains nodes\n   in interval [X,G]\
    \ and [Y,G], while the second path contains nodes in\n   interval [H,X] and [H,Y].\
    \  This is illustrated in Figure 21.  It is\n   necessary to decrease and then\
    \ increase for the MRT-Blue and increase\n   and then decrease for the MRT-Red;\
    \ if one simply increased for one\n   and decreased for the other, then both paths\
    \ would go through the\n   root R.\n                 (Cloud 6)<---[Y]<---(Cloud\
    \ 5)<------------|\n                   |                                     \
    \  |\n                   |                                       |\n         \
    \          V                                       |\n                  [G]--->(Cloud\
    \ 4)--->[R]--->(Cloud 1)--->[H]\n                   ^                        \
    \               |\n                   |                                      \
    \ |\n                   |                                       |\n          \
    \        (Cloud 3)<---[X]<---(Cloud 2)<-----------|\n              MRT-Blue path:\
    \ decrease to H and increase to Y\n                   X->Cloud 2->H->Cloud 5->Y\n\
    \              MRT-Red path:  increase to G and decrease to Y\n              \
    \     X->Cloud 3->G->Cloud 6->Y\n                       Figure 21: X and Y Unordered\n\
    \   This gives disjoint paths as long as G and H are not the same node.\n   Since\
    \ G>>Y and H<<Y, if G and H could be the same node, that would\n   have to be\
    \ the root R.  This is not possible because there is only\n   one incoming interface\
    \ to the root R that is created when the initial\n   cycle is found.  Recall from\
    \ Figure 6 that whenever an ear was found\n   to have an end that was the root\
    \ R, the ear was directed from R so\n   that the associated interface on R is\
    \ outgoing and not incoming.\n   Therefore, there must be exactly one node M that\
    \ is the largest one\n   before R, so the MRT-Red path will never reach R; it\
    \ will turn at M\n   and decrease to Y.\n"
- title: 5.7.3.  Computing Redundant Tree Next Hops in a 2-Connected Graph
  contents:
  - "5.7.3.  Computing Redundant Tree Next Hops in a 2-Connected Graph\n   The basic\
    \ ideas for computing RT next hops in a 2-connected graph\n   were given in Sections\
    \ 5.7.1 and 5.7.2.  Given these two ideas, how\n   can we find the trees?\n  \
    \ If some node X only wants to find the next hops (which is usually the\n   case\
    \ for IP networks), it is enough to find which nodes are greater\n   and less\
    \ than X, and which are not ordered; this can be done by\n   running an increasing-SPF\
    \ and a decreasing-SPF rooted at X and not\n   exploring any links from the ADAG\
    \ root.\n   In principle, a traversal method other than SPF could be used to\n\
    \   traverse the GADAG in the process of determining blue and red next\n   hops\
    \ that result in maximally redundant trees.  This will be the case\n   as long\
    \ as one traversal uses the links in the direction specified by\n   the GADAG\
    \ and the other traversal uses the links in the direction\n   opposite of that\
    \ specified by the GADAG.  However, a different\n   traversal algorithm will generally\
    \ result in different blue and red\n   next hops.  Therefore, the algorithm specified\
    \ here requires the use\n   of SPF to traverse the GADAG to generate MRT blue\
    \ and red next hops,\n   as described below.\n   An increasing-SPF rooted at X\
    \ and not exploring links from the root\n   will find the increasing next hops\
    \ to all Y>>X.  Those increasing\n   next hops are X's next hops on the MRT-Blue\
    \ to reach Y.  A\n   decreasing-SPF rooted at X and not exploring links from the\
    \ root will\n   find the decreasing next hops to all Z<<X.  Those decreasing next\n\
    \   hops are X's next hops on the MRT-Red to reach Z.  Since the root R\n   is\
    \ both greater than and less than X, after this increasing-SPF and\n   decreasing-SPF,\
    \ X's next hops on the MRT-Blue and on the MRT-Red to\n   reach R are known. \
    \ For every node Y>>X, X's next hops on the MRT-Red\n   to reach Y are set to\
    \ those on the MRT-Red to reach R.  For every\n   node Z<<X, X's next hops on\
    \ the MRT-Blue to reach Z are set to those\n   on the MRT-Blue to reach R.\n \
    \  For those nodes that were not reached by either the increasing-SPF or\n   the\
    \ decreasing-SPF, we can determine the next hops as well.  The\n   increasing\
    \ MRT-Blue next hop for a node that is not ordered with\n   respect to X is the\
    \ next hop along the decreasing MRT-Red towards R,\n   and the decreasing MRT-Red\
    \ next hop is the next hop along the\n   increasing MRT-Blue towards R.  Naturally,\
    \ since R is ordered with\n   respect to all the nodes, there will always be an\
    \ increasing and a\n   decreasing path towards it.  This algorithm does not provide\
    \ the\n   complete specific path taken but just the appropriate next hops to\n\
    \   use.  The identities of G and H are not determined by the computing\n   node\
    \ X.\n   The final case to consider is when the GADAG root R computes its own\n\
    \   next hops.  Since the GADAG root R is << all other nodes, running an\n   increasing-SPF\
    \ rooted at R will reach all other nodes; the MRT-Blue\n   next hops are those\
    \ found with this increasing-SPF.  Similarly, since\n   the GADAG root R is >>\
    \ all other nodes, running a decreasing-SPF\n   rooted at R will reach all other\
    \ nodes; the MRT-Red next hops are\n   those found with this decreasing-SPF.\n\
    \                 E---D---|              E<--D<--|\n                 |   |   |\
    \              |   ^   |\n                 |   |   |              V   |   |\n\
    \                 R   F   C              R   F   C\n                 |   |   |\
    \              |   ^   ^\n                 |   |   |              V   |   |\n\
    \                 A---B---|              A-->B---|\n                    (a)  \
    \                  (b)\n            A 2-connected graph    A spanning ADAG rooted\
    \ at R\n                                 Figure 22\n   As an example, consider\
    \ the situation depicted in Figure 22.  Node C\n   runs an increasing-SPF and\
    \ a decreasing-SPF on the ADAG.  The\n   increasing-SPF reaches D, E, and R; the\
    \ decreasing-SPF reaches B, A,\n   and R.  E>>C.  So, towards E the MRT-Blue next\
    \ hop is D, since E was\n   reached on the increasing path through D.  The MRT-Red\
    \ next hop\n   towards E is B, since R was reached on the decreasing path through\
    \ B.\n   Since E>>D, D will similarly compute its MRT-Blue next hop to be E,\n\
    \   ensuring that a packet on MRT-Blue will use path C-D-E.  B, A, and R\n   will\
    \ similarly compute the MRT-Red next hops towards E (which is\n   ordered less\
    \ than B, A and R), ensuring that a packet on MRT-Red will\n   use path C-B-A-R-E.\n\
    \   C can determine the next hops towards F as well.  Since F is not\n   ordered\
    \ with respect to C, the MRT-Blue next hop is the decreasing\n   one towards R\
    \ (which is B) and the MRT-Red next hop is the increasing\n   one towards R (which\
    \ is D).  Since F>>B, for its MRT-Blue next hop\n   towards F, B will use the\
    \ real increasing next hop towards F.  So a\n   packet forwarded to B on MRT-Blue\
    \ will get to F on path C-B-F.\n   Similarly, D will use the real decreasing next\
    \ hop towards F as its\n   MRT-Red next hop, a packet on MRT-Red will use path\
    \ C-D-F.\n"
- title: 5.7.4.  Generalizing for a Graph That Isn't 2-Connected
  contents:
  - "5.7.4.  Generalizing for a Graph That Isn't 2-Connected\n   If a graph isn't\
    \ 2-connected, then the basic approach given in\n   Section 5.7.3 needs some extensions\
    \ to determine the appropriate MRT\n   next hops to use for destinations outside\
    \ the computing router X's\n   blocks.  In order to find a pair of maximally redundant\
    \ trees in that\n   graph, we need to find a pair of RTs in each of the blocks\
    \ (the root\n   of these trees will be discussed later) and combine them.\n  \
    \ When computing the MRT next hops from a router X, there are three\n   basic\
    \ differences:\n   1.  Only nodes in a common block with X should be explored\
    \ in the\n       increasing-SPF and decreasing-SPF.\n   2.  Instead of using the\
    \ GADAG root, X's localroot should be used.\n       This has the following implications:\n\
    \       A.  The links from X's localroot should not be explored.\n       B.  If\
    \ a node is explored in the outgoing SPF so Y>>X, then X's\n           MRT-Red\
    \ next hops to reach Y uses X's MRT-Red next hops to\n           reach X's localroot\
    \ and if Z<<X, then X's MRT-Blue next hops\n           to reach Z uses X's MRT-Blue\
    \ next hops to reach X's\n           localroot.\n       C.  If a node W in a common\
    \ block with X was not reached in the\n           increasing-SPF or decreasing-SPF,\
    \ then W is unordered with\n           respect to X.  X's MRT-Blue next hops to\
    \ W are X's decreasing\n           (aka MRT-Red) next hops to X's localroot. \
    \ X's MRT-Red next\n           hops to W are X's increasing (aka MRT-Blue) next\
    \ hops to X's\n           localroot.\n   3.  For nodes in different blocks, the\
    \ next hops must be inherited\n       via the relevant cut-vertex.\n   These are\
    \ all captured in the detailed algorithm given in\n   Section 5.7.5.\n"
- title: 5.7.5.  Complete Algorithm to Compute MRT Next Hops
  contents:
  - "5.7.5.  Complete Algorithm to Compute MRT Next Hops\n   The complete algorithm\
    \ to compute MRT Next Hops for a particular\n   router X is given in Figure 23.\
    \  In addition to computing the MRT-\n   Blue next hops and MRT-Red next hops\
    \ used by X to reach each node Y,\n   the algorithm also stores an \"order_proxy\"\
    , which is the proper cut-\n   vertex to reach Y if it is outside the block, and\
    \ which is used later\n   in deciding whether the MRT-Blue or the MRT-Red can\
    \ provide an\n   acceptable alternate for a particular primary next hop.\n   In_Common_Block(x,\
    \ y)\n     if ( (x.block_id is y.block_id)\n          or (x is y.localroot) or\
    \ (y is x.localroot) )\n        return true\n     return false\n   Store_Results(y,\
    \ direction)\n      if direction is FORWARD\n         y.higher = true\n      \
    \   y.blue_next_hops = y.next_hops\n      if direction is REVERSE\n         y.lower\
    \ = true\n         y.red_next_hops = y.next_hops\n   SPF_No_Traverse_Block_Root(spf_root,\
    \ block_root, direction)\n      Initialize spf_heap to empty\n      Initialize\
    \ nodes' spf_metric to infinity and next_hops to empty\n      spf_root.spf_metric\
    \ = 0\n      insert(spf_heap, spf_root)\n      while (spf_heap is not empty)\n\
    \          min_node = remove_lowest(spf_heap)\n          Store_Results(min_node,\
    \ direction)\n          if ((min_node is spf_root) or (min_node is not block_root))\n\
    \             foreach interface intf of min_node\n                if ( ( ((direction\
    \ is FORWARD) and intf.OUTGOING) or\n                     ((direction is REVERSE)\
    \ and intf.INCOMING) )\n                     and In_Common_Block(spf_root, intf.remote_node)\
    \ )\n                   path_metric = min_node.spf_metric + intf.metric\n    \
    \               if path_metric < intf.remote_node.spf_metric\n               \
    \       intf.remote_node.spf_metric = path_metric\n                      if min_node\
    \ is spf_root\n                        intf.remote_node.next_hops = make_list(intf)\n\
    \                      else\n                        intf.remote_node.next_hops\
    \ = min_node.next_hops\n                      insert_or_update(spf_heap, intf.remote_node)\n\
    \                   else if path_metric == intf.remote_node.spf_metric\n     \
    \                 if min_node is spf_root\n                         add_to_list(intf.remote_node.next_hops,\
    \ intf)\n                      else\n                         add_list_to_list(intf.remote_node.next_hops,\n\
    \                                          min_node.next_hops)\n   SetEdge(y)\n\
    \     if y.blue_next_hops is empty and y.red_next_hops is empty\n        SetEdge(y.localroot)\n\
    \        y.blue_next_hops = y.localroot.blue_next_hops\n        y.red_next_hops\
    \ = y.localroot.red_next_hops\n        y.order_proxy = y.localroot.order_proxy\n\
    \   Compute_MRT_NextHops(x, gadag_root)\n      foreach node y\n        y.higher\
    \ = y.lower = false\n        clear y.red_next_hops and y.blue_next_hops\n    \
    \    y.order_proxy = y\n      SPF_No_Traverse_Block_Root(x, x.localroot, FORWARD)\n\
    \      SPF_No_Traverse_Block_Root(x, x.localroot, REVERSE)\n      // red and blue\
    \ next hops are stored to x.localroot as different\n      // paths are found via\
    \ the SPF and reverse-SPF.\n      // Similarly, any node whose localroot is x\
    \ will have its\n      // red_next_hops and blue_next_hops already set.\n    \
    \  // Handle nodes in the same block that aren't the localroot\n      foreach\
    \ node y\n        if (y.IN_MRT_ISLAND and (y is not x) and\n             (y.block_id\
    \ is x.block_id) )\n           if y.higher\n              y.red_next_hops = x.localroot.red_next_hops\n\
    \           else if y.lower\n              y.blue_next_hops = x.localroot.blue_next_hops\n\
    \           else\n              y.blue_next_hops = x.localroot.red_next_hops\n\
    \              y.red_next_hops = x.localroot.blue_next_hops\n      // Inherit\
    \ next hops and order_proxies to other components\n      if (x is not gadag_root)\
    \ and (x.localroot is not gadag_root)\n         gadag_root.blue_next_hops = x.localroot.blue_next_hops\n\
    \         gadag_root.red_next_hops = x.localroot.red_next_hops\n         gadag_root.order_proxy\
    \ = x.localroot\n      foreach node y\n         if (y is not gadag_root) and (y\
    \ is not x) and y.IN_MRT_ISLAND\n           SetEdge(y)\n   max_block_id = 0\n\
    \   Assign_Block_ID(gadag_root, max_block_id)\n   Compute_MRT_NextHops(x, gadag_root)\n\
    \          Figure 23: Complete Algorithm to Compute MRT Next Hops\n"
- title: 5.8.  Identify MRT Alternates
  contents:
  - "5.8.  Identify MRT Alternates\n   At this point, a computing router S knows its\
    \ MRT-Blue next hops and\n   MRT-Red next hops for each destination in the MRT\
    \ Island.  The\n   primary next hops along the SPT are also known.  It remains\
    \ to\n   determine for each primary next hop to a destination D, which MRT\n \
    \  avoids the primary next-hop node F.  This computation depends upon\n   data\
    \ set in Compute_MRT_NextHops such as each node y's\n   y.blue_next_hops, y.red_next_hops,\
    \ y.order_proxy, y.higher, y.lower,\n   and topo_orders.  Recall that any router\
    \ knows only which are the\n   nodes greater and lesser than itself, but it cannot\
    \ decide the\n   relation between any two given nodes easily; that is why we need\n\
    \   topological ordering.\n   For each primary next-hop node F to each destination\
    \ D, S can call\n   Select_Alternates(S, D, F, primary_intf) to determine whether\
    \ to use\n   the MRT-Blue or MRT-Red next hops as the alternate next hop(s) for\n\
    \   that primary next hop.  The algorithm is given in Figure 24 and\n   discussed\
    \ afterwards.\n  Select_Alternates_Internal(D, F, primary_intf,\n            \
    \                     D_lower, D_higher, D_topo_order):\n      if D_higher and\
    \ D_lower\n          if F.HIGHER and F.LOWER\n              if F.topo_order <\
    \ D_topo_order\n                  return USE_RED\n              else\n       \
    \           return USE_BLUE\n          if F.HIGHER\n              return USE_RED\n\
    \          if F.LOWER\n              return USE_BLUE\n          //F unordered\
    \ wrt S\n          return USE_RED_OR_BLUE\n      else if D_higher\n          if\
    \ F.HIGHER and F.LOWER\n              return USE_BLUE\n          if F.LOWER\n\
    \              return USE_BLUE\n          if F.HIGHER\n              if (F.topo_order\
    \ > D_topo_order)\n                  return USE_BLUE\n              if (F.topo_order\
    \ < D_topo_order)\n                  return USE_RED\n          //F unordered wrt\
    \ S\n          return USE_RED_OR_BLUE\n      else if D_lower\n          if F.HIGHER\
    \ and F.LOWER\n              return USE_RED\n          if F.HIGHER\n         \
    \     return USE_RED\n          if F.LOWER\n              if F.topo_order > D_topo_order\n\
    \                  return USE_BLUE\n              if F.topo_order < D_topo_order\n\
    \                  return USE_RED\n          //F unordered wrt S\n          return\
    \ USE_RED_OR_BLUE\n      else  //D is unordered wrt S\n          if F.HIGHER and\
    \ F.LOWER\n              if primary_intf.OUTGOING and primary_intf.INCOMING\n\
    \                  return USE_RED_OR_BLUE\n              if primary_intf.OUTGOING\n\
    \                  return USE_BLUE\n              if primary_intf.INCOMING\n \
    \                 return USE_RED\n              //primary_intf not in GADAG\n\
    \              return USE_RED\n          if F.LOWER\n              return USE_RED\n\
    \          if F.HIGHER\n              return USE_BLUE\n          //F unordered\
    \ wrt S\n          if F.topo_order > D_topo_order:\n              return USE_BLUE\n\
    \          else:\n              return USE_RED\n  Select_Alternates(D, F, primary_intf)\n\
    \      if not In_Common_Block(F, S)\n          return PRIM_NH_IN_DIFFERENT_BLOCK\n\
    \      if (D is F) or (D.order_proxy is F)\n          return PRIM_NH_IS_D_OR_OP_FOR_D\n\
    \      D_lower = D.order_proxy.LOWER\n      D_higher = D.order_proxy.HIGHER\n\
    \      D_topo_order = D.order_proxy.topo_order\n      return Select_Alternates_Internal(D,\
    \ F, primary_intf,\n                                        D_lower, D_higher,\
    \ D_topo_order)\n      Figure 24: Select_Alternates() and Select_Alternates_Internal()\n\
    \   It is useful to first handle the case where F is also D, or F is the\n   order\
    \ proxy for D.  In this case, only link protection is possible.\n   The MRT that\
    \ doesn't use the failed primary next hop is used.  If\n   both MRTs use the primary\
    \ next hop, then the primary next hop must be\n   a cut-link, so either MRT could\
    \ be used but the set of MRT next hops\n   must be pruned to avoid the failed\
    \ primary next-hop interface.  To\n   indicate this case, Select_Alternates returns\n\
    \   PRIM_NH_IS_D_OR_OP_FOR_D.  Explicit pseudocode to handle the three\n   sub-cases\
    \ above is not provided.\n   The logic behind Select_Alternates_Internal() is\
    \ described in\n   Figure 25.  As an example, consider the first case described\
    \ in the\n   table, where the D>>S and D<<S.  If this is true, then either S or\
    \ D\n   must be the block root, R.  If F>>S and F<<S, then S is the block\n  \
    \ root.  So the blue path from S to D is the increasing path to D, and\n   the\
    \ red path S to D is the decreasing path to D.  If the\n   F.topo_order>D.topo_order,\
    \ then either F is ordered higher than D or\n   F is unordered with respect to\
    \ D.  Therefore, F is either on a\n   decreasing path from S to D, or it is on\
    \ neither an increasing nor a\n   decreasing path from S to D.  In either case,\
    \ it is safe to take an\n   increasing path from S to D to avoid F.  We know that\
    \ when S is R,\n   the increasing path is the blue path, so it is safe to use\
    \ the blue\n   path to avoid F.\n   If instead F.topo_order<D.topo_order, then\
    \ either F is ordered lower\n   than D, or F is unordered with respect to D. \
    \ Therefore, F is either\n   on an increasing path from S to D, or it is on neither\
    \ an increasing\n   nor a decreasing path from S to D.  In either case, it is\
    \ safe to\n   take a decreasing path from S to D to avoid F.  We know that when\
    \ S\n   is R, the decreasing path is the red path, so it is safe to use the\n\
    \   red path to avoid F.\n   If F>>S or F<<S (but not both), then D is the block\
    \ root.  We then\n   know that the blue path from S to D is the increasing path\
    \ to R, and\n   the red path is the decreasing path to R.  When F>>S, we deduce\
    \ that\n   F is on an increasing path from S to R.  So in order to avoid F, we\n\
    \   use a decreasing path from S to R, which is the red path.  Instead,\n   when\
    \ F<<S, we deduce that F is on a decreasing path from S to R.  So\n   in order\
    \ to avoid F, we use an increasing path from S to R, which is\n   the blue path.\n\
    \   All possible cases are systematically described in the same manner in\n  \
    \ the rest of the table.\n"
- title: +------+------------+------+------------------------------+------------+
  contents:
  - '+------+------------+------+------------------------------+------------+

    '
- title: '| D    | MRT blue   | F    | additional      | F          | Alternate  |'
  contents:
  - '| D    | MRT blue   | F    | additional      | F          | Alternate  |

    '
- title: '| wrt  | and red    | wrt  | criteria        | wrt        |            |'
  contents:
  - '| wrt  | and red    | wrt  | criteria        | wrt        |            |

    '
- title: '| S    | path       | S    |                 | MRT        |            |'
  contents:
  - '| S    | path       | S    |                 | MRT        |            |

    '
- title: '|      | properties |      |                 | (deduced)  |            |'
  contents:
  - '|      | properties |      |                 | (deduced)  |            |

    '
- title: +------+------------+------+-----------------+------------+------------+
  contents:
  - '+------+------------+------+-----------------+------------+------------+

    '
- title: '| D>>S | Blue path: | F>>S | additional      | F on an    | Use Red    |'
  contents:
  - '| D>>S | Blue path: | F>>S | additional      | F on an    | Use Red    |

    '
- title: '| and  | Increasing | only | criteria        | increasing | to avoid   |'
  contents:
  - '| and  | Increasing | only | criteria        | increasing | to avoid   |

    '
- title: '| D<<S,| path to R. |      | not needed      | path from  | F          |'
  contents:
  - '| D<<S,| path to R. |      | not needed      | path from  | F          |

    '
- title: '| D is | Red path:  |      |                 | S to R     |            |'
  contents:
  - '| D is | Red path:  |      |                 | S to R     |            |

    '
- title: '| R,   | Decreasing +------+-----------------+------------+------------+'
  contents:
  - '| R,   | Decreasing +------+-----------------+------------+------------+

    '
- title: '|      | path to R. | F<<S | additional      | F on a     | Use Blue   |'
  contents:
  - '|      | path to R. | F<<S | additional      | F on a     | Use Blue   |

    '
- title: '|      |            | only | criteria        | decreasing | to avoid   |'
  contents:
  - '|      |            | only | criteria        | decreasing | to avoid   |

    '
- title: '|      |            |      | not needed      | path from  | F          |'
  contents:
  - '|      |            |      | not needed      | path from  | F          |

    '
- title: '| or   |            |      |                 | S to R     |            |'
  contents:
  - '| or   |            |      |                 | S to R     |            |

    '
- title: '|      |            +------+-----------------+------------+------------+'
  contents:
  - '|      |            +------+-----------------+------------+------------+

    '
- title: '|      |            | F>>S | topo(F)>topo(D) | F on a     | Use Blue   |'
  contents:
  - '|      |            | F>>S | topo(F)>topo(D) | F on a     | Use Blue   |

    '
- title: '| S is | Blue path: | and  | implies that    | decreasing | to avoid   |'
  contents:
  - '| S is | Blue path: | and  | implies that    | decreasing | to avoid   |

    '
- title: '| R    | Increasing | F<<S,| F>>D or F??D    | path from  | F          |'
  contents:
  - '| R    | Increasing | F<<S,| F>>D or F??D    | path from  | F          |

    '
- title: '|      | path to D. |      |                 | S to D or  |            |'
  contents:
  - '|      | path to D. |      |                 | S to D or  |            |

    '
- title: '|      | Red path:  |      |                 | neither    |            |'
  contents:
  - '|      | Red path:  |      |                 | neither    |            |

    '
- title: '|      | Decreasing |      +-----------------+------------+------------+'
  contents:
  - '|      | Decreasing |      +-----------------+------------+------------+

    '
- title: '|      | path to D. |      | topo(F)<topo(D) | F on an    | Use Red    |'
  contents:
  - '|      | path to D. |      | topo(F)<topo(D) | F on an    | Use Red    |

    '
- title: '|      |            |      | implies that    | increasing | to avoid   |'
  contents:
  - '|      |            |      | implies that    | increasing | to avoid   |

    '
- title: '|      |            |      | F<<D or F??D    | path from  | F          |'
  contents:
  - '|      |            |      | F<<D or F??D    | path from  | F          |

    '
- title: '|      |            |      |                 | S to D or  |            |'
  contents:
  - '|      |            |      |                 | S to D or  |            |

    '
- title: '|      |            |      |                 | neither    |            |'
  contents:
  - '|      |            |      |                 | neither    |            |

    '
- title: '|      |            +------+-----------------+------------+------------+'
  contents:
  - '|      |            +------+-----------------+------------+------------+

    '
- title: '|      |            | F??S | Can only occur  | F is on    | Use Red    |'
  contents:
  - '|      |            | F??S | Can only occur  | F is on    | Use Red    |

    '
- title: '|      |            |      | when link       | neither    | or Blue    |'
  contents:
  - '|      |            |      | when link       | neither    | or Blue    |

    '
- title: '|      |            |      | between         | increasing | to avoid   |'
  contents:
  - '|      |            |      | between         | increasing | to avoid   |

    '
- title: '|      |            |      | F and S         | nor decr.  | F          |'
  contents:
  - '|      |            |      | F and S         | nor decr.  | F          |

    '
- title: '|      |            |      | is marked       | path from  |            |'
  contents:
  - '|      |            |      | is marked       | path from  |            |

    '
- title: '|      |            |      | MRT_INELIGIBLE  | S to D or R|            |'
  contents:
  - '|      |            |      | MRT_INELIGIBLE  | S to D or R|            |

    '
- title: +------+------------+------+-----------------+------------+------------+
  contents:
  - '+------+------------+------+-----------------+------------+------------+

    '
- title: '| D>>S | Blue path: | F<<S | additional      | F on       | Use Blue   |'
  contents:
  - '| D>>S | Blue path: | F<<S | additional      | F on       | Use Blue   |

    '
- title: '| only | Increasing | only | criteria        | decreasing | to avoid   |'
  contents:
  - '| only | Increasing | only | criteria        | decreasing | to avoid   |

    '
- title: '|      | shortest   |      | not needed      | path from  | F          |'
  contents:
  - '|      | shortest   |      | not needed      | path from  | F          |

    '
- title: '|      | path from  |      |                 | S to R     |            |'
  contents:
  - '|      | path from  |      |                 | S to R     |            |

    '
- title: '|      | S to D.    +------+-----------------+------------+------------+'
  contents:
  - '|      | S to D.    +------+-----------------+------------+------------+

    '
- title: '|      | Red path:  | F>>S | topo(F)>topo(D) | F on       | Use Blue   |'
  contents:
  - '|      | Red path:  | F>>S | topo(F)>topo(D) | F on       | Use Blue   |

    '
- title: '|      | Decreasing | only | implies that    | decreasing | to avoid   |'
  contents:
  - '|      | Decreasing | only | implies that    | decreasing | to avoid   |

    '
- title: '|      | shortest   |      | F>>D or F??D    | path from  | F          |'
  contents:
  - '|      | shortest   |      | F>>D or F??D    | path from  | F          |

    '
- title: '|      | path from  |      |                 | R to D     |            |'
  contents:
  - '|      | path from  |      |                 | R to D     |            |

    '
- title: '|      | S to R,    |      |                 | or         |            |'
  contents:
  - '|      | S to R,    |      |                 | or         |            |

    '
- title: '|      | then       |      |                 | neither    |            |'
  contents:
  - '|      | then       |      |                 | neither    |            |

    '
- title: '|      | decreasing |      +-----------------+------------+------------+'
  contents:
  - '|      | decreasing |      +-----------------+------------+------------+

    '
- title: '|      | shortest   |      | topo(F)<topo(D) | F on       | Use Red    |'
  contents:
  - '|      | shortest   |      | topo(F)<topo(D) | F on       | Use Red    |

    '
- title: '|      | path from  |      | implies that    | increasing | to avoid   |'
  contents:
  - '|      | path from  |      | implies that    | increasing | to avoid   |

    '
- title: '|      | R to D.    |      | F<<D or F??D    | path from  | F          |'
  contents:
  - '|      | R to D.    |      | F<<D or F??D    | path from  | F          |

    '
- title: '|      |            |      |                 | S to D     |            |'
  contents:
  - '|      |            |      |                 | S to D     |            |

    '
- title: '|      |            |      |                 | or         |            |'
  contents:
  - '|      |            |      |                 | or         |            |

    '
- title: '|      |            |      |                 | neither    |            |'
  contents:
  - '|      |            |      |                 | neither    |            |

    '
- title: '|      |            +------+-----------------+------------+------------+'
  contents:
  - '|      |            +------+-----------------+------------+------------+

    '
- title: '|      |            | F>>S | additional      | F on Red   | Use Blue   |'
  contents:
  - '|      |            | F>>S | additional      | F on Red   | Use Blue   |

    '
- title: '|      |            | and  | criteria        |            | to avoid   |'
  contents:
  - '|      |            | and  | criteria        |            | to avoid   |

    '
- title: '|      |            | F<<S,| not needed      |            | F          |'
  contents:
  - '|      |            | F<<S,| not needed      |            | F          |

    '
- title: '|      |            | F is |                 |            |            |'
  contents:
  - '|      |            | F is |                 |            |            |

    '
- title: '|      |            | R    |                 |            |            |'
  contents:
  - '|      |            | R    |                 |            |            |

    '
- title: '|      |            +------+-----------------+------------+------------+'
  contents:
  - '|      |            +------+-----------------+------------+------------+

    '
- title: '|      |            | F??S | Can only occur  | F is on    | Use Red    |'
  contents:
  - '|      |            | F??S | Can only occur  | F is on    | Use Red    |

    '
- title: '|      |            |      | when link       | neither    | or Blue    |'
  contents:
  - '|      |            |      | when link       | neither    | or Blue    |

    '
- title: '|      |            |      | between         | increasing | to avoid   |'
  contents:
  - '|      |            |      | between         | increasing | to avoid   |

    '
- title: '|      |            |      | F and S         | nor decr.  | F          |'
  contents:
  - '|      |            |      | F and S         | nor decr.  | F          |

    '
- title: '|      |            |      | is marked       | path from  |            |'
  contents:
  - '|      |            |      | is marked       | path from  |            |

    '
- title: '|      |            |      | MRT_INELIGIBLE  | S to D or R|            |'
  contents:
  - '|      |            |      | MRT_INELIGIBLE  | S to D or R|            |

    '
- title: +------+------------+------+-----------------+------------+------------+
  contents:
  - '+------+------------+------+-----------------+------------+------------+

    '
- title: '| D<<S | Blue path: | F>>S | additional      | F on       | Use Red    |'
  contents:
  - '| D<<S | Blue path: | F>>S | additional      | F on       | Use Red    |

    '
- title: '| only | Increasing | only | criteria        | increasing | to avoid   |'
  contents:
  - '| only | Increasing | only | criteria        | increasing | to avoid   |

    '
- title: '|      | shortest   |      | not needed      | path from  | F          |'
  contents:
  - '|      | shortest   |      | not needed      | path from  | F          |

    '
- title: '|      | path from  |      |                 | S to R     |            |'
  contents:
  - '|      | path from  |      |                 | S to R     |            |

    '
- title: '|      | S to R,    +------+-----------------+------------+------------+'
  contents:
  - '|      | S to R,    +------+-----------------+------------+------------+

    '
- title: '|      | then       | F<<S | topo(F)>topo(D) | F on       | Use Blue   |'
  contents:
  - '|      | then       | F<<S | topo(F)>topo(D) | F on       | Use Blue   |

    '
- title: '|      | increasing | only | implies that    | decreasing | to avoid   |'
  contents:
  - '|      | increasing | only | implies that    | decreasing | to avoid   |

    '
- title: '|      | shortest   |      | F>>D or F??D    | path from  | F          |'
  contents:
  - '|      | shortest   |      | F>>D or F??D    | path from  | F          |

    '
- title: '|      | path from  |      |                 | R to D     |            |'
  contents:
  - '|      | path from  |      |                 | R to D     |            |

    '
- title: '|      | R to D.    |      |                 | or         |            |'
  contents:
  - '|      | R to D.    |      |                 | or         |            |

    '
- title: '|      | Red path:  |      |                 | neither    |            |'
  contents:
  - '|      | Red path:  |      |                 | neither    |            |

    '
- title: '|      | Decreasing |      +-----------------+------------+------------+'
  contents:
  - '|      | Decreasing |      +-----------------+------------+------------+

    '
- title: '|      | shortest   |      | topo(F)<topo(D) | F on       | Use Red    |'
  contents:
  - '|      | shortest   |      | topo(F)<topo(D) | F on       | Use Red    |

    '
- title: '|      | path from  |      | implies that    | increasing | to avoid   |'
  contents:
  - '|      | path from  |      | implies that    | increasing | to avoid   |

    '
- title: '|      | S to D.    |      | F<<D or F??D    | path from  | F          |'
  contents:
  - '|      | S to D.    |      | F<<D or F??D    | path from  | F          |

    '
- title: '|      |            |      |                 | S to D     |            |'
  contents:
  - '|      |            |      |                 | S to D     |            |

    '
- title: '|      |            |      |                 | or         |            |'
  contents:
  - '|      |            |      |                 | or         |            |

    '
- title: '|      |            |      |                 | neither    |            |'
  contents:
  - '|      |            |      |                 | neither    |            |

    '
- title: '|      |            +------+-----------------+------------+------------+'
  contents:
  - '|      |            +------+-----------------+------------+------------+

    '
- title: '|      |            | F>>S | additional      | F on Blue  | Use Red    |'
  contents:
  - '|      |            | F>>S | additional      | F on Blue  | Use Red    |

    '
- title: '|      |            | and  | criteria        |            | to avoid   |'
  contents:
  - '|      |            | and  | criteria        |            | to avoid   |

    '
- title: '|      |            | F<<S,| not             |            | F          |'
  contents:
  - '|      |            | F<<S,| not             |            | F          |

    '
- title: '|      |            | F is | needed          |            |            |'
  contents:
  - '|      |            | F is | needed          |            |            |

    '
- title: '|      |            | R    |                 |            |            |'
  contents:
  - '|      |            | R    |                 |            |            |

    '
- title: '|      |            +------+-----------------+------------+------------+'
  contents:
  - '|      |            +------+-----------------+------------+------------+

    '
- title: '|      |            | F??S | Can only occur  | F is on    | Use Red    |'
  contents:
  - '|      |            | F??S | Can only occur  | F is on    | Use Red    |

    '
- title: '|      |            |      | when link       | neither    | or Blue    |'
  contents:
  - '|      |            |      | when link       | neither    | or Blue    |

    '
- title: '|      |            |      | between         | increasing | to avoid   |'
  contents:
  - '|      |            |      | between         | increasing | to avoid   |

    '
- title: '|      |            |      | F and S         | nor decr.  | F          |'
  contents:
  - '|      |            |      | F and S         | nor decr.  | F          |

    '
- title: '|      |            |      | is marked       | path from  |            |'
  contents:
  - '|      |            |      | is marked       | path from  |            |

    '
- title: '|      |            |      | MRT_INELIGIBLE  | S to D or R|            |'
  contents:
  - '|      |            |      | MRT_INELIGIBLE  | S to D or R|            |

    '
- title: +------+------------+------+-----------------+------------+------------+
  contents:
  - '+------+------------+------+-----------------+------------+------------+

    '
- title: '| D??S | Blue path: | F<<S | additional      | F on a     | Use Red    |'
  contents:
  - '| D??S | Blue path: | F<<S | additional      | F on a     | Use Red    |

    '
- title: '|      | Decr. from | only | criteria        | decreasing | to avoid   |'
  contents:
  - '|      | Decr. from | only | criteria        | decreasing | to avoid   |

    '
- title: '|      | S to first |      | not needed      | path from  | F          |'
  contents:
  - '|      | S to first |      | not needed      | path from  | F          |

    '
- title: '|      | node K<<D, |      |                 | S to K.    |            |'
  contents:
  - '|      | node K<<D, |      |                 | S to K.    |            |

    '
- title: '|      | then incr. +------+-----------------+------------+------------+'
  contents:
  - '|      | then incr. +------+-----------------+------------+------------+

    '
- title: '|      | to D.      | F>>S | additional      | F on an    | Use Blue   |'
  contents:
  - '|      | to D.      | F>>S | additional      | F on an    | Use Blue   |

    '
- title: '|      | Red path:  | only | criteria        | increasing | to avoid   |'
  contents:
  - '|      | Red path:  | only | criteria        | increasing | to avoid   |

    '
- title: '|      | Incr. from |      | not needed      | path from  | F          |'
  contents:
  - '|      | Incr. from |      | not needed      | path from  | F          |

    '
- title: '|      | S to first |      |                 | S to L     |            |'
  contents:
  - '|      | S to first |      |                 | S to L     |            |

    '
- title: '|      | node L>>D, |      |                 |            |            |'
  contents:
  - '|      | node L>>D, |      |                 |            |            |

    '
- title: '|      | then decr. |      |                 |            |            |'
  contents:
  - '|      | then decr. |      |                 |            |            |

    '
- title: '|      |            +------+-----------------+------------+------------+'
  contents:
  - '|      |            +------+-----------------+------------+------------+

    '
- title: '|      |            | F??S | topo(F)>topo(D) | F on decr. | Use Blue   |'
  contents:
  - '|      |            | F??S | topo(F)>topo(D) | F on decr. | Use Blue   |

    '
- title: '|      |            |      | implies that    | path from  | to avoid   |'
  contents:
  - '|      |            |      | implies that    | path from  | to avoid   |

    '
- title: '|      |            |      | F>>D or F??D    | L to D or  | F          |'
  contents:
  - '|      |            |      | F>>D or F??D    | L to D or  | F          |

    '
- title: '|      |            |      |                 | neither    |            |'
  contents:
  - '|      |            |      |                 | neither    |            |

    '
- title: '|      |            |      +-----------------+------------+------------+'
  contents:
  - '|      |            |      +-----------------+------------+------------+

    '
- title: '|      |            |      | topo(F)<topo(D) | F on incr. | Use Red    |'
  contents:
  - '|      |            |      | topo(F)<topo(D) | F on incr. | Use Red    |

    '
- title: '|      |            |      | implies that    | path from  | to avoid   |'
  contents:
  - '|      |            |      | implies that    | path from  | to avoid   |

    '
- title: '|      |            |      | F<<D or F??D    | K to D or  | F          |'
  contents:
  - '|      |            |      | F<<D or F??D    | K to D or  | F          |

    '
- title: '|      |            |      |                 | neither    |            |'
  contents:
  - '|      |            |      |                 | neither    |            |

    '
- title: '|      |            +------+-----------------+------------+------------+'
  contents:
  - '|      |            +------+-----------------+------------+------------+

    '
- title: '|      |            | F>>S | GADAG link      | F on an    | Use Blue   |'
  contents:
  - '|      |            | F>>S | GADAG link      | F on an    | Use Blue   |

    '
- title: '|      |            | and  | direction       | incr. path | to avoid   |'
  contents:
  - '|      |            | and  | direction       | incr. path | to avoid   |

    '
- title: '|      |            | F<<S,| S->F            | from S     | F          |'
  contents:
  - '|      |            | F<<S,| S->F            | from S     | F          |

    '
- title: '|      |            | F is +-----------------+------------+------------+'
  contents:
  - '|      |            | F is +-----------------+------------+------------+

    '
- title: '|      |            | R    | GADAG link      | F on a     | Use Red    |'
  contents:
  - '|      |            | R    | GADAG link      | F on a     | Use Red    |

    '
- title: '|      |            |      | direction       | decr. path | to avoid   |'
  contents:
  - '|      |            |      | direction       | decr. path | to avoid   |

    '
- title: '|      |            |      | S<-F            | from S     | F          |'
  contents:
  - '|      |            |      | S<-F            | from S     | F          |

    '
- title: '|      |            |      +-----------------+------------+------------+'
  contents:
  - '|      |            |      +-----------------+------------+------------+

    '
- title: '|      |            |      | GADAG link      | Either F is the order   |'
  contents:
  - '|      |            |      | GADAG link      | Either F is the order   |

    '
- title: '|      |            |      | direction       | proxy for D (case       |'
  contents:
  - '|      |            |      | direction       | proxy for D (case       |

    '
- title: '|      |            |      | S<-->F          | already handled) or D   |'
  contents:
  - '|      |            |      | S<-->F          | already handled) or D   |

    '
- title: '|      |            |      |                 | is in a different block |'
  contents:
  - '|      |            |      |                 | is in a different block |

    '
- title: '|      |            |      |                 | from F, in which case   |'
  contents:
  - '|      |            |      |                 | from F, in which case   |

    '
- title: '|      |            |      |                 | Red or Blue avoids F    |'
  contents:
  - '|      |            |      |                 | Red or Blue avoids F    |

    '
- title: '|      |            |      +-----------------+-------------------------+'
  contents:
  - '|      |            |      +-----------------+-------------------------+

    '
- title: '|      |            |      | S-F link not    | Relies on special       |'
  contents:
  - '|      |            |      | S-F link not    | Relies on special       |

    '
- title: '|      |            |      | in GADAG,       | construction of GADAG   |'
  contents:
  - '|      |            |      | in GADAG,       | construction of GADAG   |

    '
- title: '|      |            |      | only when       | to demonstrate that     |'
  contents:
  - '|      |            |      | only when       | to demonstrate that     |

    '
- title: '|      |            |      | S-F link is     | using Red avoids F      |'
  contents:
  - '|      |            |      | S-F link is     | using Red avoids F      |

    '
- title: '|      |            |      | MRT_INELIGIBLE  | (see text)              |'
  contents:
  - '|      |            |      | MRT_INELIGIBLE  | (see text)              |

    '
- title: +------+------------+------+-----------------+-------------------------+
  contents:
  - "+------+------------+------+-----------------+-------------------------+\n  \
    \  Determining MRT next hops and alternates based on the partial order\n     \
    \    and topological sort relationships between the source(S),\n     destination(D),\
    \ primary next hop(F), and block root(R).  topo(N)\n   indicates the topological\
    \ sort value of node N.  X??Y indicates that\n    node X is unordered with respect\
    \ to node Y.  It is assumed that the\n    case where F is D, or where F is the\
    \ order proxy for D, has already\n                               been handled.\n\
    \            Figure 25: Determining MRT Next Hops and Alternates\n   The last\
    \ case in Figure 25 requires additional explanation.  The fact\n   that the red\
    \ path from S to D in this case avoids F relies on a\n   special property of the\
    \ GADAGs that we have constructed in this\n   algorithm, a property not shared\
    \ by all GADAGs in general.  When D is\n   unordered with respect to S, and F\
    \ is the localroot for S, it can\n   occur that the link between S and F is not\
    \ in the GADAG only when\n   that link has been marked MRT_INELIGIBLE.  For an\
    \ arbitrary GADAG, S\n   doesn't have enough information based on the computed\
    \ order\n   relationships to determine if the red path or blue path will hit F\n\
    \   (which is also the localroot) before hitting K or L, and making it\n   safely\
    \ to D.  However, the GADAGs that we construct using the\n   algorithm in this\
    \ document are not arbitrary GADAGs.  They have the\n   additional property that\
    \ incoming links to a localroot come from only\n   one other node in the same\
    \ block.  This is a result of the method of\n   construction.  This additional\
    \ property guarantees that the red path\n   from S to D will never pass through\
    \ the localroot of S.  (That would\n   require the localroot to play the role\
    \ of L, the first node in the\n   path ordered higher than D, which would in turn\
    \ require the localroot\n   to have two incoming links in the GADAG, which cannot\
    \ happen.)\n   Therefore, it is safe to use the red path to avoid F with these\n\
    \   specially constructed GADAGs.\n   As an example of how Select_Alternates_Internal()\
    \ operates, consider\n   the ADAG depicted in Figure 26 and first suppose that\
    \ G is the\n   source, D is the destination, and H is the failed next hop.  Since\n\
    \   D>>G, we need to compare H.topo_order and D.topo_order.  Since\n   D.topo_order>H.topo_order,\
    \ D must be either higher than H or\n   unordered with respect to H, so we should\
    \ select the decreasing path\n   towards the root.  If, however, the destination\
    \ were instead J, we\n   must find that H.topo_order>J.topo_order, so we must\
    \ choose the\n   increasing Blue next hop to J, which is I.  In the case, when\
    \ instead\n   the destination is C, we find that we need to first decrease to\
    \ avoid\n   using H, so the Blue, first decreasing then increasing, path is\n\
    \   selected.\n                             [E]<-[D]<-[H]<-[J]\n             \
    \                 |    ^    ^    ^\n                              V    |    |\
    \    |\n                             [R]  [C]  [G]->[I]\n                    \
    \          |    ^    ^    ^\n                              V    |    |    |\n\
    \                             [A]->[B]->[F]---|\n            Figure 26: ADAG Rooted\
    \ at R for a 2-Connected Graph\n"
- title: 5.9.  Named Proxy-Nodes
  contents:
  - "5.9.  Named Proxy-Nodes\n   As discussed in Section 11.2 of [RFC7812], it is\
    \ necessary to find\n   MRT-Blue and MRT-Red next hops and MRT-FRR alternates\
    \ for named\n   proxy-nodes.  An example use case is for a router that is not\
    \ part of\n   that local MRT Island, when there is only partial MRT support in\
    \ the\n   domain.\n"
- title: 5.9.1.  Determining Proxy-Node Attachment Routers
  contents:
  - "5.9.1.  Determining Proxy-Node Attachment Routers\n   Section 11.2 of [RFC7812]\
    \ discusses general considerations for\n   determining the two proxy-node attachment\
    \ routers for a given proxy-\n   node, corresponding to a prefix.  A router in\
    \ the MRT Island that\n   advertises the prefix is a candidate for being a proxy-node\n\
    \   attachment router, with the associated named-proxy-cost equal to the\n   advertised\
    \ cost to the prefix.\n   An Island Border Router (IBR) is a router in the MRT\
    \ Island that is\n   connected to an Island Neighbor (IN), which is a router not\
    \ in the\n   MRT Island but in the same area/level.  An (IBR,IN) pair is a\n \
    \  candidate for being a proxy-node attachment router, if the shortest\n   path\
    \ from the IN to the prefix does not enter the MRT Island.  A\n   method for identifying\
    \ such Loop-Free Island Neighbors (LFINs) is\n   given below.  The named-proxy-cost\
    \ assigned to each (IBR, IN) pair is\n   cost(IBR, IN) + D_opt(IN, prefix).\n\
    \   From the set of prefix-advertising routers and the set of IBRs with\n   at\
    \ least one LFIN, the two routers with the lowest named-proxy-cost\n   are selected.\
    \  Ties are broken based upon the lowest Router ID.  For\n   ease of discussion,\
    \ the two selected routers will be referred to as\n   proxy-node attachment routers.\n"
- title: 5.9.2.  Computing If an Island Neighbor (IN) Is Loop-Free
  contents:
  - "5.9.2.  Computing If an Island Neighbor (IN) Is Loop-Free\n   As discussed above,\
    \ the IN needs to be loop-free with respect to the\n   whole MRT Island for the\
    \ destination.  This can be accomplished by\n   running the usual SPF algorithm\
    \ while keeping track of which shortest\n   paths have passed through the MRT\
    \ island.  Pseudocode for this is\n   shown in Figure 27.  The Island_Marking_SPF()\
    \ is run for each IN that\n   needs to be evaluated for the loop-free condition,\
    \ with the IN as the\n   spf_root.  Whether or not an IN is loop-free with respect\
    \ to the MRT\n   island can then be determined by evaluating node.PATH_HITS_ISLAND\
    \ for\n   each destination of interest.\n    Island_Marking_SPF(spf_root)\n  \
    \      Initialize spf_heap to empty\n        Initialize nodes' spf_metric to infinity\
    \ and next_hops to empty\n            and PATH_HITS_ISLAND to false\n        spf_root.spf_metric\
    \ = 0\n        insert(spf_heap, spf_root)\n        while (spf_heap is not empty)\n\
    \            min_node = remove_lowest(spf_heap)\n            foreach interface\
    \ intf of min_node\n                path_metric = min_node.spf_metric + intf.metric\n\
    \                if path_metric < intf.remote_node.spf_metric\n              \
    \      intf.remote_node.spf_metric = path_metric\n                    if min_node\
    \ is spf_root\n                        intf.remote_node.next_hops = make_list(intf)\n\
    \                    else\n                        intf.remote_node.next_hops\
    \ = min_node.next_hops\n                    if intf.remote_node.IN_MRT_ISLAND\n\
    \                        intf.remote_node.PATH_HITS_ISLAND = true\n          \
    \          else\n                        intf.remote_node.PATH_HITS_ISLAND =\n\
    \                            min_node.PATH_HITS_ISLAND\n                    insert_or_update(spf_heap,\
    \ intf.remote_node)\n                else if path_metric == intf.remote_node.spf_metric\n\
    \                    if min_node is spf_root\n                        add_to_list(intf.remote_node.next_hops,\
    \ intf)\n                    else\n                        add_list_to_list(intf.remote_node.next_hops,\n\
    \                                         min_node.next_hops)\n              \
    \      if intf.remote_node.IN_MRT_ISLAND\n                        intf.remote_node.PATH_HITS_ISLAND\
    \ = true\n                    else\n                        intf.remote_node.PATH_HITS_ISLAND\
    \ =\n                            min_node.PATH_HITS_ISLAND\n   Figure 27: Island_Marking_SPF()\
    \ for Determining If an Island Neighbor\n                               Is Loop-Free\n\
    \   It is also possible that a given prefix is originated by a\n   combination\
    \ of non-island routers and island routers.  The results of\n   the Island_Marking_SPF()\
    \ computation can be used to determine if the\n   shortest path from an IN to\
    \ reach that prefix hits the MRT Island.\n   The shortest path for the IN to reach\
    \ prefix P is determined by the\n   total cost to reach prefix P, which is the\
    \ sum of the cost for the IN\n   to reach a prefix-advertising node and the cost\
    \ with which that node\n   advertises the prefix.  The path with the minimum total\
    \ cost to\n   prefix P is chosen.  If the prefix-advertising node for that minimum\n\
    \   total cost path has PATH_HITS_ISLAND set to True, then the IN is not\n   loop-free\
    \ with respect to the MRT Island for reaching prefix P.  If\n   there are multiple\
    \ minimum total cost paths to reach prefix P, then\n   all of the prefix-advertising\
    \ routers involved in the minimum total\n   cost paths MUST have PATH_HITS_ISLAND\
    \ set to False for the IN to be\n   considered loop-free to reach P.\n   Note\
    \ that there are other computations that could be used to\n   determine if paths\
    \ from a given IN _might_ pass through the MRT\n   Island for a given prefix or\
    \ destination.  For example, a previous\n   draft version of this document specified\
    \ running the SPF algorithm on\n   modified topology that treats the MRT Island\
    \ as a single node (with\n   intra-island links set to zero cost) in order to\
    \ provide input to\n   computations to determine if the path from IN to non-island\n\
    \   destination hits the MRT Island in this modified topology.  This\n   computation\
    \ is enough to guarantee that a path will not hit the MRT\n   Island in the original\
    \ topology.  However, it is possible that a path\n   that is disqualified for\
    \ hitting the MRT Island in the modified\n   topology will not actually hit the\
    \ MRT Island in the original\n   topology.  The algorithm described in Island_Marking_SPF()\
    \ above does\n   not modify the original topology, and will only disqualify a\
    \ path if\n   the actual path does in fact hit the MRT Island.\n   Since all routers\
    \ need to come to the same conclusion about which\n   routers qualify as LFINs,\
    \ this specification requires that all\n   routers computing LFINs MUST use an\
    \ algorithm whose result is\n   identical to that of the Island_Marking_SPF()\
    \ in Figure 27.\n"
- title: 5.9.3.  Computing MRT Next Hops for Proxy-Nodes
  contents:
  - "5.9.3.  Computing MRT Next Hops for Proxy-Nodes\n   Determining the MRT next\
    \ hops for a proxy-node in the degenerate case\n   where the proxy-node is attached\
    \ to only one node in the GADAG is\n   trivial, as all needed information can\
    \ be derived from that proxy-\n   node attachment router.  If there are multiple\
    \ interfaces connecting\n   the proxy-node to the single proxy-node attachment\
    \ router, then some\n   can be assigned to MRT-Red and others to MRT_Blue.\n \
    \  Now, consider the proxy-node P that is attached to two proxy-node\n   attachment\
    \ routers.  The pseudocode for Select_Proxy_Node_NHs(P,S) in\n   Figure 28 specifies\
    \ how a computing-router S MUST compute the MRT red\n   and blue next hops to\
    \ reach proxy-node P.  The proxy-node attachment\n   router with the lower value\
    \ of mrt_node_id (as defined in Figure 15)\n   is assigned to X, and the other\
    \ proxy-node attachment router is\n   assigned to Y.  We will be using the relative\
    \ order of X,Y, and S in\n   the partial order defined by the GADAG to determine\
    \ the MRT red and\n   blue next hops to reach P, so we also define A and B as\
    \ the order\n   proxies for X and Y, respectively, with respect to S.  The order\n\
    \   proxies for all nodes with respect to S were already computed in\n   Compute_MRT_NextHops().\n\
    \ def Select_Proxy_Node_NHs(P,S):\n     if P.pnar1.node.node_id < P.pnar2.node.node_id:\n\
    \         X = P.pnar1.node\n         Y = P.pnar2.node\n     else:\n         X\
    \ = P.pnar2.node\n         Y = P.pnar1.node\n     P.pnar_X = X\n     P.pnar_Y\
    \ = Y\n     A = X.order_proxy\n     B = Y.order_proxy\n     if (A is S.localroot\n\
    \         and B is S.localroot):\n         // case 1.0\n         Copy_List_Items(P.blue_next_hops,\
    \ X.blue_next_hops)\n         Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n\
    \         return\n     if (A is S.localroot\n         and B is not S.localroot):\n\
    \         // case 2.0\n         if B.LOWER:\n             // case 2.1\n      \
    \       Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n             Copy_List_Items(P.red_next_hops,\
    \ Y.red_next_hops)\n             return\n         if B.HIGHER:\n             //\
    \ case 2.2\n             Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n\
    \             Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n           \
    \  return\n         else:\n             // case 2.3\n             Copy_List_Items(P.blue_next_hops,\
    \ X.red_next_hops)\n             Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n\
    \             return\n     if (A is not S.localroot\n         and B is S.localroot):\n\
    \         // case 3.0\n         if A.LOWER:\n             // case 3.1\n      \
    \       Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n             Copy_List_Items(P.red_next_hops,\
    \ Y.blue_next_hops)\n             return\n         if A.HIGHER:\n            \
    \ // case 3.2\n             Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n\
    \             Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n            \
    \ return\n         else:\n             // case 3.3\n             Copy_List_Items(P.blue_next_hops,\
    \ X.red_next_hops)\n             Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n\
    \             return\n     if (A is not S.localroot\n         and B is not S.localroot):\n\
    \         // case 4.0\n         if (S is A.localroot or S is B.localroot):\n \
    \            // case 4.05\n             if A.topo_order < B.topo_order:\n    \
    \             // case 4.05.1\n                 Copy_List_Items(P.blue_next_hops,\
    \ X.blue_next_hops)\n                 Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n\
    \                 return\n             else:\n                 // case 4.05.2\n\
    \                 Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n       \
    \          Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n              \
    \   return\n         if A.LOWER:\n             // case 4.1\n             if B.HIGHER:\n\
    \                 // case 4.1.1\n                 Copy_List_Items(P.blue_next_hops,\
    \ X.red_next_hops)\n                 Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n\
    \                 return\n             if B.LOWER:\n                 // case 4.1.2\n\
    \                 if A.topo_order < B.topo_order:\n                     // case\
    \ 4.1.2.1\n                     Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n\
    \                     Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n    \
    \                 return\n                 else:\n                     // case\
    \ 4.1.2.2\n                     Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n\
    \                     Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n   \
    \                  return\n             else:\n                 // case 4.1.3\n\
    \                 Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n       \
    \          Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n               \
    \  return\n         if A.HIGHER:\n             // case 4.2\n             if B.HIGHER:\n\
    \                 // case 4.2.1\n                 if A.topo_order < B.topo_order:\n\
    \                     // case 4.2.1.1\n                     Copy_List_Items(P.blue_next_hops,\
    \ X.blue_next_hops)\n                     Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n\
    \                     return\n                 else:\n                     //\
    \ case 4.2.1.2\n                     Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n\
    \                     Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n   \
    \                  return\n             if B.LOWER:\n                 // case\
    \ 4.2.2\n                 Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n\
    \                 Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n        \
    \         return\n             else:\n                 // case 4.2.3\n       \
    \          Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n             \
    \    Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n                 return\n\
    \         else:\n             // case 4.3\n             if B.LOWER:\n        \
    \         // case 4.3.1\n                 Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n\
    \                 Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n        \
    \         return\n             if B.HIGHER:\n                 // case 4.3.2\n\
    \                 Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n      \
    \           Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n             \
    \    return\n             else:\n                 // case 4.3.3\n            \
    \     if A.topo_order < B.topo_order:\n                     // case 4.3.3.1\n\
    \                     Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n  \
    \                   Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n      \
    \               return\n                 else:\n                     // case 4.3.3.2\n\
    \                     Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n   \
    \                  Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n      \
    \               return\n     assert(False)\n                    Figure 28: Select_Proxy_Node_NHs()\n\
    \   It is useful to understand up front that the blue next hops to reach\n   proxy-node\
    \ P produced by Select_Proxy_Node_NHs() will always be the\n   next hops that\
    \ reach proxy-node attachment router X, while the red\n   next hops to reach proxy-node\
    \ P will always be the next hops that\n   reach proxy-node attachment router Y.\
    \  This is different from the red\n   and blue next hops produced by Compute_MRT_NextHops()\
    \ where, for\n   example, blue next hops to a destination that is ordered with\
    \ respect\n   to the source will always correspond to an INCREASING next hop on\
    \ the\n   GADAG.  The exact choice of which next hops chosen by\n   Select_Proxy_Node_NHs()\
    \ as the blue next hops to reach P (which will\n   necessarily go through X on\
    \ its way to P) does depend on the GADAG,\n   but the relationship is more complex\
    \ than was the case with\n   Compute_MRT_NextHops().\n   There are 21 different\
    \ relative order relationships between A, B, and\n   S that Select_Proxy_Node_NHs()\
    \ uses to determine red and blue next\n   hops to P.  This document does not attempt\
    \ to provide an exhaustive\n   description of each case considered in Select_Proxy_Node_NHs().\n\
    \   Instead, we provide a high-level overview of the different cases, and\n  \
    \ we consider a few cases in detail to give an example of the reasoning\n   that\
    \ can be used to understand each case.\n   At the highest level, Select_Proxy_Node_NHs()\
    \ distinguishes between\n   four different cases depending on whether or not A\
    \ or B is the\n   localroot for S.  For example, for case 4.0, neither A nor B\
    \ is the\n   localroot for S.  Case 4.05 addresses the case where S is the\n \
    \  localroot for either A or B, while cases 4.1, 4.2, and 4.3 address\n   the\
    \ cases where A is ordered lower than S, A is ordered higher than\n   S, or A\
    \ is unordered with respect to S on the GADAG.  In general,\n   each of these\
    \ cases is then further subdivided into whether or not B\n   is ordered lower\
    \ than S, B is ordered higher than S, or B is\n   unordered with respect to S.\
    \  In some cases, we also need a further\n   level of discrimination, where we\
    \ use the topological sort order of A\n   with respect to B.\n   As a detailed\
    \ example, let's consider case 4.1 and all of its sub-\n   cases, and explain\
    \ why the red and blue next hops to reach P are\n   chosen as they are in Select_Proxy_Node_NHs().\
    \  In case 4.1, neither\n   A nor B is the localroot for S, S is not the localroot\
    \ for A or B,\n   and A is ordered lower than S on the GADAG.  In this situation,\
    \ we\n   know that the red path to reach X (as computed in\n   Compute_MRT_NextHops())\
    \ will follow DECREASING next hops towards A,\n   while the blue path to reach\
    \ X will follow INCREASING next hops to\n   the localroot, and then INCREASING\
    \ next hops to A.\n   Now consider sub-case 4.1.1 where B is ordered higher than\
    \ S.  In\n   this situation, we know that the blue path to reach Y will follow\n\
    \   INCREASING next hops towards B, while the red next hops to reach Y\n   will\
    \ follow DECREASING next hops to the localroot, and then\n   DECREASING next hops\
    \ to B.  So, to reach X and Y by two disjoint\n   paths, we can choose the red\
    \ next hops to X and the blue next hops to\n   Y.  We have chosen the convention\
    \ that blue next hops to P are those\n   that pass through X, and red next hops\
    \ to P are those that pass\n   through Y, so we can see that case 4.1.1 produces\
    \ the desired result.\n   Choosing blue to X and red to Y does not produce disjoint\
    \ paths\n   because the paths intersect at least at the localroot.\n   Now consider\
    \ sub-case 4.1.2 where B is ordered lower than S.  In this\n   situation, we know\
    \ that the red path to reach Y will follow\n   DECREASING next hops towards B,\
    \ while the BLUE next hops to reach Y\n   will follow INCREASING next hops to\
    \ the localroot, and then\n   INCREASING next hops to A.  The choice here is more\
    \ difficult than in\n   4.1.1 because A and B are both on the DECREASING path\
    \ from S towards\n   the localroot.  We want to use the direct DECREASING(red)\
    \ path to the\n   one that is nearer to S on the GADAG.  We get this extra information\n\
    \   by comparing the topological sort order of A and B.  If\n   A.topo_order<B.topo_order,\
    \ then we use red to Y and blue to X, since\n   the red path to Y will DECREASE\
    \ to B without hitting A, and the blue\n   path to X will INCREASE to A without\
    \ hitting B.  Instead, if\n   A.topo_order>B.topo_order, then we use red to X\
    \ and blue to Y.\n   Note that when A is unordered with respect to B, the result\
    \ of\n   comparing A.topo_order with B.topo_order could be greater than or\n \
    \  less than.  In this case, the result doesn't matter because either\n   choice\
    \ (red to Y and blue to X or red to X and blue to Y) would work.\n   What is required\
    \ is that all nodes in the network give the same\n   result when comparing A.topo_order\
    \ with B.topo_order.  This is\n   guaranteed by having all nodes run the same\
    \ algorithm\n   (Run_Topological_Sort_GADAG()) to compute the topological sort\
    \ order.\n   Finally, we consider case 4.1.3, where B is unordered with respect\
    \ to\n   S.  In this case, the blue path to reach Y will follow the DECREASING\n\
    \   next hops towards the localroot until it reaches some node (K) which\n   is\
    \ ordered less than B, after which it will take INCREASING next hops\n   to B.\
    \  The red path to reach Y will follow the INCREASING next hops\n   towards the\
    \ localroot until it reaches some node (L) which is ordered\n   greater than B,\
    \ after which it will take DECREASING next hops to B.\n   Both K and A are reached\
    \ by DECREASING from S, but we don't have\n   information about whether or not\
    \ that DECREASING path will hit K or A\n   first.  Instead, we do know that the\
    \ INCREASING path from S will hit\n   L before reaching A.  Therefore, we use\
    \ the red path to reach Y and\n   the red path to reach X.\n   Similar reasoning\
    \ can be applied to understand the other 17 cases\n   used in Select_Proxy_Node_NHs().\
    \  However, cases 2.3 and 3.3 deserve\n   special attention because the correctness\
    \ of the solution for these\n   two cases relies on a special property of the\
    \ GADAGs that we have\n   constructed in this algorithm, a property not shared\
    \ by all GADAGs in\n   general.  Focusing on case 2.3, we consider the case where\
    \ A is the\n   localroot for S, while B is not, and B is unordered with respect\
    \ to\n   S.  The red path to X DECREASES from S to the localroot A, while the\n\
    \   blue path to X INCREASES from S to the localroot A.  The blue path to\n  \
    \ Y DECREASES towards the localroot A until it reaches some node (K)\n   which\
    \ is ordered less than B, after which the path INCREASES to B.\n   The red path\
    \ to Y INCREASES towards the localroot A until it reaches\n   some node (L) which\
    \ is ordered greater than B, after which the path\n   DECREASES to B.  It can\
    \ be shown that for an arbitrary GADAG, with\n   only the ordering relationships\
    \ computed so far, we don't have enough\n   information to choose a pair of paths\
    \ to reach X and Y that are\n   guaranteed to be disjoint.  In some topologies,\
    \ A will play the role\n   of K, the first node ordered less than B on the blue\
    \ path to Y.  In\n   other topologies, A will play the role of L, the first node\
    \ ordered\n   greater than B on the red path to Y.  The basic problem is that\
    \ we\n   cannot distinguish between these two cases based on the ordering\n  \
    \ relationships.\n   As discussed Section 5.8, the GADAGs that we construct using\
    \ the\n   algorithm in this document are not arbitrary GADAGs.  They have the\n\
    \   additional property that incoming links to a localroot come from only\n  \
    \ one other node in the same block.  This is a result of the method of\n   construction.\
    \  This additional property guarantees that localroot A\n   will never play the\
    \ role of L in the red path to Y, since L must have\n   at least two incoming\
    \ links from different nodes in the same block in\n   the GADAG.  This, in turn,\
    \ allows Select_Proxy_Node_NHs() to choose\n   the red path to Y and the red path\
    \ to X as the disjoint MRT paths to\n   reach P.\n"
- title: 5.9.4.  Computing MRT Alternates for Proxy-Nodes
  contents:
  - "5.9.4.  Computing MRT Alternates for Proxy-Nodes\n   After finding the red and\
    \ the blue next hops for a given proxy-node\n   P, it is necessary to know which\
    \ one of these to use in the case of\n   failure.  This can be done by Select_Alternates_Proxy_Node(),\
    \ as\n   shown in the pseudocode in Figure 29.\n  def Select_Alternates_Proxy_Node(P,F,primary_intf):\n\
    \      S = primary_intf.local_node\n      X = P.pnar_X\n      Y = P.pnar_Y\n \
    \     A = X.order_proxy\n      B = Y.order_proxy\n      if F is A and F is B:\n\
    \          return 'PRIM_NH_IS_OP_FOR_BOTH_X_AND_Y'\n      if F is A:\n       \
    \   return 'USE_RED'\n      if F is B:\n          return 'USE_BLUE'\n      if\
    \ not In_Common_Block(A, B):\n          if In_Common_Block(F, A):\n          \
    \    return 'USE_RED'\n          elif In_Common_Block(F, B):\n              return\
    \ 'USE_BLUE'\n          else:\n              return 'USE_RED_OR_BLUE'\n      if\
    \ (not In_Common_Block(F, A)\n          and not In_Common_Block(F, A) ):\n   \
    \       return 'USE_RED_OR_BLUE'\n      alt_to_X = Select_Alternates(X, F, primary_intf)\n\
    \      alt_to_Y = Select_Alternates(Y, F, primary_intf)\n      if (alt_to_X ==\
    \ 'USE_RED_OR_BLUE'\n          and alt_to_Y == 'USE_RED_OR_BLUE'):\n         \
    \ return 'USE_RED_OR_BLUE'\n      if alt_to_X == 'USE_RED_OR_BLUE':\n        \
    \  return 'USE_BLUE'\n      if alt_to_Y == 'USE_RED_OR_BLUE':\n          return\
    \ 'USE_RED'\n      if (A is S.localroot\n          and B is S.localroot):\n  \
    \        // case 1.0\n          if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'):\n\
    \              return 'USE_RED_OR_BLUE'\n          if alt_to_X == 'USE_BLUE':\n\
    \              return 'USE_BLUE'\n          if alt_to_Y == 'USE_RED':\n      \
    \        return 'USE_RED'\n          assert(False)\n      if (A is S.localroot\n\
    \          and B is not S.localroot):\n          // case 2.0\n          if B.LOWER:\n\
    \              // case 2.1\n              if (alt_to_X == 'USE_BLUE' and alt_to_Y\
    \ == 'USE_RED'):\n                  return 'USE_RED_OR_BLUE'\n              if\
    \ alt_to_X == 'USE_BLUE':\n                  return 'USE_BLUE'\n             \
    \ if alt_to_Y == 'USE_RED':\n                  return 'USE_RED'\n            \
    \  assert(False)\n          if B.HIGHER:\n              // case 2.2\n        \
    \      if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n              \
    \    return 'USE_RED_OR_BLUE'\n              if alt_to_X == 'USE_RED':\n     \
    \             return 'USE_BLUE'\n              if alt_to_Y == 'USE_BLUE':\n  \
    \                return 'USE_RED'\n              assert(False)\n          else:\n\
    \              // case 2.3\n              if (alt_to_X == 'USE_RED' and alt_to_Y\
    \ == 'USE_RED'):\n                  return 'USE_RED_OR_BLUE'\n              if\
    \ alt_to_X == 'USE_RED':\n                  return 'USE_BLUE'\n              if\
    \ alt_to_Y == 'USE_RED':\n                  return 'USE_RED'\n              assert(False)\n\
    \      if (A is not S.localroot\n          and B is S.localroot):\n          //\
    \ case 3.0\n          if A.LOWER:\n              // case 3.1\n              if\
    \ (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n                  return\
    \ 'USE_RED_OR_BLUE'\n              if alt_to_X == 'USE_RED':\n               \
    \   return 'USE_BLUE'\n              if alt_to_Y == 'USE_BLUE':\n            \
    \      return 'USE_RED'\n              assert(False)\n          if A.HIGHER:\n\
    \              // case 3.2\n              if (alt_to_X == 'USE_BLUE' and alt_to_Y\
    \ == 'USE_RED'):\n                  return 'USE_RED_OR_BLUE'\n              if\
    \ alt_to_X == 'USE_BLUE':\n                  return 'USE_BLUE'\n             \
    \ if alt_to_Y == 'USE_RED':\n                  return 'USE_RED'\n            \
    \  assert(False)\n          else:\n              // case 3.3\n              if\
    \ (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_RED'):\n                  return\
    \ 'USE_RED_OR_BLUE'\n              if alt_to_X == 'USE_RED':\n               \
    \   return 'USE_BLUE'\n              if alt_to_Y == 'USE_RED':\n             \
    \     return 'USE_RED'\n              assert(False)\n      if (A is not S.localroot\n\
    \          and B is not S.localroot):\n          // case 4.0\n          if (S\
    \ is A.localroot or S is B.localroot):\n              // case 4.05\n         \
    \     if A.topo_order < B.topo_order:\n                  // case 4.05.1\n    \
    \              if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'):\n      \
    \                return 'USE_RED_OR_BLUE'\n                  if alt_to_X == 'USE_BLUE':\n\
    \                      return 'USE_BLUE'\n                  if alt_to_Y == 'USE_RED':\n\
    \                      return 'USE_RED'\n                  assert(False)\n   \
    \           else:\n                  // case 4.05.2\n                  if (alt_to_X\
    \ == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n                      return 'USE_RED_OR_BLUE'\n\
    \                  if alt_to_X == 'USE_RED':\n                      return 'USE_BLUE'\n\
    \                  if alt_to_Y == 'USE_BLUE':\n                      return 'USE_RED'\n\
    \                  assert(False)\n          if A.LOWER:\n              // case\
    \ 4.1\n              if B.HIGHER:\n                  // case 4.1.1\n         \
    \         if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n           \
    \           return 'USE_RED_OR_BLUE'\n                  if alt_to_X == 'USE_RED':\n\
    \                      return 'USE_BLUE'\n                  if alt_to_Y == 'USE_BLUE':\n\
    \                      return 'USE_RED'\n                  assert(False)\n   \
    \           if B.LOWER:\n                  // case 4.1.2\n                  if\
    \ A.topo_order < B.topo_order:\n                      // case 4.1.2.1\n      \
    \                if (alt_to_X == 'USE_BLUE'\n                          and alt_to_Y\
    \ == 'USE_RED'):\n                          return 'USE_RED_OR_BLUE'\n       \
    \               if alt_to_X == 'USE_BLUE':\n                          return 'USE_BLUE'\n\
    \                      if alt_to_Y == 'USE_RED':\n                          return\
    \ 'USE_RED'\n                      assert(False)\n                  else:\n  \
    \                    // case 4.1.2.2\n                      if (alt_to_X == 'USE_RED'\n\
    \                          and alt_to_Y == 'USE_BLUE'):\n                    \
    \      return 'USE_RED_OR_BLUE'\n                      if alt_to_X == 'USE_RED':\n\
    \                          return 'USE_BLUE'\n                      if alt_to_Y\
    \ == 'USE_BLUE':\n                          return 'USE_RED'\n               \
    \       assert(False)\n              else:\n                  // case 4.1.3\n\
    \                  if (F.LOWER and not F.HIGHER\n                      and F.topo_order\
    \ > A.topo_order):\n                      // case 4.1.3.1\n                  \
    \    return 'USE_RED'\n                  else:\n                      // case\
    \ 4.1.3.2\n                      return 'USE_BLUE'\n          if A.HIGHER:\n \
    \             // case 4.2\n              if B.HIGHER:\n                  // case\
    \ 4.2.1\n                  if A.topo_order < B.topo_order:\n                 \
    \     // case 4.2.1.1\n                      if (alt_to_X == 'USE_BLUE'\n    \
    \                      and alt_to_Y == 'USE_RED'):\n                         \
    \ return 'USE_RED_OR_BLUE'\n                      if alt_to_X == 'USE_BLUE':\n\
    \                          return 'USE_BLUE'\n                      if alt_to_Y\
    \ == 'USE_RED':\n                          return 'USE_RED'\n                \
    \      assert(False)\n                  else:\n                      // case 4.2.1.2\n\
    \                      if (alt_to_X == 'USE_RED'\n                          and\
    \ alt_to_Y == 'USE_BLUE'):\n                          return 'USE_RED_OR_BLUE'\n\
    \                      if alt_to_X == 'USE_RED':\n                          return\
    \ 'USE_BLUE'\n                      if alt_to_Y == 'USE_BLUE':\n             \
    \             return 'USE_RED'\n                      assert(False)\n        \
    \      if B.LOWER:\n                  // case 4.2.2\n                  if (alt_to_X\
    \ == 'USE_BLUE'\n                      and alt_to_Y == 'USE_RED'):\n         \
    \             return 'USE_RED_OR_BLUE'\n                  if alt_to_X == 'USE_BLUE':\n\
    \                      return 'USE_BLUE'\n                  if alt_to_Y == 'USE_RED':\n\
    \                      return 'USE_RED'\n                  assert(False)\n   \
    \           else:\n                  // case 4.2.3\n                  if (F.HIGHER\
    \ and not F.LOWER\n                      and F.topo_order < A.topo_order):\n \
    \                     return 'USE_RED'\n                  else:\n            \
    \          return 'USE_BLUE'\n          else:\n              // case 4.3\n   \
    \           if B.LOWER:\n                  // case 4.3.1\n                  if\
    \ (F.LOWER and not F.HIGHER\n                      and F.topo_order > B.topo_order):\n\
    \                      return 'USE_BLUE'\n                  else:\n          \
    \            return 'USE_RED'\n              if B.HIGHER:\n                  //\
    \ case 4.3.2\n                  if (F.HIGHER and not F.LOWER\n               \
    \       and F.topo_order < B.topo_order):\n                      return 'USE_BLUE'\n\
    \                  else:\n                      return 'USE_RED'\n           \
    \   else:\n                  // case 4.3.3\n                  if A.topo_order\
    \ < B.topo_order:\n                      // case 4.3.3.1\n                   \
    \   if (alt_to_X == 'USE_BLUE'\n                          and alt_to_Y == 'USE_RED'):\n\
    \                          return 'USE_RED_OR_BLUE'\n                      if\
    \ alt_to_X == 'USE_BLUE':\n                          return 'USE_BLUE'\n     \
    \                 if alt_to_Y == 'USE_RED':\n                          return\
    \ 'USE_RED'\n                      assert(False)\n                  else:\n  \
    \                    // case 4.3.3.2\n                      if (alt_to_X == 'USE_RED'\n\
    \                          and alt_to_Y == 'USE_BLUE'):\n                    \
    \      return 'USE_RED_OR_BLUE'\n                      if alt_to_X == 'USE_RED':\n\
    \                          return 'USE_BLUE'\n                      if alt_to_Y\
    \ == 'USE_BLUE':\n                          return 'USE_RED'\n               \
    \       assert(False)\n      assert(False)\n                 Figure 29: Select_Alternates_Proxy_Node()\n\
    \   Select_Alternates_Proxy_Node(P,F,primary_intf) determines whether it\n   is\
    \ safe to use the blue path to P (which goes through X), the red\n   path to P\
    \ (which goes through Y), or either, when the primary_intf to\n   node F (and\
    \ possibly node F) fails.  The basic approach is to run\n   Select_Alternates(X,F,primary_intf)\
    \ and\n   Select_Alternates(Y,F,primary_intf) to determine which of the two MRT\n\
    \   paths to X and which of the two MRT paths to Y is safe to use in the\n   event\
    \ of the failure of F.  In general, we will find that if it is\n   safe to use\
    \ a particular path to X or Y when F fails, and\n   Select_Proxy_Node_NHs() used\
    \ that path when constructing the red or\n   blue path to reach P, then it will\
    \ also be safe to use that path to\n   reach P when F fails.  This rule has one\
    \ exception which is covered\n   below.  First, we give a concrete example of\
    \ how\n   Select_Alternates_Proxy_Node() works in the common case.\n   The 21\
    \ ordering relationships used in Select_Proxy_Node_NHs() are\n   repeated in Select_Alternates_Proxy_Node().\
    \  We focus on case 4.1.1\n   to give a detailed example of the reasoning used\
    \ in\n   Select_Alternates_Proxy_Node().  In Select_Proxy_Node_NHs(), we\n   determined\
    \ for case 4.1.1 that the red next hops to X and the blue\n   next hops to Y allow\
    \ us to reach X and Y by disjoint paths, and are\n   thus the blue and red next\
    \ hops to reach P.  Therefore, if\n   Select_Alternates(X, F, primary_intf) is\
    \ run and we find that it is\n   safe to USE_RED to reach X, then we also conclude\
    \ that it is safe to\n   use the MRT path through X to reach P (the blue path\
    \ to P) when F\n   fails.  Similarly, if we run Select_Alternates(Y, F, primary_intf)\n\
    \   and we find that it is safe to USE_BLUE to reach Y, then we also\n   conclude\
    \ that it is safe to use the MRT path through Y to reach P\n   (the red path to\
    \ P) when F fails.  If both of the paths that were\n   used in Select_Proxy_Node_NHs()\
    \ to construct the blue and red paths\n   to P are found to be safe to use to\
    \ use to reach X and Y, t then we\n   conclude that we can use either the red\
    \ or the blue path to P.\n   This simple reasoning gives the correct answer in\
    \ most of the cases.\n   However, additional logic is needed when either A or\
    \ B (but not both\n   A and B) is unordered with respect to S.  This applies to\
    \ cases\n   4.1.3, 4.2.3, 4.3.1, and 4.3.2.  Looking at case 4.1.3 in more\n \
    \  detail, A is ordered less than S, but B is unordered with respect to\n   S.\
    \  In the discussion of case 4.1.3 above, we saw that\n   Select_Proxy_Node_NHs()\
    \ chose the red path to reach Y and the red\n   path to reach X.  We also saw\
    \ that the red path to reach Y will\n   follow the INCREASING next hops towards\
    \ the localroot until it\n   reaches some node (L) which is ordered greater than\
    \ B, after which it\n   will take DECREASING next hops to B.  The problem is that\
    \ the red\n   path to reach P (the one that goes through Y) won't necessarily\
    \ be\n   the same as the red path to reach Y.  This is because the next hop\n\
    \   that node L computes for its red next hop to reach P may be different\n  \
    \ from the next hop it computes for its red next hop to reach Y.  This\n   is\
    \ because B is ordered lower than L, so L applies case 4.1.2 of\n   Select_Proxy_Node_NHs()\
    \ in order to determine its next hops to reach\n   P.  If A.topo_order<B.topo_order\
    \ (case 4.1.2.1), then L will choose\n   DECREASING next hops directly to B, which\
    \ is the same result that L\n   computes in Compute_MRT_NextHops() to reach Y.\
    \  However, if\n   A.topo_order>B.topo_order (case 4.1.2.2), then L will choose\n\
    \   INCREASING next hops to reach B, which is different from what L\n   computes\
    \ in Compute_MRT_NextHops() to reach Y.  So, testing the\n   safety of the path\
    \ for S to reach Y on failure of F as a surrogate\n   for the safety of using\
    \ the red path to reach P is not reliable in\n   this case.  It is possible construct\
    \ topologies where the red path to\n   P hits F even though the red path to Y\
    \ does not hit F.\n   Fortunately, there is enough information in the order relationships\n\
    \   that we have already computed to still figure out which alternate to\n   choose\
    \ in these four cases.  The basic idea is to always choose the\n   path involving\
    \ the ordered node, unless that path would hit F.\n   Returning to case 4.1.3,\
    \ we see that since A is ordered lower than S,\n   the only way for S to hit F\
    \ using a simple DECREASING path to A is\n   for F to lie between A and S on the\
    \ GADAG.  This scenario is covered\n   by requiring that F be lower than S (but\
    \ not also higher than S) and\n   that F.topo_order>A.topo_order in case 4.1.3.1.\n\
    \   We just need to confirm that it is safe to use the path involving B\n   in\
    \ this scenario.  In case 4.1.3.1, either F is between A and S on\n   the GADAG,\
    \ or F is unordered with respect to A and lies on the\n   DECREASING path from\
    \ S to the localroot.  When F is between A and S\n   on the GADAG, then the path\
    \ through B chosen to avoid A in\n   Select_Proxy_Node_NHs() will also avoid F.\
    \  When F is unordered with\n   respect to A and lies on the DECREASING path from\
    \ S to the localroot,\n   then we consider two cases.  Either F.topo_order<B.topo_order\
    \ or\n   F.topo_order>B.topo_order.  In the first case, since\n   F.topo_order<B.topo_order\
    \ and F.topo_order>A.topo_order, it must be\n   the case that A.topo_order<B.topo_order.\
    \  Therefore, L will choose\n   DECREASING next hops directly to B (case 4.1.2.1),\
    \ which cannot hit F\n   since F.topo_order<B.topo_order.  In the second case,\
    \ where\n   F.topo_order>B.topo_order, the only way for the path involving B to\n\
    \   hit F is if it DECREASES from L to B through F, i.e., it must be that\n  \
    \ L>>F>>B.  However, since S>>F, this would imply that S>>B.  However,\n   we\
    \ know that S is unordered with respect to B, so the second case\n   cannot occur.\
    \  So we have demonstrated that the red path to P (which\n   goes via B and Y)\
    \ is safe to use under the conditions of 4.1.3.1.\n   Similar reasoning can be\
    \ applied to the other three special cases\n   where either A or B is unordered\
    \ with respect to S.\n"
- title: '6.  MRT Lowpoint Algorithm: Next-Hop Conformance'
  contents:
  - "6.  MRT Lowpoint Algorithm: Next-Hop Conformance\n   This specification defines\
    \ the MRT Lowpoint algorithm, which includes\n   the construction of a common\
    \ GADAG and the computation of MRT-Red and\n   MRT-Blue next hops to each node\
    \ in the graph.  An implementation MAY\n   select any subset of next hops for\
    \ MRT-Red and MRT-Blue that respect\n   the available nodes that are described\
    \ in Section 5.7 for each of the\n   MRT-Red and MRT-Blue and the selected next\
    \ hops are further along in\n   the interval of allowed nodes towards the destination.\n\
    \   For example, the MRT-Blue next hops used when the destination Y >> X,\n  \
    \ the computing router, MUST be one or more nodes, T, whose topo_order\n   is\
    \ in the interval [X.topo_order, Y.topo_order] and where Y >> T or Y\n   is T.\
    \  Similarly, the MRT-Red next hops MUST be have a topo_order in\n   the interval\
    \ [R-small.topo_order, X.topo_order] or [Y.topo_order,\n   R-big.topo_order].\n\
    \   Implementations SHOULD implement the Select_Alternates() function to\n   pick\
    \ an MRT-FRR alternate.\n"
- title: 7.  Broadcast Interfaces
  contents:
  - "7.  Broadcast Interfaces\n   When broadcast interfaces are used to connect nodes,\
    \ the broadcast\n   network MUST be represented as a pseudonode, where each real\
    \ node\n   connects to the pseudonode.  The interface metric in the direction\n\
    \   from real node to pseudonode is the non-zero interface metric, while\n   the\
    \ interface metric in the direction from the pseudonode to the real\n   node is\
    \ set to zero.  This is consistent with the way that broadcast\n   interfaces\
    \ are represented as pseudonodes in IS-IS and OSPF.\n   Pseudonodes MUST be treated\
    \ as equivalent to real nodes in the\n   network graph used in the MRT Lowpoint\
    \ algorithm with a few\n   exceptions detailed below.\n   The pseudonodes MUST\
    \ be included in the computation of the GADAG.\n   The neighbors of the pseudonode\
    \ need to know the mrt_node_id of the\n   pseudonode in order to consistently\
    \ order interfaces, which is needed\n   to compute the GADAG.  The mrt_node_id\
    \ for IS-IS is the 7-octet\n   neighbor system ID and pseudonode number in TLV\
    \ 22 or TLV 222.  The\n   mrt_node_id for OSPFv2 is the 4-octet interface address\
    \ of the\n   Designated Router found in the Link ID field for the link type 2\n\
    \   (transit network) in the Router-LSA.  The mrt_node_id for OSPFv3 is\n   the\
    \ 4 octet interface address of the Designated Router found in the\n   Neighbor\
    \ Interface ID field for the link type 2 (transit network) in\n   the Router-LSA.\
    \  Note that this is different from the Neighbor Router\n   ID field used for\
    \ the mrt_node_id for point-to-point links in OSPFv3\n   Router-LSAs given in\
    \ Figure 15.\n   Pseudonodes MUST NOT be considered candidates for selection as\
    \ GADAG\n   root.  This rule is intended to result in a more stable network-wide\n\
    \   selection of GADAG root by removing the possibility that the change\n   of\
    \ Designated Router or Designated Intermediate System on a broadcast\n   network\
    \ can result in a change of GADAG root.\n"
- title: 7.1.  Computing MRT Next Hops on Broadcast Networks
  contents:
  - "7.1.  Computing MRT Next Hops on Broadcast Networks\n   The pseudonode does not\
    \ correspond to a real node, so it is not\n   actually involved in forwarding.\
    \  A real node on a broadcast network\n   cannot simply forward traffic to the\
    \ broadcast network.  It must\n   specify another real node on the broadcast network\
    \ as the next hop.\n   On a network graph where a broadcast network is represented\
    \ by a\n   pseudonode, this means that if a real node determines that the next\n\
    \   hop to reach a given destination is a pseudonode, it must also\n   determine\
    \ the next-next-hop for that destination in the network\n   graph, which corresponds\
    \ to a real node attached to the broadcast\n   network.\n   It is interesting\
    \ to note that this issue is not unique to the MRT\n   algorithm, but is also\
    \ encountered in normal SPF computations for\n   IGPs.  Section 16.1.1 of [RFC2328]\
    \ describes how this is done for\n   OSPF.  When OSPF runs its shortest-path tree\
    \ calculation, it deals\n   with pseudonodes in the following manner.  Whenever\
    \ the calculating\n   router finds a shorter path to reach a real destination\
    \ node and the\n   shorter path to the destination is a single pseudonode hop,\
    \ then the\n   next hop for that destination is taken from the interface IP address\n\
    \   in the Router-LSA correspond to the link to the real destination\n   node.\n\
    \   For IS-IS, in the example pseudocode implementation of Dijkstra's\n   algorithm\
    \ in Annex C of [ISO10589-Second-Edition], whenever the\n   algorithm encounters\
    \ an adjacency from a real node to a pseudonode,\n   it gets converted to a set\
    \ of adjacencies from the real node to the\n   neighbors of the pseudonode.  In\
    \ this way, the computed next hops\n   point all the way to the real node, and\
    \ not the pseudonode.\n   We could avoid the problem of determining next hops\
    \ across\n   pseudonodes in MRT by converting the pseudonode representation of\n\
    \   broadcast networks to a full mesh of links between real nodes on the\n   same\
    \ network.  However, if we make that conversion before computing\n   the GADAG,\
    \ we lose information about which links actually correspond\n   to a single physical\
    \ interface into the broadcast network.  This\n   could result computing red and\
    \ blue next hops that use the same\n   broadcast interface, in which case neither\
    \ the red nor the blue next\n   hop would be usable as an alternate on failure\
    \ of the broadcast\n   interface.\n   Instead, we take the following approach,\
    \ which maintains the property\n   that either the red and blue next hop will\
    \ avoid the broadcast\n   network, if topologically allowed.  We run the MRT Lowpoint\
    \ algorithm\n   treating the pseudonodes as equivalent to real nodes in the network\n\
    \   graph, with the exceptions noted above.  In addition to running the\n   MRT\
    \ Lowpoint algorithm from the point of view of itself, a computing\n   router\
    \ connected to a pseudonode MUST also run the MRT Lowpoint\n   algorithm from\
    \ the point of view of each of its pseudonode neighbors.\n   For example, if a\
    \ computing router S determines that its MRT red next\n   hop to reach a destination\
    \ D is a pseudonode P, S looks at its MRT\n   Lowpoint algorithm computation from\
    \ P's point of view to determine\n   P's red next hop to reach D, say interface\
    \ 1 on node X.  S now knows\n   that its real red next hop to reach D is interface\
    \ 1 on node X on the\n   broadcast network represented by P, and it can install\
    \ the\n   corresponding entry in its FIB.\n"
- title: 7.2.  Using MRT Next Hops as Alternates in the Event of Failures on
  contents:
  - "7.2.  Using MRT Next Hops as Alternates in the Event of Failures on\n      Broadcast\
    \ Networks\n   In the previous section, we specified how to compute MRT next hops\n\
    \   when broadcast networks are involved.  In this section, we discuss\n   how\
    \ a PLR can use those MRT next hops in the event of failures\n   involving broadcast\
    \ networks.\n   A PLR attached to a broadcast network running only OSPF or IS-IS\
    \ with\n   large Hello intervals has limited ability to quickly detect failures\n\
    \   on a broadcast network.  The only failure mode that can be quickly\n   detected\
    \ is the failure of the physical interface connecting the PLR\n   to the broadcast\
    \ network.  For the failure of the interface\n   connecting the PLR to the broadcast\
    \ network, the alternate that\n   avoids the broadcast network can be computed\
    \ by using the broadcast\n   network pseudonode as F, the primary next-hop node,\
    \ in\n   Select_Alternates().  This will choose an alternate path that avoids\n\
    \   the broadcast network.  However, the alternate path will not\n   necessarily\
    \ avoid all of the real nodes connected to the broadcast\n   network.  This is\
    \ because we have used the pseudonode to represent\n   the broadcast network.\
    \  And we have enforced the node-protecting\n   property of MRT on the pseudonode\
    \ to provide protection against\n   failure of the broadcast network, not the\
    \ real next-hop nodes on the\n   broadcast network.  This is the best that we\
    \ can hope to do if\n   failure of the broadcast interface is the only failure\
    \ mode that the\n   PLR can respond to.\n   We can improve on this if the PLR\
    \ also has the ability to quickly\n   detect a lack of connectivity across the\
    \ broadcast network to a given\n   IP-layer node.  This can be accomplished by\
    \ running BFD between all\n   pairs of IGP neighbors on the broadcast network.\
    \  Note that in the\n   case of OSPF, this would require establishing BFD sessions\
    \ between\n   all pairs of neighbors in the 2-WAY state.  When the PLR can quickly\n\
    \   detect the failure of a particular next hop across a broadcast\n   network,\
    \ the PLR can be more selective in its choice of alternates.\n   For example,\
    \ when the PLR observes that connectivity to an IP-layer\n   node on a broadcast\
    \ network has failed, the PLR may choose to still\n   use the broadcast network\
    \ to reach other IP-layer nodes that are\n   still reachable.  Or, if the PLR\
    \ observes that connectivity has\n   failed to several IP-layer nodes on the same\
    \ broadcast network, it\n   may choose to treat the entire broadcast network as\
    \ failed.  The\n   choice of MRT alternates by a PLR for a particular set of failure\n\
    \   conditions is a local decision, since it does not require\n   coordination\
    \ with other nodes.\n"
- title: 8.  Evaluation of Alternative Methods for Constructing GADAGs
  contents:
  - "8.  Evaluation of Alternative Methods for Constructing GADAGs\n   This document\
    \ specifies the MRT Lowpoint algorithm.  One component of\n   the algorithm involves\
    \ constructing a common GADAG based on the\n   network topology.  The MRT Lowpoint\
    \ algorithm computes the GADAG\n   using the method described in Section 5.5.\
    \  This method aims to\n   minimize the amount of computation required to compute\
    \ the GADAG.  In\n   the process of developing the MRT Lowpoint algorithm, two\
    \ alternative\n   methods for constructing GADAGs were also considered.  These\n\
    \   alternative methods are described in Appendices B and C.  In general,\n  \
    \ these other two methods require more computation to compute the\n   GADAG. \
    \ The analysis below was performed to determine if the\n   alternative GADAG construction\
    \ methods produce shorter MRT alternate\n   paths in real network topologies,\
    \ and if so, to what extent.\n   Figure 30 compares results obtained using the\
    \ three different methods\n   for constructing GADAGs on five different service\
    \ provider network\n   topologies.  MRT_LOWPOINT indicates the method specified\
    \ in\n   Section 5.5, while MRT_SPF and MRT_HYBRID indicate the methods\n   specified\
    \ in Appendices B and C, respectively.  The columns on the\n   right present the\
    \ distribution of alternate path lengths for each\n   GADAG construction method.\
    \  Each MRT computation was performed using\n   a same GADAG root chosen based\
    \ on centrality.\n   For three of the topologies analyzed (T201, T206, and T211),\
    \ the use\n   of MRT_SPF or MRT_HYBRID methods does not appear to provide a\n\
    \   significantly shorter alternate path lengths compared to the\n   MRT_LOWPOINT\
    \ method.  However, for two of the topologies (T216 and\n   T219), the use of\
    \ the MRT_SPF method resulted in noticeably shorter\n   alternate path lengths\
    \ than the use of the MRT_LOWPOINT or MRT_HYBRID\n   methods.\n   It was decided\
    \ to use the MRT_LOWPOINT method to construct the GADAG\n   in the algorithm specified\
    \ in this document, in order to initially\n   offer an algorithm with lower computational\
    \ requirements.  These\n   results indicate that in the future it may be useful\
    \ to evaluate and\n   potentially specify other MRT Lowpoint algorithm variants\
    \ that use\n   different GADAG construction methods.\n   +-------------------------------------------------------------------+\n\
    \   |        Topology name         |   percentage of failure scenarios  |\n  \
    \ |                              |  protected by an alternate N hops  |\n   |\
    \      GADAG construction      |   longer than the primary path     |\n   |  \
    \          method            +------------------------------------+\n   |    \
    \                          |   |   |   |   |   |   |   |   | no |\n   |      \
    \                        |   |   |   |   |   |10 |12 |14 | alt|\n   |        \
    \                      |0-1|2-3|4-5|6-7|8-9|-11|-13|-15| <16|\n   +------------------------------+---+---+---+---+---+---+---+---+----+\n\
    \   |  T201(avg primary hops=3.5)  |   |   |   |   |   |   |   |   |    |\n  \
    \ |  MRT_HYBRID                  | 33| 26| 23|  6|  3|   |   |   |    |\n   |\
    \  MRT_SPF                     | 33| 36| 23|  6|  3|   |   |   |    |\n   |  MRT_LOWPOINT\
    \                | 33| 36| 23|  6|  3|   |   |   |    |\n   +------------------------------+---+---+---+---+---+---+---+---+----+\n\
    \   |  T206(avg primary hops=3.7)  |   |   |   |   |   |   |   |   |    |\n  \
    \ |  MRT_HYBRID                  | 50| 35| 13|  2|   |   |   |   |    |\n   |\
    \  MRT_SPF                     | 50| 35| 13|  2|   |   |   |   |    |\n   |  MRT_LOWPOINT\
    \                | 55| 32| 13|   |   |   |   |   |    |\n   +------------------------------+---+---+---+---+---+---+---+---+----+\n\
    \   |  T211(avg primary hops=3.3)  |   |   |   |   |   |   |   |   |    |\n  \
    \ |  MRT_HYBRID                  | 86| 14|   |   |   |   |   |   |    |\n   |\
    \  MRT_SPF                     | 86| 14|   |   |   |   |   |   |    |\n   |  MRT_LOWPOINT\
    \                | 85| 15|  1|   |   |   |   |   |    |\n   +------------------------------+---+---+---+---+---+---+---+---+----+\n\
    \   |  T216(avg primary hops=5.2)  |   |   |   |   |   |   |   |   |    |\n  \
    \ |  MRT_HYBRID                  | 23| 22| 18| 13| 10|  7|  4|  2|   2|\n   |\
    \  MRT_SPF                     | 35| 32| 19|  9|  3|  1|   |   |    |\n   |  MRT_LOWPOINT\
    \                | 28| 25| 18| 11|  7|  6|  3|  2|   1|\n   +------------------------------+---+---+---+---+---+---+---+---+----+\n\
    \   |  T219(avg primary hops=7.7)  |   |   |   |   |   |   |   |   |    |\n  \
    \ |  MRT_HYBRID                  | 20| 16| 13| 10|  7|  5|  5|  5|   3|\n   |\
    \  MRT_SPF                     | 31| 23| 19| 12|  7|  4|  2|  1|    |\n   |  MRT_LOWPOINT\
    \                | 19| 14| 15| 12| 10|  8|  7|  6|  10|\n   +------------------------------+---+---+---+---+---+---+---+---+----+\n\
    \        Figure 30: The Length of Alternate Paths for Various GADAG\n        \
    \                   Construction Methods\n"
- title: 9.  Operational Considerations
  contents:
  - "9.  Operational Considerations\n   This section discusses operational considerations\
    \ related to the MRT\n   Lowpoint algorithm and other potential MRT algorithm\
    \ variants.  For a\n   discussion of operational considerations related to MRT-FRR\
    \ in\n   general, see the \"Operational Considerations\" section of [RFC7812].\n"
- title: 9.1.  GADAG Root Selection
  contents:
  - "9.1.  GADAG Root Selection\n   The Default MRT Profile uses the GADAG Root Selection\
    \ Priority\n   advertised by routers as the primary criterion for selecting the\n\
    \   GADAG root.  It is RECOMMENDED that an operator designate a set of\n   routers\
    \ as good choices for selection as GADAG root by setting the\n   GADAG Root Selection\
    \ Priority for that set of routers to lower (more\n   preferred) numerical values.\
    \  Criteria for making this designation\n   are discussed below.\n   Analysis\
    \ has shown that the centrality of a router can have a\n   significant impact\
    \ on the lengths of the alternate paths computed.\n   Therefore, it is RECOMMENDED\
    \ that off-line analysis that considers\n   the centrality of a router be used\
    \ to help determine how good a\n   choice a particular router is for the role\
    \ of GADAG root.\n   If the router currently selected as GADAG root becomes unreachable\
    \ in\n   the IGP topology, then a new GADAG root will be selected.  Changing\n\
    \   the GADAG root can change the overall structure of the GADAG as well\n   the\
    \ paths of the red and MRT-Blue trees built using that GADAG.  In\n   order to\
    \ minimize change in the associated red and MRT-Blue\n   forwarding entries that\
    \ can result from changing the GADAG root, it\n   is RECOMMENDED that operators\
    \ prioritize for selection as GADAG root\n   those routers that are expected to\
    \ consistently remain part of the\n   IGP topology.\n"
- title: 9.2.  Destination-Rooted GADAGs
  contents:
  - "9.2.  Destination-Rooted GADAGs\n   The MRT Lowpoint algorithm constructs a single\
    \ GADAG rooted at a\n   single node selected as the GADAG root.  It is also possible\
    \ to\n   construct a different GADAG for each destination, with the GADAG\n  \
    \ rooted at the destination.  A router can compute the MRT-Red and MRT-\n   Blue\
    \ next hops for that destination based on the GADAG rooted at that\n   destination.\
    \  Building a different GADAG for each destination is\n   computationally more\
    \ expensive, but it may give somewhat shorter\n   alternate paths.  Using destination-rooted\
    \ GADAGs would require a new\n   MRT profile to be created with a new MRT algorithm\
    \ specification,\n   since all routers in the MRT Island would need to use destination-\n\
    \   rooted GADAGs.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   The algorithm described in this document does\
    \ not introduce new\n   security concerns beyond those already discussed in the\
    \ document\n   describing the MRT FRR architecture [RFC7812].\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC7812]  Atlas, A., Bowers, C., and G. Enyedi, \"An Architecture for\n \
    \             IP/LDP Fast Reroute Using Maximally Redundant Trees\n          \
    \    (MRT-FRR)\", RFC 7812, DOI 10.17487/RFC7812, June 2016,\n              <http://www.rfc-editor.org/info/rfc7812>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [EnyediThesis]\n              Enyedi, G., \"\
    Novel Algorithms for IP Fast Reroute\",\n              Department of Telecommunications\
    \ and Media Informatics,\n              Budapest University of Technology and\
    \ Economics Ph.D.\n              Thesis, February 2011,\n              <https://repozitorium.omikk.bme.hu/bitstream/\n\
    \              handle/10890/1040/ertekezes.pdf>.\n   [IEEE8021Qca]\n         \
    \     IEEE, \"IEEE Standard for Local and metropolitan area\n              networks\
    \ - Bridges and Bridged Networks - Amendment 24:\n              Path Control and\
    \ Reservation\", IEEE 802.1Qca-2015,\n              DOI 10.1109/IEEESTD.2016.7434544,\
    \ 2016,\n              <https://standards.ieee.org/findstds/\n              standard/802.1Qca-2015.html>.\n\
    \   [ISO10589-Second-Edition]\n              International Organization for Standardization,\n\
    \              \"Intermediate system to Intermediate system intra-domain\n   \
    \           routeing information exchange protocol for use in\n              conjunction\
    \ with the protocol for providing the\n              connectionless-mode Network\
    \ Service (ISO 8473)\", ISO/\n              IEC 10589:2002, Second Edition, November\
    \ 2002.\n   [Kahn_1962_topo_sort]\n              Kahn, A., \"Topological sorting\
    \ of large networks\",\n              Communications of the ACM, Volume 5, Issue\
    \ 11 DOI\n              10.1145/368996.369025, November 1962,\n              <http://dl.acm.org/citation.cfm?doid=368996.369025>.\n\
    \   [MRTLinear]\n              Enyedi, G., Retvari, G., and A. Csaszar, \"On Finding\n\
    \              Maximally Redundant Trees in Strictly Linear Time\", IEEE\n   \
    \           Symposium on Computers and Communications (ISCC), 2009,\n        \
    \      <http://opti.tmit.bme.hu/~enyedi/ipfrr/\n              distMaxRedTree.pdf>.\n\
    \   [RFC2328]  Moy, J., \"OSPF Version 2\", STD 54, RFC 2328,\n              DOI\
    \ 10.17487/RFC2328, April 1998,\n              <http://www.rfc-editor.org/info/rfc2328>.\n"
- title: Appendix A.  Python Implementation of MRT Lowpoint Algorithm
  contents:
  - "Appendix A.  Python Implementation of MRT Lowpoint Algorithm\n   Below is Python\
    \ code implementing the MRT Lowpoint algorithm\n   specified in this document.\
    \  The code is also posted on GitHub\n   <https://github.com/cbowers/draft-ietf-rtgwg-mrt-frr-\n\
    \   algorithm/blob/python_code_RFC7811/src/mrt_lowpoint_draft_text.py>.\n   While\
    \ this Python code is believed to correctly implement the\n   pseudocode description\
    \ of the algorithm, in the event of a\n   difference, the pseudocode description\
    \ should be considered\n   normative.\n"
- title: <CODE BEGINS>
  contents:
  - '<CODE BEGINS>

    '
- title: '# This program has been tested to run on Python 2.6 and 2.7'
  contents:
  - '# This program has been tested to run on Python 2.6 and 2.7

    '
- title: '# (specifically Python 2.6.6 and 2.7.8 were tested).'
  contents:
  - '# (specifically Python 2.6.6 and 2.7.8 were tested).

    '
- title: '# The program has known incompatibilities with Python 3.X.'
  contents:
  - '# The program has known incompatibilities with Python 3.X.

    '
- title: '# When executed, this program will generate a text file describing'
  contents:
  - '# When executed, this program will generate a text file describing

    '
- title: '# an example topology.  It then reads that text file back in as input'
  contents:
  - '# an example topology.  It then reads that text file back in as input

    '
- title: '# to create the example topology, and runs the MRT Lowpoint algorithm.'
  contents:
  - '# to create the example topology, and runs the MRT Lowpoint algorithm.

    '
- title: '# This was done to simplify the inclusion of the program as a single'
  contents:
  - '# This was done to simplify the inclusion of the program as a single

    '
- title: '# text file that can be extracted from the RFC.'
  contents:
  - '# text file that can be extracted from the RFC.

    '
- title: '# The output of the program is four text files containing a description'
  contents:
  - '# The output of the program is four text files containing a description

    '
- title: '# of the GADAG, the blue and MRT-Reds for all destinations, and the'
  contents:
  - '# of the GADAG, the blue and MRT-Reds for all destinations, and the

    '
- title: '# MRT alternates for all failures.'
  contents:
  - '# MRT alternates for all failures.

    '
- title: import random
  contents:
  - 'import random

    '
- title: import os.path
  contents:
  - 'import os.path

    '
- title: import heapq
  contents:
  - 'import heapq

    '
- title: '# simple Class definitions allow structure-like dot notation for'
  contents:
  - '# simple Class definitions allow structure-like dot notation for

    '
- title: '# variables and a convenient place to initialize those variables.'
  contents:
  - '# variables and a convenient place to initialize those variables.

    '
- title: 'class Topology:'
  contents:
  - "class Topology:\n    def __init__(self):\n        self.gadag_root = None\n  \
    \      self.node_list = []\n        self.node_dict = {}\n        self.test_gr\
    \ = None\n        self.island_node_list_for_test_gr = []\n        self.stored_named_proxy_dict\
    \ = {}\n        self.init_new_computing_router()\n    def init_new_computing_router(self):\n\
    \        self.island_node_list = []\n        self.named_proxy_dict = {}\n"
- title: 'class Node:'
  contents:
  - "class Node:\n    def __init__(self):\n        self.node_id = None\n        self.intf_list\
    \ = []\n        self.profile_id_list = [0]\n        self.GR_sel_priority = 128\n\
    \        self.blue_next_hops_dict = {}\n        self.red_next_hops_dict = {}\n\
    \        self.blue_to_green_nh_dict = {}\n        self.red_to_green_nh_dict =\
    \ {}\n        self.prefix_cost_dict = {}\n        self.pnh_dict = {}\n       \
    \ self.alt_dict = {}\n        self.init_new_computing_router()\n    def init_new_computing_router(self):\n\
    \        self.island_intf_list = []\n        self.IN_MRT_ISLAND = False\n    \
    \    self.IN_GADAG = False\n        self.dfs_number = None\n        self.dfs_parent\
    \ = None\n        self.dfs_parent_intf = None\n        self.dfs_child_list = []\n\
    \        self.lowpoint_number = None\n        self.lowpoint_parent = None\n  \
    \      self.lowpoint_parent_intf = None\n        self.localroot = None\n     \
    \   self.block_id = None\n        self.IS_CUT_VERTEX = False\n        self.blue_next_hops\
    \ = []\n        self.red_next_hops = []\n        self.primary_next_hops = []\n\
    \        self.alt_list = []\n"
- title: 'class Interface:'
  contents:
  - "class Interface:\n    def __init__(self):\n        self.metric = None\n     \
    \   self.area = None\n        self.MRT_INELIGIBLE = False\n        self.IGP_EXCLUDED\
    \ = False\n        self.SIMULATION_OUTGOING = False\n        self.init_new_computing_router()\n\
    \    def init_new_computing_router(self):\n        self.UNDIRECTED = True\n  \
    \      self.INCOMING = False\n        self.OUTGOING = False\n        self.INCOMING_STORED\
    \ = False\n        self.OUTGOING_STORED = False\n        self.IN_MRT_ISLAND =\
    \ False\n        self.PROCESSED = False\n"
- title: 'class Bundle:'
  contents:
  - "class Bundle:\n    def __init__(self):\n        self.UNDIRECTED = True\n    \
    \    self.OUTGOING = False\n        self.INCOMING = False\n"
- title: 'class Alternate:'
  contents:
  - "class Alternate:\n    def __init__(self):\n        self.failed_intf = None\n\
    \        self.red_or_blue = None\n        self.nh_list = []\n        self.fec\
    \ = 'NO_ALTERNATE'\n        self.prot = 'NO_PROTECTION'\n        self.info = 'NONE'\n"
- title: 'class Proxy_Node_Attachment_Router:'
  contents:
  - "class Proxy_Node_Attachment_Router:\n    def __init__(self):\n        self.prefix\
    \ = None\n        self.node = None\n        self.named_proxy_cost = None\n   \
    \     self.min_lfin = None\n        self.nh_intf_list = []\n"
- title: 'class Named_Proxy_Node:'
  contents:
  - "class Named_Proxy_Node:\n    def __init__(self):\n        self.node_id = None\
    \  #this is the prefix_id\n        self.node_prefix_cost_list = []\n        self.lfin_list\
    \ = []\n        self.pnar1 = None\n        self.pnar2 = None\n        self.pnar_X\
    \ = None\n        self.pnar_Y = None\n        self.blue_next_hops = []\n     \
    \   self.red_next_hops = []\n        self.primary_next_hops = []\n        self.blue_next_hops_dict\
    \ = {}\n        self.red_next_hops_dict = {}\n        self.pnh_dict = {}\n   \
    \     self.alt_dict = {}\n"
- title: 'def Interface_Compare(intf_a, intf_b):'
  contents:
  - "def Interface_Compare(intf_a, intf_b):\n    if intf_a.metric < intf_b.metric:\n\
    \        return -1\n    if intf_b.metric < intf_a.metric:\n        return 1\n\
    \    if intf_a.remote_node.node_id < intf_b.remote_node.node_id:\n        return\
    \ -1\n    if intf_b.remote_node.node_id < intf_a.remote_node.node_id:\n      \
    \  return 1\n    return 0\n"
- title: 'def Sort_Interfaces(topo):'
  contents:
  - "def Sort_Interfaces(topo):\n    for node in topo.island_node_list:\n        node.island_intf_list.sort(Interface_Compare)\n"
- title: 'def Reset_Computed_Node_and_Intf_Values(topo):'
  contents:
  - "def Reset_Computed_Node_and_Intf_Values(topo):\n    topo.init_new_computing_router()\n\
    \    for node in topo.node_list:\n        node.init_new_computing_router()\n \
    \       for intf in node.intf_list:\n            intf.init_new_computing_router()\n"
- title: '# This function takes a file with links represented by 2-digit'
  contents:
  - '# This function takes a file with links represented by 2-digit

    '
- title: '# numbers in the format:'
  contents:
  - '# numbers in the format:

    '
- title: '# 01,05,10'
  contents:
  - '# 01,05,10

    '
- title: '# 05,02,30'
  contents:
  - '# 05,02,30

    '
- title: '# 02,01,15'
  contents:
  - '# 02,01,15

    '
- title: '# which represents a triangle topology with nodes 01, 05, and 02'
  contents:
  - '# which represents a triangle topology with nodes 01, 05, and 02

    '
- title: '# and symmetric metrics of 10, 30, and 15.'
  contents:
  - '# and symmetric metrics of 10, 30, and 15.

    '
- title: '# Inclusion of a fourth column makes the metrics for the link'
  contents:
  - '# Inclusion of a fourth column makes the metrics for the link

    '
- title: '# asymmetric.  An entry of:'
  contents:
  - '# asymmetric.  An entry of:

    '
- title: '# 02,07,10,15'
  contents:
  - '# 02,07,10,15

    '
- title: '# creates a link from node 02 to 07 with metrics 10 and 15.'
  contents:
  - '# creates a link from node 02 to 07 with metrics 10 and 15.

    '
- title: 'def Create_Topology_From_File(filename):'
  contents:
  - "def Create_Topology_From_File(filename):\n    topo = Topology()\n    node_id_set=\
    \ set()\n    cols_list = []\n    # on first pass just create nodes\n    with open(filename\
    \ + '.csv') as topo_file:\n        for line in topo_file:\n            line =\
    \ line.rstrip('\\r\\n')\n            cols=line.split(',')\n            cols_list.append(cols)\n\
    \            nodea_node_id = int(cols[0])\n            nodeb_node_id = int(cols[1])\n\
    \            if (nodea_node_id > 999 or nodeb_node_id > 999):\n              \
    \  print(\"node_id must be between 0 and 999.\")\n                print(\"exiting.\"\
    )\n                exit()\n            node_id_set.add(nodea_node_id)\n      \
    \      node_id_set.add(nodeb_node_id)\n    for node_id in node_id_set:\n     \
    \   node = Node()\n        node.node_id = node_id\n        topo.node_list.append(node)\n\
    \        topo.node_dict[node_id] = node\n    # on second pass create interfaces\n\
    \    for cols in cols_list:\n        nodea_node_id = int(cols[0])\n        nodeb_node_id\
    \ = int(cols[1])\n        metric = int(cols[2])\n        reverse_metric = int(cols[2])\n\
    \        if len(cols) > 3:\n            reverse_metric=int(cols[3])\n        nodea\
    \ = topo.node_dict[nodea_node_id]\n        nodeb = topo.node_dict[nodeb_node_id]\n\
    \        nodea_intf = Interface()\n        nodea_intf.metric = metric\n      \
    \  nodea_intf.area = 0\n        nodeb_intf = Interface()\n        nodeb_intf.metric\
    \ = reverse_metric\n        nodeb_intf.area = 0\n        nodea_intf.remote_intf\
    \ = nodeb_intf\n        nodeb_intf.remote_intf = nodea_intf\n        nodea_intf.remote_node\
    \ = nodeb\n        nodeb_intf.remote_node = nodea\n        nodea_intf.local_node\
    \ = nodea\n        nodeb_intf.local_node = nodeb\n        nodea_intf.link_data\
    \ = len(nodea.intf_list)\n        nodeb_intf.link_data = len(nodeb.intf_list)\n\
    \        nodea.intf_list.append(nodea_intf)\n        nodeb.intf_list.append(nodeb_intf)\n\
    \    return topo\n"
- title: 'def MRT_Island_Identification(topo, computing_rtr, profile_id, area):'
  contents:
  - "def MRT_Island_Identification(topo, computing_rtr, profile_id, area):\n   if\
    \ profile_id in computing_rtr.profile_id_list:\n       computing_rtr.IN_MRT_ISLAND\
    \ = True\n       explore_list = [computing_rtr]\n   else:\n       return\n   while\
    \ explore_list != []:\n       next_rtr = explore_list.pop()\n       for intf in\
    \ next_rtr.intf_list:\n           if ( (not intf.IN_MRT_ISLAND)\n            \
    \    and (not intf.MRT_INELIGIBLE)\n                and (not intf.remote_intf.MRT_INELIGIBLE)\n\
    \                and (not intf.IGP_EXCLUDED) and intf.area == area\n         \
    \       and (profile_id in intf.remote_node.profile_id_list)):\n             \
    \   intf.IN_MRT_ISLAND = True\n                intf.remote_intf.IN_MRT_ISLAND\
    \ = True\n                if (not intf.remote_node.IN_MRT_ISLAND):\n         \
    \           intf.remote_INTF.IN_MRT_ISLAND = True\n                    explore_list.append(intf.remote_node)\n"
- title: 'def Compute_Island_Node_List_For_Test_GR(topo, test_gr):'
  contents:
  - "def Compute_Island_Node_List_For_Test_GR(topo, test_gr):\n    Reset_Computed_Node_and_Intf_Values(topo)\n\
    \    topo.test_gr = topo.node_dict[test_gr]\n    MRT_Island_Identification(topo,\
    \ topo.test_gr, 0, 0)\n    for node in topo.node_list:\n        if node.IN_MRT_ISLAND:\n\
    \            topo.island_node_list_for_test_gr.append(node)\n"
- title: 'def Set_Island_Intf_and_Node_Lists(topo):'
  contents:
  - "def Set_Island_Intf_and_Node_Lists(topo):\n    for node in topo.node_list:\n\
    \        if node.IN_MRT_ISLAND:\n            topo.island_node_list.append(node)\n\
    \            for intf in node.intf_list:\n                if intf.IN_MRT_ISLAND:\n\
    \                    node.island_intf_list.append(intf)\n"
- title: global_dfs_number = None
  contents:
  - 'global_dfs_number = None

    '
- title: 'def Lowpoint_Visit(x, parent, intf_p_to_x):'
  contents:
  - "def Lowpoint_Visit(x, parent, intf_p_to_x):\n    global global_dfs_number\n \
    \   x.dfs_number = global_dfs_number\n    x.lowpoint_number = x.dfs_number\n \
    \   global_dfs_number += 1\n    x.dfs_parent = parent\n    if intf_p_to_x == None:\n\
    \        x.dfs_parent_intf = None\n    else:\n        x.dfs_parent_intf = intf_p_to_x.remote_intf\n\
    \    x.lowpoint_parent = None\n    if parent != None:\n        parent.dfs_child_list.append(x)\n\
    \    for intf in x.island_intf_list:\n        if intf.remote_node.dfs_number ==\
    \ None:\n            Lowpoint_Visit(intf.remote_node, x, intf)\n            if\
    \ intf.remote_node.lowpoint_number < x.lowpoint_number:\n                x.lowpoint_number\
    \ = intf.remote_node.lowpoint_number\n                x.lowpoint_parent = intf.remote_node\n\
    \                x.lowpoint_parent_intf = intf\n        else:\n            if\
    \ intf.remote_node is not parent:\n                if intf.remote_node.dfs_number\
    \ < x.lowpoint_number:\n                    x.lowpoint_number = intf.remote_node.dfs_number\n\
    \                    x.lowpoint_parent = intf.remote_node\n                  \
    \  x.lowpoint_parent_intf = intf\n"
- title: 'def Run_Lowpoint(topo):'
  contents:
  - "def Run_Lowpoint(topo):\n    global global_dfs_number\n    global_dfs_number\
    \ = 0\n    Lowpoint_Visit(topo.gadag_root, None, None)\n"
- title: max_block_id = None
  contents:
  - 'max_block_id = None

    '
- title: 'def Assign_Block_ID(x, cur_block_id):'
  contents:
  - "def Assign_Block_ID(x, cur_block_id):\n    global max_block_id\n    x.block_id\
    \ = cur_block_id\n    for c in x.dfs_child_list:\n        if (c.localroot is x):\n\
    \            max_block_id += 1\n            Assign_Block_ID(c, max_block_id)\n\
    \        else:\n            Assign_Block_ID(c, cur_block_id)\n"
- title: 'def Run_Assign_Block_ID(topo):'
  contents:
  - "def Run_Assign_Block_ID(topo):\n    global max_block_id\n    max_block_id = 0\n\
    \    Assign_Block_ID(topo.gadag_root, max_block_id)\n"
- title: 'def Construct_Ear(x, stack, intf, ear_type):'
  contents:
  - "def Construct_Ear(x, stack, intf, ear_type):\n    ear_list = []\n    cur_intf\
    \ = intf\n    not_done = True\n    while not_done:\n        cur_intf.UNDIRECTED\
    \ = False\n        cur_intf.OUTGOING = True\n        cur_intf.remote_intf.UNDIRECTED\
    \ = False\n        cur_intf.remote_intf.INCOMING = True\n        if cur_intf.remote_node.IN_GADAG\
    \ == False:\n            cur_intf.remote_node.IN_GADAG = True\n            ear_list.append(cur_intf.remote_node)\n\
    \            if ear_type == 'CHILD':\n                cur_intf = cur_intf.remote_node.lowpoint_parent_intf\n\
    \            else:\n                assert ear_type == 'NEIGHBOR'\n          \
    \      cur_intf = cur_intf.remote_node.dfs_parent_intf\n        else:\n      \
    \      not_done = False\n    if ear_type == 'CHILD' and cur_intf.remote_node is\
    \ x:\n        # x is a cut-vertex and the local root for the block\n        #\
    \ in which the ear is computed\n        x.IS_CUT_VERTEX = True\n        localroot\
    \ = x\n    else:\n        # inherit local root from the end of the ear\n     \
    \   localroot = cur_intf.remote_node.localroot\n    while ear_list != []:\n  \
    \      y = ear_list.pop()\n        y.localroot = localroot\n        stack.append(y)\n"
- title: 'def Construct_GADAG_via_Lowpoint(topo):'
  contents:
  - "def Construct_GADAG_via_Lowpoint(topo):\n    gadag_root = topo.gadag_root\n \
    \   gadag_root.IN_GADAG = True\n    gadag_root.localroot = None\n    stack = []\n\
    \    stack.append(gadag_root)\n    while stack != []:\n        x = stack.pop()\n\
    \        for intf in x.island_intf_list:\n            if ( intf.remote_node.IN_GADAG\
    \ == False\n                 and intf.remote_node.dfs_parent is x ):\n       \
    \         Construct_Ear(x, stack, intf, 'CHILD' )\n        for intf in x.island_intf_list:\n\
    \            if (intf.remote_node.IN_GADAG == False\n                and intf.remote_node.dfs_parent\
    \ is not x):\n                Construct_Ear(x, stack, intf, 'NEIGHBOR')\n"
- title: 'def Assign_Remaining_Lowpoint_Parents(topo):'
  contents:
  - "def Assign_Remaining_Lowpoint_Parents(topo):\n    for node in topo.island_node_list:\n\
    \        if ( node is not topo.gadag_root\n            and node.lowpoint_parent\
    \ == None ):\n            node.lowpoint_parent = node.dfs_parent\n           \
    \ node.lowpoint_parent_intf = node.dfs_parent_intf\n            node.lowpoint_number\
    \ = node.dfs_parent.dfs_number\n"
- title: 'def Add_Undirected_Block_Root_Links(topo):'
  contents:
  - "def Add_Undirected_Block_Root_Links(topo):\n    for node in topo.island_node_list:\n\
    \        if node.IS_CUT_VERTEX or node is topo.gadag_root:\n            for intf\
    \ in node.island_intf_list:\n                if ( intf.remote_node.localroot is\
    \ not node\n                     or intf.PROCESSED ):\n                    continue\n\
    \                bundle_list = []\n                bundle = Bundle()\n       \
    \         for intf2 in node.island_intf_list:\n                    if intf2.remote_node\
    \ is intf.remote_node:\n                        bundle_list.append(intf2)\n  \
    \                      if not intf2.UNDIRECTED:\n                            bundle.UNDIRECTED\
    \ = False\n                            if intf2.INCOMING:\n                  \
    \              bundle.INCOMING = True\n                            if intf2.OUTGOING:\n\
    \                                bundle.OUTGOING = True\n                if bundle.UNDIRECTED:\n\
    \                    for intf3 in bundle_list:\n                        intf3.UNDIRECTED\
    \ = False\n                        intf3.remote_intf.UNDIRECTED = False\n    \
    \                    intf3.PROCESSED = True\n                        intf3.remote_intf.PROCESSED\
    \ = True\n                        intf3.OUTGOING = True\n                    \
    \    intf3.remote_intf.INCOMING = True\n                else:\n              \
    \      if (bundle.OUTGOING and bundle.INCOMING):\n                        for\
    \ intf3 in bundle_list:\n                            intf3.UNDIRECTED = False\n\
    \                            intf3.remote_intf.UNDIRECTED = False\n          \
    \                  intf3.PROCESSED = True\n                            intf3.remote_intf.PROCESSED\
    \ = True\n                            intf3.OUTGOING = True\n                \
    \            intf3.INCOMING = True\n                            intf3.remote_intf.INCOMING\
    \ = True\n                            intf3.remote_intf.OUTGOING = True\n    \
    \                elif bundle.OUTGOING:\n                        for intf3 in bundle_list:\n\
    \                            intf3.UNDIRECTED = False\n                      \
    \      intf3.remote_intf.UNDIRECTED = False\n                            intf3.PROCESSED\
    \ = True\n                            intf3.remote_intf.PROCESSED = True\n   \
    \                         intf3.OUTGOING = True\n                            intf3.remote_intf.INCOMING\
    \ = True\n                    elif bundle.INCOMING:\n                        for\
    \ intf3 in bundle_list:\n                            intf3.UNDIRECTED = False\n\
    \                            intf3.remote_intf.UNDIRECTED = False\n          \
    \                  intf3.PROCESSED = True\n                            intf3.remote_intf.PROCESSED\
    \ = True\n                            intf3.INCOMING = True\n                \
    \            intf3.remote_intf.OUTGOING = True\n"
- title: 'def Modify_Block_Root_Incoming_Links(topo):'
  contents:
  - "def Modify_Block_Root_Incoming_Links(topo):\n    for node in topo.island_node_list:\n\
    \        if ( node.IS_CUT_VERTEX == True or node is topo.gadag_root ):\n     \
    \       for intf in node.island_intf_list:\n                if intf.remote_node.localroot\
    \ is node:\n                    if intf.INCOMING:\n                        intf.INCOMING\
    \ = False\n                        intf.INCOMING_STORED = True\n             \
    \           intf.remote_intf.OUTGOING = False\n                        intf.remote_intf.OUTGOING_STORED\
    \ = True\n"
- title: 'def Revert_Block_Root_Incoming_Links(topo):'
  contents:
  - "def Revert_Block_Root_Incoming_Links(topo):\n    for node in topo.island_node_list:\n\
    \        if ( node.IS_CUT_VERTEX == True or node is topo.gadag_root ):\n     \
    \       for intf in node.island_intf_list:\n                if intf.remote_node.localroot\
    \ is node:\n                    if intf.INCOMING_STORED:\n                   \
    \     intf.INCOMING = True\n                        intf.remote_intf.OUTGOING\
    \ = True\n                        intf.INCOMING_STORED = False\n             \
    \           intf.remote_intf.OUTGOING_STORED = False\n"
- title: 'def Run_Topological_Sort_GADAG(topo):'
  contents:
  - "def Run_Topological_Sort_GADAG(topo):\n    Modify_Block_Root_Incoming_Links(topo)\n\
    \    for node in topo.island_node_list:\n        node.unvisited = 0\n        for\
    \ intf in node.island_intf_list:\n            if (intf.INCOMING == True):\n  \
    \              node.unvisited += 1\n    working_list = []\n    topo_order_list\
    \ = []\n    working_list.append(topo.gadag_root)\n    while working_list != []:\n\
    \        y = working_list.pop(0)\n        topo_order_list.append(y)\n        for\
    \ intf in y.island_intf_list:\n            if ( intf.OUTGOING == True):\n    \
    \            intf.remote_node.unvisited -= 1\n                if intf.remote_node.unvisited\
    \ == 0:\n                    working_list.append(intf.remote_node)\n    next_topo_order\
    \ = 1\n    while topo_order_list != []:\n        y = topo_order_list.pop(0)\n\
    \        y.topo_order = next_topo_order\n        next_topo_order += 1\n    Revert_Block_Root_Incoming_Links(topo)\n"
- title: 'def Set_Other_Undirected_Links_Based_On_Topo_Order(topo):'
  contents:
  - "def Set_Other_Undirected_Links_Based_On_Topo_Order(topo):\n    for node in topo.island_node_list:\n\
    \        for intf in node.island_intf_list:\n            if intf.UNDIRECTED:\n\
    \                if node.topo_order < intf.remote_node.topo_order:\n         \
    \           intf.OUTGOING = True\n                    intf.UNDIRECTED = False\n\
    \                    intf.remote_intf.INCOMING = True\n                    intf.remote_intf.UNDIRECTED\
    \ = False\n                else:\n                    intf.INCOMING = True\n \
    \                   intf.UNDIRECTED = False\n                    intf.remote_intf.OUTGOING\
    \ = True\n                    intf.remote_intf.UNDIRECTED = False\n"
- title: 'def Initialize_Temporary_Interface_Flags(topo):'
  contents:
  - "def Initialize_Temporary_Interface_Flags(topo):\n    for node in topo.island_node_list:\n\
    \        for intf in node.island_intf_list:\n            intf.PROCESSED = False\n\
    \            intf.INCOMING_STORED = False\n            intf.OUTGOING_STORED =\
    \ False\n"
- title: 'def Add_Undirected_Links(topo):'
  contents:
  - "def Add_Undirected_Links(topo):\n    Initialize_Temporary_Interface_Flags(topo)\n\
    \    Add_Undirected_Block_Root_Links(topo)\n    Run_Topological_Sort_GADAG(topo)\n\
    \    Set_Other_Undirected_Links_Based_On_Topo_Order(topo)\n"
- title: 'def In_Common_Block(x,y):'
  contents:
  - "def In_Common_Block(x,y):\n    if (  (x.block_id == y.block_id)\n          or\
    \ ( x is y.localroot) or (y is x.localroot) ):\n        return True\n    return\
    \ False\n"
- title: 'def Copy_List_Items(target_list, source_list):'
  contents:
  - "def Copy_List_Items(target_list, source_list):\n    del target_list[:] # Python\
    \ idiom to remove all elements of a list\n    for element in source_list:\n  \
    \      target_list.append(element)\n"
- title: 'def Add_Item_To_List_If_New(target_list, item):'
  contents:
  - "def Add_Item_To_List_If_New(target_list, item):\n    if item not in target_list:\n\
    \        target_list.append(item)\n"
- title: 'def Store_Results(y, direction):'
  contents:
  - "def Store_Results(y, direction):\n    if direction == 'INCREASING':\n       \
    \ y.HIGHER = True\n        Copy_List_Items(y.blue_next_hops, y.next_hops)\n  \
    \  if direction == 'DECREASING':\n        y.LOWER = True\n        Copy_List_Items(y.red_next_hops,\
    \ y.next_hops)\n    if direction == 'NORMAL_SPF':\n        y.primary_spf_metric\
    \ = y.spf_metric\n        Copy_List_Items(y.primary_next_hops, y.next_hops)\n\
    \    if direction == 'MRT_ISLAND_SPF':\n        Copy_List_Items(y.mrt_island_next_hops,\
    \ y.next_hops)\n    if direction == 'COLLAPSED_SPF':\n        y.collapsed_metric\
    \ = y.spf_metric\n        Copy_List_Items(y.collapsed_next_hops, y.next_hops)\n"
- title: '# Note that the Python heapq function allows for duplicate items,'
  contents:
  - '# Note that the Python heapq function allows for duplicate items,

    '
- title: '# so we use the ''spf_visited'' property to only consider a node'
  contents:
  - '# so we use the ''spf_visited'' property to only consider a node

    '
- title: '# as min_node the first time it gets removed from the heap.'
  contents:
  - '# as min_node the first time it gets removed from the heap.

    '
- title: 'def SPF_No_Traverse_Block_Root(topo, spf_root, block_root, direction):'
  contents:
  - "def SPF_No_Traverse_Block_Root(topo, spf_root, block_root, direction):\n    spf_heap\
    \ = []\n    for y in topo.island_node_list:\n        y.spf_metric = 2147483647\
    \ # 2^31-1\n        y.next_hops = []\n        y.spf_visited = False\n    spf_root.spf_metric\
    \ = 0\n    heapq.heappush(spf_heap,\n                   (spf_root.spf_metric,\
    \ spf_root.node_id,  spf_root) )\n    while spf_heap != []:\n        #extract\
    \ third element of tuple popped from heap\n        min_node = heapq.heappop(spf_heap)[2]\n\
    \        if min_node.spf_visited:\n            continue\n        min_node.spf_visited\
    \ = True\n        Store_Results(min_node, direction)\n        if ( (min_node is\
    \ spf_root) or (min_node is not block_root) ):\n            for intf in min_node.island_intf_list:\n\
    \                if ( ( (direction == 'INCREASING' and intf.OUTGOING )\n     \
    \               or (direction == 'DECREASING' and intf.INCOMING ) )\n        \
    \            and In_Common_Block(spf_root, intf.remote_node) ) :\n           \
    \         path_metric = min_node.spf_metric + intf.metric\n                  \
    \  if path_metric < intf.remote_node.spf_metric:\n                        intf.remote_node.spf_metric\
    \ = path_metric\n                        if min_node is spf_root:\n          \
    \                  intf.remote_node.next_hops = [intf]\n                     \
    \   else:\n                            Copy_List_Items(intf.remote_node.next_hops,\n\
    \                                            min_node.next_hops)\n           \
    \             heapq.heappush(spf_heap,\n                                     \
    \  ( intf.remote_node.spf_metric,\n                                         intf.remote_node.node_id,\n\
    \                                         intf.remote_node ) )\n             \
    \       elif path_metric == intf.remote_node.spf_metric:\n                   \
    \     if min_node is spf_root:\n                            Add_Item_To_List_If_New(\n\
    \                                intf.remote_node.next_hops,intf)\n          \
    \              else:\n                            for nh_intf in min_node.next_hops:\n\
    \                                Add_Item_To_List_If_New(\n                  \
    \                  intf.remote_node.next_hops,nh_intf)\n"
- title: 'def Normal_SPF(topo, spf_root):'
  contents:
  - "def Normal_SPF(topo, spf_root):\n    spf_heap = []\n    for y in topo.node_list:\n\
    \        y.spf_metric = 2147483647 # 2^31-1 as max metric\n        y.next_hops\
    \ = []\n        y.primary_spf_metric = 2147483647\n        y.primary_next_hops\
    \ = []\n        y.spf_visited = False\n    spf_root.spf_metric = 0\n    heapq.heappush(spf_heap,\n\
    \                   (spf_root.spf_metric,spf_root.node_id,spf_root) )\n    while\
    \ spf_heap != []:\n        #extract third element of tuple popped from heap\n\
    \        min_node = heapq.heappop(spf_heap)[2]\n        if min_node.spf_visited:\n\
    \            continue\n        min_node.spf_visited = True\n        Store_Results(min_node,\
    \ 'NORMAL_SPF')\n        for intf in min_node.intf_list:\n            path_metric\
    \ = min_node.spf_metric + intf.metric\n            if path_metric < intf.remote_node.spf_metric:\n\
    \                intf.remote_node.spf_metric = path_metric\n                if\
    \ min_node is spf_root:\n                    intf.remote_node.next_hops = [intf]\n\
    \                else:\n                    Copy_List_Items(intf.remote_node.next_hops,\n\
    \                                    min_node.next_hops)\n                heapq.heappush(spf_heap,\n\
    \                               ( intf.remote_node.spf_metric,\n             \
    \                    intf.remote_node.node_id,\n                             \
    \    intf.remote_node ) )\n            elif path_metric == intf.remote_node.spf_metric:\n\
    \                if min_node is spf_root:\n                    Add_Item_To_List_If_New(\n\
    \                        intf.remote_node.next_hops,intf)\n                else:\n\
    \                    for nh_intf in min_node.next_hops:\n                    \
    \    Add_Item_To_List_If_New(\n                            intf.remote_node.next_hops,nh_intf)\n"
- title: 'def Set_Edge(y):'
  contents:
  - "def Set_Edge(y):\n    if (y.blue_next_hops == [] and y.red_next_hops == []):\n\
    \        Set_Edge(y.localroot)\n        Copy_List_Items(y.blue_next_hops,y.localroot.blue_next_hops)\n\
    \        Copy_List_Items(y.red_next_hops ,y.localroot.red_next_hops)\n       \
    \ y.order_proxy = y.localroot.order_proxy\n"
- title: 'def Compute_MRT_NH_For_One_Src_To_Island_Dests(topo,x):'
  contents:
  - "def Compute_MRT_NH_For_One_Src_To_Island_Dests(topo,x):\n    for y in topo.island_node_list:\n\
    \        y.HIGHER = False\n        y.LOWER = False\n        y.red_next_hops =\
    \ []\n        y.blue_next_hops = []\n        y.order_proxy = y\n    SPF_No_Traverse_Block_Root(topo,\
    \ x, x.localroot, 'INCREASING')\n    SPF_No_Traverse_Block_Root(topo, x, x.localroot,\
    \ 'DECREASING')\n    for y in topo.island_node_list:\n        if ( y is not x\
    \ and (y.block_id == x.block_id) ):\n            assert (not ( y is x.localroot\
    \ or x is y.localroot) )\n            assert(not (y.HIGHER and y.LOWER) )\n  \
    \          if y.HIGHER == True:\n                Copy_List_Items(y.red_next_hops,\n\
    \                                x.localroot.red_next_hops)\n            elif\
    \ y.LOWER == True:\n                Copy_List_Items(y.blue_next_hops,\n      \
    \                          x.localroot.blue_next_hops)\n            else:\n  \
    \              Copy_List_Items(y.blue_next_hops,\n                           \
    \     x.localroot.red_next_hops)\n                Copy_List_Items(y.red_next_hops,\n\
    \                                x.localroot.blue_next_hops)\n    # Inherit x's\
    \ MRT next hops to reach the GADAG root\n    # from x's MRT next hops to reach\
    \ its local root,\n    # but first check if x is the gadag_root (in which case\n\
    \    # x does not have a local root) or if x's local root\n    # is the gadag\
    \ root (in which case we already have the\n    # x's MRT next hops to reach the\
    \ gadag root)\n    if x is not topo.gadag_root and x.localroot is not topo.gadag_root:\n\
    \        Copy_List_Items(topo.gadag_root.blue_next_hops,\n                   \
    \     x.localroot.blue_next_hops)\n        Copy_List_Items(topo.gadag_root.red_next_hops,\n\
    \                        x.localroot.red_next_hops)\n        topo.gadag_root.order_proxy\
    \ = x.localroot\n    # Inherit next hops and order_proxies to other blocks\n \
    \   for y in topo.island_node_list:\n        if (y is not topo.gadag_root and\
    \ y is not x ):\n            Set_Edge(y)\n"
- title: 'def Store_MRT_Nexthops_For_One_Src_To_Island_Dests(topo,x):'
  contents:
  - "def Store_MRT_Nexthops_For_One_Src_To_Island_Dests(topo,x):\n    for y in topo.island_node_list:\n\
    \        if y is x:\n            continue\n        x.blue_next_hops_dict[y.node_id]\
    \ = []\n        x.red_next_hops_dict[y.node_id] = []\n        Copy_List_Items(x.blue_next_hops_dict[y.node_id],\n\
    \                        y.blue_next_hops)\n        Copy_List_Items(x.red_next_hops_dict[y.node_id],\n\
    \                        y.red_next_hops)\n"
- title: 'def Store_Primary_and_Alts_For_One_Src_To_Island_Dests(topo,x):'
  contents:
  - "def Store_Primary_and_Alts_For_One_Src_To_Island_Dests(topo,x):\n    for y in\
    \ topo.island_node_list:\n        x.pnh_dict[y.node_id] = []\n        Copy_List_Items(x.pnh_dict[y.node_id],\
    \ y.primary_next_hops)\n        x.alt_dict[y.node_id] = []\n        Copy_List_Items(x.alt_dict[y.node_id],\
    \ y.alt_list)\n"
- title: 'def Store_Primary_NHs_For_One_Source_To_Nodes(topo,x):'
  contents:
  - "def Store_Primary_NHs_For_One_Source_To_Nodes(topo,x):\n    for y in topo.node_list:\n\
    \        x.pnh_dict[y.node_id] = []\n        Copy_List_Items(x.pnh_dict[y.node_id],\
    \ y.primary_next_hops)\n"
- title: 'def Store_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,x):'
  contents:
  - "def Store_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,x):\n    for prefix in\
    \ topo.named_proxy_dict:\n        P = topo.named_proxy_dict[prefix]\n        x.blue_next_hops_dict[P.node_id]\
    \ = []\n        x.red_next_hops_dict[P.node_id] = []\n        Copy_List_Items(x.blue_next_hops_dict[P.node_id],\n\
    \                        P.blue_next_hops)\n        Copy_List_Items(x.red_next_hops_dict[P.node_id],\n\
    \                        P.red_next_hops)\n"
- title: 'def Store_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,x):'
  contents:
  - "def Store_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,x):\n    for prefix in topo.named_proxy_dict:\n\
    \        P = topo.named_proxy_dict[prefix]\n        x.alt_dict[P.node_id] = []\n\
    \        Copy_List_Items(x.alt_dict[P.node_id],\n                        P.alt_list)\n"
- title: 'def Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,x):'
  contents:
  - "def Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,x):\n    for prefix\
    \ in topo.named_proxy_dict:\n        P = topo.named_proxy_dict[prefix]\n     \
    \   x.pnh_dict[P.node_id] = []\n        Copy_List_Items(x.pnh_dict[P.node_id],\n\
    \                        P.primary_next_hops)\n"
- title: def Select_Alternates_Internal(D, F, primary_intf,
  contents:
  - "def Select_Alternates_Internal(D, F, primary_intf,\n                        \
    \       D_lower, D_higher, D_topo_order):\n    if D_higher and D_lower:\n    \
    \    if F.HIGHER and F.LOWER:\n            if F.topo_order > D_topo_order:\n \
    \               return 'USE_BLUE'\n            else:\n                return 'USE_RED'\n\
    \        if F.HIGHER:\n            return 'USE_RED'\n        if F.LOWER:\n   \
    \         return 'USE_BLUE'\n        assert(primary_intf.MRT_INELIGIBLE\n    \
    \           or primary_intf.remote_intf.MRT_INELIGIBLE)\n        return 'USE_RED_OR_BLUE'\n\
    \    if D_higher:\n        if F.HIGHER and F.LOWER:\n            return 'USE_BLUE'\n\
    \        if F.LOWER:\n            return 'USE_BLUE'\n        if F.HIGHER:\n  \
    \          if (F.topo_order > D_topo_order):\n                return 'USE_BLUE'\n\
    \            if (F.topo_order < D_topo_order):\n                return 'USE_RED'\n\
    \            assert(False)\n        assert(primary_intf.MRT_INELIGIBLE\n     \
    \          or primary_intf.remote_intf.MRT_INELIGIBLE)\n        return 'USE_RED_OR_BLUE'\n\
    \    if D_lower:\n        if F.HIGHER and F.LOWER:\n            return 'USE_RED'\n\
    \        if F.HIGHER:\n            return 'USE_RED'\n        if F.LOWER:\n   \
    \         if F.topo_order > D_topo_order:\n                return 'USE_BLUE'\n\
    \            if F.topo_order < D_topo_order:\n                return 'USE_RED'\n\
    \            assert(False)\n        assert(primary_intf.MRT_INELIGIBLE\n     \
    \          or primary_intf.remote_intf.MRT_INELIGIBLE)\n        return 'USE_RED_OR_BLUE'\n\
    \    else: # D is unordered wrt S\n        if F.HIGHER and F.LOWER:\n        \
    \    if primary_intf.OUTGOING and primary_intf.INCOMING:\n                # This\
    \ can happen when F and D are in different blocks\n                return 'USE_RED_OR_BLUE'\n\
    \            if primary_intf.OUTGOING:\n                return 'USE_BLUE'\n  \
    \          if primary_intf.INCOMING:\n                return 'USE_RED'\n     \
    \       #This can occur when primary_intf is MRT_INELIGIBLE.\n            #This\
    \ appears to be a case where the special\n            #construction of the GADAG\
    \ allows us to choose red,\n            #whereas with an arbitrary GADAG, neither\
    \ red nor blue\n            #is guaranteed to work.\n            assert(primary_intf.MRT_INELIGIBLE\n\
    \                   or primary_intf.remote_intf.MRT_INELIGIBLE)\n            return\
    \ 'USE_RED'\n        if F.LOWER:\n            return 'USE_RED'\n        if F.HIGHER:\n\
    \            return 'USE_BLUE'\n        assert(primary_intf.MRT_INELIGIBLE\n \
    \              or primary_intf.remote_intf.MRT_INELIGIBLE)\n        if F.topo_order\
    \ > D_topo_order:\n            return 'USE_BLUE'\n        else:\n            return\
    \ 'USE_RED'\n"
- title: 'def Select_Alternates(D, F, primary_intf):'
  contents:
  - "def Select_Alternates(D, F, primary_intf):\n    S = primary_intf.local_node\n\
    \    if not In_Common_Block(F, S):\n        return 'PRIM_NH_IN_DIFFERENT_BLOCK'\n\
    \    if (D is F) or (D.order_proxy is F):\n        return 'PRIM_NH_IS_D_OR_OP_FOR_D'\n\
    \    D_lower = D.order_proxy.LOWER\n    D_higher = D.order_proxy.HIGHER\n    D_topo_order\
    \ = D.order_proxy.topo_order\n    return Select_Alternates_Internal(D, F, primary_intf,\n\
    \                                      D_lower, D_higher, D_topo_order)\n"
- title: 'def Is_Remote_Node_In_NH_List(node, intf_list):'
  contents:
  - "def Is_Remote_Node_In_NH_List(node, intf_list):\n    for intf in intf_list:\n\
    \        if node is intf.remote_node:\n            return True\n    return False\n"
- title: 'def Select_Alts_For_One_Src_To_Island_Dests(topo,x):'
  contents:
  - "def Select_Alts_For_One_Src_To_Island_Dests(topo,x):\n    Normal_SPF(topo, x)\n\
    \    for D in topo.island_node_list:\n        D.alt_list = []\n        if D is\
    \ x:\n            continue\n        for failed_intf in D.primary_next_hops:\n\
    \            alt = Alternate()\n            alt.failed_intf = failed_intf\n  \
    \          cand_alt_list = []\n            F = failed_intf.remote_node\n     \
    \       #We need to test if F is in the island, as opposed\n            #to just\
    \ testing if failed_intf is in island_intf_list,\n            #because failed_intf\
    \ could be marked as MRT_INELIGIBLE.\n            if F in topo.island_node_list:\n\
    \                alt.info = Select_Alternates(D, F, failed_intf)\n           \
    \ else:\n                #The primary next hop is not in the MRT Island.\n   \
    \             #Either red or blue will avoid the primary next hop,\n         \
    \       #because the primary next hop is not even in the\n                #GADAG.\n\
    \                alt.info = 'USE_RED_OR_BLUE'\n            if (alt.info == 'USE_RED_OR_BLUE'):\n\
    \                alt.red_or_blue = random.choice(['USE_RED','USE_BLUE'])\n   \
    \         if (alt.info == 'USE_BLUE'\n                or alt.red_or_blue == 'USE_BLUE'):\n\
    \                Copy_List_Items(alt.nh_list, D.blue_next_hops)\n            \
    \    alt.fec = 'BLUE'\n                alt.prot = 'NODE_PROTECTION'\n        \
    \    if (alt.info == 'USE_RED' or alt.red_or_blue == 'USE_RED'):\n           \
    \     Copy_List_Items(alt.nh_list, D.red_next_hops)\n                alt.fec =\
    \ 'RED'\n                alt.prot = 'NODE_PROTECTION'\n            if (alt.info\
    \ == 'PRIM_NH_IN_DIFFERENT_BLOCK'):\n                alt.fec = 'NO_ALTERNATE'\n\
    \                alt.prot = 'NO_PROTECTION'\n            if (alt.info == 'PRIM_NH_IS_D_OR_OP_FOR_D'):\n\
    \                if failed_intf.OUTGOING and failed_intf.INCOMING:\n         \
    \           # cut-link: if there are parallel cut links, use\n               \
    \     # the link(s) with lowest metric that are not\n                    # primary\
    \ intf or None\n                    cand_alt_list = [None]\n                 \
    \   min_metric = 2147483647\n                    for intf in x.island_intf_list:\n\
    \                        if ( intf is not failed_intf and\n                  \
    \           (intf.remote_node is\n                             failed_intf.remote_node)):\n\
    \                            if intf.metric < min_metric:\n                  \
    \              cand_alt_list = [intf]\n                                min_metric\
    \ = intf.metric\n                            elif intf.metric == min_metric:\n\
    \                                cand_alt_list.append(intf)\n                \
    \    if cand_alt_list != [None]:\n                        alt.fec = 'GREEN'\n\
    \                        alt.prot = 'PARALLEL_CUTLINK'\n                    else:\n\
    \                        alt.fec = 'NO_ALTERNATE'\n                        alt.prot\
    \ = 'NO_PROTECTION'\n                    Copy_List_Items(alt.nh_list, cand_alt_list)\n\
    \                # Is_Remote_Node_In_NH_List() is used, as opposed\n         \
    \       # to just checking if failed_intf is in D.red_next_hops,\n           \
    \     # because failed_intf could be marked as MRT_INELIGIBLE.\n             \
    \   elif Is_Remote_Node_In_NH_List(F, D.red_next_hops):\n                    Copy_List_Items(alt.nh_list,\
    \ D.blue_next_hops)\n                    alt.fec = 'BLUE'\n                  \
    \  alt.prot = 'LINK_PROTECTION'\n                elif Is_Remote_Node_In_NH_List(F,\
    \ D.blue_next_hops):\n                    Copy_List_Items(alt.nh_list, D.red_next_hops)\n\
    \                    alt.fec = 'RED'\n                    alt.prot = 'LINK_PROTECTION'\n\
    \                else:\n                    alt.fec = random.choice(['RED','BLUE'])\n\
    \                    alt.prot = 'LINK_PROTECTION'\n            D.alt_list.append(alt)\n"
- title: 'def Write_GADAG_To_File(topo, file_prefix):'
  contents:
  - "def Write_GADAG_To_File(topo, file_prefix):\n    gadag_edge_list = []\n    for\
    \ node in topo.node_list:\n        for intf in node.intf_list:\n            if\
    \ intf.SIMULATION_OUTGOING:\n                local_node =  \"%04d\" % (intf.local_node.node_id)\n\
    \                remote_node = \"%04d\" % (intf.remote_node.node_id)\n       \
    \         intf_data = \"%03d\" % (intf.link_data)\n                edge_string=(local_node+','+remote_node+','+\n\
    \                             intf_data+'\\n')\n                gadag_edge_list.append(edge_string)\n\
    \    gadag_edge_list.sort();\n    filename = file_prefix + '_gadag.csv'\n    with\
    \ open(filename, 'w') as gadag_file:\n        gadag_file.write('local_node,'\\\
    \n                         'remote_node,local_intf_link_data\\n')\n        for\
    \ edge_string in gadag_edge_list:\n            gadag_file.write(edge_string);\n"
- title: 'def Write_MRTs_For_All_Dests_To_File(topo, color, file_prefix):'
  contents:
  - "def Write_MRTs_For_All_Dests_To_File(topo, color, file_prefix):\n    edge_list\
    \ = []\n    for node in topo.island_node_list_for_test_gr:\n        if color ==\
    \ 'blue':\n            node_next_hops_dict = node.blue_next_hops_dict\n      \
    \  elif color == 'red':\n            node_next_hops_dict = node.red_next_hops_dict\n\
    \        for dest_node_id in node_next_hops_dict:\n            for intf in node_next_hops_dict[dest_node_id]:\n\
    \                gadag_root =  \"%04d\" % (topo.gadag_root.node_id)\n        \
    \        dest_node =  \"%04d\" % (dest_node_id)\n                local_node =\
    \  \"%04d\" % (intf.local_node.node_id)\n                remote_node = \"%04d\"\
    \ % (intf.remote_node.node_id)\n                intf_data = \"%03d\" % (intf.link_data)\n\
    \                edge_string=(gadag_root+','+dest_node+','+local_node+\n     \
    \                          ','+remote_node+','+intf_data+'\\n')\n            \
    \    edge_list.append(edge_string)\n    edge_list.sort()\n    filename = file_prefix\
    \ + '_' + color + '_to_all.csv'\n    with open(filename, 'w') as mrt_file:\n \
    \       mrt_file.write('gadag_root,dest,'\\\n            'local_node,remote_node,link_data\\\
    n')\n        for edge_string in edge_list:\n            mrt_file.write(edge_string);\n"
- title: 'def Write_Both_MRTs_For_All_Dests_To_File(topo, file_prefix):'
  contents:
  - "def Write_Both_MRTs_For_All_Dests_To_File(topo, file_prefix):\n    Write_MRTs_For_All_Dests_To_File(topo,\
    \ 'blue', file_prefix)\n    Write_MRTs_For_All_Dests_To_File(topo, 'red', file_prefix)\n"
- title: 'def Write_Alternates_For_All_Dests_To_File(topo, file_prefix):'
  contents:
  - "def Write_Alternates_For_All_Dests_To_File(topo, file_prefix):\n    edge_list\
    \ = []\n    for x in topo.island_node_list_for_test_gr:\n        for dest_node_id\
    \ in x.alt_dict:\n            alt_list = x.alt_dict[dest_node_id]\n          \
    \  for alt in alt_list:\n                for alt_intf in alt.nh_list:\n      \
    \              gadag_root =  \"%04d\" % (topo.gadag_root.node_id)\n          \
    \          dest_node =  \"%04d\" % (dest_node_id)\n                    prim_local_node\
    \ =  \\\n                        \"%04d\" % (alt.failed_intf.local_node.node_id)\n\
    \                    prim_remote_node = \\\n                        \"%04d\" %\
    \ (alt.failed_intf.remote_node.node_id)\n                    prim_intf_data =\
    \ \\\n                        \"%03d\" % (alt.failed_intf.link_data)\n       \
    \             if alt_intf == None:\n                        alt_local_node = \"\
    None\"\n                        alt_remote_node = \"None\"\n                 \
    \       alt_intf_data = \"None\"\n                    else:\n                \
    \        alt_local_node = \\\n                            \"%04d\" % (alt_intf.local_node.node_id)\n\
    \                        alt_remote_node = \\\n                            \"\
    %04d\" % (alt_intf.remote_node.node_id)\n                        alt_intf_data\
    \ = \\\n                            \"%03d\" % (alt_intf.link_data)\n        \
    \            edge_string = (gadag_root+','+dest_node+','+\n                  \
    \      prim_local_node+','+prim_remote_node+','+\n                        prim_intf_data+','+alt_local_node+','+\n\
    \                        alt_remote_node+','+alt_intf_data+','+\n            \
    \            alt.fec +'\\n')\n                    edge_list.append(edge_string)\n\
    \    edge_list.sort()\n    filename = file_prefix + '_alts_to_all.csv'\n    with\
    \ open(filename, 'w') as alt_file:\n        alt_file.write('gadag_root,dest,'\\\
    \n            'prim_nh.local_node,prim_nh.remote_node,'\\\n            'prim_nh.link_data,alt_nh.local_node,'\\\
    \n            'alt_nh.remote_node,alt_nh.link_data,'\\\n            'alt_nh.fec\\\
    n')\n        for edge_string in edge_list:\n            alt_file.write(edge_string);\n"
- title: 'def Raise_GADAG_Root_Selection_Priority(topo,node_id):'
  contents:
  - "def Raise_GADAG_Root_Selection_Priority(topo,node_id):\n    node = topo.node_dict[node_id]\n\
    \    node.GR_sel_priority = 255\n"
- title: 'def Lower_GADAG_Root_Selection_Priority(topo,node_id):'
  contents:
  - "def Lower_GADAG_Root_Selection_Priority(topo,node_id):\n    node = topo.node_dict[node_id]\n\
    \    node.GR_sel_priority = 128\n"
- title: 'def GADAG_Root_Compare(node_a, node_b):'
  contents:
  - "def GADAG_Root_Compare(node_a, node_b):\n    if (node_a.GR_sel_priority > node_b.GR_sel_priority):\n\
    \        return 1\n    elif (node_a.GR_sel_priority < node_b.GR_sel_priority):\n\
    \        return -1\n    else:\n        if node_a.node_id > node_b.node_id:\n \
    \           return 1\n        elif node_a.node_id < node_b.node_id:\n        \
    \    return -1\n"
- title: 'def Set_GADAG_Root(topo,computing_router):'
  contents:
  - "def Set_GADAG_Root(topo,computing_router):\n    gadag_root_list = []\n    for\
    \ node in topo.island_node_list:\n        gadag_root_list.append(node)\n    gadag_root_list.sort(GADAG_Root_Compare)\n\
    \    topo.gadag_root = gadag_root_list.pop()\n"
- title: 'def Add_Prefix_Advertisements_From_File(topo, filename):'
  contents:
  - "def Add_Prefix_Advertisements_From_File(topo, filename):\n    prefix_filename\
    \ = filename + '.prefix'\n    cols_list = []\n    if not os.path.exists(prefix_filename):\n\
    \        return\n    with open(prefix_filename) as prefix_file:\n        for line\
    \ in prefix_file:\n            line = line.rstrip('\\r\\n')\n            cols=line.split(',')\n\
    \            cols_list.append(cols)\n            prefix_id = int(cols[0])\n  \
    \          if prefix_id < 2000 or prefix_id >2999:\n                print('skipping\
    \ the following line of prefix file')\n                print('prefix id should\
    \ be between 2000 and 2999')\n                print(line)\n                continue\n\
    \            prefix_node_id = int(cols[1])\n            prefix_cost = int(cols[2])\n\
    \            advertising_node = topo.node_dict[prefix_node_id]\n            advertising_node.prefix_cost_dict[prefix_id]\
    \ = prefix_cost\n"
- title: 'def Add_Prefixes_for_Non_Island_Nodes(topo):'
  contents:
  - "def Add_Prefixes_for_Non_Island_Nodes(topo):\n    for node in topo.node_list:\n\
    \        if node.IN_MRT_ISLAND:\n            continue\n        prefix_id = node.node_id\
    \ + 1000\n        node.prefix_cost_dict[prefix_id] = 0\n"
- title: 'def Add_Profile_IDs_from_File(topo, filename):'
  contents:
  - "def Add_Profile_IDs_from_File(topo, filename):\n    profile_filename = filename\
    \ + '.profile'\n    for node in topo.node_list:\n        node.profile_id_list\
    \ = []\n    cols_list = []\n    if os.path.exists(profile_filename):\n       \
    \ with open(profile_filename) as profile_file:\n            for line in profile_file:\n\
    \                line = line.rstrip('\\r\\n')\n                cols=line.split(',')\n\
    \                cols_list.append(cols)\n                node_id = int(cols[0])\n\
    \                profile_id = int(cols[1])\n                this_node = topo.node_dict[node_id]\n\
    \                this_node.profile_id_list.append(profile_id)\n    else:\n   \
    \     for node in topo.node_list:\n            node.profile_id_list = [0]\n"
- title: 'def Island_Marking_SPF(topo,spf_root):'
  contents:
  - "def Island_Marking_SPF(topo,spf_root):\n    spf_root.isl_marking_spf_dict = {}\n\
    \    for y in topo.node_list:\n        y.spf_metric = 2147483647 # 2^31-1 as max\
    \ metric\n        y.PATH_HITS_ISLAND = False\n        y.next_hops = []\n     \
    \   y.spf_visited = False\n    spf_root.spf_metric = 0\n    spf_heap = []\n  \
    \  heapq.heappush(spf_heap,\n                   (spf_root.spf_metric,spf_root.node_id,spf_root)\
    \ )\n    while spf_heap != []:\n        #extract third element of tuple popped\
    \ from heap\n        min_node = heapq.heappop(spf_heap)[2]\n        if min_node.spf_visited:\n\
    \            continue\n        min_node.spf_visited = True\n        spf_root.isl_marking_spf_dict[min_node.node_id]\
    \ = \\\n            (min_node.spf_metric, min_node.PATH_HITS_ISLAND)\n       \
    \ for intf in min_node.intf_list:\n            path_metric = min_node.spf_metric\
    \ + intf.metric\n            if path_metric < intf.remote_node.spf_metric:\n \
    \               intf.remote_node.spf_metric = path_metric\n                if\
    \ min_node is spf_root:\n                    intf.remote_node.next_hops = [intf]\n\
    \                else:\n                    Copy_List_Items(intf.remote_node.next_hops,\n\
    \                                    min_node.next_hops)\n                if (intf.remote_node.IN_MRT_ISLAND):\n\
    \                    intf.remote_node.PATH_HITS_ISLAND = True\n              \
    \  else:\n                    intf.remote_node.PATH_HITS_ISLAND = \\\n       \
    \                 min_node.PATH_HITS_ISLAND\n                heapq.heappush(spf_heap,\n\
    \                               ( intf.remote_node.spf_metric,\n             \
    \                    intf.remote_node.node_id,\n                             \
    \    intf.remote_node ) )\n            elif path_metric == intf.remote_node.spf_metric:\n\
    \                if min_node is spf_root:\n                    Add_Item_To_List_If_New(\n\
    \                        intf.remote_node.next_hops,intf)\n                else:\n\
    \                    for nh_intf in min_node.next_hops:\n                    \
    \    Add_Item_To_List_If_New(\n                            intf.remote_node.next_hops,nh_intf)\n\
    \                if (intf.remote_node.IN_MRT_ISLAND):\n                    intf.remote_node.PATH_HITS_ISLAND\
    \ = True\n                else:\n                    if (intf.remote_node.PATH_HITS_ISLAND\n\
    \                        or min_node.PATH_HITS_ISLAND):\n                    \
    \    intf.remote_node.PATH_HITS_ISLAND = True\n"
- title: 'def Create_Basic_Named_Proxy_Nodes(topo):'
  contents:
  - "def Create_Basic_Named_Proxy_Nodes(topo):\n    for node in topo.node_list:\n\
    \        for prefix in node.prefix_cost_dict:\n            prefix_cost = node.prefix_cost_dict[prefix]\n\
    \            if prefix in topo.named_proxy_dict:\n                P = topo.named_proxy_dict[prefix]\n\
    \                P.node_prefix_cost_list.append((node,prefix_cost))\n        \
    \    else:\n                P = Named_Proxy_Node()\n                topo.named_proxy_dict[prefix]\
    \ = P\n                P.node_id = prefix\n                P.node_prefix_cost_list\
    \ = [(node,prefix_cost)]\n"
- title: 'def Compute_Loop_Free_Island_Neighbors_For_Each_Prefix(topo):'
  contents:
  - "def Compute_Loop_Free_Island_Neighbors_For_Each_Prefix(topo):\n    topo.island_nbr_set\
    \ = set()\n    topo.island_border_set = set()\n    for node in topo.node_list:\n\
    \        if node.IN_MRT_ISLAND:\n            continue\n        for intf in node.intf_list:\n\
    \            if intf.remote_node.IN_MRT_ISLAND:\n                topo.island_nbr_set.add(node)\n\
    \                topo.island_border_set.add(intf.remote_node)\n    for island_nbr\
    \ in topo.island_nbr_set:\n        Island_Marking_SPF(topo,island_nbr)\n    for\
    \ prefix in topo.named_proxy_dict:\n        P = topo.named_proxy_dict[prefix]\n\
    \        P.lfin_list = []\n        for island_nbr in topo.island_nbr_set:\n  \
    \          min_isl_nbr_to_pref_cost = 2147483647\n            for (adv_node, prefix_cost)\
    \ in P.node_prefix_cost_list:\n                (adv_node_cost, path_hits_island)\
    \ = \\\n                    island_nbr.isl_marking_spf_dict[adv_node.node_id]\n\
    \                isl_nbr_to_pref_cost = adv_node_cost + prefix_cost\n        \
    \        if isl_nbr_to_pref_cost < min_isl_nbr_to_pref_cost:\n               \
    \     min_isl_nbr_to_pref_cost = isl_nbr_to_pref_cost\n                    min_path_hits_island\
    \ = path_hits_island\n                elif isl_nbr_to_pref_cost == min_isl_nbr_to_pref_cost:\n\
    \                    if min_path_hits_island or path_hits_island:\n          \
    \              min_path_hits_island = True\n            if not min_path_hits_island:\n\
    \                P.lfin_list.append( (island_nbr,\n                          \
    \           min_isl_nbr_to_pref_cost) )\n"
- title: 'def Compute_Island_Border_Router_LFIN_Pairs_For_Each_Prefix(topo):'
  contents:
  - "def Compute_Island_Border_Router_LFIN_Pairs_For_Each_Prefix(topo):\n    for ibr\
    \ in topo.island_border_set:\n        ibr.prefix_lfin_dict = {}\n        ibr.min_intf_metric_dict\
    \ = {}\n        ibr.min_intf_list_dict = {}\n        ibr.min_intf_list_dict[None]\
    \ = None\n        for intf in ibr.intf_list:\n            if not intf.remote_node\
    \ in topo.island_nbr_set:\n                continue\n            if not intf.remote_node\
    \ in ibr.min_intf_metric_dict:\n                ibr.min_intf_metric_dict[intf.remote_node]\
    \ = \\\n                    intf.metric\n                ibr.min_intf_list_dict[intf.remote_node]\
    \ = [intf]\n            else:\n                if (intf.metric\n             \
    \       < ibr.min_intf_metric_dict[intf.remote_node]):\n                    ibr.min_intf_metric_dict[intf.remote_node]\
    \ = \\\n                         intf.metric\n                    ibr.min_intf_list_dict[intf.remote_node]\
    \ = [intf]\n                elif (intf.metric\n                      < ibr.min_intf_metric_dict[intf.remote_node]):\n\
    \                    ibr.min_intf_list_dict[intf.remote_node].\\\n           \
    \             append(intf)\n    for prefix in topo.named_proxy_dict:\n       \
    \ P = topo.named_proxy_dict[prefix]\n        for ibr in topo.island_border_set:\n\
    \            min_ibr_lfin_pref_cost = 2147483647\n            min_lfin = None\n\
    \            for (lfin, lfin_to_pref_cost) in P.lfin_list:\n                if\
    \ not lfin in ibr.min_intf_metric_dict:\n                    continue\n      \
    \          ibr_lfin_pref_cost = \\\n                    ibr.min_intf_metric_dict[lfin]\
    \ + lfin_to_pref_cost\n                if ibr_lfin_pref_cost < min_ibr_lfin_pref_cost:\n\
    \                    min_ibr_lfin_pref_cost = ibr_lfin_pref_cost\n           \
    \         min_lfin = lfin\n            ibr.prefix_lfin_dict[prefix] = (min_lfin,\n\
    \                min_ibr_lfin_pref_cost,\n                ibr.min_intf_list_dict[min_lfin])\n"
- title: 'def Proxy_Node_Att_Router_Compare(pnar_a, pnar_b):'
  contents:
  - "def Proxy_Node_Att_Router_Compare(pnar_a, pnar_b):\n    if pnar_a.named_proxy_cost\
    \ < pnar_b.named_proxy_cost:\n        return -1\n    if pnar_b.named_proxy_cost\
    \ < pnar_a.named_proxy_cost:\n        return 1\n    if pnar_a.node.node_id < pnar_b.node.node_id:\n\
    \        return -1\n    if pnar_b.node.node_id < pnar_a.node.node_id:\n      \
    \  return 1\n    if pnar_a.min_lfin == None:\n        return -1\n    if pnar_b.min_lfin\
    \ == None:\n        return 1\n"
- title: 'def Choose_Proxy_Node_Attachment_Routers(topo):'
  contents:
  - "def Choose_Proxy_Node_Attachment_Routers(topo):\n    for prefix in topo.named_proxy_dict:\n\
    \        P = topo.named_proxy_dict[prefix]\n        pnar_candidate_list = []\n\
    \        for (node, prefix_cost) in P.node_prefix_cost_list:\n            if not\
    \ node.IN_MRT_ISLAND:\n                continue\n            pnar = Proxy_Node_Attachment_Router()\n\
    \            pnar.prefix = prefix\n            pnar.named_proxy_cost = prefix_cost\n\
    \            pnar.node = node\n            pnar_candidate_list.append(pnar)\n\
    \        for ibr in topo.island_border_set:\n            (min_lfin, prefix_cost,\
    \ min_intf_list) = \\\n                ibr.prefix_lfin_dict[prefix]\n        \
    \    if min_lfin == None:\n                continue\n            pnar = Proxy_Node_Attachment_Router()\n\
    \            pnar.named_proxy_cost = prefix_cost\n            pnar.node = ibr\n\
    \            pnar.min_lfin = min_lfin\n            pnar.nh_intf_list = min_intf_list\n\
    \            pnar_candidate_list.append(pnar)\n        pnar_candidate_list.sort(cmp=Proxy_Node_Att_Router_Compare)\n\
    \        #pop first element from list\n        first_pnar = pnar_candidate_list.pop(0)\n\
    \        second_pnar = None\n        for next_pnar in pnar_candidate_list:\n \
    \           if next_pnar.node is first_pnar.node:\n                continue\n\
    \            second_pnar = next_pnar\n            break\n        P.pnar1 = first_pnar\n\
    \        P.pnar2 = second_pnar\n"
- title: 'def Attach_Named_Proxy_Nodes(topo):'
  contents:
  - "def Attach_Named_Proxy_Nodes(topo):\n    Compute_Loop_Free_Island_Neighbors_For_Each_Prefix(topo)\n\
    \    Compute_Island_Border_Router_LFIN_Pairs_For_Each_Prefix(topo)\n    Choose_Proxy_Node_Attachment_Routers(topo)\n"
- title: 'def Select_Proxy_Node_NHs(P,S):'
  contents:
  - "def Select_Proxy_Node_NHs(P,S):\n    if P.pnar1.node.node_id < P.pnar2.node.node_id:\n\
    \        X = P.pnar1.node\n        Y = P.pnar2.node\n    else:\n        X = P.pnar2.node\n\
    \        Y = P.pnar1.node\n    P.pnar_X = X\n    P.pnar_Y = Y\n    A = X.order_proxy\n\
    \    B = Y.order_proxy\n    if (A is S.localroot\n        and B is S.localroot):\n\
    \        #print(\"1.0\")\n        Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n\
    \        Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n        return\n \
    \   if (A is S.localroot\n        and B is not S.localroot):\n        #print(\"\
    2.0\")\n        if B.LOWER:\n            #print(\"2.1\")\n            Copy_List_Items(P.blue_next_hops,\
    \ X.blue_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n\
    \            return\n        if B.HIGHER:\n            #print(\"2.2\")\n     \
    \       Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n            Copy_List_Items(P.red_next_hops,\
    \ Y.blue_next_hops)\n            return\n        else:\n            #print(\"\
    2.3\")\n            Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n     \
    \       Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n            return\n\
    \    if (A is not S.localroot\n        and B is S.localroot):\n        #print(\"\
    3.0\")\n        if A.LOWER:\n            #print(\"3.1\")\n            Copy_List_Items(P.blue_next_hops,\
    \ X.red_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n\
    \            return\n        if A.HIGHER:\n            #print(\"3.2\")\n     \
    \       Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n            Copy_List_Items(P.red_next_hops,\
    \ Y.red_next_hops)\n            return\n        else:\n            #print(\"3.3\"\
    )\n            Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n          \
    \  Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n            return\n   \
    \ if (A is not S.localroot\n        and B is not S.localroot):\n        #print(\"\
    4.0\")\n        if (S is A.localroot or S is B.localroot):\n            #print(\"\
    4.05\")\n            if A.topo_order < B.topo_order:\n                #print(\"\
    4.05.1\")\n                Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n\
    \                Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n         \
    \       return\n            else:\n                #print(\"4.05.2\")\n      \
    \          Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n              \
    \  Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n                return\n\
    \        if A.LOWER:\n            #print(\"4.1\")\n            if B.HIGHER:\n\
    \                #print(\"4.1.1\")\n                Copy_List_Items(P.blue_next_hops,\
    \ X.red_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n\
    \                return\n            if B.LOWER:\n                #print(\"4.1.2\"\
    )\n                if A.topo_order < B.topo_order:\n                    #print(\"\
    4.1.2.1\")\n                    Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n\
    \                    Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n     \
    \               return\n                else:\n                    #print(\"4.1.2.2\"\
    )\n                    Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n  \
    \                  Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n      \
    \              return\n            else:\n                #print(\"4.1.3\")\n\
    \                Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n        \
    \        Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n                return\n\
    \        if A.HIGHER:\n            #print(\"4.2\")\n            if B.HIGHER:\n\
    \                #print(\"4.2.1\")\n                if A.topo_order < B.topo_order:\n\
    \                    #print(\"4.2.1.1\")\n                    Copy_List_Items(P.blue_next_hops,\
    \ X.blue_next_hops)\n                    Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n\
    \                    return\n                else:\n                    #print(\"\
    4.2.1.2\")\n                    Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n\
    \                    Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n    \
    \                return\n            if B.LOWER:\n                #print(\"4.2.2\"\
    )\n                Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n     \
    \           Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n              \
    \  return\n            else:\n                #print(\"4.2.3\")\n            \
    \    Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n                Copy_List_Items(P.red_next_hops,\
    \ Y.blue_next_hops)\n                return\n        else:\n            #print(\"\
    4.3\")\n            if B.LOWER:\n                #print(\"4.3.1\")\n         \
    \       Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n                Copy_List_Items(P.red_next_hops,\
    \ Y.red_next_hops)\n                return\n            if B.HIGHER:\n       \
    \         #print(\"4.3.2\")\n                Copy_List_Items(P.blue_next_hops,\
    \ X.blue_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n\
    \                return\n            else:\n                #print(\"4.3.3\")\n\
    \                if A.topo_order < B.topo_order:\n                    #print(\"\
    4.3.3.1\")\n                    Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n\
    \                    Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n     \
    \               return\n                else:\n                    #print(\"4.3.3.2\"\
    )\n                    Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n  \
    \                  Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n      \
    \              return\n    assert(False)\n"
- title: 'def Compute_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,S):'
  contents:
  - "def Compute_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,S):\n    for prefix\
    \ in topo.named_proxy_dict:\n        P = topo.named_proxy_dict[prefix]\n     \
    \   if P.pnar2 == None:\n            if S is P.pnar1.node:\n                #\
    \ set the MRT next hops for the PNAR to\n                # reach the LFIN and\
    \ change FEC to green\n                Copy_List_Items(P.blue_next_hops,\n   \
    \                             P.pnar1.nh_intf_list)\n                S.blue_to_green_nh_dict[P.node_id]\
    \ = True\n                Copy_List_Items(P.red_next_hops,\n                 \
    \               P.pnar1.nh_intf_list)\n                S.red_to_green_nh_dict[P.node_id]\
    \ = True\n            else:\n                # inherit MRT NHs for P from pnar1\n\
    \                Copy_List_Items(P.blue_next_hops,\n                         \
    \       P.pnar1.node.blue_next_hops)\n                Copy_List_Items(P.red_next_hops,\n\
    \                                P.pnar1.node.red_next_hops)\n        else:\n\
    \            Select_Proxy_Node_NHs(P,S)\n            # set the MRT next hops for\
    \ the PNAR to reach the LFIN\n            # and change FEC to green rely on the\
    \ red or blue\n            # next hops being empty to figure out which one needs\n\
    \            # to point to the LFIN.\n            if S is P.pnar1.node:\n    \
    \            this_pnar = P.pnar1\n            elif S is P.pnar2.node:\n      \
    \          this_pnar = P.pnar2\n            else:\n                continue\n\
    \            if P.blue_next_hops == []:\n                Copy_List_Items(P.blue_next_hops,\n\
    \                    this_pnar.nh_intf_list)\n                S.blue_to_green_nh_dict[P.node_id]\
    \ = True\n            if P.red_next_hops == []:\n                Copy_List_Items(P.red_next_hops,\n\
    \                    this_pnar.nh_intf_list)\n                S.red_to_green_nh_dict[P.node_id]\
    \ = True\n"
- title: 'def Select_Alternates_Proxy_Node(P,F,primary_intf):'
  contents:
  - "def Select_Alternates_Proxy_Node(P,F,primary_intf):\n    S = primary_intf.local_node\n\
    \    X = P.pnar_X\n    Y = P.pnar_Y\n    A = X.order_proxy\n    B = Y.order_proxy\n\
    \    if F is A and F is B:\n        return 'PRIM_NH_IS_OP_FOR_BOTH_X_AND_Y'\n\
    \    if F is A:\n        return 'USE_RED'\n    if F is B:\n        return 'USE_BLUE'\n\
    \    if not In_Common_Block(A, B):\n        if In_Common_Block(F, A):\n      \
    \      return 'USE_RED'\n        elif In_Common_Block(F, B):\n            return\
    \ 'USE_BLUE'\n        else:\n            return 'USE_RED_OR_BLUE'\n    if (not\
    \ In_Common_Block(F, A)\n        and not In_Common_Block(F, A) ):\n        return\
    \ 'USE_RED_OR_BLUE'\n    alt_to_X = Select_Alternates(X, F, primary_intf)\n  \
    \  alt_to_Y = Select_Alternates(Y, F, primary_intf)\n    if (alt_to_X == 'USE_RED_OR_BLUE'\n\
    \        and alt_to_Y == 'USE_RED_OR_BLUE'):\n        return 'USE_RED_OR_BLUE'\n\
    \    if alt_to_X == 'USE_RED_OR_BLUE':\n        return 'USE_BLUE'\n    if alt_to_Y\
    \ == 'USE_RED_OR_BLUE':\n        return 'USE_RED'\n    if (A is S.localroot\n\
    \        and B is S.localroot):\n        #print(\"1.0\")\n        if (alt_to_X\
    \ == 'USE_BLUE' and alt_to_Y == 'USE_RED'):\n            return 'USE_RED_OR_BLUE'\n\
    \        if alt_to_X == 'USE_BLUE':\n            return 'USE_BLUE'\n        if\
    \ alt_to_Y == 'USE_RED':\n            return 'USE_RED'\n        assert(False)\n\
    \    if (A is S.localroot\n        and B is not S.localroot):\n        #print(\"\
    2.0\")\n        if B.LOWER:\n            #print(\"2.1\")\n            if (alt_to_X\
    \ == 'USE_BLUE' and alt_to_Y == 'USE_RED'):\n                return 'USE_RED_OR_BLUE'\n\
    \            if alt_to_X == 'USE_BLUE':\n                return 'USE_BLUE'\n \
    \           if alt_to_Y == 'USE_RED':\n                return 'USE_RED'\n    \
    \        assert(False)\n        if B.HIGHER:\n            #print(\"2.2\")\n  \
    \          if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n          \
    \      return 'USE_RED_OR_BLUE'\n            if alt_to_X == 'USE_RED':\n     \
    \           return 'USE_BLUE'\n            if alt_to_Y == 'USE_BLUE':\n      \
    \          return 'USE_RED'\n            assert(False)\n        else:\n      \
    \      #print(\"2.3\")\n            if (alt_to_X == 'USE_RED' and alt_to_Y ==\
    \ 'USE_RED'):\n                return 'USE_RED_OR_BLUE'\n            if alt_to_X\
    \ == 'USE_RED':\n                return 'USE_BLUE'\n            if alt_to_Y ==\
    \ 'USE_RED':\n                return 'USE_RED'\n            assert(False)\n  \
    \  if (A is not S.localroot\n        and B is S.localroot):\n        #print(\"\
    3.0\")\n        if A.LOWER:\n            #print(\"3.1\")\n            if (alt_to_X\
    \ == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n                return 'USE_RED_OR_BLUE'\n\
    \            if alt_to_X == 'USE_RED':\n                return 'USE_BLUE'\n  \
    \          if alt_to_Y == 'USE_BLUE':\n                return 'USE_RED'\n    \
    \        assert(False)\n        if A.HIGHER:\n            #print(\"3.2\")\n  \
    \          if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'):\n          \
    \      return 'USE_RED_OR_BLUE'\n            if alt_to_X == 'USE_BLUE':\n    \
    \            return 'USE_BLUE'\n            if alt_to_Y == 'USE_RED':\n      \
    \          return 'USE_RED'\n            assert(False)\n        else:\n      \
    \      #print(\"3.3\")\n            if (alt_to_X == 'USE_RED' and alt_to_Y ==\
    \ 'USE_RED'):\n                return 'USE_RED_OR_BLUE'\n            if alt_to_X\
    \ == 'USE_RED':\n                return 'USE_BLUE'\n            if alt_to_Y ==\
    \ 'USE_RED':\n                return 'USE_RED'\n            assert(False)\n  \
    \  if (A is not S.localroot\n        and B is not S.localroot):\n        #print(\"\
    4.0\")\n        if (S is A.localroot or S is B.localroot):\n            #print(\"\
    4.05\")\n            if A.topo_order < B.topo_order:\n                #print(\"\
    4.05.1\")\n                if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'):\n\
    \                    return 'USE_RED_OR_BLUE'\n                if alt_to_X ==\
    \ 'USE_BLUE':\n                    return 'USE_BLUE'\n                if alt_to_Y\
    \ == 'USE_RED':\n                    return 'USE_RED'\n                assert(False)\n\
    \            else:\n                #print(\"4.05.2\")\n                if (alt_to_X\
    \ == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n                    return 'USE_RED_OR_BLUE'\n\
    \                if alt_to_X == 'USE_RED':\n                    return 'USE_BLUE'\n\
    \                if alt_to_Y == 'USE_BLUE':\n                    return 'USE_RED'\n\
    \                assert(False)\n        if A.LOWER:\n            #print(\"4.1\"\
    )\n            if B.HIGHER:\n                #print(\"4.1.1\")\n             \
    \   if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n                 \
    \   return 'USE_RED_OR_BLUE'\n                if alt_to_X == 'USE_RED':\n    \
    \                return 'USE_BLUE'\n                if alt_to_Y == 'USE_BLUE':\n\
    \                    return 'USE_RED'\n                assert(False)\n       \
    \     if B.LOWER:\n                #print(\"4.1.2\")\n                if A.topo_order\
    \ < B.topo_order:\n                    #print(\"4.1.2.1\")\n                 \
    \   if (alt_to_X == 'USE_BLUE'\n                        and alt_to_Y == 'USE_RED'):\n\
    \                        return 'USE_RED_OR_BLUE'\n                    if alt_to_X\
    \ == 'USE_BLUE':\n                        return 'USE_BLUE'\n                \
    \    if alt_to_Y == 'USE_RED':\n                        return 'USE_RED'\n   \
    \                 assert(False)\n                else:\n                    #print(\"\
    4.1.2.2\")\n                    if (alt_to_X == 'USE_RED'\n                  \
    \      and alt_to_Y == 'USE_BLUE'):\n                        return 'USE_RED_OR_BLUE'\n\
    \                    if alt_to_X == 'USE_RED':\n                        return\
    \ 'USE_BLUE'\n                    if alt_to_Y == 'USE_BLUE':\n               \
    \         return 'USE_RED'\n                    assert(False)\n            else:\n\
    \                #print(\"4.1.3\")\n                if (F.LOWER and not F.HIGHER\n\
    \                    and F.topo_order > A.topo_order):\n                    #print(\"\
    4.1.3.1\")\n                    return 'USE_RED'\n                else:\n    \
    \                #print(\"4.1.3.2\")\n                    return 'USE_BLUE'\n\
    \        if A.HIGHER:\n            #print(\"4.2\")\n            if B.HIGHER:\n\
    \                #print(\"4.2.1\")\n                if A.topo_order < B.topo_order:\n\
    \                    #print(\"4.2.1.1\")\n                    if (alt_to_X ==\
    \ 'USE_BLUE'\n                        and alt_to_Y == 'USE_RED'):\n          \
    \              return 'USE_RED_OR_BLUE'\n                    if alt_to_X == 'USE_BLUE':\n\
    \                        return 'USE_BLUE'\n                    if alt_to_Y ==\
    \ 'USE_RED':\n                        return 'USE_RED'\n                    assert(False)\n\
    \                else:\n                    #print(\"4.2.1.2\")\n            \
    \        if (alt_to_X == 'USE_RED'\n                        and alt_to_Y == 'USE_BLUE'):\n\
    \                        return 'USE_RED_OR_BLUE'\n                    if alt_to_X\
    \ == 'USE_RED':\n                        return 'USE_BLUE'\n                 \
    \   if alt_to_Y == 'USE_BLUE':\n                        return 'USE_RED'\n   \
    \                 assert(False)\n            if B.LOWER:\n                #print(\"\
    4.2.2\")\n                if (alt_to_X == 'USE_BLUE'\n                    and\
    \ alt_to_Y == 'USE_RED'):\n                    return 'USE_RED_OR_BLUE'\n    \
    \            if alt_to_X == 'USE_BLUE':\n                    return 'USE_BLUE'\n\
    \                if alt_to_Y == 'USE_RED':\n                    return 'USE_RED'\n\
    \                assert(False)\n            else:\n                #print(\"4.2.3\"\
    )\n                if (F.HIGHER and not F.LOWER\n                    and F.topo_order\
    \ < A.topo_order):\n                    return 'USE_RED'\n                else:\n\
    \                    return 'USE_BLUE'\n        else:\n            #print(\"4.3\"\
    )\n            if B.LOWER:\n                #print(\"4.3.1\")\n              \
    \  if (F.LOWER and not F.HIGHER\n                    and F.topo_order > B.topo_order):\n\
    \                    return 'USE_BLUE'\n                else:\n              \
    \      return 'USE_RED'\n            if B.HIGHER:\n                #print(\"4.3.2\"\
    )\n                if (F.HIGHER and not F.LOWER\n                    and F.topo_order\
    \ < B.topo_order):\n                    return 'USE_BLUE'\n                else:\n\
    \                    return 'USE_RED'\n            else:\n                #print(\"\
    4.3.3\")\n                if A.topo_order < B.topo_order:\n                  \
    \  #print(\"4.3.3.1\")\n                    if (alt_to_X == 'USE_BLUE'\n     \
    \                   and alt_to_Y == 'USE_RED'):\n                        return\
    \ 'USE_RED_OR_BLUE'\n                    if alt_to_X == 'USE_BLUE':\n        \
    \                return 'USE_BLUE'\n                    if alt_to_Y == 'USE_RED':\n\
    \                        return 'USE_RED'\n                    assert(False)\n\
    \                else:\n                    #print(\"4.3.3.2\")\n            \
    \        if (alt_to_X == 'USE_RED'\n                        and alt_to_Y == 'USE_BLUE'):\n\
    \                        return 'USE_RED_OR_BLUE'\n                    if alt_to_X\
    \ == 'USE_RED':\n                        return 'USE_BLUE'\n                 \
    \   if alt_to_Y == 'USE_BLUE':\n                        return 'USE_RED'\n   \
    \                 assert(False)\n    assert(False)\n"
- title: 'def Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src):'
  contents:
  - "def Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src):\n    for\
    \ prefix in topo.named_proxy_dict:\n        P = topo.named_proxy_dict[prefix]\n\
    \        min_total_pref_cost = 2147483647\n        for (adv_node, prefix_cost)\
    \ in P.node_prefix_cost_list:\n            total_pref_cost = (adv_node.primary_spf_metric\n\
    \                               + prefix_cost)\n            if total_pref_cost\
    \ < min_total_pref_cost:\n                min_total_pref_cost = total_pref_cost\n\
    \                Copy_List_Items(P.primary_next_hops,\n                      \
    \          adv_node.primary_next_hops)\n            elif total_pref_cost == min_total_pref_cost:\n\
    \                for nh_intf in adv_node.primary_next_hops:\n                \
    \    Add_Item_To_List_If_New(P.primary_next_hops,\n                          \
    \                  nh_intf)\n"
- title: 'def Select_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,src):'
  contents:
  - "def Select_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,src):\n    for prefix in\
    \ topo.named_proxy_dict:\n        P = topo.named_proxy_dict[prefix]\n        P.alt_list\
    \ = []\n        for failed_intf in P.primary_next_hops:\n            alt = Alternate()\n\
    \            alt.failed_intf = failed_intf\n            if failed_intf not in\
    \ src.island_intf_list:\n                alt.info = 'PRIM_NH_FOR_PROXY_NODE_NOT_IN_ISLAND'\n\
    \            elif P.pnar1 is None:\n                alt.info = 'NO_PNARs_EXIST_FOR_THIS_PREFIX'\n\
    \            elif src is P.pnar1.node:\n                alt.info = 'SRC_IS_PNAR'\n\
    \            elif P.pnar2 is not None and src is P.pnar2.node:\n             \
    \   alt.info = 'SRC_IS_PNAR'\n            elif P.pnar2 is None:\n            \
    \    #inherit alternates from the only pnar.\n                alt.info = Select_Alternates(P.pnar1.node,\n\
    \                            failed_intf.remote_node, failed_intf)\n         \
    \   elif failed_intf in src.island_intf_list:\n                alt.info = Select_Alternates_Proxy_Node(P,\n\
    \                            failed_intf.remote_node, failed_intf)\n         \
    \   if alt.info == 'USE_RED_OR_BLUE':\n                alt.red_or_blue = \\\n\
    \                    random.choice(['USE_RED','USE_BLUE'])\n            if (alt.info\
    \ == 'USE_BLUE'\n                or alt.red_or_blue == 'USE_BLUE'):\n        \
    \        Copy_List_Items(alt.nh_list, P.blue_next_hops)\n                alt.fec\
    \ = 'BLUE'\n                alt.prot = 'NODE_PROTECTION'\n            elif (alt.info\
    \ == 'USE_RED'\n                  or alt.red_or_blue == 'USE_RED'):\n        \
    \        Copy_List_Items(alt.nh_list, P.red_next_hops)\n                alt.fec\
    \ = 'RED'\n                alt.prot = 'NODE_PROTECTION'\n            elif (alt.info\
    \ == 'PRIM_NH_IS_D_OR_OP_FOR_D'\n                or alt.info == 'PRIM_NH_IS_OP_FOR_BOTH_X_AND_Y'):\n\
    \                if failed_intf.OUTGOING and failed_intf.INCOMING:\n         \
    \           # cut-link: if there are parallel cut links, use\n               \
    \     # the link(s) with lowest metric that are not\n                    # primary\
    \ intf or None\n                    cand_alt_list = [None]\n                 \
    \   min_metric = 2147483647\n                    for intf in src.island_intf_list:\n\
    \                        if ( intf is not failed_intf and\n                  \
    \           (intf.remote_node is\n                             failed_intf.remote_node)):\n\
    \                            if intf.metric < min_metric:\n                  \
    \              cand_alt_list = [intf]\n                                min_metric\
    \ = intf.metric\n                            elif intf.metric == min_metric:\n\
    \                                cand_alt_list.append(intf)\n                \
    \    if cand_alt_list != [None]:\n                        alt.fec = 'GREEN'\n\
    \                        alt.prot = 'PARALLEL_CUTLINK'\n                    else:\n\
    \                        alt.fec = 'NO_ALTERNATE'\n                        alt.prot\
    \ = 'NO_PROTECTION'\n                    Copy_List_Items(alt.nh_list, cand_alt_list)\n\
    \                else:\n                    # set Z as the node to inherit blue\
    \ next hops from\n                    if alt.info == 'PRIM_NH_IS_D_OR_OP_FOR_D':\n\
    \                        Z = P.pnar1.node\n                    else:\n       \
    \                 Z = P\n                    if failed_intf in Z.red_next_hops:\n\
    \                        Copy_List_Items(alt.nh_list, Z.blue_next_hops)\n    \
    \                    alt.fec = 'BLUE'\n                        alt.prot = 'LINK_PROTECTION'\n\
    \                    else:\n                        assert(failed_intf in Z.blue_next_hops)\n\
    \                        Copy_List_Items(alt.nh_list, Z.red_next_hops)\n     \
    \                   alt.fec = 'RED'\n                        alt.prot = 'LINK_PROTECTION'\n\
    \            elif alt.info == 'PRIM_NH_FOR_PROXY_NODE_NOT_IN_ISLAND':\n      \
    \          if (P.pnar2 == None and src is P.pnar1.node):\n                   \
    \ #MRT Island is singly connected to non-island dest\n                    alt.fec\
    \ = 'NO_ALTERNATE'\n                    alt.prot = 'NO_PROTECTION'\n         \
    \       elif P.node_id in src.blue_to_green_nh_dict:\n                    # blue\
    \ to P goes to failed LFIN so use red to P\n                    Copy_List_Items(alt.nh_list,\
    \ P.red_next_hops)\n                    alt.fec = 'RED'\n                    alt.prot\
    \ = 'LINK_PROTECTION'\n                elif P.node_id in src.red_to_green_nh_dict:\n\
    \                    # red to P goes to failed LFIN so use blue to P\n       \
    \             Copy_List_Items(alt.nh_list, P.blue_next_hops)\n               \
    \     alt.fec = 'BLUE'\n                    alt.prot = 'LINK_PROTECTION'\n   \
    \             else:\n                    Copy_List_Items(alt.nh_list, P.blue_next_hops)\n\
    \                    alt.fec = 'BLUE'\n                    alt.prot = 'LINK_PROTECTION'\n\
    \            elif alt.info == 'TEMP_NO_ALTERNATE':\n                alt.fec =\
    \ 'NO_ALTERNATE'\n                alt.prot = 'NO_PROTECTION'\n            P.alt_list.append(alt)\n"
- title: 'def Run_Basic_MRT_for_One_Source(topo, src):'
  contents:
  - "def Run_Basic_MRT_for_One_Source(topo, src):\n    MRT_Island_Identification(topo,\
    \ src, 0, 0)\n    Set_Island_Intf_and_Node_Lists(topo)\n    Set_GADAG_Root(topo,src)\n\
    \    Sort_Interfaces(topo)\n    Run_Lowpoint(topo)\n    Assign_Remaining_Lowpoint_Parents(topo)\n\
    \    Construct_GADAG_via_Lowpoint(topo)\n    Run_Assign_Block_ID(topo)\n    Add_Undirected_Links(topo)\n\
    \    Compute_MRT_NH_For_One_Src_To_Island_Dests(topo,src)\n    Store_MRT_Nexthops_For_One_Src_To_Island_Dests(topo,src)\n\
    \    Select_Alts_For_One_Src_To_Island_Dests(topo,src)\n    Store_Primary_and_Alts_For_One_Src_To_Island_Dests(topo,src)\n"
- title: 'def Store_GADAG_and_Named_Proxies_Once(topo):'
  contents:
  - "def Store_GADAG_and_Named_Proxies_Once(topo):\n    for node in topo.node_list:\n\
    \        for intf in node.intf_list:\n            if intf.OUTGOING:\n        \
    \        intf.SIMULATION_OUTGOING = True\n            else:\n                intf.SIMULATION_OUTGOING\
    \ = False\n    for prefix in topo.named_proxy_dict:\n        P = topo.named_proxy_dict[prefix]\n\
    \        topo.stored_named_proxy_dict[prefix] = P\n"
- title: 'def Run_Basic_MRT_for_All_Sources(topo):'
  contents:
  - "def Run_Basic_MRT_for_All_Sources(topo):\n    for src in topo.node_list:\n  \
    \      Reset_Computed_Node_and_Intf_Values(topo)\n        Run_Basic_MRT_for_One_Source(topo,src)\n\
    \        if src is topo.gadag_root:\n            Store_GADAG_and_Named_Proxies_Once(topo)\n"
- title: 'def Run_MRT_for_One_Source(topo, src):'
  contents:
  - "def Run_MRT_for_One_Source(topo, src):\n    MRT_Island_Identification(topo, src,\
    \ 0, 0)\n    Set_Island_Intf_and_Node_Lists(topo)\n    Set_GADAG_Root(topo,src)\n\
    \    Sort_Interfaces(topo)\n    Run_Lowpoint(topo)\n    Assign_Remaining_Lowpoint_Parents(topo)\n\
    \    Construct_GADAG_via_Lowpoint(topo)\n    Run_Assign_Block_ID(topo)\n    Add_Undirected_Links(topo)\n\
    \    Compute_MRT_NH_For_One_Src_To_Island_Dests(topo,src)\n    Store_MRT_Nexthops_For_One_Src_To_Island_Dests(topo,src)\n\
    \    Select_Alts_For_One_Src_To_Island_Dests(topo,src)\n    Store_Primary_and_Alts_For_One_Src_To_Island_Dests(topo,src)\n\
    \    Create_Basic_Named_Proxy_Nodes(topo)\n    Attach_Named_Proxy_Nodes(topo)\n\
    \    Compute_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src)\n    Store_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src)\n\
    \    Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src)\n    Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src)\n\
    \    Select_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,src)\n    Store_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,src)\n"
- title: 'def Run_Prim_SPF_for_One_Source(topo,src):'
  contents:
  - "def Run_Prim_SPF_for_One_Source(topo,src):\n    Normal_SPF(topo, src)\n    Store_Primary_NHs_For_One_Source_To_Nodes(topo,src)\n\
    \    Create_Basic_Named_Proxy_Nodes(topo)\n    Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src)\n\
    \    Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src)\n"
- title: 'def Run_MRT_for_All_Sources(topo):'
  contents:
  - "def Run_MRT_for_All_Sources(topo):\n    for src in topo.node_list:\n        Reset_Computed_Node_and_Intf_Values(topo)\n\
    \        if src in topo.island_node_list_for_test_gr:\n            # src runs\
    \ MRT if it is in same MRT island as test_gr\n            Run_MRT_for_One_Source(topo,src)\n\
    \            if src is topo.gadag_root:\n                Store_GADAG_and_Named_Proxies_Once(topo)\n\
    \        else:\n            # src still runs SPF if not in MRT island\n      \
    \      Run_Prim_SPF_for_One_Source(topo,src)\n"
- title: 'def Write_Output_To_Files(topo,file_prefix):'
  contents:
  - "def Write_Output_To_Files(topo,file_prefix):\n    Write_GADAG_To_File(topo,file_prefix)\n\
    \    Write_Both_MRTs_For_All_Dests_To_File(topo,file_prefix)\n    Write_Alternates_For_All_Dests_To_File(topo,file_prefix)\n"
- title: 'def Create_Basic_Topology_Input_File(filename):'
  contents:
  - "def Create_Basic_Topology_Input_File(filename):\n    data = [[01,02,10],[02,03,10],[03,04,11],[04,05,10,20],[05,06,10],\n\
    \            [06,07,10],[06,07,10],[06,07,15],[07,01,10],[07,51,10],\n       \
    \     [51,52,10],[52,53,10],[53,03,10],[01,55,10],[55,06,10],\n            [04,12,10],[12,13,10],[13,14,10],[14,15,10],[15,16,10],\n\
    \            [16,17,10],[17,04,10],[05,76,10],[76,77,10],[77,78,10],\n       \
    \     [78,79,10],[79,77,10]]\n    with open(filename + '.csv', 'w') as topo_file:\n\
    \        for item in data:\n            if len(item) > 3:\n                line\
    \ = (str(item[0])+','+str(item[1])+','+\n                        str(item[2])+','+str(item[3])+'\\\
    n')\n            else:\n                line = (str(item[0])+','+str(item[1])+','+\n\
    \                        str(item[2])+'\\n')\n            topo_file.write(line)\n"
- title: 'def Create_Complex_Topology_Input_File(filename):'
  contents:
  - "def Create_Complex_Topology_Input_File(filename):\n    data = [[01,02,10],[02,03,10],[03,04,11],[04,05,10,20],[05,06,10],\n\
    \            [06,07,10],[06,07,10],[06,07,15],[07,01,10],[07,51,10],\n       \
    \     [51,52,10],[52,53,10],[53,03,10],[01,55,10],[55,06,10],\n            [04,12,10],[12,13,10],[13,14,10],[14,15,10],[15,16,10],\n\
    \            [16,17,10],[17,04,10],[05,76,10],[76,77,10],[77,78,10],\n       \
    \     [78,79,10],[79,77,10]]\n    with open(filename + '.csv', 'w') as topo_file:\n\
    \        for item in data:\n            if len(item) > 3:\n                line\
    \ = (str(item[0])+','+str(item[1])+','+\n                        str(item[2])+','+str(item[3])+'\\\
    n')\n            else:\n                line = (str(item[0])+','+str(item[1])+','+\n\
    \                        str(item[2])+'\\n')\n            topo_file.write(line)\n\
    \    data = [[01,0],[02,0],[03,0],[04,0],[05,0],\n            [06,0],[07,0],\n\
    \            [51,0],[55,0],\n            [12,0],[13,0],[14,0],[15,0],\n      \
    \      [16,0],[17,0],[76,0],[77,0],\n            [78,0],[79,0]]\n    with open(filename\
    \ + '.profile', 'w') as topo_file:\n        for item in data:\n            line\
    \ = (str(item[0])+','+str(item[1])+'\\n')\n            topo_file.write(line)\n\
    \    data = [[2001,05,100],[2001,07,120],[2001,03,130],\n            [2002,13,100],[2002,15,110],\n\
    \            [2003,52,100],[2003,78,100]]\n    with open(filename + '.prefix',\
    \ 'w') as topo_file:\n        for item in data:\n            line = (str(item[0])+','+str(item[1])+','+\n\
    \                    str(item[2])+'\\n')\n            topo_file.write(line)\n"
- title: 'def Generate_Basic_Topology_and_Run_MRT():'
  contents:
  - "def Generate_Basic_Topology_and_Run_MRT():\n    this_gadag_root = 3\n    Create_Basic_Topology_Input_File('basic_topo_input')\n\
    \    topo = Create_Topology_From_File('basic_topo_input')\n    res_file_base =\
    \ 'basic_topo'\n    Compute_Island_Node_List_For_Test_GR(topo, this_gadag_root)\n\
    \    Raise_GADAG_Root_Selection_Priority(topo,this_gadag_root)\n    Run_Basic_MRT_for_All_Sources(topo)\n\
    \    Write_Output_To_Files(topo, res_file_base)\n"
- title: 'def Generate_Complex_Topology_and_Run_MRT():'
  contents:
  - "def Generate_Complex_Topology_and_Run_MRT():\n    this_gadag_root = 3\n    Create_Complex_Topology_Input_File('complex_topo_input')\n\
    \    topo = Create_Topology_From_File('complex_topo_input')\n    Add_Profile_IDs_from_File(topo,'complex_topo_input')\n\
    \    Add_Prefix_Advertisements_From_File(topo,'complex_topo_input')\n    Compute_Island_Node_List_For_Test_GR(topo,\
    \ this_gadag_root)\n    Add_Prefixes_for_Non_Island_Nodes(topo)\n    res_file_base\
    \ = 'complex_topo'\n    Raise_GADAG_Root_Selection_Priority(topo,this_gadag_root)\n\
    \    Run_MRT_for_All_Sources(topo)\n    Write_Output_To_Files(topo, res_file_base)\n"
- title: Generate_Basic_Topology_and_Run_MRT()
  contents:
  - 'Generate_Basic_Topology_and_Run_MRT()

    '
- title: Generate_Complex_Topology_and_Run_MRT()
  contents:
  - 'Generate_Complex_Topology_and_Run_MRT()

    '
- title: <CODE ENDS>
  contents:
  - '<CODE ENDS>

    '
- title: Appendix B.  Constructing a GADAG Using SPFs
  contents:
  - "Appendix B.  Constructing a GADAG Using SPFs\n   The basic idea in this method\
    \ for constructing a GADAG is to use\n   slightly modified SPF computations to\
    \ find ears.  In every block, an\n   SPF computation is first done to find a cycle\
    \ from the local root and\n   then SPF computations in that block find ears until\
    \ there are no more\n   interfaces to be explored.  The used result from the SPF\
    \ computation\n   is the path of interfaces indicated by following the previous\
    \ hops\n   from the minimized IN_GADAG node back to the SPF root.\n   To do this,\
    \ first all cut-vertices must be identified and localroots\n   assigned as specified\
    \ in Figure 12.\n   The slight modifications to the SPF are as follows.  The root\
    \ of the\n   block is referred to as the block-root; it is either the GADAG root\n\
    \   or a cut-vertex.\n   a.  The SPF is rooted at a neighbor x of an IN_GADAG\
    \ node y.  All\n       links between y and x are marked as TEMP_UNUSABLE.  They\
    \ should\n       not be used during the SPF computation.\n   b.  If y is not the\
    \ block-root, then it is marked TEMP_UNUSABLE.  It\n       should not be used\
    \ during the SPF computation.  This prevents\n       ears from starting and ending\
    \ at the same node and avoids cycles;\n       the exception is because cycles\
    \ to/from the block-root are\n       acceptable and expected.\n   c.  Do not explore\
    \ links to nodes whose localroot is not the block-\n       root.  This keeps the\
    \ SPF confined to the particular block.\n   d.  Terminate when the first IN_GADAG\
    \ node z is minimized.\n   e.  Respect the existing directions (e.g., INCOMING,\
    \ OUTGOING,\n       UNDIRECTED) already specified for each interface.\n    Mod_SPF(spf_root,\
    \ block_root)\n       Initialize spf_heap to empty\n       Initialize nodes' spf_metric\
    \ to infinity\n       spf_root.spf_metric = 0\n       insert(spf_heap, spf_root)\n\
    \       found_in_gadag = false\n       while (spf_heap is not empty) and (found_in_gadag\
    \ is false)\n           min_node = remove_lowest(spf_heap)\n           if min_node.IN_GADAG\n\
    \              found_in_gadag = true\n           else\n              foreach interface\
    \ intf of min_node\n                 if ((intf.OUTGOING or intf.UNDIRECTED) and\n\
    \                     ((intf.remote_node.localroot is block_root) or\n       \
    \               (intf.remote_node is block_root)) and\n                     (intf.remote_node\
    \ is not TEMP_UNUSABLE) and\n                     (intf is not TEMP_UNUSABLE))\n\
    \                    path_metric = min_node.spf_metric + intf.metric\n       \
    \             if path_metric < intf.remote_node.spf_metric\n                 \
    \      intf.remote_node.spf_metric = path_metric\n                       intf.remote_node.spf_prev_intf\
    \ = intf\n                       insert_or_update(spf_heap, intf.remote_node)\n\
    \       return min_node\n    SPF_for_Ear(cand_intf.local_node,cand_intf.remote_node,\
    \ block_root,\n                method)\n       Mark all interfaces between cand_intf.remote_node\n\
    \                  and cand_intf.local_node as TEMP_UNUSABLE\n       if cand_intf.local_node\
    \ is not block_root\n          Mark cand_intf.local_node as TEMP_UNUSABLE\n  \
    \     Initialize ear_list to empty\n       end_ear = Mod_SPF(spf_root, block_root)\n\
    \       y = end_ear.spf_prev_hop\n       while y.local_node is not spf_root\n\
    \         add_to_list_start(ear_list, y)\n         y.local_node.IN_GADAG = true\n\
    \         y = y.local_node.spf_prev_intf\n       if(method is not hybrid)\n  \
    \        Set_Ear_Direction(ear_list, cand_intf.local_node,\n                 \
    \           end_ear,block_root)\n       Clear TEMP_UNUSABLE from all interfaces\
    \ between\n             cand_intf.remote_node and cand_intf.local_node\n     \
    \  Clear TEMP_UNUSABLE from cand_intf.local_node\n    return end_ear\n       \
    \       Figure 31: Modified SPF for GADAG Construction\n   Assume that an ear\
    \ is found by going from y to x and then running an\n   SPF that terminates by\
    \ minimizing z (e.g., y<->x...q<->z).  Now it is\n   necessary to determine the\
    \ direction of the ear; if y<<z, then the\n   path should be y->x...q->z; but\
    \ if y>>z, then the path should be\n   y<-x...q<-z.  In Section 5.5, the same\
    \ problem was handled by finding\n   all ears that started at a node before looking\
    \ at ears starting at\n   nodes higher in the partial order.  In this GADAG construction\n\
    \   method, using that approach could mean that new ears aren't added in\n   order\
    \ of their total cost since all ears connected to a node would\n   need to be\
    \ found before additional nodes could be found.\n   The alternative is to track\
    \ the order relationship of each node with\n   respect to every other node.  This\
    \ can be accomplished by maintaining\n   two sets of nodes at each node.  The\
    \ first set, Higher_Nodes,\n   contains all nodes that are known to be ordered\
    \ above the node.  The\n   second set, Lower_Nodes, contains all nodes that are\
    \ known to be\n   ordered below the node.  This is the approach used in this GADAG\n\
    \   construction method.\n      Set_Ear_Direction(ear_list, end_a, end_b, block_root)\n\
    \        // Default of A_TO_B for the following cases:\n        // (a) end_a and\
    \ end_b are the same (root)\n        // or (b) end_a is in end_b's Lower Nodes\n\
    \        // or (c) end_a and end_b were unordered with respect to each\n     \
    \   //        other\n        direction = A_TO_B\n        if (end_b is block_root)\
    \ and (end_a is not end_b)\n           direction = B_TO_A\n        else if end_a\
    \ is in end_b.Higher_Nodes\n           direction = B_TO_A\n        if direction\
    \ is B_TO_A\n           foreach interface i in ear_list\n               i.UNDIRECTED\
    \ = false\n               i.INCOMING = true\n               i.remote_intf.UNDIRECTED\
    \ = false\n               i.remote_intf.OUTGOING = true\n        else\n      \
    \     foreach interface i in ear_list\n               i.UNDIRECTED = false\n \
    \              i.OUTGOING = true\n               i.remote_intf.UNDIRECTED = false\n\
    \               i.remote_intf.INCOMING = true\n         if end_a is end_b\n  \
    \          return\n         // Next, update all nodes' Lower_Nodes and Higher_Nodes\n\
    \         if (end_a is in end_b.Higher_Nodes)\n            foreach node x where\
    \ x.localroot is block_root\n                if end_a is in x.Lower_Nodes\n  \
    \                 foreach interface i in ear_list\n                      add i.remote_node\
    \ to x.Lower_Nodes\n                if end_b is in x.Higher_Nodes\n          \
    \         foreach interface i in ear_list\n                      add i.local_node\
    \ to x.Higher_Nodes\n          else\n            foreach node x where x.localroot\
    \ is block_root\n                if end_b is in x.Lower_Nodes\n              \
    \     foreach interface i in ear_list\n                      add i.local_node\
    \ to x.Lower_Nodes\n                if end_a is in x.Higher_Nodes\n          \
    \         foreach interface i in ear_list\n                      add i.remote_node\
    \ to x.Higher_Nodes\n         Figure 32: Algorithm to Assign Links of an Ear Direction\n\
    \   A goal of this GADAG construction method is to find the shortest\n   cycles\
    \ and ears.  An ear is started by going to a neighbor x of an\n   IN_GADAG node\
    \ y.  The path from x to an IN_GADAG node is minimal,\n   since it is computed\
    \ via SPF.  Since a shortest path is made of\n   shortest paths, to find the shortest\
    \ ears requires reaching from the\n   set of IN_GADAG nodes to the closest node\
    \ that isn't IN_GADAG.\n   Therefore, an ordered tree is maintained of interfaces\
    \ that could be\n   explored from the IN_GADAG nodes.  The interfaces are ordered\
    \ by\n   their characteristics of metric, local loopback address, remote\n   loopback\
    \ address, and ifindex, based on the Interface_Compare\n   function defined in\
    \ Figure 14.\n   This GADAG construction method ignores interfaces picked from\
    \ the\n   ordered list that belong to the block root if the block in which the\n\
    \   interface is present already has an ear that has been computed.  This\n  \
    \ is necessary since we allow at most one incoming interface to a block\n   root\
    \ in each block.  This requirement stems from the way next hops\n   are computed\
    \ as was seen in Section 5.7.  After any ear gets\n   computed, we traverse the\
    \ newly added nodes to the GADAG and insert\n   interfaces whose far end is not\
    \ yet on the GADAG to the ordered tree\n   for later processing.\n   Finally,\
    \ cut-links are a special case because there is no point in\n   doing an SPF on\
    \ a block of two nodes.  The algorithm identifies cut-\n   links simply as links\
    \ where both ends of the link are cut-vertices.\n   Cut-links can simply be added\
    \ to the GADAG with both OUTGOING and\n   INCOMING specified on their interfaces.\n\
    \     add_eligible_interfaces_of_node(ordered_intfs_tree,node)\n        for each\
    \ interface of node\n           if intf.remote_node.IN_GADAG is false\n      \
    \        insert(intf,ordered_intfs_tree)\n     check_if_block_has_ear(x,block_id)\n\
    \        block_has_ear = false\n           for all interfaces of x\n         \
    \     if ( (intf.remote_node.block_id == block_id) &&\n                    intf.remote_node.IN_GADAG\
    \ )\n                 block_has_ear = true\n     return block_has_ear\n     Construct_GADAG_via_SPF(topology,\
    \ root)\n       Compute_Localroot (root,root)\n       Assign_Block_ID(root,0)\n\
    \       root.IN_GADAG = true\n          add_eligible_interfaces_of_node(ordered_intfs_tree,root)\n\
    \       while ordered_intfs_tree is not empty\n          cand_intf = remove_lowest(ordered_intfs_tree)\n\
    \          if cand_intf.remote_node.IN_GADAG is false\n             if L(cand_intf.remote_node)\
    \ == D(cand_intf.remote_node)\n                // Special case for cut-links\n\
    \                cand_intf.UNDIRECTED = false\n                cand_intf.remote_intf.UNDIRECTED\
    \ = false\n                cand_intf.OUTGOING = true\n                cand_intf.INCOMING\
    \ = true\n                cand_intf.remote_intf.OUTGOING = true\n            \
    \    cand_intf.remote_intf.INCOMING = true\n                cand_intf.remote_node.IN_GADAG\
    \ = true\n             add_eligible_interfaces_of_node(\n                    \
    \        ordered_intfs_tree,cand_intf.remote_node)\n          else\n         \
    \    if (cand_intf.remote_node.local_root ==\n                 cand_intf.local_node)\
    \ &&\n                 check_if_block_has_ear(cand_intf.local_node,\n        \
    \                      cand_intf.remote_node.block_id))\n                 /* Skip\
    \ the interface since the block root\n                 already has an incoming\
    \ interface in the\n                 block */\n             else\n           \
    \  ear_end = SPF_for_Ear(cand_intf.local_node,\n                     cand_intf.remote_node,\n\
    \                     cand_intf.remote_node.localroot,\n                     SPF\
    \ method)\n             y = ear_end.spf_prev_hop\n             while y.local_node\
    \ is not cand_intf.local_node\n                 add_eligible_interfaces_of_node(\n\
    \                     ordered_intfs_tree, y.local_node)\n                 y =\
    \ y.local_node.spf_prev_intf\n            Figure 33: SPF-Based Method for GADAG\
    \ Construction\n"
- title: Appendix C.  Constructing a GADAG Using a Hybrid Method
  contents:
  - "Appendix C.  Constructing a GADAG Using a Hybrid Method\n   The idea of this\
    \ method is to combine the salient features of the\n   lowpoint inheritance and\
    \ SPF methods.  To this end, we process nodes\n   as they get added to the GADAG\
    \ just like in the lowpoint inheritance\n   by maintaining a stack of nodes. \
    \ This ensures that we do not need to\n   maintain lower and higher sets at each\
    \ node to ascertain ear\n   directions since the ears will always be directed\
    \ from the node being\n   processed towards the end of the ear.  To compute the\
    \ ear however, we\n   resort to an SPF to have the possibility of better ears\
    \ (path\n   lengths) thus giving more flexibility than the restricted use of\n\
    \   lowpoint/dfs parents.\n   Regarding ears involving a block root, unlike the\
    \ SPF method, which\n   ignored interfaces of the block root after the first ear,\
    \ in the\n   hybrid method we would have to process all interfaces of the block\n\
    \   root before moving on to other nodes in the block since the direction\n  \
    \ of an ear is predetermined.  Thus, whenever the block already has an\n   ear\
    \ computed, and we are processing an interface of the block root,\n   we mark\
    \ the block root as unusable before the SPF run that computes\n   the ear.  This\
    \ ensures that the SPF terminates at some node other\n   than the block-root.\
    \  This in turn guarantees that the block-root has\n   only one incoming interface\
    \ in each block, which is necessary for\n   correctly computing the next hops\
    \ on the GADAG.\n   As in the SPF GADAG, bridge ears are handled as a special\
    \ case.\n   The entire algorithm is shown below in Figure 34.\n      find_spf_stack_ear(stack,\
    \ x, y, xy_intf, block_root)\n         if L(y) == D(y)\n            // Special\
    \ case for cut-links\n            xy_intf.UNDIRECTED = false\n            xy_intf.remote_intf.UNDIRECTED\
    \ = false\n            xy_intf.OUTGOING = true\n            xy_intf.INCOMING =\
    \ true\n            xy_intf.remote_intf.OUTGOING = true\n            xy_intf.remote_intf.INCOMING\
    \ = true\n            xy_intf.remote_node.IN_GADAG = true\n            push y\
    \ onto stack\n            return\n         else\n            if (y.local_root\
    \ == x) &&\n                 check_if_block_has_ear(x,y.block_id)\n          \
    \     //Avoid the block root during the SPF\n               Mark x as TEMP_UNUSABLE\n\
    \            end_ear = SPF_for_Ear(x,y,block_root,hybrid)\n            If x was\
    \ set as TEMP_UNUSABLE, clear it\n            cur = end_ear\n            while\
    \ (cur != y)\n               intf = cur.spf_prev_hop\n               prev = intf.local_node\n\
    \               intf.UNDIRECTED = false\n               intf.remote_intf.UNDIRECTED\
    \ = false\n               intf.OUTGOING = true\n               intf.remote_intf.INCOMING\
    \ = true\n               push prev onto stack\n            cur = prev\n      \
    \      xy_intf.UNDIRECTED = false\n            xy_intf.remote_intf.UNDIRECTED\
    \ = false\n            xy_intf.OUTGOING = true\n            xy_intf.remote_intf.INCOMING\
    \ = true\n            return\n      Construct_GADAG_via_hybrid(topology,root)\n\
    \         Compute_Localroot (root,root)\n         Assign_Block_ID(root,0)\n  \
    \       root.IN_GADAG = true\n         Initialize Stack to empty\n         push\
    \ root onto Stack\n         while (Stack is not empty)\n            x = pop(Stack)\n\
    \            for each interface intf of x\n               y = intf.remote_node\n\
    \               if y.IN_GADAG is false\n                  find_spf_stack_ear(stack,\
    \ x, y, intf, y.block_root)\n                Figure 34: Hybrid GADAG Construction\
    \ Method\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to thank Shraddha Hegde, Eric Wu,\
    \ Janos\n   Farkas, Stewart Bryant, Alvaro Retana, and Deccan (Shaofu Peng) for\n\
    \   their suggestions and review.  We would also like to thank Anil Kumar\n  \
    \ SN for his assistance in clarifying the algorithm description and\n   pseudocode.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Gabor Sandor Enyedi\n   Ericsson\n   Konyves Kalman krt\
    \ 11\n   Budapest  1097\n   Hungary\n   Email: Gabor.Sandor.Enyedi@ericsson.com\n\
    \   Andras Csaszar\n   Ericsson\n   Konyves Kalman krt 11\n   Budapest  1097\n\
    \   Hungary\n   Email: Andras.Csaszar@ericsson.com\n   Alia Atlas\n   Juniper\
    \ Networks\n   10 Technology Park Drive\n   Westford, MA  01886\n   United States\n\
    \   Email: akatlas@juniper.net\n   Chris Bowers\n   Juniper Networks\n   1194\
    \ N. Mathilda Ave.\n   Sunnyvale, CA  94089\n   United States\n   Email: cbowers@juniper.net\n\
    \   Abishek Gopalan\n   University of Arizona\n   1230 E Speedway Blvd.\n   Tucson,\
    \ AZ  85721\n   United States\n   Email: abishek@ece.arizona.edu\n"
