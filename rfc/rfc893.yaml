- title: __initial_text__
  contents:
  - '                         Trailer Encapsulations

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This RFC discusses the motivation for use of \"trailer\
    \ encapsulations\"\n   on local-area networks and describes the implementation\
    \ of such an\n   encapsulation on various media.  This document is for information\n\
    \   only.  This is NOT an official protocol for the ARPA Internet\n   community.\n"
- title: Introduction
  contents:
  - "Introduction\n   A trailer encapsulation is a link level packet format employed\
    \ by\n   4.2BSD UNIX (among others).  A trailer encapsulation, or \"trailer\"\
    ,\n   may be generated by a system under certain conditions in an effort to\n\
    \   minimize the number and size of memory-to-memory copy operations\n   performed\
    \ by a receiving host when processing a data packet.\n   Trailers are strictly\
    \ a link level packet format and are not visible\n   (when properly implemented)\
    \ in any higher level protocol processing.\n   This note cites the motivation\
    \ behind the trailer encapsulation and\n   describes the trailer encapsulation\
    \ packet formats currently in use\n   on 3 Mb/s Experimental Ethernet, 10 Mb/s\
    \ Ethernet, and 10 Mb/s V2LNI\n   ring networks [1].\n   The use of a trailer\
    \ encapsulation was suggested by Greg Chesson, and\n   the encapsulation described\
    \ here was designed by Bill Joy.\n"
- title: Motivation
  contents:
  - "Motivation\n   Trailers are motivated by the overhead which may be incurred during\n\
    \   protocol processing when one or more memory to memory copies must be\n   performed.\
    \  Copying can be required at many levels of processing,\n   from moving data\
    \ between the network medium and the host's memory, to\n   passing data between\
    \ the operating system and user address spaces.\n   An optimal network implementation\
    \ would expect to incur zero copy\n   operations between delivery of a data packet\
    \ into host memory and\n   presentation of the appropriate data to the receiving\
    \ process.  While\n   many packets may not be processed without some copying operations,\n\
    \   when the host computer provides suitable memory management support it\n  \
    \ may often be possible to avoid copying simply by manipulating the\n   appropriate\
    \ virtual memory hardware.\n   In a page mapped virtual memory environment, two\
    \ prerequisites are\n   usually required to achieve the goal of zero copy operations\
    \ during\n   packet processing.  Data destined for a receiving agent must be\n"
- title: RFC 893                                                       April 1984
  contents:
  - "RFC 893                                                       April 1984\n  \
    \ aligned on a page boundary and must have a size which is a multiple\n   of the\
    \ hardware page size (or filled to a page boundary).  The latter\n   restriction\
    \ assumes virtual memory protection is maintained at the\n   page level; different\
    \ architectures may alter these prerequisites.\n   Data to be transmitted across\
    \ a network may easily be segmented in\n   the appropriate size, but unless the\
    \ encapsulating protocol header\n   information is fixed in size, alignment to\
    \ a page boundary is\n   virtually impossible.  Protocol header information may\
    \ vary in size\n   due to the use of multiple protocols (each with a different\
    \ header),\n   or it may vary in size by agreement (for example, when optional\n\
    \   information is included in the header).  To insure page alignment the\n  \
    \ header information which prefixes data destined for the receiver must\n   be\
    \ reduced to a fixed size; this is normally the case at the link\n   level of\
    \ a network.  By taking all (possibly) variable length header\n   information\
    \ and moving it after the data segment a sending host may\n   \"do its best\"\
    \ in allowing the receiving host the opportunity to\n   receive data on a page\
    \ aligned boundary.  This rearrangement of data\n   at the link level to force\
    \ variable length header information to\n   \"trail\" the data is the substance\
    \ of the trailer encapsulation.\n   There are several implicit assumptions in\
    \ the above argument.\n      1. The receiving host must be willing to accept trailers.\
    \  As this\n      is a link level encapsulation, unless a host to host negotiation\n\
    \      is performed (preferably at the link level to avoid violating\n      layering\
    \ principles), only certain hosts will be able to converse,\n      or their communication\
    \ may be significantly impaired if trailer\n      packets are mixed with non-trailer\
    \ packets.\n      2. The cost of receiving data on a page aligned boundary should\
    \ be\n      comparable to receiving data on a non-page aligned boundary.  If\n\
    \      the overhead of insuring proper alignment is too high, the savings\n  \
    \    in avoiding copy operations may not be cost effective.\n      3. The size\
    \ of the variable length header information should be\n      significantly less\
    \ than that of the data segment being\n      transmitted. It is possible to move\
    \ trailing information without\n      physically copying it, but often implementation\
    \ constraints and\n      the characteristics of the underlying network hardware\
    \ preclude\n      merely remapping the header(s).\n      4. The memory to memory\
    \ copying overhead which is expected to be\n      performed by the receiver must\
    \ be significant enough to warrant\n      the added complexity in the both the\
    \ sending and receiving host\n      software.\n   The first point is well known\
    \ and the motivation for this note.\n"
- title: RFC 893                                                       April 1984
  contents:
  - "RFC 893                                                       April 1984\n  \
    \ Thought has been given to negotiating the user of trailers on a per\n   host\
    \ basis using a variant of the Address Resolution Protocol [2]\n   (actually augmenting\
    \ the protocol), but at present all systems using\n   trailers require hosts sharing\
    \ a network medium to uniformly accept\n   trailers or never transmit them.  (The\
    \ latter is easily carried out\n   at boot time in 4.2BSD without modifying the\
    \ operating system source\n   code.)\n   The second point is (to our knowledge)\
    \ insignificant.  While a host\n   may not be able to take advantage of the alignment\
    \ and size\n   properties of a trailer packet, it should nonetheless never hamper\n\
    \   it.\n   Regarding the third point, let us assume the trailing header\n   information\
    \ is copied and not remapped, and consider the header\n   overhead in the TCP/IP\
    \ protocols as a representative example [3].  If\n   we assume both the TCP and\
    \ IP protocol headers are part of the\n   variable length header information,\
    \ then the smallest trailer packet\n   (generated by a VAX) would have 512 bytes\
    \ of data and 40+ bytes of\n   header information (plus the trailer header described\
    \ later).  While\n   the trailing header could have IP and/or TCP options included\
    \ this\n   would normally be rare (one would expect most TCP options, for\n  \
    \ example, to be included in the initial connection setup exchange) and\n   certainly\
    \ much smaller than 512 bytes.  If the data segment is\n   larger, the ratio decreases\
    \ and the expected gain due to fewer copies\n   on the receiving end increases.\
    \  Given the relative overheads of a\n   memory to memory copy operation and that\
    \ of a page map manipulation\n   (including translation buffer invalidation),\
    \ the advantage is\n   obvious.\n   The fourth issue, we believe, is actually\
    \ a non-issue.  In our\n   implementation the additional code required to support\
    \ the trailer\n   encapsulation amounts to about a dozen lines of code in each\
    \ link\n   level \"network interface driver\".  The resulting performance\n  \
    \ improvement more than warrants this minor investment in software.\n   It should\
    \ be recognized that modifying the network (and normal link)\n   level format\
    \ of a packet in the manner described forces the receiving\n   host to buffer\
    \ the entire packet before processing.  Clever\n   implementations may parse protocol\
    \ headers as the packet arrives to\n   find out the actual size (or network level\
    \ packet type) of an\n   incoming message.  This allows these implementations\
    \ to avoid\n   preallocating maximum sized buffers to incoming packets which it\
    \ can\n   recognize as unacceptable.  Implementations which parses the network\n\
    \   level format on the fly are violating layering principles which have\n   been\
    \ extolled in design for some time (but often violated in\n   implementation).\
    \  The problem of postponing link level type\n"
- title: RFC 893                                                       April 1984
  contents:
  - "RFC 893                                                       April 1984\n  \
    \ recognition is a valid criticism.  In the case of network hardware\n   which\
    \ supports DMA, however, the entire packet is always received\n   before processing\
    \ begins.\n"
- title: Trailer Encapsulation Packet Formats
  contents:
  - "Trailer Encapsulation Packet Formats\n   In this section we describe the link\
    \ level packet formats used on the\n   3 Mb/s Experimental Ethernet, and 10 Mb/s\
    \ Ethernet networks as well\n   as the 10 Mb/s V2LNI ring network.  The formats\
    \ used in each case\n   differ only in the format and type field values used in\
    \ each of the\n   local area network headers.\n   The format of a trailer packet\
    \ is shown in the following diagram.\n      +----+-------------------------------------------------+----+\n\
    \      | LH |                     data                        | TH |\n      +----+-------------------------------------------------+----+\n\
    \           ^                    (  ^  )                      ^\n      LH:\n \
    \        The fixed-size local network header.  For 10 a Mb/s Ethernet,\n     \
    \    the 16-byte Ethernet header.  The type field in the header\n         indicates\
    \ that both the packet type (trailer) and the length of\n         the data segment.\n\
    \         For the 10 Mb/s Ethernet, the types are between 1001 and 1010\n    \
    \     hexadecimal (4096 and  4112 decimal). The type is calculated as\n      \
    \   1000 (hex) plus the number of 512-byte pages of data.  A\n         maximum\
    \  of 16 pages of data may be transmitted in a single\n         trailer packet\
    \ (8192 bytes).\n      data:\n         The \"data\" portion of the packet.  This\
    \ is normally only data\n         to be delivered to the receiving processes (i.e.\
    \ it contains no\n         TCP or IP header information).  Data size is always\
    \ a multiple\n         of 512 bytes.\n      TH:\n         The \"trailer\".  This\
    \ is actually a composition of the original\n         protocol headers and a fixed\
    \ size trailer prefix which defines\n         the type and size\n         of the\
    \ trailing data.  The format of a trailer is shown below.\n   The carats (^) indicate\
    \ the page boundaries on which the receiving\n   host would place its input buffer\
    \ for optimal alignment when\n"
- title: RFC 893                                                       April 1984
  contents:
  - "RFC 893                                                       April 1984\n  \
    \ receiving a trailer packet.  The link level receiving routine is able\n   to\
    \ locate the trailer using the size indicated in the link level\n   header's type\
    \ field.  The receiving routine is expected to discard\n   the link level header\
    \ and trailer prefix, and remap the trailing data\n   segment to the front of\
    \ the packet to regenerate the original network\n   level packet format.\n"
- title: Trailer Format
  contents:
  - "Trailer Format\n   +----------------+----------------+------~...~----------+\n\
    \   |      TYPE      |  HEADER LENGTH |  ORIGINAL HEADER(S) |\n   +----------------+----------------+------~...~----------+\n\
    \   Type:        16 bits\n      The type field encodes the original link level\
    \ type of the\n      transmitted packet.  This is the value which would normally\
    \ be\n      placed in the link level header if a trailer were not generated.\n\
    \   Header length:       16 bits\n      The header length field of the trailer\
    \ data segment.  This\n      specifies the length in bytes of the following header\
    \ data.\n   Original headers: <variable length>\n      The header information\
    \ which logically belongs before the data\n      segment.  This is normally the\
    \ network and transport level\n      protocol headers.\n"
- title: Summary
  contents:
  - "Summary\n   A link level encapsulation which promotes alignment properties\n\
    \   necessary for the efficient use of virtual memory hardware facilities\n  \
    \ has been described.  This encapsulation format is in use on many\n   systems\
    \ and is a standard facility in 4.2BSD UNIX.  The encapsulation\n   provides an\
    \ efficient mechanism by which cooperating hosts on a local\n   network may obtain\
    \ significant performance improvements.  The use of\n   this encapsulation technique\
    \ currently requires uniform cooperation\n   from all hosts on a network; hopefully\
    \ a per host negotiation\n   mechanism may be added to allow consenting hosts\
    \ to utilize the\n   encapsulation in a non-uniform environment.\n"
- title: RFC 893                                                       April 1984
  contents:
  - 'RFC 893                                                       April 1984

    '
- title: References
  contents:
  - "References\n   [1]  \"The Ethernet - A Local Area Network\", Version 1.0, Digital\n\
    \   Equipment Corporation, Intel Corporation, Xerox Corporation,\n   September\
    \ 1980.\n   [2]  Plummer, David C., \"An Ethernet Address Resolution Protocol\"\
    ,\n   RFC-826,  Symbolics Cambridge Research Center, November 1982.\n   [3]  Postel,\
    \ J., \"Internet Protocol\", RFC-791, USC/Information\n   Sciences Institute,\
    \ September 1981.\n"
