- title: __initial_text__
  contents:
  - "            Elliptic Curve Cryptography (ECC) Cipher Suites\n               \
    \    for Transport Layer Security (TLS)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes new key exchange algorithms based on Elliptic\n\
    \   Curve Cryptography (ECC) for the Transport Layer Security (TLS)\n   protocol.\
    \  In particular, it specifies the use of Elliptic Curve\n   Diffie-Hellman (ECDH)\
    \ key agreement in a TLS handshake and the use of\n   Elliptic Curve Digital Signature\
    \ Algorithm (ECDSA) as a new\n   authentication mechanism.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Key Exchange Algorithms .........................................4\n  \
    \    2.1. ECDH_ECDSA .................................................6\n    \
    \  2.2. ECDHE_ECDSA ................................................6\n      2.3.\
    \ ECDH_RSA ...................................................7\n      2.4. ECDHE_RSA\
    \ ..................................................7\n      2.5. ECDH_anon ..................................................7\n\
    \   3. Client Authentication ...........................................8\n  \
    \    3.1. ECDSA_sign .................................................8\n    \
    \  3.2. ECDSA_fixed_ECDH ...........................................9\n      3.3.\
    \ RSA_fixed_ECDH .............................................9\n   4. TLS Extensions\
    \ for ECC ..........................................9\n   5. Data Structures and\
    \ Computations ...............................10\n      5.1. Client Hello Extensions\
    \ ...................................10\n           5.1.1. Supported Elliptic\
    \ Curves Extension ................12\n           5.1.2. Supported Point Formats\
    \ Extension ..................13\n      5.2. Server Hello Extension ....................................14\n\
    \      5.3. Server Certificate ........................................15\n  \
    \    5.4. Server Key Exchange .......................................17\n    \
    \  5.5. Certificate Request .......................................21\n      5.6.\
    \ Client Certificate ........................................22\n      5.7. Client\
    \ Key Exchange .......................................23\n      5.8. Certificate\
    \ Verify ........................................25\n      5.9. Elliptic Curve\
    \ Certificates ...............................26\n      5.10. ECDH, ECDSA, and\
    \ RSA Computations ........................26\n   6. Cipher Suites ..................................................27\n\
    \   7. Security Considerations ........................................28\n  \
    \ 8. IANA Considerations ............................................29\n   9.\
    \ Acknowledgements ...............................................29\n   10. References\
    \ ....................................................30\n      10.1. Normative\
    \ References .....................................30\n      10.2. Informative\
    \ References ...................................31\n   Appendix A.  Equivalent\
    \ Curves (Informative) ......................32\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Elliptic Curve Cryptography (ECC) is emerging as an attractive\n\
    \   public-key cryptosystem, in particular for mobile (i.e., wireless)\n   environments.\
    \  Compared to currently prevalent cryptosystems such as\n   RSA, ECC offers equivalent\
    \ security with smaller key sizes.  This is\n   illustrated in the following table,\
    \ based on [18], which gives\n   approximate comparable key sizes for symmetric-\
    \ and asymmetric-key\n   cryptosystems based on the best-known algorithms for\
    \ attacking them.\n                    Symmetric  |   ECC   |  DH/DSA/RSA\n  \
    \                 ------------+---------+-------------\n                     \
    \   80     |   163   |     1024\n                       112     |   233   |  \
    \   2048\n                       128     |   283   |     3072\n              \
    \         192     |   409   |     7680\n                       256     |   571\
    \   |    15360\n                  Table 1: Comparable Key Sizes (in bits)\n  \
    \ Smaller key sizes result in savings for power, memory, bandwidth, and\n   computational\
    \ cost that make ECC especially attractive for\n   constrained environments.\n\
    \   This document describes additions to TLS to support ECC, applicable\n   both\
    \ to TLS Version 1.0 [2] and to TLS Version 1.1 [3].  In\n   particular, it defines\n\
    \   o  the use of the Elliptic Curve Diffie-Hellman (ECDH) key agreement\n   \
    \   scheme with long-term or ephemeral keys to establish the TLS\n      premaster\
    \ secret, and\n   o  the use of fixed-ECDH certificates and ECDSA for authentication\
    \ of\n      TLS peers.\n   The remainder of this document is organized as follows.\
    \  Section 2\n   provides an overview of ECC-based key exchange algorithms for\
    \ TLS.\n   Section 3 describes the use of ECC certificates for client\n   authentication.\
    \  TLS extensions that allow a client to negotiate the\n   use of specific curves\
    \ and point formats are presented in Section 4.\n   Section 5 specifies various\
    \ data structures needed for an ECC-based\n   handshake, their encoding in TLS\
    \ messages, and the processing of\n   those messages.  Section 6 defines new ECC-based\
    \ cipher suites and\n   identifies a small subset of these as recommended for\
    \ all\n   implementations of this specification.  Section 7 discusses security\n\
    \   considerations.  Section 8 describes IANA considerations for the name\n  \
    \ spaces created by this document.  Section 9 gives acknowledgements.\n   This\
    \ is followed by the lists of normative and informative references\n   cited in\
    \ this document, the authors' contact information, and\n   statements on intellectual\
    \ property rights and copyrights.\n   Implementation of this specification requires\
    \ familiarity with TLS\n   [2][3], TLS extensions [4], and ECC [5][6][7][11][17].\n\
    \   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\"\
    ,\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in\
    \ this\n   document are to be interpreted as described in RFC 2119 [1].\n"
- title: 2.  Key Exchange Algorithms
  contents:
  - "2.  Key Exchange Algorithms\n   This document introduces five new ECC-based key\
    \ exchange algorithms\n   for TLS.  All of them use ECDH to compute the TLS premaster\
    \ secret,\n   and they differ only in the lifetime of ECDH keys (long-term or\n\
    \   ephemeral) and the mechanism (if any) used to authenticate them.  The\n  \
    \ derivation of the TLS master secret from the premaster secret and the\n   subsequent\
    \ generation of bulk encryption/MAC keys and initialization\n   vectors is independent\
    \ of the key exchange algorithm and not impacted\n   by the introduction of ECC.\n\
    \   The table below summarizes the new key exchange algorithms, which\n   mimic\
    \ DH_DSS, DHE_DSS, DH_RSA, DHE_RSA, and DH_anon (see [2] and\n   [3]), respectively.\n\
    \          Key\n          Exchange\n          Algorithm           Description\n\
    \          ---------           -----------\n          ECDH_ECDSA          Fixed\
    \ ECDH with ECDSA-signed certificates.\n          ECDHE_ECDSA         Ephemeral\
    \ ECDH with ECDSA signatures.\n          ECDH_RSA            Fixed ECDH with RSA-signed\
    \ certificates.\n          ECDHE_RSA           Ephemeral ECDH with RSA signatures.\n\
    \          ECDH_anon           Anonymous ECDH, no signatures.\n              \
    \       Table 2: ECC Key Exchange Algorithms\n   The ECDHE_ECDSA and ECDHE_RSA\
    \ key exchange mechanisms provide forward\n   secrecy.  With ECDHE_RSA, a server\
    \ can reuse its existing RSA\n   certificate and easily comply with a constrained\
    \ client's elliptic\n   curve preferences (see Section 4).  However, the computational\
    \ cost\n   incurred by a server is higher for ECDHE_RSA than for the traditional\n\
    \   RSA key exchange, which does not provide forward secrecy.\n   The ECDH_RSA\
    \ mechanism requires a server to acquire an ECC\n   certificate, but the certificate\
    \ issuer can still use an existing RSA\n   key for signing.  This eliminates the\
    \ need to update the keys of\n   trusted certification authorities accepted by\
    \ TLS clients.  The\n   ECDH_ECDSA mechanism requires ECC keys for the server\
    \ as well as the\n   certification authority and is best suited for constrained\
    \ devices\n   unable to support RSA.\n   The anonymous key exchange algorithm\
    \ does not provide authentication\n   of the server or the client.  Like other\
    \ anonymous TLS key exchanges,\n   it is subject to man-in-the-middle attacks.\
    \  Implementations of this\n   algorithm SHOULD provide authentication by other\
    \ means.\n   Note that there is no structural difference between ECDH and ECDSA\n\
    \   keys.  A certificate issuer may use X.509 v3 keyUsage and\n   extendedKeyUsage\
    \ extensions to restrict the use of an ECC public key\n   to certain computations\
    \ [15].  This document refers to an ECC key as\n   ECDH-capable if its use in\
    \ ECDH is permitted.  ECDSA-capable is\n   defined similarly.\n              Client\
    \                                        Server\n              ------        \
    \                                ------\n              ClientHello          -------->\n\
    \                                                       ServerHello\n        \
    \                                              Certificate*\n                \
    \                                ServerKeyExchange*\n                        \
    \                      CertificateRequest*+\n                                \
    \   <--------       ServerHelloDone\n              Certificate*+\n           \
    \   ClientKeyExchange\n              CertificateVerify*+\n              [ChangeCipherSpec]\n\
    \              Finished             -------->\n                              \
    \                  [ChangeCipherSpec]\n                                   <--------\
    \              Finished\n              Application Data     <------->      Application\
    \ Data\n                   * message is not sent under some conditions\n     \
    \              + message is not sent unless client authentication\n          \
    \           is desired\n                 Figure 1: Message flow in a full TLS\
    \ handshake\n   Figure 1 shows all messages involved in the TLS key establishment\n\
    \   protocol (aka full handshake).  The addition of ECC has direct impact\n  \
    \ only on the ClientHello, the ServerHello, the server's Certificate\n   message,\
    \ the ServerKeyExchange, the ClientKeyExchange, the\n   CertificateRequest, the\
    \ client's Certificate message, and the\n   CertificateVerify.  Next, we describe\
    \ each ECC key exchange algorithm\n   in greater detail in terms of the content\
    \ and processing of these\n   messages.  For ease of exposition, we defer discussion\
    \ of client\n   authentication and associated messages (identified with a + in\n\
    \   Figure 1) until Section 3 and of the optional ECC-specific extensions\n  \
    \ (which impact the Hello messages) until Section 4.\n"
- title: 2.1.  ECDH_ECDSA
  contents:
  - "2.1.  ECDH_ECDSA\n   In ECDH_ECDSA, the server's certificate MUST contain an\
    \ ECDH-capable\n   public key and be signed with ECDSA.\n   A ServerKeyExchange\
    \ MUST NOT be sent (the server's certificate\n   contains all the necessary keying\
    \ information required by the client\n   to arrive at the premaster secret).\n\
    \   The client generates an ECDH key pair on the same curve as the\n   server's\
    \ long-term public key and sends its public key in the\n   ClientKeyExchange message\
    \ (except when using client authentication\n   algorithm ECDSA_fixed_ECDH or RSA_fixed_ECDH,\
    \ in which case the\n   modifications from Section 3.2 or Section 3.3 apply).\n\
    \   Both client and server perform an ECDH operation and use the\n   resultant\
    \ shared secret as the premaster secret.  All ECDH\n   calculations are performed\
    \ as specified in Section 5.10.\n"
- title: 2.2.  ECDHE_ECDSA
  contents:
  - "2.2.  ECDHE_ECDSA\n   In ECDHE_ECDSA, the server's certificate MUST contain an\
    \ ECDSA-\n   capable public key and be signed with ECDSA.\n   The server sends\
    \ its ephemeral ECDH public key and a specification of\n   the corresponding curve\
    \ in the ServerKeyExchange message.  These\n   parameters MUST be signed with\
    \ ECDSA using the private key\n   corresponding to the public key in the server's\
    \ Certificate.\n   The client generates an ECDH key pair on the same curve as\
    \ the\n   server's ephemeral ECDH key and sends its public key in the\n   ClientKeyExchange\
    \ message.\n   Both client and server perform an ECDH operation (Section 5.10)\
    \ and\n   use the resultant shared secret as the premaster secret.\n"
- title: 2.3.  ECDH_RSA
  contents:
  - "2.3.  ECDH_RSA\n   This key exchange algorithm is the same as ECDH_ECDSA except\
    \ that the\n   server's certificate MUST be signed with RSA rather than ECDSA.\n"
- title: 2.4.  ECDHE_RSA
  contents:
  - "2.4.  ECDHE_RSA\n   This key exchange algorithm is the same as ECDHE_ECDSA except\
    \ that\n   the server's certificate MUST contain an RSA public key authorized\n\
    \   for signing, and that the signature in the ServerKeyExchange message\n   must\
    \ be computed with the corresponding RSA private key.  The server\n   certificate\
    \ MUST be signed with RSA.\n"
- title: 2.5.  ECDH_anon
  contents:
  - "2.5.  ECDH_anon\n   In ECDH_anon, the server's Certificate, the CertificateRequest,\
    \ the\n   client's Certificate, and the CertificateVerify messages MUST NOT be\n\
    \   sent.\n   The server MUST send an ephemeral ECDH public key and a specification\n\
    \   of the corresponding curve in the ServerKeyExchange message.  These\n   parameters\
    \ MUST NOT be signed.\n   The client generates an ECDH key pair on the same curve\
    \ as the\n   server's ephemeral ECDH key and sends its public key in the\n   ClientKeyExchange\
    \ message.\n   Both client and server perform an ECDH operation and use the\n\
    \   resultant shared secret as the premaster secret.  All ECDH\n   calculations\
    \ are performed as specified in Section 5.10.\n   Note that while the ECDH_ECDSA,\
    \ ECDHE_ECDSA, ECDH_RSA, and ECDHE_RSA\n   key exchange algorithms require the\
    \ server's certificate to be signed\n   with a particular signature scheme, this\
    \ specification (following the\n   similar cases of DH_DSS, DHE_DSS, DH_RSA, and\
    \ DHE_RSA in [2] and [3])\n   does not impose restrictions on signature schemes\
    \ used elsewhere in\n   the certificate chain.  (Often such restrictions will\
    \ be useful, and\n   it is expected that this will be taken into account in certification\n\
    \   authorities' signing practices.  However, such restrictions are not\n   strictly\
    \ required in general: Even if it is beyond the capabilities\n   of a client to\
    \ completely validate a given chain, the client may be\n   able to validate the\
    \ server's certificate by relying on a trusted\n   certification authority whose\
    \ certificate appears as one of the\n   intermediate certificates in the chain.)\n"
- title: 3.  Client Authentication
  contents:
  - "3.  Client Authentication\n   This document defines three new client authentication\
    \ mechanisms,\n   each named after the type of client certificate involved: ECDSA_sign,\n\
    \   ECDSA_fixed_ECDH, and RSA_fixed_ECDH.  The ECDSA_sign mechanism is\n   usable\
    \ with any of the non-anonymous ECC key exchange algorithms\n   described in Section\
    \ 2 as well as other non-anonymous (non-ECC) key\n   exchange algorithms defined\
    \ in TLS [2][3].  The ECDSA_fixed_ECDH and\n   RSA_fixed_ECDH mechanisms are usable\
    \ with ECDH_ECDSA and ECDH_RSA.\n   Their use with ECDHE_ECDSA and ECDHE_RSA is\
    \ prohibited because the\n   use of a long-term ECDH client key would jeopardize\
    \ the forward\n   secrecy property of these algorithms.\n   The server can request\
    \ ECC-based client authentication by including\n   one or more of these certificate\
    \ types in its CertificateRequest\n   message.  The server must not include any\
    \ certificate types that are\n   prohibited for the negotiated key exchange algorithm.\
    \  The client\n   must check if it possesses a certificate appropriate for any\
    \ of the\n   methods suggested by the server and is willing to use it for\n  \
    \ authentication.\n   If these conditions are not met, the client should send\
    \ a client\n   Certificate message containing no certificates.  In this case,\
    \ the\n   ClientKeyExchange should be sent as described in Section 2, and the\n\
    \   CertificateVerify should not be sent.  If the server requires client\n   authentication,\
    \ it may respond with a fatal handshake failure alert.\n   If the client has an\
    \ appropriate certificate and is willing to use it\n   for authentication, it\
    \ must send that certificate in the client's\n   Certificate message (as per Section\
    \ 5.6) and prove possession of the\n   private key corresponding to the certified\
    \ key.  The process of\n   determining an appropriate certificate and proving\
    \ possession is\n   different for each authentication mechanism and described\
    \ below.\n   NOTE: It is permissible for a server to request (and the client to\n\
    \   send) a client certificate of a different type than the server\n   certificate.\n"
- title: 3.1.  ECDSA_sign
  contents:
  - "3.1.  ECDSA_sign\n   To use this authentication mechanism, the client MUST possess\
    \ a\n   certificate containing an ECDSA-capable public key and signed with\n \
    \  ECDSA.\n   The client proves possession of the private key corresponding to\
    \ the\n   certified key by including a signature in the CertificateVerify\n  \
    \ message as described in Section 5.8.\n"
- title: 3.2.  ECDSA_fixed_ECDH
  contents:
  - "3.2.  ECDSA_fixed_ECDH\n   To use this authentication mechanism, the client MUST\
    \ possess a\n   certificate containing an ECDH-capable public key, and that\n\
    \   certificate MUST be signed with ECDSA.  Furthermore, the client's\n   ECDH\
    \ key MUST be on the same elliptic curve as the server's long-term\n   (certified)\
    \ ECDH key.  This might limit use of this mechanism to\n   closed environments.\
    \  In situations where the client has an ECC key\n   on a different curve, it\
    \ would have to authenticate using either\n   ECDSA_sign or a non-ECC mechanism\
    \ (e.g., RSA).  Using fixed ECDH for\n   both servers and clients is computationally\
    \ more efficient than\n   mechanisms providing forward secrecy.\n   When using\
    \ this authentication mechanism, the client MUST send an\n   empty ClientKeyExchange\
    \ as described in Section 5.7 and MUST NOT send\n   the CertificateVerify message.\
    \  The ClientKeyExchange is empty since\n   the client's ECDH public key required\
    \ by the server to compute the\n   premaster secret is available inside the client's\
    \ certificate.  The\n   client's ability to arrive at the same premaster secret\
    \ as the server\n   (demonstrated by a successful exchange of Finished messages)\
    \ proves\n   possession of the private key corresponding to the certified public\n\
    \   key, and the CertificateVerify message is unnecessary.\n"
- title: 3.3.  RSA_fixed_ECDH
  contents:
  - "3.3.  RSA_fixed_ECDH\n   This authentication mechanism is identical to ECDSA_fixed_ECDH\
    \ except\n   that the client's certificate MUST be signed with RSA.\n   Note that\
    \ while the ECDSA_sign, ECDSA_fixed_ECDH, and RSA_fixed_ECDH\n   client authentication\
    \ mechanisms require the client's certificate to\n   be signed with a particular\
    \ signature scheme, this specification does\n   not impose restrictions on signature\
    \ schemes used elsewhere in the\n   certificate chain.  (Often such restrictions\
    \ will be useful, and it\n   is expected that this will be taken into account\
    \ in certification\n   authorities' signing practices.  However, such restrictions\
    \ are not\n   strictly required in general: Even if it is beyond the capabilities\n\
    \   of a server to completely validate a given chain, the server may be\n   able\
    \ to validate the clients certificate by relying on a trust anchor\n   that appears\
    \ as one of the intermediate certificates in the chain.)\n"
- title: 4.  TLS Extensions for ECC
  contents:
  - "4.  TLS Extensions for ECC\n   Two new TLS extensions are defined in this specification:\
    \ (i) the\n   Supported Elliptic Curves Extension, and (ii) the Supported Point\n\
    \   Formats Extension.  These allow negotiating the use of specific\n   curves\
    \ and point formats (e.g., compressed vs. uncompressed,\n   respectively) during\
    \ a handshake starting a new session.  These\n   extensions are especially relevant\
    \ for constrained clients that may\n   only support a limited number of curves\
    \ or point formats.  They\n   follow the general approach outlined in [4]; message\
    \ details are\n   specified in Section 5.  The client enumerates the curves it\
    \ supports\n   and the point formats it can parse by including the appropriate\n\
    \   extensions in its ClientHello message.  The server similarly\n   enumerates\
    \ the point formats it can parse by including an extension\n   in its ServerHello\
    \ message.\n   A TLS client that proposes ECC cipher suites in its ClientHello\n\
    \   message SHOULD include these extensions.  Servers implementing ECC\n   cipher\
    \ suites MUST support these extensions, and when a client uses\n   these extensions,\
    \ servers MUST NOT negotiate the use of an ECC cipher\n   suite unless they can\
    \ complete the handshake while respecting the\n   choice of curves and compression\
    \ techniques specified by the client.\n   This eliminates the possibility that\
    \ a negotiated ECC handshake will\n   be subsequently aborted due to a client's\
    \ inability to deal with the\n   server's EC key.\n   The client MUST NOT include\
    \ these extensions in the ClientHello\n   message if it does not propose any ECC\
    \ cipher suites.  A client that\n   proposes ECC cipher suites may choose not\
    \ to include these\n   extensions.  In this case, the server is free to choose\
    \ any one of\n   the elliptic curves or point formats listed in Section 5.  That\n\
    \   section also describes the structure and processing of these\n   extensions\
    \ in greater detail.\n   In the case of session resumption, the server simply\
    \ ignores the\n   Supported Elliptic Curves Extension and the Supported Point\
    \ Formats\n   Extension appearing in the current ClientHello message.  These\n\
    \   extensions only play a role during handshakes negotiating a new\n   session.\n"
- title: 5.  Data Structures and Computations
  contents:
  - "5.  Data Structures and Computations\n   This section specifies the data structures\
    \ and computations used by\n   ECC-based key mechanisms specified in Sections\
    \ 2, 3, and 4.  The\n   presentation language used here is the same as that used\
    \ in TLS\n   [2][3].  Since this specification extends TLS, these descriptions\n\
    \   should be merged with those in the TLS specification and any others\n   that\
    \ extend TLS.  This means that enum types may not specify all\n   possible values,\
    \ and structures with multiple formats chosen with a\n   select() clause may not\
    \ indicate all possible cases.\n"
- title: 5.1.  Client Hello Extensions
  contents:
  - "5.1.  Client Hello Extensions\n   This section specifies two TLS extensions that\
    \ can be included with\n   the ClientHello message as described in [4], the Supported\
    \ Elliptic\n   Curves Extension and the Supported Point Formats Extension.\n \
    \  When these extensions are sent:\n   The extensions SHOULD be sent along with\
    \ any ClientHello message that\n   proposes ECC cipher suites.\n   Meaning of\
    \ these extensions:\n   These extensions allow a client to enumerate the elliptic\
    \ curves it\n   supports and/or the point formats it can parse.\n   Structure\
    \ of these extensions:\n   The general structure of TLS extensions is described\
    \ in [4], and this\n   specification adds two new types to ExtensionType.\n  \
    \     enum { elliptic_curves(10), ec_point_formats(11) } ExtensionType;\n   elliptic_curves\
    \ (Supported Elliptic Curves Extension):   Indicates\n      the set of elliptic\
    \ curves supported by the client.  For this\n      extension, the opaque extension_data\
    \ field contains\n      EllipticCurveList.  See Section 5.1.1 for details.\n \
    \  ec_point_formats (Supported Point Formats Extension):   Indicates the\n   \
    \   set of point formats that the client can parse.  For this\n      extension,\
    \ the opaque extension_data field contains\n      ECPointFormatList.  See Section\
    \ 5.1.2 for details.\n   Actions of the sender:\n   A client that proposes ECC\
    \ cipher suites in its ClientHello message\n   appends these extensions (along\
    \ with any others), enumerating the\n   curves it supports and the point formats\
    \ it can parse.  Clients\n   SHOULD send both the Supported Elliptic Curves Extension\
    \ and the\n   Supported Point Formats Extension.  If the Supported Point Formats\n\
    \   Extension is indeed sent, it MUST contain the value 0 (uncompressed)\n   as\
    \ one of the items in the list of point formats.\n   Actions of the receiver:\n\
    \   A server that receives a ClientHello containing one or both of these\n   extensions\
    \ MUST use the client's enumerated capabilities to guide its\n   selection of\
    \ an appropriate cipher suite.  One of the proposed ECC\n   cipher suites must\
    \ be negotiated only if the server can successfully\n   complete the handshake\
    \ while using the curves and point formats\n   supported by the client (cf. Sections\
    \ 5.3 and 5.4).\n   NOTE: A server participating in an ECDHE-ECDSA key exchange\
    \ may use\n   different curves for (i) the ECDSA key in its certificate, and (ii)\n\
    \   the ephemeral ECDH key in the ServerKeyExchange message.  The server\n   must\
    \ consider the extensions in both cases.\n   If a server does not understand the\
    \ Supported Elliptic Curves\n   Extension, does not understand the Supported Point\
    \ Formats Extension,\n   or is unable to complete the ECC handshake while restricting\
    \ itself\n   to the enumerated curves and point formats, it MUST NOT negotiate\
    \ the\n   use of an ECC cipher suite.  Depending on what other cipher suites\n\
    \   are proposed by the client and supported by the server, this may\n   result\
    \ in a fatal handshake failure alert due to the lack of common\n   cipher suites.\n"
- title: 5.1.1.  Supported Elliptic Curves Extension
  contents:
  - "5.1.1.  Supported Elliptic Curves Extension\n        enum {\n            sect163k1\
    \ (1), sect163r1 (2), sect163r2 (3),\n            sect193r1 (4), sect193r2 (5),\
    \ sect233k1 (6),\n            sect233r1 (7), sect239k1 (8), sect283k1 (9),\n \
    \           sect283r1 (10), sect409k1 (11), sect409r1 (12),\n            sect571k1\
    \ (13), sect571r1 (14), secp160k1 (15),\n            secp160r1 (16), secp160r2\
    \ (17), secp192k1 (18),\n            secp192r1 (19), secp224k1 (20), secp224r1\
    \ (21),\n            secp256k1 (22), secp256r1 (23), secp384r1 (24),\n       \
    \     secp521r1 (25),\n            reserved (0xFE00..0xFEFF),\n            arbitrary_explicit_prime_curves(0xFF01),\n\
    \            arbitrary_explicit_char2_curves(0xFF02),\n            (0xFFFF)\n\
    \        } NamedCurve;\n   sect163k1, etc:   Indicates support of the corresponding\
    \ named curve\n      or class of explicitly defined curves.  The named curves\
    \ defined\n      here are those specified in SEC 2 [13].  Note that many of these\n\
    \      curves are also recommended in ANSI X9.62 [7] and FIPS 186-2 [11].\n  \
    \    Values 0xFE00 through 0xFEFF are reserved for private use.  Values\n    \
    \  0xFF01 and 0xFF02 indicate that the client supports arbitrary\n      prime\
    \ and characteristic-2 curves, respectively (the curve\n      parameters must\
    \ be encoded explicitly in ECParameters).\n   The NamedCurve name space is maintained\
    \ by IANA.  See Section 8 for\n   information on how new value assignments are\
    \ added.\n        struct {\n            NamedCurve elliptic_curve_list<1..2^16-1>\n\
    \        } EllipticCurveList;\n   Items in elliptic_curve_list are ordered according\
    \ to the client's\n   preferences (favorite choice first).\n   As an example,\
    \ a client that only supports secp192r1 (aka NIST P-192;\n   value 19 = 0x0013)\
    \ and secp224r1 (aka NIST P-224; value 21 = 0x0015)\n   and prefers to use secp192r1\
    \ would include a TLS extension consisting\n   of the following octets.  Note\
    \ that the first two octets indicate the\n   extension type (Supported Elliptic\
    \ Curves Extension):\n        00 0A 00 06 00 04 00 13 00 15\n   A client that\
    \ supports arbitrary explicit characteristic-2 curves\n   (value 0xFF02) would\
    \ include an extension consisting of the following\n   octets:\n        00 0A\
    \ 00 04 00 02 FF 02\n"
- title: 5.1.2.  Supported Point Formats Extension
  contents:
  - "5.1.2.  Supported Point Formats Extension\n        enum { uncompressed (0), ansiX962_compressed_prime\
    \ (1),\n               ansiX962_compressed_char2 (2), reserved (248..255)\n  \
    \      } ECPointFormat;\n        struct {\n            ECPointFormat ec_point_format_list<1..2^8-1>\n\
    \        } ECPointFormatList;\n   Three point formats are included in the definition\
    \ of ECPointFormat\n   above.  The uncompressed point format is the default format\
    \ in that\n   implementations of this document MUST support it for all of their\n\
    \   supported curves.  Compressed point formats reduce bandwidth by\n   including\
    \ only the x-coordinate and a single bit of the y-coordinate\n   of the point.\
    \  Implementations of this document MAY support the\n   ansiX962_compressed_prime\
    \ and ansiX962_compressed_char2 formats,\n   where the former applies only to\
    \ prime curves and the latter applies\n   only to characteristic-2 curves.  (These\
    \ formats are specified in\n   [7].)  Values 248 through 255 are reserved for\
    \ private use.\n   The ECPointFormat name space is maintained by IANA.  See Section\
    \ 8\n   for information on how new value assignments are added.\n   Items in ec_point_format_list\
    \ are ordered according to the client's\n   preferences (favorite choice first).\n\
    \   A client that can parse only the uncompressed point format (value 0)\n   includes\
    \ an extension consisting of the following octets; note that\n   the first two\
    \ octets indicate the extension type (Supported Point\n   Formats Extension):\n\
    \        00 0B 00 02 01 00\n   A client that in the case of prime fields prefers\
    \ the compressed\n   format (ansiX962_compressed_prime, value 1) over the uncompressed\n\
    \   format (value 0), but in the case of characteristic-2 fields prefers\n   the\
    \ uncompressed format (value 0) over the compressed format\n   (ansiX962_compressed_char2,\
    \ value 2), may indicate these preferences\n   by including an extension consisting\
    \ of the following octets:\n        00 0B 00 04 03 01 00 02\n"
- title: 5.2.  Server Hello Extension
  contents:
  - "5.2.  Server Hello Extension\n   This section specifies a TLS extension that\
    \ can be included with the\n   ServerHello message as described in [4], the Supported\
    \ Point Formats\n   Extension.\n   When this extension is sent:\n   The Supported\
    \ Point Formats Extension is included in a ServerHello\n   message in response\
    \ to a ClientHello message containing the Supported\n   Point Formats Extension\
    \ when negotiating an ECC cipher suite.\n   Meaning of this extension:\n   This\
    \ extension allows a server to enumerate the point formats it can\n   parse (for\
    \ the curve that will appear in its ServerKeyExchange\n   message when using the\
    \ ECDHE_ECDSA, ECDHE_RSA, or ECDH_anon key\n   exchange algorithm, or for the\
    \ curve that is used in the server's\n   public key that will appear in its Certificate\
    \ message when using the\n   ECDH_ECDSA or ECDH_RSA key exchange algorithm).\n\
    \   Structure of this extension:\n   The server's Supported Point Formats Extension\
    \ has the same structure\n   as the client's Supported Point Formats Extension\
    \ (see\n   Section 5.1.2).  Items in elliptic_curve_list here are ordered\n  \
    \ according to the server's preference (favorite choice first).  Note\n   that\
    \ the server may include items that were not found in the client's\n   list (e.g.,\
    \ the server may prefer to receive points in compressed\n   format even when a\
    \ client cannot parse this format: the same client\n   may nevertheless be capable\
    \ of outputting points in compressed\n   format).\n   Actions of the sender:\n\
    \   A server that selects an ECC cipher suite in response to a\n   ClientHello\
    \ message including a Supported Point Formats Extension\n   appends this extension\
    \ (along with others) to its ServerHello\n   message, enumerating the point formats\
    \ it can parse.  The Supported\n   Point Formats Extension, when used, MUST contain\
    \ the value 0\n   (uncompressed) as one of the items in the list of point formats.\n\
    \   Actions of the receiver:\n   A client that receives a ServerHello message\
    \ containing a Supported\n   Point Formats Extension MUST respect the server's\
    \ choice of point\n   formats during the handshake (cf. Sections 5.6 and 5.7).\
    \  If no\n   Supported Point Formats Extension is received with the ServerHello,\n\
    \   this is equivalent to an extension allowing only the uncompressed\n   point\
    \ format.\n"
- title: 5.3.  Server Certificate
  contents:
  - "5.3.  Server Certificate\n   When this message is sent:\n   This message is sent\
    \ in all non-anonymous ECC-based key exchange\n   algorithms.\n   Meaning of this\
    \ message:\n   This message is used to authentically convey the server's static\n\
    \   public key to the client.  The following table shows the server\n   certificate\
    \ type appropriate for each key exchange algorithm.  ECC\n   public keys MUST\
    \ be encoded in certificates as described in\n   Section 5.9.\n   NOTE: The server's\
    \ Certificate message is capable of carrying a chain\n   of certificates.  The\
    \ restrictions mentioned in Table 3 apply only to\n   the server's certificate\
    \ (first in the chain).\n          Key Exchange Algorithm  Server Certificate\
    \ Type\n          ----------------------  -----------------------\n          ECDH_ECDSA\
    \              Certificate MUST contain an\n                                 \
    \ ECDH-capable public key.  It\n                                  MUST be signed\
    \ with ECDSA.\n          ECDHE_ECDSA             Certificate MUST contain an\n\
    \                                  ECDSA-capable public key.  It\n           \
    \                       MUST be signed with ECDSA.\n          ECDH_RSA       \
    \         Certificate MUST contain an\n                                  ECDH-capable\
    \ public key.  It\n                                  MUST be signed with RSA.\n\
    \          ECDHE_RSA               Certificate MUST contain an\n             \
    \                     RSA public key authorized for\n                        \
    \          use in digital signatures.  It\n                                  MUST\
    \ be signed with RSA.\n                    Table 3: Server Certificate Types\n\
    \   Structure of this message:\n   Identical to the TLS Certificate format.\n\
    \   Actions of the sender:\n   The server constructs an appropriate certificate\
    \ chain and conveys it\n   to the client in the Certificate message.  If the client\
    \ has used a\n   Supported Elliptic Curves Extension, the public key in the server's\n\
    \   certificate MUST respect the client's choice of elliptic curves; in\n   particular,\
    \ the public key MUST employ a named curve (not the same\n   curve as an explicit\
    \ curve) unless the client has indicated support\n   for explicit curves of the\
    \ appropriate type.  If the client has used\n   a Supported Point Formats Extension,\
    \ both the server's public key\n   point and (in the case of an explicit curve)\
    \ the curve's base point\n   MUST respect the client's choice of point formats.\
    \  (A server that\n   cannot satisfy these requirements MUST NOT choose an ECC\
    \ cipher suite\n   in its ServerHello message.)\n   Actions of the receiver:\n\
    \   The client validates the certificate chain, extracts the server's\n   public\
    \ key, and checks that the key type is appropriate for the\n   negotiated key\
    \ exchange algorithm.  (A possible reason for a fatal\n   handshake failure is\
    \ that the client's capabilities for handling\n   elliptic curves and point formats\
    \ are exceeded; cf. Section 5.1.)\n"
- title: 5.4.  Server Key Exchange
  contents:
  - "5.4.  Server Key Exchange\n   When this message is sent:\n   This message is\
    \ sent when using the ECDHE_ECDSA, ECDHE_RSA, and\n   ECDH_anon key exchange algorithms.\n\
    \   Meaning of this message:\n   This message is used to convey the server's ephemeral\
    \ ECDH public key\n   (and the corresponding elliptic curve domain parameters)\
    \ to the\n   client.\n   Structure of this message:\n        enum { explicit_prime\
    \ (1), explicit_char2 (2),\n               named_curve (3), reserved(248..255)\
    \ } ECCurveType;\n   explicit_prime:   Indicates the elliptic curve domain parameters\
    \ are\n      conveyed verbosely, and the underlying finite field is a prime\n\
    \      field.\n   explicit_char2:   Indicates the elliptic curve domain parameters\
    \ are\n      conveyed verbosely, and the underlying finite field is a\n      characteristic-2\
    \ field.\n   named_curve:   Indicates that a named curve is used.  This option\n\
    \      SHOULD be used when applicable.\n   Values 248 through 255 are reserved\
    \ for private use.\n   The ECCurveType name space is maintained by IANA.  See\
    \ Section 8 for\n   information on how new value assignments are added.\n    \
    \    struct {\n            opaque a <1..2^8-1>;\n            opaque b <1..2^8-1>;\n\
    \        } ECCurve;\n   a, b:   These parameters specify the coefficients of the\
    \ elliptic\n      curve.  Each value contains the byte string representation of\
    \ a\n      field element following the conversion routine in Section 4.3.3 of\n\
    \      ANSI X9.62 [7].\n        struct {\n            opaque point <1..2^8-1>;\n\
    \        } ECPoint;\n   point:   This is the byte string representation of an\
    \ elliptic curve\n      point following the conversion routine in Section 4.3.6\
    \ of ANSI\n      X9.62 [7].  This byte string may represent an elliptic curve\
    \ point\n      in uncompressed or compressed format; it MUST conform to what the\n\
    \      client has requested through a Supported Point Formats Extension\n    \
    \  if this extension was used.\n        enum { ec_basis_trinomial, ec_basis_pentanomial\
    \ } ECBasisType;\n   ec_basis_trinomial:   Indicates representation of a characteristic-2\n\
    \      field using a trinomial basis.\n   ec_basis_pentanomial:   Indicates representation\
    \ of a\n      characteristic-2 field using a pentanomial basis.\n        struct\
    \ {\n            ECCurveType    curve_type;\n            select (curve_type) {\n\
    \                case explicit_prime:\n                    opaque      prime_p\
    \ <1..2^8-1>;\n                    ECCurve     curve;\n                    ECPoint\
    \     base;\n                    opaque      order <1..2^8-1>;\n             \
    \       opaque      cofactor <1..2^8-1>;\n                case explicit_char2:\n\
    \                    uint16      m;\n                    ECBasisType basis;\n\
    \                    select (basis) {\n                        case ec_trinomial:\n\
    \                            opaque  k <1..2^8-1>;\n                        case\
    \ ec_pentanomial:\n                            opaque  k1 <1..2^8-1>;\n      \
    \                      opaque  k2 <1..2^8-1>;\n                            opaque\
    \  k3 <1..2^8-1>;\n                    };\n                    ECCurve     curve;\n\
    \                    ECPoint     base;\n                    opaque      order\
    \ <1..2^8-1>;\n                    opaque      cofactor <1..2^8-1>;\n        \
    \        case named_curve:\n                    NamedCurve namedcurve;\n     \
    \       };\n        } ECParameters;\n   curve_type:   This identifies the type\
    \ of the elliptic curve domain\n      parameters.\n   prime_p:   This is the odd\
    \ prime defining the field Fp.\n   curve:   Specifies the coefficients a and b\
    \ of the elliptic curve E.\n   base:   Specifies the base point G on the elliptic\
    \ curve.\n   order:   Specifies the order n of the base point.\n   cofactor: \
    \  Specifies the cofactor h = #E(Fq)/n, where #E(Fq)\n      represents the number\
    \ of points on the elliptic curve E defined\n      over the field Fq (either Fp\
    \ or F2^m).\n   m:   This is the degree of the characteristic-2 field F2^m.\n\
    \   k:   The exponent k for the trinomial basis representation x^m + x^k\n   \
    \   +1.\n   k1, k2, k3:   The exponents for the pentanomial representation x^m\
    \ +\n      x^k3 + x^k2 + x^k1 + 1 (such that k3 > k2 > k1).\n   namedcurve:  \
    \ Specifies a recommended set of elliptic curve domain\n      parameters.  All\
    \ those values of NamedCurve are allowed that refer\n      to a specific curve.\
    \  Values of NamedCurve that indicate support\n      for a class of explicitly\
    \ defined curves are not allowed here\n      (they are only permissible in the\
    \ ClientHello extension); this\n      applies to arbitrary_explicit_prime_curves(0xFF01)\
    \ and\n      arbitrary_explicit_char2_curves(0xFF02).\n        struct {\n    \
    \        ECParameters    curve_params;\n            ECPoint         public;\n\
    \        } ServerECDHParams;\n   curve_params:   Specifies the elliptic curve\
    \ domain parameters\n      associated with the ECDH public key.\n   public:  \
    \ The ephemeral ECDH public key.\n   The ServerKeyExchange message is extended\
    \ as follows.\n        enum { ec_diffie_hellman } KeyExchangeAlgorithm;\n   ec_diffie_hellman:\
    \   Indicates the ServerKeyExchange message contains\n      an ECDH public key.\n\
    \        select (KeyExchangeAlgorithm) {\n            case ec_diffie_hellman:\n\
    \                ServerECDHParams    params;\n                Signature      \
    \     signed_params;\n        } ServerKeyExchange;\n   params:   Specifies the\
    \ ECDH public key and associated domain\n      parameters.\n   signed_params:\
    \   A hash of the params, with the signature appropriate\n      to that hash applied.\
    \  The private key corresponding to the\n      certified public key in the server's\
    \ Certificate message is used\n      for signing.\n          enum { ecdsa } SignatureAlgorithm;\n\
    \          select (SignatureAlgorithm) {\n              case ecdsa:\n        \
    \          digitally-signed struct {\n                      opaque sha_hash[sha_size];\n\
    \                  };\n          } Signature;\n        ServerKeyExchange.signed_params.sha_hash\n\
    \            SHA(ClientHello.random + ServerHello.random +\n                 \
    \                             ServerKeyExchange.params);\n   NOTE: SignatureAlgorithm\
    \ is \"rsa\" for the ECDHE_RSA key exchange\n   algorithm and \"anonymous\" for\
    \ ECDH_anon.  These cases are defined in\n   TLS [2][3].  SignatureAlgorithm is\
    \ \"ecdsa\" for ECDHE_ECDSA.  ECDSA\n   signatures are generated and verified\
    \ as described in Section 5.10,\n   and SHA in the above template for sha_hash\
    \ accordingly may denote a\n   hash algorithm other than SHA-1.  As per ANSI X9.62,\
    \ an ECDSA\n   signature consists of a pair of integers, r and s.  The digitally-\n\
    \   signed element is encoded as an opaque vector <0..2^16-1>, the\n   contents\
    \ of which are the DER encoding [9] corresponding to the\n   following ASN.1 notation\
    \ [8].\n           Ecdsa-Sig-Value ::= SEQUENCE {\n               r       INTEGER,\n\
    \               s       INTEGER\n           }\n   Actions of the sender:\n   The\
    \ server selects elliptic curve domain parameters and an ephemeral\n   ECDH public\
    \ key corresponding to these parameters according to the\n   ECKAS-DH1 scheme\
    \ from IEEE 1363 [6].  It conveys this information to\n   the client in the ServerKeyExchange\
    \ message using the format defined\n   above.\n   Actions of the receiver:\n \
    \  The client verifies the signature (when present) and retrieves the\n   server's\
    \ elliptic curve domain parameters and ephemeral ECDH public\n   key from the\
    \ ServerKeyExchange message.  (A possible reason for a\n   fatal handshake failure\
    \ is that the client's capabilities for\n   handling elliptic curves and point\
    \ formats are exceeded;\n   cf. Section 5.1.)\n"
- title: 5.5.  Certificate Request
  contents:
  - "5.5.  Certificate Request\n   When this message is sent:\n   This message is\
    \ sent when requesting client authentication.\n   Meaning of this message:\n \
    \  The server uses this message to suggest acceptable client\n   authentication\
    \ methods.\n   Structure of this message:\n   The TLS CertificateRequest message\
    \ is extended as follows.\n        enum {\n            ecdsa_sign(64), rsa_fixed_ecdh(65),\n\
    \            ecdsa_fixed_ecdh(66), (255)\n        } ClientCertificateType;\n \
    \  ecdsa_sign, etc.  Indicates that the server would like to use the\n      corresponding\
    \ client authentication method specified in Section 3.\n   Actions of the sender:\n\
    \   The server decides which client authentication methods it would like\n   to\
    \ use, and conveys this information to the client using the format\n   defined\
    \ above.\n   Actions of the receiver:\n   The client determines whether it has\
    \ a suitable certificate for use\n   with any of the requested methods and whether\
    \ to proceed with client\n   authentication.\n"
- title: 5.6.  Client Certificate
  contents:
  - "5.6.  Client Certificate\n   When this message is sent:\n   This message is sent\
    \ in response to a CertificateRequest when a\n   client has a suitable certificate\
    \ and has decided to proceed with\n   client authentication.  (Note that if the\
    \ server has used a Supported\n   Point Formats Extension, a certificate can only\
    \ be considered\n   suitable for use with the ECDSA_sign, RSA_fixed_ECDH, and\n\
    \   ECDSA_fixed_ECDH authentication methods if the public key point\n   specified\
    \ in it respects the server's choice of point formats.  If no\n   Supported Point\
    \ Formats Extension has been used, a certificate can\n   only be considered suitable\
    \ for use with these authentication methods\n   if the point is represented in\
    \ uncompressed point format.)\n   Meaning of this message:\n   This message is\
    \ used to authentically convey the client's static\n   public key to the server.\
    \  The following table summarizes what client\n   certificate types are appropriate\
    \ for the ECC-based client\n   authentication mechanisms described in Section\
    \ 3.  ECC public keys\n   must be encoded in certificates as described in Section\
    \ 5.9.\n   NOTE: The client's Certificate message is capable of carrying a chain\n\
    \   of certificates.  The restrictions mentioned in Table 4 apply only to\n  \
    \ the client's certificate (first in the chain).\n          Client\n         \
    \ Authentication Method   Client Certificate Type\n          ---------------------\
    \   -----------------------\n          ECDSA_sign              Certificate MUST\
    \ contain an\n                                  ECDSA-capable public key and\n\
    \                                  be signed with ECDSA.\n          ECDSA_fixed_ECDH\
    \        Certificate MUST contain an\n                                  ECDH-capable\
    \ public key on the\n                                  same elliptic curve as\
    \ the server's\n                                  long-term ECDH key.  This certificate\n\
    \                                  MUST be signed with ECDSA.\n          RSA_fixed_ECDH\
    \          Certificate MUST contain an\n                                  ECDH-capable\
    \ public key on the\n                                  same elliptic curve as\
    \ the server's\n                                  long-term ECDH key.  This certificate\n\
    \                                  MUST be signed with RSA.\n                \
    \     Table 4: Client Certificate Types\n   Structure of this message:\n   Identical\
    \ to the TLS client Certificate format.\n   Actions of the sender:\n   The client\
    \ constructs an appropriate certificate chain, and conveys\n   it to the server\
    \ in the Certificate message.\n   Actions of the receiver:\n   The TLS server\
    \ validates the certificate chain, extracts the client's\n   public key, and checks\
    \ that the key type is appropriate for the\n   client authentication method.\n"
- title: 5.7.  Client Key Exchange
  contents:
  - "5.7.  Client Key Exchange\n   When this message is sent:\n   This message is\
    \ sent in all key exchange algorithms.  If client\n   authentication with ECDSA_fixed_ECDH\
    \ or RSA_fixed_ECDH is used, this\n   message is empty.  Otherwise, it contains\
    \ the client's ephemeral ECDH\n   public key.\n   Meaning of the message:\n  \
    \ This message is used to convey ephemeral data relating to the key\n   exchange\
    \ belonging to the client (such as its ephemeral ECDH public\n   key).\n   Structure\
    \ of this message:\n   The TLS ClientKeyExchange message is extended as follows.\n\
    \        enum { implicit, explicit } PublicValueEncoding;\n   implicit, explicit:\
    \   For ECC cipher suites, this indicates whether\n      the client's ECDH public\
    \ key is in the client's certificate\n      (\"implicit\") or is provided, as\
    \ an ephemeral ECDH public key, in\n      the ClientKeyExchange message (\"explicit\"\
    ).  (This is \"explicit\"\n      in ECC cipher suites except when the client uses\
    \ the\n      ECDSA_fixed_ECDH or RSA_fixed_ECDH client authentication\n      mechanism.)\n\
    \        struct {\n            select (PublicValueEncoding) {\n              \
    \  case implicit: struct { };\n                case explicit: ECPoint ecdh_Yc;\n\
    \            } ecdh_public;\n        } ClientECDiffieHellmanPublic;\n   ecdh_Yc:\
    \   Contains the client's ephemeral ECDH public key as a byte\n      string ECPoint.point,\
    \ which may represent an elliptic curve point\n      in uncompressed or compressed\
    \ format.  Here, the format MUST\n      conform to what the server has requested\
    \ through a Supported Point\n      Formats Extension if this extension was used,\
    \ and MUST be\n      uncompressed if this extension was not used.\n        struct\
    \ {\n            select (KeyExchangeAlgorithm) {\n                case ec_diffie_hellman:\
    \ ClientECDiffieHellmanPublic;\n            } exchange_keys;\n        } ClientKeyExchange;\n\
    \   Actions of the sender:\n   The client selects an ephemeral ECDH public key\
    \ corresponding to the\n   parameters it received from the server according to\
    \ the ECKAS-DH1\n   scheme from IEEE 1363 [6].  It conveys this information to\
    \ the client\n   in the ClientKeyExchange message using the format defined above.\n\
    \   Actions of the receiver:\n   The server retrieves the client's ephemeral ECDH\
    \ public key from the\n   ClientKeyExchange message and checks that it is on the\
    \ same elliptic\n   curve as the server's ECDH key.\n"
- title: 5.8.  Certificate Verify
  contents:
  - "5.8.  Certificate Verify\n   When this message is sent:\n   This message is sent\
    \ when the client sends a client certificate\n   containing a public key usable\
    \ for digital signatures, e.g., when the\n   client is authenticated using the\
    \ ECDSA_sign mechanism.\n   Meaning of the message:\n   This message contains\
    \ a signature that proves possession of the\n   private key corresponding to the\
    \ public key in the client's\n   Certificate message.\n   Structure of this message:\n\
    \   The TLS CertificateVerify message and the underlying Signature type\n   are\
    \ defined in [2] and [3], and the latter is extended here in\n   Section 5.4.\
    \  For the ecdsa case, the signature field in the\n   CertificateVerify message\
    \ contains an ECDSA signature computed over\n   handshake messages exchanged so\
    \ far, exactly similar to\n   CertificateVerify with other signing algorithms\
    \ in [2] and [3]:\n        CertificateVerify.signature.sha_hash\n            SHA(handshake_messages);\n\
    \   ECDSA signatures are computed as described in Section 5.10, and SHA\n   in\
    \ the above template for sha_hash accordingly may denote a hash\n   algorithm\
    \ other than SHA-1.  As per ANSI X9.62, an ECDSA signature\n   consists of a pair\
    \ of integers, r and s.  The digitally-signed\n   element is encoded as an opaque\
    \ vector <0..2^16-1>, the contents of\n   which are the DER encoding [9] corresponding\
    \ to the following ASN.1\n   notation [8].\n        Ecdsa-Sig-Value ::= SEQUENCE\
    \ {\n            r       INTEGER,\n            s       INTEGER\n        }\n  \
    \ Actions of the sender:\n   The client computes its signature over all handshake\
    \ messages sent or\n   received starting at client hello and up to but not including\
    \ this\n   message.  It uses the private key corresponding to its certified\n\
    \   public key to compute the signature, which is conveyed in the format\n   defined\
    \ above.\n   Actions of the receiver:\n   The server extracts the client's signature\
    \ from the CertificateVerify\n   message, and verifies the signature using the\
    \ public key it received\n   in the client's Certificate message.\n"
- title: 5.9.  Elliptic Curve Certificates
  contents:
  - "5.9.  Elliptic Curve Certificates\n   X.509 certificates containing ECC public\
    \ keys or signed using ECDSA\n   MUST comply with [14] or another RFC that replaces\
    \ or extends it.\n   Clients SHOULD use the elliptic curve domain parameters recommended\n\
    \   in ANSI X9.62 [7], FIPS 186-2 [11], and SEC 2 [13].\n"
- title: 5.10.  ECDH, ECDSA, and RSA Computations
  contents:
  - "5.10.  ECDH, ECDSA, and RSA Computations\n   All ECDH calculations (including\
    \ parameter and key generation as well\n   as the shared secret calculation) are\
    \ performed according to [6]\n   using the ECKAS-DH1 scheme with the identity\
    \ map as key derivation\n   function (KDF), so that the premaster secret is the\
    \ x-coordinate of\n   the ECDH shared secret elliptic curve point represented\
    \ as an octet\n   string.  Note that this octet string (Z in IEEE 1363 terminology)\
    \ as\n   output by FE2OSP, the Field Element to Octet String Conversion\n   Primitive,\
    \ has constant length for any given field; leading zeros\n   found in this octet\
    \ string MUST NOT be truncated.\n   (Note that this use of the identity KDF is\
    \ a technicality.  The\n   complete picture is that ECDH is employed with a non-trivial\
    \ KDF\n   because TLS does not directly use the premaster secret for anything\n\
    \   other than for computing the master secret.  As of TLS 1.0 [2] and\n   1.1\
    \ [3], this means that the MD5- and SHA-1-based TLS PRF serves as a\n   KDF; it\
    \ is conceivable that future TLS versions or new TLS extensions\n   introduced\
    \ in the future may vary this computation.)\n   All ECDSA computations MUST be\
    \ performed according to ANSI X9.62 [7]\n   or its successors.  Data to be signed/verified\
    \ is hashed, and the\n   result run directly through the ECDSA algorithm with\
    \ no additional\n   hashing.  The default hash function is SHA-1 [10], and sha_size\
    \ (see\n   Sections 5.4 and 5.8) is 20.  However, an alternative hash function,\n\
    \   such as one of the new SHA hash functions specified in FIPS 180-2\n   [10],\
    \ may be used instead if the certificate containing the EC public\n   key explicitly\
    \ requires use of another hash function.  (The mechanism\n   for specifying the\
    \ required hash function has not been standardized,\n   but this provision anticipates\
    \ such standardization and obviates the\n   need to update this document in response.\
    \  Future PKIX RFCs may\n   choose, for example, to specify the hash function\
    \ to be used with a\n   public key in the parameters field of subjectPublicKeyInfo.)\n\
    \   All RSA signatures must be generated and verified according to PKCS#1\n  \
    \ [12] block type 1.\n"
- title: 6.  Cipher Suites
  contents:
  - "6.  Cipher Suites\n   The table below defines new ECC cipher suites that use\
    \ the key\n   exchange algorithms specified in Section 2.\n     CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA\
    \           = { 0xC0, 0x01 }\n     CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA\
    \        = { 0xC0, 0x02 }\n     CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\
    \   = { 0xC0, 0x03 }\n     CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA   \
    \ = { 0xC0, 0x04 }\n     CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA    =\
    \ { 0xC0, 0x05 }\n     CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA          = {\
    \ 0xC0, 0x06 }\n     CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA       = { 0xC0,\
    \ 0x07 }\n     CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA  = { 0xC0, 0x08\
    \ }\n     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA   = { 0xC0, 0x09 }\n\
    \     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA   = { 0xC0, 0x0A }\n  \
    \   CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA             = { 0xC0, 0x0B }\n    \
    \ CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA          = { 0xC0, 0x0C }\n     CipherSuite\
    \ TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA     = { 0xC0, 0x0D }\n     CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\
    \      = { 0xC0, 0x0E }\n     CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA  \
    \    = { 0xC0, 0x0F }\n     CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA          \
    \  = { 0xC0, 0x10 }\n     CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA         =\
    \ { 0xC0, 0x11 }\n     CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA    = {\
    \ 0xC0, 0x12 }\n     CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA     = { 0xC0,\
    \ 0x13 }\n     CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA     = { 0xC0, 0x14\
    \ }\n     CipherSuite TLS_ECDH_anon_WITH_NULL_SHA            = { 0xC0, 0x15 }\n\
    \     CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA         = { 0xC0, 0x16 }\n  \
    \   CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA    = { 0xC0, 0x17 }\n    \
    \ CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA     = { 0xC0, 0x18 }\n     CipherSuite\
    \ TLS_ECDH_anon_WITH_AES_256_CBC_SHA     = { 0xC0, 0x19 }\n                  \
    \      Table 5: TLS ECC cipher suites\n   The key exchange method, cipher, and\
    \ hash algorithm for each of these\n   cipher suites are easily determined by\
    \ examining the name.  Ciphers\n   (other than AES ciphers) and hash algorithms\
    \ are defined in [2] and\n   [3].  AES ciphers are defined in [19].\n   Server\
    \ implementations SHOULD support all of the following cipher\n   suites, and client\
    \ implementations SHOULD support at least one of\n   them: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,\n\
    \   TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,\n   TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,\
    \ and\n   TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Security issues are discussed throughout this\
    \ memo.\n   For TLS handshakes using ECC cipher suites, the security\n   considerations\
    \ in appendices D.2 and D.3 of [2] and [3] apply\n   accordingly.\n   Security\
    \ discussions specific to ECC can be found in [6] and [7].\n   One important issue\
    \ that implementers and users must consider is\n   elliptic curve selection. \
    \ Guidance on selecting an appropriate\n   elliptic curve size is given in Table\
    \ 1.\n   Beyond elliptic curve size, the main issue is elliptic curve\n   structure.\
    \  As a general principle, it is more conservative to use\n   elliptic curves\
    \ with as little algebraic structure as possible.\n   Thus, random curves are\
    \ more conservative than special curves such as\n   Koblitz curves, and curves\
    \ over F_p with p random are more\n   conservative than curves over F_p with p\
    \ of a special form (and\n   curves over F_p with p random might be considered\
    \ more conservative\n   than curves over F_2^m as there is no choice between multiple\
    \ fields\n   of similar size for characteristic 2).  Note, however, that algebraic\n\
    \   structure can also lead to implementation efficiencies, and\n   implementers\
    \ and users may, therefore, need to balance conservatism\n   against a need for\
    \ efficiency.  Concrete attacks are known against\n   only very few special classes\
    \ of curves, such as supersingular\n   curves, and these classes are excluded\
    \ from the ECC standards that\n   this document references [6], [7].\n   Another\
    \ issue is the potential for catastrophic failures when a\n   single elliptic\
    \ curve is widely used.  In this case, an attack on the\n   elliptic curve might\
    \ result in the compromise of a large number of\n   keys.  Again, this concern\
    \ may need to be balanced against efficiency\n   and interoperability improvements\
    \ associated with widely-used curves.\n   Substantial additional information on\
    \ elliptic curve choice can be\n   found in [5], [6], [7], and [11].\n   Implementers\
    \ and users must also consider whether they need forward\n   secrecy.  Forward\
    \ secrecy refers to the property that session keys\n   are not compromised if\
    \ the static, certified keys belonging to the\n   server and client are compromised.\
    \  The ECDHE_ECDSA and ECDHE_RSA key\n   exchange algorithms provide forward secrecy\
    \ protection in the event\n   of server key compromise, while ECDH_ECDSA and ECDH_RSA\
    \ do not.\n   Similarly, if the client is providing a static, certified key,\n\
    \   ECDSA_sign client authentication provides forward secrecy protection\n   in\
    \ the event of client key compromise, while ECDSA_fixed_ECDH and\n   RSA_fixed_ECDH\
    \ do not.  Thus, to obtain complete forward secrecy\n   protection, ECDHE_ECDSA\
    \ or ECDHE_RSA must be used for key exchange,\n   with ECDSA_sign used for client\
    \ authentication if necessary.  Here\n   again the security benefits of forward\
    \ secrecy may need to be\n   balanced against the improved efficiency offered\
    \ by other options.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document describes three new name spaces for\
    \ use with the TLS\n   protocol:\n   o  NamedCurve (Section 5.1)\n   o  ECPointFormat\
    \ (Section 5.1)\n   o  ECCurveType (Section 5.4)\n   For each name space, this\
    \ document defines the initial value\n   assignments and defines a range of 256\
    \ values (NamedCurve) or eight\n   values (ECPointFormat and ECCurveType) reserved\
    \ for Private Use.  Any\n   additional assignments require IETF Consensus action\
    \ [16].\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   The authors wish to thank Bill Anderson and Tim Dierks.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [1]   Bradner, S., \"Key Words for Use in RFCs\
    \ to Indicate Requirement\n         Levels\", RFC 2119, March 1997.\n   [2]  \
    \ Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\",\n         RFC 2246,\
    \ January 1999.\n   [3]   Dierks, T. and E. Rescorla, \"The Transport Layer Security\
    \ (TLS)\n         Protocol Version 1.1\", RFC 4346, April 2006.\n   [4]   Blake-Wilson,\
    \ S., Nystrom, M., Hopwood, D., Mikkelsen, J., and\n         T. Wright, \"Transport\
    \ Layer Security (TLS) Extensions\", RFC\n         4366, April 2006.\n   [5] \
    \  SECG, \"Elliptic Curve Cryptography\", SEC 1, 2000,\n         <http://www.secg.org/>.\n\
    \   [6]   IEEE, \"Standard Specifications for Public Key Cryptography\",\n   \
    \      IEEE 1363, 2000.\n   [7]   ANSI, \"Public Key Cryptography For The Financial\
    \ Services\n         Industry: The Elliptic Curve Digital Signature Algorithm\n\
    \         (ECDSA)\", ANSI X9.62, 1998.\n   [8]   International Telecommunication\
    \ Union, \"Information technology\n         - Abstract Syntax Notation One (ASN.1):\
    \ Specification of basic\n         notation\", ITU-T Recommendation X.680, 2002.\n\
    \   [9]   International Telecommunication Union, \"Information technology\n  \
    \       - ASN.1 encoding rules: Specification of Basic Encoding Rules\n      \
    \   (BER), Canonical Encoding Rules (CER) and Distinguished\n         Encoding\
    \ Rules (DER)\", ITU-T Recommendation X.690, 2002.\n   [10]  NIST, \"Secure Hash\
    \ Standard\", FIPS 180-2, 2002.\n   [11]  NIST, \"Digital Signature Standard\"\
    , FIPS 186-2, 2000.\n   [12]  RSA Laboratories, \"PKCS#1: RSA Encryption Standard\
    \ version\n         1.5\", PKCS 1, November 1993.\n   [13]  SECG, \"Recommended\
    \ Elliptic Curve Domain Parameters\", SEC 2,\n         2000, <http://www.secg.org/>.\n\
    \   [14]  Polk, T., Housley, R., and L. Bassham, \"Algorithms and\n         Identifiers\
    \ for the Internet X.509 Public Key Infrastructure\n         Certificate and Certificate\
    \ Revocation List (CRL) Profile\",\n         RFC 3279, April 2002.\n   [15]  Housley,\
    \ R., Polk, T., Ford, W., and D. Solo, \"Internet X.509\n         Public Key Infrastructure\
    \ Certificate and Certificate\n         Revocation List (CRL) Profile\", RFC 3280,\
    \ April 2002.\n   [16]  Narten, T. and H. Alvestrand, \"Guidelines for Writing\
    \ an IANA\n         Considerations Section in RFCs\", RFC 2434, October 1998.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [17]  Harper, G., Menezes, A., and S. Vanstone,\
    \ \"Public-Key\n         Cryptosystems with Very Small Key Lengths\", Advances\
    \ in\n         Cryptology -- EUROCRYPT '92, LNCS 658, 1993.\n   [18]  Lenstra,\
    \ A. and E. Verheul, \"Selecting Cryptographic Key\n         Sizes\", Journal\
    \ of Cryptology 14 (2001) 255-293,\n         <http://www.cryptosavvy.com/>.\n\
    \   [19]  Chown, P., \"Advanced Encryption Standard (AES) Ciphersuites for\n \
    \        Transport Layer Security (TLS)\", RFC 3268, June 2002.\n"
- title: Appendix A.  Equivalent Curves (Informative)
  contents:
  - "Appendix A.  Equivalent Curves (Informative)\n   All of the NIST curves [11]\
    \ and several of the ANSI curves [7] are\n   equivalent to curves listed in Section\
    \ 5.1.1.  In the following\n   table, multiple names in one row represent aliases\
    \ for the same\n   curve.\n             ------------------------------------------\n\
    \                       Curve names chosen by\n                  different standards\
    \ organizations\n             ------------+---------------+-------------\n   \
    \          SECG        |  ANSI X9.62   |  NIST\n             ------------+---------------+-------------\n\
    \             sect163k1   |               |   NIST K-163\n             sect163r1\
    \   |               |\n             sect163r2   |               |   NIST B-163\n\
    \             sect193r1   |               |\n             sect193r2   |      \
    \         |\n             sect233k1   |               |   NIST K-233\n       \
    \      sect233r1   |               |   NIST B-233\n             sect239k1   |\
    \               |\n             sect283k1   |               |   NIST K-283\n \
    \            sect283r1   |               |   NIST B-283\n             sect409k1\
    \   |               |   NIST K-409\n             sect409r1   |               |\
    \   NIST B-409\n             sect571k1   |               |   NIST K-571\n    \
    \         sect571r1   |               |   NIST B-571\n             secp160k1 \
    \  |               |\n             secp160r1   |               |\n           \
    \  secp160r2   |               |\n             secp192k1   |               |\n\
    \             secp192r1   |  prime192v1   |   NIST P-192\n             secp224k1\
    \   |               |\n             secp224r1   |               |   NIST P-224\n\
    \             secp256k1   |               |\n             secp256r1   |  prime256v1\
    \   |   NIST P-256\n             secp384r1   |               |   NIST P-384\n\
    \             secp521r1   |               |   NIST P-521\n             ------------+---------------+-------------\n\
    \      Table 6: Equivalent curves defined by SECG, ANSI, and NIST\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Simon Blake-Wilson\n   SafeNet Technologies BV\n   Amstelveenseweg\
    \ 88-90\n   1075 XJ, Amsterdam\n   NL\n   Phone: +31 653 899 836\n   EMail: sblakewilson@safenet-inc.com\n\
    \   Nelson Bolyard\n   Sun Microsystems Inc.\n   4170 Network Circle\n   MS SCA17-201\n\
    \   Santa Clara, CA  95054\n   US\n   Phone: +1 408 930 1443\n   EMail: nelson@bolyard.com\n\
    \   Vipul Gupta\n   Sun Microsystems Laboratories\n   16 Network Circle\n   MS\
    \ UMPK16-160\n   Menlo Park, CA  94025\n   US\n   Phone: +1 650 786 7551\n   EMail:\
    \ vipul.gupta@sun.com\n   Chris Hawk\n   Corriente Networks LLC\n   1563 Solano\
    \ Ave., #484\n   Berkeley, CA  94707\n   US\n   Phone: +1 510 527 0601\n   EMail:\
    \ chris@corriente.net\n   Bodo Moeller\n   Ruhr-Uni Bochum\n   Horst-Goertz-Institut,\
    \ Lehrstuhl fuer Kommunikationssicherheit\n   IC 4/139\n   44780 Bochum\n   DE\n\
    \   Phone: +49 234 32 26795\n   EMail: bodo@openssl.org\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
