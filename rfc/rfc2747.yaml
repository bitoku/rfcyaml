- title: __initial_text__
  contents:
  - '                   RSVP Cryptographic Authentication

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the format and use of RSVP's INTEGRITY object\n\
    \   to provide hop-by-hop integrity and authentication of RSVP messages.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Resource ReSerVation Protocol RSVP [1] is a protocol\
    \ for setting\n   up distributed state in routers and hosts, and in particular\
    \ for\n   reserving resources to implement integrated service.  RSVP allows\n\
    \   particular users to obtain preferential access to network resources,\n   under\
    \ the control of an admission control mechanism.  Permission to\n   make a reservation\
    \ will depend both upon the availability of the\n   requested resources along\
    \ the path of the data, and upon satisfaction\n   of policy rules.\n   To ensure\
    \ the integrity of this admission control mechanism, RSVP\n   requires the ability\
    \ to protect its messages against corruption and\n   spoofing.  This document\
    \ defines a mechanism to protect RSVP message\n   integrity hop-by-hop.  The proposed\
    \ scheme transmits an\n   authenticating digest of the message, computed using\
    \ a secret\n   Authentication Key and a keyed-hash algorithm.  This scheme provides\n\
    \   protection against forgery or message modification.  The INTEGRITY\n   object\
    \ of each RSVP message is tagged with a one-time-use sequence\n   number.  This\
    \ allows the message receiver to identify playbacks and\n   hence to thwart replay\
    \ attacks.  The proposed mechanism does not\n   afford confidentiality, since\
    \ messages stay in the clear; however,\n   the mechanism is also exportable from\
    \ most countries, which would be\n   impossible were a privacy algorithm to be\
    \ used.  Note: this document\n   uses the terms \"sender\" and \"receiver\" differently\
    \ from [1].  They\n   are used here to refer to systems that face each other across\
    \ an RSVP\n   hop, the \"sender\" being the system generating RSVP messages.\n\
    \   The message replay prevention algorithm is quite simple.  The sender\n   generates\
    \ packets with monotonically increasing sequence numbers.  In\n   turn, the receiver\
    \ only accepts packets that have a larger sequence\n   number than the previous\
    \ packet.  To start this process, a receiver\n   handshakes with the sender to\
    \ get an initial sequence number.  This\n   memo discusses ways to relax the strictness\
    \ of the in-order delivery\n   of messages as well as techniques to generate monotonically\n\
    \   increasing sequence numbers that are robust across sender failures\n   and\
    \ restarts.\n   The proposed mechanism is independent of a specific cryptographic\n\
    \   algorithm, but the document describes the use of Keyed-Hashing for\n   Message\
    \ Authentication using HMAC-MD5 [7].  As noted in [7], there\n   exist stronger\
    \ hashes, such as HMAC-SHA1; where warranted,\n   implementations will do well\
    \ to make them available.  However, in the\n   general case, [7] suggests that\
    \ HMAC-MD5 is adequate to the purpose\n   at hand and has preferable performance\
    \ characteristics.  [7] also\n   offers source code and test vectors for this\
    \ algorithm, a boon to\n   those who would test for interoperability.  HMAC-MD5\
    \ is required as a\n   baseline to be universally included in RSVP implementations\
    \ providing\n   cryptographic authentication, with other proposals optional (see\n\
    \   Section 6 on Conformance Requirements).\n   The RSVP checksum MAY be disabled\
    \ (set to zero) when the INTEGRITY\n   object is included in the message, as the\
    \ message digest is a much\n   stronger integrity check.\n"
- title: 1.1.  Conventions used in this document
  contents:
  - "1.1.  Conventions used in this document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [8].\n"
- title: 1.2.  Why not use the Standard IPSEC Authentication Header?
  contents:
  - "1.2.  Why not use the Standard IPSEC Authentication Header?\n   One obvious question\
    \ is why, since there exists a standard\n   authentication mechanism, IPSEC [3,5],\
    \ we would choose not to use it.\n   This was discussed at length in the working\
    \ group, and the use of\n   IPSEC was rejected for the following reasons.\n  \
    \ The security associations in IPSEC are based on destination address.\n   It\
    \ is not clear that RSVP messages are well defined for either source\n   or destination\
    \ based security associations, as a router must forward\n   PATH and PATH TEAR\
    \ messages using the same source address as the\n   sender listed in the SENDER\
    \ TEMPLATE.  RSVP traffic may otherwise not\n   follow exactly the same path as\
    \ data traffic.  Using either source or\n   destination based associations would\
    \ require opening a new security\n   association among the routers for which a\
    \ reservation traverses.\n   In addition, it was noted that neighbor relationships\
    \ between RSVP\n   systems are not limited to those that face one another across\
    \ a\n   communication channel.  RSVP relationships across non-RSVP clouds,\n \
    \  such as those described in Section 2.9 of [1], are not necessarily\n   visible\
    \ to the sending system.  These arguments suggest the use of a\n   key management\
    \ strategy based on RSVP router to RSVP router\n   associations instead of IPSEC.\n"
- title: 2.  Data Structures
  contents:
  - '2.  Data Structures

    '
- title: 2.1.  INTEGRITY Object Format
  contents:
  - "2.1.  INTEGRITY Object Format\n   An RSVP message consists of a sequence of \"\
    objects,\" which are type-\n   length-value encoded fields having specific purposes.\
    \  The\n   information required for hop-by-hop integrity checking is carried in\n\
    \   an INTEGRITY object.  The same INTEGRITY object type is used for both\n  \
    \ IPv4 and IPv6.\n   The INTEGRITY object has the following format:\n      Keyed\
    \ Message Digest INTEGRITY Object: Class = 4, C-Type = 1\n       +-------------+-------------+-------------+-------------+\n\
    \       |    Flags    | 0 (Reserved)|                           |\n       +-------------+-------------+\
    \                           +\n       |                    Key Identifier    \
    \                 |\n       +-------------+-------------+-------------+-------------+\n\
    \       |                    Sequence Number                    |\n       |  \
    \                                                     |\n       +-------------+-------------+-------------+-------------+\n\
    \       |                                                       |\n       +  \
    \                                                     +\n       |            \
    \                                           |\n       +                  Keyed\
    \ Message Digest                 |\n       |                                 \
    \                      |\n       +                                           \
    \            +\n       |                                                     \
    \  |\n       +-------------+-------------+-------------+-------------+\n     o\
    \    Flags: An 8-bit field with the following format:\n                      \
    \                Flags\n                          0   1   2   3   4   5   6  \
    \ 7\n                        +---+---+---+---+---+---+---+---+\n             \
    \           | H |                           |\n                        | F | \
    \            0             |\n                        +---+---+---+---+---+---+---+---+\n\
    \          Currently only one flag (HF) is defined.  The remaining flags\n   \
    \       are reserved for future use and MUST be set to 0.\n          o    Bit\
    \ 0: Handshake Flag (HF) concerns the integrity\n               handshake mechanism\
    \ (Section 4.3).  Message senders\n               willing to respond to integrity\
    \ handshake messages SHOULD\n               set this flag to 1 whereas those that\
    \ will reject\n               integrity handshake messages SHOULD set this to\
    \ 0.\n     o    Key Identifier: An unsigned 48-bit number that MUST be unique\n\
    \          for a given sender.  Locally unique Key Identifiers can be\n      \
    \    generated using some combination of the address (IP or MAC or\n         \
    \ LIH) of the sending interface and the key number.  The\n          combination\
    \ of the Key Identifier and the sending system's IP\n          address uniquely\
    \ identifies the security association (Section\n          2.2).\n     o    Sequence\
    \ Number: An unsigned 64-bit monotonically increasing,\n          unique sequence\
    \ number.\n          Sequence Number values may be any monotonically increasing\n\
    \          sequence that provides the INTEGRITY object [of each RSVP\n       \
    \   message] with a tag that is unique for the associated key's\n          lifetime.\
    \  Details on sequence number generation are presented\n          in Section 3.\n\
    \     o    Keyed Message Digest: The digest MUST be a multiple of 4\n        \
    \  octets long.  For HMAC-MD5, it will be 16 bytes long.\n"
- title: 2.2.  Security Association
  contents:
  - "2.2.  Security Association\n   The sending and receiving systems maintain a security\
    \ association for\n   each authentication key that they share.  This security\
    \ association\n   includes the following parameters:\n     o    Authentication\
    \ algorithm and algorithm mode being used.\n     o    Key used with the authentication\
    \ algorithm.\n     o    Lifetime of the key.\n     o    Associated sending interface\
    \ and other security association\n          selection criteria [REQUIRED at Sending\
    \ System].\n     o    Source Address of the sending system [REQUIRED at Receiving\n\
    \          System].\n     o    Latest sending sequence number used with this key\
    \ identifier\n          [REQUIRED at Sending System].\n     o    List of last\
    \ N sequence numbers received with this key\n          identifier [REQUIRED at\
    \ Receiving System].\n"
- title: 3.  Generating Sequence Numbers
  contents:
  - "3.  Generating Sequence Numbers\n   In this section we describe methods that\
    \ could be chosen to generate\n   the sequence numbers used in the INTEGRITY object\
    \ of an RSVP message.\n   As previous stated, there are two important properties\
    \ that MUST be\n   satisfied by the generation procedure.  The first property\
    \ is that\n   the sequence numbers are unique, or one-time, for the lifetime of\
    \ the\n   integrity key that is in current use.  A receiver can use this\n   property\
    \ to unambiguously distinguish between a new or a replayed\n   message.  The second\
    \ property is that the sequence numbers are\n   generated in monotonically increasing\
    \ order, modulo 2^64.  This is\n   required to greatly reduce the amount of saved\
    \ state, since a\n   receiver only needs to save the value of the highest sequence\
    \ number\n   seen to avoid a replay attack.  Since the starting sequence number\n\
    \   might be arbitrarily large, the modulo operation is required to\n   accommodate\
    \ sequence number roll-over within some key's lifetime.\n   This solution draws\
    \ from TCP's approach [9].\n   The sequence number field is chosen to be a 64-bit\
    \ unsigned quantity.\n   This is large enough to avoid exhaustion over the key\
    \ lifetime.  For\n   example, if a key lifetime was conservatively defined as\
    \ one year,\n   there would be enough sequence number values to send RSVP messages\
    \ at\n   an average rate of about 585 gigaMessages per second.  A 32-bit\n   sequence\
    \ number would limit this average rate to about 136 messages\n   per second.\n\
    \   The ability to generate unique monotonically increasing sequence\n   numbers\
    \ across a failure and restart implies some form of stable\n   storage, either\
    \ local to the device or remotely over the network.\n   Three sequence number\
    \ generation procedures are described below.\n"
- title: 3.1.  Simple Sequence Numbers
  contents:
  - "3.1.  Simple Sequence Numbers\n   The most straightforward approach is to generate\
    \ a unique sequence\n   number using a message counter.  Each time a message is\
    \ transmitted\n   for a given key, the sequence number counter is incremented.\
    \  The\n   current value of this counter is continually or periodically saved\
    \ to\n   stable storage.  After a restart, the counter is recovered using this\n\
    \   stable storage.  If the counter was saved periodically to stable\n   storage,\
    \ the count should be recovered by increasing the saved value\n   to be larger\
    \ than any possible value of the counter at the time of\n   the failure.  This\
    \ can be computed, knowing the interval at which the\n   counter was saved to\
    \ stable storage and incrementing the stored value\n   by that amount.\n"
- title: 3.2.  Sequence Numbers Based on a Real Time Clock
  contents:
  - "3.2.  Sequence Numbers Based on a Real Time Clock\n   Most devices will probably\
    \ not have the capability to save sequence\n   number counters to stable storage\
    \ for each key.  A more universal\n   solution is to base sequence numbers on\
    \ the stable storage of a real\n   time clock.  Many computing devices have a\
    \ real time clock module\n   that includes stable storage of the clock.  These\
    \ modules generally\n   include some form of nonvolatile memory to retain clock\
    \ information\n   in the event of a power failure.\n   In this approach, we could\
    \ use an NTP based timestamp value as the\n   sequence number.  The roll-over\
    \ period of an NTP timestamp is about\n   136 years, much longer than any reasonable\
    \ lifetime of a key.  In\n   addition, the granularity of the NTP timestamp is\
    \ fine enough to\n   allow the generation of an RSVP message every 200 picoseconds\
    \ for a\n   given key.  Many real time clock modules do not have the resolution\n\
    \   of an NTP timestamp.  In these cases, the least significant bits of\n   the\
    \ timestamp can be generated using a message counter, which is\n   reset every\
    \ clock tick.  For example, when the real time clock\n   provides a resolution\
    \ of 1 second, the 32 least significant bits of\n   the sequence number can be\
    \ generated using a message counter.  The\n   remaining 32 bits are filled with\
    \ the 32 least significant bits of\n   the timestamp.  Assuming that the recovery\
    \ time after failure takes\n   longer than one tick of the real time clock, the\
    \ message counter for\n   the low order bits can be safely reset to zero after\
    \ a restart.\n"
- title: 3.3.  Sequence Numbers Based on a Network Recovered Clock
  contents:
  - "3.3.  Sequence Numbers Based on a Network Recovered Clock\n   If the device does\
    \ not contain any stable storage of sequence number\n   counters or of a real\
    \ time clock, it could recover the real time\n   clock from the network using\
    \ NTP.  Once the clock has been recovered\n   following a restart, the sequence\
    \ number generation procedure would\n   be identical to the procedure described\
    \ above.\n"
- title: 4.  Message Processing
  contents:
  - "4.  Message Processing\n   Implementations SHOULD allow specification of interfaces\
    \ that are to\n   be secured, for either sending messages, or receiving them,\
    \ or both.\n   The sender must ensure that all RSVP messages sent on secured sending\n\
    \   interfaces include an INTEGRITY object, generated using the\n   appropriate\
    \ Key.  Receivers verify whether RSVP messages, except of\n   the type \"Integrity\
    \ Challenge\" (Section 4.3), arriving on a secured\n   receiving interface contain\
    \ the INTEGRITY object.  If the INTEGRITY\n   object is absent, the receiver discards\
    \ the message.\n   Security associations are simplex - the keys that a sending\
    \ system\n   uses to sign its messages may be different from the keys that its\n\
    \   receivers use to sign theirs.  Hence, each association is associated\n   with\
    \ a unique sending system and (possibly) multiple receiving\n   systems.\n   Each\
    \ sender SHOULD have distinct security associations (and keys) per\n   secured\
    \ sending interface (or LIH).  While administrators may\n   configure all the\
    \ routers and hosts on a subnet (or for that matter,\n   in their network) using\
    \ a single security association,\n   implementations MUST assume that each sender\
    \ may send using a\n   distinct security association on each secured interface.\
    \  At the\n   sender, security association selection is based on the interface\n\
    \   through which the message is sent.  This selection MAY include\n   additional\
    \ criteria, such as the destination address (when sending\n   the message unicast,\
    \ over a broadcast LAN with a large number of\n   hosts) or user identities at\
    \ the sender or receivers [2].  Finally,\n   all intended message recipients should\
    \ participate in this security\n   association.  Route flaps in a non RSVP cloud\
    \ might cause messages\n   for the same receiver to be sent on different interfaces\
    \ at different\n   times.  In such cases, the receivers should participate in\
    \ all\n   possible security associations that may be selected for the\n   interfaces\
    \ through which the message might be sent.\n   Receivers select keys based on\
    \ the Key Identifier and the sending\n   system's IP address.  The Key Identifier\
    \ is included in the INTEGRITY\n   object.  The sending system's address can be\
    \ obtained either from the\n   RSVP_HOP object, or if that's not present (as is\
    \ the case with\n   PathErr and ResvConf messages) from the IP source address.\
    \  Since the\n   Key Identifier is unique for a sender, this method uniquely\n\
    \   identifies the key.\n   The integrity mechanism slightly modifies the processing\
    \ rules for\n   RSVP messages, both when including the INTEGRITY object in a message\n\
    \   sent over a secured sending interface and when accepting a message\n   received\
    \ on a secured receiving interface.  These modifications are\n   detailed below.\n"
- title: 4.1.  Message Generation
  contents:
  - "4.1.  Message Generation\n   For an RSVP message sent over a secured sending\
    \ interface, the\n   message is created as described in [1], with these exceptions:\n\
    \     (1)  The RSVP checksum field is set to zero.  If required, an RSVP\n   \
    \       checksum can be calculated when the processing of the\n          INTEGRITY\
    \ object is complete.\n     (2)  The INTEGRITY object is inserted in the appropriate\
    \ place, and\n          its location in the message is remembered for later use.\n\
    \     (3)  The sending interface and other appropriate criteria (as\n        \
    \  mentioned above) are used to determine the Authentication Key\n          and\
    \ the hash algorithm to be used.\n     (4)  The unused flags and the reserved\
    \ field in the INTEGRITY\n          object MUST be set to 0.  The Handshake Flag\
    \ (HF) should be\n          set according to rules specified in Section 2.1.\n\
    \     (5)  The sending sequence number MUST be updated to ensure a\n         \
    \ unique, monotonically increasing number.  It is then placed in\n          the\
    \ Sequence Number field of the INTEGRITY object.\n     (6)  The Keyed Message\
    \ Digest field is set to zero.\n     (7)  The Key Identifier is placed into the\
    \ INTEGRITY object.\n     (8)  An authenticating digest of the message is computed\
    \ using the\n          Authentication Key in conjunction with the keyed-hash\n\
    \          algorithm.  When the HMAC-MD5 algorithm is used, the hash\n       \
    \   calculation is described in [7].\n     (9)  The digest is written into the\
    \ Cryptographic Digest field of\n          the INTEGRITY object.\n"
- title: 4.2.  Message Reception
  contents:
  - "4.2.  Message Reception\n   When the message is received on a secured receiving\
    \ interface, and is\n   not of the type \"Integrity Challenge\", it is processed\
    \ in the\n   following manner:\n     (1)  The RSVP checksum field is saved and\
    \ the field is subsequently\n          set to zero.\n     (2)  The Cryptographic\
    \ Digest field of the INTEGRITY object is\n          saved and the field is subsequently\
    \ set to zero.\n     (3)  The Key Identifier field and the sending system address\
    \ are\n          used to uniquely determine the Authentication Key and the hash\n\
    \          algorithm to be used.  Processing of this packet might be\n       \
    \   delayed when the Key Management System (Appendix 1) is queried\n         \
    \ for this information.\n     (4)  A new keyed-digest is calculated using the\
    \ indicated algorithm\n          and the Authentication Key.\n     (5)  If the\
    \ calculated digest does not match the received digest,\n          the message\
    \ is discarded without further processing.\n     (6)  If the message is of type\
    \ \"Integrity Response\", verify that\n          the CHALLENGE object identically\
    \ matches the originated\n          challenge.  If it matches, save the sequence\
    \ number in the\n          INTEGRITY object as the largest sequence number received\
    \ to\n          date.\n          Otherwise, for all other RSVP Messages, the sequence\
    \ number is\n          validated to prevent replay attacks, and messages with\
    \ invalid\n          sequence numbers are ignored by the receiver.\n         \
    \ When a message is accepted, the sequence number of that\n          message could\
    \ update a stored value corresponding to the\n          largest sequence number\
    \ received to date.  Each subsequent\n          message must then have a larger\
    \ (modulo 2^64) sequence number\n          to be accepted.  This simple processing\
    \ rule prevents message\n          replay attacks, but it must be modified to\
    \ tolerate limited\n          out-of-order message delivery.  For example, if\
    \ several\n          messages were sent in a burst (in a periodic refresh generated\n\
    \          by a router, or as a result of a tear down function), they\n      \
    \    might get reordered and then the sequence numbers would not be\n        \
    \  received in an increasing order.\n          An implementation SHOULD allow\
    \ administrative configuration\n          that sets the receiver's tolerance to\
    \ out-of-order message\n          delivery.  A simple approach would allow administrators\
    \ to\n          specify a message window corresponding to the worst case\n   \
    \       reordering behavior.  For example, one might specify that\n          packets\
    \ reordered within a 32 message window would be\n          accepted.  If no reordering\
    \ can occur, the window is set to\n          one.\n          The receiver must\
    \ store a list of all sequence numbers seen\n          within the reordering window.\
    \  A received sequence number is\n          valid if (a) it is greater than the\
    \ maximum sequence number\n          received or (b) it is a past sequence number\
    \ lying within the\n          reordering window and not recorded in the list.\
    \  Acceptance of\n          a sequence number implies adding it to the list and\
    \ removing a\n          number from the lower end of the list.  Messages received\
    \ with\n          sequence numbers lying below the lower end of the list or\n\
    \          marked seen in the list are discarded.\n   When an \"Integrity Challenge\"\
    \ message is received on a secured\n   sending interface it is processed in the\
    \ following manner:\n     (1)  An \"Integrity Response\" message is formed using\
    \ the Challenge\n          object received in the challenge message.\n     (2)\
    \  The message is sent back to the receiver, based on the source\n          IP\
    \ address of the challenge message, using the \"Message\n          Generation\"\
    \ steps outlined above.  The selection of the\n          Authentication Key and\
    \ the hash algorithm to be used is\n          determined by the key identifier\
    \ supplied in the challenge\n          message.\n"
- title: 4.3.  Integrity Handshake at Restart or Initialization of the Receiver
  contents:
  - "4.3.  Integrity Handshake at Restart or Initialization of the Receiver\n   To\
    \ obtain the starting sequence number for a live Authentication Key,\n   the receiver\
    \ MAY initiate an integrity handshake with the sender.\n   This handshake consists\
    \ of a receiver's Challenge and the sender's\n   Response, and may be either initiated\
    \ during restart or postponed\n   until a message signed with that key arrives.\n\
    \   Once the receiver has decided to initiate an integrity handshake for\n   a\
    \ particular Authentication Key, it identifies the sender using the\n   sending\
    \ system's address configured in the corresponding security\n   association. \
    \ The receiver then sends an RSVP Integrity Challenge\n   message to the sender.\
    \  This message contains the Key Identifier to\n   identify the sender's key and\
    \ MUST have a unique challenge cookie\n   that is based on a local secret to prevent\
    \ guessing.  see Section\n   2.5.3 of [4]).  It is suggested that the cookie be\
    \ an MD5 hash of a\n   local secret and a timestamp to provide uniqueness (see\
    \ Section 9).\n   An RSVP Integrity Challenge message will carry a message type\
    \ of 11.\n   The message format is as follows:\n     <Integrity Challenge message>\
    \ ::= <Common Header> <CHALLENGE>\n   he CHALLENGE object has the following format:\n\
    \                CHALLENGE Object: Class = 64, C-Type = 1\n       +-------------+-------------+-------------+-------------+\n\
    \       |        0 (Reserved)       |                           |\n       +-------------+-------------+\
    \                           +\n       |                    Key Identifier    \
    \                 |\n       +-------------+-------------+-------------+-------------+\n\
    \       |                    Challenge Cookie                   |\n       |  \
    \                                                     |\n       +-------------+-------------+-------------+-------------+\n\
    \   The sender accepts the \"Integrity Challenge\" without doing an\n   integrity\
    \ check.  It returns an RSVP \"Integrity Response\" message\n   that contains\
    \ the original CHALLENGE object.  It also includes an\n   INTEGRITY object, signed\
    \ with the key specified by the Key Identifier\n   included in the \"Integrity\
    \ Challenge\".\n   An RSVP Integrity Response message will carry a message type\
    \ of 12.\n   The message format is as follows:\n     <Integrity Response message>\
    \ ::= <Common Header> <INTEGRITY>\n                                      <CHALLENGE>\n\
    \   The \"Integrity Response\" message is accepted by the receiver\n   (challenger)\
    \ only if the returned CHALLENGE object matches the one\n   sent in the \"Integrity\
    \ Challenge\" message.  This prevents replay of\n   old \"Integrity Response\"\
    \ messages.  If the match is successful, the\n   receiver saves the Sequence Number\
    \ from the INTEGRITY object as the\n   latest sequence number received with the\
    \ key identifier included in\n   the CHALLENGE.\n   If a response is not received\
    \ within a given period of time, the\n   challenge is repeated.  When the integrity\
    \ handshake successfully\n   completes, the receiver begins accepting normal RSVP\
    \ signaling\n   messages from that sender and ignores any other \"Integrity Response\"\
    \n   messages.\n   The Handshake Flag (HF) is used to allow implementations the\n\
    \   flexibility of not including the integrity handshake mechanism.  By\n   setting\
    \ this flag to 1, message senders that implement the integrity\n   handshake distinguish\
    \ themselves from those that do not.  Receivers\n   SHOULD NOT attempt to handshake\
    \ with senders whose INTEGRITY object\n   has HF = 0.\n   An integrity handshake\
    \ may not be necessary in all environments.  A\n   common use of RSVP integrity\
    \ will be between peering domain routers,\n   which are likely to be processing\
    \ a steady stream of RSVP messages\n   due to aggregation effects.  When a router\
    \ restarts after a crash,\n   valid RSVP messages from peering senders will probably\
    \ arrive within\n   a short time.  Assuming that replay messages are injected\
    \ into the\n   stream of valid RSVP messages, there may be only a small window\
    \ of\n   opportunity for a replay attack before a valid message is processed.\n\
    \   This valid message will set the largest sequence number seen to a\n   value\
    \ greater than any number that had been stored prior to the\n   crash, preventing\
    \ any further replays.\n   On the other hand, not using an integrity handshake\
    \ could allow\n   exposure to replay attacks if there is a long period of silence\
    \ from\n   a given sender following a restart of a receiver.  Hence, it SHOULD\n\
    \   be an administrative decision whether or not the receiver performs an\n  \
    \ integrity handshake with senders that are willing to respond to\n   \"Integrity\
    \ Challenge\" messages, and whether it accepts any messages\n   from senders that\
    \ refuse to do so.  These decisions will be based on\n   assumptions related to\
    \ a particular network environment.\n"
- title: 5.  Key Management
  contents:
  - "5.  Key Management\n   It is likely that the IETF will define a standard key\
    \ management\n   protocol.  It is strongly desirable to use that key management\n\
    \   protocol to distribute RSVP Authentication Keys among communicating\n   RSVP\
    \ implementations.  Such a protocol would provide scalability and\n   significantly\
    \ reduce the human administrative burden.  The Key\n   Identifier can be used\
    \ as a hook between RSVP and such a future\n   protocol.  Key management protocols\
    \ have a long history of subtle\n   flaws that are often discovered long after\
    \ the protocol was first\n   described in public.  To avoid having to change all\
    \ RSVP\n   implementations should such a flaw be discovered, integrated key\n\
    \   management protocol techniques were deliberately omitted from this\n   specification.\n"
- title: 5.1.  Key Management Procedures
  contents:
  - "5.1.  Key Management Procedures\n   Each key has a lifetime associated with it\
    \ that is recorded in all\n   systems (sender and receivers) configured with that\
    \ key.  The concept\n   of a \"key lifetime\" merely requires that the earliest\
    \ (KeyStartValid)\n   and latest (KeyEndValid) times that the key is valid be\
    \ programmable\n   in a way the system understands.  Certain key generation mechanisms,\n\
    \   such as Kerberos or some public key schemes, may directly produce\n   ephemeral\
    \ keys.  In this case, the lifetime of the key is implicitly\n   defined as part\
    \ of the key.\n   In general, no key is ever used outside its lifetime (but see\
    \ Section\n   5.3).  Possible mechanisms for managing key lifetime include the\n\
    \   Network Time Protocol and hardware time-of-day clocks.\n   To maintain security,\
    \ it is advisable to change the RSVP\n   Authentication Key on a regular basis.\
    \  It should be possible to\n   switch the RSVP Authentication Key without loss\
    \ of RSVP state or\n   denial of reservation service, and without requiring people\
    \ to change\n   all the keys at once.  This requires an RSVP implementation to\n\
    \   support the storage and use of more than one active RSVP\n   Authentication\
    \ Key at the same time.  Hence both the sender and\n   receivers might have multiple\
    \ active keys for a given security\n   association.\n   Since keys are shared\
    \ between a sender and (possibly) multiple\n   receivers, there is a region of\
    \ uncertainty around the time of key\n   switch-over during which some systems\
    \ may still be using the old key\n   and others might have switched to the new\
    \ key.  The size of this\n   uncertainty region is related to clock synchrony\
    \ of the systems.\n   Administrators should configure the overlap between the\
    \ expiration\n   time of the old key (KeyEndValid) and the validity of the new\
    \ key\n   (KeyStartValid) to be at least twice the size of this uncertainty\n\
    \   interval.  This will allow the sender to make the key switch-over at\n   the\
    \ midpoint of this interval and be confident that all receivers are\n   now accepting\
    \ the new key.  For the duration of the overlap in key\n   lifetimes, a receiver\
    \ must be prepared to authenticate messages using\n   either key.\n   During a\
    \ key switch-over, it will be necessary for each receiver to\n   handshake with\
    \ the sender using the new key.  As stated before, a\n   receiver has the choice\
    \ of initiating a handshake during the\n   switchover or postponing the handshake\
    \ until the receipt of a message\n   using that key.\n"
- title: 5.2.  Key Management Requirements
  contents:
  - "5.2.  Key Management Requirements\n   Requirements on an implementation are as\
    \ follows:\n     o    It is strongly desirable that a hypothetical security breach\n\
    \          in one Internet protocol not automatically compromise other\n     \
    \     Internet protocols.  The Authentication Key of this\n          specification\
    \ SHOULD NOT be stored using protocols or\n          algorithms that have known\
    \ flaws.\n     o    An implementation MUST support the storage and use of more\n\
    \          than one key at the same time, for both sending and receiving\n   \
    \       systems.\n     o    An implementation MUST associate a specific lifetime\
    \ (i.e.,\n          KeyStartValid and KeyEndValid) with each key and the\n   \
    \       corresponding Key Identifier.\n     o    An implementation MUST support\
    \ manual key distribution (e.g.,\n          the privileged user manually typing\
    \ in the key, key lifetime,\n          and key identifier on the console).  The\
    \ lifetime may be\n          infinite.\n     o    If more than one algorithm is\
    \ supported, then the\n          implementation MUST require that the algorithm\
    \ be specified\n          for each key at the time the other key information is\
    \ entered.\n     o    Keys that are out of date MAY be automatically deleted by\
    \ the\n          implementation.\n     o    Manual deletion of active keys MUST\
    \ also be supported.\n     o    Key storage SHOULD persist across a system restart,\
    \ warm or\n          cold, to ease operational usage.\n"
- title: 5.3.  Pathological Case
  contents:
  - "5.3.  Pathological Case\n   It is possible that the last key for a given security\
    \ association has\n   expired.  When this happens, it is unacceptable to revert\
    \ to an\n   unauthenticated condition, and not advisable to disrupt current\n\
    \   reservations.  Therefore, the system should send a \"last\n   authentication\
    \ key expiration\" notification to the network manager\n   and treat the key as\
    \ having an infinite lifetime until the lifetime\n   is extended, the key is deleted\
    \ by network management, or a new key\n   is configured.\n"
- title: 6.  Conformance Requirements
  contents:
  - "6.  Conformance Requirements\n   To conform to this specification, an implementation\
    \ MUST support all\n   of its aspects.  The HMAC-MD5 authentication algorithm\
    \ defined in [7]\n   MUST be implemented by all conforming implementations.  A\
    \ conforming\n   implementation MAY also support other authentication algorithms\
    \ such\n   as NIST's Secure Hash Algorithm (SHA).  Manual key distribution as\n\
    \   described above MUST be supported by all conforming implementations.\n   All\
    \ implementations MUST support the smooth key roll over described\n   under \"\
    Key Management Procedures.\"\n   Implementations SHOULD support a standard key\
    \ management protocol for\n   secure distribution of RSVP Authentication Keys\
    \ once such a key\n   management protocol is standardized by the IETF.\n"
- title: 7.  Kerberos generation of RSVP Authentication Keys
  contents:
  - "7.  Kerberos generation of RSVP Authentication Keys\n   Kerberos[10] MAY be used\
    \ to generate the RSVP Authentication key used\n   in generating a signature in\
    \ the Integrity Object sent from a RSVP\n   sender to a receiver.   Kerberos key\
    \ generation avoids the use of\n   shared keys between RSVP senders and receivers\
    \ such as hosts and\n   routers.  Kerberos allows for the use of trusted third\
    \ party keying\n   relationships between security principals (RSVP sender and\
    \ receivers)\n   where the Kerberos key distribution center(KDC) establishes an\n\
    \   ephemeral session key that is subsequently shared between RSVP sender\n  \
    \ and receivers.  In the multicast case all receivers of a multicast\n   RSVP\
    \ message MUST share a single key with the KDC (e.g. the receivers\n   are in\
    \ effect the same security principal with respect to Kerberos).\n   The Key information\
    \ determined by the sender MAY specify the use of\n   Kerberos in place of configured\
    \ shared keys as the mechanism for\n   establishing a key between the sender and\
    \ receiver.  The Kerberos\n   identity of the receiver is established as part\
    \ of the sender's\n   interface configuration or it can be established through\
    \ other\n   mechanisms.  When generating the first RSVP message for a specific\n\
    \   key identifier the sender requests a Kerberos service ticket and gets\n  \
    \ back an ephemeral session key and a Kerberos ticket from the KDC.\n   The sender\
    \ encapsulates the ticket and the identity of the sender in\n   an Identity Policy\
    \ Object[2]. The sender includes the Policy Object\n   in the RSVP message.  The\
    \ session key is then used by the sender as\n   the RSVP Authentication key in\
    \ section 4.1 step (3) and is stored as\n   Key information associated with the\
    \ key identifier.\n   Upon RSVP Message reception, the receiver retrieves the\
    \ Kerberos\n   Ticket from the Identity Policy Object, decrypts the ticket and\n\
    \   retrieves the session key from the ticket.  The session key is the\n   same\
    \ key as used by the sender and is used as the key in section 4.2\n   step (3).\
    \  The receiver stores the key for use in processing\n   subsequent RSVP messages.\n\
    \   Kerberos tickets have lifetimes and the sender MUST NOT use tickets\n   that\
    \ have expired.  A new ticket MUST be requested and used by the\n   sender for\
    \ the receiver prior to the ticket expiring.\n"
- title: 7.1.  Optimization when using Kerberos Based Authentication
  contents:
  - "7.1.  Optimization when using Kerberos Based Authentication\n   Kerberos tickets\
    \ are relatively long (> 500 bytes) and it is not\n   necessary to send a ticket\
    \ in every RSVP message.  The ephemeral\n   session key can be cached by the sender\
    \ and receiver and can be used\n   for the lifetime of the Kerberos ticket.  In\
    \ this case, the sender\n   only needs to include the Kerberos ticket in the first\
    \ Message\n   generated.  Subsequent RSVP messages use the key identifier to\n\
    \   retrieve the cached key (and optionally other identity information)\n   instead\
    \ of passing tickets from sender to receiver in each RSVP\n   message.\n   A receiver\
    \ may not have cached key state with an associated Key\n   Identifier due to reboot\
    \ or route changes.  If the receiver's policy\n   indicates the use of Kerberos\
    \ keys for integrity checking, the\n   receiver can send an integrity Challenge\
    \ message back to the sender.\n   Upon receiving an integrity Challenge message\
    \ a sender MUST send an\n   Identity object that includes the Kerberos ticket\
    \ in the integrity\n   Response message, thereby allowing the receiver to retrieve\
    \ and store\n   the session key from the Kerberos ticket for subsequent Integrity\n\
    \   checking.\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   This document is derived directly from similar work done\
    \ for OSPF and\n   RIP Version II, jointly by Ran Atkinson and Fred Baker.  Significant\n\
    \   editing was done by Bob Braden, resulting in increased clarity.\n   Significant\
    \ comments were submitted by Steve Bellovin, who actually\n   understands this\
    \ stuff.  Matt Crawford and Dan Harkins helped revise\n   the document.\n"
- title: 9.  References
  contents:
  - "9.  References\n   [1]  Braden, R., Zhang, L., Berson, S., Herzog, S. and S.\
    \ Jamin,\n        \"Resource ReSerVation Protocol (RSVP) -- Version 1 Functional\n\
    \        Specification\", RFC 2205, September 1997.\n   [2]  Yadav, S., et al.,\
    \ \"Identity Representation for RSVP\", RFC 2752,\n        January 2000.\n   [3]\
    \  Atkinson, R. and S. Kent, \"Security Architecture for the\n        Internet\
    \ Protocol\", RFC 2401, November 1998.\n   [4]  Maughan, D., Schertler, M., Schneider,\
    \ M. and J. Turner,\n        \"Internet Security Association and Key Management\
    \ Protocol\n        (ISAKMP)\", RFC 2408, November 1998.\n   [5]  Kent, S. and\
    \ R. Atkinson, \"IP Authentication Header\", RFC 2402,\n        November 1998.\n\
    \   [6]  Kent, S. and R. Atkinson, \"IP Encapsulating Security Payload\n     \
    \   (ESP)\", RFC 2406, November 1998.\n   [7]  Krawczyk, H., Bellare, M. and R.\
    \ Canetti, \"HMAC: Keyed-Hashing\n        for Message Authentication\", RFC 2104,\
    \ March 1996.\n   [8]  Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n\
    \        Levels\", BCP 14, RFC 2119, March 1997.\n   [9]  Postel, J., \"Transmission\
    \ Control Protocol\", STD 7, RFC 793,\n        September 1981.\n   [10] Kohl,\
    \ J. and C. Neuman, \"The Kerberos Network Authentication\n        Service (V5)\"\
    , RFC 1510, September 1993.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   This entire memo describes and specifies an\
    \ authentication mechanism\n   for RSVP that is believed to be secure against\
    \ active and passive\n   attacks.\n   The quality of the security provided by\
    \ this mechanism depends on the\n   strength of the implemented authentication\
    \ algorithms, the strength\n   of the key being used, and the correct implementation\
    \ of the security\n   mechanism in all communicating RSVP implementations.  This\
    \ mechanism\n   also depends on the RSVP Authentication Keys being kept confidential\n\
    \   by all parties.  If any of these assumptions are incorrect or\n   procedures\
    \ are insufficiently secure, then no real security will be\n   provided to the\
    \ users of this mechanism.\n   While the handshake \"Integrity Response\" message\
    \ is integrity-\n   checked, the handshake \"Integrity Challenge\" message is\
    \ not.  This\n   was done intentionally to avoid the case when both peering routers\
    \ do\n   not have a starting sequence number for each other's key.\n   Consequently,\
    \ they will each keep sending handshake \"Integrity\n   Challenge\" messages that\
    \ will be dropped by the other end.  Moreover,\n   requiring only the response\
    \ to be integrity-checked eliminates a\n   dependency on an security association\
    \ in the opposite direction.\n   This, however, lets an intruder generate fake\
    \ handshaking challenges\n   with a certain challenge cookie.  It could then save\
    \ the response and\n   attempt to play it against a receiver that is in recovery.\
    \  If it was\n   lucky enough to have guessed the challenge cookie used by the\n\
    \   receiver at recovery time it could use the saved response.  This\n   response\
    \ would be accepted, since it is properly signed, and would\n   have a smaller\
    \ sequence number for the sender because it was an old\n   message.  This opens\
    \ the receiver up to replays. Still, it seems very\n   difficult to exploit. \
    \ It requires not only guessing the challenge\n   cookie (which is based on a\
    \ locally known secret) in advance, but\n   also being able to masquerade as the\
    \ receiver to generate a handshake\n   \"Integrity Challenge\" with the proper\
    \ IP address and not being\n   caught.\n   Confidentiality is not provided by\
    \ this mechanism.  If\n   confidentiality is required, IPSEC ESP [6] may be the\
    \ best approach,\n   although it is subject to the same criticisms as IPSEC\n\
    \   Authentication, and therefore would be applicable only in specific\n   environments.\
    \  Protection against traffic analysis is also not\n   provided.  Mechanisms such\
    \ as bulk link encryption might be used when\n   protection against traffic analysis\
    \ is required.\n"
- title: 11.  Authors' Addresses
  contents:
  - "11.  Authors' Addresses\n   Fred Baker\n   Cisco Systems\n   519 Lado Drive\n\
    \   Santa Barbara, CA 93111\n   Phone: (408) 526-4257\n   EMail: fred@cisco.com\n\
    \   Bob Lindell\n   USC Information Sciences Institute\n   4676 Admiralty Way\n\
    \   Marina del Rey, CA 90292\n   Phone: (310) 822-1511\n   EMail: lindell@ISI.EDU\n\
    \   Mohit Talwar\n   Microsoft Corporation\n   One Microsoft Way\n   Redmond,\
    \ WA  98052\n   Phone: +1 425 705 3131\n   EMail: mohitt@microsoft.com\n"
- title: '12.  Appendix 1: Key Management Interface'
  contents:
  - "12.  Appendix 1: Key Management Interface\n   This appendix describes a generic\
    \ interface to Key Management.  This\n   description is at an abstract level realizing\
    \ that implementations\n   may need to introduce small variations to the actual\
    \ interface.\n   At the start of execution, RSVP would use this interface to obtain\n\
    \   the current set of relevant keys for sending and receiving messages.\n   During\
    \ execution, RSVP can query for specific keys given a Key\n   Identifier and Source\
    \ Address, discover newly created keys, and be\n   informed of those keys that\
    \ have been deleted.  The interface\n   provides both a polling and asynchronous\
    \ upcall style for wider\n   applicability.\n"
- title: 12.1.  Data Structures
  contents:
  - "12.1.  Data Structures\n   Information about keys is returned using the following\
    \ KeyInfo data\n   structure:\n     KeyInfo {\n             Key Type (Send or\
    \ Receive)\n             KeyIdentifier\n             Key\n             Authentication\
    \ Algorithm Type and Mode\n             KeyStartValid\n             KeyEndValid\n\
    \             Status (Active or Deleted)\n             Outgoing Interface (for\
    \ Send only)\n             Other Outgoing Security Association Selection Criteria\n\
    \                     (for Send only, optional)\n             Sending System Address\
    \ (for Receive Only)\n     }\n"
- title: 12.2.  Default Key Table
  contents:
  - "12.2.  Default Key Table\n   This function returns a list of KeyInfo data structures\
    \ corresponding\n   to all of the keys that are configured for sending and receiving\
    \ RSVP\n   messages and have an Active Status.  This function is usually called\n\
    \   at the start of execution but there is no limit on the number of\n   times\
    \ that it may be called.\n     KM_DefaultKeyTable() -> KeyInfoList\n"
- title: 12.3.  Querying for Unknown Receive Keys
  contents:
  - "12.3.  Querying for Unknown Receive Keys\n   When a message arrives with an unknown\
    \ Key Identifier and Sending\n   System Address pair, RSVP can use this function\
    \ to query the Key\n   Management System for the appropriate key.  The status\
    \ of the element\n   returned, if any, must be Active.\n     KM_GetRecvKey( INTEGRITY\
    \ Object, SrcAddress ) -> KeyInfo\n"
- title: 12.4.  Polling for Updates
  contents:
  - "12.4.  Polling for Updates\n   This function returns a list of KeyInfo data structures\
    \ corresponding\n   to any incremental changes that have been made to the default\
    \ key\n   table or requested keys since the last call to either\n   KM_KeyTablePoll,\
    \ KM_DefaultKeyTable, or KM_GetRecvKey.  The status of\n   some elements in the\
    \ returned list may be set to Deleted.\n      KM_KeyTablePoll() -> KeyInfoList\n"
- title: 12.5.  Asynchronous Upcall Interface
  contents:
  - "12.5.  Asynchronous Upcall Interface\n   Rather than repeatedly calling the KM_KeyTablePoll(),\
    \ an\n   implementation may choose to use an asynchronous event model.  This\n\
    \   function registers interest to key changes for a given Key Identifier\n  \
    \ or for all keys if no Key Identifier is specified.  The upcall\n   function\
    \ is called each time a change is made to a key.\n     KM_KeyUpdate ( Function\
    \ [, KeyIdentifier ] )\n   where the upcall function is parameterized as follows:\n\
    \     Function ( KeyInfo )\n"
- title: 13.  Full Copyright Statement
  contents:
  - "13.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
