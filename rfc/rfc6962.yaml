- title: __initial_text__
  contents:
  - '                        Certificate Transparency

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes an experimental protocol for publicly logging\n\
    \   the existence of Transport Layer Security (TLS) certificates as they\n   are\
    \ issued or observed, in a manner that allows anyone to audit\n   certificate\
    \ authority (CA) activity and notice the issuance of\n   suspect certificates\
    \ as well as to audit the certificate logs\n   themselves.  The intent is that\
    \ eventually clients would refuse to\n   honor certificates that do not appear\
    \ in a log, effectively forcing\n   CAs to add all issued certificates to the\
    \ logs.\n   Logs are network services that implement the protocol operations for\n\
    \   submissions and queries that are defined in this document.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6962.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Informal Introduction ...........................................3\n\
    \      1.1. Requirements Language ......................................4\n  \
    \    1.2. Data Structures ............................................4\n   2.\
    \ Cryptographic Components ........................................4\n      2.1.\
    \ Merkle Hash Trees ..........................................4\n           2.1.1.\
    \ Merkle Audit Paths ..................................5\n           2.1.2. Merkle\
    \ Consistency Proofs ...........................6\n           2.1.3. Example .............................................7\n\
    \           2.1.4. Signatures ..........................................8\n  \
    \ 3. Log Format and Operation ........................................9\n    \
    \  3.1. Log Entries ................................................9\n      3.2.\
    \ Structure of the Signed Certificate Timestamp .............12\n      3.3. Including\
    \ the Signed Certificate Timestamp in the\n           TLS Handshake .............................................13\n\
    \           3.3.1. TLS Extension ......................................15\n  \
    \    3.4. Merkle Tree ...............................................15\n    \
    \  3.5. Signed Tree Head ..........................................16\n   4. Log\
    \ Client Messages ............................................17\n      4.1. Add\
    \ Chain to Log ..........................................17\n      4.2. Add PreCertChain\
    \ to Log ...................................18\n      4.3. Retrieve Latest Signed\
    \ Tree Head ..........................18\n      4.4. Retrieve Merkle Consistency\
    \ Proof between Two\n           Signed Tree Heads .........................................19\n\
    \      4.5. Retrieve Merkle Audit Proof from Log by Leaf Hash .........19\n  \
    \    4.6. Retrieve Entries from Log .................................20\n    \
    \  4.7. Retrieve Accepted Root Certificates .......................21\n      4.8.\
    \ Retrieve Entry+Merkle Audit Proof from Log ................21\n   5. Clients\
    \ ........................................................21\n      5.1. Submitters\
    \ ................................................22\n      5.2. TLS Client ................................................22\n\
    \      5.3. Monitor ...................................................22\n  \
    \    5.4. Auditor ...................................................23\n   6.\
    \ IANA Considerations ............................................23\n   7. Security\
    \ Considerations ........................................23\n      7.1. Misissued\
    \ Certificates ....................................24\n      7.2. Detection of\
    \ Misissue .....................................24\n      7.3. Misbehaving Logs\
    \ ..........................................24\n   8. Efficiency Considerations\
    \ ......................................25\n   9. Future Changes .................................................25\n\
    \   10. Acknowledgements ..............................................25\n  \
    \ 11. References ....................................................25\n    \
    \  11.1. Normative Reference ......................................25\n      11.2.\
    \ Informative References ...................................26\n"
- title: 1.  Informal Introduction
  contents:
  - "1.  Informal Introduction\n   Certificate transparency aims to mitigate the problem\
    \ of misissued\n   certificates by providing publicly auditable, append-only,\
    \ untrusted\n   logs of all issued certificates.  The logs are publicly auditable\
    \ so\n   that it is possible for anyone to verify the correctness of each log\n\
    \   and to monitor when new certificates are added to it.  The logs do\n   not\
    \ themselves prevent misissue, but they ensure that interested\n   parties (particularly\
    \ those named in certificates) can detect such\n   misissuance.  Note that this\
    \ is a general mechanism, but in this\n   document, we only describe its use for\
    \ public TLS server certificates\n   issued by public certificate authorities\
    \ (CAs).\n   Each log consists of certificate chains, which can be submitted by\n\
    \   anyone.  It is expected that public CAs will contribute all their\n   newly\
    \ issued certificates to one or more logs; it is also expected\n   that certificate\
    \ holders will contribute their own certificate\n   chains.  In order to avoid\
    \ logs being spammed into uselessness, it is\n   required that each chain is rooted\
    \ in a known CA certificate.  When a\n   chain is submitted to a log, a signed\
    \ timestamp is returned, which\n   can later be used to provide evidence to clients\
    \ that the chain has\n   been submitted.  TLS clients can thus require that all\
    \ certificates\n   they see have been logged.\n   Those who are concerned about\
    \ misissue can monitor the logs, asking\n   them regularly for all new entries,\
    \ and can thus check whether\n   domains they are responsible for have had certificates\
    \ issued that\n   they did not expect.  What they do with this information,\n\
    \   particularly when they find that a misissuance has happened, is\n   beyond\
    \ the scope of this document, but broadly speaking, they can\n   invoke existing\
    \ business mechanisms for dealing with misissued\n   certificates.  Of course,\
    \ anyone who wants can monitor the logs and,\n   if they believe a certificate\
    \ is incorrectly issued, take action as\n   they see fit.\n   Similarly, those\
    \ who have seen signed timestamps from a particular\n   log can later demand a\
    \ proof of inclusion from that log.  If the log\n   is unable to provide this\
    \ (or, indeed, if the corresponding\n   certificate is absent from monitors' copies\
    \ of that log), that is\n   evidence of the incorrect operation of the log.  The\
    \ checking\n   operation is asynchronous to allow TLS connections to proceed without\n\
    \   delay, despite network connectivity issues and the vagaries of\n   firewalls.\n\
    \   The append-only property of each log is technically achieved using\n   Merkle\
    \ Trees, which can be used to show that any particular version\n   of the log\
    \ is a superset of any particular previous version.\n   Likewise, Merkle Trees\
    \ avoid the need to blindly trust logs: if a log\n   attempts to show different\
    \ things to different people, this can be\n   efficiently detected by comparing\
    \ tree roots and consistency proofs.\n   Similarly, other misbehaviors of any\
    \ log (e.g., issuing signed\n   timestamps for certificates they then don't log)\
    \ can be efficiently\n   detected and proved to the world at large.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 1.2.  Data Structures
  contents:
  - "1.2.  Data Structures\n   Data structures are defined according to the conventions\
    \ laid out in\n   Section 4 of [RFC5246].\n"
- title: 2.  Cryptographic Components
  contents:
  - '2.  Cryptographic Components

    '
- title: 2.1.  Merkle Hash Trees
  contents:
  - "2.1.  Merkle Hash Trees\n   Logs use a binary Merkle Hash Tree for efficient\
    \ auditing.  The\n   hashing algorithm is SHA-256 [FIPS.180-4] (note that this\
    \ is fixed\n   for this experiment, but it is anticipated that each log would\
    \ be\n   able to specify a hash algorithm).  The input to the Merkle Tree Hash\n\
    \   is a list of data entries; these entries will be hashed to form the\n   leaves\
    \ of the Merkle Hash Tree.  The output is a single 32-byte\n   Merkle Tree Hash.\
    \  Given an ordered list of n inputs, D[n] = {d(0),\n   d(1), ..., d(n-1)}, the\
    \ Merkle Tree Hash (MTH) is thus defined as\n   follows:\n   The hash of an empty\
    \ list is the hash of an empty string:\n   MTH({}) = SHA-256().\n   The hash of\
    \ a list with one entry (also known as a leaf hash) is:\n   MTH({d(0)}) = SHA-256(0x00\
    \ || d(0)).\n   For n > 1, let k be the largest power of two smaller than n (i.e.,\n\
    \   k < n <= 2k).  The Merkle Tree Hash of an n-element list D[n] is then\n  \
    \ defined recursively as\n   MTH(D[n]) = SHA-256(0x01 || MTH(D[0:k]) || MTH(D[k:n])),\n\
    \   where || is concatenation and D[k1:k2] denotes the list {d(k1),\n   d(k1+1),...,\
    \ d(k2-1)} of length (k2 - k1).  (Note that the hash\n   calculations for leaves\
    \ and nodes differ.  This domain separation is\n   required to give second preimage\
    \ resistance.)\n   Note that we do not require the length of the input list to\
    \ be a\n   power of two.  The resulting Merkle Tree may thus not be balanced;\n\
    \   however, its shape is uniquely determined by the number of leaves.\n   (Note:\
    \ This Merkle Tree is essentially the same as the history tree\n   [CrosbyWallach]\
    \ proposal, except our definition handles non-full\n   trees differently.)\n"
- title: 2.1.1.  Merkle Audit Paths
  contents:
  - "2.1.1.  Merkle Audit Paths\n   A Merkle audit path for a leaf in a Merkle Hash\
    \ Tree is the shortest\n   list of additional nodes in the Merkle Tree required\
    \ to compute the\n   Merkle Tree Hash for that tree.  Each node in the tree is\
    \ either a\n   leaf node or is computed from the two nodes immediately below it\n\
    \   (i.e., towards the leaves).  At each step up the tree (towards the\n   root),\
    \ a node from the audit path is combined with the node computed\n   so far.  In\
    \ other words, the audit path consists of the list of\n   missing nodes required\
    \ to compute the nodes leading from a leaf to\n   the root of the tree.  If the\
    \ root computed from the audit path\n   matches the true root, then the audit\
    \ path is proof that the leaf\n   exists in the tree.\n   Given an ordered list\
    \ of n inputs to the tree, D[n] = {d(0), ...,\n   d(n-1)}, the Merkle audit path\
    \ PATH(m, D[n]) for the (m+1)th input\n   d(m), 0 <= m < n, is defined as follows:\n\
    \   The path for the single leaf in a tree with a one-element input list\n   D[1]\
    \ = {d(0)} is empty:\n   PATH(0, {d(0)}) = {}\n   For n > 1, let k be the largest\
    \ power of two smaller than n.  The\n   path for the (m+1)th element d(m) in a\
    \ list of n > m elements is then\n   defined recursively as\n   PATH(m, D[n])\
    \ = PATH(m, D[0:k]) : MTH(D[k:n]) for m < k; and\n   PATH(m, D[n]) = PATH(m -\
    \ k, D[k:n]) : MTH(D[0:k]) for m >= k,\n   where : is concatenation of lists and\
    \ D[k1:k2] denotes the length\n   (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)}\
    \ as before.\n"
- title: 2.1.2.  Merkle Consistency Proofs
  contents:
  - "2.1.2.  Merkle Consistency Proofs\n   Merkle consistency proofs prove the append-only\
    \ property of the tree.\n   A Merkle consistency proof for a Merkle Tree Hash\
    \ MTH(D[n]) and a\n   previously advertised hash MTH(D[0:m]) of the first m leaves,\
    \ m <= n,\n   is the list of nodes in the Merkle Tree required to verify that\
    \ the\n   first m inputs D[0:m] are equal in both trees.  Thus, a consistency\n\
    \   proof must contain a set of intermediate nodes (i.e., commitments to\n   inputs)\
    \ sufficient to verify MTH(D[n]), such that (a subset of) the\n   same nodes can\
    \ be used to verify MTH(D[0:m]).  We define an algorithm\n   that outputs the\
    \ (unique) minimal consistency proof.\n   Given an ordered list of n inputs to\
    \ the tree, D[n] = {d(0), ...,\n   d(n-1)}, the Merkle consistency proof PROOF(m,\
    \ D[n]) for a previous\n   Merkle Tree Hash MTH(D[0:m]), 0 < m < n, is defined\
    \ as:\n   PROOF(m, D[n]) = SUBPROOF(m, D[n], true)\n   The subproof for m = n\
    \ is empty if m is the value for which PROOF was\n   originally requested (meaning\
    \ that the subtree Merkle Tree Hash\n   MTH(D[0:m]) is known):\n   SUBPROOF(m,\
    \ D[m], true) = {}\n   The subproof for m = n is the Merkle Tree Hash committing\
    \ inputs\n   D[0:m]; otherwise:\n   SUBPROOF(m, D[m], false) = {MTH(D[m])}\n \
    \  For m < n, let k be the largest power of two smaller than n.  The\n   subproof\
    \ is then defined recursively.\n   If m <= k, the right subtree entries D[k:n]\
    \ only exist in the current\n   tree.  We prove that the left subtree entries\
    \ D[0:k] are consistent\n   and add a commitment to D[k:n]:\n   SUBPROOF(m, D[n],\
    \ b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n])\n   If m > k, the left subtree entries\
    \ D[0:k] are identical in both\n   trees.  We prove that the right subtree entries\
    \ D[k:n] are consistent\n   and add a commitment to D[0:k].\n   SUBPROOF(m, D[n],\
    \ b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k])\n   Here, : is a concatenation\
    \ of lists, and D[k1:k2] denotes the length\n   (k2 - k1) list {d(k1), d(k1+1),...,\
    \ d(k2-1)} as before.\n   The number of nodes in the resulting proof is bounded\
    \ above by\n   ceil(log2(n)) + 1.\n"
- title: 2.1.3.  Example
  contents:
  - "2.1.3.  Example\n   The binary Merkle Tree with 7 leaves:\n               hash\n\
    \              /    \\\n             /      \\\n            /        \\\n    \
    \       /          \\\n          /            \\\n         k              l\n\
    \        / \\            / \\\n       /   \\          /   \\\n      /     \\ \
    \       /     \\\n     g       h      i      j\n    / \\     / \\    / \\    \
    \ |\n    a b     c d    e f     d6\n    | |     | |    | |\n   d0 d1   d2 d3 \
    \ d4 d5\n   The audit path for d0 is [b, h, l].\n   The audit path for d3 is [c,\
    \ g, l].\n   The audit path for d4 is [f, j, k].\n   The audit path for d6 is\
    \ [i, k].\n   The same tree, built incrementally in four steps:\n       hash0\
    \          hash1=k\n       / \\              /  \\\n      /   \\            /\
    \    \\\n     /     \\          /      \\\n     g      c         g       h\n \
    \   / \\     |        / \\     / \\\n    a b     d2       a b     c d\n    | |\
    \              | |     | |\n   d0 d1            d0 d1   d2 d3\n             hash2\
    \                    hash\n             /  \\                    /    \\\n   \
    \         /    \\                  /      \\\n           /      \\           \
    \     /        \\\n          /        \\              /          \\\n        \
    \ /          \\            /            \\\n        k            i          k\
    \              l\n       / \\          / \\        / \\            / \\\n    \
    \  /   \\         e f       /   \\          /   \\\n     /     \\        | | \
    \     /     \\        /     \\\n    g       h      d4 d5    g       h      i \
    \     j\n   / \\     / \\             / \\     / \\    / \\     |\n   a b    \
    \ c d             a b     c d    e f     d6\n   | |     | |             | |  \
    \   | |    | |\n   d0 d1   d2 d3           d0 d1   d2 d3  d4 d5\n   The consistency\
    \ proof between hash0 and hash is PROOF(3, D[7]) = [c,\n   d, g, l].  c, g are\
    \ used to verify hash0, and d, l are additionally\n   used to show hash is consistent\
    \ with hash0.\n   The consistency proof between hash1 and hash is PROOF(4, D[7])\
    \ = [l].\n   hash can be verified using hash1=k and l.\n   The consistency proof\
    \ between hash2 and hash is PROOF(6, D[7]) = [i,\n   j, k].  k, i are used to\
    \ verify hash2, and j is additionally used to\n   show hash is consistent with\
    \ hash2.\n"
- title: 2.1.4.  Signatures
  contents:
  - "2.1.4.  Signatures\n   Various data structures are signed.  A log MUST use either\
    \ elliptic\n   curve signatures using the NIST P-256 curve (Section D.1.2.3 of\
    \ the\n   Digital Signature Standard [DSS]) or RSA signatures (RSASSA-PKCS1-\n\
    \   V1_5 with SHA-256, Section 8.2 of [RFC3447]) using a key of at least\n   2048\
    \ bits.\n"
- title: 3.  Log Format and Operation
  contents:
  - "3.  Log Format and Operation\n   Anyone can submit certificates to certificate\
    \ logs for public\n   auditing; however, since certificates will not be accepted\
    \ by TLS\n   clients unless logged, it is expected that certificate owners or\n\
    \   their CAs will usually submit them.  A log is a single, ever-growing,\n  \
    \ append-only Merkle Tree of such certificates.\n   When a valid certificate is\
    \ submitted to a log, the log MUST\n   immediately return a Signed Certificate\
    \ Timestamp (SCT).  The SCT is\n   the log's promise to incorporate the certificate\
    \ in the Merkle Tree\n   within a fixed amount of time known as the Maximum Merge\
    \ Delay (MMD).\n   If the log has previously seen the certificate, it MAY return\
    \ the\n   same SCT as it returned before.  TLS servers MUST present an SCT from\n\
    \   one or more logs to the TLS client together with the certificate.\n   TLS\
    \ clients MUST reject certificates that do not have a valid SCT for\n   the end-entity\
    \ certificate.\n   Periodically, each log appends all its new entries to the Merkle\
    \ Tree\n   and signs the root of the tree.  Auditors can thus verify that each\n\
    \   certificate for which an SCT has been issued indeed appears in the\n   log.\
    \  The log MUST incorporate a certificate in its Merkle Tree\n   within the Maximum\
    \ Merge Delay period after the issuance of the SCT.\n   Log operators MUST NOT\
    \ impose any conditions on retrieving or sharing\n   data from the log.\n"
- title: 3.1.  Log Entries
  contents:
  - "3.1.  Log Entries\n   Anyone can submit a certificate to any log.  In order to\
    \ enable\n   attribution of each logged certificate to its issuer, the log SHALL\n\
    \   publish a list of acceptable root certificates (this list might\n   usefully\
    \ be the union of root certificates trusted by major browser\n   vendors).  Each\
    \ submitted certificate MUST be accompanied by all\n   additional certificates\
    \ required to verify the certificate chain up\n   to an accepted root certificate.\
    \  The root certificate itself MAY be\n   omitted from the chain submitted to\
    \ the log server.\n   Alternatively, (root as well as intermediate) certificate\
    \ authorities\n   may submit a certificate to logs prior to issuance.  To do so,\
    \ the CA\n   submits a Precertificate that the log can use to create an entry\
    \ that\n   will be valid against the issued certificate.  The Precertificate is\n\
    \   constructed from the certificate to be issued by adding a special\n   critical\
    \ poison extension (OID 1.3.6.1.4.1.11129.2.4.3, whose\n   extnValue OCTET STRING\
    \ contains ASN.1 NULL data (0x05 0x00)) to the\n   end-entity TBSCertificate (this\
    \ extension is to ensure that the\n   Precertificate cannot be validated by a\
    \ standard X.509v3 client) and\n   signing the resulting TBSCertificate [RFC5280]\
    \ with either\n   o  a special-purpose (CA:true, Extended Key Usage: Certificate\n\
    \      Transparency, OID 1.3.6.1.4.1.11129.2.4.4) Precertificate Signing\n   \
    \   Certificate.  The Precertificate Signing Certificate MUST be\n      directly\
    \ certified by the (root or intermediate) CA certificate\n      that will ultimately\
    \ sign the end-entity TBSCertificate yielding\n      the end-entity certificate\
    \ (note that the log may relax standard\n      validation rules to allow this,\
    \ so long as the issued certificate\n      will be valid),\n   o  or, the CA certificate\
    \ that will sign the final certificate.\n   As above, the Precertificate submission\
    \ MUST be accompanied by the\n   Precertificate Signing Certificate, if used,\
    \ and all additional\n   certificates required to verify the chain up to an accepted\
    \ root\n   certificate.  The signature on the TBSCertificate indicates the\n \
    \  certificate authority's intent to issue a certificate.  This intent\n   is\
    \ considered binding (i.e., misissuance of the Precertificate is\n   considered\
    \ equal to misissuance of the final certificate).  Each log\n   verifies the Precertificate\
    \ signature chain and issues a Signed\n   Certificate Timestamp on the corresponding\
    \ TBSCertificate.\n   Logs MUST verify that the submitted end-entity certificate\
    \ or\n   Precertificate has a valid signature chain leading back to a trusted\n\
    \   root CA certificate, using the chain of intermediate CA certificates\n   provided\
    \ by the submitter.  Logs MAY accept certificates that have\n   expired, are not\
    \ yet valid, have been revoked, or are otherwise not\n   fully valid according\
    \ to X.509 verification rules in order to\n   accommodate quirks of CA certificate-issuing\
    \ software.  However, logs\n   MUST refuse to publish certificates without a valid\
    \ chain to a known\n   root CA.  If a certificate is accepted and an SCT issued,\
    \ the\n   accepting log MUST store the entire chain used for verification,\n \
    \  including the certificate or Precertificate itself and including the\n   root\
    \ certificate used to verify the chain (even if it was omitted\n   from the submission),\
    \ and MUST present this chain for auditing upon\n   request.  This chain is required\
    \ to prevent a CA from avoiding blame\n   by logging a partial or empty chain.\
    \  (Note: This effectively\n   excludes self-signed and DANE-based certificates\
    \ until some mechanism\n   to control spam for those certificates is found.  The\
    \ authors welcome\n   suggestions.)\n   Each certificate entry in a log MUST include\
    \ the following\n   components:\n       enum { x509_entry(0), precert_entry(1),\
    \ (65535) } LogEntryType;\n       struct {\n           LogEntryType entry_type;\n\
    \           select (entry_type) {\n               case x509_entry: X509ChainEntry;\n\
    \               case precert_entry: PrecertChainEntry;\n           } entry;\n\
    \       } LogEntry;\n       opaque ASN.1Cert<1..2^24-1>;\n       struct {\n  \
    \         ASN.1Cert leaf_certificate;\n           ASN.1Cert certificate_chain<0..2^24-1>;\n\
    \       } X509ChainEntry;\n       struct {\n           ASN.1Cert pre_certificate;\n\
    \           ASN.1Cert precertificate_chain<0..2^24-1>;\n       } PrecertChainEntry;\n\
    \   Logs MAY limit the length of chain they will accept.\n   \"entry_type\" is\
    \ the type of this entry.  Future revisions of this\n   protocol version may add\
    \ new LogEntryType values.  Section 4 explains\n   how clients should handle unknown\
    \ entry types.\n   \"leaf_certificate\" is the end-entity certificate submitted\
    \ for\n   auditing.\n   \"certificate_chain\" is a chain of additional certificates\
    \ required to\n   verify the end-entity certificate.  The first certificate MUST\n\
    \   certify the end-entity certificate.  Each following certificate MUST\n   directly\
    \ certify the one preceding it.  The final certificate MUST be\n   a root certificate\
    \ accepted by the log.\n   \"pre_certificate\" is the Precertificate submitted\
    \ for auditing.\n   \"precertificate_chain\" is a chain of additional certificates\
    \ required\n   to verify the Precertificate submission.  The first certificate\
    \ MAY\n   be a valid Precertificate Signing Certificate and MUST certify the\n\
    \   first certificate.  Each following certificate MUST directly certify\n   the\
    \ one preceding it.  The final certificate MUST be a root\n   certificate accepted\
    \ by the log.\n"
- title: 3.2.  Structure of the Signed Certificate Timestamp
  contents:
  - "3.2.  Structure of the Signed Certificate Timestamp\n       enum { certificate_timestamp(0),\
    \ tree_hash(1), (255) }\n         SignatureType;\n       enum { v1(0), (255) }\n\
    \         Version;\n         struct {\n             opaque key_id[32];\n     \
    \    } LogID;\n         opaque TBSCertificate<1..2^24-1>;\n         struct {\n\
    \           opaque issuer_key_hash[32];\n           TBSCertificate tbs_certificate;\n\
    \         } PreCert;\n         opaque CtExtensions<0..2^16-1>;\n   \"key_id\"\
    \ is the SHA-256 hash of the log's public key, calculated over\n   the DER encoding\
    \ of the key represented as SubjectPublicKeyInfo.\n   \"issuer_key_hash\" is the\
    \ SHA-256 hash of the certificate issuer's\n   public key, calculated over the\
    \ DER encoding of the key represented\n   as SubjectPublicKeyInfo.  This is needed\
    \ to bind the issuer to the\n   final certificate.\n   \"tbs_certificate\" is\
    \ the DER-encoded TBSCertificate (see [RFC5280])\n   component of the Precertificate\
    \ -- that is, without the signature and\n   the poison extension.  If the Precertificate\
    \ is not signed with the\n   CA certificate that will issue the final certificate,\
    \ then the\n   TBSCertificate also has its issuer changed to that of the CA that\n\
    \   will issue the final certificate.  Note that it is also possible to\n   reconstruct\
    \ this TBSCertificate from the final certificate by\n   extracting the TBSCertificate\
    \ from it and deleting the SCT extension.\n   Also note that since the TBSCertificate\
    \ contains an\n   AlgorithmIdentifier that must match both the Precertificate\
    \ signature\n   algorithm and final certificate signature algorithm, they must\
    \ be\n   signed with the same algorithm and parameters.  If the Precertificate\n\
    \   is issued using a Precertificate Signing Certificate and an Authority\n  \
    \ Key Identifier extension is present in the TBSCertificate, the\n   corresponding\
    \ extension must also be present in the Precertificate\n   Signing Certificate\
    \ -- in this case, the TBSCertificate also has its\n   Authority Key Identifier\
    \ changed to match the final issuer.\n       struct {\n           Version sct_version;\n\
    \           LogID id;\n           uint64 timestamp;\n           CtExtensions extensions;\n\
    \           digitally-signed struct {\n               Version sct_version;\n \
    \              SignatureType signature_type = certificate_timestamp;\n       \
    \        uint64 timestamp;\n               LogEntryType entry_type;\n        \
    \       select(entry_type) {\n                   case x509_entry: ASN.1Cert;\n\
    \                   case precert_entry: PreCert;\n               } signed_entry;\n\
    \              CtExtensions extensions;\n           };\n       } SignedCertificateTimestamp;\n\
    \   The encoding of the digitally-signed element is defined in [RFC5246].\n  \
    \ \"sct_version\" is the version of the protocol to which the SCT\n   conforms.\
    \  This version is v1.\n   \"timestamp\" is the current NTP Time [RFC5905], measured\
    \ since the\n   epoch (January 1, 1970, 00:00), ignoring leap seconds, in\n  \
    \ milliseconds.\n   \"entry_type\" may be implicit from the context in which the\
    \ SCT is\n   presented.\n   \"signed_entry\" is the \"leaf_certificate\" (in the\
    \ case of an\n   X509ChainEntry) or is the PreCert (in the case of a\n   PrecertChainEntry),\
    \ as described above.\n   \"extensions\" are future extensions to this protocol\
    \ version (v1).\n   Currently, no extensions are specified.\n"
- title: 3.3.  Including the Signed Certificate Timestamp in the TLS Handshake
  contents:
  - "3.3.  Including the Signed Certificate Timestamp in the TLS Handshake\n   The\
    \ SCT data corresponding to the end-entity certificate from at\n   least one log\
    \ must be included in the TLS handshake, either by using\n   an X509v3 certificate\
    \ extension as described below, by using a TLS\n   extension (Section 7.4.1.4\
    \ of [RFC5246]) with type\n   \"signed_certificate_timestamp\", or by using Online\
    \ Certificate Status\n   Protocol (OCSP) Stapling (also known as the \"Certificate\
    \ Status\n   Request\" TLS extension; see [RFC6066]), where the response includes\n\
    \   an OCSP extension with OID 1.3.6.1.4.1.11129.2.4.5 (see [RFC2560])\n   and\
    \ body:\n       SignedCertificateTimestampList ::= OCTET STRING\n   At least one\
    \ SCT MUST be included.  Server operators MAY include more\n   than one SCT.\n\
    \   Similarly, a certificate authority MAY submit a Precertificate to\n   more\
    \ than one log, and all obtained SCTs can be directly embedded in\n   the final\
    \ certificate, by encoding the SignedCertificateTimestampList\n   structure as\
    \ an ASN.1 OCTET STRING and inserting the resulting data\n   in the TBSCertificate\
    \ as an X.509v3 certificate extension (OID\n   1.3.6.1.4.1.11129.2.4.2).  Upon\
    \ receiving the certificate, clients\n   can reconstruct the original TBSCertificate\
    \ to verify the SCT\n   signature.\n   The contents of the ASN.1 OCTET STRING\
    \ embedded in an OCSP extension\n   or X509v3 certificate extension are as follows:\n\
    \        opaque SerializedSCT<1..2^16-1>;\n        struct {\n            SerializedSCT\
    \ sct_list <1..2^16-1>;\n        } SignedCertificateTimestampList;\n   Here, \"\
    SerializedSCT\" is an opaque byte string that contains the\n   serialized TLS\
    \ structure.  This encoding ensures that TLS clients can\n   decode each SCT individually\
    \ (i.e., if there is a version upgrade,\n   out-of-date clients can still parse\
    \ old SCTs while skipping over new\n   SCTs whose versions they don't understand).\n\
    \   Likewise, SCTs can be embedded in a TLS extension.  See below for\n   details.\n\
    \   TLS clients MUST implement all three mechanisms.  Servers MUST\n   implement\
    \ at least one of the three mechanisms.  Note that existing\n   TLS servers can\
    \ generally use the certificate extension mechanism\n   without modification.\n\
    \   TLS servers should send SCTs from multiple logs in case one or more\n   logs\
    \ are not acceptable to the client (for example, if a log has been\n   struck\
    \ off for misbehavior or has had a key compromise).\n"
- title: 3.3.1.  TLS Extension
  contents:
  - "3.3.1.  TLS Extension\n   The SCT can be sent during the TLS handshake using\
    \ a TLS extension\n   with type \"signed_certificate_timestamp\".\n   Clients\
    \ that support the extension SHOULD send a ClientHello\n   extension with the\
    \ appropriate type and empty \"extension_data\".\n   Servers MUST only send SCTs\
    \ to clients who have indicated support for\n   the extension in the ClientHello,\
    \ in which case the SCTs are sent by\n   setting the \"extension_data\" to a \"\
    SignedCertificateTimestampList\".\n   Session resumption uses the original session\
    \ information: clients\n   SHOULD include the extension type in the ClientHello,\
    \ but if the\n   session is resumed, the server is not expected to process it\
    \ or\n   include the extension in the ServerHello.\n"
- title: 3.4.  Merkle Tree
  contents:
  - "3.4.  Merkle Tree\n   The hashing algorithm for the Merkle Tree Hash is SHA-256.\n\
    \   Structure of the Merkle Tree input:\n       enum { timestamped_entry(0), (255)\
    \ }\n         MerkleLeafType;\n       struct {\n           uint64 timestamp;\n\
    \           LogEntryType entry_type;\n           select(entry_type) {\n      \
    \         case x509_entry: ASN.1Cert;\n               case precert_entry: PreCert;\n\
    \           } signed_entry;\n           CtExtensions extensions;\n       } TimestampedEntry;\n\
    \       struct {\n           Version version;\n           MerkleLeafType leaf_type;\n\
    \           select (leaf_type) {\n               case timestamped_entry: TimestampedEntry;\n\
    \           }\n       } MerkleTreeLeaf;\n   Here, \"version\" is the version of\
    \ the protocol to which the\n   MerkleTreeLeaf corresponds.  This version is v1.\n\
    \   \"leaf_type\" is the type of the leaf input.  Currently, only\n   \"timestamped_entry\"\
    \ (corresponding to an SCT) is defined.  Future\n   revisions of this protocol\
    \ version may add new MerkleLeafType types.\n   Section 4 explains how clients\
    \ should handle unknown leaf types.\n   \"timestamp\" is the timestamp of the\
    \ corresponding SCT issued for this\n   certificate.\n   \"signed_entry\" is the\
    \ \"signed_entry\" of the corresponding SCT.\n   \"extensions\" are \"extensions\"\
    \ of the corresponding SCT.\n   The leaves of the Merkle Tree are the leaf hashes\
    \ of the\n   corresponding \"MerkleTreeLeaf\" structures.\n"
- title: 3.5.  Signed Tree Head
  contents:
  - "3.5.  Signed Tree Head\n   Every time a log appends new entries to the tree,\
    \ the log SHOULD sign\n   the corresponding tree hash and tree information (see\
    \ the\n   corresponding Signed Tree Head client message in Section 4.3).  The\n\
    \   signature for that data is structured as follows:\n       digitally-signed\
    \ struct {\n           Version version;\n           SignatureType signature_type\
    \ = tree_hash;\n           uint64 timestamp;\n           uint64 tree_size;\n \
    \          opaque sha256_root_hash[32];\n       } TreeHeadSignature;\n   \"version\"\
    \ is the version of the protocol to which the\n   TreeHeadSignature conforms.\
    \  This version is v1.\n   \"timestamp\" is the current time.  The timestamp MUST\
    \ be at least as\n   recent as the most recent SCT timestamp in the tree.  Each\
    \ subsequent\n   timestamp MUST be more recent than the timestamp of the previous\n\
    \   update.\n   \"tree_size\" equals the number of entries in the new tree.\n\
    \   \"sha256_root_hash\" is the root of the Merkle Hash Tree.\n   Each log MUST\
    \ produce on demand a Signed Tree Head that is no older\n   than the Maximum Merge\
    \ Delay.  In the unlikely event that it receives\n   no new submissions during\
    \ an MMD period, the log SHALL sign the same\n   Merkle Tree Hash with a fresh\
    \ timestamp.\n"
- title: 4.  Log Client Messages
  contents:
  - "4.  Log Client Messages\n   Messages are sent as HTTPS GET or POST requests.\
    \  Parameters for\n   POSTs and all responses are encoded as JavaScript Object\
    \ Notation\n   (JSON) objects [RFC4627].  Parameters for GETs are encoded as order-\n\
    \   independent key/value URL parameters, using the \"application/\n   x-www-form-urlencoded\"\
    \ format described in the \"HTML 4.01\n   Specification\" [HTML401].  Binary data\
    \ is base64 encoded [RFC4648] as\n   specified in the individual messages.\n \
    \  Note that JSON objects and URL parameters may contain fields not\n   specified\
    \ here.  These extra fields should be ignored.\n   The <log server> prefix can\
    \ include a path as well as a server name\n   and a port.\n   In general, where\
    \ needed, the \"version\" is v1 and the \"id\" is the log\n   id for the log server\
    \ queried.\n   Any errors will be returned as HTTP 4xx or 5xx responses, with\
    \ human-\n   readable error messages.\n"
- title: 4.1.  Add Chain to Log
  contents:
  - "4.1.  Add Chain to Log\n   POST https://<log server>/ct/v1/add-chain\n   Inputs:\n\
    \      chain:  An array of base64-encoded certificates.  The first\n         element\
    \ is the end-entity certificate; the second chains to the\n         first and\
    \ so on to the last, which is either the root\n         certificate or a certificate\
    \ that chains to a known root\n         certificate.\n   Outputs:\n      sct_version:\
    \  The version of the SignedCertificateTimestamp\n         structure, in decimal.\
    \  A compliant v1 implementation MUST NOT\n         expect this to be 0 (i.e.,\
    \ v1).\n      id:  The log ID, base64 encoded.  Since log clients who request\
    \ an\n         SCT for inclusion in TLS handshakes are not required to verify\n\
    \         it, we do not assume they know the ID of the log.\n      timestamp:\
    \  The SCT timestamp, in decimal.\n      extensions:  An opaque type for future\
    \ expansion.  It is likely\n         that not all participants will need to understand\
    \ data in this\n         field.  Logs should set this to the empty string.  Clients\n\
    \         should decode the base64-encoded data and include it in the\n      \
    \   SCT.\n      signature:  The SCT signature, base64 encoded.\n   If the \"sct_version\"\
    \ is not v1, then a v1 client may be unable to\n   verify the signature.  It MUST\
    \ NOT construe this as an error.  (Note:\n   Log clients don't need to be able\
    \ to verify this structure; only TLS\n   clients do.  If we were to serve the\
    \ structure as a binary blob, then\n   we could completely change it without requiring\
    \ an upgrade to v1\n   clients.)\n"
- title: 4.2.  Add PreCertChain to Log
  contents:
  - "4.2.  Add PreCertChain to Log\n   POST https://<log server>/ct/v1/add-pre-chain\n\
    \   Inputs:\n      chain:  An array of base64-encoded Precertificates.  The first\n\
    \         element is the end-entity certificate; the second chains to the\n  \
    \       first and so on to the last, which is either the root\n         certificate\
    \ or a certificate that chains to a known root\n         certificate.\n   Outputs\
    \ are the same as in Section 4.1.\n"
- title: 4.3.  Retrieve Latest Signed Tree Head
  contents:
  - "4.3.  Retrieve Latest Signed Tree Head\n   GET https://<log server>/ct/v1/get-sth\n\
    \   No inputs.\n   Outputs:\n      tree_size:  The size of the tree, in entries,\
    \ in decimal.\n      timestamp:  The timestamp, in decimal.\n      sha256_root_hash:\
    \  The Merkle Tree Hash of the tree, in base64.\n      tree_head_signature:  A\
    \ TreeHeadSignature for the above data.\n"
- title: 4.4.  Retrieve Merkle Consistency Proof between Two Signed Tree Heads
  contents:
  - "4.4.  Retrieve Merkle Consistency Proof between Two Signed Tree Heads\n   GET\
    \ https://<log server>/ct/v1/get-sth-consistency\n   Inputs:\n      first:  The\
    \ tree_size of the first tree, in decimal.\n      second:  The tree_size of the\
    \ second tree, in decimal.\n   Both tree sizes must be from existing v1 STHs (Signed\
    \ Tree Heads).\n   Outputs:\n      consistency:  An array of Merkle Tree nodes,\
    \ base64 encoded.\n   Note that no signature is required on this data, as it is\
    \ used to\n   verify an STH, which is signed.\n"
- title: 4.5.  Retrieve Merkle Audit Proof from Log by Leaf Hash
  contents:
  - "4.5.  Retrieve Merkle Audit Proof from Log by Leaf Hash\n   GET https://<log\
    \ server>/ct/v1/get-proof-by-hash\n   Inputs:\n      hash:  A base64-encoded v1\
    \ leaf hash.\n      tree_size:  The tree_size of the tree on which to base the\
    \ proof,\n         in decimal.\n   The \"hash\" must be calculated as defined\
    \ in Section 3.4.  The\n   \"tree_size\" must designate an existing v1 STH.\n\
    \   Outputs:\n      leaf_index:  The 0-based index of the end entity corresponding\
    \ to\n         the \"hash\" parameter.\n      audit_path:  An array of base64-encoded\
    \ Merkle Tree nodes proving\n         the inclusion of the chosen certificate.\n"
- title: 4.6.  Retrieve Entries from Log
  contents:
  - "4.6.  Retrieve Entries from Log\n   GET https://<log server>/ct/v1/get-entries\n\
    \   Inputs:\n      start:  0-based index of first entry to retrieve, in decimal.\n\
    \      end:  0-based index of last entry to retrieve, in decimal.\n   Outputs:\n\
    \      entries:  An array of objects, each consisting of\n         leaf_input:\
    \  The base64-encoded MerkleTreeLeaf structure.\n         extra_data:  The base64-encoded\
    \ unsigned data pertaining to the\n            log entry.  In the case of an X509ChainEntry,\
    \ this is the\n            \"certificate_chain\".  In the case of a PrecertChainEntry,\n\
    \            this is the whole \"PrecertChainEntry\".\n   Note that this message\
    \ is not signed -- the retrieved data can be\n   verified by constructing the\
    \ Merkle Tree Hash corresponding to a\n   retrieved STH.  All leaves MUST be v1.\
    \  However, a compliant v1\n   client MUST NOT construe an unrecognized MerkleLeafType\
    \ or\n   LogEntryType value as an error.  This means it may be unable to parse\n\
    \   some entries, but note that each client can inspect the entries it\n   does\
    \ recognize as well as verify the integrity of the data by\n   treating unrecognized\
    \ leaves as opaque input to the tree.\n   The \"start\" and \"end\" parameters\
    \ SHOULD be within the range 0 <= x <\n   \"tree_size\" as returned by \"get-sth\"\
    \ in Section 4.3.\n   Logs MAY honor requests where 0 <= \"start\" < \"tree_size\"\
    \ and \"end\" >=\n   \"tree_size\" by returning a partial response covering only\
    \ the valid\n   entries in the specified range.  Note that the following restriction\n\
    \   may also apply:\n   Logs MAY restrict the number of entries that can be retrieved\
    \ per\n   \"get-entries\" request.  If a client requests more than the permitted\n\
    \   number of entries, the log SHALL return the maximum number of entries\n  \
    \ permissible.  These entries SHALL be sequential beginning with the\n   entry\
    \ specified by \"start\".\n"
- title: 4.7.  Retrieve Accepted Root Certificates
  contents:
  - "4.7.  Retrieve Accepted Root Certificates\n   GET https://<log server>/ct/v1/get-roots\n\
    \   No inputs.\n   Outputs:\n      certificates:  An array of base64-encoded root\
    \ certificates that\n         are acceptable to the log.\n"
- title: 4.8.  Retrieve Entry+Merkle Audit Proof from Log
  contents:
  - "4.8.  Retrieve Entry+Merkle Audit Proof from Log\n   GET https://<log server>/ct/v1/get-entry-and-proof\n\
    \   Inputs:\n      leaf_index:  The index of the desired entry.\n      tree_size:\
    \  The tree_size of the tree for which the proof is\n         desired.\n   The\
    \ tree size must designate an existing STH.\n   Outputs:\n      leaf_input:  The\
    \ base64-encoded MerkleTreeLeaf structure.\n      extra_data:  The base64-encoded\
    \ unsigned data, same as in\n         Section 4.6.\n      audit_path:  An array\
    \ of base64-encoded Merkle Tree nodes proving\n         the inclusion of the chosen\
    \ certificate.\n   This API is probably only useful for debugging.\n"
- title: 5.  Clients
  contents:
  - "5.  Clients\n   There are various different functions clients of logs might perform.\n\
    \   We describe here some typical clients and how they could function.\n   Any\
    \ inconsistency may be used as evidence that a log has not behaved\n   correctly,\
    \ and the signatures on the data structures prevent the log\n   from denying that\
    \ misbehavior.\n   All clients should gossip with each other, exchanging STHs\
    \ at least;\n   this is all that is required to ensure that they all have a\n\
    \   consistent view.  The exact mechanism for gossip will be described in\n  \
    \ a separate document, but it is expected there will be a variety.\n"
- title: 5.1.  Submitters
  contents:
  - "5.1.  Submitters\n   Submitters submit certificates or Precertificates to the\
    \ log as\n   described above.  They may go on to use the returned SCT to construct\n\
    \   a certificate or use it directly in a TLS handshake.\n"
- title: 5.2.  TLS Client
  contents:
  - "5.2.  TLS Client\n   TLS clients are not directly clients of the log, but they\
    \ receive\n   SCTs alongside or in server certificates.  In addition to normal\n\
    \   validation of the certificate and its chain, they should validate the\n  \
    \ SCT by computing the signature input from the SCT data as well as the\n   certificate\
    \ and verifying the signature, using the corresponding\n   log's public key. \
    \ Note that this document does not describe how\n   clients obtain the logs' public\
    \ keys.\n   TLS clients MUST reject SCTs whose timestamp is in the future.\n"
- title: 5.3.  Monitor
  contents:
  - "5.3.  Monitor\n   Monitors watch logs and check that they behave correctly. \
    \ They also\n   watch for certificates of interest.\n   A monitor needs to, at\
    \ least, inspect every new entry in each log it\n   watches.  It may also want\
    \ to keep copies of entire logs.  In order\n   to do this, it should follow these\
    \ steps for each log:\n   1.  Fetch the current STH (Section 4.3).\n   2.  Verify\
    \ the STH signature.\n   3.  Fetch all the entries in the tree corresponding to\
    \ the STH\n       (Section 4.6).\n   4.  Confirm that the tree made from the fetched\
    \ entries produces the\n       same hash as that in the STH.\n   5.  Fetch the\
    \ current STH (Section 4.3).  Repeat until the STH\n       changes.\n   6.  Verify\
    \ the STH signature.\n   7.  Fetch all the new entries in the tree corresponding\
    \ to the STH\n       (Section 4.6).  If they remain unavailable for an extended\n\
    \       period, then this should be viewed as misbehavior on the part of\n   \
    \    the log.\n   8.  Either:\n       1.  Verify that the updated list of all\
    \ entries generates a tree\n           with the same hash as the new STH.\n  \
    \     Or, if it is not keeping all log entries:\n       2.  Fetch a consistency\
    \ proof for the new STH with the previous\n           STH (Section 4.4).\n   \
    \    3.  Verify the consistency proof.\n       4.  Verify that the new entries\
    \ generate the corresponding\n           elements in the consistency proof.\n\
    \   9.  Go to Step 5.\n"
- title: 5.4.  Auditor
  contents:
  - "5.4.  Auditor\n   Auditors take partial information about a log as input and\
    \ verify\n   that this information is consistent with other partial information\n\
    \   they have.  An auditor might be an integral component of a TLS\n   client;\
    \ it might be a standalone service; or it might be a secondary\n   function of\
    \ a monitor.\n   Any pair of STHs from the same log can be verified by requesting\
    \ a\n   consistency proof (Section 4.4).\n   A certificate accompanied by an SCT\
    \ can be verified against any STH\n   dated after the SCT timestamp + the Maximum\
    \ Merge Delay by requesting\n   a Merkle audit proof (Section 4.5).\n   Auditors\
    \ can fetch STHs from time to time of their own accord, of\n   course (Section\
    \ 4.3).\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   IANA has allocated an RFC 5246 ExtensionType value\
    \ (18) for the SCT\n   TLS extension.  The extension name is \"signed_certificate_timestamp\"\
    .\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   With CAs, logs, and servers performing the actions\
    \ described here,\n   TLS clients can use logs and signed timestamps to reduce\
    \ the\n   likelihood that they will accept misissued certificates.  If a server\n\
    \   presents a valid signed timestamp for a certificate, then the client\n   knows\
    \ that the certificate has been published in a log.  From this,\n   the client\
    \ knows that the subject of the certificate has had some\n   time to notice the\
    \ misissue and take some action, such as asking a CA\n   to revoke a misissued\
    \ certificate.  A signed timestamp is not a\n   guarantee that the certificate\
    \ is not misissued, since the subject of\n   the certificate might not have checked\
    \ the logs or the CA might have\n   refused to revoke the certificate.\n   In\
    \ addition, if TLS clients will not accept unlogged certificates,\n   then site\
    \ owners will have a greater incentive to submit certificates\n   to logs, possibly\
    \ with the assistance of their CA, increasing the\n   overall transparency of\
    \ the system.\n"
- title: 7.1.  Misissued Certificates
  contents:
  - "7.1.  Misissued Certificates\n   Misissued certificates that have not been publicly\
    \ logged, and thus\n   do not have a valid SCT, will be rejected by TLS clients.\
    \  Misissued\n   certificates that do have an SCT from a log will appear in that\n\
    \   public log within the Maximum Merge Delay, assuming the log is\n   operating\
    \ correctly.  Thus, the maximum period of time during which a\n   misissued certificate\
    \ can be used without being available for audit\n   is the MMD.\n"
- title: 7.2.  Detection of Misissue
  contents:
  - "7.2.  Detection of Misissue\n   The logs do not themselves detect misissued certificates;\
    \ they rely\n   instead on interested parties, such as domain owners, to monitor\
    \ them\n   and take corrective action when a misissue is detected.\n"
- title: 7.3.  Misbehaving Logs
  contents:
  - "7.3.  Misbehaving Logs\n   A log can misbehave in two ways: (1) by failing to\
    \ incorporate a\n   certificate with an SCT in the Merkle Tree within the MMD\
    \ and (2) by\n   violating its append-only property by presenting two different,\n\
    \   conflicting views of the Merkle Tree at different times and/or to\n   different\
    \ parties.  Both forms of violation will be promptly and\n   publicly detectable.\n\
    \   Violation of the MMD contract is detected by log clients requesting a\n  \
    \ Merkle audit proof for each observed SCT.  These checks can be\n   asynchronous\
    \ and need only be done once per each certificate.  In\n   order to protect the\
    \ clients' privacy, these checks need not reveal\n   the exact certificate to\
    \ the log.  Clients can instead request the\n   proof from a trusted auditor (since\
    \ anyone can compute the audit\n   proofs from the log) or request Merkle proofs\
    \ for a batch of\n   certificates around the SCT timestamp.\n   Violation of the\
    \ append-only property is detected by global\n   gossiping, i.e., everyone auditing\
    \ logs comparing their versions of\n   the latest Signed Tree Heads.  As soon\
    \ as two conflicting Signed Tree\n   Heads for the same log are detected, this\
    \ is cryptographic proof of\n   that log's misbehavior.\n"
- title: 8.  Efficiency Considerations
  contents:
  - "8.  Efficiency Considerations\n   The Merkle Tree design serves the purpose of\
    \ keeping communication\n   overhead low.\n   Auditing logs for integrity does\
    \ not require third parties to\n   maintain a copy of each entire log.  The Signed\
    \ Tree Heads can be\n   updated as new entries become available, without recomputing\
    \ entire\n   trees.  Third-party auditors need only fetch the Merkle consistency\n\
    \   proofs against a log's existing STH to efficiently verify the append-\n  \
    \ only property of updates to their Merkle Trees, without auditing the\n   entire\
    \ tree.\n"
- title: 9.  Future Changes
  contents:
  - "9.  Future Changes\n   This section lists things we might address in a Standards\
    \ Track\n   version of this document.\n   o  Rather than forcing a log operator\
    \ to create a new log in order to\n      change the log signing key, we may allow\
    \ some key roll mechanism.\n   o  We may add hash and signing algorithm agility.\n\
    \   o  We may describe some gossip protocols.\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   The authors would like to thank Erwann Abelea, Robin\
    \ Alden, Al\n   Cutter, Francis Dupont, Stephen Farrell, Brad Hill, Jeff Hodges,\
    \ Paul\n   Hoffman, Jeffrey Hutzelman, SM, Alexey Melnikov, Chris Palmer, Trevor\n\
    \   Perrin, Ryan Sleevi, Rob Stradling, and Carl Wallace for their\n   valuable\
    \ contributions.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative Reference
  contents:
  - "11.1.  Normative Reference\n   [RFC2119]        Bradner, S., \"Key words for\
    \ use in RFCs to Indicate\n                    Requirement Levels\", BCP 14, RFC\
    \ 2119, March 1997.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [CrosbyWallach]  Crosby, S. and D. Wallach,\
    \ \"Efficient Data\n                    Structures for Tamper-Evident Logging\"\
    , Proceedings\n                    of the 18th USENIX Security Symposium, Montreal,\n\
    \                    August 2009, <http://static.usenix.org/event/sec09/\n   \
    \                 tech/full_papers/crosby.pdf>.\n   [DSS]            National\
    \ Institute of Standards and Technology,\n                    \"Digital Signature\
    \ Standard (DSS)\", FIPS 186-3,\n                    June 2009, <http://csrc.nist.gov/publications/fips/\n\
    \                    fips186-3/fips_186-3.pdf>.\n   [FIPS.180-4]     National\
    \ Institute of Standards and Technology,\n                    \"Secure Hash Standard\"\
    , FIPS PUB 180-4, March 2012,\n                    <http://csrc.nist.gov/publications/fips/fips180-4/\n\
    \                    fips-180-4.pdf>.\n   [HTML401]        Raggett, D., Le Hors,\
    \ A., and I. Jacobs, \"HTML 4.01\n                    Specification\", World Wide\
    \ Web Consortium\n                    Recommendation REC-html401-19991224, December\
    \ 1999,\n                    <http://www.w3.org/TR/1999/REC-html401-19991224>.\n\
    \   [RFC2560]        Myers, M., Ankney, R., Malpani, A., Galperin, S.,\n     \
    \               and C. Adams, \"X.509 Internet Public Key\n                  \
    \  Infrastructure Online Certificate Status Protocol -\n                    OCSP\"\
    , RFC 2560, June 1999.\n   [RFC3447]        Jonsson, J. and B. Kaliski, \"Public-Key\
    \ Cryptography\n                    Standards (PKCS) #1: RSA Cryptography Specifications\n\
    \                    Version 2.1\", RFC 3447, February 2003.\n   [RFC4627]   \
    \     Crockford, D., \"The application/json Media Type for\n                 \
    \   JavaScript Object Notation (JSON)\", RFC 4627,\n                    July 2006.\n\
    \   [RFC4648]        Josefsson, S., \"The Base16, Base32, and Base64 Data\n  \
    \                  Encodings\", RFC 4648, October 2006.\n   [RFC5246]        Dierks,\
    \ T. and E. Rescorla, \"The Transport Layer\n                    Security (TLS)\
    \ Protocol Version 1.2\", RFC 5246,\n                    August 2008.\n   [RFC5280]\
    \        Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n               \
    \     Housley, R., and W. Polk, \"Internet X.509 Public Key\n                \
    \    Infrastructure Certificate and Certificate\n                    Revocation\
    \ List (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5905]        Mills, D., Martin,\
    \ J., Burbank, J., and W. Kasch,\n                    \"Network Time Protocol\
    \ Version 4: Protocol and\n                    Algorithms Specification\", RFC\
    \ 5905, June 2010.\n   [RFC6066]        Eastlake, D., \"Transport Layer Security\
    \ (TLS)\n                    Extensions: Extension Definitions\", RFC 6066,\n\
    \                    January 2011.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Ben Laurie\n   Google UK Ltd.\n   EMail: benl@google.com\n\
    \   Adam Langley\n   Google Inc.\n   EMail: agl@google.com\n   Emilia Kasper\n\
    \   Google Switzerland GmbH\n   EMail: ekasper@google.com\n"
