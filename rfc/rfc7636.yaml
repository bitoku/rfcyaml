- title: __initial_text__
  contents:
  - '          Proof Key for Code Exchange by OAuth Public Clients

    '
- title: Abstract
  contents:
  - "Abstract\n   OAuth 2.0 public clients utilizing the Authorization Code Grant\
    \ are\n   susceptible to the authorization code interception attack.  This\n \
    \  specification describes the attack as well as a technique to mitigate\n   against\
    \ the threat through the use of Proof Key for Code Exchange\n   (PKCE, pronounced\
    \ \"pixy\").\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7636.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Protocol Flow ..............................................5\n  \
    \ 2. Notational Conventions ..........................................6\n   3.\
    \ Terminology .....................................................7\n      3.1.\
    \ Abbreviations ..............................................7\n   4. Protocol\
    \ ........................................................8\n      4.1. Client\
    \ Creates a Code Verifier .............................8\n      4.2. Client Creates\
    \ the Code Challenge ..........................8\n      4.3. Client Sends the\
    \ Code Challenge with the\n           Authorization Request ......................................9\n\
    \      4.4. Server Returns the Code ....................................9\n  \
    \         4.4.1. Error Response ......................................9\n    \
    \  4.5. Client Sends the Authorization Code and the Code\n           Verifier\
    \ to the Token Endpoint ............................10\n      4.6. Server Verifies\
    \ code_verifier before Returning the\n           Tokens ....................................................10\n\
    \   5. Compatibility ..................................................11\n  \
    \ 6. IANA Considerations ............................................11\n    \
    \  6.1. OAuth Parameters Registry .................................11\n      6.2.\
    \ PKCE Code Challenge Method Registry .......................11\n           6.2.1.\
    \ Registration Template ..............................12\n           6.2.2. Initial\
    \ Registry Contents ..........................13\n   7. Security Considerations\
    \ ........................................13\n      7.1. Entropy of the code_verifier\
    \ ..............................13\n      7.2. Protection against Eavesdroppers\
    \ ..........................13\n      7.3. Salting the code_challenge ................................14\n\
    \      7.4. OAuth Security Considerations .............................14\n  \
    \    7.5. TLS Security Considerations ...............................15\n   8.\
    \ References .....................................................15\n      8.1.\
    \ Normative References ......................................15\n      8.2. Informative\
    \ References ....................................16\n   Appendix A.  Notes on\
    \ Implementing Base64url Encoding without\n                Padding  .............................................17\n\
    \   Appendix B.  Example for the S256 code_challenge_method ...........17\n  \
    \ Acknowledgements ..................................................19\n   Authors'\
    \ Addresses ................................................20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   OAuth 2.0 [RFC6749] public clients are susceptible to the\n\
    \   authorization code interception attack.\n   In this attack, the attacker intercepts\
    \ the authorization code\n   returned from the authorization endpoint within a\
    \ communication path\n   not protected by Transport Layer Security (TLS), such\
    \ as inter-\n   application communication within the client's operating system.\n\
    \   Once the attacker has gained access to the authorization code, it can\n  \
    \ use it to obtain the access token.\n   Figure 1 shows the attack graphically.\
    \  In step (1), the native\n   application running on the end device, such as\
    \ a smartphone, issues\n   an OAuth 2.0 Authorization Request via the browser/operating\
    \ system.\n   The Redirection Endpoint URI in this case typically uses a custom\
    \ URI\n   scheme.  Step (1) happens through a secure API that cannot be\n   intercepted,\
    \ though it may potentially be observed in advanced attack\n   scenarios.  The\
    \ request then gets forwarded to the OAuth 2.0\n   authorization server in step\
    \ (2).  Because OAuth requires the use of\n   TLS, this communication is protected\
    \ by TLS and cannot be\n   intercepted.  The authorization server returns the\
    \ authorization code\n   in step (3).  In step (4), the Authorization Code is\
    \ returned to the\n   requester via the Redirection Endpoint URI that was provided\
    \ in step\n   (1).\n   Note that it is possible for a malicious app to register\
    \ itself as a\n   handler for the custom scheme in addition to the legitimate\
    \ OAuth 2.0\n   app.  Once it does so, the malicious app is now able to intercept\
    \ the\n   authorization code in step (4).  This allows the attacker to request\n\
    \   and obtain an access token in steps (5) and (6), respectively.\n    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \    | End Device (e.g., Smartphone)  |\n    |                               \
    \ |\n    | +-------------+   +----------+ | (6) Access Token  +----------+\n \
    \   | |Legitimate   |   | Malicious|<--------------------|          |\n    | |OAuth\
    \ 2.0 App|   | App      |-------------------->|          |\n    | +-------------+\
    \   +----------+ | (5) Authorization |          |\n    |        |    ^       \
    \   ^       |        Grant      |          |\n    |        |     \\         |\
    \       |                   |          |\n    |        |      \\   (4)  |    \
    \   |                   |          |\n    |    (1) |       \\  Authz|       |\
    \                   |          |\n    |   Authz|        \\ Code |       |    \
    \               |  Authz   |\n    | Request|         \\     |       |        \
    \           |  Server  |\n    |        |          \\    |       |            \
    \       |          |\n    |        |           \\   |       |                \
    \   |          |\n    |        v            \\  |       |                   |\
    \          |\n    | +----------------------------+ |                   |     \
    \     |\n    | |                            | | (3) Authz Code    |          |\n\
    \    | |     Operating System/      |<--------------------|          |\n    |\
    \ |         Browser            |-------------------->|          |\n    | |   \
    \                         | | (2) Authz Request |          |\n    | +----------------------------+\
    \ |                   +----------+\n    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n \
    \            Figure 1: Authorization Code Interception Attack\n   A number of\
    \ pre-conditions need to hold for this attack to work:\n   1. The attacker manages\
    \ to register a malicious application on the\n      client device and registers\
    \ a custom URI scheme that is also used\n      by another application.  The operating\
    \ systems must allow a custom\n      URI scheme to be registered by multiple applications.\n\
    \   2. The OAuth 2.0 authorization code grant is used.\n   3. The attacker has\
    \ access to the OAuth 2.0 [RFC6749] \"client_id\" and\n      \"client_secret\"\
    \ (if provisioned).  All OAuth 2.0 native app\n      client-instances use the\
    \ same \"client_id\".  Secrets provisioned in\n      client binary applications\
    \ cannot be considered confidential.\n   4. Either one of the following condition\
    \ is met:\n      4a. The attacker (via the installed application) is able to\n\
    \          observe only the responses from the authorization endpoint.\n     \
    \     When \"code_challenge_method\" value is \"plain\", only this\n         \
    \ attack is mitigated.\n      4b. A more sophisticated attack scenario allows\
    \ the attacker to\n          observe requests (in addition to responses) to the\n\
    \          authorization endpoint.  The attacker is, however, not able to\n  \
    \        act as a man in the middle.  This was caused by leaking http\n      \
    \    log information in the OS.  To mitigate this,\n          \"code_challenge_method\"\
    \ value must be set either to \"S256\" or\n          a value defined by a cryptographically\
    \ secure\n          \"code_challenge_method\" extension.\n   While this is a long\
    \ list of pre-conditions, the described attack has\n   been observed in the wild\
    \ and has to be considered in OAuth 2.0\n   deployments.  While the OAuth 2.0\
    \ threat model (Section 4.4.1 of\n   [RFC6819]) describes mitigation techniques,\
    \ they are, unfortunately,\n   not applicable since they rely on a per-client\
    \ instance secret or a\n   per-client instance redirect URI.\n   To mitigate this\
    \ attack, this extension utilizes a dynamically\n   created cryptographically\
    \ random key called \"code verifier\".  A\n   unique code verifier is created\
    \ for every authorization request, and\n   its transformed value, called \"code\
    \ challenge\", is sent to the\n   authorization server to obtain the authorization\
    \ code.  The\n   authorization code obtained is then sent to the token endpoint\
    \ with\n   the \"code verifier\", and the server compares it with the previously\n\
    \   received request code so that it can perform the proof of possession\n   of\
    \ the \"code verifier\" by the client.  This works as the mitigation\n   since\
    \ the attacker would not know this one-time key, since it is sent\n   over TLS\
    \ and cannot be intercepted.\n"
- title: 1.1.  Protocol Flow
  contents:
  - "1.1.  Protocol Flow\n                                                 +-------------------+\n\
    \                                                 |   Authz Server    |\n    \
    \   +--------+                                | +---------------+ |\n       |\
    \        |--(A)- Authorization Request ---->|               | |\n       |    \
    \    |       + t(code_verifier), t_m  | | Authorization | |\n       |        |\
    \                                | |    Endpoint   | |\n       |        |<-(B)----\
    \ Authorization Code -----|               | |\n       |        |             \
    \                   | +---------------+ |\n       | Client |                 \
    \               |                   |\n       |        |                     \
    \           | +---------------+ |\n       |        |--(C)-- Access Token Request\
    \ ---->|               | |\n       |        |          + code_verifier       |\
    \ |    Token      | |\n       |        |                                | |  \
    \ Endpoint    | |\n       |        |<-(D)------ Access Token ---------|      \
    \         | |\n       +--------+                                | +---------------+\
    \ |\n                                                 +-------------------+\n\
    \                     Figure 2: Abstract Protocol Flow\n   This specification\
    \ adds additional parameters to the OAuth 2.0\n   Authorization and Access Token\
    \ Requests, shown in abstract form in\n   Figure 2.\n   A. The client creates\
    \ and records a secret named the \"code_verifier\"\n      and derives a transformed\
    \ version \"t(code_verifier)\" (referred to\n      as the \"code_challenge\"),\
    \ which is sent in the OAuth 2.0\n      Authorization Request along with the transformation\
    \ method \"t_m\".\n   B. The Authorization Endpoint responds as usual but records\n\
    \      \"t(code_verifier)\" and the transformation method.\n   C. The client then\
    \ sends the authorization code in the Access Token\n      Request as usual but\
    \ includes the \"code_verifier\" secret generated\n      at (A).\n   D. The authorization\
    \ server transforms \"code_verifier\" and compares\n      it to \"t(code_verifier)\"\
    \ from (B).  Access is denied if they are\n      not equal.\n   An attacker who\
    \ intercepts the authorization code at (B) is unable to\n   redeem it for an access\
    \ token, as they are not in possession of the\n   \"code_verifier\" secret.\n"
- title: 2.  Notational Conventions
  contents:
  - "2.  Notational Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   \"Key words for use in RFCs to Indicate Requirement Levels\"\
    \ [RFC2119].\n   If these words are used without being spelled in uppercase, then\
    \ they\n   are to be interpreted with their natural language meanings.\n   This\
    \ specification uses the Augmented Backus-Naur Form (ABNF)\n   notation of [RFC5234].\n\
    \   STRING denotes a sequence of zero or more ASCII [RFC20] characters.\n   OCTETS\
    \ denotes a sequence of zero or more octets.\n   ASCII(STRING) denotes the octets\
    \ of the ASCII [RFC20] representation\n   of STRING where STRING is a sequence\
    \ of zero or more ASCII\n   characters.\n   BASE64URL-ENCODE(OCTETS) denotes the\
    \ base64url encoding of OCTETS,\n   per Appendix A, producing a STRING.\n   BASE64URL-DECODE(STRING)\
    \ denotes the base64url decoding of STRING,\n   per Appendix A, producing a sequence\
    \ of octets.\n   SHA256(OCTETS) denotes a SHA2 256-bit hash [RFC6234] of OCTETS.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   In addition to the terms defined in OAuth 2.0 [RFC6749],\
    \ this\n   specification defines the following terms:\n   code verifier\n    \
    \  A cryptographically random string that is used to correlate the\n      authorization\
    \ request to the token request.\n   code challenge\n      A challenge derived\
    \ from the code verifier that is sent in the\n      authorization request, to\
    \ be verified against later.\n   code challenge method\n      A method that was\
    \ used to derive code challenge.\n   Base64url Encoding\n      Base64 encoding\
    \ using the URL- and filename-safe character set\n      defined in Section 5 of\
    \ [RFC4648], with all trailing '='\n      characters omitted (as permitted by\
    \ Section 3.2 of [RFC4648]) and\n      without the inclusion of any line breaks,\
    \ whitespace, or other\n      additional characters.  (See Appendix A for notes\
    \ on implementing\n      base64url encoding without padding.)\n"
- title: 3.1.  Abbreviations
  contents:
  - "3.1.  Abbreviations\n   ABNF   Augmented Backus-Naur Form\n   Authz  Authorization\n\
    \   PKCE   Proof Key for Code Exchange\n   MITM   Man-in-the-middle\n   MTI  \
    \  Mandatory To Implement\n"
- title: 4.  Protocol
  contents:
  - '4.  Protocol

    '
- title: 4.1.  Client Creates a Code Verifier
  contents:
  - "4.1.  Client Creates a Code Verifier\n   The client first creates a code verifier,\
    \ \"code_verifier\", for each\n   OAuth 2.0 [RFC6749] Authorization Request, in\
    \ the following manner:\n   code_verifier = high-entropy cryptographic random\
    \ STRING using the\n   unreserved characters [A-Z] / [a-z] / [0-9] / \"-\" / \"\
    .\" / \"_\" / \"~\"\n   from Section 2.3 of [RFC3986], with a minimum length of\
    \ 43 characters\n   and a maximum length of 128 characters.\n   ABNF for \"code_verifier\"\
    \ is as follows.\n   code-verifier = 43*128unreserved\n   unreserved = ALPHA /\
    \ DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   ALPHA = %x41-5A / %x61-7A\n   DIGIT\
    \ = %x30-39\n   NOTE: The code verifier SHOULD have enough entropy to make it\n\
    \   impractical to guess the value.  It is RECOMMENDED that the output of\n  \
    \ a suitable random number generator be used to create a 32-octet\n   sequence.\
    \  The octet sequence is then base64url-encoded to produce a\n   43-octet URL\
    \ safe string to use as the code verifier.\n"
- title: 4.2.  Client Creates the Code Challenge
  contents:
  - "4.2.  Client Creates the Code Challenge\n   The client then creates a code challenge\
    \ derived from the code\n   verifier by using one of the following transformations\
    \ on the code\n   verifier:\n   plain\n      code_challenge = code_verifier\n\
    \   S256\n      code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))\n\
    \   If the client is capable of using \"S256\", it MUST use \"S256\", as\n   \"\
    S256\" is Mandatory To Implement (MTI) on the server.  Clients are\n   permitted\
    \ to use \"plain\" only if they cannot support \"S256\" for some\n   technical\
    \ reason and know via out-of-band configuration that the\n   server supports \"\
    plain\".\n   The plain transformation is for compatibility with existing\n   deployments\
    \ and for constrained environments that can't use the S256\n   transformation.\n\
    \   ABNF for \"code_challenge\" is as follows.\n   code-challenge = 43*128unreserved\n\
    \   unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   ALPHA = %x41-5A\
    \ / %x61-7A\n   DIGIT = %x30-39\n"
- title: 4.3.  Client Sends the Code Challenge with the Authorization Request
  contents:
  - "4.3.  Client Sends the Code Challenge with the Authorization Request\n   The\
    \ client sends the code challenge as part of the OAuth 2.0\n   Authorization Request\
    \ (Section 4.1.1 of [RFC6749]) using the\n   following additional parameters:\n\
    \   code_challenge\n      REQUIRED.  Code challenge.\n   code_challenge_method\n\
    \      OPTIONAL, defaults to \"plain\" if not present in the request.  Code\n\
    \      verifier transformation method is \"S256\" or \"plain\".\n"
- title: 4.4.  Server Returns the Code
  contents:
  - "4.4.  Server Returns the Code\n   When the server issues the authorization code\
    \ in the authorization\n   response, it MUST associate the \"code_challenge\"\
    \ and\n   \"code_challenge_method\" values with the authorization code so it can\n\
    \   be verified later.\n   Typically, the \"code_challenge\" and \"code_challenge_method\"\
    \ values\n   are stored in encrypted form in the \"code\" itself but could\n \
    \  alternatively be stored on the server associated with the code.  The\n   server\
    \ MUST NOT include the \"code_challenge\" value in client requests\n   in a form\
    \ that other entities can extract.\n   The exact method that the server uses to\
    \ associate the\n   \"code_challenge\" with the issued \"code\" is out of scope\
    \ for this\n   specification.\n"
- title: 4.4.1.  Error Response
  contents:
  - "4.4.1.  Error Response\n   If the server requires Proof Key for Code Exchange\
    \ (PKCE) by OAuth\n   public clients and the client does not send the \"code_challenge\"\
    \ in\n   the request, the authorization endpoint MUST return the authorization\n\
    \   error response with the \"error\" value set to \"invalid_request\".  The\n\
    \   \"error_description\" or the response of \"error_uri\" SHOULD explain the\n\
    \   nature of error, e.g., code challenge required.\n   If the server supporting\
    \ PKCE does not support the requested\n   transformation, the authorization endpoint\
    \ MUST return the\n   authorization error response with \"error\" value set to\n\
    \   \"invalid_request\".  The \"error_description\" or the response of\n   \"\
    error_uri\" SHOULD explain the nature of error, e.g., transform\n   algorithm\
    \ not supported.\n"
- title: 4.5.  Client Sends the Authorization Code and the Code Verifier to the
  contents:
  - "4.5.  Client Sends the Authorization Code and the Code Verifier to the\n    \
    \  Token Endpoint\n   Upon receipt of the Authorization Code, the client sends\
    \ the Access\n   Token Request to the token endpoint.  In addition to the parameters\n\
    \   defined in the OAuth 2.0 Access Token Request (Section 4.1.3 of\n   [RFC6749]),\
    \ it sends the following parameter:\n   code_verifier\n      REQUIRED.  Code verifier\n\
    \   The \"code_challenge_method\" is bound to the Authorization Code when\n  \
    \ the Authorization Code is issued.  That is the method that the token\n   endpoint\
    \ MUST use to verify the \"code_verifier\".\n"
- title: 4.6.  Server Verifies code_verifier before Returning the Tokens
  contents:
  - "4.6.  Server Verifies code_verifier before Returning the Tokens\n   Upon receipt\
    \ of the request at the token endpoint, the server\n   verifies it by calculating\
    \ the code challenge from the received\n   \"code_verifier\" and comparing it\
    \ with the previously associated\n   \"code_challenge\", after first transforming\
    \ it according to the\n   \"code_challenge_method\" method specified by the client.\n\
    \   If the \"code_challenge_method\" from Section 4.3 was \"S256\", the\n   received\
    \ \"code_verifier\" is hashed by SHA-256, base64url-encoded, and\n   then compared\
    \ to the \"code_challenge\", i.e.:\n   BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))\
    \ == code_challenge\n   If the \"code_challenge_method\" from Section 4.3 was\
    \ \"plain\", they are\n   compared directly, i.e.:\n   code_verifier == code_challenge.\n\
    \   If the values are equal, the token endpoint MUST continue processing\n   as\
    \ normal (as defined by OAuth 2.0 [RFC6749]).  If the values are not\n   equal,\
    \ an error response indicating \"invalid_grant\" as described in\n   Section 5.2\
    \ of [RFC6749] MUST be returned.\n"
- title: 5.  Compatibility
  contents:
  - "5.  Compatibility\n   Server implementations of this specification MAY accept\
    \ OAuth2.0\n   clients that do not implement this extension.  If the \"code_verifier\"\
    \n   is not received from the client in the Authorization Request, servers\n \
    \  supporting backwards compatibility revert to the OAuth 2.0 [RFC6749]\n   protocol\
    \ without this extension.\n   As the OAuth 2.0 [RFC6749] server responses are\
    \ unchanged by this\n   specification, client implementations of this specification\
    \ do not\n   need to know if the server has implemented this specification or\
    \ not\n   and SHOULD send the additional parameters as defined in Section 4 to\n\
    \   all servers.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   IANA has made the following registrations per this\
    \ document.\n"
- title: 6.1.  OAuth Parameters Registry
  contents:
  - "6.1.  OAuth Parameters Registry\n   This specification registers the following\
    \ parameters in the IANA\n   \"OAuth Parameters\" registry defined in OAuth 2.0\
    \ [RFC6749].\n   o  Parameter name: code_verifier\n   o  Parameter usage location:\
    \ token request\n   o  Change controller: IESG\n   o  Specification document(s):\
    \ RFC 7636 (this document)\n   o  Parameter name: code_challenge\n   o  Parameter\
    \ usage location: authorization request\n   o  Change controller: IESG\n   o \
    \ Specification document(s): RFC 7636 (this document)\n   o  Parameter name: code_challenge_method\n\
    \   o  Parameter usage location: authorization request\n   o  Change controller:\
    \ IESG\n   o  Specification document(s): RFC 7636 (this document)\n"
- title: 6.2.  PKCE Code Challenge Method Registry
  contents:
  - "6.2.  PKCE Code Challenge Method Registry\n   This specification establishes\
    \ the \"PKCE Code Challenge Methods\"\n   registry.  The new registry should be\
    \ a sub-registry of the \"OAuth\n   Parameters\" registry.\n   Additional \"code_challenge_method\"\
    \ types for use with the\n   authorization endpoint are registered using the Specification\n\
    \   Required policy [RFC5226], which includes review of the request by\n   one\
    \ or more Designated Experts (DEs).  The DEs will ensure that there\n   is at\
    \ least a two-week review of the request on the oauth-ext-\n   review@ietf.org\
    \ mailing list and that any discussion on that list\n   converges before they\
    \ respond to the request.  To allow for the\n   allocation of values prior to\
    \ publication, the Designated Expert(s)\n   may approve registration once they\
    \ are satisfied that an acceptable\n   specification will be published.\n   Registration\
    \ requests and discussion on the oauth-ext-review@ietf.org\n   mailing list should\
    \ use an appropriate subject, such as \"Request for\n   PKCE code_challenge_method:\
    \ example\").\n   The Designated Expert(s) should consider the discussion on the\n\
    \   mailing list, as well as the overall security properties of the\n   challenge\
    \ method when evaluating registration requests.  New methods\n   should not disclose\
    \ the value of the code_verifier in the request to\n   the Authorization endpoint.\
    \  Denials should include an explanation\n   and, if applicable, suggestions as\
    \ to how to make the request\n   successful.\n"
- title: 6.2.1.  Registration Template
  contents:
  - "6.2.1.  Registration Template\n   Code Challenge Method Parameter Name:\n   \
    \   The name requested (e.g., \"example\").  Because a core goal of this\n   \
    \   specification is for the resulting representations to be compact,\n      it\
    \ is RECOMMENDED that the name be short -- not to exceed 8\n      characters without\
    \ a compelling reason to do so.  This name is\n      case-sensitive.  Names may\
    \ not match other registered names in a\n      case-insensitive manner unless\
    \ the Designated Expert(s) states\n      that there is a compelling reason to\
    \ allow an exception in this\n      particular case.\n   Change Controller:\n\
    \      For Standards Track RFCs, state \"IESG\".  For others, give the name\n\
    \      of the responsible party.  Other details (e.g., postal address,\n     \
    \ email address, and home page URI) may also be included.\n   Specification Document(s):\n\
    \      Reference to the document(s) that specifies the parameter,\n      preferably\
    \ including URI(s) that can be used to retrieve copies of\n      the document(s).\
    \  An indication of the relevant sections may also\n      be included but is not\
    \ required.\n"
- title: 6.2.2.  Initial Registry Contents
  contents:
  - "6.2.2.  Initial Registry Contents\n   Per this document, IANA has registered\
    \ the Code Challenge Method\n   Parameter Names defined in Section 4.2 in this\
    \ registry.\n   o  Code Challenge Method Parameter Name: plain\n   o  Change Controller:\
    \ IESG\n   o  Specification Document(s): Section 4.2 of RFC 7636 (this document)\n\
    \   o  Code Challenge Method Parameter Name: S256\n   o  Change Controller: IESG\n\
    \   o  Specification Document(s): Section 4.2 of RFC 7636 (this document)\n"
- title: 7.  Security Considerations
  contents:
  - '7.  Security Considerations

    '
- title: 7.1.  Entropy of the code_verifier
  contents:
  - "7.1.  Entropy of the code_verifier\n   The security model relies on the fact\
    \ that the code verifier is not\n   learned or guessed by the attacker.  It is\
    \ vitally important to\n   adhere to this principle.  As such, the code verifier\
    \ has to be\n   created in such a manner that it is cryptographically random and\
    \ has\n   high entropy that it is not practical for the attacker to guess.\n \
    \  The client SHOULD create a \"code_verifier\" with a minimum of 256 bits\n \
    \  of entropy.  This can be done by having a suitable random number\n   generator\
    \ create a 32-octet sequence.  The octet sequence can then be\n   base64url-encoded\
    \ to produce a 43-octet URL safe string to use as a\n   \"code_challenge\" that\
    \ has the required entropy.\n"
- title: 7.2.  Protection against Eavesdroppers
  contents:
  - "7.2.  Protection against Eavesdroppers\n   Clients MUST NOT downgrade to \"plain\"\
    \ after trying the \"S256\" method.\n   Servers that support PKCE are required\
    \ to support \"S256\", and servers\n   that do not support PKCE will simply ignore\
    \ the unknown\n   \"code_verifier\".  Because of this, an error when \"S256\"\
    \ is presented\n   can only mean that the server is faulty or that a MITM attacker\
    \ is\n   trying a downgrade attack.\n   The \"S256\" method protects against eavesdroppers\
    \ observing or\n   intercepting the \"code_challenge\", because the challenge\
    \ cannot be\n   used without the verifier.  With the \"plain\" method, there is\
    \ a\n   chance that \"code_challenge\" will be observed by the attacker on the\n\
    \   device or in the http request.  Since the code challenge is the same\n   as\
    \ the code verifier in this case, the \"plain\" method does not\n   protect against\
    \ the eavesdropping of the initial request.\n   The use of \"S256\" protects against\
    \ disclosure of the \"code_verifier\"\n   value to an attacker.\n   Because of\
    \ this, \"plain\" SHOULD NOT be used and exists only for\n   compatibility with\
    \ deployed implementations where the request path is\n   already protected.  The\
    \ \"plain\" method SHOULD NOT be used in new\n   implementations, unless they\
    \ cannot support \"S256\" for some technical\n   reason.\n   The \"S256\" code\
    \ challenge method or other cryptographically secure\n   code challenge method\
    \ extension SHOULD be used.  The \"plain\" code\n   challenge method relies on\
    \ the operating system and transport\n   security not to disclose the request\
    \ to an attacker.\n   If the code challenge method is \"plain\" and the code challenge\
    \ is to\n   be returned inside authorization \"code\" to achieve a stateless\n\
    \   server, it MUST be encrypted in such a manner that only the server\n   can\
    \ decrypt and extract it.\n"
- title: 7.3.  Salting the code_challenge
  contents:
  - "7.3.  Salting the code_challenge\n   To reduce implementation complexity, salting\
    \ is not used in the\n   production of the code challenge, as the code verifier\
    \ contains\n   sufficient entropy to prevent brute-force attacks.  Concatenating\
    \ a\n   publicly known value to a code verifier (containing 256 bits of\n   entropy)\
    \ and then hashing it with SHA256 to produce a code challenge\n   would not increase\
    \ the number of attempts necessary to brute force a\n   valid value for code verifier.\n\
    \   While the \"S256\" transformation is like hashing a password, there are\n\
    \   important differences.  Passwords tend to be relatively low-entropy\n   words\
    \ that can be hashed offline and the hash looked up in a\n   dictionary.  By concatenating\
    \ a unique though public value to each\n   password prior to hashing, the dictionary\
    \ space that an attacker\n   needs to search is greatly expanded.\n   Modern graphics\
    \ processors now allow attackers to calculate hashes in\n   real time faster than\
    \ they could be looked up from a disk.  This\n   eliminates the value of the salt\
    \ in increasing the complexity of a\n   brute-force attack for even low-entropy\
    \ passwords.\n"
- title: 7.4.  OAuth Security Considerations
  contents:
  - "7.4.  OAuth Security Considerations\n   All the OAuth security analysis presented\
    \ in [RFC6819] applies, so\n   readers SHOULD carefully follow it.\n"
- title: 7.5.  TLS Security Considerations
  contents:
  - "7.5.  TLS Security Considerations\n   Current security considerations can be\
    \ found in \"Recommendations for\n   Secure Use of Transport Layer Security (TLS)\
    \ and Datagram Transport\n   Layer Security (DTLS)\" [BCP195].  This supersedes\
    \ the TLS version\n   recommendations in OAuth 2.0 [RFC6749].\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [BCP195]   Sheffer, Y., Holz, R., and P. Saint-Andre,\n\
    \              \"Recommendations for Secure Use of Transport Layer\n         \
    \     Security (TLS) and Datagram Transport Layer Security\n              (DTLS)\"\
    , BCP 195, RFC 7525, May 2015,\n              <http://www.rfc-editor.org/info/bcp195>.\n\
    \   [RFC20]    Cerf, V., \"ASCII format for network interchange\", STD 80,\n \
    \             RFC 20, DOI 10.17487/RFC0020, October 1969,\n              <http://www.rfc-editor.org/info/rfc20>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3986]\
    \  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource\
    \ Identifier (URI): Generic Syntax\", STD 66, RFC\n              3986, DOI 10.17487/RFC3986,\
    \ January 2005,\n              <http://www.rfc-editor.org/info/rfc3986>.\n   [RFC4648]\
    \  Josefsson, S., \"The Base16, Base32, and Base64 Data\n              Encodings\"\
    , RFC 4648, DOI 10.17487/RFC4648, October 2006,\n              <http://www.rfc-editor.org/info/rfc4648>.\n\
    \   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n   \
    \           IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n       \
    \       DOI 10.17487/RFC5226, May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n\
    \   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n \
    \             Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,\
    \ January 2008,\n              <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC6234]\
    \  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n             \
    \ (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n              DOI 10.17487/RFC6234,\
    \ May 2011,\n              <http://www.rfc-editor.org/info/rfc6234>.\n   [RFC6749]\
    \  Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\",\n              RFC\
    \ 6749, DOI 10.17487/RFC6749, October 2012,\n              <http://www.rfc-editor.org/info/rfc6749>.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [RFC6819]  Lodderstedt, T., Ed., McGloin, M.,\
    \ and P. Hunt, \"OAuth 2.0\n              Threat Model and Security Considerations\"\
    , RFC 6819,\n              DOI 10.17487/RFC6819, January 2013,\n             \
    \ <http://www.rfc-editor.org/info/rfc6819>.\n"
- title: Appendix A.  Notes on Implementing Base64url Encoding without Padding
  contents:
  - "Appendix A.  Notes on Implementing Base64url Encoding without Padding\n   This\
    \ appendix describes how to implement a base64url-encoding\n   function without\
    \ padding, based upon the standard base64-encoding\n   function that uses padding.\n\
    \   To be concrete, example C# code implementing these functions is shown\n  \
    \ below.  Similar code could be used in other languages.\n     static string base64urlencode(byte\
    \ [] arg)\n     {\n       string s = Convert.ToBase64String(arg); // Regular base64\
    \ encoder\n       s = s.Split('=')[0]; // Remove any trailing '='s\n       s =\
    \ s.Replace('+', '-'); // 62nd char of encoding\n       s = s.Replace('/', '_');\
    \ // 63rd char of encoding\n       return s;\n     }\n   An example correspondence\
    \ between unencoded and encoded values\n   follows.  The octet sequence below\
    \ encodes into the string below,\n   which when decoded, reproduces the octet\
    \ sequence.\n   3 236 255 224 193\n   A-z_4ME\n"
- title: Appendix B.  Example for the S256 code_challenge_method
  contents:
  - "Appendix B.  Example for the S256 code_challenge_method\n   The client uses output\
    \ of a suitable random number generator to\n   create a 32-octet sequence.  The\
    \ octets representing the value in\n   this example (using JSON array notation)\
    \ are:\n      [116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173,\n\
    \      187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83,\n   \
    \   132, 141, 121]\n   Encoding this octet sequence as base64url provides the\
    \ value of the\n   code_verifier:\n       dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n\
    \   The code_verifier is then hashed via the SHA256 hash function to\n   produce:\n\
    \     [19, 211, 30, 150, 26, 26, 216, 236, 47, 22, 177, 12, 76, 152, 46,\n   \
    \   8, 118, 168, 120, 173, 109, 241, 68, 86, 110, 225, 137, 74, 203,\n      112,\
    \ 249, 195]\n   Encoding this octet sequence as base64url provides the value of\
    \ the\n   code_challenge:\n       E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM\n\
    \   The authorization request includes:\n       code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM\n\
    \       &code_challenge_method=S256\n   The authorization server then records\
    \ the code_challenge and\n   code_challenge_method along with the code that is\
    \ granted to the\n   client.\n   In the request to the token_endpoint, the client\
    \ includes the code\n   received in the authorization response as well as the\
    \ additional\n   parameter:\n       code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n\
    \   The authorization server retrieves the information for the code\n   grant.\
    \  Based on the recorded code_challenge_method being S256, it\n   then hashes\
    \ and base64url-encodes the value of code_verifier:\n   BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))\n\
    \   The calculated value is then compared with the value of\n   \"code_challenge\"\
    :\n   BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) == code_challenge\n   If\
    \ the two values are equal, then the authorization server can\n   provide the\
    \ tokens as long as there are no other errors in the\n   request.  If the values\
    \ are not equal, then the request must be\n   rejected, and an error returned.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The initial draft version of this specification was created\
    \ by the\n   OpenID AB/Connect Working Group of the OpenID Foundation.\n   This\
    \ specification is the work of the OAuth Working Group, which\n   includes dozens\
    \ of active and dedicated participants.  In particular,\n   the following individuals\
    \ contributed ideas, feedback, and wording\n   that shaped and formed the final\
    \ specification:\n      Anthony Nadalin, Microsoft\n      Axel Nenker, Deutsche\
    \ Telekom\n      Breno de Medeiros, Google\n      Brian Campbell, Ping Identity\n\
    \      Chuck Mortimore, Salesforce\n      Dirk Balfanz, Google\n      Eduardo\
    \ Gueiros, Jive Communications\n      Hannes Tschonfenig, ARM\n      James Manger,\
    \ Telstra\n      Justin Richer, MIT Kerberos\n      Josh Mandel, Boston Children's\
    \ Hospital\n      Lewis Adam, Motorola Solutions\n      Madjid Nakhjiri, Samsung\n\
    \      Michael B. Jones, Microsoft\n      Paul Madsen, Ping Identity\n      Phil\
    \ Hunt, Oracle\n      Prateek Mishra, Oracle\n      Ryo Ito, mixi\n      Scott\
    \ Tomilson, Ping Identity\n      Sergey Beryozkin\n      Takamichi Saito\n   \
    \   Torsten Lodderstedt, Deutsche Telekom\n      William Denniss, Google\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Nat Sakimura (editor)\n   Nomura Research Institute\n\
    \   1-6-5 Marunouchi, Marunouchi Kitaguchi Bldg.\n   Chiyoda-ku, Tokyo  100-0005\n\
    \   Japan\n   Phone: +81-3-5533-2111\n   Email: n-sakimura@nri.co.jp\n   URI:\
    \   http://nat.sakimura.org/\n   John Bradley\n   Ping Identity\n   Casilla 177,\
    \ Sucursal Talagante\n   Talagante, RM\n   Chile\n   Phone: +44 20 8133 3718\n\
    \   Email: ve7jtb@ve7jtb.com\n   URI:   http://www.thread-safe.com/\n   Naveen\
    \ Agarwal\n   Google\n   1600 Amphitheatre Parkway\n   Mountain View, CA  94043\n\
    \   United States\n   Phone: +1 650-253-0000\n   Email: naa@google.com\n   URI:\
    \   http://google.com/\n"
