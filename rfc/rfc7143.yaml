- contents:
  - "       Internet Small Computer System Interface (iSCSI) Protocol\n                             (Consolidated)\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes a transport protocol for SCSI that works
    on\n   top of TCP.  The iSCSI protocol aims to be fully compliant with the\n   standardized
    SCSI Architecture Model (SAM-2).  RFC 3720 defined the\n   original iSCSI protocol.
    \ RFC 3721 discusses iSCSI naming examples\n   and discovery techniques.  Subsequently,
    RFC 3980 added an additional\n   naming format to the iSCSI protocol.  RFC 4850
    followed up by adding\n   a new public extension key to iSCSI.  RFC 5048 offered
    a number of\n   clarifications as well as a few improvements and corrections to
    the\n   original iSCSI protocol.\n   This document obsoletes RFCs 3720, 3980,
    4850, and 5048 by\n   consolidating them into a single document and making additional\n
    \  updates to the consolidated specification.  This document also\n   updates
    RFC 3721.  The text in this document thus supersedes the text\n   in all the noted
    RFCs wherever there is a difference in semantics.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7143.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ...................................................11\n
    \  2. Acronyms, Definitions, and Document Summary ....................11\n      2.1.
    Acronyms ..................................................11\n      2.2. Definitions
    ...............................................13\n      2.3. Summary of Changes
    ........................................19\n      2.4. Conventions ...............................................20\n
    \  3. UML Conventions ................................................20\n      3.1.
    UML Conventions Overview ..................................20\n      3.2. Multiplicity
    Notion .......................................21\n      3.3. Class Diagram Conventions
    .................................22\n      3.4. Class Diagram Notation for Associations
    ...................23\n      3.5. Class Diagram Notation for Aggregations ...................24\n
    \     3.6. Class Diagram Notation for Generalizations ................25\n   4.
    Overview .......................................................25\n      4.1.
    SCSI Concepts .............................................25\n      4.2. iSCSI
    Concepts and Functional Overview ....................26\n           4.2.1. Layers
    and Sessions ................................27\n           4.2.2. Ordering and
    iSCSI Numbering .......................28\n                  4.2.2.1. Command
    Numbering and Acknowledging .......28\n                  4.2.2.2. Response/Status
    Numbering and\n                           Acknowledging .............................32\n
    \                 4.2.2.3. Response Ordering .........................32\n                           4.2.2.3.1.
    Need for Response Ordering .....32\n                           4.2.2.3.2. Response
    Ordering Model\n                                      Description ....................33\n
    \                          4.2.2.3.3. iSCSI Semantics with\n                                      the
    Interface Model ............33\n                           4.2.2.3.4. Current
    List of Fenced\n                                      Response Use Cases .............34\n
    \                 4.2.2.4. Data Sequencing ...........................35\n           4.2.3.
    iSCSI Task Management ..............................36\n                  4.2.3.1.
    Task Management Overview ..................36\n                  4.2.3.2. Notion
    of Affected Tasks ..................36\n                  4.2.3.3. Standard Multi-Task
    Abort Semantics .......37\n                  4.2.3.4. FastAbort Multi-Task Abort
    Semantics ......38\n                  4.2.3.5. Affected Tasks Shared across\n
    \                          Standard and FastAbort Sessions ...........40\n                  4.2.3.6.
    Rationale behind the FastAbort Semantics ..41\n           4.2.4. iSCSI Login ........................................42\n
    \          4.2.5. iSCSI Full Feature Phase ...........................44\n                  4.2.5.1.
    Command Connection Allegiance .............44\n                  4.2.5.2. Data
    Transfer Overview ....................45\n                  4.2.5.3. Tags and
    Integrity Checks .................46\n                  4.2.5.4. SCSI Task Management
    during iSCSI\n                           Full Feature Phase ........................47\n
    \          4.2.6. iSCSI Connection Termination .......................47\n           4.2.7.
    iSCSI Names ........................................47\n                  4.2.7.1.
    iSCSI Name Properties .....................48\n                  4.2.7.2. iSCSI
    Name Encoding .......................50\n                  4.2.7.3. iSCSI Name
    Structure ......................51\n                  4.2.7.4. Type \"iqn.\" (iSCSI
    Qualified Name) ........52\n                  4.2.7.5. Type \"eui.\" (IEEE EUI-64
    Format) ..........53\n                  4.2.7.6. Type \"naa.\" (Network Address
    Authority) ...54\n           4.2.8. Persistent State ...................................55\n
    \          4.2.9. Message Synchronization and Steering ...............55\n                  4.2.9.1.
    Sync/Steering and iSCSI PDU Length ........56\n      4.3. iSCSI Session Types
    .......................................56\n      4.4. SCSI-to-iSCSI Concepts Mapping
    Model ......................57\n           4.4.1. iSCSI Architecture Model ...........................58\n
    \          4.4.2. SCSI Architecture Model ............................59\n           4.4.3.
    Consequences of the Model ..........................61\n                  4.4.3.1.
    I_T Nexus State ...........................62\n                  4.4.3.2. Reservations
    ..............................63\n      4.5. iSCSI UML Model ...........................................64\n
    \     4.6. Request/Response Summary ..................................66\n           4.6.1.
    Request/Response Types Carrying SCSI Payload .......66\n                  4.6.1.1.
    SCSI Command ..............................66\n                  4.6.1.2. SCSI
    Response .............................66\n                  4.6.1.3. Task Management
    Function Request ..........67\n                  4.6.1.4. Task Management Function
    Response .........68\n                  4.6.1.5. SCSI Data-Out and SCSI Data-In
    ............68\n                  4.6.1.6. Ready To Transfer (R2T) ...................69\n
    \          4.6.2. Requests/Responses Carrying SCSI and iSCSI\n                  Payload
    ............................................69\n                  4.6.2.1. Asynchronous
    Message ......................69\n           4.6.3. Requests/Responses Carrying
    iSCSI-Only Payload .....69\n                  4.6.3.1. Text Requests and Text
    Responses ..........69\n                  4.6.3.2. Login Requests and Login Responses
    ........70\n                  4.6.3.3. Logout Requests and Logout Responses ......71\n
    \                 4.6.3.4. SNACK Request .............................71\n                  4.6.3.5.
    Reject ....................................71\n                  4.6.3.6. NOP-Out
    Request and NOP-In Response .......71\n   5. SCSI Mode Parameters for iSCSI .................................72\n
    \  6. Login and Full Feature Phase Negotiation .......................72\n      6.1.
    Text Format ...............................................73\n      6.2. Text
    Mode Negotiation .....................................76\n           6.2.1. List
    Negotiations ..................................80\n           6.2.2. Simple-Value
    Negotiations ..........................80\n      6.3. Login Phase ...............................................81\n
    \          6.3.1. Login Phase Start ..................................84\n           6.3.2.
    iSCSI Security Negotiation .........................87\n           6.3.3. Operational
    Parameter Negotiation during\n                  the Login Phase ....................................87\n
    \          6.3.4. Connection Reinstatement ...........................88\n           6.3.5.
    Session Reinstatement, Closure, and Timeout ........89\n                  6.3.5.1.
    Loss of Nexus Notification ................90\n           6.3.6. Session Continuation
    and Failure ...................90\n      6.4. Operational Parameter Negotiation
    outside the\n           Login Phase ...............................................90\n
    \  7. iSCSI Error Handling and Recovery ..............................92\n      7.1.
    Overview ..................................................92\n           7.1.1.
    Background .........................................92\n           7.1.2. Goals
    ..............................................92\n           7.1.3. Protocol Features
    and State Expectations ...........93\n           7.1.4. Recovery Classes ...................................94\n
    \                 7.1.4.1. Recovery Within-command ...................95\n                  7.1.4.2.
    Recovery Within-connection ................96\n                  7.1.4.3. Connection
    Recovery .......................96\n                  7.1.4.4. Session Recovery
    ..........................97\n           7.1.5. Error Recovery Hierarchy ...........................97\n
    \     7.2. Retry and Reassign in Recovery ............................99\n           7.2.1.
    Usage of Retry .....................................99\n           7.2.2. Allegiance
    Reassignment ...........................100\n      7.3. Usage of Reject PDU in
    Recovery ..........................101\n      7.4. Error Recovery Considerations
    for Discovery Sessions .....102\n           7.4.1. ErrorRecoveryLevel for Discovery
    Sessions .........102\n           7.4.2. Reinstatement Semantics for Discovery
    Sessions ....102\n                  7.4.2.1. Unnamed Discovery Sessions ...............103\n
    \                 7.4.2.2. Named Discovery Sessions .................103\n           7.4.3.
    Target PDUs during Discovery ......................103\n      7.5. Connection
    Timeout Management ............................104\n           7.5.1. Timeouts
    on Transport Exception Events ............104\n           7.5.2. Timeouts on Planned
    Decommissioning ...............104\n      7.6. Implicit Termination of Tasks ............................104\n
    \     7.7. Format Errors ............................................105\n      7.8.
    Digest Errors ............................................106\n      7.9. Sequence
    Errors ..........................................107\n      7.10. Message Error
    Checking ..................................108\n      7.11. SCSI Timeouts ...........................................108\n
    \     7.12. Negotiation Failures ....................................109\n      7.13.
    Protocol Errors .........................................110\n      7.14. Connection
    Failures .....................................110\n      7.15. Session Errors
    ..........................................111\n   8. State Transitions .............................................112\n
    \     8.1. Standard Connection State Diagrams .......................112\n           8.1.1.
    State Descriptions for Initiators and Targets .....112\n           8.1.2. State
    Transition Descriptions for\n                  Initiators and Targets ............................114\n
    \          8.1.3. Standard Connection State Diagram for an\n                  Initiator
    .........................................118\n           8.1.4. Standard Connection
    State Diagram for a Target ....120\n      8.2. Connection Cleanup State Diagram
    for Initiators\n           and Targets ..............................................122\n
    \          8.2.1. State Descriptions for Initiators and Targets .....124\n           8.2.2.
    State Transition Descriptions for\n                  Initiators and Targets ............................124\n
    \     8.3. Session State Diagrams ...................................126\n           8.3.1.
    Session State Diagram for an Initiator ............126\n           8.3.2. Session
    State Diagram for a Target ................127\n           8.3.3. State Descriptions
    for Initiators and Targets .....129\n           8.3.4. State Transition Descriptions
    for\n                  Initiators and Targets ............................129\n
    \  9. Security Considerations .......................................131\n      9.1.
    iSCSI Security Mechanisms ................................132\n      9.2. In-Band
    Initiator-Target Authentication ..................132\n           9.2.1. CHAP
    Considerations ...............................134\n           9.2.2. SRP Considerations
    ................................136\n           9.2.3. Kerberos Considerations
    ...........................136\n      9.3. IPsec ....................................................137\n
    \          9.3.1. Data Authentication and Integrity .................137\n           9.3.2.
    Confidentiality ...................................138\n           9.3.3. Policy,
    Security Associations, and\n                  Cryptographic Key Management ......................139\n
    \     9.4. Security Considerations for the X#NodeArchitecture Key ...141\n      9.5.
    SCSI Access Control Considerations .......................143\n   10. Notes to
    Implementers ........................................143\n      10.1. Multiple
    Network Adapters ...............................143\n           10.1.1. Conservative
    Reuse of ISIDs ......................143\n           10.1.2. iSCSI Name, ISID,
    and TPGT Use ...................144\n      10.2. Autosense and Auto Contingent
    Allegiance (ACA) ..........146\n      10.3. iSCSI Timeouts ..........................................146\n
    \     10.4. Command Retry and Cleaning Old Command Instances ........147\n      10.5.
    Sync and Steering Layer, and Performance ................147\n      10.6. Considerations
    for State-Dependent Devices and\n            Long-Lasting SCSI Operations ............................147\n
    \          10.6.1. Determining the Proper ErrorRecoveryLevel ........148\n      10.7.
    Multi-Task Abort Implementation Considerations ..........149\n   11. iSCSI PDU
    Formats ............................................150\n      11.1. iSCSI PDU
    Length and Padding ............................150\n      11.2. PDU Template,
    Header, and Opcodes .......................150\n           11.2.1. Basic Header
    Segment (BHS) .......................152\n                  11.2.1.1. I (Immediate)
    Bit .......................152\n                  11.2.1.2. Opcode ..................................152\n
    \                 11.2.1.3. F (Final) Bit ...........................154\n                  11.2.1.4.
    Opcode-Specific Fields ..................154\n                  11.2.1.5. TotalAHSLength
    ..........................154\n                  11.2.1.6. DataSegmentLength .......................154\n
    \                 11.2.1.7. LUN .....................................154\n                  11.2.1.8.
    Initiator Task Tag ......................154\n           11.2.2. Additional Header
    Segment (AHS) ..................155\n                  11.2.2.1. AHSType .................................155\n
    \                 11.2.2.2. AHSLength ...............................155\n                  11.2.2.3.
    Extended CDB AHS ........................156\n                  11.2.2.4. Bidirectional
    Read Expected Data\n                            Transfer Length AHS .....................156\n
    \          11.2.3. Header Digest and Data Digest ....................156\n           11.2.4.
    Data Segment .....................................157\n      11.3. SCSI Command
    ............................................158\n           11.3.1. Flags and
    Task Attributes (Byte 1) ...............159\n           11.3.2. CmdSN - Command
    Sequence Number ..................159\n           11.3.3. ExpStatSN ........................................160\n
    \          11.3.4. Expected Data Transfer Length ....................160\n           11.3.5.
    CDB - SCSI Command Descriptor Block ..............160\n           11.3.6. Data
    Segment - Command Data ......................161\n      11.4. SCSI Response ...........................................161\n
    \          11.4.1. Flags (Byte 1) ...................................162\n           11.4.2.
    Status ...........................................163\n           11.4.3. Response
    .........................................163\n           11.4.4. SNACK Tag ........................................164\n
    \          11.4.5. Residual Count ...................................164\n                  11.4.5.1.
    Field Semantics .........................164\n                  11.4.5.2. Residuals
    Concepts Overview .............164\n                  11.4.5.3. SCSI REPORT LUNS
    Command and\n                            Residual Overflow .......................165\n
    \          11.4.6. Bidirectional Read Residual Count ................166\n           11.4.7.
    Data Segment - Sense and Response Data Segment ...167\n                  11.4.7.1.
    SenseLength .............................167\n                  11.4.7.2. Sense
    Data ..............................168\n           11.4.8. ExpDataSN ........................................168\n
    \          11.4.9. StatSN - Status Sequence Number ..................168\n           11.4.10.
    ExpCmdSN - Next Expected CmdSN from This\n                    Initiator .......................................169\n
    \          11.4.11. MaxCmdSN - Maximum CmdSN from This Initiator ....169\n      11.5.
    Task Management Function Request ........................170\n           11.5.1.
    Function .........................................170\n           11.5.2. TotalAHSLength
    and DataSegmentLength .............173\n           11.5.3. LUN ..............................................173\n
    \          11.5.4. Referenced Task Tag ..............................173\n           11.5.5.
    RefCmdSN .........................................174\n           11.5.6. ExpDataSN
    ........................................174\n      11.6. Task Management Function
    Response .......................175\n           11.6.1. Response .........................................176\n
    \          11.6.2. TotalAHSLength and DataSegmentLength .............177\n      11.7.
    SCSI Data-Out and SCSI Data-In ..........................178\n           11.7.1.
    F (Final) Bit ....................................180\n           11.7.2. A (Acknowledge)
    Bit ..............................180\n           11.7.3. Flags (Byte 1) ...................................181\n
    \          11.7.4. Target Transfer Tag and LUN ......................181\n           11.7.5.
    DataSN ...........................................182\n           11.7.6. Buffer
    Offset ....................................182\n           11.7.7. DataSegmentLength
    ................................182\n      11.8. Ready To Transfer (R2T) .................................183\n
    \          11.8.1. TotalAHSLength and DataSegmentLength .............184\n           11.8.2.
    R2TSN ............................................184\n           11.8.3. StatSN
    ...........................................185\n           11.8.4. Desired Data
    Transfer Length and Buffer Offset ...185\n           11.8.5. Target Transfer Tag
    ..............................185\n      11.9. Asynchronous Message ....................................186\n
    \          11.9.1. AsyncEvent .......................................187\n           11.9.2.
    AsyncVCode .......................................189\n           11.9.3. LUN
    ..............................................189\n           11.9.4. Sense Data
    and iSCSI Event Data ..................190\n                  11.9.4.1. SenseLength
    .............................190\n      11.10. Text Request ...........................................191\n
    \          11.10.1. F (Final) Bit ...................................192\n           11.10.2.
    C (Continue) Bit ................................192\n           11.10.3. Initiator
    Task Tag ..............................192\n           11.10.4. Target Transfer
    Tag .............................192\n           11.10.5. Text ............................................193\n
    \     11.11. Text Response ..........................................194\n           11.11.1.
    F (Final) Bit ...................................194\n           11.11.2. C (Continue)
    Bit ................................195\n           11.11.3. Initiator Task Tag
    ..............................195\n           11.11.4. Target Transfer Tag .............................195\n
    \          11.11.5. StatSN ..........................................196\n           11.11.6.
    Text Response Data ..............................196\n      11.12. Login Request
    ..........................................196\n           11.12.1. T (Transit)
    Bit .................................197\n           11.12.2. C (Continue) Bit
    ................................197\n           11.12.3. CSG and NSG .....................................198\n
    \          11.12.4. Version .........................................198\n                  11.12.4.1.
    Version-max ............................198\n                  11.12.4.2. Version-min
    ............................198\n           11.12.5. ISID ............................................199\n
    \          11.12.6. TSIH ............................................200\n           11.12.7.
    Connection ID (CID) .............................200\n           11.12.8. CmdSN
    ...........................................201\n           11.12.9. ExpStatSN
    .......................................201\n           11.12.10. Login Parameters
    ...............................201\n      11.13. Login Response .........................................202\n
    \          11.13.1. Version-max .....................................202\n           11.13.2.
    Version-active ..................................203\n           11.13.3. TSIH
    ............................................203\n           11.13.4. StatSN ..........................................203\n
    \          11.13.5. Status-Class and Status-Detail ..................203\n           11.13.6.
    T (Transit) Bit .................................206\n           11.13.7. C (Continue)
    Bit ................................206\n           11.13.8. Login Parameters
    ................................207\n      11.14. Logout Request .........................................207\n
    \          11.14.1. Reason Code .....................................209\n           11.14.2.
    TotalAHSLength and DataSegmentLength ............209\n           11.14.3. CID
    .............................................210\n           11.14.4. ExpStatSN
    .......................................210\n           11.14.5. Implicit Termination
    of Tasks ...................210\n      11.15. Logout Response ........................................211\n
    \          11.15.1. Response ........................................212\n           11.15.2.
    TotalAHSLength and DataSegmentLength ............212\n           11.15.3. Time2Wait
    .......................................212\n           11.15.4. Time2Retain .....................................212\n
    \     11.16. SNACK Request ..........................................213\n           11.16.1.
    Type ............................................214\n           11.16.2. Data
    Acknowledgment .............................215\n           11.16.3. Resegmentation
    ..................................215\n           11.16.4. Initiator Task Tag
    ..............................216\n           11.16.5. Target Transfer Tag or
    SNACK Tag ................216\n           11.16.6. BegRun ..........................................216\n
    \          11.16.7. RunLength .......................................216\n      11.17.
    Reject .................................................217\n           11.17.1.
    Reason ..........................................218\n           11.17.2. DataSN/R2TSN
    ....................................219\n           11.17.3. StatSN, ExpCmdSN,
    and MaxCmdSN ..................219\n           11.17.4. Complete Header of Bad
    PDU ......................219\n      11.18. NOP-Out ................................................220\n
    \          11.18.1. Initiator Task Tag ..............................221\n           11.18.2.
    Target Transfer Tag .............................221\n           11.18.3. Ping
    Data .......................................221\n      11.19. NOP-In .................................................222\n
    \          11.19.1. Target Transfer Tag .............................223\n           11.19.2.
    StatSN ..........................................223\n           11.19.3. LUN
    .............................................223\n   12. iSCSI Security Text Keys
    and Authentication Methods ..........223\n      12.1. AuthMethod ..............................................224\n
    \          12.1.1. Kerberos .........................................226\n           12.1.2.
    Secure Remote Password (SRP) .....................226\n           12.1.3. Challenge
    Handshake Authentication\n                   Protocol (CHAP) ..................................228\n
    \  13. Login/Text Operational Text Keys .............................229\n      13.1.
    HeaderDigest and DataDigest .............................230\n      13.2. MaxConnections
    ..........................................232\n      13.3. SendTargets .............................................232\n
    \     13.4. TargetName ..............................................232\n      13.5.
    InitiatorName ...........................................233\n      13.6. TargetAlias
    .............................................233\n      13.7. InitiatorAlias ..........................................234\n
    \     13.8. TargetAddress ...........................................234\n      13.9.
    TargetPortalGroupTag ....................................235\n      13.10. InitialR2T
    .............................................236\n      13.11. ImmediateData ..........................................236\n
    \     13.12. MaxRecvDataSegmentLength ...............................237\n      13.13.
    MaxBurstLength .........................................238\n      13.14. FirstBurstLength
    .......................................238\n      13.15. DefaultTime2Wait .......................................239\n
    \     13.16. DefaultTime2Retain .....................................239\n      13.17.
    MaxOutstandingR2T ......................................239\n      13.18. DataPDUInOrder
    .........................................240\n      13.19. DataSequenceInOrder
    ....................................240\n      13.20. ErrorRecoveryLevel .....................................241\n
    \     13.21. SessionType ............................................241\n      13.22.
    The Private Extension Key Format .......................242\n      13.23. TaskReporting
    ..........................................242\n      13.24. iSCSIProtocolLevel
    Negotiation .........................243\n      13.25. Obsoleted Keys .........................................243\n
    \     13.26. X#NodeArchitecture .....................................244\n           13.26.1.
    Definition ......................................244\n           13.26.2. Implementation
    Requirements .....................244\n   14. Rationale for Revised IANA Considerations
    ....................245\n   15. IANA Considerations ..........................................246\n
    \  16. References ...................................................248\n      16.1.
    Normative References ....................................248\n      16.2. Informative
    References ..................................251\n   Appendix A. Examples .............................................254\n
    \    A.1. Read Operation Example ....................................254\n     A.2.
    Write Operation Example ...................................255\n     A.3. R2TSN/DataSN
    Use Examples .................................256\n          A.3.1. Output (Write)
    Data DataSN/R2TSN Example ...........256\n          A.3.2. Input (Read) Data DataSN
    Example ...................257\n          A.3.3. Bidirectional DataSN Example
    .......................258\n          A.3.4. Unsolicited and Immediate Output
    (Write) Data\n                 with DataSN Example ................................259\n
    \    A.4. CRC Examples ..............................................259\n   Appendix
    B. Login Phase Examples .................................261\n   Appendix C. SendTargets
    Operation ................................268\n   Appendix D. Algorithmic Presentation
    of Error Recovery\n               Classes ..............................................272\n
    \    D.1. General Data Structure and Procedure Description ..........273\n     D.2.
    Within-command Error Recovery Algorithms ..................274\n          D.2.1.
    Procedure Descriptions .............................274\n          D.2.2. Initiator
    Algorithms ...............................275\n          D.2.3. Target Algorithms
    ..................................277\n     D.3. Within-connection Recovery Algorithms
    .....................279\n          D.3.1. Procedure Descriptions .............................279\n
    \         D.3.2. Initiator Algorithms ...............................280\n          D.3.3.
    Target Algorithms ..................................283\n     D.4. Connection
    Recovery Algorithms ............................283\n          D.4.1. Procedure
    Descriptions .............................283\n          D.4.2. Initiator Algorithms
    ...............................284\n          D.4.3. Target Algorithms ..................................286\n
    \  Appendix E. Clearing Effects of Various Events on Targets ........288\n     E.1.
    Clearing Effects on iSCSI Objects .........................288\n     E.2. Clearing
    Effects on SCSI Objects ..........................293\n   Acknowledgments ..................................................294\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Small Computer System Interface (SCSI) is a popular
    family of\n   protocols for communicating with I/O devices, especially storage\n
    \  devices.  SCSI is a client-server architecture.  Clients of a SCSI\n   interface
    are called \"initiators\".  Initiators issue SCSI \"commands\"\n   to request
    services from components -- logical units of a server\n   known as a \"target\".
    \ A \"SCSI transport\" maps the client-server SCSI\n   protocol to a specific
    interconnect.  An initiator is one endpoint of\n   a SCSI transport, and a target
    is the other endpoint.\n   The SCSI protocol has been mapped over various transports,
    including\n   Parallel SCSI, Intelligent Peripheral Interface (IPI), IEEE 1394\n
    \  (FireWire), and Fibre Channel.  These transports are I/O-specific and\n   have
    limited distance capabilities.\n   The iSCSI protocol defined in this document
    describes a means of\n   transporting SCSI packets over TCP/IP, providing for
    an interoperable\n   solution that can take advantage of existing Internet infrastructure,\n
    \  Internet management facilities, and address distance limitations.\n"
  title: 1.  Introduction
- contents:
  - '2.  Acronyms, Definitions, and Document Summary

    '
  - contents:
    - "2.1.  Acronyms\n   Acronym     Definition\n   --------------------------------------------------------------\n
      \  3DES        Triple Data Encryption Standard\n   ACA         Auto Contingent
      Allegiance\n   AEN         Asynchronous Event Notification\n   AES         Advanced
      Encryption Standard\n   AH          Additional Header (not the IPsec AH!)\n
      \  AHS         Additional Header Segment\n   API         Application Programming
      Interface\n   ASC         Additional Sense Code\n   ASCII       American Standard
      Code for Information Interchange\n   ASCQ        Additional Sense Code Qualifier\n
      \  ATA         AT Attachment\n   BHS         Basic Header Segment\n   CBC         Cipher
      Block Chaining\n   CD          Compact Disk\n   CDB         Command Descriptor
      Block\n   CHAP        Challenge Handshake Authentication Protocol\n   CID         Connection
      ID\n   CO          Connection Only\n   CRC         Cyclic Redundancy Check\n
      \  CRL         Certificate Revocation List\n   CSG         Current Stage\n   CSM
      \        Connection State Machine\n   DES         Data Encryption Standard\n
      \  DNS         Domain Name Server\n   DOI         Domain of Interpretation\n
      \  DVD         Digital Versatile Disk\n   EDTL        Expected Data Transfer
      Length\n   ESP         Encapsulating Security Payload\n   EUI         Extended
      Unique Identifier\n   FFP         Full Feature Phase\n   FFPO        Full Feature
      Phase Only\n   HBA         Host Bus Adapter\n   HMAC        Hashed Message Authentication
      Code\n   I_T         Initiator_Target\n   I_T_L       Initiator_Target_LUN\n
      \  IANA        Internet Assigned Numbers Authority\n   IB          InfiniBand\n
      \  ID          Identifier\n   IDN         Internationalized Domain Name\n   IEEE
      \       Institute of Electrical and Electronics Engineers\n   IETF        Internet
      Engineering Task Force\n   IKE         Internet Key Exchange\n   I/O         Input-Output\n
      \  IO          Initialize Only\n   IP          Internet Protocol\n   IPsec       Internet
      Protocol Security\n   IPv4        Internet Protocol Version 4\n   IPv6        Internet
      Protocol Version 6\n   IQN         iSCSI Qualified Name\n   iSCSI       Internet
      SCSI\n   iSER        iSCSI Extensions for RDMA (see [RFC7145])\n   ISID        Initiator
      Session ID\n   iSNS        Internet Storage Name Service (see [RFC4171])\n   ITN
      \        iSCSI Target Name\n   ITT         Initiator Task Tag\n   KRB5        Kerberos
      V5\n   LFL         Lower Functional Layer\n   LTDS        Logical-Text-Data-Segment\n
      \  LO          Leading Only\n   LU          Logical Unit\n   LUN         Logical
      Unit Number\n   MAC         Message Authentication Code\n   NA          Not
      Applicable\n   NAA         Network Address Authority\n   NIC         Network
      Interface Card\n   NOP         No Operation\n   NSG         Next Stage\n   OCSP
      \       Online Certificate Status Protocol\n   OS          Operating System\n
      \  PDU         Protocol Data Unit\n   PKI         Public Key Infrastructure\n
      \  R2T         Ready To Transfer\n   R2TSN       Ready To Transfer Sequence
      Number\n   RDMA        Remote Direct Memory Access\n   RFC         Request For
      Comments\n   SA          Security Association\n   SAM         SCSI Architecture
      Model\n   SAM-2       SCSI Architecture Model - 2\n   SAN         Storage Area
      Network\n   SAS         Serial Attached SCSI\n   SATA        Serial AT Attachment\n
      \  SCSI        Small Computer System Interface\n   SLP         Service Location
      Protocol\n   SN          Sequence Number\n   SNACK       Selective Negative
      Acknowledgment - also\n               Sequence Number Acknowledgement for data\n
      \  SPDTL       SCSI-Presented Data Transfer Length\n   SPKM        Simple Public-Key
      Mechanism\n   SRP         Secure Remote Password\n   SSID        Session ID\n
      \  SW          Session-Wide\n   TCB         Task Control Block\n   TCP         Transmission
      Control Protocol\n   TMF         Task Management Function\n   TPGT        Target
      Portal Group Tag\n   TSIH        Target Session Identifying Handle\n   TTT         Target
      Transfer Tag\n   UA          Unit Attention\n   UFL         Upper Functional
      Layer\n   ULP         Upper Level Protocol\n   URN         Uniform Resource
      Name\n   UTF         Universal Transformation Format\n   WG          Working
      Group\n"
    title: 2.1.  Acronyms
  - contents:
    - "2.2.  Definitions\n   - Alias: An alias string can also be associated with
      an iSCSI node.\n     The alias allows an organization to associate a user-friendly\n
      \    string with the iSCSI name.  However, the alias string is not a\n     substitute
      for the iSCSI name.\n   - CID (connection ID): Connections within a session
      are identified by\n     a connection ID.  It is a unique ID for this connection
      within the\n     session for the initiator.  It is generated by the initiator
      and\n     presented to the target during Login Requests and during logouts\n
      \    that close connections.\n   - Connection: A connection is a TCP connection.
      \ Communication\n     between the initiator and target occurs over one or more
      TCP\n     connections.  The TCP connections carry control messages, SCSI\n     commands,
      parameters, and data within iSCSI Protocol Data Units\n     (iSCSI PDUs).\n
      \  - I/O Buffer: An I/O Buffer is a buffer that is used in a SCSI read\n     or
      write operation so SCSI data may be sent from or received into\n     that buffer.
      \ For a read or write data transfer to take place for a\n     task, an I/O Buffer
      is required on the initiator and at least one\n     is required on the target.\n
      \  - INCITS: \"INCITS\" stands for InterNational Committee for Information\n
      \    Technology Standards.  The INCITS has a broad standardization scope\n     within
      the field of Information and Communications Technologies\n     (ICT), encompassing
      storage, processing, transfer, display,\n     management, organization, and
      retrieval of information.  INCITS\n     serves as ANSI's Technical Advisory
      Group for the ISO/IEC Joint\n     Technical Committee 1 (JTC 1).  See <http://www.incits.org>.\n
      \  - InfiniBand: InfiniBand is an I/O architecture originally intended\n     to
      replace Peripheral Component Interconnect (PCI) and address\n     high-performance
      server interconnectivity [IB].\n   - iSCSI Device: An iSCSI device is a SCSI
      device using an iSCSI\n     service delivery subsystem.  The Service Delivery
      Subsystem is\n     defined by [SAM2] as a transport mechanism for SCSI commands
      and\n     responses.\n   - iSCSI Initiator Name: The iSCSI Initiator Name specifies
      the\n     worldwide unique name of the initiator.\n   - iSCSI Initiator Node:
      An iSCSI initiator node is the \"initiator\"\n     device.  The word \"initiator\"
      has been appropriately qualified as\n     either a port or a device in the rest
      of the document when the\n     context is ambiguous.  All unqualified usages
      of \"initiator\" refer\n     to an initiator port (or device), depending on
      the context.\n   - iSCSI Layer: This layer builds/receives iSCSI PDUs and\n
      \    relays/receives them to/from one or more TCP connections that form\n     an
      initiator-target \"session\".\n   - iSCSI Name: This is the name of an iSCSI
      initiator or iSCSI target.\n   - iSCSI Node: The iSCSI node represents a single
      iSCSI initiator or\n     iSCSI target, or a single instance of each.  There
      are one or more\n     iSCSI nodes within a Network Entity.  The iSCSI node is
      accessible\n     via one or more Network Portals.  An iSCSI node is identified
      by\n     its iSCSI name.  The separation of the iSCSI name from the\n     addresses
      used by and for the iSCSI node allows multiple iSCSI\n     nodes to use the
      same address and the same iSCSI node to use\n     multiple addresses.\n   -
      iSCSI Target Name: The iSCSI Target Name specifies the worldwide\n     unique
      name of the target.\n   - iSCSI Target Node: The iSCSI target node is the \"target\"
      device.\n     The word \"target\" has been appropriately qualified as either
      a port\n     or a device in the rest of the document when the context is\n     ambiguous.
      \ All unqualified usages of \"target\" refer to a target\n     port (or device),
      depending on the context.\n   - iSCSI Task: An iSCSI task is an iSCSI request
      for which a response\n     is expected.\n   - iSCSI Transfer Direction: The
      iSCSI transfer direction is defined\n     with regard to the initiator.  Outbound
      or outgoing transfers are\n     transfers from the initiator to the target,
      while inbound or\n     incoming transfers are from the target to the initiator.\n
      \  - ISID: The ISID is the initiator part of the session identifier.  It\n     is
      explicitly specified by the initiator during login.\n   - I_T Nexus: According
      to [SAM2], the I_T nexus is a relationship\n     between a SCSI initiator port
      and a SCSI target port.  For iSCSI,\n     this relationship is a session, defined
      as a relationship between\n     an iSCSI initiator's end of the session (SCSI
      initiator port) and\n     the iSCSI target's portal group.  The I_T nexus can
      be identified\n     by the conjunction of the SCSI port names; that is, the
      I_T nexus\n     identifier is the tuple (iSCSI Initiator Name + ',i,' + ISID,
      iSCSI\n     Target Name + ',t,' + Target Portal Group Tag).\n   - I_T_L Nexus:
      An I_T_L nexus is a SCSI concept and is defined as the\n     relationship between
      a SCSI initiator port, a SCSI target port, and\n     a Logical Unit (LU).\n
      \  - NAA: \"NAA\" refers to Network Address Authority, a naming format\n     defined
      by the INCITS T11 Fibre Channel protocols [FC-FS3].\n   - Network Entity: The
      Network Entity represents a device or gateway\n     that is accessible from
      the IP network.  A Network Entity must have\n     one or more Network Portals,
      each of which can be used to gain\n     access to the IP network by some iSCSI
      nodes contained in that\n     Network Entity.\n   - Network Portal: The Network
      Portal is a component of a Network\n     Entity that has a TCP/IP network address
      and that may be used by an\n     iSCSI node within that Network Entity for the
      connection(s) within\n     one of its iSCSI sessions.  A Network Portal in an
      initiator is\n     identified by its IP address.  A Network Portal in a target
      is\n     identified by its IP address and its listening TCP port.\n   - Originator:
      In a negotiation or exchange, the originator is the\n     party that initiates
      the negotiation or exchange.\n   - PDU (Protocol Data Unit): The initiator and
      target divide their\n     communications into messages.  The term \"iSCSI Protocol
      Data Unit\"\n     (iSCSI PDU) is used for these messages.\n   - Portal Groups:
      iSCSI supports multiple connections within the same\n     session; some implementations
      will have the ability to combine\n     connections in a session across multiple
      Network Portals.  A portal\n     group defines a set of Network Portals within
      an iSCSI Network\n     Entity that collectively supports the capability of coordinating
      a\n     session with connections spanning these portals.  Not all Network\n
      \    Portals within a portal group need participate in every session\n     connected
      through that portal group.  One or more portal groups may\n     provide access
      to an iSCSI node.  Each Network Portal, as utilized\n     by a given iSCSI node,
      belongs to exactly one portal group within\n     that node.\n   - Portal Group
      Tag: This 16-bit quantity identifies a portal group\n     within an iSCSI node.
      \ All Network Portals with the same Portal\n     Group Tag in the context of
      a given iSCSI node are in the same\n     portal group.\n   - Recovery R2T: A
      recovery R2T is an R2T generated by a target upon\n     detecting the loss of
      one or more Data-Out PDUs through one of the\n     following means: a digest
      error, a sequence error, or a sequence\n     reception timeout.  A recovery
      R2T carries the next unused R2TSN\n     but requests all or part of the data
      burst that an earlier R2T\n     (with a lower R2TSN) had already requested.\n
      \  - Responder: In a negotiation or exchange, the responder is the party\n     that
      responds to the originator of the negotiation or exchange.\n   - SAS: The Serial
      Attached SCSI (SAS) standard contains both a\n     physical layer compatible
      with Serial ATA, and protocols for\n     transporting SCSI commands to SAS devices
      and ATA commands to SATA\n     devices [SAS] [SPL].\n   - SCSI Device: This
      is the SAM-2 term for an entity that contains one\n     or more SCSI ports that
      are connected to a service delivery\n     subsystem and supports a SCSI application
      protocol.  For example, a\n     SCSI initiator device contains one or more SCSI
      initiator ports and\n     zero or more application clients.  A target device
      contains one or\n     more SCSI target ports and one or more device servers
      and\n     associated LUs.  For iSCSI, the SCSI device is the component within\n
      \    an iSCSI node that provides the SCSI functionality.  As such, there\n     can
      be at most one SCSI device within a given iSCSI node.  Access\n     to the SCSI
      device can only be achieved in an iSCSI Normal\n     operational session.  The
      SCSI device name is defined to be the\n     iSCSI name of the node.\n   - SCSI
      Layer: This builds/receives SCSI CDBs (Command Descriptor\n     Blocks) and
      relays/receives them with the remaining Execute Command\n     [SAM2] parameters
      to/from the iSCSI Layer.\n   - Session: The group of TCP connections that link
      an initiator with a\n     target form a session (loosely equivalent to a SCSI
      I_T nexus).\n     TCP connections can be added and removed from a session.  Across\n
      \    all connections within a session, an initiator sees one and the\n     same
      target.\n   - SCSI Port: This is the SAM-2 term for an entity in a SCSI device\n
      \    that provides the SCSI functionality to interface with a service\n     delivery
      subsystem.  For iSCSI, the definitions of the SCSI\n     initiator port and
      the SCSI target port are different.\n   - SCSI Initiator Port: This maps to
      the endpoint of an iSCSI Normal\n     operational session.  An iSCSI Normal
      operational session is\n     negotiated through the login process between an
      iSCSI initiator\n     node and an iSCSI target node.  At successful completion
      of this\n     process, a SCSI initiator port is created within the SCSI initiator\n
      \    device.  The SCSI initiator port name and SCSI initiator port\n     identifier
      are both defined to be the iSCSI Initiator Name together\n     with (a) a label
      that identifies it as an initiator port\n     name/identifier and (b) the ISID
      portion of the session identifier.\n   - SCSI Port Name: This is a name consisting
      of UTF-8 [RFC3629]\n     encoding of Unicode [UNICODE] characters and includes
      the iSCSI\n     name + 'i' or 't' + ISID or Target Portal Group Tag.\n   - SCSI-Presented
      Data Transfer Length (SPDTL): SPDTL is the aggregate\n     data length of the
      data that the SCSI layer logically \"presents\" to\n     the iSCSI layer for
      a Data-In or Data-Out transfer in the context\n     of a SCSI task.  For a bidirectional
      task, there are two SPDTL\n     values -- one for Data-In and one for Data-Out.
      \ Note that the\n     notion of \"presenting\" includes immediate data per the
      data\n     transfer model in [SAM2] and excludes overlapping data transfers,\n
      \    if any, requested by the SCSI layer.\n   - SCSI Target Port: This maps
      to an iSCSI target portal group.\n   - SCSI Target Port Name and SCSI Target
      Port Identifier: These are\n     both defined to be the iSCSI Target Name together
      with (a) a label\n     that identifies it as a target port name/identifier and
      (b) the\n     Target Portal Group Tag.\n   - SSID (Session ID): A session between
      an iSCSI initiator and an\n     iSCSI target is defined by a session ID that
      is a tuple composed of\n     an initiator part (ISID) and a target part (Target
      Portal Group\n     Tag).  The ISID is explicitly specified by the initiator
      at session\n     establishment.  The Target Portal Group Tag is implied by the\n
      \    initiator through the selection of the TCP endpoint at connection\n     establishment.
      \ The TargetPortalGroupTag key must also be returned\n     by the target as
      a confirmation during connection establishment.\n   - T10: T10 is a technical
      committee within INCITS that develops\n     standards and technical reports
      on I/O interfaces, particularly the\n     series of SCSI (Small Computer System
      Interface) standards.  See\n     <http://www.t10.org>.\n   - T11: T11 is a technical
      committee within INCITS responsible for\n     standards development in the areas
      of Intelligent Peripheral\n     Interface (IPI), High-Performance Parallel Interface
      (HIPPI), and\n     Fibre Channel (FC).  See <http://www.t11.org>.\n   - Target
      Portal Group Tag: This is a numerical identifier (16-bit)\n     for an iSCSI
      target portal group.\n   - Target Transfer Tag (TTT): The TTT is an iSCSI protocol
      field used\n     in a few iSCSI PDUs (e.g., R2T, NOP-In) that is always sent
      from\n     the target to the initiator first and then quoted as a reference
      in\n     initiator-sent PDUs back to the target relating to the same\n     task/exchange.
      \ Therefore, the TTT effectively acts as an opaque\n     handle to an existing
      task/exchange to help the target associate\n     the incoming PDUs from the
      initiator to the proper execution\n     context.\n   - Third-party: This term
      is used in this document as a qualifier to\n     nexus objects (I_T or I_T_L)
      and iSCSI sessions, to indicate that\n     these objects and sessions reap the
      side effects of actions that\n     take place in the context of a separate iSCSI
      session.  One example\n     of a third-party session is an iSCSI session discovering
      that its\n     I_T_L nexus to a LU got reset due to a LU reset operation\n     orchestrated
      via a separate I_T nexus.\n   - TSIH (Target Session Identifying Handle): This
      is a target-assigned\n     tag for a session with a specific named initiator.
      \ The target\n     generates it during session establishment.  Other than defining
      it\n     as a 16-bit binary string, its internal format and content are not\n
      \    defined by this protocol but for the value with all bits set to 0\n     that
      is reserved and used by the initiator to indicate a new\n     session.  It is
      given to the target during additional connection\n     establishment for the
      same session.\n"
    title: 2.2.  Definitions
  - contents:
    - "2.3.  Summary of Changes\n   1)  Consolidated RFCs 3720, 3980, 4850, and 5048,
      and made the\n       necessary editorial changes.\n   2)  Specified iSCSIProtocolLevel
      as \"1\" in Section 13.24 and added a\n       related normative reference to
      [RFC7144].\n   3)  Removed markers and related keys.\n   4)  Removed SPKM authentication
      and related keys.\n   5)  Added a new Section 13.25 on responding to obsoleted
      keys.\n   6)  Have explicitly allowed initiator+target implementations\n       throughout
      the text.\n   7)  Clarified in Section 4.2.7 that implementations SHOULD NOT
      rely\n       on SLP-based discovery.\n   8)  Added Unified Modeling Language
      (UML) diagrams and related\n       conventions in Section 3.\n   9)  Made FastAbort
      implementation a \"SHOULD\" requirement in\n       Section 4.2.3.4, rather than
      the previous \"MUST\" requirement.\n   10) Required in Section 4.2.7.1 that
      iSCSI Target Name be the same as\n       iSCSI Initiator Name for SCSI (composite)
      devices with both\n       roles.\n   11) Changed the \"MUST NOT\" to \"should
      be avoided\" in Section 4.2.7.2\n       regarding usage of characters such as
      punctuation marks in iSCSI\n       names.\n   12) Updated Section 9.3 to require
      the following: MUST implement\n       IPsec, 2400-series RFCs (IPsec v2, IKEv1);
      and SHOULD implement\n       IPsec, 4300-series RFCs (IPsec v3, IKEv2).\n   13)
      Clarified in Section 10.2 that ACA is a \"SHOULD\" only for iSCSI\n       targets.\n
      \  14) Prohibited usage of X# name prefix for new public keys in\n       Section
      6.2.\n   15) Prohibited usage of Y# name prefix for new digest extensions in\n
      \      Section 13.1 and Z# name prefix for new authentication method\n       extensions
      in Section 12.1.\n   16) Added a \"SHOULD\" in Section 6.2 that initiators and
      targets\n       support at least six (6) exchanges during text negotiation.\n
      \  17) Added a clarification that Appendix C is normative.\n   18) Added a normative
      requirement on [RFC7146] and made a few related\n       changes in Section 9.3
      to align the text in this document with\n       that of [RFC7146].\n   19) Added
      a new Section 9.2.3 covering Kerberos authentication\n       considerations.\n
      \  20) Added text in Section 9.3.3 noting that OCSP is now allowed for\n       checking
      certificates used with IPsec in addition to the use\n       of CRLs.\n   21)
      Added text in Section 9.3.1 specifying that extended sequence\n       numbers
      (ESNs) are now required for ESPv2 (part of IPsec v2).\n"
    title: 2.3.  Summary of Changes
  - contents:
    - "2.4.  Conventions\n   In examples, \"I->\" and \"T->\" show iSCSI PDUs sent
      by the initiator\n   and target, respectively.\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
      as described in RFC 2119 [RFC2119].\n"
    title: 2.4.  Conventions
  title: 2.  Acronyms, Definitions, and Document Summary
- contents:
  - '3.  UML Conventions

    '
  - contents:
    - "3.1.  UML Conventions Overview\n   The SCSI Architecture Model (SAM) uses class
      diagrams and object\n   diagrams with notation that is based on the Unified
      Modeling Language\n   [UML].  Therefore, this document also uses UML to model
      the\n   relationships for SCSI and iSCSI objects.\n   A treatise on the graphical
      notation used in UML is beyond the scope\n   of this document.  However, given
      the use of ASCII drawing for UML\n   static class diagrams, a description of
      the notational conventions\n   used in this document is included in the remainder
      of this section.\n"
    title: 3.1.  UML Conventions Overview
  - contents:
    - "3.2.  Multiplicity Notion\n   Not specified   The number of instances of an
      attribute is not\n                   specified.\n               1   One instance
      of the class or attribute exists.\n            0..*   Zero or more instances
      of the class or attribute\n                   exist.\n            1..*   One
      or more instances of the class or attribute\n                   exist.\n            0..1
      \  Zero or one instance of the class or attribute\n                   exists.\n
      \           n..m   n to m instances of the class or attribute exist\n                   (e.g.,
      2..8).\n         x, n..m   Multiple disjoint instances of the class or\n                   attribute
      exist (e.g., 2, 8..15).\n"
    title: 3.2.  Multiplicity Notion
  - contents:
    - "3.3.  Class Diagram Conventions\n     +--------------+    +--------------+
      \      +--------------+\n     |  Class Name  |    |  Class Name  |       |  Class
      Name  |\n     +--------------+    +--------------+       +--------------+\n
      \    |              |    |              |\n     +--------------+    +--------------+\n
      \    |              |\n     +--------------+\n     The previous three diagrams
      are examples of a class with no\n     attributes and with no operations.\n     +-------------------+
      \   +-------------------+\n     |    Class Name     |    |    Class Name     |\n
      \    +-------------------+    +-------------------+\n     | attribute 01[1]
      \  |    |   attribute 01[1] |\n     | attribute 02[1]   |    |   attribute 02[1]
      |\n     +-------------------+    +-------------------+\n     |                   |\n
      \    +-------------------+\n     The preceding two diagrams are examples of
      a class with attributes\n     and with no operations.\n     +------------------------+\n
      \    |      Class Name        |\n     +------------------------+\n     |    attribute
      01[1..*]  |\n     |    attribute 02[1]     |\n     +------------------------+\n
      \    |    operation 01()      |\n     |    operation 02()      |\n     +------------------------+\n
      \    The preceding diagram is an example of a class with attributes\n     that
      have a specified multiplicity and operations.\n"
    title: 3.3.  Class Diagram Conventions
  - contents:
    - "3.4.  Class Diagram Notation for Associations\n     +-----------------+\n     |
      \    Class A     |\n     +-----------------+ association_name   +-----------------+\n
      \    | attribute 01[1] |<------------------>|     Class B     |\n     | attribute
      02[1] | 1..*          0..1 +-----------------+\n     +-----------------+                    |
      attribute 03[1] |\n     | operation 1()   |                    +-----------------+\n
      \    +-----------------+\n     The preceding diagram is an example where Class
      A knows about\n     Class B (i.e., read as \"Class A association_name Class
      B\") and\n     Class B knows about Class A (i.e., read as \"Class B\n     association_name
      Class A\").  The use of association_name is\n     optional.  The multiplicity
      notation (1..* and 0..1) indicates the\n     number of instances of the object.\n
      \    +--------------------+\n     |      Class A       |\n     +--------------------+
      \             +--------------------+\n     | attribute 01[1]    |<-------------|
      \     Class B       |\n     | attribute 02[1]    | 1      0..1  +--------------------+\n
      \    +--------------------+              | attribute 03[1]    |\n     | operation
      1()      |              +--------------------+\n     +--------------------+\n
      \    The preceding diagram is an example where Class B knows about\n     Class
      A (i.e., read as \"Class B knows about Class A\") but Class A\n     does not
      know about Class B.\n     +----------------------+\n     |       Class A        |\n
      \    +----------------------+            +--------------------+\n     |   attribute
      01[1]    |----------->|      Class B       |\n     |   attribute 02[1]    |
      0..*     1 +--------------------+\n     +----------------------+            |
      attribute 03[1]    |\n     |    operation 1()     |            +--------------------+\n
      \    +----------------------+\n     The preceding diagram is an example where
      Class A knows about\n     Class B (i.e., read as \"Class A knows about Class
      B\") but Class B\n     does not know about Class A.\n"
    title: 3.4.  Class Diagram Notation for Associations
  - contents:
    - "3.5.  Class Diagram Notation for Aggregations\n     +---------------+             +--------------+\n
      \    |  Class whole  |o------------|  Class part  |\n     +---------------+
      \            +--------------+\n     The preceding diagram is an example where
      Class whole is an\n     aggregate that contains Class part and where Class part
      may\n     continue to exist even if Class whole is removed (i.e., read as\n
      \    \"the whole contains the part\").\n     +---------------+             +--------------+\n
      \    |  Class whole  |@------------|  Class part  |\n     +---------------+
      \            +--------------+\n     The preceding diagram is an example where
      Class whole is an\n     aggregate that contains Class part where Class part
      only belongs\n     to one Class whole, and the Class part does not continue
      to exist\n     if the Class whole is removed (i.e., read as \"the whole contains\n
      \    the part\").\n     +-------------+\n     |             |\n     +-------------+\n
      \       |       |\n        + =(a)= +\n        |       |\n     The preceding
      diagram is an example where there is a constraint\n     between the associations,
      where the (a) footnote describes the\n     constraint.\n"
    title: 3.5.  Class Diagram Notation for Aggregations
  - contents:
    - "3.6.  Class Diagram Notation for Generalizations\n     +---------------+\n
      \    |  Superclass   |\n     +-------^-------+\n            /_\\\n             |\n
      \    +---------------+\n     |    Subclass   |\n     +---------------+\n     The
      preceding diagram is an example where the subclass is a kind\n     of superclass.
      \ A subclass shares all the attributes and\n     operations of the superclass
      (i.e., the subclass inherits from the\n     superclass).\n"
    title: 3.6.  Class Diagram Notation for Generalizations
  title: 3.  UML Conventions
- contents:
  - '4.  Overview

    '
  - contents:
    - "4.1.  SCSI Concepts\n   The SCSI Architecture Model - 2 [SAM2] describes in
      detail the\n   architecture of the SCSI family of I/O protocols.  This section\n
      \  provides a brief background of the SCSI architecture and is intended\n   to
      familiarize readers with its terminology.\n   At the highest level, SCSI is
      a family of interfaces for requesting\n   services from I/O devices, including
      hard drives, tape drives, CD and\n   DVD drives, printers, and scanners.  In
      SCSI terminology, an\n   individual I/O device is called a \"logical unit\"
      (LU).\n   SCSI is a client-server architecture.  Clients of a SCSI interface\n
      \  are called \"initiators\".  Initiators issue SCSI \"commands\" to request\n
      \  services from components -- LUs of a server known as a \"target\".  The\n
      \  \"device server\" on the LU accepts SCSI commands and processes them.\n   A
      \"SCSI transport\" maps the client-server SCSI protocol to a specific\n   interconnect.
      \ The initiator is one endpoint of a SCSI transport.\n   The \"target\" is the
      other endpoint.  A target can contain multiple\n   LUs.  Each LU has an address
      within a target called a Logical Unit\n   Number (LUN).\n   A SCSI task is a
      SCSI command or possibly a linked set of SCSI\n   commands.  Some LUs support
      multiple pending (queued) tasks, but the\n   queue of tasks is managed by the
      LU.  The target uses an initiator-\n   provided \"task tag\" to distinguish
      between tasks.  Only one command\n   in a task can be outstanding at any given
      time.\n   Each SCSI command results in an optional data phase and a required\n
      \  response phase.  In the data phase, information can travel from the\n   initiator
      to the target (e.g., write), from the target to the\n   initiator (e.g., read),
      or in both directions.  In the response\n   phase, the target returns the final
      status of the operation,\n   including any errors.\n   Command Descriptor Blocks
      (CDBs) are the data structures used to\n   contain the command parameters that
      an initiator sends to a target.\n   The CDB content and structure are defined
      by [SAM2] and device-type\n   specific SCSI standards.\n"
    title: 4.1.  SCSI Concepts
  - contents:
    - "4.2.  iSCSI Concepts and Functional Overview\n   The iSCSI protocol is a mapping
      of the SCSI command, event, and task\n   management model (see [SAM2]) over
      the TCP protocol.  SCSI commands\n   are carried by iSCSI requests, and SCSI
      responses and status are\n   carried by iSCSI responses.  iSCSI also uses the
      request-response\n   mechanism for iSCSI protocol mechanisms.\n   For the remainder
      of this document, the terms \"initiator\" and\n   \"target\" refer to \"iSCSI
      initiator node\" and \"iSCSI target node\",\n   respectively (see iSCSI), unless
      otherwise qualified.\n   As its title suggests, Section 4 presents an overview
      of the iSCSI\n   concepts, and later sections in the rest of the specification
      contain\n   the normative requirements -- in many cases covering the same\n
      \  concepts discussed in Section 4.  Such normative requirements text\n   overrides
      the overview text in Section 4 if there is a disagreement\n   between the two.\n
      \  In keeping with similar protocols, the initiator and target divide\n   their
      communications into messages.  This document uses the term\n   \"iSCSI Protocol
      Data Unit\" (iSCSI PDU) for these messages.\n   For performance reasons, iSCSI
      allows a \"phase-collapse\".  A command\n   and its associated data may be shipped
      together from initiator to\n   target, and data and responses may be shipped
      together from targets.\n   The iSCSI transfer direction is defined with respect
      to the\n   initiator.  Outbound or outgoing transfers are transfers from an\n
      \  initiator to a target, while inbound or incoming transfers are from a\n   target
      to an initiator.\n   An iSCSI task is an iSCSI request for which a response
      is expected.\n   In this document, \"iSCSI request\", \"iSCSI command\", request,
      or\n   (unqualified) command have the same meaning.  Also, unless otherwise\n
      \  specified, status, response, or numbered response have the same\n   meaning.\n"
    - contents:
      - "4.2.1.  Layers and Sessions\n   The following conceptual layering model is
        used to specify initiator\n   and target actions and the way in which they
        relate to transmitted\n   and received Protocol Data Units:\n      - The SCSI
        layer builds/receives SCSI CDBs (Command Descriptor\n        Blocks) and passes/receives
        them with the remaining Execute\n        Command [SAM2] parameters to/from\n
        \     - the iSCSI layer that builds/receives iSCSI PDUs and\n        relays/receives
        them to/from one or more TCP connections; the\n        group of connections
        form an initiator-target \"session\".\n   Communication between the initiator
        and target occurs over one or\n   more TCP connections.  The TCP connections
        carry control messages,\n   SCSI commands, parameters, and data within iSCSI
        Protocol Data Units\n   (iSCSI PDUs).  The group of TCP connections that link
        an initiator\n   with a target form a session (equivalent to a SCSI I_T nexus;
        see\n   Section 4.4.2).  A session is defined by a session ID that is\n   composed
        of an initiator part and a target part.  TCP connections can\n   be added
        and removed from a session.  Each connection within a\n   session is identified
        by a connection ID (CID).\n   Across all connections within a session, an
        initiator sees one\n   \"target image\".  All target-identifying elements,
        such as a LUN, are\n   the same.  A target also sees one \"initiator image\"
        across all\n   connections within a session.  Initiator-identifying elements,
        such\n   as the Initiator Task Tag, are global across the session, regardless\n
        \  of the connection on which they are sent or received.\n   iSCSI targets
        and initiators MUST support at least one TCP connection\n   and MAY support
        several connections in a session.  For error recovery\n   purposes, targets
        and initiators that support a single active\n   connection in a session SHOULD
        support two connections during\n   recovery.\n"
      title: 4.2.1.  Layers and Sessions
    - contents:
      - "4.2.2.  Ordering and iSCSI Numbering\n   iSCSI uses command and status numbering
        schemes and a data sequencing\n   scheme.\n   Command numbering is session-wide
        and is used for ordered command\n   delivery over multiple connections.  It
        can also be used as a\n   mechanism for command flow control over a session.\n
        \  Status numbering is per connection and is used to enable missing\n   status
        detection and recovery in the presence of transient or\n   permanent communication
        errors.\n   Data sequencing is per command or part of a command (R2T-triggered\n
        \  sequence) and is used to detect missing data and/or R2T PDUs due to\n   header
        digest errors.\n   Typically, fields in the iSCSI PDUs communicate the sequence
        numbers\n   between the initiator and target.  During periods when traffic
        on a\n   connection is unidirectional, iSCSI NOP-Out/NOP-In PDUs may be\n
        \  utilized to synchronize the command and status ordering counters of\n   the
        target and initiator.\n   The iSCSI session abstraction is equivalent to the
        SCSI I_T nexus,\n   and the iSCSI session provides an ordered command delivery
        from the\n   SCSI initiator to the SCSI target.  For detailed design\n   considerations
        that led to the iSCSI session model as it is defined\n   here and how it relates
        the SCSI command ordering features defined in\n   SCSI specifications to the
        iSCSI concepts, see [RFC3783].\n"
      - contents:
        - "4.2.2.1.  Command Numbering and Acknowledging\n   iSCSI performs ordered
          command delivery within a session.  All\n   commands (initiator-to-target
          PDUs) in transit from the initiator to\n   the target are numbered.\n   iSCSI
          considers a task to be instantiated on the target in response\n   to every
          request issued by the initiator.  A set of task management\n   operations,
          including abort and reassign (see Section 11.5), may be\n   performed on
          an iSCSI task; however, an abort operation cannot be\n   performed on a
          task management operation, and usage of reassign\n   operations has certain
          constraints.  See Section 11.5.1 for details.\n   Some iSCSI tasks are SCSI
          tasks, and many SCSI activities are related\n   to a SCSI task ([SAM2]).
          \ In all cases, the task is identified by the\n   Initiator Task Tag for
          the life of the task.\n   The command number is carried by the iSCSI PDU
          as the CmdSN (command\n   sequence number).  The numbering is session-wide.
          \ Outgoing iSCSI\n   PDUs carry this number.  The iSCSI initiator allocates
          CmdSNs with a\n   32-bit unsigned counter (modulo 2**32).  Comparisons and
          arithmetic\n   on CmdSNs use Serial Number Arithmetic as defined in [RFC1982]
          where\n   SERIAL_BITS = 32.\n   Commands meant for immediate delivery are
          marked with an immediate\n   delivery flag; they MUST also carry the current
          CmdSN.  The CmdSN\n   MUST NOT advance after a command marked for immediate
          delivery is\n   sent.\n   Command numbering starts with the first Login
          Request on the first\n   connection of a session (the leading login on the
          leading\n   connection), and the CmdSN MUST be incremented by 1 in a Serial\n
          \  Number Arithmetic sense, as defined in [RFC1982], for every\n   non-immediate
          command issued afterwards.\n   If immediate delivery is used with task management
          commands, these\n   commands may reach the target before the tasks on which
          they are\n   supposed to act.  However, their CmdSN serves as a marker of
          their\n   position in the stream of commands.  The initiator and target
          MUST\n   ensure that the SCSI task management functions specified in [SAM2]\n
          \  act in accordance with the [SAM2] specification.  For example, both\n
          \  commands and responses appear as if delivered in order.  Whenever the\n
          \  CmdSN for an outgoing PDU is not specified by an explicit rule, the\n
          \  CmdSN will carry the current value of the local CmdSN variable (see\n
          \  later in this section).\n   The means by which an implementation decides
          to mark a PDU for\n   immediate delivery or by which iSCSI decides by itself
          to mark a PDU\n   for immediate delivery are beyond the scope of this document.\n
          \  The number of commands used for immediate delivery is not limited,\n
          \  and their delivery to execution is not acknowledged through the\n   numbering
          scheme.  An iSCSI target MAY reject immediate commands,\n   e.g., due to
          lack of resources to accommodate additional commands.\n   An iSCSI target
          MUST be able to handle at least one immediate task\n   management command
          and one immediate non-task-management iSCSI\n   command per connection at
          any time.\n   In this document, delivery for execution means delivery to
          the SCSI\n   execution engine or an iSCSI protocol-specific execution engine\n
          \  (e.g., for Text Requests with public or private extension keys\n   involving
          an execution component).  With the exception of the\n   commands marked
          for immediate delivery, the iSCSI target layer MUST\n   deliver the commands
          for execution in the order specified by the\n   CmdSN.  Commands marked
          for immediate delivery may be delivered by\n   the iSCSI target layer for
          execution as soon as detected.  iSCSI may\n   avoid delivering some commands
          to the SCSI target layer if required\n   by a prior SCSI or iSCSI action
          (e.g., a CLEAR TASK SET task\n   management request received before all
          the commands on which it was\n   supposed to act).\n   On any connection,
          the iSCSI initiator MUST send the commands in\n   increasing order of CmdSN,
          except for commands that are retransmitted\n   due to digest error recovery
          and connection recovery.\n   For the numbering mechanism, the initiator
          and target maintain the\n   following three variables for each session:\n
          \     - CmdSN: the current command sequence number, advanced by 1 on\n        each
          command shipped except for commands marked for immediate\n        delivery
          as discussed above.  The CmdSN always contains the\n        number to be
          assigned to the next command PDU.\n      - ExpCmdSN: the next expected command
          by the target.  The target\n        acknowledges all commands up to, but
          not including, this number.\n        The initiator treats all commands with
          a CmdSN less than the\n        ExpCmdSN as acknowledged.  The target iSCSI
          layer sets the\n        ExpCmdSN to the largest non-immediate CmdSN that
          it can deliver\n        for execution \"plus 1\" per [RFC1982].  There MUST
          NOT be any\n        holes in the acknowledged CmdSN sequence.\n      - MaxCmdSN:
          the maximum number to be shipped.  The queuing\n        capacity of the
          receiving iSCSI layer is\n        MaxCmdSN - ExpCmdSN + 1.\n   The initiator's
          ExpCmdSN and MaxCmdSN are derived from target-to-\n   initiator PDU fields.
          \ Comparisons and arithmetic on the ExpCmdSN and\n   MaxCmdSN MUST use Serial
          Number Arithmetic as defined in [RFC1982]\n   where SERIAL_BITS = 32.\n
          \  The target MUST NOT transmit a MaxCmdSN that is less than\n   ExpCmdSN
          - 1.  For non-immediate commands, the CmdSN field can take\n   any value
          from the ExpCmdSN to the MaxCmdSN inclusive.  The target\n   MUST silently
          ignore any non-immediate command outside of this range\n   or non-immediate
          duplicates within the range.  The CmdSN carried by\n   immediate commands
          may lie outside the ExpCmdSN-to-MaxCmdSN range.\n   For example, if the
          initiator has previously sent a non-immediate\n   command carrying the CmdSN
          equal to the MaxCmdSN, the target window\n   is closed.  For group task
          management commands issued as immediate\n   commands, the CmdSN indicates
          the scope of the group action (e.g., an\n   ABORT TASK SET indicates which
          commands are to be aborted).\n   MaxCmdSN and ExpCmdSN fields are processed
          by the initiator as\n   follows:\n      - If the PDU MaxCmdSN is less than
          the PDU ExpCmdSN - 1 (in a\n        Serial Number Arithmetic sense), they
          are both ignored.\n      - If the PDU MaxCmdSN is greater than the local
          MaxCmdSN (in a\n        Serial Number Arithmetic sense), it updates the
          local MaxCmdSN;\n        otherwise, it is ignored.\n      - If the PDU ExpCmdSN
          is greater than the local ExpCmdSN (in a\n        Serial Number Arithmetic
          sense), it updates the local ExpCmdSN;\n        otherwise, it is ignored.\n
          \  This sequence is required because updates may arrive out of order\n   (e.g.,
          the updates are sent on different TCP connections).\n   iSCSI initiators
          and targets MUST support the command numbering\n   scheme.\n   A numbered
          iSCSI request will not change its allocated CmdSN,\n   regardless of the
          number of times and circumstances in which it is\n   reissued (see Section
          7.2.1).  At the target, the CmdSN is only\n   relevant while the command
          has not created any state related to its\n   execution (execution state);
          afterwards, the CmdSN becomes\n   irrelevant.  Testing for the execution
          state (represented by\n   identifying the Initiator Task Tag) MUST precede
          any other action at\n   the target.  If no execution state is found, it
          is followed by\n   ordering and delivery.  If an execution state is found,
          it is\n   followed by delivery if it has not already been delivered.\n   If
          an initiator issues a command retry for a command with CmdSN R on\n   a
          connection when the session CmdSN value is Q, it MUST NOT advance\n   the
          CmdSN past R + 2**31 - 1 unless\n      - the connection is no longer operational
          (i.e., it has returned\n        to the FREE state; see Section 8.1.3),\n
          \     - the connection has been reinstated (see Section 6.3.4), or\n      -
          a non-immediate command with a CmdSN equal to or greater than Q\n        was
          issued subsequent to the command retry on the same\n        connection and
          the reception of that command is acknowledged by\n        the target (see
          Section 10.4).\n   A target command response or Data-In PDU with status
          MUST NOT precede\n   the command acknowledgment.  However, the acknowledgment
          MAY be\n   included in the response or the Data-In PDU.\n"
        title: 4.2.2.1.  Command Numbering and Acknowledging
      - contents:
        - "4.2.2.2.  Response/Status Numbering and Acknowledging\n   Responses in
          transit from the target to the initiator are numbered.\n   The StatSN (status
          sequence number) is used for this purpose.  The\n   StatSN is a counter
          maintained per connection.  The ExpStatSN is used\n   by the initiator to
          acknowledge status.  The status sequence number\n   space is 32-bit unsigned
          integers, and the arithmetic operations are\n   the regular mod(2**32) arithmetic.\n
          \  Status numbering starts with the Login Response to the first Login\n
          \  Request of the connection.  The Login Response includes an initial\n
          \  value for status numbering (any initial value is valid).\n   To enable
          command recovery, the target MAY maintain enough state\n   information for
          data and status recovery after a connection failure.\n   A target doing
          so can safely discard all of the state information\n   maintained for recovery
          of a command after the delivery of the status\n   for the command (numbered
          StatSN) is acknowledged through the\n   ExpStatSN.\n   A large absolute
          difference between the StatSN and the ExpStatSN may\n   indicate a failed
          connection.  Initiators MUST undertake recovery\n   actions if the difference
          is greater than an implementation-defined\n   constant that MUST NOT exceed
          2**31 - 1.\n   Initiators and targets MUST support the response-numbering
          scheme.\n"
        title: 4.2.2.2.  Response/Status Numbering and Acknowledging
      - contents:
        - '4.2.2.3.  Response Ordering

          '
        - contents:
          - "4.2.2.3.1.  Need for Response Ordering\n   Whenever an iSCSI session
            is composed of multiple connections, the\n   Response PDUs (task responses
            or TMF Responses) originating in the\n   target SCSI layer are distributed
            onto the multiple connections by\n   the target iSCSI layer according
            to iSCSI connection allegiance\n   rules.  This process generally may
            not preserve the ordering of the\n   responses by the time they are delivered
            to the initiator SCSI layer.\n   Since ordering is not expected across
            SCSI Response PDUs anyway, this\n   approach works fine in the general
            case.  However, to address the\n   special cases where some ordering is
            desired by the SCSI layer, we\n   introduce the notion of a \"Response
            Fence\": a Response Fence is\n   logically the attribute/property of a
            SCSI response message handed\n   off to a target iSCSI layer that indicates
            that there are special\n   SCSI-level ordering considerations associated
            with this particular\n   response message.  Whenever a Response Fence
            is set or required on a\n   SCSI response message, we define the semantics
            in Section 4.2.2.3.2\n   with respect to the target iSCSI layer's handling
            of such SCSI\n   response messages.\n"
          title: 4.2.2.3.1.  Need for Response Ordering
        - contents:
          - "4.2.2.3.2.  Response Ordering Model Description\n   The target SCSI protocol
            layer hands off the SCSI response messages\n   to the target iSCSI layer
            by invoking the \"Send Command Complete\"\n   protocol data service ([SAM2],
            Clause 5.4.2) and \"Task Management\n   Function Executed\" ([SAM2], Clause
            6.9) service.  On receiving the\n   SCSI response message, the iSCSI layer
            exhibits the Response Fence\n   behavior for certain SCSI response messages
            (Section 4.2.2.3.4\n   describes the specific instances where the semantics
            must be\n   realized).\n   Whenever the Response Fence behavior is required
            for a SCSI response\n   message, the target iSCSI layer MUST ensure that
            the following\n   conditions are met in delivering the response message
            to the\n   initiator iSCSI layer:\n      - A response with a Response
            Fence MUST be delivered\n        chronologically after all the \"preceding\"
            responses on the I_T_L\n        nexus, if the preceding responses are
            delivered at all, to the\n        initiator iSCSI layer.\n      - A response
            with a Response Fence MUST be delivered\n        chronologically prior
            to all the \"following\" responses on the\n        I_T_L nexus.\n   The
            notions of \"preceding\" and \"following\" refer to the order of\n   handoff
            of a response message from the target SCSI protocol layer to\n   the target
            iSCSI layer.\n"
          title: 4.2.2.3.2.  Response Ordering Model Description
        - contents:
          - "4.2.2.3.3.  iSCSI Semantics with the Interface Model\n   Whenever the
            TaskReporting key (Section 13.23) is negotiated to\n   ResponseFence or
            FastAbort for an iSCSI session and the Response\n   Fence behavior is
            required for a SCSI response message, the target\n   iSCSI layer MUST
            perform the actions described in this section for\n   that session.\n
            \     a) If it is a single-connection session, no special processing is\n
            \        required.  The standard SCSI Response PDU build and dispatch\n
            \        process happens.\n      b) If it is a multi-connection session,
            the target iSCSI layer\n         takes note of the last-sent and unacknowledged
            StatSN on each\n         of the connections in the iSCSI session, and
            waits for an\n         acknowledgment (NOP-In PDUs MAY be used to solicit\n
            \        acknowledgments as needed in order to accelerate this process)\n
            \        of each such StatSN to clear the fence.  The SCSI Response PDU\n
            \        requiring the Response Fence behavior MUST NOT be sent to the\n
            \        initiator before acknowledgments are received for each of the\n
            \        unacknowledged StatSNs.\n      c) The target iSCSI layer must
            wait for an acknowledgment of the\n         SCSI Response PDU that carried
            the SCSI response requiring the\n         Response Fence behavior.  The
            fence MUST be considered cleared\n         only after receiving the acknowledgment.\n
            \     d) All further status processing for the LU is resumed only after\n
            \        clearing the fence.  If any new responses for the I_T_L nexus\n
            \        are received from the SCSI layer before the fence is cleared,\n
            \        those Response PDUs MUST be held and queued at the iSCSI layer\n
            \        until the fence is cleared.\n"
          title: 4.2.2.3.3.  iSCSI Semantics with the Interface Model
        - contents:
          - "4.2.2.3.4.  Current List of Fenced Response Use Cases\n   This section
            lists the situations in which fenced response behavior\n   is REQUIRED
            in iSCSI target implementations.  Note that the following\n   list is
            an exhaustive enumeration as currently identified -- it is\n   expected
            that as SCSI protocol specifications evolve, the\n   specifications will
            enumerate when response fencing is required on a\n   case-by-case basis.\n
            \  Whenever the TaskReporting key (Section 13.23) is negotiated to\n   ResponseFence
            or FastAbort for an iSCSI session, the target iSCSI\n   layer MUST assume
            that the Response Fence is required for the\n   following SCSI completion
            messages:\n      a) The first completion message carrying the UA after
            the multi-\n         task abort on issuing and third-party sessions.  See\n
            \        Section 4.2.3.2 for related TMF discussion.\n      b) The TMF
            Response carrying the multi-task TMF Response on the\n         issuing
            session.\n      c) The completion message indicating ACA establishment
            on the\n         issuing session.\n      d) The first completion message
            carrying the ACA ACTIVE status\n         after ACA establishment on issuing
            and third-party sessions.\n      e) The TMF Response carrying the CLEAR
            ACA response on the issuing\n         session.\n      f) The response
            to a PERSISTENT RESERVE OUT/PREEMPT AND ABORT\n         command.\n   Notes:\n
            \     - Due to the absence of ACA-related fencing requirements in\n        [RFC3720],
            initiator implementations SHOULD NOT use ACA on\n        multi-connection
            iSCSI sessions with targets complying only with\n        [RFC3720].  This
            can be determined via TaskReporting key\n        (Section 13.23) negotiation
            -- when the negotiation results in\n        either \"RFC3720\" or \"NotUnderstood\".\n
            \     - Initiators that want to employ ACA on multi-connection iSCSI\n
            \       sessions SHOULD first assess response-fencing behavior via\n        negotiating
            for the \"ResponseFence\" or \"FastAbort\" value for the\n        TaskReporting
            (Section 13.23) key.\n"
          title: 4.2.2.3.4.  Current List of Fenced Response Use Cases
        title: 4.2.2.3.  Response Ordering
      - contents:
        - "4.2.2.4.  Data Sequencing\n   Data and R2T PDUs transferred as part of
          some command execution MUST\n   be sequenced.  The DataSN field is used
          for data sequencing.  For\n   input (read) data PDUs, the DataSN starts
          with 0 for the first data\n   PDU of an input command and advances by 1
          for each subsequent data\n   PDU.  For output data PDUs, the DataSN starts
          with 0 for the first\n   data PDU of a sequence (the initial unsolicited
          sequence or any data\n   PDU sequence issued to satisfy an R2T) and advances
          by 1 for each\n   subsequent data PDU.  R2Ts are also sequenced per command.
          \ For\n   example, the first R2T has an R2TSN of 0 and advances by 1 for
          each\n   subsequent R2T.  For bidirectional commands, the target uses the\n
          \  DataSN/R2TSN to sequence Data-In and R2T PDUs in one continuous\n   sequence
          (undifferentiated).  Unlike command and status, data PDUs\n   and R2Ts are
          not acknowledged by a field in regular outgoing PDUs.\n   Data-In PDUs can
          be acknowledged on demand by a special form of the\n   SNACK PDU.  Data
          and R2T PDUs are implicitly acknowledged by status\n   for the command.
          \ The DataSN/R2TSN field enables the initiator to\n   detect missing data
          or R2T PDUs.\n   For any read or bidirectional command, a target MUST issue
          less than\n   2**32 combined R2T and Data-In PDUs.  Any output data sequence
          MUST\n   contain less than 2**32 Data-Out PDUs.\n"
        title: 4.2.2.4.  Data Sequencing
      title: 4.2.2.  Ordering and iSCSI Numbering
    - contents:
      - '4.2.3.  iSCSI Task Management

        '
      - contents:
        - "4.2.3.1.  Task Management Overview\n   iSCSI task management features allow
          an initiator to control the\n   active iSCSI tasks on an operational iSCSI
          session that it has with\n   an iSCSI target.  Section 11.5 defines the
          task management function\n   types that this specification defines -- ABORT
          TASK, ABORT TASK SET,\n   CLEAR ACA, CLEAR TASK SET, LOGICAL UNIT RESET,
          TARGET WARM RESET,\n   TARGET COLD RESET, and TASK REASSIGN.\n   Out of
          these function types, ABORT TASK and TASK REASSIGN functions\n   manage
          a single active task, whereas ABORT TASK SET, CLEAR TASK SET,\n   LOGICAL
          UNIT RESET, TARGET WARM RESET, and TARGET COLD RESET\n   functions can each
          potentially affect multiple active tasks.\n"
        title: 4.2.3.1.  Task Management Overview
      - contents:
        - "4.2.3.2.  Notion of Affected Tasks\n   This section defines the notion
          of \"affected tasks\" in multi-task\n   abort scenarios.  Scope definitions
          in this section apply to both the\n   standard multi-task abort semantics
          (Section 4.2.3.3) and the\n   FastAbort multi-task abort semantics behavior
          (Section 4.2.3.4).\n   ABORT TASK SET: All outstanding tasks for the I_T_L
          nexus identified\n      by the LUN field in the ABORT TASK SET TMF Request
          PDU.\n   CLEAR TASK SET: All outstanding tasks in the task set for the LU\n
          \     identified by the LUN field in the CLEAR TASK SET TMF Request PDU.\n
          \     See [SPC3] for the definition of a \"task set\".\n   LOGICAL UNIT
          RESET: All outstanding tasks from all initiators for the\n      LU identified
          by the LUN field in the LOGICAL UNIT RESET\n      Request PDU.\n   TARGET
          WARM RESET/TARGET COLD RESET: All outstanding tasks from all\n      initiators
          across all LUs to which the TMF-issuing session has\n      access on the
          SCSI target device hosting the iSCSI session.\n   Usage: An \"ABORT TASK
          SET TMF Request PDU\" in the preceding text is\n      an iSCSI TMF Request
          PDU with the \"Function\" field set to \"ABORT\n      TASK SET\" as defined
          in Section 11.5.  Similar usage is employed\n      for other scope descriptions.\n"
        title: 4.2.3.2.  Notion of Affected Tasks
      - contents:
        - "4.2.3.3.  Standard Multi-Task Abort Semantics\n   All iSCSI implementations
          MUST support the protocol behavior defined\n   in this section as the default
          behavior.  The execution of ABORT TASK\n   SET, CLEAR TASK SET, LOGICAL
          UNIT RESET, TARGET WARM RESET, and\n   TARGET COLD RESET TMF Requests consists
          of the following sequence of\n   actions in the specified order on the specified
          party.\n   The initiator iSCSI layer:\n      a) MUST continue to respond
          to each TTT received for the affected\n         tasks.\n      b) SHOULD
          process any responses received for affected tasks in the\n         normal
          fashion.  This is acceptable because the responses are\n         guaranteed
          to have been sent prior to the TMF Response.\n      c) SHOULD receive the
          TMF Response concluding all the tasks in the\n         set of affected tasks,
          unless the initiator has done something\n         (e.g., LU reset, connection
          drop) that may prevent the TMF\n         Response from being sent or received.
          \ The initiator MUST thus\n         conclude all affected tasks as part
          of this step in either case\n         and MUST discard any TMF Response
          received after the affected\n         tasks are concluded.\n   The target
          iSCSI layer:\n      a) MUST wait for responses on currently valid Target
          Transfer Tags\n         of the affected tasks from the issuing initiator.
          \ MAY wait for\n         responses on currently valid Target Transfer Tags
          of the\n         affected tasks from third-party initiators.\n      b) MUST
          wait (concurrent with the wait in Step a) for all commands\n         of
          the affected tasks to be received based on the CmdSN\n         ordering.
          \ SHOULD NOT wait for new commands on third-party\n         affected sessions
          -- only the instantiated tasks have to be\n         considered for the purpose
          of determining the affected tasks.\n         However, in the case of target-scoped
          requests (i.e., TARGET\n         WARM RESET and TARGET COLD RESET), all
          of the commands that are\n         not yet received on the issuing session
          in the command stream\n         can be considered to have been received
          with no command waiting\n         period -- i.e., the entire CmdSN space
          up to the CmdSN of the\n         task management function can be \"plugged\".\n
          \     c) MUST propagate the TMF Request to, and receive the response\n         from,
          the target SCSI layer.\n      d) MUST provide the Response Fence behavior
          for the TMF Response\n         on the issuing session as specified in Section
          4.2.2.3.2.\n      e) MUST provide the Response Fence behavior on the first
          post-TMF\n         Response on third-party sessions as specified in\n         Section
          4.2.2.3.3.  If some tasks originate from non-iSCSI\n         I_T_L nexuses,
          then the means by which the target ensures that\n         all affected tasks
          have returned their status to the initiator\n         are defined by the
          specific non-iSCSI transport protocol(s).\n   Technically, the TMF servicing
          is complete in Step d).  Data\n   transfers corresponding to terminated
          tasks may, however, still be in\n   progress on third-party iSCSI sessions
          even at the end of Step e).\n   The TMF Response MUST NOT be sent by the
          target iSCSI layer before\n   the end of Step d) and MAY be sent at the
          end of Step d) despite\n   these outstanding data transfers until after
          Step e).\n"
        title: 4.2.3.3.  Standard Multi-Task Abort Semantics
      - contents:
        - "4.2.3.4.  FastAbort Multi-Task Abort Semantics\n   Protocol behavior defined
          in this section SHOULD be implemented by\n   all iSCSI implementations complying
          with this document, noting that\n   some steps below may not be compatible
          with [RFC3720] semantics.\n   However, protocol behavior defined in this
          section MUST be exhibited\n   by iSCSI implementations on an iSCSI session
          when they negotiate the\n   TaskReporting (Section 13.23) key to \"FastAbort\"
          on that session.\n   The execution of ABORT TASK SET, CLEAR TASK SET, LOGICAL
          UNIT RESET,\n   TARGET WARM RESET, and TARGET COLD RESET TMF Requests consists
          of the\n   following sequence of actions in the specified order on the specified\n
          \  party.\n   The initiator iSCSI layer:\n      a) MUST NOT send any more
          Data-Out PDUs for affected tasks on the\n         issuing connection of
          the issuing iSCSI session once the TMF is\n         sent to the target.\n
          \     b) SHOULD process any responses received for affected tasks in the\n
          \        normal fashion.  This is acceptable because the responses are\n
          \        guaranteed to have been sent prior to the TMF Response.\n      c)
          MUST respond to each Async Message PDU with a Task Termination\n         AsyncEvent
          (5) as defined in Section 11.9.\n      d) MUST treat the TMF Response as
          terminating all affected tasks\n         for which responses have not been
          received and MUST discard any\n         responses for affected tasks received
          after the TMF Response is\n         passed to the SCSI layer (although the
          semantics defined in\n         this section ensure that such an out-of-order
          scenario will\n         never happen with a compliant target implementation).\n
          \  The target iSCSI layer:\n      a) MUST wait for all commands of the affected
          tasks to be received\n         based on the CmdSN ordering on the issuing
          session.  SHOULD NOT\n         wait for new commands on third-party affected
          sessions -- only\n         the instantiated tasks have to be considered
          for the purpose of\n         determining the affected tasks.  In the case
          of target-scoped\n         requests (i.e., TARGET WARM RESET and TARGET
          COLD RESET), all\n         the commands that are not yet received on the
          issuing session\n         in the command stream can be considered to have
          been received\n         with no command waiting period -- i.e., the entire
          CmdSN space\n         up to the CmdSN of the task management function can
          be\n         \"plugged\".\n      b) MUST propagate the TMF Request to, and
          receive the response\n         from, the target SCSI layer.\n      c) MUST
          leave all active \"affected TTTs\" (i.e., active TTTs\n         associated
          with affected tasks) valid.\n      d) MUST send an Asynchronous Message
          PDU with AsyncEvent=5\n         (Section 11.9) on:\n         1) each connection
          of each third-party session to which at\n            least one affected
          task is allegiant if\n            TaskReporting=FastAbort is operational
          on that third-party\n            session, and\n         2) each connection
          except the issuing connection of the issuing\n            session that has
          at least one allegiant affected task.\n            If there are multiple
          affected LUs (say, due to a target\n            reset), then one Async Message
          PDU MUST be sent for each\n            such LU on each connection that has
          at least one allegiant\n            affected task.  The LUN field in the
          Asynchronous Message\n            PDU MUST be set to match the LUN for each
          such LU.\n      e) MUST address the Response Fence flag on the TMF Response
          on the\n         issuing session as defined in Section 4.2.2.3.3.\n      f)
          MUST address the Response Fence flag on the first post-TMF\n         Response
          on third-party sessions as defined in\n         Section 4.2.2.3.3.  If some
          tasks originate from non-iSCSI\n         I_T_L nexuses, then the means by
          which the target ensures that\n         all affected tasks have returned
          their status to the initiator\n         are defined by the specific non-iSCSI
          transport protocol(s).\n      g) MUST free up the affected TTTs (and STags
          for iSER, if\n         applicable) and the corresponding buffers, if any,
          once it\n         receives each associated NOP-Out acknowledgment that the\n
          \        initiator generated in response to each Async Message.\n   Technically,
          the TMF servicing is complete in Step e).  Data\n   transfers corresponding
          to terminated tasks may, however, still be in\n   progress even at the end
          of Step f).  A TMF Response MUST NOT be sent\n   by the target iSCSI layer
          before the end of Step e) and MAY be sent\n   at the end of Step e) despite
          these outstanding Data transfers until\n   Step g).  Step g) specifies an
          event to free up any such resources\n   that may have been reserved to support
          outstanding data transfers.\n"
        title: 4.2.3.4.  FastAbort Multi-Task Abort Semantics
      - contents:
        - "4.2.3.5.  Affected Tasks Shared across Standard and FastAbort Sessions\n
          \  If an iSCSI target implementation is capable of supporting\n   TaskReporting=FastAbort
          functionality (Section 13.23), it may end up\n   in a situation where some
          sessions have TaskReporting=RFC3720\n   operational (RFC 3720 sessions)
          while some other sessions have\n   TaskReporting=FastAbort operational (FastAbort
          sessions) even while\n   accessing a shared set of affected tasks (Section
          4.2.3.2).  If the\n   issuing session is an RFC 3720 session, the iSCSI
          target\n   implementation is FastAbort-capable, and the third-party affected\n
          \  session is a FastAbort session, the following behavior SHOULD be\n   exhibited
          by the iSCSI target layer:\n      a) Between Steps c) and d) of the target
          behavior in\n         Section 4.2.3.3, send an Asynchronous Message PDU
          with\n         AsyncEvent=5 (Section 11.9) on each connection of each third-\n
          \        party session to which at least one affected task is allegiant.\n
          \        If there are multiple affected LUs, then send one Async Message\n
          \        PDU for each such LU on each connection that has at least one\n
          \        allegiant affected task.  When sent, the LUN field in the\n         Asynchronous
          Message PDU MUST be set to match the LUN for each\n         such LU.\n      b)
          After Step e) of the target behavior in Section 4.2.3.3, free\n         up
          the affected TTTs (and STags for iSER, if applicable) and\n         the
          corresponding buffers, if any, once each associated NOP-Out\n         acknowledgment
          is received that the third-party initiator\n         generated in response
          to each Async Message sent in Step a).\n   If the issuing session is a FastAbort
          session, the iSCSI target\n   implementation is FastAbort-capable, and the
          third-party affected\n   session is an RFC 3720 session, the iSCSI target
          layer MUST NOT send\n   Asynchronous Message PDUs on the third-party session
          to prompt the\n   FastAbort behavior.\n   If the third-party affected session
          is a FastAbort session and the\n   issuing session is a FastAbort session,
          the initiator in the third-\n   party role MUST respond to each Async Message
          PDU with AsyncEvent=5\n   as defined in Section 11.9.  Note that an initiator
          MAY thus receive\n   these Async Messages on a third-party affected session
          even if the\n   session is a single-connection session.\n"
        title: 4.2.3.5.  Affected Tasks Shared across Standard and FastAbort Sessions
      - contents:
        - "4.2.3.6.  Rationale behind the FastAbort Semantics\n   There are fundamentally
          three basic objectives behind the semantics\n   specified in Sections 4.2.3.3
          and 4.2.3.4.\n      a) Maintaining an ordered command flow I_T nexus abstraction
          to\n         the target SCSI layer even with multi-connection sessions.\n
          \        - Target iSCSI processing of a TMF Request must maintain the\n
          \          single flow illusion.  The target behavior in Step b) of\n           Section
          4.2.3.3 and the target behavior in Step a) of\n           Section 4.2.3.4
          correspond to this objective.\n      b) Maintaining a single ordered response
          flow I_T nexus\n         abstraction to the initiator SCSI layer even with
          multi-\n         connection sessions when one response (i.e., TMF Response)\n
          \        could imply the status of other unfinished tasks from the\n         initiator's
          perspective.\n         - The target must ensure that the initiator does
          not see \"old\"\n           task responses (that were placed on the wire
          chronologically\n           earlier than the TMF Response) after seeing
          the TMF Response.\n           The target behavior in Step d) of Section
          4.2.3.3 and the\n           target behavior in Step e) of Section 4.2.3.4
          correspond to\n           this objective.\n         - Whenever the result
          of a TMF action is visible across\n           multiple I_T_L nexuses, [SAM2]
          requires the SCSI device\n           server to trigger a UA on each of the
          other I_T_L nexuses.\n           Once an initiator is notified of such a
          UA, the application\n           client on the receiving initiator is required
          to clear its\n           task state (Clause 5.5 of [SAM2]) for the affected
          tasks.  It\n           would thus be inappropriate to deliver a SCSI Response
          for a\n           task after the task state is cleared on the initiator,
          i.e.,\n           after the UA is notified.  The UA notification contained
          in\n           the first SCSI Response PDU on each affected third-party\n
          \          I_T_L nexus after the TMF action thus MUST NOT pass the\n           affected
          task responses on any of the iSCSI sessions\n           accessing the LU.
          \ The target behavior in Step e) of\n           Section 4.2.3.3 and the
          target behavior in Step f) of\n           Section 4.2.3.4 correspond to
          this objective.\n      c) Draining all active TTTs corresponding to affected
          tasks in a\n         deterministic fashion.\n         - Data-Out PDUs with
          stale TTTs arriving after the tasks are\n           terminated can create
          a buffer management problem even for\n           traditional iSCSI implementations
          and is fatal for the\n           connection for iSCSI/iSER implementations.
          \ Either the\n           termination of affected tasks should be postponed
          until the\n           TTTs are retired (as in Step a) of Section 4.2.3.3),
          or the\n           TTTs and the buffers should stay allocated beyond task\n
          \          termination to be deterministically freed up later (as in\n           Steps
          c) and g) of Section 4.2.3.4).\n   The only other notable optimization is
          the plugging.  If all tasks on\n   an I_T nexus will be aborted anyway (as
          with a target reset), there\n   is no need to wait to receive all commands
          to plug the CmdSN holes.\n   The target iSCSI layer can simply plug all
          missing CmdSN slots and\n   move on with TMF processing.  The first objective
          (maintaining a\n   single ordered command flow) is still met with this optimization\n
          \  because the target SCSI layer only sees ordered commands.\n"
        title: 4.2.3.6.  Rationale behind the FastAbort Semantics
      title: 4.2.3.  iSCSI Task Management
    - contents:
      - "4.2.4.  iSCSI Login\n   The purpose of the iSCSI login is to enable a TCP
        connection for\n   iSCSI use, authentication of the parties, negotiation of
        the\n   session's parameters, and marking of the connection as belonging to\n
        \  an iSCSI session.\n   A session is used to identify to a target all the
        connections with a\n   given initiator that belong to the same I_T nexus.
        \ (For more details\n   on how a session relates to an I_T nexus, see Section
        4.4.2.)\n   The targets listen on a well-known TCP port or other TCP port
        for\n   incoming connections.  The initiator begins the login process by\n
        \  connecting to one of these TCP ports.\n   As part of the login process,
        the initiator and target SHOULD\n   authenticate each other and MAY set a
        security association protocol\n   for the session.  This can occur in many
        different ways and is\n   subject to negotiation; see Section 12.\n   To protect
        the TCP connection, an IPsec security association MAY be\n   established before
        the Login Request.  For information on using IPsec\n   security for iSCSI,
        see Section 9, [RFC3723], and [RFC7146].\n   The iSCSI Login Phase is carried
        through Login Requests and\n   Responses.  Once suitable authentication has
        occurred and operational\n   parameters have been set, the session transitions
        to the Full Feature\n   Phase and the initiator may start to send SCSI commands.
        \ The\n   security policy for whether and by what means a target chooses to\n
        \  authorize an initiator is beyond the scope of this document.  For a\n   more
        detailed description of the Login Phase, see Section 6.\n   The login PDU
        includes the ISID part of the session ID (SSID).  The\n   target portal group
        that services the login is implied by the\n   selection of the connection
        endpoint.  For a new session, the TSIH is\n   zero.  As part of the response,
        the target generates a TSIH.\n   During session establishment, the target
        identifies the SCSI\n   initiator port (the \"I\" in the \"I_T nexus\") through
        the value pair\n   (InitiatorName, ISID).  We describe InitiatorName later
        in this\n   section.  Any persistent state (e.g., persistent reservations)
        on the\n   target that is associated with a SCSI initiator port is identified\n
        \  based on this value pair.  Any state associated with the SCSI target\n
        \  port (the \"T\" in the \"I_T nexus\") is identified externally by the\n
        \  TargetName and Target Portal Group Tag (see Section 4.4.1).  The ISID\n
        \  is subject to reuse restrictions because it is used to identify a\n   persistent
        state (see Section 4.4.3).\n   Before the Full Feature Phase is established,
        only Login Request and\n   Login Response PDUs are allowed.  Login Requests
        and Responses MUST\n   be used exclusively during login.  On any connection,
        the Login Phase\n   MUST immediately follow TCP connection establishment,
        and a\n   subsequent Login Phase MUST NOT occur before tearing down the\n
        \  connection.\n   A target receiving any PDU except a Login Request before
        the Login\n   Phase is started MUST immediately terminate the connection on
        which\n   the PDU was received.  Once the Login Phase has started, if the\n
        \  target receives any PDU except a Login Request, it MUST send a Login\n
        \  reject (with Status \"invalid during login\") and then disconnect.  If\n
        \  the initiator receives any PDU except a Login Response, it MUST\n   immediately
        terminate the connection.\n"
      title: 4.2.4.  iSCSI Login
    - contents:
      - "4.2.5.  iSCSI Full Feature Phase\n   Once the two sides successfully conclude
        the login on the first --\n   also called the leading -- connection in the
        session, the iSCSI\n   session is in the iSCSI Full Feature Phase.  A connection
        is in the\n   Full Feature Phase if the session is in the Full Feature Phase
        and\n   the connection login has completed successfully.  An iSCSI connection\n
        \  is not in the Full Feature Phase when\n      a) it does not have an established
        transport connection, or\n      b) when it has a valid transport connection,
        but a successful\n         login was not performed or the connection is currently\n
        \        logged out.\n   In a normal Full Feature Phase, the initiator may
        send SCSI commands\n   and data to the various LUs on the target by encapsulating
        them in\n   iSCSI PDUs that go over the established iSCSI session.\n"
      - contents:
        - "4.2.5.1.  Command Connection Allegiance\n   For any iSCSI request issued
          over a TCP connection, the corresponding\n   response and/or other related
          PDU(s) MUST be sent over the same\n   connection.  We call this \"connection
          allegiance\".  If the original\n   connection fails before the command is
          completed, the connection\n   allegiance of the command may be explicitly
          reassigned to a different\n   transport connection as described in detail
          in Section 7.2.\n   Thus, if an initiator issues a read command, the target
          MUST send the\n   requested data, if any, followed by the status, to the
          initiator over\n   the same TCP connection that was used to deliver the
          SCSI command.\n   If an initiator issues a write command, the initiator
          MUST send the\n   data, if any, for that command over the same TCP connection
          that was\n   used to deliver the SCSI command.  The target MUST return Ready
          To\n   Transfer (R2T), if any, and the status over the same TCP connection\n
          \  that was used to deliver the SCSI command.  Retransmission requests\n
          \  (SNACK PDUs), and the data and status that they generate, MUST also\n
          \  use the same connection.\n   However, consecutive commands that are part
          of a SCSI linked command-\n   chain task (see [SAM2]) MAY use different
          connections.  Connection\n   allegiance is strictly per command and not
          per task.  During the\n   iSCSI Full Feature Phase, the initiator and target
          MAY interleave\n   unrelated SCSI commands, their SCSI data, and responses
          over the\n   session.\n"
        title: 4.2.5.1.  Command Connection Allegiance
      - contents:
        - "4.2.5.2.  Data Transfer Overview\n   Outgoing SCSI data (initiator-to-target
          user data or command\n   parameters) is sent as either solicited data or
          unsolicited data.\n   Solicited data are sent in response to R2T PDUs.  Unsolicited
          data\n   can be sent as part of an iSCSI Command PDU (\"immediate data\")
          or in\n   separate iSCSI data PDUs.\n   Immediate data are assumed to originate
          at offset 0 in the initiator\n   SCSI write-buffer (outgoing data buffer).
          \ All other data PDUs have\n   the buffer offset set explicitly in the PDU
          header.\n   An initiator may send unsolicited data up to FirstBurstLength
          (see\n   Section 13.14) as immediate (up to the negotiated maximum PDU\n
          \  length), in a separate PDU sequence, or both.  All subsequent data\n
          \  MUST be solicited.  The maximum length of an individual data PDU or\n
          \  the immediate-part of the first unsolicited burst MAY be negotiated\n
          \  at login.\n   The maximum amount of unsolicited data that can be sent
          with a\n   command is negotiated at login through the FirstBurstLength (see\n
          \  Section 13.14) key.  A target MAY separately enable immediate data\n
          \  (through the ImmediateData key) without enabling the more general\n   (separate
          data PDUs) form of unsolicited data (through the\n   InitialR2T key).\n
          \  Unsolicited data for a write are meant to reduce the effect of\n   latency
          on throughput (no R2T is needed to start sending data).  In\n   addition,
          immediate data is meant to reduce the protocol overhead\n   (both bandwidth
          and execution time).\n   An iSCSI initiator MAY choose not to send unsolicited
          data, only\n   immediate data or FirstBurstLength bytes of unsolicited data
          with a\n   command.  If any non-immediate unsolicited data is sent, the
          total\n   unsolicited data MUST be either FirstBurstLength or all of the
          data,\n   if the total amount is less than the FirstBurstLength.\n   It
          is considered an error for an initiator to send unsolicited data\n   PDUs
          to a target that operates in R2T mode (only solicited data are\n   allowed).
          \ It is also an error for an initiator to send more\n   unsolicited data,
          whether immediate or as separate PDUs, than\n   FirstBurstLength.\n   An
          initiator MUST honor an R2T data request for a valid outstanding\n   command
          (i.e., carrying a valid Initiator Task Tag) and deliver all\n   the requested
          data, provided the command is supposed to deliver\n   outgoing data and
          the R2T specifies data within the command bounds.\n   The initiator action
          is unspecified for receiving an R2T request that\n   specifies data, all
          or in part, outside of the bounds of the command.\n   A target SHOULD NOT
          silently discard data and then request\n   retransmission through R2T.  Initiators
          SHOULD NOT keep track of the\n   data transferred to or from the target
          (scoreboarding).  SCSI targets\n   perform residual count calculation to
          check how much data was\n   actually transferred to or from the device by
          a command.  This may\n   differ from the amount the initiator sent and/or
          received for reasons\n   such as retransmissions and errors.  Read or bidirectional
          commands\n   implicitly solicit the transmission of the entire amount of
          data\n   covered by the command.  SCSI data packets are matched to their\n
          \  corresponding SCSI commands by using tags specified in the protocol.\n
          \  In addition, iSCSI initiators and targets MUST enforce some ordering\n
          \  rules.  When unsolicited data is used, the order of the unsolicited\n
          \  data on each connection MUST match the order in which the commands on\n
          \  that connection are sent.  Command and unsolicited data PDUs may be\n
          \  interleaved on a single connection as long as the ordering\n   requirements
          of each are maintained (e.g., command N + 1 MAY be sent\n   before the unsolicited
          Data-Out PDUs for command N, but the\n   unsolicited Data-Out PDUs for command
          N MUST precede the unsolicited\n   Data-Out PDUs of command N + 1).  A target
          that receives data out of\n   order MAY terminate the session.\n"
        title: 4.2.5.2.  Data Transfer Overview
      - contents:
        - "4.2.5.3.  Tags and Integrity Checks\n   Initiator tags for pending commands
          are unique initiator-wide for a\n   session.  Target tags are not strictly
          specified by the protocol.  It\n   is assumed that target tags are used
          by the target to tag (alone or\n   in combination with the LUN) the solicited
          data.  Target tags are\n   generated by the target and \"echoed\" by the
          initiator.\n   These mechanisms are designed to accomplish efficient data
          delivery\n   along with a large degree of control over the data flow.\n
          \  As the Initiator Task Tag is used to identify a task during its\n   execution,
          the iSCSI initiator and target MUST verify that all other\n   fields used
          in task-related PDUs have values that are consistent with\n   the values
          used at the task instantiation, based on the Initiator\n   Task Tag (e.g.,
          the LUN used in an R2T PDU MUST be the same as the\n   one used in the SCSI
          Command PDU used to instantiate the task).\n   Using inconsistent field
          values is considered a protocol error.\n"
        title: 4.2.5.3.  Tags and Integrity Checks
      - contents:
        - "4.2.5.4.  SCSI Task Management during iSCSI Full Feature Phase\n   SCSI
          task management assumes that individual tasks and task groups\n   can be
          aborted based solely on the task tags (for individual tasks)\n   or the
          timing of the task management command (for task groups) and\n   that the
          task management action is executed synchronously -- i.e., no\n   message
          involving an aborted task will be seen by the SCSI initiator\n   after receiving
          the task management response.  In iSCSI, initiators\n   and targets interact
          asynchronously over several connections.  iSCSI\n   specifies the protocol
          mechanism and implementation requirements\n   needed to present a synchronous
          SCSI view while using an asynchronous\n   iSCSI infrastructure.\n"
        title: 4.2.5.4.  SCSI Task Management during iSCSI Full Feature Phase
      title: 4.2.5.  iSCSI Full Feature Phase
    - contents:
      - "4.2.6.  iSCSI Connection Termination\n   An iSCSI connection may be terminated
        via a transport connection\n   shutdown or a transport reset.  A transport
        reset is assumed to be an\n   exceptional event.\n   Graceful TCP connection
        shutdowns are done by sending TCP FINs.  A\n   graceful transport connection
        shutdown SHOULD only be initiated by\n   either party when the connection
        is not in the iSCSI Full Feature\n   Phase.  A target MAY terminate a Full
        Feature Phase connection on\n   internal exception events, but it SHOULD announce
        the fact through an\n   Asynchronous Message PDU.  Connection termination
        with outstanding\n   commands may require recovery actions.\n   If a connection
        is terminated while in the Full Feature Phase,\n   connection cleanup (see
        Section 7.14) is required prior to recovery.\n   By doing connection cleanup
        before starting recovery, the initiator\n   and target will avoid receiving
        stale PDUs after recovery.\n"
      title: 4.2.6.  iSCSI Connection Termination
    - contents:
      - "4.2.7.  iSCSI Names\n   Both targets and initiators require names for the
        purpose of\n   identification.  In addition, names enable iSCSI storage resources
        to\n   be managed, regardless of location (address).  An iSCSI Node Name is\n
        \  also the SCSI device name contained in the iSCSI node.  The iSCSI\n   name
        of a SCSI device is the principal object used in authentication\n   of targets
        to initiators and initiators to targets.  This name is\n   also used to identify
        and manage iSCSI storage resources.\n   iSCSI names must be unique within
        the operation domain of the end\n   user.  However, because the operation
        domain of an IP network is\n   potentially worldwide, the iSCSI name formats
        are architected to be\n   worldwide unique.  To assist naming authorities
        in the construction\n   of worldwide unique names, iSCSI provides three name
        formats for\n   different types of naming authorities.\n   iSCSI names are
        associated with iSCSI nodes, and not iSCSI network\n   adapter cards, to ensure
        that the replacement of network adapter\n   cards does not require reconfiguration
        of all SCSI and iSCSI resource\n   allocation information.\n   Some SCSI commands
        require that protocol-specific identifiers be\n   communicated within SCSI
        CDBs.  See Section 2.2 for the definition of\n   the SCSI port name/identifier
        for iSCSI ports.\n   An initiator may discover the iSCSI Target Names to which
        it has\n   access, along with their addresses, using the SendTargets Text\n
        \  Request, or other techniques discussed in [RFC3721].\n   iSCSI equipment
        that needs discovery functions beyond SendTargets\n   SHOULD implement iSNS
        (see [RFC4171]) for extended discovery\n   management capabilities and interoperability.
        \ Although [RFC3721]\n   implies an SLP ([RFC2608]) implementation requirement,
        SLP has not\n   been widely implemented or deployed for use with iSCSI in
        practice.\n   iSCSI implementations therefore SHOULD NOT rely on SLP-based\n
        \  discovery interoperability.\n"
      - contents:
        - "4.2.7.1.  iSCSI Name Properties\n   Each iSCSI node, whether it is an initiator,
          a target, or both, MUST\n   have an iSCSI name.  Whenever an iSCSI node
          contains an iSCSI\n   initiator node and an iSCSI target node, the iSCSI
          Initiator Name\n   MUST be the same as the iSCSI Target Name for the contained
          Nodes\n   such that there is only one iSCSI Node Name for the iSCSI node\n
          \  overall.  Note the related requirements in Section 9.2.1 on how to\n
          \  map CHAP names to iSCSI names in such a scenario.\n   Initiators and
          targets MUST support the receipt of iSCSI names of up\n   to the maximum
          length of 223 bytes.\n   The initiator MUST present both its iSCSI Initiator
          Name and the\n   iSCSI Target Name to which it wishes to connect in the
          first Login\n   Request of a new session or connection.  The only exception
          is if a\n   Discovery session (see Section 4.3) is to be established.  In
          this\n   case, the iSCSI Initiator Name is still required, but the iSCSI\n
          \  Target Name MAY be omitted.\n   iSCSI names have the following properties:\n
          \     - iSCSI names are globally unique.  No two initiators or targets\n
          \       can have the same name.\n      - iSCSI names are permanent.  An
          iSCSI initiator node or target\n        node has the same name for its lifetime.\n
          \     - iSCSI names do not imply a location or address.  An iSCSI\n        initiator
          or target can move or have multiple addresses.  A\n        change of address
          does not imply a change of name.\n      - iSCSI names do not rely on a central
          name broker; the naming\n        authority is distributed.\n      - iSCSI
          names support integration with existing unique naming\n        schemes.\n
          \     - iSCSI names rely on existing naming authorities.  iSCSI does not\n
          \       create any new naming authority.\n   The encoding of an iSCSI name
          has the following properties:\n      - iSCSI names have the same encoding
          method, regardless of the\n        underlying protocols.\n      - iSCSI
          names are relatively simple to compare.  The algorithm for\n        comparing
          two iSCSI names for equivalence does not rely on an\n        external server.\n
          \     - iSCSI names are composed only of printable ASCII and Unicode\n        characters.
          \ iSCSI names allow the use of international\n        character sets, but
          uppercase characters are prohibited.  The\n        iSCSI stringprep profile
          [RFC3722] maps uppercase characters to\n        lowercase and SHOULD be
          used to prepare iSCSI names from input\n        that may include uppercase
          characters.  No whitespace characters\n        are used in iSCSI names;
          see [RFC3722] for details.\n      - iSCSI names may be transported using
          both binary and ASCII-based\n        protocols.\n   An iSCSI name really
          names a logical software entity and is not tied\n   to a port or other hardware
          that can be changed.  For instance, an\n   Initiator Name should name the
          iSCSI initiator node, not a particular\n   NIC or HBA.  When multiple NICs
          are used, they should generally all\n   present the same iSCSI Initiator
          Name to the targets, because they\n   are simply paths to the same SCSI
          layer.  In most operating systems,\n   the named entity is the operating
          system image.\n   Similarly, a target name should not be tied to hardware
          interfaces\n   that can be changed.  A target name should identify the logical\n
          \  target and must be the same for the target, regardless of the\n   physical
          portion being addressed.  This assists iSCSI initiators in\n   determining
          that the two targets it has discovered are really two\n   paths to the same
          target.\n   The iSCSI name is designed to fulfill the functional requirements
          for\n   Uniform Resource Names (URNs) [RFC1737].  For example, it is required\n
          \  that the name have a global scope, be independent of address or\n   location,
          and be persistent and globally unique.  Names must be\n   extensible and
          scalable with the use of naming authorities.  The name\n   encoding should
          be both human and machine readable.  See [RFC1737]\n   for further requirements.\n"
        title: 4.2.7.1.  iSCSI Name Properties
      - contents:
        - "4.2.7.2.  iSCSI Name Encoding\n   An iSCSI name MUST be a UTF-8 (see [RFC3629])
          encoding of a string of\n   Unicode characters with the following properties:\n
          \     - It is in Normalization Form C (see \"Unicode Normalization Forms\"\n
          \       [UNICODE]).\n      - It only contains characters allowed by the
          output of the iSCSI\n        stringprep template (described in [RFC3722]).\n
          \     - The following characters are used for formatting iSCSI names:\n
          \          dash ('-'=U+002d)\n           dot ('.'=U+002e)\n           colon
          (':'=U+003a)\n      - The UTF-8 encoding of the name is not larger than
          223 bytes.\n   The stringprep process is described in [RFC3454]; iSCSI's
          use of the\n   stringprep process is described in [RFC3722].  The stringprep
          process\n   is a method designed by the Internationalized Domain Name (IDN)\n
          \  working group to translate human-typed strings into a format that can\n
          \  be compared as opaque strings.  iSCSI names are expected to be used\n
          \  by administrators for purposes such as system configuration; for this\n
          \  reason, characters that may lead to human confusion among different\n
          \  iSCSI names (e.g., punctuation, spacing, diacritical marks) should be\n
          \  avoided, even when such characters are allowed as stringprep\n   processing
          output by [RFC3722].  The stringprep process also converts\n   strings into
          equivalent strings of lowercase characters.\n   The stringprep process does
          not need to be implemented if the names\n   are generated using only characters
          allowed as output by the\n   stringprep processing specified in [RFC3722].
          \ Those allowed\n   characters include all ASCII lowercase and numeric characters,
          as\n   well as lowercase Unicode characters as specified in [RFC3722].  Once\n
          \  iSCSI names encoded in UTF-8 are \"normalized\" as described in this\n
          \  section, they may be safely compared byte for byte.\n"
        title: 4.2.7.2.  iSCSI Name Encoding
      - contents:
        - "4.2.7.3.  iSCSI Name Structure\n   An iSCSI name consists of two parts
          -- a type designator followed by\n   a unique name string.\n   iSCSI uses
          three existing naming authorities in constructing globally\n   unique iSCSI
          names.  The type designator in an iSCSI name indicates\n   the naming authority
          on which the name is based.  The three iSCSI\n   name formats are the following:\n
          \     a) iSCSI-Qualified Name: based on domain names to identify a\n         naming
          authority\n      b) NAA format Name: based on a naming format defined by
          [FC-FS3]\n         for constructing globally unique identifiers, referred
          to as\n         the Network Address Authority (NAA)\n      c) EUI format
          Name: based on EUI names, where the IEEE\n         Registration Authority
          assists in the formation of worldwide\n         unique names (EUI-64 format)\n
          \  The corresponding type designator strings currently defined are:\n      a)
          iqn. - iSCSI Qualified name\n      b) naa. - Remainder of the string is
          an INCITS T11-defined Network\n         Address Authority identifier, in
          ASCII-encoded hexadecimal\n      c) eui. - Remainder of the string is an
          IEEE EUI-64 identifier, in\n         ASCII-encoded hexadecimal\n   These
          three naming authority designators were considered sufficient\n   at the
          time of writing this document.  The creation of additional\n   naming type
          designators for iSCSI may be considered by the IETF and\n   detailed in
          separate RFCs.\n   The following table summarizes the current SCSI transport
          protocols\n   and their naming formats.\n        SCSI Transport Protocol
          \      Naming Format\n     +----------------------------+-------+-----+----+\n
          \    |                            | EUI-64| NAA |IQN |\n     |----------------------------|-------|-----|----|\n
          \    | iSCSI (Internet SCSI)      |   X   |  X  | X  |\n     |----------------------------|-------|-----|----|\n
          \    | FCP (Fibre Channel)        |       |  X  |    |\n     |----------------------------|-------|-----|----|\n
          \    | SAS (Serial Attached SCSI) |       |  X  |    |\n     +----------------------------+-------+-----+----+\n"
        title: 4.2.7.3.  iSCSI Name Structure
      - contents:
        - "4.2.7.4.  Type \"iqn.\" (iSCSI Qualified Name)\n   This iSCSI name type
          can be used by any organization that owns a\n   domain name.  This naming
          format is useful when an end user or\n   service provider wishes to assign
          iSCSI names for targets and/or\n   initiators.\n   To generate names of
          this type, the person or organization generating\n   the name must own a
          registered domain name.  This domain name does\n   not have to resolve to
          an address; it just needs to be reserved to\n   prevent others from generating
          iSCSI names using the same\n   domain name.\n   Since a domain name can
          expire, be acquired by another entity, or may\n   be used to generate iSCSI
          names by both owners, the domain name must\n   be additionally qualified
          by a date during which the naming authority\n   owned the domain name.  A
          date code is provided as part of the \"iqn.\"\n   format for this reason.\n
          \  The iSCSI qualified name string consists of:\n      - The string \"iqn.\",
          used to distinguish these names from \"eui.\"\n        formatted names.\n
          \     - A date code, in yyyy-mm format.  This date MUST be a date during\n
          \       which the naming authority owned the domain name used in this\n
          \       format and SHOULD be the first month in which the domain name\n
          \       was owned by this naming authority at 00:01 GMT of the first day\n
          \       of the month.  This date code uses the Gregorian calendar.  All\n
          \       four digits in the year must be present.  Both digits of the\n        month
          must be present, with January == \"01\" and December ==\n        \"12\".
          \ The dash must be included.\n      - A dot \".\"\n      - The reverse domain
          name of the naming authority (person or\n        organization) creating
          this iSCSI name.\n      - An optional, colon (:)-prefixed string within
          the character set\n        and length boundaries that the owner of the domain
          name deems\n        appropriate.  This may contain product types, serial
          numbers,\n        host identifiers, or software keys (e.g., it may include
          colons\n        to separate organization boundaries).  With the exception
          of the\n        colon prefix, the owner of the domain name can assign everything\n
          \       after the reverse domain name as desired.  It is the\n        responsibility
          of the entity that is the naming authority to\n        ensure that the iSCSI
          names it assigns are worldwide unique.\n        For example, \"Example Storage
          Arrays, Inc.\" might own the domain\n        name \"example.com\".\n   The
          following are examples of iSCSI qualified names that might be\n   generated
          by \"EXAMPLE Storage Arrays, Inc.\"\n                    Naming     String
          defined by\n      Type  Date     Auth      \"example.com\" naming authority\n
          \     +--++-----+ +---------+ +--------------------------------+\n      |
          ||      | |         | |                                |\n      iqn.2001-04.com.example:storage:diskarrays-sn-a8675309\n
          \     iqn.2001-04.com.example\n      iqn.2001-04.com.example:storage.tape1.sys1.xyz\n
          \     iqn.2001-04.com.example:storage.disk2.sys1.xyz\n"
        title: 4.2.7.4.  Type "iqn." (iSCSI Qualified Name)
      - contents:
        - "4.2.7.5.  Type \"eui.\" (IEEE EUI-64 Format)\n   The IEEE Registration
          Authority provides a service for assigning\n   globally unique identifiers
          [EUI].  The EUI-64 format is used to\n   build a global identifier in other
          network protocols.  For example,\n   Fibre Channel defines a method of encoding
          it into a WorldWideName.\n   For more information on registering for EUI
          identifiers, see [OUI].\n   The format is \"eui.\" followed by an EUI-64
          identifier (16 ASCII-\n   encoded hexadecimal digits).\n      Example iSCSI
          name:\n         Type   EUI-64 identifier (ASCII-encoded hexadecimal)\n         +--++--------------+\n
          \        |  ||              |\n         eui.02004567A425678D\n   The IEEE
          EUI-64 iSCSI name format might be used when a manufacturer\n   is already
          registered with the IEEE Registration Authority and uses\n   EUI-64 formatted
          worldwide unique names for its products.\n   More examples of name construction
          are discussed in [RFC3721].\n"
        title: 4.2.7.5.  Type "eui." (IEEE EUI-64 Format)
      - contents:
        - "4.2.7.6.  Type \"naa.\" (Network Address Authority)\n   The INCITS T11
          Framing and Signaling Specification [FC-FS3] defines a\n   format called
          the Network Address Authority (NAA) format for\n   constructing worldwide
          unique identifiers that use various identifier\n   registration authorities.
          \ This identifier format is used by the\n   Fibre Channel and SAS SCSI transport
          protocols.  As FC and SAS\n   constitute a large fraction of networked SCSI
          ports, the NAA format\n   is a widely used format for SCSI transports.  The
          objective behind\n   iSCSI supporting a direct representation of an NAA
          format Name is to\n   facilitate construction of a target device name that
          translates\n   easily across multiple namespaces for a SCSI storage device\n
          \  containing ports served by different transports.  More specifically,\n
          \  this format allows implementations wherein one NAA identifier can be\n
          \  assigned as the basis for the SCSI device name for a SCSI target with\n
          \  both SAS ports and iSCSI ports.\n   The iSCSI NAA naming format is \"naa.\",
          followed by an NAA identifier\n   represented in ASCII-encoded hexadecimal
          digits.\n   An example of an iSCSI name with a 64-bit NAA value follows:\n
          \     Type  NAA identifier (ASCII-encoded hexadecimal)\n      +--++--------------+\n
          \     |  ||              |\n      naa.52004567BA64678D\n   An example of
          an iSCSI name with a 128-bit NAA value follows:\n      Type  NAA identifier
          (ASCII-encoded hexadecimal)\n      +--++------------------------------+\n
          \     |  ||                              |\n      naa.62004567BA64678D0123456789ABCDEF\n
          \  The iSCSI NAA naming format might be used in an implementation when\n
          \  the infrastructure for generating NAA worldwide unique names is\n   already
          in place because the device contains both SAS and iSCSI SCSI\n   ports.\n
          \  The NAA identifier formatted in an ASCII-hexadecimal representation\n
          \  has a maximum size of 32 characters (128-bit NAA format).  As a\n   result,
          there is no issue with this naming format exceeding the\n   maximum size
          for iSCSI Node Names.\n"
        title: 4.2.7.6.  Type "naa." (Network Address Authority)
      title: 4.2.7.  iSCSI Names
    - contents:
      - "4.2.8.  Persistent State\n   iSCSI does not require any persistent state
        maintenance across\n   sessions.  However, in some cases, SCSI requires persistent\n
        \  identification of the SCSI initiator port name (see Sections 4.4.2\n   and
        4.4.3.)\n   iSCSI sessions do not persist through power cycles and boot\n
        \  operations.\n   All iSCSI session and connection parameters are reinitialized
        on\n   session and connection creation.\n   Commands persist beyond connection
        termination if the session\n   persists and command recovery within the session
        is supported.\n   However, when a connection is dropped, command execution,
        as\n   perceived by iSCSI (i.e., involving iSCSI protocol exchanges for the\n
        \  affected task), is suspended until a new allegiance is established by\n
        \  the \"TASK REASSIGN\" task management function.  See Section 11.5.\n"
      title: 4.2.8.  Persistent State
    - contents:
      - "4.2.9.  Message Synchronization and Steering\n   iSCSI presents a mapping
        of the SCSI protocol onto TCP.  This\n   encapsulation is accomplished by
        sending iSCSI PDUs of varying\n   lengths.  Unfortunately, TCP does not have
        a built-in mechanism for\n   signaling message boundaries at the TCP layer.
        \ iSCSI overcomes this\n   obstacle by placing the message length in the iSCSI
        message header.\n   This serves to delineate the end of the current message
        as well as\n   the beginning of the next message.\n   In situations where
        IP packets are delivered in order from the\n   network, iSCSI message framing
        is not an issue and messages are\n   processed one after the other.  In the
        presence of IP packet\n   reordering (i.e., frames being dropped), legacy
        TCP implementations\n   store the \"out of order\" TCP segments in temporary
        buffers until the\n   missing TCP segments arrive, at which time the data
        must be copied to\n   the application buffers.  In iSCSI, it is desirable
        to steer the SCSI\n   data within these out-of-order TCP segments into the
        preallocated\n   SCSI buffers rather than store them in temporary buffers.
        \ This\n   decreases the need for dedicated reassembly buffers as well as
        the\n   latency and bandwidth related to extra copies.\n   Relying solely
        on the \"message length\" information from the iSCSI\n   message header may
        make it impossible to find iSCSI message\n   boundaries in subsequent TCP
        segments due to the loss of a TCP\n   segment that contains the iSCSI message
        length.  The missing TCP\n   segment(s) must be received before any of the
        following segments can\n   be steered to the correct SCSI buffers (due to
        the inability to\n   determine the iSCSI message boundaries).  Since these
        segments cannot\n   be steered to the correct location, they must be saved
        in temporary\n   buffers that must then be copied to the SCSI buffers.\n   Different
        schemes can be used to recover synchronization.  The\n   details of any such
        schemes are beyond this protocol specification,\n   but it suffices to note
        that [RFC4297] provides an overview of the\n   direct data placement problem
        on IP networks, and [RFC5046] specifies\n   a protocol extension for iSCSI
        that facilitates this direct data\n   placement objective.  The rest of this
        document refers to any such\n   direct data placement protocol usage as an
        example of a \"Sync and\n   Steering layer\".\n   Under normal circumstances
        (no PDU loss or data reception out of\n   order), iSCSI data steering can
        be accomplished by using the\n   identifying tag and the data offset fields
        in the iSCSI header in\n   addition to the TCP sequence number from the TCP
        header.  The\n   identifying tag helps associate the PDU with a SCSI buffer
        address,\n   while the data offset and TCP sequence number are used to determine\n
        \  the offset within the buffer.\n"
      - contents:
        - "4.2.9.1.  Sync/Steering and iSCSI PDU Length\n   When a large iSCSI message
          is sent, the TCP segment(s) that contains\n   the iSCSI header may be lost.
          \ The remaining TCP segment(s) up to the\n   next iSCSI message must be
          buffered (in temporary buffers) because\n   the iSCSI header that indicates
          to which SCSI buffers the data are to\n   be steered was lost.  To minimize
          the amount of buffering, it is\n   recommended that the iSCSI PDU length
          be restricted to a small value\n   (perhaps a few TCP segments in length).
          \ During login, each end of\n   the iSCSI session specifies the maximum
          iSCSI PDU length it will\n   accept.\n"
        title: 4.2.9.1.  Sync/Steering and iSCSI PDU Length
      title: 4.2.9.  Message Synchronization and Steering
    title: 4.2.  iSCSI Concepts and Functional Overview
  - contents:
    - "4.3.  iSCSI Session Types\n   iSCSI defines two types of sessions:\n      a)
      Normal operational session - an unrestricted session.\n      b) Discovery session
      - a session only opened for target discovery.\n         The target MUST ONLY
      accept Text Requests with the SendTargets\n         key and a Logout Request
      with reason \"close the session\".  All\n         other requests MUST be rejected.\n
      \  The session type is defined during login with the SessionType=value\n   parameter
      in the login command.\n"
    title: 4.3.  iSCSI Session Types
  - contents:
    - "4.4.  SCSI-to-iSCSI Concepts Mapping Model\n   The following diagram shows
      an example of how multiple iSCSI nodes\n   (targets in this case) can coexist
      within the same Network Entity and\n   can share Network Portals (IP addresses
      and TCP ports).  Other more\n   complex configurations are also possible.  For
      detailed descriptions\n   of the components of these diagrams, see Section 4.4.1.\n
      \                +-----------------------------------+\n                 | Network
      Entity (iSCSI Client)     |\n                 |                                   |\n
      \                |          +-------------+          |\n                 |          |
      iSCSI Node  |          |\n                 |          | (Initiator) |          |\n
      \                |          +-------------+          |\n                 |              |
      \     |             |\n                 | +--------------+ +--------------+
      |\n                 | |Network Portal| |Network Portal| |\n                 |
      |   192.0.2.4  | |   192.0.2.5  | |\n                 +-+--------------+-+--------------+-+\n
      \                         |                  |\n                          |
      \  IP Networks    |\n                          |                  |\n                 +-+--------------+-+--------------+-+\n
      \                | |Network Portal| |Network Portal| |\n                 | |198.51.100.21
      | |198.51.100.3  | |\n                 | | TCP Port 3260| | TCP Port 3260| |\n
      \                | +--------------+ +--------------+ |\n                 |        |
      \                 |       |\n                 |         ------------------        |\n
      \                |            |          |           |\n                 | +-------------+
      +--------------+  |\n                 | | iSCSI Node  | | iSCSI Node   |  |\n
      \                | | (Target)    | | (Target)     |  |\n                 | +-------------+
      +--------------+  |\n                 |                                   |\n
      \                |   Network Entity (iSCSI Server)   |\n                 +-----------------------------------+\n"
    - contents:
      - "4.4.1.  iSCSI Architecture Model\n   This section describes the part of the
        iSCSI Architecture Model that\n   has the most bearing on the relationship
        between iSCSI and the SCSI\n   Architecture Model.\n      - Network Entity
        - represents a device or gateway that is\n        accessible from the IP network.
        \ A Network Entity must have one\n        or more Network Portals (see the
        \"Network Portal\" item below),\n        each of which can be used by some
        iSCSI nodes (see the next\n        item) contained in that Network Entity
        to gain access to the IP\n        network.\n      - iSCSI Node - represents
        a single iSCSI initiator or iSCSI\n        target, or an instance of each.
        \ There are one or more iSCSI\n        nodes within a Network Entity.  The
        iSCSI node is accessible via\n        one or more Network Portals (see below).
        \ An iSCSI node is\n        identified by its iSCSI name (see Sections 4.2.7
        and 13).  The\n        separation of the iSCSI name from the addresses used
        by and for\n        the iSCSI node allows multiple iSCSI nodes to use the
        same\n        addresses and allows the same iSCSI node to use multiple\n        addresses.\n
        \     - An alias string may also be associated with an iSCSI node.  The\n
        \       alias allows an organization to associate a user-friendly string\n
        \       with the iSCSI name.  However, the alias string is not a\n        substitute
        for the iSCSI name.\n      - Network Portal - a component of a Network Entity
        that has a\n        TCP/IP network address and that may be used by an iSCSI
        node\n        within that Network Entity for the connection(s) within one
        of\n        its iSCSI sessions.  In an initiator, it is identified by its
        IP\n        address.  In a target, it is identified by its IP address and\n
        \       its listening TCP port.\n      - Portal Groups - iSCSI supports multiple
        connections within the\n        same session; some implementations will have
        the ability to\n        combine connections in a session across multiple Network\n
        \       Portals.  A portal group defines a set of Network Portals within\n
        \       an iSCSI node that collectively supports the capability of\n        coordinating
        a session with connections that span these portals.\n        Not all Network
        Portals within a portal group need to\n        participate in every session
        connected through that portal\n        group.  One or more portal groups may
        provide access to an iSCSI\n        node.  Each Network Portal, as utilized
        by a given iSCSI node,\n        belongs to exactly one portal group within
        that node.  Portal\n        groups are identified within an iSCSI node by
        a Portal Group\n        Tag, a simple unsigned integer between 0 and 65535
        (see\n        Section 13.9).  All Network Portals with the same Portal Group\n
        \       Tag in the context of a given iSCSI node are in the same portal\n
        \       group.\n        Both iSCSI initiators and iSCSI targets have portal
        groups,\n        though only the iSCSI target portal groups are used directly
        in\n        the iSCSI protocol (e.g., in SendTargets).  For references to\n
        \       the initiator portal Groups, see Section 10.1.2.\n      - Portals
        within a portal group should support similar session\n        parameters,
        because they may participate in a common session.\n   The following diagram
        shows an example of one such configuration on a\n   target and how a session
        that shares Network Portals within a portal\n   group may be established.\n
        \      ----------------------------IP Network---------------------\n              |
        \               |                  |\n         +----|----------------|----+
        \       +----|---------+\n         | +---------+ +---------+  |        | +---------+
        \ |\n         | | Network | | Network |  |        | | Network |  |\n         |
        | Portal  | | Portal  |  |        | | Portal  |  |\n         | +---------+
        +---------+  |        | +---------+  |\n         |    |                |    |
        \       |    |         |\n         |    |    Portal      |    |        |    |
        Portal  |\n         |    |    Group 1     |    |        |    | Group 2 |\n
        \        +--------------------------+        +--------------+\n              |
        \               |                  |\n     +--------|----------------|------------------|------------------+\n
        \    |        |                |                  |                  |\n     |
        +----------------------------+ +----------------------------+ |\n     | |
        iSCSI Session (Target side)| | iSCSI Session (Target side)| |\n     | |                            |
        |                            | |\n     | |        (TSIH = 56)         | |
        \       (TSIH = 48)         | |\n     | +----------------------------+ +----------------------------+
        |\n     |                                                               |\n
        \    |                      iSCSI Target Node                        |\n     |
        \            (within Network Entity, not shown)                |\n     +---------------------------------------------------------------+\n"
      title: 4.4.1.  iSCSI Architecture Model
    - contents:
      - "4.4.2.  SCSI Architecture Model\n   This section describes the relationship
        between the SCSI Architecture\n   Model [SAM2] and constructs of the SCSI
        device, SCSI port and I_T\n   nexus, and the iSCSI constructs described in
        Section 4.4.1.\n   This relationship implies implementation requirements in
        order to\n   conform to the SAM-2 model and other SCSI operational functions.\n
        \  These requirements are detailed in Section 4.4.3.\n   The following list
        outlines mappings of SCSI architectural elements\n   to iSCSI.\n      a) SCSI
        Device - This is the SAM-2 term for an entity that\n         contains one
        or more SCSI ports that are connected to a service\n         delivery subsystem
        and supports a SCSI application protocol.\n         For example, a SCSI initiator
        device contains one or more SCSI\n         initiator ports and zero or more
        application clients.  A SCSI\n         target device contains one or more
        SCSI target ports and one or\n         more LUs.  For iSCSI, the SCSI device
        is the component within\n         an iSCSI node that provides the SCSI functionality.
        \ As such,\n         there can be at most one SCSI device within an iSCSI
        node.\n         Access to the SCSI device can only be achieved in an iSCSI\n
        \        Normal operational session (see Section 4.3).  The SCSI device\n
        \        name is defined to be the iSCSI name of the node and MUST be\n         used
        in the iSCSI protocol.\n      b) SCSI Port - This is the SAM-2 term for an
        entity in a SCSI\n         device that provides the SCSI functionality to
        interface with a\n         service delivery subsystem or transport.  For iSCSI,
        the\n         definitions of the SCSI initiator port and the SCSI target port\n
        \        are different.\n         SCSI initiator port: This maps to one endpoint
        of an iSCSI\n         Normal operational session (see Section 4.3).  An iSCSI
        Normal\n         operational session is negotiated through the login process\n
        \        between an iSCSI initiator node and an iSCSI target node.  At\n         successful
        completion of this process, a SCSI initiator port is\n         created within
        the SCSI initiator device.  The SCSI initiator\n         port Name and SCSI
        initiator port Identifier are both defined\n         to be the iSCSI Initiator
        Name together with (a) a label that\n         identifies it as an initiator
        port name/identifier and (b) the\n         ISID portion of the session identifier.\n
        \        SCSI target port: This maps to an iSCSI target portal group.\n         The
        SCSI Target Port Name and the SCSI Target Port Identifier\n         are both
        defined to be the iSCSI Target Name together with (a)\n         a label that
        identifies it as a target port name/identifier and\n         (b) the Target
        Portal Group Tag.\n         The SCSI port name MUST be used in iSCSI.  When
        used in SCSI\n         parameter data, the SCSI port name MUST be encoded
        as:\n         1) the iSCSI name in UTF-8 format, followed by\n         2)
        a comma separator (1 byte), followed by\n         3) the ASCII character 'i'
        (for SCSI initiator port) or the\n            ASCII character 't' (for SCSI
        target port) (1 byte),\n            followed by\n         4) a comma separator
        (1 byte), followed by\n         5) a text encoding as a hex-constant (see
        Section 6.1) of the\n            ISID (for SCSI initiator port) or the Target
        Portal Group\n            Tag (for SCSI target port), including the initial
        0X or 0x\n            and the terminating null (15 bytes for iSCSI initiator
        port,\n            7 bytes for iSCSI target port).\n            The ASCII
        character 'i' or 't' is the label that identifies\n            this port as
        either a SCSI initiator port or a SCSI target\n            port.\n      c)
        I_T nexus - This indicates a relationship between a SCSI\n         initiator
        port and a SCSI target port, according to [SAM2].\n         For iSCSI, this
        relationship is a session, defined as a\n         relationship between an
        iSCSI initiator's end of the session\n         (SCSI initiator port) and the
        iSCSI target's portal group.  The\n         I_T nexus can be identified by
        the conjunction of the SCSI port\n         names or by the iSCSI session identifier
        (SSID).  iSCSI defines\n         the I_T nexus identifier to be the tuple
        (iSCSI Initiator Name\n         + \",i,0x\" + ISID in text format, iSCSI Target
        Name + \",t,0x\" +\n         Target Portal Group Tag in text format).  An
        uppercase hex\n         prefix \"0X\" may alternatively be used in place of
        \"0x\".\n         NOTE: The I_T nexus identifier is not equal to the SSID.\n"
      title: 4.4.2.  SCSI Architecture Model
    - contents:
      - "4.4.3.  Consequences of the Model\n   This section describes implementation
        and behavioral requirements\n   that result from the mapping of SCSI constructs
        to the iSCSI\n   constructs defined above.  Between a given SCSI initiator
        port and a\n   given SCSI target port, only one I_T nexus (session) can exist.
        \ No\n   more than one nexus relationship (parallel nexus) is allowed by\n
        \  [SAM2].  Therefore, at any given time, only one session with the same\n
        \  SSID can exist between a given iSCSI initiator node and an iSCSI\n   target
        node.\n   These assumptions lead to the following conclusions and requirements:\n
        \  ISID RULE: Between a given iSCSI initiator and iSCSI target portal\n   group
        (SCSI target port), there can only be one session with a given\n   value for
        the ISID that identifies the SCSI initiator port.  See\n   Section 11.12.5.\n
        \  The structure of the ISID that contains a naming authority component\n
        \  (see Section 11.12.5 and [RFC3721]) provides a mechanism to\n   facilitate
        compliance with the ISID RULE.  See Section 10.1.1.\n   The iSCSI initiator
        node should manage the assignment of ISIDs prior\n   to session initiation.
        \ The \"ISID RULE\" does not preclude the use of\n   the same ISID from the
        same iSCSI initiator with different target\n   portal groups on the same iSCSI
        target or on other iSCSI targets (see\n   Section 10.1.1).  Allowing this
        would be analogous to a single SCSI\n   initiator port having relationships
        (nexus) with multiple SCSI target\n   ports on the same SCSI target device
        or SCSI target ports on other\n   SCSI target devices.  It is also possible
        to have multiple sessions\n   with different ISIDs to the same target portal
        group.  Each such\n   session would be considered to be with a different initiator
        even\n   when the sessions originate from the same initiator device.  The
        same\n   ISID may be used by a different iSCSI initiator because it is the\n
        \  iSCSI name together with the ISID that identifies the SCSI initiator\n
        \  port.\n   NOTE: A consequence of the ISID RULE and the specification for
        the\n   I_T nexus identifier is that two nexuses with the same identifier\n
        \  should never exist at the same time.\n   TSIH RULE: The iSCSI target selects
        a non-zero value for the TSIH at\n   session creation (when an initiator presents
        a 0 value at login).\n   After being selected, the same TSIH value MUST be
        used whenever the\n   initiator or target refers to the session and a TSIH
        is required.\n"
      - contents:
        - "4.4.3.1.  I_T Nexus State\n   Certain nexus relationships contain an explicit
          state (e.g.,\n   initiator-specific mode pages) that may need to be preserved
          by the\n   device server [SAM2] in a LU through changes or failures in the
          iSCSI\n   layer (e.g., session failures).  In order for that state to be\n
          \  restored, the iSCSI initiator should reestablish its session\n   (re-login)
          to the same target portal group using the previous ISID.\n   That is, it
          should reinstate the session via iSCSI session\n   reinstatement (Section
          6.3.5) or continue via session continuation\n   (Section 6.3.6).  This is
          because the SCSI initiator port identifier\n   and the SCSI target port
          identifier (or relative target port) form\n   the datum that the SCSI LU
          device server uses to identify the I_T\n   nexus.\n"
        title: 4.4.3.1.  I_T Nexus State
      - contents:
        - "4.4.3.2.  Reservations\n   There are two reservation management methods
          defined in the SCSI\n   standards: reserve/release reservations, based on
          the RESERVE and\n   RELEASE commands [SPC2]; and persistent reservations,
          based on the\n   PERSISTENT RESERVE IN and PERSISTENT RESERVE OUT commands
          [SPC3].\n   Reserve/release reservations are obsolete [SPC3] and should
          not be\n   used.  Persistent reservations are suggested as an alternative;
          see\n   Annex B of [SPC4].\n   State for persistent reservations is required
          to persist through\n   changes and failures at the iSCSI layer that result
          in I_T nexus\n   failures; see [SPC3] for details and specific requirements.\n
          \  In contrast, [SPC2] does not specify detailed persistence\n   requirements
          for reserve/release reservation state after an I_T nexus\n   failure.  Nonetheless,
          when reserve/release reservations are\n   supported by an iSCSI target,
          the preferred implementation approach\n   is to preserve reserve/release
          reservation state for iSCSI session\n   reinstatement (see Section 6.3.5)
          or session continuation (see\n   Section 6.3.6).\n   Two additional caveats
          apply to reserve/release reservations:\n      - Retention of a failed session's
          reserve/release reservation\n        state by an iSCSI target, even after
          that failed iSCSI session\n        is not reinstated or continued, may require
          an initiator to\n        issue a reset (e.g., LOGICAL UNIT RESET; see Section
          11.5) in\n        order to remove that reservation state.\n      - Reserve/release
          reservations may not behave as expected when\n        persistent reservations
          are also used on the same LU; see the\n        discussion of \"Exceptions
          to SPC-2 RESERVE and RELEASE behavior\"\n        in [SPC4].\n"
        title: 4.4.3.2.  Reservations
      title: 4.4.3.  Consequences of the Model
    title: 4.4.  SCSI-to-iSCSI Concepts Mapping Model
  - contents:
    - "4.5.  iSCSI UML Model\n   This section presents the application of the UML
      modeling concepts\n   discussed in Section 3 to the iSCSI and SCSI Architecture
      Model\n   discussed in Section 4.4.\n                       +----------------+\n
      \                      | Network Entity |\n                       +----------------+\n
      \                           @ 1     @ 1\n                            |       |\n
      \    +----------------------+       |\n     |                              |\n
      \    |                              | 0..*\n     |                   +------------------+\n
      \    |                   | iSCSI Node       |\n     |                   +------------------+\n
      \    |                       @       @\n     |                       |       |\n
      \    |           +-----------+ =(a)= +-----------+\n     |           |                               |\n
      \    |           | 0..1                          | 0..1\n     | +------------------------+
      \      +----------------------+\n     | |    iSCSI Target Node   |       | iSCSI
      Initiator Node |\n     | +------------------------+       +----------------------+\n
      \    |             @ 1                            @ 1\n     |             +---------------+
      \             |\n     |                        1..* |              | 1..*\n
      \    |                    +-----------------------------+\n     |                    |
      \        Portal Group        |\n     |                    +-----------------------------+\n
      \    |                                     O 1\n     |                                     |\n
      \    |                                     | 1..*\n     |               1..*
      +------------------------+\n     +--------------------|        Network Portal
      \ |\n                          +------------------------+\n   (a) Each instance
      of an iSCSI node class MUST contain one iSCSI\n       target node instance,
      one iSCSI initiator node instance, or both.\n                    +----------------+\n
      \                   | Network Entity |\n                    +----------------+\n
      \                        @ 1         @ 1\n                         |           |
      \             +------------------+\n   +---------------------+           |              |
      \  iSCSI Session  |\n   |                                 |              +------------------+\n
      \  |                                 | 0..*         |     SSID[1]      |\n   |
      \                 +--------------------+        |     ISID[1]      |\n   |                  |
      \     iSCSI Node    |        +------------------+\n   |                  +--------------------+
      \                  @ 1\n   |                  | iSCSI Node Name[1] |                   |\n
      \  |                  |    Alias [0..1]    |                   | 0..*\n   |
      \                 +--------------------+        +------------------+\n   |                  |
      \                   |        | iSCSI Connection |\n   |                  +--------------------+
      \       +------------------+\n   |                         @ 1         @ 1        |
      \     CID[1]      |\n   |                         |           |          +------------------+\n
      \  |           +-------------+ ==(b)==   +---------+              0..* |\n   |
      \          | 1                                 | 1                 |\n   | +------------------------+
      \            +------------------------+ |\n   | |   iSCSI Target Node    |             |
      iSCSI Initiator Node   | |\n   | +------------------------+             +------------------------+
      |\n   | | iSCSI Target Name [1]  |             |iSCSI Initiator Name [1]| |\n
      \  | +------------------------+             +------------------------+ |\n   |
      \           @ 1                                    @ 1             |\n   |            |
      1..*                                 | 1..*          |\n   | +--------------------------+
      \          +------------------------+ |\n   | |   Target Portal Group    |           |
      Initiator Portal Group | |\n   | +--------------------------+           +------------------------+
      |\n   | |Target Portal Group Tag[1]|           | Portal Group Tag[1]    | |\n
      \  | +--------------------------+           +------------------------+ |\n   |
      \           o 1                                    o 1             |\n   |            +------------+
      \             +----------+               |\n   |                    1..* |              |
      1..*                     |\n   |                +-------------------------+
      \                       |\n   |                |          Network Portal |                        |\n
      \  |                +-------------------------+                        |\n   |
      \         1..*  |         IP Address [1]  | 1                      |\n   +----------------|
      \        TCP Port [0..1] |<-----------------------+\n                    +-------------------------+\n
      \  (b) Each instance of an iSCSI node class MUST contain one iSCSI\n       target
      node instance, one iSCSI initiator node instance, or both.\n       However,
      in all scenarios, note that an iSCSI node MUST only have\n       a single iSCSI
      name.  Note the related requirement in\n       Section 4.2.7.1.\n"
    title: 4.5.  iSCSI UML Model
  - contents:
    - "4.6.  Request/Response Summary\n   This section lists and briefly describes
      all the iSCSI PDU types\n   (requests and responses).\n   All iSCSI PDUs are
      built as a set of one or more header segments\n   (basic and auxiliary) and
      zero or one data segments.  The header\n   group and the data segment may each
      be followed by a CRC (digest).\n   The basic header segment has a fixed length
      of 48 bytes.\n"
    - contents:
      - '4.6.1.  Request/Response Types Carrying SCSI Payload

        '
      - contents:
        - "4.6.1.1.  SCSI Command\n   This request carries the SCSI CDB and all the
          other SCSI Execute\n   Command [SAM2] procedure call IN arguments, such
          as task attributes,\n   Expected Data Transfer Length for one or both transfer
          directions\n   (the latter for bidirectional commands), and a task tag (as
          part of\n   the I_T_L_x nexus).  The I_T_L nexus is derived by the initiator
          and\n   target from the LUN field in the request, and the I_T nexus is\n
          \  implicit in the session identification.\n   In addition, the SCSI Command
          PDU carries information required for\n   the proper operation of the iSCSI
          protocol -- the command sequence\n   number (CmdSN) and the expected status
          sequence number (ExpStatSN) on\n   the connection it is issued.\n   All
          or part of the SCSI output (write) data associated with the SCSI\n   command
          may be sent as part of the SCSI Command PDU as a data\n   segment.\n"
        title: 4.6.1.1.  SCSI Command
      - contents:
        - "4.6.1.2.  SCSI Response\n   The SCSI Response carries all the SCSI Execute
          Command procedure call\n   (see [SAM2]) OUT arguments and the SCSI Execute
          Command procedure\n   call return value.\n   The SCSI Response contains
          the residual counts from the operation, if\n   any; an indication of whether
          the counts represent an overflow or an\n   underflow; and the SCSI status
          if the status is valid or a response\n   code (a non-zero return value for
          the Execute Command procedure call)\n   if the status is not valid.\n   For
          a valid status that indicates that the command has been processed\n   but
          resulted in an exception (e.g., a SCSI CHECK CONDITION), the PDU\n   data
          segment contains the associated sense data.  The use of\n   Autosense ([SAM2])
          is REQUIRED by iSCSI.\n   Some data segment content may also be associated
          (in the data\n   segment) with a non-zero response code.\n   In addition,
          the SCSI Response PDU carries information required for\n   the proper operation
          of the iSCSI protocol:\n      - ExpDataSN - the number of Data-In PDUs that
          a target has sent\n        (to enable the initiator to check that all have
          arrived)\n      - StatSN - the status sequence number on this connection\n
          \     - ExpCmdSN - the next expected command sequence number at the\n        target\n
          \     - MaxCmdSN - the maximum CmdSN acceptable at the target from this\n
          \       initiator\n"
        title: 4.6.1.2.  SCSI Response
      - contents:
        - "4.6.1.3.  Task Management Function Request\n   The Task Management Function
          Request provides an initiator with a way\n   to explicitly control the execution
          of one or more SCSI tasks or\n   iSCSI functions.  The PDU carries a function
          identifier (i.e., which\n   task management function to perform) and enough
          information to\n   unequivocally identify the task or task set on which
          to perform the\n   action, even if the task(s) to act upon has not yet arrived
          or has\n   been discarded due to an error.\n   The referenced tag identifies
          an individual task if the function\n   refers to an individual task.\n   The
          I_T_L nexus identifies task sets.  In iSCSI, the I_T_L nexus is\n   identified
          by the LUN and the session identification (the session\n   identifies an
          I_T nexus).\n   For task sets, the CmdSN of the Task Management Function
          Request\n   helps identify the tasks upon which to act, namely all tasks\n
          \  associated with a LUN and having a CmdSN preceding the Task\n   Management
          Function Request CmdSN.\n   For a task management function, the coordination
          between responses to\n   the tasks affected and the Task Management Function
          Response is done\n   by the target.\n"
        title: 4.6.1.3.  Task Management Function Request
      - contents:
        - "4.6.1.4.  Task Management Function Response\n   The Task Management Function
          Response carries an indication of\n   function completion for a Task Management
          Function Request, including\n   how it completed (response and qualifier)
          and additional information\n   for failure responses.\n   After the Task
          Management Function Response indicates task management\n   function completion,
          the initiator will not receive any additional\n   responses from the affected
          tasks.\n"
        title: 4.6.1.4.  Task Management Function Response
      - contents:
        - "4.6.1.5.  SCSI Data-Out and SCSI Data-In\n   SCSI Data-Out and SCSI Data-In
          are the main vehicles by which SCSI\n   data payload is carried between
          the initiator and target.  Data\n   payload is associated with a specific
          SCSI command through the\n   Initiator Task Tag.  For target convenience,
          outgoing solicited data\n   also carries a Target Transfer Tag (copied from
          R2T) and the LUN.\n   Each PDU contains the payload length and the data
          offset relative to\n   the buffer address contained in the SCSI Execute
          Command procedure\n   call.\n   In each direction, the data transfer is
          split into \"sequences\".  An\n   end-of-sequence is indicated by the F
          bit.\n   An outgoing sequence is either unsolicited (only the first sequence\n
          \  can be unsolicited) or consists of all the Data-Out PDUs sent in\n   response
          to an R2T.\n   Input sequences enable the switching of direction for bidirectional\n
          \  commands as required.\n   For input, the target may request positive
          acknowledgment of input\n   data.  This is limited to sessions that support
          error recovery and is\n   implemented through the A bit in the SCSI Data-In
          PDU header.\n   Data-In and Data-Out PDUs also carry the DataSN to enable
          the\n   initiator and target to detect missing PDUs (discarded due to an\n
          \  error).\n   In addition, the StatSN is carried by the Data-In PDUs.\n
          \  To enable a SCSI command to be processed while involving a minimum\n
          \  number of messages, the last SCSI Data-In PDU passed for a command\n
          \  may also contain the status if the status indicates termination with\n
          \  no exceptions (no sense or response involved).\n"
        title: 4.6.1.5.  SCSI Data-Out and SCSI Data-In
      - contents:
        - "4.6.1.6.  Ready To Transfer (R2T)\n   R2T is the mechanism by which the
          SCSI target \"requests\" the\n   initiator for output data.  R2T specifies
          to the initiator the offset\n   of the requested data relative to the buffer
          address from the Execute\n   Command procedure call and the length of the
          solicited data.\n   To help the SCSI target associate the resulting Data-Out
          with an R2T,\n   the R2T carries a Target Transfer Tag that will be copied
          by the\n   initiator in the solicited SCSI Data-Out PDUs.  There are no\n
          \  protocol-specific requirements with regard to the value of these\n   tags,
          but it is assumed that together with the LUN, they will enable\n   the target
          to associate data with an R2T.\n   R2T also carries information required
          for proper operation of the\n   iSCSI protocol, such as:\n      - R2TSN
          (to enable an initiator to detect a missing R2T)\n      - StatSN\n      -
          ExpCmdSN\n      - MaxCmdSN\n"
        title: 4.6.1.6.  Ready To Transfer (R2T)
      title: 4.6.1.  Request/Response Types Carrying SCSI Payload
    - contents:
      - '4.6.2.  Requests/Responses Carrying SCSI and iSCSI Payload

        '
      - contents:
        - "4.6.2.1.  Asynchronous Message\n   Asynchronous Message PDUs are used to
          carry SCSI asynchronous event\n   notifications (AENs) and iSCSI asynchronous
          messages.\n   When carrying an AEN, the event details are reported as sense
          data in\n   the data segment.\n"
        title: 4.6.2.1.  Asynchronous Message
      title: 4.6.2.  Requests/Responses Carrying SCSI and iSCSI Payload
    - contents:
      - '4.6.3.  Requests/Responses Carrying iSCSI-Only Payload

        '
      - contents:
        - "4.6.3.1.  Text Requests and Text Responses\n   Text Requests and Responses
          are designed as a parameter negotiation\n   vehicle and as a vehicle for
          future extension.\n   In the data segment, Text Requests/Responses carry
          text information\n   using a simple \"key=value\" syntax.\n   Text Requests/Responses
          may form extended sequences using the same\n   Initiator Task Tag.  The
          initiator uses the F (Final) flag bit in the\n   Text Request header to
          indicate its readiness to terminate a\n   sequence.  The target uses the
          F bit in the Text Response header to\n   indicate its consent to sequence
          termination.\n   Text Requests and Responses also use the Target Transfer
          Tag to\n   indicate continuation of an operation or a new beginning.  A
          target\n   that wishes to continue an operation will set the Target Transfer
          Tag\n   in a Text Response to a value different from the default 0xffffffff.\n
          \  An initiator willing to continue will copy this value into the Target\n
          \  Transfer Tag of the next Text Request.  If the initiator wants to\n   restart
          the current target negotiation (start fresh), it will set the\n   Target
          Transfer Tag to 0xffffffff.\n   Although a complete exchange is always started
          by the initiator,\n   specific parameter negotiations may be initiated by
          the initiator or\n   target.\n"
        title: 4.6.3.1.  Text Requests and Text Responses
      - contents:
        - "4.6.3.2.  Login Requests and Login Responses\n   Login Requests and Responses
          are used exclusively during the Login\n   Phase of each connection to set
          up the session and connection\n   parameters.  (The Login Phase consists
          of a sequence of Login\n   Requests and Responses carrying the same Initiator
          Task Tag.)\n   A connection is identified by an arbitrarily selected connection
          ID\n   (CID) that is unique within a session.\n   Similar to the Text Requests
          and Responses, Login Requests/Responses\n   carry key=value text information
          with a simple syntax in the data\n   segment.\n   The Login Phase proceeds
          through several stages (security\n   negotiation, operational parameter
          negotiation) that are selected\n   with two binary coded fields in the header
          -- the Current Stage (CSG)\n   and the Next Stage (NSG) -- with the appearance
          of the latter being\n   signaled by the \"Transit\" flag (T).\n   The first
          Login Phase of a session plays a special role, called the\n   leading login,
          which determines some header fields (e.g., the version\n   number, the maximum
          number of connections, and the session\n   identification).\n   The CmdSN
          initial value is also set by the leading login.\n   The StatSN for each
          connection is initiated by the connection login.\n   A Login Request may
          indicate an implied logout (cleanup) of the\n   connection to be logged
          in (a connection restart) by using the same\n   connection ID (CID) as an
          existing connection as well as the same\n   session-identifying elements
          of the session to which the old\n   connection was associated.\n"
        title: 4.6.3.2.  Login Requests and Login Responses
      - contents:
        - "4.6.3.3.  Logout Requests and Logout Responses\n   Logout Requests and
          Responses are used for the orderly closing of\n   connections for recovery
          or maintenance.  The Logout Request may be\n   issued following a target
          prompt (through an Asynchronous Message) or\n   at an initiator's initiative.
          \ When issued on the connection to be\n   logged out, no other request may
          follow it.\n   The Logout Response indicates that the connection or session
          cleanup\n   is completed and no other responses will arrive on the connection
          (if\n   received on the logging-out connection).  In addition, the Logout\n
          \  Response indicates how long the target will continue to hold\n   resources
          for recovery (e.g., command execution that continues on a\n   new connection)
          in the Time2Retain field and how long the initiator\n   must wait before
          proceeding with recovery in the Time2Wait field.\n"
        title: 4.6.3.3.  Logout Requests and Logout Responses
      - contents:
        - "4.6.3.4.  SNACK Request\n   With the SNACK Request, the initiator requests
          retransmission of\n   numbered responses or data from the target.  A single
          SNACK Request\n   covers a contiguous set of missing items, called a run,
          of a given\n   type of items.  The type is indicated in a type field in
          the PDU\n   header.  The run is composed of an initial item (StatSN, DataSN,\n
          \  R2TSN) and the number of missed Status, Data, or R2T PDUs.  For long\n
          \  Data-In sequences, the target may request (at predefined minimum\n   intervals)
          a positive acknowledgment for the data sent.  A SNACK\n   Request with a
          type field that indicates ACK and the number of\n   Data-In PDUs acknowledged
          conveys this positive acknowledgment.\n"
        title: 4.6.3.4.  SNACK Request
      - contents:
        - "4.6.3.5.  Reject\n   Reject enables the target to report an iSCSI error
          condition (e.g.,\n   protocol, unsupported option) that uses a Reason field
          in the PDU\n   header and includes the complete header of the bad PDU in
          the Reject\n   PDU data segment.\n"
        title: 4.6.3.5.  Reject
      - contents:
        - "4.6.3.6.  NOP-Out Request and NOP-In Response\n   This request/response
          pair may be used by an initiator and target as\n   a \"ping\" mechanism
          to verify that a connection/session is still\n   active and all of its components
          are operational.  Such a ping may be\n   triggered by the initiator or target.
          \ The triggering party indicates\n   that it wants a reply by setting a
          value different from the default\n   0xffffffff in the corresponding Initiator/Target
          Transfer Tag.\n   NOP-In/NOP-Out may also be used in \"unidirectional\"
          fashion to convey\n   to the initiator/target command, status, or data counter
          values when\n   there is no other \"carrier\" and there is a need to update
          the\n   initiator/target.\n"
        title: 4.6.3.6.  NOP-Out Request and NOP-In Response
      title: 4.6.3.  Requests/Responses Carrying iSCSI-Only Payload
    title: 4.6.  Request/Response Summary
  title: 4.  Overview
- contents:
  - "5.  SCSI Mode Parameters for iSCSI\n   There are no iSCSI-specific mode pages.\n"
  title: 5.  SCSI Mode Parameters for iSCSI
- contents:
  - "6.  Login and Full Feature Phase Negotiation\n   iSCSI parameters are negotiated
    at session or connection\n   establishment by using Login Requests and Responses
    (see\n   Section 4.2.4) and during the Full Feature Phase (Section 4.2.5) by\n
    \  using Text Requests and Responses.  In both cases, the mechanism used\n   is
    an exchange of iSCSI-text-key=value pairs.  For brevity,\n   iSCSI-text-keys are
    called just \"keys\" in the rest of this document.\n   Keys are either declarative
    or require negotiation, and the key\n   description indicates whether the key
    is declarative or requires\n   negotiation.\n   For the declarative keys, the
    declaring party sets a value for the\n   key.  The key specification indicates
    whether the key can be declared\n   by the initiator, the target, or both.\n   For
    the keys that require negotiation, one of the parties (the\n   proposing party)
    proposes a value or set of values by including the\n   key=value in the data part
    of a Login or Text Request or Response.\n   The other party (the accepting party)
    makes a selection based on the\n   value or list of values proposed and includes
    the selected value in a\n   key=value in the data part of the following Login
    or Text Response or\n   Request.  For most of the keys, both the initiator and
    target can be\n   proposing parties.\n   The login process proceeds in two stages
    -- the security negotiation\n   stage and the operational parameter negotiation
    stage.  Both stages\n   are optional, but at least one of them has to be present
    to enable\n   setting some mandatory parameters.\n   If present, the security
    negotiation stage precedes the operational\n   parameter negotiation stage.\n
    \  Progression from stage to stage is controlled by the T (Transit) bit\n   in
    the Login Request/Response PDU header.  Through the T bit set\n   to 1, the initiator
    indicates that it would like to transition.  The\n   target agrees to the transition
    (and selects the next stage) when\n   ready.  A field in the Login PDU header
    indicates the current stage\n   (CSG), and during transition, another field indicates
    the next stage\n   (NSG) proposed (initiator) and selected (target).\n   The text
    negotiation process is used to negotiate or declare\n   operational parameters.
    \ The negotiation process is controlled by the\n   F (Final) bit in the PDU header.
    \ During text negotiations, the F bit\n   is used by the initiator to indicate
    that it is ready to finish the\n   negotiation and by the target to acquiesce
    the end of negotiation.\n   Since some key=value pairs may not fit entirely in
    a single PDU, the\n   C (Continue) bit is used (both in Login and Text) to indicate
    that\n   \"more follows\".\n   The text negotiation uses an additional mechanism
    by which a target\n   may deliver larger amounts of data to an inquiring initiator.
    \ The\n   target sets a Target Task Tag to be used as a bookmark that, when\n
    \  returned by the initiator, means \"go on\".  If reset to a \"neutral\n   value\",
    it means \"forget about the rest\".\n   This section details the types of keys
    and values used, the syntax\n   rules for parameter formation, and the negotiation
    schemes to be used\n   with different types of parameters.\n"
  - contents:
    - "6.1.  Text Format\n   The initiator and target send a set of key=value pairs
      encoded in\n   UTF-8 Unicode.  All the text keys and text values specified in
      this\n   document are case sensitive; they are to be presented and interpreted\n
      \  as they appear in this document without change of case.\n   The following
      character symbols are used in this document for text\n   items (the hexadecimal
      values represent Unicode code points):\n   (a-z, A-Z) (0x61-0x7a, 0x41-0x5a)
      - letters\n                   (0-9) (0x30-0x39) - digits\n                          \"
      \" (0x20) - space\n                          \".\" (0x2e) - dot\n                          \"-\"
      (0x2d) - minus\n                          \"+\" (0x2b) - plus\n                          \"@\"
      (0x40) - commercial at\n                          \"_\" (0x5f) - underscore\n
      \                         \"=\" (0x3d) - equal\n                          \":\"
      (0x3a) - colon\n                          \"/\" (0x2f) - solidus or slash\n
      \                         \"[\" (0x5b) - left bracket\n                          \"]\"
      (0x5d) - right bracket\n                         null (0x00) - null separator\n
      \                         \",\" (0x2c) - comma\n                          \"~\"
      (0x7e) - tilde\n   Key=value pairs may span PDU boundaries.  An initiator or
      target that\n   sends partial key=value text within a PDU indicates that more
      text\n   follows by setting the C bit in the Text or Login Request or the Text\n
      \  or Login Response to 1.  Data segments in a series of PDUs that have\n   the
      C bit set to 1 and end with a PDU that has the C bit set to 0, or\n   that include
      a single PDU that has the C bit set to 0, have to be\n   considered as forming
      a single logical-text-data-segment (LTDS).\n   Every key=value pair, including
      the last or only pair in a LTDS, MUST\n   be followed by one null (0x00) delimiter.\n
      \  A key-name is whatever precedes the first \"=\" in the key=value pair.\n
      \  The term \"key\" is used frequently in this document in place of\n   \"key-name\".\n
      \  A value is whatever follows the first \"=\" in the key=value pair up to\n
      \  the end of the key=value pair, but not including the null delimiter.\n   The
      following definitions will be used in the rest of this document:\n      - standard-label:
      A string of one or more characters that consists\n        of letters, digits,
      dot, minus, plus, commercial at, or\n        underscore.  A standard-label MUST
      begin with a capital letter\n        and must not exceed 63 characters.\n      -
      key-name: A standard-label.\n      - text-value: A string of zero or more characters
      that consists of\n        letters, digits, dot, minus, plus, commercial at,
      underscore,\n        slash, left bracket, right bracket, or colon.\n      -
      iSCSI-name-value: A string of one or more characters that\n        consists
      of minus, dot, colon, or any character allowed by the\n        output of the
      iSCSI stringprep template as specified in\n        [RFC3722] (see also Section
      4.2.7.2).\n      - iSCSI-local-name-value: A UTF-8 string; no null characters
      are\n        allowed in the string.  This encoding is to be used for\n        localized
      (internationalized) aliases.\n      - boolean-value: The string \"Yes\" or \"No\".\n
      \     - hex-constant: A hexadecimal constant encoded as a string that\n        starts
      with \"0x\" or \"0X\" followed by one or more digits or the\n        letters
      a, b, c, d, e, f, A, B, C, D, E, or F.  Hex-constants\n        are used to encode
      numerical values or binary strings.  When\n        used to encode numerical
      values, the excessive use of leading 0\n        digits is discouraged.  The
      string following 0X (or 0x)\n        represents a base16 number that starts
      with the most significant\n        base16 digit, followed by all other digits
      in decreasing order\n        of significance and ending with the least significant
      base16\n        digit.  When used to encode binary strings, hexadecimal\n        constants
      have an implicit byte-length that includes four bits\n        for every hexadecimal
      digit of the constant, including leading\n        zeroes.  For example, a hex-constant
      of n hexadecimal digits has\n        a byte-length of (the integer part of)
      (n + 1)/2.\n      - decimal-constant: An unsigned decimal number with the digit
      0 or\n        a string of one or more digits that starts with a non-zero\n        digit.
      \ Decimal-constants are used to encode numerical values or\n        binary strings.
      \ Decimal-constants can only be used to encode\n        binary strings if the
      string length is explicitly specified.\n        There is no implicit length
      for decimal strings.\n        Decimal-constants MUST NOT be used for parameter
      values if the\n        values can be equal to or greater than 2**64 (numerical)
      or for\n        binary strings that can be longer than 64 bits.\n      - base64-constant:
      Base64 constant encoded as a string that starts\n        with \"0b\" or \"0B\"
      followed by 1 or more digits, letters, plus\n        sign, slash, or equals
      sign.  The encoding is done according to\n        [RFC4648].\n      - numerical-value:
      An unsigned integer always less than 2**64\n        encoded as a decimal-constant
      or a hex-constant.  Unsigned\n        integer arithmetic applies to numerical-values.\n
      \     - large-numerical-value: An unsigned integer that can be larger\n        than
      or equal to 2**64 encoded as a hex-constant or\n        base64-constant.  Unsigned
      integer arithmetic applies to large-\n        numerical-values.\n      - numerical-range:
      Two numerical-values separated by a tilde,\n        where the value to the right
      of the tilde must not be lower than\n        the value to the left.\n      -
      regular-binary-value: A binary string not longer than 64 bits\n        encoded
      as a decimal-constant, hex-constant, or base64-constant.\n        The length
      of the string is either specified by the key\n        definition or is the implicit
      byte-length of the encoded string.\n      - large-binary-value: A binary string
      longer than 64 bits encoded\n        as a hex-constant or base64-constant.  The
      length of the string\n        is either specified by the key definition or is
      the implicit\n        byte-length of the encoded string.\n      - binary-value:
      A regular-binary-value or a large-binary-value.\n        Operations on binary
      values are key-specific.\n      - simple-value: Text-value, iSCSI-name-value,
      boolean-value,\n        numerical-value, a numerical-range, or a binary-value.\n
      \     - list-of-values: A sequence of text-values separated by a comma.\n   If
      not otherwise specified, the maximum length of a simple-value (not\n   its encoded
      representation) is 255 bytes, not including the delimiter\n   (comma or zero
      byte).\n   Any iSCSI target or initiator MUST support receiving at least\n   8192
      bytes of key=value data in a negotiation sequence.  When\n   proposing or accepting
      authentication methods that explicitly require\n   support for very long authentication
      items, the initiator and target\n   MUST support receiving at least 64 kilobytes
      of key=value data.\n"
    title: 6.1.  Text Format
  - contents:
    - "6.2.  Text Mode Negotiation\n   During login, and thereafter, some session
      or connection parameters\n   are either declared or negotiated through an exchange
      of textual\n   information.\n   The initiator starts the negotiation and/or
      declaration through a\n   Text or Login Request and indicates when it is ready
      for completion\n   (by setting the F bit to 1 and keeping it at 1 in a Text
      Request, or\n   the T bit in the Login Request).  As negotiation text may span
      PDU\n   boundaries, a Text or Login Request or a Text or Login Response PDU\n
      \  that has the C bit set to 1 MUST NOT have the F bit or T bit set\n   to 1.\n
      \  A target receiving a Text or Login Request with the C bit set to 1\n   MUST
      answer with a Text or Login Response with no data segment\n   (DataSegmentLength
      0).  An initiator receiving a Text or Login\n   Response with the C bit set
      to 1 MUST answer with a Text or Login\n   Request with no data segment (DataSegmentLength
      0).\n   A target or initiator SHOULD NOT use a Text or Login Response or a\n
      \  Text or Login Request with no data segment (DataSegmentLength 0)\n   unless
      explicitly required by a general or a key-specific negotiation\n   rule.\n   There
      MUST NOT be more than one outstanding Text Request, or Text\n   Response PDU
      on an iSCSI connection.  An outstanding PDU in this\n   context is one that
      has not been acknowledged by the remote iSCSI\n   side.\n   The format of a
      declaration is:\n      Declarer-> <key>=<valuex>\n   The general format of text
      negotiation is:\n      Proposer-> <key>=<valuex>\n      Acceptor-> <key>={<valuey>|NotUnderstood|Irrelevant|Reject}\n
      \  Thus, a declaration is a one-way textual exchange (unless the key is\n   not
      understood by the receiver), while a negotiation is a two-way\n   exchange.\n
      \  The proposer or declarer can be either the initiator or the target,\n   and
      the acceptor can be either the target or initiator, respectively.\n   Targets
      are not limited to respond to key=value pairs as proposed by\n   the initiator.
      \ The target may propose key=value pairs of its own.\n   All negotiations are
      explicit (i.e., the result MUST only be based on\n   newly exchanged or declared
      values).  There are no implicit\n   proposals.  If a proposal is not made, then
      a reply cannot be\n   expected.  Conservative design also requires that default
      values\n   should not be relied upon when the use of some other value has\n
      \  serious consequences.\n   The value proposed or declared can be a numerical-value,
      a numerical-\n   range defined by the lower and upper value with both integers\n
      \  separated by a tilde, a binary value, a text-value, an iSCSI-name-\n   value,
      an iSCSI-local-name-value, a boolean-value (Yes or No), or a\n   list of comma-separated
      text-values.  A range, a large-numerical-\n   value, an iSCSI-name-value, and
      an iSCSI-local-name-value MAY ONLY be\n   used if explicitly allowed.  An accepted
      value can be a numerical-\n   value, a large-numerical-value, a text-value,
      or a boolean-value.\n   If a specific key is not relevant for the current negotiation,
      the\n   acceptor may answer with the constant \"Irrelevant\" for all types of\n
      \  negotiations.  However, the negotiation is not considered to have\n   failed
      if the answer is \"Irrelevant\".  The \"Irrelevant\" answer is\n   meant for
      those cases in which several keys are presented by a\n   proposing party but
      the selection made by the acceptor for one of the\n   keys makes other keys
      irrelevant.  The following example illustrates\n   the use of \"Irrelevant\":\n
      \     I->T InitialR2T=No,ImmediateData=Yes,FirstBurstLength=4192\n      T->I
      InitialR2T=Yes,ImmediateData=No,FirstBurstLength=Irrelevant\n      I->T X-rdname-vkey1=(bla,alb,None),
      X-rdname-vkey2=(bla,alb)\n      T->I X-rdname-vkey1=None, X-rdname-vkey2=Irrelevant\n
      \  Any key not understood by the acceptor may be ignored by the acceptor\n   without
      affecting the basic function.  However, the answer for a key\n   that is not
      understood MUST be key=NotUnderstood.  Note that\n   NotUnderstood is a valid
      answer for both declarative and negotiated\n   keys.  The general iSCSI philosophy
      is that comprehension precedes\n   processing for any iSCSI key.  A proposer
      of an iSCSI key, negotiated\n   or declarative, in a text key exchange MUST
      thus be able to properly\n   handle a NotUnderstood response.\n   The proper
      way to handle a NotUnderstood response depends on where\n   the key is specified
      and whether the key is declarative or\n   negotiated.  An iSCSI implementation
      MUST comprehend all text keys\n   defined in this document.  Returning a NotUnderstood
      response on any\n   of these text keys therefore MUST be considered a protocol
      error and\n   handled accordingly.  For all other \"later\" keys, i.e., text
      keys\n   defined in later specifications, a NotUnderstood answer concludes the\n
      \  negotiation for a negotiated key, whereas for a declarative key a\n   NotUnderstood
      answer simply informs the declarer of a lack of\n   comprehension by the receiver.\n
      \  In either case, a NotUnderstood answer always requires that the\n   protocol
      behavior associated with that key not be used within the\n   scope of the key
      (connection/session) by either side.\n   The constants \"None\", \"Reject\",
      \"Irrelevant\", and \"NotUnderstood\" are\n   reserved and MUST ONLY be used
      as described here.  Violation of this\n   rule is a protocol error (in particular,
      the use of \"Reject\",\n   \"Irrelevant\", and \"NotUnderstood\" as proposed
      values).\n   \"Reject\" or \"Irrelevant\" are legitimate negotiation options
      where\n   allowed, but their excessive use is discouraged.  A negotiation is\n
      \  considered complete when the acceptor has sent the key value pair\n   even
      if the value is \"Reject\", \"Irrelevant\", or \"NotUnderstood\".\n   Sending
      the key again would be a renegotiation and is forbidden for\n   many keys.\n
      \  If the acceptor sends \"Reject\" as an answer, the negotiated key is\n   left
      at its current value (or default if no value was set).  If the\n   current value
      is not acceptable to the proposer on the connection or\n   to the session in
      which it is sent, the proposer MAY choose to\n   terminate the connection or
      session.\n   All keys in this document MUST be supported by iSCSI initiators
      and\n   targets when used as specified here.  If used as specified, these\n
      \  keys MUST NOT be answered with NotUnderstood.\n   Implementers may introduce
      new private keys by prefixing them with X-\n   followed by their (reverse) domain
      name, or with new public keys\n   registered with IANA.  For example, the entity
      owning the domain\n   example.com can issue:\n      X-com.example.bar.foo.do_something=3\n
      \  Each new public key in the course of standardization MUST define the\n   acceptable
      responses to the key, including NotUnderstood as\n   appropriate.  Unlike [RFC3720],
      note that this document prohibits the\n   X# prefix for new public keys.  Based
      on iSCSI implementation\n   experience, we know that there is no longer a need
      for a standard\n   name prefix for keys that allow a NotUnderstood response.
      \ Note that\n   NotUnderstood will generally have to be allowed for new public
      keys\n   for backwards compatibility, as well as for private X- keys.  Thus,\n
      \  the name prefix \"X#\" in new public key-names does not carry any\n   significance.
      \ To avoid confusion, new public key-names MUST NOT\n   begin with an \"X#\"
      prefix.\n   Implementers MAY also introduce new values, but ONLY for new keys
      or\n   authentication methods (see Section 12) or digests (see\n   Section 13.1).\n
      \  Whenever parameter actions or acceptance are dependent on other\n   parameters,
      the dependency rules and parameter sequence must be\n   specified with the parameters.\n
      \  In the Login Phase (see Section 6.3), every stage is a separate\n   negotiation.
      \ In the Full Feature Phase, a Text Request/Response\n   sequence is a negotiation.
      \ Negotiations MUST be handled as atomic\n   operations.  For example, all negotiated
      values go into effect after\n   the negotiation concludes in agreement or are
      ignored if the\n   negotiation fails.\n   Some parameters may be subject to
      integrity rules (e.g., parameter-x\n   must not exceed parameter-y, or parameter-u
      not 1 implies that\n   parameter-v be Yes).  Whenever required, integrity rules
      are\n   specified with the keys.  Checking for compliance with the integrity\n
      \  rule must only be performed after all the parameters are available\n   (the
      existent and the newly negotiated).  An iSCSI target MUST\n   perform integrity
      checking before the new parameters take effect.  An\n   initiator MAY perform
      integrity checking.\n   An iSCSI initiator or target MAY terminate a negotiation
      that does\n   not terminate within an implementation-specific reasonable time
      or\n   number of exchanges but SHOULD allow at least six (6) exchanges.\n"
    - contents:
      - "6.2.1.  List Negotiations\n   In list negotiation, the originator sends a
        list of values (which may\n   include \"None\"), in order of preference.\n
        \  The responding party MUST respond with the same key and the first\n   value
        that it supports (and is allowed to use for the specific\n   originator) selected
        from the originator list.\n   The constant \"None\" MUST always be used to
        indicate a missing\n   function.  However, \"None\" is only a valid selection
        if it is\n   explicitly proposed.  When \"None\" is proposed as a selection
        item in\n   a negotiation for a key, it indicates to the responder that not\n
        \  supporting any functionality related to that key is legal, and if\n   \"None\"
        is the negotiation result for such a key, it means that key-\n   specific
        semantics are not operational for the negotiation scope\n   (connection or
        session) of that key.\n   If an acceptor does not understand any particular
        value in a list, it\n   MUST ignore it.  If an acceptor does not support,
        does not\n   understand, or is not allowed to use any of the proposed options
        with\n   a specific originator, it may use the constant \"Reject\" or terminate\n
        \  the negotiation.  The selection of a value not proposed MUST be\n   handled
        by the originator as a protocol error.\n"
      title: 6.2.1.  List Negotiations
    - contents:
      - "6.2.2.  Simple-Value Negotiations\n   For simple-value negotiations, the
        accepting party MUST answer with\n   the same key.  The value it selects becomes
        the negotiation result.\n   Proposing a value not admissible (e.g., not within
        the specified\n   bounds) MAY be answered with the constant \"Reject\"; otherwise,
        the\n   acceptor MUST select an admissible value.\n   The selection, by the
        acceptor, of a value not admissible under the\n   selection rules is considered
        a protocol error.  The selection rules\n   are key-specific.\n   For a numerical
        range, the value selected MUST be an integer within\n   the proposed range
        or \"Reject\" (if the range is unacceptable).\n   For Boolean negotiations
        (i.e., keys taking the values \"Yes\" or\n   \"No\"), the accepting party
        MUST answer with the same key and the\n   result of the negotiation when the
        received value does not determine\n   that result by itself.  The last value
        transmitted becomes the\n   negotiation result.  The rules for selecting the
        value with which to\n   answer are expressed as Boolean functions of the value
        received, and\n   the value that the accepting party would have selected if
        given a\n   choice.\n   Specifically, the two cases in which answers are OPTIONAL
        are:\n      - The Boolean function is \"AND\" and the value \"No\" is received.\n
        \       The outcome of the negotiation is \"No\".\n      - The Boolean function
        is \"OR\" and the value \"Yes\" is received.\n        The outcome of the negotiation
        is \"Yes\".\n   Responses are REQUIRED in all other cases, and the value chosen
        and\n   sent by the acceptor becomes the outcome of the negotiation.\n"
      title: 6.2.2.  Simple-Value Negotiations
    title: 6.2.  Text Mode Negotiation
  - contents:
    - "6.3.  Login Phase\n   The Login Phase establishes an iSCSI connection between
      an initiator\n   and a target; it also creates a new session or associates the\n
      \  connection to an existing session.  The Login Phase sets the iSCSI\n   protocol
      parameters and security parameters, and authenticates the\n   initiator and
      target to each other.\n   The Login Phase is only implemented via Login Requests
      and Responses.\n   The whole Login Phase is considered as a single task and
      has a single\n   Initiator Task Tag (similar to the linked SCSI commands).\n
      \  There MUST NOT be more than one outstanding Login Request or Login\n   Response
      on an iSCSI connection.  An outstanding PDU in this context\n   is one that
      has not been acknowledged by the remote iSCSI side.\n   The default MaxRecvDataSegmentLength
      is used during login.\n   The Login Phase sequence of requests and responses
      proceeds as\n   follows:\n      - Login initial request\n      - Login partial
      response (optional)\n      - More Login Requests and Responses (optional)\n
      \     - Login Final-Response (mandatory)\n   The initial Login Request of any
      connection MUST include the\n   InitiatorName key=value pair.  The initial Login
      Request of the first\n   connection of a session MAY also include the SessionType
      key=value\n   pair.  For any connection within a session whose type is not\n
      \  \"Discovery\", the first Login Request MUST also include the TargetName\n
      \  key=value pair.\n   The Login Final-Response accepts or rejects the Login
      Request.\n   The Login Phase MAY include a SecurityNegotiation stage and a\n
      \  LoginOperationalNegotiation stage and MUST include at least one of\n   them,
      but the included stage MAY be empty except for the mandatory\n   names.\n   The
      Login Requests and Responses contain a field (CSG) that indicates\n   the current
      negotiation stage (SecurityNegotiation or\n   LoginOperationalNegotiation).
      \ If both stages are used, the\n   SecurityNegotiation MUST precede the LoginOperationalNegotiation.\n
      \  Some operational parameters can be negotiated outside the login\n   through
      Text Requests and Responses.\n   Authentication-related security keys (Section
      12) MUST be completely\n   negotiated within the Login Phase.  The use of underlying
      IPsec\n   security is specified in Section 9.3, in [RFC3723], and in [RFC7146].\n
      \  iSCSI support for security within the protocol only consists of\n   authentication
      in the Login Phase.\n   In some environments, a target or an initiator is not
      interested in\n   authenticating its counterpart.  It is possible to bypass\n
      \  authentication through the Login Request and Response.\n   The initiator
      and target MAY want to negotiate iSCSI authentication\n   parameters.  Once
      this negotiation is completed, the channel is\n   considered secure.\n   Most
      of the negotiation keys are only allowed in a specific stage.\n   The keys used
      during the SecurityNegotiation stage are listed in\n   Section 12, and the keys
      used during the LoginOperationalNegotiation\n   stage are discussed in Section
      13.  Only a limited set of keys\n   (marked as Any-Stage in Section 13) may
      be used in either of the two\n   stages.\n   Any given Login Request or Response
      belongs to a specific stage; this\n   determines the negotiation keys allowed
      with the request or response.\n   Sending a key that is not allowed in the current
      stage is considered\n   a protocol error.\n   Stage transition is performed
      through a command exchange\n   (request/response) that carries the T bit and
      the same CSG code.\n   During this exchange, the next stage is selected by the
      target via\n   the Next Stage code (NSG).  The selected NSG MUST NOT exceed
      the\n   value stated by the initiator.  The initiator can request a\n   transition
      whenever it is ready, but a target can only respond with a\n   transition after
      one is proposed by the initiator.\n   In a negotiation sequence, the T bit settings
      in one Login Request-\n   Login Response pair have no bearing on the T bit settings
      of the next\n   pair.  An initiator that has the T bit set to 1 in one pair
      and is\n   answered with a T bit setting of 0 may issue the next request with\n
      \  the T bit set to 0.\n   When a transition is requested by the initiator and
      acknowledged by\n   the target, both the initiator and target switch to the
      selected\n   stage.\n   Targets MUST NOT submit parameters that require an additional\n
      \  initiator Login Request in a Login Response with the T bit set to 1.\n   Stage
      transitions during login (including entering and exit) are only\n   possible
      as outlined in the following table:\n     +-----------------------------------------------------------+\n
      \    |From      To ->  | Security    | Operational | FullFeature |\n     | |
      \              |             |             |             |\n     | V               |
      \            |             |             |\n     +-----------------------------------------------------------+\n
      \    | (start)         | yes         | yes         | no          |\n     +-----------------------------------------------------------+\n
      \    | Security        | no          | yes         | yes         |\n     +-----------------------------------------------------------+\n
      \    | Operational     | no          | no          | yes         |\n     +-----------------------------------------------------------+\n
      \  The Login Final-Response that accepts a Login Request can only come\n   as
      a response to a Login Request with the T bit set to 1, and both\n   the request
      and response MUST indicate FullFeaturePhase as the next\n   phase via the NSG
      field.\n   Neither the initiator nor the target should attempt to declare or\n
      \  negotiate a parameter more than once during login, except for\n   responses
      to specific keys that explicitly allow repeated key\n   declarations (e.g.,
      TargetAddress).  An attempt to\n   renegotiate/redeclare parameters not specifically
      allowed MUST be\n   detected by the initiator and target.  If such an attempt
      is detected\n   by the target, the target MUST respond with a Login reject (initiator\n
      \  error); if detected by the initiator, the initiator MUST drop the\n   connection.\n"
    - contents:
      - "6.3.1.  Login Phase Start\n   The Login Phase starts with a Login Request
        from the initiator to the\n   target.  The initial Login Request includes:\n
        \     - Protocol version supported by the initiator\n      - iSCSI Initiator
        Name and iSCSI Target Name\n      - ISID, TSIH, and connection IDs\n      -
        Negotiation stage that the initiator is ready to enter\n   A login may create
        a new session, or it may add a connection to an\n   existing session.  Between
        a given iSCSI initiator node (selected\n   only by an InitiatorName) and a
        given iSCSI target defined by an\n   iSCSI TargetName and a Target Portal
        Group Tag, the login results are\n   defined by the following table:\n    +----------------------------------------------------------------+\n
        \   |ISID    | TSIH        | CID    |   Target Action                |\n    +----------------------------------------------------------------+\n
        \   |new     | non-zero    | any    |   fail the login               |\n    |
        \       |             |        |   (\"session does not exist\")   |\n    +----------------------------------------------------------------+\n
        \   |new     | zero        | any    |   instantiate a new session    |\n    +----------------------------------------------------------------+\n
        \   |existing| zero        | any    |   do session reinstatement     |\n    |
        \       |             |        |   (see Section 6.3.5)          |\n    +----------------------------------------------------------------+\n
        \   |existing| non-zero    | new    |   add a new connection to      |\n    |
        \       | existing    |        |   the session                  |\n    +----------------------------------------------------------------+\n
        \   |existing| non-zero    |existing|   do connection reinstatement  |\n    |
        \       | existing    |        |   (see Section 7.1.4.3)        |\n    +----------------------------------------------------------------+\n
        \   |existing| non-zero    | any    |   fail the login               |\n    |
        \       | new         |        |   (\"session does not exist\")   |\n    +----------------------------------------------------------------+\n
        \  The determination of \"existing\" or \"new\" is made by the target.\n   Optionally,
        the Login Request may include:\n      - Security parameters OR\n      - iSCSI
        operational parameters AND/OR\n      - The next negotiation stage that the
        initiator is ready to\n        enter\n   The target can answer the login in
        the following ways:\n      - Login Response with Login reject.  This is an
        immediate\n        rejection from the target that causes the connection to\n
        \       terminate and the session to terminate if this is the first (or\n
        \       only) connection of a new session.  The T bit, the CSG field,\n        and
        the NSG field are reserved.\n      - Login Response with Login accept as the
        Final-Response (T bit\n        set to 1 and the NSG in both request and response
        is set to\n        FullFeaturePhase).  The response includes the protocol
        version\n        supported by the target and the session ID and may include
        iSCSI\n        operational or security parameters (that depend on the current\n
        \       stage).\n      - Login Response with Login accept as a partial response
        (NSG not\n        set to FullFeaturePhase in both request and response) that\n
        \       indicates the start of a negotiation sequence.  The response\n        includes
        the protocol version supported by the target and either\n        security
        or iSCSI parameters (when no security mechanism is\n        chosen) supported
        by the target.\n   If the initiator decides to forego the SecurityNegotiation
        stage, it\n   issues the Login with the CSG set to LoginOperationalNegotiation,
        and\n   the target may reply with a Login Response that indicates that it
        is\n   unwilling to accept the connection (see Section 11.13) without\n   SecurityNegotiation
        and will terminate the connection with a response\n   of Authentication failure
        (see Section 11.13.5).\n   If the initiator is willing to negotiate iSCSI
        security, but is\n   unwilling to make the initial parameter proposal and
        may accept a\n   connection without iSCSI security, it issues the Login with
        the T bit\n   set to 1, the CSG set to SecurityNegotiation, and the NSG set
        to\n   LoginOperationalNegotiation.  If the target is also ready to skip\n
        \  security, the Login Response only contains the TargetPortalGroupTag\n   key
        (see Section 13.9), the T bit set to 1, the CSG set to\n   SecurityNegotiation,
        and the NSG set to LoginOperationalNegotiation.\n   An initiator that chooses
        to operate without iSCSI security and with\n   all the operational parameters
        taking the default values issues the\n   Login with the T bit set to 1, the
        CSG set to\n   LoginOperationalNegotiation, and the NSG set to FullFeaturePhase.
        \ If\n   the target is also ready to forego security and can finish its\n
        \  LoginOperationalNegotiation, the Login Response has the T bit set to\n
        \  1, the CSG set to LoginOperationalNegotiation, and the NSG set to\n   FullFeaturePhase
        in the next stage.\n   During the Login Phase, the iSCSI target MUST return
        the\n   TargetPortalGroupTag key with the first Login Response PDU with which\n
        \  it is allowed to do so (i.e., the first Login Response issued after\n   the
        first Login Request with the C bit set to 0) for all session\n   types.  The
        TargetPortalGroupTag key value indicates the iSCSI portal\n   group servicing
        the Login Request PDU.  If the reconfiguration of\n   iSCSI portal groups
        is a concern in a given environment, the iSCSI\n   initiator should use this
        key to ascertain that it had indeed\n   initiated the Login Phase with the
        intended target portal group.\n"
      title: 6.3.1.  Login Phase Start
    - contents:
      - "6.3.2.  iSCSI Security Negotiation\n   The security exchange sets the security
        mechanism and authenticates\n   the initiator and the target to each other.
        \ The exchange proceeds\n   according to the authentication method chosen
        in the negotiation\n   phase and is conducted using the key=value parameters
        carried in the\n   Login Requests and Responses.\n   An initiator-directed
        negotiation proceeds as follows:\n      - The initiator sends a Login Request
        with an ordered list of the\n        options it supports (authentication algorithm).
        \ The options are\n        listed in the initiator's order of preference.
        \ The initiator\n        MAY also send private or public extension options.\n
        \     - The target MUST reply with the first option in the list it\n        supports
        and is allowed to use for the specific initiator,\n        unless it does
        not support any, in which case it MUST answer\n        with \"Reject\" (see
        Section 6.2).  The parameters are encoded in\n        UTF-8 as key=value.
        \ For security parameters, see Section 12.\n      - When the initiator considers
        itself ready to conclude the\n        SecurityNegotiation stage, it sets the
        T bit to 1 and the NSG to\n        what it would like the next stage to be.
        \ The target will then\n        set the T bit to 1 and set the NSG to the
        next stage in the\n        Login Response when it finishes sending its security
        keys.  The\n        next stage selected will be the one the target selected.
        \ If the\n        next stage is FullFeaturePhase, the target MUST reply with
        a\n        Login Response with the TSIH value.\n   If the security negotiation
        fails at the target, then the target MUST\n   send the appropriate Login Response
        PDU.  If the security negotiation\n   fails at the initiator, the initiator
        SHOULD close the connection.\n   It should be noted that the negotiation might
        also be directed by the\n   target if the initiator does support security
        but is not ready to\n   direct the negotiation (propose options); see Appendix
        B for an\n   example.\n"
      title: 6.3.2.  iSCSI Security Negotiation
    - contents:
      - "6.3.3.  Operational Parameter Negotiation during the Login Phase\n   Operational
        parameter negotiation during the Login Phase MAY be done:\n      - starting
        with the first Login Request if the initiator does not\n        propose any
        security/integrity option.\n      - starting immediately after the security
        negotiation if the\n        initiator and target perform such a negotiation.\n
        \  Operational parameter negotiation MAY involve several Login Request-\n
        \  Login Response exchanges started and terminated by the initiator.\n   The
        initiator MUST indicate its intent to terminate the negotiation\n   by setting
        the T bit to 1; the target sets the T bit to 1 on the last\n   response.\n
        \  Even when the initiator indicates its intent to switch stages by\n   setting
        the T bit to 1 in a Login Request, the target MAY respond\n   with a Login
        Response with the T bit set to 0.  In that case, the\n   initiator SHOULD
        continue to set the T bit to 1 in subsequent Login\n   Requests (even empty
        requests) that it sends, until the target sends\n   a Login Response with
        the T bit set to 1 or sends a key that requires\n   the initiator to set the
        T bit to 0.\n   Some session-specific parameters can only be specified during
        the\n   Login Phase of the first connection of a session (i.e., begun by a\n
        \  Login Request that contains a zero-valued TSIH) -- the leading Login\n
        \  Phase (e.g., the maximum number of connections that can be used for\n   this
        session).\n   A session is operational once it has at least one connection
        in the\n   Full Feature Phase.  New or replacement connections can only be
        added\n   to a session after the session is operational.\n   For operational
        parameters, see Section 13.\n"
      title: 6.3.3.  Operational Parameter Negotiation during the Login Phase
    - contents:
      - "6.3.4.  Connection Reinstatement\n   Connection reinstatement is the process
        of an initiator logging in\n   with an ISID-TSIH-CID combination that is possibly
        active from the\n   target's perspective, which causes the implicit logging
        out of the\n   connection corresponding to the CID and reinstatement of a
        new Full\n   Feature Phase iSCSI connection in its place (with the same CID).\n
        \  Thus, the TSIH in the Login Request PDU MUST be non-zero, and the CID\n
        \  does not change during a connection reinstatement.  The Login Request\n
        \  performs the logout function of the old connection if an explicit\n   logout
        was not performed earlier.  In sessions with a single\n   connection, this
        may imply the opening of a second connection with\n   the sole purpose of
        cleaning up the first.  Targets MUST support\n   opening a second connection
        even when they do not support multiple\n   connections in the Full Feature
        Phase if ErrorRecoveryLevel is 2 and\n   SHOULD support opening a second connection
        if ErrorRecoveryLevel is\n   less than 2.\n   If the operational ErrorRecoveryLevel
        is 2, connection reinstatement\n   enables future task reassignment.  If the
        operational\n   ErrorRecoveryLevel is less than 2, connection reinstatement
        is the\n   replacement of the old CID without enabling task reassignment.
        \ In\n   this case, all the tasks that were active on the old CID must be\n
        \  immediately terminated without further notice to the initiator.\n   The
        initiator connection state MUST be CLEANUP_WAIT (Section 8.1.3)\n   when the
        initiator attempts a connection reinstatement.\n   In practical terms, in
        addition to the implicit logout of the old\n   connection, reinstatement is
        equivalent to a new connection login.\n"
      title: 6.3.4.  Connection Reinstatement
    - contents:
      - "6.3.5.  Session Reinstatement, Closure, and Timeout\n   Session reinstatement
        is the process of an initiator logging in with\n   an ISID that is possibly
        active from the target's perspective for\n   that initiator, thus implicitly
        logging out the session that\n   corresponds to the ISID and reinstating a
        new iSCSI session in its\n   place (with the same ISID).  Therefore, the TSIH
        in the Login PDU\n   MUST be zero to signal session reinstatement.  Session
        reinstatement\n   causes all the tasks that were active on the old session
        to be\n   immediately terminated by the target without further notice to the\n
        \  initiator.\n   The initiator session state MUST be FAILED (Section 8.3)
        when the\n   initiator attempts a session reinstatement.\n   Session closure
        is an event defined to be one of the following:\n      - a successful \"session
        close\" logout.\n      - a successful \"connection close\" logout for the
        last Full Feature\n        Phase connection when no other connection in the
        session is\n        waiting for cleanup (Section 8.2) and no tasks in the
        session\n        are waiting for reassignment.\n   Session timeout is an event
        defined to occur when the last connection\n   state timeout expires and no
        tasks are waiting for reassignment.\n   This takes the session to the FREE
        state (see the session state\n   diagrams in Section 8.3).\n"
      - contents:
        - "6.3.5.1.  Loss of Nexus Notification\n   The iSCSI layer provides the SCSI
          layer with the \"I_T nexus loss\"\n   notification when any one of the following
          events happens:\n      - successful completion of session reinstatement\n
          \     - session closure event\n      - session timeout event\n   Certain
          SCSI object clearing actions may result due to the\n   notification in the
          SCSI end nodes, as documented in Appendix E.\n"
        title: 6.3.5.1.  Loss of Nexus Notification
      title: 6.3.5.  Session Reinstatement, Closure, and Timeout
    - contents:
      - "6.3.6.  Session Continuation and Failure\n   Session continuation is the
        process by which the state of a\n   preexisting session continues to be used
        by connection reinstatement\n   (Section 6.3.4) or by adding a connection
        with a new CID.  Either of\n   these actions associates the new transport
        connection with the\n   session state.\n   Session failure is an event where
        the last Full Feature Phase\n   connection reaches the CLEANUP_WAIT state
        (Section 8.2) or completes\n   a successful recovery logout, thus causing
        all active tasks (that are\n   formerly allegiant to the connection) to start
        waiting for task\n   reassignment.\n"
      title: 6.3.6.  Session Continuation and Failure
    title: 6.3.  Login Phase
  - contents:
    - "6.4.  Operational Parameter Negotiation outside the Login Phase\n   Some operational
      parameters MAY be negotiated outside (after) the\n   Login Phase.\n   Parameter
      negotiation in the Full Feature Phase is done through Text\n   Requests and
      Responses.  Operational parameter negotiation MAY\n   involve several Text Request-Text
      Response exchanges, all of which\n   use the same Initiator Task Tag; the initiator
      always starts and\n   terminates each of these exchanges.  The initiator MUST
      indicate its\n   intent to finish the negotiation by setting the F bit to 1;
      the\n   target sets the F bit to 1 on the last response.\n   If the target responds
      to a Text Request with the F bit set to 1 with\n   a Text Response with the
      F bit set to 0, the initiator should keep\n   sending the Text Request (even
      empty requests) with the F bit set to\n   1 while it still wants to finish the
      negotiation, until it receives\n   the Text Response with the F bit set to 1.
      \ Responding to a Text\n   Request with the F bit set to 1 with an empty (no
      key=value pairs)\n   response with the F bit set to 0 is discouraged.\n   Even
      when the initiator indicates its intent to finish the\n   negotiation by setting
      the F bit to 1 in a Text Request, the target\n   MAY respond with a Text Response
      with the F bit set to 0.  In that\n   case, the initiator SHOULD continue to
      set the F bit to 1 in\n   subsequent Text Requests (even empty requests) that
      it sends, until\n   the target sends the final Text Response with the F bit
      set to 1.\n   Note that in the same case of a Text Request with the F bit set
      to 1,\n   the target SHOULD NOT respond with an empty (no key=value pairs) Text\n
      \  Response with the F bit set to 0, because such a response may cause\n   the
      initiator to abandon the negotiation.\n   Targets MUST NOT submit parameters
      that require an additional\n   initiator Text Request in a Text Response with
      the F bit set to 1.\n   In a negotiation sequence, the F bit settings in one
      Text Request-\n   Text Response pair have no bearing on the F bit settings of
      the next\n   pair.  An initiator that has the F bit set to 1 in a request and
      is\n   being answered with an F bit setting of 0 may issue the next request\n
      \  with the F bit set to 0.\n   Whenever the target responds with the F bit
      set to 0, it MUST set the\n   Target Transfer Tag to a value other than the
      default 0xffffffff.\n   An initiator MAY reset an operational parameter negotiation
      by\n   issuing a Text Request with the Target Transfer Tag set to the value\n
      \  0xffffffff after receiving a response with the Target Transfer Tag\n   set
      to a value other than 0xffffffff.  A target may reset an\n   operational parameter
      negotiation by answering a Text Request with a\n   Reject PDU.\n   Neither the
      initiator nor the target should attempt to declare or\n   negotiate a parameter
      more than once during any negotiation sequence,\n   except for responses to
      specific keys that explicitly allow repeated\n   key declarations (e.g., TargetAddress).
      \ If such an attempt is\n   detected by the target, the target MUST respond
      with a Reject PDU\n   with a reason of \"Protocol Error\".  The initiator MUST
      reset the\n   negotiation as outlined above.\n   Parameters negotiated by a
      text exchange negotiation sequence only\n   become effective after the negotiation
      sequence is completed.\n"
    title: 6.4.  Operational Parameter Negotiation outside the Login Phase
  title: 6.  Login and Full Feature Phase Negotiation
- contents:
  - '7.  iSCSI Error Handling and Recovery

    '
  - contents:
    - '7.1.  Overview

      '
    - contents:
      - "7.1.1.  Background\n   The following two considerations prompted the design
        of much of the\n   error recovery functionality in iSCSI:\n      - An iSCSI
        PDU may fail the digest check and be dropped, despite\n        being received
        by the TCP layer.  The iSCSI layer must\n        optionally be allowed to
        recover such dropped PDUs.\n      - A TCP connection may fail at any time
        during the data transfer.\n        All the active tasks must optionally be
        allowed to be continued\n        on a different TCP connection within the
        same session.\n   Implementations have considerable flexibility in deciding
        what degree\n   of error recovery to support, when to use it, and by which
        mechanisms\n   to achieve the required behavior.  Only the externally visible\n
        \  actions of the error recovery mechanisms must be standardized to\n   ensure
        interoperability.\n   This section describes a general model for recovery
        in support of\n   interoperability.  See Appendix D for further details on
        how the\n   described model may be implemented.  Compliant implementations
        do not\n   have to match the implementation details of this model as presented,\n
        \  but the external behavior of such implementations must correspond to\n
        \  the externally observable characteristics of the presented model.\n"
      title: 7.1.1.  Background
    - contents:
      - "7.1.2.  Goals\n   The major design goals of the iSCSI error recovery scheme
        are as\n   follows:\n      - Allow iSCSI implementations to meet different
        requirements by\n        defining a collection of error recovery mechanisms
        from which\n        implementations may choose.\n      - Ensure interoperability
        between any two implementations\n        supporting different sets of error
        recovery capabilities.\n      - Define the error recovery mechanisms to ensure
        command ordering\n        even in the face of errors, for initiators that
        demand ordering.\n      - Do not make additions in the fast path, but allow
        moderate\n        complexity in the error recovery path.\n      - Prevent
        both the initiator and target from attempting to recover\n        the same
        set of PDUs at the same time.  For example, there must\n        be a clear
        \"error recovery functionality distribution\" between\n        the initiator
        and target.\n"
      title: 7.1.2.  Goals
    - contents:
      - "7.1.3.  Protocol Features and State Expectations\n   The initiator mechanisms
        defined in connection with error recovery\n   are:\n      a) NOP-Out to probe
        sequence numbers of the target (Section 11.18)\n      b) Command retry (Section
        7.2.1)\n      c) Recovery R2T support (Section 7.8)\n      d) Requesting retransmission
        of status/data/R2T using the SNACK\n         facility (Section 11.16)\n      e)
        Acknowledging the receipt of the data (Section 11.16)\n      f) Reassigning
        the connection allegiance of a task to a different\n         TCP connection
        (Section 7.2.2)\n      g) Terminating the entire iSCSI session to start afresh\n
        \        (Section 7.1.4.4)\n   The target mechanisms defined in connection
        with error recovery are:\n      a) NOP-In to probe sequence numbers of the
        initiator\n         (Section 11.19)\n      b) Requesting retransmission of
        data using the recovery R2T\n         feature (Section 7.8)\n      c) SNACK
        support (Section 11.16)\n      d) Requesting that parts of read data be acknowledged\n
        \        (Section 11.7.2)\n      e) Allegiance reassignment support (Section
        7.2.2)\n      f) Terminating the entire iSCSI session to force the initiator
        to\n         start over (Section 7.1.4.4)\n   For any outstanding SCSI command,
        it is assumed that iSCSI, in\n   conjunction with SCSI at the initiator, is
        able to keep enough\n   information to be able to rebuild the command PDU
        and that outgoing\n   data is available (in host memory) for retransmission
        while the\n   command is outstanding.  It is also assumed that at the target,\n
        \  incoming data (read data) MAY be kept for recovery, or it can be\n   reread
        from a device server.\n   It is further assumed that a target will keep the
        \"status and sense\"\n   for a command it has executed if it supports status
        retransmission.\n   A target that agrees to support data retransmission is
        expected to be\n   prepared to retransmit the outgoing data (i.e., Data-In)
        on request\n   until either the status for the completed command is acknowledged
        or\n   the data in question has been separately acknowledged.\n"
      title: 7.1.3.  Protocol Features and State Expectations
    - contents:
      - "7.1.4.  Recovery Classes\n   iSCSI enables the following classes of recovery
        (in the order of\n   increasing scope of affected iSCSI tasks):\n      - within
        a command (i.e., without requiring command restart)\n      - within a connection
        (i.e., without requiring the connection to\n        be rebuilt, but perhaps
        requiring command restart)\n      - connection recovery (i.e., perhaps requiring
        connections to be\n        rebuilt and commands to be reissued)\n      - session
        recovery\n   The recovery scenarios detailed in the rest of this section are\n
        \  representative rather than exclusive.  In every case, they detail the\n
        \  lowest recovery class that MAY be attempted.  The implementer is left\n
        \  to decide under which circumstances to escalate to the next recovery\n
        \  class and/or what recovery classes to implement.  Both the iSCSI\n   target
        and initiator MAY escalate the error handling to an error\n   recovery class,
        which impacts a larger number of iSCSI tasks in any\n   of the cases identified
        in the following discussion.\n   In all classes, the implementer has the choice
        of deferring errors to\n   the SCSI initiator (with an appropriate response
        code), in which case\n   the task, if any, has to be removed from the target
        and all the side\n   effects, such as ACA, must be considered.\n   The use
        of within-connection and within-command recovery classes MUST\n   NOT be attempted
        before the connection is in the Full Feature Phase.\n   In the detailed description
        of the recovery classes, the mandating\n   terms (MUST, SHOULD, MAY, etc.)
        indicate normative actions to be\n   executed if the recovery class is supported
        (see Section 7.1.5 for\n   the related negotiation semantics) and used.\n"
      - contents:
        - "7.1.4.1.  Recovery Within-command\n   At the target, the following cases
          lend themselves to within-command\n   recovery:\n      Lost data PDU - realized
          through one of the following:\n      a) Data digest error - dealt with as
          specified in Section 7.8,\n         using the option of a recovery R2T\n
          \     b) Sequence reception timeout (no data or partial-data-and-no-\n         F-bit)
          - considered an implicit sequence error and dealt with\n         as specified
          in Section 7.9, using the option of a recovery R2T\n      c) Header digest
          error, which manifests as a sequence reception\n         timeout or a sequence
          error - dealt with as specified in\n         Section 7.9, using the option
          of a recovery R2T\n   At the initiator, the following cases lend themselves
          to within-\n   command recovery:\n      Lost data PDU or lost R2T - realized
          through one of the following:\n      a) Data digest error - dealt with as
          specified in Section 7.8,\n         using the option of a SNACK\n      b)
          Sequence reception timeout (no status) or response reception\n         timeout
          - dealt with as specified in Section 7.9, using the\n         option of
          a SNACK\n      c) Header digest error, which manifests as a sequence reception\n
          \        timeout or a sequence error - dealt with as specified in\n         Section
          7.9, using the option of a SNACK\n   To avoid a race with the target, which
          may already have a recovery\n   R2T or a termination response on its way,
          an initiator SHOULD NOT\n   originate a SNACK for an R2T based on its internal
          timeouts (if any).\n   Recovery in this case is better left to the target.\n
          \  The timeout values used by the initiator and target are outside the\n
          \  scope of this document.  A sequence reception timeout is generally a\n
          \  large enough value to allow the data sequence transfer to be\n   complete.\n"
        title: 7.1.4.1.  Recovery Within-command
      - contents:
        - "7.1.4.2.  Recovery Within-connection\n   At the initiator, the following
          cases lend themselves to within-\n   connection recovery:\n      a) Requests
          not acknowledged for a long time.  Requests are\n         acknowledged explicitly
          through the ExpCmdSN or implicitly by\n         receiving data and/or status.
          \ The initiator MAY retry\n         non-acknowledged commands as specified
          in Section 7.2.\n      b) Lost iSCSI numbered response.  It is recognized
          by either\n         identifying a data digest error on a Response PDU or
          a Data-In\n         PDU carrying the status, or receiving a Response PDU
          with a\n         higher StatSN than expected.  In the first case, digest
          error\n         handling is done as specified in Section 7.8, using the
          option\n         of a SNACK.  In the second case, sequence error handling
          is\n         done as specified in Section 7.9, using the option of a SNACK.\n
          \  At the target, the following cases lend themselves to within-\n   connection
          recovery:\n      - Status/Response not acknowledged for a long time.  The
          target\n        MAY issue a NOP-In (with a valid Target Transfer Tag or\n
          \       otherwise) that carries the next status sequence number it is\n
          \       going to use in the StatSN field.  This helps the initiator\n        detect
          any missing StatSN(s) and issue a SNACK for the status.\n   The timeout
          values used by the initiator and the target are outside\n   the scope of
          this document.\n"
        title: 7.1.4.2.  Recovery Within-connection
      - contents:
        - "7.1.4.3.  Connection Recovery\n   At an iSCSI initiator, the following
          cases lend themselves to\n   connection recovery:\n      a) TCP connection
          failure: The initiator MUST close the\n         connection.  It then MUST
          either implicitly or explicitly log\n         out the failed connection
          with the reason code \"remove the\n         connection for recovery\" and
          reassign connection allegiance for\n         all commands still in progress
          associated with the failed\n         connection on one or more connections
          (some or all of which MAY\n         be newly established connections) using
          the \"TASK REASSIGN\"\n         task management function (see Section 11.5.1).
          \ For an\n         initiator, a command is in progress as long as it has
          not\n         received a response or a Data-In PDU including status.\n         Note:
          The logout function is mandatory.  However, a new\n         connection establishment
          is only mandatory if the failed\n         connection was the last or only
          connection in the session.\n      b) Receiving an Asynchronous Message that
          indicates that one or\n         all connections in a session have been dropped.
          \ The initiator\n         MUST handle it as a TCP connection failure for
          the\n         connection(s) referred to in the message.\n   At an iSCSI
          target, the following cases lend themselves to connection\n   recovery:\n
          \     - TCP connection failure: The target MUST close the connection\n        and,
          if more than one connection is available, the target SHOULD\n        send
          an Asynchronous Message that indicates that it has dropped\n        the
          connection.  Then, the target will wait for the initiator to\n        continue
          recovery.\n"
        title: 7.1.4.3.  Connection Recovery
      - contents:
        - "7.1.4.4.  Session Recovery\n   Session recovery should be performed when
          all other recovery attempts\n   have failed.  Very simple initiators and
          targets MAY perform session\n   recovery on all iSCSI errors and rely on
          recovery on the SCSI layer\n   and above.\n   Session recovery implies the
          closing of all TCP connections,\n   internally aborting all executing and
          queued tasks for the given\n   initiator at the target, terminating all
          outstanding SCSI commands\n   with an appropriate SCSI service response
          at the initiator, and\n   restarting a session on a new set of connection(s)
          (TCP connection\n   establishment and login on all new connections).\n   For
          possible clearing effects of session recovery on SCSI and iSCSI\n   objects,
          refer to Appendix E.\n"
        title: 7.1.4.4.  Session Recovery
      title: 7.1.4.  Recovery Classes
    - contents:
      - "7.1.5.  Error Recovery Hierarchy\n   The error recovery classes described
        so far are organized into a\n   hierarchy for ease in understanding and to
        limit the complexity of\n   the implementation.  With a few well-defined recovery
        levels,\n   interoperability is easier to achieve.  The attributes of this\n
        \  hierarchy are as follows:\n      a) Each level is a superset of the capabilities
        of the previous\n         level.  For example, Level 1 support implies supporting
        all\n         capabilities of Level 0 and more.\n      b) As a corollary,
        supporting a higher error recovery level means\n         increased sophistication
        and possibly an increase in resource\n         requirements.\n      c) Supporting
        error recovery level \"n\" is advertised and\n         negotiated by each
        iSCSI entity by exchanging the text key\n         \"ErrorRecoveryLevel=n\".
        \ The lower of the two exchanged values\n         is the operational ErrorRecoveryLevel
        for the session.\n   The following diagram represents the error recovery hierarchy.\n
        \                           +\n                           / \\\n                          /
        2 \\      <-- Connection recovery\n                         +-----+\n                        /
        \  1   \\    <-- Digest failure recovery\n                       +---------+\n
        \                     /     0     \\  <-- Session failure recovery\n                     +-------------+\n
        \  The following table lists the error recovery (ER) capabilities\n   expected
        from the implementations that support each error recovery\n   level.\n    +-------------------+--------------------------------------------+\n
        \   |ErrorRecoveryLevel | Associated Error Recovery Capabilities     |\n    +-------------------+--------------------------------------------+\n
        \   |        0          | Session recovery class                     |\n    |
        \                  | (Session Recovery)                         |\n    +-------------------+--------------------------------------------+\n
        \   |        1          | Digest failure recovery (see Note below)   |\n    |
        \                  | plus the capabilities of ER Level 0        |\n    +-------------------+--------------------------------------------+\n
        \   |        2          | Connection recovery class                  |\n    |
        \                  | (Connection Recovery)                      |\n    |                   |
        plus the capabilities of ER Level 1        |\n    +-------------------+--------------------------------------------+\n
        \  Note: Digest failure recovery is comprised of two recovery classes:\n   the
        Within-connection recovery class (recovery within-connection) and\n   the
        Within-command recovery class (recovery within-command).\n   When a defined
        value of ErrorRecoveryLevel is proposed by an\n   originator in a text negotiation,
        the originator MUST support the\n   functionality defined for the proposed
        value and, additionally,\n   functionality corresponding to any defined value
        numerically less\n   than the proposed value.  When a defined value of ErrorRecoveryLevel\n
        \  is returned by a responder in a text negotiation, the responder MUST\n
        \  support the functionality corresponding to the ErrorRecoveryLevel it\n
        \  is accepting.\n   When either party attempts to use error recovery functionality
        beyond\n   what is negotiated, the recovery attempts MAY fail, unless an\n
        \  a priori agreement outside the scope of this document exists between\n
        \  the two parties to provide such support.\n   Implementations MUST support
        error recovery level \"0\", while the rest\n   are OPTIONAL to implement.
        \ In implementation terms, the above\n   striation means that the following
        incremental sophistication with\n   each level is required:\n    +-------------------+--------------------------------------------+\n
        \   | Level Transition  | Incremental Requirement                    |\n    +-------------------+--------------------------------------------+\n
        \   |        0->1       | PDU retransmissions on the same connection |\n    +-------------------+--------------------------------------------+\n
        \   |        1->2       | Retransmission across connections and      |\n    |
        \                  | allegiance reassignment                    |\n    +-------------------+--------------------------------------------+\n"
      title: 7.1.5.  Error Recovery Hierarchy
    title: 7.1.  Overview
  - contents:
    - "7.2.  Retry and Reassign in Recovery\n   This section summarizes two important
      and somewhat related iSCSI\n   protocol features used in error recovery.\n"
    - contents:
      - "7.2.1.  Usage of Retry\n   By resending the same iSCSI Command PDU (\"retry\")
        in the absence of a\n   command acknowledgment (by way of an ExpCmdSN update)
        or a response,\n   an initiator attempts to \"plug\" (what it thinks are)
        the\n   discontinuities in CmdSN ordering on the target end.  Discarded\n
        \  command PDUs, due to digest errors, may have created these\n   discontinuities.\n
        \  Retry MUST NOT be used for reasons other than plugging command\n   sequence
        gaps and, in particular, cannot be used for requesting PDU\n   retransmissions
        from a target.  Any such PDU retransmission requests\n   for a currently allegiant
        command in progress may be made using the\n   SNACK mechanism described in
        Section 11.16, although the usage of\n   SNACK is OPTIONAL.\n   If initiators,
        as part of plugging command sequence gaps as described\n   above, inadvertently
        issue retries for allegiant commands already in\n   progress (i.e., targets
        did not see the discontinuities in CmdSN\n   ordering), the duplicate commands
        are silently ignored by targets as\n   specified in Section 4.2.2.1.\n   When
        an iSCSI command is retried, the command PDU MUST carry the\n   original Initiator
        Task Tag and the original operational attributes\n   (e.g., flags, function
        names, LUN, CDB, etc.) as well as the original\n   CmdSN.  The command being
        retried MUST be sent on the same connection\n   as the original command, unless
        the original connection was already\n   successfully logged out.\n"
      title: 7.2.1.  Usage of Retry
    - contents:
      - "7.2.2.  Allegiance Reassignment\n   By issuing a \"TASK REASSIGN\" task management
        request\n   (Section 11.5.1), the initiator signals its intent to continue
        an\n   already active command (but with no current connection allegiance)
        as\n   part of connection recovery.  This means that a new connection\n   allegiance
        is requested for the command, which seeks to associate it\n   to the connection
        on which the task management request is being\n   issued.  Before the allegiance
        reassignment is attempted for a task,\n   an implicit or explicit Logout with
        the reason code \"remove the\n   connection for recovery\" (see Section 11.14.1)
        MUST be successfully\n   completed for the previous connection to which the
        task was\n   allegiant.\n   In reassigning connection allegiance for a command,
        the target SHOULD\n   continue the command from its current state.  For example,
        when\n   reassigning read commands, the target SHOULD take advantage of the\n
        \  ExpDataSN field provided by the Task Management Function Request\n   (which
        must be set to 0 if there was no data transfer) and bring the\n   read command
        to completion by sending the remaining data and sending\n   (or resending)
        the status.  The ExpDataSN acknowledges all data sent\n   up to, but not including,
        the Data-In PDU and/or R2T with the DataSN\n   (or R2TSN) equal to the ExpDataSN.
        \ However, targets may choose to\n   send/receive all unacknowledged data
        or all of the data on a\n   reassignment of connection allegiance if unable
        to recover or\n   maintain accurate state.  Initiators MUST NOT subsequently
        request\n   data retransmission through Data SNACK for PDUs numbered less
        than\n   the ExpDataSN (i.e., prior to the acknowledged sequence number).
        \ For\n   all types of commands, a reassignment request implies that the task\n
        \  is still considered in progress by the initiator, and the target must\n
        \  conclude the task appropriately if the target returns the \"Function\n
        \  complete\" response to the reassignment request.  This might possibly\n
        \  involve retransmission of data/R2T/status PDUs as necessary but MUST\n
        \  involve the (re)transmission of the status PDU.\n   It is OPTIONAL for
        targets to support the allegiance reassignment.\n   This capability is negotiated
        via the ErrorRecoveryLevel text key\n   during the login time.  When a target
        does not support allegiance\n   reassignment, it MUST respond with a task
        management response code of\n   \"Task allegiance reassignment not supported\".
        \ If allegiance\n   reassignment is supported by the target but the task is
        still\n   allegiant to a different connection, or a successful recovery Logout\n
        \  of the previously allegiant connection was not performed, the target\n
        \  MUST respond with a task management response code of \"Task still\n   allegiant\".\n
        \  If allegiance reassignment is supported by the target, the task\n   management
        response to the reassignment request MUST be issued before\n   the reassignment
        becomes effective.\n   If a SCSI command that involves data input is reassigned,
        any SNACK\n   Tag it holds for a final response from the original connection
        is\n   deleted, and the default value of 0 MUST be used instead.\n"
      title: 7.2.2.  Allegiance Reassignment
    title: 7.2.  Retry and Reassign in Recovery
  - contents:
    - "7.3.  Usage of Reject PDU in Recovery\n   Targets MUST NOT implicitly terminate
      an active task by sending a\n   Reject PDU for any PDU exchanged during the
      life of the task.  If the\n   target decides to terminate the task, a Response
      PDU (SCSI, Text,\n   Task, etc.) must be returned by the target to conclude
      the task.  If\n   the task had never been active before the Reject (i.e., the
      Reject is\n   on the command PDU), targets should not send any further responses\n
      \  because the command itself is being discarded.\n   The above rule means that
      the initiator can eventually expect a\n   response on receiving Rejects, if
      the received Reject is for a PDU\n   other than the command PDU itself.  The
      non-command Rejects only have\n   diagnostic value in logging the errors, and
      they can be used for\n   retransmission decisions by the initiators.\n   The
      CmdSN of the rejected command PDU (if it is a non-immediate\n   command) MUST
      NOT be considered received by the target (i.e., a\n   command sequence gap must
      be assumed for the CmdSN), even though the\n   CmdSN of the rejected command
      PDU may be reliably ascertained.  Upon\n   receiving the Reject, the initiator
      MUST plug the CmdSN gap in order\n   to continue to use the session.  The gap
      may be plugged by either\n   transmitting a command PDU with the same CmdSN
      or aborting the task\n   (see Section 7.11 for information regarding how an
      abort may plug a\n   CmdSN gap).\n   When a data PDU is rejected and its DataSN
      can be ascertained, a\n   target MUST advance the ExpDataSN for the current
      data burst if a\n   recovery R2T is being generated.  The target MAY advance
      its\n   ExpDataSN if it does not attempt to recover the lost data PDU.\n"
    title: 7.3.  Usage of Reject PDU in Recovery
  - contents:
    - '7.4.  Error Recovery Considerations for Discovery Sessions

      '
    - contents:
      - "7.4.1.  ErrorRecoveryLevel for Discovery Sessions\n   The negotiation of
        the key ErrorRecoveryLevel is not required for\n   Discovery sessions -- i.e.,
        for sessions that negotiated\n   \"SessionType=Discovery\" -- because the
        default value of 0 is\n   necessary and sufficient for Discovery sessions.
        \ It is, however,\n   possible that some legacy iSCSI implementations might
        attempt to\n   negotiate the ErrorRecoveryLevel key on Discovery sessions.
        \ When\n   such a negotiation attempt is made by the remote side, a compliant\n
        \  iSCSI implementation MUST propose a value of 0 (zero) in response.\n   The
        operational ErrorRecoveryLevel for Discovery sessions thus MUST\n   be 0.
        \ This naturally follows from the functionality constraints that\n   Section
        4.3 imposes on Discovery sessions.\n"
      title: 7.4.1.  ErrorRecoveryLevel for Discovery Sessions
    - contents:
      - "7.4.2.  Reinstatement Semantics for Discovery Sessions\n   Discovery sessions
        are intended to be relatively short-lived.\n   Initiators are not expected
        to establish multiple Discovery sessions\n   to the same iSCSI Network Portal.
        \ An initiator may use the same\n   iSCSI Initiator Name and ISID when establishing
        different unique\n   sessions with different targets and/or different portal
        groups.  This\n   behavior is discussed in Section 10.1.1 and is, in fact,
        encouraged\n   as conservative reuse of ISIDs.\n   The ISID RULE in Section
        4.4.3 states that there must not be more\n   than one session with a matching
        4-tuple: <InitiatorName, ISID,\n   TargetName, TargetPortalGroupTag>.  While
        the spirit of the ISID RULE\n   applies to Discovery sessions the same as
        it does for Normal\n   sessions, note that some Discovery sessions differ
        from the Normal\n   sessions in two important aspects:\n      a) Because Appendix
        C allows a Discovery session to be established\n         without specifying
        a TargetName key in the Login Request PDU\n         (let us call such a session
        an \"Unnamed\" Discovery session),\n         there is no target node context
        to enforce the ISID RULE.\n      b) Portal groups are defined only in the
        context of a target node.\n         When the TargetName key is NULL-valued
        (i.e., not specified),\n         the TargetPortalGroupTag thus cannot be ascertained
        to enforce\n         the ISID RULE.\n   The following two sections describe
        Unnamed Discovery sessions and\n   Named Discovery sessions, respectively.\n"
      - contents:
        - "7.4.2.1.  Unnamed Discovery Sessions\n   For Unnamed Discovery sessions,
          neither the TargetName nor the\n   TargetPortalGroupTag is available to
          the targets in order to enforce\n   the ISID RULE.  Therefore, the following
          rule applies.\n   UNNAMED ISID RULE: Targets MUST enforce the uniqueness
          of the\n   following 4-tuple for Unnamed Discovery sessions: <InitiatorName,\n
          \  ISID, NULL, TargetAddress>.  The following semantics are implied by\n
          \  this uniqueness requirement.\n   Targets SHOULD allow concurrent establishment
          of one Discovery\n   session with each of its Network Portals by the same
          initiator port\n   with a given iSCSI Node Name and an ISID.  Each of the
          concurrent\n   Discovery sessions, if established by the same initiator
          port to\n   other Network Portals, MUST be treated as independent sessions
          --\n   i.e., one session MUST NOT reinstate the other.\n   A new Unnamed
          Discovery session that has a matching <InitiatorName,\n   ISID, NULL, TargetAddress>
          to an existing Discovery session MUST\n   reinstate the existing Unnamed
          Discovery session.  Note thus that\n   only an Unnamed Discovery session
          may reinstate another Unnamed\n   Discovery session.\n"
        title: 7.4.2.1.  Unnamed Discovery Sessions
      - contents:
        - "7.4.2.2.  Named Discovery Sessions\n   For Named Discovery sessions, the
          TargetName key is specified by the\n   initiator, and thus the target can
          unambiguously ascertain the\n   TargetPortalGroupTag as well.  Since all
          the four elements of the\n   4-tuple are known, the ISID RULE MUST be enforced
          by targets with no\n   changes from Section 4.4.3 semantics.  A new session
          with a matching\n   <InitiatorName, ISID, TargetName, TargetPortalGroupTag>
          thus will\n   reinstate an existing session.  Note in this case that any
          new iSCSI\n   session (Discovery or Normal) with the matching 4-tuple may
          reinstate\n   an existing Named Discovery iSCSI session.\n"
        title: 7.4.2.2.  Named Discovery Sessions
      title: 7.4.2.  Reinstatement Semantics for Discovery Sessions
    - contents:
      - "7.4.3.  Target PDUs during Discovery\n   Targets SHOULD NOT send any responses
        other than a Text Response and\n   Logout Response on a Discovery session,
        once in the Full Feature\n   Phase.\n   Implementation Note: A target may
        simply drop the connection in a\n   Discovery session when it would have requested
        a Logout via an Async\n   Message on Normal sessions.\n"
      title: 7.4.3.  Target PDUs during Discovery
    title: 7.4.  Error Recovery Considerations for Discovery Sessions
  - contents:
    - "7.5.  Connection Timeout Management\n   iSCSI defines two session-global timeout
      values (in seconds) --\n   Time2Wait and Time2Retain -- that are applicable
      when an iSCSI Full\n   Feature Phase connection is taken out of service either
      intentionally\n   or by an exception.  Time2Wait is the initial \"respite time\"
      before\n   attempting an explicit/implicit Logout for the CID in question or\n
      \  task reassignment for the affected tasks (if any).  Time2Retain is\n   the
      maximum time after the initial respite interval that the task\n   and/or connection
      state(s) is/are guaranteed to be maintained on the\n   target to cater to a
      possible recovery attempt.  Recovery attempts\n   for the connection and/or
      task(s) SHOULD NOT be made before\n   Time2Wait seconds but MUST be completed
      within Time2Retain seconds\n   after that initial Time2Wait waiting period.\n"
    - contents:
      - "7.5.1.  Timeouts on Transport Exception Events\n   A transport connection
        shutdown or a transport reset without any\n   preceding iSCSI protocol interactions
        informing the endpoints of the\n   fact causes a Full Feature Phase iSCSI
        connection to be abruptly\n   terminated.  The timeout values to be used in
        this case are the\n   negotiated values of DefaultTime2Wait (Section 13.15)
        and\n   DefaultTime2Retain (Section 13.16) text keys for the session.\n"
      title: 7.5.1.  Timeouts on Transport Exception Events
    - contents:
      - "7.5.2.  Timeouts on Planned Decommissioning\n   Any planned decommissioning
        of a Full Feature Phase iSCSI connection\n   is preceded by either a Logout
        Response PDU or an Async Message PDU.\n   The Time2Wait and Time2Retain field
        values (Section 11.15) in a\n   Logout Response PDU, and the Parameter2 and
        Parameter3 fields of an\n   Async Message (AsyncEvent types \"drop the connection\"
        or \"drop all\n   the connections\"; see Section 11.9.1), specify the timeout
        values to\n   be used in each of these cases.\n   These timeout values are
        only applicable for the affected connection\n   and the tasks active on that
        connection.  These timeout values have\n   no bearing on initiator timers
        (if any) that are already running on\n   connections or tasks associated with
        that session.\n"
      title: 7.5.2.  Timeouts on Planned Decommissioning
    title: 7.5.  Connection Timeout Management
  - contents:
    - "7.6.  Implicit Termination of Tasks\n   A target implicitly terminates the
      active tasks due to iSCSI protocol\n   dynamics in the following cases:\n      a)
      When a connection is implicitly or explicitly logged out with\n         the
      reason code \"close the connection\" and there are active\n         tasks allegiant
      to that connection.\n      b) When a connection fails and eventually the connection
      state\n         times out (state transition M1 in Section 8.2.2), and there
      are\n         active tasks allegiant to that connection.\n      c) When a successful
      Logout with the reason code \"remove the\n         connection for recovery\"
      is performed while there are active\n         tasks allegiant to that connection,
      and those tasks eventually\n         time out after the Time2Wait and Time2Retain
      periods without\n         allegiance reassignment.\n      d) When a connection
      is implicitly or explicitly logged out with\n         the reason code \"close
      the session\" and there are active tasks\n         in that session.\n   If the
      tasks terminated in cases a), b), c), and d) above are SCSI\n   tasks, they
      must be internally terminated as if with CHECK CONDITION\n   status.  This status
      is only meaningful for appropriately handling\n   the internal SCSI state and
      SCSI side effects with respect to\n   ordering, because this status is never
      communicated back as a\n   terminating status to the initiator.  However, additional
      actions may\n   have to be taken at the SCSI level, depending on the SCSI context
      as\n   defined by the SCSI standards (e.g., queued commands and ACA; UA for\n
      \  the next command on the I_T nexus in cases a), b), and c); etc. --\n   see
      [SAM2] and [SPC3]).\n"
    title: 7.6.  Implicit Termination of Tasks
  - contents:
    - "7.7.  Format Errors\n   The following two explicit violations of PDU layout
      rules are format\n   errors:\n      a) Illegal contents of any PDU header field
      except the Opcode\n         (legal values are specified in Section 11).\n      b)
      Inconsistent field contents (consistent field contents are\n         specified
      in Section 11).\n   Format errors indicate a major implementation flaw in one
      of the\n   parties.\n   When a target or an initiator receives an iSCSI PDU
      with a format\n   error, it MUST immediately terminate all transport connections
      in the\n   session with either a connection close or a connection reset, and\n
      \  escalate the format error to session recovery (see Section 7.1.4.4).\n   All
      initiator-detected PDU construction errors MUST be considered as\n   format
      errors.  Some examples of such errors are:\n      - NOP-In with a valid TTT
      but an invalid LUN\n      - NOP-In with a valid ITT (i.e., a NOP-In response)
      and also a\n        valid TTT\n      - SCSI Response PDU with Status=CHECK CONDITION,
      but\n        DataSegmentLength = 0\n"
    title: 7.7.  Format Errors
  - contents:
    - "7.8.  Digest Errors\n   The discussion below regarding the legal choices in
      handling digest\n   errors excludes session recovery as an explicit option,
      but either\n   party detecting a digest error may choose to escalate the error
      to\n   session recovery.\n   When a target or an initiator receives any iSCSI
      PDU with a header\n   digest error, it MUST either discard the header and all
      data up to\n   the beginning of a later PDU or close the connection.  Because
      the\n   digest error indicates that the length field of the header may have\n
      \  been corrupted, the location of the beginning of a later PDU needs to\n   be
      reliably ascertained by other means, such as the operation of a\n   Sync and
      Steering layer.\n   When a target receives any iSCSI PDU with a payload digest
      error, it\n   MUST answer with a Reject PDU with a reason code of Data-Digest-Error\n
      \  and discard the PDU.\n   - If the discarded PDU is a solicited or unsolicited
      iSCSI data PDU\n     (for immediate data in a command PDU, the non-data PDU
      rule below\n     applies), the target MUST do one of the following:\n     a)
      Request retransmission with a recovery R2T.\n     b) Terminate the task with
      a SCSI Response PDU with a CHECK\n        CONDITION Status and an iSCSI Condition
      of \"Protocol Service CRC\n        error\" (Section 11.4.7.2).  If the target
      chooses to implement\n        this option, it MUST wait to receive all the data
      (signaled by a\n        data PDU with the Final bit set for all outstanding
      R2Ts) before\n        sending the SCSI Response PDU.  A task management command
      (such\n        as an ABORT TASK) from the initiator during this wait may also\n
      \       conclude the task.\n   - No further action is necessary for targets
      if the discarded PDU is\n     a non-data PDU.  In the case of immediate data
      being present on a\n     discarded command, the immediate data is implicitly
      recovered when\n     the task is retried (see Section 7.2.1), followed by the
      entire\n     data transfer for the task.\n   When an initiator receives any
      iSCSI PDU with a payload digest error,\n   it MUST discard the PDU.\n      -
      If the discarded PDU is an iSCSI data PDU, the initiator MUST do\n        one
      of the following:\n        a) Request the desired data PDU through SNACK.  In
      response to\n           the SNACK, the target MUST either resend the data PDU
      or\n           reject the SNACK with a Reject PDU with a reason code of\n           \"SNACK
      reject\", in which case:\n           a.1) If the status has not already been
      sent for the command,\n                the target MUST terminate the command
      with a CHECK\n                CONDITION Status and an iSCSI Condition of \"SNACK\n
      \               rejected\" (Section 11.4.7.2).\n           a.2) If the status
      was already sent, no further action is\n                necessary for the target.
      \ The initiator in this case\n                MUST wait for the status to be
      received and then discard\n                it, so as to internally signal the
      completion with CHECK\n                CONDITION Status and an iSCSI Condition
      of \"Protocol\n                Service CRC error\" (Section 11.4.7.2).\n        b)
      Abort the task and terminate the command with an error.\n      - If the discarded
      PDU is a response PDU or an unsolicited PDU\n        (e.g., Async, Reject),
      the initiator MUST do one of the\n        following:\n        a) Request PDU
      retransmission with a status of SNACK.\n        b) Log out the connection for
      recovery, and continue the tasks\n           on a different connection instance
      as described in\n           Section 7.2.\n        c) Log out to close the connection
      (abort all the commands\n           associated with the connection).\n      Note
      that an unsolicited PDU carries the next StatSN value on an\n      iSCSI connection,
      thereby advancing the StatSN.  When an initiator\n      discards one of these
      PDUs due to a payload digest error, the\n      entire PDU, including the header,
      MUST be discarded.\n      Consequently, the initiator MUST treat the exception
      like a loss\n      of any other solicited response PDU.\n"
    title: 7.8.  Digest Errors
  - contents:
    - "7.9.  Sequence Errors\n   When an initiator receives an iSCSI R2T/data PDU
      with an out-of-order\n   R2TSN/DataSN or a SCSI Response PDU with an ExpDataSN
      that implies\n   missing data PDU(s), it means that the initiator must have
      detected a\n   header or payload digest error on one or more earlier R2T/data
      PDUs.\n   The initiator MUST address these implied digest errors as described\n
      \  in Section 7.8.  When a target receives a data PDU with an out-of-\n   order
      DataSN, it means that the target must have hit a header or\n   payload digest
      error on at least one of the earlier data PDUs.  The\n   target MUST address
      these implied digest errors as described in\n   Section 7.8.\n   When an initiator
      receives an iSCSI status PDU with an out-of-order\n   StatSN that implies missing
      responses, it MUST address the one or\n   more missing status PDUs as described
      in Section 7.8.  As a side\n   effect of receiving the missing responses, the
      initiator may discover\n   missing data PDUs.  If the initiator wants to recover
      the missing\n   data for a command, it MUST NOT acknowledge the received responses\n
      \  that start from the StatSN of the relevant command until it has\n   completed
      receiving all the data PDUs of the command.\n   When an initiator receives duplicate
      R2TSNs (due to proactive\n   retransmission of R2Ts by the target) or duplicate
      DataSNs (due to\n   proactive SNACKs by the initiator), it MUST discard the
      duplicates.\n"
    title: 7.9.  Sequence Errors
  - contents:
    - "7.10.  Message Error Checking\n   In iSCSI implementations to date, there has
      been some uncertainty\n   regarding the extent to which incoming messages have
      to be checked\n   for protocol errors, beyond what is strictly required for
      processing\n   the inbound message.  This section addresses this question.\n
      \  Unless this document requires it, an iSCSI implementation is not\n   required
      to do an exhaustive protocol conformance check on an\n   incoming iSCSI PDU.
      \ The iSCSI implementation in particular is not\n   required to double-check
      the remote iSCSI implementation's\n   conformance to protocol requirements.\n"
    title: 7.10.  Message Error Checking
  - contents:
    - "7.11.  SCSI Timeouts\n   An iSCSI initiator MAY attempt to plug a command sequence
      gap on the\n   target end (in the absence of an acknowledgment of the command
      by way\n   of the ExpCmdSN) before the ULP timeout by retrying the\n   unacknowledged
      command, as described in Section 7.2.\n   On a ULP timeout for a command (that
      carried a CmdSN of n), if the\n   iSCSI initiator intends to continue the session
      it MUST abort the\n   command by using either an appropriate Task Management
      Function\n   Request for the specific command or a \"close the connection\"
      logout.\n   When using an ABORT TASK, if the ExpCmdSN is still less than (n
      + 1),\n   the target may see the abort request while missing the original\n
      \  command itself, due to one of the following reasons:\n      - The original
      command was dropped due to digest error.\n      - The connection on which the
      original command was sent was\n        successfully logged out.  On logout,
      the unacknowledged commands\n        issued on the connection being logged out
      are discarded.\n   If the abort request is received and the original command
      is missing,\n   targets MUST consider the original command with that RefCmdSN
      as\n   received and issue a task management response with the response code\n
      \  \"Function complete\".  This response concludes the task on both ends.\n
      \  If the abort request is received and the target can determine (based\n   on
      the Referenced Task Tag) that the command was received and\n   executed, and
      also that the response was sent prior to the abort,\n   then the target MUST
      respond with the response code \"Task Does Not\n   Exist\".\n"
    title: 7.11.  SCSI Timeouts
  - contents:
    - "7.12.  Negotiation Failures\n   Text Request and Response sequences, when used
      to set/negotiate\n   operational parameters, constitute the negotiation/parameter
      setting.\n   A negotiation failure is considered to be one or more of the\n
      \  following:\n      - For a negotiated key, none of the choices are acceptable
      to one\n        of the sides in the negotiation.\n      - For a declarative
      key, the declared value is not acceptable to\n        the other side in the
      negotiation.\n      - The Text Request timed out and possibly terminated.\n
      \     - The Text Request was answered with a Reject PDU.\n   The following two
      rules should be used to address negotiation\n   failures:\n      a) During login,
      any failure in negotiation MUST be considered a\n         login process failure;
      the Login Phase, along with the\n         connection, MUST be terminated.  If
      the target detects the\n         failure, it must terminate the login with the
      appropriate Login\n         response code.\n      b) A failure in negotiation
      during the Full Feature Phase will\n         terminate the entire negotiation
      sequence, which may consist of\n         a series of Text Requests that use
      the same Initiator Task Tag.\n         The operational parameters of the session
      or the connection\n         MUST continue to be the values agreed upon during
      an earlier\n         successful negotiation (i.e., any partial results of this\n
      \        unsuccessful negotiation MUST NOT take effect and MUST be\n         discarded).\n"
    title: 7.12.  Negotiation Failures
  - contents:
    - "7.13.  Protocol Errors\n   Mapping framed messages over a \"streaming\" connection
      such as TCP\n   makes the proposed mechanisms vulnerable to simple software
      framing\n   errors.  On the other hand, the introduction of framing mechanisms
      to\n   limit the effects of these errors may be onerous on performance for\n
      \  simple implementations.  Command sequence numbers and the mechanisms\n   for
      dropping and reestablishing connections (discussed earlier in\n   Section 7
      and its subsections) help handle this type of mapping\n   errors.\n   All violations
      of iSCSI PDU exchange sequences specified in this\n   document are also protocol
      errors.  This category of errors can only\n   be addressed by fixing the implementations;
      iSCSI defines Reject and\n   response codes to enable this.\n"
    title: 7.13.  Protocol Errors
  - contents:
    - "7.14.  Connection Failures\n   iSCSI can keep a session in operation if it
      is able to keep/establish\n   at least one TCP connection between the initiator
      and the target in a\n   timely fashion.  Targets and/or initiators may recognize
      a failing\n   connection by either transport-level means (TCP), a gap in the\n
      \  command sequence number, a response stream that is not filled for a\n   long
      time, or a failing iSCSI NOP (acting as a ping).  The latter MAY\n   be used
      periodically to increase the speed and likelihood of\n   detecting connection
      failures.  As an example for transport-level\n   means, initiators and targets
      MAY also use the keep-alive option (see\n   [RFC1122]) on the TCP connection
      to enable early link failure\n   detection on otherwise idle links.\n   On connection
      failure, the initiator and target MUST do one of the\n   following:\n      a)
      Attempt connection recovery within the session (Connection\n         Recovery).\n
      \     b) Log out the connection with the reason code \"close the\n         connection\"
      (Section 11.14.5), reissue missing commands, and\n         implicitly terminate
      all active commands.  This option requires\n         support for the Within-connection
      recovery class (recovery\n         within-connection).\n      c) Perform session
      recovery (Session Recovery).\n   Either side may choose to escalate to session
      recovery (via the\n   initiator dropping all the connections or via an Async
      Message that\n   announces the similar intent from a target), and the other
      side MUST\n   give it precedence.  On a connection failure, a target MUST terminate\n
      \  and/or discard all of the active immediate commands, regardless of\n   which
      of the above options is used (i.e., immediate commands are not\n   recoverable
      across connection failures).\n"
    title: 7.14.  Connection Failures
  - contents:
    - "7.15.  Session Errors\n   If all of the connections of a session fail and cannot
      be\n   reestablished in a short time, or if initiators detect protocol\n   errors
      repeatedly, an initiator may choose to terminate a session and\n   establish
      a new session.\n   In this case, the initiator takes the following actions:\n
      \     - Resets or closes all the transport connections.\n      - Terminates
      all outstanding requests with an appropriate response\n        before initiating
      a new session.  If the same I_T nexus is\n        intended to be reestablished,
      the initiator MUST employ session\n        reinstatement (see Section 6.3.5).\n
      \  When the session timeout (the connection state timeout for the last\n   failed
      connection) happens on the target, it takes the following\n   actions:\n      -
      Resets or closes the TCP connections (closes the session).\n      - Terminates
      all active tasks that were allegiant to the\n        connection(s) that constituted
      the session.\n   A target MUST also be prepared to handle a session reinstatement\n
      \  request from the initiator that may be addressing session errors.\n"
    title: 7.15.  Session Errors
  title: 7.  iSCSI Error Handling and Recovery
- contents:
  - "8.  State Transitions\n   iSCSI connections and iSCSI sessions go through several
    well-defined\n   states from the time they are created to the time they are cleared.\n
    \  The connection state transitions are described in two separate but\n   dependent
    sets of state diagrams for ease in understanding.  The\n   first set of diagrams,
    \"standard connection state diagrams\",\n   describes the connection state transitions
    when the iSCSI connection\n   is not waiting for, or undergoing, a cleanup by
    way of an explicit or\n   implicit logout.  The second set, \"connection cleanup
    state diagram\",\n   describes the connection state transitions while performing
    the iSCSI\n   connection cleanup.  While the first set has two diagrams -- one
    each\n   for initiator and target -- the second set has a single diagram\n   applicable
    to both initiators and targets.\n   The \"session state diagram\" describes the
    state transitions an iSCSI\n   session would go through during its lifetime, and
    it depends on the\n   states of possibly multiple iSCSI connections that participate
    in the\n   session.\n   States and transitions are described in text, tables,
    and diagrams.\n   The diagrams are used for illustration.  The text and the tables
    are\n   the governing specification.\n"
  - contents:
    - '8.1.  Standard Connection State Diagrams

      '
    - contents:
      - "8.1.1.  State Descriptions for Initiators and Targets\n   State descriptions
        for the standard connection state diagram are as\n   follows:\n   S1: FREE\n
        \      - initiator: State on instantiation, or after successful\n         connection
        closure.\n       - target: State on instantiation, or after successful\n         connection
        closure.\n   S2: XPT_WAIT\n       - initiator: Waiting for a response to its
        transport\n         connection establishment request.\n       - target: Illegal.\n
        \  S3: XPT_UP\n       - initiator: Illegal.\n       - target: Waiting for
        the login process to commence.\n   S4: IN_LOGIN\n       - initiator: Waiting
        for the login process to conclude,\n         possibly involving several PDU
        exchanges.\n       - target: Waiting for the login process to conclude,\n
        \        possibly involving several PDU exchanges.\n   S5: LOGGED_IN\n       -
        initiator: In the Full Feature Phase, waiting for all\n         internal,
        iSCSI, and transport events.\n       - target: In the Full Feature Phase,
        waiting for all internal,\n         iSCSI, and transport events.\n   S6: IN_LOGOUT\n
        \      - initiator: Waiting for a Logout Response.\n       - target: Waiting
        for an internal event signaling completion\n         of logout processing.\n
        \  S7: LOGOUT_REQUESTED\n       - initiator: Waiting for an internal event
        signaling\n         readiness to proceed with Logout.\n       - target: Waiting
        for the Logout process to start after\n         having requested a Logout
        via an Async Message.\n   S8: CLEANUP_WAIT\n       - initiator: Waiting for
        the context and/or resources to\n         initiate the cleanup processing
        for this CSM.\n       - target: Waiting for the cleanup process to start for
        this CSM.\n"
      title: 8.1.1.  State Descriptions for Initiators and Targets
    - contents:
      - "8.1.2.  State Transition Descriptions for Initiators and Targets\n   T1:\n
        \      - initiator: Transport connect request was made (e.g., TCP SYN\n         sent).\n
        \      - target: Illegal.\n   T2:\n       - initiator: Transport connection
        request timed out, a\n         transport reset was received, or an internal
        event of\n         receiving a Logout Response (success) on another connection\n
        \        for a \"close the session\" Logout Request was received.\n       -
        target: Illegal.\n   T3:\n       - initiator: Illegal.\n       - target: Received
        a valid transport connection request that\n         establishes the transport
        connection.\n   T4:\n       - initiator: Transport connection established,
        thus\n         prompting the initiator to start the iSCSI Login.\n       -
        target: Initial iSCSI Login Request was received.\n   T5:\n       - initiator:
        The final iSCSI Login Response with a Status-Class\n         of zero was received.\n
        \      - target: The final iSCSI Login Request to conclude the\n         Login
        Phase was received, thus prompting the target to send\n         the final
        iSCSI Login Response with a Status-Class of zero.\n   T6:\n       - initiator:
        Illegal.\n       - target: Timed out waiting for an iSCSI Login, transport\n
        \        disconnect indication was received, transport reset was\n         received,
        or an internal event indicating a transport\n         timeout was received.
        \ In all these cases, the connection is\n         to be closed.\n   T7:\n
        \      - initiator: One of the following events caused the transition:\n         a)
        The final iSCSI Login Response was received with a\n            non-zero Status-Class.\n
        \        b) Login timed out.\n         c) A transport disconnect indication
        was received.\n         d) A transport reset was received.\n         e) An
        internal event indicating a transport timeout was\n            received.\n
        \        f) An internal event of receiving a Logout Response\n            (success)
        on another connection for a \"close the\n            session\" Logout Request
        was received.\n       In all these cases, the transport connection is closed.\n
        \      - target: One of the following events caused the transition:\n         a)
        The final iSCSI Login Request to conclude the Login\n            Phase was
        received, prompting the target to send the\n            final iSCSI Login
        Response with a non-zero Status-Class.\n         b) Login timed out.\n         c)
        A transport disconnect indication was received.\n         d) A transport reset
        was received.\n         e) An internal event indicating a transport timeout
        was\n            received.\n         f) On another connection, a \"close the
        session\" Logout Request\n            was received.\n       In all these cases,
        the connection is to be closed.\n   T8:\n       - initiator: An internal event
        of receiving a Logout\n         Response (success) on another connection for
        a \"close the\n         session\" Logout Request was received, thus closing
        this\n         connection and requiring no further cleanup.\n       - target:
        An internal event of sending a Logout Response\n         (success) on another
        connection for a \"close the session\"\n         Logout Request was received,
        or an internal event of a\n         successful connection/session reinstatement
        was received,\n         thus prompting the target to close this connection
        cleanly.\n   T9, T10:\n       - initiator: An internal event that indicates
        the readiness\n         to start the Logout process was received, thus prompting
        an\n         iSCSI Logout to be sent by the initiator.\n       - target: An
        iSCSI Logout Request was received.\n   T11, T12:\n       - initiator: An Async
        PDU with AsyncEvent \"Request Logout\"\n         was received.\n       - target:
        An internal event that requires the decommissioning\n         of the connection
        was received, thus causing an Async PDU with\n         an AsyncEvent \"Request
        Logout\" to be sent.\n   T13:\n       - initiator: An iSCSI Logout Response
        (success) was received,\n         or an internal event of receiving a Logout
        Response (success)\n         on another connection for a \"close the session\"
        Logout Request\n         was received.\n       - target: An internal event
        was received that indicates\n         successful processing of the Logout,
        which prompts an iSCSI\n         Logout Response (success) to be sent; an
        internal event of\n         sending a Logout Response (success) on another
        connection\n         for a \"close the session\" Logout Request was received;
        or\n         an internal event of a successful connection/session\n         reinstatement
        was received.  In all these cases, the\n         transport connection is closed.\n
        \  T14:\n       - initiator: An Async PDU with AsyncEvent \"Request Logout\"\n
        \        was received again.\n       - target: Illegal.\n   T15, T16:\n       -
        initiator: One or more of the following events caused this\n         transition:\n
        \        a) An internal event that indicates a transport connection\n            timeout
        was received, thus prompting a transport reset\n            or transport connection
        closure.\n         b) A transport reset was received.\n         c) A transport
        disconnect indication was received.\n         d) An Async PDU with AsyncEvent
        \"Drop connection\" (for this\n            CID) was received.\n         e)
        An Async PDU with AsyncEvent \"Drop all connections\" was\n            received.\n
        \      - target: One or more of the following events caused this\n         transition:\n
        \        a) Internal event that indicates that a transport connection\n            timeout
        was received, thus prompting a transport reset\n            or transport connection
        closure.\n         b) An internal event of a failed connection/session\n            reinstatement
        was received.\n         c) A transport reset was received.\n         d) A
        transport disconnect indication was received.\n         e) An internal emergency
        cleanup event was received, which\n            prompts an Async PDU with AsyncEvent
        \"Drop connection\" (for\n            this CID), or event \"Drop all connections\".\n
        \  T17:\n       - initiator: One or more of the following events caused this\n
        \        transition:\n         a) A Logout Response (failure, i.e., a non-zero
        status)\n            was received, or Logout timed out.\n         b) Any of
        the events specified for T15 and T16 occurred.\n       - target: One or more
        of the following events caused this\n         transition:\n         a) An
        internal event that indicates a failure of the\n            Logout processing
        was received, which prompts a\n            Logout Response (failure, i.e.,
        a non-zero status)\n            to be sent.\n         b) Any of the events
        specified for T15 and T16 occurred.\n   T18:\n       - initiator: An internal
        event of receiving a Logout\n         Response (success) on another connection
        for a \"close the\n         session\" Logout Request was received.\n       -
        target: An internal event of sending a Logout Response\n         (success)
        on another connection for a \"close the session\"\n         Logout Request
        was received, or an internal event of a\n         successful connection/session
        reinstatement was received.\n         In both these cases, the connection
        is closed.\n   The CLEANUP_WAIT state (S8) implies that there are possible
        iSCSI\n   tasks that have not reached conclusion and are still considered\n
        \  busy.\n"
      title: 8.1.2.  State Transition Descriptions for Initiators and Targets
    - contents:
      - "8.1.3.  Standard Connection State Diagram for an Initiator\n   Symbolic names
        for states:\n      S1: FREE\n      S2: XPT_WAIT\n      S4: IN_LOGIN\n      S5:
        LOGGED_IN\n      S6: IN_LOGOUT\n      S7: LOGOUT_REQUESTED\n      S8: CLEANUP_WAIT\n
        \  States S5, S6, and S7 constitute the Full Feature Phase operation of\n
        \  the connection.\n   The state diagram is as follows:\n                        -------<-------------+\n
        \           +--------->/ S1    \\<----+       |\n         T13|       +->\\
        \      /<-+   \\      |\n            |      /    ---+---    \\   \\     |\n
        \           |     /        |     T2 \\   |    |\n            |  T8 |        |T1
        \      |  |    |\n            |     |        |        /   |T7  |\n            |
        \    |        |       /    |    |\n            |     |        |      /     |
        \   |\n            |     |        V     /     /     |\n            |     |
        \    ------- /     /      |\n            |     |    / S2    \\     /       |\n
        \           |     |    \\       /    /        |\n            |     |     ---+---
        \   /         |\n            |     |        |T4    /          |\n            |
        \    |        V     /           | T18\n            |     |     ------- /            |\n
        \           |     |    / S4    \\             |\n            |     |    \\
        \      /             |\n            |     |     ---+---              |         T15\n
        \           |     |        |T5      +--------+---------+\n            |     |
        \       |       /T16+-----+------+  |\n            |     |        |      /
        \  -+-----+--+   |  |\n            |     |        |     /   /  S7   \\  |T12|
        \ |\n            |     |        |    / +->\\       /<-+   V  V\n            |
        \    |        |   / /    -+-----       -------\n            |     |        |
        \ / /T11   |T10        /  S8   \\\n            |     |        V / /       V
        \ +----+   \\       /\n            |     |      ---+-+-      ----+--  |    -------\n
        \           |     |     / S5    \\T9  / S6    \\<+      ^\n            |     +-----\\
        \      /--->\\       / T14    |\n            |            -------      --+---+---------+T17\n
        \           +---------------------------+\n   The following state transition
        table represents the above diagram.\n   Each row represents the starting state
        for a given transition, which,\n   after taking a transition marked in a table
        cell, would end in the\n   state represented by the column of the cell.  For
        example, from\n   state S1, the connection takes the T1 transition to arrive
        at\n   state S2.  The fields marked \"-\" correspond to undefined transitions.\n
        \     +----+---+---+---+---+----+---+\n      |S1  |S2 |S4 |S5 |S6 |S7  |S8
        |\n   ---+----+---+---+---+---+----+---+\n    S1| -  |T1 | - | - | - | -  |
        - |\n   ---+----+---+---+---+---+----+---+\n    S2|T2  |-  |T4 | - | - | -
        \ | - |\n   ---+----+---+---+---+---+----+---+\n    S4|T7  |-  |-  |T5 | -
        | -  | - |\n   ---+----+---+---+---+---+----+---+\n    S5|T8  |-  |-  | -
        |T9 |T11 |T15|\n   ---+----+---+---+---+---+----+---+\n    S6|T13 |-  |-  |
        - |T14|-   |T17|\n   ---+----+---+---+---+---+----+---+\n    S7|T18 |-  |-
        \ | - |T10|T12 |T16|\n   ---+----+---+---+---+---+----+---+\n    S8| -  |-
        \ |-  | - | - | -  | - |\n   ---+----+---+---+---+---+----+---+\n"
      title: 8.1.3.  Standard Connection State Diagram for an Initiator
    - contents:
      - "8.1.4.  Standard Connection State Diagram for a Target\n   Symbolic names
        for states:\n      S1: FREE\n      S3: XPT_UP\n      S4: IN_LOGIN\n      S5:
        LOGGED_IN\n      S6: IN_LOGOUT\n      S7: LOGOUT_REQUESTED\n      S8: CLEANUP_WAIT\n
        \  States S5, S6, and S7 constitute the Full Feature Phase operation of\n
        \  the connection.\n   The state diagram is as follows:\n                           -------<-------------+\n
        \              +--------->/ S1    \\<----+       |\n            T13|       +->\\
        \      /<-+   \\      |\n               |      /    ---+---    \\   \\     |\n
        \              |     /        |     T6 \\   |    |\n               |  T8 |
        \       |T3       |  |    |\n               |     |        |        /   |T7
        \ |\n               |     |        |       /    |    |\n               |     |
        \       |      /     |    |\n               |     |        V     /     /     |\n
        \              |     |     ------- /     /      |\n               |     |
        \   / S3    \\     /       |\n               |     |    \\       /    /        |
        T18\n               |     |     ---+---    /         |\n               |     |
        \       |T4    /          |\n               |     |        V     /           |\n
        \              |     |     ------- /            |\n               |     |
        \   / S4    \\             |\n               |     |    \\       /             |\n
        \              |     |     ---+---         T15  |\n               |     |
        \       |T5      +--------+---------+\n               |     |        |       /T16+-----+------+
        \ |\n               |     |        |      /  -+-----+---+   |  |\n               |
        \    |        |     /   /  S7   \\  |T12|  |\n               |     |        |
        \   / +->\\       /<-+   V  V\n               |     |        |   / /    -+-----
        \      -------\n               |     |        |  / /T11   |T10        /  S8
        \  \\\n               |     |        V / /       V           \\       /\n
        \              |     |      ---+-+-      -------       -------\n               |
        \    |     / S5    \\T9  / S6    \\        ^\n               |     +-----\\
        \      /--->\\       /        |\n               |            -------      --+---+---------+T17\n
        \              +---------------------------+\n   The following state transition
        table represents the above diagram and\n   follows the conventions described
        for the initiator diagram.\n      +----+---+---+---+---+----+---+\n      |S1
        \ |S3 |S4 |S5 |S6 |S7  |S8 |\n   ---+----+---+---+---+---+----+---+\n    S1|
        -  |T3 | - | - | - | -  | - |\n   ---+----+---+---+---+---+----+---+\n    S3|T6
        \ |-  |T4 | - | - | -  | - |\n   ---+----+---+---+---+---+----+---+\n    S4|T7
        \ |-  |-  |T5 | - | -  | - |\n   ---+----+---+---+---+---+----+---+\n    S5|T8
        \ |-  |-  | - |T9 |T11 |T15|\n   ---+----+---+---+---+---+----+---+\n    S6|T13
        |-  |-  | - |-  |-   |T17|\n   ---+----+---+---+---+---+----+---+\n    S7|T18
        |-  |-  | - |T10|T12 |T16|\n   ---+----+---+---+---+---+----+---+\n    S8|
        -  |-  |-  | - | - | -  | - |\n   ---+----+---+---+---+---+----+---+\n"
      title: 8.1.4.  Standard Connection State Diagram for a Target
    title: 8.1.  Standard Connection State Diagrams
  - contents:
    - "8.2.  Connection Cleanup State Diagram for Initiators and Targets\n   Symbolic
      names for states:\n      R1: CLEANUP_WAIT (same as S8)\n      R2: IN_CLEANUP\n
      \     R3: FREE (same as S1)\n   Whenever a connection state machine in cleanup
      (let's call it CSM-C)\n   enters the CLEANUP_WAIT state (S8), it must go through
      the state\n   transitions described in the connection cleanup state diagram,
      using\n   either a) a separate Full Feature Phase connection (let's call it\n
      \  CSM-E, for explicit) in the LOGGED_IN state in the same session or\n   b)
      a new transport connection (let's call it CSM-I, for implicit) in\n   the FREE
      state that is to be added to the same session.  In the CSM-E\n   case, an explicit
      logout for the CID that corresponds to CSM-C (as\n   either a connection or
      session logout) needs to be performed to\n   complete the cleanup.  In the CSM-I
      case, an implicit logout for the\n   CID that corresponds to CSM-C needs to
      be performed by way of\n   connection reinstatement (Section 6.3.4) for that
      CID.  In either\n   case, the protocol exchanges on CSM-E or CSM-I determine
      the state\n   transitions for CSM-C.  Therefore, this cleanup state diagram
      is only\n   applicable to the instance of the connection in cleanup (i.e.,\n
      \  CSM-C).  In the case of an implicit logout, for example, CSM-C\n   reaches
      FREE (R3) at the time CSM-I reaches LOGGED_IN.  In the case\n   of an explicit
      logout, CSM-C reaches FREE (R3) when CSM-E receives a\n   successful Logout
      Response while continuing to be in the LOGGED_IN\n   state.\n   An initiator
      must initiate an explicit or implicit connection logout\n   for a connection
      in the CLEANUP_WAIT state, if the initiator intends\n   to continue using the
      associated iSCSI session.\n   The following state diagram applies to both initiators
      and targets.\n   (M1, M2, M3, and M4 are defined in Section 8.2.2.)\n                           ---------\n
      \                         / R1      \\\n                      +---\\         /<-+\n
      \                    /     ----+----    \\\n                    /          |
      \        \\ M3\n                 M1 |          |M2        |\n                    |
      \         |         /\n                    |          |        /\n                    |
      \         |       /\n                    |          V      /\n                    |
      \      ---------/\n                    |      / R2      \\\n                    |
      \     \\         /\n                    |       ---------\n                    |
      \         |\n                    |          |M4\n                    |          |\n
      \                   |          |\n                    |          |\n                    |
      \         V\n                    |       --------\n                    |      /
      R3     \\\n                    +----->\\        /\n                            --------\n
      \  The following state transition table represents the above diagram and\n   follows
      the same conventions as in earlier sections.\n        +----+----+----+\n        |R1
      \ |R2  |R3  |\n   -----+----+----+----+\n    R1  | -  |M2  |M1  |\n   -----+----+----+----+\n
      \   R2  |M3  | -  |M4  |\n   -----+----+----+----+\n    R3  | -  | -  | -  |\n
      \  -----+----+----+----+\n"
    - contents:
      - "8.2.1.  State Descriptions for Initiators and Targets\n   R1: CLEANUP_WAIT
        (same as S8)\n       - initiator: Waiting for the internal event to initiate
        the\n         cleanup processing for CSM-C.\n       - target: Waiting for
        the cleanup process to start for CSM-C.\n   R2: IN_CLEANUP\n       - initiator:
        Waiting for the connection cleanup process to\n         conclude for CSM-C.\n
        \      - target: Waiting for the connection cleanup process to conclude\n
        \        for CSM-C.\n   R3: FREE (same as S1)\n       - initiator: End state
        for CSM-C.\n       - target: End state for CSM-C.\n"
      title: 8.2.1.  State Descriptions for Initiators and Targets
    - contents:
      - "8.2.2.  State Transition Descriptions for Initiators and Targets\n   M1:
        One or more of the following events was received:\n       - initiator:\n         *
        An internal event that indicates connection state timeout.\n         * An
        internal event of receiving a successful Logout Response\n           on a
        different connection for a \"close the session\" Logout.\n       - target:\n
        \        * An internal event that indicates connection state timeout.\n         *
        An internal event of sending a Logout Response (success) on a\n           different
        connection for a \"close the session\" Logout\n           Request.\n   M2:
        An implicit/explicit logout process was initiated by the\n       initiator.\n
        \      - In CSM-I usage:\n         * initiator: An internal event requesting
        the connection (or\n           session) reinstatement was received, thus prompting
        a\n           connection (or session) reinstatement Login to be sent,\n           transitioning
        CSM-I to state IN_LOGIN.\n         * target: A connection/session reinstatement
        Login was received\n           while in state XPT_UP.\n       - In CSM-E usage:\n
        \        * initiator: An internal event was received that indicates that\n
        \          an explicit logout was sent for this CID in state LOGGED_IN.\n
        \        * target: An explicit logout was received for this CID in state\n
        \          LOGGED_IN.\n   M3: Logout failure was detected.\n       - In CSM-I
        usage:\n         * initiator: CSM-I failed to reach LOGGED_IN and arrived
        into\n           FREE instead.\n         * target: CSM-I failed to reach LOGGED_IN
        and arrived into FREE\n           instead.\n       - In CSM-E usage:\n         *
        initiator: either CSM-E moved out of LOGGED_IN, or Logout\n           timed
        out and/or aborted, or Logout Response (failure) was\n           received.\n
        \        * target: either CSM-E moved out of LOGGED_IN, Logout timed out\n
        \          and/or aborted, or an internal event that indicates that a\n           failed
        Logout processing was received.  A Logout Response\n           (failure) was
        sent in the last case.\n   M4: Successful implicit/explicit logout was performed.\n
        \      - In CSM-I usage:\n         * initiator: CSM-I reached state LOGGED_IN,
        or an internal\n           event of receiving a Logout Response (success)
        on another\n           connection for a \"close the session\" Logout Request
        was\n           received.\n         * target: CSM-I reached state LOGGED_IN,
        or an internal event\n           of sending a Logout Response (success) on
        a different\n           connection for a \"close the session\" Logout Request
        was\n           received.\n       - In CSM-E usage:\n         * initiator:
        CSM-E stayed in LOGGED_IN and received a Logout\n           Response (success),
        or an internal event of receiving a\n           Logout Response (success)
        on another connection for a \"close\n           the session\" Logout Request
        was received.\n         * target: CSM-E stayed in LOGGED_IN and an internal
        event\n           indicating a successful Logout processing was received,
        or an\n           internal event of sending a Logout Response (success) on
        a\n           different connection for a \"close the session\" Logout Request\n
        \          was received.\n"
      title: 8.2.2.  State Transition Descriptions for Initiators and Targets
    title: 8.2.  Connection Cleanup State Diagram for Initiators and Targets
  - contents:
    - '8.3.  Session State Diagrams

      '
    - contents:
      - "8.3.1.  Session State Diagram for an Initiator\n   Symbolic names for states:\n
        \     Q1: FREE\n      Q3: LOGGED_IN\n      Q4: FAILED\n   State Q3 represents
        the Full Feature Phase operation of the session.\n   The state diagram is
        as follows.  (N1, N3, N4, N5, and N6 are defined\n   in Section 8.3.4.)\n
        \                                  ---------\n                                  /
        Q1      \\\n                      +---------->\\         /<-+\n                     /
        \            ----+----   |\n                    /                  |       |N3\n
        \               N6  |                  |N1     |\n                    |                  |
        \      |\n                    |       N4         |       |\n                    |
        +------------+   |      /\n                    | |            |   |     /\n
        \                   | |            |   |    /\n                    | |            V
        \  V   /\n                  --+-+---         -------+-\n                 /
        Q4     \\ N5    / Q3      \\\n                 \\        /<------\\         /\n
        \                 --------         ---------\n   The state transition table
        is as follows:\n        +---+---+---+\n        |Q1 |Q3 |Q4 |\n   -----+---+---+---+\n
        \   Q1  | - |N1 | - |\n   -----+---+---+---+\n    Q3  |N3 | - |N5 |\n   -----+---+---+---+\n
        \   Q4  |N6 |N4 | - |\n   -----+---+---+---+\n"
      title: 8.3.1.  Session State Diagram for an Initiator
    - contents:
      - "8.3.2.  Session State Diagram for a Target\n   Symbolic names for states:\n
        \     Q1: FREE\n      Q2: ACTIVE\n      Q3: LOGGED_IN\n      Q4: FAILED\n
        \     Q5: IN_CONTINUE\n   State Q3 represents the Full Feature Phase operation
        of the session.\n   The state diagram is as follows:\n                                           ---------\n
        \                    +------------------->/ Q1      \\\n                    /
        \    +-------------->\\         /<-+\n                    |     |                ---+-----
        \  |\n                    |     |                 ^ |        |N3\n                 N6
        |     |N11            N9| V N1     |\n                    |     |                 +--------
        \ |\n                    |     |                / Q2      \\ |\n                    |
        \    |                \\         / |\n                    |  ---+-----            +--+-----
        \ |\n                    | / Q5      \\              |       |\n                    |
        \\         / N10          |       |\n                    |  -+-+----+-----------+
        \  | N2   /\n                    |   ^ |                |   |     /\n                    |
        N7| |N8              |   |    /\n                    |   | |                |
        \  V   /\n                  --+---+-V                V------+-\n                 /
        Q4      \\ N5           / Q3      \\\n                 \\         /<-------------\\
        \        /\n                  ---------                ---------\n   The state
        transition table is as follows:\n        +----+----+----+----+----+\n        |Q1
        \ |Q2  |Q3  |Q4  |Q5  |\n   -----+----+----+----+----+----+\n    Q1  | -  |N1
        \ | -  | -  | -  |\n   -----+----+----+----+----+----+\n    Q2  |N9  | -  |N2
        \ | -  | -  |\n   -----+----+----+----+----+----+\n    Q3  |N3  | -  | -  |N5
        \ | -  |\n   -----+----+----+----+----+----+\n    Q4  |N6  | -  | -  | -  |N7
        \ |\n   -----+----+----+----+----+----+\n    Q5  |N11 | -  |N10 |N8  | -  |\n
        \  -----+----+----+----+----+----+\n"
      title: 8.3.2.  Session State Diagram for a Target
    - contents:
      - "8.3.3.  State Descriptions for Initiators and Targets\n   Q1: FREE\n       -
        initiator: State on instantiation or after cleanup.\n       - target: State
        on instantiation or after cleanup.\n   Q2: ACTIVE\n       - initiator: Illegal.\n
        \      - target: The first iSCSI connection in the session transitioned\n
        \        to IN_LOGIN, waiting for it to complete the login process.\n   Q3:
        LOGGED_IN\n       - initiator: Waiting for all session events.\n       - target:
        Waiting for all session events.\n   Q4: FAILED\n       - initiator: Waiting
        for session recovery or session\n         continuation.\n       - target:
        Waiting for session recovery or session continuation.\n   Q5: IN_CONTINUE\n
        \      - initiator: Illegal.\n       - target: Waiting for session continuation
        attempt to reach a\n         conclusion.\n"
      title: 8.3.3.  State Descriptions for Initiators and Targets
    - contents:
      - "8.3.4.  State Transition Descriptions for Initiators and Targets\n   N1:\n
        \      - initiator: At least one transport connection reached the\n         LOGGED_IN
        state.\n       - target: The first iSCSI connection in the session had reached\n
        \        the IN_LOGIN state.\n   N2:\n       - initiator: Illegal.\n       -
        target: At least one iSCSI connection reached the LOGGED_IN\n         state.\n
        \  N3:\n       - initiator: Graceful closing of the session via session closure\n
        \        (Section 6.3.6).\n       - target: Graceful closing of the session
        via session closure\n         (Section 6.3.6) or a successful session reinstatement
        cleanly\n         closed the session.\n   N4:\n       - initiator: A session
        continuation attempt succeeded.\n       - target: Illegal.\n   N5:\n       -
        initiator: Session failure (Section 6.3.6) occurred.\n       - target: Session
        failure (Section 6.3.6) occurred.\n   N6:\n       - initiator: Session state
        timeout occurred, or a session\n         reinstatement cleared this session
        instance.  This results in\n         the freeing of all associated resources,
        and the session state\n         is discarded.\n       - target: Session state
        timeout occurred, or a session\n         reinstatement cleared this session
        instance.  This results in\n         the freeing of all associated resources,
        and the session state\n         is discarded.\n   N7:\n       - initiator:
        Illegal.\n       - target: A session continuation attempt was initiated.\n
        \  N8:\n       - initiator: Illegal.\n       - target: The last session continuation
        attempt failed.\n   N9:\n       - initiator: Illegal.\n       - target: Login
        attempt on the leading connection failed.\n   N10:\n       - initiator: Illegal.\n
        \      - target: A session continuation attempt succeeded.\n   N11:\n       -
        initiator: Illegal.\n       - target: A successful session reinstatement cleanly
        closed the\n         session.\n"
      title: 8.3.4.  State Transition Descriptions for Initiators and Targets
    title: 8.3.  Session State Diagrams
  title: 8.  State Transitions
- contents:
  - "9.  Security Considerations\n   Historically, native storage systems have not
    had to consider\n   security, because their environments offered minimal security
    risks.\n   That is, these environments consisted of storage devices either\n   directly
    attached to hosts or connected via a Storage Area Network\n   (SAN) distinctly
    separate from the communications network.  The use\n   of storage protocols, such
    as SCSI, over IP networks requires that\n   security concerns be addressed.  iSCSI
    implementations must provide\n   means of protection against active attacks (e.g.,
    pretending to be\n   another identity; message insertion, deletion, modification,
    and\n   replaying) and passive attacks (e.g., eavesdropping, gaining\n   advantage
    by analyzing the data sent over the line).\n   Although technically possible,
    iSCSI SHOULD NOT be configured without\n   security, specifically in-band authentication;
    see Section 9.2.\n   iSCSI configured without security should be confined to closed\n
    \  environments that have very limited and well-controlled security\n   risks.
    \ [RFC3723] specifies the mechanisms that must be used in order\n   to mitigate
    risks fully described in that document.\n   The following section describes the
    security mechanisms provided by\n   an iSCSI implementation.\n"
  - contents:
    - "9.1.  iSCSI Security Mechanisms\n   The entities involved in iSCSI security
      are the initiator, target,\n   and the IP communication endpoints.  iSCSI scenarios
      in which\n   multiple initiators or targets share a single communication endpoint\n
      \  are expected.  To accommodate such scenarios, iSCSI supports two\n   separate
      security mechanisms: in-band authentication between the\n   initiator and the
      target at the iSCSI connection level (carried out\n   by exchange of iSCSI Login
      PDUs), and packet protection (integrity,\n   authentication, and confidentiality)
      by IPsec at the IP level.  The\n   two security mechanisms complement each other.
      \ The in-band\n   authentication provides end-to-end trust (at login time) between
      the\n   iSCSI initiator and the target, while IPsec provides a secure channel\n
      \  between the IP communication endpoints.  iSCSI can be used to access\n   sensitive
      information for which significant security protection is\n   appropriate.  As
      further specified in the rest of this security\n   considerations section, both
      iSCSI security mechanisms are mandatory\n   to implement (MUST).  The use of
      in-band authentication is strongly\n   recommended (SHOULD).  In contrast, the
      use of IPsec is optional\n   (MAY), as the security risks that it addresses
      may only be present\n   over a subset of the networks used by an iSCSI connection
      or a\n   session; a specific example is that when an iSCSI session spans data\n
      \  centers, IPsec VPN gateways at the data center boundaries to protect\n   the
      WAN connectivity between data centers may be appropriate in\n   combination
      with in-band iSCSI authentication.\n   Further details on typical iSCSI scenarios
      and the relationship\n   between the initiators, targets, and the communication
      endpoints can\n   be found in [RFC3723].\n"
    title: 9.1.  iSCSI Security Mechanisms
  - contents:
    - "9.2.  In-Band Initiator-Target Authentication\n   During login, the target
      MAY authenticate the initiator and the\n   initiator MAY authenticate the target.
      \ The authentication is\n   performed on every new iSCSI connection by an exchange
      of iSCSI Login\n   PDUs using a negotiated authentication method.\n   The authentication
      method cannot assume an underlying IPsec\n   protection, because IPsec is optional
      to use.  An attacker should\n   gain as little advantage as possible by inspecting
      the authentication\n   phase PDUs.  Therefore, a method using cleartext (or
      equivalent)\n   passwords MUST NOT be used; on the other hand, identity protection
      is\n   not strictly required.\n   The authentication mechanism protects against
      an unauthorized login\n   to storage resources by using a false identity (spoofing).
      \ Once the\n   authentication phase is completed, if the underlying IPsec is
      not\n   used, all PDUs are sent and received in the clear.  The\n   authentication
      mechanism alone (without underlying IPsec) should only\n   be used when there
      is no risk of eavesdropping or of message\n   insertion, deletion, modification,
      and replaying.\n   Section 12 defines several authentication methods and the
      exact steps\n   that must be followed in each of them, including the iSCSI-text-keys\n
      \  and their allowed values in each step.  Whenever an iSCSI initiator\n   gets
      a response whose keys, or their values, are not according to the\n   step definition,
      it MUST abort the connection.\n   Whenever an iSCSI target gets a request or
      response whose keys, or\n   their values, are not according to the step definition,
      it MUST\n   answer with a Login reject with the \"Initiator Error\" or \"Missing\n
      \  Parameter\" status.  These statuses are not intended for\n   cryptographically
      incorrect values such as the CHAP response, for\n   which the \"Authentication
      Failure\" status MUST be specified.  The\n   importance of this rule can be
      illustrated in CHAP with target\n   authentication (see Section 12.1.3), where
      the initiator would have\n   been able to conduct a reflection attack by omitting
      its response key\n   (CHAP_R), using the same CHAP challenge as the target and
      reflecting\n   the target's response back to the target.  In CHAP, this is prevented\n
      \  because the target must answer the missing CHAP_R key with a\n   Login reject
      with the \"Missing Parameter\" status.\n   For some of the authentication methods,
      a key specifies the identity\n   of the iSCSI initiator or target for authentication
      purposes.  The\n   value associated with that key MAY be different from the
      iSCSI name\n   and SHOULD be configurable (CHAP_N: see Section 12.1.3; SRP_U:
      see\n   Section 12.1.2).  For this reason, iSCSI implementations SHOULD\n   manage
      authentication in a way that impersonation across iSCSI names\n   via these
      authentication identities is not possible.  Specifically,\n   implementations
      SHOULD allow configuration of an authentication\n   identity for a Name if different,
      and authentication credentials for\n   that identity.  During the login time,
      implementations SHOULD verify\n   the Name-to-identity relationship in addition
      to authenticating the\n   identity through the negotiated authentication method.\n
      \  When an iSCSI session has multiple TCP connections, either\n   concurrently
      or sequentially, the authentication method and\n   identities should not vary
      among the connections.  Therefore, all\n   connections in an iSCSI session SHOULD
      use the same authentication\n   method, iSCSI name, and authentication identity
      (for authentication\n   methods that use an authentication identity).  Implementations
      SHOULD\n   check this and cause an authentication failure on a new connection\n
      \  that uses a different authentication method, iSCSI name, or\n   authentication
      identity from those already used in the session.  In\n   addition, implementations
      SHOULD NOT support both authenticated and\n   unauthenticated TCP connections
      in the same iSCSI session, added\n   either concurrently or sequentially to
      the session.\n"
    - contents:
      - "9.2.1.  CHAP Considerations\n   Compliant iSCSI initiators and targets MUST
        implement the CHAP\n   authentication method [RFC1994] (according to Section
        12.1.3,\n   including the target authentication option).\n   When CHAP is
        performed over a non-encrypted channel, it is vulnerable\n   to an off-line
        dictionary attack.  Implementations MUST support the\n   use of up to 128-bit
        random CHAP secrets, including the means to\n   generate such secrets and
        to accept them from an external generation\n   source.  Implementations MUST
        NOT provide secret generation (or\n   expansion) means other than random generation.\n
        \  An administrative entity of an environment in which CHAP is used with\n
        \  a secret that has less than 96 random bits MUST enforce IPsec\n   encryption
        (according to the implementation requirements in\n   Section 9.3.2) to protect
        the connection.  Moreover, in this case,\n   IKE authentication with group
        pre-shared cryptographic keys SHOULD\n   NOT be used unless it is not essential
        to protect group members\n   against off-line dictionary attacks by other
        members.\n   CHAP secrets MUST be an integral number of bytes (octets).  A\n
        \  compliant implementation SHOULD NOT continue with the login step in\n   which
        it should send a CHAP response (CHAP_R; see Section 12.1.3)\n   unless it
        can verify that the CHAP secret is at least 96 bits or that\n   IPsec encryption
        is being used to protect the connection.\n   Any CHAP secret used for initiator
        authentication MUST NOT be\n   configured for authentication of any target,
        and any CHAP secret used\n   for target authentication MUST NOT be configured
        for authentication\n   of any initiator.  If the CHAP response received by
        one end of an\n   iSCSI connection is the same as the CHAP response that the
        receiving\n   endpoint would have generated for the same CHAP challenge, the\n
        \  response MUST be treated as an authentication failure and cause the\n   connection
        to close (this ensures that the same CHAP secret is not\n   used for authentication
        in both directions).  Also, if an iSCSI\n   implementation can function as
        both initiator and target, different\n   CHAP secrets and identities MUST
        be configured for these two roles.\n   The following is an example of the
        attacks prevented by the above\n   requirements:\n      a) \"Rogue\" wants
        to impersonate \"Storage\" to Alice and knows that\n         a single secret
        is used for both directions of Storage-Alice\n         authentication.\n      b)
        Rogue convinces Alice to open two connections to itself and\n         identifies
        itself as Storage on both connections.\n      c) Rogue issues a CHAP challenge
        on Connection 1, waits for Alice\n         to respond, and then reflects Alice's
        challenge as the initial\n         challenge to Alice on Connection 2.\n      d)
        If Alice doesn't check for the reflection across connections,\n         Alice's
        response on Connection 2 enables Rogue to impersonate\n         Storage on
        Connection 1, even though Rogue does not know the\n         Alice-Storage
        CHAP secret.\n   Originators MUST NOT reuse the CHAP challenge sent by the
        responder\n   for the other direction of a bidirectional authentication.\n
        \  Responders MUST check for this condition and close the iSCSI TCP\n   connection
        if it occurs.\n   The same CHAP secret SHOULD NOT be configured for authentication
        of\n   multiple initiators or multiple targets, as this enables any of them\n
        \  to impersonate any other one of them, and compromising one of them\n   enables
        the attacker to impersonate any of them.  It is recommended\n   that iSCSI
        implementations check for the use of identical CHAP\n   secrets by different
        peers when this check is feasible and take\n   appropriate measures to warn
        users and/or administrators when this is\n   detected.\n   When an iSCSI initiator
        or target authenticates itself to\n   counterparts in multiple administrative
        domains, it SHOULD use a\n   different CHAP secret for each administrative
        domain to avoid\n   propagating security compromises across domains.\n   Within
        a single administrative domain:\n      - A single CHAP secret MAY be used
        for authentication of an\n        initiator to multiple targets.\n      -
        A single CHAP secret MAY be used for an authentication of a\n        target
        to multiple initiators when the initiators use an\n        external server
        (e.g., RADIUS [RFC2865]) to verify the target's\n        CHAP responses and
        do not know the target's CHAP secret.\n   If an external response verification
        server (e.g., RADIUS) is not\n   used, employing a single CHAP secret for
        authentication of a target\n   to multiple initiators requires that all such
        initiators know that\n   target's secret.  Any of these initiators can impersonate
        the target\n   to any other such initiator, and compromise of such an initiator\n
        \  enables an attacker to impersonate the target to all such initiators.\n
        \  Targets SHOULD use separate CHAP secrets for authentication to each\n   initiator
        when such risks are of concern; in this situation, it may\n   be useful to
        configure a separate logical iSCSI target with its own\n   iSCSI Node Name
        for each initiator or group of initiators among which\n   such separation
        is desired.\n   The above requirements strengthen the security properties
        of CHAP\n   authentication for iSCSI by comparison to the basic CHAP\n   authentication
        mechanism [RFC1994].  It is very important to adhere\n   to these requirements,
        especially the requirements for strong (large\n   randomly generated) CHAP
        secrets, as iSCSI implementations and\n   deployments that fail to use strong
        CHAP secrets are likely to be\n   highly vulnerable to off-line dictionary
        attacks on CHAP secrets.\n   Replacement of CHAP with a better authentication
        mechanism is\n   anticipated in a future version of iSCSI.  The FC-SP-2 standard\n
        \  [FC-SP-2] has specified the Extensible Authentication Protocol -\n   Generalized
        Pre-Shared Key (EAP-GPSK) authentication mechanism\n   [RFC5433] as an alternative
        to (and possible future replacement for)\n   Fibre Channel's similar usage
        of strengthened CHAP.  Another possible\n   replacement for CHAP is a secure
        password mechanism, e.g., an updated\n   version of iSCSI's current SRP authentication
        mechanism.\n"
      title: 9.2.1.  CHAP Considerations
    - contents:
      - "9.2.2.  SRP Considerations\n   The strength of the SRP authentication method
        (specified in\n   [RFC2945]) is dependent on the characteristics of the group
        being\n   used (i.e., the prime modulus N and generator g).  As described
        in\n   [RFC2945], N is required to be a Sophie Germain prime (of the form\n
        \  N = 2q + 1, where q is also prime) and the generator g is a primitive\n
        \  root of GF(N).  In iSCSI authentication, the prime modulus N MUST be\n
        \  at least 768 bits.\n   The list of allowed SRP groups is provided in [RFC3723].\n"
      title: 9.2.2.  SRP Considerations
    - contents:
      - "9.2.3.  Kerberos Considerations\n   iSCSI uses raw Kerberos V5 [RFC4120]
        for authenticating a client\n   (iSCSI initiator) principal to a service (iSCSI
        target) principal.\n   Note that iSCSI does not use the Generic Security Service
        Application\n   Program Interface (GSS-API) [RFC2743] or the Kerberos V5 GSS-API\n
        \  security mechanism [RFC4121].  This means that iSCSI implementations\n
        \  supporting the KRB5 AuthMethod (Section 12.1) are directly involved\n   in
        the Kerberos protocol.  When Kerberos V5 is used for\n   authentication, the
        following actions MUST be performed as specified\n   in [RFC4120]:\n      -
        The target MUST validate KRB_AP_REQ to ensure that the initiator\n        can
        be trusted.\n      - When mutual authentication is selected, the initiator
        MUST\n        validate KRB_AP_REP to determine the outcome of mutual\n        authentication.\n
        \  As Kerberos V5 is capable of providing mutual authentication,\n   implementations
        SHOULD support mutual authentication by default for\n   login authentication.\n
        \  Note, however, that Kerberos authentication only assures that the\n   server
        (iSCSI target) can be trusted by the Kerberos client\n   (initiator) and vice
        versa; an initiator should employ appropriately\n   secured service discovery
        techniques (e.g., iSNS; see Section 4.2.7)\n   to ensure that it is talking
        to the intended target principal.\n   iSCSI does not use Kerberos v5 for either
        integrity or\n   confidentiality protection of the iSCSI protocol.  iSCSI
        uses IPsec\n   for those purposes as specified in Section 9.3.\n"
      title: 9.2.3.  Kerberos Considerations
    title: 9.2.  In-Band Initiator-Target Authentication
  - contents:
    - "9.3.  IPsec\n   iSCSI uses the IPsec mechanism for packet protection (cryptographic\n
      \  integrity, authentication, and confidentiality) at the IP level\n   between
      the iSCSI communicating endpoints.  The following sections\n   describe the
      IPsec protocols that must be implemented for data\n   authentication and integrity;
      confidentiality; and cryptographic key\n   management.\n   An iSCSI initiator
      or target may provide the required IPsec support\n   fully integrated or in
      conjunction with an IPsec front-end device.\n   In the latter case, the compliance
      requirements with regard to IPsec\n   support apply to the \"combined device\".
      \ Only the \"combined device\"\n   is to be considered an iSCSI device.\n   Detailed
      considerations and recommendations for using IPsec for iSCSI\n   are provided
      in [RFC3723] as updated by [RFC7146].  The IPsec\n   requirements are reproduced
      here for convenience and are intended to\n   match those in [RFC7146]; in the
      event of a discrepancy, the\n   requirements in [RFC7146] apply.\n"
    - contents:
      - "9.3.1.  Data Authentication and Integrity\n   Data authentication and integrity
        are provided by a cryptographic\n   keyed Message Authentication Code in every
        sent packet.  This code\n   protects against message insertion, deletion,
        and modification.\n   Protection against message replay is realized by using
        a sequence\n   counter.\n   An iSCSI-compliant initiator or target MUST provide
        data\n   authentication and integrity by implementing IPsec v2 [RFC2401] with\n
        \  ESPv2 [RFC2406] in tunnel mode, SHOULD provide data authentication\n   and
        integrity by implementing IPsec v3 [RFC4301] with ESPv3 [RFC4303]\n   in tunnel
        mode, and MAY provide data authentication and integrity by\n   implementing
        either IPsec v2 or v3 with the appropriate version of\n   ESP in transport
        mode.  The IPsec implementation MUST fulfill the\n   following iSCSI-specific
        requirements:\n      - HMAC-SHA1 MUST be implemented in the specific form
        of\n        HMAC-SHA-1-96 [RFC2404].\n      - AES CBC MAC with XCBC extensions
        using 128-bit keys SHOULD be\n        implemented [RFC3566].\n      - Implementations
        that support IKEv2 [RFC5996] SHOULD also\n        implement AES Galois Message
        Authentication Code (GMAC)\n        [RFC4543] using 128-bit keys.\n   The
        ESP anti-replay service MUST also be implemented.\n   At the high speeds at
        which iSCSI is expected to operate, a single\n   IPsec SA could rapidly exhaust
        the ESP 32-bit sequence number space,\n   requiring frequent rekeying of the
        SA, as rollover of the ESP\n   sequence number within a single SA is prohibited
        for both ESPv2\n   [RFC2406] and ESPv3 [RFC4303].  In order to provide the
        means to\n   avoid this potentially undesirable frequent rekeying, implementations\n
        \  that are capable of operating at speeds of 1 gigabit/second or higher\n
        \  MUST implement extended (64-bit) sequence numbers for ESPv2 (and\n   ESPv3,
        if supported) and SHOULD use extended sequence numbers for all\n   iSCSI traffic.
        \ Extended sequence number negotiation as part of\n   security association
        establishment is specified in [RFC4304] for\n   IKEv1 and [RFC5996] for IKEv2.\n"
      title: 9.3.1.  Data Authentication and Integrity
    - contents:
      - "9.3.2.  Confidentiality\n   Confidentiality is provided by encrypting the
        data in every packet.\n   When confidentiality is used, it MUST be accompanied
        by data\n   authentication and integrity to provide comprehensive protection\n
        \  against eavesdropping and against message insertion, deletion,\n   modification,
        and replaying.\n   An iSCSI-compliant initiator or target MUST provide confidentiality\n
        \  by implementing IPsec v2 [RFC2401] with ESPv2 [RFC2406] in tunnel\n   mode,
        SHOULD provide confidentiality by implementing IPsec v3\n   [RFC4301] with
        ESPv3 [RFC4303] in tunnel mode, and MAY provide\n   confidentiality by implementing
        either IPsec v2 or v3 with the\n   appropriate version of ESP in transport
        mode, with the following\n   iSCSI-specific requirements that apply to IPsec
        v2 and IPsec v3:\n      - 3DES in CBC mode MAY be implemented [RFC2451].\n
        \     - AES in CBC mode with 128-bit keys MUST be implemented [RFC3602];\n
        \       other key sizes MAY be supported.\n      - AES in Counter mode MAY
        be implemented [RFC3686].\n      - Implementations that support IKEv2 [RFC5996]
        SHOULD also\n        implement AES Galois/Counter Mode (GCM) with 128-bit
        keys\n        [RFC4106]; other key sizes MAY be supported.\n   Due to its
        inherent weakness, DES in CBC mode MUST NOT be used.\n   The NULL encryption
        algorithm MUST also be implemented.\n"
      title: 9.3.2.  Confidentiality
    - contents:
      - "9.3.3.  Policy, Security Associations, and Cryptographic Key Management\n
        \  A compliant iSCSI implementation MUST meet the cryptographic key\n   management
        requirements of the IPsec protocol suite.  Authentication,\n   security association
        negotiation, and cryptographic key management\n   MUST be provided by implementing
        IKE [RFC2409] using the IPsec DOI\n   [RFC2407] and SHOULD be provided by
        implementing IKEv2 [RFC5996],\n   with the following iSCSI-specific requirements:\n
        \     a) Peer authentication using a pre-shared cryptographic key MUST\n         be
        supported.  Certificate-based peer authentication using\n         digital
        signatures MAY be supported.  For IKEv1 ([RFC2409]),\n         peer authentication
        using the public key encryption methods\n         outlined in Sections 5.2
        and 5.3 of [RFC2409] SHOULD NOT be\n         used.\n      b) When digital
        signatures are used to achieve authentication, an\n         IKE negotiator
        SHOULD use IKE Certificate Request Payload(s) to\n         specify the certificate
        authority.  IKE negotiators SHOULD\n         check certificate validity via
        the pertinent Certificate\n         Revocation List (CRL) or via the use of
        the Online Certificate\n         Status Protocol (OCSP) [RFC6960] before accepting
        a PKI\n         certificate for use in IKE authentication procedures.  OCSP\n
        \        support within the IKEv2 protocol is specified in [RFC4806].\n         These
        checks may not be needed in environments where a small\n         number of
        certificates are statically configured as trust\n         anchors.\n      c)
        Conformant iSCSI implementations of IKEv1 MUST support Main\n         Mode
        and SHOULD support Aggressive Mode.  Main Mode with a\n         pre-shared
        key authentication method SHOULD NOT be used when\n         either the initiator
        or the target uses dynamically assigned\n         addresses.  While in many
        cases pre-shared keys offer good\n         security, situations in which dynamically
        assigned addresses\n         are used force the use of a group pre-shared
        key, which creates\n         vulnerability to a man-in-the-middle attack.\n
        \     d) In the IKEv1 Phase 2 Quick Mode, in exchanges for creating the\n
        \        Phase 2 SA, the Identification Payload MUST be present.\n      e)
        The following identification type requirements apply to IKEv1:\n         ID_IPV4_ADDR,
        ID_IPV6_ADDR (if the protocol stack supports\n         IPv6), and ID_FQDN
        Identification Types MUST be supported;\n         ID_USER_FQDN SHOULD be supported.
        \ The IP Subnet, IP Address\n         Range, ID_DER_ASN1_DN, and ID_DER_ASN1_GN
        Identification Types\n         SHOULD NOT be used.  The ID_KEY_ID Identification
        Type MUST NOT\n         be used.\n      f) If IKEv2 is supported, the following
        identification\n         requirements apply:  ID_IPV4_ADDR, ID_IPV6_ADDR (if
        the\n         protocol stack supports IPv6), and ID_FQDN Identification Types\n
        \        MUST be supported; ID_RFC822_ADDR SHOULD be supported.  The\n         ID_DER_ASN1_DN
        and ID_DER_ASN1_GN Identification Types SHOULD\n         NOT be used.  The
        ID_KEY_ID Identification Type MUST NOT be\n         used.\n   The reasons
        for the \"MUST NOT\" and \"SHOULD NOT\" for identification\n   type requirements
        in preceding bullets e) and f) are:\n      - IP Subnet and IP Address Range
        are too broad to usefully\n        identify an iSCSI endpoint.\n      - The
        DN and GN types are X.500 identities; it is usually better\n        to use
        an identity from subjectAltName in a PKI certificate.\n      - ID_KEY_ID is
        not interoperable as specified.\n   Manual cryptographic keying MUST NOT be
        used, because it does not\n   provide the necessary rekeying support.\n   When
        Diffie-Hellman (DH) groups are used, a DH group of at least\n   2048 bits
        SHOULD be offered as a part of all proposals to create\n   IPsec security
        associations to protect iSCSI traffic, with both IKEv1\n   and IKEv2.\n   When
        IPsec is used, the receipt of an IKEv1 Phase 2 delete message or\n   an IKEv2
        INFORMATIONAL exchange that deletes the SA SHOULD NOT be\n   interpreted as
        a reason for tearing down the iSCSI TCP connection.\n   If additional traffic
        is sent on it, a new IKE SA will be created to\n   protect it.\n   The method
        used by the initiator to determine whether the target\n   should be connected
        using IPsec is regarded as an issue of IPsec\n   policy administration and
        thus not defined in the iSCSI standard.\n   The method used by an initiator
        that supports both IPsec v2 and v3 to\n   determine which versions of IPsec
        are supported by the target is also\n   regarded as an issue of IPsec policy
        administration and thus not\n   defined in the iSCSI standard.  If both IPsec
        v2 and v3 are supported\n   by both the initiator and target, the use of IPsec
        v3 is recommended.\n   If an iSCSI target is discovered via a SendTargets
        request in a\n   Discovery session not using IPsec, the initiator should assume
        that\n   it does not need IPsec to establish a session to that target.  If
        an\n   iSCSI target is discovered using a Discovery session that does use\n
        \  IPsec, the initiator SHOULD use IPsec when establishing a session to\n
        \  that target.\n"
      title: 9.3.3.  Policy, Security Associations, and Cryptographic Key Management
    title: 9.3.  IPsec
  - contents:
    - "9.4.  Security Considerations for the X#NodeArchitecture Key\n   The security
      considerations in this section are specific to the\n   X#NodeArchitecture discussed
      in Section 13.26.\n   This extension key transmits specific implementation details
      about\n   the node that sends it; such details may be considered sensitive in\n
      \  some environments.  For example, if a certain software or firmware\n   version
      is known to contain security weaknesses, announcing the\n   presence of that
      version via this key may not be desirable.  The\n   countermeasures for this
      security concern are:\n      a) sending less detailed information in the key
      values,\n      b) not sending the extension key, or\n      c) using IPsec ([RFC4303])
      to provide confidentiality for the\n         iSCSI connection on which the key
      is sent.\n   To support the first and second countermeasures, all implementations\n
      \  of this extension key MUST provide an administrative mechanism to\n   disable
      sending the key.  In addition, all implementations SHOULD\n   provide an administrative
      mechanism to configure a verbosity level of\n   the key value, thereby controlling
      the amount of information sent.\n   For example, a lower verbosity level might
      enable transmission of\n   node architecture component names only, but no version
      numbers.  The\n   choice of which countermeasure is most appropriate depends
      on the\n   environment.  However, sending less detailed information in the key\n
      \  values may be an acceptable countermeasure in many environments,\n   since
      it provides a compromise between sending too much information\n   and the other
      more complete countermeasures of not sending the key at\n   all or using IPsec.\n
      \  In addition to security considerations involving transmission of the\n   key
      contents, any logging method(s) used for the key values MUST keep\n   the information
      secure from intruders.  For all implementations, the\n   requirements to address
      this security concern are as follows:\n      a) Display of the log MUST only
      be possible with administrative\n         rights to the node.\n      b) Options
      to disable logging to disk and to keep logs for a fixed\n         duration SHOULD
      be provided.\n   Finally, it is important to note that different nodes may have\n
      \  different levels of risk, and these differences may affect the\n   implementation.
      \ The components of risk include assets, threats, and\n   vulnerabilities.  Consider
      the following example iSCSI nodes, which\n   demonstrate differences in assets
      and vulnerabilities of the nodes,\n   and, as a result, differences in implementation:\n
      \     a) One iSCSI target based on a special-purpose operating system:\n         Since
      the iSCSI target controls access to the data storage\n         containing company
      assets, the asset level is seen as very\n         high.  Also, because of the
      special-purpose operating system,\n         in which vulnerabilities are less
      well known, the vulnerability\n         level is viewed as low.\n      b) Multiple
      iSCSI initiators in a blade farm, each running a\n         general-purpose operating
      system: The asset level of each node\n         is viewed as low, since blades
      are replaceable and low cost.\n         However, the vulnerability level is
      viewed as high, since there\n         may be many well-known vulnerabilities
      to that general-purpose\n         operating system.  For this target, an appropriate\n
      \        implementation might be the logging of received key values but\n         no
      transmission of the key.  For this initiator, an appropriate\n         implementation
      might be transmission of the key but no logging\n         of received key values.\n"
    title: 9.4.  Security Considerations for the X#NodeArchitecture Key
  - contents:
    - "9.5.  SCSI Access Control Considerations\n   iSCSI is a SCSI transport protocol
      and as such does not apply any\n   access controls on SCSI-level operations
      such as SCSI task management\n   functions (e.g., LU reset; see Section 11.5.1).
      \ SCSI-level access\n   controls (e.g., ACCESS CONTROL OUT; see [SPC3]) have
      to be\n   appropriately deployed in practice to address SCSI-level security\n
      \  considerations, in addition to security via iSCSI connection and\n   packet
      protection mechanisms that were already discussed in preceding\n   sections.\n"
    title: 9.5.  SCSI Access Control Considerations
  title: 9.  Security Considerations
- contents:
  - "10.  Notes to Implementers\n   This section notes some of the performance and
    reliability\n   considerations of the iSCSI protocol.  This protocol was designed
    to\n   allow efficient silicon and software implementations.  The iSCSI task\n
    \  tag mechanism was designed to enable Direct Data Placement (DDP -- a\n   DMA
    form) at the iSCSI level or lower.\n   The guiding assumption made throughout
    the design of this protocol is\n   that targets are resource constrained relative
    to initiators.\n   Implementers are also advised to consider the implementation\n
    \  consequences of the iSCSI-to-SCSI mapping model as outlined in\n   Section
    4.4.3.\n"
  - contents:
    - "10.1.  Multiple Network Adapters\n   The iSCSI protocol allows multiple connections,
      not all of which need\n   to go over the same network adapter.  If multiple
      network connections\n   are to be utilized with hardware support, the iSCSI
      protocol command-\n   data-status allegiance to one TCP connection ensures that
      there is no\n   need to replicate information across network adapters or otherwise\n
      \  require them to cooperate.\n   However, some task management commands may
      require some loose form of\n   cooperation or replication at least on the target.\n"
    - contents:
      - "10.1.1.  Conservative Reuse of ISIDs\n   Historically, the SCSI model (and
        implementations and applications\n   based on that model) has assumed that
        SCSI ports are static, physical\n   entities.  Recent extensions to the SCSI
        model have taken advantage\n   of persistent worldwide unique names for these
        ports.  In iSCSI,\n   however, the SCSI initiator ports are the endpoints
        of dynamically\n   created sessions, so the presumptions of \"static and physical\"
        do not\n   apply.  In any case, the \"model\" sections (particularly,\n   Section
        4.4.1) provide for persistent, reusable names for the\n   iSCSI-type SCSI
        initiator ports even though there does not need to be\n   any physical entity
        bound to these names.\n   To both minimize the disruption of legacy applications
        and better\n   facilitate the SCSI features that rely on persistent names
        for SCSI\n   ports, iSCSI implementations SHOULD attempt to provide a stable\n
        \  presentation of SCSI initiator ports (both to the upper OS layers and\n
        \  the targets to which they connect).  This can be achieved in an\n   initiator
        implementation by conservatively reusing ISIDs.  In other\n   words, the same
        ISID should be used in the login process to multiple\n   target portal groups
        (of the same iSCSI target or different iSCSI\n   targets).  The ISID RULE
        (Section 4.4.3) only prohibits reuse to the\n   same target portal group.
        \ It does not \"preclude\" reuse to other\n   target portal groups.  The principle
        of conservative reuse\n   \"encourages\" reuse to other target portal groups.
        \ When a SCSI target\n   device sees the same (InitiatorName, ISID) pair in
        different sessions\n   to different target portal groups, it can identify
        the underlying\n   SCSI initiator port on each session as the same SCSI port.
        \ In\n   effect, it can recognize multiple paths from the same source.\n"
      title: 10.1.1.  Conservative Reuse of ISIDs
    - contents:
      - "10.1.2.  iSCSI Name, ISID, and TPGT Use\n   The designers of the iSCSI protocol
        are aware that legacy SCSI\n   transports rely on initiator identity to assign
        access to storage\n   resources.  Although newer techniques that simplify
        access control\n   are available, support for configuration and authentication
        schemes\n   that are based on initiator identity is deemed important in order
        to\n   support legacy systems and administration software.  iSCSI thus\n   supports
        the notion that it should be possible to assign access to\n   storage resources
        based on \"initiator device\" identity.\n   When there are multiple hardware
        or software components coordinated\n   as a single iSCSI node, there must
        be some (logical) entity that\n   represents the iSCSI node that makes the
        iSCSI Node Name available to\n   all components involved in session creation
        and login.  Similarly,\n   this entity that represents the iSCSI node must
        be able to coordinate\n   session identifier resources (the ISID for initiators)
        to enforce\n   both the ISID RULE and the TSIH RULE (see Section 4.4.3).\n
        \  For targets, because of the closed environment, implementation of\n   this
        entity should be straightforward.  However, vendors of iSCSI\n   hardware
        (e.g., NICs or HBAs) intended for targets SHOULD provide\n   mechanisms for
        configuration of the iSCSI Node Name across the portal\n   groups instantiated
        by multiple instances of these components within\n   a target.\n   However,
        complex targets making use of multiple Target Portal Group\n   Tags may reconfigure
        them to achieve various quality goals.  The\n   initiators have two mechanisms
        at their disposal to discover and/or\n   check reconfiguring targets -- the
        Discovery session type and a key\n   returned by the target during login to
        confirm the TPGT.  An\n   initiator should attempt to \"rediscover\" the target
        configuration\n   whenever a session is terminated unexpectedly.\n   For initiators,
        in the long term, it is expected that operating\n   system vendors will take
        on the role of this entity and provide\n   standard APIs that can inform components
        of their iSCSI Node Name and\n   can configure and/or coordinate ISID allocation,
        use, and reuse.\n   Recognizing that such initiator APIs are not available
        today, other\n   implementations of the role of this entity are possible.
        \ For\n   example, a human may instantiate the (common) node name as part
        of\n   the installation process of each iSCSI component involved in session\n
        \  creation and login.  This may be done by pointing the component to\n   either
        a vendor-specific location for this datum or a system-wide\n   location.  The
        structure of the ISID namespace (see Section 11.12.5\n   and [RFC3721]) facilitates
        implementation of the ISID coordination by\n   allowing each component vendor
        to independently (of other vendor's\n   components) coordinate allocation,
        use, and reuse of its own\n   partition of the ISID namespace in a vendor-specific
        manner.\n   Partitioning of the ISID namespace within initiator portal groups\n
        \  managed by that vendor allows each such initiator portal group to act\n
        \  independently of all other portal groups when selecting an ISID for a\n
        \  login; this facilitates enforcement of the ISID RULE (see\n   Section 4.4.3)
        at the initiator.\n   A vendor of iSCSI hardware (e.g., NICs or HBAs) intended
        for use in\n   initiators MUST implement a mechanism for configuring the iSCSI
        Node\n   Name.  Vendors and administrators must ensure that iSCSI Node Names\n
        \  are worldwide unique.  It is therefore important that when one\n   chooses
        to reuse the iSCSI Node Name of a disabled unit one does not\n   reassign
        that name to the original unit unless its worldwide\n   uniqueness can be
        ascertained again.\n   In addition, a vendor of iSCSI hardware must implement
        a mechanism to\n   configure and/or coordinate ISIDs for all sessions managed
        by\n   multiple instances of that hardware within a given iSCSI node.  Such\n
        \  configuration might be either permanently preassigned at the factory\n
        \  (in a necessarily globally unique way), statically assigned (e.g.,\n   partitioned
        across all the NICs at initialization in a locally unique\n   way), or dynamically
        assigned (e.g., on-line allocator, also in a\n   locally unique way).  In
        the latter two cases, the configuration may\n   be via public APIs (perhaps
        driven by an independent vendor's\n   software, such as the OS vendor) or
        private APIs driven by the\n   vendor's own software.\n   The process of name
        assignment and coordination has to be as\n   encompassing and automated as
        possible, as years of legacy usage have\n   shown that it is highly error-prone.
        \ It should be mentioned that\n   today SCSI has alternative schemes of access
        control that can be used\n   by all transports, and their security is not
        dependent on strict\n   naming coordination.\n"
      title: 10.1.2.  iSCSI Name, ISID, and TPGT Use
    title: 10.1.  Multiple Network Adapters
  - contents:
    - "10.2.  Autosense and Auto Contingent Allegiance (ACA)\n   \"Autosense\" refers
      to the automatic return of sense data to the\n   initiator in cases where a
      command did not complete successfully.\n   iSCSI initiators and targets MUST
      support and use Autosense.\n   ACA helps preserve ordered command execution
      in the presence of\n   errors.  As there can be many commands in-flight between
      an initiator\n   and a target, SCSI initiator functionality in some operating
      systems\n   depends on ACA to enforce ordered command execution during error\n
      \  recovery, and hence iSCSI initiator implementations for those\n   operating
      systems need to support ACA.  In order to support error\n   recovery for these
      operating systems and iSCSI initiators, iSCSI\n   targets SHOULD support ACA.\n"
    title: 10.2.  Autosense and Auto Contingent Allegiance (ACA)
  - contents:
    - "10.3.  iSCSI Timeouts\n   iSCSI recovery actions are often dependent on iSCSI
      timeouts being\n   recognized and acted upon before SCSI timeouts.  Determining
      the\n   right timeouts to use for various iSCSI actions (command\n   acknowledgments
      expected, status acknowledgments, etc.) is very much\n   dependent on infrastructure
      (e.g., hardware, links, TCP/IP stack,\n   iSCSI driver).  As a guide, the implementer
      may use an average\n   NOP-Out/NOP-In turnaround delay multiplied by a \"safety
      factor\"\n   (e.g., 4) as a good estimate for the basic delay of the iSCSI stack\n
      \  for a given connection.  The safety factor should account for network\n   load
      variability.  For connection teardown, the implementer may want\n   to also
      consider TCP common practice for the given infrastructure.\n   Text negotiations
      MAY also be subject to either time limits or limits\n   in the number of exchanges.
      \ Those limits SHOULD be generous enough\n   to avoid affecting interoperability
      (e.g., allowing each key to be\n   negotiated on a separate exchange).\n   The
      relationship between iSCSI timeouts and SCSI timeouts should also\n   be considered.
      \ SCSI timeouts should be longer than iSCSI timeouts\n   plus the time required
      for iSCSI recovery whenever iSCSI recovery is\n   planned.  Alternatively, an
      implementer may choose to interlock iSCSI\n   timeouts and recovery with SCSI
      timeouts so that SCSI recovery will\n   become active only where iSCSI is not
      planned to, or failed to,\n   recover.\n   The implementer may also want to
      consider the interaction between\n   various iSCSI exception events -- such
      as a digest failure -- and\n   subsequent timeouts.  When iSCSI error recovery
      is active, a digest\n   failure is likely to result in discovering a missing
      command or data\n   PDU.  In these cases, an implementer may want to lower the
      timeout\n   values to enable faster initiation for recovery procedures.\n"
    title: 10.3.  iSCSI Timeouts
  - contents:
    - "10.4.  Command Retry and Cleaning Old Command Instances\n   To avoid having
      old, retried command instances appear in a valid\n   command window after a
      command sequence number wraparound, the\n   protocol requires (see Section 4.2.2.1)
      that on every connection on\n   which a retry has been issued a non-immediate
      command be issued and\n   acknowledged within an interval of 2**31 - 1 commands
      from the CmdSN\n   of the retried command.  This requirement can be fulfilled
      by an\n   implementation in several ways.\n   The simplest technique to use
      is to send a (non-retry) non-immediate\n   SCSI command (or a NOP if no SCSI
      command is available for a while)\n   after every command retry on the connection
      on which the retry was\n   attempted.  Because errors are deemed rare events,
      this technique is\n   probably the most effective, as it does not involve additional
      checks\n   at the initiator when issuing commands.\n"
    title: 10.4.  Command Retry and Cleaning Old Command Instances
  - contents:
    - "10.5.  Sync and Steering Layer, and Performance\n   While a Sync and Steering
      layer is optional, an initiator/target that\n   does not have it working against
      a target/initiator that demands sync\n   and steering may experience performance
      degradation caused by packet\n   reordering and loss.  Providing a sync and
      steering mechanism is\n   recommended for all high-speed implementations.\n"
    title: 10.5.  Sync and Steering Layer, and Performance
  - contents:
    - "10.6.  Considerations for State-Dependent Devices and Long-Lasting SCSI\n       Operations\n
      \  Sequential access devices operate on the principle that the position\n   of
      the device is based on the last command processed.  As such,\n   command processing
      order, and knowledge of whether or not the\n   previous command was processed,
      are of the utmost importance to\n   maintain data integrity.  For example, inadvertent
      retries of SCSI\n   commands when it is not known if the previous SCSI command
      was\n   processed is a potential data integrity risk.\n   For a sequential access
      device, consider the scenario in which a SCSI\n   SPACE command to backspace
      one filemark is issued and then reissued\n   due to no status received for the
      command.  If the first SPACE\n   command was actually processed, the reissued
      SPACE command, if\n   processed, will cause the position to change.  Thus, a
      subsequent\n   write operation will write data to the wrong position, and any\n
      \  previous data at that position will be overwritten.\n   For a medium changer
      device, consider the scenario in which an\n   EXCHANGE MEDIUM command (the SOURCE
      ADDRESS and DESTINATION ADDRESS\n   are the same, thus performing a swap) is
      issued and then reissued due\n   to no status received for the command.  If
      the first EXCHANGE MEDIUM\n   command was actually processed, the reissued EXCHANGE
      MEDIUM command,\n   if processed, will perform the swap again.  The net effect
      is that no\n   swap was performed, thus putting data integrity at risk.\n   All
      commands that change the state of the device (e.g., SPACE\n   commands for sequential
      access devices and EXCHANGE MEDIUM commands\n   for medium changer devices)
      MUST be issued as non-immediate commands\n   for deterministic and ordered delivery
      to iSCSI targets.\n   For many of those state-changing commands, the execution
      model also\n   assumes that the command is executed exactly once.  Devices\n
      \  implementing READ POSITION and LOCATE provide a means for SCSI-level\n   command
      recovery, and new tape-class devices should support those\n   commands.  In
      their absence, a retry at the SCSI level is difficult,\n   and error recovery
      at the iSCSI level is advisable.\n   Devices operating on long-latency delivery
      subsystems and performing\n   long-lasting SCSI operations may need mechanisms
      that enable\n   connection replacement while commands are running (e.g., during
      an\n   extended copy operation).\n"
    - contents:
      - "10.6.1.  Determining the Proper ErrorRecoveryLevel\n   The implementation
        and use of a specific ErrorRecoveryLevel should be\n   determined based on
        the deployment scenarios of a given iSCSI\n   implementation.  Generally,
        the following factors must be considered\n   before deciding on the proper
        level of recovery:\n      a) Application resilience to I/O failures.\n      b)
        Required level of availability in the face of transport\n         connection
        failures.\n      c) Probability of transport-layer \"checksum escape\" (message
        error\n         undetected by TCP checksum -- see [RFC3385] for related\n
        \        discussion).  This in turn decides the iSCSI digest failure\n         frequency
        and thus the criticality of iSCSI-level error\n         recovery.  The details
        of estimating this probability are\n         outside the scope of this document.\n
        \  A consideration of the above factors for SCSI tape devices as an\n   example
        suggests that implementations SHOULD use ErrorRecoveryLevel=1\n   when transport
        connection failure is not a concern and SCSI-level\n   recovery is unavailable,
        and ErrorRecoveryLevel=2 when there is a\n   high likelihood of connection
        failure during a backup/retrieval.\n   For extended copy operations, implementations
        SHOULD use\n   ErrorRecoveryLevel=2 whenever there is a relatively high likelihood\n
        \  of connection failure.\n"
      title: 10.6.1.  Determining the Proper ErrorRecoveryLevel
    title: 10.6.  Considerations for State-Dependent Devices and Long-Lasting SCSI
  - contents:
    - "10.7.  Multi-Task Abort Implementation Considerations\n   Multi-task abort
      operations are typically issued in emergencies, such\n   as clearing a device
      lock-up, HA failover/failback, etc.  In these\n   circumstances, it is desirable
      to rapidly go through the error-\n   handling process as opposed to the target
      waiting on multiple third-\n   party initiators that may not even be functional
      anymore --\n   especially if this emergency is triggered because of one such\n
      \  initiator failure.  Therefore, both iSCSI target and initiator\n   implementations
      SHOULD support FastAbort multi-task abort semantics\n   (Section 4.2.3.4).\n
      \  Note that in both standard semantics (Section 4.2.3.3) and FastAbort\n   semantics
      (Section 4.2.3.4) there may be outstanding data transfers\n   even after the
      TMF completion is reported on the issuing session.  In\n   the case of iSCSI/iSER
      [RFC7145], these would be tagged data\n   transfers for STags not owned by any
      active tasks.  Whether or not\n   real buffers support these data transfers
      is implementation\n   dependent.  However, the data transfers logically MUST
      be silently\n   discarded by the target iSCSI layer in all cases.  A target
      MAY, on\n   an implementation-defined internal timeout, also choose to drop
      the\n   connections on which it did not receive the expected Data-Out\n   sequences
      (Section 4.2.3.3) or NOP-Out acknowledgments\n   (Section 4.2.3.4) so as to
      reclaim the associated buffer, STag, and\n   TTT resources as appropriate.\n"
    title: 10.7.  Multi-Task Abort Implementation Considerations
  title: 10.  Notes to Implementers
- contents:
  - "11.  iSCSI PDU Formats\n   All multi-byte integers that are specified in formats
    defined in this\n   document are to be represented in network byte order (i.e.,\n
    \  big-endian).  Any field that appears in this document assumes that\n   the
    most significant byte is the lowest numbered byte and the most\n   significant
    bit (within byte or field) is the lowest numbered bit\n   unless specified otherwise.\n
    \  Any compliant sender MUST set all bits not defined and all reserved\n   fields
    to 0, unless specified otherwise.  Any compliant receiver MUST\n   ignore any
    bit not defined and all reserved fields unless specified\n   otherwise.  Receipt
    of reserved code values in defined fields MUST be\n   reported as a protocol error.\n
    \  Reserved fields are marked by the word \"reserved\", some abbreviation\n   of
    \"reserved\", or by \".\" for individual bits when no other form of\n   marking
    is technically feasible.\n"
  - contents:
    - "11.1.  iSCSI PDU Length and Padding\n   iSCSI PDUs are padded to the closest
      integer number of 4-byte words.\n   The padding bytes SHOULD be sent as 0.\n"
    title: 11.1.  iSCSI PDU Length and Padding
  - contents:
    - "11.2.  PDU Template, Header, and Opcodes\n   All iSCSI PDUs have one or more
      header segments and, optionally, a\n   data segment.  After the entire header
      segment group, a header digest\n   MAY follow.  The data segment MAY also be
      followed by a data digest.\n   The Basic Header Segment (BHS) is the first segment
      in all of the\n   iSCSI PDUs.  The BHS is a fixed-length 48-byte header segment.
      \ It\n   MAY be followed by Additional Header Segments (AHS), a Header-Digest,\n
      \  a Data Segment, and/or a Data-Digest.\n   The overall structure of an iSCSI
      PDU is as follows:\n   Byte/     0       |       1       |       2       |       3
      \      |\n      /              |               |               |               |\n
      \    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0/ Basic Header Segment (BHS)                                    /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48/ Additional Header Segment 1 (AHS) (optional)                  /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    / Additional Header Segment 2 (AHS) (optional)                  /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    +---------------+---------------+---------------+---------------+\n     /
      Additional Header Segment n (AHS) (optional)                  /\n    +/                                                               /\n
      \    +---------------+---------------+---------------+---------------+\n    k/
      Header-Digest (optional)                                      /\n    +/                                                               /\n
      \    +---------------+---------------+---------------+---------------+\n    l/
      Data Segment (optional)                                       /\n    +/                                                               /\n
      \    +---------------+---------------+---------------+---------------+\n    m/
      Data-Digest (optional)                                        /\n    +/                                                               /\n
      \    +---------------+---------------+---------------+---------------+\n   All
      PDU segments and digests are padded to the closest integer number\n   of 4-byte
      words.  For example, all PDU segments and digests start at\n   a 4-byte word
      boundary, and the padding ranges from 0 to 3 bytes.\n   The padding bytes SHOULD
      be sent as 0.\n   iSCSI Response PDUs do not have AH Segments.\n"
    - contents:
      - "11.2.1.  Basic Header Segment (BHS)\n   The BHS is 48 bytes long.  The Opcode
        and DataSegmentLength fields\n   appear in all iSCSI PDUs.  In addition, when
        used, the Initiator Task\n   Tag and Logical Unit Number always appear in
        the same location in the\n   header.\n   The format of the BHS is:\n   Byte/
        \    0       |       1       |       2       |       3       |\n      /              |
        \              |               |               |\n     |0 1 2 3 4 5 6 7|0
        1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
        \   0|.|I| Opcode    |F| Opcode-specific fields                      |\n     +---------------+---------------+---------------+---------------+\n
        \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
        \   8| LUN or Opcode-specific fields                                 |\n     +
        \                                                              +\n   12|                                                               |\n
        \    +---------------+---------------+---------------+---------------+\n   16|
        Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
        \  20/ Opcode-specific fields                                        /\n    +/
        \                                                              /\n     +---------------+---------------+---------------+---------------+\n
        \  48\n"
      - contents:
        - "11.2.1.1.  I (Immediate) Bit\n   For Request PDUs, the I bit set to 1 is
          an immediate delivery marker.\n"
        title: 11.2.1.1.  I (Immediate) Bit
      - contents:
        - "11.2.1.2.  Opcode\n   The Opcode indicates the type of iSCSI PDU the header
          encapsulates.\n   The Opcodes are divided into two categories: initiator
          Opcodes and\n   target Opcodes.  Initiator Opcodes are in PDUs sent by the
          initiator\n   (Request PDUs).  Target Opcodes are in PDUs sent by the target\n
          \  (Response PDUs).\n   Initiators MUST NOT use target Opcodes, and targets
          MUST NOT use\n   initiator Opcodes.\n   Initiator Opcodes defined in this
          specification are:\n      0x00 NOP-Out\n      0x01 SCSI Command (encapsulates
          a SCSI Command Descriptor\n           Block)\n      0x02 SCSI Task Management
          Function Request\n      0x03 Login Request\n      0x04 Text Request\n      0x05
          SCSI Data-Out (for write operations)\n      0x06 Logout Request\n      0x10
          SNACK Request\n      0x1c-0x1e Vendor-specific codes\n   Target Opcodes
          are:\n      0x20 NOP-In\n      0x21 SCSI Response - contains SCSI status
          and possibly sense\n           information or other response information\n
          \     0x22 SCSI Task Management Function Response\n      0x23 Login Response\n
          \     0x24 Text Response\n      0x25 SCSI Data-In (for read operations)\n
          \     0x26 Logout Response\n      0x31 Ready To Transfer (R2T) - sent by
          target when it is ready\n           to receive data\n      0x32 Asynchronous
          Message - sent by target to indicate certain\n           special conditions\n
          \     0x3c-0x3e Vendor-specific codes\n      0x3f Reject\n   All other Opcodes
          are unassigned.\n"
        title: 11.2.1.2.  Opcode
      - contents:
        - "11.2.1.3.  F (Final) Bit\n   When set to 1 it indicates the final (or only)
          PDU of a sequence.\n"
        title: 11.2.1.3.  F (Final) Bit
      - contents:
        - "11.2.1.4.  Opcode-Specific Fields\n   These fields have different meanings
          for different Opcode types.\n"
        title: 11.2.1.4.  Opcode-Specific Fields
      - contents:
        - "11.2.1.5.  TotalAHSLength\n   This is the total length of all AHS header
          segments in units of\n   4-byte words, including padding, if any.\n   The
          TotalAHSLength is only used in PDUs that have an AHS and MUST be\n   0 in
          all other PDUs.\n"
        title: 11.2.1.5.  TotalAHSLength
      - contents:
        - "11.2.1.6.  DataSegmentLength\n   This is the data segment payload length
          in bytes (excluding padding).\n   The DataSegmentLength MUST be 0 whenever
          the PDU has no data segment.\n"
        title: 11.2.1.6.  DataSegmentLength
      - contents:
        - "11.2.1.7.  LUN\n   Some Opcodes operate on a specific LU.  The Logical
          Unit Number (LUN)\n   field identifies which LU.  If the Opcode does not
          relate to a LU,\n   this field is either ignored or may be used in an Opcode-specific\n
          \  way.  The LUN field is 64 bits and should be formatted in accordance\n
          \  with [SAM2].  For example, LUN[0] from [SAM2] is BHS byte 8 and so on\n
          \  up to LUN[7] from [SAM2], which is BHS byte 15.\n"
        title: 11.2.1.7.  LUN
      - contents:
        - "11.2.1.8.  Initiator Task Tag\n   The initiator assigns a task tag to each
          iSCSI task it issues.  While\n   a task exists, this tag MUST uniquely identify
          the task session-wide.\n   SCSI may also use the Initiator Task Tag as part
          of the SCSI task\n   identifier when the timespan during which an iSCSI
          Initiator Task Tag\n   must be unique extends over the timespan during which
          a SCSI task tag\n   must be unique.  However, the iSCSI Initiator Task Tag
          must exist and\n   be unique even for untagged SCSI commands.\n   An ITT
          value of 0xffffffff is reserved and MUST NOT be assigned for a\n   task
          by the initiator.  The only instance in which it may be seen on\n   the
          wire is in a target-initiated NOP-In PDU (Section 11.19) and in\n   the
          initiator response to that PDU, if necessary.\n"
        title: 11.2.1.8.  Initiator Task Tag
      title: 11.2.1.  Basic Header Segment (BHS)
    - contents:
      - "11.2.2.  Additional Header Segment (AHS)\n   The general format of an AHS
        is:\n   Byte/     0       |       1       |       2       |       3       |\n
        \     /              |               |               |               |\n     |0
        1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
        \   0| AHSLength                     | AHSType       | AHS-Specific  |\n     +---------------+---------------+---------------+---------------+\n
        \   4/ AHS-Specific                                                  /\n    +/
        \                                                              /\n     +---------------+---------------+---------------+---------------+\n
        \   x\n"
      - contents:
        - "11.2.2.1.  AHSType\n   The AHSType field is coded as follows:\n      bit
          0-1 - Reserved\n      bit 2-7 - AHS code\n      0 - Reserved\n      1 -
          Extended CDB\n      2 - Bidirectional Read Expected Data Transfer Length\n
          \     3 - 63 Reserved\n"
        title: 11.2.2.1.  AHSType
      - contents:
        - "11.2.2.2.  AHSLength\n   This field contains the effective length in bytes
          of the AHS,\n   excluding AHSType and AHSLength and padding, if any.  The
          AHS is\n   padded to the smallest integer number of 4-byte words (i.e.,
          from 0\n   up to 3 padding bytes).\n"
        title: 11.2.2.2.  AHSLength
      - contents:
        - "11.2.2.3.  Extended CDB AHS\n   The format of the Extended CDB AHS is:\n
          \  Byte/     0       |       1       |       2       |       3       |\n
          \     /              |               |               |               |\n
          \    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n
          \    +---------------+---------------+---------------+---------------+\n
          \   0| AHSLength (CDBLength - 15)    | 0x01          |  Reserved     |\n
          \    +---------------+---------------+---------------+---------------+\n
          \   4/ ExtendedCDB...+padding                                        /\n
          \   +/                                                               /\n
          \    +---------------+---------------+---------------+---------------+\n
          \   x\n   This type of AHS MUST NOT be used if the CDBLength is less than
          17.\n   The length includes the reserved byte 3.\n"
        title: 11.2.2.3.  Extended CDB AHS
      - contents:
        - "11.2.2.4.  Bidirectional Read Expected Data Transfer Length AHS\n   The
          format of the Bidirectional Read Expected Data Transfer Length\n   AHS is:\n
          \  Byte/     0       |       1       |       2       |       3       |\n
          \     /              |               |               |               |\n
          \    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n
          \    +---------------+---------------+---------------+---------------+\n
          \   0| AHSLength (0x0005)            | 0x02          | Reserved      |\n
          \    +---------------+---------------+---------------+---------------+\n
          \   4| Bidirectional Read Expected Data Transfer Length              |\n
          \    +---------------+---------------+---------------+---------------+\n
          \   8\n"
        title: 11.2.2.4.  Bidirectional Read Expected Data Transfer Length AHS
      title: 11.2.2.  Additional Header Segment (AHS)
    - contents:
      - "11.2.3.  Header Digest and Data Digest\n   Optional header and data digests
        protect the integrity of the header\n   and data, respectively.  The digests,
        if present, are located,\n   respectively, after the header and PDU-specific
        data and cover,\n   respectively, the header and the PDU data, each including
        the padding\n   bytes, if any.\n   The existence and type of digests are negotiated
        during the Login\n   Phase.\n   The separation of the header and data digests
        is useful in iSCSI\n   routing applications, in which only the header changes
        when a message\n   is forwarded.  In this case, only the header digest should
        be\n   recalculated.\n   Digests are not included in data or header length
        fields.\n   A zero-length Data Segment also implies a zero-length Data-Digest.\n"
      title: 11.2.3.  Header Digest and Data Digest
    - contents:
      - "11.2.4.  Data Segment\n   The (optional) Data Segment contains PDU-associated
        data.  Its\n   payload effective length is provided in the BHS field --\n
        \  DataSegmentLength.  The Data Segment is also padded to an integer\n   number
        of 4-byte words.\n"
      title: 11.2.4.  Data Segment
    title: 11.2.  PDU Template, Header, and Opcodes
  - contents:
    - "11.3.  SCSI Command\n   The format of the SCSI Command PDU is:\n   Byte/     0
      \      |       1       |       2       |       3       |\n      /              |
      \              |               |               |\n     |0 1 2 3 4 5 6 7|0 1
      2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|I| 0x01      |F|R|W|. .|ATTR | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| Logical Unit Number (LUN)                                     |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Expected Data Transfer Length                                 |\n     +---------------+---------------+---------------+---------------+\n
      \  24| CmdSN                                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpStatSN                                                     |\n     +---------------+---------------+---------------+---------------+\n
      \  32/ SCSI Command Descriptor Block (CDB)                           /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48/ AHS (optional)                                                /\n     +---------------+---------------+---------------+---------------+\n
      \   x/ Header-Digest (optional)                                      /\n     +---------------+---------------+---------------+---------------+\n
      \   y/ (DataSegment, Command Data) (optional)                        /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \   z/ Data-Digest (optional)                                        /\n     +---------------+---------------+---------------+---------------+\n"
    - contents:
      - "11.3.1.  Flags and Task Attributes (Byte 1)\n   The flags for a SCSI Command
        PDU are:\n      bit 0    (F) is set to 1 when no unsolicited SCSI Data-Out
        PDUs\n               follow this PDU.  When F = 1 for a write and if Expected\n
        \              Data Transfer Length is larger than the\n               DataSegmentLength,
        the target may solicit additional data\n               through R2T.\n      bit
        1    (R) is set to 1 when the command is expected to input\n               data.\n
        \     bit 2    (W) is set to 1 when the command is expected to output\n               data.\n
        \     bit 3-4  Reserved.\n      bit 5-7  contains Task Attributes.\n   Task
        Attributes (ATTR) have one of the following integer values (see\n   [SAM2]
        for details):\n        0 - Untagged\n        1 - Simple\n        2 - Ordered\n
        \       3 - Head of queue\n        4 - ACA\n      5-7 - Reserved\n   At least
        one of the W and F bits MUST be set to 1.\n   Either or both of R and W MAY
        be 1 when the Expected Data Transfer\n   Length and/or the Bidirectional Read
        Expected Data Transfer Length\n   are 0, but they MUST NOT both be 0 when
        the Expected Data Transfer\n   Length and/or Bidirectional Read Expected Data
        Transfer Length are\n   not 0 (i.e., when some data transfer is expected,
        the transfer\n   direction is indicated by the R and/or W bit).\n"
      title: 11.3.1.  Flags and Task Attributes (Byte 1)
    - contents:
      - "11.3.2.  CmdSN - Command Sequence Number\n   The CmdSN enables ordered delivery
        across multiple connections in a\n   single session.\n"
      title: 11.3.2.  CmdSN - Command Sequence Number
    - contents:
      - "11.3.3.  ExpStatSN\n   Command responses up to ExpStatSN - 1 (modulo 2**32)
        have been\n   received (acknowledges status) on the connection.\n"
      title: 11.3.3.  ExpStatSN
    - contents:
      - "11.3.4.  Expected Data Transfer Length\n   For unidirectional operations,
        the Expected Data Transfer Length\n   field contains the number of bytes of
        data involved in this SCSI\n   operation.  For a unidirectional write operation
        (W flag set to 1 and\n   R flag set to 0), the initiator uses this field to
        specify the number\n   of bytes of data it expects to transfer for this operation.
        \ For a\n   unidirectional read operation (W flag set to 0 and R flag set
        to 1),\n   the initiator uses this field to specify the number of bytes of
        data\n   it expects the target to transfer to the initiator.  It corresponds\n
        \  to the SAM-2 byte count.\n   For bidirectional operations (both R and W
        flags are set to 1), this\n   field contains the number of data bytes involved
        in the write\n   transfer.  For bidirectional operations, an additional header
        segment\n   MUST be present in the header sequence that indicates the\n   Bidirectional
        Read Expected Data Transfer Length.  The Expected Data\n   Transfer Length
        field and the Bidirectional Read Expected Data\n   Transfer Length field correspond
        to the SAM-2 byte count.\n   If the Expected Data Transfer Length for a write
        and the length of\n   the immediate data part that follows the command (if
        any) are the\n   same, then no more data PDUs are expected to follow.  In
        this case,\n   the F bit MUST be set to 1.\n   If the Expected Data Transfer
        Length is higher than the\n   FirstBurstLength (the negotiated maximum amount
        of unsolicited data\n   the target will accept), the initiator MUST send the
        maximum amount\n   of unsolicited data OR ONLY the immediate data, if any.\n
        \  Upon completion of a data transfer, the target informs the initiator\n
        \  (through residual counts) of how many bytes were actually processed\n   (sent
        and/or received) by the target.\n"
      title: 11.3.4.  Expected Data Transfer Length
    - contents:
      - "11.3.5.  CDB - SCSI Command Descriptor Block\n   There are 16 bytes in the
        CDB field to accommodate the commonly used\n   CDBs.  Whenever the CDB is
        larger than 16 bytes, an Extended CDB AHS\n   MUST be used to contain the
        CDB spillover.\n"
      title: 11.3.5.  CDB - SCSI Command Descriptor Block
    - contents:
      - "11.3.6.  Data Segment - Command Data\n   Some SCSI commands require additional
        parameter data to accompany the\n   SCSI command.  This data may be placed
        beyond the boundary of the\n   iSCSI header in a data segment.  Alternatively,
        user data (e.g., from\n   a write operation) can be placed in the data segment
        (both cases are\n   referred to as immediate data).  These data are governed
        by the rules\n   for solicited vs. unsolicited data outlined in Section 4.2.5.2.\n"
      title: 11.3.6.  Data Segment - Command Data
    title: 11.3.  SCSI Command
  - contents:
    - "11.4.  SCSI Response\n   The format of the SCSI Response PDU is:\n   Byte/
      \    0       |       1       |       2       |       3       |\n      /              |
      \              |               |               |\n     |0 1 2 3 4 5 6 7|0 1
      2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x21      |1|. .|o|u|O|U|.| Response      | Status        |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| Reserved                                                      |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| SNACK Tag or Reserved                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36| ExpDataSN or Reserved                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  40| Bidirectional Read Residual Count or Reserved                 |\n     +---------------+---------------+---------------+---------------+\n
      \  44| Residual Count or Reserved                                    |\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \    / Data Segment (optional)                                       /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    | Data-Digest (optional)                                        |\n     +---------------+---------------+---------------+---------------+\n"
    - contents:
      - "11.4.1.  Flags (Byte 1)\n   bit 1-2     Reserved.\n   bit 3 - (o) set for
        Bidirectional Read Residual Overflow.  In this\n               case, the Bidirectional
        Read Residual Count indicates the\n               number of bytes that were
        not transferred to the\n               initiator because the initiator's Bidirectional
        Read\n               Expected Data Transfer Length was not sufficient.\n   bit
        4 - (u) set for Bidirectional Read Residual Underflow.  In this\n               case,
        the Bidirectional Read Residual Count indicates the\n               number
        of bytes that were not transferred to the\n               initiator out of
        the number of bytes expected to be\n               transferred.\n   bit 5
        - (O) set for Residual Overflow.  In this case, the Residual\n               Count
        indicates the number of bytes that were not\n               transferred because
        the initiator's Expected Data\n               Transfer Length was not sufficient.
        \ For a bidirectional\n               operation, the Residual Count contains
        the residual for\n               the write operation.\n   bit 6 - (U) set
        for Residual Underflow.  In this case, the Residual\n               Count
        indicates the number of bytes that were not\n               transferred out
        of the number of bytes that were expected\n               to be transferred.
        \ For a bidirectional operation, the\n               Residual Count contains
        the residual for the write\n               operation.\n   bit 7 - (0) Reserved.\n
        \  Bits O and U and bits o and u are mutually exclusive (i.e., having\n   both
        o and u or O and U set to 1 is a protocol error).\n   For a response other
        than \"Command Completed at Target\", bits 3-6\n   MUST be 0.\n"
      title: 11.4.1.  Flags (Byte 1)
    - contents:
      - "11.4.2.  Status\n   The Status field is used to report the SCSI status of
        the command (as\n   specified in [SAM2]) and is only valid if the response
        code is\n   Command Completed at Target.\n   Some of the status codes defined
        in [SAM2] are:\n      0x00 GOOD\n      0x02 CHECK CONDITION\n      0x08 BUSY\n
        \     0x18 RESERVATION CONFLICT\n      0x28 TASK SET FULL\n      0x30 ACA
        ACTIVE\n      0x40 TASK ABORTED\n   See [SAM2] for the complete list and definitions.\n
        \  If a SCSI device error is detected while data from the initiator is\n   still
        expected (the command PDU did not contain all the data and the\n   target
        has not received a data PDU with the Final bit set), the\n   target MUST wait
        until it receives a data PDU with the F bit set in\n   the last expected sequence
        before sending the Response PDU.\n"
      title: 11.4.2.  Status
    - contents:
      - "11.4.3.  Response\n   This field contains the iSCSI service response.\n   iSCSI
        service response codes defined in this specification are:\n      0x00 - Command
        Completed at Target\n      0x01 - Target Failure\n      0x80-0xff - Vendor
        specific\n   All other response codes are reserved.\n   The Response field
        is used to report a service response.  The mapping\n   of the response code
        into a SCSI service response code value, if\n   needed, is outside the scope
        of this document.  However, in symbolic\n   terms, response value 0x00 maps
        to the SCSI service response (see\n   [SAM2] and [SPC3]) of TASK COMPLETE
        or LINKED COMMAND COMPLETE.  All\n   other Response values map to the SCSI
        service response of SERVICE\n   DELIVERY OR TARGET FAILURE.\n   If a SCSI
        Response PDU does not arrive before the session is\n   terminated, the SCSI
        service response is SERVICE DELIVERY OR TARGET\n   FAILURE.\n   A non-zero
        response field indicates a failure to execute the command,\n   in which case
        the Status and Flag fields are undefined and MUST be\n   ignored on reception.\n"
      title: 11.4.3.  Response
    - contents:
      - "11.4.4.  SNACK Tag\n   This field contains a copy of the SNACK Tag of the
        last SNACK Tag\n   accepted by the target on the same connection and for the
        command for\n   which the response is issued.  Otherwise, it is reserved and
        should\n   be set to 0.\n   After issuing a R-Data SNACK, the initiator must
        discard any SCSI\n   status unless contained in a SCSI Response PDU carrying
        the same\n   SNACK Tag as the last issued R-Data SNACK for the SCSI command
        on the\n   current connection.\n   For a detailed discussion on R-Data SNACK,
        see Section 11.16.3.\n"
      title: 11.4.4.  SNACK Tag
    - contents:
      - '11.4.5.  Residual Count

        '
      - contents:
        - "11.4.5.1.  Field Semantics\n   The Residual Count field MUST be valid in
          the case where either the U\n   bit or the O bit is set.  If neither bit
          is set, the Residual Count\n   field MUST be ignored on reception and SHOULD
          be set to 0 when\n   sending.  Targets may set the residual count, and initiators
          may use\n   it when the response code is Command Completed at Target (even
          if the\n   status returned is not GOOD).  If the O bit is set, the Residual\n
          \  Count indicates the number of bytes that were not transferred because\n
          \  the initiator's Expected Data Transfer Length was not sufficient.  If\n
          \  the U bit is set, the Residual Count indicates the number of bytes\n
          \  that were not transferred out of the number of bytes expected to be\n
          \  transferred.\n"
        title: 11.4.5.1.  Field Semantics
      - contents:
        - "11.4.5.2.  Residuals Concepts Overview\n   \"SCSI-Presented Data Transfer
          Length (SPDTL)\" is the term this\n   document uses (see Section 2.2 for
          definition) to represent the\n   aggregate data length that the target SCSI
          layer attempts to transfer\n   using the local iSCSI layer for a task.  \"Expected
          Data Transfer\n   Length (EDTL)\" is the iSCSI term that represents the
          length of data\n   that the iSCSI layer expects to transfer for a task.
          \ EDTL is\n   specified in the SCSI Command PDU.\n   When SPDTL = EDTL for
          a task, the target iSCSI layer completes the\n   task with no residuals.
          \ Whenever SPDTL differs from EDTL for a task,\n   that task is said to
          have a residual.\n   If SPDTL > EDTL for a task, iSCSI Overflow MUST be
          signaled in the\n   SCSI Response PDU as specified in Section 11.4.5.1.
          \ The Residual\n   Count MUST be set to the numerical value of (SPDTL -
          EDTL).\n   If SPDTL < EDTL for a task, iSCSI Underflow MUST be signaled
          in the\n   SCSI Response PDU as specified in Section 11.4.5.1.  The Residual\n
          \  Count MUST be set to the numerical value of (EDTL - SPDTL).\n   Note
          that the Overflow and Underflow scenarios are independent of\n   Data-In
          and Data-Out.  Either scenario is logically possible in\n   either direction
          of data transfer.\n"
        title: 11.4.5.2.  Residuals Concepts Overview
      - contents:
        - "11.4.5.3.  SCSI REPORT LUNS Command and Residual Overflow\n   This section
          discusses the residual overflow issues, citing the\n   example of the SCSI
          REPORT LUNS command.  Note, however, that there\n   are several SCSI commands
          (e.g., INQUIRY) with ALLOCATION LENGTH\n   fields following the same underlying
          rules.  The semantics in the\n   rest of the section apply to all such SCSI
          commands.\n   The specification of the SCSI REPORT LUNS command requires
          that the\n   SCSI target limit the amount of data transferred to a maximum
          size\n   (ALLOCATION LENGTH) provided by the initiator in the REPORT LUNS
          CDB.\n   If the Expected Data Transfer Length (EDTL) in the iSCSI header
          of\n   the SCSI Command PDU for a REPORT LUNS command is set to at least
          as\n   large as that ALLOCATION LENGTH, the SCSI-layer truncation prevents\n
          \  an iSCSI Residual Overflow from occurring.  A SCSI initiator can\n   detect
          that such truncation has occurred via other information at the\n   SCSI
          layer.  The rest of the section elaborates on this required\n   behavior.\n
          \  The SCSI REPORT LUNS command requests a target SCSI layer to return a\n
          \  LU inventory (LUN list) to the initiator SCSI layer (see Clause 6.21\n
          \  of [SPC3]).  The size of this LUN list may not be known to the\n   initiator
          SCSI layer when it issues the REPORT LUNS command; to avoid\n   transferring
          more LUN list data than the initiator is prepared for,\n   the REPORT LUNS
          CDB contains an ALLOCATION LENGTH field to specify\n   the maximum amount
          of data to be transferred to the initiator for\n   this command.  If the
          initiator SCSI layer has underestimated the\n   number of LUs at the target,
          it is possible that the complete LU\n   inventory does not fit in the specified
          ALLOCATION LENGTH.  In this\n   situation, Clause 4.3.4.6 of [SPC3] requires
          that the target SCSI\n   layer \"shall terminate transfers to the Data-In
          Buffer\" when the\n   number of bytes specified by the ALLOCATION LENGTH
          field have been\n   transferred.\n   Therefore, in response to a REPORT
          LUNS command, the SCSI layer at\n   the target presents at most ALLOCATION
          LENGTH bytes of data (LU\n   inventory) to iSCSI for transfer to the initiator.
          \ For a REPORT LUNS\n   command, if the iSCSI EDTL is at least as large
          as the ALLOCATION\n   LENGTH, the SCSI truncation ensures that the EDTL
          will accommodate\n   all of the data to be transferred.  If all of the LU
          inventory data\n   presented to the iSCSI layer -- i.e., the data remaining
          after any\n   SCSI truncation -- is transferred to the initiator by the
          iSCSI\n   layer, an iSCSI Residual Overflow has not occurred and the iSCSI
          (O)\n   bit MUST NOT be set in the SCSI Response or final SCSI Data-Out
          PDU.\n   Note that this behavior is implied in Section 11.4.5.1, along with\n
          \  the specification of the REPORT LUNS command in [SPC3].  However, if\n
          \  the iSCSI EDTL is larger than the ALLOCATION LENGTH in this scenario,\n
          \  note that the iSCSI Underflow MUST be signaled in the SCSI Response\n
          \  PDU.  An iSCSI Underflow MUST also be signaled when the iSCSI EDTL is\n
          \  equal to the ALLOCATION LENGTH but the LU inventory data presented to\n
          \  the iSCSI layer is smaller than the ALLOCATION LENGTH.\n   The LUN LIST
          LENGTH field in the LU inventory (the first field in the\n   inventory)
          is not affected by truncation of the inventory to fit in\n   ALLOCATION
          LENGTH; this enables a SCSI initiator to determine that\n   the received
          inventory is incomplete by noticing that the LUN LIST\n   LENGTH in the
          inventory is larger than the ALLOCATION LENGTH that was\n   sent in the
          REPORT LUNS CDB.  A common initiator behavior in this\n   situation is to
          reissue the REPORT LUNS command with a larger\n   ALLOCATION LENGTH.\n"
        title: 11.4.5.3.  SCSI REPORT LUNS Command and Residual Overflow
      title: 11.4.5.  Residual Count
    - contents:
      - "11.4.6.  Bidirectional Read Residual Count\n   The Bidirectional Read Residual
        Count field MUST be valid in the case\n   where either the u bit or the o
        bit is set.  If neither bit is set,\n   the Bidirectional Read Residual Count
        field is reserved.  Targets may\n   set the Bidirectional Read Residual Count,
        and initiators may use it\n   when the response code is Command Completed
        at Target.  If the o bit\n   is set, the Bidirectional Read Residual Count
        indicates the number of\n   bytes that were not transferred to the initiator
        because the\n   initiator's Bidirectional Read Expected Data Transfer Length
        was not\n   sufficient.  If the u bit is set, the Bidirectional Read Residual\n
        \  Count indicates the number of bytes that were not transferred to the\n
        \  initiator out of the number of bytes expected to be transferred.\n"
      title: 11.4.6.  Bidirectional Read Residual Count
    - contents:
      - "11.4.7.  Data Segment - Sense and Response Data Segment\n   iSCSI targets
        MUST support and enable Autosense.  If Status is CHECK\n   CONDITION (0x02),
        then the data segment MUST contain sense data for\n   the failed command.\n
        \  For some iSCSI responses, the response data segment MAY contain some\n
        \  response-related information (e.g., for a target failure, it may\n   contain
        a vendor-specific detailed description of the failure).\n   If the DataSegmentLength
        is not 0, the format of the data segment is\n   as follows:\n   Byte/     0
        \      |       1       |       2       |       3       |\n      /              |
        \              |               |               |\n     |0 1 2 3 4 5 6 7|0
        1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
        \   0|SenseLength                    | Sense Data                    |\n     +---------------+---------------+---------------+---------------+\n
        \   x/ Sense Data                                                    /\n     +---------------+---------------+---------------+---------------+\n
        \   y/ Response Data                                                 /\n     /
        \                                                              /\n     +---------------+---------------+---------------+---------------+\n"
      - contents:
        - "11.4.7.1.  SenseLength\n   This field indicates the length of Sense Data.\n"
        title: 11.4.7.1.  SenseLength
      - contents:
        - "11.4.7.2.  Sense Data\n   The Sense Data contains detailed information
          about a CHECK CONDITION.\n   [SPC3] specifies the format and content of
          the Sense Data.\n   Certain iSCSI conditions result in the command being
          terminated at\n   the target (response code of Command Completed at Target)
          with a SCSI\n   CHECK CONDITION Status as outlined in the next table:\n
          \  +--------------------------+-----------+---------------------------+\n
          \  | iSCSI Condition          |Sense      | Additional Sense Code and |\n
          \  |                          |Key        | Qualifier                 |\n
          \  +--------------------------+-----------+---------------------------+\n
          \  | Unexpected unsolicited   |Aborted    | ASC = 0x0c ASCQ = 0x0c    |\n
          \  | data                     |Command-0B | Write Error               |\n
          \  +--------------------------+-----------+---------------------------+\n
          \  | Incorrect amount of data |Aborted    | ASC = 0x0c ASCQ = 0x0d    |\n
          \  |                          |Command-0B | Write Error               |\n
          \  +--------------------------+-----------+---------------------------+\n
          \  | Protocol Service CRC     |Aborted    | ASC = 0x47 ASCQ = 0x05    |\n
          \  | error                    |Command-0B | CRC Error Detected        |\n
          \  +--------------------------+-----------+---------------------------+\n
          \  | SNACK rejected           |Aborted    | ASC = 0x11 ASCQ = 0x13    |\n
          \  |                          |Command-0B | Read Error                |\n
          \  +--------------------------+-----------+---------------------------+\n
          \  The target reports the \"Incorrect amount of data\" condition if,\n   during
          data output, the total data length to output is greater than\n   FirstBurstLength
          and the initiator sent unsolicited non-immediate\n   data but the total
          amount of unsolicited data is different than\n   FirstBurstLength.  The
          target reports the same error when the amount\n   of data sent as a reply
          to an R2T does not match the amount\n   requested.\n"
        title: 11.4.7.2.  Sense Data
      title: 11.4.7.  Data Segment - Sense and Response Data Segment
    - contents:
      - "11.4.8.  ExpDataSN\n   This field indicates the number of Data-In (read)
        PDUs the target has\n   sent for the command.\n   This field MUST be 0 if
        the response code is not Command Completed at\n   Target or the target sent
        no Data-In PDUs for the command.\n"
      title: 11.4.8.  ExpDataSN
    - contents:
      - "11.4.9.  StatSN - Status Sequence Number\n   The StatSN is a sequence number
        that the target iSCSI layer generates\n   per connection and that in turn
        enables the initiator to acknowledge\n   status reception.  The StatSN is
        incremented by 1 for every\n   response/status sent on a connection, except
        for responses sent as a\n   result of a retry or SNACK.  In the case of responses
        sent due to a\n   retransmission request, the StatSN MUST be the same as the
        first time\n   the PDU was sent, unless the connection has since been restarted.\n"
      title: 11.4.9.  StatSN - Status Sequence Number
    - contents:
      - "11.4.10.  ExpCmdSN - Next Expected CmdSN from This Initiator\n   The ExpCmdSN
        is a sequence number that the target iSCSI returns to\n   the initiator to
        acknowledge command reception.  It is used to update\n   a local variable
        with the same name.  An ExpCmdSN equal to\n   MaxCmdSN + 1 indicates that
        the target cannot accept new commands.\n"
      title: 11.4.10.  ExpCmdSN - Next Expected CmdSN from This Initiator
    - contents:
      - "11.4.11.  MaxCmdSN - Maximum CmdSN from This Initiator\n   The MaxCmdSN is
        a sequence number that the target iSCSI returns to\n   the initiator to indicate
        the maximum CmdSN the initiator can send.\n   It is used to update a local
        variable with the same name.  If the\n   MaxCmdSN is equal to ExpCmdSN - 1,
        this indicates to the initiator\n   that the target cannot receive any additional
        commands.  When the\n   MaxCmdSN changes at the target while the target has
        no pending PDUs\n   to convey this information to the initiator, it MUST generate
        a\n   NOP-In to carry the new MaxCmdSN.\n"
      title: 11.4.11.  MaxCmdSN - Maximum CmdSN from This Initiator
    title: 11.4.  SCSI Response
  - contents:
    - "11.5.  Task Management Function Request\n   Byte/     0       |       1       |
      \      2       |       3       |\n      /              |               |               |
      \              |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1
      2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|I| 0x02      |1| Function    | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| Logical Unit Number (LUN) or Reserved                         |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Referenced Task Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n
      \  24| CmdSN                                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpStatSN                                                     |\n     +---------------+---------------+---------------+---------------+\n
      \  32| RefCmdSN or Reserved                                          |\n     +---------------+---------------+---------------+---------------+\n
      \  36| ExpDataSN or Reserved                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  40/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n"
    - contents:
      - "11.5.1.  Function\n   The task management functions provide an initiator
        with a way to\n   explicitly control the execution of one or more tasks (SCSI
        and iSCSI\n   tasks).  The task management function codes are listed below.
        \ For a\n   more detailed description of SCSI task management, see [SAM2].\n
        \     1  ABORT TASK - aborts the task identified by the Referenced Task\n
        \        Tag field.\n      2  ABORT TASK SET - aborts all tasks issued via
        this session on\n         the LU.\n      3  CLEAR ACA - clears the Auto Contingent
        Allegiance condition.\n      4  CLEAR TASK SET - aborts all tasks in the appropriate
        task set\n         as defined by the TST field in the Control mode page\n
        \        (see [SPC3]).\n      5  LOGICAL UNIT RESET\n      6  TARGET WARM
        RESET\n      7  TARGET COLD RESET\n      8  TASK REASSIGN - reassigns connection
        allegiance for the task\n         identified by the Initiator Task Tag field
        to this connection,\n         thus resuming the iSCSI exchanges for the task.\n
        \  Values 9-12 are assigned in [RFC7144].  All other possible values for\n
        \  the Function field are unassigned.\n   For all these functions, the Task
        Management Function Response MUST\n   be returned as detailed in Section 11.6.
        \ All these functions apply\n   to the referenced tasks, regardless of whether
        they are proper SCSI\n   tasks or tagged iSCSI operations.  Task management
        requests must act\n   on all the commands from the same session having a CmdSN
        lower than\n   the task management CmdSN.  LOGICAL UNIT RESET, TARGET WARM
        RESET,\n   and TARGET COLD RESET may affect commands from other sessions or\n
        \  commands from the same session, regardless of their CmdSN value.\n   If
        the task management request is marked for immediate delivery, it\n   must
        be considered immediately for execution, but the operations\n   involved (all
        or part of them) may be postponed to allow the target\n   to receive all relevant
        tasks.  According to [SAM2], for all the\n   tasks covered by the task management
        response (i.e., with a CmdSN\n   lower than the task management command CmdSN),
        except for the task\n   management response to a TASK REASSIGN, additional
        responses MUST NOT\n   be delivered to the SCSI layer after the task management
        response.\n   The iSCSI initiator MAY deliver to the SCSI layer all responses\n
        \  received before the task management response (i.e., it is a matter of\n
        \  implementation if the SCSI responses that are received before the\n   task
        management response but after the task management request was\n   issued are
        delivered to the SCSI layer by the iSCSI layer in the\n   initiator).  The
        iSCSI target MUST ensure that no responses for the\n   tasks covered by a
        task management function are delivered to the\n   iSCSI initiator after the
        task management response, except for a task\n   covered by a TASK REASSIGN.\n
        \  For ABORT TASK SET and CLEAR TASK SET, the issuing initiator MUST\n   continue
        to respond to all valid Target Transfer Tags (received via\n   R2T, Text Response,
        NOP-In, or SCSI Data-In PDUs) related to the\n   affected task set, even after
        issuing the task management request.\n   The issuing initiator SHOULD, however,
        terminate (i.e., by setting\n   the F bit to 1) these response sequences as
        quickly as possible.  The\n   target for its part MUST wait for responses
        on all affected Target\n   Transfer Tags before acting on either of these
        two task management\n   requests.  If all or part of the response sequence
        is not received\n   (due to digest errors) for a valid TTT, the target MAY
        treat it as a\n   case of a within-command error recovery class (see Section
        7.1.4.1)\n   if it is supporting ErrorRecoveryLevel >= 1 or, alternatively,
        may\n   drop the connection to complete the requested task set function.\n
        \  If an ABORT TASK is issued for a task created by an immediate\n   command,
        then the RefCmdSN MUST be that of the task management\n   request itself (i.e.,
        the CmdSN and RefCmdSN are equal); otherwise,\n   the RefCmdSN MUST be set
        to the CmdSN of the task to be aborted\n   (lower than the CmdSN).\n   If
        the connection is still active (i.e., it is not undergoing an\n   implicit
        or explicit logout), an ABORT TASK MUST be issued on the\n   same connection
        to which the task to be aborted is allegiant at the\n   time the task management
        request is issued.  If the connection is\n   implicitly or explicitly logged
        out (i.e., no other request will be\n   issued on the failing connection and
        no other response will be\n   received on the failing connection), then an
        ABORT TASK function\n   request may be issued on another connection.  This
        task management\n   request will then establish a new allegiance for the command
        to be\n   aborted as well as abort it (i.e., the task to be aborted will not\n
        \  have to be retried or reassigned, and its status, if sent but not\n   acknowledged,
        will be resent followed by the task management\n   response).\n   At the target,
        an ABORT TASK function MUST NOT be executed on a task\n   management request;
        such a request MUST result in a task management\n   response of \"Function
        rejected\".\n   For the LOGICAL UNIT RESET function, the target MUST behave
        as\n   dictated by the Logical Unit Reset function in [SAM2].\n   The implementation
        of the TARGET WARM RESET function and the TARGET\n   COLD RESET function is
        OPTIONAL and, when implemented, should act as\n   described below.  The TARGET
        WARM RESET is also subject to SCSI\n   access controls on the requesting initiator
        as defined in [SPC3].\n   When authorization fails at the target, the appropriate
        response as\n   described in Section 11.6.1 MUST be returned by the target.
        \ The\n   TARGET COLD RESET function is not subject to SCSI access controls,\n
        \  but its execution privileges may be managed by iSCSI mechanisms such\n
        \  as login authentication.\n   When executing the TARGET WARM RESET and TARGET
        COLD RESET functions,\n   the target cancels all pending operations on all
        LUs known by the\n   issuing initiator.  Both functions are equivalent to
        the TARGET RESET\n   function specified by [SAM2].  They can affect many other
        initiators\n   logged in with the servicing SCSI target port.\n   Additionally,
        the target MUST treat the TARGET COLD RESET function as\n   a power-on event,
        thus terminating all of its TCP connections to all\n   initiators (all sessions
        are terminated).  For this reason, the\n   service response (defined by [SAM2])
        for this SCSI task management\n   function may not be reliably delivered to
        the issuing initiator port.\n   For the TASK REASSIGN function, the target
        should reassign the\n   connection allegiance to this new connection (and
        thus resume iSCSI\n   exchanges for the task).  TASK REASSIGN MUST ONLY be
        received by the\n   target after the connection on which the command was previously\n
        \  executing has been successfully logged out.  The task management\n   response
        MUST be issued before the reassignment becomes effective.\n   For additional
        usage semantics, see Section 7.2.\n   At the target, a TASK REASSIGN function
        request MUST NOT be executed\n   to reassign the connection allegiance of
        a Task Management Function\n   Request, an active text negotiation task, or
        a Logout task; such a\n   request MUST result in a task management response
        of \"Function\n   rejected\".\n   TASK REASSIGN MUST be issued as an immediate
        command.\n"
      title: 11.5.1.  Function
    - contents:
      - "11.5.2.  TotalAHSLength and DataSegmentLength\n   For this PDU, TotalAHSLength
        and DataSegmentLength MUST be 0.\n"
      title: 11.5.2.  TotalAHSLength and DataSegmentLength
    - contents:
      - "11.5.3.  LUN\n   This field is required for functions that address a specific
        LU\n   (ABORT TASK, CLEAR TASK SET, ABORT TASK SET, CLEAR ACA, LOGICAL UNIT\n
        \  RESET) and is reserved in all others.\n"
      title: 11.5.3.  LUN
    - contents:
      - "11.5.4.  Referenced Task Tag\n   This is the Initiator Task Tag of the task
        to be aborted for the\n   ABORT TASK function or reassigned for the TASK REASSIGN
        function.\n   For all the other functions, this field MUST be set to the reserved\n
        \  value 0xffffffff.\n"
      title: 11.5.4.  Referenced Task Tag
    - contents:
      - "11.5.5.  RefCmdSN\n   If an ABORT TASK is issued for a task created by an
        immediate\n   command, then the RefCmdSN MUST be that of the task management\n
        \  request itself (i.e., the CmdSN and RefCmdSN are equal).\n   For an ABORT
        TASK of a task created by a non-immediate command, the\n   RefCmdSN MUST be
        set to the CmdSN of the task identified by the\n   Referenced Task Tag field.
        \ Targets must use this field as described\n   in Section 11.6.1 when the
        task identified by the Referenced Task Tag\n   field is not with the target.\n
        \  Otherwise, this field is reserved.\n"
      title: 11.5.5.  RefCmdSN
    - contents:
      - "11.5.6.  ExpDataSN\n   For recovery purposes, the iSCSI target and initiator
        maintain a data\n   acknowledgment reference number -- the first input DataSN
        number\n   unacknowledged by the initiator.  When issuing a new command, this\n
        \  number is set to 0.  If the function is TASK REASSIGN, which\n   establishes
        a new connection allegiance for a previously issued read\n   or bidirectional
        command, the ExpDataSN will contain an updated data\n   acknowledgment reference
        number or the value 0; the latter indicates\n   that the data acknowledgment
        reference number is unchanged.  The\n   initiator MUST discard any data PDUs
        from the previous execution that\n   it did not acknowledge, and the target
        MUST transmit all Data-In PDUs\n   (if any) starting with the data acknowledgment
        reference number.  The\n   number of retransmitted PDUs may or may not be
        the same as the\n   original transmission, depending on if there was a change
        in\n   MaxRecvDataSegmentLength in the reassignment.  The target MAY also\n
        \  send no more Data-In PDUs if all data has been acknowledged.\n   The value
        of ExpDataSN MUST be 0 or higher than the DataSN of the\n   last acknowledged
        Data-In PDU, but not larger than DataSN + 1 of the\n   last Data-IN PDU sent
        by the target.  Any other value MUST be ignored\n   by the target.\n   For
        other functions, this field is reserved.\n"
      title: 11.5.6.  ExpDataSN
    title: 11.5.  Task Management Function Request
  - contents:
    - "11.6.  Task Management Function Response\n   Byte/     0       |       1       |
      \      2       |       3       |\n      /              |               |               |
      \              |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1
      2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x22      |1| Reserved    | Response      | Reserved      |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------------------------------------------------------+\n
      \   8/ Reserved                                                      /\n     /
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  16| Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  For the functions ABORT TASK, ABORT TASK SET, CLEAR ACA, CLEAR TASK\n   SET,
      LOGICAL UNIT RESET, TARGET COLD RESET, TARGET WARM RESET, and\n   TASK REASSIGN,
      the target performs the requested task management\n   function and sends a task
      management response back to the initiator.\n   For TASK REASSIGN, the new connection
      allegiance MUST ONLY become\n   effective at the target after the target issues
      the task management\n   response.\n"
    - contents:
      - "11.6.1.  Response\n   The target provides a response, which may take on the
        following\n   values:\n       0 - Function complete\n       1 - Task does
        not exist\n       2 - LUN does not exist\n       3 - Task still allegiant\n
        \      4 - Task allegiance reassignment not supported\n       5 - Task management
        function not supported\n       6 - Function authorization failed\n     255
        - Function rejected\n   In addition to the above values, the value 7 is defined
        by [RFC7144].\n   For a discussion on the usage of response codes 3 and 4,
        see\n   Section 7.2.2.\n   For the TARGET COLD RESET and TARGET WARM RESET
        functions, the target\n   cancels all pending operations across all LUs known
        to the issuing\n   initiator.  For the TARGET COLD RESET function, the target
        MUST then\n   close all of its TCP connections to all initiators (terminates
        all\n   sessions).\n   The mapping of the response code into a SCSI service
        response code\n   value, if needed, is outside the scope of this document.
        \ However, in\n   symbolic terms, Response values 0 and 1 map to the SCSI
        service\n   response of FUNCTION COMPLETE.  Response value 2 maps to the SCSI\n
        \  service response of INCORRECT LOGICAL UNIT NUMBER.  All other\n   Response
        values map to the SCSI service response of FUNCTION\n   REJECTED.  If a Task
        Management Function Response PDU does not arrive\n   before the session is
        terminated, the SCSI service response is\n   SERVICE DELIVERY OR TARGET FAILURE.\n
        \  The response to ABORT TASK SET and CLEAR TASK SET MUST only be issued\n
        \  by the target after all of the commands affected have been received\n   by
        the target, the corresponding task management functions have been\n   executed
        by the SCSI target, and the delivery of all responses\n   delivered until
        the task management function completion has been\n   confirmed (acknowledged
        through the ExpStatSN) by the initiator on\n   all connections of this session.
        \ For the exact timeline of events,\n   refer to Sections 4.2.3.3 and 4.2.3.4.\n
        \  For the ABORT TASK function,\n      a) if the Referenced Task Tag identifies
        a valid task leading to a\n         successful termination, then targets must
        return the \"Function\n         complete\" response.\n      b) if the Referenced
        Task Tag does not identify an existing task\n         but the CmdSN indicated
        by the RefCmdSN field in the Task\n         Management Function Request is
        within the valid CmdSN window\n         and less than the CmdSN of the Task
        Management Function Request\n         itself, then targets must consider the
        CmdSN as received and\n         return the \"Function complete\" response.\n
        \     c) if the Referenced Task Tag does not identify an existing task\n         and
        the CmdSN indicated by the RefCmdSN field in the Task\n         Management
        Function Request is outside the valid CmdSN window,\n         then targets
        must return the \"Task does not exist\" response.\n   For response semantics
        on function types that can potentially impact\n   multiple active tasks on
        the target, see Section 4.2.3.\n"
      title: 11.6.1.  Response
    - contents:
      - "11.6.2.  TotalAHSLength and DataSegmentLength\n   For this PDU, TotalAHSLength
        and DataSegmentLength MUST be 0.\n"
      title: 11.6.2.  TotalAHSLength and DataSegmentLength
    title: 11.6.  Task Management Function Response
  - contents:
    - "11.7.  SCSI Data-Out and SCSI Data-In\n   The SCSI Data-Out PDU for write operations
      has the following format:\n   Byte/     0       |       1       |       2       |
      \      3       |\n      /              |               |               |               |\n
      \    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x05      |F| Reserved                                    |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| LUN or Reserved                                               |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Target Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n
      \  24| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpStatSN                                                     |\n     +---------------+---------------+---------------+---------------+\n
      \  32| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36| DataSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  40| Buffer Offset                                                 |\n     +---------------+---------------+---------------+---------------+\n
      \  44| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \    / DataSegment                                                   /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    | Data-Digest (optional)                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  The SCSI Data-In PDU for read operations has the following format:\n   Byte/
      \    0       |       1       |       2       |       3       |\n      /              |
      \              |               |               |\n     |0 1 2 3 4 5 6 7|0 1
      2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x25      |F|A|0 0 0|O|U|S| Reserved      |Status or Rsvd |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| LUN or Reserved                                               |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Target Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN or Reserved                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36| DataSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  40| Buffer Offset                                                 |\n     +---------------+---------------+---------------+---------------+\n
      \  44| Residual Count                                                |\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \    / DataSegment                                                   /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    | Data-Digest (optional)                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  Status can accompany the last Data-In PDU if the command did not end\n   with
      an exception (i.e., the status is \"good status\" -- GOOD,\n   CONDITION MET,
      or INTERMEDIATE-CONDITION MET).  The presence of\n   status (and of a residual
      count) is signaled via the S flag bit.\n   Although targets MAY choose to send
      even non-exception status in\n   separate responses, initiators MUST support
      non-exception status in\n   Data-In PDUs.\n"
    - contents:
      - "11.7.1.  F (Final) Bit\n   For outgoing data, this bit is 1 for the last
        PDU of unsolicited data\n   or the last PDU of a sequence that answers an
        R2T.\n   For incoming data, this bit is 1 for the last input (read) data PDU\n
        \  of a sequence.  Input can be split into several sequences, each\n   having
        its own F bit.  Splitting the data stream into sequences does\n   not affect
        DataSN counting on Data-In PDUs.  It MAY be used as a\n   \"change direction\"
        indication for bidirectional operations that need\n   such a change.\n   DataSegmentLength
        MUST NOT exceed MaxRecvDataSegmentLength for the\n   direction it is sent,
        and the total of all the DataSegmentLength of\n   all PDUs in a sequence MUST
        NOT exceed MaxBurstLength (or\n   FirstBurstLength for unsolicited data).
        \ However, the number of\n   individual PDUs in a sequence (or in total) may
        be higher than the\n   ratio of MaxBurstLength (or FirstBurstLength) to\n
        \  MaxRecvDataSegmentLength (as PDUs may be limited in length by the\n   capabilities
        of the sender).  Using a DataSegmentLength of 0 may\n   increase beyond what
        is reasonable for the number of PDUs and should\n   therefore be avoided.\n
        \  For bidirectional operations, the F bit is 1 for both the end of the\n
        \  input sequences and the end of the output sequences.\n"
      title: 11.7.1.  F (Final) Bit
    - contents:
      - "11.7.2.  A (Acknowledge) Bit\n   For sessions with ErrorRecoveryLevel=1 or
        higher, the target sets\n   this bit to 1 to indicate that it requests a positive
        acknowledgment\n   from the initiator for the data received.  The target should
        use the\n   A bit moderately; it MAY only set the A bit to 1 once every\n
        \  MaxBurstLength bytes, or on the last Data-In PDU that concludes the\n   entire
        requested read data transfer for the task from the target's\n   perspective,
        and it MUST NOT do so more frequently.  The target MUST\n   NOT set to 1 the
        A bit for sessions with ErrorRecoveryLevel=0.  The\n   initiator MUST ignore
        the A bit set to 1 for sessions with\n   ErrorRecoveryLevel=0.\n   On receiving
        a Data-In PDU with the A bit set to 1 on a session with\n   ErrorRecoveryLevel
        greater than 0, if there are no holes in the read\n   data until that Data-In
        PDU, the initiator MUST issue a SNACK of type\n   DataACK, except when it
        is able to acknowledge the status for the\n   task immediately via the ExpStatSN
        on other outbound PDUs if the\n   status for the task is also received.  In
        the latter case\n   (acknowledgment through the ExpStatSN), sending a SNACK
        of type\n   DataACK in response to the A bit is OPTIONAL, but if it is done,
        it\n   must not be sent after the status acknowledgment through the\n   ExpStatSN.
        \ If the initiator has detected holes in the read data\n   prior to that Data-In
        PDU, it MUST postpone issuing the SNACK of type\n   DataACK until the holes
        are filled.  An initiator also MUST NOT\n   acknowledge the status for the
        task before those holes are filled.  A\n   status acknowledgment for a task
        that generated the Data-In PDUs is\n   considered by the target as an implicit
        acknowledgment of the Data-In\n   PDUs if such an acknowledgment was requested
        by the target.\n"
      title: 11.7.2.  A (Acknowledge) Bit
    - contents:
      - "11.7.3.  Flags (Byte 1)\n   The last SCSI data packet sent from a target
        to an initiator for a\n   SCSI command that completed successfully (with a
        status of GOOD,\n   CONDITION MET, INTERMEDIATE, or INTERMEDIATE-CONDITION
        MET) may also\n   optionally contain the Status for the data transfer.  In
        this case,\n   Sense Data cannot be sent together with the Command Status.
        \ If the\n   command is completed with an error, then the response and sense
        data\n   MUST be sent in a SCSI Response PDU (i.e., MUST NOT be sent in a
        SCSI\n   data packet).  For bidirectional commands, the status MUST be sent
        in\n   a SCSI Response PDU.\n      bit 2-4          - Reserved.\n      bit
        5-6          - used the same as in a SCSI Response.  These\n                         bits
        are only valid when S is set to 1.  For\n                         details,
        see Section 11.4.1.\n      bit 7 S (status) - set to indicate that the Command
        Status field\n                         contains status.  If this bit is set
        to 1, the\n                         F bit MUST also be set to 1.\n   The fields
        StatSN, Status, and Residual Count only have meaningful\n   content if the
        S bit is set to 1.  The values for these fields are\n   defined in Section
        11.4.\n"
      title: 11.7.3.  Flags (Byte 1)
    - contents:
      - "11.7.4.  Target Transfer Tag and LUN\n   On outgoing data, the Target Transfer
        Tag is provided to the target\n   if the transfer is honoring an R2T.  In
        this case, the Target\n   Transfer Tag field is a replica of the Target Transfer
        Tag provided\n   with the R2T.\n   On incoming data, the Target Transfer Tag
        and LUN MUST be provided by\n   the target if the A bit is set to 1; otherwise,
        they are reserved.\n   The Target Transfer Tag and LUN are copied by the initiator
        into the\n   SNACK of type DataACK that it issues as a result of receiving
        a SCSI\n   Data-In PDU with the A bit set to 1.\n   The Target Transfer Tag
        values are not specified by this protocol,\n   except that the value 0xffffffff
        is reserved and means that the\n   Target Transfer Tag is not supplied.  If
        the Target Transfer Tag is\n   provided, then the LUN field MUST hold a valid
        value and be\n   consistent with whatever was specified with the command;
        otherwise,\n   the LUN field is reserved.\n"
      title: 11.7.4.  Target Transfer Tag and LUN
    - contents:
      - "11.7.5.  DataSN\n   For input (read) or bidirectional Data-In PDUs, the DataSN
        is the\n   input PDU number within the data transfer for the command identified\n
        \  by the Initiator Task Tag.\n   R2T and Data-In PDUs, in the context of
        bidirectional commands, share\n   the numbering sequence (see Section 4.2.2.4).\n
        \  For output (write) data PDUs, the DataSN is the Data-Out PDU number\n   within
        the current output sequence.  Either the current output\n   sequence is identified
        by the Initiator Task Tag (for unsolicited\n   data) or it is a data sequence
        generated for one R2T (for data\n   solicited through R2T).\n"
      title: 11.7.5.  DataSN
    - contents:
      - "11.7.6.  Buffer Offset\n   The Buffer Offset field contains the offset of
        this PDU payload data\n   within the complete data transfer.  The sum of the
        buffer offset and\n   length should not exceed the expected transfer length
        for the\n   command.\n   The order of data PDUs within a sequence is determined
        by\n   DataPDUInOrder.  When set to Yes, it means that PDUs have to be in\n
        \  increasing buffer offset order and overlays are forbidden.\n   The ordering
        between sequences is determined by DataSequenceInOrder.\n   When set to Yes,
        it means that sequences have to be in increasing\n   buffer offset order and
        overlays are forbidden.\n"
      title: 11.7.6.  Buffer Offset
    - contents:
      - "11.7.7.  DataSegmentLength\n   This is the data payload length of a SCSI
        Data-In or SCSI Data-Out\n   PDU.  The sending of 0-length data segments should
        be avoided, but\n   initiators and targets MUST be able to properly receive
        0-length data\n   segments.\n   The data segments of Data-In and Data-Out
        PDUs SHOULD be filled to\n   the integer number of 4-byte words (real payload),
        unless the F bit\n   is set to 1.\n"
      title: 11.7.7.  DataSegmentLength
    title: 11.7.  SCSI Data-Out and SCSI Data-In
  - contents:
    - "11.8.  Ready To Transfer (R2T)\n   Byte/     0       |       1       |       2
      \      |       3       |\n      /              |               |               |
      \              |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1
      2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x31      |1| Reserved                                    |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| LUN                                                           |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Target Transfer Tag                                           |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36| R2TSN                                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  40| Buffer Offset                                                 |\n     +---------------+---------------+---------------+---------------+\n
      \  44| Desired Data Transfer Length                                  |\n     +---------------------------------------------------------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  When an initiator has submitted a SCSI command with data that passes\n   from
      the initiator to the target (write), the target may specify\n   which blocks
      of data it is ready to receive.  The target may request\n   that the data blocks
      be delivered in whichever order is convenient\n   for the target at that particular
      instant.  This information is\n   passed from the target to the initiator in
      the Ready To Transfer\n   (R2T) PDU.\n   In order to allow write operations
      without an explicit initial R2T,\n   the initiator and target MUST have negotiated
      the key InitialR2T to\n   No during login.\n   An R2T MAY be answered with one
      or more SCSI Data-Out PDUs with a\n   matching Target Transfer Tag.  If an R2T
      is answered with a single\n   Data-Out PDU, the buffer offset in the data PDU
      MUST be the same as\n   the one specified by the R2T, and the data length of
      the data PDU\n   MUST be the same as the Desired Data Transfer Length specified
      in the\n   R2T.  If the R2T is answered with a sequence of data PDUs, the buffer\n
      \  offset and length MUST be within the range of those specified by the\n   R2T,
      and the last PDU MUST have the F bit set to 1.  If the last PDU\n   (marked
      with the F bit) is received before the Desired Data Transfer\n   Length is transferred,
      a target MAY choose to reject that PDU with\n   the \"Protocol Error\" reason
      code.  DataPDUInOrder governs the\n   Data-Out PDU ordering.  If DataPDUInOrder
      is set to Yes, the buffer\n   offsets and lengths for consecutive PDUs MUST
      form a continuous\n   non-overlapping range, and the PDUs MUST be sent in increasing
      offset\n   order.\n   The target may send several R2T PDUs.  It therefore can
      have a number\n   of pending data transfers.  The number of outstanding R2T
      PDUs is\n   limited by the value of the negotiated key MaxOutstandingR2T.  Within\n
      \  a task, outstanding R2Ts MUST be fulfilled by the initiator in the\n   order
      in which they were received.\n   R2T PDUs MAY also be used to recover Data-Out
      PDUs.  Such an R2T\n   (Recovery-R2T) is generated by a target upon detecting
      the loss of\n   one or more Data-Out PDUs due to:\n      - Digest error\n      -
      Sequence error\n      - Sequence reception timeout\n   A Recovery-R2T carries
      the next unused R2TSN but requests part of or\n   the entire data burst that
      an earlier R2T (with a lower R2TSN) had\n   already requested.\n   DataSequenceInOrder
      governs the buffer offset ordering in consecutive\n   R2Ts.  If DataSequenceInOrder
      is Yes, then consecutive R2Ts MUST\n   refer to continuous non-overlapping ranges,
      except for Recovery-R2Ts.\n"
    - contents:
      - "11.8.1.  TotalAHSLength and DataSegmentLength\n   For this PDU, TotalAHSLength
        and DataSegmentLength MUST be 0.\n"
      title: 11.8.1.  TotalAHSLength and DataSegmentLength
    - contents:
      - "11.8.2.  R2TSN\n   R2TSN is the R2T PDU input PDU number within the command
        identified\n   by the Initiator Task Tag.\n   For bidirectional commands,
        R2T and Data-In PDUs share the input PDU\n   numbering sequence (see Section
        4.2.2.4).\n"
      title: 11.8.2.  R2TSN
    - contents:
      - "11.8.3.  StatSN\n   The StatSN field will contain the next StatSN.  The StatSN
        for this\n   connection is not advanced after this PDU is sent.\n"
      title: 11.8.3.  StatSN
    - contents:
      - "11.8.4.  Desired Data Transfer Length and Buffer Offset\n   The target specifies
        how many bytes it wants the initiator to send\n   because of this R2T PDU.
        \ The target may request the data from the\n   initiator in several chunks,
        not necessarily in the original order of\n   the data.  The target therefore
        also specifies a buffer offset that\n   indicates the point at which the data
        transfer should begin, relative\n   to the beginning of the total data transfer.
        \ The Desired Data\n   Transfer Length MUST NOT be 0 and MUST NOT exceed MaxBurstLength.\n"
      title: 11.8.4.  Desired Data Transfer Length and Buffer Offset
    - contents:
      - "11.8.5.  Target Transfer Tag\n   The target assigns its own tag to each R2T
        request that it sends to\n   the initiator.  This tag can be used by the target
        to easily identify\n   the data it receives.  The Target Transfer Tag and
        LUN are copied in\n   the outgoing data PDUs and are only used by the target.
        \ There is no\n   protocol rule about the Target Transfer Tag except that
        the value\n   0xffffffff is reserved and MUST NOT be sent by a target in an
        R2T.\n"
      title: 11.8.5.  Target Transfer Tag
    title: 11.8.  Ready To Transfer (R2T)
  - contents:
    - "11.9.  Asynchronous Message\n   An Asynchronous Message may be sent from the
      target to the initiator\n   without corresponding to a particular command.  The
      target specifies\n   the reason for the event and sense data.\n   Byte/     0
      \      |       1       |       2       |       3       |\n      /              |
      \              |               |               |\n     |0 1 2 3 4 5 6 7|0 1
      2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x32      |1| Reserved                                    |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| LUN or Reserved                                               |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      0xffffffff                                                    |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36| AsyncEvent    | AsyncVCode    | Parameter1 or Reserved        |\n     +---------------+---------------+---------------+---------------+\n
      \  40| Parameter2 or Reserved        | Parameter3 or Reserved        |\n     +---------------+---------------+---------------+---------------+\n
      \  44| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \    / DataSegment - Sense Data and iSCSI Event Data                 /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    | Data-Digest (optional)                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  Some Asynchronous Messages are strictly related to iSCSI, while\n   others
      are related to SCSI [SAM2].\n   The StatSN counts this PDU as an acknowledgeable
      event (the StatSN is\n   advanced), which allows for initiator and target state\n
      \  synchronization.\n"
    - contents:
      - "11.9.1.  AsyncEvent\n   The codes used for iSCSI Asynchronous Messages (events)
        are:\n        0 (SCSI Async Event) - a SCSI asynchronous event is reported
        in\n          the sense data.  Sense Data that accompanies the report, in\n
        \         the data segment, identifies the condition.  The sending of a\n
        \         SCSI event (\"asynchronous event reporting\" in SCSI\n          terminology)
        is dependent on the target support for SCSI\n          asynchronous event
        reporting (see [SAM2]) as indicated in the\n          standard INQUIRY data
        (see [SPC3]).  Its use may be enabled by\n          parameters in the SCSI
        Control mode page (see [SPC3]).\n        1 (Logout Request) - the target requests
        Logout.  This Async\n          Message MUST be sent on the same connection
        as the one\n          requesting to be logged out.  The initiator MUST honor
        this\n          request by issuing a Logout as early as possible but no later\n
        \         than Parameter3 seconds.  The initiator MUST send a Logout\n          with
        a reason code of \"close the connection\" OR \"close the\n          session\"
        to close all the connections.  Once this message is\n          received, the
        initiator SHOULD NOT issue new iSCSI commands on\n          the connection
        to be logged out.  The target MAY reject any\n          new I/O requests that
        it receives after this message with the\n          reason code \"Waiting for
        Logout\".  If the initiator does not\n          log out in Parameter3 seconds,
        the target should send an Async\n          PDU with iSCSI event code \"Dropped
        the connection\" if possible\n          or simply terminate the transport
        connection.  Parameter1 and\n          Parameter2 are reserved.\n        2
        (Connection Drop Notification) - the target indicates that it\n          will
        drop the connection.\n          The Parameter1 field indicates the CID of
        the connection that\n          is going to be dropped.\n          The Parameter2
        field (Time2Wait) indicates, in seconds, the\n          minimum time to wait
        before attempting to reconnect or\n          reassign.\n          The Parameter3
        field (Time2Retain) indicates the maximum time\n          allowed to reassign
        commands after the initial wait (in\n          Parameter2).\n          If
        the initiator does not attempt to reconnect and/or reassign\n          the
        outstanding commands within the time specified by\n          Parameter3, or
        if Parameter3 is 0, the target will terminate\n          all outstanding commands
        on this connection.  In this case, no\n          other responses should be
        expected from the target for the\n          outstanding commands on this connection.\n
        \         A value of 0 for Parameter2 indicates that reconnect can be\n          attempted
        immediately.\n        3 (Session Drop Notification) - the target indicates
        that it\n          will drop all the connections of this session.\n          The
        Parameter1 field is reserved.\n          The Parameter2 field (Time2Wait)
        indicates, in seconds, the\n          minimum time to wait before attempting
        to reconnect.\n          The Parameter3 field (Time2Retain) indicates the
        maximum time\n          allowed to reassign commands after the initial wait
        (in\n          Parameter2).\n          If the initiator does not attempt to
        reconnect and/or reassign\n          the outstanding commands within the time
        specified by\n          Parameter3, or if Parameter3 is 0, the session is
        terminated.\n          In this case, the target will terminate all outstanding\n
        \         commands in this session; no other responses should be\n          expected
        from the target for the outstanding commands in this\n          session.  A
        value of 0 for Parameter2 indicates that reconnect\n          can be attempted
        immediately.\n        4 (Negotiation Request) - the target requests parameter\n
        \         negotiation on this connection.  The initiator MUST honor this\n
        \         request by issuing a Text Request (that can be empty) on the\n          same
        connection as early as possible, but no later than\n          Parameter3 seconds,
        unless a Text Request is already pending\n          on the connection, or
        by issuing a Logout Request.  If the\n          initiator does not issue a
        Text Request, the target may\n          reissue the Asynchronous Message requesting
        parameter\n          negotiation.\n        5 (Task Termination) - all active
        tasks for a LU with a matching\n          LUN field in the Async Message PDU
        are being terminated.  The\n          receiving initiator iSCSI layer MUST
        respond to this message\n          by taking the following steps, in order:\n
        \         - Stop Data-Out transfers on that connection for all active\n            TTTs
        for the affected LUN quoted in the Async Message PDU.\n          - Acknowledge
        the StatSN of the Async Message PDU via a\n            NOP-Out PDU with ITT=0xffffffff
        (i.e., non-ping flavor),\n            while copying the LUN field from the
        Async Message to\n            NOP-Out.\n          This value of AsyncEvent,
        however, MUST NOT be used on an\n          iSCSI session unless the new TaskReporting
        text key defined in\n          Section 13.23 was negotiated to FastAbort on
        the session.\n    248-255 (Vendor-unique) - vendor-specific iSCSI event.  The\n
        \         AsyncVCode details the vendor code, and data MAY accompany the\n
        \         report.\n   All other event codes are unassigned.\n"
      title: 11.9.1.  AsyncEvent
    - contents:
      - "11.9.2.  AsyncVCode\n   AsyncVCode is a vendor-specific detail code that
        is only valid if the\n   AsyncEvent field indicates a vendor-specific event.
        \ Otherwise, it is\n   reserved.\n"
      title: 11.9.2.  AsyncVCode
    - contents:
      - "11.9.3.  LUN\n   The LUN field MUST be valid if AsyncEvent is 0.  Otherwise,
        this\n   field is reserved.\n"
      title: 11.9.3.  LUN
    - contents:
      - "11.9.4.  Sense Data and iSCSI Event Data\n   For a SCSI event, this data
        accompanies the report in the data\n   segment and identifies the condition.\n
        \  For an iSCSI event, additional vendor-unique data MAY accompany the\n   Async
        event.  Initiators MAY ignore the data when not understood,\n   while processing
        the rest of the PDU.\n   If the DataSegmentLength is not 0, the format of
        the DataSegment is\n   as follows:\n   Byte/     0       |       1       |
        \      2       |       3       |\n      /              |               |               |
        \              |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0
        1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
        \   0|SenseLength                    | Sense Data                    |\n     +---------------+---------------+---------------+---------------+\n
        \   x/ Sense Data                                                    /\n     +---------------+---------------+---------------+---------------+\n
        \   y/ iSCSI Event Data                                              /\n     /
        \                                                              /\n     +---------------+---------------+---------------+---------------+\n
        \   z|\n"
      - contents:
        - "11.9.4.1.  SenseLength\n   This is the length of Sense Data.  When the
          Sense Data field is empty\n   (e.g., the event is not a SCSI event), SenseLength
          is 0.\n"
        title: 11.9.4.1.  SenseLength
      title: 11.9.4.  Sense Data and iSCSI Event Data
    title: 11.9.  Asynchronous Message
  - contents:
    - "11.10.  Text Request\n   The Text Request is provided to allow for the exchange
      of information\n   and for future extensions.  It permits the initiator to inform
      a\n   target of its capabilities or request some special operations.\n   Byte/
      \    0       |       1       |       2       |       3       |\n      /              |
      \              |               |               |\n     |0 1 2 3 4 5 6 7|0 1
      2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|I| 0x04      |F|C| Reserved                                  |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| LUN or Reserved                                               |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Target Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n
      \  24| CmdSN                                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpStatSN                                                     |\n     +---------------+---------------+---------------+---------------+\n
      \  32/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \    / DataSegment (Text)                                            /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    | Data-Digest (optional)                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  An initiator MUST NOT have more than one outstanding Text Request on\n   a
      connection at any given time.\n   On a connection failure, an initiator must
      either explicitly abort\n   any active allegiant text negotiation task or cause
      such a task to be\n   implicitly terminated by the target.\n"
    - contents:
      - "11.10.1.  F (Final) Bit\n   When set to 1, this bit indicates that this is
        the last or only Text\n   Request in a sequence of Text Requests; otherwise,
        it indicates that\n   more Text Requests will follow.\n"
      title: 11.10.1.  F (Final) Bit
    - contents:
      - "11.10.2.  C (Continue) Bit\n   When set to 1, this bit indicates that the
        text (set of key=value\n   pairs) in this Text Request is not complete (it
        will be continued on\n   subsequent Text Requests); otherwise, it indicates
        that this Text\n   Request ends a set of key=value pairs.  A Text Request
        with the C bit\n   set to 1 MUST have the F bit set to 0.\n"
      title: 11.10.2.  C (Continue) Bit
    - contents:
      - "11.10.3.  Initiator Task Tag\n   This is the initiator-assigned identifier
        for this Text Request.  If\n   the command is sent as part of a sequence of
        Text Requests and\n   responses, the Initiator Task Tag MUST be the same for
        all the\n   requests within the sequence (similar to linked SCSI commands).
        \ The\n   I bit for all requests in a sequence also MUST be the same.\n"
      title: 11.10.3.  Initiator Task Tag
    - contents:
      - "11.10.4.  Target Transfer Tag\n   When the Target Transfer Tag is set to
        the reserved value 0xffffffff,\n   it tells the target that this is a new
        request, and the target resets\n   any internal state associated with the
        Initiator Task Tag (resets the\n   current negotiation state).\n   The target
        sets the Target Transfer Tag in a Text Response to a value\n   other than
        the reserved value 0xffffffff whenever it indicates that\n   it has more data
        to send or more operations to perform that are\n   associated with the specified
        Initiator Task Tag.  It MUST do so\n   whenever it sets the F bit to 0 in
        the response.  By copying the\n   Target Transfer Tag from the response to
        the next Text Request, the\n   initiator tells the target to continue the
        operation for the specific\n   Initiator Task Tag.  The initiator MUST ignore
        the Target Transfer\n   Tag in the Text Response when the F bit is set to
        1.\n   This mechanism allows the initiator and target to transfer a large\n
        \  amount of textual data over a sequence of text-command/text-response\n
        \  exchanges or to perform extended negotiation sequences.\n   If the Target
        Transfer Tag is not 0xffffffff, the LUN field MUST be\n   sent by the target
        in the Text Response.\n   A target MAY reset its internal negotiation state
        if an exchange is\n   stalled by the initiator for a long time or if it is
        running out of\n   resources.\n   Long Text Responses are handled as shown
        in the following example:\n      I->T Text SendTargets=All (F = 1, TTT = 0xffffffff)\n
        \     T->I Text <part 1> (F = 0, TTT = 0x12345678)\n      I->T Text <empty>
        (F = 1, TTT = 0x12345678)\n      T->I Text <part 2> (F = 0, TTT = 0x12345678)\n
        \     I->T Text <empty> (F = 1, TTT = 0x12345678)\n      ...\n      T->I Text
        <part n> (F = 1, TTT = 0xffffffff)\n"
      title: 11.10.4.  Target Transfer Tag
    - contents:
      - "11.10.5.  Text\n   The data lengths of a Text Request MUST NOT exceed the
        iSCSI target\n   MaxRecvDataSegmentLength (a parameter that is negotiated
        per\n   connection and per direction).  The text format is specified in\n
        \  Section 6.2.\n   Sections 12 and 13 list some basic Text key=value pairs,
        some of\n   which can be used in Login Requests/Responses and some in Text\n
        \  Requests/Responses.\n   A key=value pair can span Text Request or Text
        Response boundaries.\n   A key=value pair can start in one PDU and continue
        on the next.  In\n   other words, the end of a PDU does not necessarily signal
        the end of\n   a key=value pair.\n   The target responds by sending its response
        back to the initiator.\n   The response text format is similar to the request
        text format.  The\n   Text Response MAY refer to key=value pairs presented
        in an earlier\n   Text Request, and the text in the request may refer to earlier\n
        \  responses.\n   Section 6.2 details the rules for the Text Requests and
        Responses.\n   Text operations are usually meant for parameter setting/negotiations\n
        \  but can also be used to perform some long-lasting operations.\n   Text
        operations that take a long time should be placed in their own\n   Text Request.\n"
      title: 11.10.5.  Text
    title: 11.10.  Text Request
  - contents:
    - "11.11.  Text Response\n   The Text Response PDU contains the target's responses
      to the\n   initiator's Text Request.  The format of the Text field matches that\n
      \  of the Text Request.\n   Byte/     0       |       1       |       2       |
      \      3       |\n      /              |               |               |               |\n
      \    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x24      |F|C| Reserved                                  |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| LUN or Reserved                                               |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Target Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \    / DataSegment (Text)                                            /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    | Data-Digest (optional)                                        |\n     +---------------+---------------+---------------+---------------+\n"
    - contents:
      - "11.11.1.  F (Final) Bit\n   When set to 1, in response to a Text Request
        with the Final bit set\n   to 1, the F bit indicates that the target has finished
        the whole\n   operation.  Otherwise, if set to 0 in response to a Text Request
        with\n   the Final Bit set to 1, it indicates that the target has more work
        to\n   do (invites a follow-on Text Request).  A Text Response with the\n
        \  F bit set to 1 in response to a Text Request with the F bit set to 0\n
        \  is a protocol error.\n   A Text Response with the F bit set to 1 MUST NOT
        contain key=value\n   pairs that may require additional answers from the initiator.\n
        \  A Text Response with the F bit set to 1 MUST have a Target Transfer\n   Tag
        field set to the reserved value 0xffffffff.\n   A Text Response with the F
        bit set to 0 MUST have a Target Transfer\n   Tag field set to a value other
        than the reserved value 0xffffffff.\n"
      title: 11.11.1.  F (Final) Bit
    - contents:
      - "11.11.2.  C (Continue) Bit\n   When set to 1, this bit indicates that the
        text (set of key=value\n   pairs) in this Text Response is not complete (it
        will be continued on\n   subsequent Text Responses); otherwise, it indicates
        that this Text\n   Response ends a set of key=value pairs.  A Text Response
        with the\n   C bit set to 1 MUST have the F bit set to 0.\n"
      title: 11.11.2.  C (Continue) Bit
    - contents:
      - "11.11.3.  Initiator Task Tag\n   The Initiator Task Tag matches the tag used
        in the initial Text\n   Request.\n"
      title: 11.11.3.  Initiator Task Tag
    - contents:
      - "11.11.4.  Target Transfer Tag\n   When a target has more work to do (e.g.,
        cannot transfer all the\n   remaining text data in a single Text Response
        or has to continue the\n   negotiation) and has enough resources to proceed,
        it MUST set the\n   Target Transfer Tag to a value other than the reserved
        value\n   0xffffffff.  Otherwise, the Target Transfer Tag MUST be set to\n
        \  0xffffffff.\n   When the Target Transfer Tag is not 0xffffffff, the LUN
        field may be\n   significant.\n   The initiator MUST copy the Target Transfer
        Tag and LUN in its next\n   request to indicate that it wants the rest of
        the data.\n   When the target receives a Text Request with the Target Transfer
        Tag\n   set to the reserved value 0xffffffff, it resets its internal\n   information
        (resets state) associated with the given Initiator Task\n   Tag (restarts
        the negotiation).\n   When a target cannot finish the operation in a single
        Text Response\n   and does not have enough resources to continue, it rejects
        the Text\n   Request with the appropriate Reject code.\n   A target may reset
        its internal state associated with an Initiator\n   Task Tag (the current
        negotiation state) as expressed through the\n   Target Transfer Tag if the
        initiator fails to continue the exchange\n   for some time.  The target may
        reject subsequent Text Requests with\n   the Target Transfer Tag set to the
        \"stale\" value.\n"
      title: 11.11.4.  Target Transfer Tag
    - contents:
      - "11.11.5.  StatSN\n   The target StatSN variable is advanced by each Text
        Response sent.\n"
      title: 11.11.5.  StatSN
    - contents:
      - "11.11.6.  Text Response Data\n   The data lengths of a Text Response MUST
        NOT exceed the iSCSI\n   initiator MaxRecvDataSegmentLength (a parameter that
        is negotiated\n   per connection and per direction).\n   The text in the Text
        Response Data is governed by the same rules as\n   the text in the Text Request
        Data (see Section 11.11.2).\n   Although the initiator is the requesting party
        and controls the\n   request-response initiation and termination, the target
        can offer\n   key=value pairs of its own as part of a sequence and not only
        in\n   response to the initiator.\n"
      title: 11.11.6.  Text Response Data
    title: 11.11.  Text Response
  - contents:
    - "11.12.  Login Request\n   After establishing a TCP connection between an initiator
      and a\n   target, the initiator MUST start a Login Phase to gain further access\n
      \  to the target's resources.\n   The Login Phase (see Section 6.3) consists
      of a sequence of Login\n   Requests and Login Responses that carry the same
      Initiator Task Tag.\n   Login Requests are always considered as immediate.\n
      \  Byte/     0       |       1       |       2       |       3       |\n      /
      \             |               |               |               |\n     |0 1 2
      3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|1| 0x03      |T|C|.|.|CSG|NSG| Version-max   | Version-min   |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| ISID                                                          |\n     +
      \                              +---------------+---------------+\n   12|                               |
      TSIH                          |\n     +---------------+---------------+---------------+---------------+\n
      \  16| Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| CID                           | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n
      \  24| CmdSN                                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpStatSN or Reserved                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  32| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  40/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48/ DataSegment - Login Parameters in Text Request Format         /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n"
    - contents:
      - "11.12.1.  T (Transit) Bit\n   When set to 1, this bit indicates that the
        initiator is ready to\n   transit to the next stage.\n   If the T bit is set
        to 1 and the NSG is set to FullFeaturePhase, then\n   this also indicates
        that the initiator is ready for the Login\n   Final-Response (see Section
        6.3).\n"
      title: 11.12.1.  T (Transit) Bit
    - contents:
      - "11.12.2.  C (Continue) Bit\n   When set to 1, this bit indicates that the
        text (set of key=value\n   pairs) in this Login Request is not complete (it
        will be continued on\n   subsequent Login Requests); otherwise, it indicates
        that this Login\n   Request ends a set of key=value pairs.  A Login Request
        with the\n   C bit set to 1 MUST have the T bit set to 0.\n"
      title: 11.12.2.  C (Continue) Bit
    - contents:
      - "11.12.3.  CSG and NSG\n   Through these fields -- Current Stage (CSG) and
        Next Stage (NSG) --\n   the Login negotiation requests and responses are associated
        with a\n   specific stage in the session (SecurityNegotiation,\n   LoginOperationalNegotiation,
        FullFeaturePhase) and may indicate the\n   next stage to which they want to
        move (see Section 6.3).  The Next\n   Stage value is only valid when the T
        bit is 1; otherwise, it is\n   reserved.\n   The stage codes are:\n      0
        - SecurityNegotiation\n      1 - LoginOperationalNegotiation\n      3 - FullFeaturePhase\n
        \  All other codes are reserved.\n"
      title: 11.12.3.  CSG and NSG
    - contents:
      - "11.12.4.  Version\n   The version number for this document is 0x00.  Therefore,
        both\n   Version-min and Version-max MUST be set to 0x00.\n"
      - contents:
        - "11.12.4.1.  Version-max\n   Version-max indicates the maximum version number
          supported.\n   All Login Requests within the Login Phase MUST carry the
          same\n   Version-max.\n   The target MUST use the value presented with the
          first Login Request.\n"
        title: 11.12.4.1.  Version-max
      - contents:
        - "11.12.4.2.  Version-min\n   All Login Requests within the Login Phase MUST
          carry the same\n   Version-min.  The target MUST use the value presented
          with the first\n   Login Request.\n"
        title: 11.12.4.2.  Version-min
      title: 11.12.4.  Version
    - contents:
      - "11.12.5.  ISID\n   This is an initiator-defined component of the session
        identifier and\n   is structured as follows (see Section 10.1.1 for details):\n
        \  Byte/     0       |       1       |       2       |       3       |\n      /
        \             |               |               |               |\n     |0 1
        2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
        \   8| T |     A     |              B                |      C        |\n     +---------------+---------------+---------------+---------------+\n
        \  12|               D               |\n     +---------------+---------------+\n
        \  The T field identifies the format and usage of A, B, C, and D as\n   indicated
        below:\n      T\n      00b    OUI-Format\n             A and B: 22-bit OUI\n
        \            (the I/G and U/L bits are omitted)\n             C and D: 24-bit
        Qualifier\n      01b    EN: Format (IANA Enterprise Number)\n             A:
        Reserved\n             B and C: EN (IANA Enterprise Number)\n             D:
        Qualifier\n      10b    \"Random\"\n             A: Reserved\n             B
        and C: Random\n             D: Qualifier\n      11b    A, B, C, and D: Reserved\n
        \  For the T field values 00b and 01b, a combination of A and B (for\n   00b)
        or B and C (for 01b) identifies the vendor or organization whose\n   component
        (software or hardware) generates this ISID.  A vendor or\n   organization
        with one or more OUIs, or one or more Enterprise\n   Numbers, MUST use at
        least one of these numbers and select the\n   appropriate value for the T
        field when its components generate ISIDs.\n   An OUI or EN MUST be set in
        the corresponding fields in network byte\n   order (byte big-endian).\n   If
        the T field is 10b, B and C are set to a random 24-bit unsigned\n   integer
        value in network byte order (byte big-endian).  See [RFC3721]\n   for how
        this affects the principle of \"conservative reuse\".\n   The Qualifier field
        is a 16-bit or 24-bit unsigned integer value that\n   provides a range of
        possible values for the ISID within the selected\n   namespace.  It may be
        set to any value within the constraints\n   specified in the iSCSI protocol
        (see Sections 4.4.3 and 10.1.1).\n   The T field value of 11b is reserved.\n
        \  If the ISID is derived from something assigned to a hardware adapter\n
        \  or interface by a vendor as a preset default value, it MUST be\n   configurable
        to a value assigned according to the SCSI port behavior\n   desired by the
        system in which it is installed (see Sections 10.1.1\n   and 10.1.2).  The
        resultant ISID MUST also be persistent over power\n   cycles, reboot, card
        swap, etc.\n"
      title: 11.12.5.  ISID
    - contents:
      - "11.12.6.  TSIH\n   The TSIH must be set in the first Login Request.  The
        reserved value\n   0 MUST be used on the first connection for a new session.
        \ Otherwise,\n   the TSIH sent by the target at the conclusion of the successful
        login\n   of the first connection for this session MUST be used.  The TSIH\n
        \  identifies to the target the associated existing session for this new\n
        \  connection.\n   All Login Requests within a Login Phase MUST carry the
        same TSIH.\n   The target MUST check the value presented with the first Login\n
        \  Request and act as specified in Section 6.3.1.\n"
      title: 11.12.6.  TSIH
    - contents:
      - "11.12.7.  Connection ID (CID)\n   The CID provides a unique ID for this connection
        within the session.\n   All Login Requests within the Login Phase MUST carry
        the same CID.\n   The target MUST use the value presented with the first Login
        Request.\n   A Login Request with a non-zero TSIH and a CID equal to that
        of an\n   existing connection implies a logout of the connection followed
        by a\n   login (see Section 6.3.4).  For details regarding the implicit Logout\n
        \  Request, see Section 11.14.\n"
      title: 11.12.7.  Connection ID (CID)
    - contents:
      - "11.12.8.  CmdSN\n   The CmdSN is either the initial command sequence number
        of a session\n   (for the first Login Request of a session -- the \"leading\"
        login) or\n   the command sequence number in the command stream if the login
        is for\n   a new connection in an existing session.\n   Examples:\n   - Login
        on a leading connection: If the leading login carries the\n     CmdSN 123,
        all other Login Requests in the same Login Phase carry\n     the CmdSN 123,
        and the first non-immediate command in the Full\n     Feature Phase also carries
        the CmdSN 123.\n   - Login on other than a leading connection: If the current
        CmdSN at\n     the time the first login on the connection is issued is 500,
        then\n     that PDU carries CmdSN=500.  Subsequent Login Requests that are\n
        \    needed to complete this Login Phase may carry a CmdSN higher than\n     500
        if non-immediate requests that were issued on other connections\n     in the
        same session advance the CmdSN.\n   If the Login Request is a leading Login
        Request, the target MUST use\n   the value presented in the CmdSN as the target
        value for the\n   ExpCmdSN.\n"
      title: 11.12.8.  CmdSN
    - contents:
      - "11.12.9.  ExpStatSN\n   For the first Login Request on a connection, this
        is the ExpStatSN\n   for the old connection, and this field is only valid
        if the Login\n   Request restarts a connection (see Section 6.3.4).\n   For
        subsequent Login Requests, it is used to acknowledge the Login\n   Responses
        with their increasing StatSN values.\n"
      title: 11.12.9.  ExpStatSN
    - contents:
      - "11.12.10.  Login Parameters\n   The initiator MUST provide some basic parameters
        in order to enable\n   the target to determine if the initiator may use the
        target's\n   resources and the initial text parameters for the security exchange.\n
        \  All the rules specified in Section 11.10.5 for Text Requests also\n   hold
        for Login Requests.  Keys and their explanations are listed in\n   Section
        12 (security negotiation keys) and in Section 13 (operational\n   parameter
        negotiation keys).  All keys listed in Section 13, except\n   for the X extension
        formats, MUST be supported by iSCSI initiators\n   and targets.  Keys listed
        in Section 12 only need to be supported\n   when the function to which they
        refer is mandatory to implement.\n"
      title: 11.12.10.  Login Parameters
    title: 11.12.  Login Request
  - contents:
    - "11.13.  Login Response\n   The Login Response indicates the progress and/or
      end of the Login\n   Phase.\n   Byte/     0       |       1       |       2
      \      |       3       |\n      /              |               |               |
      \              |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1
      2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x23      |T|C|.|.|CSG|NSG| Version-max   |Version-active |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| ISID                                                          |\n     +
      \                              +---------------+---------------+\n   12|                               |
      TSIH                          |\n     +---------------+---------------+---------------+---------------+\n
      \  16| Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36| Status-Class  | Status-Detail | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n
      \  40/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48/ DataSegment - Login Parameters in Text Request Format         /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n"
    - contents:
      - "11.13.1.  Version-max\n   This is the highest version number supported by
        the target.\n   All Login Responses within the Login Phase MUST carry the
        same\n   Version-max.\n   The initiator MUST use the value presented as a
        response to the first\n   Login Request.\n"
      title: 11.13.1.  Version-max
    - contents:
      - "11.13.2.  Version-active\n   Version-active indicates the highest version
        supported by the target\n   and initiator.  If the target does not support
        a version within the\n   range specified by the initiator, the target rejects
        the login and\n   this field indicates the lowest version supported by the
        target.\n   All Login Responses within the Login Phase MUST carry the same\n
        \  Version-active.\n   The initiator MUST use the value presented as a response
        to the first\n   Login Request.\n"
      title: 11.13.2.  Version-active
    - contents:
      - "11.13.3.  TSIH\n   The TSIH is the target-assigned session-identifying handle.
        \ Its\n   internal format and content are not defined by this protocol, except\n
        \  for the value 0, which is reserved.  With the exception of the Login\n
        \  Final-Response in a new session, this field should be set to the TSIH\n
        \  provided by the initiator in the Login Request.  For a new session,\n   the
        target MUST generate a non-zero TSIH and ONLY return it in the\n   Login Final-Response
        (see Section 6.3).\n"
      title: 11.13.3.  TSIH
    - contents:
      - "11.13.4.  StatSN\n   For the first Login Response (the response to the first
        Login\n   Request), this is the starting status sequence number for the\n
        \  connection.  The next response of any kind -- including the next\n   Login
        Response, if any, in the same Login Phase -- will carry this\n   number +
        1.  This field is only valid if the Status-Class is 0.\n"
      title: 11.13.4.  StatSN
    - contents:
      - "11.13.5.  Status-Class and Status-Detail\n   The Status returned in a Login
        Response indicates the execution\n   status of the Login Phase.  The status
        includes:\n      Status-Class\n      Status-Detail\n   A Status-Class of 0
        indicates success.\n   A non-zero Status-Class indicates an exception.  In
        this case,\n   Status-Class is sufficient for a simple initiator to use when\n
        \  handling exceptions, without having to look at the Status-Detail.\n   The
        Status-Detail allows finer-grained exception handling for more\n   sophisticated
        initiators and for better information for logging.\n   The Status-Classes
        are as follows:\n      0  Success - indicates that the iSCSI target successfully\n
        \        received, understood, and accepted the request.  The numbering\n
        \        fields (StatSN, ExpCmdSN, MaxCmdSN) are only valid if Status-\n         Class
        is 0.\n      1  Redirection - indicates that the initiator must take further\n
        \        action to complete the request.  This is usually due to the\n         target
        moving to a different address.  All of the redirection\n         Status-Class
        responses MUST return one or more text key\n         parameters of the type
        \"TargetAddress\", which indicates the\n         target's new address.  A
        redirection response MAY be issued by\n         a target prior to or after
        completing a security negotiation if\n         a security negotiation is required.
        \ A redirection SHOULD be\n         accepted by an initiator, even without
        having the target\n         complete a security negotiation if any security
        negotiation is\n         required, and MUST be accepted by the initiator after
        the\n         completion of the security negotiation if any security\n         negotiation
        is required.\n      2  Initiator Error (not a format error) - indicates that
        the\n         initiator most likely caused the error.  This MAY be due to
        a\n         request for a resource for which the initiator does not have\n
        \        permission.  The request should not be tried again.\n      3  Target
        Error - indicates that the target sees no errors in the\n         initiator's
        Login Request but is currently incapable of\n         fulfilling the request.
        \ The initiator may retry the same Login\n         Request later.\n   The
        table below shows all of the currently allocated status codes.\n   The codes
        are in hexadecimal; the first byte is the Status-Class, and\n   the second
        byte is the status detail.\n     -----------------------------------------------------------------\n
        \    Status        | Code | Description\n                   |(hex) |\n     -----------------------------------------------------------------\n
        \    Success       | 0000 | Login is proceeding OK (*1).\n     -----------------------------------------------------------------\n
        \    Target moved  | 0101 | The requested iSCSI Target Name (ITN)\n     temporarily
        \  |      | has temporarily moved\n                   |      | to the address
        provided.\n     -----------------------------------------------------------------\n
        \    Target moved  | 0102 | The requested ITN has permanently moved\n     permanently
        \  |      | to the address provided.\n     -----------------------------------------------------------------\n
        \    Initiator     | 0200 | Miscellaneous iSCSI initiator\n     error         |
        \     | errors.\n     -----------------------------------------------------------------\n
        \    Authentication| 0201 | The initiator could not be\n     failure       |
        \     | successfully authenticated or target\n                   |      |
        authentication is not supported.\n     -----------------------------------------------------------------\n
        \    Authorization | 0202 | The initiator is not allowed access\n     failure
        \      |      | to the given target.\n     -----------------------------------------------------------------\n
        \    Not found     | 0203 | The requested ITN does not\n                   |
        \     | exist at this address.\n     -----------------------------------------------------------------\n
        \    Target removed| 0204 | The requested ITN has been removed, and\n                   |
        \     | no forwarding address is provided.\n     -----------------------------------------------------------------\n
        \    Unsupported   | 0205 | The requested iSCSI version range is\n     version
        \      |      | not supported by the target.\n     -----------------------------------------------------------------\n
        \    Too many      | 0206 | Too many connections on this SSID.\n     connections
        \  |      |\n     -----------------------------------------------------------------\n
        \    Missing       | 0207 | Missing parameters (e.g., iSCSI\n     parameter
        \    |      | Initiator Name and/or Target Name).\n     -----------------------------------------------------------------\n
        \    Can't include | 0208 | Target does not support session\n     in session
        \   |      | spanning to this connection (address).\n     -----------------------------------------------------------------\n
        \    Session type  | 0209 | Target does not support this type of\n     not
        supported |      | session or not from this initiator.\n     -----------------------------------------------------------------\n
        \    Session does  | 020a | Attempt to add a connection\n     not exist     |
        \     | to a non-existent session.\n     -----------------------------------------------------------------\n
        \    Invalid during| 020b | Invalid request type during login.\n     login
        \        |      |\n     -----------------------------------------------------------------\n
        \    Target error  | 0300 | Target hardware or software error.\n     -----------------------------------------------------------------\n
        \    Service       | 0301 | The iSCSI service or target is not\n     unavailable
        \  |      | currently operational.\n     -----------------------------------------------------------------\n
        \    Out of        | 0302 | The target has insufficient session,\n     resources
        \    |      | connection, or other resources.\n     -----------------------------------------------------------------\n
        \  (*1) If the response T bit is set to 1 in both the request and the\n        matching
        response, and the NSG is set to FullFeaturePhase in\n        both the request
        and the matching response, the Login Phase is\n        finished, and the initiator
        may proceed to issue SCSI commands.\n   If the Status-Class is not 0, the
        initiator and target MUST close the\n   TCP connection.\n   If the target
        wishes to reject the Login Request for more than one\n   reason, it should
        return the primary reason for the rejection.\n"
      title: 11.13.5.  Status-Class and Status-Detail
    - contents:
      - "11.13.6.  T (Transit) Bit\n   The T bit is set to 1 as an indicator of the
        end of the stage.  If\n   the T bit is set to 1 and the NSG is set to FullFeaturePhase,
        then\n   this is also the Login Final-Response (see Section 6.3).  A T bit
        of\n   0 indicates a \"partial\" response, which means \"more negotiation\n
        \  needed\".\n   A Login Response with the T bit set to 1 MUST NOT contain
        key=value\n   pairs that may require additional answers from the initiator
        within\n   the same stage.\n   If the Status-Class is 0, the T bit MUST NOT
        be set to 1 if the T bit\n   in the request was set to 0.\n"
      title: 11.13.6.  T (Transit) Bit
    - contents:
      - "11.13.7.  C (Continue) Bit\n   When set to 1, this bit indicates that the
        text (set of key=value\n   pairs) in this Login Response is not complete (it
        will be continued\n   on subsequent Login Responses); otherwise, it indicates
        that this\n   Login Response ends a set of key=value pairs.  A Login Response
        with\n   the C bit set to 1 MUST have the T bit set to 0.\n"
      title: 11.13.7.  C (Continue) Bit
    - contents:
      - "11.13.8.  Login Parameters\n   The target MUST provide some basic parameters
        in order to enable the\n   initiator to determine if it is connected to the
        correct port and the\n   initial text parameters for the security exchange.\n
        \  All the rules specified in Section 11.11.6 for Text Responses also\n   hold
        for Login Responses.  Keys and their explanations are listed in\n   Section
        12 (security negotiation keys) and in Section 13 (operational\n   parameter
        negotiation keys).  All keys listed in Section 13, except\n   for the X extension
        formats, MUST be supported by iSCSI initiators\n   and targets.  Keys listed
        in Section 12 only need to be supported\n   when the function to which they
        refer is mandatory to implement.\n"
      title: 11.13.8.  Login Parameters
    title: 11.13.  Login Response
  - contents:
    - "11.14.  Logout Request\n   The Logout Request is used to perform a controlled
      closing of a\n   connection.\n   An initiator MAY use a Logout Request to remove
      a connection from a\n   session or to close an entire session.\n   After sending
      the Logout Request PDU, an initiator MUST NOT send any\n   new iSCSI requests
      on the closing connection.  If the Logout Request\n   is intended to close the
      session, new iSCSI requests MUST NOT be sent\n   on any of the connections participating
      in the session.\n   When receiving a Logout Request with the reason code \"close
      the\n   connection\" or \"close the session\", the target MUST terminate all\n
      \  pending commands, whether acknowledged via the ExpCmdSN or not, on\n   that
      connection or session, respectively.\n   When receiving a Logout Request with
      the reason code \"remove the\n   connection for recovery\", the target MUST
      discard all requests not\n   yet acknowledged via the ExpCmdSN that were issued
      on the specified\n   connection and suspend all data/status/R2T transfers on
      behalf of\n   pending commands on the specified connection.\n   The target then
      issues the Logout Response and half-closes the TCP\n   connection (sends FIN).
      \ After receiving the Logout Response and\n   attempting to receive the FIN
      (if still possible), the initiator MUST\n   completely close the logging-out
      connection.  For the terminated\n   commands, no additional responses should
      be expected.\n   A Logout for a CID may be performed on a different transport\n
      \  connection when the TCP connection for the CID has already been\n   terminated.
      \ In such a case, only a logical \"closing\" of the iSCSI\n   connection for
      the CID is implied with a Logout.\n   All commands that were not terminated
      or not completed (with status)\n   and acknowledged when the connection is closed
      completely can be\n   reassigned to a new connection if the target supports
      connection\n   recovery.\n   If an initiator intends to start recovery for a
      failing connection,\n   it MUST use the Logout Request to \"clean up\" the target
      end of a\n   failing connection and enable recovery to start, or use the Login\n
      \  Request with a non-zero TSIH and the same CID on a new connection for\n   the
      same effect.  In sessions with a single connection, the\n   connection can be
      closed and then a new connection reopened.  A\n   connection reinstatement login
      can be used for recovery (see\n   Section 6.3.4).\n   A successful completion
      of a Logout Request with the reason code\n   \"close the connection\" or \"remove
      the connection for recovery\"\n   results at the target in the discarding of
      unacknowledged commands\n   received on the connection being logged out.  These
      are commands that\n   have arrived on the connection being logged out but that
      have not\n   been delivered to SCSI because one or more commands with a smaller\n
      \  CmdSN have not been received by iSCSI.  See Section 4.2.2.1.  The\n   resulting
      holes in the command sequence numbers will have to be\n   handled by appropriate
      recovery (see Section 7), unless the session\n   is also closed.\n   The entire
      logout discussion in this section is also applicable for\n   an implicit Logout
      realized by way of a connection reinstatement or\n   session reinstatement.
      \ When a Login Request performs an implicit\n   Logout, the implicit Logout
      is performed as if having the reason\n   codes specified below:\n     Reason
      Code     Type of Implicit Logout\n     -------------------------------------------------------------\n
      \         0          session reinstatement\n          1          connection
      reinstatement when the operational\n                     ErrorRecoveryLevel
      < 2\n          2          connection reinstatement when the operational\n                     ErrorRecoveryLevel
      = 2\n   Byte/     0       |       1       |       2       |       3       |\n
      \     /              |               |               |               |\n     |0
      1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|I| 0x06      |1| Reason Code | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------------------------------------------------------+\n
      \   8/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  16| Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| CID or Reserved               | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n
      \  24| CmdSN                                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpStatSN                                                     |\n     +---------------+---------------+---------------+---------------+\n
      \  32/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n"
    - contents:
      - "11.14.1.  Reason Code\n   The Reason Code field indicates the reason for
        Logout as follows:\n      0 - close the session.  All commands associated
        with the\n          session (if any) are terminated.\n      1 - close the
        connection.  All commands associated with the\n          connection (if any)
        are terminated.\n      2 - remove the connection for recovery.  The connection
        is\n          closed, and all commands associated with it, if any, are\n          to
        be prepared for a new allegiance.\n   All other values are reserved.\n"
      title: 11.14.1.  Reason Code
    - contents:
      - "11.14.2.  TotalAHSLength and DataSegmentLength\n   For this PDU, TotalAHSLength
        and DataSegmentLength MUST be 0.\n"
      title: 11.14.2.  TotalAHSLength and DataSegmentLength
    - contents:
      - "11.14.3.  CID\n   This is the connection ID of the connection to be closed
        (including\n   closing the TCP stream).  This field is only valid if the reason
        code\n   is not \"close the session\".\n"
      title: 11.14.3.  CID
    - contents:
      - "11.14.4.  ExpStatSN\n   This is the last ExpStatSN value for the connection
        to be closed.\n"
      title: 11.14.4.  ExpStatSN
    - contents:
      - "11.14.5.  Implicit Termination of Tasks\n   A target implicitly terminates
        the active tasks due to the iSCSI\n   protocol in the following cases:\n      a)
        When a connection is implicitly or explicitly logged out with\n         the
        reason code \"close the connection\" and there are active\n         tasks
        allegiant to that connection.\n      b) When a connection fails and eventually
        the connection state\n         times out (state transition M1 in Section 8.2.2)
        and there are\n         active tasks allegiant to that connection.\n      c)
        When a successful recovery Logout is performed while there are\n         active
        tasks allegiant to that connection and those tasks\n         eventually time
        out after the Time2Wait and Time2Retain periods\n         without allegiance
        reassignment.\n      d) When a connection is implicitly or explicitly logged
        out with\n         the reason code \"close the session\" and there are active
        tasks\n         in that session.\n   If the tasks terminated in any of the
        above cases are SCSI tasks,\n   they must be internally terminated as if with
        CHECK CONDITION status.\n   This status is only meaningful for appropriately
        handling the\n   internal SCSI state and SCSI side effects with respect to
        ordering,\n   because this status is never communicated back as a terminating\n
        \  status to the initiator.  However, additional actions may have to be\n
        \  taken at the SCSI level, depending on the SCSI context as defined by\n
        \  the SCSI standards (e.g., queued commands and ACA; UA for the next\n   command
        on the I_T nexus in cases a), b), and c) above).  After the\n   tasks are
        terminated, the target MUST report a Unit Attention\n   condition on the next
        command processed on any connection for each\n   affected I_T_L nexus with
        the status of CHECK CONDITION, the ASC/ASCQ\n   value of 47h/7Fh (\"SOME COMMANDS
        CLEARED BY ISCSI PROTOCOL EVENT\"),\n   etc.; see [SPC3].\n"
      title: 11.14.5.  Implicit Termination of Tasks
    title: 11.14.  Logout Request
  - contents:
    - "11.15.  Logout Response\n   The Logout Response is used by the target to indicate
      if the cleanup\n   operation for the connection(s) has completed.\n   After
      Logout, the TCP connection referred by the CID MUST be closed\n   at both ends
      (or all connections must be closed if the logout reason\n   was session close).\n
      \  Byte/     0       |       1       |       2       |       3       |\n      /
      \             |               |               |               |\n     |0 1 2
      3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x26      |1| Reserved    | Response      | Reserved      |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------------------------------------------------------+\n
      \   8/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  16| Initiator Task Tag                                            |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36| Reserved                                                      |\n     +---------------------------------------------------------------+\n
      \  40| Time2Wait                     | Time2Retain                   |\n     +---------------+---------------+---------------+---------------+\n
      \  44| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n"
    - contents:
      - "11.15.1.  Response\n   Response field settings are as follows:\n      0 -
        connection or session closed successfully.\n      1 - CID not found.\n      2
        - connection recovery is not supported (i.e., the Logout reason\n          code
        was \"remove the connection for recovery\" and the target\n          does
        not support it as indicated by the operational\n          ErrorRecoveryLevel).\n
        \     3 - cleanup failed for various reasons.\n"
      title: 11.15.1.  Response
    - contents:
      - "11.15.2.  TotalAHSLength and DataSegmentLength\n   For this PDU, TotalAHSLength
        and DataSegmentLength MUST be 0.\n"
      title: 11.15.2.  TotalAHSLength and DataSegmentLength
    - contents:
      - "11.15.3.  Time2Wait\n   If the Logout response code is 0 and the operational\n
        \  ErrorRecoveryLevel is 2, this is the minimum amount of time, in\n   seconds,
        to wait before attempting task reassignment.  If the Logout\n   response code
        is 0 and the operational ErrorRecoveryLevel is less\n   than 2, this field
        is to be ignored.\n   This field is invalid if the Logout response code is
        1.\n   If the Logout response code is 2 or 3, this field specifies the\n   minimum
        time to wait before attempting a new implicit or explicit\n   logout.\n   If
        Time2Wait is 0, the reassignment or a new Logout may be attempted\n   immediately.\n"
      title: 11.15.3.  Time2Wait
    - contents:
      - "11.15.4.  Time2Retain\n   If the Logout response code is 0 and the operational\n
        \  ErrorRecoveryLevel is 2, this is the maximum amount of time, in\n   seconds,
        after the initial wait (Time2Wait) that the target waits for\n   the allegiance
        reassignment for any active task, after which the task\n   state is discarded.
        \ If the Logout response code is 0 and the\n   operational ErrorRecoveryLevel
        is less than 2, this field is to be\n   ignored.\n   This field is invalid
        if the Logout response code is 1.\n   If the Logout response code is 2 or
        3, this field specifies the\n   maximum amount of time, in seconds, after
        the initial wait\n   (Time2Wait) that the target waits for a new implicit
        or explicit\n   logout.\n   If it is the last connection of a session, the
        whole session state is\n   discarded after Time2Retain.\n   If Time2Retain
        is 0, the target has already discarded the connection\n   (and possibly the
        session) state along with the task states.  No\n   reassignment or Logout
        is required in this case.\n"
      title: 11.15.4.  Time2Retain
    title: 11.15.  Logout Response
  - contents:
    - "11.16.  SNACK Request\n   Byte/     0       |       1       |       2       |
      \      3       |\n      /              |               |               |               |\n
      \    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x10      |1|.|.|.| Type  | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| LUN or Reserved                                               |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag or 0xffffffff                              |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Target Transfer Tag or SNACK Tag or 0xffffffff                |\n     +---------------+---------------+---------------+---------------+\n
      \  24| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpStatSN                                                     |\n     +---------------+---------------+---------------+---------------+\n
      \  32/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  40| BegRun                                                        |\n     +---------------------------------------------------------------+\n
      \  44| RunLength                                                     |\n     +---------------------------------------------------------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  If the implementation supports ErrorRecoveryLevel greater than zero,\n   it
      MUST support all SNACK types.\n   The SNACK is used by the initiator to request
      the retransmission of\n   numbered responses, data, or R2T PDUs from the target.
      \ The SNACK\n   Request indicates the numbered responses or data \"runs\" whose\n
      \  retransmission is requested, where the run starts with the first\n   StatSN,
      DataSN, or R2TSN whose retransmission is requested and\n   indicates the number
      of Status, Data, or R2T PDUs requested,\n   including the first.  0 has special
      meaning when used as a starting\n   number and length:\n      - When used in
      RunLength, it means all PDUs starting with the\n        initial.\n      - When
      used in both BegRun and RunLength, it means all\n        unacknowledged PDUs.\n
      \  The numbered response(s) or R2T(s) requested by a SNACK MUST be\n   delivered
      as exact replicas of the ones that the target transmitted\n   originally, except
      for the fields ExpCmdSN, MaxCmdSN, and ExpDataSN,\n   which MUST carry the current
      values.  R2T(s)requested by SNACK MUST\n   also carry the current value of the
      StatSN.\n   The numbered Data-In PDUs requested by a Data SNACK MUST be delivered\n
      \  as exact replicas of the ones that the target transmitted originally,\n   except
      for the fields ExpCmdSN and MaxCmdSN, which MUST carry the\n   current values;
      and except for resegmentation (see Section 11.16.3).\n   Any SNACK that requests
      a numbered response, data, or R2T that was\n   not sent by the target or was
      already acknowledged by the initiator\n   MUST be rejected with a reason code
      of \"Protocol Error\".\n"
    - contents:
      - "11.16.1.  Type\n   This field encodes the SNACK function as follows:\n      0
        - Data/R2T SNACK: requesting retransmission of one or more\n          Data-In
        or R2T PDUs.\n      1 - Status SNACK: requesting retransmission of one or
        more\n          numbered responses.\n      2 - DataACK: positively acknowledges
        Data-In PDUs.\n      3 - R-Data SNACK: requesting retransmission of Data-In
        PDUs with\n          possible resegmentation and status tagging.\n   All other
        values are reserved.\n   Data/R2T SNACK, Status SNACK, or R-Data SNACK for
        a command MUST\n   precede status acknowledgment for the given command.\n"
      title: 11.16.1.  Type
    - contents:
      - "11.16.2.  Data Acknowledgment\n   If an initiator operates at ErrorRecoveryLevel
        1 or higher, it MUST\n   issue a SNACK of type DataACK after receiving a Data-In
        PDU with the\n   A bit set to 1.  However, if the initiator has detected holes
        in the\n   input sequence, it MUST postpone issuing the SNACK of type DataACK\n
        \  until the holes are filled.  An initiator MAY ignore the A bit if it\n
        \  deems that the bit is being set aggressively by the target (i.e.,\n   before
        the MaxBurstLength limit is reached).\n   The DataACK is used to free resources
        at the target and not to\n   request or imply data retransmission.\n   An
        initiator MUST NOT request retransmission for any data it had\n   already
        acknowledged.\n"
      title: 11.16.2.  Data Acknowledgment
    - contents:
      - "11.16.3.  Resegmentation\n   If the initiator MaxRecvDataSegmentLength changed
        between the\n   original transmission and the time the initiator requests\n
        \  retransmission, the initiator MUST issue a R-Data SNACK (see\n   Section
        11.16.1).  With R-Data SNACK, the initiator indicates that it\n   discards
        all the unacknowledged data and expects the target to resend\n   it.  It also
        expects resegmentation.  In this case, the retransmitted\n   Data-In PDUs
        MAY be different from the ones originally sent in order\n   to reflect changes
        in MaxRecvDataSegmentLength.  Their DataSN starts\n   with the BegRun of the
        last DataACK received by the target if any was\n   received; otherwise, it
        starts with 0 and is increased by 1 for each\n   resent Data-In PDU.\n   A
        target that has received a R-Data SNACK MUST return a SCSI Response\n   that
        contains a copy of the SNACK Tag field from the R-Data SNACK in\n   the SCSI
        Response SNACK Tag field as its last or only Response.  For\n   example, if
        it has already sent a response containing another value\n   in the SNACK Tag
        field or had the status included in the last Data-In\n   PDU, it must send
        a new SCSI Response PDU.  If a target sends more\n   than one SCSI Response
        PDU due to this rule, all SCSI Response PDUs\n   must carry the same StatSN
        (see Section 11.4.4).  If an initiator\n   attempts to recover a lost SCSI
        Response (with a Status-SNACK; see\n   Section 11.16.1) when more than one
        response has been sent, the\n   target will send the SCSI Response with the
        latest content known to\n   the target, including the last SNACK Tag for the
        command.\n   For considerations in allegiance reassignment of a task to a\n
        \  connection with a different MaxRecvDataSegmentLength, refer to\n   Section
        7.2.2.\n"
      title: 11.16.3.  Resegmentation
    - contents:
      - "11.16.4.  Initiator Task Tag\n   For a Status SNACK and DataACK, the Initiator
        Task Tag MUST be set to\n   the reserved value 0xffffffff.  In all other cases,
        the Initiator\n   Task Tag field MUST be set to the Initiator Task Tag of
        the\n   referenced command.\n"
      title: 11.16.4.  Initiator Task Tag
    - contents:
      - "11.16.5.  Target Transfer Tag or SNACK Tag\n   For a R-Data SNACK, this field
        MUST contain a value that is different\n   from 0 or 0xffffffff and is unique
        for the task (identified by the\n   Initiator Task Tag).  This value MUST
        be copied by the iSCSI target\n   in the last or only SCSI Response PDU it
        issues for the command.\n   For DataACK, the Target Transfer Tag MUST contain
        a copy of the\n   Target Transfer Tag and LUN provided with the SCSI Data-In
        PDU with\n   the A bit set to 1.\n   In all other cases, the Target Transfer
        Tag field MUST be set to the\n   reserved value 0xffffffff.\n"
      title: 11.16.5.  Target Transfer Tag or SNACK Tag
    - contents:
      - "11.16.6.  BegRun\n   This field indicates the DataSN, R2TSN, or StatSN of
        the first PDU\n   whose retransmission is requested (Data/R2T and Status SNACK),
        or the\n   next expected DataSN (DataACK SNACK).\n   A BegRun of 0, when used
        in conjunction with a RunLength of 0, means\n   \"resend all unacknowledged
        Data-In, R2T or Response PDUs\".\n   BegRun MUST be 0 for a R-Data SNACK.\n"
      title: 11.16.6.  BegRun
    - contents:
      - "11.16.7.  RunLength\n   This field indicates the number of PDUs whose retransmission
        is\n   requested.\n   A RunLength of 0 signals that all Data-In, R2T, or Response
        PDUs\n   carrying the numbers equal to or greater than BegRun have to be\n
        \  resent.\n   The RunLength MUST also be 0 for a DataACK SNACK in addition
        to a\n   R-Data SNACK.\n"
      title: 11.16.7.  RunLength
    title: 11.16.  SNACK Request
  - contents:
    - "11.17.  Reject\n   Byte/     0       |       1       |       2       |       3
      \      |\n      /              |               |               |               |\n
      \    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x3f      |1| Reserved    | Reason        | Reserved      |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  16| 0xffffffff                                                    |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36| DataSN/R2TSN or Reserved                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  40| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  44| Reserved                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  xx/ Complete Header of Bad PDU                                    /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  yy/Vendor-specific data (if any)                                  /\n     /
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  zz| Data-Digest (optional)                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  Reject is used to indicate an iSCSI error condition (protocol,\n   unsupported
      option, etc.).\n"
    - contents:
      - "11.17.1.  Reason\n   The reject Reason is coded as follows:\n   +------+----------------------------------------+----------------+\n
        \  | Code | Explanation                            |Can the original|\n   |
        (hex)|                                        |PDU be resent?  |\n   +------+----------------------------------------+----------------+\n
        \  | 0x01 | Reserved                               | no             |\n   |
        \     |                                        |                |\n   | 0x02
        | Data (payload) digest error            | yes (Note 1)   |\n   |      |                                        |
        \               |\n   | 0x03 | SNACK Reject                           | yes
        \           |\n   |      |                                        |                |\n
        \  | 0x04 | Protocol Error (e.g., SNACK Request for| no             |\n   |
        \     | a status that was already acknowledged)|                |\n   |      |
        \                                       |                |\n   | 0x05 | Command
        not supported                  | no             |\n   |      |                                        |
        \               |\n   | 0x06 | Immediate command reject - too many    | yes
        \           |\n   |      | immediate commands                     |                |\n
        \  |      |                                        |                |\n   |
        0x07 | Task in progress                       | no             |\n   |      |
        \                                       |                |\n   | 0x08 | Invalid
        data ack                       | no             |\n   |      |                                        |
        \               |\n   | 0x09 | Invalid PDU field                      | no
        (Note 2)    |\n   |      |                                        |                |\n
        \  | 0x0a | Long op reject - Can't generate Target | yes            |\n   |
        \     | Transfer Tag - out of resources        |                |\n   |      |
        \                                       |                |\n   | 0x0b | Deprecated;
        MUST NOT be used           | N/A (Note 3)   |\n   |      |                                        |
        \               |\n   | 0x0c | Waiting for Logout                     | no
        \            |\n   +------+----------------------------------------+----------------+\n
        \  Note 1: For iSCSI, Data-Out PDU retransmission is only done if the\n           target
        requests retransmission with a recovery R2T.  However,\n           if this
        is the data digest error on immediate data, the\n           initiator may
        choose to retransmit the whole PDU, including\n           the immediate data.\n
        \  Note 2: A target should use this reason code for all invalid values\n           of
        PDU fields that are meant to describe a task, a response,\n           or a
        data transfer.  Some examples are invalid TTT/ITT,\n           buffer offset,
        LUN qualifying a TTT, and an invalid sequence\n           number in a SNACK.\n
        \  Note 3: Reason code 0x0b (\"Negotiation Reset\") as defined in\n           Section
        10.17.1 of [RFC3720] is deprecated and MUST NOT be\n           used by implementations.
        \ An implementation receiving reason\n           code 0x0b MUST treat it as
        a negotiation failure that\n           terminates the Login Phase and the
        TCP connection, as\n           specified in Section 7.12.\n   All other values
        for Reason are unassigned.\n   In all the cases in which a pre-instantiated
        SCSI task is terminated\n   because of the reject, the target MUST issue a
        proper SCSI command\n   response with CHECK CONDITION as described in Section
        11.4.3.  In\n   these cases in which a status for the SCSI task was already
        sent\n   before the reject, no additional status is required.  If the error
        is\n   detected while data from the initiator is still expected (i.e., the\n
        \  command PDU did not contain all the data and the target has not\n   received
        a Data-Out PDU with the Final bit set to 1 for the\n   unsolicited data, if
        any, and all outstanding R2Ts, if any), the\n   target MUST wait until it
        receives the last expected Data-Out PDUs\n   with the F bit set to 1 before
        sending the Response PDU.\n   For additional usage semantics of the Reject
        PDU, see Section 7.3.\n"
      title: 11.17.1.  Reason
    - contents:
      - "11.17.2.  DataSN/R2TSN\n   This field is only valid if the rejected PDU is
        a Data/R2T SNACK and\n   the Reject reason code is \"Protocol Error\" (see
        Section 11.16).  The\n   DataSN/R2TSN is the next Data/R2T sequence number
        that the target\n   would send for the task, if any.\n"
      title: 11.17.2.  DataSN/R2TSN
    - contents:
      - "11.17.3.  StatSN, ExpCmdSN, and MaxCmdSN\n   These fields carry their usual
        values and are not related to the\n   rejected command.  The StatSN is advanced
        after a Reject.\n"
      title: 11.17.3.  StatSN, ExpCmdSN, and MaxCmdSN
    - contents:
      - "11.17.4.  Complete Header of Bad PDU\n   The target returns the header (not
        including the digest) of the PDU\n   in error as the data of the response.\n"
      title: 11.17.4.  Complete Header of Bad PDU
    title: 11.17.  Reject
  - contents:
    - "11.18.  NOP-Out\n   Byte/     0       |       1       |       2       |       3
      \      |\n      /              |               |               |               |\n
      \    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|I| 0x00      |1| Reserved                                    |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| LUN or Reserved                                               |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag or 0xffffffff                              |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Target Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n
      \  24| CmdSN                                                         |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpStatSN                                                     |\n     +---------------+---------------+---------------+---------------+\n
      \  32/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \    / DataSegment - Ping Data (optional)                            /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    | Data-Digest (optional)                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  NOP-Out may be used by an initiator as a \"ping request\" to verify\n   that
      a connection/session is still active and all its components are\n   operational.
      \ The NOP-In response is the \"ping echo\".\n   A NOP-Out is also sent by an
      initiator in response to a NOP-In.\n   A NOP-Out may also be used to confirm
      a changed ExpStatSN if another\n   PDU will not be available for a long time.\n
      \  Upon receipt of a NOP-In with the Target Transfer Tag set to a valid\n   value
      (not the reserved value 0xffffffff), the initiator MUST respond\n   with a NOP-Out.
      \ In this case, the NOP-Out Target Transfer Tag MUST\n   contain a copy of the
      NOP-In Target Transfer Tag.  The initiator\n   SHOULD NOT send a NOP-Out in
      response to any other received NOP-In,\n   in order to avoid lengthy sequences
      of NOP-In and NOP-Out PDUs sent\n   in response to each other.\n"
    - contents:
      - "11.18.1.  Initiator Task Tag\n   The NOP-Out MUST have the Initiator Task
        Tag set to a valid value\n   only if a response in the form of a NOP-In is
        requested (i.e., the\n   NOP-Out is used as a ping request).  Otherwise, the
        Initiator Task\n   Tag MUST be set to 0xffffffff.\n   When a target receives
        the NOP-Out with a valid Initiator Task Tag,\n   it MUST respond with a NOP-In
        Response (see Section 4.6.3.6).\n   If the Initiator Task Tag contains 0xffffffff,
        the I bit MUST be set\n   to 1, and the CmdSN is not advanced after this PDU
        is sent.\n"
      title: 11.18.1.  Initiator Task Tag
    - contents:
      - "11.18.2.  Target Transfer Tag\n   The Target Transfer Tag is a target-assigned
        identifier for the\n   operation.\n   The NOP-Out MUST only have the Target
        Transfer Tag set if it is\n   issued in response to a NOP-In with a valid
        Target Transfer Tag.  In\n   this case, it copies the Target Transfer Tag
        from the NOP-In PDU.\n   Otherwise, the Target Transfer Tag MUST be set to
        0xffffffff.\n   When the Target Transfer Tag is set to a value other than
        0xffffffff,\n   the LUN field MUST also be copied from the NOP-In.\n"
      title: 11.18.2.  Target Transfer Tag
    - contents:
      - "11.18.3.  Ping Data\n   Ping data is reflected in the NOP-In Response.  The
        length of the\n   reflected data is limited to MaxRecvDataSegmentLength.  The
        length of\n   ping data is indicated by the DataSegmentLength.  0 is a valid
        value\n   for the DataSegmentLength and indicates the absence of ping data.\n"
      title: 11.18.3.  Ping Data
    title: 11.18.  NOP-Out
  - contents:
    - "11.19.  NOP-In\n   Byte/     0       |       1       |       2       |       3
      \      |\n      /              |               |               |               |\n
      \    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n
      \   0|.|.| 0x20      |1| Reserved                                    |\n     +---------------+---------------+---------------+---------------+\n
      \   4|TotalAHSLength | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n
      \   8| LUN or Reserved                                               |\n     +
      \                                                              +\n   12|                                                               |\n
      \    +---------------+---------------+---------------+---------------+\n   16|
      Initiator Task Tag or 0xffffffff                              |\n     +---------------+---------------+---------------+---------------+\n
      \  20| Target Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n
      \  24| StatSN                                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  28| ExpCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  32| MaxCmdSN                                                      |\n     +---------------+---------------+---------------+---------------+\n
      \  36/ Reserved                                                      /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \  48| Header-Digest (optional)                                      |\n     +---------------+---------------+---------------+---------------+\n
      \    / DataSegment - Return Ping Data                                /\n    +/
      \                                                              /\n     +---------------+---------------+---------------+---------------+\n
      \    | Data-Digest (optional)                                        |\n     +---------------+---------------+---------------+---------------+\n
      \  NOP-In is sent by a target as either a response to a NOP-Out, a\n   \"ping\"
      to an initiator, or a means to carry a changed ExpCmdSN and/or\n   MaxCmdSN
      if another PDU will not be available for a long time (as\n   determined by the
      target).\n   When a target receives the NOP-Out with a valid Initiator Task
      Tag\n   (not the reserved value 0xffffffff), it MUST respond with a NOP-In\n
      \  with the same Initiator Task Tag that was provided in the NOP-Out\n   request.
      \ It MUST also duplicate up to the first\n   MaxRecvDataSegmentLength bytes
      of the initiator-provided Ping Data.\n   For such a response, the Target Transfer
      Tag MUST be 0xffffffff.  The\n   target SHOULD NOT send a NOP-In in response
      to any other received\n   NOP-Out in order to avoid lengthy sequences of NOP-In
      and NOP-Out\n   PDUs sent in response to each other.\n   Otherwise, when a target
      sends a NOP-In that is not a response to a\n   NOP-Out received from the initiator,
      the Initiator Task Tag MUST be\n   set to 0xffffffff, and the data segment MUST
      NOT contain any data\n   (DataSegmentLength MUST be 0).\n"
    - contents:
      - "11.19.1.  Target Transfer Tag\n   If the target is responding to a NOP-Out,
        this field is set to the\n   reserved value 0xffffffff.\n   If the target
        is sending a NOP-In as a ping (intending to receive a\n   corresponding NOP-Out),
        this field is set to a valid value (not the\n   reserved value 0xffffffff).\n
        \  If the target is initiating a NOP-In without wanting to receive a\n   corresponding
        NOP-Out, this field MUST hold the reserved value\n   0xffffffff.\n"
      title: 11.19.1.  Target Transfer Tag
    - contents:
      - "11.19.2.  StatSN\n   The StatSN field will always contain the next StatSN.
        \ However, when\n   the Initiator Task Tag is set to 0xffffffff, the StatSN
        for the\n   connection is not advanced after this PDU is sent.\n"
      title: 11.19.2.  StatSN
    - contents:
      - "11.19.3.  LUN\n   A LUN MUST be set to a correct value when the Target Transfer
        Tag is\n   valid (not the reserved value 0xffffffff).\n"
      title: 11.19.3.  LUN
    title: 11.19.  NOP-In
  title: 11.  iSCSI PDU Formats
- contents:
  - "12.  iSCSI Security Text Keys and Authentication Methods\n   Only the following
    keys are used during the SecurityNegotiation stage\n   of the Login Phase:\n      SessionType\n
    \     InitiatorName\n      TargetName\n      TargetAddress\n      InitiatorAlias\n
    \     TargetAlias\n      TargetPortalGroupTag\n      AuthMethod and the keys used
    by the authentication methods\n         specified in Section 12.1, along with
    all of their associated\n         keys, as well as Vendor-Specific Authentication
    Methods.\n   Other keys MUST NOT be used.\n   SessionType, InitiatorName, TargetName,
    InitiatorAlias, TargetAlias,\n   and TargetPortalGroupTag are described in Section
    13 as they can be\n   used in the OperationalNegotiation stage as well.\n   All
    security keys have connection-wide applicability.\n"
  - contents:
    - "12.1.  AuthMethod\n   Use: During Login - Security Negotiation\n   Senders:
      Initiator and target\n   Scope: connection\n   AuthMethod = <list-of-values>\n
      \  The main item of security negotiation is the authentication method\n   (AuthMethod).\n
      \  The authentication methods that can be used (appear in the list-of-\n   values)
      are either vendor-unique methods or those listed in the\n   following table:\n
      \   +--------------------------------------------------------------+\n    |
      Name         | Description                                   |\n    +--------------------------------------------------------------+\n
      \   | KRB5         | Kerberos V5 - defined in [RFC4120]            |\n    +--------------------------------------------------------------+\n
      \   | SRP          | Secure Remote Password -                      |\n    |
      \             | defined in [RFC2945]                          |\n    +--------------------------------------------------------------+\n
      \   | CHAP         | Challenge Handshake Authentication Protocol - |\n    |
      \             | defined in [RFC1994]                          |\n    +--------------------------------------------------------------+\n
      \   | None         | No authentication                             |\n    +--------------------------------------------------------------+\n
      \  The AuthMethod selection is followed by an \"authentication exchange\"\n
      \  specific to the authentication method selected.\n   The authentication method
      proposal may be made by either the\n   initiator or the target.  However, the
      initiator MUST make the first\n   step specific to the selected authentication
      method as soon as it is\n   selected.  It follows that if the target makes the
      authentication\n   method proposal, the initiator sends the first key(s) of
      the exchange\n   together with its authentication method selection.\n   The
      authentication exchange authenticates the initiator to the target\n   and, optionally,
      the target to the initiator.  Authentication is\n   OPTIONAL to use but MUST
      be supported by the target and initiator.\n   The initiator and target MUST
      implement CHAP.  All other\n   authentication methods are OPTIONAL.\n   Private
      or public extension algorithms MAY also be negotiated for\n   authentication
      methods.  Whenever a private or public extension\n   algorithm is part of the
      default offer (the offer made in the absence\n   of explicit administrative
      action), the implementer MUST ensure that\n   CHAP is listed as an alternative
      in the default offer and \"None\" is\n   not part of the default offer.\n   Extension
      authentication methods MUST be named using one of the\n   following two formats:\n
      \     1) Z-reversed.vendor.dns_name.do_something=\n      2) New public key with
      no name prefix constraints\n   Authentication methods named using the Z- format
      are used as private\n   extensions.  New public keys must be registered with
      IANA using the\n   IETF Review process ([RFC5226]).  New public extensions for\n
      \  authentication methods MUST NOT use the Z# name prefix.\n   For all of the
      public or private extension authentication methods,\n   the method-specific
      keys MUST conform to the format specified in\n   Section 6.1 for standard-label.\n
      \  To identify the vendor for private extension authentication methods,\n   we
      suggest using the reversed DNS-name as a prefix to the proper\n   digest names.\n
      \  The part of digest-name following Z- MUST conform to the format for\n   standard-label
      specified in Section 6.1.\n   Support for public or private extension authentication
      methods is\n   OPTIONAL.\n   The following subsections define the specific exchanges
      for each of\n   the standardized authentication methods.  As mentioned earlier,
      the\n   first step is always done by the initiator.\n"
    - contents:
      - "12.1.1.  Kerberos\n   For KRB5 (Kerberos V5) [RFC4120] [RFC1964], the initiator
        MUST use:\n      KRB_AP_REQ=<KRB_AP_REQ>\n   where KRB_AP_REQ is the client
        message as defined in [RFC4120].\n   The default principal name assumed by
        an iSCSI initiator or target\n   (prior to any administrative configuration
        action) MUST be the iSCSI\n   Initiator Name or iSCSI Target Name, respectively,
        prefixed by the\n   string \"iscsi/\".\n   If the initiator authentication
        fails, the target MUST respond with a\n   Login reject with \"Authentication
        Failure\" status.  Otherwise, if the\n   initiator has selected the mutual
        authentication option (by setting\n   MUTUAL-REQUIRED in the ap-options field
        of the KRB_AP_REQ), the\n   target MUST reply with:\n      KRB_AP_REP=<KRB_AP_REP>\n
        \  where KRB_AP_REP is the server's response message as defined in\n   [RFC4120].\n
        \  If mutual authentication was selected and target authentication\n   fails,
        the initiator MUST close the connection.\n   KRB_AP_REQ and KRB_AP_REP are
        binary-values, and their binary length\n   (not the length of the character
        string that represents them in\n   encoded form) MUST NOT exceed 65536 bytes.
        \ Hex or Base64 encoding\n   may be used for KRB_AP_REQ and KRB_AP_REP; see
        Section 6.1.\n"
      title: 12.1.1.  Kerberos
    - contents:
      - "12.1.2.  Secure Remote Password (SRP)\n   For SRP [RFC2945], the initiator
        MUST use:\n      SRP_U=<U> TargetAuth=Yes     /* or TargetAuth=No */\n   The
        target MUST answer with a Login reject with the \"Authorization\n   Failure\"
        status or reply with:\n      SRP_GROUP=<G1,G2...> SRP_s=<s>\n   where G1,G2...
        are proposed groups, in order of preference.\n   The initiator MUST either
        close the connection or continue with:\n      SRP_A=<A> SRP_GROUP=<G>\n   where
        G is one of G1,G2... that were proposed by the target.\n   The target MUST
        answer with a Login reject with the \"Authentication\n   Failure\" status
        or reply with:\n      SRP_B=<B>\n   The initiator MUST close the connection
        or continue with:\n      SRP_M=<M>\n   If the initiator authentication fails,
        the target MUST answer with a\n   Login reject with \"Authentication Failure\"
        status.  Otherwise, if the\n   initiator sent TargetAuth=Yes in the first
        message (requiring target\n   authentication), the target MUST reply with:\n
        \     SRP_HM=<H(A | M | K)>\n   If the target authentication fails, the initiator
        MUST close the\n   connection:\n   where U, s, A, B, M, and H(A | M | K) are
        defined in [RFC2945] (using\n   the SHA1 hash function, such as SRP-SHA1)\n
        \  and\n   G,Gn (\"Gn\" stands for G1,G2...) are identifiers of SRP groups\n
        \  specified in [RFC3723].\n   G, Gn, and U are text strings; s,A,B,M, and
        H(A | M | K) are\n   binary-values.  The length of s,A,B,M and H(A | M | K)
        in binary form\n   (not the length of the character string that represents
        them in\n   encoded form) MUST NOT exceed 1024 bytes.  Hex or Base64 encoding
        may\n   be used for s,A,B,M and H(A | M | K); see Section 6.1.\n   See Appendix
        B for the related login example.\n   For the SRP_GROUP, all the groups specified
        in [RFC3723] up to\n   1536 bits (i.e., SRP-768, SRP-1024, SRP-1280, SRP-1536)
        must be\n   supported by initiators and targets.  To guarantee interoperability,\n
        \  targets MUST always offer \"SRP-1536\" as one of the proposed groups.\n"
      title: 12.1.2.  Secure Remote Password (SRP)
    - contents:
      - "12.1.3.  Challenge Handshake Authentication Protocol (CHAP)\n   For CHAP
        [RFC1994], the initiator MUST use:\n      CHAP_A=<A1,A2...>\n   where A1,A2...
        are proposed algorithms, in order of preference.\n   The target MUST answer
        with a Login reject with the \"Authentication\n   Failure\" status or reply
        with:\n      CHAP_A=<A> CHAP_I=<I> CHAP_C=<C>\n   where A is one of A1,A2...
        that were proposed by the initiator.\n   The initiator MUST continue with:\n
        \     CHAP_N=<N> CHAP_R=<R>\n   or, if it requires target authentication,
        with:\n      CHAP_N=<N> CHAP_R=<R> CHAP_I=<I> CHAP_C=<C>\n   If the initiator
        authentication fails, the target MUST answer with a\n   Login reject with
        \"Authentication Failure\" status.  Otherwise, if the\n   initiator required
        target authentication, the target MUST either\n   answer with a Login reject
        with \"Authentication Failure\" or reply\n   with:\n      CHAP_N=<N> CHAP_R=<R>\n
        \  If the target authentication fails, the initiator MUST close the\n   connection:\n
        \  where N, (A,A1,A2), I, C, and R are (correspondingly) the Name,\n   Algorithm,
        Identifier, Challenge, and Response as defined in\n   [RFC1994].\n   N is
        a text string; A,A1,A2, and I are numbers; C and R are\n   binary-values.
        \ Their binary length (not the length of the character\n   string that represents
        them in encoded form) MUST NOT exceed\n   1024 bytes.  Hex or Base64 encoding
        may be used for C and R; see\n   Section 6.1.\n   See Appendix B for the related
        login example.\n   For the Algorithm, as stated in [RFC1994], one value is
        required to\n   be implemented:\n      5     (CHAP with MD5)\n   To guarantee
        interoperability, initiators MUST always offer it as one\n   of the proposed
        algorithms.\n"
      title: 12.1.3.  Challenge Handshake Authentication Protocol (CHAP)
    title: 12.1.  AuthMethod
  title: 12.  iSCSI Security Text Keys and Authentication Methods
- contents:
  - "13.  Login/Text Operational Text Keys\n   Some session-specific parameters MUST
    only be carried on the leading\n   connection and cannot be changed after the
    leading connection login\n   (e.g., MaxConnections -- the maximum number of connections).
    \ This\n   holds for a single connection session with regard to connection\n   restart.
    \ The keys that fall into this category have the \"use: LO\"\n   (Leading Only).\n
    \  Keys that can only be used during login have the \"use: IO\"\n   (Initialize
    Only), while those that can be used in both the Login\n   Phase and Full Feature
    Phase have the \"use: ALL\".\n   Keys that can only be used during the Full Feature
    Phase use FFPO\n   (Full Feature Phase Only).\n   Keys marked as Any-Stage may
    also appear in the SecurityNegotiation\n   stage, while all other keys described
    in this section are\n   operational keys.\n   Keys that do not require an answer
    are marked as Declarative.\n   Key scope is indicated as session-wide (SW) or
    connection-only (CO).\n   \"Result function\", wherever mentioned, states the
    function that can\n   be applied to check the validity of the responder selection.\n
    \  \"Minimum\" means that the selected value cannot exceed the offered\n   value.
    \ \"Maximum\" means that the selected value cannot be lower than\n   the offered
    value.  \"AND\" means that the selected value must be a\n   possible result of
    a Boolean \"and\" function with an arbitrary Boolean\n   value (e.g., if the offered
    value is No the selected value must be\n   No).  \"OR\" means that the selected
    value must be a possible result of\n   a Boolean \"or\" function with an arbitrary
    Boolean value (e.g., if the\n   offered value is Yes the selected value must be
    Yes).\n"
  - contents:
    - "13.1.  HeaderDigest and DataDigest\n   Use: IO\n   Senders: Initiator and target\n
      \  Scope: CO\n   HeaderDigest = <list-of-values>\n   DataDigest = <list-of-values>\n
      \  Default is None for both HeaderDigest and DataDigest.\n   Digests enable
      the checking of end-to-end, non-cryptographic data\n   integrity beyond the
      integrity checks provided by the link layers and\n   the covering of the whole
      communication path, including all elements\n   that may change the network-level
      PDUs, such as routers, switches,\n   and proxies.\n   The following table lists
      cyclic integrity checksums that can be\n   negotiated for the digests and MUST
      be implemented by every iSCSI\n   initiator and target.  These digest options
      only have error detection\n   significance.\n     +---------------------------------------------+\n
      \    | Name          | Description     | Generator |\n     +---------------------------------------------+\n
      \    | CRC32C        | 32-bit CRC      |0x11edc6f41|\n     +---------------------------------------------+\n
      \    | None          | no digest                   |\n     +---------------------------------------------+\n
      \  The generator polynomial G(x) for this digest is given in hexadecimal\n   notation
      (e.g., \"0x3b\" stands for 0011 1011, and the polynomial is\n   x**5 + x**4
      + x**3 + x + 1).\n   When the initiator and target agree on a digest, this digest
      MUST be\n   used for every PDU in the Full Feature Phase.\n   Padding bytes,
      when present in a segment covered by a CRC, SHOULD be\n   set to 0 and are included
      in the CRC.\n   The CRC MUST be calculated by a method that produces the same
      results\n   as the following process:\n   - The PDU bits are considered as the
      coefficients of a polynomial\n     M(x) of degree n - 1; bit 7 of the lowest
      numbered byte is\n     considered the most significant bit (x**n - 1), followed
      by bit 6\n     of the lowest numbered byte through bit 0 of the highest numbered\n
      \    byte (x**0).\n   - The most significant 32 bits are complemented.\n   -
      The polynomial is multiplied by x**32, then divided by G(x).  The\n     generator
      polynomial produces a remainder R(x) of degree <= 31.\n   - The coefficients
      of R(x) are formed into a 32-bit sequence.\n   - The bit sequence is complemented,
      and the result is the CRC.\n   - The CRC bits are mapped into the digest word.
      \ The x**31\n     coefficient is mapped to bit 7 of the lowest numbered byte
      of the\n     digest, and the mapping continues with successive coefficients
      and\n     bits so that the x**24 coefficient is mapped to bit 0 of the lowest\n
      \    numbered byte.  The mapping continues further with the x**23\n     coefficient
      mapped to bit 7 of the next byte in the digest until\n     the x**0 coefficient
      is mapped to bit 0 of the highest numbered\n     byte of the digest.\n   - Computing
      the CRC over any segment (data or header) extended to\n     include the CRC
      built using the generator 0x11edc6f41 will always\n     get the value 0x1c2d19ed
      as its final remainder (R(x)).  This value\n     is given here in its polynomial
      form (i.e., not mapped as the\n     digest word).\n   For a discussion about
      selection criteria for the CRC, see [RFC3385].\n   For a detailed analysis of
      the iSCSI polynomial, see [Castagnoli93].\n   Private or public extension algorithms
      MAY also be negotiated for\n   digests.  Whenever a private or public digest
      extension algorithm is\n   part of the default offer (the offer made in the
      absence of explicit\n   administrative action), the implementer MUST ensure
      that CRC32C is\n   listed as an alternative in the default offer and \"None\"
      is not part\n   of the default offer.\n   Extension digest algorithms MUST be
      named using one of the following\n   two formats:\n      1) Y-reversed.vendor.dns_name.do_something=\n
      \     2) New public key with no name prefix constraints\n   Digests named using
      the Y- format are used for private purposes\n   (unregistered).  New public
      keys must be registered with IANA using\n   the IETF Review process ([RFC5226]).
      \ New public extensions for\n   digests MUST NOT use the Y# name prefix.\n   For
      private extension digests, to identify the vendor we suggest\n   using the reversed
      DNS-name as a prefix to the proper digest names.\n   The part of digest-name
      following Y- MUST conform to the format for\n   standard-label specified in
      Section 6.1.\n   Support for public or private extension digests is OPTIONAL.\n"
    title: 13.1.  HeaderDigest and DataDigest
  - contents:
    - "13.2.  MaxConnections\n   Use: LO\n   Senders: Initiator and target\n   Scope:
      SW\n   Irrelevant when: SessionType=Discovery\n   MaxConnections=<numerical-value-from-1-to-65535>\n
      \  Default is 1.\n   Result function is Minimum.\n   The initiator and target
      negotiate the maximum number of connections\n   requested/acceptable.\n"
    title: 13.2.  MaxConnections
  - contents:
    - "13.3.  SendTargets\n   Use: FFPO\n   Senders: Initiator\n   Scope: SW\n   For
      a complete description, see Appendix C.\n"
    title: 13.3.  SendTargets
  - contents:
    - "13.4.  TargetName\n   Use: IO by initiator, FFPO by target -- only as response
      to a\n      SendTargets, Declarative, Any-Stage\n   Senders: Initiator and target\n
      \  Scope: SW\n   TargetName=<iSCSI-name-value>\n   Examples:\n      TargetName=iqn.1993-11.com.disk-vendor:diskarrays.sn.45678\n
      \     TargetName=eui.020000023B040506\n      TargetName=naa.62004567BA64678D0123456789ABCDEF\n
      \  The initiator of the TCP connection MUST provide this key to the\n   remote
      endpoint in the first Login Request if the initiator is not\n   establishing
      a Discovery session.  The iSCSI Target Name specifies\n   the worldwide unique
      name of the target.\n   The TargetName key may also be returned by the SendTargets
      Text\n   Request (which is its only use when issued by a target).\n   The TargetName
      MUST NOT be redeclared within the Login Phase.\n"
    title: 13.4.  TargetName
  - contents:
    - "13.5.  InitiatorName\n   Use: IO, Declarative, Any-Stage\n   Senders: Initiator\n
      \  Scope: SW\n   InitiatorName=<iSCSI-name-value>\n   Examples:\n      InitiatorName=iqn.1992-04.com.os-vendor.plan9:cdrom.12345\n
      \     InitiatorName=iqn.2001-02.com.ssp.users:customer235.host90\n      InitiatorName=naa.52004567BA64678D\n
      \  The initiator of the TCP connection MUST provide this key to the\n   remote
      endpoint at the first login of the Login Phase for every\n   connection.  The
      InitiatorName key enables the initiator to identify\n   itself to the remote
      endpoint.\n   The InitiatorName MUST NOT be redeclared within the Login Phase.\n"
    title: 13.5.  InitiatorName
  - contents:
    - "13.6.  TargetAlias\n   Use: ALL, Declarative, Any-Stage\n   Senders: Target\n
      \  Scope: SW\n   TargetAlias=<iSCSI-local-name-value>\n   Examples:\n      TargetAlias=Bob-s
      Disk\n      TargetAlias=Database Server 1 Log Disk\n      TargetAlias=Web Server
      3 Disk 20\n   If a target has been configured with a human-readable name or\n
      \  description, this name SHOULD be communicated to the initiator during\n   a
      Login Response PDU if SessionType=Normal (see Section 13.21).  This\n   string
      is not used as an identifier, nor is it meant to be used for\n   authentication
      or authorization decisions.  It can be displayed by\n   the initiator's user
      interface in a list of targets to which it is\n   connected.\n"
    title: 13.6.  TargetAlias
  - contents:
    - "13.7.  InitiatorAlias\n   Use: ALL, Declarative, Any-Stage\n   Senders: Initiator\n
      \  Scope: SW\n   InitiatorAlias=<iSCSI-local-name-value>\n   Examples:\n      InitiatorAlias=Web
      Server 4\n      InitiatorAlias=spyalley.nsa.gov\n      InitiatorAlias=Exchange
      Server\n   If an initiator has been configured with a human-readable name or\n
      \  description, it SHOULD be communicated to the target during a Login\n   Request
      PDU.  If not, the host name can be used instead.  This string\n   is not used
      as an identifier, nor is it meant to be used for\n   authentication or authorization
      decisions.  It can be displayed by\n   the target's user interface in a list
      of initiators to which it is\n   connected.\n"
    title: 13.7.  InitiatorAlias
  - contents:
    - "13.8.  TargetAddress\n   Use: ALL, Declarative, Any-Stage\n   Senders: Target\n
      \  Scope: SW\n   TargetAddress=domainname[:port][,portal-group-tag]\n   The
      domainname can be specified as either a DNS host name, a dotted-\n   decimal
      IPv4 address, or a bracketed IPv6 address as specified in\n   [RFC3986].\n   If
      the TCP port is not specified, it is assumed to be the IANA-\n   assigned default
      port for iSCSI (see Section 14).\n   If the TargetAddress is returned as the
      result of a redirect status\n   in a Login Response, the comma and portal-group-tag
      MUST be omitted.\n   If the TargetAddress is returned within a SendTargets response,
      the\n   portal-group-tag MUST be included.\n   Examples:\n      TargetAddress=10.0.0.1:5003,1\n
      \     TargetAddress=[1080:0:0:0:8:800:200C:417A],65\n      TargetAddress=[1080::8:800:200C:417A]:5003,1\n
      \     TargetAddress=computingcenter.example.com,23\n   The use of the portal-group-tag
      is described in Appendix C.  The\n   formats for the port and portal-group-tag
      are the same as the one\n   specified in TargetPortalGroupTag.\n"
    title: 13.8.  TargetAddress
  - contents:
    - "13.9.  TargetPortalGroupTag\n   Use: IO by target, Declarative, Any-Stage\n
      \  Senders: Target\n   Scope: SW\n   TargetPortalGroupTag=<16-bit-binary-value>\n
      \  Example:\n      TargetPortalGroupTag=1\n   The TargetPortalGroupTag key is
      a 16-bit binary-value that uniquely\n   identifies a portal group within an
      iSCSI target node.  This key\n   carries the value of the tag of the portal
      group that is servicing\n   the Login Request.  The iSCSI target returns this
      key to the\n   initiator in the Login Response PDU to the first Login Request
      PDU\n   that has the C bit set to 0 when TargetName is given by the\n   initiator.\n
      \  [SAM2] notes in its informative text that the TPGT value should be\n   non-zero;
      note that this is incorrect.  A zero value is allowed as a\n   legal value for
      the TPGT.  This discrepancy currently stands\n   corrected in [SAM4].\n   For
      the complete usage expectations of this key, see Section 6.3.\n"
    title: 13.9.  TargetPortalGroupTag
  - contents:
    - "13.10.  InitialR2T\n   Use: LO\n   Senders: Initiator and target\n   Scope:
      SW\n   Irrelevant when: SessionType=Discovery\n   InitialR2T=<boolean-value>\n
      \  Examples:\n      I->InitialR2T=No\n      T->InitialR2T=No\n   Default is
      Yes.\n   Result function is OR.\n   The InitialR2T key is used to turn off the
      default use of R2T for\n   unidirectional operations and the output part of
      bidirectional\n   commands, thus allowing an initiator to start sending data
      to a\n   target as if it has received an initial R2T with Buffer\n   Offset=Immediate
      Data Length and Desired Data Transfer\n   Length=(min(FirstBurstLength, Expected
      Data Transfer Length) -\n   Received Immediate Data Length).\n   The default
      action is that R2T is required, unless both the initiator\n   and the target
      send this key-pair attribute specifying InitialR2T=No.\n   Only the first outgoing
      data burst (immediate data and/or separate\n   PDUs) can be sent unsolicited
      (i.e., not requiring an explicit R2T).\n"
    title: 13.10.  InitialR2T
  - contents:
    - "13.11.  ImmediateData\n   Use: LO\n   Senders: Initiator and target\n   Scope:
      SW\n   Irrelevant when: SessionType=Discovery\n   ImmediateData=<boolean-value>\n
      \  Default is Yes.\n   Result function is AND.\n   The initiator and target
      negotiate support for immediate data.  To\n   turn immediate data off, the initiator
      or target must state its\n   desire to do so.  ImmediateData can be turned on
      if both the\n   initiator and target have ImmediateData=Yes.\n   If ImmediateData
      is set to Yes and InitialR2T is set to Yes\n   (default), then only immediate
      data are accepted in the first burst.\n   If ImmediateData is set to No and
      InitialR2T is set to Yes, then the\n   initiator MUST NOT send unsolicited data
      and the target MUST reject\n   unsolicited data with the corresponding response
      code.\n   If ImmediateData is set to No and InitialR2T is set to No, then the\n
      \  initiator MUST NOT send unsolicited immediate data but MAY send one\n   unsolicited
      burst of Data-OUT PDUs.\n   If ImmediateData is set to Yes and InitialR2T is
      set to No, then the\n   initiator MAY send unsolicited immediate data and/or
      one unsolicited\n   burst of Data-OUT PDUs.\n   The following table is a summary
      of unsolicited data options:\n     +----------+-------------+------------------+-------------+\n
      \    |InitialR2T|ImmediateData|    Unsolicited   |ImmediateData|\n     |          |
      \            |   Data-Out PDUs  |             |\n     +----------+-------------+------------------+-------------+\n
      \    | No       | No          | Yes              | No          |\n     +----------+-------------+------------------+-------------+\n
      \    | No       | Yes         | Yes              | Yes         |\n     +----------+-------------+------------------+-------------+\n
      \    | Yes      | No          | No               | No          |\n     +----------+-------------+------------------+-------------+\n
      \    | Yes      | Yes         | No               | Yes         |\n     +----------+-------------+------------------+-------------+\n"
    title: 13.11.  ImmediateData
  - contents:
    - "13.12.  MaxRecvDataSegmentLength\n   Use: ALL, Declarative\n   Senders: Initiator
      and target\n   Scope: CO\n   MaxRecvDataSegmentLength=<numerical-value-512-to-(2**24
      - 1)>\n   Default is 8192 bytes.\n   The initiator or target declares the maximum
      data segment length in\n   bytes it can receive in an iSCSI PDU.\n   The transmitter
      (initiator or target) is required to send PDUs with a\n   data segment that
      does not exceed MaxRecvDataSegmentLength of the\n   receiver.\n   A target receiver
      is additionally limited by MaxBurstLength for\n   solicited data and FirstBurstLength
      for unsolicited data.  An\n   initiator MUST NOT send solicited PDUs exceeding
      MaxBurstLength nor\n   unsolicited PDUs exceeding FirstBurstLength (or FirstBurstLength-\n
      \  Immediate Data Length if immediate data were sent).\n"
    title: 13.12.  MaxRecvDataSegmentLength
  - contents:
    - "13.13.  MaxBurstLength\n   Use: LO\n   Senders: Initiator and target\n   Scope:
      SW\n   Irrelevant when: SessionType=Discovery\n   MaxBurstLength=<numerical-value-512-to-(2**24
      - 1)>\n   Default is 262144 (256 KB).\n   Result function is Minimum.\n   The
      initiator and target negotiate the maximum SCSI data payload in\n   bytes in
      a Data-In or a solicited Data-Out iSCSI sequence.  A\n   sequence consists of
      one or more consecutive Data-In or Data-Out PDUs\n   that end with a Data-In
      or Data-Out PDU with the F bit set to 1.\n"
    title: 13.13.  MaxBurstLength
  - contents:
    - "13.14.  FirstBurstLength\n   Use: LO\n   Senders: Initiator and target\n   Scope:
      SW\n   Irrelevant when: SessionType=Discovery\n   Irrelevant when: ( InitialR2T=Yes
      and ImmediateData=No )\n   FirstBurstLength=<numerical-value-512-to-(2**24 -
      1)>\n   Default is 65536 (64 KB).\n   Result function is Minimum.\n   The initiator
      and target negotiate the maximum amount in bytes of\n   unsolicited data an
      iSCSI initiator may send to the target during the\n   execution of a single
      SCSI command.  This covers the immediate data\n   (if any) and the sequence
      of unsolicited Data-Out PDUs (if any) that\n   follow the command.\n   FirstBurstLength
      MUST NOT exceed MaxBurstLength.\n"
    title: 13.14.  FirstBurstLength
  - contents:
    - "13.15.  DefaultTime2Wait\n   Use: LO\n   Senders: Initiator and target\n   Scope:
      SW\n   DefaultTime2Wait=<numerical-value-0-to-3600>\n   Default is 2.\n   Result
      function is Maximum.\n   The initiator and target negotiate the minimum time,
      in seconds, to\n   wait before attempting an explicit/implicit logout or an
      active task\n   reassignment after an unexpected connection termination or a\n
      \  connection reset.\n   A value of 0 indicates that logout or active task reassignment
      can be\n   attempted immediately.\n"
    title: 13.15.  DefaultTime2Wait
  - contents:
    - "13.16.  DefaultTime2Retain\n   Use: LO\n   Senders: Initiator and target\n
      \  Scope: SW\n   DefaultTime2Retain=<numerical-value-0-to-3600>\n   Default
      is 20.\n   Result function is Minimum.\n   The initiator and target negotiate
      the maximum time, in seconds,\n   after an initial wait (Time2Wait), before
      which an active task\n   reassignment is still possible after an unexpected
      connection\n   termination or a connection reset.\n   This value is also the
      session state timeout if the connection in\n   question is the last LOGGED_IN
      connection in the session.\n   A value of 0 indicates that connection/task state
      is immediately\n   discarded by the target.\n"
    title: 13.16.  DefaultTime2Retain
  - contents:
    - "13.17.  MaxOutstandingR2T\n   Use: LO\n   Senders: Initiator and target\n   Scope:
      SW\n   MaxOutstandingR2T=<numerical-value-from-1-to-65535>\n   Irrelevant when:
      SessionType=Discovery\n   Default is 1.\n   Result function is Minimum.\n   The
      initiator and target negotiate the maximum number of outstanding\n   R2Ts per
      task, excluding any implied initial R2T that might be part\n   of that task.
      \ An R2T is considered outstanding until the last data\n   PDU (with the F bit
      set to 1) is transferred or a sequence reception\n   timeout (Section 7.1.4.1)
      is encountered for that data sequence.\n"
    title: 13.17.  MaxOutstandingR2T
  - contents:
    - "13.18.  DataPDUInOrder\n   Use: LO\n   Senders: Initiator and target\n   Scope:
      SW\n   Irrelevant when: SessionType=Discovery\n   DataPDUInOrder=<boolean-value>\n
      \  Default is Yes.\n   Result function is OR.\n   \"No\" is used by iSCSI to
      indicate that the data PDUs within sequences\n   can be in any order.  \"Yes\"
      is used to indicate that data PDUs within\n   sequences have to be at continuously
      increasing addresses and\n   overlays are forbidden.\n"
    title: 13.18.  DataPDUInOrder
  - contents:
    - "13.19.  DataSequenceInOrder\n   Use: LO\n   Senders: Initiator and target\n
      \  Scope: SW\n   Irrelevant when: SessionType=Discovery\n   DataSequenceInOrder=<boolean-value>\n
      \  Default is Yes.\n   Result function is OR.\n   A data sequence is a sequence
      of Data-In or Data-Out PDUs that end\n   with a Data-In or Data-Out PDU with
      the F bit set to 1.  A Data-Out\n   sequence is sent either unsolicited or in
      response to an R2T.\n   Sequences cover an offset-range.\n   If DataSequenceInOrder
      is set to No, data PDU sequences may be\n   transferred in any order.\n   If
      DataSequenceInOrder is set to Yes, data sequences MUST be\n   transferred using
      continuously non-decreasing sequence offsets (R2T\n   buffer offset for writes,
      or the smallest SCSI Data-In buffer offset\n   within a read data sequence).\n
      \  If DataSequenceInOrder is set to Yes, a target may retry at most the\n   last
      R2T, and an initiator may at most request retransmission for the\n   last read
      data sequence.  For this reason, if ErrorRecoveryLevel is\n   not 0 and DataSequenceInOrder
      is set to Yes, then MaxOutstandingR2T\n   MUST be set to 1.\n"
    title: 13.19.  DataSequenceInOrder
  - contents:
    - "13.20.  ErrorRecoveryLevel\n   Use: LO\n   Senders: Initiator and target\n
      \  Scope: SW\n   ErrorRecoveryLevel=<numerical-value-0-to-2>\n   Default is
      0.\n   Result function is Minimum.\n   The initiator and target negotiate the
      recovery level supported.\n   Recovery levels represent a combination of recovery
      capabilities.\n   Each recovery level includes all the capabilities of the lower\n
      \  recovery levels and adds some new ones to them.\n   In the description of
      recovery mechanisms, certain recovery classes\n   are specified.  Section 7.1.5
      describes the mapping between the\n   classes and the levels.\n"
    title: 13.20.  ErrorRecoveryLevel
  - contents:
    - "13.21.  SessionType\n   Use: LO, Declarative, Any-Stage\n   Senders: Initiator\n
      \  Scope: SW\n   SessionType=<Discovery|Normal>\n   Default is Normal.\n   The
      initiator indicates the type of session it wants to create.  The\n   target
      can either accept it or reject it.\n   A Discovery session indicates to the
      target that the only purpose of\n   this session is discovery.  The only requests
      a target accepts in\n   this type of session are a Text Request with a SendTargets
      key and a\n   Logout Request with reason \"close the session\".\n   The Discovery
      session implies MaxConnections = 1 and overrides both\n   the default and an
      explicit setting.  As Section 7.4.1 states,\n   ErrorRecoveryLevel MUST be 0
      (zero) for Discovery sessions.\n   Depending on the type of session, a target
      may decide on resources to\n   allocate, the security to enforce, etc., for
      the session.  If the\n   SessionType key is thus going to be offered as \"Discovery\",
      it SHOULD\n   be offered in the initial Login Request by the initiator.\n"
    title: 13.21.  SessionType
  - contents:
    - "13.22.  The Private Extension Key Format\n   Use: ALL\n   Senders: Initiator
      and target\n   Scope: specific key dependent\n   X-reversed.vendor.dns_name.do_something=\n
      \  Keys with this format are used for private extension purposes.  These\n   keys
      always start with X- if unregistered with IANA (private).  New\n   public keys
      (if registered with IANA via an IETF Review [RFC5226]) no\n   longer have an
      X# name prefix requirement; implementers may propose\n   any intuitive unique
      name.\n   For unregistered keys, to identify the vendor we suggest using the\n
      \  reversed DNS-name as a prefix to the key-proper.\n   The part of key-name
      following X- MUST conform to the format for\n   key-name specified in Section
      6.1.\n   Vendor-specific keys MUST ONLY be used in Normal sessions.\n   Support
      for public or private extension keys is OPTIONAL.\n"
    title: 13.22.  The Private Extension Key Format
  - contents:
    - "13.23.  TaskReporting\n   Use: LO\n   Senders: Initiator and target\n   Scope:
      SW\n   Irrelevant when: SessionType=Discovery\n   TaskReporting=<list-of-values>\n
      \  Default is RFC3720.\n   This key is used to negotiate the task completion
      reporting semantics\n   from the SCSI target.  The following table describes
      the semantics\n   that an iSCSI target MUST support for respective negotiated
      key\n   values.  Whenever this key is negotiated, at least the RFC3720 and\n
      \  ResponseFence values MUST be offered as options by the negotiation\n   originator.\n
      \    +--------------+------------------------------------------+\n     | Name
      \        |             Description                  |\n     +--------------+------------------------------------------+\n
      \    | RFC3720      | RFC 3720-compliant semantics.  Response  |\n     |              |
      fencing is not guaranteed, and fast      |\n     |              | completion
      of multi-task aborting is not |\n     |              | supported.                               |\n
      \    +--------------+------------------------------------------+\n     | ResponseFence|
      Response Fence (Section 4.2.2.3.3)       |\n     |              | semantics
      MUST be supported in reporting |\n     |              | task completions.                        |\n
      \    +--------------+------------------------------------------+\n     | FastAbort
      \   | Updated fast multi-task abort semantics  |\n     |              | defined
      in Section 4.2.3.4 MUST be       |\n     |              | supported.  Support
      for the Response     |\n     |              | Fence is implied -- i.e., semantics
      as   |\n     |              | described in Section 4.2.2.3.3 MUST be   |\n     |
      \             | supported as well.                       |\n     +--------------+------------------------------------------+\n
      \  When TaskReporting is not negotiated to FastAbort, the standard\n   multi-task
      abort semantics in Section 4.2.3.3 MUST be used.\n"
    title: 13.23.  TaskReporting
  - contents:
    - "13.24.  iSCSIProtocolLevel Negotiation\n   The iSCSIProtocolLevel associated
      with this document is \"1\".  As a\n   responder or an originator in a negotiation
      of this key, an iSCSI\n   implementation compliant to this document alone, without
      any future\n   protocol extensions, MUST use this value as defined by [RFC7144].\n"
    title: 13.24.  iSCSIProtocolLevel Negotiation
  - contents:
    - "13.25.  Obsoleted Keys\n   This document obsoletes the following keys defined
      in [RFC3720]:\n   IFMarker, OFMarker, OFMarkInt, and IFMarkInt.  However, iSCSI\n
      \  implementations compliant to this document may still receive these\n   obsoleted
      keys -- i.e., in a responder role -- in a text negotiation.\n   When an IFMarker
      or OFMarker key is received, a compliant iSCSI\n   implementation SHOULD respond
      with the constant \"Reject\" value.  The\n   implementation MAY alternatively
      respond with a \"No\" value.\n   However, the implementation MUST NOT respond
      with a \"NotUnderstood\"\n   value for either of these keys.\n   When an IFMarkInt
      or OFMarkInt key is received, a compliant iSCSI\n   implementation MUST respond
      with the constant \"Reject\" value.  The\n   implementation MUST NOT respond
      with a \"NotUnderstood\" value for\n   either of these keys.\n"
    title: 13.25.  Obsoleted Keys
  - contents:
    - '13.26.  X#NodeArchitecture

      '
    - contents:
      - "13.26.1.  Definition\n   Use: LO, Declarative\n   Senders: Initiator and
        target\n   Scope: SW\n   X#NodeArchitecture=<list-of-values>\n   Default is
        None.\n   Examples:\n      X#NodeArchitecture=ExampleOS/v1234,ExampleInc_SW_Initiator/1.05a\n
        \     X#NodeArchitecture=ExampleInc_HW_Initiator/4010,Firmware/2.0.0.5\n      X#NodeArchitecture=ExampleInc_SW_Initiator/2.1,CPU_Arch/i686\n
        \  This document does not define the structure or content of the list of\n
        \  values.\n   The initiator or target declares the details of its iSCSI node\n
        \  architecture to the remote endpoint.  These details may include, but\n
        \  are not limited to, iSCSI vendor software, firmware, or hardware\n   versions;
        the OS version; or hardware architecture.  This key may be\n   declared on
        a Discovery session or a Normal session.\n   The length of the key value (total
        length of the list-of-values) MUST\n   NOT be greater than 255 bytes.\n   X#NodeArchitecture
        MUST NOT be redeclared during the Login Phase.\n"
      title: 13.26.1.  Definition
    - contents:
      - "13.26.2.  Implementation Requirements\n   Functional behavior of the iSCSI
        node (this includes the iSCSI\n   protocol logic -- the SCSI, iSCSI, and TCP/IP
        protocols) MUST NOT\n   depend on the presence, absence, or content of the
        X#NodeArchitecture\n   key.  The key MUST NOT be used by iSCSI nodes for interoperability
        or\n   for exclusion of other nodes.  To ensure proper use, key values\n   SHOULD
        be set by the node itself, and there SHOULD NOT be provisions\n   for the
        key values to contain user-defined text.\n   Nodes implementing this key MUST
        choose one of the following\n   implementation options:\n      - only transmit
        the key,\n      - only log the key values received from other nodes, or\n
        \     - both transmit and log the key values.\n   Each node choosing to implement
        transmission of the key values MUST\n   be prepared to handle the response
        of iSCSI nodes that do not\n   understand the key.\n   Nodes that implement
        transmission and/or logging of the key values\n   may also implement administrative
        mechanisms that disable and/or\n   change the logging and key transmission
        details (see Section 9.4).\n   Thus, a valid behavior for this key may be
        that a node is completely\n   silent (the node does not transmit any key value
        and simply discards\n   any key values it receives without issuing a NotUnderstood
        response).\n"
      title: 13.26.2.  Implementation Requirements
    title: 13.26.  X#NodeArchitecture
  title: 13.  Login/Text Operational Text Keys
- contents:
  - "14.  Rationale for Revised IANA Considerations\n   This document makes rather
    significant changes in this area, and this\n   section outlines the reasons behind
    the changes.  As previously\n   specified in [RFC3720], iSCSI had used text string
    prefixes, such as\n   X- and X#, to distinguish extended login/text keys, digest\n
    \  algorithms, and authentication methods from their standardized\n   counterparts.
    \ Based on experience with other protocols, [RFC6648],\n   however, strongly recommends
    against this practice, in large part\n   because extensions that use such prefixes
    may become standard over\n   time, at which point it can be infeasible to change
    their text string\n   names due to widespread usage under the existing text string
    name.\n   iSCSI's experience with public extensions supports the\n   recommendations
    in [RFC6648], as the only extension item ever\n   registered with IANA, the X#NodeArchitecture
    key, was specified as a\n   standard key in a Standards Track RFC [RFC4850] and
    hence did not\n   require the X# prefix.  In addition, that key is the only public\n
    \  iSCSI extension that has been registered with IANA since RFC 3720 was\n   originally
    published, so there has been effectively no use of the X#,\n   Y#, and Z# public
    extension formats.\n   Therefore, this document makes the following changes to
    the IANA\n   registration procedures for iSCSI:\n      1) The separate registries
    for X#, Y#, and Z# public extensions\n         are removed.  The single entry
    in the registry for X#\n         login/text keys (X#NodeArchitecture) is transferred
    to the main\n         \"iSCSI Login/Text Keys\" registry.  IANA has never created
    the\n         latter two registries because there have been no registration\n
    \        requests for them.  These public extension formats (X#, Y#, Z#)\n         MUST
    NOT be used, with the exception of the existing\n         X#NodeArchitecture key.\n
    \     2) The registration procedures for the main \"iSCSI Login/Text\n         Keys\",
    \"iSCSI digests\", and \"iSCSI authentication methods\" IANA\n         registries
    are changed to IETF Review [RFC5226] for possible\n         future extensions
    to iSCSI.  This change includes a deliberate\n         decision to remove the
    possibility of specifying an IANA-\n         registered iSCSI extension in an
    RFC published via an RFC\n         Editor Independent Submission, as the level
    of review in that\n         process is insufficient for iSCSI extensions.\n      3)
    The restriction against registering items using the private\n         extension
    formats (X-, Y-, Z-) in the main IANA registries is\n         removed.  Extensions
    using these formats MAY be registered\n         under the IETF Review registration
    procedures, but each format\n         is restricted to the type of extension for
    which it is\n         specified in this RFC and MUST NOT be used for other types.\n
    \        For example, the X- extension format for extension login/text\n         keys
    MUST NOT be used for digest algorithms or authentication\n         methods.\n"
  title: 14.  Rationale for Revised IANA Considerations
- contents:
  - "15.  IANA Considerations\n   The well-known TCP port number for iSCSI connections
    assigned by IANA\n   is 3260, and this is the default iSCSI port.  Implementations
    needing\n   a system TCP port number may use port 860, the port assigned by IANA\n
    \  as the iSCSI system port; however, in order to use port 860, it MUST\n   be
    explicitly specified -- implementations MUST NOT default to the\n   use of port
    860, as 3260 is the only allowed default.\n   IANA has replaced the references
    for ports 860 and 3260, both TCP and\n   UDP, with references to this document.
    \ Please see\n   http://www.iana.org/assignments/service-names-port-numbers.\n
    \  IANA has updated all references to RFC 3720, RFC 4850, and RFC 5048\n   to
    instead reference this RFC in all of the iSCSI registries that are\n   part of
    the \"Internet Small Computer System Interface (iSCSI)\n   Parameters\" set of
    registries.  This change reflects the fact that\n   those three RFCs are obsoleted
    by this RFC.  References to other RFCs\n   that are not being obsoleted (e.g.,
    RFC 3723, RFC 5046) should not be\n   changed.\n   IANA has performed the following
    actions on the \"iSCSI Login/Text\n   Keys\" registry:\n      - Changed the registration
    procedure to IETF Review from Standard\n        Required.\n      - Changed the
    RFC 5048 reference for the registry to reference\n        this RFC.\n      - Added
    the X#NodeArchitecture key from the \"iSCSI extended key\"\n        registry,
    and changed its reference to this RFC.\n      - Changed all references to RFC
    3720 and RFC 5048 to instead\n        reference this RFC.\n   IANA has changed
    the registration procedures for the \"iSCSI\n   authentication methods\" and \"iSCSI
    digests\" registries to IETF Review\n   from RFC Required.\n   IANA has removed
    the \"iSCSI extended key\" registry, as its one entry\n   has been added to the
    \"iSCSI Login/Text Keys\" registry.\n   IANA has marked as obsolete the values
    4 and 5 for SPKM1 and SPKM2,\n   respectively, in the \"iSCSI authentication methods\"
    subregistry of\n   the \"Internet Small Computer System Interface (iSCSI) Parameters\"
    set\n   of registries.\n   IANA has added this document to the \"iSCSI Protocol
    Level\" registry\n   with value 1, as mentioned in Section 13.24.\n   All the
    other IANA considerations stated in [RFC3720] and [RFC5048]\n   remain unchanged.
    \ The assignments contained in the following\n   subregistries are not repeated
    in this document:\n      - iSCSI authentication methods (from Section 13 of [RFC3720])\n
    \     - iSCSI digests (from Section 13 of [RFC3720])\n   This document obsoletes
    the SPKM1 and SPKM2 key values for the\n   AuthMethod text key.  Consequently,
    the SPKM_ text key prefix MUST be\n   treated as obsolete and not be reused.\n"
  title: 15.  IANA Considerations
- contents:
  - '16.  References

    '
  - contents:
    - "16.1.  Normative References\n   [EUI]      \"Guidelines for 64-bit Global Identifier
      (EUI-64(TM))\",\n              <http://standards.ieee.org/regauth/oui/tutorials/\n
      \             EUI64.html>.\n   [FC-FS3]   INCITS Technical Committee T11, \"Fibre
      Channel - Framing\n              and Signaling - 3 (FC-FS-3)\", ANSI INCITS
      470-2011, 2011.\n   [OUI]      \"IEEE OUI and \"company_id\" Assignments\",\n
      \             <http://standards.ieee.org/regauth/oui>.\n   [RFC1122]  Braden,
      R., Ed., \"Requirements for Internet Hosts -\n              Communication Layers\",
      STD 3, RFC 1122, October 1989.\n   [RFC1964]  Linn, J., \"The Kerberos Version
      5 GSS-API Mechanism\",\n              RFC 1964, June 1996.\n   [RFC1982]  Elz,
      R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982,\n              August
      1996.\n   [RFC1994]  Simpson, W., \"PPP Challenge Handshake Authentication\n
      \             Protocol (CHAP)\", RFC 1994, August 1996.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC2404]  Madson, C. and R. Glenn, \"The
      Use of HMAC-SHA-1-96 within\n              ESP and AH\", RFC 2404, November
      1998.\n   [RFC2406]  Kent, S. and R. Atkinson, \"IP Encapsulating Security\n
      \             Payload (ESP)\", RFC 2406, November 1998.\n   [RFC2451]  Pereira,
      R. and R. Adams, \"The ESP CBC-Mode Cipher\n              Algorithms\", RFC
      2451, November 1998.\n   [RFC2945]  Wu, T., \"The SRP Authentication and Key
      Exchange System\",\n              RFC 2945, September 2000.\n   [RFC3454]  Hoffman,
      P. and M. Blanchet, \"Preparation of\n              Internationalized Strings
      (\"stringprep\")\", RFC 3454,\n              December 2002.\n   [RFC3566]  Frankel,
      S. and H. Herbert, \"The AES-XCBC-MAC-96 Algorithm\n              and Its Use
      With IPsec\", RFC 3566, September 2003.\n   [RFC3629]  Yergeau, F., \"UTF-8,
      a transformation format of\n              ISO 10646\", STD 63, RFC 3629, November
      2003.\n   [RFC3686]  Housley, R., \"Using Advanced Encryption Standard (AES)\n
      \             Counter Mode With IPsec Encapsulating Security Payload\n              (ESP)\",
      RFC 3686, January 2004.\n   [RFC3722]  Bakke, M., \"String Profile for Internet
      Small Computer\n              Systems Interface (iSCSI) Names\", RFC 3722, April
      2004.\n   [RFC3723]  Aboba, B., Tseng, J., Walker, J., Rangan, V., and F.\n
      \             Travostino, \"Securing Block Storage Protocols over IP\",\n              RFC
      3723, April 2004.\n   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter,
      \"Uniform\n              Resource Identifier (URI): Generic Syntax\", STD 66,\n
      \             RFC 3986, January 2005.\n   [RFC4106]  Viega, J. and D. McGrew,
      \"The Use of Galois/Counter Mode\n              (GCM) in IPsec Encapsulating
      Security Payload (ESP)\",\n              RFC 4106, June 2005.\n   [RFC4120]
      \ Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The\n              Kerberos
      Network Authentication Service (V5)\", RFC 4120,\n              July 2005.\n
      \  [RFC4171]  Tseng, J., Gibbons, K., Travostino, F., Du Laney, C., and\n              J.
      Souza, \"Internet Storage Name Service (iSNS)\",\n              RFC 4171, September
      2005.\n   [RFC4291]  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n
      \             Architecture\", RFC 4291, February 2006.\n   [RFC4301]  Kent,
      S. and K. Seo, \"Security Architecture for the\n              Internet Protocol\",
      RFC 4301, December 2005.\n   [RFC4303]  Kent, S., \"IP Encapsulating Security
      Payload (ESP)\",\n              RFC 4303, December 2005.\n   [RFC4304]  Kent,
      S., \"Extended Sequence Number (ESN) Addendum to\n              IPsec Domain
      of Interpretation (DOI) for Internet Security\n              Association and
      Key Management Protocol (ISAKMP)\",\n              RFC 4304, December 2005.\n
      \  [RFC4543]  McGrew, D. and J. Viega, \"The Use of Galois Message\n              Authentication
      Code (GMAC) in IPsec ESP and AH\", RFC 4543,\n              May 2006.\n   [RFC4648]
      \ Josefsson, S., \"The Base16, Base32, and Base64 Data\n              Encodings\",
      RFC 4648, October 2006.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines
      for Writing an\n              IANA Considerations Section in RFCs\", BCP 26,
      RFC 5226,\n              May 2008.\n   [RFC5996]  Kaufman, C., Hoffman, P.,
      Nir, Y., and P. Eronen,\n              \"Internet Key Exchange Protocol Version
      2 (IKEv2)\",\n              RFC 5996, September 2010.\n   [RFC6960]  Santesson,
      S., Myers, M., Ankney, R., Malpani, A.,\n              Galperin, S., and C.
      Adams, \"X.509 Internet Public Key\n              Infrastructure Online Certificate
      Status Protocol - OCSP\",\n              RFC 6960, June 2013.\n   [RFC7144]
      \ Knight, F. and M. Chadalapaka, \"Internet Small Computer\n              System
      Interface (iSCSI) SCSI Features Update\", RFC 7144,\n              April 2014.\n
      \  [RFC7145]  Ko, M. and A. Nezhinsky, \"Internet Small Computer System\n              Interface
      (iSCSI) Extensions for the Remote Direct Memory\n              Access (RDMA)
      Specification\", RFC 7145, April 2014.\n   [RFC7146]  Black, D. and P. Koning,
      \"Securing Block Storage Protocols\n              over IP: RFC 3723 Requirements
      Update for IPsec v3\",\n              RFC 7146, April 2014.\n   [SAM2]     INCITS
      Technical Committee T10, \"SCSI Architecture Model -\n              2 (SAM-2)\",
      ANSI INCITS 366-2003, ISO/IEC 14776-412, 2003.\n   [SAM4]     INCITS Technical
      Committee T10, \"SCSI Architecture Model -\n              4 (SAM-4)\", ANSI
      INCITS 447-2008, ISO/IEC 14776-414, 2008.\n   [SPC2]     INCITS Technical Committee
      T10, \"SCSI Primary Commands -\n              2\", ANSI INCITS 351-2001, ISO/IEC
      14776-452, 2001.\n   [SPC3]     INCITS Technical Committee T10, \"SCSI Primary
      Commands -\n              3\", ANSI INCITS 408-2005, ISO/IEC 14776-453, 2005.\n
      \  [UML]      ISO, \"Unified Modeling Language (UML) Version 1.4.2\",\n              ISO/IEC
      19501:2005.\n   [UNICODE]  The Unicode Consortium, \"Unicode Standard Annex
      #15:\n              Unicode Normalization Forms\", 2013,\n              <http://www.unicode.org/unicode/reports/tr15>.\n"
    title: 16.1.  Normative References
  - contents:
    - "16.2.  Informative References\n   [Castagnoli93]\n              Castagnoli,
      G., Brauer, S., and M. Herrmann, \"Optimization\n              of Cyclic Redundancy-Check
      Codes with 24 and 32 Parity\n              Bits\", IEEE Transact. on Communications,
      Vol. 41, No. 6,\n              June 1993.\n   [FC-SP-2]  INCITS Technical Committee
      T11, \"Fibre Channel Security\n              Protocols 2\", ANSI INCITS 496-2012,
      2012.\n   [IB]       InfiniBand, \"InfiniBand(TM) Architecture Specification\",\n
      \             Vol. 1, Rel. 1.2.1, InfiniBand Trade Association,\n              <http://www.infinibandta.org>.\n
      \  [RFC1737]  Sollins, K. and L. Masinter, \"Functional Requirements for\n              Uniform
      Resource Names\", RFC 1737, December 1994.\n   [RFC2401]  Kent, S. and R. Atkinson,
      \"Security Architecture for the\n              Internet Protocol\", RFC 2401,
      November 1998.\n   [RFC2407]  Piper, D., \"The Internet IP Security Domain of\n
      \             Interpretation for ISAKMP\", RFC 2407, November 1998.\n   [RFC2409]
      \ Harkins, D. and D. Carrel, \"The Internet Key Exchange\n              (IKE)\",
      RFC 2409, November 1998.\n   [RFC2608]  Guttman, E., Perkins, C., Veizades,
      J., and M. Day,\n              \"Service Location Protocol, Version 2\", RFC
      2608,\n              June 1999.\n   [RFC2743]  Linn, J., \"Generic Security
      Service Application Program\n              Interface Version 2, Update  \",
      RFC 2743, January 2000.\n   [RFC2865]  Rigney, C., Willens, S., Rubens, A.,
      and W. Simpson,\n              \"Remote Authentication Dial In User Service
      (RADIUS)\",\n              RFC 2865, June 2000.\n   [RFC3385]  Sheinwald, D.,
      Satran, J., Thaler, P., and V. Cavanna,\n              \"Internet Protocol Small
      Computer System Interface (iSCSI)\n              Cyclic Redundancy Check (CRC)/Checksum
      Considerations\",\n              RFC 3385, September 2002.\n   [RFC3602]  Frankel,
      S., Glenn, R., and S. Kelly, \"The AES-CBC Cipher\n              Algorithm and
      Its Use with IPsec\", RFC 3602,\n              September 2003.\n   [RFC3720]
      \ Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M.,\n              and
      E. Zeidner, \"Internet Small Computer Systems Interface\n              (iSCSI)\",
      RFC 3720, April 2004.\n   [RFC3721]  Bakke, M., Hafner, J., Hufferd, J., Voruganti,
      K., and M.\n              Krueger, \"Internet Small Computer Systems Interface\n
      \             (iSCSI) Naming and Discovery\", RFC 3721, April 2004.\n   [RFC3783]
      \ Chadalapaka, M. and R. Elliott, \"Small Computer Systems\n              Interface
      (SCSI) Command Ordering Considerations with\n              iSCSI\", RFC 3783,
      May 2004.\n   [RFC4121]  Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos\n
      \             Version 5 Generic Security Service Application Program\n              Interface
      (GSS-API) Mechanism: Version 2\", RFC 4121,\n              July 2005.\n   [RFC4297]
      \ Romanow, A., Mogul, J., Talpey, T., and S. Bailey, \"Remote\n              Direct
      Memory Access (RDMA) over IP Problem Statement\",\n              RFC 4297, December
      2005.\n   [RFC4806]  Myers, M. and H. Tschofenig, \"Online Certificate Status\n
      \             Protocol (OCSP) Extensions to IKEv2\", RFC 4806,\n              February
      2007.\n   [RFC4850]  Wysochanski, D., \"Declarative Public Extension Key for\n
      \             Internet Small Computer Systems Interface (iSCSI) Node\n              Architecture\",
      RFC 4850, April 2007.\n   [RFC5046]  Ko, M., Chadalapaka, M., Hufferd, J., Elzur,
      U., Shah, H.,\n              and P. Thaler, \"Internet Small Computer System
      Interface\n              (iSCSI) Extensions for Remote Direct Memory Access\n
      \             (RDMA)\", RFC 5046, October 2007.\n   [RFC5048]  Chadalapaka,
      M., Ed., \"Internet Small Computer System\n              Interface (iSCSI) Corrections
      and Clarifications\",\n              RFC 5048, October 2007.\n   [RFC5433]  Clancy,
      T. and H. Tschofenig, \"Extensible Authentication\n              Protocol -
      Generalized Pre-Shared Key (EAP-GPSK) Method\",\n              RFC 5433, February
      2009.\n   [RFC6648]  Saint-Andre, P., Crocker, D., and M. Nottingham,\n              \"Deprecating
      the \"X-\" Prefix and Similar Constructs in\n              Application Protocols\",
      BCP 178, RFC 6648, June 2012.\n   [SAS]      INCITS Technical Committee T10,
      \"Serial Attached SCSI -\n              2.1 (SAS-2.1)\", ANSI INCITS 457-2010,
      2010.\n   [SBC2]     INCITS Technical Committee T10, \"SCSI Block Commands -
      2\n              (SBC-2)\", ANSI INCITS 405-2005, ISO/IEC 14776-322, 2005.\n
      \  [SPC4]     INCITS Technical Committee T10, \"SCSI Primary Commands -\n              4\",
      ANSI INCITS 513-201x.\n   [SPL]      INCITS Technical Committee T10, \"SAS Protocol
      Layer - 2\n              (SPL-2)\", ANSI INCITS 505-2013, ISO/IEC 14776-262,
      2013.\n"
    title: 16.2.  Informative References
  title: 16.  References
- contents:
  - 'Appendix A.  Examples

    '
  - contents:
    - "A.1.  Read Operation Example\n   +------------------+-----------------------+---------------------+\n
      \  |Initiator Function|       PDU Type        |   Target Function   |\n   +------------------+-----------------------+---------------------+\n
      \  | Command request  |SCSI Command (read)>>> |                     |\n   |
      (read)           |                       |                     |\n   +------------------+-----------------------+---------------------+\n
      \  |                  |                       |Prepare Data Transfer|\n   +------------------+-----------------------+---------------------+\n
      \  |   Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n   +------------------+-----------------------+---------------------+\n
      \  |   Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n   +------------------+-----------------------+---------------------+\n
      \  |   Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n   +------------------+-----------------------+---------------------+\n
      \  |                  |   <<< SCSI Response   |Send Status and Sense|\n   +------------------+-----------------------+---------------------+\n
      \  | Command Complete |                       |                     |\n   +------------------+-----------------------+---------------------+\n"
    title: A.1.  Read Operation Example
  - contents:
    - "A.2.  Write Operation Example\n   +------------------+-----------------------+---------------------+\n
      \  |Initiator Function|       PDU Type        |   Target Function   |\n   +------------------+-----------------------+---------------------+\n
      \  | Command request  |SCSI Command (write)>>>| Receive command     |\n   |
      (write)          |                       | and queue it        |\n   +------------------+-----------------------+---------------------+\n
      \  |                  |                       | Process old commands|\n   +------------------+-----------------------+---------------------+\n
      \  |                  |                       | Ready to process    |\n   |
      \                 |   <<< R2T             | write command       |\n   +------------------+-----------------------+---------------------+\n
      \  |   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n   +------------------+-----------------------+---------------------+\n
      \  |                  |   <<< R2T             | Ready for data      |\n   +------------------+-----------------------+---------------------+\n
      \  |                  |   <<< R2T             | Ready for data      |\n   +------------------+-----------------------+---------------------+\n
      \  |   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n   +------------------+-----------------------+---------------------+\n
      \  |   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n   +------------------+-----------------------+---------------------+\n
      \  |                  |   <<< SCSI Response   |Send Status and Sense|\n   +------------------+-----------------------+---------------------+\n
      \  | Command Complete |                       |                     |\n   +------------------+-----------------------+---------------------+\n"
    title: A.2.  Write Operation Example
  - contents:
    - 'A.3.  R2TSN/DataSN Use Examples

      '
    - contents:
      - "A.3.1.  Output (Write) Data DataSN/R2TSN Example\n   +-------------------+------------------------+---------------------+\n
        \  |Initiator Function |  PDU Type and Content  |   Target Function   |\n
        \  +-------------------+------------------------+---------------------+\n
        \  | Command request   |SCSI Command (write)>>> | Receive command     |\n
        \  | (write)           |                        | and queue it        |\n
        \  +-------------------+------------------------+---------------------+\n
        \  |                   |                        | Process old commands|\n
        \  +-------------------+------------------------+---------------------+\n
        \  |                   |   <<< R2T              | Ready for data      |\n
        \  |                   |   R2TSN = 0            |                     |\n
        \  +-------------------+------------------------+---------------------+\n
        \  |                   |   <<< R2T              | Ready for more data |\n
        \  |                   |   R2TSN = 1            |                     |\n
        \  +-------------------+------------------------+---------------------+\n
        \  | Send Data         |   SCSI Data-Out >>>    |   Receive Data      |\n
        \  | for R2TSN 0       |   DataSN = 0, F = 0    |                     |\n
        \  +-------------------+------------------------+---------------------+\n
        \  | Send Data         |   SCSI Data-Out >>>    |   Receive Data      |\n
        \  | for R2TSN 0       |   DataSN = 1, F = 1    |                     |\n
        \  +-------------------+------------------------+---------------------+\n
        \  | Send Data         |   SCSI Data >>>        |   Receive Data      |\n
        \  | for R2TSN 1       |   DataSN = 0, F = 1    |                     |\n
        \  +-------------------+------------------------+---------------------+\n
        \  |                   |   <<< SCSI Response    |Send Status and Sense|\n
        \  |                   |   ExpDataSN = 0        |                     |\n
        \  +-------------------+------------------------+---------------------+\n
        \  | Command Complete  |                        |                     |\n
        \  +-------------------+------------------------+---------------------+\n"
      title: A.3.1.  Output (Write) Data DataSN/R2TSN Example
    - contents:
      - "A.3.2.  Input (Read) Data DataSN Example\n   +------------------+-----------------------+----------------------+\n
        \  |Initiator Function|        PDU Type       |    Target Function   |\n   +------------------+-----------------------+----------------------+\n
        \  | Command request  |SCSI Command (read)>>> |                      |\n   |
        (read)           |                       |                      |\n   +------------------+-----------------------+----------------------+\n
        \  |                  |                       |Prepare Data Transfer |\n   +------------------+-----------------------+----------------------+\n
        \  |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   |
        \                 |   DataSN = 0, F = 0   |                      |\n   +------------------+-----------------------+----------------------+\n
        \  |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   |
        \                 |   DataSN = 1, F = 0   |                      |\n   +------------------+-----------------------+----------------------+\n
        \  |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   |
        \                 |   DataSN = 2, F = 1   |                      |\n   +------------------+-----------------------+----------------------+\n
        \  |                  |   <<< SCSI Response   |Send Status and Sense |\n   |
        \                 |   ExpDataSN = 3       |                      |\n   +------------------+-----------------------+----------------------+\n
        \  | Command Complete |                       |                      |\n   +------------------+-----------------------+----------------------+\n"
      title: A.3.2.  Input (Read) Data DataSN Example
    - contents:
      - "A.3.3.  Bidirectional DataSN Example\n   +------------------+-----------------------+---------------------+\n
        \  |Initiator Function|       PDU Type        |   Target Function   |\n   +------------------+-----------------------+---------------------+\n
        \  | Command request  |SCSI Command >>>       |                     |\n   |
        (Read-Write)     | Read-Write            |                     |\n   +------------------+-----------------------+---------------------+\n
        \  |                  |                       | Process old commands|\n   +------------------+-----------------------+---------------------+\n
        \  |                  |   <<< R2T             | Ready to process    |\n   |
        \                 |   R2TSN = 0           | write command       |\n   +------------------+-----------------------+---------------------+\n
        \  | * Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n   |
        \                 |   DataSN = 0, F = 0   |                     |\n   +------------------+-----------------------+---------------------+\n
        \  | * Receive Data   |   <<< SCSI Data-In    |   Send Data         |\n   |
        \                 |   DataSN = 1, F = 1   |                     |\n   +------------------+-----------------------+---------------------+\n
        \  | * Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n   |
        for R2TSN 0      |   DataSN = 0, F = 1   |                     |\n   +------------------+-----------------------+---------------------+\n
        \  |                  |   <<< SCSI Response   |Send Status and Sense|\n   |
        \                 |   ExpDataSN = 2       |                     |\n   +------------------+-----------------------+---------------------+\n
        \  | Command Complete |                       |                     |\n   +------------------+-----------------------+---------------------+\n
        \  * Send Data and Receive Data may be transferred simultaneously as in\n
        \    an atomic Read-Old-Write-New or sequentially as in an atomic\n     Read-Update-Write
        (in the latter case, the R2T may follow the\n     received data).\n"
      title: A.3.3.  Bidirectional DataSN Example
    - contents:
      - "A.3.4.  Unsolicited and Immediate Output (Write) Data with DataSN\n        Example\n
        \  +------------------+------------------------+----------------------+\n
        \  |Initiator Function|  PDU Type and Content  |   Target Function    |\n
        \  +------------------+------------------------+----------------------+\n
        \  | Command request  |SCSI Command (write)>>> | Receive command      |\n
        \  | (write)          |F = 0                   | and data             |\n
        \  |+ immediate data  |                        | and queue it         |\n
        \  +------------------+------------------------+----------------------+\n
        \  | Send Unsolicited |    SCSI Write Data >>> | Receive more Data    |\n
        \  | Data             |    DataSN = 0, F = 1   |                      |\n
        \  +------------------+------------------------+----------------------+\n
        \  |                  |                        | Process old commands |\n
        \  +------------------+------------------------+----------------------+\n
        \  |                  |    <<< R2T             | Ready for more data  |\n
        \  |                  |    R2TSN = 0           |                      |\n
        \  +------------------+------------------------+----------------------+\n
        \  | Send Data        |    SCSI Write Data >>> |   Receive Data       |\n
        \  | for R2TSN 0      |    DataSN = 0, F = 1   |                      |\n
        \  +------------------+------------------------+----------------------+\n
        \  |                  |    <<< SCSI Response   |Send Status and Sense |\n
        \  |                  |                        |                      |\n
        \  +------------------+------------------------+----------------------+\n
        \  | Command Complete |                        |                      |\n
        \  +------------------+------------------------+----------------------+\n"
      title: A.3.4.  Unsolicited and Immediate Output (Write) Data with DataSN
    title: A.3.  R2TSN/DataSN Use Examples
  - contents:
    - "A.4.  CRC Examples\n   Note: All values are hexadecimal.\n   32 bytes of zeroes:\n
      \     Byte:        0  1  2  3\n         0:       00 00 00 00\n       ...\n        28:
      \      00 00 00 00\n       CRC:       aa 36 91 8a\n   32 bytes of ones:\n      Byte:
      \       0  1  2  3\n         0:       ff ff ff ff\n       ...\n        28:       ff
      ff ff ff\n       CRC:       43 ab a8 62\n   32 bytes of incrementing 00..1f:\n
      \     Byte:        0  1  2  3\n         0:       00 01 02 03\n       ...\n        28:
      \      1c 1d 1e 1f\n       CRC:       4e 79 dd 46\n   32 bytes of decrementing
      1f..00:\n      Byte:        0  1  2  3\n         0:       1f 1e 1d 1c\n       ...\n
      \       28:       03 02 01 00\n       CRC:       5c db 3f 11\n   An iSCSI -
      SCSI Read (10) Command PDU:\n     Byte:        0     1    2    3\n        0:
      \      01    c0   00   00\n        4:       00    00   00   00\n        8:       00
      \   00   00   00\n       12:       00    00   00   00\n       16:       14    00
      \  00   00\n       20:       00    00   04   00\n       24:       00    00   00
      \  14\n       28:       00    00   00   18\n       32:       28    00   00   00\n
      \      36:       00    00   00   00\n       40:       02    00   00   00\n       44:
      \      00    00   00   00\n      CRC:       56    3a   96   d9\n"
    title: A.4.  CRC Examples
  title: Appendix A.  Examples
- contents:
  - "Appendix B.  Login Phase Examples\n   In the first example, the initiator and
    target authenticate each\n   other via Kerberos:\n      I-> Login (CSG,NSG=0,1
    T=1)\n          InitiatorName=iqn.1999-07.com.os:hostid.77\n          TargetName=iqn.1999-07.com.example:diskarray.sn.88\n
    \         AuthMethod=KRB5,SRP,None\n      T-> Login (CSG,NSG=0,0 T=0)\n          AuthMethod=KRB5\n
    \     I-> Login (CSG,NSG=0,1 T=1)\n          KRB_AP_REQ=<krb_ap_req>\n   (krb_ap_req
    contains the Kerberos V5 ticket and authenticator with\n   MUTUAL-REQUIRED set
    in the ap-options field)\n   If the authentication is successful, the target proceeds
    with:\n      T-> Login (CSG,NSG=0,1 T=1)\n          KRB_AP_REP=<krb_ap_rep>\n
    \  (krb_ap_rep is the Kerberos V5 mutual authentication reply)\n   If the authentication
    is successful, the initiator may proceed\n   with:\n      I-> Login (CSG,NSG=1,0
    T=0) FirstBurstLength=8192\n      T-> Login (CSG,NSG=1,0 T=0) FirstBurstLength=4096\n
    \         MaxBurstLength=8192\n      I-> Login (CSG,NSG=1,0 T=0) MaxBurstLength=8192\n
    \         ... more iSCSI Operational Parameters\n      T-> Login (CSG,NSG=1,0
    T=0)\n          ... more iSCSI Operational Parameters\n      And at the end:\n
    \     I-> Login (CSG,NSG=1,3 T=1)\n          optional iSCSI parameters\n      T->
    Login (CSG,NSG=1,3 T=1) \"login accept\"\n   If the initiator's authentication
    by the target is not successful,\n   the target responds with:\n      T-> Login
    \"login reject\"\n   instead of the Login KRB_AP_REP message, and it terminates
    the\n   connection.\n   If the target's authentication by the initiator is not
    successful,\n   the initiator terminates the connection (without responding to
    the\n   Login KRB_AP_REP message).\n   In the next example, only the initiator
    is authenticated by the\n   target via Kerberos:\n      I-> Login (CSG,NSG=0,1
    T=1)\n          InitiatorName=iqn.1999-07.com.os:hostid.77\n          TargetName=iqn.1999-07.com.example:diskarray.sn.88\n
    \         AuthMethod=SRP,KRB5,None\n      T-> Login-PR (CSG,NSG=0,0 T=0)\n          AuthMethod=KRB5\n
    \     I-> Login (CSG,NSG=0,1 T=1)\n          KRB_AP_REQ=krb_ap_req\n   (MUTUAL-REQUIRED
    not set in the ap-options field of krb_ap_req)\n   If the authentication is successful,
    the target proceeds with:\n      T-> Login (CSG,NSG=0,1 T=1)\n      I-> Login
    (CSG,NSG=1,0 T=0)\n          ... iSCSI parameters\n      T-> Login (CSG,NSG=1,0
    T=0)\n          ... iSCSI parameters\n      . . .\n      T-> Login (CSG,NSG=1,3
    T=1)\"login accept\"\n   In the next example, the initiator and target authenticate
    each other\n   via SRP:\n      I-> Login (CSG,NSG=0,1 T=1)\n          InitiatorName=iqn.1999-07.com.os:hostid.77\n
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n          AuthMethod=KRB5,SRP,None\n
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n          AuthMethod=SRP\n      I-> Login
    (CSG,NSG=0,0 T=0)\n          SRP_U=<user>\n          TargetAuth=Yes\n      T->
    Login (CSG,NSG=0,0 T=0)\n          SRP_N=<N>\n          SRP_g=<g>\n          SRP_s=<s>\n
    \     I-> Login (CSG,NSG=0,0 T=0)\n          SRP_A=<A>\n      T-> Login (CSG,NSG=0,0
    T=0)\n          SRP_B=<B>\n      I-> Login (CSG,NSG=0,1 T=1)\n          SRP_M=<M>\n
    \  If the initiator authentication is successful, the target proceeds\n   with:\n
    \     T-> Login (CSG,NSG=0,1 T=1)\n          SRP_HM=<H(A | M | K)>\n   where N,
    g, s, A, B, M, and H(A | M | K) are defined in [RFC2945].\n   If the target authentication
    is not successful, the initiator\n   terminates the connection; otherwise, it
    proceeds.\n      I-> Login (CSG,NSG=1,0 T=0)\n          ... iSCSI parameters\n
    \     T-> Login (CSG,NSG=1,0 T=0)\n          ... iSCSI parameters\n      And at
    the end:\n      I-> Login (CSG,NSG=1,3 T=1)\n          optional iSCSI parameters\n
    \     T-> Login (CSG,NSG=1,3 T=1) \"login accept\"\n   If the initiator authentication
    is not successful, the target\n   responds with:\n      T-> Login \"login reject\"\n
    \  instead of the T-> Login SRP_HM=<H(A | M | K)> message, and it\n   terminates
    the connection.\n   In the next example, only the initiator is authenticated by
    the\n   target via SRP:\n      I-> Login (CSG,NSG=0,1 T=1)\n          InitiatorName=iqn.1999-07.com.os:hostid.77\n
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n          AuthMethod=KRB5,SRP,None\n
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n          AuthMethod=SRP\n      I-> Login
    (CSG,NSG=0,0 T=0)\n          SRP_U=<user>\n          TargetAuth=No\n      T->
    Login (CSG,NSG=0,0 T=0)\n          SRP_N=<N>\n          SRP_g=<g>\n          SRP_s=<s>\n
    \     I-> Login (CSG,NSG=0,0 T=0)\n          SRP_A=<A>\n      T-> Login (CSG,NSG=0,0
    T=0)\n          SRP_B=<B>\n      I-> Login (CSG,NSG=0,1 T=1)\n           SRP_M=<M>\n
    \  If the initiator authentication is successful, the target proceeds\n   with:\n
    \     T-> Login (CSG,NSG=0,1 T=1)\n      I-> Login (CSG,NSG=1,0 T=0)\n          ...
    iSCSI parameters\n      T-> Login (CSG,NSG=1,0 T=0)\n          ... iSCSI parameters\n
    \     And at the end:\n      I-> Login (CSG,NSG=1,3 T=1)\n          optional iSCSI
    parameters\n      T-> Login (CSG,NSG=1,3 T=1) \"login accept\"\n   In the next
    example, the initiator and target authenticate each other\n   via CHAP:\n      I->
    Login (CSG,NSG=0,0 T=0)\n          InitiatorName=iqn.1999-07.com.os:hostid.77\n
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n          AuthMethod=KRB5,CHAP,None\n
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n          AuthMethod=CHAP\n      I-> Login
    (CSG,NSG=0,0 T=0)\n          CHAP_A=<A1,A2>\n      T-> Login (CSG,NSG=0,0 T=0)\n
    \         CHAP_A=<A1>\n          CHAP_I=<I>\n          CHAP_C=<C>\n      I-> Login
    (CSG,NSG=0,1 T=1)\n          CHAP_N=<N>\n          CHAP_R=<R>\n          CHAP_I=<I>\n
    \         CHAP_C=<C>\n   If the initiator authentication is successful, the target
    proceeds\n   with:\n      T-> Login (CSG,NSG=0,1 T=1)\n          CHAP_N=<N>\n
    \         CHAP_R=<R>\n   If the target authentication is not successful, the initiator
    aborts\n   the connection; otherwise, it proceeds.\n      I-> Login (CSG,NSG=1,0
    T=0)\n          ... iSCSI parameters\n      T-> Login (CSG,NSG=1,0 T=0)\n          ...
    iSCSI parameters\n      And at the end:\n      I-> Login (CSG,NSG=1,3 T=1)\n          optional
    iSCSI parameters\n      T-> Login (CSG,NSG=1,3 T=1) \"login accept\"\n   If the
    initiator authentication is not successful, the target\n   responds with:\n      T->
    Login \"login reject\"\n   instead of the Login CHAP_R=<response> \"proceed and
    change stage\"\n   message, and it terminates the connection.\n   In the next
    example, only the initiator is authenticated by the\n   target via CHAP:\n      I->
    Login (CSG,NSG=0,1 T=0)\n          InitiatorName=iqn.1999-07.com.os:hostid.77\n
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n          AuthMethod=KRB5,CHAP,None\n
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n          AuthMethod=CHAP\n      I-> Login
    (CSG,NSG=0,0 T=0)\n          CHAP_A=<A1,A2>\n      T-> Login (CSG,NSG=0,0 T=0)\n
    \         CHAP_A=<A1>\n          CHAP_I=<I>\n          CHAP_C=<C>\n      I-> Login
    (CSG,NSG=0,1 T=1)\n          CHAP_N=<N>\n          CHAP_R=<R>\n   If the initiator
    authentication is successful, the target proceeds\n   with:\n      T-> Login (CSG,NSG=0,1
    T=1)\n      I-> Login (CSG,NSG=1,0 T=0)\n          ... iSCSI parameters\n      T->
    Login (CSG,NSG=1,0 T=0)\n          ... iSCSI parameters\n      And at the end:\n
    \     I-> Login (CSG,NSG=1,3 T=1)\n          optional iSCSI parameters\n      T->
    Login (CSG,NSG=1,3 T=1) \"login accept\"\n   In the next example, the initiator
    does not offer any security\n   parameters.  It therefore may offer iSCSI parameters
    on the Login PDU\n   with the T bit set to 1, and the target may respond with
    a final\n   Login Response PDU immediately:\n      I-> Login (CSG,NSG=1,3 T=1)\n
    \         InitiatorName=iqn.1999-07.com.os:hostid.77\n          TargetName=iqn.1999-07.com.example:diskarray.sn.88\n
    \         ... iSCSI parameters\n      T-> Login (CSG,NSG=1,3 T=1) \"login accept\"\n
    \         ... ISCSI parameters\n   In the next example, the initiator does offer
    security parameters on\n   the Login PDU, but the target does not choose any (i.e.,
    chooses the\n   \"None\" values):\n      I-> Login (CSG,NSG=0,1 T=1)\n          InitiatorName=iqn.1999-07.com.os:hostid.77\n
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n          AuthMethod=KRB5,SRP,None\n
    \     T-> Login-PR (CSG,NSG=0,1 T=1)\n          AuthMethod=None\n      I-> Login
    (CSG,NSG=1,0 T=0)\n          ... iSCSI parameters\n      T-> Login (CSG,NSG=1,0
    T=0)\n          ... iSCSI parameters\n      And at the end:\n      I-> Login (CSG,NSG=1,3
    T=1)\n          optional iSCSI parameters\n      T-> Login (CSG,NSG=1,3 T=1) \"login
    accept\"\n"
  title: Appendix B.  Login Phase Examples
- contents:
  - "Appendix C.  SendTargets Operation\n   The text in this appendix is a normative
    part of this document.\n   To reduce the amount of configuration required on an
    initiator, iSCSI\n   provides the SendTargets Text Request.  The initiator uses
    the\n   SendTargets request to get a list of targets to which it may have\n   access,
    as well as the list of addresses (IP address and TCP port) on\n   which these
    targets may be accessed.\n   To make use of SendTargets, an initiator must first
    establish one of\n   two types of sessions.  If the initiator establishes the
    session\n   using the key \"SessionType=Discovery\", the session is a Discovery\n
    \  session, and a target name does not need to be specified.  Otherwise,\n   the
    session is a Normal operational session.  The SendTargets command\n   MUST only
    be sent during the Full Feature Phase of a Normal or\n   Discovery session.\n
    \  A system that contains targets MUST support Discovery sessions on\n   each
    of its iSCSI IP address-port pairs and MUST support the\n   SendTargets command
    on the Discovery session.  In a Discovery\n   session, a target MUST return all
    path information (IP address-port\n   pairs and Target Portal Group Tags) for
    the targets on the target\n   Network Entity that the requesting initiator is
    authorized to access.\n   A target MUST support the SendTargets command on operational\n
    \  sessions; these will only return path information about the target to\n   which
    the session is connected and do not need to return information\n   about other
    target names that may be defined in the responding\n   system.\n   An initiator
    MAY make use of the SendTargets command as it sees fit.\n   A SendTargets command
    consists of a single Text Request PDU.  This\n   PDU contains exactly one text
    key and value.  The text key MUST be\n   SendTargets.  The expected response depends
    upon the value, as well\n   as whether the session is a Discovery session or an
    operational\n   session.\n   The value must be one of:\n      All\n         The
    initiator is requesting that information on all relevant\n         targets known
    to the implementation be returned.  This value\n         MUST be supported on
    a Discovery session and MUST NOT be\n         supported on an operational session.\n
    \     <iSCSI-target-name>\n         If an iSCSI Target Name is specified, the
    session should\n         respond with addresses for only the named target, if
    possible.\n         This value MUST be supported on Discovery sessions.  A\n         Discovery
    session MUST be capable of returning addresses for\n         those targets that
    would have been returned had value=All been\n         designated.\n      <nothing>\n
    \        The session should only respond with addresses for the target\n         to
    which the session is logged in.  This MUST be supported on\n         operational
    sessions and MUST NOT return targets other than the\n         one to which the
    session is logged in.\n   The response to this command is a Text Response that
    contains a list\n   of zero or more targets and, optionally, their addresses.
    \ Each\n   target is returned as a target record.  A target record begins with\n
    \  the TargetName text key, followed by a list of TargetAddress text\n   keys,
    and bounded by the end of the Text Response or the next\n   TargetName key, which
    begins a new record.  No text keys other than\n   TargetName and TargetAddress
    are permitted within a SendTargets\n   response.\n   For the format of the TargetName,
    see Section 13.4.\n   A Discovery session MAY respond to a SendTargets request
    with its\n   complete list of targets, or with a list of targets that is based
    on\n   the name of the initiator logged in to the session.\n   A SendTargets response
    MUST NOT contain target names if there are no\n   targets for the requesting initiator
    to access.\n   Each target record returned includes zero or more TargetAddress\n
    \  fields.\n   Each target record starts with one text key of the form:\n      TargetName=<target-name-goes-here>\n
    \  followed by zero or more address keys of the form:\n   TargetAddress=<hostname-or-ipaddress>[:<tcp-port>],\n
    \     <portal-group-tag>\n   The hostname-or-ipaddress contains a domain name,
    IPv4 address, or\n   IPv6 address ([RFC4291]), as specified for the TargetAddress
    key.\n   A hostname-or-ipaddress duplicated in TargetAddress responses for a\n
    \  given node (the port is absent or equal) would probably indicate that\n   multiple
    address families are in use at once (IPv6 and IPv4).\n   Each TargetAddress belongs
    to a portal group, identified by its\n   numeric Target Portal Group Tag (see
    Section 13.9).  The iSCSI Target\n   Name, together with this tag, constitutes
    the SCSI port identifier;\n   the tag only needs to be unique within a given target's
    name list of\n   addresses.\n   Multiple-connection sessions can span iSCSI addresses
    that belong to\n   the same portal group.\n   Multiple-connection sessions cannot
    span iSCSI addresses that belong\n   to different portal groups.\n   If a SendTargets
    response reports an iSCSI address for a target, it\n   SHOULD also report all
    other addresses in its portal group in the\n   same response.\n   A SendTargets
    Text Response can be longer than a single Text Response\n   PDU and makes use
    of the long Text Responses as specified.\n   After obtaining a list of targets
    from the Discovery session, an\n   iSCSI initiator may initiate new sessions to
    log in to the discovered\n   targets for full operation.  The initiator MAY keep
    the Discovery\n   session open and MAY send subsequent SendTargets commands to
    discover\n   new targets.\n   Examples:\n   This example is the SendTargets response
    from a single target that\n   has no other interface ports.\n   The initiator
    sends a Text Request that contains:\n      SendTargets=All\n   The target sends
    a Text Response that contains:\n      TargetName=iqn.1993-11.com.example:diskarray.sn.8675309\n
    \  All the target had to return in this simple case was the target name.\n   It
    is assumed by the initiator that the IP address and TCP port for\n   this target
    are the same as those used on the current connection to\n   the default iSCSI
    target.\n   The next example has two internal iSCSI targets, each accessible via\n
    \  two different ports with different IP addresses.  The following is\n   the
    Text Response:\n      TargetName=iqn.1993-11.com.example:diskarray.sn.8675309\n
    \     TargetAddress=10.1.0.45:3000,1\n      TargetAddress=10.1.1.45:3000,2\n      TargetName=iqn.1993-11.com.example:diskarray.sn.1234567\n
    \     TargetAddress=10.1.0.45:3000,1\n      TargetAddress=10.1.1.45:3000,2\n   Both
    targets share both addresses; the multiple addresses are likely\n   used to provide
    multi-path support.  The initiator may connect to\n   either target name on either
    address.  Each of the addresses has its\n   own Target Portal Group Tag; they
    do not support spanning multiple-\n   connection sessions with each other.  Keep
    in mind that the Target\n   Portal Group Tags for the two named targets are independent
    of one\n   another; portal group \"1\" on the first target is not necessarily
    the\n   same as portal group \"1\" on the second target.\n   In the above example,
    a DNS host name or an IPv6 address could have\n   been returned instead of an
    IPv4 address.\n   The next Text Response shows a target that supports spanning
    sessions\n   across multiple addresses and further illustrates the use of the\n
    \  Target Portal Group Tags:\n      TargetName=iqn.1993-11.com.example:diskarray.sn.8675309\n
    \     TargetAddress=10.1.0.45:3000,1\n      TargetAddress=10.1.1.46:3000,1\n      TargetAddress=10.1.0.47:3000,2\n
    \     TargetAddress=10.1.1.48:3000,2\n      TargetAddress=10.1.1.49:3000,3\n   In
    this example, any of the target addresses can be used to reach the\n   same target.
    \ A single-connection session can be established to any\n   of these TCP addresses.
    \ A multiple-connection session could span\n   addresses .45 and .46 or .47 and
    .48 but cannot span any other\n   combination.  A TargetAddress with its own tag
    (.49) cannot be\n   combined with any other address within the same session.\n
    \  This SendTargets response does not indicate whether .49 supports\n   multiple
    connections per session; it is communicated via the\n   MaxConnections text key
    upon login to the target.\n"
  title: Appendix C.  SendTargets Operation
- contents:
  - "Appendix D.  Algorithmic Presentation of Error Recovery Classes\n   This appendix
    illustrates the error recovery classes using a\n   pseudo-programming language.
    \ The procedure names are chosen to be\n   obvious to most implementers.  Each
    of the recovery classes described\n   has initiator procedures as well as target
    procedures.  These\n   algorithms focus on outlining the mechanics of error recovery
    classes\n   and do not exhaustively describe all other aspects/cases.  Examples\n
    \  of this approach are as follows:\n      - Handling for only certain Opcode
    types is shown.\n      - Only certain reason codes (e.g., Recovery in Logout command)
    are\n        outlined.\n      - Resultant cases, such as recovery of Synchronization
    on a header\n        digest error, are considered out of scope in these algorithms.\n
    \       In this particular example, a header digest error may lead to\n        connection
    recovery if some type of Sync and Steering layer is\n        not implemented.\n
    \  These algorithms strive to convey the iSCSI error recovery concepts\n   in
    the simplest terms and are not designed to be optimal.\n"
  - contents:
    - "D.1.  General Data Structure and Procedure Description\n   This section defines
      the procedures and data structures that are\n   commonly used by all the error
      recovery algorithms.  The structures\n   may not be the exhaustive representations
      of what is required for a\n   typical implementation.\n   Data structure definitions:\n
      \  struct TransferContext {\n           int TargetTransferTag;\n           int
      ExpectedDataSN;\n   };\n   struct TCB {              /* task control block */\n
      \          Boolean SoFarInOrder;\n           int ExpectedDataSN; /* used for
      both R2Ts and Data */\n           int MissingDataSNList[MaxMissingDPDU];\n           Boolean
      FbitReceived;\n           Boolean StatusXferd;\n           Boolean CurrentlyAllegiant;\n
      \          int ActiveR2Ts;\n           int Response;\n           char *Reason;\n
      \          struct TransferContext\n                       TransferContextList[MaxOutstandingR2T];\n
      \          int InitiatorTaskTag;\n           int CmdSN;\n           int SNACK_Tag;\n
      \  };\n   struct Connection {\n           struct Session SessionReference;\n
      \          Boolean SoFarInOrder;\n           int CID;\n           int State;\n
      \          int CurrentTimeout;\n           int ExpectedStatSN;\n           int
      MissingStatSNList[MaxMissingSPDU];\n           Boolean PerformConnectionCleanup;\n
      \  };\n   struct Session {\n           int NumConnections;\n           int CmdSN;\n
      \          int Maxconnections;\n           int ErrorRecoveryLevel;\n           struct
      iSCSIEndpoint OtherEndInfo;\n           struct Connection ConnectionList[MaxSupportedConns];\n
      \  };\n   Procedure descriptions:\n   Receive-an-In-PDU(transport connection,
      inbound PDU);\n   check-basic-validity(inbound PDU);\n   Start-Timer(timeout
      handler, argument, timeout value);\n   Build-And-Send-Reject(transport connection,
      bad PDU, reason code);\n"
    title: D.1.  General Data Structure and Procedure Description
  - contents:
    - 'D.2.  Within-command Error Recovery Algorithms

      '
    - contents:
      - "D.2.1.  Procedure Descriptions\n   Recover-Data-if-Possible(last required
        DataSN, task control block);\n   Build-And-Send-DSnack(task control block);\n
        \  Build-And-Send-RDSnack(task control block);\n   Build-And-Send-Abort(task
        control block);\n   SCSI-Task-Completion(task control block);\n   Build-And-Send-A-Data-Burst(transport
        connection, data-descriptor,\n      task control block);\n   Build-And-Send-R2T(transport
        connection, data-descriptor,\n      task control block);\n   Build-And-Send-Status(transport
        connection, task control block);\n   Transfer-Context-Timeout-Handler(transfer
        context);\n   Notes:\n   - One procedure used in this section: the Handle-Status-SNACK-request\n
        \    is defined in Appendix D.3.\n   - The response-processing pseudocode
        shown in the target algorithms\n     applies to all solicited PDUs that carry
        the StatSN -- SCSI\n     Response, Text Response, etc.\n"
      title: D.2.1.  Procedure Descriptions
    - contents:
      - "D.2.2.  Initiator Algorithms\n   Recover-Data-if-Possible(LastRequiredDataSN,
        TCB)\n   {\n       if (operational ErrorRecoveryLevel > 0) {\n            if
        (# of missing PDUs is trackable) {\n                  Note the missing DataSNs
        in TCB.\n                  if (the task spanned a change in\n                             MaxRecvDataSegmentLength)
        {\n                       if (TCB.StatusXferd is TRUE)\n                           drop
        the status PDU;\n                       Build-And-Send-RDSnack(TCB);\n                  }
        else {\n                       Build-And-Send-DSnack(TCB);\n                  }\n
        \           } else {\n                TCB.Reason = \"Protocol Service CRC
        error\";\n                     }\n       } else {\n             TCB.Reason
        = \"Protocol Service CRC error\";\n       }\n       if (TCB.Reason == \"Protocol
        Service CRC error\") {\n             Clear the missing PDU list in the TCB.\n
        \            if (TCB.StatusXferd is not TRUE)\n                Build-And-Send-Abort(TCB);\n
        \      }\n   }\n   Receive-an-In-PDU(Connection, CurrentPDU)\n   {\n    check-basic-validity(CurrentPDU);\n
        \   if (Header-Digest-Bad) discard, return;\n    Retrieve TCB for CurrentPDU.InitiatorTaskTag.\n
        \   if ((CurrentPDU.type == Data)\n                or (CurrentPDU.type = R2T))
        {\n       if (Data-Digest-Bad for Data) {\n                 send-data-SNACK
        = TRUE;\n         LastRequiredDataSN = CurrentPDU.DataSN;\n               }
        else {\n             if (TCB.SoFarInOrder = TRUE) {\n                 if (current
        DataSN is expected) {\n                      Increment TCB.ExpectedDataSN.\n
        \                } else {\n                         TCB.SoFarInOrder = FALSE;\n
        \                        send-data-SNACK = TRUE;\n                        }\n
        \            } else {\n                     if (current DataSN was considered
        missing) {\n                        remove current DataSN from missing PDU
        list.\n                    } else if (current DataSN is higher than expected)
        {\n                                send-data-SNACK = TRUE;\n                         }
        else {\n                               discard, return;\n                         }\n
        \                        Adjust TCB.ExpectedDataSN if appropriate.\n                }\n
        \               LastRequiredDataSN = CurrentPDU.DataSN - 1;\n                  }\n
        \                 if (send-data-SNACK is TRUE and\n                    task
        is not already considered failed) {\n                Recover-Data-if-Possible(LastRequiredDataSN,
        TCB);\n       }\n               if (missing data PDU list is empty) {\n                  TCB.SoFarInOrder
        = TRUE;\n               }\n       if (CurrentPDU.type == R2T) {\n          Increment
        ActiveR2Ts for this task.\n          Create a data-descriptor for the data
        burst.\n          Build-And-Send-A-Data-Burst(Connection, data-descriptor,
        TCB);\n        }\n     } else if (CurrentPDU.type == Response) {\n        if
        (Data-Digest-Bad) {\n                   send-status-SNACK = TRUE;\n                }
        else {\n           TCB.StatusXferd = TRUE;\n           Store the status information
        in TCB.\n           if (ExpDataSN does not match) {\n                TCB.SoFarInOrder
        = FALSE;\n                Recover-Data-if-Possible(current DataSN, TCB);\n
        \          }\n                   if (missing data PDU list is empty) {\n                        TCB.SoFarInOrder
        = TRUE;\n                   }\n        }\n     } else { /* REST UNRELATED
        TO WITHIN-COMMAND-RECOVERY, NOT SHOWN */\n     }\n     if ((TCB.SoFarInOrder
        == TRUE) and\n                           (TCB.StatusXferd == TRUE)) {\n             SCSI-Task-Completion(TCB);\n
        \     }\n   }\n"
      title: D.2.2.  Initiator Algorithms
    - contents:
      - "D.2.3.  Target Algorithms\n   Receive-an-In-PDU(Connection, CurrentPDU)\n
        \  {\n     check-basic-validity(CurrentPDU);\n     if (Header-Digest-Bad)
        discard, return;\n     Retrieve TCB for CurrentPDU.InitiatorTaskTag.\n     if
        (CurrentPDU.type == Data) {\n         Retrieve TContext from CurrentPDU.TargetTransferTag;\n
        \        if (Data-Digest-Bad) {\n                     Build-And-Send-Reject(Connection,
        CurrentPDU,\n                                  Payload-Digest-Error);\n            Note
        the missing data PDUs in MissingDataRange[].\n                     send-recovery-R2T
        = TRUE;\n                  } else {\n            if (current DataSN is not
        expected) {\n                Note the missing data PDUs in MissingDataRange[].\n
        \                        send-recovery-R2T = TRUE;\n                     }\n
        \           if (CurrentPDU.Fbit == TRUE) {\n                if (current PDU
        is solicited) {\n                        Decrement TCB.ActiveR2Ts.\n                }\n
        \               if ((current PDU is unsolicited and\n                        data
        received is less than I/O length and\n                          data received
        is less than FirstBurstLength)\n                     or (current PDU is solicited
        and the length of\n                          this burst is less than expected))
        {\n                     send-recovery-R2T = TRUE;\n                     Note
        the missing data in MissingDataRange[].\n                }\n                     }\n
        \                 }\n                  Increment TContext.ExpectedDataSN.\n
        \        if (send-recovery-R2T is TRUE and\n                   task is not
        already considered failed) {\n            if (operational ErrorRecoveryLevel
        > 0) {\n                Increment TCB.ActiveR2Ts.\n                Create
        a data-descriptor for the data burst\n                           from MissingDataRange.\n
        \               Build-And-Send-R2T(Connection, data-descriptor, TCB);\n            }
        else {\n                 if (current PDU is the last unsolicited)\n                     TCB.Reason
        = \"Not enough unsolicited data\";\n                 else\n                     TCB.Reason
        = \"Protocol Service CRC error\";\n            }\n         }\n         if
        (TCB.ActiveR2Ts == 0) {\n            Build-And-Send-Status(Connection, TCB);\n
        \        }\n     } else if (CurrentPDU.type == SNACK) {\n         snack-failure
        = FALSE;\n         if (operational ErrorRecoveryLevel > 0) {\n            if
        (CurrentPDU.type == Data/R2T) {\n                if (the request is satisfiable)
        {\n                   if (request for Data) {\n                      Create
        a data-descriptor for the data burst\n                          from BegRun
        and RunLength.\n                      Build-And-Send-A-Data-Burst(Connection,\n
        \                        data-descriptor, TCB);\n                   } else
        { /* R2T */\n                      Create a data-descriptor for the data burst\n
        \                         from BegRun and RunLength.\n                      Build-And-Send-R2T(Connection,
        data-descriptor,\n                         TCB);\n                    }\n
        \                } else {\n                       snack-failure = TRUE;\n
        \                }\n            } else if (CurrentPDU.type == status) {\n
        \                Handle-Status-SNACK-request(Connection, CurrentPDU);\n            }
        else if (CurrentPDU.type == DataACK) {\n                   Consider all data
        up to CurrentPDU.BegRun as\n                   acknowledged.\n                   Free
        up the retransmission resources for that data.\n              } else if (CurrentPDU.type
        == R-Data SNACK) {\n                            Create a data descriptor for
        a data burst\n                            covering all unacknowledged data.\n
        \                 Build-And-Send-A-Data-Burst(Connection,\n                     data-descriptor,
        TCB);\n                  TCB.SNACK_Tag = CurrentPDU.SNACK_Tag;\n                  if
        (there's no more data to send) {\n                     Build-And-Send-Status(Connection,
        TCB);\n                  }\n            }\n         } else { /* operational
        ErrorRecoveryLevel = 0 */\n                  snack-failure = TRUE;\n         }\n
        \        if (snack-failure == TRUE) {\n              Build-And-Send-Reject(Connection,
        CurrentPDU,\n                  SNACK-Reject);\n              if (TCB.StatusXferd
        != TRUE) {\n                  TCB.Reason = \"SNACK rejected\";\n                  Build-And-Send-Status(Connection,
        TCB);\n              }\n         }\n     } else { /* REST UNRELATED TO WITHIN-COMMAND-RECOVERY,
        NOT SHOWN */\n     }\n   }\n   Transfer-Context-Timeout-Handler(TContext)\n
        \  {\n     Retrieve TCB and Connection from TContext.\n     Decrement TCB.ActiveR2Ts.\n
        \    if (operational ErrorRecoveryLevel > 0 and\n                   task is
        not already considered failed) {\n         Note the missing data PDUs in MissingDataRange[].\n
        \        Create a data-descriptor for the data burst\n                           from
        MissingDataRange[].\n         Build-And-Send-R2T(Connection, data-descriptor,
        TCB);\n       } else {\n           TCB.Reason = \"Protocol Service CRC error\";\n
        \          if (TCB.ActiveR2Ts = 0) {\n              Build-And-Send-Status(Connection,
        TCB);\n           }\n       }\n   }\n"
      title: D.2.3.  Target Algorithms
    title: D.2.  Within-command Error Recovery Algorithms
  - contents:
    - 'D.3.  Within-connection Recovery Algorithms

      '
    - contents:
      - "D.3.1.  Procedure Descriptions\n   Procedure descriptions:\n   Recover-Status-if-Possible(transport
        connection,\n      currently received PDU);\n   Evaluate-a-StatSN(transport
        connection, currently received PDU);\n   Retransmit-Command-if-Possible(transport
        connection, CmdSN);\n   Build-And-Send-SSnack(transport connection);\n   Build-And-Send-Command(transport
        connection,\n      task control block);\n   Command-Acknowledge-Timeout-Handler(task
        control block);\n   Status-Expect-Timeout-Handler(transport connection);\n
        \  Build-And-Send-NOP-Out(transport connection);\n   Handle-Status-SNACK-request(transport
        connection,\n      Status SNACK PDU);\n   Retransmit-Status-Burst(Status SNACK,
        task control block);\n   Is-Acknowledged(beginning StatSN, run length);\n
        \  Implementation-specific parameters that are tunable:\n   InitiatorProactiveSNACKEnabled\n
        \  Notes:\n   - The initiator algorithms only deal with unsolicited NOP-In
        PDUs for\n     generating Status SNACKs.  A solicited NOP-In PDU has an assigned\n
        \    StatSN that, when out of order, could trigger the out-of-order\n     StatSN
        handling in within-command algorithms, again leading to\n     Recover-Status-if-Possible.\n
        \  - The pseudocode shown may result in the retransmission of\n     unacknowledged
        commands in more cases than necessary.  This will\n     not, however, affect
        the correctness of the operation because the\n     target is required to discard
        the duplicate CmdSNs.\n   - The procedure Build-And-Send-Async is defined
        in the connection\n     recovery algorithms.\n   - The procedure Status-Expect-Timeout-Handler
        describes how\n     initiators may proactively attempt to retrieve the Status
        if they\n     so choose.  This procedure is assumed to be triggered much before\n
        \    the standard ULP timeout.\n"
      title: D.3.1.  Procedure Descriptions
    - contents:
      - "D.3.2.  Initiator Algorithms\n     Recover-Status-if-Possible(Connection,
        CurrentPDU)\n     {\n         if ((Connection.state == LOGGED_IN) and\n                     connection
        is not already considered failed) {\n            if (operational ErrorRecoveryLevel
        > 0) {\n               if (# of missing PDUs is trackable) {\n                     Note
        the missing StatSNs in Connection\n                     that were not already
        requested with SNACK;\n                 Build-And-Send-SSnack(Connection);\n
        \                      } else {\n                         Connection.PerformConnectionCleanup
        = TRUE;\n               }\n            } else {\n                       Connection.PerformConnectionCleanup
        = TRUE;\n            }\n            if (Connection.PerformConnectionCleanup
        == TRUE) {\n               Start-Timer(Connection-Cleanup-Handler, Connection,
        0);\n                     }\n         }\n     }\n     Retransmit-Command-if-Possible(Connection,
        CmdSN)\n     {\n         if (operational ErrorRecoveryLevel > 0) {\n            Retrieve
        the InitiatorTaskTag, and thus TCB for the CmdSN.\n            Build-And-Send-Command(Connection,
        TCB);\n         }\n     }\n     Evaluate-a-StatSN(Connection, CurrentPDU)\n
        \    {\n         send-status-SNACK = FALSE;\n         if (Connection.SoFarInOrder
        == TRUE) {\n            if (current StatSN is the expected) {\n                 Increment
        Connection.ExpectedStatSN.\n            } else {\n                          Connection.SoFarInOrder
        = FALSE;\n                          send-status-SNACK = TRUE;\n                     }\n
        \        } else {\n            if (current StatSN was considered missing)
        {\n                 remove current StatSN from the missing list.\n            }
        else {\n                          if (current StatSN is higher than expected){\n
        \                             send-status-SNACK = TRUE;\n                          }
        else {\n                              send-status-SNACK = FALSE;\n                      discard
        the PDU;\n                 }\n            }\n            Adjust Connection.ExpectedStatSN
        if appropriate.\n            if (missing StatSN list is empty) {\n                 Connection.SoFarInOrder
        = TRUE;\n                     }\n         }\n         return send-status-SNACK;\n
        \    }\n     Receive-an-In-PDU(Connection, CurrentPDU)\n     {\n         check-basic-validity(CurrentPDU);\n
        \        if (Header-Digest-Bad) discard, return;\n         Retrieve TCB for
        CurrentPDU.InitiatorTaskTag.\n         if (CurrentPDU.type == NOP-In) {\n
        \              if (the PDU is unsolicited) {\n                     if (current
        StatSN is not expected) {\n                          Recover-Status-if-Possible(Connection,\n
        \                                      CurrentPDU);\n                     }\n
        \                    if (current ExpCmdSN is not Session.CmdSN) {\n                          Retransmit-Command-if-Possible(Connection,\n
        \                                      CurrentPDU.ExpCmdSN);\n                     }\n
        \              }\n         } else if (CurrentPDU.type == Reject) {\n               if
        (it is a data digest error on immediate data) {\n                     Retransmit-Command-if-Possible(Connection,\n
        \                                      CurrentPDU.BadPDUHeader.CmdSN);\n               }\n
        \        } else if (CurrentPDU.type == Response) {\n              send-status-SNACK
        = Evaluate-a-StatSN(Connection,\n                                             CurrentPDU);\n
        \             if (send-status-SNACK == TRUE)\n                  Recover-Status-if-Possible(Connection,
        CurrentPDU);\n         } else { /* REST UNRELATED TO WITHIN-CONNECTION-RECOVERY,\n
        \                  * NOT SHOWN */\n         }\n     }\n     Command-Acknowledge-Timeout-Handler(TCB)\n
        \    {\n         Retrieve the Connection for TCB.\n         Retransmit-Command-if-Possible(Connection,
        TCB.CmdSN);\n     }\n     Status-Expect-Timeout-Handler(Connection)\n     {\n
        \        if (operational ErrorRecoveryLevel > 0) {\n             Build-And-Send-NOP-Out(Connection);\n
        \        } else if (InitiatorProactiveSNACKEnabled){\n             if ((Connection.state
        == LOGGED_IN) and\n                          connection is not already considered
        failed) {\n                  Build-And-Send-SSnack(Connection);\n             }\n
        \        }\n     }\n"
      title: D.3.2.  Initiator Algorithms
    - contents:
      - "D.3.3.  Target Algorithms\n   Handle-Status-SNACK-request(Connection, CurrentPDU)\n
        \    {\n         if (operational ErrorRecoveryLevel > 0) {\n            if
        (request for an acknowledged run) {\n                Build-And-Send-Reject(Connection,
        CurrentPDU,\n                                              Protocol-Error);\n
        \           } else if (request for an untransmitted run) {\n                discard,
        return;\n            } else {\n                Retransmit-Status-Burst(CurrentPDU,
        TCB);\n            }\n         } else {\n            Build-And-Send-Async(Connection,
        DroppedConnection,\n                                  DefaultTime2Wait, DefaultTime2Retain);\n
        \        }\n     }\n"
      title: D.3.3.  Target Algorithms
    title: D.3.  Within-connection Recovery Algorithms
  - contents:
    - 'D.4.  Connection Recovery Algorithms

      '
    - contents:
      - "D.4.1.  Procedure Descriptions\n   Build-And-Send-Async(transport connection,
        reason code,\n      minimum time, maximum time);\n   Pick-A-Logged-In-Connection(session);\n
        \  Build-And-Send-Logout(transport connection,\n      logout connection identifier,
        reason code);\n   PerformImplicitLogout(transport connection,\n      logout
        connection identifier, target information);\n   PerformLogin(transport connection,
        target information);\n   CreateNewTransportConnection(target information);\n
        \  Build-And-Send-Command(transport connection, task control block);\n   Connection-Cleanup-Handler(transport
        connection);\n   Connection-Resource-Timeout-Handler(transport connection);\n
        \  Quiesce-And-Prepare-for-New-Allegiance(session, task control block);\n
        \  Build-And-Send-Logout-Response(transport connection,\n      CID of connection
        in recovery, reason code);\n   Build-And-Send-TaskMgmt-Response(transport
        connection,\n      task mgmt command PDU, response code);\n   Establish-New-Allegiance(task
        control block, transport connection);\n   Schedule-Command-To-Continue(task
        control block);\n   Note:\n   - Transport exception conditions such as unexpected
        connection\n     termination, connection reset, and hung connection while
        the\n     connection is in the Full Feature Phase are all assumed to be\n
        \    asynchronously signaled to the iSCSI layer using the\n     Transport_Exception_Handler
        procedure.\n"
      title: D.4.1.  Procedure Descriptions
    - contents:
      - "D.4.2.  Initiator Algorithms\n     Receive-an-In-PDU(Connection, CurrentPDU)\n
        \    {\n         check-basic-validity(CurrentPDU);\n         if (Header-Digest-Bad)
        discard, return;\n         Retrieve TCB from CurrentPDU.InitiatorTaskTag.\n
        \        if (CurrentPDU.type == Async) {\n             if (CurrentPDU.AsyncEvent
        == ConnectionDropped) {\n                Retrieve the AffectedConnection for\n
        \                  CurrentPDU.Parameter1.\n                AffectedConnection.CurrentTimeout
        =\n                   CurrentPDU.Parameter3;\n               AffectedConnection.State
        = CLEANUP_WAIT;\n               Start-Timer(Connection-Cleanup-Handler,\n
        \                           AffectedConnection, CurrentPDU.Parameter2);\n
        \            } else if (CurrentPDU.AsyncEvent == LogoutRequest)) {\n               AffectedConnection
        = Connection;\n               AffectedConnection.State = LOGOUT_REQUESTED;\n
        \              AffectedConnection.PerformConnectionCleanup = TRUE;\n                        AffectedConnection.CurrentTimeout
        =\n                           CurrentPDU.Parameter3;\n               Start-Timer(Connection-Cleanup-Handler,\n
        \                            AffectedConnection, 0);\n             } else
        if (CurrentPDU.AsyncEvent == SessionDropped)) {\n               for (each
        Connection) {\n                   Connection.State = CLEANUP_WAIT;\n                   Connection.CurrentTimeout
        = CurrentPDU.Parameter3;\n                   Start-Timer(Connection-Cleanup-Handler,\n
        \                            Connection, CurrentPDU.Parameter2);\n               }\n
        \              Session.state = FAILED;\n             }\n         } else if
        (CurrentPDU.type == LogoutResponse) {\n             Retrieve the CleanupConnection
        for CurrentPDU.CID.\n             if (CurrentPDU.Response = failure) {\n                CleanupConnection.State
        = CLEANUP_WAIT;\n             } else {\n                 CleanupConnection.State
        = FREE;\n             }\n         } else if (CurrentPDU.type == LoginResponse)
        {\n              if (this is a response to an implicit Logout) {\n                 Retrieve
        the CleanupConnection.\n                 if (successful) {\n                     CleanupConnection.State
        = FREE;\n                     Connection.State = LOGGED_IN;\n                 }
        else {\n                      CleanupConnection.State = CLEANUP_WAIT;\n                      DestroyTransportConnection(Connection);\n
        \                }\n              }\n         } else { /* REST UNRELATED TO
        CONNECTION-RECOVERY,\n                   * NOT SHOWN */\n         }\n         if
        (CleanupConnection.State == FREE) {\n            for (each command that was
        active on CleanupConnection) {\n            /* Establish new connection allegiance
        */\n                 NewConnection = Pick-A-Logged-In-Connection(Session);\n
        \                Build-And-Send-Command(NewConnection, TCB);\n             }\n
        \        }\n     }\n     Connection-Cleanup-Handler(Connection)\n     {\n
        \        Retrieve Session from Connection.\n         if (Connection can still
        exchange iSCSI PDUs) {\n             NewConnection = Connection;\n         }
        else {\n             Start-Timer(Connection-Resource-Timeout-Handler,\n                   Connection,
        Connection.CurrentTimeout);\n             if (there are other logged-in connections)
        {\n                  NewConnection = Pick-A-Logged-In-Connection(Session);\n
        \            } else {\n                  NewConnection =\n                     CreateTransportConnection(Session.OtherEndInfo);\n
        \                 Initiate an implicit Logout on NewConnection for\n                     Connection.CID.\n
        \                 return;\n             }\n         }\n         Build-And-Send-Logout(NewConnection,
        Connection.CID,\n                                             RecoveryRemove);\n
        \    }\n     Transport_Exception_Handler(Connection)\n     {\n         Connection.PerformConnectionCleanup
        = TRUE;\n         if (the event is an unexpected transport disconnect) {\n
        \            Connection.State = CLEANUP_WAIT;\n             Connection.CurrentTimeout
        = DefaultTime2Retain;\n             Start-Timer(Connection-Cleanup-Handler,
        Connection,\n                            DefaultTime2Wait);\n         } else
        {\n             Connection.State = FREE;\n         }\n     }\n"
      title: D.4.2.  Initiator Algorithms
    - contents:
      - "D.4.3.  Target Algorithms\n     Receive-an-In-PDU(Connection, CurrentPDU)\n
        \    {\n         check-basic-validity(CurrentPDU);\n         if (Header-Digest-Bad)
        discard, return;\n         else if (Data-Digest-Bad) {\n                   Build-And-Send-Reject(Connection,
        CurrentPDU,\n                                            Payload-Digest-Error);\n
        \                  discard, return;\n         }\n         Retrieve TCB and
        Session.\n         if (CurrentPDU.type == Logout) {\n            if (CurrentPDU.ReasonCode
        = RecoveryRemove) {\n                Retrieve the CleanupConnection from CurrentPDU.CID).\n
        \               for (each command active on CleanupConnection) {\n                     Quiesce-And-Prepare-for-New-Allegiance(Session,\n
        \                       TCB);\n                     TCB.CurrentlyAllegiant
        = FALSE;\n                }\n                Cleanup-Connection-State(CleanupConnection);\n
        \               if ((quiescing successful) and (cleanup successful))\n     {\n
        \                    Build-And-Send-Logout-Response(Connection,\n                                       CleanupConnection.CID,
        Success);\n                } else {\n                     Build-And-Send-Logout-Response(Connection,\n
        \                                      CleanupConnection.CID, Failure);\n
        \               }\n             }\n         } else if ((CurrentPDU.type ==
        Login) and\n                              operational ErrorRecoveryLevel ==
        2) {\n                 Retrieve the CleanupConnection from CurrentPDU.CID).\n
        \                for (each command active on CleanupConnection) {\n                       Quiesce-And-Prepare-for-New-Allegiance(Session,\n
        \                         TCB);\n                       TCB.CurrentlyAllegiant
        = FALSE;\n                 }\n                 Cleanup-Connection-State(CleanupConnection);\n
        \                if ((quiescing successful) and (cleanup successful))\n     {\n
        \                      Continue with the rest of the login processing;\n                 }
        else {\n                       Build-And-Send-Login-Response(Connection,\n
        \                                 CleanupConnection.CID, Target Error);\n
        \                }\n             }\n         } else if (CurrentPDU.type ==
        TaskManagement) {\n               if (CurrentPDU.function == \"TaskReassign\")
        {\n                     if (Session.ErrorRecoveryLevel < 2) {\n                         Build-And-Send-TaskMgmt-Response(Connection,\n
        \                           CurrentPDU,\n                               \"Task
        allegiance reassignment not\n                                                   supported\");\n
        \                    } else if (task is not found) {\n                         Build-And-Send-TaskMgmt-Response(Connection,\n
        \                           CurrentPDU, \"Task not in task set\");\n                     }
        else if (task is currently allegiant) {\n                         Build-And-Send-TaskMgmt-Response(Connection,\n
        \                           CurrentPDU, \"Task still allegiant\");\n                     }
        else {\n                         Establish-New-Allegiance(TCB, Connection);\n
        \                        TCB.CurrentlyAllegiant = TRUE;\n                         Schedule-Command-To-Continue(TCB);\n
        \                    }\n               }\n         } else { /* REST UNRELATED
        TO CONNECTION-RECOVERY,\n                   * NOT SHOWN */\n         }\n     }\n
        \    Transport_Exception_Handler(Connection)\n     {\n         Connection.PerformConnectionCleanup
        = TRUE;\n         if (the event is an unexpected transport disconnect) {\n
        \            Connection.State = CLEANUP_WAIT;\n              Start-Timer(Connection-Resource-Timeout-Handler,\n
        \                Connection, (DefaultTime2Wait+DefaultTime2Retain));\n               if
        (this Session has Full Feature Phase connections\n                     left)
        {\n                   DifferentConnection =\n                      Pick-A-Logged-In-Connection(Session);\n
        \                   Build-And-Send-Async(DifferentConnection,\n                          DroppedConnection,
        DefaultTime2Wait,\n                            DefaultTime2Retain);\n             }\n
        \        } else {\n               Connection.State = FREE;\n         }\n     }\n"
      title: D.4.3.  Target Algorithms
    title: D.4.  Connection Recovery Algorithms
  title: Appendix D.  Algorithmic Presentation of Error Recovery Classes
- contents:
  - 'Appendix E.  Clearing Effects of Various Events on Targets

    '
  - contents:
    - "E.1.  Clearing Effects on iSCSI Objects\n   The following tables describe the
      target behavior on receiving the\n   events specified in the rows of the table.
      \ The second table is an\n   extension of the first table and defines clearing
      actions for more\n   objects on the same events.  The legend is:\n    Y = Yes
      (cleared/discarded/reset on the event specified in the row).\n        Unless
      otherwise noted, the clearing action is only applicable\n        for the issuing
      initiator port.\n    N = No (not affected on the event specified in the row,
      i.e., stays\n        at previous value).\n   NA = Not Applicable or Not Defined.\n
      \                           +------+------+------+------+------+\n                            |IT
      (1)|IC (2)|CT (5)|ST (6)|PP (7)|\n     +----------------------+------+------+------+------+------+\n
      \    |connection failure (8)|Y     |Y     |N     |N     |Y     |\n     +----------------------+------+------+------+------+------+\n
      \    |connection state      |NA    |NA    |Y     |N     |NA    |\n     |timeout
      (9)           |      |      |      |      |      |\n     +----------------------+------+------+------+------+------+\n
      \    |session timeout/      |Y     |Y     |Y     |Y     |Y (14)|\n     |closure/reinstatement
      |      |      |      |      |      |\n     |(10)                  |      |      |
      \     |      |      |\n     +----------------------+------+------+------+------+------+\n
      \    |session continuation  |NA    |NA    |N (11)|N     |NA    |\n     |(12)
      \                 |      |      |      |      |      |\n     +----------------------+------+------+------+------+------+\n
      \    |successful connection |Y     |Y     |Y     |N     |Y (13)|\n     |close
      logout          |      |      |      |      |      |\n     +----------------------+------+------+------+------+------+\n
      \    |session failure (18)  |Y     |Y     |N     |N     |Y     |\n     +----------------------+------+------+------+------+------+\n
      \    |successful recovery   |Y     |Y     |N     |N     |Y (13)|\n     |Logout
      \               |      |      |      |      |      |\n     +----------------------+------+------+------+------+------+\n
      \    |failed Logout         |Y     |Y     |N     |N     |Y     |\n     +----------------------+------+------+------+------+------+\n
      \    |connection Login      |NA    |NA    |NA    |Y (15)|NA    |\n     |(leading)
      \            |      |      |      |      |      |\n     +----------------------+------+------+------+------+------+\n
      \    |connection Login      |NA    |NA    |N (11)|N     |Y     |\n     |(non-leading)
      \        |      |      |      |      |      |\n     +----------------------+------+------+------+------+------+\n
      \    |TARGET COLD RESET (16)|Y (20)|Y     |Y     |Y     |Y     |\n     +----------------------+------+------+------+------+------+\n
      \    |TARGET WARM RESET (16)|Y (20)|Y     |Y     |Y     |Y     |\n     +----------------------+------+------+------+------+------+\n
      \    |LU reset (19)         |Y (20)|Y     |Y     |Y     |Y     |\n     +----------------------+------+------+------+------+------+\n
      \    |power cycle (16)      |Y     |Y     |Y     |Y     |Y     |\n     +----------------------+------+------+------+------+------+\n
      \    (1)  Incomplete TTTs (IT) are Target Transfer Tags on which the\n          target
      is still expecting PDUs to be received.  Examples\n          include TTTs received
      via R2T, NOP-In, etc.\n     (2)  Immediate Commands (IC) are immediate commands,
      but waiting\n          for execution on a target (for example, ABORT TASK SET).\n
      \    (5)  Connection Tasks (CT) are tasks that are active on the iSCSI\n          connection
      in question.\n     (6)  Session Tasks (ST) are tasks that are active on the
      entire\n          iSCSI session.  A union of \"connection tasks\" on all\n          participating
      connections.\n     (7)  Partial PDUs (PP) (if any) are PDUs that are partially
      sent\n          and waiting for transport window credit to complete the\n          transmission.\n
      \    (8)  Connection failure is a connection exception condition - one\n          of
      the transport connections shut down, transport connections\n          reset,
      or transport connections timed out, which abruptly\n          terminated the
      iSCSI Full Feature Phase connection.  A\n          connection failure always
      takes the connection state machine\n          to the CLEANUP_WAIT state.\n     (9)
      \ Connection state timeout happens if a connection spends more\n          time
      than agreed upon during login negotiation in the\n          CLEANUP_WAIT state,
      and this takes the connection to the FREE\n          state (M1 transition in
      connection cleanup state diagram; see\n          Section 8.2).\n     (10) Session
      timeout, closure, and reinstatement are defined in\n          Section 6.3.5.\n
      \    (11) This clearing effect is \"Y\" only if it is a connection\n          reinstatement
      and the operational ErrorRecoveryLevel is less\n          than 2.\n     (12)
      Session continuation is defined in Section 6.3.6.\n     (13) This clearing effect
      is only valid if the connection is being\n          logged out on a different
      connection and when the connection\n          being logged out on the target
      may have some partial PDUs\n          pending to be sent.  In all other cases,
      the effect is \"NA\".\n     (14) This clearing effect is only valid for a \"close
      the session\"\n          logout in a multi-connection session.  In all other
      cases, the\n          effect is \"NA\".\n     (15) Only applicable if this leading
      connection login is a session\n          reinstatement.  If this is not the
      case, it is \"NA\".\n     (16) This operation affects all logged-in initiators.\n
      \    (18) Session failure is defined in Section 6.3.6.\n     (19) This operation
      affects all logged-in initiators, and the\n          clearing effects are only
      applicable to the LU being reset.\n     (20) With standard multi-task abort
      semantics (Section 4.2.3.3), a\n          TARGET WARM RESET or a TARGET COLD
      RESET or a LU reset would\n          clear the active TTTs upon completion.
      \ However, the FastAbort\n          multi-task abort semantics defined by Section
      4.2.3.4 do not\n          guarantee that the active TTTs are cleared by the
      end of the\n          reset operations.  In fact, the FastAbort semantics are\n
      \         designed to allow clearing the TTTs in a \"lazy\" fashion after\n
      \         the TMF Response is delivered.  Thus, when\n          TaskReporting=FastAbort
      (Section 13.23) is operational on a\n          session, the clearing effects
      of reset operations on\n          \"Incomplete TTTs\" is \"N\".\n                           +------+-------+------+------+-------+\n
      \                          |DC (1)|DD (2) |SS (3)|CS (4)|DS (5) |\n     +---------------------+------+-------+------+------+-------+\n
      \    |connection failure   |N     |Y      |N     |N     |N      |\n     +---------------------+------+-------+------+------+-------+\n
      \    |connection state     |Y     |NA     |Y     |N     |NA     |\n     |timeout
      \             |      |       |      |      |       |\n     +---------------------+------+-------+------+------+-------+\n
      \    |session timeout/     |Y     |Y      |Y (7) |Y     |NA     |\n     |closure/reinstatement|
      \     |       |      |      |       |\n     +---------------------+------+-------+------+------+-------+\n
      \    |session continuation |N (11)|NA (12)|NA    |N     |NA (13)|\n     +---------------------+------+-------+------+------+-------+\n
      \    |successful connection|Y     |Y      |Y     |N     |NA     |\n     |close
      Logout         |      |       |      |      |       |\n     +---------------------+------+-------+------+------+-------+\n
      \    |session failure      |N     |Y      |N     |N     |N      |\n     +---------------------+------+-------+------+------+-------+\n
      \    |successful recovery  |Y     |Y      |Y     |N     |N      |\n     |Logout
      \              |      |       |      |      |       |\n     +---------------------+------+-------+------+------+-------+\n
      \    |failed Logout        |N     |Y (9)  |N     |N     |N      |\n     +---------------------+------+-------+------+------+-------+\n
      \    |connection Login     |NA    |NA     |N (8) |N (8) |NA     |\n     |(leading
      \            |      |       |      |      |       |\n     +---------------------+------+-------+------+------+-------+\n
      \    |connection Login     |N (11)|NA (12)|N (8) |N     |NA (13)|\n     |(non-leading)
      \       |      |       |      |      |       |\n     +---------------------+------+-------+------+------+-------+\n
      \    |TARGET COLD RESET    |Y     |Y      |Y     |Y (10)|NA     |\n     +---------------------+------+-------+------+------+-------+\n
      \    |TARGET WARM RESET    |Y     |Y      |N     |N     |NA     |\n     +---------------------+------+-------+------+------+-------+\n
      \    |LU reset             |N     |Y      |N     |N     |N      |\n     +---------------------+------+-------+------+------+-------+\n
      \    |power cycle          |Y     |Y      |Y     |Y (10)|NA     |\n     +---------------------+------+-------+------+------+-------+\n
      \    (1)  Discontiguous Commands (DC) are commands allegiant to the\n          connection
      in question and waiting to be reordered in the\n          iSCSI layer.  All
      \"Y\"s in this column assume that the task\n          causing the event (if
      indeed the event is the result of a\n          task) is issued as an immediate
      command, because the\n          discontiguities can be ahead of the task.\n
      \    (2)  Discontiguous Data (DD) are data PDUs received for the task in\n          question
      and waiting to be reordered due to prior\n          discontiguities in the DataSN.\n
      \    (3)  \"SS\" refers to the StatSN.\n     (4)  \"CS\" refers to the CmdSN.\n
      \    (5)  \"DS\" refers to the DataSN.\n     (7)  This action clears the StatSN
      on all the connections.\n     (8)  This sequence number is instantiated on this
      event.\n     (9)  A logout failure drives the connection state machine to the\n
      \         CLEANUP_WAIT state, similar to the connection failure event.\n          Hence,
      it has a similar effect on this and several other\n          protocol aspects.\n
      \    (10) This is cleared by virtue of the fact that all sessions with\n          all
      initiators are terminated.\n     (11) This clearing effect is \"Y\" if it is
      a connection\n          reinstatement.\n     (12) This clearing effect is \"Y\"
      only if it is a connection\n          reinstatement and the operational ErrorRecoveryLevel
      is 2.\n     (13) This clearing effect is \"N\" only if it is a connection\n
      \         reinstatement and the operational ErrorRecoveryLevel is 2.\n"
    title: E.1.  Clearing Effects on iSCSI Objects
  - contents:
    - "E.2.  Clearing Effects on SCSI Objects\n   The only iSCSI protocol action that
      can effect clearing actions on\n   SCSI objects is the \"I_T nexus loss\" notification
      (Section 6.3.5.1\n   (\"Loss of Nexus Notification\")).  [SPC3] describes the
      clearing\n   effects of this notification on a variety of SCSI attributes.  In\n
      \  addition, SCSI standards documents (such as [SAM2] and [SBC2]) define\n   additional
      clearing actions that may take place for several SCSI\n   objects on SCSI events
      such as LU resets and power-on resets.\n   Since iSCSI defines a TARGET COLD
      RESET as a \"protocol-equivalent\" to\n   a target power-cycle, the iSCSI TARGET
      COLD RESET must also be\n   considered as the power-on reset event in interpreting
      the actions\n   defined in the SCSI standards.\n   When the iSCSI session is
      reconstructed (between the same SCSI ports\n   with the same nexus identifier)
      reestablishing the same I_T nexus,\n   all SCSI objects that are defined to
      not clear on the \"I_T nexus\n   loss\" notification event, such as persistent
      reservations, are\n   automatically associated to this new session.\n"
    title: E.2.  Clearing Effects on SCSI Objects
  title: Appendix E.  Clearing Effects of Various Events on Targets
- contents:
  - "Acknowledgments\n   Several individuals on the original IPS Working Group made\n
    \  significant contributions to the original RFCs 3720, 3980, 4850,\n   and 5048.\n
    \  Specifically, the authors of the original RFCs -- which herein are\n   consolidated
    into a single document -- were the following:\n      RFC 3720: Julian Satran,
    Kalman Meth, Costa Sapuntzakis,\n      Mallikarjun Chadalapaka, Efri Zeidner\n
    \     RFC 3980: Marjorie Krueger, Mallikarjun Chadalapaka, Rob Elliott\n      RFC
    4850: David Wysochanski\n      RFC 5048: Mallikarjun Chadalapaka\n   Many thanks
    to Fred Knight for contributing to the UML notations and\n   drawings in this
    document.\n   We would in addition like to acknowledge the following individuals\n
    \  who contributed to this revised document: David Harrington, Paul\n   Koning,
    Mark Edwards, Rob Elliott, and Martin Stiemerling.\n   Thanks to Yi Zeng and Nico
    Williams for suggesting and/or reviewing\n   Kerberos-related security considerations
    text.\n   The authors gratefully acknowledge the valuable feedback during the\n
    \  Last Call review process from a number of individuals; their feedback\n   significantly
    improved this document.  The individuals were Stephen\n   Farrell, Brian Haberman,
    Barry Leiba, Pete Resnick, Sean Turner,\n   Alexey Melnikov, Kathleen Moriarty,
    Fred Knight, Mike Christie, Qiang\n   Wang, Shiv Rajpal, and Andy Banta.\n   Finally,
    this document also benefited from significant review\n   contributions from the
    Storm Working Group at large.\n   Comments may be sent to Mallikarjun Chadalapaka.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Mallikarjun Chadalapaka\n   Microsoft\n   One Microsoft
    Way\n   Redmond, WA  98052\n   USA\n   EMail: cbm@chadalapaka.com\n   Julian Satran\n
    \  Infinidat Ltd.\n   EMail: julians@infinidat.com, julian@satran.net\n   Kalman
    Meth\n   IBM Haifa Research Lab\n   Haifa University Campus - Mount Carmel\n   Haifa
    31905, Israel\n   Phone +972.4.829.6341\n   EMail: meth@il.ibm.com\n   David L.
    Black\n   EMC Corporation\n   176 South St.\n   Hopkinton, MA  01748\n   USA\n
    \  Phone +1 (508) 293-7953\n   EMail: david.black@emc.com\n"
  title: Authors' Addresses
