- contents:
  - '   Kerberos Principal Name Canonicalization and Cross-Realm Referrals

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This memo documents a method for a Kerberos Key Distribution Center\n
    \  (KDC) to respond to client requests for Kerberos tickets when the\n   client
    does not have detailed configuration information on the realms\n   of users or
    services.  The KDC will handle requests for principals in\n   other realms by
    returning either a referral error or a cross-realm\n   Ticket-Granting Ticket
    (TGT) to another realm on the referral path.\n   The clients will use this referral
    information to reach the realm of\n   the target principal and then receive the
    ticket.  This memo also\n   provides a mechanism for verifying that a request
    has not been\n   tampered with in transit.  This memo updates RFC 4120.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6806.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n   2.  Conventions Used in This Document  . . . . . . . . . .
    . . . .  4\n   3.  Requesting a Referral  . . . . . . . . . . . . . . . . . .
    . .  4\n   4.  Realm Organization Model . . . . . . . . . . . . . . . . . . .
    \ 5\n     4.1.  Trust Assumptions  . . . . . . . . . . . . . . . . . . . .  5\n
    \  5.  Enterprise Principal Name Type . . . . . . . . . . . . . . . .  6\n   6.
    \ Name Canonicalization  . . . . . . . . . . . . . . . . . . . .  7\n   7.  Client
    Referrals . . . . . . . . . . . . . . . . . . . . . . .  9\n   8.  Server Referrals
    . . . . . . . . . . . . . . . . . . . . . . . 10\n   9.  Cross-Realm Routing  .
    . . . . . . . . . . . . . . . . . . . . 11\n   10. Caching Information  . . .
    . . . . . . . . . . . . . . . . . . 11\n   11. Negotiation of FAST and Detecting
    Modified Requests  . . . . . 12\n   12. IANA Considerations  . . . . . . . . .
    . . . . . . . . . . . . 13\n   13. Security Considerations  . . . . . . . . .
    . . . . . . . . . . 13\n     13.1. Shared-Password Case . . . . . . . . . . .
    . . . . . . . . 16\n     13.2. Pre-Authentication Data  . . . . . . . . . . .
    . . . . . . 16\n   14. Acknowledgments  . . . . . . . . . . . . . . . . . . .
    . . . . 17\n   15. References . . . . . . . . . . . . . . . . . . . . . . . .
    . . 17\n     15.1. Normative References . . . . . . . . . . . . . . . . . . .
    17\n     15.2. Informative References . . . . . . . . . . . . . . . . . . 17\n
    \  Appendix A.  Compatibility with Earlier Implementations of\n                Name
    Canonicalization . . . . . . . . . . . . . . . . 18\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Current implementations of the Kerberos Authentication Service
    (AS)\n   and Ticket-Granting Service (TGS) protocols, as defined in [RFC4120],\n
    \  use principal names constructed from a known user or service name and\n   realm.
    \ A service name is typically constructed from a name of the\n   service and the
    DNS host name of the computer that is providing the\n   service.  Many existing
    deployments of Kerberos use a single Kerberos\n   realm where all users and services
    would be using the same realm.\n   However, in an environment where there are
    multiple Kerberos realms,\n   the client needs to be able to determine what realm
    a particular user\n   or service is in before making an AS or TGS request.  Traditionally,\n
    \  this requires client configuration to make this possible.\n   When having to
    deal with multiple realms, users are forced to know\n   what realm they are in
    before they can obtain a Ticket-Granting\n   Ticket (TGT) with an AS request.
    \ However, in many cases, the user\n   would like to use a more familiar name
    that is not directly related\n   to the realm of their Kerberos principal name.
    \ A good example of\n   this is an email name in the style described in [RFC5322].
    \ This\n   document describes a mechanism that would allow a user to specify a\n
    \  user principal name that is an alias for the user's Kerberos\n   principal
    name.  In practice, this would be the name that the user\n   specifies to obtain
    a TGT from a Kerberos KDC.  The user principal\n   name no longer has a direct
    relationship with the Kerberos principal\n   or realm.  Thus, the administrator
    is able to move the user's\n   principal to other realms without the user having
    to know that it\n   happened.\n   Once a TGT has been obtained, the user would
    like to be able to\n   access services in any Kerberos realm for which there is
    an\n   authentication path from the realm of their principal.  To do this\n   requires
    that the client be able to determine what realm the target\n   service principal
    is in before making the TGS request.  Current\n   implementations of Kerberos
    typically have a table that maps DNS host\n   names to corresponding Kerberos
    realms.  The user-supplied host name\n   or its domain component is looked up
    in this table (often using the\n   result of some form of host name lookup performed
    with insecure DNS\n   queries, in violation of [RFC4120]).  The corresponding
    realm is then\n   used to complete the target service principal name.  Even if
    insecure\n   DNS queries were not used, managing this table is problematic.\n
    \  This traditional mechanism requires that each client have very\n   detailed
    configuration information about the hosts that are providing\n   services and
    their corresponding realms.  Having client-side\n   configuration information
    can be very costly from an administration\n   point of view -- especially if there
    are many realms and computers in\n   the environment.\n   This memo proposes a
    solution for these problems and simplifies\n   administration by minimizing the
    configuration information needed on\n   each computer using Kerberos.  Specifically,
    it describes a mechanism\n   to allow the KDC to handle canonicalization of names,
    provide for\n   principal aliases for users and services, and allow the KDC to\n
    \  determine the trusted realm authentication path by being able to\n   generate
    referrals to other realms in order to locate principals.\n   Two kinds of KDC
    referrals are introduced in this memo:\n   1. Client referrals, in which the client
    doesn't know which realm\n      contains a user account.\n   2. Server referrals,
    in which the client doesn't know which realm\n      contains a server account.\n
    \  These two types of referrals introduce new opportunities for an\n   attacker.
    \ In order to avoid these attacks, a mechanism is provided\n   to protect the
    integrity of the request between the client and KDC.\n   This mechanism complements
    the Flexible Authentication Secure Tunnels\n   (FAST) facility provided in [RFC6113].
    \ A mechanism is provided to\n   negotiate the availability of FAST.  Among other
    benefits, this can\n   be used to protect errors generated by the referral process.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
    in [RFC2119].\n"
  title: 2.  Conventions Used in This Document
- contents:
  - "3.  Requesting a Referral\n   In order to request referrals as defined in later
    sections, the\n   Kerberos client MUST explicitly request the \"canonicalize\"
    KDC option\n   (bit 15) [RFC4120] for the AS-REQ or TGS-REQ.  This flag indicates
    to\n   the KDC that the client is prepared to receive a reply that contains\n
    \  a principal name other than the one requested.\n          KDCOptions ::= KerberosFlags\n
    \                  -- canonicalize (15)\n                   -- other KDCOptions
    values omitted\n   When sending names with the \"canonicalize\" KDC option, the
    client\n   should expect that names in the KDC's reply MAY be different than the\n
    \  name in the request.  A referral TGT is a cross-realm TGT that is\n   returned
    with the server name of the ticket being different from the\n   server name in
    the request [RFC4120].\n"
  title: 3.  Requesting a Referral
- contents:
  - "4.  Realm Organization Model\n   This memo assumes that the world of principals
    is arranged on\n   multiple levels: the realm, the enterprise, and the world.
    \ A KDC may\n   issue tickets for any principal in its realm or cross-realm tickets\n
    \  for realms with which it has a direct cross-realm relationship.  The\n   KDC
    also has access to a trusted name service that can resolve any\n   name from within
    its enterprise into a realm closer along the\n   authentication path to the service.
    \ This trusted name service\n   removes the need to use an untrusted DNS lookup
    for name resolution.\n   For example, consider the following configuration, where
    lines\n   indicate cross-realm relationships:\n                      EXAMPLE.COM\n
    \                     /        \\\n                     /          \\\n          ADMIN.EXAMPLE.COM
    \ DEV.EXAMPLE.COM\n   In this configuration, all users in the EXAMPLE.COM enterprise
    could\n   have principal names, such as alice@EXAMPLE.COM, with the same realm\n
    \  portion.  In addition, servers at EXAMPLE.COM should be able to have\n   DNS
    host names from any DNS domain independent of what Kerberos realm\n   their principals
    reside in.\n"
  - contents:
    - "4.1.  Trust Assumptions\n   Two realms participate in any cross-realm relationship:
      an issuing\n   realm issues a cross-realm ticket, and a consuming realm uses
      this\n   ticket.  There is a degree of trust of the issuing realm by the\n   consuming
      realm implied by this relationship.  Whenever a service in\n   the consuming
      realm permits an authentication path containing the\n   issuing realm, that
      service trusts the issuing realm to accurately\n   represent the identity of
      the authenticated principal and any\n   information about the transited path.
      \ If the consuming realm's KDC\n   sets the transited policy checked flag, the
      KDC is making the same\n   trust assumption that a service would.\n   This trust
      is transitive across a multi-hop authentication path.  The\n   service's realm
      trusts each hop along the authentication path closer\n   to the client to accurately
      represent the authenticated identity and\n   to accurately represent transited
      information.  Any KDC along this\n   path could impersonate the client.\n   KDC-signed
      or -issued authorization data often implies additional\n   trust.  The implications
      of such trust from a security and\n   operational standpoint is an ongoing topic
      of discussion during the\n   development of this specification.  As such, such
      discussion is out\n   of scope for this memo.\n   Administrators have several
      tools to limit trust caused by cross-\n   realm relationships.  A service or
      KDC can control what\n   authentication paths are acceptable.  For example,
      if a given realm\n   is not permitted on the authentication path for a particular
      client,\n   then that realm cannot affect trust placed in that client principal.\n
      \  Consuming realms can exercise significant control by deciding what\n   principals
      to place on an access-control list.  If no client using a\n   given issuing
      realm in authentication paths is permitted to access a\n   resource, then that
      issuing realm is not trusted in access decisions\n   regarding that resource.\n
      \  Creating a cross-realm relationship implies relatively little\n   inherent
      trust in the issuing realm.  Significant trust only applies\n   as principals
      dependent on that issuing realm are given access to\n   resources.  However,
      two deployment characteristics may increase the\n   trust implied by the initial
      cross-realm relationship.  First, a\n   number of realms provide access to any
      principal to some resources.\n   Access decisions involving these resources
      involve a degree of trust\n   in all issuing realms in the transited graph.
      \ Secondly, many realms\n   do not constrain the set of principals to which
      users of that realm\n   may grant access.  In these realms, creating a cross-realm\n
      \  relationship delegates the decision to trust that realm to users of\n   the
      consuming realm.  In this situation, creating the cross-realm\n   relationship
      is the primary trust decision point under the\n   administrator's control.\n"
    title: 4.1.  Trust Assumptions
  title: 4.  Realm Organization Model
- contents:
  - "5.  Enterprise Principal Name Type\n   The NT-ENTERPRISE type principal name
    contains one component, a\n   string of realm-defined content, which is intended
    to be used as an\n   alias for another principal name in some realm in the enterprise.
    \ It\n   is used for conveying the alias name, not for the real principal\n   names
    within the realms, and thus is only useful when name\n   canonicalization is requested.\n
    \  The intent is to allow unification of email and security principal\n   names.
    \ For example, all users at EXAMPLE.COM may have a client\n   principal name of
    the form \"joe@EXAMPLE.COM\", even though the\n   principals are contained in
    multiple realms.  This global name is\n   again an alias for the true client principal
    name, which indicates\n   what realm contains the principal.  Thus, accounts \"alice\"
    in the\n   realm DEV.EXAMPLE.COM and \"bob\" in ADMIN.EXAMPLE.COM may log on as\n
    \  \"alice@EXAMPLE.COM\" and \"bob@EXAMPLE.COM\".\n   This utilizes a new principal
    name type, as the KDC-REQ message only\n   contains a single client realm (crealm)
    field, and the realm portion\n   of this name corresponds to the Kerberos realm
    with which the request\n   is made.  Thus, the entire name \"alice@EXAMPLE.COM\"
    is transmitted as\n   a single component in the client name field of the AS-REQ
    message,\n   with a name type of NT-ENTERPRISE [RFC4120] (and the local realm\n
    \  name).  The KDC will recognize this name type and then transform the\n   requested
    name into the true principal name if the client account\n   resides in the local
    realm.  The true principal name can have a name\n   type different from the requested
    name type.  Typically, the true\n   principal name will be an NT-PRINCIPAL [RFC4120].\n"
  title: 5.  Enterprise Principal Name Type
- contents:
  - "6.  Name Canonicalization\n   A service or account may have multiple principal
    names.  For example,\n   if a host is known by multiple names, host-based services
    on it may\n   be known by multiple names in order to prevent the client from\n
    \  needing a secure directory service to determine the correct host name\n   to
    use.  In order to avoid the need to update the host whenever a new\n   alias is
    created, the KDC may provide the mapping information to the\n   client in the
    credential acquisition process.\n   If the \"canonicalize\" KDC option is set,
    then the KDC MAY change the\n   client and server principal names and types in
    the AS response and\n   ticket returned from those in the request.  Names MUST
    NOT be changed\n   in the response to a TGS request, although it is common for
    KDCs to\n   maintain a set of aliases for service principals.  Regardless of\n
    \  which alias a client requests, the same service key is used.\n   However, in
    the TGS request, the client receives a ticket for the\n   alias requested.  Services
    MUST NOT make distinctions based on which\n   alias is in the issued ticket, because
    the service name in a ticket\n   is not cryptographically protected and can be
    changed by parties\n   other than the KDC.\n   For example, the AS request may
    specify a client name of \"bob@\n   EXAMPLE.COM\" as an NT-ENTERPRISE name with
    the \"canonicalize\" KDC\n   option set, and the KDC will return with a client
    name of \"104567\" as\n   an NT-UID [RFC4120].\n   (It is assumed that the client
    discovers whether the KDC supports the\n   NT-ENTERPRISE name type via out-of-band
    mechanisms.)\n   See Section 11 for a mechanism to detect modification of the
    request\n   between the client and KDC.  However, for the best protection,\n   Flexible
    Authentication Secure Tunneling (FAST) [RFC6113] or another\n   mechanism that
    protects the entire KDC exchange SHOULD be used.\n   Clients MAY reject responses
    from a KDC where the client or server\n   name is changed if the KDC does not
    support such a mechanism.\n   Clients SHOULD reject an AS response that changes
    the server name\n   unless the response is protected by such a mechanism or the
    new\n   server name is one explicitly expected by the client.  For example,\n
    \  many clients permit the realm name to be changed in an AS response,\n   even
    if the response is not protected.  See Section 13 for a\n   discussion of the
    tradeoffs in allowing unprotected responses.\n   In order to permit authorization
    decisions to be made based on\n   aliases as well as the canonicalized form of
    a principal name, the\n   KDC MAY include the following authorization data element,
    wrapped in\n   AD-KDC-ISSUED, in the initial credentials and copy it from a ticket-\n
    \  granting ticket into additional credentials:\n   AD-LOGIN-ALIAS ::= SEQUENCE
    { -- ad-type number 80 --\n     login-aliases  [0] SEQUENCE (SIZE (1..MAX)) OF
    PrincipalName,\n     ...\n   }\n   The login-aliases field lists one or more of
    the aliases the\n   principal is known by.\n   In addition to permitting authorization
    based on aliases, this\n   permits user-to-user exchanges where the party receiving
    the\n   authenticator knows the other party only by an alias.  The recipient\n
    \  of such an authenticator SHOULD check the AD-LOGIN-ALIAS names, if\n   present,
    in addition to the normal client name field, against the\n   identity of the party
    with which it wishes to authenticate; either\n   should be allowed to match.  (Note
    that this is not backwards\n   compatible with [RFC4120]; if the server side of
    the user-to-user\n   exchange does not support this extension and does not know
    the true\n   principal name, authentication may fail if the alias is sought in
    the\n   client name field.)\n   The use of AD-KDC-ISSUED authorization data elements
    in cross-realm\n   cases has not been well explored at this writing; hence, we
    will only\n   specify the inclusion of this data in the one-realm case.  The AD-\n
    \  LOGIN-ALIAS information SHOULD be dropped in the general cross-realm\n   case.
    \ However, a realm MAY implement a policy of accepting and\n   re-signing (wrapping
    in a new AD-KDC-ISSUED element) alias\n   information provided by certain trusted
    realms in the cross-realm\n   ticket-granting service.\n   The canonical principal
    name for an alias MUST NOT be in the form of\n   a ticket-granting service name,
    as (in a case of server name\n   canonicalization) that would be construed as
    a case of cross-realm\n   referral, described below.\n"
  title: 6.  Name Canonicalization
- contents:
  - "7.  Client Referrals\n   The simplest form of ticket referral is for a user requesting
    a\n   ticket using an AS-REQ.  In this case, the client machine will send\n   the
    AS-REQ to a convenient realm trusted to map principals, for\n   example, the realm
    of the client machine.  In the case of the name\n   alice@EXAMPLE.COM, the client
    MAY optimistically choose to send the\n   request to EXAMPLE.COM.  The realm in
    the AS-REQ is always the name\n   of the realm that the request is for, as specified
    in [RFC4120].\n   The KDC will try to lookup the name in its local account database.\n
    \  If the account is present in the realm of the request, it SHOULD\n   return
    a KDC reply with the appropriate ticket.\n   If the account is not present in
    the realm specified in the request\n   and the \"canonicalize\" KDC option is
    set, the KDC may look up the\n   client principal name using some kind of name
    service or directory\n   service.  If this lookup is unsuccessful, it MUST return
    the error\n   KDC_ERR_C_PRINCIPAL_UNKNOWN [RFC4120].  If the lookup is successful,\n
    \  it MUST return an error KDC_ERR_WRONG_REALM [RFC4120]; in the error\n   message,
    the crealm field will contain either the true realm of the\n   client or another
    realm that MAY have better information about the\n   client's true realm.  The
    client MUST NOT use the cname returned in\n   this error message.\n   If the client
    receives a KDC_ERR_WRONG_REALM error, it will issue a\n   new AS request with
    the same client principal name used to generate\n   the first AS request to the
    realm specified by the realm field of the\n   Kerberos error message corresponding
    to the first request.  (The\n   client realm name will be updated in the new request
    to refer to this\n   new realm.)  The client SHOULD repeat these steps until it
    finds the\n   true realm of the client.  To avoid infinite referral loops, an\n
    \  implementation should limit the number of referrals.  A suggested\n   limit
    is 5 referrals before giving up.\n   Since the same client name is sent to the
    referring and referred-to\n   realms, both realms must recognize the same client
    names.  In\n   particular, the referring realm cannot (usefully) define principal\n
    \  name aliases that the referred-to realm will not know.\n   The true principal
    name of the client, returned in AS-REP, can be\n   validated in a subsequent TGS
    message exchange where its value is\n   communicated back to the KDC via the authenticator
    in the PA-TGS-REQ\n   padata [RFC4120].  However, this requires trusting the referred-to\n
    \  realm's KDCs.  Clients should limit the referral mappings they will\n   accept
    to realms trusted via some local policy.  Some possible\n   factors that might
    be taken into consideration for such a policy\n   might include:\n   o  Any realm
    indicated by the local KDC if the returned KRB-ERROR\n      message is protected
    by some additional means, for example, FAST\n   o  A list of realms configured
    by an administrator\n   o  Any realm accepted by the user when explicitly prompted\n
    \  One common approach for limiting the realms from which referrals are\n   accepted
    is to limit referrals to realms that can construct an\n   authentication path
    back to the service principal of the local\n   machine.  This tends to work well
    when realms are generally within an\n   organization and all realms that can form
    an authentication path back\n   to the local machine have some reasonable level
    of mapping trust.\n   Deployments involving more complex trust, for example, high\n
    \  probability of malicious realms, are likely to need more complex\n   policy
    and MAY need to prompt the user before accepting some\n   referrals.\n   There
    is currently no provision for changing the client name in a\n   client referral
    response.\n"
  title: 7.  Client Referrals
- contents:
  - "8.  Server Referrals\n   The primary difference in server referrals is that the
    KDC returns a\n   referral TGT rather than an error message as is done in the
    client\n   referrals.\n   If the \"canonicalize\" flag in the KDC options is set
    and the KDC\n   doesn't find the principal locally, either as a regular principal
    or\n   as an alias for another local principal, the KDC MAY return a cross-\n
    \  realm ticket-granting ticket to the next hop on the trust path\n   towards
    a realm that may be able to resolve the principal name.\n   The client will use
    this referral information to request a chain of\n   cross-realm ticket-granting
    tickets until it reaches the realm of the\n   server, and can then expect to receive
    a valid service ticket.\n   However, an implementation should limit the number
    of referrals that\n   it processes to avoid infinite referral loops.  A suggested
    limit is\n   5 referrals before giving up.\n   The client may cache the mapping
    of the requested name to the name of\n   the next realm to use and the principal
    name to ask for (see\n   Section 10).\n   Here is an example of a client requesting
    a service ticket for a\n   service in realm DEV.EXAMPLE.COM where the client is
    in\n   ADMIN.EXAMPLE.COM.\n      +NC = Canonicalize KDCOption set\n      C: TGS-REQ
    sname=http/foo.dev.example.com +NC to ADMIN.EXAMPLE.COM\n      S: TGS-REP sname=krbtgt/EXAMPLE.COM@ADMIN.EXAMPLE.COM\n
    \     C: TGS-REQ sname=http/foo.dev.example.com +NC to EXAMPLE.COM\n      S: TGS-REP
    sname=krbtgt/DEV.EXAMPLE.COM@EXAMPLE.COM\n      C: TGS-REQ sname=http/foo.dev.example.com
    +NC to DEV.EXAMPLE.COM\n      S: TGS-REP sname=http/foo.dev.example.com@DEV.EXAMPLE.COM\n
    \  Note that any referral or alias processing of the server name in\n   user-to-user
    authentication should use the same data as client name\n   canonicalization or
    referral.  Otherwise, the name used by one user\n   to log in may not be useable
    by another for user-to-user\n   authentication to the first.\n"
  title: 8.  Server Referrals
- contents:
  - "9.  Cross-Realm Routing\n   RFC 4120 permits a KDC to return a closer referral
    ticket when a\n   cross-realm TGT is requested.  This specification extends this\n
    \  behavior when the canonicalize flag is set.  When this flag is set, a\n   KDC
    MAY return a TGT for a realm closer to the service for any\n   service as discussed
    in the previous section.  When a client follows\n   such a referral, it includes
    the realm of the referred-to realm in\n   the generated request.\n   When the
    canonicalize flag is not set, the rules defined in RFC 4120\n   apply.\n"
  title: 9.  Cross-Realm Routing
- contents:
  - "10.  Caching Information\n   It is possible that the client may wish to get additional
    credentials\n   for the same service principal, perhaps with different authorization-\n
    \  data restrictions or other changed attributes.  The return of a\n   server
    referral from a KDC can be taken as an indication that the\n   requested principal
    does not currently exist in the local realm.\n   Clearly, it would reduce network
    traffic if the clients could cache\n   that information and use it when acquiring
    the second set of\n   credentials for a service, rather than always having to
    recheck with\n   the local KDC to see if the name has been created locally.\n
    \  When the TGT expires, the previously returned referral from the local\n   KDC
    should be considered invalid, and the local KDC must be asked\n   again for information
    for the desired service principal name.  (Note\n   that the client may get back
    multiple referral TGTs from the local\n   KDC to the same remote realm, with different
    lifetimes.  The lifetime\n   information SHOULD be properly associated with the
    requested service\n   principal names.  Simply having another TGT for the same
    remote realm\n   does not extend the validity of previously acquired information
    about\n   one service principal name.)\n   Accordingly, KDC authors and maintainers
    should consider what factors\n   (e.g., DNS alias lifetimes) they may or may not
    wish to incorporate\n   into credential expiration times in cases of referrals.\n"
  title: 10.  Caching Information
- contents:
  - "11.  Negotiation of FAST and Detecting Modified Requests\n   Implementations
    of this specification MUST support the FAST\n   negotiation mechanism described
    in this section.  This mechanism\n   provides detection of KDC requests modified
    by an attacker when those\n   requests result in a reply instead of an error.
    \ In addition, this\n   mechanism provides a secure way to detect if a KDC supports
    FAST.\n   Clients conforming to this specification MUST send new pre-\n   authentication
    data of type PA-REQ-ENC-PA-REP (149) in all AS\n   requests and MAY send this
    padata type in TGS requests.  The value of\n   this padata item SHOULD be empty
    and its value MUST be ignored by a\n   receiving KDC.  Sending this padata item
    indicates support for this\n   negotiation mechanism.  KDCs conforming to this
    specification must\n   always set the ticket flag enc-pa-rep (15) in all the issued
    tickets.\n   This ticket flag indicates KDC support for the mechanism.\n   The
    KDC response [RFC4120] is extended to support an additional field\n   containing
    encrypted pre-authentication data.\n          EncKDCRepPart   ::= SEQUENCE {\n
    \                key                [0] EncryptionKey,\n                 last-req
    \          [1] LastReq,\n                 nonce              [2] UInt32,\n                 key-expiration
    \    [3] KerberosTime OPTIONAL,\n                 flags              [4] TicketFlags,\n
    \                authtime           [5] KerberosTime,\n                 starttime
    \         [6] KerberosTime OPTIONAL,\n                 endtime            [7]
    KerberosTime,\n                 renew-till         [8] KerberosTime OPTIONAL,\n
    \                srealm             [9] Realm,\n                 sname             [10]
    PrincipalName,\n                 caddr             [11] HostAddresses OPTIONAL,\n
    \                encrypted-pa-data [12] SEQUENCE OF PA-DATA OPTIONAL\n         }\n
    \  The encrypted-pa-data element MUST be absent unless either the\n   \"canonicalize\"
    KDC option is set or the PA-REQ-ENC-PA-REP padata item\n   is sent.\n   If the
    PA-REQ-ENC-PA-REP padata item is sent in the request, then the\n   KDC MUST include
    a PA-REQ-ENC-PA-REP padata item in the encrypted-pa-\n   data item of any generated
    KDC reply.  The PA-REQ-ENC-PA-REP pa-data\n   value contains the checksum computed
    over the type AS-REQ or TGS-REQ\n   in the request.  The checksum key is the reply
    key and the checksum\n   type is the required checksum type for the encryption
    type of the\n   reply key, and the key usage number is KEY_USAGE_AS_REQ (56).
    \ If the\n   KDC supports FAST, then the KDC MUST include a padata of type PA-FX-\n
    \  FAST in any encrypted-pa-data sequence it generates.  The padata item\n   MUST
    be empty on sending, and the contents of the padata item MUST be\n   ignored on
    receiving.\n   A client MUST reject a response for which it sent PA-REQ-ENC-PA-REP\n
    \  if the ENC-PA-REP ticket flag is set and the PA-REQ-ENC-PA-REP padata\n   item
    is absent or the checksum is not successfully verified.\n"
  title: 11.  Negotiation of FAST and Detecting Modified Requests
- contents:
  - "12.  IANA Considerations\n   PA-REQ-ENC-PA-REP has been registered in the Kerveros
    \"Pre-\n   authentication and Typed Data\" registry\n   <http://www.iana.org/assignments/kerberos-parameters>.\n"
  title: 12.  IANA Considerations
- contents:
  - "13.  Security Considerations\n   For the AS exchange case, it is important that
    the logon mechanism\n   not trust a name that has not been used to authenticate
    the user.\n   For example, the name that the user enters as part of a logon\n
    \  exchange may not be the name that the user authenticates as, given\n   that
    the KDC_ERR_WRONG_REALM error may have been returned.  The\n   relevant Kerberos
    naming information for logon (if any) is the client\n   name and client realm
    in the service ticket targeted at the\n   workstation obtained using the user's
    initial TGT.  That is, rather\n   than trusting the client name in the AS response,
    a workstation\n   SHOULD perform an AP-REQ authentication against itself as a
    service\n   and use the client name in the ticket issued for its service by the\n
    \  KDC.\n   How the client name and client realm are mapped into a local account\n
    \  for logon is a local matter, but the client logon mechanism MUST use\n   additional
    information such as the client realm and/or authorization\n   attributes from
    the service ticket presented to the workstation by\n   the user when mapping the
    logon credentials to a local account on the\n   workstation.\n   Not all fields
    in a KDC reply defined by RFC 4120 are protected.\n   None of the fields defined
    in RFC 4120 for AS request are protected,\n   and some information in a TGS request
    may not be protected.  The\n   referrals mechanism creates several opportunities
    for attack because\n   of these unprotected fields.  FAST [RFC6113] can be used
    to\n   completely mitigate these issues by protecting both the KDC request\n   and
    response.  However, FAST requires that a client obtain an armor\n   ticket before
    authenticating.  Not all realms permit all clients to\n   obtain armor tickets.
    \ Also, while it is expected to be uncommon, a\n   client might wish to use name
    canonicalization while obtaining an\n   armor ticket.  The mechanism described
    in Section 11 detects\n   modification of the request between the KDC and client,
    mitigating\n   some attacks.\n   There is a widely deployed base of implementations
    that use name\n   canonicalization or server referrals that use neither the negotiation\n
    \  mechanism nor FAST.  So, implementations may be faced with only the\n   limited
    protection afforded by RFC 4120, by the negotiation mechanism\n   discussed in
    this document, or by FAST.  All three situations are\n   important to consider
    from a security standpoint.\n   An attacker cannot mount a downgrade attack against
    a client.  The\n   negotiation mechanism described in this document is securely\n
    \  indicated by the presence of a ticket flag.  So, a client will detect\n   if
    the facility was available but not used.  It is possible for an\n   attacker to
    strip the indication that a client supports the\n   negotiation facility.  The
    client will learn from the response that\n   this happened, but the KDC will not
    learn that the client is\n   attacked.  So, for a single round-trip Kerberos exchange,
    the KDC may\n   believe the exchange was successful when the client detects an\n
    \  attack.  Packet loss or client failure can produce a similar result;\n   this
    is not a significant vulnerability.  The negotiation facility\n   described in
    this document securely indicates the presence of FAST.\n   So, if a client wishes
    to use FAST when it is available, an attacker\n   cannot force the client to downgrade
    away from FAST.  An attacker MAY\n   be able to prevent a client from obtaining
    an armor ticket, for\n   example, by responding to a request for anonymous Public
    Key\n   Cryptography for Initial Authentication in Kerberos (PKINIT) with an\n
    \  error response.\n   If FAST is used, then the communications between the client
    and KDC\n   are protected.  However, name canonicalization places a new\n   responsibility
    for mapping principals onto the KDC.  This can\n   increase the number of KDCs
    involved in an authentication, which adds\n   additional trusted third parties
    to the exchange.\n   If only the negotiation mechanism is used, then the request
    from the\n   client to the KDC is protected, but not all of the response is\n
    \  protected.  In particular, the client name is not protected; the\n   ticket
    is also not protected.  An attacker can potentially modify\n   these fields.  Modification
    of the client name will result in a\n   denial of service.  When the client attempts
    to authenticate to a\n   service (including the TGS), it constructs an AP-REQ
    message.  This\n   message includes a client name that MUST match the client name
    in the\n   ticket according to RFC 4120.  Thus, if the client name is changed,\n
    \  the resulting ticket will fail when used.  This is undesirable\n   because
    the authentication is separated from the later failure, which\n   may confuse
    problem determination.  If the ticket is replaced with\n   another ticket, then
    later authentication to a service will fail\n   because the client will not know
    the session key for the other\n   ticket.  If the ticket is simply modified, then
    authentication to a\n   service will fail as with RFC 4120.  More significant
    attacks are\n   possible if a KDC violates the requirements of RFC 4120 and issues\n
    \  two tickets with the same session key, or if a service violates the\n   requirements
    of RFC 4120 and does not check the client name against\n   that in the ticket.\n
    \  There is an additional attack possible when FAST is not used against\n   KDC_ERR_WRONG_REALM.
    \ Since this is an error response, not an AS\n   response, it is not protected
    by the negotiation mechanism.  Thus, an\n   attacker may be able to convince a
    client to authenticate to a realm\n   other than the one intended.  If an attacker
    is off-path, this may\n   give the attacker an advantage in attacking the client's
    credentials.\n   Also, see the discussion of shared passwords below.\n   More
    serious attacks are possible if no protection beyond RFC 4120 is\n   used.  In
    this case, neither the client name nor the service name is\n   protected between
    the client and KDC.  In the general case, if an\n   attacker changes the client
    name, then authentication will fail\n   because the client will not have the right
    credentials (password,\n   certificate, or other) to authenticate as the user
    selected by the\n   attacker.  However, see the discussion of shared passwords
    below.\n   Changing the server name can be a very significant attack.  For\n   example,
    if a user is authenticating in order to send some\n   confidential information,
    then the attacker could gain this\n   information by directing the user to a server
    under the attacker's\n   control.  The server name in the response is protected
    by RFC 4120,\n   but not the one in the request.  Fortunately, users are typically\n
    \  authenticating to the \"krbtgt\" service in an AS exchange.  Clients\n   that
    permit changes to the server name when no protection beyond RFC\n   4120 is in
    use SHOULD carefully restrict what service names are\n   acceptable.  One critical
    case to consider is the password-changing\n   service.  When a user authenticates
    to change their password, they\n   use an AS authentication directly to the password-changing
    service.\n   Clients MUST restrict service name changes sufficiently that the\n
    \  client ends up talking to the correct password-changing service.\n"
  - contents:
    - "13.1.  Shared-Password Case\n   A special case to examine is when the user
      is known (or correctly\n   suspected) to use the same password for multiple
      accounts.  A man-in-\n   the-middle attacker can either alter the request on
      its way to the\n   KDC, changing the client principal name, or reply to the
      client with\n   a response previously sent by the KDC in response to a request
      from\n   the attacker.  The response received by the client can then be\n   decrypted
      by the user, though if the default \"salt\" generated from\n   the principal
      name is used to produce the user's key, a PA-ETYPE-INFO\n   or PA-ETYPE-INFO2
      preauth record may need to be added or altered by\n   the attacker to cause
      the client software to generate the key needed\n   for the message it will receive.
      \ None of this requires the attacker\n   to know the user's password, and without
      further checking, this could\n   cause the user to unknowingly use the wrong
      credentials.\n   In normal operation as described in [RFC4120], a generated
      AP-REQ\n   message includes in the Authenticator field a copy of the client's\n
      \  idea of its own principal name.  If this differs from the name in the\n   KDC-generated
      ticket, the application server will reject the message.\n   With client name
      canonicalization as described in this document, the\n   client may get its principal
      name from the response from the KDC.\n   Using the wrong credentials may provide
      an advantage to an attacker.\n   For example, if a client uses one principal
      for administrative\n   operations and one for less privileged operation, an
      attacker may\n   coerce a client into using the wrong privilege to either cause
      some\n   later operation to succeed or fail.\n"
    title: 13.1.  Shared-Password Case
  - contents:
    - "13.2.  Pre-Authentication Data\n   In cases of credential renewal, forwarding,
      or validation, if\n   credentials are sent to the KDC that are not an initial
      ticket-\n   granting ticket for the client's home realm, the encryption key
      used\n   to protect the TGS exchange is one known to a third party (namely,\n
      \  the service for which the credential was issued).  Consequently, in\n   such
      an exchange, the protection described earlier may be compromised\n   by the
      service.  This is not generally believed to be a problem.  If\n   it is, some
      form of explicit TGS armor could be added to FAST.\n"
    title: 13.2.  Pre-Authentication Data
  title: 13.  Security Considerations
- contents:
  - "14.  Acknowledgments\n   John Brezak, Mike Swift, and Jonathan Trostle wrote
    the initial\n   version of this document.\n   Karthik Jaganathan contributed to
    earlier versions.\n   Sam Hartman's work on this document was funded by the MIT
    Kerberos\n   Consortium.\n"
  title: 14.  Acknowledgments
- contents:
  - '15.  References

    '
  - contents:
    - "15.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC4120]  Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The\n
      \             Kerberos Network Authentication Service (V5)\", RFC 4120,\n              July
      2005.\n   [RFC6113]  Hartman, S. and L. Zhu, \"A Generalized Framework for\n
      \             Kerberos Pre-Authentication\", RFC 6113, April 2011.\n"
    title: 15.1.  Normative References
  - contents:
    - "15.2.  Informative References\n   [RFC4556]  Zhu, L. and B. Tung, \"Public
      Key Cryptography for Initial\n              Authentication in Kerberos (PKINIT)\",
      RFC 4556, June 2006.\n   [RFC5280]  Cooper, D., Santesson, S., Farrell, S.,
      Boeyen, S.,\n              Housley, R., and W. Polk, \"Internet X.509 Public
      Key\n              Infrastructure Certificate and Certificate Revocation List\n
      \             (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5322]  Resnick, P.,
      Ed., \"Internet Message Format\", RFC 5322,\n              October 2008.\n   [XPR]
      \     Trostle, J., Kosinovsky, I., and M. Swift, \"Implementation\n              of
      Crossrealm Referral Handling in the MIT Kerberos\n              Client\",  Network
      and Distributed System Security\n              Symposium, February 2001.\n"
    title: 15.2.  Informative References
  title: 15.  References
- contents:
  - "Appendix A.  Compatibility with Earlier Implementations of Name\n             Canonicalization\n
    \  The Microsoft Windows 2000 and Windows 2003 releases included an\n   earlier
    form of name-canonicalization [XPR].  Here are the\n   differences:\n   1) Windows
    include an additional encrypted padata element.  The\n      preauth data type
    definition in the encrypted preauth data is as\n      follows:\n          PA-SVR-REFERRAL-INFO
    \      20\n          PA-SVR-REFERRAL-DATA ::= SEQUENCE {\n                 referred-name
    \  [1] PrincipalName OPTIONAL,\n                 referred-realm  [0] Realm\n          }}\n
    \        The referred-principal is never sent.  The referred-realm is\n         included
    in TGS replies and includes the realm name of the\n         realm to which the
    client is referred.  This information is\n         redundant with the realm in
    the second component of the\n         returned TGT.\n   2) When PKINIT [RFC4556]
    is used, the NT-ENTERPRISE client name is\n      encoded as a Subject Alternative
    Name (SAN) extension [RFC5280] in\n      the client's X.509 certificate.  The
    type of the otherName field\n      for this SAN extension is AnotherName [RFC5280].
    \ The type-id\n      field of the type AnotherName is id-ms-sc-logon-upn\n      (1.3.6.1.4.1.311.20.2.3),
    and the value field of the type\n      AnotherName is a KerberosString [RFC4120].
    \ The value of this\n      KerberosString type is the single component in the
    name-string\n      [RFC4120] sequence for the corresponding NT-ENTERPRISE name
    type.\n   In Microsoft's current implementation through the use of global\n   catalogs,
    any domain in one forest is reachable from any other domain\n   in the same forest
    or another trusted forest with 3 or less\n   referrals.  A forest is a collection
    of realms with hierarchical\n   trust relationships: there can be multiple trust
    trees in a forest;\n   each child and parent realm pair and each root realm pair
    have\n   bidirectional transitive direct trust between them.\n   While we might
    want to permit multiple aliases to exist and even be\n   reported in AD-LOGIN-ALIAS,
    the Microsoft implementation permits only\n   one NT-ENTERPRISE alias to exist,
    so this question had not previously\n   arisen.\n"
  title: Appendix A.  Compatibility with Earlier Implementations of Name
- contents:
  - "Authors' Addresses\n   Sam Hartman (editor)\n   Painless Security\n   EMail:
    hartmans-ietf@mit.edu\n   Kenneth Raeburn\n   Massachusetts Institute of Technology\n
    \  EMail: raeburn@mit.edu\n   Larry Zhu\n   Microsoft Corporation\n   One Microsoft
    Way\n   Redmond, WA  98052\n   US\n   EMail: lzhu@microsoft.com\n"
  title: Authors' Addresses
