- contents:
  - "       Applicability Statement for the Use of IPv6 UDP Datagrams\n                          with
    Zero Checksums\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document provides an applicability statement for the use of
    UDP\n   transport checksums with IPv6.  It defines recommendations and\n   requirements
    for the use of IPv6 UDP datagrams with a zero UDP\n   checksum.  It describes
    the issues and design principles that need to\n   be considered when UDP is used
    with IPv6 to support tunnel\n   encapsulations, and it examines the role of the
    IPv6 UDP transport\n   checksum.  The document also identifies issues and constraints
    for\n   deployment on network paths that include middleboxes.  An appendix\n   presents
    a summary of the trade-offs that were considered in\n   evaluating the safety
    of the update to RFC 2460 that changes the use\n   of the UDP checksum with IPv6.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6936.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n     1.1.  Document Structure . . . . . . . . . . . . . . . .
    . . . .  5\n     1.2.  Terminology  . . . . . . . . . . . . . . . . . . . . .
    . .  5\n     1.3.  Use of UDP Tunnels . . . . . . . . . . . . . . . . . . . .
    \ 6\n       1.3.1.  Motivation for New Approaches  . . . . . . . . . . . .  6\n
    \      1.3.2.  Reducing Forwarding Costs  . . . . . . . . . . . . . .  6\n       1.3.3.
    \ Need to Inspect the Entire Packet  . . . . . . . . . .  7\n       1.3.4.  Interactions
    with Middleboxes  . . . . . . . . . . . .  7\n       1.3.5.  Support for Load
    Balancing . . . . . . . . . . . . . .  8\n   2.  Standards-Track Transports .
    . . . . . . . . . . . . . . . . .  9\n     2.1.  UDP with Standard Checksum .
    . . . . . . . . . . . . . . .  9\n     2.2.  UDP-Lite . . . . . . . . . . . .
    . . . . . . . . . . . . .  9\n       2.2.1.  Using UDP-Lite as a Tunnel Encapsulation
    . . . . . . . 10\n     2.3.  General Tunnel Encapsulations  . . . . . . . . .
    . . . . . 10\n     2.4.  Relationship of Zero UDP Checksum to UDP-Lite and UDP\n
    \          with Checksum  . . . . . . . . . . . . . . . . . . . . . . 11\n   3.
    \ Issues Requiring Consideration . . . . . . . . . . . . . . . . 12\n     3.1.
    \ Effect of Packet Modification in the Network . . . . . . . 13\n       3.1.1.
    \ Corruption of the Destination IP Address Field . . . . 14\n       3.1.2.  Corruption
    of the Source IP Address Field  . . . . . . 15\n       3.1.3.  Corruption of Port
    Information . . . . . . . . . . . . 16\n       3.1.4.  Delivery to an Unexpected
    Port . . . . . . . . . . . . 16\n       3.1.5.  Corruption of Fragmentation Information
    \ . . . . . . . 18\n     3.2.  Where Packet Corruption Occurs . . . . . . . .
    . . . . . . 20\n     3.3.  Validating the Network Path  . . . . . . . . . . .
    . . . . 20\n     3.4.  Applicability of the Zero UDP Checksum Method  . . . .
    . . 21\n     3.5.  Impact on Non-Supporting Devices or Applications . . . . .
    22\n   4.  Constraints on Implementation of IPv6 Nodes Supporting\n       Zero
    Checksum  . . . . . . . . . . . . . . . . . . . . . . . . 23\n   5.  Requirements
    on Usage of the Zero UDP Checksum . . . . . . . . 24\n   6.  Summary  . . . .
    . . . . . . . . . . . . . . . . . . . . . . . 27\n   7.  Security Considerations
    \ . . . . . . . . . . . . . . . . . . . 28\n   8.  Acknowledgments  . . . . .
    . . . . . . . . . . . . . . . . . . 29\n   9.  References . . . . . . . . . .
    . . . . . . . . . . . . . . . . 30\n     9.1.  Normative References . . . . .
    . . . . . . . . . . . . . . 30\n     9.2.  Informative References . . . . . .
    . . . . . . . . . . . . 30\n   Appendix A.  Evaluation of Proposal to Update RFC
    2460 to\n                Support Zero Checksum . . . . . . . . . . . . . . . .
    33\n     A.1.  Alternatives to the Standard Checksum  . . . . . . . . . . 33\n
    \    A.2.  Comparison of Alternative Methods  . . . . . . . . . . . . 34\n       A.2.1.
    \ Middlebox Traversal  . . . . . . . . . . . . . . . . . 34\n       A.2.2.  Load
    Balancing . . . . . . . . . . . . . . . . . . . . 35\n       A.2.3.  Ingress and
    Egress Performance Implications  . . . . . 36\n       A.2.4.  Deployability  .
    . . . . . . . . . . . . . . . . . . . 36\n       A.2.5.  Corruption Detection
    Strength  . . . . . . . . . . . . 37\n       A.2.6.  Comparison Summary . . .
    . . . . . . . . . . . . . . . 37\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The User Datagram Protocol (UDP) [RFC0768] transport is
    defined for\n   IPv4 [RFC0791], and it is defined in \"Internet Protocol, Version
    6\n   (IPv6)\" [RFC2460] for IPv6 hosts and routers.  The UDP transport\n   protocol
    has a minimal set of features.  This limited set has enabled\n   a wide range
    of applications to use UDP, but these applications do\n   need to provide many
    important transport functions on top of UDP.\n   The UDP usage guidelines [RFC5405]
    provide overall guidance for\n   application designers, including the use of UDP
    to support tunneling.\n   The key difference between UDP usage with IPv4 and IPv6
    is that RFC\n   2460 mandates use of a calculated UDP checksum, i.e., a non-zero\n
    \  value, due to the lack of an IPv6 header checksum.  The inclusion of\n   the
    pseudo-header in the checksum computation provides a statistical\n   check that
    datagrams have been delivered to the intended IPv6\n   destination node.  Algorithms
    for checksum computation are described\n   in [RFC1071].\n   The inability to
    use an IPv6 datagram with a zero UDP checksum has\n   been found to be a real
    problem for certain classes of application,\n   primarily tunnel applications.
    \ This class of application has been\n   deployed with a zero UDP checksum using
    IPv4.  The design of IPv6\n   raises different issues when considering the safety
    of using a UDP\n   checksum with IPv6.  These issues can significantly affect\n
    \  applications, whether an endpoint is the intended user or an innocent\n   bystander
    (i.e., when a packet is received by a different endpoint to\n   that intended).\n
    \  This document identifies a set of issues that must be considered and\n   mitigated
    to enable safe deployment of IPv6 applications that use a\n   zero UDP checksum.
    \ The appendix compares the strengths and\n   weaknesses of a number of proposed
    solutions.  The comparison of\n   methods provided in this document is also expected
    to be useful when\n   considering applications that have different goals from
    the ones\n   whose needs led to the writing of this document, especially\n   applications
    that can use existing standardized transport protocols.\n   The analysis concludes
    that using a zero UDP checksum is the best\n   method of the proposed alternatives
    to meet the goals of certain\n   tunnel applications.\n   This document defines
    recommendations and requirements for use of\n   IPv6 datagrams with a zero UDP
    checksum.  This usage is expected to\n   have initial deployment issues related
    to middleboxes, limiting the\n   usability more than desired in the currently
    deployed Internet.\n   However, this limitation will be largest initially and
    will decrease\n   as updates are provided in middleboxes that support the zero
    UDP\n   checksum for IPv6.  Therefore, in this document, we derive a set of\n
    \  constraints required to ensure safe deployment of a zero UDP\n   checksum.\n
    \  Finally, the document identifies some issues that require future\n   consideration
    and possibly additional research.\n"
  - contents:
    - "1.1.  Document Structure\n   Section 1 provides a background to key issues
      and introduces the use\n   of UDP as a tunnel transport protocol.\n   Section
      2 describes a set of standards-track datagram transport\n   protocols that may
      be used to support tunnels.\n   Section 3 discusses issues with a zero UDP checksum
      for IPv6.  It\n   considers the impact of corruption, the need for validation
      of the\n   path, and when it is suitable to use a zero UDP checksum.\n   Section
      4 is an applicability statement that defines requirements and\n   recommendations
      on the implementation of IPv6 nodes that support the\n   use of a zero UDP checksum.\n
      \  Section 5 provides an applicability statement that defines\n   requirements
      and recommendations for protocols and tunnel\n   encapsulations that are transported
      over an IPv6 transport that does\n   not perform a UDP checksum calculation
      to verify the integrity at the\n   transport endpoints.\n   Section 6 provides
      the recommendations for standardization of zero\n   UDP checksum, with a summary
      of the findings, and notes the remaining\n   issues that need future work.\n
      \  Appendix A evaluates the set of proposals to update the UDP transport\n   behavior
      and other alternatives intended to improve support for\n   tunnel protocols.
      \ It concludes by assessing the trade-offs of the\n   various methods and by
      identifying advantages and disadvantages for\n   each method.\n"
    title: 1.1.  Document Structure
  - contents:
    - "1.2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and
      \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
    title: 1.2.  Terminology
  - contents:
    - "1.3.  Use of UDP Tunnels\n   One increasingly popular use of UDP is as a tunneling
      protocol, where\n   a tunnel endpoint encapsulates the packets of another protocol
      inside\n   UDP datagrams and transmits them to another tunnel endpoint.  Using\n
      \  UDP as a tunneling protocol is attractive when the payload protocol\n   is
      not supported by the middleboxes that may exist along the path,\n   because
      many middleboxes support transmission using UDP.  In this\n   use, the receiving
      endpoint decapsulates the UDP datagrams and\n   forwards the original packets
      contained in the payload [RFC5405].\n   Tunnels establish virtual links that
      appear to directly connect\n   locations that are distant in the physical Internet
      topology, and\n   they can be used to create virtual (private) networks.\n"
    - contents:
      - "1.3.1.  Motivation for New Approaches\n   A number of tunnel encapsulations
        deployed over IPv4 have used the\n   UDP transport with a zero checksum.  Users
        of these protocols expect\n   a similar solution for IPv6.\n   A number of
        tunnel protocols are also currently being defined (e.g.,\n   Automated Multicast
        Tunnels [AMT] and Locator/Identifier Separation\n   Protocol (LISP) [RFC6830]).
        \ These protocols provided several\n   motivations to update IPv6 UDP checksum
        processing so that it would\n   benefit from simpler checksum processing,
        including:\n   o  Reducing forwarding costs, motivated by redundancy present
        in the\n      encapsulated packet header, because in tunnel encapsulations,\n
        \     payload integrity and length verification may be provided by\n      higher-layer
        encapsulations (often using the IPv4, UDP, UDP-Lite\n      [RFC3828], or TCP
        checksums [RFC0793]).\n   o  Eliminating the need to access the entire packet
        when a tunnel\n      endpoint forwards the packet.\n   o  Enhancing the ability
        to traverse and function with middleboxes.\n   o  A desire to use the port
        number space to enable load sharing.\n"
      title: 1.3.1.  Motivation for New Approaches
    - contents:
      - "1.3.2.  Reducing Forwarding Costs\n   It is a common requirement to terminate
        a large number of tunnels on\n   a single router or host.  The processing
        cost per tunnel includes\n   both state (memory requirements) and per-packet
        processing at the\n   tunnel ingress and egress.\n   Automatic IP Multicast
        Tunneling, known as AMT [AMT], currently\n   specifies UDP as the transport
        protocol for packets carrying tunneled\n   IP multicast packets.  The current
        specification for AMT states that\n   the UDP checksum in the outer packet
        header should be zero (see\n   Section 6.6 of [AMT]).  That section argues
        that the computation of\n   an additional checksum is an unwarranted burden
        on nodes implementing\n   lightweight tunneling protocols when an inner packet
        is already\n   adequately protected.  The AMT protocol needs to replicate
        a\n   multicast packet to each gateway tunnel.  In this case, the outer IP\n
        \  addresses are different for each tunnel; therefore, a different\n   pseudo-header
        must be built to form the header for each tunnel egress\n   that receives
        replicated multicast packets.\n   The argument concerning redundant processing
        costs is valid regarding\n   the integrity of a tunneled packet.  In some
        architectures (e.g., PC-\n   based routers), other mechanisms may also significantly
        reduce\n   checksum processing costs.  For example, there are implementations\n
        \  that have optimized checksum processing algorithms, including the use\n
        \  of checksum offloading.  This processing is readily available for\n   IPv4
        packets at high line rates.  Such processing may be anticipated\n   for IPv6
        endpoints, allowing receivers to reject corrupted packets\n   without further
        processing.  However, for certain classes of tunnel\n   endpoints, this off-loading
        is not available and is unlikely to\n   become available in the near future.\n"
      title: 1.3.2.  Reducing Forwarding Costs
    - contents:
      - "1.3.3.  Need to Inspect the Entire Packet\n   The currently deployed hardware
        in many routers uses a fast-path\n   processing that provides only the first
        n bytes of a packet to the\n   forwarding engine, where typically n <= 128.\n
        \  When this design is used to support a tunnel ingress and egress, it\n   prevents
        fast processing of a transport checksum over an entire\n   (large) packet.
        \ Hence, the currently defined IPv6 UDP checksum is\n   poorly suited for
        use within a router that is unable to access the\n   entire packet and does
        not provide checksum off-loading.  Thus,\n   enabling checksum calculation
        over the complete packet can impact\n   router design, performance, energy
        consumption, and cost.\n"
      title: 1.3.3.  Need to Inspect the Entire Packet
    - contents:
      - "1.3.4.  Interactions with Middleboxes\n   Many paths in the Internet include
        one or more middleboxes of various\n   types.  Large classes of middleboxes
        will handle zero UDP checksum\n   packets, but do not support UDP-Lite or
        the other investigated\n   proposals.  These middleboxes include load balancers
        (see\n   Section 1.3.5) including equal-cost multipath (ECMP) routing, traffic\n
        \  classifiers, and other functions that reads some fields in the UDP\n   headers
        but does not validate the UDP checksum.\n   There are also middleboxes that
        either validate or modify the UDP\n   checksum.  The two most common classes
        are firewalls and NATs.  In\n   IPv4, UDP encapsulation may be desirable for
        NAT traversal, because\n   UDP support is commonly provided.  It is also necessary
        due to the\n   almost ubiquitous deployment of IPv4 NATs.  There has also
        been\n   discussion of NAT for IPv6, although not for the same reason as in\n
        \  IPv4.  If IPv6 NAT becomes a reality, it hopefully will not present\n   the
        same protocol issues as for IPv4.  If NAT is defined for IPv6, it\n   should
        take into consideration the use of a zero UDP checksum.\n   The requirements
        for IPv6 firewall traversal are likely be to be\n   similar to those for IPv4.
        \ In addition, it can be reasonably\n   expected that a firewall conforming
        to RFC 2460 will not regard\n   datagrams with a zero UDP checksum as valid.
        \ Use of a zero UDP\n   checksum with IPv6 requires firewalls to be updated
        before the full\n   utility of the change becomes available.\n   It can be
        expected that datagrams with zero UDP checksum will\n   initially not have
        the same middlebox traversal characteristics as\n   regular UDP (RFC 2460).
        \ However, when implementations follow the\n   requirements specified in this
        document, we expect the traversal\n   capabilities to improve over time.  We
        also note that deployment of\n   IPv6-capable middleboxes is still in its
        initial phases.  Thus, it\n   might be that the number of non-updated boxes
        quickly becomes a very\n   small percentage of the deployed middleboxes.\n"
      title: 1.3.4.  Interactions with Middleboxes
    - contents:
      - "1.3.5.  Support for Load Balancing\n   The UDP port number fields have been
        used as a basis to design load-\n   balancing solutions for IPv4.  This approach
        has also been leveraged\n   for IPv6.  An alternate method would be to utilize
        the IPv6 flow\n   label [RFC6437] as a basis for entropy for load balancing.
        \ This\n   would have the desirable effect of freeing IPv6 load-balancing\n
        \  devices from the need to assume semantics for the use of the\n   transport
        port field, and also, it works for all types of transport\n   protocols.\n
        \  This use of the Flow Label for load balancing is consistent with the\n
        \  intended use, although further clarity was needed to ensure the field\n
        \  can be consistently used for this purpose.  Therefore, an updated\n   IPv6
        flow label [RFC6437] and ECMP routing [RFC6438] usage were\n   specified.
        \ Router vendors could be encouraged to start using the\n   IPv6 Flow Label
        as a part of the flow hash, providing support for\n   ECMP without requiring
        use of UDP.\n   However, the method for populating the outer IPv6 header with
        a value\n   for the flow label is not trivial.  If the inner packet uses IPv6,\n
        \  the flow label value could be copied to the outer packet header.\n   However,
        many current endpoints set the flow label to a zero value\n   (thus, no entropy).
        \ The ingress of a tunnel seeking to provide good\n   entropy in the flow
        label field would therefore need to create a\n   random flow label value and
        keep corresponding state so that all\n   packets that were associated with
        a flow would be consistently given\n   the same flow label.  Although possible,
        this complexity may not be\n   desirable in a tunnel ingress.\n   The end-to-end
        use of flow labels for load balancing is a long-term\n   solution.  Even if
        the usage of the flow label has been clarified,\n   there will be a transition
        time before a significant proportion of\n   endpoints start to assign a good
        quality flow label to the flows that\n   they originate.  The use of load
        balancing using the transport header\n   fields would continue until any widespread
        deployment is finally\n   achieved.\n"
      title: 1.3.5.  Support for Load Balancing
    title: 1.3.  Use of UDP Tunnels
  title: 1.  Introduction
- contents:
  - "2.  Standards-Track Transports\n   The IETF has defined a set of transport protocols
    that may be\n   applicable for tunnels with IPv6.  There is also a set of network-\n
    \  layer encapsulation tunnels, such as IP-in-IP and Generic Routing\n   Encapsulation
    (GRE).  These solutions, which are already\n   standardized, are discussed first,
    before discussing the issues,\n   because they provide background for the description
    of the issues and\n   allow some comparison with existing issues.\n"
  - contents:
    - "2.1.  UDP with Standard Checksum\n   UDP [RFC0768] with standard checksum behavior,
      as defined in RFC\n   2460, has already been discussed.  UDP usage guidelines
      are provided\n   in [RFC5405].\n"
    title: 2.1.  UDP with Standard Checksum
  - contents:
    - "2.2.  UDP-Lite\n   UDP-Lite [RFC3828] offers an alternate transport to UDP
      and is\n   specified as a proposed standard, RFC 3828.  A MIB is defined in\n
      \  [RFC5097], and unicast usage guidelines are defined in [RFC5405].\n   There
      has been at least one open-source implementation of UDP-Lite as\n   a part of
      the Linux kernel since version 2.6.20.\n   UDP-Lite provides a checksum with
      an option for partial coverage.\n   When using this option, a datagram is divided
      into a sensitive part\n   (covered by the checksum) and an insensitive part
      (not covered by the\n   checksum).  When the checksum covers the entire packet,
      UDP-Lite is\n   fully equivalent with UDP, with the exception that it uses a\n
      \  different value in the Next Header field in the IPv6 header.  Errors\n   or
      corruption in the insensitive part will not cause the datagram to\n   be discarded
      by the transport layer at the receiving endpoint.  A\n   minor side effect of
      using UDP-Lite is that it was specified for\n   damage-tolerant payloads, and
      some link layers may employ different\n   link encapsulations when forwarding
      UDP-Lite segments (e.g., radio\n   access bearers).  Most link layers will cover
      the insensitive part\n   with the same strong Layer 2 frame Cyclic Redundancy
      Check (CRC) that\n   covers the sensitive part.\n"
    - contents:
      - "2.2.1.  Using UDP-Lite as a Tunnel Encapsulation\n   Tunnel encapsulations,
        such as Control And Provisioning of Wireless\n   Access Points (CAPWAP) [RFC5415],
        can use UDP-Lite, because it\n   provides a transport-layer checksum, including
        an IP pseudo-header\n   checksum, in IPv6, without the need for a router/middlebox
        to\n   traverse the entire packet payload.  This provides most of the\n   verification
        required for delivery and still keeps a low complexity\n   for the checksumming
        operation.  UDP-Lite may set the length of\n   checksum coverage on a per-packet
        basis.  This feature could be used\n   if a tunnel protocol is designed to
        verify only delivery of the\n   tunneled payload and uses a calculated checksum
        for control\n   information.\n   Currently, support for middlebox traversal
        using UDP-Lite is poor,\n   because UDP-Lite uses a different IPv6 network-layer
        Next Header\n   value than that used for UDP; therefore, few middleboxes are
        able to\n   interpret UDP-Lite and take appropriate actions when forwarding
        the\n   packet.  This makes UDP-Lite less suited to protocols needing general\n
        \  Internet support, until such time as UDP-Lite has achieved better\n   support
        in middleboxes and endpoints.\n"
      title: 2.2.1.  Using UDP-Lite as a Tunnel Encapsulation
    title: 2.2.  UDP-Lite
  - contents:
    - "2.3.  General Tunnel Encapsulations\n   The IETF has defined a set of tunneling
      protocols or network-layer\n   encapsulations, e.g., IP-in-IP and GRE.  These
      either do not include\n   a checksum or use a checksum that is optional, because
      tunnel\n   encapsulations are typically layered directly over the Internet layer\n
      \  (identified by the upper layer type in the IPv6 Next Header field)\n   and
      because they are not used as endpoint transport protocols.  There\n   is little
      chance of confusing a tunnel-encapsulated packet with other\n   application
      data.  Such confusion could result in corruption of\n   application state or
      data.\n   From an end-to-end perspective, the principal difference between an\n
      \  endpoint transport and a tunnel encapsulation is the value of the\n   network-layer
      Next Header field.  In the former, it identifies a\n   transport protocol that
      supports endpoint applications.  In the\n   latter, it identifies a tunnel protocol
      egress.  This separation of\n   function reduces the probability that corruption
      of a tunneled packet\n   could result in the packet being erroneously delivered
      to an\n   application.  Specifically, packets are delivered only to protocol\n
      \  modules that process a specific Next Header value.  The Next Header\n   field
      therefore provides a first-level check of correct\n   demultiplexing.  In contrast,
      the UDP port space is shared by many\n   diverse applications, and therefore,
      UDP demultiplexing relies solely\n   on the port numbers.\n"
    title: 2.3.  General Tunnel Encapsulations
  - contents:
    - "2.4.  Relationship of Zero UDP Checksum to UDP-Lite and UDP with\n      Checksum\n
      \  The operation of IPv6 with UDP with a zero checksum is not the same\n   as
      IPv4 with UDP with a zero checksum.  Protocol designers should not\n   be fooled
      into thinking that the two are the same.  The requirements\n   below list a
      set of additional considerations for IPv6.\n   Where possible, existing general
      tunnel encapsulations, such as GRE\n   and IP-in-IP, should be used.  This section
      assumes that such\n   existing tunnel encapsulations do not offer the functionally
      required\n   to satisfy the protocol designer's goals.  This section considers
      the\n   standardized alternative solutions rather than the full set of ideas\n
      \  evaluated in Appendix A.  The alternatives to UDP with a zero\n   checksum
      are UDP with a (calculated) checksum and UDP-Lite.\n   UDP with a checksum has
      the advantage of close to universal support\n   in both endpoints and middleboxes.
      \ It also provides statistical\n   verification of delivery to the intended
      destination (address and\n   port).  However, some classes of device have limited
      support for\n   calculation of a checksum that covers a full datagram.  For
      these\n   devices, this limited support can incur significant processing costs\n
      \  (e.g., requiring processing in the router's slow path) and hence can\n   reduce
      capacity or fail to function.\n   UDP-Lite has the advantage of using a checksum
      that can be calculated\n   only over the pseudo-header and the UDP header.  This
      provides a\n   statistical verification of delivery to the intended destination\n
      \  (address and port).  The checksum can be calculated without access to\n   the
      datagram payload, requiring access only to the part that is to be\n   protected.
      \ A drawback is that UDP-Lite currently has limited support\n   in both endpoints
      (i.e., is not supported on all operating system\n   platforms) and middleboxes
      (which must support the UDP-Lite header\n   type).  Therefore, using a path
      verification method is recommended.\n   IPv6 and UDP with a zero checksum can
      also be used by nodes that do\n   not permit calculation of a payload checksum.
      \ Many existing classes\n   of middleboxes do not verify or change the transport
      checksum.  For\n   these middleboxes, IPv6 with a zero UDP checksum is expected
      to\n   function where UDP-Lite would not.  However, support for the zero UDP\n
      \  checksum in middleboxes that do change or verify the checksum is\n   currently
      limited, and this may result in datagrams with a zero UDP\n   checksum being
      discarded.  Therefore, using a path verification\n   method is recommended.\n
      \  For some sets of constraints, no solution exists.  For example, a\n   protocol
      designer who needs to originate or receive datagrams on a\n   device that cannot
      efficiently calculate a checksum over a full\n   datagram and also needs these
      packets to pass through a middlebox\n   that verifies or changes a UDP checksum,
      but that does not support a\n   zero UDP checksum, cannot use the zero UDP checksum
      method.\n   Similarly, a protocol designer who needs to originate datagrams
      on a\n   device with UDP-Lite support, but needs the packets to pass through
      a\n   middlebox that does not support UDP-Lite, cannot use UDP-Lite.  For\n
      \  such cases, there is no optimal solution.  The current recommendation\n   is
      to use or fall back to using UDP with full checksum coverage.\n"
    title: 2.4.  Relationship of Zero UDP Checksum to UDP-Lite and UDP with
  title: 2.  Standards-Track Transports
- contents:
  - "3.  Issues Requiring Consideration\n   This informative section evaluates issues
    about the proposal to\n   update IPv6 [RFC2460] to enable the UDP transport checksum
    to be set\n   to zero.  Some of the identified issues are common to other protocols\n
    \  already in use.  This section also provides background to help in\n   understanding
    the requirements and recommendations that follow.\n   The decision in RFC 2460
    to omit an integrity check at the network\n   level meant that the IPv6 transport
    checksum was overloaded with many\n   functions, including validating:\n   o  That
    the endpoint address was not corrupted within a router, i.e.,\n      a packet
    was intended to be received by this destination, and that\n      the packet does
    not consist of a wrong header spliced to a\n      different payload.\n   o  That
    extension header processing is correctly delimited, i.e., the\n      start of
    data has not been corrupted.  In this case, reception of\n      a valid Next Header
    value provides some protection.\n   o  Reassembly processing, when used.\n   o
    \ The length of the payload.\n   o  The port values, i.e., the correct application
    receives the\n      payload.  (Applications should also check the expected use
    of\n      source ports/addresses.)\n   o  The payload integrity.\n   In IPv4,
    the first four of these checks are performed using the IPv4\n   header checksum.\n
    \  In IPv6, these checks occur within the endpoint stack using the UDP\n   checksum
    information.  An IPv6 node also relies on the header\n   information to determine
    whether to send an ICMPv6 error message\n   [RFC4443] and to determine the node
    to which this is sent.  Corrupted\n   information may lead to misdelivery to an
    unintended application\n   socket on an unexpected host.\n"
  - contents:
    - "3.1.  Effect of Packet Modification in the Network\n   IP packets may be corrupted
      as they traverse an Internet path.  Older\n   evidence presented in \"When the
      CRC and TCP Checksum Disagree\"\n   [Sigcomm2000] shows that this was an issue
      with IPv4 routers in the\n   year 2000 and that occasional corruption could
      result from bad\n   internal router processing in routers or hosts.  These errors
      are not\n   detected by the strong frame checksums employed at the link layer\n
      \  [RFC3819].  During the development of this document in 2009, a number\n   of
      individuals provided reports of observed rates for received UDP\n   datagrams
      using IPv4 where the UDP checksum had been detected as\n   corrupt.  These rates
      were as high as 1.39E-4 for some paths, but\n   close to zero for other paths.\n
      \  There is extensive experience with deployments using tunnel protocols\n   in
      well-managed networks (e.g., corporate networks and service\n   provider core
      networks).  This has shown the robustness of methods\n   such as Pseudowire
      Emulation Edge-to-Edge (PWE3) and MPLS that do not\n   employ a transport protocol
      checksum and that have not specified\n   mechanisms to protect from corruption
      of the unprotected headers\n   (such as the VPN Identifier in MPLS).  Reasons
      for the robustness may\n   include:\n   o  A reduced probability of corruption
      on paths through well-managed\n      networks.\n   o  IP forms the majority
      of the inner traffic carried by these\n      tunnels.  Hence, from a transport
      perspective, endpoint\n      verification is already being performed when a
      received IPv4\n      packet is processed or by the transport pseudo-header for
      an IPv6\n      packet.  This update to UDP does not change this behavior.\n
      \  o  In certain cases, a combination of additional filtering (e.g.,\n      filtering
      a MAC destination address in a Layer 2 tunnel)\n      significantly reduces
      the probability of final misdelivery to the\n      IP stack.\n   o  The tunnel
      protocols did not use a UDP transport header.\n      Therefore, any corruption
      is unlikely to result in misdelivery to\n      another UDP-based application.
      \ This concern is specific to UDP\n      with IPv6.\n   While this experience
      can guide the present recommendations, any\n   update to UDP must preserve operation
      in the general Internet, which\n   is heterogeneous and can include links and
      systems of widely varying\n   characteristics.  Transport protocols used by
      hosts need to be\n   designed with this in mind, especially when there is need
      to traverse\n   edge networks, where middlebox deployments are common.\n   Currently,
      for the general Internet, there is no evidence that\n   corruption is rare,
      nor is there evidence that corruption in IPv6 is\n   rare.  Therefore, it seems
      prudent not to relax checks on\n   misdelivery.  The emergence of low-end IPv6
      routers and the proposed\n   use of NAT with IPv6 provide further motivation
      to protect from\n   misdelivery.\n   Corruption in the network may result in:\n
      \  o  A datagram being misdelivered to the wrong host/router or the\n      wrong
      transport entity within an endpoint.  Such a datagram needs\n      to be discarded.\n
      \  o  A datagram payload being corrupted, but still delivered to the\n      intended
      host/router transport entity.  Such a datagram needs to\n      be either discarded
      or correctly processed by an application that\n      provides its own integrity
      checks.\n   o  A datagram payload being truncated by corruption of the length\n
      \     field.  Such a datagram needs to be discarded.\n   Using a checksum significantly
      reduces the impact of errors, reducing\n   the probability of undetected corruption
      of state (and data) on both\n   the host stack and the applications using the
      transport service.\n   The following sections examine the effect of modifications
      to the\n   destination and source IP address fields, the port fields, and the\n
      \  fragmentation information.\n"
    - contents:
      - "3.1.1.  Corruption of the Destination IP Address Field\n   An IPv6 endpoint
        destination address could be modified in the\n   network; for example, it
        could be corrupted by an error.  This is not\n   a concern for IPv4, because
        the IP header checksum will result in\n   this packet being discarded by the
        receiving IP stack.  When using\n   IPv6, however, such modification in the
        network cannot be detected at\n   the network layer.  Detection of this corruption
        by a UDP receiver\n   relies on the IPv6 pseudo-header that is incorporated
        in the\n   transport checksum.\n   There are two possible outcomes:\n   o
        \ Delivery to a destination address that is not in use.  The packet\n      will
        not be delivered, but an error report could be generated.\n   o  Delivery
        to a different destination address.  This modification\n      will normally
        be detected by the transport checksum, resulting in\n      a silent discard.
        \ Without a computed checksum, the packet would\n      be passed to the endpoint
        port demultiplexing function.  If an\n      application is bound to the associated
        ports, the packet payload\n      will be passed to the application.  (See
        Section 3.1.4 on port\n      processing.)\n"
      title: 3.1.1.  Corruption of the Destination IP Address Field
    - contents:
      - "3.1.2.  Corruption of the Source IP Address Field\n   This section examines
        what happens when the source IP address is\n   corrupted in transit.  This
        is not a concern in IPv4, because the IP\n   header checksum will normally
        result in this packet being discarded\n   by the receiving IP stack.  Detection
        of this corruption by a UDP\n   receiver relies on the IPv6 pseudo-header
        that is incorporated in the\n   transport checksum.\n   Corruption of an IPv6
        source address does not result in the IP packet\n   being delivered to a different
        endpoint protocol or destination\n   address.  If only the source address
        is corrupted, the datagram will\n   likely be processed in the intended context,
        although with erroneous\n   origin information.  When using unicast reverse
        path forwarding\n   [RFC2827], a change in address may result in the router
        discarding\n   the packet when the route to the modified source address is
        different\n   from that of the source address of the original packet.\n   The
        result will depend on the application or protocol that processes\n   the packet.
        \ Some examples are:\n   o  An application that requires a pre-established
        context may\n      disregard the datagram as invalid or could map it to another\n
        \     context (if a context for the modified source address were already\n
        \     activated).\n   o  A stateless application will process the datagram
        outside of any\n      context.  A simple example is the ECHO server, which
        will respond\n      with a datagram directed to the modified source address.
        \ This\n      would create unwanted additional processing load and generate\n
        \     traffic to the modified endpoint address.\n   o  Some datagram applications
        build state using the information from\n      packet headers.  A previously
        unused source address would result\n      in receiver processing and the creation
        of unnecessary transport-\n      layer state at the receiver.  For example,
        Real-time Protocol\n      (RTP) [RFC3550] sessions commonly employ a source-independent\n
        \     receiver port.  State is created for each received flow.\n      Therefore,
        reception of a datagram with a corrupted source address\n      will result
        in the accumulation of unnecessary state in the RTP\n      state machine,
        including collision detection and response (since\n      the same synchronization
        source (SSRC) value will appear to arrive\n      from multiple source IP addresses).\n
        \  o  ICMP messages relating to a corrupted packet can be misdirected to\n
        \     the wrong source node.\n   In general, the effect of corrupting the
        source address will depend\n   upon the protocol that processes the packet
        and its robustness to\n   this error.  For the case where the packet is received
        by a tunnel\n   endpoint, the tunnel application is expected to correctly
        handle a\n   corrupted source address.\n   The impact of source address modification
        is more difficult to\n   quantify when the receiving application is not the
        one originally\n   intended and several fields have been modified in transit.\n"
      title: 3.1.2.  Corruption of the Source IP Address Field
    - contents:
      - "3.1.3.  Corruption of Port Information\n   This section describes what happens
        if one or both of the UDP port\n   values are corrupted in transit.  This
        can also happen when IPv4 is\n   used with a zero UDP checksum, but not when
        UDP checksums are\n   calculated or when UDP-Lite is used.  If the ports carried
        in the\n   transport header of an IPv6 packet are corrupted in transit, packets\n
        \  may be delivered to the wrong application process (on the intended\n   machine),
        responses or errors may be sent to the wrong application\n   process (on the
        intended machine), or both may occur.\n"
      title: 3.1.3.  Corruption of Port Information
    - contents:
      - "3.1.4.  Delivery to an Unexpected Port\n   If one combines the corruption
        effects, such as a corrupted\n   destination address and corrupted ports,
        there are a number of\n   potential outcomes when traffic arrives at an unexpected
        port.  The\n   following are the possibilities and their outcomes for a packet
        that\n   does not use UDP checksum validation:\n   o  The packet could be
        delivered to a port that is not in use.  The\n      packet is discarded, but
        could generate an ICMPv6 message (e.g.,\n      port unreachable).\n   o  The
        packet could be delivered to a different node that implements\n      the same
        application, so the packet may be accepted, but side\n      effects could
        occur or accumulated state could be generated.\n   o  The packet could be
        delivered to an application that does not\n      implement the tunnel protocol,
        so the packet may be incorrectly\n      parsed and may be misinterpreted,
        causing side effects or\n      generating accumulated state.\n   The probability
        of each outcome depends on the statistical\n   probability that the address
        or the port information for the source\n   or destination becomes corrupted
        in the datagram such that they match\n   those of an existing flow or server
        port.  Unfortunately, such a\n   match may be more likely for UDP than for
        connection-oriented\n   transports, because:\n   1.  There is no handshake
        prior to communication and no sequence\n       numbers (as in TCP, Datagram
        Congestion Control Protocol (DCCP),\n       and Stream Control Transmission
        Protocol (SCTP)).  This makes it\n       hard to verify that an application
        process is given only the\n       application data associated with a specific
        transport session.\n   2.  Applications writers often bind to wildcard values
        in endpoint\n       identifiers and do not always validate the correctness
        of\n       datagrams they receive.  (Guidance on this topic is provided in\n
        \      [RFC5405].)\n   While these rules could, in principle, be revised to
        declare naive\n   applications as \"historic\", this remedy is not realistic.
        \ The\n   transport owes it to the stack to do its best to reject bogus\n
        \  datagrams.\n   If checksum coverage is suppressed, the application needs
        to provide\n   a method to detect and discard the unwanted data.  A tunnel
        protocol\n   would need to perform its own integrity checks on any control\n
        \  information if it is transported in datagrams with a zero UDP\n   checksum.
        \ If the tunnel payload is another IP packet, the packets\n   requiring checksums
        can be assumed to have their own checksums,\n   provided that the rate of
        corrupted packets is not significantly\n   larger due to the tunnel encapsulation.
        \ If a tunnel transports other\n   inner payloads that do not use IP, the
        assumptions of corruption\n   detection for that particular protocol must
        be fulfilled.  This may\n   require an additional checksum/CRC and/or integrity
        protection of the\n   payload and tunnel headers.\n   A protocol that uses
        a zero UDP checksum cannot assume that it is the\n   only protocol using a
        zero UDP checksum.  Therefore, it needs to\n   handle misdelivery gracefully.
        \ It must be robust when malformed\n   packets are received on a listening
        port, and it must expect that\n   these packets may contain corrupted data
        or data associated with a\n   completely different protocol.\n"
      title: 3.1.4.  Delivery to an Unexpected Port
    - contents:
      - "3.1.5.  Corruption of Fragmentation Information\n   The fragmentation information
        in IPv6 employs a 32-bit identity field\n   (compared to only a 16-bit field
        in IPv4), a 13-bit fragment offset,\n   and a 1-bit flag indicating whether
        there are more fragments.\n   Corruption of any of these fields may result
        in one of two outcomes:\n   o  Reassembly failure: An error in the \"More
        Fragments\" field for the\n      last fragment will, for example, result in
        the packet never being\n      considered complete, so it will eventually be
        timed out and\n      discarded.  A corruption in the ID field will result
        in the\n      fragment not being delivered to the intended context, thus leaving\n
        \     the rest of the packet incomplete, unless that packet has been\n      duplicated
        before the corruption.  The incomplete packet will\n      eventually be timed
        out and discarded.\n   o  Erroneous reassembly: The reassembled packet did
        not match the\n      original packet.  This can occur when the ID field of
        a fragment\n      is corrupted, resulting in a fragment becoming associated
        with\n      another packet and taking the place of another fragment.\n      Corruption
        in the offset information can cause the fragment to be\n      misaligned in
        the reassembly buffer, resulting in incorrect\n      reassembly.  Corruption
        can cause the packet to become shorter or\n      longer; however, completing
        the reassembly is much less probable,\n      because this would require consistent
        corruption of the IPv6\n      header's payload length and offset fields.  To
        prevent erroneous\n      assembly, the reassembling stack must provide strong
        checks that\n      detect overlap and missing data.  Note, however, that this
        is not\n      guaranteed and has been clarified in \"Handling of Overlapping
        IPv6\n      Fragments\" [RFC5722].\n   The erroneous reassembly of packets
        is a general concern, and such\n   packets should be discarded instead of
        being passed to higher-layer\n   processes.  The primary detector of packet
        length changes is the IP\n   payload length field, with a secondary check
        provided by the\n   transport checksum.  The Upper-Layer Packet length field
        included in\n   the pseudo-header assists in verifying correct reassembly,
        because\n   the Internet checksum has a low probability of detecting insertion
        of\n   data or overlap errors (due to misplacement of data).  The checksum\n
        \  is also incapable of detecting insertion or removal of data that is\n   all-zero
        in a chunk that is a multiple of 16 bits.\n   The most significant risk of
        corruption results following mis-\n   association of a fragment with a different
        packet.  This risk can be\n   significant, because the size of fragments is
        often the same (e.g.,\n   fragments that form when the path MTU results in
        fragmentation of a\n   larger packet, which is common when addition of a tunnel\n
        \  encapsulation header increases the size of a packet).  Detection of\n   this
        type of error requires a checksum or other integrity check of\n   the headers
        and the payload.  While such protection is desirable for\n   tunnel encapsulations
        using IPv4, because the small fragmentation ID\n   can easily result in wraparound
        [RFC4963], this is especially\n   desirable for tunnels that perform flow
        aggregation [TUNNELS].\n   Tunnel fragmentation behavior matters.  There can
        be outer or inner\n   fragmentation tunnels in the Internet Architecture [TUNNELS].
        \ If\n   there is inner fragmentation by the tunnel, the outer headers will\n
        \  never be fragmented, and thus, a zero UDP checksum in the outer\n   header
        will not affect the reassembly process.  When a tunnel\n   performs outer
        header fragmentation, the tunnel egress needs to\n   perform reassembly of
        the outer fragments into an inner packet.  The\n   inner packet is either
        a complete packet or a fragment.  If it is a\n   fragment, the destination
        endpoint of the fragment will perform\n   reassembly of the received fragments.
        \ The complete packet or the\n   reassembled fragments will then be processed
        according to the packet\n   Next Header field.  The receiver may detect reassembly
        anomalies only\n   when it uses a protocol with a checksum.  The larger the
        number of\n   reassembly processes to which a packet has been subjected, the\n
        \  greater the probability of an error.  The following list describes\n   some
        tunnel fragmentation behaviors:\n   o  An IP-in-IP tunnel that performs inner
        fragmentation has similar\n      properties to a UDP tunnel with a zero UDP
        checksum that also\n      performs inner fragmentation.\n   o  An IP-in-IP
        tunnel that performs outer fragmentation has similar\n      properties to
        a UDP tunnel with a zero UDP checksum that performs\n      outer fragmentation.\n
        \  o  A tunnel that performs outer fragmentation can result in a higher\n
        \     level of corruption due to both inner and outer fragmentation,\n      enabling
        more chances for reassembly errors to occur.\n   o  Recursive tunneling can
        result in fragmentation at more than one\n      header level, even for fragmentation
        of the encapsulated packet,\n      unless the fragmentation is performed on
        the innermost IP header.\n   o  Unless there is verification at each reassembly,
        the probability\n      of undetected errors will increase with the number
        of times\n      fragmentation is recursively applied, making both IP-in-IP
        and UDP\n      with zero UDP checksum vulnerable to undetected errors.\n   In
        conclusion, fragmentation of datagrams with a zero UDP checksum\n   does not
        worsen the performance compared to some other commonly used\n   tunnel encapsulations.
        \ However, caution is needed for recursive\n   tunneling that offers no additional
        verification at the different\n   tunnel layers.\n"
      title: 3.1.5.  Corruption of Fragmentation Information
    title: 3.1.  Effect of Packet Modification in the Network
  - contents:
    - "3.2.  Where Packet Corruption Occurs\n   Corruption of IP packets can occur
      at any point along a network path:\n   during packet generation, during transmission
      over the link, in the\n   process of routing and switching, etc.  Some transmission
      steps\n   include a checksum or CRC that reduces the probability for corrupted\n
      \  packets being forwarded, but there still exists a probability that\n   errors
      may propagate undetected.\n   Unfortunately, the Internet community lacks reliable
      information to\n   identify the most common functions or equipment that results
      in\n   packet corruption.  However, there are indications that the place\n   where
      corruption occurs can vary significantly from one path to\n   another.  However,
      there is a risk in taking evidence from one usage\n   domain and using it to
      infer characteristics for another.  Methods\n   intended for general Internet
      usage must therefore assume that\n   corruption can occur, and mechanisms must
      be deployed to mitigate the\n   effects of corruption and any resulting misdelivery.\n"
    title: 3.2.  Where Packet Corruption Occurs
  - contents:
    - "3.3.  Validating the Network Path\n   IP transports designed for use in the
      general Internet should not\n   assume specific path characteristics.  Network
      protocols may reroute\n   packets, thus changing the set of routers and middleboxes
      along a\n   path.  Therefore, transports such as TCP, SCTP, and DCCP have been\n
      \  designed to negotiate protocol parameters, adapt to different network\n   path
      characteristics, and receive feedback to verify that the current\n   path is
      suited to the intended application.  Applications using UDP\n   and UDP-Lite
      need to provide their own mechanisms to confirm the\n   validity of the current
      network path.\n   A zero value in the UDP checksum field is explicitly disallowed
      in\n   RFC 2460.  Thus, it may be expected that any device on the path that\n
      \  has a reason to look beyond the IP header, for example, to validate\n   the
      UDP checksum, will consider such a packet as erroneous or illegal\n   and may
      discard it, unless the device is updated to support the new\n   behavior.  Any
      middlebox that modifies the UDP checksum, for example,\n   a NAT that changes
      the values of the IP and UDP header in such a way\n   that the checksum over
      the pseudo-header changes value, will need to\n   be updated to support this
      behavior.  Until then, a zero UDP checksum\n   packet is likely to be discarded,
      either directly in the middlebox or\n   at the destination, when a zero UDP
      checksum has been modified to be\n   non-zero by an incremental update.\n   A
      pair of endpoints intending to use the new behavior will therefore\n   need
      not only to ensure support at each endpoint, but also to ensure\n   that the
      path between them will deliver packets with the new\n   behavior.  This may
      require using negotiation or an explicit mandate\n   to use the new behavior
      by all nodes that support the new protocol.\n   Enabling the use of a zero checksum
      places new requirements on\n   equipment deployed within the network, such as
      middleboxes.  A\n   middlebox (e.g., a firewall or NAT) may enable zero checksum
      usage\n   for a particular range of ports.  Note that checksum off-loading and\n
      \  operating system design may result in all IPv6 UDP traffic being sent\n   with
      a calculated checksum.  This requires middleboxes that are\n   configured to
      enable a zero UDP checksum to continue to work with\n   bidirectional UDP flows
      that use a zero UDP checksum in only one\n   direction, and therefore, they
      must not maintain separate state for a\n   UDP flow based on its checksum usage.\n
      \  Support along the path between endpoints can be guaranteed in limited\n   deployments
      by appropriate configuration.  In general, it can be\n   expected to take time
      for deployment of any updated behavior to\n   become ubiquitous.\n   A sender
      will need to probe the path to verify the expected behavior.\n   Path characteristics
      may change, and usage therefore should be robust\n   and able to detect a failure
      of the path under normal usage, and\n   should be able to renegotiate.  Note
      that a bidirectional path does\n   not necessarily support the same checksum
      usage in both the forward\n   and return directions.  Receipt of a datagram
      with a zero UDP\n   checksum does not imply that the remote endpoint can also
      receive a\n   datagram with a zero UDP checksum.  This behavior will require\n
      \  periodic validation of the path, adding complexity to any solution\n   using
      the new behavior.\n"
    title: 3.3.  Validating the Network Path
  - contents:
    - "3.4.  Applicability of the Zero UDP Checksum Method\n   The update to the IPv6
      specification defined in [RFC6935] modifies\n   only IPv6 nodes that implement
      specific protocols designed to permit\n   omission of a UDP checksum.  This
      document provides an applicability\n   statement for the updated method, indicating
      when the mechanism can\n   (and cannot) be used.  Enabling a zero UDP checksum,
      and ensuring\n   correct interactions with the stack, implies much more than
      simply\n   disabling the checksum algorithm for specific packets at the\n   transport
      interface.\n   When the zero UDP checksum method is widely available, we expect
      that\n   it will be used by applications that perceive to gain benefit from\n
      \  it.  Any solution that uses an end-to-end transport protocol rather\n   than
      an IP-in-IP encapsulation needs to minimize the possibility that\n   application
      processes could confuse a corrupted or wrongly delivered\n   UDP datagram with
      that of data addressed to the application running\n   on their endpoint.\n   A
      protocol or application that uses the zero UDP checksum method must\n   ensure
      that the lack of checksum does not affect the protocol\n   operation.  This
      includes being robust to receiving an unintended\n   packet from another protocol
      or context following corruption of a\n   destination or source address and/or
      port value.  It also includes\n   considering the need for additional implicit
      protection mechanisms\n   required when using the payload of a UDP packet received
      with a zero\n   checksum.\n"
    title: 3.4.  Applicability of the Zero UDP Checksum Method
  - contents:
    - "3.5.  Impact on Non-Supporting Devices or Applications\n   It is important
      to consider the potential impact of using a zero UDP\n   checksum on endpoint
      devices and applications that are not modified\n   to support the new behavior
      or, by default or preference, do not use\n   the regular behavior.  These applications
      must not be significantly\n   impacted by the update.\n   To illustrate why
      this necessary, consider the implications of a node\n   that enables use of
      a zero UDP checksum at the interface level.  This\n   would result in all applications
      that listen to a UDP socket\n   receiving datagrams where the checksum was not
      verified.  This could\n   have a significant impact on an application that was
      not designed\n   with the additional robustness needed to handle received packets
      with\n   corruption, creating state or destroying existing state in the\n   application.\n
      \  Therefore, a zero UDP checksum needs to be enabled only for\n   individual
      ports using an explicit request by the application.  In\n   this case, applications
      using other ports would maintain the current\n   IPv6 behavior, discarding incoming
      datagrams with a zero UDP\n   checksum.  These other applications would not
      be affected by this\n   changed behavior.  An application that allows the changed
      behavior\n   should be aware of the risk of corruption and the increased level
      of\n   misdirected traffic, and can be designed robustly to handle this\n   risk.\n"
    title: 3.5.  Impact on Non-Supporting Devices or Applications
  title: 3.  Issues Requiring Consideration
- contents:
  - "4.  Constraints on Implementation of IPv6 Nodes Supporting Zero Checksum\n   This
    section is an applicability statement that defines requirements\n   and recommendations
    for the implementation of IPv6 nodes that support\n   the use of a zero value
    in the checksum field of a UDP datagram.\n   All implementations that support
    the zero UDP checksum method MUST\n   conform to the requirements defined below:\n
    \  1.   An IPv6 sending node MAY use a calculated RFC 2460 checksum for\n        all
    datagrams that it sends.  This explicitly permits an\n        interface that supports
    checksum off-loading to insert an\n        updated UDP checksum value in all UDP
    datagrams that it\n        forwards.  Note, however, that sending a calculated
    checksum\n        requires the receiver to also perform the checksum calculation.\n
    \       Checksum off-loading can normally be switched off for a\n        particular
    interface to ensure that datagrams are sent with a\n        zero UDP checksum.\n
    \  2.   IPv6 nodes SHOULD, by default, NOT allow the zero UDP checksum\n        method
    for transmission.\n   3.   IPv6 nodes MUST provide a way for the application/protocol
    to\n        indicate the set of ports that will be enabled to send datagrams\n
    \       with a zero UDP checksum.  This may be implemented by enabling a\n        transport
    mode using a socket API call when the socket is\n        established, or by a
    similar mechanism.  It may also be\n        implemented by enabling the method
    for a pre-assigned static\n        port used by a specific tunnel protocol.\n
    \  4.   IPv6 nodes MUST provide a method to allow an application/\n        protocol
    to indicate that a particular UDP datagram is required\n        to be sent with
    a UDP checksum.  This needs to be allowed by the\n        operating system at
    any time (e.g., to send keepalive\n        datagrams), not just when a socket
    is established in zero\n        checksum mode.\n   5.   The default IPv6 node
    receiver behavior MUST be to discard all\n        IPv6 packets carrying datagrams
    with a zero UDP checksum.\n   6.   IPv6 nodes MUST provide a way for the application/protocol
    to\n        indicate the set of ports that will be enabled to receive\n        datagrams
    with a zero UDP checksum.  This may be implemented via\n        a socket API call
    or by a similar mechanism.  It may also be\n        implemented by enabling the
    method for a pre-assigned static\n        port used by a specific tunnel protocol.\n
    \  7.   IPv6 nodes supporting usage of zero UDP checksums MUST also\n        allow
    reception using a calculated UDP checksum on all ports\n        configured to
    allow zero UDP checksum usage.  (The sending\n        endpoint, e.g., the encapsulating
    ingress, may choose to compute\n        the UDP checksum or may calculate it by
    default.)  The receiving\n        endpoint MUST use the reception method specified
    in RFC2460 when\n        the checksum field is not zero.\n   8.   RFC 2460 specifies
    that IPv6 nodes SHOULD log received datagrams\n        with a zero UDP checksum.
    \ This remains the case for any\n        datagram received on a port that does
    not explicitly enable\n        processing of a zero UDP checksum.  A port for
    which the zero\n        UDP checksum has been enabled MUST NOT log the datagram
    solely\n        because the checksum value is zero.\n   9.   IPv6 nodes MAY separately
    identify received UDP datagrams that\n        are discarded with a zero UDP checksum.
    \ They SHOULD NOT add\n        these to the standard log, because the endpoint
    has not been\n        verified.  This may be used to support other functions (such
    as\n        a security policy).\n   10.  IPv6 nodes that receive ICMPv6 messages
    that refer to packets\n        with a zero UDP checksum MUST provide appropriate
    checks\n        concerning the consistency of the reported packet to verify that\n
    \       the reported packet actually originated from the node, before\n        acting
    upon the information (e.g., validating the address and\n        port numbers in
    the ICMPv6 message body).\n"
  title: 4.  Constraints on Implementation of IPv6 Nodes Supporting Zero Checksum
- contents:
  - "5.  Requirements on Usage of the Zero UDP Checksum\n   This section is an applicability
    statement that identifies\n   requirements and recommendations for protocols and
    tunnel\n   encapsulations that are transported over an IPv6 transport flow\n   (e.g.,
    a tunnel) that does not perform a UDP checksum calculation to\n   verify the integrity
    at the transport endpoints.  Before deciding to\n   use the zero UDP checksum
    and lose the integrity verification\n   provided by non-zero checksumming, a protocol
    developer should\n   seriously consider if they can use checksummed UDP packets
    or UDP-\n   Lite [RFC3828], because IPv6 with a zero UDP checksum is not\n   equivalent
    in behavior to IPv4 with zero UDP checksum.\n   The requirements and recommendations
    for protocols and tunnel\n   encapsulations using an IPv6 transport flow that
    does not perform a\n   UDP checksum calculation to verify the integrity at the
    transport\n   endpoints are:\n   1.   Transported protocols that enable the use
    of zero UDP checksum\n        MUST enable this only for a specific port or port
    range.  This\n        needs to be enabled at the sending and receiving endpoints
    for a\n        UDP flow.\n   2.   An integrity mechanism is always RECOMMENDED
    at the transported\n        protocol layer to ensure that corruption rates of
    the delivered\n        payload are not increased (e.g., at the innermost packet
    of a\n        UDP tunnel).  A mechanism that isolates the causes of corruption\n
    \       (e.g., identifying misdelivery, IPv6 header corruption, or\n        tunnel
    header corruption) is also expected to provide additional\n        information
    about the status of the tunnel (e.g., to suggest a\n        security attack).\n
    \  3.   A transported protocol that encapsulates Internet Protocol (IPv4\n        or
    IPv6) packets MAY rely on the inner packet integrity checks,\n        provided
    that the tunnel protocol will not significantly\n        increase the rate of
    corruption of the inner IP packet.  If a\n        significantly increased corruption
    rate can occur, the tunnel\n        protocol MUST provide an additional integrity
    verification\n        mechanism.  Early detection is desirable to avoid wasting\n
    \       unnecessary computation, transmission capacity, or storage for\n        packets
    that will subsequently be discarded.\n   4.   A transported protocol that supports
    the use of a zero UDP\n        checksum MUST be designed so that corruption of
    any header\n        information does not result in accumulation of incorrect state\n
    \       for the protocol.\n   5.   A transported protocol with a non-tunnel payload
    or one that\n        encapsulates non-IP packets MUST have a CRC or other mechanism\n
    \       for checking packet integrity, unless the non-IP packet is\n        specifically
    designed for transmission over a lower layer that\n        does not provide a
    packet integrity guarantee.\n   6.   A transported protocol with control feedback
    SHOULD be robust to\n        changes in the network path, because the set of middleboxes
    on a\n        path may vary during the life of an association.  The UDP\n        endpoints
    need to discover paths with middleboxes that drop\n        packets with a zero
    UDP checksum.  Therefore, transported\n        protocols SHOULD send keepalive
    messages with a zero UDP\n        checksum.  An endpoint that discovers an appreciable
    loss rate\n        for keepalive packets MAY terminate the UDP flow (e.g., a\n
    \       tunnel).  Section 3.1.3 of RFC 5405 describes requirements for\n        congestion
    control when using a UDP-based transport.\n   7.   A protocol with control feedback
    that can fall back to using UDP\n        with a calculated RFC 2460 checksum is
    expected to be more\n        robust to changes in the network path.  Therefore,
    keepalive\n        messages SHOULD include both UDP datagrams with a checksum
    and\n        datagrams with a zero UDP checksum.  This will enable the remote\n
    \       endpoint to distinguish between a path failure and the dropping\n        of
    datagrams with a zero UDP checksum.\n   8.   A middlebox implementation MUST allow
    forwarding of an IPv6 UDP\n        datagram with both a zero and a standard UDP
    checksum using the\n        same UDP port.\n   9.   A middlebox MAY configure
    a restricted set of specific port\n        ranges that forward UDP datagrams with
    a zero UDP checksum.  The\n        middlebox MAY drop IPv6 datagrams with a zero
    UDP checksum that\n        are outside a configured range.\n   10.  When a middlebox
    forwards an IPv6 UDP flow containing datagrams\n        with both a zero and a
    standard UDP checksum, the middlebox MUST\n        NOT maintain separate state
    for flows, depending on the value of\n        their UDP checksum field.  (This
    requirement is necessary to\n        enable a sender that always calculates a
    checksum to communicate\n        via a middlebox with a remote endpoint that uses
    a zero UDP\n        checksum.)\n   Special considerations are required when designing
    a UDP tunnel\n   protocol where the tunnel ingress or egress may be a router that
    may\n   not have access to the packet payload.  When the node is acting as a\n
    \  host (i.e., sending or receiving a packet addressed to itself), the\n   checksum
    processing is similar to other hosts.  However, when the\n   node (e.g., a router)
    is acting as a tunnel ingress or egress that\n   forwards a packet to or from
    a UDP tunnel, there may be restricted\n   access to the packet payload.  This
    prevents calculating (or\n   verifying) a UDP checksum.  In this case, the tunnel
    protocol may use\n   a zero UDP checksum and must:\n   o  Ensure that tunnel ingress
    and tunnel egress router are both\n      configured to use a zero UDP checksum.
    \ For example, this may\n      include ensuring that hardware checksum off-loading
    is disabled.\n   o  The tunnel operator must ensure that middleboxes on the network\n
    \     path are updated to support use of a zero UDP checksum.\n   o  A tunnel
    egress should implement appropriate security techniques\n      to protect from
    overload, including source address filtering to\n      prevent traffic injection
    by an attacker and rate-limiting of any\n      packets that incur additional processing,
    such as UDP datagrams\n      used for control functions that require verification
    of a\n      calculated checksum to verify the network path.  Usage of common\n
    \     control traffic for multiple tunnels between a pair of nodes can\n      assist
    in reducing the number of packets to be processed.\n"
  title: 5.  Requirements on Usage of the Zero UDP Checksum
- contents:
  - "6.  Summary\n   This document provides an applicability statement for the use
    of UDP\n   transport checksums with IPv6.\n   It examines the role of the UDP
    transport checksum when used with\n   IPv6 and presents a summary of the trade-offs
    in evaluating the\n   safety of updating RFC 2460 to permit an IPv6 endpoint to
    use a zero\n   UDP checksum field to indicate that no checksum is present.\n   Application
    designers should first examine whether their transport\n   goals may be met using
    standard UDP (with a calculated checksum) or\n   UDP-Lite.  The use of UDP with
    a zero UDP checksum has merits for\n   some applications, such as tunnel encapsulation,
    and is widely used\n   in IPv4.  However, there are different dangers for IPv6.
    \ There is an\n   increased risk of corruption and misdelivery when using zero
    UDP\n   checksum in IPv6 compared to using IPv4 due to the lack of an IPv6\n   header
    checksum.  Thus, application designers need to evaluate the\n   risks of enabling
    use of a zero UDP checksum and consider a solution\n   that at least provides
    the same delivery protection as for IPv4, for\n   example, by utilizing UDP-Lite
    or by enabling the UDP checksum.  The\n   use of checksum off-loading may help
    alleviate the cost of checksum\n   processing and permit use of a checksum using
    method defined in RFC\n   2460.\n   Tunnel applications using UDP for encapsulation
    can, in many cases,\n   use a zero UDP checksum without significant impact on
    the corruption\n   rate.  A well-designed tunnel application should include consistency\n
    \  checks to validate the header information encapsulated with a\n   received
    packet.  In most cases, tunnels encapsulating IP packets can\n   rely on the integrity
    protection provided by the transported protocol\n   (or tunneled inner packet).
    \ When correctly implemented, such an\n   endpoint will not be negatively impacted
    by the omission of the\n   transport-layer checksum.  Recursive tunneling and
    fragmentation are\n   potential issues that can raise corruption rates significantly,
    and\n   they require careful consideration.\n   Other UDP applications at the
    intended destination node or another\n   node can be impacted if the nodes are
    allowed to receive datagrams\n   that have a zero UDP checksum.  It is important
    that already deployed\n   applications are not impacted by a change at the transport
    layer.  If\n   these applications execute on nodes that implement RFC 2460, they\n
    \  will discard (and log) all datagrams with a zero UDP checksum.  This\n   is
    not an issue.\n   In general, UDP-based applications need to employ a mechanism
    that\n   allows a large percentage of the corrupted packets to be removed\n   before
    they reach an application, to protect both the data stream of\n   the application
    and the control plane of higher layer protocols.\n   These checks are currently
    performed by the UDP checksum for IPv6 or\n   by the reduced checksum for UDP-Lite
    when used with IPv6.\n   The transport of recursive tunneling and the use of fragmentation\n
    \  pose difficult issues that need to be considered in the design of\n   tunnel
    protocols.  There is an increased risk of an error in the\n   innermost packet
    when fragmentation occurs across several layers of\n   tunneling and several different
    reassembly processes are run without\n   verification of correctness.  This requires
    extra thought and careful\n   consideration in the design of transported tunnels.\n
    \  Any use of the updated method must consider the implications for\n   firewalls,
    NATs, and other middleboxes.  It is not expected that IPv6\n   NATs will handle
    IPv6 UDP datagrams in the same way that they handle\n   IPv4 UDP datagrams.  In
    many deployed cases, an update to support an\n   IPv6 zero UDP checksum will be
    required.  Firewalls are intended to\n   be configured, and therefore, they may
    need to be explicitly updated\n   to allow new services or protocols.  Deployment
    of IPv6 middleboxes\n   is not yet as prolific as it is in IPv4, and therefore,
    new devices\n   are expected to follow the methods specified in this document.\n
    \  Each application should consider the implications of choosing an IPv6\n   transport
    that uses a zero UDP checksum and should consider whether\n   other standard methods
    may be more appropriate and may simplify\n   application design.\n"
  title: 6.  Summary
- contents:
  - "7.  Security Considerations\n   Transport checksums provide the first stage of
    protection for the\n   stack, although they cannot be considered authentication
    mechanisms.\n   These checks are also desirable to ensure that packet counters\n
    \  correctly log actual activity, and they can be used to detect unusual\n   behaviors.\n
    \  Depending on the hardware design, the processing requirements may\n   differ
    for tunnels that have a zero UDP checksum and those that\n   calculate a checksum.
    \ This processing overhead may need to be\n   considered when deciding whether
    to enable a tunnel and to determine\n   an acceptable rate for transmission.  This
    can become a security risk\n   for designs that can handle a significantly larger
    number of packets\n   with zero UDP checksums compared to datagrams with a non-zero\n
    \  checksum, such as a tunnel egress.  An attacker could attempt to\n   inject
    non-zero checksummed UDP packets into a tunnel that is\n   forwarding zero checksum
    UDP packets and cause overload in the\n   processing of the non-zero checksums,
    e.g., if it happens in a\n   router's slow path.  Protection mechanisms should
    therefore be\n   employed when this threat exists.  Protection may include source-\n
    \  address filtering to prevent an attacker from injecting traffic, as\n   well
    as throttling the amount of non-zero checksum traffic.  The\n   latter may impact
    the functioning of the tunnel protocol.\n   Transmission of IPv6 packets with
    a zero UDP checksum could reveal\n   additional information to help an on-path
    attacker identify the\n   operating system or configuration of a sending node.
    \ There is a need\n   to probe the network path to determine whether the current
    path\n   supports the use of IPv6 packets with a zero UDP checksum.  The\n   details
    of the probing mechanism may differ for different tunnel\n   encapsulations, and
    if they are visible in the network (e.g., if not\n   using IPsec in encryption
    mode), they could reveal additional\n   information to help an on-path attacker
    identify the type of tunnel\n   being used.\n   IP-in-IP or GRE tunnels offer
    good traversal of middleboxes that have\n   not been designed for security, e.g.,
    firewalls.  However, firewalls\n   may be expected to be configured to block general
    tunnels, because\n   they present a large attack surface.  This applicability
    statement\n   therefore permits this method to be enabled only for specific port\n
    \  ranges.\n   When the zero UDP checksum mode is enabled for a range of ports,\n
    \  nodes and middleboxes must forward received UDP datagrams that have\n   either
    a calculated checksum or a zero checksum.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  Acknowledgments\n   We would like to thank Brian Haberman, Brian Carpenter,
    Margaret\n   Wasserman, Lars Eggert, and others in the TSV directorate.  Barry\n
    \  Leiba, Ronald Bonica, Pete Resnick, and Stewart Bryant helped to make\n   this
    document one with greater applicability.  Thanks to P.F.\n   Chimento for careful
    review and editorial corrections.\n   Thanks also to Remi Denis-Courmont, Pekka
    Savola, Glen Turner, and\n   many others who contributed comments and ideas via
    the 6man, behave,\n   lisp, and mboned lists.\n"
  title: 8.  Acknowledgments
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC0768]     Postel, J., \"User Datagram Protocol\",
      STD 6, RFC 768,\n                 August 1980.\n   [RFC0791]     Postel, J.,
      \"Internet Protocol\", STD 5, RFC 791,\n                 September 1981.\n   [RFC2119]
      \    Bradner, S., \"Key words for use in RFCs to Indicate\n                 Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2460]     Deering, S. and R.
      Hinden, \"Internet Protocol, Version\n                 6 (IPv6) Specification\",
      RFC 2460, December 1998.\n   [RFC6935]     Eubanks, M., Chimento, P., and M.
      Westerlund, \"IPv6 and\n                 UDP Checksums for Tunneled Packets\",
      RFC 6935,\n                 April 2013.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [AMT]         Bumgardner, G., \"Automatic
      Multicast Tunneling\", Work\n                 in Progress, June 2012.\n   [RFC0793]
      \    Postel, J., \"Transmission Control Protocol\", STD 7,\n                 RFC
      793, September 1981.\n   [RFC1071]     Braden, R., Borman, D., Partridge, C.,
      and W. Plummer,\n                 \"Computing the Internet checksum\", RFC 1071,\n
      \                September 1988.\n   [RFC1141]     Mallory, T. and A. Kullberg,
      \"Incremental updating of\n                 the Internet checksum\", RFC 1141,
      January 1990.\n   [RFC1624]     Rijsinghani, A., \"Computation of the Internet
      Checksum\n                 via Incremental Update\", RFC 1624, May 1994.\n   [RFC2827]
      \    Ferguson, P. and D. Senie, \"Network Ingress Filtering:\n                 Defeating
      Denial of Service Attacks which employ IP\n                 Source Address Spoofing\",
      BCP 38, RFC 2827, May 2000.\n   [RFC3550]     Schulzrinne, H., Casner, S., Frederick,
      R., and V.\n                 Jacobson, \"RTP: A Transport Protocol for Real-Time\n
      \                Applications\", STD 64, RFC 3550, July 2003.\n   [RFC3819]
      \    Karn, P., Bormann, C., Fairhurst, G., Grossman, D.,\n                 Ludwig,
      R., Mahdavi, J., Montenegro, G., Touch, J., and\n                 L. Wood, \"Advice
      for Internet Subnetwork Designers\",\n                 BCP 89, RFC 3819, July
      2004.\n   [RFC3828]     Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E.,\n
      \                and G. Fairhurst, \"The Lightweight User Datagram\n                 Protocol
      (UDP-Lite)\", RFC 3828, July 2004.\n   [RFC4443]     Conta, A., Deering, S.,
      and M. Gupta, \"Internet Control\n                 Message Protocol (ICMPv6)
      for the Internet Protocol\n                 Version 6 (IPv6) Specification\",
      RFC 4443, March 2006.\n   [RFC4963]     Heffner, J., Mathis, M., and B. Chandler,
      \"IPv4\n                 Reassembly Errors at High Data Rates\", RFC 4963,\n
      \                July 2007.\n   [RFC5097]     Renker, G. and G. Fairhurst, \"MIB
      for the UDP-Lite\n                 protocol\", RFC 5097, January 2008.\n   [RFC5405]
      \    Eggert, L. and G. Fairhurst, \"Unicast UDP Usage\n                 Guidelines
      for Application Designers\", BCP 145,\n                 RFC 5405, November 2008.\n
      \  [RFC5415]     Calhoun, P., Montemurro, M., and D. Stanley, \"Control\n                 And
      Provisioning of Wireless Access Points (CAPWAP)\n                 Protocol Specification\",
      RFC 5415, March 2009.\n   [RFC5722]     Krishnan, S., \"Handling of Overlapping
      IPv6 Fragments\",\n                 RFC 5722, December 2009.\n   [RFC6437]     Amante,
      S., Carpenter, B., Jiang, S., and J.\n                 Rajahalme, \"IPv6 Flow
      Label Specification\", RFC 6437,\n                 November 2011.\n   [RFC6438]
      \    Carpenter, B. and S. Amante, \"Using the IPv6 Flow Label\n                 for
      Equal Cost Multipath Routing and Link Aggregation\n                 in Tunnels\",
      RFC 6438, November 2011.\n   [RFC6830]     Farinacci, D., Fuller, V., Meyer,
      D., and D. Lewis,\n                 \"The Locator/ID Separation Protocol (LISP)\",
      RFC 6830,\n                 January 2013.\n   [Sigcomm2000] Stone, J. and C.
      Partridge, \"When the CRC and TCP\n                 Checksum Disagree\", 2000,\n
      \                <http://conferences.sigcomm.org/sigcomm/2000/conf/\n                 abstract/9-1.htm>.\n
      \  [TUNNELS]     Touch, J. and M. Townsley, \"Tunnels in the Internet\n                 Architecture\",
      Work in Progress, March 2010.\n   [UDPTT]       Fairhurst, G., \"The UDP Tunnel
      Transport mode\", Work in\n                 Progress, February 2010.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Appendix A.  Evaluation of Proposal to Update RFC 2460 to Support Zero\n             Checksum\n
    \  This informative appendix documents the evaluation of the proposal to\n   update
    IPv6 [RFC2460] such that it provides the option that some\n   nodes may suppress
    generation and checking of the UDP transport\n   checksum.  It also compares this
    proposal with other alternatives,\n   and notes that for a particular application,
    some standard methods\n   may be more appropriate than using IPv6 with a zero
    UDP checksum.\n"
  - contents:
    - "A.1.  Alternatives to the Standard Checksum\n   There are several alternatives
      to the normal method for calculating\n   the UDP checksum [RFC1071] that do
      not require a tunnel endpoint to\n   inspect the entire packet when computing
      a checksum.  These include:\n   o  IP-in-IP tunneling.  Because this method
      completely dispenses with\n      a transport protocol in the outer layer, it
      has reduced overhead\n      and complexity, but also reduced functionality.
      \ There is no outer\n      checksum over the packet, and also there are no ports
      to perform\n      demultiplexing among different tunnel types.  This reduces
      the\n      available information upon which a load balancer may act.\n   o  UDP-Lite
      with the checksum coverage set to only the header portion\n      of a packet.
      \ This requires a pseudo-header checksum calculation\n      only on the encapsulating
      packet header.  The computed checksum\n      value may be cached (before adding
      the Length field) for each\n      flow/destination and subsequently combined
      with the Length of each\n      packet to minimize per-packet processing.  This
      value is combined\n      with the UDP payload length for the pseudo-header.
      \ However, this\n      length is expected to be known when performing packet
      forwarding.\n   o  Delta computation of the checksum from an encapsulated checksum\n
      \     field.  Because the checksum is a cumulative sum [RFC1624], an\n      encapsulating
      header checksum can be derived from the new pseudo-\n      header, the inner
      checksum, and the sum of the other network-layer\n      fields not included
      in the pseudo-header of the encapsulated\n      packet, in a manner resembling
      incremental checksum update\n      [RFC1141].  This would not require access
      to the whole packet, but\n      does require fields to be collected across the
      header and\n      arithmetic operations to be performed on each packet.  The
      method\n      would work only for packets that contain a 2's complement\n      transport
      checksum (i.e., it would not be appropriate for SCTP or\n      when IP fragmentation
      is used).\n   o  UDP has been modified to disable checksum processing (Zero
      UDP\n      Checksum) [RFC6935].  This eliminates the need for a checksum\n      calculation,
      but would require constraints on appropriate usage\n      and updates to endpoints
      and middleboxes.\n   o  The proposed UDP Tunnel Transport [UDPTT] protocol suggested
      a\n      method where UDP would be modified to derive the checksum only\n      from
      the encapsulating packet protocol header.  This value does\n      not change
      between packets in a single flow.  The value may be\n      cached per flow/destination
      to minimize per-packet processing.\n   o  A method has been proposed that uses
      a new (to-be-defined) IPv6\n      Destination Options Header to provide an end-to-end
      validation\n      check at the network layer.  This would allow an endpoint
      to\n      verify delivery to an appropriate endpoint, but would also require\n
      \     IPv6 nodes to correctly handle the additional header and would\n      require
      changes to middlebox behavior (e.g., when used with a NAT\n      that always
      adjusts the checksum value).\n   o  There has been a proposal to simply ignore
      the UDP checksum value\n      on reception at the tunnel egress, allowing a
      tunnel ingress to\n      insert any value, correct or false.  For tunnel usage,
      a non-\n      standard checksum value may be used, forcing an RFC 2460 receiver\n
      \     to drop the packet.  The main downside is that it would be\n      impossible
      to identify a UDP datagram (in the network or an\n      endpoint) that is treated
      in this way compared to a packet that\n      has actually been corrupted.\n
      \  These options are compared and discussed further in the following\n   sections.\n"
    title: A.1.  Alternatives to the Standard Checksum
  - contents:
    - "A.2.  Comparison of Alternative Methods\n   This section compares the methods
      listed above to support datagram\n   tunneling.  It includes proposals for updating
      the behavior of UDP.\n   While this comparison focuses on applications that
      are expected to\n   execute on routers, the distinction between a router and
      a host is\n   not always clear, especially at the transport level.  Systems
      (such\n   as UNIX-based operating systems) routinely provide both functions.\n
      \  From a received packet, there is no way to identify the role of the\n   receiving
      node.\n"
    - contents:
      - "A.2.1.  Middlebox Traversal\n   Regular UDP with a standard checksum or the
        delta-encoded\n   optimization for creating correct checksums has the best
        possibility\n   for successful traversal of a middlebox.  No new support is
        required.\n   A method that ignores the UDP checksum on reception is expected
        to\n   have a good probability of traversal, because most middleboxes\n   perform
        an incremental checksum update.  UDPTT would also be able to\n   traverse
        a middlebox with this behavior.  However, a middlebox on the\n   path that
        attempts to verify a standard checksum will not forward\n   packets using
        either of these methods, thus preventing traversal.  A\n   method that ignores
        the checksum has the additional downside that it\n   prevents improvement
        of middlebox traversal, because there is no way\n   to identify UDP datagrams
        that use the modified checksum behavior.\n   IP-in-IP or GRE tunnels offer
        good traversal of middleboxes that have\n   not been designed for security,
        e.g., firewalls.  However, firewalls\n   may be expected to be configured
        to block general tunnels, because\n   they present a large attack surface.\n
        \  A new IPv6 Destination Options header will suffer traversal issues\n   with
        middleboxes, especially firewalls and NATs, and will likely\n   require them
        to be updated before the extension header is passed.\n   Datagrams with a
        zero UDP checksum will not be passed by any\n   middlebox that validates the
        checksum using RFC 2460 or updates the\n   checksum field, such as NAT or
        firewalls.  This would require an\n   update to correctly handle a datagram
        with a zero UDP checksum.\n   UDP-Lite will require an update of almost all
        types of middleboxes,\n   because it requires support for a separate network-layer
        protocol\n   number.  Once enabled, the method to support incremental checksum\n
        \  updates would be identical to that for UDP, but different for\n   checksum
        validation.\n"
      title: A.2.1.  Middlebox Traversal
    - contents:
      - "A.2.2.  Load Balancing\n   The usefulness of solutions for load balancers
        depends on the\n   difference in entropy in the headers for different flows
        that can be\n   included in a hash function.  All the proposals that use the
        UDP\n   protocol number have equal behavior.  UDP-Lite has the potential for\n
        \  behavior that is equally as good as UDP.  However, UDP-Lite is\n   currently
        unlikely to be supported by deployed hashing mechanisms,\n   which could cause
        a load balancer not to use the transport header in\n   the computed hash.
        \ A load balancer that uses only the IP header will\n   have low entropy,
        but this could be improved by including the IPv6\n   the flow label, provided
        that the tunnel ingress ensures that\n   different flow labels are assigned
        to different flows.  However, a\n   transition to the common use of good quality
        flow labels is likely to\n   take time to deploy.\n"
      title: A.2.2.  Load Balancing
    - contents:
      - "A.2.3.  Ingress and Egress Performance Implications\n   IP-in-IP tunnels
        are often considered efficient, because they\n   introduce very little processing
        and have low data overhead.  The\n   other proposals introduce a UDP-like
        header, which incurs an\n   associated data overhead.  Processing is minimized
        for the method\n   that uses a zero UDP checksum and for the method that ignores
        the UDP\n   checksum on reception, and processing is only slightly higher
        for\n   UDPTT, the extension header, and UDP-Lite.  The delta calculation\n
        \  scheme operates on a few more fields, but also introduces serious\n   failure
        modes that can result in a need to calculate a checksum over\n   the complete
        datagram.  Regular UDP is clearly the most costly to\n   process, always requiring
        checksum calculation over the entire\n   datagram.\n   It is important to
        note that the zero UDP checksum method, ignoring\n   checksum on reception,
        the Option Header, UDPTT, and UDP-Lite will\n   likely incur additional complexities
        in the application to\n   incorporate a negotiation and validation mechanism.\n"
      title: A.2.3.  Ingress and Egress Performance Implications
    - contents:
      - "A.2.4.  Deployability\n   The major factors influencing deployability of
        these solutions are a\n   need to update both endpoints, a need for negotiation,
        and the need\n   to update middleboxes.  These are summarized below:\n   o
        \ The solution with the best deployability is regular UDP.  This\n      requires
        no changes and has good middlebox traversal\n      characteristics.\n   o
        \ The next easiest to deploy is the delta checksum solution.  This\n      does
        not modify the protocol on the wire and needs changes only in\n      the tunnel
        ingress.\n   o  IP-in-IP tunnels should not require changes to the endpoints,
        but\n      they raise issues regarding the traversal of firewalls and other\n
        \     security devices, which are expected to require updates.\n   o  Ignoring
        the checksum on reception will require changes at both\n      endpoints.  The
        never-ceasing risk of path failure requires\n      additional checks to ensure
        that this solution is robust, and it\n      will require changes or additions
        to the tunnel control protocol\n      to negotiate support and validate the
        path.\n   o  The remaining solutions (including the zero UDP checksum method)\n
        \     offer similar deployability.  UDP-Lite requires support at both\n      endpoints
        and in middleboxes.  UDPTT and the zero UDP checksum\n      method, with or
        without an extension header, require support at\n      both endpoints and
        in middleboxes.  UDP-Lite, UDPTT, and the zero\n      UDP checksum method
        and the use of extension headers may also\n      require changes or additions
        to the tunnel control protocol to\n      negotiate support and path validation.\n"
      title: A.2.4.  Deployability
    - contents:
      - "A.2.5.  Corruption Detection Strength\n   The standard UDP checksum and the
        delta checksum can both provide\n   some verification at the tunnel egress.
        \ This can significantly\n   reduce the probability that a corrupted inner
        packet is forwarded.\n   UDP-Lite, UDPTT, and the extension header all provide
        some\n   verification against corruption, but they do not verify the inner\n
        \  packet.  They provide only a strong indication that the delivered\n   packet
        was intended for the tunnel egress and was correctly\n   delimited.\n   The
        methods using a zero UDP checksum, ignoring the UDP checksum on\n   reception,
        and IP-and-IP encapsulation all provide no verification\n   that a received
        datagram was intended to be processed by a specific\n   tunnel egress or that
        the inner encapsulated packet was correct.\n   Section 3.1 discusses experience
        using specific protocols in well-\n   managed networks.\n"
      title: A.2.5.  Corruption Detection Strength
    - contents:
      - "A.2.6.  Comparison Summary\n   The comparisons above may be summarized as,
        \"there is no silver\n   bullet that will slay all the issues\".  One has
        to select which\n   downsides can best be lived with.  Focusing on the existing\n
        \  solutions, they can be summarized as:\n   Regular UDP:  The method defined
        in RFC 2460 has good middlebox\n      traversal and load balancing and multiplexing,
        and requires a\n      checksum in the outer headers to cover the whole packet.\n
        \  IP-in-IP:  A low-complexity encapsulation that has limited middlebox\n
        \     traversal, no multiplexing support, and poor load-balancing\n      support
        that could improve over time.\n   UDP-Lite:  A medium-complexity encapsulation
        that has good\n      multiplexing support, limited middlebox traversal that
        may\n      possibly improve over time, and poor load-balancing support that\n
        \     could improve over time, and that, in most cases, requires\n      application-level
        negotiation to select the protocol and\n      validation to confirm that the
        path forwards UDP-Lite.\n   Delta computation of a tunnel checksum:  The delta
        checksum is an\n      optimization in the processing of UDP, and, as such,
        it exhibits\n      some of the drawbacks of using regular UDP.\n   The remaining
        proposals may be described in similar terms:\n   Zero Checksum:  A low-complexity
        encapsulation that has good\n      multiplexing support, limited middlebox
        traversal that could\n      improve over time, and good load-balancing support,
        and that, in\n      most cases, requires application-level negotiation and
        validation\n      to confirm that the path forwards a zero UDP checksum.\n
        \  UDPTT:  A medium-complexity encapsulation that has good multiplexing\n
        \     support, limited middlebox traversal that may possibly improve\n      over
        time, and good load-balancing support, and that, in most\n      cases, requires
        application-level negotiation to select the\n      transport and validation
        to confirm the path forwards UDPTT\n      datagrams.\n   IPv6 Destination
        Option IP-in-IP Tunneling:  A medium-complexity\n      encapsulation that
        has no multiplexing support, limited middlebox\n      traversal, and poor
        load-balancing support that could improve over\n      time, and that, in most
        cases, requires negotiation to confirm\n      that the option is supported
        and validation to confirm the path\n      forwards the option.\n   IPv6 Destination
        Option Combined with Zero UDP Checksum:  A medium-\n      complexity encapsulation
        that has good multiplexing support,\n      limited load-balancing support
        that could improve over time, and\n      that, in most cases, requires negotiation
        to confirm the option is\n      supported and validation to confirm the path
        forwards the option.\n   Ignore the Checksum on Reception:  A low-complexity
        encapsulation\n      that has good multiplexing support, medium middlebox
        traversal\n      that can never improve, and good load-balancing support,
        and that,\n      in most cases, requires negotiation to confirm that the option
        is\n      supported by the remote endpoint and validation to confirm the\n
        \     path forwards a zero UDP checksum.\n   There is no clear single optimum
        solution.  If the most important\n   need is to traverse middleboxes, the
        best choice is to stay with\n   regular UDP and consider the optimizations
        that may be required to\n   perform the checksumming.  If one can live with
        limited middlebox\n   traversal, if low complexity is necessary, and one does
        not require\n   load balancing, IP-in-IP tunneling is the simplest.  If one
        wants\n   strengthened error detection, but with the currently limited\n   middlebox
        traversal and load balancing, UDP-Lite is appropriate.\n   Zero UDP checksum
        addresses another set of constraints: low\n   complexity and a need for load
        balancing from the current Internet,\n   provided that the usage can accept
        the currently limited support for\n   middlebox traversal.\n   Techniques
        for load balancing and middlebox traversal do continue to\n   evolve.  Over
        a long time, developments in load balancing have good\n   potential to improve.
        \ This time horizon is long, because it requires\n   both load balancer and
        endpoint updates to get full benefit.  The\n   challenges of middlebox traversal
        are also expected to change with\n   time as device capabilities evolve.  Middleboxes
        are very prolific,\n   with a larger proportion of end user ownership, and
        therefore may be\n   expected to take a long time to evolve.\n   However,
        we note that the deployment of IPv6-capable middleboxes is\n   still in its
        initial phase, and if a new method becomes standardized\n   quickly, fewer
        boxes will be non-compliant.\n   Thus, the question of whether to permit use
        of datagrams with a zero\n   UDP checksum for IPv6 under reasonable constraints
        is best viewed as\n   a trade-off among a number of more subjective questions:\n
        \  o  Is there sufficient interest in using a zero UDP checksum with the\n
        \     given constraints (summarized below)?\n   o  Are there other avenues
        of change that will resolve the issue in a\n      better way and sufficiently
        quickly ?\n   o  Do we accept the complexity cost of having one more solution
        in\n      the future?\n   The analysis concludes that the IETF should carefully
        consider\n   constraints on sanctioning the use of any new transport mode.
        \ The\n   6man working group of the IETF has determined that the answers to
        the\n   above questions are sufficient to update IPv6 to standardize use of
        a\n   zero UDP checksum for use by tunnel encapsulations for specific\n   applications.\n
        \  Each application should consider the implications of choosing an IPv6\n
        \  transport that uses a zero UDP checksum.  In many cases, standard\n   methods
        may be more appropriate and may simplify application design.\n   The use of
        checksum off-loading may help alleviate the checksum\n   processing cost and
        permit use of a checksum using the method defined\n   in RFC 2460.\n"
      title: A.2.6.  Comparison Summary
    title: A.2.  Comparison of Alternative Methods
  title: Appendix A.  Evaluation of Proposal to Update RFC 2460 to Support Zero
- contents:
  - "Authors' Addresses\n   Godred Fairhurst\n   University of Aberdeen\n   School
    of Engineering\n   Aberdeen, AB24 3UE\n   Scotland, UK\n   EMail: gorry@erg.abdn.ac.uk\n
    \  URI:   http://www.erg.abdn.ac.uk/users/gorry\n   Magnus Westerlund\n   Ericsson\n
    \  Farogatan 6\n   Stockholm,  SE-164 80\n   Sweden\n   Phone: +46 8 719 0000\n
    \  EMail: magnus.westerlund@ericsson.com\n"
  title: Authors' Addresses
