- title: __initial_text__
  contents:
  - '              Unified Memory Space Protocol Specification

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies Unified Memory Space Protocol (UMSP), which\n\
    \   gives a capability of immediate access to memory of the remote nodes.\n"
- title: Conventions used in this document
  contents:
  - "Conventions used in this document\n   The key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC-2119 [2].\n   The following syntax specification uses the augmented Backus-Naur\n\
    \   Form (ABNF) as described in RFC-2234 [3].\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction...................................................4\n\
    \   2.  The UMSP Model.................................................5\n   \
    \  2.1  128-bit Address Space.......................................5\n     2.2\
    \  Computing Model.............................................7\n     2.3  System\
    \ Architecture.........................................9\n   3.  Instruction Format............................................11\n\
    \     3.1  Instruction Header.........................................12\n   \
    \  3.2  Extension Headers..........................................15\n     3.3\
    \  Instruction Operands.......................................17\n     3.4  Address\
    \ Formats............................................17\n   4.  Response of the\
    \ Instructions..................................19\n     4.1  RSP, RSP_P.................................................20\n\
    \     4.2  SND_CANCEL.................................................20\n   5.\
    \  Jobs Management...............................................21\n     5.1\
    \  Job Initiate...............................................23\n       5.1.1\
    \  CONTROL_REQ............................................24\n       5.1.2  CONTROL_CONFIRM........................................25\n\
    \       5.1.3  CONTROL_REJECT.........................................26\n   \
    \  5.2  Task Initiate..............................................26\n      \
    \ 5.2.1  TASK_REG...............................................26\n       5.2.2\
    \  TASK_CONFIRM...........................................27\n       5.2.3  TASK_REJECT............................................28\n\
    \       5.2.4  TASK_CHK...............................................28\n   \
    \  5.3  Establishment of session connection........................29\n      \
    \ 5.3.1  SESSION_OPEN...........................................29\n       5.3.2\
    \  SESSION_ACCEPT.........................................31\n       5.3.3  SESSION_REJECT.........................................31\n\
    \       5.3.4  Connection Profile.....................................32\n   \
    \  5.4  Session Closing............................................33\n      \
    \ 5.4.1  SESSION_CLOSE..........................................34\n       5.4.2\
    \  SESSION_ABEND..........................................35\n     5.5  Task Termination...........................................35\n\
    \       5.5.1  TASK_TERMINATE.........................................36\n   \
    \    5.5.2  TASK_TERMINATE_INFO....................................36\n     5.6\
    \  Job Completion.............................................37\n       5.6.1\
    \  JOB_COMPLETED..........................................37\n       5.6.2  JOB_COMPLETED_INFO.....................................38\n\
    \     5.7  Activity Control of Nodes..................................38\n   \
    \    5.7.1  _INACTION_TIME.........................................39\n      \
    \ 5.7.2  STATE_REQ..............................................40\n       5.7.3\
    \  TASK_STATE.............................................41\n       5.7.4  NODE_RELOAD............................................42\n\
    \     5.8  Work without session connection............................42\n   6.\
    \  Instructions of Exchange between VM...........................44\n     6.1\
    \  Data Reading/Writing Instructions..........................45\n       6.1.1\
    \  REQ_DATA...............................................45\n       6.1.2  DATA...................................................46\n\
    \       6.1.3  WRITE..................................................46\n   \
    \    6.1.4  WRITE_EXT..............................................47\n     6.2\
    \  Comparison Instructions....................................47\n       6.2.1\
    \  CMP....................................................47\n       6.2.2  CMP_EXT................................................48\n\
    \       6.2.3  Response to Comparison Instructions....................48\n   \
    \  6.3  Control Transfer Instructions..............................48\n      \
    \ 6.3.1  JUMP, CALL.............................................48\n       6.3.2\
    \  RETURN.................................................49\n     6.4  Memory\
    \ Control Instructions................................50\n       6.4.1  MEM_ALLOC..............................................50\n\
    \       6.4.2  MVCODE.................................................50\n   \
    \    6.4.3  ADDRESS................................................51\n      \
    \ 6.4.4  FREE...................................................51\n       6.4.5\
    \  MVRUN..................................................51\n     6.5  Other\
    \ Instructions.........................................52\n       6.5.1  SYN....................................................52\n\
    \       6.5.2  NOP....................................................53\n   \
    \  6.6  Work with Objects..........................................53\n      \
    \ 6.6.1  Reading/Writing of the Objects Data....................54\n         6.6.1.1\
    \  OBJ_REQ_DATA.......................................54\n         6.6.1.2  OBJ_WRITE..........................................55\n\
    \         6.6.1.3  OBJ_WRITE_EXT......................................56\n   \
    \    6.6.2  Comparison Instructions of the Objects Data............56\n      \
    \   6.6.2.1  OBJ_DATA_CMP.......................................56\n         6.6.2.2\
    \  OBJ_DATA_CMP_EXT...................................57\n       6.6.3  Execution\
    \ of the Objects Procedures....................57\n         6.6.3.1  CALL_BNUM..........................................57\n\
    \         6.6.3.2  CALL_BNAME.........................................58\n   \
    \      6.6.3.3  GET_NUM_PROC.......................................59\n      \
    \   6.6.3.4  PROC_NUM...........................................59\n       6.6.4\
    \  The Objects Creation...................................59\n         6.6.4.1\
    \  NEW, SYS_NEW.......................................60\n         6.6.4.2  OBJECT.............................................61\n\
    \         6.6.4.3  DELETE.............................................61\n   \
    \    6.6.5  The Objects Identification.............................61\n      \
    \   6.6.5.1  OBJ_SEEK...........................................62\n         6.6.5.2\
    \  OBJ_GET_NAME.......................................62\n   7.  Chains........................................................62\n\
    \     7.1  Sequence...................................................63\n   \
    \  7.2  Transaction................................................64\n      \
    \ 7.2.1  _BEGIN_TR..............................................64\n       7.2.2\
    \  EXEC_TR................................................65\n       7.2.3  CANCEL_TR..............................................66\n\
    \     7.3  Fragmented instruction.....................................66\n   \
    \  7.4  Buffering..................................................67\n     7.5\
    \  Acknowledgement of chains..................................69\n     7.6  Base-displacement\
    \ Addressing...............................70\n   8.  Extension Headers.............................................71\n\
    \     8.1  _ALIGNMENT.................................................71\n   \
    \  8.2  _MSG.......................................................71\n     8.3\
    \  _NAME......................................................72\n     8.4  _DATA......................................................72\n\
    \     8.5  _LIFE_TIME.................................................72\n   9.\
    \  Search of resources...........................................73\n     9.1\
    \  VM_REQ.....................................................75\n     9.2  VM_NOTIF...................................................75\n\
    \   10.  Security Consideration.......................................77\n   11.\
    \  Used Abbreviations...........................................78\n   12.  References...................................................79\n\
    \   13.  Author's Address.............................................80\n   14.\
    \  Full Copyright Statement.....................................81\n"
- title: 1  Introduction
  contents:
  - "1  Introduction\n   UMSP is the network connection-oriented protocol.  It corresponds\
    \ to\n   session and presentation layers of model OSI.  The protocol is\n   designed\
    \ for implementation in a wide class of systems, from simple\n   devices based\
    \ on the dedicated processors, up to universal computers\n   and clusters.\n \
    \  For the data exchange, the protocol uses transport layer service with\n   reliable\
    \ delivery.  It is possible to use not providing reliable\n   delivery protocol\
    \ for the transmission of not requiring\n   acknowledgement data.  This document\
    \ describes use TCP and UDP.\n   The creation of network environment for the organization\
    \ 128-bit\n   address space of memory distributed between Internet nodes is the\n\
    \   basic purpose of the protocol UMSP.  The protocol defines algorithm\n   of\
    \ the connections management and format of network primitives.  It\n   doesn't\
    \ control local memory on the node.\n   As against the traditional network protocols,\
    \ the user applications\n   on different nodes interact not by the network primitives\
    \ exchanging\n   or working with the dataflows, but by immediate data reading/write\
    \ or\n   control transfers to the code in virtual memory of the remote node.\n\
    \   The user's application can know nothing about existence of the\n   protocol\
    \ and network, and simply use the instructions with 128-bit\n   addresses.\n \
    \  Firstly, it is supposed to use UMSP in systems based on the virtual\n   machines\
    \ (VM), executing the pseudo-code.  However, the protocol may\n   be used in systems\
    \ executing a processor code, for example, in\n   clusters or in universal operational\
    \ systems, for the organization of\n   the distributed virtual address space.\
    \  Besides, the minimal profile\n   of the protocol may be used in simple devices,\
    \ which do not have the\n   operational system.\n   The protocol gives various\
    \ means for set the connection parameters\n   and allows building systems with\
    \ a high protection level without\n   restriction applications functionalities.\n\
    \   UMSP can essentially simplify the distributed systems development\n   process.\
    \  It gives an opportunity to unite not only information, but\n   also calculating\
    \ resources of the large number of polytypic computers\n   without significant\
    \ expenses for the programs standardization and\n   development.\n"
- title: 2  The UMSP Model
  contents:
  - '2  The UMSP Model

    '
- title: 2.1  128-bit Address Space
  contents:
  - "2.1  128-bit Address Space\n   UMSP is based on the 128-bit distributed address\
    \ memory space model.\n   The 128-bit address contains the information about the\
    \ network type,\n   network node address and local memory address.  It has the\
    \ following\n   format:\n   Octets\n    0      1                             \
    \                       16\n   +------+--------------+--------------------+----------------+\n\
    \   |Header|     FREE     |     NODE_ADDR      |    MEM_ADDR    |\n   +------+--------------+--------------------+----------------+\n\
    \   Complete address length is fixed and is equal to 16 octets.\n   Header\n \
    \     1 octet.  Address header field completely defines the address\n      format.\
    \  The header has the following format:\n      Bits\n       0     1     2    \
    \ 3     4     5     6     7\n      +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \      |      ADDR_LENGTH      |  NET_TYPE | ADDR_CODE |\n      +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \      ADDR_LENGTH\n         4 bits.  The length of the network address.  This\
    \ field\n         contains the number of octets in the NODE_ADDR field.  The\n\
    \         value 0 is not allowed.\n      NET_TYPE\n         2 bits.  The network\
    \ type.  This field specifies a type of\n         network, in which the node is.\n\
    \      ADDR_CODE\n         2 bits.  The length code of the local memory address.\
    \  The\n         value of this field specifies the length of the local memory\n\
    \         address.  The following values of the field and appropriated to\n  \
    \       them length of the field MEM_ADDR are defined:\n            %b00 - 16\
    \ bit\n            %b01 - 24 bit\n            %b10 - 32 bit\n            %b11\
    \ - 64 bit\n      The values combination of the three fields of heading is named\n\
    \      address format number.  These fields unequivocally define a\n      network,\
    \ in which the node is located.  Format number writes as\n      follows:\n   \
    \      N <ADDR_LENGTH> - <NET_TYPE> - <ADDR_CODE>\n      For example, N 4-0-2\
    \ defines the address with length of the node\n      network address 4 octets\
    \ and memory address with the length 32\n      bits.  The network type 0 for such\
    \ address format is defined for\n      the network IPv4 in the presented document.\
    \  If the network type\n      is equal to zero, it may be missed during the writing\
    \ of the\n      address format number.  For example, format N 4-0-2 and 4-2 are\n\
    \      equivalent.  If both fields NET_TYPE and ADDR_CODE are set to\n      zero,\
    \ they may be omitted.  Thus, a format number writes as one\n      figure.\n \
    \     One or several address format numbers must be assigned for each\n      global\
    \ network, included in unified system.\n   FREE\n      0 - 12 octets.  This field\
    \ is unused by the protocol.  It may\n      contain any additional information,\
    \ which is necessary for the\n      control system of the node memory.  If this\
    \ field is not used, the\n      zero value must be set in all octets.  Using of\
    \ this field results\n      that the network instructions must contain only complete\
    \ 16 -\n      octet address and the short address of local memory cannot be\n\
    \      used.\n   NODE_ADDR\n      1 - 13 octets.  The node address.  The format\
    \ of this field is\n      defined separately for each address format number. \
    \ The field of\n      the node address should not necessary precisely correspond\
    \ to the\n      real network address.  If the real network address is longer than\n\
    \      this field, it is necessary to organize in the network a subset of\n  \
    \    supporting the protocol UMSP addresses.\n   MEM_ADDR\n      16/24/32/64 bits.\
    \  The address of local memory.  This field is the\n      memory address in system,\
    \ which is set by a field NODE_ADDR.  The\n      node completely responds for\
    \ its memory control.  The protocol\n      does not define the order of using\
    \ and format of this field.\n   128-bit address for the user applications is one\
    \ field.  The user\n   code cannot know about a physical arrangement of addressed\
    \ memory.\n   The 128-bit memory address may be transmits between nodes, as the\n\
    \   data, for example, in the buffer of function parameters, or in the\n   instruction\
    \ of copying the data.  Therefore, it must identify the\n   given node from any\
    \ other nodes unequivocal.\n   Any certain algorithm, connecting real network\
    \ and 128-bit address,\n   does not exist.  All used address formats must be known\
    \ beforehand.\n   As UMSP has its own address space, it can unite several global\n\
    \   networks.  The nodes can have internal local networks or subordinated\n  \
    \ addressable devices connected with the node by the not-network\n   communications.\
    \  Any node by address format number must have an\n   opportunity to define the\
    \ gateway respond for routing of this\n   address.\n"
- title: 2.2  Computing Model
  contents:
  - "2.2  Computing Model\n   Computing model is three-layer:\n      (1) Job\n   \
    \   (2) Task\n      (3) Thread of control\n   The job corresponds to the user\
    \ application.  The job is distributed\n   and can simultaneously be executed\
    \ on many nodes.  The job control is\n   carried out centralize, from the node\
    \ named as Job Control Point\n   (JCP).  One JCP can control the some jobs.  JCP\
    \ can be located on the\n   same node, on which the job is created, or on any\
    \ other addressed net\n   point.\n   The task is the job presentation on the separate\
    \ node.  The task\n   includes one or several computing threads of control.  The\
    \ job has\n   only one task on each node.\n   The job is finished, when the appropriate\
    \ user application is\n   finished.  At the end of the job all tasks of this job\
    \ on all nodes\n   are finished.\n   The job has its isolated 128-bit address\
    \ space.  The address space is\n   segmented.  A segment is the local memory of\
    \ one node.  Besides, the\n   protocol allows working with objects.  The objects\
    \ are separate\n   associative memory of the node.\n   The task thread represents\
    \ the concrete control thread, which are\n   executed by VM in the certain node.\
    \  The thread can read and write to\n   any address of 128-bit address space of\
    \ the job.  The control\n   transfer to the address from other (remote) node,\
    \ results to the\n   creation of the new thread on the remote node.  The continuous\
    \ code\n   segment cannot be distributed on several nodes.  In addition, it is\n\
    \   impossible to receive continuous memory area distributed on several\n   nodes.\n\
    \   The protocol does not demand to support the different tasks of not-\n   crossed\
    \ memory space from the separate VM node.  The supporting of\n   multi-thread\
    \ is not also the obligatory requirement.\n   The 128-bit Global Job Identifier\
    \ (GJID) is defined by protocol.  It\n   is assigned on JCP, which will control\
    \ the job.  All active GJID have\n   the unique values in the unified system at\
    \ each moment of time.\n   The job can contain VM code of different types.  Different\
    \ types VM\n   can be situated on one or different nodes.  The mechanism of\n\
    \   association of different VM types in groups on one node is\n   stipulated,\
    \ so to the non-uniform code can be executed on one node in\n   a context of one\
    \ job.  The groups are described in details in section\n   9.  VM, incorporated\
    \ in groups, must work in common memory space (to\n   have a common subsystem\
    \ of memory control).\n"
- title: 2.3  System Architecture
  contents:
  - "2.3  System Architecture\n   System structure, based on using Virtual Machines,\
    \ is given in the\n   following figure:\n              Node 1                \
    \              Node 2\n             --------                            --------\n\
    \      +--------------------+              +--------------------+\n      | User\
    \ Application 1 |              | User Application 1 |\n      +-----------------------+\
    \           +-----------------------+\n         | User Application N |       \
    \       | User Application N |\n         +--------------------+              +--------------------+\n\
    \   +-----+  +-----+       +-----+      +-----+  +-----+       +-----+\n   | VM1\
    \ |  | VM2 | . . . | VMn |      | VM1 |  | VM2 | . . . | VMn |\n   +--+--+  +--+--+\
    \       +--+--+      +--+--+  +--+--+       +--+--+\n      |        |        \
    \     |            |        |             |\n    +--------------------------+\
    \        +--------------------------+\n    |                          |      \
    \  |                          |\n    | +-----+  U M S P         |        |   \
    \       U M S P         |\n    | | JCP |                  |        |         \
    \                 |\n    | +-----+                  |        +-------------+------------+\n\
    \    +-------------+------------+                      |\n                  |\
    \                             +-----+-----+\n            +-----+-----+       \
    \                |    TCP    |\n            |    TCP    |                    \
    \   +-----+-----+\n            +-----+-----+                             |\n \
    \                 |                                   |\n                  +-----------------/\
    \                 |\n                                   /------------------+\n\
    \                                  /\n                                  |\n  \
    \                          +-----+-----+\n                Node N      |    TCP\
    \    |\n               --------     +-----+-----+\n                          \
    \        |\n                     +------------+------------+\n               \
    \      | +-----+                 |\n                     | | JCP | U M S P   \
    \      |\n                     | +-----+                 |\n                 \
    \    +-------------------------+\n         Figure 1. Structure of the system based\
    \ on use VM.\n   One or several VM are working on upper level for UMSP.  The VM\
    \ layer\n   is not network level.  Last network level is UMSP.  Therefore, VM\n\
    \   layer has no its own network primitives and uses together with UMSP\n   the\
    \ same field of operation code.\n   The end services user of the protocol is the\
    \ user code, which is\n   executed by the virtual machine.  It has the instructions\
    \ with the\n   128-bit address.  VM translates these instructions to network\n\
    \   commands, which are transmitted through the UMSP protocol for the\n   executing\
    \ by the remote machine.  Internal organization VM, command\n   system and API\
    \ can be anyone.  The protocol defines only format of\n   primitives, which the\
    \ virtual machines exchange through a network.\n   The protocol does not control\
    \ the jobs memory.  Control of memory\n   should realize VM.  If a few VM works\
    \ on one node, they may have the\n   common memory space or may be completely\
    \ isolated.\n   UMSP uses the transport layer with reliable delivery for the data\n\
    \   exchange.  This document defines of using TCP.  For the transfer of\n   not\
    \ requiring acknowledgement data may be used UDP.  Thus, the\n   connection through\
    \ TCP is obligatory.  Use of multiple connections\n   TCP with multiplexing is\
    \ supposed.  The control of transport\n   connections is not the part of the UMSP\
    \ protocol.\n   The UMSP instructions do not contain network addresses of the\n\
    \   receiver and sender.  The protocol requires that one address UMSP\n   must\
    \ correspond to the one transport layer address.  Accordingly, it\n   is necessary\
    \ to define unequivocal the node address on transport\n   layer by the 128-bit\
    \ address of memory.\n   Except the TCP, it is possible to use other transport\
    \ protocols or\n   not network communications.  The following requirements are\
    \ showed to\n   them:\n      o  Reliable delivery.  The transport layer must inform\
    \ about\n         delivery or its impossibility;\n      o  The violation of a\
    \ sequence of transmitted segments is allowed;\n      o  The duplication of segments\
    \ is not allowed;\n      o  At emergency reload of nodes it is necessary to guarantee\n\
    \         identification of segments concerning session connections,\n       \
    \  assigned up to reload;\n      o  Use connectionless-mode is possible.\n   VM\
    \ is the independent program and the interaction with the protocol\n   is necessary\
    \ for it only when it executes the instructions with the\n   128-bit address,\
    \ concerning to other node.  VM can execute several\n   user tasks.  Each task\
    \ can contain several threads of control.  VM\n   must be able to interpret the\
    \ application instructions with the 128-\n   bit address to one or several instructions\
    \ of the UMSP protocol.\n   The session connection opens between nodes for the\
    \ data exchange.\n   One connection is relational only with one job.  There may\
    \ be several\n   session connections for the different jobs simultaneously between\
    \ two\n   nodes.  Besides, the protocol provides the connectionless data\n   exchange.\n\
    \   The exchange between UMSP nodes can include the instructions of the\n   following\
    \ type:\n      o  Immediate reading/write in memory;\n      o  Requests of allocation/free\
    \ memory;\n      o  Comparison instructions;\n      o  Call-subroutine and unconditional\
    \ jump instructions;\n      o  Synchronization instructions;\n      o  Work with\
    \ objects instructions - reading / writing in memory of\n         objects and\
    \ execution of objects procedures.\n   UMSP does not trace the user control threads.\
    \  VM must provide itself\n   the necessary order of performance of the instructions.\n\
    \   The length of UMSP instructions does not depend on segment length of\n   the\
    \ transport layer.  The segmentation is provided for transfer of\n   the long\
    \ instructions.  The packing of the short instructions in one\n   segment with\
    \ a possibility of compression of headings is used for its\n   transfer.  The\
    \ minimal size of necessary for work segment is 6\n   octets.  For realization\
    \ of all functions, it is necessary 54 octets.\n"
- title: 3  Instruction Format
  contents:
  - "3  Instruction Format\n   The UMSP instruction includes the basic header, extension\
    \ headers and\n   operands.  All fields have variable length.\n   +----------------+----------------------+------------------------+\n\
    \   |     Header     |   Extension headers  |       Operands         |\n   +----------------+----------------------+------------------------+\n\
    \   The header contains operation code and the information necessary for\n   the\
    \ instruction interpretation.\n   The optional extension headers contain the additional\
    \ information,\n   not defined in basic header.\n   The operands contain instructions\
    \ data.\n   The instruction format allows calculating common instruction length,\n\
    \   without knowing definition of separate operation code.\n   The instructions\
    \ headers provide for the short and extended format\n   for maintenance of the\
    \ effective protocol work in wide range of\n   network speeds.  Besides, there\
    \ is a simple algorithm of the headers\n   compression.\n   The all instructions\
    \ and extension headers the identifiers are given\n   which enter the name by\
    \ upper case symbols.  The identifiers of the\n   instructions begin with the\
    \ letter.  The identifiers of the extension\n   headers begin with underlining\
    \ symbol.\n"
- title: 3.1  Instruction Header
  contents:
  - "3.1  Instruction Header\n   The header has the following format:\n    Octets:\n\
    \       +0                              +1\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   0: |            OPCODE             |ASK|  PCK  |CHN|EXT| OPR_LENGTH|\n   \
    \   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   2: |\
    \                        OPR_LENGTH_EXT                         |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   4: |                         CHAIN_NUMBER                          |\n   \
    \   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   6: |\
    \                         INSTR_NUMBER                          |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   8: |                                                               |\n   \
    \   +                          SESSION_ID                           +\n      |\
    \                                                               |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   12:|                                                               |\n   \
    \   +                            REQ_ID                             +\n      |\
    \                                                               |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   OPCODE\n      1 octet.  The operation code.  Value of this field is identified\
    \ by\n      the instruction.  Values of operation codes are divided into the\n\
    \      following intervals:\n             1 - 112  management instructions\n \
    \          113 - 127  reserved\n           128 - 223  instructions of exchange\
    \ between VM\n         0, 224, 255  reserved\n   ASK\n      1 bit.  The flag of\
    \ response necessity.  This flag defines\n      presence of field REQ_ID in header.\
    \  If ASK = 1, there is field\n      REQ_ID in the instruction.  If EXT = 0, the\
    \ field REQ_ID in the\n      instruction are absent.\n   PCK\n      2 bits.  The\
    \ Header compression attribute.  These bits are used\n      for packing instructions\
    \ headers transmitted on one connection TCP\n      or for sending of the several\
    \ instructions in one package UDP.\n      Use of these bits is based on the assumption\
    \ that two following in\n      succession instructions concern to one session\
    \ connection, or one\n      chain, with a high probability.  The PCK bits have\
    \ one of the\n      following values:\n      %b00 - The instruction does not belong\
    \ to the definite session.\n             The fields CHAIN_NUMBER, INSTR_NUMBER\
    \ and SESSION_ID are\n             absent in header of such instruction.\n   \
    \   %b01 - The given instruction concerns to the same session\n             connection,\
    \ as previous.  The field SESSION_ID in the\n             instruction header is\
    \ absent.\n      %b10 - The given instruction belongs to the same connection and\n\
    \             same chain, as previous.  The fields CHAIN_NUMBER,\n           \
    \  INSTR_NUMBER and SESSION_ID in header of such instruction\n             are\
    \ absent.  The INSTR_NUMBER value of the current\n             instruction calculates\
    \ by addition of one to INSTR_NUMBER\n             value of the previous instruction.\n\
    \      %b11 - The given instruction may does not concern to the same\n       \
    \      session, as previous.  The field SESSION_ID is present at\n           \
    \  it.  The presence of fields CHAIN_NUMBER and INSTR_NUMBER\n             is\
    \ defined by CHN flag.\n   CHN\n      1 bit.  The flag of chain.  Transmitted\
    \ on one session connection\n      and concerning one job instructions, may be\
    \ unified in a chain.\n      Chains are considered in details by section 7.  If\
    \ SEQ = 1, the\n      instruction is connected with chain and there are fields\n\
    \      CHAIN_NUMBER and INSTR_NUMBER (if PCK is not set to %b10) at it.\n    \
    \  If bit CHN = 0, the instruction is not connected with chains and\n      there\
    \ are no fields CHAIN_NUMBER and INSTR_NUMBER in it.\n   EXT\n      1 bit.  The\
    \ flag of extension headers presence in the instruction.\n      If EXT = 1, there\
    \ is one or more extension headers in the\n      instruction.  If EXT = 0, the\
    \ extension headers in the instruction\n      are absent.\n   OPR_LENGTH\n   \
    \   3 bits.  The number of 32 bit words in the operands field.  The\n      value\
    \ 0 defines absence of operands field.  The value %b111\n      specifies use of\
    \ the extended header format.  In the extended\n      format, the length of operands\
    \ is defined by the field\n      OPR_LENGTH_EXT, and the field OPR_LENGTH is not\
    \ used.\n   OPR_LENGTH_EXT\n      2 octets.  The number of 32 bit words in the\
    \ operands field.  The\n      field OPR_LENGTH_EXT is present in header, only\
    \ if OPR_LENGTH =\n      %b111.  If OPR_LENGTH < > %b111, the field OPR_LENGTH_EXT\
    \ is\n      absent.  If OPR_LENGTH_EXT = 0, the field of operands is absent.\n\
    \      There are following reasons, on which it is necessary to use field\n  \
    \    OPR_LENGTH_EXT instead of OPR_LENGTH:\n         (1) If operands length must\
    \ be more than 24 octets\n         (2) If making the fields alignment of 4 octets\
    \ is more\n             effective, than compression of header of 2 octets.\n \
    \  CHAIN_NUMBER\n      2 octets.  The number of chain.  This field contains number\
    \ of\n      chain, to which the given instruction concerns.  The values %x0000\n\
    \      and %xFFFF are reserved.\n   INSTR_NUMBER\n      2 octets.  The instruction\
    \ number.  This field contains the serial\n      number of instruction in a chain.\
    \  The numbering begins with zero.\n      Value %xFFFF is reserved.\n   SESSION_ID\n\
    \      4 octets.  It is the identifier of the session connection assigned\n  \
    \    by the instruction receiver.  During the session connection\n      opening,\
    \ each side sets its own identifier to connection and\n      informs it to other\
    \ side.  The zero value of this field specifies\n      that the instruction does\
    \ not concern to the definite session.\n      The value %xFFFFFFFF is reserved.\n\
    \   REQ_ID\n      4 octets.  The request identifier.  It is uses for establishment\n\
    \      of correspondence between requests and responds to it.\n   Further, the\
    \ identifier OPR_LENGTH is used at the description of the\n   instructions format.\
    \  It means using of OPR_LENGTH_EXT field, if\n   OPR_LENGTH = %b111.  The instruction\
    \ with length of operands, which\n   are not exceeding 24 octets, may be transmitted\
    \ with header in the\n   short format (OPR_LENGTH < > %b111) or in the extended\
    \ format\n   (OPR_LENGTH = %b111).  Both forms are equivalent.\n   Minimal header\
    \ length in the short format is 2 octets, in the\n   extended format - 4 octets.\
    \  Maximal header length is 16 octets.\n"
- title: 3.2  Extension Headers
  contents:
  - "3.2  Extension Headers\n   If the EXT flag in the instruction header set to 1,\
    \ the instruction\n   contains from one up to thirty extension headers.  The extension\n\
    \   headers are used for the following purposes:\n   o  For sending of the service\
    \ information which were not provided in\n      the basic header.\n   o  For sending\
    \ of the data of length more than 262240 octets in one\n      instruction.\n \
    \  The extension headers have the following common format:\n   Octets:\n     \
    \  +0                              +1\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   0: |HXT|       HEAD_LENGTH         |       HEAD_LENGTH_EXT         |\n   \
    \   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   2: |\
    \                   continued HEAD_LENGTH_EXT                   |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   4: |HSL|HOB|HRZ|     HEAD_CODE     |         HEAD_CODE_EXT         |\n   \
    \   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   6: |\
    \                           RESERVED                            |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   8: |                                                               |\n   \
    \   /                             DATA                              /\n      /\
    \                                                               /\n      |   \
    \                                                            |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   HXT\n      1 bit.  Specify length of the field of data length.  If HXT = 0,\n\
    \      length of the extension header is defined by a field HEAD_LENGTH.\n   \
    \   The field HEAD_LENGTH_EXT in this case is absent.  If HXT = 1,\n      length\
    \ of header is defined by unification of fields HEAD_LENGTH\n      and HEAD_LENGTH_EXT.\n\
    \   HEAD_LENGTH\n      7 bit.  The number of 16 bit words in DATA field.  If HXT\
    \ = 0,\n      this is independent field.  If HXT = 1, it is the senior bits of\n\
    \      complete length field.\n   HEAD_LENGTH_EXT\n      3 octets.  The number\
    \ of 16 bit words in DATA field.  If HXT = 0,\n      this field is absent.  If\
    \ HXT = 1, it is the younger bits of\n      complete length field.\n   HSL\n \
    \     1 bit.  The flag of last header.  It is set to 1 for last\n      extension\
    \ header in the instruction.  In other extension headers,\n      this flag is\
    \ set to 0.\n   HOB\n      1 bit.  The flag of obligatory processing.  It defines\
    \ the order\n      of the instruction processing, if the receiving node does not\
    \ know\n      purpose of the extension header or cannot process it by any\n  \
    \    reason.  If HOB = 1, instruction must not be carried out.  If HOB\n     \
    \ = 0, it does not influence on the instruction processing.  The\n      protocol\
    \ must process all extension headers, irrespective of\n      errors presence.\n\
    \   HRZ\n      1 bit.  The field is reserved for the future expansions.  This\n\
    \      field must not be analyzed by the protocol on receiving.  It must\n   \
    \   be set to 0 at sending.\n   HEAD_CODE\n      5 bits.  If HXT = 0, the field\
    \ contains the extension header code.\n      If HXT = 1, this field joins the\
    \ field HEAD_CODE_EXT.  It is the\n      senior bits of the header code.\n   HEAD_CODE_EXT\n\
    \      1 octet.  If HXT = 0, this field is absent.  If HXT = 1, it is the\n  \
    \    younger bits of the header code.\n   RESERVED\n      2 octets.  If HXT =\
    \ 0, this field is absent.  If HXT = 1, this\n      field is reserved for further\
    \ use.  The field RESERVED must not be\n      analyzed by the protocol during\
    \ the receiving in the current\n      realization of the protocol.  It must be\
    \ set to 0 at sending.\n   DATA\n      The data field of the extension header.\
    \  If HXT = 0, the length of\n      field is 0 - 254 octets, if HXT = 1, the length\
    \ is 0 - 4 * 10^9\n      octets.  The format of this field is defined separately\
    \ for each\n      value of the header code.\n   On the receiving side, the extension\
    \ headers must be processed in\n   that order, in what they follow in the instruction.\
    \  If the\n   instruction contains more than 30 extension headers, it is considered\n\
    \   erroneous.  It is necessary to break off the session connection, on\n   which\
    \ it was transmitted, after the reception of such instruction.\n   The identifiers\
    \ HEAD_LENGTH and HEAD_CODE are used further in the\n   text at the description\
    \ of the extended headers format.  It assumes\n   using of fields HEAD_LENGTH\
    \ + HEAD_LENGTH_EXT and HEAD_CODE +\n   HEAD_CODE_EXT, if HXT = 1.  The headers\
    \ with the code 0 - 30 can be\n   sent in short (HXT = 0) and in extended (HXT\
    \ = 1) format.\n"
- title: 3.3  Instruction Operands
  contents:
  - "3.3  Instruction Operands\n   The operands field contains the instruction data.\
    \  The length of\n   operands field is showed in OPR_LENGTH or OPR_LENGTH_EXT\
    \ and it is\n   multiple to four octets.  If necessary, 1 - 3 zero-value octets\
    \ are\n   padded in the end of a field.  Maximal length of operands is 262140\n\
    \   octets.  The extension headers are used, if the instruction must\n   contain\
    \ longer data.\n   The format of the operands field is defined separately for\
    \ each\n   instruction.\n"
- title: 3.4  Address Formats
  contents:
  - "3.4  Address Formats\n   The following address format numbers are definite for\
    \ nodes,\n   immediately connected to the global IPv4 network:\n      N 4-0-0\
    \ (4)\n      N 4-0-1 (4-1)\n      N 4-0-2 (4-2)\n   The appropriate formats of\
    \ 128-bit addresses:\n   Octets:\n      +0              +1              +2   \
    \           +3\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   0: |0 1 0 0|0 0|0 0|                   Free                        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   4: |\
    \                              Free                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   8: |            Free               |           IP address          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   12:|\
    \           IP address          |      Local memory address     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   0:\
    \ |0 1 0 0|0 0|0 1|                   Free                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   4: |                              Free                             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   8: |\
    \     Free      |                  IP address                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   12:|   IP address  |             Local memory address              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   0: |0 1 0 0|0 0|1 0|                   Free                        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   4: |\
    \                            Free                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   8: |                         IP address                            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   12:|\
    \                     Local memory address                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Free\n      It is not used by the protocol.\n   IP address\n      It sets\
    \ the node address in the global IPv4 network.\n   Local memory address\n    \
    \  It is described in section 2.1.\n   IP-address defines the nodes of the given\
    \ type unequivocally.  The\n   TCP is used for the interaction with such nodes.\
    \  For sending of not\n   requiring response instructions, using UDP is allowed.\
    \  IANA has\n   assigned ports TCP and UDP 2110.  This port must be open for the\n\
    \   listening (receiving).  TCP node, initialing the connection opening,\n   or\
    \ the UDP node, carrying out the package sending, can use any port.\n   Using\
    \ several TCP connections with multiplexing is supposed.\n"
- title: 4  Response of the Instructions
  contents:
  - "4  Response of the Instructions\n   The protocol instructions are divided into\
    \ two types:\n      (1)  The management instructions transmitted on UMSP layer\
    \ (OPCODE\n           = 1 - 112).\n      (2)  The instructions of the exchange\
    \ between VM (OPCODE = 128 -\n           223).\n   The processing of two types\
    \ of the instructions differs as follows:\n   o  The field of the identifier of\
    \ request REQ_ID is formed by the\n      protocol in the instructions of the first\
    \ type, and it is formed\n      by VM for the instructions of the second type.\n\
    \   o  The protocol must analyze the field REQ_ID and compare it with the\n  \
    \    instructions, transmitted earlier, after receiving of the response\n    \
    \  instruction of the first type.\n   o  The protocol must not analyze the field\
    \ REQ_ID after receiving of\n      the response instruction of the second type.\
    \  This instruction is\n      simply sent to VM.\n   The response instructions\
    \ have the field ASK equal to 1.  It means,\n   that the header have the field\
    \ REQ_ID.  The value taken from the\n   confirmed instruction is written into\
    \ the field REQ_ID.  The response\n   instruction does not require response.\n\
    \   A few VM can be connected to the protocol on the node.  Everyone VM\n   can\
    \ work in its own address space.  The identifiers of requests for\n   different\
    \ VM can coincide.  Therefore, instruction is identified by\n   two fields:\n\
    \   o  The session identifier SESSION_ID, which is connected with\n      definite\
    \ VM.\n   o  The request identifier REQ_ID.\n"
- title: 4.1  RSP, RSP_P
  contents:
  - "4.1  RSP, RSP_P\n   \"Response\" (RSP) and \"Response of the protocol\" (RSP_P)\
    \ instructions\n   have the identical format.  The difference is only in the operation\n\
    \   code:\n      OPCODE = 129/1  ; correspondingly to RSP/RSP_P\n      ASK = 1\n\
    \      PCK = %b01/11\n      EXT = 0/1\n      CHN = 0\n      OPR_LENGTH = 0/1\n\
    \      SESSION_ID and REQ_ID - The values is taken from the confirmed\n      \
    \                        instruction.\n      Operands:\n         2 octets: The\
    \ basic return code.\n         2 octets: The additional return code.\n      The\
    \ optional extension header:\n         _MSG - contains the arbitrary error description.\n\
    \   The instruction without operands is used for the positive response.\n   It\
    \ is equivalent to zero values of the field of the basic and\n   additional return\
    \ codes.\n   The zero basic return code is used for positive response.  The\n\
    \   additional return code may have non-zero value.\n   The instruction with non-zero\
    \ basic return code is used for negative\n   response.  The basic return code\
    \ defines the error category.  The\n   additional return code identifies an error.\n\
    \   The instruction RSP is formed upon the VM request.  The return codes\n   must\
    \ be received from VM.  If the protocol cannot deliver the\n   requiring response\
    \ instruction to VM, it forms negative response RSP\n   independently.\n   The\
    \ instruction RSP_P is always formed at the UMSP layer.  If the\n   protocol cannot\
    \ define on what instruction the RSP_P is transmitted,\n   nothing actions is\
    \ executed.\n"
- title: 4.2  SND_CANCEL
  contents:
  - "4.2  SND_CANCEL\n   There can be a necessity to cancel sending after the part\
    \ of the data\n   have been already transmitted and have occupied the buffer on\
    \ the\n   reception side, by sending of the long fragmented instructions or\n\
    \   transactions.  The protocol provides the instruction \"The sending is\n  \
    \ canceled\" (SND_CANCEL) for this purpose.  This instruction has the\n   following\
    \ fields value:\n      OPCODE = 2\n      ASK = 0\n      PCK = %b01/10/11\n   \
    \   EXT = 0/1\n      CHN = 1\n      OPR_LENGTH = 1\n      SESSION_ID - The value\
    \ is taken from the cancelled chain.\n      CHAIN_NUMBER - Number of the chain,\
    \ which sending is cancelled.\n      INSTR_NUMBER - Always has zero-value.\n \
    \     Operands:\n         2 octets: The basic return code.\n         2 octets:\
    \ The additional return code.\n      The optional extension header:\n        \
    \ _MSG - contains the arbitrary error description.\n   The instruction SND_CANCEL\
    \ is used for the cancel of the partially\n   transmitted transaction or fragmented\
    \ instruction.  At the receiving\n   the SND_CANCEL instruction, all the earlier\
    \ received data in the\n   chain are rejected.\n"
- title: 5  Jobs Management
  contents:
  - "5  Jobs Management\n   The jobs management includes the following functions:\n\
    \   o  Initiation and completion of jobs;\n   o  Initiation and completion of\
    \ tasks;\n   o  Opening and closing of session connections;\n   o  Activity control\
    \ of nodes.\n   The instructions with OPCODE = 1 - 112 are used for jobs management.\n\
    \   These instructions must be sent through TCP.  Use UDP is not allowed,\n  \
    \ even if the instructions do not demand response.\n   UMSP bases on model with\
    \ the centralized control of the separate job.\n   The reason is that the pointers\
    \ control is not obviously possible in\n   the decentralized system.  Any task\
    \ can be finished at any moment or\n   the node can be reloaded.  There is no\
    \ way guaranteeing the\n   notification about in the decentralized system all\
    \ other nodes, on\n   which the job works.  As the job continues to exist - the\
    \ task\n   concerning the job can be initiated on the same node again.  This\n\
    \   task can allocate new dynamic resources.  The addresses for the again\n  \
    \ allocated resources can be crossed with addresses of resources, which\n   existed\
    \ on the node before the task restart.  The old pointers can be\n   kept on other\
    \ nodes.  It may be the formally correct pointers, but\n   they will actually\
    \ specify other objects.  The uncontrollable work of\n   the application can be\
    \ consequence of such situation.\n   UMSP solves this task as follows:\n   o \
    \ It allows defining the node, on which the task was completed,\n      precisely.\n\
    \   o  If the task on the node is finished before end of the job, all\n      nodes,\
    \ on which the job is executed, are notified of it.\n   o  The repeated task initialization\
    \ on the node is allowed, while all\n      nodes will receive the message about\
    \ the first task end.\n   The protocol does not control the pointers.  VM supervises\
    \ the\n   pointers correctness.  VM must have architecture, in which 128 - bit\n\
    \   pointers are stored in special memory areas, for this purpose.  The\n   protocol\
    \ informs VM about the nodes, on which task have finished the\n   work.  VM must\
    \ make all pointers concerning such tasks, invalid.  It\n   results in exclusive\
    \ situations at the access under these pointers.\n   If the application provides\
    \ processing exceptions, it keeps the\n   capacity for work, or it is finished\
    \ emergency.  Such decision allows\n   excluding unguided applications working.\n\
    \   For the decision of the specified questions at UMSP level, the\n   control\
    \ job node is defined for each job.  It names Job Control Point\n   (JCP).  It\
    \ may be the same node, on which the job is initiated, or it\n   can be another\
    \ dedicated node.  The basic JCP function is to trace\n   the initialization and\
    \ the end of the job tasks.  Besides, the\n   dedicated JCP node may be used for\
    \ the centralized users\n   identification and the attack protection.\n   The\
    \ following identifiers are definite for the jobs and tasks\n   control:\n   o\
    \  Locally Task Identifier (LTID) is assigned to each active task on\n      the\
    \ node.  LTID length is equal to the length of local memory\n      address defined\
    \ for the node.  All LTID on the node must give\n      unique values at each moment\
    \ of time.  It is allowed to establish\n      LTID, used earlier in the already\
    \ completed tasks, for the again\n      initiated tasks.\n   o  JCP assigned the\
    \ Control Task Identifier (CTID) to each task of\n      the job.  Its length is\
    \ equal to length of the local address\n      memory on the node JCP.  All CTID\
    \ on the JCP must give unique\n      values at each moment of time.  As against\
    \ LTID, the CTID value is\n      chosen with some restrictions.\n   o  Globally\
    \ Task Identifier (GTID) is assigned to each task.  GTID\n      has the same format,\
    \ as the 128 - bit address of node memory has.\n      The address of local memory\
    \ is replaced on LTID in it.\n   o  Globally Job Identifier (GJID) is assigned\
    \ to the each job.  GJID\n      is defined on the JCP node.  It has the same format,\
    \ as the 128 -\n      bit address of node JCP memory has.  The address of local\
    \ memory\n      is replaced on CTID of the first (initial) task of the job in\
    \ it.\n      GJID is used in the procedure of session connection opening for\n\
    \      the definition JCP, which controls the job.\n   LTID and CTID are written\
    \ at the instructions in the field of length\n   2/4/8 octets.  If the allocated\
    \ for identifier field in the\n   instruction is longer than identifier, LTID\
    \ (CTID) writes in the last\n   octets.  In the initial octets, the value 0 must\
    \ be written.  If\n   received LTID (CTID) is shorter than the local memory address,\
    \ it is\n   necessary to pad it with the zero octets in the beginning.\n   GTID\
    \ and GJID are written at the instructions in the field of length\n   4-16 octets.\
    \  The field FREE is not present at these identifiers (see\n   section 2.1). \
    \ It is considered, that it contains the zero-value\n   octets.  Length of the\
    \ identifier is defined in header of the\n   address.\n   By sending of instructions\
    \ CONTROL_REQ, TASK_REG and SESSION_OPEN,\n   the protocol uses timeout.  The\
    \ value of timeout is assigned by node\n   and must be more than three intervals\
    \ of the maximal time of delivery\n   at the transport layer.  The timeout is\
    \ not influenced the waiting\n   period in queue to the transport layer.\n"
- title: 5.1    Job Initiate
  contents:
  - "5.1    Job Initiate\n   The job concerns to the user application executed on\
    \ VM.  The UMSP\n   job initialization can be made simultaneously with the application\n\
    \   user start or during its working.\n   The task, appropriated to its job, is\
    \ initialized on the node\n   together with the job.  LTID is binding to this\
    \ task.\n   If the node, on which the user application was loaded, is chosen for\n\
    \   JCP, the question of the job initialization lays beyond the scope of\n   the\
    \ network protocol.\n   Other node can be chosen as JCP for the following reasons:\n\
    \   o  The job initialization node is connected to network by slow-speed\n   \
    \   or overloaded channel.  It is undesirable to send the managing\n      traffic.\n\
    \   o  The node has no computing possibilities for conducting the\n      managing\
    \ tables.\n   o  The authentication on the detailed node is necessary.\n   If\
    \ the other node is chosen for JCP, the node, that initiates the\n   job, must\
    \ register the job at JCP.\n"
- title: 5.1.1     CONTROL_REQ
  contents:
  - "5.1.1     CONTROL_REQ\n   The instruction \"To request a control\" (CONTROL_REQ)\
    \ is sending from\n   the node, initial the job, to JCP of other node.  The instruction\
    \ has\n   the following values of fields:\n      OPCODE = 3\n      PCK = %b00\n\
    \      CHN = 0\n      ASK = 1\n      EXT = 0/1\n      OPR_LENGTH = 2/3  ; Depends\
    \ on LTID length.\n      REQ_ID - The value is assigned by the sender node protocol\
    \ and\n               then will be sent in the response.\n      Operands:\n  \
    \       4 octets: The control parameters profile.  This field has the\n      \
    \             following format:\n            bits\n             0     1     2\
    \     3     4     5     6     7\n            +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \            |                                               |\n            +\
    \                 JOB_LIFE_TIME                 +\n            |             \
    \                                  |\n            +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \            | CMT |    Reserved     |        VERSION        |\n            +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \            |                   Reserved                    |\n            +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \            JOB_LIFE_TIME\n               2 octets.  The job lifetime in seconds.\
    \  The zero-value\n               signifies that the restriction of the job lifetime\
    \ is\n               unused.\n            CMT\n               1 bit.  The flag\
    \ of several JCP using.  This field is\n               reserved for the future\
    \ expansion of the protocol.\n            VERSION\n               1 octet.  The\
    \ number of the UMSP version.  It must\n               contain the value 1.\n\
    \            Reserved\n               3 + 8 bits.  All bits must be set to 0.\n\
    \         4/8 octet: LTID of task of the job, assigned on the node, which\n  \
    \                  initiate the job (by the sender of this\n                 \
    \   instruction).\n      The optional extension headers:\n         _JOB_NAME \
    \ -  This header contains the name of the Job.  Is\n                       assigned\
    \ once and must not change further.\n         _INACT_TIME - This header contains\
    \ the inaction time (see\n                       section 5.7).\n   At reception\
    \ of the CONTROL_REQ instruction JCP checks the LTID value\n   from the received\
    \ instruction and makes the following:\n   (1) If the node, which has sent CONTROL_REQ,\
    \ already has registered\n       on JCP the active job with such LTID, the notification\
    \ about\n       abnormality end of the registered job is sent, as is described\
    \ in\n       section 5.5.2 (it is considered, that the node was reloaded).\n \
    \      After that, the sanction to an initiation of the new job is sent.\n   (2)\
    \ If the node has no registered job with received LTID, it allows\n       the\
    \ new job initiation at once.\n   If JCP confirms the control, it will send the\
    \ instruction\n   CONTROL_CONFIRM, or else CONTROL_REJECT.\n"
- title: 5.1.2     CONTROL_CONFIRM
  contents:
  - "5.1.2     CONTROL_CONFIRM\n   The instruction \"To confirm the control\" (CONTROL_CONFIRM)\
    \ is sent\n   from JCP as the positive response to CONTROL_REQ instruction.\n\
    \   CONTROL_CONFIRM has the following values of fields:\n      OPCODE = 4\n  \
    \    PCK = %b00\n      CHN = 0\n      ASK = 1 ; The instruction does not need\
    \ to be responded.  This flag\n                specifies presence of the REQ_ID\
    \ field.\n      EXT = 0/1\n      OPR_LENGTH = 1-4 ; Depends of length of the GJID.\n\
    \      REQ_ID - The value is taken from the instruction CONTROL_REQ\n      Operands:\n\
    \         4-16 octets: The GJID assigned to the job on the JCP.\n   The sending\
    \ of the instruction CONTROL_REQ means request of control\n   and request of task\
    \ initiation.  Assigned to the task CTID is part\n   GJID (field of the local\
    \ memory address).\n"
- title: 5.1.3     CONTROL_REJECT
  contents:
  - "5.1.3     CONTROL_REJECT\n   The instruction \"To reject the control\" (CONTROL_REJECT)\
    \ is sent from\n   JCP as the negative response to CONTROL_REQ instruction.\n\
    \   CONTROL_REJECT has the following values of fields:\n      OPCODE = 4\n   \
    \   PCK = %b00\n      CHN = 0\n      ASK = 1.  The instruction does not need to\
    \ be responded.  This flag\n                specifies presence of the REQ_ID field.\n\
    \      EXT = 0/1\n      OPR_LENGTH = 1/2 ; Depends on presence of the control\
    \ parameters\n                         profile field.\n      REQ_ID - The value\
    \ is taken from the instruction CONTROL_REQ\n      Operands:\n         2 octets:\
    \ The basic error code.  The zero-value is not\n                   available.\n\
    \         2 octets: The additional error code.\n         4 octets: The control\
    \ parameters profile (see section 5.1.1),\n                   that is allowed\
    \ by JCP.  This is optional field.\n      The optional extension headers:\n  \
    \       _INACT_TIME - This header contains the inaction time (see\n          \
    \             section 5.7).\n         _MSG - contains the arbitrary error description.\n"
- title: 5.2    Task Initiate
  contents:
  - "5.2    Task Initiate\n   The job is executed on several nodes simultaneously.\
    \  The task,\n   appropriate to it, must be initialized on each node.  There is\n\
    \   corresponding only one task to one job on the node.  Each task must\n   be\
    \ connected only with one job.\n   The task is initiated together with the job\
    \ on the node, which had\n   created the job.  On the other nodes, the task is\
    \ initiated during\n   the receiving of the first request on the opening of the\
    \ session\n   connection, which is appropriate to the job.  The request about\n\
    \   openings of session connection contains GJID.  GJID contains the JCP\n   address.\
    \  It is necessary to receive the sanction from JCP for the\n   task start.  If\
    \ the request about the opening of session has been\n   received from JCP node,\
    \ it is not necessary to request the sanction.\n"
- title: 5.2.1     TASK_REG
  contents:
  - "5.2.1     TASK_REG\n   The instruction \"To register a task\" (TASK_REG) is sent\
    \ from the\n   node, which initials the task, to JCP of the remote node.  The\n\
    \   instruction has the following values of fields:\n      OPCODE = 6/7/8 ; For\
    \ length CTID of 2/4/8 octets.\n      PCK = %b00\n      CHN = 0\n      ASK = 1\n\
    \      EXT = 0/1\n      OPR_LENGTH = 2-8  ; Depends on length of the GTID and\
    \ LTID.\n      REQ_ID - The value is assigned by the sender node protocol and\n\
    \               then will be sent in the response.\n      Operands:\n        \
    \ 2/4/8 octets: CTID of the task initiated the job.  It CTID is a\n          \
    \             part GJID from the instruction SESSION_OPEN.\n         4-16 octets:\
    \ GTID, assigned on the node, initialed session\n                      connection.\
    \  GTID is formed of sender addresses (at\n                      transport layer)\
    \ and field LTID of the instruction\n                      SESSION_OPEN.\n   \
    \      2/4/8 octets:  LTID, assigned on the node, initialed the task\n       \
    \                 (by the sender of this instruction).\n      The optional extension\
    \ headers:\n         _INACT_TIME - This header contains the inaction time (see\n\
    \                       section 5.7).\n   The instruction TASK_REG must be sent\
    \ only if the task with given\n   GJID was not initiated on the node.\n   JCP\
    \ confirms initiation of a task at observance of the following\n   conditions:\n\
    \   (1) Task with received GTID already has registered on JCP.\n   (2) Task with\
    \ LTID for the node requesting for initiation has not\n       registered.\n  \
    \ In all other cases, JCP will not confirm a task.\n   If JCP confirms the task,\
    \ it will send the instruction TASK_CONFIRM,\n   differently TASK_REJECT.\n"
- title: 5.2.2     TASK_CONFIRM
  contents:
  - "5.2.2     TASK_CONFIRM\n   The instruction \"To confirm the task\" (TASK_CONFIRM)\
    \ is sent from JCP\n   as the positive response to TASK_REG.  TASK_CONFIRM has\
    \ the following\n   values of fields:\n      OPCODE = 9\n      PCK = %b00\n  \
    \    CHN = 0\n      ASK = 1.  The instruction does not need to be responded. \
    \ This flag\n                specifies the field REQ_ID presence.\n      EXT =\
    \ 0/1\n      OPR_LENGTH = 1/2  ; Depends on length of the CTID.\n      REQ_ID\
    \ - The value is taken from the instruction TASK_REG.\n      Operands:\n     \
    \    4/8 octets: The CTID assigned to the task on the JCP.\n      The optional\
    \ extension headers:\n         _JOB_NAME - This header contains the name of the\
    \ Job.\n"
- title: 5.2.3     TASK_REJECT
  contents:
  - "5.2.3     TASK_REJECT\n   The instruction \"To reject the task\" (TASK_REJECT)\
    \ is sent from JCP\n   as the negative response to TASK_REG instruction.  TASK_REJECT\
    \ has\n   the following values of fields:\n      OPCODE = 10\n      PCK = %b00\n\
    \      CHN = 0\n      ASK = 1.  The instruction does not need to be responded.\
    \  This flag\n                specifies presence of the REQ_ID field.\n      EXT\
    \ = 0/1\n      OPR_LENGTH = 1\n      REQ_ID - The value is taken from the instruction\
    \ CONTROL_REQ\n      Operands:\n         2 octets: The basic error code.  The\
    \ zero-value is not\n                   available.\n         2 octets: The additional\
    \ error code.\n      The optional extension headers:\n         _INACT_TIME - This\
    \ header contains the inaction time (see\n                       section 5.7).\n\
    \         _MSG - contains the arbitrary error description.\n"
- title: 5.2.4     TASK_CHK
  contents:
  - "5.2.4     TASK_CHK\n   With the purposes of a safety the node, which have received\
    \ request\n   about the opening of session connection, may check up at JCP the\n\
    \   node, which has initialed connection, even if the task was already\n   initiated.\n\
    \   The instruction \"To check up the task\" (TASK_CHK) is sent from the\n   node,\
    \ which has received the instruction of the establishment of\n   session connection\
    \ SESSION_OPEN, to JCP.  The task with given GJID,\n   must have existed on the\
    \ node already.  The instruction TASK_CHK\n   format coincides with TASK_REG.\
    \  OPCODE = 11.  The response to the\n   instruction TASK_CHK JCP forms instructions\
    \ TASK_REG similarly.\n   JCP confirms the instruction TASK_CHK if a task with\
    \ received GTID\n   and LTID already has registered on JCP.\n   The sending of\
    \ the TASK_CHK is optional.\n"
- title: 5.3    Establishment of session connection
  contents:
  - "5.3    Establishment of session connection\n   The session connection is established\
    \ between two tasks of one job.\n   The connection is established under the VM\
    \ initiative and it is used\n   for the exchange of the instructions between VM.\n\
    \   One session connection must be connected only with one task on the\n   node.\
    \  The task may have several connections with different nodes.\n   Between two\
    \ nodes must be only one session connection with one GJID.\n   The request about\
    \ the establishment of session connection contains\n   the global identifier of\
    \ the job GJID.  If the node receives the\n   request about the establishment\
    \ of connection with GJID, which is not\n   presented on the given node, VM must\
    \ create a new task.  If the task\n   has been already initialized, the new task\
    \ is not created.\n   The session connection needs to be established over TCP.\
    \  After the\n   connection is established, the sending of the instructions, which\
    \ are\n   not require of execution response, is possible through UDP.  One TCP\n\
    \   connection may be used by several session connections.  One session\n   connection\
    \ may use several TCP connections.\n   The protocol allows working without the\
    \ establishment of session\n   connection.  The node must have VM by default,\
    \ which must execute the\n   instructions without the establishment of connection.\n\
    \   At the establishment of session connection, the sides agree about the\n  \
    \ used VM type and the subset of the protocol functions.  The session\n   connection\
    \ UMSP may be asymmetrical.  It means, that two sides of one\n   connection can\
    \ be connected with VM of the different type and provide\n   the different subset\
    \ of the protocol functions.\n   If at an establishment of session connection\
    \ the zero-type VM is\n   used, it specifies group VM (see section 9).  The zero-value\
    \ of\n   realization VM is not allowed.\n   The procedure of the establishment\
    \ of session connection may contain\n   from 2-way up to 8-way handshakes.\n"
- title: 5.3.1     SESSION_OPEN
  contents:
  - "5.3.1     SESSION_OPEN\n   The instruction \"To open a session\" (SESSION_OPEN)\
    \ is used for the\n   initiation of session connection and for the specification\
    \ of\n   connection parameters during handshake.  It has the following values\n\
    \   of fields:\n      OPCODE = 12\n      PCK = %b00/11.  In the first instruction\
    \ (initial) the value of\n                       this field is set to %b00.  In\
    \ all subsequent -\n                       %b11.\n      CHN = 0\n      ASK = 1\n\
    \      EXT = 0/1\n      OPR_LENGTH = 6 - 10 ; Depends on length GJID and LTID.\n\
    \      SESSION_ID - In the first instruction this field is absent.  In all\n \
    \                  subsequent, it contains the identifier of sessions,\n     \
    \              assigned by the instruction receiver.\n      REQ_ID - This field\
    \ contains the session connection identifier,\n               assigned by the\
    \ instruction sender.\n      Operands:\n         2 octets: The VM type required\
    \ from the addressee.\n         2 octets: The VM version required from the addressee.\n\
    \         4 octets: The profile of connection required from the\n            \
    \       instruction addressee.\n         2 octets: The VM type of the sender.\n\
    \         2 octets: The VM version of the sender.\n         4 octets: The profile\
    \ of connection given by the instruction\n                   sender.\n       \
    \  2 octets: The number of 256 octet blocks in the buffer,\n                 \
    \  allocated for session (\"window\"), on the side of the\n                  \
    \ sender of this instruction (see section 7.4).  The\n                   zero-value\
    \ specifies absence of the buffer.\n         4-16 octets: GJID.\n         4/8\
    \ octets: LTID of the sender task, assigned on the node -\n                  \
    \   sender of the instruction.  It is used in the\n                     instruction\
    \ TASK_REG (as a part of the field GTID).\n   If the VM type and version, required\
    \ from the addressee, have the\n   value 0, the receiving node independently chooses\
    \ the VM type and\n   reports it in the response.  The establishment of connection\
    \ without\n   binding to VM or VM group is not allowed.\n   Totally, it can be\
    \ transmitted up to 7 instructions SESSION_OPEN at\n   the establishment of connection.\
    \  The instruction SESSION_ACCEPT is\n   used for the response of the establishment\
    \ of connection.  For the\n   refusal of connection the instruction, SESSION_REJECT\
    \ is used.\n   It is possible to refuse connection on any step.  It is necessary\n\
    \   either to confirm connections, or to refuse it on the eighth step.\n   During\
    \ the establishment of connection the following parameters may\n   be changed:\n\
    \   o  VM type and VM version;\n   o  profiles of connection.\n   If the repeated\
    \ request about opening of session connection is\n   received from the definite\
    \ node, while one connection with received\n   GJID have been already established,\
    \ the following variants are\n   possible:\n   (1) If the request has arrived\
    \ from the node JCP, it is necessary:\n       o  To finish the existing task emergency\
    \ and to deallocate all\n          dynamic resources belong to it.\n       o \
    \ To initiates a task without request of the JCP sanction again.\n       o  To\
    \ confirm the establishment of connection.\n   (2) If the request arrived not\
    \ from the JCP node, it is necessary to\n       refuse the establishment of new\
    \ session connection.  The existing\n       task does not need to be changed.\n"
- title: 5.3.2     SESSION_ACCEPT
  contents:
  - "5.3.2     SESSION_ACCEPT\n   The instruction \"To accept the session\" (SESSION_ACCEPT)\
    \ is used for\n   positive response to the establishment of session connection.\
    \  It has\n   the following values of fields:\n      OPCODE = 13\n      ASK =\
    \ 1\n      PCK = %11\n      EXT = 0/1\n      CHN = 0\n      OPR_LENGTH = 0\n \
    \     SESSION_ID - This field contains the session connection identifier\n   \
    \                of assigned by the node of the addressee of the\n           \
    \        instruction.\n      REQ_ID - This field contains the session connection\
    \ identifier,\n               assigned by the instruction sender.\n"
- title: 5.3.3     SESSION_REJECT
  contents:
  - "5.3.3     SESSION_REJECT\n   The instruction \"To reject the session\" (SESSION_ACCEPT)\
    \ is used for\n   negative response to the establishment of session connection.\
    \  It has\n   the following values of fields:\n      OPCODE = 14\n      ASK =\
    \ 0\n      PCK = %b11\n      EXT = 0/1\n      CHN = 0\n      OPR_LENGTH = 1\n\
    \      SESSION_ID - This field contains the session connection identifier\n  \
    \                 of assigned by the node of the addressee of the\n          \
    \         instruction.\n      Operands:\n         2 octets: The basic error code.\
    \  The zero-value is not\n                   available.\n         2 octets: The\
    \ additional error code.\n      The optional extension headers:\n         _MSG\
    \ - contains the arbitrary error description.\n"
- title: 5.3.4     Connection Profile
  contents:
  - "5.3.4     Connection Profile\n   The profile of connection is defined in 4-octet\
    \ field of flags.  The\n   flags have identifiers S0 - S31.  The number in the\
    \ identifier is\n   defining the serial number of bit.  If the flag is set to\
    \ 1, the\n   function, connected with it, is provided.  If the flag is set to\
    \ 0,\n   the function, connected with it, is not provided (not required).  The\n\
    \   list of functions, determined at the establishment of session\n   connection,\
    \ are described further.\n   Work with chains:\n      S0 - Use of fragmented instructions.\n\
    \      S1 - Use of sequences.\n      S2 - Use of transactions.\n   Establishment\
    \ of connection:\n      S3 - Use the exchange of the data without the establishment\
    \ of\n           connection.\n      S4 - Use the exchange of the data with the\
    \ establishment of\n           connection.\n   The instructions format:\n    \
    \  S5  - Reserved.  Must have set to 0.\n      S6  - Use of 16-octet address in\
    \ the exchange instructions.\n      S7  - Use of the compressed form of header\
    \ of the instruction\n            (OPR_LENGTH < > %b111) is allowed\n      S8\
    \  - Use of the extension form of header of the instruction\n            (OPR_LENGTH\
    \ = %b111) is allowed\n      S9  - Use of the extension headers with the data\
    \ field up to 254\n            octets of length.\n      S10 - Use of the extension\
    \ headers with the data field up to 4 *\n            10^9 octets of length.\n\
    \      S11-S15  Maximal length of the data field in operands in the 4\n      \
    \         octet words.  These bits are the common field.  Maximal\n          \
    \     length in octets is computed under the formula:\n                  <max\
    \ length> = (<value of this field> + 1) * 4.\n               If the value is equal\
    \ %b1111, maximal length of the data\n               is defined by the instruction\
    \ format.\n      S16-S19  These bits are the common field.  In the profile required\n\
    \               from the addressee of the instruction, this field\n          \
    \     contains the version of the UMSP.  It must is set to the\n             \
    \  value %b0001.  In the profile given sender of the\n               instruction,\
    \ this field contains priority of the job.  The\n               more is value\
    \ of this field, the more priority.  The\n               priority of the job is\
    \ used:\n               o In queues on sending to the transport layer for the\n\
    \                 instructions of the job.\n               o For set of sending\
    \ priority of the transport layer.\n               o For set of computing priority\
    \ of the task.\n      S20 - making the border multiple of 4 octets.  If S16 =\
    \ 1:\n         (1)  OPR_LENGTH = %b111\n         (2)  Each extension header and\
    \ the field of operands begin with\n               the border multiple of four\
    \ octets.\n         (3)  The necessary number of zero octets is added in the end\
    \ of\n              each header.\n      S21 - Use of the procedures name of objects.\n\
    \      S22 - Use of the objects name.\n   The permissible instructions:\n    \
    \  S23 - The response of the execution on VM (instruction RSP) is\n          \
    \  provided.\n      S24 - Use of data reading and comparison instructions.\n \
    \     S25 - Use of data writing instructions.\n      S26 - Use of control transfer\
    \ instructions.\n      S27 - Use of synchronize instruction.\n      S28 - Use\
    \ of instructions of work witch objects.\n      S29 - Use of the immediate access\
    \ to memory of object.  If this\n            flag is set to 0, the access to object\
    \ is solved only\n            through its procedures.  If S28=0, this flag must\
    \ be set to\n            0.\n      S30 - Use of instruction MVRUN in zero-session.\n\
    \      S31 - Reserved.  Must have set to 0.\n"
- title: 5.4    Session Closing
  contents:
  - "5.4    Session Closing\n   Initiate closing session connection the node must\
    \ only, which has\n   initiated its establishment.  It uses the SESSION_CLOSE\
    \ instruction\n   for this purpose.  The procedure of break of connection is 3-way\n\
    \   handshake.  The procedure of unconditional emergency end of\n   connection\
    \ is stipulated.  It can be transmitted by any node.\n   Let node A is the initiator\
    \ of the establishment of a session, and\n   the node B is the second side of\
    \ connection.  The node A must send\n   the instruction SESSION_CLOSE for closing\
    \ session.  The node A may\n   recommence sending of the instructions after sending\
    \ of this\n   instruction.  It means that it has refused closing connection. \
    \ The\n   instructions of response (see section 6) does not influence on the\n\
    \   closing of connection.  The node, which has sent SESSION_CLOSE, does\n   not\
    \ use the timeout and can be waiting for the response beyond all\n   bounds long.\n\
    \   The node B, after reception of the instruction SESSION_CLOSE, sends\n   in\
    \ the answer the instruction RSP_P.  The zero basic return code\n   responds closing\
    \ session.  The non-zero basic return code cancels\n   closing session.  After\
    \ sending of positive response, the node must\n   not use connection during 30-second\
    \ timeout.  If the instruction\n   SESSION_ABEND or any other instruction, except\
    \ response instruction,\n   has not been received from the node A after the expiration\
    \ of this\n   time, the node send the instruction SESSION_ABEND and considers\
    \ the\n   session connection closed.\n   The node A sends the instruction SESSION_ABEND\
    \ after reception of\n   positive response on the instruction SESSION_CLOSE. \
    \ After that, the\n   connection is considered closed.  The node A may refuse\
    \ closing of\n   connection.  For this purpose, any instruction is sent, including\n\
    \   NOP.  In this case, the procedure of end interrupts, and the session\n   connection\
    \ is translated in the working state.\n"
- title: 5.4.1     SESSION_CLOSE
  contents:
  - "5.4.1     SESSION_CLOSE\n   The instruction \"To close the session\" (SESSION_CLOSE)\
    \ initiates the\n   end of session connection.  It has the following values of\
    \ fields:\n      OPCODE = 15\n      PCK = %b01/11\n      CHN = 0\n      ASK =\
    \ 0\n      EXT = 0/1\n      OPR_LENGTH = 0/1\n      SESSION_ID - Contains the\
    \ session identifier assigned by the\n                   addressee.\n      Operands:\n\
    \         2 octets: The basic termination code.\n         2 octets: The additional\
    \ termination code.\n      The optional extension header:\n         _MSG - contains\
    \ the arbitrary message.\n   The operands may be absent.  It is equivalent to\
    \ the zero exit code.\n"
- title: 5.4.2     SESSION_ABEND
  contents:
  - "5.4.2     SESSION_ABEND\n   The instruction \"Abend of session\" SESSION_ABEND\
    \ is applied to\n   unconditional end of session.  The node, which has sent this\n\
    \   instruction, finishes the exchange of the data on connection at both\n   sides,\
    \ not waiting responses from other node.  The instruction has\n   the following\
    \ values of fields:\n      OPCODE = 16\n      PCK = %b01/11\n      CHN = 0\n \
    \     ASK = 0\n      EXT = 0/1\n      OPR_LENGTH = 0/1\n      SESSION_ID - Contains\
    \ the session identifier assigned by the\n                   addressee.\n    \
    \  Operands:\n         2 octets: The basic termination code.\n         2 octets:\
    \ The additional termination code.\n      The optional extension header:\n   \
    \      _MSG - contains the arbitrary message.\n   The operands may be absent.\
    \  It is equivalent to the zero termination\n   codes.\n"
- title: 5.5    Task Termination
  contents:
  - "5.5    Task Termination\n   The task is finished during the process of the job\
    \ finishing at the\n   normal end of the user application working.  This procedure\
    \ is\n   described in the following item.  The following situations require\n\
    \   finishing the task irrespective of the job:\n   o  There are not enough of\
    \ computing resources for maintenance of the\n      task on the node;\n   o  The\
    \ node finishes the work;\n   o  If VM has accepted such decision for the internal\
    \ reasons.\n   The references to the resources allocated by the task can be on\
    \ any\n   node, on which the job is carried out.  Therefore, all nodes must be\n\
    \   notified of the end of the task.\n   Node, finishing the task, must abnormally\
    \ close all session\n   connections joining the finished task (to send the instruction\n\
    \   SESSION_ABEND).\n"
- title: 5.5.1     TASK_TERMINATE
  contents:
  - "5.5.1     TASK_TERMINATE\n   The instruction \"To terminate the task\" (TASK_TERMINATE)\
    \ is sent from\n   the node, on which the task is finished, to JCP.  The instruction\
    \ has\n   the following values of fields:\n      OPCODE = 17\n      PCK = %b00\n\
    \      CHN = 0\n      ASK = 0\n      EXT = 0/1\n      OPR_LENGTH = 2/3  ; Depends\
    \ on the length of CTID.\n      Operands:\n         2 octets: The basic termination\
    \ code.\n         2 octets: The additional termination code.\n         4/8 octets:\
    \ CTID.\n      The optional extension header:\n         _MSG - contains the arbitrary\
    \ message.\n   After sending of the instruction TASK_TERMINATE to JCP, the node\n\
    \   sends the instruction of unconditional end of connection\n   ABEND_SESSION\
    \ on all session connections connected with a task.\n   After that, the task is\
    \ considered completed.\n   If the basic return code in the instruction TASK_TERMINATE\
    \ is equal\n   to 0, it is not required to notify other nodes about the end of\
    \ the\n   task.  Such situation arises, if the task did not allocate dynamic\n\
    \   resources.  If the basic return code is unequal to 0, JCP must notify\n  \
    \ about the task end the other nodes, on which the job is carried out,\n   after\
    \ reception of the instruction TASK_TERMINATE.  JCP responds for\n   the notification\
    \ of all nodes of the job about the task end.\n"
- title: 5.5.2     TASK_TERMINATE_INFO
  contents:
  - "5.5.2     TASK_TERMINATE_INFO\n   The instruction \"The information on terminating\
    \ of the task\"\n   (TASK_TERMINATE_INFO) is used for the notification about the\
    \ task\n   end.  It is sent from JCP to other nodes, on which the job is carried\n\
    \   out.  The instruction has the following values of fields:\n      OPCODE =\
    \ 18\n      PCK = %b00\n      CHN = 0\n      ASK = 0\n      EXT = 0/1\n      OPR_LENGTH\
    \ = 2-5 ; Depends on the length of GTID.\n      Operands:\n         2 octets:\
    \ The basic termination code.\n         2 octets: The additional termination code.\n\
    \         4-16 octets: GTID of the terminated task.  JCP forms GTID from\n   \
    \                   LTID (from the instruction TASK_REG) and address\n       \
    \               of transport layer of the task.\n      The optional extension\
    \ header:\n         _MSG - contains the arbitrary message.\n   The fields of termination\
    \ codes are taken from the instruction\n   TASK_TERMINATE.  The job must delete\
    \ (to make invalid) all references\n   to resources concerning the node, on which\
    \ the completed task worked,\n   at reception of the instruction TASK_TERMINATE_INFO.\n"
- title: 5.6    Job Completion
  contents:
  - "5.6    Job Completion\n   The job is finished, when the appropriated to it the\
    \ user application\n   on the node, on which it was initiated, is finished.  The\
    \ end of the\n   job occurs under the initiative of VM.  Besides, it can be completed\n\
    \   under the JCP initiative at ending the lifetime of the job or at end\n   of\
    \ the JCP node working.\n"
- title: 5.6.1     JOB_COMPLETED
  contents:
  - "5.6.1     JOB_COMPLETED\n   The instruction \"The task is completed\" (JOB_COMPLETED)\
    \ is sent from\n   the node, which initiated the job, in the JCP side.  It has\
    \ the\n   following values of fields:\n      OPCODE = 19\n      PCK = %b00\n \
    \     CHN = 0\n      ASK = 0\n      EXT = 0/1\n      OPR_LENGTH = 2/3 ; Depends\
    \ on the CTID length.\n      Operands:\n         2 octets: The basic completion\
    \ code.\n         2 octets: The additional completion code.\n         4/8 octets:\
    \ CTID of the completed task of the job.  CTID is a\n                     part\
    \ GJID of the job.\n      The optional extension header:\n         _MSG - contains\
    \ the arbitrary message.\n   After sending of the instruction JOB_COMPLETED to\
    \ JCP, the node sends\n   on all connected with the session connections of the\
    \ job the\n   instruction of unconditional end of connection ABEND_SESSION.  After\n\
    \   that, the job is considered completed.\n   JCP must notify of the end of the\
    \ job the nodes, on which the job is\n   carried out, after reception of the instruction\
    \ JOB_COMPLETED.  JCP\n   responds for the notification of all nodes of the job\
    \ about end of\n   the job.\n   The instruction TASK_TERMINATE_INFO may be transferred\
    \ under the\n   initiative JCP, if node of the task has abnormal terminated work.\n"
- title: 5.6.2     JOB_COMPLETED_INFO
  contents:
  - "5.6.2     JOB_COMPLETED_INFO\n   The instruction \"The information on completion\
    \ of the job\"\n   (JOB_COMPLETED_INFO) is used for the notification about end\
    \ of the\n   job.  It is sent from JCP to other nodes, on which the job is carried\n\
    \   out.  The instruction has the following values of fields:\n      OPCODE =\
    \ 20\n      PCK = %b00\n      CHN = 0\n      ASK = 0\n      EXT = 0/1 ;\n    \
    \  OPR_LENGTH = 2-5 ; Depends on the GJID length and presence of\n           \
    \              fields completion code.\n      Operands:\n         2 octets: The\
    \ basic completion code.\n         2 octets: The additional completion code.\n\
    \         4-16 octets: GJID of the completed job.\n      The optional extension\
    \ header:\n         _MSG - contains the arbitrary message.\n   The fields of completion\
    \ codes are optional.\n   The fields of completion codes are taken from the instruction\n\
    \   JOB_COMPLETED.  At reception of the instruction, JOB_COMPLETED_INFO\n   the\
    \ node must make the following:\n   (1)  To remove all session connections, connected\
    \ to the task.  At\n        that, it is not necessary to send network primitives.\n\
    \   (2)  To abnormally finish the task of the job and to deallocate all\n    \
    \    dynamic resources of the task.\n   The instruction JOB_COMPLETED_INFO is\
    \ used for the end of the job\n   under the JCP initiative at the end of lifetime\
    \ or at end of the JCP\n   node working.  In these cases, the node initiated the\
    \ job is the\n   first addressee of the instruction.\n   JCP considers the job\
    \ completed after sending of all instructions\n   JOB_COMPLETED_INFO.\n"
- title: 5.7    Activity Control of Nodes
  contents:
  - "5.7    Activity Control of Nodes\n   UMSP unites nodes, which have any arrangement\
    \ in the network and\n   which are not having uniform controls.  Each of nodes\
    \ can be\n   disconnected or reloaded at any moment of time.  However, other nodes\n\
    \   can be not notified about it.  The fact of breaking or repeated\n   establishment\
    \ of transport connection cannot be the indicator of\n   disconnect or restart\
    \ of the node.  The control of transport\n   connections is not the part of the\
    \ UMSP protocol and the presence of\n   transport connection is not obligatory.\n\
    \   Besides the separate task on the node can be finished emergency.\n   Procedure\
    \ described in section 5.5.1 in this case must be executed.\n   If this procedure\
    \ cannot be executed, must is abnormally finished\n   work of the node.\n   The\
    \ JCP executes the functions of the control of nodes activity.  The\n   instruction\
    \ of request of the status TASK_REQ is sent periodically\n   between tasks on\
    \ nodes and JCP for this purpose.\n   The following actions JCP are possible at\
    \ detection of deactivating\n   of the node:\n   (1)  If the task initiated the\
    \ job was finished, it is considered,\n        that the job is completed.  JCP\
    \ sends the instruction\n        JOB_COMPLETED_INFO to all other nodes, on which\
    \ the job was\n        executed.\n   (2)  JCP sends the instruction TASK_TERMINATE_INFO\
    \ to all other nodes\n        of the job, if the task, which has not initiated\
    \ the job, is\n        finished.\n   The deactivating of the JCP node imposes\
    \ the restriction on GJID\n   appropriated by it after reloading.  The following\
    \ variants are\n   probable:\n   (1)  The disconnection of the JCP node passed\
    \ normally.  It\n        transferred to all nodes, which it has controlled, instruction\n\
    \        JOB_COMPLETED_INFO.  In this case, it can appropriate anyone\n      \
    \  GJID after reloading.\n   (2)  There is the emergency disconnect of the JCP\
    \ node.  It has not\n        informed all nodes about the deactivating.  In this\
    \ case, it\n        must guarantee after reloading, that new GJID will not concur\n\
    \        witch the GJID, existing up to the reload, during two maximal\n     \
    \   intervals of inactivity time (which sets this JCP).\n   The reload of nodes,\
    \ which are not being JCP, does not impose\n   restrictions on LTID established\
    \ on these nodes.\n"
- title: 5.7.1     _INACTION_TIME
  contents:
  - "5.7.1     _INACTION_TIME\n   The extension header \"The time of inaction\" (_INACTION_TIME)\
    \ allows\n   setting the inaction time of the node (non JCP).  It has the\n  \
    \ following values of fields:\n      HEAD_CODE = 2\n      HEAD_LENGTH = 1;\n \
    \     HOB = 1\n      DATA contains:\n         2 octets: The inaction period. \
    \ The number of 0,5 second\n         intervals, through which the activity of\
    \ the node - sender of\n         the instruction from the side JCP - will be checked.\n\
    \   The inaction period must be more than three intervals of the maximal\n   time\
    \ of delivery at the transport layer.  The waiting period in queue\n   to the\
    \ transport layer does not influence on timeout.\n   The header _INACTION_TIME\
    \ may be attached to the following\n   instructions:\n   (1)  To the instruction\
    \ TASK_REG.  In this case must be satisfied\n        condition - on node there\
    \ must not be other active tasks, which\n        are controlled the JCP of addressee.\
    \  The zero-value specifies\n        that the activity checking is unused.  The\
    \ absence of the header\n        specifies that the inaction period must be set\
    \ on the JCP.\n   (2)  To the instruction TASK_REJECT, if the time from the instruction\n\
    \        TASK_REG does not fit for JCP.\n   (3)  To the instruction TASK_CONFIRM,\
    \ if instruction TASK_REG had no\n        this header.\n   If JCP receives the\
    \ instruction TASK_REG with the attached heading\n   _INACTION_TIME, it must check\
    \ up presence of active tasks with sender\n   node (as it can mean, that the node\
    \ was reloaded).  If such tasks\n   exist, for each of them it is necessary to\
    \ execute procedure of end\n   of the task described in section 5.6.2.  The instruction\
    \ TASK_CONFIRM\n   must be sent only after that.\n"
- title: 5.7.2     STATE_REQ
  contents:
  - "5.7.2     STATE_REQ\n   The instruction \"State Request\" (STATE_REQ) is sent\
    \ from JCP to the\n   definite task of other node.  The instruction has the following\n\
    \   values of fields:\n      OPCODE = 21\n      PCK = %b00\n      CHN = 0\n  \
    \    ASK = 0\n      EXT = 0\n      OPR_LENGTH = 1/2 ; Depends on the LTID length.\n\
    \      Operand:\n         4/8 octets: LTID, established on the node of the instruction\n\
    \                     addressee.\n   The instruction STATE_REQ will be sent in\
    \ the defined task but it has\n   concern with node.  It is sent, if between the\
    \ node and JCP was not\n   sending of the instruction during inactive time.  The\
    \ task activated\n   after sending of last instruction STATE_REQ does not influence\
    \ the\n   control of activity.\n   The instruction TASK_STATE is sent in reply\
    \ to STATE_REQ.  At\n   expectation of the response, the timeout equal to one\
    \ inaction period\n   is used.  After the expiration of the timeout the node is\
    \ considered\n   switched - off.\n   If the node not receives of any instructions\
    \ from JCP during two\n   intervals of inaction time, it is considered, that JCP\
    \ has finished\n   the work.  The actions of the node in this case are described\
    \ in\n   section 5.6.2 at receiving the instruction JOB_COMPLETED_INFO.  The\n\
    \   check of this condition is optional for the node.\n   If at JCP there are\
    \ no active tasks connected with the defined node,\n   the control of activity\
    \ of this node will not be carried out.\n"
- title: 5.7.3     TASK_STATE
  contents:
  - "5.7.3     TASK_STATE\n   The instruction \"Task State\" (TASK_STATE) is sent\
    \ from the definite\n   task to JCP.  It serves for the response of the instruction\n\
    \   STATE_REQ.  The instruction has the following values of fields:\n      OPCODE\
    \ = 22\n      PCK = %b00\n      CHN = 0\n      ASK = 0\n      EXT = 0\n      OPR_LENGTH\
    \ = 1/2/3 ; Depends on the CTID length.\n      Operands:\n         1 octet:  The\
    \ state code of task.  The following values are\n                   defined for\
    \ this field:\n            %x01 - The task is active and has active session\n\
    \                   connections.\n            %x02 - The task is active and have\
    \ no session connections.\n            %x03 - The task is active, have no session\
    \ connections and\n                   have no resources, allocated on the node.\n\
    \            %x04 - The task is completed.\n         1/3 octets: Reserved.  If\
    \ OPR_LENGTH = 1, then this field has\n                     length 1 octet, else\
    \ 3 octets. JCP must not check\n                     the value of this field.\
    \  It is established in zero\n                     value by sending.\n       \
    \  2/4/8 octets: CTID connected with LTID from the instruction\n             \
    \          STATE_REQ.\n   If OPR_LENGTH = 1 that length of the reserved field\
    \ is equal to one\n   octet and length CTID makes two octets.  In all other cases,\
    \ length\n   of the reserved field is equal 3 octets and length CTID - not less\n\
    \   than 4 octets.\n"
- title: 5.7.4     NODE_RELOAD
  contents:
  - "5.7.4     NODE_RELOAD\n   The instruction \"The node was reloaded\" (NODE_RELOAD)\
    \ is sent to JCP\n   as the negative response to STATE_REQ instruction.  NODE_RELOAD\
    \ has\n   the following values of fields:\n      OPCODE = 23\n      PCK = %b00\n\
    \      CHN = 0\n      ASK = 0\n      EXT = 0\n      OPR_LENGTH = 1/2 ; Depends\
    \ on the LTID length.\n      Operands:\n         4/8 octets: LTID.  The value\
    \ is taken from the instruction\n                     STATE_REQ.\n   The instruction\
    \ RELOAD_NODE indicates, that the task with given LTID\n   for given JCP on the\
    \ node is absent.  At reception of this\n   instruction, JCP must make the following:\n\
    \   (1)  To send the instruction STATE_REQ to all tasks of the node,\n       \
    \ which were initiated before a sending of the penultimate\n        instruction\
    \ STATE_REQ.\n   (2)  To wait for ending of one inaction interval after sending\
    \ of the\n        last instruction STATE_REQ (on which the negative response is\n\
    \        received).\n   (3)  To send the instructions STATE_REQ to all tasks of\
    \ the node,\n        which were initiated between last and penultimate instructions\n\
    \        STATE_REQ (not including instructions from item 1).\n   For all instructions\
    \ STATE_REQ the positive response (TASK_STATE) or\n   negative response (RELOAD_NODE)\
    \ must be transmitted.\n"
- title: 5.8    Work without session connection
  contents:
  - "5.8    Work without session connection\n   The protocol provides the data exchange\
    \ between nodes without an\n   establishment of session connection.  In this case,\
    \ initialization of\n   the job and tasks is not made and JCP is not used.\n \
    \  The format of the instructions, transmitted without the establishment\n   of\
    \ connection, is completely correspond to the instructions\n   transmitted by\
    \ session connections.  The difference is that the field\n   SESSION_ID has zero\
    \ value or PCK = %b00.\n   The node, supporting work without the establishment\
    \ of session\n   connection, must have VM, which executes by default the instructions\n\
    \   transmitted without the establishment of connection.  In fact, these\n   instructions\
    \ are executed within the framework of a so-called zero-\n   session (or zero-task)\
    \ of this VM.  The memory address space of this\n   VM is accessible without a\
    \ connection establishment.\n   The instruction SESSION_INIT with SESSION_ID =\
    \ 0 and REQ_ID = 0\n   allows to specify parameters of its zero-session and to\
    \ request the\n   zero-session parameters of the addressee node.  If the node,\
    \ which\n   has received such instruction, provides the requiring profile, it\n\
    \   sends the instruction SESSION_ACCEPT.  If the profile is not\n   provided,\
    \ the answerback instruction SESSION_INIT will send, in which\n   the field SESSION_ID\
    \ and REQ_ID also have the value 0.  Actually,\n   such instructions of session\
    \ initialization do not establish\n   connection, but have the information meaning.\
    \  The exchange of the\n   data by zero-session can occur irrespective of its.\n\
    \   There are the following restrictions at working without connection:\n   o\
    \  The chain must be sent, only if it is completely located in one\n      segment\
    \ of the transport layer.\n   o  It is impossible to request an allocation of\
    \ memory and to create\n      objects (except instruction MVRUN).  This objects\
    \ is not adhered\n      to the definite job and is not automatically release the\
    \ resources\n      at the end of the job, which has created them.\n   o  Parameters\
    \ of functions and the returned values must not contain\n      the pointers, because\
    \ the node can be reloaded at any moment.  It\n      will result that the pointers\
    \ will become invalid or will address\n      other objects.\n   The protocol cannot\
    \ check those conditions.  Their realization lays\n   on VM wholly.\n   The work\
    \ without establishment of session connection may be used in\n   the following\
    \ systems:\n   o  In simple devices, which do not have the operational system;\n\
    \   o  On servers which are executed a plenty of requests (for work\n      without\
    \ connection of resources is used less);\n   o  In systems requiring the fast\
    \ response to rare requests (if\n      keeping of connection is inexpedient).\n"
- title: 6  Instructions of Exchange between VM
  contents:
  - "6  Instructions of Exchange between VM\n   The instructions intended for an exchange\
    \ between VM uses values\n   OPCODE in range 128 - 223.  Depending on length of\
    \ the operands\n   field, several formats of the instruction may be defined for\
    \ one\n   OPCODE.  The complete instruction format is defined by aggregate of\n\
    \   the values of fields OPCODE and OPR_LENGTH.\n   The instruction has the field\
    \ REQ_ID, if in the instruction header\n   flag ASK = 1.  REQ_ID is used for the\
    \ response identification.  The\n   value of this field is specifies by VM.  The\
    \ response is formed by\n   VM, too.  The protocol does not check the response\
    \ and does not\n   analyze the value of the field REQ_ID for the instructions\
    \ of\n   exchange between VM.  One of the instructions RSP, DATA, RETURN,\n  \
    \ ADDRESS, OBJECT or PROC_NUM is used for sending of the response.  The\n   instructions\
    \ of response have ASK = 1 and the value taken from the\n   confirmed instruction\
    \ is record in REQ_ID.  The instructions of\n   response do not require the response.\n\
    \   The instructions of exchange between VM may be sent through UDP at\n   observance\
    \ of the following conditions:\n   o  ASK = 0;\n   o  The instruction is located\
    \ in one segment UDP;\n   The timeouts and the repeated sending are not used at\
    \ UMSP layer for\n   instructions of exchange between VM.  It is explained to,\
    \ that the\n   time of sending instructions with low priority may be very large\n\
    \   because of the output queues.  Therefore, the VM must make a decision\n  \
    \ on timeout, as only VM has the complete information on type of the\n   transmitted\
    \ data.  Besides, the transport layer protocol must use the\n   timeouts.\n  \
    \ A few VM may be connected to the protocol on the node.  VM may\n   simultaneously\
    \ execute several jobs.  Each job may work in its\n   address space.  The protocol\
    \ determines VM and job, which the\n   received instruction must transfer to,\
    \ on field SESSION_ID value.\n   The local memory address is located in the instruction\
    \ in field of\n   length 2/4/8 octets.  If memory address length in the instruction\
    \ is\n   not equal to memory address length defined for the node, the\n   following\
    \ variants are possible:\n   o  If memory address length is set in 24 bits for\
    \ the node, the\n      address is writes in the end of 4 - octets field.  The\
    \ 0 value\n      sets in an initial (zero) octet.\n   o  If the instruction format\
    \ assumes the memory address length not\n      less than 4 octets, 2-octet address\
    \ is located in the last octets.\n      The first 2 octets must set to zero.\n\
    \   o  If instruction is the member of a chain and it has the less length\n  \
    \    of the memory address, than it is defined for the node - it is\n      considered,\
    \ that the base-displacement addressing is used.  If the\n      value of the memory\
    \ base is not assigned for the chain -\n      instruction is erroneous.\n   o\
    \  If the instruction is not the member of a chain and has the length\n      of\
    \ memory address less, than it is defined for the node, it is\n      considered,\
    \ that the abbreviated address is used.  The complete\n      address length must\
    \ be received by padding in front of it the\n      necessary number of zero-value\
    \ octets.\n   o  In all other cases, the instruction is erroneous.\n   Complete\
    \ 128-bit memory address writes in operands in the 16-octets\n   field.  The reason\
    \ of using of the complete address is that the\n   additional information, using\
    \ by the memory control subsystem in the\n   node, may contain in its field FREE\
    \ (see section 2.1).  If the FREE\n   of the complete address is set to zero,\
    \ it is recommended to use\n   local address in operands.\n   Operands field has\
    \ a length, which is an integral number of 32 bits.\n   The alignment is making\
    \ by padding, if necessary, of the zero-value\n   octets at the end of the field.\n\
    \   Header fields of the instructions not defined in the formats\n   description\
    \ are used according to the description from section 3.\n   The instruction of\
    \ the transfer control JUMP, CALL, CALL_BNUM and\n   CALL_BNAME may contain the\
    \ information about VM of the sender.  If VM\n   type and VM version of the sender\
    \ are contains in the instruction,\n   the call parameters are formed in a format\
    \ VM of the sender.  Else,\n   the call parameters have format defined by VM of\
    \ the addressee.  The\n   code is always connected with of specific VM.\n   All\
    \ instructions of the protocol work with binary data and do not\n   provide operations\
    \ of formats transformation.\n"
- title: 6.1  Data Reading/Writing Instructions
  contents:
  - '6.1  Data Reading/Writing Instructions

    '
- title: 6.1.1   REQ_DATA
  contents:
  - "6.1.1   REQ_DATA\n   The instruction \"To request a data\" (REQ_DATA) is used\
    \ for the data\n   request from the remote node.  Two instructions REQ_DATA with\
    \ length\n   of the length field 2 and 4 octets are defined.  These instructions\n\
    \   have the following values of fields:\n      OPCODE = 130/131      ; For length\
    \ of the length field of 2/4\n                              octets.\n      OPR_LENGTH\
    \ = 1/2/3/5  ; Depends on address length.\n      Operands:\n         2/4 octets:\
    \ The length field. The number of the required data in\n                     octets.\n\
    \         2/4/8/16 octets: The memory address of the required data.\n   The instruction\
    \ DATA, containing required data, is sent in reply to\n   it.  If the data cannot\
    \ be sent, the instruction RSP with the non-\n   zero basic return code, comes\
    \ back.\n"
- title: 6.1.2   DATA
  contents:
  - "6.1.2   DATA\n   The instruction \"The data\" (DATA) is sent in reply to the\
    \ instruction\n   REQ_DATA and OBJ_REQ_DATA.  The instruction has the following\
    \ values\n   of fields:\n      OPCODE = 132\n      OPR_LENGTH = 0 - 65535  ; Depends\
    \ on the immediate data length of\n                                the operand.\n\
    \      Operands:\n         0 - 262140 octets: Immediate data.  If OPR_LENGTH =\
    \ 0, this\n                            field are absent.\n      Extension headers:\n\
    \         _DATA - Contains immediate data.  If OPR_LENGTH <> 0, this\n       \
    \          header are absent.\n   The extension header is used, if the data are\
    \ more then an maximum\n   operands field size.  The data must not be sent simultaneously\
    \ in\n   operands and in the extension header.  To make the length of data\n \
    \  multiple of 4 octets, 1 - 3 zero-value octets are padded in the end\n   of\
    \ a field.\n"
- title: 6.1.3   WRITE
  contents:
  - "6.1.3   WRITE\n   The instruction \"To write the data\" (WRITE) is used for data\
    \ writing\n   on the remote node.  The instruction has the following values of\n\
    \   fields:\n      OPCODE = 133/134/135/136  ; For memory address length of 2/4/8/16\n\
    \                                  octets.\n      OPR_LENGTH = 1 - 65535    ;\
    \ Depends on length of the immediate\n                                  data.\n\
    \      Operands:\n         2/4/8/16 octets: The memory address for writing the\
    \ data.\n         0 - 262136 octets: Immediate data for write.\n      Extension\
    \ headers:\n         _DATA - Contains immediate data.  This header is present\
    \ only,\n                 if the data does not contain in operands.\n   At address\
    \ length of 2 octets the data length must be 2 octets.  In\n   all other cases,\
    \ address length must be not less than 4 octets and\n   data length must be multiple\
    \ of 4 octets.  The data must not be sent\n   simultaneously in operands and in\
    \ the extension header.\n   The instruction RSP is sent in reply to the instruction\
    \ WRITE.  The\n   zero basic return code defines normal executing.\n"
- title: 6.1.4   WRITE_EXT
  contents:
  - "6.1.4   WRITE_EXT\n   The instruction \"The extension writing of data\" (WRITE_EXT)\
    \ is used\n   for the data writing on the remote node.  Length of the data may\
    \ be 1\n   - 262132 octets with a step 1 octet.  The instruction has the\n   following\
    \ values of fields:\n      OPCODE = 137\n      OPR_LENGTH = 3 - 65535  ; Depends\
    \ on length of the immediate data.\n      Operands:\n         1 octets: Always\
    \ set to zero.\n         3 octets: The number of the write data in octets.  The\
    \ zero-\n                   value is not available.\n         4 - 262132 octets:\
    \ Immediate data for write.  The data length\n                            must\
    \ be multiple of 4 octets.\n         4/8/16 octets: The memory address for writing\
    \ the data.\n   To make the immediate data multiple of four octets, the data is\n\
    \   padded with 1 - 3 zero-value octets at the end of a field.\n   The instruction\
    \ RSP is sent in reply to the instruction WRITE_EXT.\n   The zero basic return\
    \ code defines normal executing.\n"
- title: 6.2  Comparison Instructions
  contents:
  - '6.2  Comparison Instructions

    '
- title: 6.2.1   CMP
  contents:
  - "6.2.1   CMP\n   The instruction \"To compare\" (CMP) is used for binary data\n\
    \   comparison.  It has the following values of fields:\n      OPCODE = 138/139/140/141\
    \  ; For the address length of 2/4/8/16\n                                  octets.\n\
    \      OPR_LENGTH = 1 - 65535    ; Depends on length of the immediate\n      \
    \                            data.\n      Operands:\n         2/4/8/16 octets:\
    \ The memory address for compared data.\n         2 - 262136 octets: The immediate\
    \ data for the comparison.\n   At the address length of 2 octets the data length\
    \ must be 2 octets.\n   In all other cases length of the address must not be less\
    \ than 4\n   octets and the data length is multiple to four octets.\n"
- title: 6.2.2   CMP_EXT
  contents:
  - "6.2.2   CMP_EXT\n   The instruction \"The extension compare\" (CMP_EXT) is used\
    \ for binary\n   data comparison.  Length of the data may be 1 - 262132 octets\
    \ with a\n   step 1 octet.  The instruction has the following values of fields:\n\
    \      OPCODE = 142\n      OPR_LENGTH = 3 - 65535  ; Depends on length of the\
    \ immediate data\n                                and the address.\n      Operands:\n\
    \         1 octet: Always set to 0.\n         3 octets: The length of compared\
    \ data in octets.  The zero-value\n                   is not available.\n    \
    \     4 - 262132 octets: The immediate data for the comparison.  The\n       \
    \                     length of field is multiple of 4 octets.\n         4/8/16\
    \ octets: The memory address of compared data.\n   To make the immediate data\
    \ multiple of four octets, the data is\n   padded with 1 - 3 zero-value octets\
    \ at the end of a field.\n"
- title: 6.2.3   Response to Comparison Instructions
  contents:
  - "6.2.3   Response to Comparison Instructions\n   The instruction RSP is sent in\
    \ reply to the instruction CMP, CMP_EXT\n   and OBJ_CMP (see below).  If the comparison\
    \ was executed, the basic\n   return code is equal to zero.  The additional return\
    \ code is equal to\n   -1, if the data at the address memories are less then the\
    \ data from\n   the operand; 0, if they are equal; and 1, if they are more.  If\
    \ the\n   comparison cannot be executed, the basic return code of the\n   instruction\
    \ RSP must be non-zero.\n"
- title: 6.3  Control Transfer Instructions
  contents:
  - '6.3  Control Transfer Instructions

    '
- title: 6.3.1   JUMP, CALL
  contents:
  - "6.3.1   JUMP, CALL\n   The \"Unconditional jump\" (JUMP) and \"To Call-subroutine\"\
    \ (CALL)_\n   instructions have an equal format and differ only by OPCODE.  These\n\
    \   instructions have the following values of fields:\n      OPCODE = 143/144\
    \  ; Correspondingly for the JUMP not containing\n                          and\
    \ containing the information about VM.\n               145/146  ; Correspondingly\
    \ the CALL not containing and\n                          containing the information\
    \ about VM.\n      OPR_LENGTH = 2 - 65535  ; Depends on inclusion of the information\n\
    \                                about VM, address length and parameters\n   \
    \                             length.\n      Operands:\n         2 octets: The\
    \ VM type of the sender.  If OPCODE=143/145 this\n                   field is\
    \ absent.\n         2 octets: The VM version of the sender.  If OPCODE=143/145\
    \ this\n                   field is absent.\n         4/8/16 octets: The address\
    \ of memory, where is necessary to\n                        transfer control.\n\
    \         2 octets: The number of 32 bit words in the call parameters\n      \
    \             field.\n         4 - 262134 octets: The immediate data are the parameters\
    \ of a\n                            call.\n   On the reception side the processing\
    \ of the instructions of a control\n   transfer occurs as follows:\n   o  The\
    \ memory address is checked.  If it has erroneous value, the\n      negative response\
    \ RSP is sent.  At this stage, the correctness of\n      parameters of a call\
    \ may be also checked up.\n   o  If the memory address and the parameters of a\
    \ call have correct\n      value, the positive response RSP is sent for the instruction\
    \ JUMP.\n      The transmitting side considers the instruction JUMP executed\n\
    \      after receiving response.\n   o  For response of an execution of the instruction\
    \ CALL the\n      instruction RETURN is sent.  The instruction RETURN may contain\n\
    \      the returned values.  If there is an exception condition in a\n      thread\
    \ of control created by the CALL instruction, the instruction\n      RSP with\
    \ a non-zero basic return code is sent instead of RETURN.\n"
- title: 6.3.2   RETURN
  contents:
  - "6.3.2   RETURN\n   The instruction \"Return of control\" (RETURN) is used at\
    \ return of\n   control from the instructions CALL, MVRUN, CALL_BNUM and CALL_BNAME\n\
    \   (see below).  Those instructions have the following values of fields:\n  \
    \    OPCODE = 147\n      OPR_LENGTH = 0 - 65535  ; Depends on length of the immediate\
    \ data.\n      Operands:\n         0 - 262140 octets: Immediate data returned\
    \ from the subroutine.\n   If it is not required to send returned value, the instruction\
    \ RETURN\n   does not contain operands. The data format coincides with the\n \
    \  instruction, for which the response (format VM of the sender or\n   addressee)\
    \ will be sent.\n"
- title: 6.4  Memory Control Instructions
  contents:
  - "6.4  Memory Control Instructions\n   UMSP gives means for division of memory\
    \ for a code and for the data.\n   The protocol does not make checks of correctness\
    \ of operations with\n   memory.  The code and the data use common address space.\
    \  The control\n   of memory is completely realized by VM.\n"
- title: 6.4.1   MEM_ALLOC
  contents:
  - "6.4.1   MEM_ALLOC\n   The instruction \"To allocate a memory for the data\" (MEM_ALLOC)\
    \ is\n   used for request of the allocation of memory under the data.  The\n \
    \  instruction has the following values of fields:\n      OPCODE = 148\n     \
    \ OPR_LENGTH = 1\n      Operands:\n         4 octets: The size of required memory\
    \ in bytes.\n   For the positive response on the instruction MEM_ALLOC, the\n\
    \   instruction ADDRESS, for negative - RSP with the non-zero basic\n   return\
    \ code is sent.  The received address can be used by the\n   protocol in the instructions\
    \ of reading/writing, comparison and\n   synchronization.\n"
- title: 6.4.2   MVCODE
  contents:
  - "6.4.2   MVCODE\n   The instruction \"To move the code\" (MVCODE) is used for\
    \ moving of the\n   executable code from one node on another.  The instruction\
    \ has the\n   following values of fields:\n      OPCODE = 149\n      OPR_LENGTH\
    \ = 1 - 65535 ; Depends on length of the code field.\n      Operands:\n      \
    \   2 octets: The VM type of addressee.\n         2 octets: The VM version of\
    \ addressee.\n         0-262136 octets: contains the executable code.\n      The\
    \ extension headers:\n         _DATA - contains the executable code.  This header\
    \ is present\n                 only, if the code does not contain in operands.\n\
    \   The code is always connected with VM of the definite type.  The code\n   field\
    \ is always transparent for the protocol.  It is formed by the VM\n   of sender\
    \ and must contain all the information necessary VM of the\n   receiver.  The\
    \ code must not simultaneously be sent in operands and\n   in the extension header.\n\
    \   For the positive response on the instruction MVCODE, the instruction\n   ADDRESS,\
    \ for negative - RSP with the non-zero basic return code is\n   used.  The code\
    \ transferred on the instruction MVCODE, may be\n   executed by the instruction\
    \ JUMP or CALL.\n"
- title: 6.4.3   ADDRESS
  contents:
  - "6.4.3   ADDRESS\n   The instruction \"The memory address\" (ADDRESS) is used\
    \ for the\n   positive response on the instruction MEM_ALLOC and MVCODE.  ADDRESS\n\
    \   has the following values of fields:\n      OPCODE = 150\n      OPR_LENGTH\
    \ = 1/2/4; Depends on length of the address.\n      Operands:\n         4/8/16\
    \ octets: The address of the allocated memory.\n   For the instruction, MEM_ALLOC\
    \ the address specifies first byte of\n   the allocated data area.  For the instruction\
    \ MVCODE the contents of\n   the address is defined VM, by which the code is connected.\n"
- title: 6.4.4   FREE
  contents:
  - "6.4.4   FREE\n   The memory allocated with the instructions MEM_ALLOC and MVCODE,\
    \ must\n   be explicitly release.  For this purpose, the instruction \"To free\n\
    \   the memory\" (FREE) is used.  It has the following values of fields:\n   \
    \   OPCODE = 151\n      OPR_LENGTH = 1/2/4; Depends on length of the address\n\
    \      Operands:\n         4/8/16 octets: the address of free memory.\n   VM must\
    \ free this memory automatically at end of the task on the\n   node.\n"
- title: 6.4.5   MVRUN
  contents:
  - "6.4.5   MVRUN\n   The instruction \"To move and run\" (MVRUN) is used for simultaneous\n\
    \   move of a code and its execution.  The instruction has the following\n   values\
    \ of fields:\n      OPCODE = 152\n      OPR_LENGTH = 1 - 65535 ; Depends on length\
    \ of the code field.\n      Operands:\n         2 octets: The addressee VM type.\n\
    \         2 octets: The addressee VM version.\n         4 - 262136 octets: Contains\
    \ an executable code.\n      The extension headers:\n         _DATA - Contains\
    \ an executable code.  This header is present\n                 only, if the code\
    \ does not contain in operands.\n   The executable code is the transparent buffer\
    \ with the binary data\n   for the protocol.  The format of this field is defined\
    \ by the VM and\n   it must contain all the information necessary for the loader\
    \ VM of\n   the addressee, including parameters of a call.\n   The code must not\
    \ simultaneously be sent in operands and in the\n   extension header.\n   The\
    \ answer to the instruction MVRUN is formed similarly to\n   instruction CALL.\
    \  It is not necessary to release memory allocated\n   for a code by this instruction.\
    \  The memory must deallocate the VM.\n"
- title: 6.5  Other Instructions
  contents:
  - '6.5  Other Instructions

    '
- title: 6.5.1   SYN
  contents:
  - "6.5.1   SYN\n   The instruction \"To Synchronize\" (SYN) is used for the single\
    \ message\n   about the data change.  The instruction has the following values\
    \ of\n   fields:\n      OPCODE = 153/154/155 ; For length of the address 4/8/16\
    \ octets.\n      OPR_LENGTH = 2 - 65535; Depends on length of the data\n     \
    \ Operands:\n         4/8/16 octets: The memory address of the tracking data.\n\
    \         2 - 131068 octets: The initial data.  Length of the data must be\n \
    \                           multiple of two octets.\n         2 - 131068 octets:\
    \ A mask for comparison.  Length of this field\n                            is\
    \ equal to length of a field of the initial\n                            data.\n\
    \   The tracking data is set by the memory address in the first operand.\n   These\
    \ data are originally compared to the initial data value from the\n   second operand.\
    \  If the values do not coincide, it is considered,\n   that the data have changed.\
    \  The third operand allows setting a mask\n   for comparison.  Set to one bits\
    \ of the mask specifies bits in the\n   data, which change must be traced.\n \
    \  The following variants of the answer are probable on the instruction:\n   o\
    \  If the address of local memory is incorrect, the instruction RSP\n      with\
    \ the non-zero basic return code is sent for the response.\n   o  If the data\
    \ do not change, in the response nothing is sent.\n   o  If the data have changed,\
    \ the instruction DATA with new value of\n      the traced data is sent.\n"
- title: 6.5.2   NOP
  contents:
  - "6.5.2   NOP\n   The instruction \"No operation\" (NOP) has the following values\
    \ of\n   fields:\n      OPCODE = 156\n      OPR_LENGTH = 0 - 65535\n      Operands:\n\
    \         0 - 262140 octets: Encapsulated data.\n      Extension headers:\n  \
    \       Any Extension headers.\n   The instruction NOP is intended for the decision\
    \ of the following\n   tasks:\n   o  Send the control extension headers, when\
    \ there are no other\n      instructions for sending in a session\n   o  Encapsulate\
    \ the fragmented instructions and transactions with the\n      established flag\
    \ of special processing (see section 7).\n"
- title: 6.6  Work with Objects
  contents:
  - "6.6  Work with Objects\n   The protocol has a set of the instructions being expansion\
    \ of the\n   protocol RPC [6].  As against RPC, UMSP allows immediately to address\n\
    \   memory on remote nodes and to send the pointers in parameters and\n   returned\
    \ values.\n   The UMSP object is identified by the 4-octet number.  The values\
    \ are\n   divided into the following ranges:\n        I -> %x00000000 - 1FFFFFFF\
    \   are assigned for standard objects\n       II -> %x20000000 - 3FFFFFFF   are\
    \ assigned for users objects\n      III -> %x30000000 - 4FFFFFFF   free\n    \
    \   IV -> %x50000000 - DFFFFFFF   transient\n        V -> %xE0000000 - FFFFFFFF\
    \   reserved\n   The objects from a range I must be definite, as standard, and\
    \ the\n   specifications of their interfaces must be published.  The protocol\n\
    \   does not suppose the private or not described interfaces of standard\n   objects.\n\
    \   The objects from a range II must be registered, but the\n   specifications\
    \ of their interfaces may be optional published.  These\n   numbers are applied\
    \ in cases, when it is required to exclude the\n   probable conflict of systems\
    \ of the different manufacturers.\n   The range III can be used freely.  The objects\
    \ accessible on these\n   numbers may be created statically or dynamically.  These\
    \ objects can\n   have any interfaces.\n   All objects, concerning ranges I, II\
    \ and III, is common for all jobs\n   on the node, including zero-session.  Their\
    \ interfaces are accessible\n   to all tasks on the node, depending on parameters\
    \ of authentication.\n   The range IV is intended for objects created dynamically\
    \ within the\n   framework of one job.  These objects are the isolated associative\n\
    \   memory of the job.  The access to these objects must be granted only\n   for\
    \ one job.  The zero-session has no access to these objects.\n   The protocol\
    \ grants the access to the data of object, as to the\n   continuous segment of\
    \ memory.  The memory of objects may be\n   overlapping or no overlapping with\
    \ flat local memory of the node.\n   The offset field is used in the instructions\
    \ of work with the data of\n   object.  The offset rules writing are similar to\
    \ the local address\n   rules writing.\n   The address memory length of the node,\
    \ definite for the UMSP\n   protocol, limits the maximal data size of one object.\
    \  The\n   instructions definite in the given section, allow to work with\n  \
    \ associative memory with the theoretical limiting size on one node -\n   2^96\
    \ (7,9 * 10^28) Byte.\n   In addition to the number, the object has the version,\
    \ 2 octets\n   length, and realization, 2 octets length.  The protocol requires\n\
    \   obligatory compatibility from bottom-up for all realizations of one\n   version\
    \ of object.  The publication of new realization of standard\n   object may contain\
    \ only added interfaces.\n   If for the sender of the instruction the version\
    \ and/or the\n   realization of object do not play any role or is unknown, the\n\
    \   instruction may contain zero fields of the version and realization of\n  \
    \ object or only zero field of realization.  The zero field of the\n   version\
    \ and non-zero field of realization are not allowed.\n"
- title: 6.6.1   Reading/Writing of the Objects Data
  contents:
  - '6.6.1   Reading/Writing of the Objects Data

    '
- title: 6.6.1.1  OBJ_REQ_DATA
  contents:
  - "6.6.1.1  OBJ_REQ_DATA\n   The instruction \"To request the data of object\" (OBJ_REQ_DATA)\
    \ is\n   used for request of data of the Object from the remote node.  The\n \
    \  instruction has the following values of fields:\n      OPCODE = 192/193   ;\
    \ For length of the field of length 2/4 octets.\n      OPR_LENGTH = 3/4/5 ; Depends\
    \ on length of the offset field.\n      Operands:\n         4 octets: The number\
    \ of object.\n         2 octets: The version of object.\n         2 octets: The\
    \ realization of object.\n         2/4 octets: The length of the required data\
    \ in octets.\n         2/4/8 octets: Offset required data from the beginning of\
    \ object\n                       in bytes.\n   At length of the length field of\
    \ 2 octets the offset length must be 2\n   octets.  In all other cases, length\
    \ of the length field and offset\n   length must be not less than 4 octets.\n\
    \   The instruction DATA, containing the required data, is sent for reply\n  \
    \ to instruction OBJ_REQ_DATA.  If the data cannot be transmitted, the\n   instruction\
    \ RSP from the non-zero basic return code comes back.\n"
- title: 6.6.1.2  OBJ_WRITE
  contents:
  - "6.6.1.2  OBJ_WRITE\n   The instruction \"To write the data in object\" (OBJ_WRITE)\
    \ is used for\n   write of the data in object.  The instruction has the following\n\
    \   values of fields:\n      OPCODE = 194/195/196   ; For length of the offset\
    \ field of 2/4/8\n                               octets.\n      OPR_LENGTH = 3\
    \ - 65535 ; Depends on the data length.\n      Operands:\n         4 octets: The\
    \ number of object.\n         2 octets: The version of object.\n         2 octets:\
    \ The realization of object.\n         2/4/8 octets: The offset in object for\
    \ the data writes.\n         2 - 262128 octets: The immediate data for write.\n\
    \      The extension headers:\n         _DATA - Contains immediate data for write.\
    \  This header is\n                 present, only if the data is not present in\
    \ operands.\n   At length of the field-offset of 2 octets, length of the data\
    \ must be\n   2 octets.  In all other cases, the offset length must be not less\n\
    \   than 4 octets and the data length is multiple to four.  The data must\n  \
    \ not simultaneously be sent in operands and in the extension header.\n   The\
    \ instruction RSP is sent in reply to the instructions OBJ_WRITE.\n   The zero\
    \ basic return code defines the normal execution.\n"
- title: 6.6.1.3  OBJ_WRITE_EXT
  contents:
  - "6.6.1.3  OBJ_WRITE_EXT\n   The instruction \"The extension writing of the data\
    \ in object\"\n   (OBJ_WRITE_EXT) is used for write of the data in object.  Length\
    \ of\n   the data may be 1 - 262132 octets with the step 1 octet.  The\n   instruction\
    \ has the following values of fields:\n      OPCODE = 197\n      OPR_LENGTH =\
    \ 3 - 65535; Depends on the data length and the address\n                    \
    \          length.\n      Operands:\n         4 octets: The number of object.\n\
    \         2 octets: The version of object.\n         2 octets: The realization\
    \ of object.\n         1 octet: Always set to 0.\n         3 octets: Length written\
    \ down data in octets.  The zero-value is\n                   incorrect.\n   \
    \      4 - 262124 octets: The immediate data for write.  Length of the\n     \
    \                       data is multiple of 4 octets.\n         2/4/8 octets:\
    \ Offset in object for the data write.\n   If the length of the written down data\
    \ is not multiple of four\n   octets, the data is padded with 1 - 3 zero octets\
    \ at the end.\n   The instruction RSP is sent in reply to the instructions\n \
    \  OBJ_WRITE_EXT.  The zero basic return code defines the normal\n   execution.\n"
- title: 6.6.2  Comparison Instructions of the Objects Data
  contents:
  - '6.6.2  Comparison Instructions of the Objects Data

    '
- title: 6.6.2.1  OBJ_DATA_CMP
  contents:
  - "6.6.2.1  OBJ_DATA_CMP\n   The instruction \"To compare the data of object\" (OBJ_DATA_CMP)\
    \ is\n   used for binary comparison of data of the object by the immediate\n \
    \  data from operands.  The instruction has the following values of\n   fields:\n\
    \      OPCODE = 198/199/200  ; For length of offset field of 2/4/8\n         \
    \                     octets.\n      OPR_LENGTH = 3 - 65535; Depends on length\
    \ of the data.\n      Operands:\n         4 octets: The number of object.\n  \
    \       2 octets: The version of object.\n         2 octets: The realization of\
    \ object.\n         2/4/8 octets: Offset in object for the compared data.\n  \
    \       2 - 262128 octets: The immediate data for comparison.\n   At length of\
    \ a field of 2 octets offset the data length must be 2\n   octets.  In all other\
    \ cases the offset length must be not less than 4\n   octets and the data length\
    \ is multiple to 4 octets.\n   The response to the instruction OBJ_DATA_CMP is\
    \ described in section\n   6.2.3.\n"
- title: 6.6.2.2  OBJ_DATA_CMP_EXT
  contents:
  - "6.6.2.2  OBJ_DATA_CMP_EXT\n   The instruction \"The extension compare of data\
    \ of the object\"\n   (OBJ_DATA_CMP_EXT) is used for binary comparison of data\
    \ of the\n   object by the immediate data from operands.  Length of the data may\n\
    \   be 1 - 262132 octets with a step 1 octet.  The instruction has\n   following\
    \ values of fields:\n      OPCODE = 201\n      OPR_LENGTH = 5 - 65535  ; Depends\
    \ on length of the immediate data\n                                and the address\
    \ length.\n      Operands:\n         4 octets: The number of object.\n       \
    \  2 octets: The version of object.\n         2 octets: The realization of object.\n\
    \         1 octet: Always set to 0.\n         3 octets: The length of compared\
    \ data in octets.  The zero-value\n                   is incorrect.\n        \
    \ 4 - 262124 octets: The immediate data for the comparison.  The\n           \
    \                 length of field is multiple of 4 octets.\n         4/8 octets:\
    \ Offset in object for the compared data.\n   To make the immediate data multiple\
    \ of four octets, the data is\n   padded with 1 - 3 zero-value octets at the end.\n\
    \   The response to the instruction OBJ_DATA_CMP_EXT is described in\n   section\
    \ 6.2.3.\n"
- title: 6.6.3   Execution of the Objects Procedures
  contents:
  - '6.6.3   Execution of the Objects Procedures

    '
- title: 6.6.3.1  CALL_BNUM
  contents:
  - "6.6.3.1  CALL_BNUM\n   The instruction \"To call the object procedure over number\"\
    \n   (CALL_BNUM) transfers control to the object procedure over indication\n \
    \  of the number.  The instruction has following values of fields:\n      OPCODE\
    \ = 202/203 ; Accordingly for the instructions not containing\n              \
    \           and containing the information about VM.\n      OPR_LENGTH = 4 - 65535\
    \ ; Depends on inclusion of the information\n                               about\
    \ VM and call parameters length.\n      Operands:\n         2 octets: The VM type\
    \ of the sender.  If OPCODE=202 this field\n                   is absent.\n  \
    \       2 octets: The VM version of the sender.  If OPCODE=202 this\n        \
    \           field is absent.\n         4 octets: The number of object.\n     \
    \    2 octets: The version of object.\n         2 octets: The realization of object.\n\
    \         4 octets: The number of the called procedure.\n         4 - 262128 octets:\
    \ Parameters of the call.\n   The processing on the reception side is made similarly\
    \ instructions\n   CALL (see section 6.3.1).\n"
- title: 6.6.3.2  CALL_BNAME
  contents:
  - "6.6.3.2  CALL_BNAME\n   The instruction \"To call the object procedure over name\"\
    \ (CALL_BNAME)\n   transfers control to the object procedure over indication of\
    \ the\n   name.  The instruction has following values of fields:\n      OPCODE\
    \ = 204/205  ; Accordingly for the instructions not\n                        \
    \  containing and containing the information\n                          about\
    \ VM.\n      OPR_LENGTH = 3 - 65535 ; Depends on inclusion of the information\n\
    \                               about VM and call parameters length.\n      Operands:\n\
    \         2 octets: The VM type of the sender.  If OPCODE=204 this field\n   \
    \                is absent.\n         2 octets: The VM version of the sender.\
    \  If OPCODE=204 this\n                   field is absent.\n         4 octets:\
    \ The number of object.\n         2 octets: The version of object.\n         2\
    \ octets: The realization of object.\n         4 - 262128 octets: Parameters of\
    \ the call.\n      The extension header:\n         _NAME - Contains the name of\
    \ the called procedure.\n   The processing on the reception side is made similarly\
    \ instructions\n   CALL (see section 6.3.1).\n   The names may have the procedures\
    \ of the objects belonging to ranges\n   III and IV.  The procedures of the objects\
    \ belonging to ranges I and\n   II must not have a name on the UMSP layer.  They\
    \ must have the number\n   only.\n"
- title: 6.6.3.3  GET_NUM_PROC
  contents:
  - "6.6.3.3  GET_NUM_PROC\n   The instruction \"To get the name of object procedure\"\
    \ (GET_NUM_PROC)\n   allows receiving number of the procedure for objects in ranges\
    \ III\n   and IV over procedure name.  The instruction has following values of\n\
    \   fields:\n      OPCODE = 206\n      OPR_LENGTH = 2\n      Operands:\n     \
    \    4 octets: The number of object.\n         2 octets: The version of object.\n\
    \         2 octets: The realization of object.\n      The extension header:\n\
    \         _NAME - Contains procedure name.\n   For the positive response on the\
    \ instruction GET_NUM_PROC, the\n   instruction PROC_NUM, for negative - RSP with\
    \ the non-zero basic\n   return code is sent.\n"
- title: 6.6.3.4  PROC_NUM
  contents:
  - "6.6.3.4  PROC_NUM\n   The instruction \"The procedure number\" (PROC_NUM) is\
    \ sent in reply to\n   the instruction GET_NUM_PROC.  The instruction PROC_NUM\
    \ has following\n   values of fields:\n      OPCODE = 207\n      OPR_LENGTH =\
    \ 3\n      Operands:\n         4 octets: The number of object.\n         2 octets:\
    \ The version of object.\n         2 octets: The realization of object.\n    \
    \     4 octets: The number of procedure.\n"
- title: 6.6.4   The Objects Creation
  contents:
  - "6.6.4   The Objects Creation\n   The objects from the ranges I and II (standard\
    \ and assigned for the\n   user) cannot be created on the remote node through\
    \ the UMSP\n   interface.  These objects must be created only through API of the\
    \ VM.\n   The objects from the ranges III and IV can be created on the remote\n\
    \   node by the protocol instructions.\n   The realization of objects from the\
    \ ranges I - III (not connected\n   with the certain job) is difficult enough.\
    \  The reason is that the\n   different jobs can have the different address spaces\
    \ of memory.  The\n   pointers must be processed in the context of the job, from\
    \ which they\n   are received.  Besides, these objects must trace the end of the\
    \ jobs\n   for deallocation of dynamic resources.  The specified requirements\n\
    \   impose essential restrictions on these objects.  The protocol does\n   not\
    \ impose any restrictions on objects from the range IV.\n   Unique key identifying\
    \ object on node, is number of object.  To\n   objects from the ranges, III and\
    \ IV the name may be assigned.  The\n   objects from range I and II must not have\
    \ names on the UMSP layer.\n   Within the framework of one task must not be two\
    \ objects having one\n   number or one name.\n"
- title: 6.6.4.1  NEW, SYS_NEW
  contents:
  - "6.6.4.1  NEW, SYS_NEW\n   The format of both instructions \"New object\" (NEW)\
    \ and \"New system\n   object\" (NEW_SYS) is similar.  First instruction creates\
    \ object in\n   the range IV, second - in the range III.  These instructions have\
    \ the\n   following values of fields:\n      OPCODE = 208/209; Accordingly for\
    \ NEW/NEW_SYS.\n      OPR_LENGTH = 3\n      Operands:\n         2 octets: The\
    \ addressee VM type.\n         2 octets: The addressee VM version.\n         2\
    \ octets: The version of object.\n         2 octets: The realization of object.\n\
    \         4 - 262136 octets: Immediate data necessary for creation of\n      \
    \                      object.\n      The extension headers:\n         _DATA -\
    \ Contains immediate data, necessary for creation of\n                 object.\
    \  This header is present, only if the data is not\n                 present in\
    \ operands.\n         _NAME - Contains the name of object.  This header is optional.\n\
    \   The instruction NEW_SYS is used for the creation of object accessible\n  \
    \ from any job, NEW - for creation of object accessible only from its\n   job.\
    \  If the object is created, the instruction OBJECT is sent for\n   the response.\
    \  If the object cannot be created, the instruction RSP\n   with the non-zero\
    \ basic return code is sent.\n   The immediate data field is transparent for the\
    \ protocol.  It is\n   formed by the sender VM and it must contain the information,\
    \ which is\n   necessary to the addressee VM for the creation of object.  Data\
    \ must\n   not simultaneously be sent in operands and in the extension header.\n\
    \   The field SESSION_ID of the instruction cannot have the zero value.\n   The\
    \ dynamic object must be created only in the context of the\n   definite job.\
    \  The object is always created on VM, with which the\n   session is connected.\n\
    \   The zero values of the version and the realizations of object means,\n   that\
    \ the object have no these values.\n   It is possible to register the name of\
    \ object simultaneously with its\n   creation.  The name contains in the _NAME\
    \ extension header.\n   All objects created upon the instructions NEW and NEW_SYS\
    \ must be\n   obviously deleted.  VM must automatically delete all dynamic objects,\n\
    \   created and not deleted by the task, at the end of the task.\n"
- title: 6.6.4.2  OBJECT
  contents:
  - "6.6.4.2  OBJECT\n   The instruction \"The Object\" (OBJECT) is used for the positive\n\
    \   response on the instruction NEW and NEW_SYS.  The instruction OBJECT\n   has\
    \ following values of fields:\n      OPCODE = 210\n      OPR_LENGTH = 2\n    \
    \  Operands:\n         4 octets: The number of object.\n         2 octets: The\
    \ version of object.\n         2 octets: The realization of object.\n"
- title: 6.6.4.3  DELETE
  contents:
  - "6.6.4.3  DELETE\n   The instruction \"To delete the object\" (DELETE) is used\
    \ for the\n   deleting of object created on the instruction NEW or NEW_SYS.  The\n\
    \   instruction DELETE has the following values of fields:\n      OPCODE = 211\n\
    \      OPR_LENGTH = 1\n      Operands:\n         4 octets: number of object\n\
    \   The object may be deleted only from the job, which has created it.\n   The\
    \ instruction RSP is sent in reply to this instruction.\n"
- title: 6.6.5   The Objects Identification
  contents:
  - "6.6.5   The Objects Identification\n   At registration of object on the node,\
    \ it may be identify by the\n   name, the length of 4 - 254 octets.  The name\
    \ contains the symbols\n   ASCII.  The following versions of the protocol may\
    \ define other types\n   of the name.\n   The name identifies with the number\
    \ of object and is its synonym.\n   The names of all active objects in one task\
    \ on the node must be\n   unique.  Thus, all active objects from the range of\
    \ number I - III\n   must have the unique names for all tasks on the node.  The\
    \ protocol\n   allows receiving the number of object by the name and the name\
    \ of\n   object by the number.\n"
- title: 6.6.5.1  OBJ_SEEK
  contents:
  - "6.6.5.1  OBJ_SEEK\n   The instruction \"To seek the object\" (OBJ_SEEK) is used\
    \ for seek of\n   number of the object by the name.  It has the following values\
    \ of\n   fields:\n      OPCODE = 212\n      OPR_LENGTH = 0\n      The extension\
    \ header:\n         _NAME - contains the name of object for search.\n   If the\
    \ object is found - the instruction OBJECT is sent in the\n   answer.  If the\
    \ object is not found - the instruction RSP with the\n   non-zero basic return\
    \ code is sent for the response.\n   The instruction OBJ_SEEK may be sent broadcast\
    \ through UDP.  In this\n   case, it concerns to zero-session.  The instruction\
    \ may contain the\n   field REQ_ID for identification of answers.  The positive\
    \ responses\n   in this case must be sent only.  The response may be transmitted\n\
    \   through UDP.\n"
- title: 6.6.5.2  OBJ_GET_NAME
  contents:
  - "6.6.5.2  OBJ_GET_NAME\n   The instruction \"To get a name of the object\" (OBJ_GET_NAME)\
    \ is used\n   for get of the name of object by number.  It has the following values\n\
    \   of fields:\n      OPCODE = 213\n      OPR_LENGTH = 1\n      Operands:\n  \
    \       4 octets: number of object for getting\n   If the object is present -\
    \ the instruction OBJECT with the extension\n   header _NAME is sent for the response.\
    \  If the object is not present\n   - the instruction RSP with the non-zero basic\
    \ return code is sent for\n   the response.\n"
- title: 7  Chains
  contents:
  - "7  Chains\n   The instructions, which will be sent on one session connection,\
    \ can\n   be unified in a chain.  The chain is a group of the instructions\n \
    \  relational with each other.  In one session, several chains\n   simultaneously\
    \ can be transferred.  The chains can be the following\n   types:\n   o  The sequence.\n\
    \   o  The transaction\n   o  The fragmented instruction.\n   If the instruction\
    \ is included into a chain, the flag CHN should be\n   equal 1.  The field CHAIN_NUMBER\
    \ of header contains number of a\n   chain, INSTR_NUMBER - serial instruction\
    \ number in a chain, since 0.\n   The numbering of chains is conducted by the\
    \ protocol.  In one session\n   simultaneously can be transferred up to 65533\
    \ chains.  Values of\n   numbers of chains %x0000 and %xFFFF reserved by the protocol.\
    \  One\n   chain can contain up to 65535 instructions.\n   The instruction with\
    \ a zero serial number INSTR_NUMBER should contain\n   the extension header describing\
    \ a chain.  Each type of a chain has\n   own initiating extension header.\n  \
    \ _END_CHAIN.  The extension header \"End of the chain\" is transferred\n   in\
    \ last instruction of chain, irrespective of type of the chain.  It\n   has the\
    \ following values of fields:\n      HEAD_CODE = 6\n      HEAD_LENGTH = 0\n  \
    \    HOB = 1\n   Number of a finished chain contains in a field CHAIN_NUMBER of\
    \ the\n   instruction header, to which the extension header is attached.\n   The\
    \ instructions, included in chains, can be transferred through UDP\n   only if\
    \ all chain is located in one segment.\n"
- title: 7.1 Sequence
  contents:
  - "7.1 Sequence\n   The sequence is a type of a chain, which unites the instructions\n\
    \   dependent from each other.  The following instruction of a sequence\n   can\
    \ be executed on VM, only if have been executed previous.  If the\n   current\
    \ instruction cannot be executed, all other instructions of the\n   given sequence\
    \ (already sent or expecting sending) simply cancel.\n   Due to this, it is possible\
    \ for one computing control thread not to\n   wait for the current instruction\
    \ positive end and to transfer\n   following at once.\n   _BEGIN_SQ.  The extension\
    \ header \"To begin a sequence\" is transferred\n   in the first instruction of\
    \ the sequence.  It has the following\n   values of fields:\n      HEAD_CODE =\
    \ 3\n      HEAD_LENGTH = 0\n      HOB = 1\n   Number of created chain is established\
    \ in field CHAIN_NUMBER of the\n   instruction header, to which the extension\
    \ header is attached.  The\n   field INSTR_NUMBER must have value 0.\n   The initiator\
    \ of creation of a sequence is VM.  It is not obligatory\n   that the sequence\
    \ should have known length beforehand.  It can be\n   completed in any moment.\
    \  If it is necessary to finish a sequence and\n   there are no instructions for\
    \ sending, the instruction NOP can be\n   generated.\n"
- title: 7.2 Transaction
  contents:
  - "7.2 Transaction\n   The transaction is a type of the chain uniting some possibly\
    \ not\n   connected with each other instructions.  All transaction instructions\n\
    \   must be executed all at once or must not be executed.  It is possible\n  \
    \ to cancel or to confirm transaction execute.  The transaction\n   cancellation\
    \ after execution is not stipulated.  If it is necessary,\n   such mechanism should\
    \ be realized at VM level, because there can be\n   instructions in transaction,\
    \ which are impossible to cancel, for\n   example a control transfer.\n   The\
    \ initiator of transaction creation is VM.  The transaction length\n   must be\
    \ known beforehand.  The length will define a way of\n   transaction transfer.\
    \  It is connected with buffering described in\n   section 7.4.\n"
- title: 7.2.1   _BEGIN_TR
  contents:
  - "7.2.1   _BEGIN_TR\n   The extension header \"To begin a transaction\" _BEGIN_TR\
    \ is\n   transferred in the first transaction instruction.  It has the\n   following\
    \ values of fields:\n      HEAD_CODE = 4\n      HEAD_LENGTH = 1\n      HOB = 1\n\
    \      DATA - Has the following format:\n      +---+---+---+---+---+---+---+---+\n\
    \      |TRE|TRR|TRS|      Reserve      |\n      +---+---+---+---+---+---+---+---+\n\
    \      |           TIME_TR             |\n      +---+---+---+---+---+---+---+---+\n\
    \      TRE\n         1 bit.  The flag of obligatory execution.  This flag relates\n\
    \         only to completely transferred, but have not yet executed\n        \
    \ transaction.  If TRE = 1, the transaction must be executed at\n         the\
    \ expiration of existence time, established by field TIME_TR,\n         or at\
    \ emergency session end.  If TRE = 0, at end of existence\n         time the transaction\
    \ must be cancelled and the negative\n         acknowledgement must be transferred,\
    \ and at emergency session\n         end - must be simply cancelled.\n      TRR\n\
    \         1 bit.  The flag of execution after sending.  If TRR = 1, the\n    \
    \     transaction must be executed after sending of all instructions,\n      \
    \   of which it is consists, at once.  Such transaction is executed\n        \
    \ after reception of the instruction with the extension header\n         _END_CHAIN.\
    \  If TRR = 0, it is necessary to transfer the\n         special instruction EXEC_TR\
    \ of transaction acknowledgement for\n         its execution.\n      TRT\n   \
    \      1 bit.  The flag of special processing.  It is entered for a\n        \
    \ possibility of the further expansion of the protocol.  If TRT =\n         1,\
    \ before transaction execution it is necessary to make some\n         additional\
    \ actions above the instructions, of which it is\n         consists, for example\
    \ to decipher.  These actions can be\n         definite in the additional extension\
    \ headers transmitted in the\n         transaction instructions.  The given document\
    \ will not define\n         cases of use of this flag.  The value TRT must be\
    \ zero.\n      Reserve\n         Must be set to 0.\n      TIME_TR\n         1\
    \ octet.  Time of transaction life in 2 - second intervals\n         (maximal\
    \ lifetime - 8 minutes).  The receiving side begins\n         readout of this\
    \ time after receiving all transaction\n         instructions.  The value %x00\
    \ sets transaction without\n         restriction of lifetime.\n   In the last\
    \ instruction of transaction the header, _END_CHAIN is\n   always sent.\n"
- title: 7.2.2   EXEC_TR
  contents:
  - "7.2.2   EXEC_TR\n   This instruction \"To execute the transaction\" (EXEC_TR)\
    \ is\n   transferred for execution transaction early transferred.  It has the\n\
    \   following values of fields:\n      OPCODE = 158\n      ASK = 1\n      PCK\
    \ = %b01/10/11\n      CHN = 1\n      EXT = 0/1\n      CHAIN_NUMBER - Contains\
    \ the number of chain, which is necessary to\n                     execute.\n\
    \      INSTR_NUMBER = 0\n      OPR_LENGTH = 0\n"
- title: 7.2.3   CANCEL_TR
  contents:
  - "7.2.3   CANCEL_TR\n   The instruction \"To cancel transaction\" (CANCEL_TR) is\
    \ transmitted\n   for a cancellation of execution transaction transmitted before.\
    \  It\n   has the following values of fields:\n      OPCODE = 159\n      ASK =\
    \ 0\n      PCK = %b01/10/11\n      CHN = 1\n      EXT = 0/1\n      CHAIN_NUMBER\
    \ - Contains the number of chain, which is necessary to\n                    \
    \ cancel.\n      INSTR_NUMBER = 0\n      OPR_LENGTH = 0\n   The instructions,\
    \ of which the cancelled transaction consists, delete\n   without a possibility\
    \ of restoration.\n"
- title: 7.3 Fragmented instruction
  contents:
  - "7.3 Fragmented instruction\n   UMSP is designed for work with the transport protocol\
    \ with the\n   limited size of transmitted data segment.  The fragmentation of\
    \ the\n   instructions is made in the following two cases:\n   (1)  If the instruction\
    \ is longer than the maximal segment size of\n        transport layer or,\n  \
    \ (2)  If the segment is formed of the several instructions and last\n       \
    \ instruction is not located in it completely.\n   The decision on fragmentation\
    \ is taken to UMSP level.\n   The fragmented instruction is encapsulated in several\
    \ NOP\n   instructions.  Then all instructions NOP are transmitted, as one\n \
    \  chain of special type.  The following algorithm is used during\n   encapsulation:\n\
    \   (1)  The fields SESSION_ID and REQ_ID from the fragmented instruction\n  \
    \      are written in the first NOP instruction.  If field REQ_ID is\n       \
    \ not present in the initial instruction, it must not be in the\n        NOP instruction.\
    \  The field SESSION_ID always is present in the\n        fragmented instructions.\n\
    \   (2)  Then these fields delete from the initial instruction.  The\n       \
    \ value of all other fields of the header does not change.\n   (3)  After that,\
    \ the initial instruction is divided into fragments of\n        necessary length.\
    \  Each fragment is located in a field of\n        operands of the NOP instruction.\
    \  Other data should not be\n        entered in operand field.\n   _BEGIN_FRG.\
    \  The extension header \"The first fragment\" is transmitted\n   to the NOP instruction,\
    \ which contains the first fragment.  It has\n   the following values of fields:\n\
    \      HEAD_CODE = 5\n      HEAD_LENGTH = 0/2 ; Depends on subordination of the\
    \ chain.\n      HOB = 1\n      Data:\n         2 octets: Number of the parental\
    \ chain.  Fragmented instruction\n                   may be a part of the sequence\
    \ or transaction.\n         2 octets: The instruction number in the parental chain.\n\
    \   The header _END_CHAIN is transmitted in NOP instruction, which\n   contains\
    \ last fragment.\n"
- title: 7.4 Buffering
  contents:
  - "7.4 Buffering\n   In the given item, the buffering used by the protocol on receiving\
    \ of\n   data is described.  The question of buffering on sending lies beyond\n\
    \   the scope of the protocol.\n   If the instruction is not include in a chain,\
    \ it is transmitted to VM\n   for execution at once and does not require buffering\
    \ at the protocol\n   level.  The interface UMSP - VM must provide asynchronous\n\
    \   instructions sending.  It is recommended, that the productivity of\n   UMSP\
    \ systems, should allow to process the instructions accepted from\n   network,\
    \ with that speed, with what they were received.  All\n   instructions are designed\
    \ so that carries out the known and limited\n   computing loading.  Exception\
    \ is the instruction of control\n   transfers, which must be processed in two\
    \ stages.  The instruction\n   correctness is checked firstly and its scheduling\
    \ is made.  Then the\n   instruction is executed.  At that must be guaranteed\
    \ that the\n   protocol can receive such part of processor time, which would allow\n\
    \   it to work in stationary mode.  Therefore, the questions of node\n   overload\
    \ are deduced on VM layer and user applications layer, where\n   they can be sensible\
    \ controlled.\n   For chains, the protocol provides two schemes of buffering during\
    \ the\n   receiving:\n   (1)  At the session connection establishment, the sides\
    \ agree about\n        the allocated buffer (\"window\") size.  The window always\
    \ is more\n        than the maximal segment of a transport layer.  The transmitting\n\
    \        side can expect for this buffer without the preliminary\n        coordination\
    \ with the receiving side.  The window size is\n        established single for\
    \ each session connection, and cannot be\n        changed in subsequent.  UMSP\
    \ is designed for using of transport\n        layer, which informs about the data\
    \ delivery.  Therefore\n        transmitting side traces the current free size\
    \ of the window on\n        the reception side for each connection without assistance.\
    \  If\n        the reception side finds out, that the data have been received,\n\
    \        which cannot be placed in the window, the connection is broken\n    \
    \    off.\n   (2)  For transactions and fragmented instructions, which size exceeds\n\
    \        the window, it is necessary to request the reception node the\n     \
    \   sanctions to sending.  The theoretical limiting size of chain\n        transmitting\
    \ so is 4 Gbytes.\n   REQ_BUF.  The instruction \"To request the buffer\" requests\
    \ at VM the\n   buffer allocation for sending of transaction or large fragmented\n\
    \   instruction (\"Window\").  It has the following values of fields:\n      OPCODE\
    \ = 24\n      ASK = 1\n      PCK = b01/11\n      CHN = 0\n      EXT = 0/1\n  \
    \    OPR_LENGTH = 1\n      Operands:\n         4 octets: The buffer required size\
    \ in octets.  The value is\n                   equal to the total size of all\
    \ instructions of the\n                   chain, including the size of the subordinated\
    \ chains.\n   The instruction is formed under the initiative of the protocol and\
    \ it\n   uses the instruction RSP_P as acknowledgement.  However, on the\n   reception\
    \ side the buffer is allocated at VM level, as VM has the\n   most complete information\
    \ about the task.  The interface between UMSP\n   and VM must give possibility\
    \ of asynchronous request of such buffer.\n   The instruction REQ_BUF can be used\
    \ irrespective of the possibility\n   to place the chain in the buffer, allocated\
    \ for session (window).  It\n   is necessary to take into account, that the negative\
    \ acknowledgement\n   can be transmitted on this instruction, but using of a \"\
    window\"\n   guarantees sending.\n   The subordinated chain on reception uses\
    \ the buffer of the parental\n   chain.\n   The sequence sending will not require\
    \ about the buffer allocation in\n   difference of transaction or fragmented instruction.\
    \  If the single\n   connection TCP is used for sending, the sequence buffering\
    \ is not\n   necessary.  If the multiple connections TCP with multiplexing are\n\
    \   used, the sequence requires buffering for the disorder instructions.\n   In\
    \ this case, it is necessary to use the buffer, allocated for\n   session.\n \
    \  Transactions, at which flag TRR = 0, always must request the sanction\n   for\
    \ sending by instruction REQ_BUF, even if they can be placed in one\n   segment\
    \ of transport layer.\n   The buffering of the fragmented instructions and transactions,\
    \ at\n   which flag TRR = 1, depends on their size:\n   o  If the transaction\
    \ is located in one segment of transport layer,\n      it is transmitted without\
    \ buffering.\n   o  If length of a chain is no more then \"window\", it can be\n\
    \      transmitted without request of the buffer of window allocation.\n     \
    \ Thus, the place in the buffer must be reserved before the sending\n      begins.\
    \  The sending cannot be begun, if it is not enough places\n      in the buffer.\
    \  In this case, it is possible to wait the window\n      deallocation or to use\
    \ the request instruction of the buffer\n      allocation at VM REQ_BUF.\n   o\
    \  If length exceeds the session window size it is necessary to use\n      the\
    \ instruction REQ_BUF.\n"
- title: 7.5 Acknowledgement of chains
  contents:
  - "7.5 Acknowledgement of chains\n   The field REQ_ID in chains of any type is established\
    \ only in the\n   first instruction and concerns to all chain.  The all following\n\
    \   instructions, including last, do not contain REQ_ID.\n   The transport protocol\
    \ used for chains sending, must inform about the\n   end of data transfer, because\
    \ it is necessary for the transmitting\n   side to know the free size of the allocated\
    \ session window on the\n   reception side.\n   If the chain uses the allocated\
    \ VM buffer (the sanction to sending\n   REQ_BUF was requested), or the chain\
    \ completely locates in transport\n   layer segment, the protocol on the transmitting\
    \ side does not trace\n   acknowledgement.\n   If the sequence is transmitted,\
    \ the transmitting side receives the\n   information about free place of the buffer\
    \ on the reception side by\n   acknowledgement of transport layer delivery.  It\
    \ can be made, as the\n   regulated sequence instructions are transmitted VM at\
    \ once after\n   receiving and release the buffer.\n   The fragmented instructions\
    \ and transactions are not transmitted VM\n   until its will be completely accepted.\
    \  If session window is use, the\n   occupation of places in the buffer can be\
    \ calculated upon\n   acknowledgement of transport layer sending.  To trace free\
    \ of places\n   it is necessary to check execution acknowledgement by VM.  The\n\
    \   following algorithm of sending is used for this purpose:\n   o  The value\
    \ of field REQ_ID, which has given VM for chain sending,\n      is kept and it\
    \ is enters the value established by the protocol\n      instead of it\n   o \
    \ The new value REQ_ID is transmitted in the first instruction of\n      chain\n\
    \   o  The chain completely collected in the session window on the\n      reception\
    \ side.  After linking, it is transmitted for execution on\n      VM.  At that,\
    \ the chain can continue to occupy a place in the\n      buffer.\n   o  After\
    \ execution, VM informs about it to the reception side\n      protocol.\n   o\
    \  The protocol clears place in the allocated buffer.\n   o  Then the protocol\
    \ forms and transmits on chain acknowledgement\n      RSP_P, instead of RSP, as\
    \ in other cases.\n   o  The transmitting side protocol corrects size of free\
    \ place in the\n      reception side buffer after reception of acknowledgement\
    \ RSP_P.\n   o  Then the old value REQ_ID is restored and the acknowledgement\
    \ is\n      transmitted to VM.\n"
- title: 7.6 Base-displacement Addressing
  contents:
  - "7.6 Base-displacement Addressing\n   The memory base address for the relative\
    \ addressing can be\n   established for the instructions from one chain.  Thus,\
    \ it is\n   possible to use the abbreviated address memory fields in the\n   instructions\
    \ of chain.  The abbreviated addresses are used, as\n   displacement from base.\n\
    \   _SET_MBASE.  The extension header \"To set memory base\" establishes\n   the\
    \ value of base address for chain.  It has the following values of\n   fields:\n\
    \      HEAD_CODE = 7\n      HEAD_LENGTH = 2/4/8   ; Depends on address length.\n\
    \      HOB = 1\n      DATA contains:\n         4/8/16 octets: The base address.\n\
    \   The length of address is 3 octets, enters the name in last octets of\n   4-octets\
    \ data field.  The initial octet is set to 0.  The base-\n   displacement addressing\
    \ is not used for nodes with address length 2\n   octets.\n   The value of memory\
    \ base for a sequence may change.  The base must be\n   established once in any\
    \ instruction for all transaction instructions.\n   The repeated establishment\
    \ of transaction base is a mistake, which\n   results refusal of transaction execution.\n"
- title: 8  Extension Headers
  contents:
  - "8  Extension Headers\n   This section contains the description of the extension\
    \ headers, which\n   are not connected with the definite instruction.  The description\
    \ of\n   the specialized extension headers describes in the appropriate\n   sections\
    \ of this document.\n"
- title: 8.1 _ALIGNMENT
  contents:
  - "8.1 _ALIGNMENT\n   The extension header \"Alignment\" (_ALIGNMENT) allows to\
    \ make any\n   extension header or field of operands multiple of 4 - 16 octets\
    \ with\n   the step of two octets.  The protocol does not give any rules of use\n\
    \   given extension header.  It can be used arbitrarily.  The header has\n   the\
    \ following values of fields:\n      HEAD_CODE = 8\n      HEAD_LENGTH = 1-7 ;\
    \ Depends on length of the data field.\n      HOB = 0\n      DATA contains:\n\
    \         2 - 14 octets: All octets of the field have the zero-value.\n   The\
    \ format of the protocol instructions provides the alignment of two\n   octets\
    \ field without any additional means.\n"
- title: 8.2 _MSG
  contents:
  - "8.2 _MSG\n   The extension header \"The any message\" (_MSG) allows sending the\n\
    \   textual message in symbols ASCII.  The order of this header\n   processing\
    \ at receiving can be anyone.  The message can be written in\n   a log-file, be\
    \ shown on the console or be ignored.  The header has\n   the following values\
    \ of fields:\n      HEAD_CODE = 9\n      HEAD_LENGTH = 1 - 127 ; Depends on data\
    \ length of field.\n      HOB = 0\n      DATA contains:\n         2 - 254 octets:\
    \ The any text of the message.\n   The instruction may contain several headings\
    \ _MSG.\n"
- title: 8.3 _NAME
  contents:
  - "8.3 _NAME\n   The extension header \"The Name\" (_NAME) allows specifying the\
    \ job\n   name, name of object or name of object procedure.  The header has the\n\
    \   following values of fields:\n      HEAD_CODE = 10\n      HEAD_LENGTH = 1 -\
    \ 127 ; Depends on length of a field of data.\n      HOB = 0\n      DATA contains:\n\
    \         2 - 254 octets: The text of the name in symbols ASCII.\n"
- title: 8.4 _DATA
  contents:
  - "8.4 _DATA\n   The extension header \"The Data\" (_DATA) is used for data transfer\
    \ in\n   the instructions of exchange between VM, if the data cannot be placed\n\
    \   in operands.  It allows transferring up to 4 Gbytes of data in one\n   instruction.\
    \  The header has the following values of fields:\n      HEAD_CODE = 11\n    \
    \  HEAD_LENGTH = 1 - 2 147 483 647 ; Depends on length of the data\n         \
    \                               field.\n      HOB = 1\n      DATA contains:\n\
    \         2 - 4 294 967 294  octets : Binary data in an any format.\n"
- title: 8.5 _LIFE_TIME
  contents:
  - "8.5 _LIFE_TIME\n   The extension header \"The lifetime\" (_LIFE_TIME) contains\
    \ value of\n   time.  It has the following values of fields:\n      HEAD_CODE\
    \ = 12\n      HEAD_LENGTH = 1/2; Depending on length of data.\n      HOB = 1\n\
    \      DATA contains:\n         2/4 octets: The time in 1,024 milliseconds intervals.\n\
    \   The header _LIFE_TIME allows to set limiting time of sending of the\n   instruction\
    \ to VM of the addressee.\n   The instruction lifetime is calculated as follows:\n\
    \   o  On the transmitting side the time of waiting in a queue to the\n      transport\
    \ layer is taken into account.  The value of the lifetime\n      decreases on\
    \ the waiting time value now of the transport layer\n      package formation.\n\
    \   o  On the reception side the lifetime is taken into account only for\n   \
    \   the fragmented instructions.  The value of the lifetime decreases\n      on\
    \ time of the instruction assembly value.  This header is ignored\n      at receiving\
    \ for no-fragmented instructions.  Its value must be\n      sent to VM.\n   o\
    \  The time of sending at the transport layer is not taken into\n      account.\
    \  For the fragmented instructions, only the time of\n      sending of the first\
    \ fragment is not taken into account.\n   The end of lifetime at the instruction\
    \ relating to sequence finishes\n   the sequence sending.  The header _LIFE_TIME\
    \ must not be used at\n   transactions sending.\n   If the instruction is fragmented,\
    \ the header _LIFE_TIME is sent only\n   in the instruction NOP, containing the\
    \ first fragment.  This header\n   deletes from the initial fragmented instruction.\
    \  If the time is\n   over, when the fragmented instruction part has not been\
    \ transmitted\n   yet, the stayed part of the instruction is cleared.\n   The\
    \ instruction lifetime is established by the sender VM and must be\n   sent together\
    \ with data to the addressee VM.  If the time of life\n   expires, the instruction\
    \ is rejected and the negative response (if\n   ASK = 1) is sent to it.  If ASK\
    \ = 0, the response is not sent.\n   The header _LIFE_TIME may be used in the\
    \ multimedia systems and in\n   the real time systems.  The protocol may raise\
    \ the priority of\n   sending for data with coming to the end lifetime.\n"
- title: 9  Search of resources
  contents:
  - "9  Search of resources\n   Virtual Machines are the identified resources of the\
    \ protocol.  The\n   VM standardization is not function of UMSP.  The protocol\
    \ gives\n   transparent environment for transportation of the code and data of\n\
    \   any type.\n   For VM, connected to the protocol, the following values are\n\
    \   established:\n   o  The VM type.  The range of values 1 - 65534.\n   o  The\
    \ VM version.  The range of values 1 - 65534.\n   The protocol requires obligatory\
    \ compatibility from bottom-up for VM\n   of one type and different numbers of\
    \ the versions (VM with larger\n   number of version must be able to execute the\
    \ VM code with any\n   smaller number of version).\n   Numbers of VM types are\
    \ broken on the following ranges:\n     1 - 1023       Assigned for standard VM\n\
    \     1024 - 49151   Assigned for registered VM of the users\n     49152 - 65534\
    \  Free (defined for dynamic and/or private VM)\n   Numbers of types and versions\
    \ %x0000 and %xFFFF are reserved by the\n   protocol.\n   Several VM of different\
    \ types may be united in a group.  All VM,\n   included in a group, must work\
    \ in the common space of local memory\n   and have the common subsystem of the\
    \ jobs control.  It means, that if\n   the same 128-bit address is met in anyone\
    \ VM code for one task, it\n   must specify one physical cell of memory.  The\
    \ performance of the\n   specified conditions allows executing multivendor user\
    \ code\n   (containing procedures for different VM) on one node.  All VM,\n  \
    \ included in a group, must have the different types.  The group can\n   include\
    \ no more than 65534 VM.  One number of group on different\n   nodes may identify\
    \ groups with different structure VM.\n   To each group VM on the node the code\
    \ of group of 2 octets length is\n   assigned.  So long as the node has even one\
    \ session connection, the\n   codes of groups must not change.  It is recommended\
    \ to change the\n   code of group only at reconfiguration of the node.  The group\
    \ VM is\n   identified, as well as one VM.  Thus, the type VM is set to 0, and\n\
    \   the number of group is assigned to VM version.\n   The support of association\
    \ VM in groups is optional requirement of\n   the protocol.  The multivendor user\
    \ code can be executed, even if the\n   association in groups is not provided.\
    \  For this purpose, the\n   procedures containing a different type of a code\
    \ must be executed on\n   different nodes.\n   UMSP gives the instructions of\
    \ search of the VM, which allow\n   defining, what VM and the groups VM are connected\
    \ at the given moment\n   to the protocol on the definite node.\n   The instructions\
    \ of search of the VM can be sent upon TCP or UDP.\n   The broadcasting dispatch\
    \ can be used.  The node can independently\n   notify about VM, available on it,\
    \ for example at start, or to respond\n   on others VM requests.  The answerback\
    \ instructions must be sent\n   under the same protocol, on which the request\
    \ was received.\n   VM from ranges of numbers 49152 - 65534 or any group VM may\
    \ be\n   identified on names.  VM with numbers 1 - 49151 must not have names\n\
    \   at a layer of the instructions UMSP.\n"
- title: 9.1 VM_REQ
  contents:
  - "9.1 VM_REQ\n   The instruction \"To request the VM\" (VM_REQ) allows finding\
    \ out VM,\n   connected on the remote node.  The instruction has the following\n\
    \   values of fields:\n      OPCODE = 25\n      PCK = %b00\n      CHN = 0\n  \
    \    ASK = 0/1\n      EXT = 0/1\n      OPR_LENGTH = 0 - 65534 ; Depending on quantity\
    \ VM in operands.\n      Operands:\n         2 octets: The type required VM. \
    \ The value 0 is not allowed.\n         2 octets: The version required VM.  The\
    \ value 0 is not allowed.\n                   The value %xFFFF requests the most\
    \ senior version.\n         .\n         .\n         .\n         2 octets: The\
    \ type required VM.\n         2 octets: The version required VM.\n      The optional\
    \ extension header:\n         _NAME - This header contains the name of required\
    \ VM or VM\n                 group.\n   The instruction without operands is used\
    \ for request of all types VM,\n   connected on the node.  The instruction with\
    \ one VM in operands\n   requests the information on one VM.  If it is contained\
    \ several VM in\n   operands, the group VM containing all specified VM is requested.\
    \  The\n   type and version in list VM must be indexed on increase.\n   To request\
    \ VM, used at work without session connection, the VM type\n   and VM version\
    \ must have the value %xFFFF.\n   The header _NAME is not connected with value\
    \ of operands.  For it,\n   the separate answer must be transmitted.\n"
- title: 9.2 VM_NOTIF
  contents:
  - "9.2 VM_NOTIF\n   The instruction \"To notify about VM\" (VM_NOTIF) is used for\
    \ the\n   notification of one VM or one VM group attached on the node.  The\n\
    \   instruction has the following values of fields:\n      OPCODE = 26\n     \
    \ PCK = %b00\n      CHN = 0\n      ASK = 0/1\n      EXT = 0/1\n      OPR_LENGTH\
    \ = 1 - 65534  ; Depending on quantity VM in operands.\n      Operands:\n    \
    \     2 octets: The used transport protocol.  The following values of\n      \
    \             this field are definite:\n            x0100 - Single TCP connection\
    \ through the port 2110.\n            x0101 - Multiple TCP connection through\
    \ the port 2110.\n            x0102 - Single TCP connection through ports 2110\
    \ and UDP\n                    through ports on receiving 2110.\n            x0103\
    \ - Multiple TCP connection through ports 2110  and UDP\n                    through\
    \ port on receiving 2110.\n            The port 2110 must be opened on the one\
    \ side or both side at\n            each TCP connection.\n         2 octets: Reserved.\
    \  This field must not be analyzed by the\n                   protocol during\
    \ the receiving in the current\n                   realization of the protocol.\
    \  It must be set to 0 at\n                   sending.\n         2 octets: The\
    \ type VM.\n         2 octets: The version VM.\n         .\n         .\n     \
    \    .\n         2 octets: The type VM.\n         2 octets: The version VM.\n\
    \      The optional extension header:\n         _NAME - This header contains the\
    \ name by separate VM or group VM\n                 from operands of the instruction.\n\
    \   It is necessary to generate several instructions, if it is required\n   to\
    \ inform about several VM or groups.  It is necessary to form the\n   separate\
    \ instructions for each protocol, if the node provides several\n   transport protocols.\n\
    \   If the instruction is used for the response to VM_REQ request, it can\n  \
    \ contain ASK = 1 and REQ_ID, established in value from the instruction\n   of\
    \ request.  If the VM group was requested, the instruction must\n   contain several\
    \ VM.  First VM must have the type set to 0 and the\n   version must contain the\
    \ number of group.  Others VM must define\n   structure of group.  The type and\
    \ version in VM list must be indexed\n   on increase.\n   The protocols, contained\
    \ in the instruction VM_NOTIF, may differ from\n   the protocol, through which\
    \ this instruction is transferred.\n"
- title: 10 Security Considerations
  contents:
  - "10 Security Considerations\n   The present document contains the description\
    \ of the functions,\n   minimally necessary for the realization of the declared\
    \ task -\n   immediate access to memory of the remote node.  To reduce initial\n\
    \   complexity of the protocol, the decision of safety questions is not\n   included\
    \ in the document.  All reasons of the given unit are the\n   recommendations\
    \ to the further expansion of the protocol.\n   For the description three nodes\
    \ are used - node A and node B are\n   exchanges the data.  The node G is JCP.\n\
    \   Protection against sniffing, spoofing and hijacking:\n      (1) The means\
    \ specifies in TCP/IP can be used.\n      (2) There is a possibility to create\
    \ chains with the special\n          processing.  To create such chain, it is\
    \ necessary to transfer\n          the extension header, determining the special\
    \ processing, in\n          the first instruction of the chain.  The instructions\
    \ of chain\n          can be encapsulated in the NOP instructions.  The algorithms\n\
    \          of the control of instructions sequence integrity or the\n        \
    \  encryption can be realized in such a way.\n   Protection against the man-in-the-middle:\n\
    \      The protection is based on the fact, that the routes between nodes\n  \
    \    A - B, A - G and G - B is not crossed.  Such scheme allows\n      organizing\
    \ the additional managing dataflow, allowing revealing\n      such type of attack.\
    \  If the specified routes pass through one\n      gateway, this protection is\
    \ less effective.\n   Authentication:\n      The protocol working is based on\
    \ a principle of the centralized\n      control.  It allows using several schemes\
    \ of authentication.  The\n      parameters of authentication are sent in the\
    \ extension headers.\n      The establishment of session connection can contain\
    \ up to eight\n      handshakes.  It also raises flexibility at a choice of\n\
    \      authentication algorithm.  The realization of authentication is\n     \
    \ possible between three pairs nodes A - B, A - G and G - B.  All\n      pairs\
    \ can be used in any combination.  The node G can be specially\n      allocated\
    \ for realization of authentication.\n   Protection against denial-of-service:\n\
    \      The instructions of the protocol have definite computing loading.\n   \
    \   It allows projecting the node so, that it can process the\n      instructions\
    \ with such speed, with what they are accepted from the\n      network.  A possible\
    \ reason of an overload is the instructions\n      JUMP and CALL.  VM must solve\
    \ this problem.  It has the complete\n      information about the user task and\
    \ can make a decision on the\n      amount of allocated resources.  The decision\
    \ of a problem is the\n      failure in service for low-priority traffic.\n  \
    \ Protection at the applications architecture level:\n      The protocol allows\
    \ creating the applications of any architecture.\n      It is possible due to\
    \ an asymmetric structure of connection.  It\n      is possible to allocate three\
    \ basic groups:\n      (1) The client who is carrying out terminal functions and\n\
    \          client/server technologies.  The security of such systems is\n    \
    \      completely defined by the server.  Such architecture is\n          represented\
    \ most protected.\n      (2) The client, loading an active code from the server.\
    \  It is the\n          least protected architecture, from the client point of\
    \ view.\n          On the server side, there are no special requirements upon\n\
    \          protection.\n      (3) The client, who is executing his code on the\
    \ server.  This\n          architecture is safe for the client.  It is necessary\
    \ to\n          strengthen the protection on the server.  The functionalities\n\
    \          of such architecture do not differ from architecture of\n         \
    \ loading by the client of an active code.  If ones take into\n          account,\
    \ that the server is the specially allocated computer,\n          the given architecture\
    \ is optimum.\n          All given technologies may be used simultaneously in\
    \ any\n          combination.\n"
- title: 11 Used Abbreviations
  contents:
  - "11 Used Abbreviations\n   API    Application Programming Interface.\n   CTID\
    \   JCP assigned the Control Task IDentifier to each task of the\n          job.\
    \  Its length is equal to length of the local address\n          memory on the\
    \ node JCP.\n   GJID   Globally Job IDentifier is assigned for the each job. GJID\
    \ is\n          defined on the JCP node.  It has the same format, as the 128 -\n\
    \          bit address of node JCP memory has.  The address of local\n       \
    \   memory is replaced on CTID of the first (initial) task of the\n          job\
    \ in it.\n   GTID   Globally Task IDentifier is assigned to each task.  GTID has\n\
    \          the same format, as the 128 - bit address of node memory has.\n   \
    \       The address of local memory is replaced on LTID in it.\n   JCP    Job\
    \ Control Point.  This node will control the job.\n   LTID   Locally Task IDentifier\
    \ is assigned to each active task on the\n          node.  LTID length is equal\
    \ to the local memory address length\n          defined for the node.\n   VM \
    \    Virtual Machine.\n"
- title: 12 References
  contents:
  - "12 References\n   [1]  Bradner, S., \"The Internet Standards Process -- Revision\
    \ 3\", BCP\n        9, RFC 2026, October 1996.\n   [2]  Bradner, S., \"Key words\
    \ for use in RFCs to Indicate Requirement\n        Levels\", RFC 2119, March 1997.\n\
    \   [3]  Crocker, D., and  P. Overell.  \"Augmented BNF for Syntax\n        Specifications:\
    \ ABNF\", RFC 2234, November 1997.\n   [4]  Postel, J., \"Transmission Control\
    \ Protocol - DARPA Internet\n        Program Protocol Specification\", STD 7,\
    \ RFC 793, September 1981.\n   [5]  Postel, J., \"User Datagram Protocol\", STD\
    \ 6, RFC 768, August\n        1980.\n   [6]  Srinivasan, R., \"RPC: Remote Procedure\
    \ Call Protocol\n        Specification Version 2\", RFC 1831, August 1995.\n"
- title: 13 Author's Address
  contents:
  - "13 Author's Address\n   Alexander Y. Bogdanov\n   NKO \"ORS\"\n   22, Smolnaya\
    \ St.\n   Moscow, Russia 125445\n   RU\n   Phone: +7 901 732 9760\n   EMail: a_bogdanov@iname.ru\n"
- title: 14 Full Copyright Statement
  contents:
  - "14 Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
