- title: __initial_text__
  contents:
  - '             Host Mobility with the Host Identity Protocol

    '
- title: Abstract
  contents:
  - "Abstract\n   This document defines a mobility extension to the Host Identity\n\
    \   Protocol (HIP).  Specifically, this document defines a \"LOCATOR_SET\"\n \
    \  parameter for HIP messages that allows for a HIP host to notify peers\n   about\
    \ alternate addresses at which it may be reached.  This document\n   also defines\
    \ how the parameter can be used to preserve communications\n   across a change\
    \ to the IP address used by one or both peer hosts.\n   The same LOCATOR_SET parameter\
    \ can also be used to support end-host\n   multihoming (as specified in RFC 8047).\
    \  This document obsoletes RFC\n   5206.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8046.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and Scope  . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Terminology and Conventions . . . . . . . . . . . . .\
    \ . . . .   4\n   3.  Protocol Model  . . . . . . . . . . . . . . . . . . . .\
    \ . . .   7\n     3.1.  Operating Environment . . . . . . . . . . . . . . . .\
    \ . .   7\n       3.1.1.  Locator . . . . . . . . . . . . . . . . . . . . . .\
    \ .   9\n       3.1.2.  Mobility Overview . . . . . . . . . . . . . . . . . .\
    \   9\n     3.2.  Protocol Overview . . . . . . . . . . . . . . . . . . . .  10\n\
    \       3.2.1.  Mobility with a Single SA Pair (No Rekeying)  . . . .  10\n  \
    \     3.2.2.  Mobility with a Single SA Pair (Mobile-Initiated\n             \
    \  Rekey)  . . . . . . . . . . . . . . . . . . . . . . .  12\n       3.2.3.  Mobility\
    \ Messaging through the Rendezvous Server  . .  13\n       3.2.4.  Network Renumbering\
    \ . . . . . . . . . . . . . . . . .  14\n     3.3.  Other Considerations  . .\
    \ . . . . . . . . . . . . . . . .  14\n       3.3.1.  Address Verification  .\
    \ . . . . . . . . . . . . . . .  14\n       3.3.2.  Credit-Based Authorization\
    \  . . . . . . . . . . . . .  15\n       3.3.3.  Preferred Locator . . . . . .\
    \ . . . . . . . . . . . .  16\n   4.  LOCATOR_SET Parameter Format  . . . . .\
    \ . . . . . . . . . . .  16\n     4.1.  Traffic Type and Preferred Locator  .\
    \ . . . . . . . . . .  18\n     4.2.  Locator Type and Locator  . . . . . . .\
    \ . . . . . . . . .  19\n     4.3.  UPDATE Packet with Included LOCATOR_SET .\
    \ . . . . . . . .  19\n   5.  Processing Rules  . . . . . . . . . . . . . . .\
    \ . . . . . . .  19\n     5.1.  Locator Data Structure and Status . . . . . .\
    \ . . . . . .  19\n     5.2.  Sending the LOCATOR_SET . . . . . . . . . . . .\
    \ . . . . .  21\n     5.3.  Handling Received LOCATOR_SETs  . . . . . . . . .\
    \ . . . .  22\n     5.4.  Verifying Address Reachability  . . . . . . . . . .\
    \ . . .  24\n     5.5.  Changing the Preferred Locator  . . . . . . . . . . .\
    \ . .  26\n     5.6.  Credit-Based Authorization  . . . . . . . . . . . . . .\
    \ .  26\n       5.6.1.  Handling Payload Packets  . . . . . . . . . . . . . .\
    \  27\n       5.6.2.  Credit Aging  . . . . . . . . . . . . . . . . . . . .  29\n\
    \   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  29\n  \
    \   6.1.  Impersonation Attacks . . . . . . . . . . . . . . . . . .  30\n    \
    \ 6.2.  Denial-of-Service Attacks . . . . . . . . . . . . . . . .  31\n      \
    \ 6.2.1.  Flooding Attacks  . . . . . . . . . . . . . . . . . .  31\n       6.2.2.\
    \  Memory/Computational-Exhaustion DoS Attacks . . . . .  32\n     6.3.  Mixed\
    \ Deployment Environment  . . . . . . . . . . . . . .  32\n     6.4.  Privacy\
    \ Concerns  . . . . . . . . . . . . . . . . . . . .  33\n   7.  IANA Considerations\
    \ . . . . . . . . . . . . . . . . . . . . .  33\n   8.  Differences from RFC 5206\
    \ . . . . . . . . . . . . . . . . . .  33\n   9.  References  . . . . . . . .\
    \ . . . . . . . . . . . . . . . . .  35\n     9.1.  Normative References  . .\
    \ . . . . . . . . . . . . . . . .  35\n     9.2.  Informative References  . .\
    \ . . . . . . . . . . . . . . .  35\n   Acknowledgments . . . . . . . . . . .\
    \ . . . . . . . . . . . . . .  36\n   Authors' Addresses  . . . . . . . . . .\
    \ . . . . . . . . . . . . .  37\n"
- title: 1.  Introduction and Scope
  contents:
  - "1.  Introduction and Scope\n   The Host Identity Protocol (HIP) [RFC7401] supports\
    \ an architecture\n   that decouples the transport layer (TCP, UDP, etc.) from\
    \ the\n   internetworking layer (IPv4 and IPv6) by using public/private key\n\
    \   pairs, instead of IP addresses, as host identities.  When a host uses\n  \
    \ HIP, the overlying protocol sublayers (e.g., transport-layer sockets\n   and\
    \ Encapsulating Security Payload (ESP) Security Associations (SAs))\n   are instead\
    \ bound to representations of these host identities, and\n   the IP addresses\
    \ are only used for packet forwarding.  However, each\n   host needs to also know\
    \ at least one IP address at which its peers\n   are reachable.  Initially, these\
    \ IP addresses are the ones used\n   during the HIP base exchange.\n   One consequence\
    \ of such a decoupling is that new solutions to\n   network-layer mobility and\
    \ host multihoming are possible.  There are\n   potentially many variations of\
    \ mobility and multihoming possible.\n   The scope of this document encompasses\
    \ messaging and elements of\n   procedure for basic network-level host mobility,\
    \ leaving more\n   complicated mobility scenarios, multihoming, and other variations\
    \ for\n   further study.  More specifically, the following are in scope:\n   \
    \   This document defines a LOCATOR_SET parameter for use in HIP\n      messages.\
    \  The LOCATOR_SET parameter allows a HIP host to notify a\n      peer about alternate\
    \ locators at which it is reachable.  The\n      locators may be merely IP addresses,\
    \ or they may have additional\n      multiplexing and demultiplexing context to\
    \ aid with the packet\n      handling in the lower layers.  For instance, an IP\
    \ address may\n      need to be paired with an ESP Security Parameter Index (SPI)\
    \ so\n      that packets are sent on the correct SA for a given address.\n   \
    \   This document also specifies the messaging and elements of\n      procedure\
    \ for end-host mobility of a HIP host.  In particular,\n      message flows to\
    \ enable successful host mobility, including\n      address verification methods,\
    \ are defined herein.\n      The HIP rendezvous server (RVS) [RFC8004] can be\
    \ used to manage\n      simultaneous mobility of both hosts, initial reachability\
    \ of a\n      mobile host, location privacy, and some modes of NAT traversal.\n\
    \      Use of the HIP RVS to manage the simultaneous mobility of both\n      hosts\
    \ is specified herein.\n   The following topics are out of scope:\n      While\
    \ the same LOCATOR_SET parameter supports host multihoming\n      (simultaneous\
    \ use of a number of addresses), procedures for host\n      multihoming are out\
    \ of scope and are specified in [RFC8047].\n      While HIP can potentially be\
    \ used with transports other than the\n      ESP transport format [RFC7402], this\
    \ document largely assumes the\n      use of ESP and leaves other transport formats\
    \ for further study.\n      We do not consider localized mobility management extensions\
    \ (i.e.,\n      mobility management techniques that do not involve directly\n\
    \      signaling the correspondent node); this document is concerned with\n  \
    \    end-to-end mobility.\n      Finally, making underlying IP mobility transparent\
    \ to the\n      transport layer has implications on the proper response of\n \
    \     transport congestion control, path MTU selection, and Quality of\n     \
    \ Service (QoS).  Transport-layer mobility triggers, and the proper\n      transport\
    \ response to a HIP mobility or multihoming address\n      change, are outside\
    \ the scope of this document.\n   The main sections of this document are organized\
    \ as follows.\n   Section 3 provides a summary overview of operations, scenarios,\
    \ and\n   other considerations.  Section 4 specifies the messaging parameter\n\
    \   syntax.  Section 5 specifies the processing rules for messages.\n   Section\
    \ 6 describes security considerations for this specification.\n"
- title: 2.  Terminology and Conventions
  contents:
  - "2.  Terminology and Conventions\n   The key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n   LOCATOR_SET.  A HIP parameter containing zero or more Locator\
    \ fields.\n   locator.  A name that controls how the packet is routed through\
    \ the\n      network and demultiplexed by the end host.  It may include a\n  \
    \    concatenation of traditional network addresses such as an IPv6\n      address\
    \ and end-to-end identifiers such as an ESP SPI.  It may\n      also include transport\
    \ port numbers or IPv6 Flow Labels as\n      demultiplexing context, or it may\
    \ simply be a network address.\n   Locator.  When capitalized in the middle of\
    \ a sentence, this term\n      refers to the encoding of a locator within the\
    \ LOCATOR_SET\n      parameter (i.e., the 'Locator' field of the parameter).\n\
    \   Address.  A name that denotes a point of attachment to the network.\n    \
    \  The two most common examples are an IPv4 address and an IPv6\n      address.\
    \  The set of possible addresses is a subset of the set of\n      possible locators.\n\
    \   Preferred locator.  A locator on which a host prefers to receive\n      data.\
    \  Certain locators are labeled as preferred when a host\n      advertises its\
    \ locator set to its peer.  By default, the locators\n      used in the HIP base\
    \ exchange are the preferred locators.  The use\n      of preferred locators,\
    \ including the scenario where multiple\n      address scopes and families may\
    \ be in use, is defined more in\n      [RFC8047] than in this document.\n   Credit-Based\
    \ Authorization (CBA).  A mechanism allowing a host to\n      send a certain amount\
    \ of data to a peer's newly announced locator\n      before the result of mandatory\
    \ address verification is known.\n"
- title: 3.  Protocol Model
  contents:
  - "3.  Protocol Model\n   This section is an overview; a more detailed specification\
    \ follows\n   this section.\n"
- title: 3.1.  Operating Environment
  contents:
  - "3.1.  Operating Environment\n   HIP [RFC7401] is a key establishment and parameter\
    \ negotiation\n   protocol.  Its primary applications are for authenticating host\n\
    \   messages based on host identities and establishing SAs for the ESP\n   transport\
    \ format [RFC7402] and possibly other protocols in the\n   future.\n    +--------------------+\
    \                       +--------------------+\n    |                    |   \
    \                    |                    |\n    |   +------------+   |      \
    \                 |   +------------+   |\n    |   |    Key     |   |         HIP\
    \           |   |    Key     |   |\n    |   | Management | <-+-----------------------+->\
    \ | Management |   |\n    |   |  Process   |   |                       |   | \
    \ Process   |   |\n    |   +------------+   |                       |   +------------+\
    \   |\n    |         ^          |                       |         ^          |\n\
    \    |         |          |                       |         |          |\n   \
    \ |         v          |                       |         v          |\n    | \
    \  +------------+   |                       |   +------------+   |\n    |   |\
    \   IPsec    |   |        ESP            |   |   IPsec    |   |\n    |   |   Stack\
    \    | <-+-----------------------+-> |   Stack    |   |\n    |   |           \
    \ |   |                       |   |            |   |\n    |   +------------+ \
    \  |                       |   +------------+   |\n    |                    |\
    \                       |                    |\n    |                    |   \
    \                    |                    |\n    |     Initiator      |      \
    \                 |     Responder      |\n    +--------------------+         \
    \              +--------------------+\n                      Figure 1: HIP Deployment\
    \ Model\n   The general deployment model for HIP is shown above, assuming\n  \
    \ operation in an end-to-end fashion.  This document specifies an\n   extension\
    \ to HIP to enable end-host mobility.  In summary, these\n   extensions to the\
    \ HIP base protocol enable the signaling of new\n   addressing information to\
    \ the peer in HIP messages.  The messages are\n   authenticated via a signature\
    \ or keyed Hash Message Authentication\n   Code (HMAC) based on its Host Identity\
    \ (HI).  This document specifies\n   the format of this new addressing (LOCATOR_SET)\
    \ parameter, the\n   procedures for sending and processing this parameter to enable\
    \ basic\n   host mobility, and procedures for a concurrent address verification\n\
    \   mechanism.\n            ---------\n            | TCP   |  (sockets bound to\
    \ HITs)\n            ---------\n               |\n            ---------\n    \
    \  ----> | ESP   |  {HIT_s, HIT_d} <-> SPI\n      |     ---------\n      |   \
    \      |\n    ----    ---------\n   | MH |-> | HIP   |  {HIT_s, HIT_d, SPI} <->\
    \ {IP_s, IP_d, SPI}\n    ----    ---------\n               |\n            ---------\n\
    \            |  IP   |\n            ---------\n       Figure 2: Architecture for\
    \ HIP Host Mobility and Multihoming\n   Figure 2 depicts a layered architectural\
    \ view of a HIP-enabled stack\n   using the ESP transport format.  In HIP, upper-layer\
    \ protocols\n   (including TCP and ESP in this figure) are bound to Host Identity\n\
    \   Tags (HITs) and not IP addresses.  The HIP sublayer is responsible\n   for\
    \ maintaining the binding between HITs and IP addresses.  The SPI\n   is used\
    \ to associate an incoming packet with the right HITs.  The\n   block labeled\
    \ \"MH\" corresponds to the function that manages the\n   bindings at the ESP\
    \ and HIP sublayers for mobility (specified in this\n   document) and multihoming\
    \ (specified in [RFC8047]).\n   Consider first the case in which there is no mobility\
    \ or multihoming,\n   as specified in the base protocol specification [RFC7401].\
    \  The HIP\n   base exchange establishes the HITs in use between the hosts, the\
    \ SPIs\n   to use for ESP, and the IP addresses (used in both the HIP signaling\n\
    \   packets and ESP data packets).  Note that there can only be one such\n   set\
    \ of bindings in the outbound direction for any given packet, and\n   the only\
    \ fields used for the binding at the HIP layer are the fields\n   exposed by ESP\
    \ (the SPI and HITs).  For the inbound direction, the\n   SPI is all that is required\
    \ to find the right host context.  ESP\n   rekeying events change the mapping\
    \ between the HIT pair and SPI, but\n   do not change the IP addresses.\n   Consider\
    \ next a mobility event, in which a host moves to another IP\n   address.  Two\
    \ things need to occur in this case.  First, the peer\n   needs to be notified\
    \ of the address change using a HIP UPDATE\n   message.  Second, each host needs\
    \ to change its local bindings at the\n   HIP sublayer (new IP addresses).  It\
    \ may be that both the SPIs and IP\n   addresses are changed simultaneously in\
    \ a single UPDATE; the protocol\n   described herein supports this.  Although\
    \ internal notification of\n   transport-layer protocols regarding the path change\
    \ (e.g., to reset\n   congestion control variables) may be desired, this specification\
    \ does\n   not address such internal notification.  In addition, elements of\n\
    \   procedure for traversing network address translators (NATs) and\n   firewalls,\
    \ including NATs and firewalls that may understand HIP, may\n   complicate the\
    \ above basic scenario and are not covered by this\n   document.\n"
- title: 3.1.1.  Locator
  contents:
  - "3.1.1.  Locator\n   This document defines a generalization of an address called\
    \ a\n   \"locator\".  A locator specifies a point of attachment to the network\n\
    \   but may also include additional end-to-end tunneling or a per-host\n   demultiplexing\
    \ context that affects how packets are handled below the\n   logical HIP sublayer\
    \ of the stack.  This generalization is useful\n   because IP addresses alone\
    \ may not be sufficient to describe how\n   packets should be handled below HIP.\
    \  For example, in a host\n   multihoming context, certain IP addresses may need\
    \ to be associated\n   with certain ESP SPIs to avoid violating the ESP anti-replay\
    \ window.\n   Addresses may also be affiliated with transport ports in certain\n\
    \   tunneling scenarios.  Locators may simply be traditional network\n   addresses.\
    \  The format of the Locator fields in the LOCATOR_SET\n   parameter is defined\
    \ in Section 4.\n"
- title: 3.1.2.  Mobility Overview
  contents:
  - "3.1.2.  Mobility Overview\n   When a host moves to another address, it notifies\
    \ its peer of the new\n   address by sending a HIP UPDATE packet containing a\
    \ single\n   LOCATOR_SET parameter and a single ESP_INFO parameter.  This UPDATE\n\
    \   packet is acknowledged by the peer.  For reliability in the presence\n   of\
    \ packet loss, the UPDATE packet is retransmitted as defined in the\n   HIP specification\
    \ [RFC7401].  The peer can authenticate the contents\n   of the UPDATE packet\
    \ based on the signature and keyed hash of the\n   packet.\n   When using the\
    \ ESP transport format [RFC7402], the host may, at the\n   same time, decide to\
    \ rekey its security association and possibly\n   generate a new Diffie-Hellman\
    \ key; all of these actions are triggered\n   by including additional parameters\
    \ in the UPDATE packet, as defined\n   in the base protocol specification [RFC7401]\
    \ and ESP extension\n   [RFC7402].\n   When using ESP (and possibly other transport\
    \ modes in the future),\n   the host is able to receive packets that are protected\
    \ using a HIP-\n   created ESP SA from any address.  Thus, a host can change its\
    \ IP\n   address and continue to send packets to its peers without necessarily\n\
    \   rekeying.  However, the peers are not able to send packets to these\n   new\
    \ addresses before they can reliably and securely update the set of\n   addresses\
    \ that they associate with the sending host.  Furthermore,\n   mobility may change\
    \ the path characteristics in such a manner that\n   reordering occurs and packets\
    \ fall outside the ESP anti-replay window\n   for the SA, thereby requiring rekeying.\n"
- title: 3.2.  Protocol Overview
  contents:
  - "3.2.  Protocol Overview\n   In this section, we briefly introduce a number of\
    \ usage scenarios for\n   HIP host mobility.  These scenarios assume that HIP\
    \ is being used\n   with the ESP transform [RFC7402], although other scenarios\
    \ may be\n   defined in the future.  To understand these usage scenarios, the\n\
    \   reader should be at least minimally familiar with the HIP\n   specification\
    \ [RFC7401] and with the use of ESP with HIP [RFC7402].\n   According to these\
    \ specifications, the data traffic in a HIP session\n   is protected with ESP,\
    \ and the ESP SPI acts as an index to the right\n   host-to-host context.  More\
    \ specification details are found later in\n   Sections 4 and 5.\n   The scenarios\
    \ below assume that the two hosts have completed a single\n   HIP base exchange\
    \ with each other.  Therefore, both of the hosts have\n   one incoming and one\
    \ outgoing SA.  Further, each SA uses the same\n   pair of IP addresses, which\
    \ are the ones used in the base exchange.\n   The readdressing protocol is an\
    \ asymmetric protocol where a mobile\n   host informs a peer host about changes\
    \ of IP addresses on affected\n   SPIs.  The readdressing exchange is designed\
    \ to be piggybacked on\n   existing HIP exchanges.  In support of mobility, the\
    \ LOCATOR_SET\n   parameter is carried in UPDATE packets.\n   The scenarios below\
    \ at times describe addresses as being in either an\n   ACTIVE, UNVERIFIED, or\
    \ DEPRECATED state.  From the perspective of a\n   host, newly learned addresses\
    \ of the peer need to be verified before\n   put into active service, and addresses\
    \ removed by the peer are put\n   into a deprecated state.  Under limited conditions\
    \ described below\n   (Section 5.6), an UNVERIFIED address may be used.  The addressing\n\
    \   states are defined more formally in Section 5.1.\n   Hosts that use link-local\
    \ addresses as source addresses in their HIP\n   handshakes may not be reachable\
    \ by a mobile peer.  Such hosts SHOULD\n   provide a globally routable address\
    \ either in the initial handshake\n   or via the LOCATOR_SET parameter.\n"
- title: 3.2.1.  Mobility with a Single SA Pair (No Rekeying)
  contents:
  - "3.2.1.  Mobility with a Single SA Pair (No Rekeying)\n   A mobile host sometimes\
    \ needs to change an IP address bound to an\n   interface.  The change of an IP\
    \ address might be needed due to a\n   change in the advertised IPv6 prefixes\
    \ on the link, a reconnected PPP\n   link, a new DHCP lease, or an actual movement\
    \ to another subnet.  In\n   order to maintain its communication context, the\
    \ host needs to inform\n   its peers about the new IP address.  This first example\
    \ considers the\n   case in which the mobile host has only one interface, one\
    \ IP address\n   in use within the HIP session, a single pair of SAs (one inbound,\
    \ one\n   outbound), and no rekeying occurring on the SAs.  We also assume that\n\
    \   the new IP addresses are within the same address family (IPv4 or\n   IPv6)\
    \ as the previous address.  This is the simplest scenario,\n   depicted in Figure\
    \ 3.  Note that the conventions for message\n   parameter notations in figures\
    \ (use of parentheses and brackets) is\n   defined in Section 2.2 of [RFC7401].\n\
    \     Mobile Host                         Peer Host\n             UPDATE(ESP_INFO,\
    \ LOCATOR_SET, SEQ)\n        ----------------------------------->\n          \
    \   UPDATE(ESP_INFO, SEQ, ACK, ECHO_REQUEST)\n        <-----------------------------------\n\
    \             UPDATE(ACK, ECHO_RESPONSE)\n        ----------------------------------->\n\
    \        Figure 3: Readdress without Rekeying but with Address Check\n   The steps\
    \ of the packet processing are as follows:\n   1.  The mobile host may be disconnected\
    \ from the peer host for a\n       brief period of time while it switches from\
    \ one IP address to\n       another; this case is sometimes referred to in the\
    \ literature as\n       a \"break-before-make\" case.  The host may also obtain\
    \ its new IP\n       address before losing the old one (\"make-before-break\"\
    \ case).  In\n       either case, upon obtaining a new IP address, the mobile\
    \ host\n       sends a LOCATOR_SET parameter to the peer host in an UPDATE\n \
    \      message.  The UPDATE message also contains an ESP_INFO parameter\n    \
    \   containing the values of the old and new SPIs for a security\n       association.\
    \  In this case, both the OLD SPI and NEW SPI\n       parameters are set to the\
    \ value of the preexisting incoming SPI;\n       this ESP_INFO does not trigger\
    \ a rekeying event but is instead\n       included for possible parameter-inspecting\
    \ firewalls on the path\n       ([RFC5207] specifies some such firewall scenarios\
    \ in which the\n       HIP-aware firewall may want to associate ESP flows to host\n\
    \       identities).  The LOCATOR_SET parameter contains the new IP\n       address\
    \ (embedded in a Locator Type of \"1\", defined below) and a\n       lifetime\
    \ associated with the locator.  The mobile host waits for\n       this UPDATE\
    \ to be acknowledged, and retransmits if necessary, as\n       specified in the\
    \ base specification [RFC7401].\n   2.  The peer host receives the UPDATE, validates\
    \ it, and updates any\n       local bindings between the HIP association and the\
    \ mobile host's\n       destination address.  The peer host MUST perform an address\n\
    \       verification by placing a nonce in the ECHO_REQUEST parameter of\n   \
    \    the UPDATE message sent back to the mobile host.  It also\n       includes\
    \ an ESP_INFO parameter with both the OLD SPI and NEW SPI\n       parameters set\
    \ to the value of the preexisting incoming SPI and\n       sends this UPDATE (with\
    \ piggybacked acknowledgment) to the mobile\n       host at its new address. \
    \ This UPDATE also acknowledges the\n       mobile host's UPDATE that triggered\
    \ the exchange.  The peer host\n       waits for its UPDATE to be acknowledged,\
    \ and retransmits if\n       necessary, as specified in the base specification\
    \ [RFC7401].  The\n       peer MAY use the new address immediately, but it MUST\
    \ limit the\n       amount of data it sends to the address until address verification\n\
    \       completes.\n   3.  The mobile host completes the readdress by processing\
    \ the UPDATE\n       ACK and echoing the nonce in an ECHO_RESPONSE, containing\
    \ the ACK\n       of the peer's UPDATE.  This UPDATE is not protected by a\n \
    \      retransmission timer because it does not contain a SEQ parameter\n    \
    \   requesting acknowledgment.  Once the peer host receives this\n       ECHO_RESPONSE,\
    \ it considers the new address to be verified and\n       can put the address\
    \ into full use.\n   While the peer host is verifying the new address, the new\
    \ address is\n   marked as UNVERIFIED (in the interim), and the old address is\n\
    \   DEPRECATED.  Once the peer host has received a correct reply to its\n   UPDATE\
    \ challenge, it marks the new address as ACTIVE and removes the\n   old address.\n"
- title: 3.2.2.  Mobility with a Single SA Pair (Mobile-Initiated Rekey)
  contents:
  - "3.2.2.  Mobility with a Single SA Pair (Mobile-Initiated Rekey)\n   The mobile\
    \ host may decide to rekey the SAs at the same time that it\n   notifies the peer\
    \ of the new address.  In this case, the above\n   procedure described in Figure\
    \ 3 is slightly modified.  The UPDATE\n   message sent from the mobile host includes\
    \ an ESP_INFO with the OLD\n   SPI set to the previous SPI, the NEW SPI set to\
    \ the desired new SPI\n   value for the incoming SA, and the KEYMAT Index desired.\
    \  Optionally,\n   the host may include a DIFFIE_HELLMAN parameter for a new Diffie-\n\
    \   Hellman key.  The peer completes the request for a rekey as is\n   normally\
    \ done for HIP rekeying, except that the new address is kept\n   as UNVERIFIED\
    \ until the UPDATE nonce challenge is received as\n   described above.  Figure\
    \ 4 illustrates this scenario.\n     Mobile Host                         Peer\
    \ Host\n             UPDATE(ESP_INFO, LOCATOR_SET, SEQ, [DIFFIE_HELLMAN])\n  \
    \      ----------------------------------->\n             UPDATE(ESP_INFO, SEQ,\
    \ ACK, [DIFFIE_HELLMAN,] ECHO_REQUEST)\n        <-----------------------------------\n\
    \             UPDATE(ACK, ECHO_RESPONSE)\n        ----------------------------------->\n\
    \              Figure 4: Readdress with Mobile-Initiated Rekey\n"
- title: 3.2.3.  Mobility Messaging through the Rendezvous Server
  contents:
  - "3.2.3.  Mobility Messaging through the Rendezvous Server\n   Section 6.11 of\
    \ [RFC7401] specifies procedures for sending HIP UPDATE\n   packets.  The UPDATE\
    \ packets are protected by a timer subject to\n   exponential backoff and resent\
    \ UPDATE_RETRY_MAX times.  It may be,\n   however, that the peer is itself in\
    \ the process of moving when the\n   local host is trying to update the IP address\
    \ bindings of the HIP\n   association.  This is sometimes called the \"double-jump\"\
    \ mobility\n   problem; each host's UPDATE packets are simultaneously sent to\
    \ a\n   stale address of the peer, and the hosts are no longer reachable from\n\
    \   one another.\n   The HIP Rendezvous Extension [RFC8004] specifies a rendezvous\
    \ service\n   that permits the I1 packet from the base exchange to be relayed\
    \ from\n   a stable or well-known public IP address location to the current IP\n\
    \   address of the host.  It is possible to support double-jump mobility\n   with\
    \ this rendezvous service if the following extensions to the\n   specifications\
    \ of [RFC8004] and [RFC7401] are followed.\n   1.  The mobile host sending an\
    \ UPDATE to the peer, and not receiving\n       an ACK, MAY resend the UPDATE\
    \ to an RVS of the peer, if such a\n       server is known.  The host MAY try\
    \ the RVS of the peer up to\n       UPDATE_RETRY_MAX times as specified in [RFC7401].\
    \  The host MAY\n       try to use the peer's RVS before it has tried UPDATE_RETRY_MAX\n\
    \       times to the last working address (i.e., the RVS MAY be tried in\n   \
    \    parallel with retries to the last working address).  The\n       aggressiveness\
    \ of a host replicating its UPDATEs to multiple\n       destinations, to try candidates\
    \ in parallel instead of serially,\n       is a policy choice outside of this\
    \ specification.\n   2.  An RVS supporting the UPDATE forwarding extensions specified\n\
    \       herein MUST modify the UPDATE in the same manner as it modifies\n    \
    \   the I1 packet before forwarding.  Specifically, it MUST rewrite\n       the\
    \ IP header source and destination addresses, recompute the IP\n       header\
    \ checksum, and include the FROM and RVS_HMAC parameters.\n   3.  A host receiving\
    \ an UPDATE packet MUST be prepared to process the\n       FROM and RVS_HMAC parameters\
    \ and MUST include a VIA_RVS parameter\n       in the UPDATE reply that contains\
    \ the ACK of the UPDATE SEQ.\n   4.  An Initiator receiving a VIA_RVS in the UPDATE\
    \ reply should\n       initiate address reachability tests (described later in\
    \ this\n       document) towards the end host's address and not towards the\n\
    \       address included in the VIA_RVS.\n   This scenario requires that hosts\
    \ using RVSs also take steps to\n   update their current address bindings with\
    \ their RVS upon a mobility\n   event.  [RFC8004] does not specify how to update\
    \ the RVS with a\n   client host's new address.  Section 3.2 of [RFC8003] describes\
    \ how a\n   host may send a REG_REQUEST in either an I2 packet (if there is no\n\
    \   active association) or an UPDATE packet (if such association exists).\n  \
    \ According to procedures described in [RFC8003], if a mobile host has\n   an\
    \ active registration, it may use mobility updates specified herein,\n   within\
    \ the context of that association, to readdress the association.\n"
- title: 3.2.4.  Network Renumbering
  contents:
  - "3.2.4.  Network Renumbering\n   It is expected that IPv6 networks will be renumbered\
    \ much more often\n   than most IPv4 networks.  From an end-host point of view,\
    \ network\n   renumbering is similar to mobility, and procedures described herein\n\
    \   also apply to notify a peer of a changed address.\n"
- title: 3.3.  Other Considerations
  contents:
  - '3.3.  Other Considerations

    '
- title: 3.3.1.  Address Verification
  contents:
  - "3.3.1.  Address Verification\n   When a HIP host receives a set of locators from\
    \ another HIP host in a\n   LOCATOR_SET, it does not necessarily know whether\
    \ the other host is\n   actually reachable at the claimed addresses.  In fact,\
    \ a malicious\n   peer host may be intentionally giving bogus addresses in order\
    \ to\n   cause a packet flood towards the target addresses [RFC4225].\n   Therefore,\
    \ the HIP host needs to first check that the peer is\n   reachable at the new\
    \ address.\n   Address verification is implemented by the challenger sending some\n\
    \   piece of unguessable information to the new address and waiting for\n   some\
    \ acknowledgment from the Responder that indicates reception of\n   the information\
    \ at the new address.  This may include the exchange of\n   a nonce or the generation\
    \ of a new SPI and observation of data\n   arriving on the new SPI.  More details\
    \ are found in Section 5.4 of\n   this document.\n   An additional potential benefit\
    \ of performing address verification is\n   to allow NATs and firewalls in the\
    \ network along the new path to\n   obtain the peer host's inbound SPI.\n"
- title: 3.3.2.  Credit-Based Authorization
  contents:
  - "3.3.2.  Credit-Based Authorization\n   CBA allows a host to securely use a new\
    \ locator even though the\n   peer's reachability at the address embedded in the\
    \ locator has not\n   yet been verified.  This is accomplished based on the following\
    \ three\n   hypotheses:\n   1.  A flooding attacker typically seeks to somehow\
    \ multiply the\n       packets it generates for the purpose of its attack because\n\
    \       bandwidth is an ample resource for many victims.\n   2.  An attacker can\
    \ often cause unamplified flooding by sending\n       packets to its victim, either\
    \ by directly addressing the victim\n       in the packets or by guiding the packets\
    \ along a specific path by\n       means of an IPv6 Routing header, if Routing\
    \ headers are not\n       filtered by firewalls.\n   3.  Consequently, the additional\
    \ effort required to set up a\n       redirection-based flooding attack (without\
    \ CBA and return\n       routability checks) would pay off for the attacker only\
    \ if\n       amplification could be obtained this way.\n   On this basis, rather\
    \ than eliminating malicious packet redirection\n   in the first place, CBA prevents\
    \ amplifications.  This is\n   accomplished by limiting the data a host can send\
    \ to an unverified\n   address of a peer by the data recently received from that\
    \ peer.\n   Redirection-based flooding attacks thus become less attractive than,\n\
    \   for example, pure direct flooding, where the attacker itself sends\n   bogus\
    \ packets to the victim.\n   Figure 5 illustrates CBA: Host B measures the amount\
    \ of data recently\n   received from peer A and, when A readdresses, sends packets\
    \ to A's\n   new, unverified address as long as the sum of the packet sizes does\n\
    \   not exceed the measured, received data volume.  When insufficient\n   credit\
    \ is left, B stops sending further packets to A until A's\n   address becomes\
    \ ACTIVE.  The address changes may be due to mobility,\n   multihoming, or any\
    \ other reason.  Not shown in Figure 5 are the\n   results of credit aging (Section\
    \ 5.6.2), a mechanism used to dampen\n   possible time-shifting attacks.\n   \
    \        +-------+                        +-------+\n           |   A   |    \
    \                    |   B   |\n           +-------+                        +-------+\n\
    \               |                                |\n       address |------------------------------->|\
    \ credit += size(packet)\n        ACTIVE |                                |\n\
    \               |------------------------------->| credit += size(packet)\n  \
    \             |<-------------------------------| do not change credit\n      \
    \         |                                |\n               + address change\
    \                 |\n               + address verification starts    |\n     \
    \  address |<-------------------------------| credit -= size(packet)\n    UNVERIFIED\
    \ |------------------------------->| credit += size(packet)\n               |<-------------------------------|\
    \ credit -= size(packet)\n               |                                |\n\
    \               |<-------------------------------| credit -= size(packet)\n  \
    \             |                                X credit < size(packet)\n     \
    \          |                                | => do not send packet!\n       \
    \        + address verification concludes |\n       address |                \
    \                |\n        ACTIVE |<-------------------------------| do not change\
    \ credit\n               |                                |\n                \
    \      Figure 5: Readdressing Scenario\n   This document does not specify how\
    \ to set the credit limit value, but\n   the goal is to allow data transfers to\
    \ proceed without much\n   interruption while the new address is verified.  A\
    \ simple heuristic\n   to accomplish this, if the sender knows roughly its round-trip\
    \ time\n   (RTT) and current sending rate to the host, is to allow enough credit\n\
    \   to support maintaining the sending rate for a duration corresponding\n   to\
    \ two or three RTTs.\n"
- title: 3.3.3.  Preferred Locator
  contents:
  - "3.3.3.  Preferred Locator\n   When a host has multiple locators, the peer host\
    \ needs to decide\n   which to use for outbound packets.  It may be that a host\
    \ would\n   prefer to receive data on a particular inbound interface.  HIP allows\n\
    \   a particular locator to be designated as a preferred locator and\n   communicated\
    \ to the peer (see Section 4).\n"
- title: 4.  LOCATOR_SET Parameter Format
  contents:
  - "4.  LOCATOR_SET Parameter Format\n   The LOCATOR_SET parameter has a type number\
    \ value that is considered\n   to be a \"critical parameter\" as per the definition\
    \ in [RFC7401]; such\n   parameter types MUST be recognized and processed by the\
    \ recipient.\n   The parameter consists of the standard HIP parameter Type and\
    \ Length\n   fields, plus zero or more Locator sub-parameters.  Each Locator sub-\n\
    \   parameter contains a Traffic Type, Locator Type, Locator Length,\n   preferred\
    \ locator bit (\"P\" bit), Locator Lifetime, and a Locator\n   encoding.  A LOCATOR_SET\
    \ containing zero Locator fields is permitted\n   but has the effect of deprecating\
    \ all addresses.\n        0                   1                   2          \
    \         3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |             Type              |            Length             |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   | Traffic Type   | Locator Type | Locator Length | Reserved   |P|\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                       Locator Lifetime                        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                            Locator                            |\n  \
    \     |                                                               |\n    \
    \   |                                                               |\n      \
    \ |                                                               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       .                                                               .\n  \
    \     .                                                               .\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ | Traffic Type   | Locator Type | Locator Length | Reserved   |P|\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                       Locator Lifetime                        |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                            Locator                            |\n      \
    \ |                                                               |\n       |\
    \                                                               |\n       |  \
    \                                                             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 6: LOCATOR_SET Parameter Format\n   Type:  193\n   Length:\
    \  Length in octets, excluding Type and Length fields, and\n      excluding padding.\n\
    \   Traffic Type:  Defines whether the locator pertains to HIP signaling,\n  \
    \    user data, or both.\n   Locator Type:  Defines the semantics of the Locator\
    \ field.\n   Locator Length:  Defines the length of the Locator field, in units\
    \ of\n      4-byte words (Locators up to a maximum of 4*255 octets are\n     \
    \ supported).\n   Reserved:  Zero when sent, ignored when received.\n   P: Preferred\
    \ locator.  Set to one if the locator is preferred for\n      that Traffic Type;\
    \ otherwise, set to zero.\n   Locator Lifetime:  Lifetime of the locator, in seconds.\n\
    \   Locator:  The locator whose semantics and encoding are indicated by\n    \
    \  the Locator Type field.  All sub-fields of the Locator field are\n      integral\
    \ multiples of four octets in length.\n   The Locator Lifetime (lifetime) indicates\
    \ how long the following\n   locator is expected to be valid.  The lifetime is\
    \ expressed in\n   seconds.  Each locator MUST have a non-zero lifetime.  The\
    \ address is\n   expected to become deprecated when the specified number of seconds\n\
    \   has passed since the reception of the message.  A deprecated address\n   SHOULD\
    \ NOT be used as a destination address if an alternate\n   (non-deprecated) is\
    \ available and has sufficient address scope.\n"
- title: 4.1.  Traffic Type and Preferred Locator
  contents:
  - "4.1.  Traffic Type and Preferred Locator\n   The following Traffic Type values\
    \ are defined:\n   0:   Both signaling (HIP control packets) and user data.\n\
    \   1:   Signaling packets only.\n   2:   Data packets only.\n   The \"P\" bit,\
    \ when set, has scope over the corresponding Traffic Type.\n   That is, when a\
    \ \"P\" bit is set for Traffic Type \"2\", for example, it\n   means that the\
    \ locator is preferred for data packets.  If there is a\n   conflict (for example,\
    \ if the \"P\" bit is set for an address of Type\n   \"0\" and a different address\
    \ of Type \"2\"), the more specific Traffic\n   Type rule applies (in this case,\
    \ \"2\").  By default, the IP addresses\n   used in the base exchange are preferred\
    \ locators for both signaling\n   and user data, unless a new preferred locator\
    \ supersedes them.  If no\n   locators are indicated as preferred for a given\
    \ Traffic Type, the\n   implementation may use an arbitrary destination locator\
    \ from the set\n   of active locators.\n"
- title: 4.2.  Locator Type and Locator
  contents:
  - "4.2.  Locator Type and Locator\n   The following Locator Type values are defined,\
    \ along with the\n   associated semantics of the Locator field:\n   0:  An IPv6\
    \ address or an IPv4-in-IPv6 format IPv4 address [RFC4291]\n       (128 bits long).\
    \  This Locator Type is defined primarily for\n       non-ESP-based usage.\n \
    \  1:  The concatenation of an ESP SPI (first 32 bits) followed by an\n      \
    \ IPv6 address or an IPv4-in-IPv6 format IPv4 address (an\n       additional 128\
    \ bits).  This IP address is defined primarily for\n       ESP-based usage.\n"
- title: 4.3.  UPDATE Packet with Included LOCATOR_SET
  contents:
  - "4.3.  UPDATE Packet with Included LOCATOR_SET\n   A number of combinations of\
    \ parameters in an UPDATE packet are\n   possible (e.g., see Section 3.2).  In\
    \ this document, procedures are\n   defined only for the case in which one LOCATOR_SET\
    \ and one ESP_INFO\n   parameter are used in any HIP packet.  Any UPDATE packet\
    \ that\n   includes a LOCATOR_SET parameter SHOULD include both an HMAC and a\n\
    \   HIP_SIGNATURE parameter.\n   The UPDATE MAY also include a HOST_ID parameter\
    \ (which may be useful\n   for HIP-aware firewalls inspecting the HIP messages\
    \ for the first\n   time).  If the UPDATE includes the HOST_ID parameter, the\
    \ receiving\n   host MUST verify that the HOST_ID corresponds to the HOST_ID that\
    \ was\n   used to establish the HIP association, and the HIP_SIGNATURE MUST\n\
    \   verify with the public key associated with this HOST_ID parameter.\n   The\
    \ relationship between the announced Locators and any ESP_INFO\n   parameters\
    \ present in the packet is defined in Section 5.2.  This\n   document does not\
    \ support any elements of procedure for sending more\n   than one LOCATOR_SET\
    \ or ESP_INFO parameter in a single UPDATE.\n"
- title: 5.  Processing Rules
  contents:
  - "5.  Processing Rules\n   This section describes rules for sending and receiving\
    \ the\n   LOCATOR_SET parameter, testing address reachability, and using CBA on\n\
    \   UNVERIFIED locators.\n"
- title: 5.1.  Locator Data Structure and Status
  contents:
  - "5.1.  Locator Data Structure and Status\n   Each locator announced in a LOCATOR_SET\
    \ parameter is represented by a\n   piece of state that contains the following\
    \ data:\n   o  the actual bit pattern representing the locator,\n   o  the lifetime\
    \ (seconds),\n   o  the status (UNVERIFIED, ACTIVE, DEPRECATED),\n   o  the Traffic\
    \ Type scope of the locator, and\n   o  whether the locator is preferred for any\
    \ particular scope.\n   The status is used to track the reachability of the address\
    \ embedded\n   within the LOCATOR_SET parameter:\n   UNVERIFIED:  indicates that\
    \ the reachability of the address has not\n      been verified yet,\n   ACTIVE:\
    \  indicates that the reachability of the address has been\n      verified and\
    \ the address has not been deprecated, and\n   DEPRECATED:  indicates that the\
    \ locator's lifetime has expired.\n   The following state changes are allowed:\n\
    \   UNVERIFIED to ACTIVE:  The reachability procedure completes\n      successfully.\n\
    \   UNVERIFIED to DEPRECATED:  The locator's lifetime expires while the\n    \
    \  locator is UNVERIFIED.\n   ACTIVE to DEPRECATED:  The locator's lifetime expires\
    \ while the\n      locator is ACTIVE.\n   ACTIVE to UNVERIFIED:  There has been\
    \ no traffic on the address for\n      some time, and the local policy mandates\
    \ that the address\n      reachability needs to be verified again before starting\
    \ to use it\n      again.\n   DEPRECATED to UNVERIFIED:  The host receives a new\
    \ lifetime for the\n      locator.\n   A DEPRECATED address MUST NOT be changed\
    \ to ACTIVE without first\n   verifying its reachability.\n   Note that the state\
    \ of whether or not a locator is preferred is not\n   necessarily the same as\
    \ the value of the preferred bit in the Locator\n   sub-parameter received from\
    \ the peer.  Peers may recommend certain\n   locators to be preferred, but the\
    \ decision on whether to actually use\n   a locator as a preferred locator is\
    \ a local decision, possibly\n   influenced by local policy.\n   In addition to\
    \ state maintained about status and remaining lifetime\n   for each locator learned\
    \ from the peer, an implementation would\n   typically maintain similar state\
    \ about its own locators that have\n   been offered to the peer.\n   A locator\
    \ lifetime that is unbounded (does not expire) can be\n   signified by setting\
    \ the value of the lifetime field to the maximum\n   (unsigned) value.\n   Finally,\
    \ the locators used to establish the HIP association are by\n   default assumed\
    \ to be the initial preferred locators in ACTIVE state,\n   with an unbounded\
    \ lifetime.\n"
- title: 5.2.  Sending the LOCATOR_SET
  contents:
  - "5.2.  Sending the LOCATOR_SET\n   The decision of when to send the LOCATOR_SET\
    \ is a local policy issue.\n   However, it is RECOMMENDED that a host send a LOCATOR_SET\
    \ whenever it\n   recognizes a change of its IP addresses in use on an active\
    \ HIP\n   association and assumes that the change is going to last at least for\n\
    \   a few seconds.  Rapidly sending LOCATOR_SETs that force the peer to\n   change\
    \ the preferred address SHOULD be avoided.\n   The sending of a new LOCATOR_SET\
    \ parameter replaces the locator\n   information from any previously sent LOCATOR_SET\
    \ parameter;\n   therefore, if a host sends a new LOCATOR_SET parameter, it needs\
    \ to\n   continue to include all active locators.  Hosts MUST NOT announce\n \
    \  broadcast or multicast addresses in LOCATOR_SETs.\n   We now describe a few\
    \ cases introduced in Section 3.2.  We assume\n   that the Traffic Type for each\
    \ locator is set to \"0\" (other values\n   for Traffic Type may be specified\
    \ in documents that separate the HIP\n   control plane from data-plane traffic).\
    \  Other mobility cases are\n   possible but are left for further study.\n   1.\
    \  Host mobility with no multihoming and no rekeying.  The mobile\n       host\
    \ creates a single UPDATE containing a single ESP_INFO with a\n       single LOCATOR_SET\
    \ parameter.  The ESP_INFO contains the current\n       value of the SPI in both\
    \ the OLD SPI and NEW SPI fields.  The\n       LOCATOR_SET contains a single Locator\
    \ with a Locator Type of \"1\";\n       the SPI MUST match that of the ESP_INFO.\
    \  The preferred bit\n       SHOULD be set and the \"Locator Lifetime\" is set\
    \ according to\n       local policy.  The UPDATE also contains a SEQ parameter\
    \ as usual.\n       This packet is retransmitted as defined in the HIP specification\n\
    \       [RFC7401].  The UPDATE should be sent to the peer's preferred IP\n   \
    \    address with an IP source address corresponding to the address in\n     \
    \  the LOCATOR_SET parameter.\n   2.  Host mobility with no multihoming but with\
    \ rekeying.  The mobile\n       host creates a single UPDATE containing a single\
    \ ESP_INFO with a\n       single LOCATOR_SET parameter (with a single address).\
    \  The\n       ESP_INFO contains the current value of the SPI in the OLD SPI,\n\
    \       the new value of the SPI in the NEW SPI, and a KEYMAT Index as\n     \
    \  selected by local policy.  Optionally, the host may choose to\n       initiate\
    \ a Diffie-Hellman rekey by including a DIFFIE_HELLMAN\n       parameter.  The\
    \ LOCATOR_SET contains a single Locator with a\n       Locator Type of \"1\";\
    \ the SPI MUST match that of the NEW SPI in\n       the ESP_INFO.  Otherwise,\
    \ the steps are identical to the case in\n       which no rekeying is initiated.\n"
- title: 5.3.  Handling Received LOCATOR_SETs
  contents:
  - "5.3.  Handling Received LOCATOR_SETs\n   A host SHOULD be prepared to receive\
    \ a single LOCATOR_SET parameter\n   in a HIP UPDATE packet.  Reception of multiple\
    \ LOCATOR_SET parameters\n   in a single packet, or in HIP packets other than\
    \ UPDATE, is outside\n   of the scope of this specification.\n   Because a host\
    \ sending the LOCATOR_SET may send the same parameter in\n   different UPDATE\
    \ messages to different destination addresses,\n   including possibly the RVS\
    \ of the host, the host receiving the\n   LOCATOR_SET MUST be prepared to handle\
    \ the possibility of duplicate\n   LOCATOR_SETs sent to more than one of the host's\
    \ addresses.  As a\n   result, the host MUST detect and avoid reprocessing a LOCATOR_SET\n\
    \   parameter that is redundant with a LOCATOR_SET parameter that has\n   been\
    \ recently received and processed.\n   This document describes sending both ESP_INFO\
    \ and LOCATOR_SET\n   parameters in an UPDATE.  The ESP_INFO parameter is included\
    \ when\n   there is a need to rekey or key a new SPI, and is otherwise included\n\
    \   for the possible benefit of HIP-aware NATs and firewalls.  The\n   LOCATOR_SET\
    \ parameter contains a complete listing of the locators\n   that the host wishes\
    \ to make or keep active for the HIP association.\n   In general, the processing\
    \ of a LOCATOR_SET depends upon the packet\n   type in which it is included. \
    \ Here, we describe only the case in\n   which ESP_INFO is present and a single\
    \ LOCATOR_SET and ESP_INFO are\n   sent in an UPDATE message; other cases are\
    \ for further study.  The\n   steps below cover each of the cases described in\
    \ Section 5.2.\n   The processing of ESP_INFO and LOCATOR_SET parameters is intended\
    \ to\n   be modular and support future generalization to the inclusion of\n  \
    \ multiple ESP_INFO and/or multiple LOCATOR_SET parameters.  A host\n   SHOULD\
    \ first process the ESP_INFO before the LOCATOR_SET, since the\n   ESP_INFO may\
    \ contain a new SPI value mapped to an existing SPI, while\n   a Locator Type\
    \ of \"1\" will only contain a reference to the new SPI.\n   When a host receives\
    \ a validated HIP UPDATE with a LOCATOR_SET and\n   ESP_INFO parameter, it processes\
    \ the ESP_INFO as follows.  The\n   ESP_INFO parameter indicates whether an SA\
    \ is being rekeyed, created,\n   deprecated, or just identified for the benefit\
    \ of HIP-aware NATs and\n   firewalls.  The host examines the OLD SPI and NEW\
    \ SPI values in the\n   ESP_INFO parameter:\n   1.  (no rekeying) If the OLD SPI\
    \ is equal to the NEW SPI and both\n       correspond to an existing SPI, the\
    \ ESP_INFO is gratuitous\n       (provided for HIP-aware NATs and firewalls) and\
    \ no rekeying is\n       necessary.\n   2.  (rekeying) If the OLD SPI indicates\
    \ an existing SPI and the NEW\n       SPI is a different non-zero value, the existing\
    \ SA is being\n       rekeyed and the host follows HIP ESP rekeying procedures\
    \ by\n       creating a new outbound SA with an SPI corresponding to the NEW\n\
    \       SPI, with no addresses bound to this SPI.  Note that locators in\n   \
    \    the LOCATOR_SET parameter will reference this new SPI instead of\n      \
    \ the old SPI.\n   3.  (new SA) If the OLD SPI value is zero and the NEW SPI is\
    \ a new\n       non-zero value, then a new SA is being requested by the peer.\n\
    \       This case is also treated like a rekeying event; the receiving\n     \
    \  host MUST create a new SA and respond with an UPDATE ACK.\n   4.  (deprecating\
    \ the SA) If the OLD SPI indicates an existing SPI and\n       the NEW SPI is\
    \ zero, the SA is being deprecated and all locators\n       uniquely bound to\
    \ the SPI are put into the DEPRECATED state.\n   If none of the above cases apply,\
    \ a protocol error has occurred and\n   the processing of the UPDATE is stopped.\n\
    \   Next, the locators in the LOCATOR_SET parameter are processed.  For\n   each\
    \ locator listed in the LOCATOR_SET parameter, check that the\n   address therein\
    \ is a legal unicast or anycast address.  That is, the\n   address MUST NOT be\
    \ a broadcast or multicast address.  Note that some\n   implementations MAY accept\
    \ addresses that indicate the local host,\n   since it may be allowed that the\
    \ host runs HIP with itself.\n   The below assumes that all Locators are of Type\
    \ \"1\" with a Traffic\n   Type of \"0\"; other cases are for further study.\n\
    \   For each Type \"1\" address listed in the LOCATOR_SET parameter, the\n   host\
    \ checks whether the address is already bound to the SPI\n   indicated.  If the\
    \ address is already bound, its lifetime is updated.\n   If the status of the\
    \ address is DEPRECATED, the status is changed to\n   UNVERIFIED.  If the address\
    \ is not already bound, the address is\n   added, and its status is set to UNVERIFIED.\
    \  Mark all addresses\n   corresponding to the SPI that were NOT listed in the\
    \ LOCATOR_SET\n   parameter as DEPRECATED.\n   As a result, at the end of processing,\
    \ the addresses listed in the\n   LOCATOR_SET parameter have a state of either\
    \ UNVERIFIED or ACTIVE,\n   and any old addresses on the old SA not listed in\
    \ the LOCATOR_SET\n   parameter have a state of DEPRECATED.\n   Once the host\
    \ has processed the locators, if the LOCATOR_SET\n   parameter contains a new\
    \ preferred locator, the host SHOULD initiate\n   a change of the preferred locator.\
    \  This requires that the host first\n   verify reachability of the associated\
    \ address, and only then change\n   the preferred locator; see Section 5.5.\n\
    \   If a host receives a locator with an unsupported Locator Type, and\n   when\
    \ such a locator is also declared to be the preferred locator for\n   the peer,\
    \ the host SHOULD send a NOTIFY error with a Notify Message\n   Type of LOCATOR_TYPE_UNSUPPORTED,\
    \ with the Notification Data field\n   containing the locator(s) that the receiver\
    \ failed to process.\n   Otherwise, a host MAY send a NOTIFY error if a (non-preferred)\n\
    \   locator with an unsupported Locator Type is received in a LOCATOR_SET\n  \
    \ parameter.\n   A host MAY add the source IP address of a received HIP packet\
    \ as a\n   candidate locator for the peer even if it is not listed in the peer's\n\
    \   LOCATOR_SET, but it SHOULD prefer locators explicitly listed in the\n   LOCATOR_SET.\n"
- title: 5.4.  Verifying Address Reachability
  contents:
  - "5.4.  Verifying Address Reachability\n   A host MUST verify the reachability\
    \ of an UNVERIFIED address.  The\n   status of a newly learned address MUST initially\
    \ be set to UNVERIFIED\n   unless the new address is advertised in an R1 packet\
    \ as a new\n   preferred locator.  A host MAY also want to verify the reachability\n\
    \   of an ACTIVE address again after some time, in which case it would\n   set\
    \ the status of the address to UNVERIFIED and reinitiate address\n   verification.\
    \  A typical verification that is protected by\n   retransmission timers is to\
    \ include an ECHO REQUEST within an UPDATE\n   sent to the new address.\n   A\
    \ host typically starts the address-verification procedure by sending\n   a nonce\
    \ to the new address.  A host MAY choose from different message\n   exchanges\
    \ or different nonce values so long as it establishes that\n   the peer has received\
    \ and replied to the nonce at the new address.\n   For example, when the host\
    \ is changing its SPI and sending an\n   ESP_INFO to the peer, the NEW SPI value\
    \ SHOULD be random and the\n   random value MAY be copied into an ECHO_REQUEST\
    \ sent in the rekeying\n   UPDATE.  However, if the host is not changing its SPI,\
    \ it MAY still\n   use the ECHO_REQUEST parameter for verification but with some\
    \ other\n   random value.  A host MAY also use other message exchanges as\n  \
    \ confirmation of the address reachability.\n   In some cases, it MAY be sufficient\
    \ to use the arrival of data on a\n   newly advertised SA as implicit address\
    \ reachability verification as\n   depicted in Figure 7, instead of waiting for\
    \ the confirmation via a\n   HIP packet.  In this case, a host advertising a new\
    \ SPI as part of\n   its address reachability check SHOULD be prepared to receive\
    \ traffic\n   on the new SA.\n     Mobile Host                               \
    \    Peer Host\n                  UPDATE(ESP_INFO, LOCATOR_SET, ...)\n       \
    \         ---------------------------------->\n                              \
    \                     prepare incoming SA\n                  UPDATE(ESP_INFO,\
    \ ...) with new SPI\n                <-----------------------------------\n  \
    \ switch to new outgoing SA\n                           data on new SA\n     \
    \           ----------------------------------->\n                           \
    \                        mark address ACTIVE\n                  UPDATE(ACK, ECHO_RESPONSE)\
    \ later arrives\n                ----------------------------------->\n      \
    \       Figure 7: Address Activation via Use of a New SA\n   When address verification\
    \ is in progress for a new preferred locator,\n   the host SHOULD select a different\
    \ locator listed as ACTIVE, if one\n   such locator is available, to continue\
    \ communications until address\n   verification completes.  Alternatively, the\
    \ host MAY use the new\n   preferred locator while in UNVERIFIED status to the\
    \ extent CBA\n   permits.  CBA is explained in Section 5.6.  Once address verification\n\
    \   succeeds, the status of the new preferred locator changes to ACTIVE.\n"
- title: 5.5.  Changing the Preferred Locator
  contents:
  - "5.5.  Changing the Preferred Locator\n   A host MAY want to change the preferred\
    \ outgoing locator for\n   different reasons, e.g., because traffic information\
    \ or ICMP error\n   messages indicate that the currently used preferred address\
    \ may have\n   become unreachable.  Another reason may be due to receiving a\n\
    \   LOCATOR_SET parameter that has the \"P\" bit set.\n   To change the preferred\
    \ locator, the host initiates the following\n   procedure:\n   1.  If the new\
    \ preferred locator has an ACTIVE status, the preferred\n       locator is changed\
    \ and the procedure succeeds.\n   2.  If the new preferred locator has an UNVERIFIED\
    \ status, the host\n       starts to verify its reachability.  The host SHOULD\
    \ use a\n       different locator listed as ACTIVE until address verification\n\
    \       completes if one such locator is available.  Alternatively, the\n    \
    \   host MAY use the new preferred locator, even though in UNVERIFIED\n      \
    \ status, to the extent CBA permits.  Once address verification\n       succeeds,\
    \ the status of the new preferred locator changes to\n       ACTIVE, and its use\
    \ is no longer governed by CBA.\n   3.  If the peer host has not indicated a preference\
    \ for any address,\n       then the host picks one of the peer's ACTIVE addresses\
    \ randomly\n       or according to local policy.  This case may arise if, for\n\
    \       example, ICMP error messages that deprecate the preferred locator\n  \
    \     arrive, but the peer has not yet indicated a new preferred\n       locator.\n\
    \   4.  If the new preferred locator has a DEPRECATED status and there is\n  \
    \     at least one non-deprecated address, the host selects one of the\n     \
    \  non-deprecated addresses as a new preferred locator and\n       continues.\
    \  If the selected address is UNVERIFIED, the address\n       verification procedure\
    \ described above will apply.\n"
- title: 5.6.  Credit-Based Authorization
  contents:
  - "5.6.  Credit-Based Authorization\n   To prevent redirection-based flooding attacks,\
    \ the use of a CBA\n   approach MUST be used when a host sends data to an UNVERIFIED\n\
    \   locator.  The following algorithm addresses the security\n   considerations\
    \ for prevention of amplification and time-shifting\n   attacks.  Other forms\
    \ of credit aging, and other values for the\n   CreditAgingFactor and CreditAgingInterval\
    \ parameters in particular,\n   are for further study, and so are the advanced\
    \ CBA techniques\n   specified in [CBA-MIPv6].\n"
- title: 5.6.1.  Handling Payload Packets
  contents:
  - "5.6.1.  Handling Payload Packets\n   A host maintains a \"credit counter\" for\
    \ each of its peers.  Whenever\n   a packet arrives from a peer, the host SHOULD\
    \ increase that peer's\n   credit counter by the size of the received packet.\
    \  When the host has\n   a packet to be sent to the peer, and when the peer's\
    \ preferred\n   locator is listed as UNVERIFIED and no alternative locator with\n\
    \   status ACTIVE is available, the host checks whether it can send the\n   packet\
    \ to the UNVERIFIED locator.  The packet SHOULD be sent if the\n   value of the\
    \ credit counter is higher than the size of the outbound\n   packet.  If the credit\
    \ counter is too low, the packet MUST be\n   discarded or buffered until address\
    \ verification succeeds.  When a\n   packet is sent to a peer at an UNVERIFIED\
    \ locator, the peer's credit\n   counter MUST be reduced by the size of the packet.\
    \  The peer's credit\n   counter is not affected by packets that the host sends\
    \ to an ACTIVE\n   locator of that peer.\n   Figure 8 depicts the actions taken\
    \ by the host when a packet is\n   received.  Figure 9 shows the decision chain\
    \ in the event a packet is\n   sent.\n       Inbound\n       Packet\n        \
    \  |\n          |       +----------------+               +---------------+\n \
    \         |       |    Increase    |               |    Deliver    |\n       \
    \   +-----> | credit counter |-------------> |   packet to   |\n             \
    \     | by packet size |               |  application  |\n                  +----------------+\
    \               +---------------+\n        Figure 8: Receiving Packets with Credit-Based\
    \ Authorization\n    Outbound\n     Packet\n        |          _________________\n\
    \        |         /                 \\                 +---------------+\n  \
    \      |        /  Is the preferred \\       No       |  Send packet  |\n    \
    \    +-----> | destination address |-------------> |  to preferred |\n       \
    \          \\    UNVERIFIED?    /                |    address    |\n         \
    \         \\_________________/                 +---------------+\n           \
    \                |\n                           | Yes\n                       \
    \    |\n                           v\n                   _________________\n \
    \                 /                 \\                 +---------------+\n   \
    \              /   Does an ACTIVE  \\      Yes       |  Send packet  |\n     \
    \           | destination address |-------------> |   to ACTIVE   |\n        \
    \         \\       exist?      /                |    address    |\n          \
    \        \\_________________/                 +---------------+\n            \
    \               |\n                           | No\n                         \
    \  |\n                           v\n                   _________________\n   \
    \               /                 \\                 +---------------+\n     \
    \            / Is credit counter \\       No       |               |\n       \
    \         |          >=         |-------------> | Drop or       |\n          \
    \       \\    packet size?   /                | buffer packet |\n            \
    \      \\_________________/                 +---------------+\n              \
    \             |\n                           | Yes\n                          \
    \ |\n                           v\n                   +---------------+      \
    \            +---------------+\n                   | Reduce credit |         \
    \         |  Send packet  |\n                   |  counter by   |---------------->\
    \ | to preferred  |\n                   |  packet size  |                  | \
    \   address    |\n                   +---------------+                  +---------------+\n\
    \         Figure 9: Sending Packets with Credit-Based Authorization\n"
- title: 5.6.2.  Credit Aging
  contents:
  - "5.6.2.  Credit Aging\n   A host ensures that the credit counters it maintains\
    \ for its peers\n   gradually decrease over time.  Such \"credit aging\" prevents\
    \ a\n   malicious peer from building up credit at a very slow speed and using\n\
    \   this, all at once, for a severe burst of redirected packets.\n   Credit aging\
    \ may be implemented by multiplying credit counters with a\n   factor, CreditAgingFactor\
    \ (a fractional value less than one), in\n   fixed-time intervals of CreditAgingInterval\
    \ length.  Choosing\n   appropriate values for CreditAgingFactor and CreditAgingInterval\
    \ is\n   important to ensure that a host can send packets to an address in\n \
    \  state UNVERIFIED even when the peer sends at a lower rate than the\n   host\
    \ itself.  When CreditAgingFactor or CreditAgingInterval are too\n   small, the\
    \ peer's credit counter might be too low to continue sending\n   packets until\
    \ address verification concludes.\n   The parameter values proposed in this document\
    \ are as follows:\n      CreditAgingFactor        7/8\n      CreditAgingInterval\
    \      5 seconds\n   These parameter values work well when the host transfers\
    \ a file to\n   the peer via a TCP connection, and the end-to-end round-trip time\n\
    \   does not exceed 500 milliseconds.  Alternative credit-aging\n   algorithms\
    \ may use other parameter values or different parameters,\n   which may even be\
    \ dynamically established.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   The HIP mobility mechanism provides a secure\
    \ means of updating a\n   host's IP address via HIP UPDATE packets.  Upon receipt,\
    \ a HIP host\n   cryptographically verifies the sender of an UPDATE, so forging\
    \ or\n   replaying a HIP UPDATE packet is very difficult (see [RFC7401]).\n  \
    \ Therefore, security issues reside in other attack domains.  The two\n   we consider\
    \ are malicious redirection of legitimate connections as\n   well as redirection-based\
    \ flooding attacks using this protocol.  This\n   can be broken down into the\
    \ following:\n      1) Impersonation attacks\n         - direct conversation with\
    \ the misled victim\n         - man-in-the-middle (MitM) attack\n      2) Denial-of-service\
    \ (DoS) attacks\n         - flooding attacks (== bandwidth-exhaustion attacks)\n\
    \            * tool 1: direct flooding\n            * tool 2: flooding by botnets\n\
    \            * tool 3: redirection-based flooding\n         - memory-exhaustion\
    \ attacks\n         - computational-exhaustion attacks\n      3) Privacy concerns\n\
    \   We consider these in more detail in the following sections.\n   In Sections\
    \ 6.1 and 6.2, we assume that all users are using HIP.  In\n   Section 6.3, we\
    \ consider the security ramifications when we have both\n   HIP and non-HIP hosts.\n"
- title: 6.1.  Impersonation Attacks
  contents:
  - "6.1.  Impersonation Attacks\n   An attacker wishing to impersonate another host\
    \ will try to mislead\n   its victim into directly communicating with them or\
    \ carry out a MitM\n   attack between the victim and the victim's desired communication\n\
    \   peer.  Without mobility support, such attacks are possible only if\n   the\
    \ attacker resides on the routing path between its victim and the\n   victim's\
    \ desired communication peer or if the attacker tricks its\n   victim into initiating\
    \ the connection over an incorrect routing path\n   (e.g., by acting as a router\
    \ or using spoofed DNS entries).\n   The HIP extensions defined in this specification\
    \ change the situation\n   in that they introduce an ability to redirect a connection,\
    \ both\n   before and after establishment.  If no precautionary measures are\n\
    \   taken, an attacker could potentially misuse the redirection feature\n   to\
    \ impersonate a victim's peer from any arbitrary location.  However,\n   the authentication\
    \ and authorization mechanisms of the HIP base\n   exchange [RFC7401] and the\
    \ signatures in the UPDATE message prevent\n   this attack.  Furthermore, ownership\
    \ of a HIP association is securely\n   linked to a HIP HI/HIT.  If an attacker\
    \ somehow uses a bug in the\n   implementation to redirect a HIP connection, the\
    \ original owner can\n   always reclaim their connection (they can always prove\
    \ ownership of\n   the private key associated with their public HI).\n   MitM\
    \ attacks are possible if an on-path attacker is present during\n   the initial\
    \ HIP base exchange and if the hosts do not authenticate\n   each other's identities.\
    \  However, once such an opportunistic base\n   exchange has taken place, a MitM\
    \ attacker that comes later to the\n   path cannot steal the HIP connection because\
    \ it is very difficult for\n   an attacker to create an UPDATE packet (or any\
    \ HIP packet) that will\n   be accepted as a legitimate update.  UPDATE packets\
    \ use HMAC and are\n   signed.  Even when an attacker can snoop packets to obtain\
    \ the SPI\n   and HIT/HI, they still cannot forge an UPDATE packet without\n \
    \  knowledge of the secret keys.  Also, replay attacks on the UPDATE\n   packet\
    \ are prevented as described in [RFC7401].\n"
- title: 6.2.  Denial-of-Service Attacks
  contents:
  - '6.2.  Denial-of-Service Attacks

    '
- title: 6.2.1.  Flooding Attacks
  contents:
  - "6.2.1.  Flooding Attacks\n   The purpose of a DoS attack is to exhaust some resource\
    \ of the victim\n   such that the victim ceases to operate correctly.  A DoS attack\
    \ can\n   aim at the victim's network attachment (flooding attack), its memory,\n\
    \   or its processing capacity.  In a flooding attack, the attacker\n   causes\
    \ an excessive number of bogus or unwanted packets to be sent to\n   the victim,\
    \ which fills their available bandwidth.  Note that the\n   victim does not necessarily\
    \ need to be a node; it can also be an\n   entire network.  The attack functions\
    \ the same way in either case.\n   An effective DoS strategy is distributed denial\
    \ of service (DDoS).\n   Here, the attacker conventionally distributes some viral\
    \ software to\n   as many nodes as possible.  Under the control of the attacker,\
    \ the\n   infected nodes (e.g., nodes in a botnet) jointly send packets to the\n\
    \   victim.  With such an \"army\", an attacker can take down even very\n   high\
    \ bandwidth networks/victims.\n   With the ability to redirect connections, an\
    \ attacker could realize a\n   DDoS attack without having to distribute viral\
    \ code.  Here, the\n   attacker initiates a large download from a server and subsequently\n\
    \   uses the HIP mobility mechanism to redirect this download to its\n   victim.\
    \  The attacker can repeat this with multiple servers.  This\n   threat is mitigated\
    \ through reachability checks and CBA.  When\n   conducted using HIP, reachability\
    \ checks can leverage the built-in\n   authentication properties of HIP.  They\
    \ can also prevent redirection-\n   based flooding attacks.  However, the delay\
    \ of such a check can have\n   a noticeable impact on application performance.\
    \  To reduce the impact\n   of the delay, CBA can be used to send a limited number\
    \ of packets to\n   the new address while the validity of the IP address is still\
    \ in\n   question.  Both strategies do not eliminate flooding attacks per se,\n\
    \   but they preclude: (i) their use from a location off the path towards\n  \
    \ the flooded victim; and (ii) any amplification in the number and size\n   of\
    \ the redirected packets.  As a result, the combination of a\n   reachability\
    \ check and CBA lowers a HIP redirection-based flooding\n   attack to the level\
    \ of a direct flooding attack in which the attacker\n   itself sends the flooding\
    \ traffic to the victim.\n"
- title: 6.2.2.  Memory/Computational-Exhaustion DoS Attacks
  contents:
  - "6.2.2.  Memory/Computational-Exhaustion DoS Attacks\n   We now consider whether\
    \ or not the proposed extensions to HIP add any\n   new DoS attacks (consideration\
    \ of DoS attacks using the base HIP\n   exchange and updates is discussed in [RFC7401]).\
    \  A simple attack is\n   to send many UPDATE packets containing many IP addresses\
    \ that are not\n   flagged as preferred.  The attacker continues to send such\
    \ packets\n   until the number of IP addresses associated with the attacker's\
    \ HI\n   crashes the system.  Therefore, a HIP association SHOULD limit the\n\
    \   number of IP addresses that can be associated with any HI.  Other\n   forms\
    \ of memory/computationally exhausting attacks via the HIP UPDATE\n   packet are\
    \ handled in the base HIP document [RFC7401].\n   A central server that has to\
    \ deal with a large number of mobile\n   clients MAY consider increasing the SA\
    \ lifetimes to try to slow down\n   the rate of rekeying UPDATEs or increasing\
    \ the cookie difficulty to\n   slow down the rate of attack-oriented connections.\n"
- title: 6.3.  Mixed Deployment Environment
  contents:
  - "6.3.  Mixed Deployment Environment\n   We now assume an environment with hosts\
    \ that are both HIP and non-HIP\n   aware.  Four cases exist:\n   1.  A HIP host\
    \ redirects its connection onto a non-HIP host.  The\n       non-HIP host will\
    \ drop the reachability packet, so this is not a\n       threat unless the HIP\
    \ host is a MitM that could somehow respond\n       successfully to the reachability\
    \ check.\n   2.  A non-HIP host attempts to redirect their connection onto a HIP\n\
    \       host.  This falls into IPv4 and IPv6 security concerns, which are\n  \
    \     outside the scope of this document.\n   3.  A non-HIP host attempts to steal\
    \ a HIP host's session (assume\n       that Secure Neighbor Discovery is not active\
    \ for the following).\n       The non-HIP host contacts the service that a HIP\
    \ host has a\n       connection with and then attempts to change its IP address\
    \ to\n       steal the HIP host's connection.  What will happen in this case\n\
    \       is implementation dependent, but such a request should fail by\n     \
    \  being ignored or dropped.  Even if the attack were successful,\n       the\
    \ HIP host could reclaim its connection via HIP.\n   4.  A HIP host attempts to\
    \ steal a non-HIP host's session.  A HIP\n       host could spoof the non-HIP\
    \ host's IP address during the base\n       exchange or set the non-HIP host's\
    \ IP address as its preferred\n       address via an UPDATE.  Other possibilities\
    \ exist, but a solution\n       is to prevent the local redirection of sessions\
    \ that were\n       previously using an unverified address, but outside of the\n\
    \       existing HIP context, into the HIP SAs until the address change\n    \
    \   can be verified.\n"
- title: 6.4.  Privacy Concerns
  contents:
  - "6.4.  Privacy Concerns\n   The exposure of a host's IP addresses through HIP\
    \ mobility extensions\n   may raise privacy concerns.  The administrator of a\
    \ host may be\n   trying to hide its location in some context through the use\
    \ of a VPN\n   or other virtual interfaces.  Similar privacy issues also arise\
    \ in\n   other frameworks such as WebRTC and are not specific to HIP.\n   Implementations\
    \ SHOULD provide a mechanism to allow the host\n   administrator to block the\
    \ exposure of selected addresses or address\n   ranges.  While this issue may\
    \ be more relevant in a host multihoming\n   scenario in which multiple IP addresses\
    \ might be exposed [RFC8047],\n   it is worth noting also here that mobility events\
    \ might cause an\n   implementation to try to inadvertently use a locator that\
    \ the\n   administrator would rather avoid exposing to the peer host.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   [RFC5206], obsoleted by this document, specified\
    \ an allocation for a\n   LOCATOR parameter in the \"Parameter Types\" subregistry\
    \ of the \"Host\n   Identity Protocol (HIP) Parameters\" registry, with a type\
    \ value of\n   193.  IANA has renamed the parameter to \"LOCATOR_SET\" and has\
    \ updated\n   the reference from [RFC5206] to this specification.\n   [RFC5206],\
    \ obsoleted by this document, specified an allocation for a\n   LOCATOR_TYPE_UNSUPPORTED\
    \ type in the \"Notify Message Types\" registry,\n   with a type value of 46.\
    \  IANA has updated the reference from\n   [RFC5206] to this specification.\n"
- title: 8.  Differences from RFC 5206
  contents:
  - "8.  Differences from RFC 5206\n   This section summarizes the technical changes\
    \ made from [RFC5206].\n   This section is informational, intended to help implementors\
    \ of the\n   previous protocol version.  If any text in this section contradicts\n\
    \   text in other portions of this specification, the text found outside\n   of\
    \ this section should be considered normative.\n   This document specifies extensions\
    \ to the HIP Version 2 protocol,\n   while [RFC5206] specifies extensions to the\
    \ HIP Version 1 protocol.\n   [RFC7401] documents the differences between these\
    \ two protocol\n   versions.\n   [RFC5206] included procedures for both HIP host\
    \ mobility and basic\n   host multihoming.  In this document, only host mobility\
    \ procedures\n   are included; host multihoming procedures are now specified in\n\
    \   [RFC8047].  In particular, multihoming-related procedures related to\n   the\
    \ exposure of multiple locators in the base exchange packets; the\n   transmission,\
    \ reception, and processing of multiple locators in a\n   single UPDATE packet;\
    \ handovers across IP address families; and other\n   multihoming-related specifications\
    \ have been removed.\n   The following additional changes have been made:\n  \
    \ o  The LOCATOR parameter in [RFC5206] has been renamed to\n      LOCATOR_SET.\n\
    \   o  Specification text regarding the handling of mobility when both\n     \
    \ hosts change IP addresses at nearly the same time (a \"double-jump\"\n     \
    \ mobility scenario) has been added.\n   o  Specification text regarding the mobility\
    \ event in which the host\n      briefly has an active new locator and old locator\
    \ at the same time\n      (a \"make-before-break\" mobility scenario) has been\
    \ added.\n   o  Specification text has been added to note that a host may add\
    \ the\n      source IP address of a received HIP packet as a candidate locator\n\
    \      for the peer even if it is not listed in the peer's LOCATOR_SET,\n    \
    \  but that it should prefer locators explicitly listed in the\n      LOCATOR_SET.\n\
    \   o  This document clarifies that the HOST_ID parameter may be included\n  \
    \    in UPDATE messages containing LOCATOR_SET parameters, for the\n      possible\
    \ benefit of HIP-aware firewalls.\n   o  The previous specification mentioned\
    \ that it may be possible to\n      include multiple LOCATOR_SET and ESP_INFO\
    \ parameters in an UPDATE.\n      This document only specifies the case of a single\
    \ LOCATOR_SET and\n      ESP_INFO parameter in an UPDATE.\n   o  The previous\
    \ specification mentioned that it may be possible to\n      send LOCATOR_SET parameters\
    \ in packets other than the UPDATE.\n      This document only specifies the use\
    \ of the UPDATE packet.\n   o  This document describes a simple heuristic for\
    \ setting the credit\n      value for CBA.\n   o  This specification mandates\
    \ that a host must be able to receive\n      and avoid reprocessing redundant\
    \ LOCATOR_SET parameters that may\n      have been sent in parallel to multiple\
    \ addresses of the host.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC4291]  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n        \
    \      Architecture\", RFC 4291, DOI 10.17487/RFC4291, February\n            \
    \  2006, <http://www.rfc-editor.org/info/rfc4291>.\n   [RFC7401]  Moskowitz, R.,\
    \ Ed., Heer, T., Jokela, P., and T.\n              Henderson, \"Host Identity\
    \ Protocol Version 2 (HIPv2)\",\n              RFC 7401, DOI 10.17487/RFC7401,\
    \ April 2015,\n              <http://www.rfc-editor.org/info/rfc7401>.\n   [RFC7402]\
    \  Jokela, P., Moskowitz, R., and J. Melen, \"Using the\n              Encapsulating\
    \ Security Payload (ESP) Transport Format with\n              the Host Identity\
    \ Protocol (HIP)\", RFC 7402,\n              DOI 10.17487/RFC7402, April 2015,\n\
    \              <http://www.rfc-editor.org/info/rfc7402>.\n   [RFC8003]  Laganier,\
    \ J. and L. Eggert, \"Host Identity Protocol (HIP)\n              Registration\
    \ Extension\", RFC 8003, DOI 10.17487/RFC8003,\n              October 2016, <http://www.rfc-editor.org/info/rfc8003>.\n\
    \   [RFC8004]  Laganier, J. and L. Eggert, \"Host Identity Protocol (HIP)\n  \
    \            Rendezvous Extension\", RFC 8004, DOI 10.17487/RFC8004,\n       \
    \       October 2016, <http://www.rfc-editor.org/info/rfc8004>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [CBA-MIPv6]\n              Vogt, C. and J. Arkko,\
    \ \"Credit-Based Authorization for\n              Mobile IPv6 Early Binding Updates\"\
    , Work in Progress,\n              draft-vogt-mobopts-credit-based-authorization-00,\
    \ February\n              2005.\n   [RFC4225]  Nikander, P., Arkko, J., Aura,\
    \ T., Montenegro, G., and E.\n              Nordmark, \"Mobile IP Version 6 Route\
    \ Optimization Security\n              Design Background\", RFC 4225, DOI 10.17487/RFC4225,\n\
    \              December 2005, <http://www.rfc-editor.org/info/rfc4225>.\n   [RFC5206]\
    \  Nikander, P., Henderson, T., Ed., Vogt, C., and J. Arkko,\n              \"\
    End-Host Mobility and Multihoming with the Host Identity\n              Protocol\"\
    , RFC 5206, DOI 10.17487/RFC5206, April 2008,\n              <http://www.rfc-editor.org/info/rfc5206>.\n\
    \   [RFC5207]  Stiemerling, M., Quittek, J., and L. Eggert, \"NAT and\n      \
    \        Firewall Traversal Issues of Host Identity Protocol (HIP)\n         \
    \     Communication\", RFC 5207, DOI 10.17487/RFC5207, April\n              2008,\
    \ <http://www.rfc-editor.org/info/rfc5207>.\n   [RFC8047]  Henderson, T., Ed.,\
    \ Vogt, C., and J. Arkko, \"Host\n              Multihoming with the Host Identity\
    \ Protocol\", RFC 8047,\n              DOI 10.17487/RFC8047, February 2017,\n\
    \              <http://www.rfc-editor.org/info/rfc8047>.\n   [SIMPLE-CBA]\n  \
    \            Vogt, C. and J. Arkko, \"Credit-Based Authorization for\n       \
    \       Concurrent Reachability Verification\", Work in Progress,\n          \
    \    draft-vogt-mobopts-simple-cba-00, February 2006.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Pekka Nikander and Jari Arkko originated this document; Christian\n\
    \   Vogt and Thomas Henderson (editor) later joined as coauthors.  Greg\n   Perkins\
    \ contributed the initial text of the security section.  Petri\n   Jokela was\
    \ a coauthor of the initial individual submission.\n   CBA was originally introduced\
    \ in [SIMPLE-CBA], and portions of this\n   document have been adopted from that\
    \ earlier document.\n   The authors thank Jeff Ahrenholz, Baris Boyvat, Rene Hummen,\
    \ Miika\n   Komu, Mika Kousa, Jan Melen, and Samu Varjonen for improvements to\n\
    \   the document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Thomas R. Henderson (editor)\n   University of Washington\n\
    \   Campus Box 352500\n   Seattle, WA\n   United States of America\n   Email:\
    \ tomhend@u.washington.edu\n   Christian Vogt\n   Independent\n   3473 North First\
    \ Street\n   San Jose, CA  95134\n   United States of America\n   Email: mail@christianvogt.net\n\
    \   Jari Arkko\n   Ericsson\n   Jorvas,  FIN-02420\n   Finland\n   Phone: +358\
    \ 40 5079256\n   Email: jari.arkko@piuha.net\n"
