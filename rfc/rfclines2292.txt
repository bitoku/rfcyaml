Abstract Specifications are in progress for changes to the sockets API to support IP version 6 [RFC 2133].
These changes are for TCP and UDP  based applications and will support most end user applications in use today: Telnet and FTP clients and servers, HTTP clients and servers, and the like.
But another class of applications exists that will also be run under IPv6.
We call these "advanced" applications and today this includes programs such as Ping, Traceroute, routing daemons, multicast routing daemons, router discovery daemons, and the like.
The API feature typically used by these programs that make them "advanced" is a raw socket to access ICMPv4, IGMPv4, or IPv4, along with some knowledge of the packet header formats used by these protocols.
To provide portability for applications that use raw sockets under IPv6, some standardization is needed for the advanced API features.
There are other features of IPv6 that some applications will need to access:
interface identification (specifying the outgoing interface and determining the incoming interface) and IPv6 extension headers that are not addressed in [RFC 2133]:
Hop by Hop options, Destination options, and the Routing header (source routing).
This document provides API access to these features too.
Introduction Specifications are in progress for changes to the sockets API to support IP version 6 [RFC 2133].
These changes are for TCP and UDP  based applications.
The current document defines some the "advanced" features of the sockets API that are required for applications to take advantage of additional features of IPv6.
Today, the portability of applications using IPv4 raw sockets is quite high, but this is mainly because most IPv4 implementations started from a common base (the Berkeley source code) or at least started with the Berkeley headers.
This allows programs such as Ping and Traceroute, for example, to compile with minimal effort on many hosts that support the sockets API.
With IPv6, however, there is no common source code base that implementors are starting from, and
the possibility for divergence at this level between different implementations is high.
To avoid a complete lack of portability amongst applications that use raw IPv6 sockets, some standardization is necessary.
There are also features from the basic IPv6 specification that are not addressed in [RFC 2133]: sending and receiving Hop by Hop options, Destination options, and Routing headers, specifying the outgoing interface, and being told of the receiving interface.
This document can be divided into the following main sections.
Definitions of the basic constants and structures required for applications to use raw IPv6 sockets.
This includes structure definitions for the IPv6 and ICMPv6 headers and all associated constants (e.g., values for the Next Header field).
Some basic semantic definitions for IPv6 raw sockets.
For example, a raw ICMPv4 socket requires the application to calculate and store the ICMPv4 header checksum.
But with IPv6 this would require the application to choose the source IPv6 address because the source address is part of the pseudo header that ICMPv6 now uses for its checksum computation.
It should be defined that with a raw ICMPv6 socket the kernel always calculates and stores the ICMPv6 header checksum.
how applications can obtain the received interface, destination address, and received hop limit, along with specifying these values on a per packet basis.
There are a class of applications that need this capability and the technique should be portable.
Access to the optional Hop by Hop, Destination, and Routing headers.
Additional features required for IPv6 application portability.
The packet information along with access to the extension headers (Hop by Hop options, Destination options, and Routing header) are specified using the "ancillary data" fields that were added to the 4.3BSD Reno sockets API in 1990.
The reason is that these ancillary data fields are part of the Posix.1g standard (which should be approved in 1997) and should therefore be adopted by most vendors.
This document does not address application access to either the authentication header or the encapsulating security payload header.
All examples in this document omit error checking in favor of brevity and clarity.
We note that many of the functions and socket options defined in this document may have error returns that are not defined in this document.
Many of these possible error returns will be recognized only as implementations proceed.
Datatypes in this document follow the Posix.1g format: intN t means a signed integer of exactly N bits (e.g., int16 t) and uintN t means an unsigned integer of exactly N bits (e.g., uint32 t).
Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and ARPv4 to avoid any confusion with the newer ICMPv6 protocol.
Many advanced applications examine fields in the IPv6 header and set and examine fields in the various ICMPv6 headers.
Common structure definitions for these headers are required, along with common constant definitions for the structure members.
Two new headers are defined: <netinet/ip6.h> and <netinet
When an include file is specified, that include file is allowed to include other files that do the actual declaration or definition.
The following structure is defined as a result of including <netinet/ip6.h
Note that this is a new header.
un1 nxt #define ip6 hlim
ip6 ctlun.ip6 un1.ip6 un1 hlim 2.1.1.
IPv6 defines many new values for the Next Header field.
The following constants are defined as a result of including <netinet/in.h>.
41 /  IPv6 header  /
50 /  encapsulating security payload  /
51 /  authentication header  /
IPv6 Destination options  / Berkeley derived IPv4 implementations also define IPPROTO IP to be 0.
This should not be a problem since IPPROTO IP is used only with IPv4 sockets and IPPROTO HOPOPTS only with IPv6 sockets.
Headers Six extension headers are defined for IPv6.
We define structures for all except the Authentication header and Encapsulating Security Payload header, both of which are beyond the scope of this document.
The following structures are defined as a result of including <netinet/ip6.h>. /
XXX should we pad it to force alignment on an 8 byte boundary?
ip6 hbh { uint8 t
should we pad it to force alignment on an 8 byte boundary?
/ struct ip6 dest { uint8 t
strict/loose bit map  / struct in6 addr  ip6r0 addr[1]
/  mask out offset from  offlg  /
/  reserved bits in ip6f offlg  /
/  more fragments flag  /
/  mask out offset from  offlg  /
/  reserved bits in ip6f offlg  /
/  more fragments flag  /
#endif Defined constants for fields larger than 1 byte depend on the byte ordering that is used.
This API assumes that the fields in the protocol headers are left in the network byte order, which is big  endian for the Internet protocols.
If not, then either these constants or the fields being tested must be converted at run time, using something like htons() or htonl().
(Note: We show an implementation that supports both big endian and little endian byte ordering, assuming a hypothetical compile time #if test to determine the byte ordering.
The constant that we show, BYTE ORDER, with values of BIG ENDIAN and LITTLE ENDIAN, are for example purposes only.
If an implementation runs on only one type of hardware it need only define the set of constants for that hardware's byte ordering.)
The ICMPv6 header is needed by numerous IPv6 applications including Ping, Traceroute, router discovery daemons, and neighbor discovery daemons.
The following structure is defined as a result of including <netinet/icmp6.h
Note that this is a new header.
In addition to a common structure for the ICMPv6 header, common definitions are required for the ICMPv6 type and code fields.
The following constants are also defined as a result of including <netinet/icmp6.h>.
/  no route to destination  /
4 /  bad port  /
/  erroneous header field  /
1 /  unrecognized Next Header  /
2 /  unrecognized IPv6 option  /
The five ICMP message types defined by IPv6 neighbor discovery (133  137) are defined in the next section.
ICMPv6 Neighbor Discovery Type and Code Values
The following structures and definitions are defined as a result of including <netinet/icmp6.h>.
135 #define ND NEIGHBOR ADVERT
/ struct icmp6 hdr  nd ra hdr;
nd ra hdr.icmp6 cksum #define
neighbor advertisement  / struct icmp6 hdr  nd na hdr; struct in6 addr   nd na target; /
#define ND NA FLAG SOLICITED
#define ND NA FLAG SOLICITED
nd rd hdr.icmp6 cksum #define
/ uint8 t  nd opt type;
2 #define  ND OPT PREFIX INFORMATION
nd opt pi type; uint8 t   nd opt pi len; uint8 t
nd opt pi prefix len; uint8 t   nd opt pi flags reserved;
uint32 t  nd opt pi valid time;
uint32 t  nd opt pi preferred time;
; uint8 t   nd opt rh len;
nd opt mtu len; uint16
The basic API ([RFC 2133]) defines some macros for testing an IPv6 address for certain properties.
This API extends those definitions with additional address testing macros, defined as a result of including <netinet/in.h>.
Many hosts provide the file /etc/protocols that contains the names of the various IP protocols and their protocol number (e.g., the value of the protocol field in the IPv4 header for that protocol, such as 1 for ICMP).
Some programs then call the function getprotobyname() to obtain the protocol value that is then specified as the third argument to the socket() function.
For example, the Ping program contains code of the form
struct protoent   proto; proto   getprotobyname("icmp"); s   socket(AF INET, SOCK RAW, proto p proto); Common names are required for the new IPv6 protocols in this file, to provide portability of applications that call the getprotoXXX() functions.
We define the following protocol names with the values shown.
These are taken from ftp://ftp.isi.edu/in notes/iana/assignments/protocol  numbers.
# fragment header for ipv6 esp
# encapsulating security payload for ipv6
# authentication header for ipv6 ipv6 icmp
Raw Sockets Raw sockets bypass the transport layer (TCP or UDP).
With IPv4, raw sockets are used to access ICMPv4, IGMPv4, and to read and write IPv4 datagrams containing a protocol field that the kernel does not process.
An example of the latter is a routing daemon for OSPF, since it uses IPv4 protocol field 89.
With IPv6 raw sockets will be used for ICMPv6 and to read and write IPv6 datagrams containing a Next Header field that the kernel does not process.
Examples of the latter are a routing daemon for OSPF for IPv6 and RSVP (protocol field 46).
All data sent via raw sockets MUST be in network byte order and all data received via raw sockets will be in network byte order.
This differs from the IPv4 raw sockets, which did not specify a byte ordering and typically used the host's byte order.
Another difference from IPv4 raw sockets is that complete packets (that is, IPv6 packets with extension headers) cannot be read or written using the IPv6 raw sockets API.
Instead, ancillary data objects are used to transfer the extension headers, as described later in this document.
Should an application need access to the complete IPv6 packet, some other technique, such as the datalink interfaces BPF or DLPI, must be used.
All fields in the IPv6 header that an application might want to change (i.e., everything other than the version number) can be modified using ancillary data and/or socket options by the application for output.
All fields in a received IPv6 header (other than the version number and Next Header fields) and all extension headers are also made available to the application as ancillary data on input.
Hence there is no need for a socket option similar to the IPv4 IP HDRINCL socket option.
When writing to a raw socket the kernel will automatically fragment the packet if its size exceeds the path MTU, inserting the required fragmentation headers.
On input the kernel reassembles received fragments, so the reader of a raw socket never sees any fragment headers.
When we say "an ICMPv6 raw socket" we mean a socket created by calling the socket function with the three arguments PF INET6, SOCK RAW, and IPPROTO ICMPV6.
Most IPv4 implementations give special treatment to a raw socket created with a third argument to socket() of IPPROTO RAW, whose value is normally 255.
We note that this value has no special meaning to an IPv6 raw socket (and the IANA currently reserves the value of 255 when used as a next header field).
(Note: This feature was added to IPv4 in 1988 by Van Jacobson to support traceroute, allowing a complete IP header to be passed by the application, before the IP HDRINCL socket option was added.)
The kernel will calculate and insert the ICMPv6 checksum for ICMPv6 raw sockets, since this checksum is mandatory.
For other raw IPv6 sockets (that is, for raw IPv6 sockets created with a third argument other than IPPROTO ICMPV6), the application must set the new IPV6 CHECKSUM socket option to have the kernel (1) compute and store a checksum for output, and (2) verify the received checksum on input, discarding the packet if the checksum is in error.
This option prevents applications from having to perform source address selection on the packets they send.
The checksum will incorporate the IPv6 pseudo header, defined in Section 8.1 of [RFC  1883].
This new socket option also specifies an integer offset into the user data of where the checksum is located.
offset   2; setsockopt(fd, IPPROTO IPV6, IPV6 CHECKSUM, &offset, sizeof(offset)); By default, this socket option is disabled.
Setting the offset to  1 also disables the option.
By disabled we mean (1) the kernel will not calculate and store a checksum for outgoing packets, and (2) the kernel will not verify a checksum for received packets.
(Note: Since the checksum is always calculated by the kernel for an ICMPv6 socket, applications are not able to generate ICMPv6 packets with incorrect checksums (presumably for testing purposes) using this API.
Type Filtering ICMPv4 raw sockets receive most ICMPv4 messages received by the kernel.
(We say "most" and not "all" because Berkeley derived kernels never pass echo requests, timestamp requests, or address mask requests to a raw socket.
Instead these three messages are processed entirely by the kernel.)
But ICMPv6 is a superset of ICMPv4, also including the functionality of IGMPv4 and ARPv4.
This means that an ICMPv6 raw socket can potentially receive many more messages than would be received with an ICMPv4 raw socket: ICMP messages similar to ICMPv4, along with neighbor solicitations, neighbor advertisements, and the three group membership messages.
Most applications using an ICMPv6 raw socket care about only a small subset of the ICMPv6 message types.
To transfer extraneous ICMPv6 messages from the kernel to user can incur a significant overhead.
Therefore this API includes a method of filtering ICMPv6 messages by the ICMPv6 type field.
Each ICMPv6 raw socket has an associated filter whose datatype is defined as struct icmp6 filter; This structure, along with the macros and constants defined later in this section, are defined as a result of including the <netinet/icmp6.h> header.
The current filter is fetched and stored using getsockopt() and setsockopt() with a level of IPPROTO ICMPV6 and an option name of ICMP6 FILTER.
Six macros operate on an icmp6 filter structure
: void ICMP6 FILTER SETPASSALL (struct icmp6 filter  );
The pointer argument to all six macros is a pointer to a filter that is modified by the first four macros examined by the last two macros.
The first two macros, SETPASSALL and SETBLOCKALL, let us specify that all ICMPv6 messages are passed to the application or that all ICMPv6 messages are blocked from being passed to the application.
The next two macros, SETPASS and SETBLOCK, let us specify that messages of a given ICMPv6 type should be passed to the application or not passed to the application (blocked).
The final two macros, WILLPASS and WILLBLOCK, return true or false depending whether the specified message type is passed to the application or blocked from being passed to the application by the filter pointed to by the second argument.
When an ICMPv6 raw socket is created, it will by default pass all ICMPv6 message types to the application.
As an example, a program that wants to receive only router advertisements could execute the following: struct icmp6 filter  myfilt; fd   socket(PF INET6, SOCK RAW, IPPROTO ICMPV6); ICMP6 FILTER SETBLOCKALL(&myfilt); ICMP6 FILTER SETPASS(ND ROUTER ADVERT, &myfilt); setsockopt(fd, IPPROTO ICMPV6, ICMP6 FILTER, &myfilt, sizeof(myfilt)); The filter structure is declared and then initialized to block all messages types.
The filter structure is then changed to allow router advertisement messages to be passed to the application and the filter is installed using setsockopt().
The icmp6 filter structure is similar to the fd set datatype used with the select() function in the sockets API.
The icmp6 filter structure is an opaque datatype and the application should not care how it is implemented.
All the application does with this datatype is allocate a variable of this type, pass a pointer to a variable of this type to getsockopt() and setsockopt(), and operate on a variable of this type using the six macros that we just defined.
Nevertheless, it is worth showing a simple implementation of this datatype and the six macros.
struct icmp6 filter { uint32 t  icmp6 filt[8];
#define ICMP6 FILTER WILLBLOCK(type, filterp)
memset((filterp), 0xFF, sizeof(struct icmp6 filter))
memset((filterp), 0, sizeof(struct icmp6 filter))
These sample definitions have two limitations that an implementation may want to change.
The first four macros evaluate their first argument two times.
The second two macros require the inclusion of the <string.h> header for the memset() function.)
Ancillary Data 4.2BSD allowed file descriptors to be transferred between separate processes across a UNIX domain socket using the sendmsg() and recvmsg() functions.
Two members of the msghdr structure, msg accrights and msg accrightslen, were used to send and receive the descriptors.
When the OSI protocols were added to 4.3BSD Reno in 1990
the names of these two fields in the msghdr structure were changed to msg control and msg controllen, because they were used by the OSI protocols for "control information", although the comments in the source code call this "ancillary data".
Other than the OSI protocols, the use of ancillary data has been rare.
In 4.4BSD, for example, the only use of ancillary data with IPv4 is to return the destination address of a received UDP datagram if the IP RECVDSTADDR socket option is set.
With Unix domain sockets ancillary data is still used to send and receive descriptors.
Nevertheless the ancillary data fields of the msghdr structure provide a clean way to pass information in addition to the data that is being read or written.
The inclusion of the msg control and msg controllen members of the msghdr structure along with the cmsghdr structure that is pointed to by the msg control member is required by the Posix.1g sockets API standard (which should be completed during 1997).
In this document ancillary data is used to exchange the following optional information between the application and the kernel: 1.
the send/receive interface and source/destination address, 2.
Hop by Hop options, 5.
Before describing these uses in detail, we review the definition of the msghdr structure itself, the cmsghdr structure that defines an ancillary data object, and some functions that operate on the ancillary data objects.
The msghdr structure is used by the recvmsg() and sendmsg() functions.
Earlier drafts of Posix.1g had the two socklen t members as size t, but Draft 6.6 of Posix.1g, apparently the final draft, changed these to socklen t to simplify binary portability for 64 bit implementations and to align Posix.1g with X/Open's Networking Services, Issue 5.
The change in msg control to a "void  " pointer
affects any code that increments this pointer.)
Most Berkeley derived implementations limit the amount of ancillary data in a call to sendmsg() to no more than 108 bytes (an mbuf).
This API requires a minimum of 10240 bytes of ancillary data, but it is recommended that the amount be limited only by the buffer space reserved by the socket (which can be modified by the SO SNDBUF socket option).
(Note: This magic number 10240 was picked as a value that should always be large enough.
108 bytes is clearly too small as the maximum size of a Type 0 Routing header is 376 bytes.)
The cmsghdr structure describes ancillary data objects transferred by recvmsg() and sendmsg().
As shown in this definition, normally there is no member with the name cmsg data[].
Instead, the data portion is accessed using the CMSG xxx()
Nevertheless, it is common to refer to the cmsg data[] member.
(Note: Before Posix.1g the cmsg len member was an integer, and not a socklen t.
See the Note in the previous section for why socklen t is used here.)
When ancillary data is sent or received, any number of ancillary data objects can be specified by the msg control and msg controllen members of the msghdr structure, because each object is preceded by a cmsghdr structure defining the object's length (the cmsg len member).
Historically Berkeley derived implementations have passed only one object at a time, but this API allows multiple objects to be passed in a single call to sendmsg() or recvmsg().
The following example shows two ancillary data objects in a control buffer.
len   level type  XX cmsg data[] XX len   level type  XX cmsg data
The fields shown as "XX" are possible padding, between the cmsghdr structure and the data, and between the data and the next cmsghdr structure, if required by the implementation.
To aid in the manipulation of ancillary data objects, three macros from 4.4BSD are defined by Posix.1g:
CMSG DATA(), CMSG NXTHDR(), and CMSG FIRSTHDR().
Before describing these macros, we show the following example of how they might be used with a call to recvmsg().
struct msghdr   msg; struct cmsghdr
; cmsgptr   CMSG NXTHDR(&msg, cmsgptr))
} We now describe the three Posix.1g macros, followed by two more that are new with this API: CMSG SPACE() and CMSG LEN().
All these macros are defined as a result of including <sys/socket.h
CMSG FIRSTHDR(const struct msghdr  mhdr); CMSG FIRSTHDR() returns a pointer to the first cmsghdr structure in the msghdr structure pointed to by mhdr.
The macro returns NULL if there is no ancillary data pointed to the by msghdr structure
(that is, if either msg control is NULL or if msg controllen is less than the size of a cmsghdr structure).
One possible implementation could be #
msg controllen >  sizeof(struct cmsghdr) ?
Most existing implementations do not test the value of msg controllen, and just return the value of msg control.
The value of msg controllen must be tested, because if the application asks recvmsg() to return ancillary data, by setting msg control to point to the application's buffer and setting msg controllen to the length of this buffer, the kernel indicates that no ancillary data is available by setting msg controllen to 0 on return.
It is also easier to put this test into this macro, than making the application perform the test.)
CMSG NXTHDR struct cmsghdr  CMSG NXTHDR(const struct msghdr  mhdr, const struct cmsghdr  cmsg); CMSG NXTHDR()
returns a pointer to the cmsghdr structure describing the next ancillary data object.
mhdr is a pointer to a msghdr structure and cmsg is a pointer to a cmsghdr structure.
If there is not another ancillary data object, the return value is NULL.
The following behavior of this macro is new to this API: if the value of the cmsg pointer is NULL, a pointer to the cmsghdr structure describing the first ancillary data object is returned.
CMSG NXTHDR(mhdr, NULL) is equivalent to CMSG FIRSTHDR(mhdr).
If there are no ancillary data objects, the return value is NULL.
This provides an alternative way of coding the processing loop shown earlier: struct msghdr  msg; struct cmsghdr
The macro ALIGN(), which is implementation dependent, rounds its argument up to the next even multiple of whatever alignment is required (probably a multiple of 4 or 8 bytes).
CMSG DATA(const struct cmsghdr  cmsg); CMSG DATA() returns a pointer to the data (what is called the cmsg data[] member, even though such a member is not defined in the structure) following a cmsghdr structure.
One possible implementation could be: #define CMSG DATA(cmsg)
CMSG SPACE unsigned int CMSG
SPACE(unsigned int length); This macro is new with this API.
Given the length of an ancillary data object, CMSG SPACE() returns the space required by the object and its cmsghdr structure, including any padding needed to satisfy alignment requirements.
This macro can be used, for example, to allocate space dynamically for the ancillary data.
This macro should not be used to initialize the cmsg len member of a cmsghdr structure; instead use the CMSG LEN() macro.
One possible implementation could be: #define CMSG SPACE(length)
CMSG LEN unsigned int CMSG
LEN(unsigned int length); This macro is new with this API.
Given the length of an ancillary data object, CMSG LEN() returns the value to store in the cmsg len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.
One possible implementation could be: #define CMSG LEN(length)
Note the difference between CMSG SPACE() and CMSG LEN(), shown also in the figure in Section 4.2: the former accounts for any required padding at the end of the ancillary data object and the latter is the actual length to store in the cmsg len member of the ancillary data object.
Summary of Options Described Using Ancillary Data
There are six types of optional information described in this document that are passed between the application and the kernel using ancillary data: 1.
the send/receive interface and source/destination address, 2.
Hop by Hop options, 5.
Nothing special need be done to send any of this optional information; the application just calls sendmsg() and specifies one or more ancillary data objects as control information.
once IPPROTO IPV6  IPV6 HOPLIMIT
once IPPROTO IPV6  IPV6 NEXTHOP   socket address structure
IPPROTO IPV6  IPV6 HOPOPTS   implementation dependent  mult.
once The final column indicates how many times an ancillary data object of that type can appear as control information.
The Hop by Hop and Destination options can appear multiple times, while all the others can appear only one time.
All these options are described in detail in following sections.
All the constants beginning with IPV6  are defined as a result of including the <netinet/in.h> header.
(Note: We intentionally use the same constant for the cmsg level member as is used as the second argument to getsockopt() and setsockopt() (what is called the "level"), and the same constant for the cmsg type member as is used as the third argument to getsockopt() and setsockopt() (what is called the "option name").
This is consistent with the existing use of ancillary data in 4.4BSD: returning the destination address of an IPv4 datagram.)
(Note: It is up to the implementation what it passes as ancillary data for the Hop by Hop option, Destination option, and Routing header option, since the API to these features is through a set of inet6 option XXX() and inet6 rthdr XXX() functions that we define later.
These functions serve two purposes: to simplify the interface to these features (instead of requiring the application to know the intimate details of the extension header formats), and to hide the actual implementation from the application.
Nevertheless, we show some examples of these features that store the actual extension header as the ancillary data.
Implementations need not use this technique.)
The summary in the previous section assumes a UDP socket.
Sending and receiving ancillary data is easy with UDP: the application calls sendmsg() and recvmsg() instead of sendto() and recvfrom().
But there might be cases where a TCP application wants to send or receive this optional information.
For example, a TCP client might want to specify a Routing header and this needs to be done before calling connect().
Similarly a TCP server might want to know the received interface after accept
() returns along with any Destination options.
A new socket option is defined that provides access to the optional information described in the previous section, but without using recvmsg() and sendmsg().
Setting the socket option specifies any of the optional output fields: setsockopt(fd, IPPROTO IPV6, IPV6 PKTOPTIONS, &buf, len); The fourth argument points to a buffer containing one or more ancillary data objects, and the fifth argument is the total length of all these objects.
The application fills in this buffer exactly as if the buffer were being passed to sendmsg() as control information.
The options set by calling setsockopt() for IPV6 PKTOPTIONS are called "sticky" options because once set they apply to all packets sent on that socket.
The application can call setsockopt() again to change all the sticky options, or it can call setsockopt() with a length of 0 to remove all the sticky options for the socket.
The corresponding receive option getsockopt(fd, IPPROTO IPV6, IPV6 PKTOPTIONS, &buf, &len); returns a buffer with one or more ancillary data objects for all the optional receive information that the application has previously specified that it wants to receive.
The fourth argument points to the buffer that is filled in by the call.
The fifth argument is a pointer to a value result integer: when the function is called the integer specifies the size of the buffer pointed to by the fourth argument, and on return this integer contains the actual number of bytes that were returned.
The application processes this buffer exactly as if the buffer were returned by recvmsg() as control information.
To simplify this document, in the remaining sections when we say "can be specified as ancillary data to sendmsg()" we mean "can be specified as ancillary data to sendmsg() or specified as a sticky option using setsockopt() and the IPV6 PKTOPTIONS socket option".
Similarly when we say "can be returned as ancillary data by recvmsg()" we mean "can be returned as ancillary data by recvmsg() or returned by getsockopt() with the IPV6 PKTOPTIONS socket option".
When using getsockopt() with the IPV6 PKTOPTIONS option and a TCP socket, only the options from the most recently received segment are retained and returned to the caller, and only after the socket option has been set.
That is, TCP need not start saving a copy of the options until the application says to do so.
The application is not allowed to specify ancillary data in a call to sendmsg() on a TCP socket, and none of the ancillary data that we describe in this document is ever returned as control information by recvmsg() on a TCP socket.
The IPV6 PKTOPTIONS socket option can also be used with a UDP socket or with a raw IPv6 socket, normally to set some of the options once, instead of with each call to sendmsg().
Unlike the TCP case, the sticky options can be overridden on a per  packet basis with ancillary data specified in a call to sendmsg() on a UDP or raw IPv6 socket.
If any ancillary data is specified in a call to sendmsg(), none of the sticky options are sent with that datagram.
There are four pieces of information that an application can specify for an outgoing packet using ancillary data: 1.
the source IPv6 address, 2.
the outgoing interface index, 3.
the outgoing hop limit, and 4.
Three similar pieces of information can be returned for a received packet as ancillary data: 1.
the destination IPv6 address, 2.
the arriving interface index, and 3.
The first two pieces of information are contained in an in6 pktinfo structure that is sent as ancillary data with sendmsg() and received as ancillary data with recvmsg().
This structure is defined as a result of including the <netinet/in.h> header.
; In the cmsghdr structure containing this ancillary data, the cmsg level member will be IPPROTO IPV6, the cmsg type member will be IPV6 PKTINFO, and the first byte of cmsg data[] will be the first byte of the in6 pktinfo structure.
This information is returned as ancillary data by recvmsg() only if the application has enabled the IPV6 PKTINFO socket option:
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 PKTINFO, &on, sizeof(on)); Nothing special need be done to send this information: just specify the control information as ancillary data for sendmsg().
(Note: The hop limit is not contained in the in6 pktinfo structure for the following reason.
Some UDP servers want to respond to client requests by sending their reply out the same interface on which the request was received and with the source IPv6 address of the reply equal to the destination IPv6 address of the request.
To do this the application can enable just the IPV6 PKTINFO socket option and then use the received control information from recvmsg() as the outgoing control information for sendmsg().
The application need not examine or modify the in6 pktinfo structure at all.
But if the hop limit were contained in this structure, the application would have to parse the received control information and change the hop limit member, since the received hop limit is not the desired value for an outgoing packet.)
/Receiving the Interface Interfaces on an IPv6 node are identified by a small positive integer, as described in Section 4 of [RFC 2133].
That document also describes a function to map an interface name to its interface index, a function to map an interface index to its interface name, and a function to return all the interface names and indexes.
Notice from this document that no interface is ever assigned an index of 0.
When specifying the outgoing interface, if the ipi6 ifindex value is 0, the kernel will choose the outgoing interface.
If the application specifies an outgoing interface for a multicast packet, the interface specified by the ancillary data overrides any interface specified by the IPV6 MULTICAST IF socket option (described in [RFC 2133]), for that call to sendmsg() only.
When the IPV6 PKTINFO socket option is enabled, the received interface index is always returned as the ipi6 ifindex member of the in6 pktinfo structure.
The source IPv6 address can be specified by calling bind() before each output operation, but supplying the source address together with the data requires less overhead (i.e., fewer system calls) and requires less state to be stored and protected in a multithreaded application.
When specifying the source IPv6 address as ancillary data, if the ipi6 addr member of the in6 pktinfo structure is the unspecified address (IN6ADDR ANY INIT), then (a) if an address is currently bound to the socket, it is used as the source address, or (b) if no address is currently bound to the socket, the kernel will choose the source address.
If the ipi6 addr member is not the unspecified address, but the socket has already bound a source address, then the ipi6 addr value overrides the already bound source address for this output operation only.
The kernel must verify that the requested source address is indeed a unicast address assigned to the node.
When the in6 pktinfo structure is returned as ancillary data by recvmsg(), the ipi6 addr member contains the destination IPv6 address from the received packet.
The outgoing hop limit is normally specified with either the IPV6 UNICAST HOPS socket option or the IPV6 MULTICAST HOPS socket option, both of which are described in [RFC 2133].
Specifying the hop limit as ancillary data lets the application override either the kernel's default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation.
Returning the received hop limit is useful for programs such as Traceroute and for IPv6 applications that need to verify that the received hop limit is 255 (e.g., that the packet has not been forwarded).
The received hop limit is returned as ancillary data by recvmsg() only if the application has enabled the IPV6 HOPLIMIT socket option:
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 HOPLIMIT, &on, sizeof(on)); In the cmsghdr structure containing this ancillary data, the cmsg level member will be IPPROTO IPV6, the cmsg type member will be IPV6 HOPLIMIT, and the first byte of cmsg data[] will be the first byte of the integer hop limit.
Nothing special need be done to specify the outgoing hop limit: just specify the control information as ancillary data for sendmsg().
As specified in [RFC 2133], the interpretation of the integer hop limit value is x <  1:
return an error of EINVAL x    1:
return an error of EINVAL 5.4.
Specifying the Next Hop Address
The IPV6 NEXTHOP ancillary data object specifies the next hop for the datagram as a socket address structure.
In the cmsghdr structure containing this ancillary data, the cmsg level member will be IPPROTO IPV6, the cmsg type member will be IPV6 NEXTHOP, and the first byte of cmsg data[] will be the first byte of the socket address structure.
This is a privileged option.
(Note: It is implementation defined and beyond the scope of this document to define what "privileged" means.
Unix systems use this term to mean the process must have an effective user ID of 0.)
If the socket address structure contains an IPv6 address (e.g., the sin6 family member is AF INET6), then the node identified by that address must be a neighbor of the sending host.
If that address equals the destination IPv6 address of the datagram, then this is equivalent to the existing SO DONTROUTE socket option.
With the IPV6 PKTINFO socket option there are no additional errors possible with the call to recvmsg().
But when specifying the outgoing interface or the source address, additional errors are possible from sendmsg().
The interface specified by ipi6 ifindex is not enabled for IPv6 use.
EADDRNOTAVAIL ipi6 ifindex specifies an interface but the address ipi6 addr is not available for use on that interface.
No route to the destination exists over the interface specified by ifi6 ifindex.
A variable number of Hop by Hop options can appear in a single Hop  by Hop options header.
Each option in the header is TLV encoded with a type, length, and value.
Today only three Hop by Hop options are defined for IPv6 [RFC 1883]: Jumbo Payload, Pad1, and PadN, although a proposal exists for a router alert Hop by Hop option.
The Jumbo Payload option should not be passed back to an application and an application should receive an error if it attempts to set it.
This option is processed entirely by the kernel.
It is indirectly specified by datagram based applications as the size of the datagram to send and indirectly passed back to these applications as the length of the received datagram.
The two pad options are for alignment purposes and are automatically inserted by a sending kernel when needed and ignored by the receiving kernel.
This section of the API is therefore defined for future Hop by Hop options that an application may need to specify and receive.
Individual Hop by Hop options (and Destination options, which are described shortly, and which are similar to the Hop by Hop options) may have specific alignment requirements.
For example, the 4 byte Jumbo Payload length should appear on a 4 byte boundary, and IPv6 addresses are normally aligned on an 8 byte boundary.
These requirements and the terminology used with these options are discussed in Section 4.2 and Appendix A of [RFC 1883].
The alignment of each option is specified by two values, called x and y, written as "xn   y".
This states that the option must appear at an integer multiple of x bytes from the beginning of the options header
(x can have the values 1, 2, 4, or 8), plus y bytes (y can have a value between 0 and 7, inclusive).
The Pad1 and PadN options are inserted as needed to maintain the required alignment.
Whatever code builds either a Hop by Hop options header or a Destination options header must know the values of x and y for each option.
Multiple Hop by Hop options can be specified by the application.
Normally one ancillary data object describes all the Hop by Hop options (since each option is itself TLV encoded) but the application can specify multiple ancillary data objects for the Hop by Hop options, each object specifying one or more options.
Care must be taken designing the API for these options since 1.
it may be possible for some future Hop by Hop options to be generated by the application and processed entirely by the application (e.g., the kernel may not know the alignment restrictions for the option), 2.
it must be possible for the kernel to insert its own Hop by Hop options in an outgoing packet (e.g., the Jumbo Payload option), 3.
the application can place one or more Hop by Hop options into a single ancillary data object, 4.
if the application specifies multiple ancillary data objects, each containing one or more Hop by Hop options, the kernel must combine these a single Hop by Hop options header, and 5.
it must be possible for the kernel to remove some Hop by Hop options from a received packet before returning the remaining Hop by Hop options to the application.
(This removal might consist of the kernel converting the option into a pad option of the same length.)
Finally, we note that access to some Hop by Hop options or to some Destination options, might require special privilege.
That is, normal applications (without special privilege) might be forbidden from setting certain options in outgoing packets, and might never see certain options in received packets.
Receiving Hop by Hop Options To receive Hop by Hop options
the application must enable the IPV6 HOPOPTS socket option:
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 HOPOPTS, &on, sizeof(on)); All the Hop by Hop options are returned as one ancillary data object described by a cmsghdr structure.
The cmsg level member will be IPPROTO IPV6 and the cmsg type member will be IPV6 HOPOPTS.
These options are then processed by calling the inet6 option next() and inet6 option find() functions, described shortly.
Sending Hop by Hop Options To send one or more Hop by Hop options, the application just specifies them as ancillary data in a call to sendmsg().
No socket option need be set.
Normally all the Hop by Hop options are specified by a single ancillary data object.
Multiple ancillary data objects, each containing one or more Hop by Hop options, can also be specified, in which case the kernel will combine all the Hop by Hop options into a single Hop by Hop extension header.
But it should be more efficient to use a single ancillary data object to describe all the Hop by Hop options.
The cmsg level member is set to IPPROTO IPV6 and the cmsg type member is set to IPV6 HOPOPTS.
The option is normally constructed using the inet6 option init(), inet6 option append(), and inet6 option alloc()
Additional errors may be possible from sendmsg() if the specified option is in error.
Hop by Hop and Destination Options Processing Building and parsing the Hop by Hop and Destination options is complicated for the reasons given earlier.
We therefore define a set of functions to help the application.
The function prototypes for these functions are all in the <netinet/in.h> header.
inet6 option space int inet6 option space(int nbytes)
; This function returns the number of bytes required to hold an option when it is stored as ancillary data, including the cmsghdr structure at the beginning, and any padding at the end (to make its size a multiple of 8 bytes).
The argument is the size of the structure defining the option, which must include any pad bytes at the beginning (the value y in the alignment term "xn
y"), the type byte, the length byte, and the option data.
(Note: If multiple options are stored in a single ancillary data object, which is the recommended technique, this function overestimates the amount of space required by the size of N 1 cmsghdr structures, where N is the number of options to be stored in the object.
This is of little consequence, since it is assumed that most Hop by Hop option headers and Destination option headers carry only one option (p. 33 of [RFC 1883]).)
inet6 option init int inet6 option
init(void  bp, struct cmsghdr   cmsgp, int type); This function is called once per ancillary data object that will contain either Hop by Hop or Destination options.
It returns 0 on success or  1 on an error.
bp is a pointer to previously allocated space that will contain the ancillary data object.
It must be large enough to contain all the individual options to be added by later calls to inet6 option append() and inet6 option alloc().
cmsgp is a pointer to a pointer to a cmsghdr structure.
cmsgp is initialized by this function to point to the cmsghdr structure constructed by this function in the buffer pointed to by bp.
type is either IPV6 HOPOPTS or IPV6 DSTOPTS.
This type is stored in the cmsg type member of the cmsghdr structure pointed to by  cmsgp.
inet6 option append int inet6 option
cmsg, const uint8 t  typep, int multx, int plusy); This function appends a Hop by Hop option or a Destination option into an ancillary data object that has been initialized by inet6 option init().
This function returns 0 if it succeeds or  1 on an error.
cmsg is a pointer to the cmsghdr structure that must have been initialized by inet6 option init().
typep is a pointer to the 8 bit option type.
It is assumed that this field is immediately followed by the 8 bit option data length field, which is then followed immediately by the option data.
The caller initializes these three fields (the type length value, or TLV) before calling this function.
The option type must have a value from 2 to 255, inclusive.
(0 and 1 are reserved for the Pad1 and PadN options, respectively.)
The option data length must have a value between 0 and 255, inclusive, and is the length of the option data that follows.
x in the alignment term "xn   y" described earlier.
It must have a value of 1, 2, 4, or 8.
plusy is the value y in the alignment term "xn
It must have a value between 0 and 7, inclusive.
inet6 option alloc uint8 t
cmsg, int datalen, int multx, int plusy); This function appends a Hop by Hop option or a Destination option into an ancillary data object that has been initialized by inet6 option init().
This function returns a pointer to the 8 bit option type field that starts the option on success, or NULL on an error.
The difference between this function and inet6 option append() is that the latter copies the contents of a previously built option into the ancillary data object while the current function returns a pointer to the space in the data object where the option's TLV must then be built by the caller.
cmsg is a pointer to the cmsghdr structure that must have been initialized by inet6 option init().
datalen is the value of the option data length byte for this option.
This value is required as an argument to allow the function to determine if padding must be appended at the end of the option.
(The inet6 option append() function does not need a data length argument since the option data length must already be stored by the caller.)
x in the alignment term "xn   y" described earlier.
It must have a value of 1, 2, 4, or 8.
plusy is the value y in the alignment term "xn
It must have a value between 0 and 7, inclusive.
inet6 option next int inet6 option next(const
cmsg, uint8 t   tptrp); This function processes the next Hop by Hop option or Destination option in an ancillary data object.
If another option remains to be processed, the return value of the function is 0 and  tptrp points to the 8 bit option type field (which is followed by the 8 bit option data length, followed by the option data).
If no more options remain to be processed, the return value is  1 and  tptrp is NULL.
If an error occurs, the return value is  1 and  tptrp is not NULL.
cmsg is a pointer to cmsghdr structure of which cmsg level equals
IPPROTO IPV6 and cmsg type equals either IPV6 HOPOPTS or IPV6 DSTOPTS.
tptrp is a pointer to a pointer to an 8 bit byte and  tptrp is used by the function to remember its place in the ancillary data object each time the function is called.
The first time this function is called for a given ancillary data object,  tptrp must be set to NULL.
Each time this function returns success,  tptrp points to the 8 bit option type field for the next option to be processed.
inet6 option find int inet6 option
t  tptrp, int type); This function is similar to the previously described inet6 option next() function, except this function lets the caller specify the option type to be searched for, instead of always returning the next option in the ancillary data object.
cmsg is a pointer to cmsghdr structure of which cmsg level equals
IPPROTO IPV6 and cmsg type equals either IPV6 HOPOPTS or IPV6 DSTOPTS.
tptrp is a pointer to a pointer to an 8 bit byte and  tptrp is used by the function to remember its place in the ancillary data object each time the function is called.
The first time this function is called for a given ancillary data object,  tptrp must be set to NULL.
This function starts searching for an option of the specified type beginning after the value of  tptrp.
If an option of the specified type is located, this function returns 0 and  tptrp points to the 8  bit option type field for the option of the specified type.
If an option of the specified type is not located, the return value is  1 and  tptrp is NULL.
If an error occurs, the return value is  1 and  tptrp is not NULL.
We now provide an example that builds two Hop by Hop options.
First we define two options, called X and Y, taken from the example in Appendix A of [RFC 1883].
We assume that all options will have structure definitions similar to what is shown below.
option X and option Y are defined in [RFC 1883], pp.
define IP6 X OPT OFFSETY    2 struct
ip6 X opt { uint8 t
pad[IP6 X OPT OFFSETY]; uint8
replace Y with assigned value  /
#define IP6 Y OPT MULTX
/  4n   3 alignment  /
define IP6 Y OPT OFFSETY
ip6 Y opt { uint8 t
ip6 Y opt pad[IP6 Y OPT OFFSETY];
ip6 Y opt len; uint8 t
struct msghdr  msg; struct cmsghdr   cmsgptr; struct ip6 X opt  optX; struct ip6 Y opt  optY; msg.msg control   malloc(inet6 option space(sizeof(optX)
inet6 option init(msg.msg control, &cmsgptr, IPV6 HOPOPTS); optX.ip6 X opt type
IP6 X OPT TYPE; optX.ip6 X opt len    IP6 X OPT LEN
; optX.ip6 X opt val1
optX.ip6 X opt val2   <64 bit value>; inet6 option
append(cmsgptr, &optX.ip6 X opt type, IP6 X OPT MULTX, IP6 X OPT OFFSETY); optY.ip6 Y opt type   IP6 Y OPT TYPE;
optY.ip6 Y opt len    IP6 Y OPT LEN
<8 bit value>; optY.ip6 Y opt val2
append(cmsgptr, &optY.ip6 Y opt type, IP6 Y OPT MULTX, IP6 Y OPT OFFSETY); msg.msg controllen
; The call to inet6 option init() builds the cmsghdr structure in the control buffer.
Here we assume a 32 bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4 byte boundaries (that is
, the ALIGN() macro shown in the sample implementations of the CMSG xxx()
macros rounds up to a multiple of 4).
The first call to inet6 option append() appends the X option.
Since this is the first option in the ancillary data object, 2 bytes are allocated for the Next Header byte and for the Hdr Ext Len byte.
The former will be set by the kernel, depending on the type of header that follows this header, and the latter byte is set to 1.
These 2 bytes form the 2 bytes of padding (IP6 X OPT OFFSETY) required at the beginning of this option.
The cmsg len member of the cmsghdr structure is incremented by 16, the size of the option.
The next call to inet6 option append() appends the Y option to the ancillary data object.
The inet6 option append() function notices that the appended data requires 4 bytes of padding at the end, to make the size of the ancillary data object a multiple of 8, and appends the PadN option before returning.
The Hdr Ext Len byte is incremented by 2 to become 3.
Alternately, the application could build two ancillary data objects, one per option, although this will probably be less efficient than combining the two options into a single ancillary data object (as just shown).
The kernel must combine these into a single Hop by Hop extension header in the final IPv6 packet.
struct msghdr  msg; struct cmsghdr   cmsgptr; struct ip6 X opt  optX; struct ip6 Y opt  optY; msg.msg control   malloc(inet6 option space(sizeof(optX))
; optX.ip6 X opt val1
optX.ip6 X opt val2   <64 bit value>; inet6 option
append(cmsgptr, &optX.ip6 X opt type, IP6 X OPT MULTX, IP6 X OPT OFFSETY)
; msg.msg controllen   CMSG SPACE(sizeof(optX)); inet6 option init((u char  )msg.msg control   msg.msg controllen, &cmsgptr, IPPROTO HOPOPTS); optY.ip6 Y opt type   IP6 Y OPT TYPE; optY.ip6 Y opt len    IP6 Y OPT LEN;
append(cmsgptr, &optY.ip6 Y opt type, IP6 Y OPT MULTX, IP6 Y OPT OFFSETY);
msg.msg controllen    cmsgptr cmsg len; Each call to inet6 option init() builds a new cmsghdr structure, and the final result looks like the following:
Hdr Ext Len 1   Pad1 Option 0
When the kernel combines these two options into a single Hop by Hop extension header, the first 3 bytes of the second ancillary data object (the Next Header byte, the Hdr Ext Len byte, and the Pad1 option) will be combined into a PadN option occupying 3 bytes.
The following code fragment is a redo of the first example shown (building two options in a single ancillary data object)
but this time we use inet6 option alloc().
uint8 t   typep; struct msghdr  msg; struct cmsghdr
; struct ip6 X opt
a pointer, not a struct
/ struct ip6 Y opt
now a pointer, not a struct
alloc(cmsgptr, IP6 X OPT LEN, IP6 X OPT MULTX, IP6 X OPT OFFSETY); optXp   (struct
(typep IP6 X OPT OFFSETY); optXp ip6 X opt type   IP6 X OPT TYPE; optXp ip6
X opt len    IP6 X OPT LEN;
optXp ip6 X opt val1
<32 bit value>; optXp ip6 X opt val2
<64 bit value>; typep   inet6 option
typep IP6 Y OPT OFFSETY); optYp ip6 Y opt type   IP6 Y OPT TYPE; optYp ip6 Y opt len    IP6 Y OPT LEN; optYp
; optYp ip6 Y opt val2   <16 bit value>; optYp ip6 Y opt val3   <32 bit value>; msg.msg controllen   cmsgptr cmsg len; Notice that inet6 option alloc() returns a pointer to the 8 bit option type field.
If the program wants a pointer to an option structure that includes the padding at the front (as shown in our definitions of the ip6 X opt and ip6 Y opt structures), the y offset at the beginning of the structure must be subtracted from the returned pointer.
The following code fragment shows the processing of Hop by Hop options using the inet6 option next() function.
struct msghdr   msg; struct cmsghdr
; cmsgptr   CMSG NXTHDR(&msg, cmsgptr))
{ if (cmsgptr cmsg level
IPPROTO IPV6 && cmsgptr cmsg type   IPV6 HOPOPTS) { uint8 t
tptr   NULL; while (inet6 option next(cmsgptr, &tptr)   0) { if ( tptr   IP6 X OPT TYPE) { struct
(tptr IP6 X OPT OFFSETY)
; <do whatever with> optXp
<do whatever with> optXp ip6 X opt val2; } else if ( tptr   IP6 Y OPT TYPE) { struct ip6 Y opt   optYp; optYp
(tptr IP6 Y OPT OFFSETY)
; <do whatever with> optYp
ip6 Y opt val1; <do whatever with> optYp ip6 Y opt val2; <do whatever with> optYp
Destination Options A variable number of Destination options can appear in one or more Destination option headers.
As defined in [RFC 1883], a Destination options header appearing before a Routing header is processed by the first destination plus any subsequent destinations specified in the Routing header, while a Destination options header appearing after a Routing header is processed only by the final destination.
As with the Hop by Hop options, each option in a Destination options header is TLV encoded with a type, length, and value.
Today no Destination options are defined for IPv6 [RFC 1883], although proposals exist to use Destination options with mobility and anycasting.
Receiving Destination Options To receive Destination options the application must enable the IPV6 DSTOPTS socket option:
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 DSTOPTS, &on, sizeof(on)); All the Destination options appearing before a Routing header are returned as one ancillary data object described by a cmsghdr structure and all the Destination options appearing after a Routing header are returned as another ancillary data object described by a cmsghdr structure.
For these ancillary data objects, the cmsg level member will be IPPROTO IPV6 and the cmsg type member will be IPV6 HOPOPTS.
These options are then processed by calling the inet6 option next() and inet6 option find() functions.
Sending Destination Options To send one or more Destination options, the application just specifies them as ancillary data in a call to sendmsg().
No socket option need be set.
As described earlier, one set of Destination options can appear before a Routing header, and one set can appear after a Routing header.
Each set can consist of one or more options.
Normally all the Destination options in a set are specified by a single ancillary data object, since each option is itself TLV  encoded.
Multiple ancillary data objects, each containing one or more Destination options, can also be specified, in which case the kernel will combine all the Destination options in the set into a single Destination extension header.
But it should be more efficient to use a single ancillary data object to describe all the Destination options in a set.
The cmsg level member is set to IPPROTO IPV6 and the cmsg type member is set to IPV6 DSTOPTS.
The option is normally constructed using the inet6 option init(), inet6 option append(), and inet6 option alloc() functions.
Additional errors may be possible from sendmsg() if the specified option is in error.
8.  Routing Header Option Source routing in IPv6 is accomplished by specifying a Routing header as an extension header.
There can be different types of Routing headers, but IPv6 currently defines only the Type 0 Routing header [RFC 1883].
This type supports up to 23 intermediate nodes.
With this maximum number of intermediate nodes, a source, and a destination, there are 24 hops, each of which is defined as a strict or loose hop.
Source routing with IPv4 sockets API (the IP OPTIONS socket option) requires the application to build the source route in the format that appears as the IPv4 header option, requiring intimate knowledge of the IPv4 options format.
This IPv6 API, however, defines eight functions that the application calls to build and examine a Routing header.
add IPv6 address & flags to Routing header inet6 rthdr lasthop
()  specify the flags for the final hop Four functions deal with a returned Routing header:
()  reverse a Routing header inet6 rthdr segments() return #segments in a Routing header inet6 rthdr getaddr()
fetch one address from a Routing header inet6 rthdr getflags
() fetch one flag from a Routing header
The function prototypes for these functions are all in the <netinet/in.h> header.
To receive a Routing header the application must enable the IPV6 RTHDR socket option:
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 RTHDR, &on, sizeof(on)); To send a Routing header the application just specifies it as ancillary data in a call to sendmsg().
A Routing header is passed between the application and the kernel as an ancillary data object.
The cmsg level member has a value of IPPROTO IPV6 and the cmsg type member has a value of IPV6 RTHDR.
The contents of the cmsg data[] member is implementation dependent and should not be accessed directly by the application, but should be accessed using the eight functions that we are about to describe.
The following constants are defined in the <netinet/in.h> header: #define IPV6
/  this hop need not be a neighbor  /
/  this hop must be a neighbor  /
IPV6 RTHDR TYPE 0    0 /
IPv6 Routing header type 0
When a Routing header is specified, the destination address specified for connect(), sendto(), or sendmsg() is the final destination address of the datagram.
The Routing header then contains the addresses of all the intermediate nodes.
inet6 rthdr space size t inet6 rthdr space(int type, int segments); This function returns the number of bytes required to hold a Routing header of the specified type containing the specified number of segments (addresses).
For an IPv6 Type 0 Routing header, the number of segments must be between 1 and 23, inclusive.
The return value includes the size of the cmsghdr structure that precedes the Routing header, and any required padding.
If the return value is 0, then either the type of the Routing header is not supported by this implementation or the number of segments is invalid for this type of Routing header.
(Note: This function returns the size but does not allocate the space required for the ancillary data.
This allows an application to allocate a larger buffer, if other ancillary data objects are desired, since all the ancillary data objects must be specified to sendmsg() as a single msg control buffer.)
inet6 rthdr init struct cmsghdr
; This function initializes the buffer pointed to by bp to contain a cmsghdr structure followed by a Routing header of the specified type.
The cmsg len member of the cmsghdr structure is initialized to the size of the structure plus the amount of space required by the Routing header.
The cmsg level and cmsg type members are also initialized as required.
The caller must allocate the buffer and its size can be determined by calling inet6 rthdr space().
Upon success the return value is the pointer to the cmsghdr structure, and this is then used as the first argument to the next two functions.
Upon an error the return value is NULL.
inet6 rthdr add int inet6 rthdr add(struct cmsghdr
cmsg, const struct in6 addr  addr, unsigned int flags); This function adds the address pointed to by addr to the end of the Routing header being constructed and sets the type of this hop to the value of flags.
For an IPv6 Type 0 Routing header, flags must be either IPV6 RTHDR LOOSE or IPV6 RTHDR STRICT.
If successful, the cmsg len member of the cmsghdr structure is updated to account for the new address in the Routing header and the return value of the function is 0.
Upon an error the return value of the function is  1. 8.4.
inet6 rthdr lasthop int inet6 rthdr
lasthop(struct cmsghdr  cmsg, unsigned int flags); This function specifies the Strict/Loose flag for the final hop of a Routing header.
For an IPv6 Type 0 Routing header, flags must be either IPV6 RTHDR LOOSE or IPV6 RTHDR STRICT.
The return value of the function is 0 upon success, or  1 upon an error.
Notice that a Routing header specifying N intermediate nodes requires N 1 Strict/Loose flags.
This requires N calls to inet6 rthdr add()
followed by one call to inet6 rthdr lasthop().
inet6 rthdr reverse int inet6 rthdr
, struct cmsghdr  out); This function takes a Routing header that was received as ancillary data (pointed to by the first argument) and writes a new Routing header that sends datagrams along the reverse of that route.
Both arguments are allowed to point to the same buffer (that is, the reversal can occur in place).
The return value of the function is 0 on success, or  1 upon an error.
inet6 rthdr segments int inet6 rthdr
segments(const struct cmsghdr  cmsg); This function returns the number of segments (addresses) contained in the Routing header described by cmsg.
On success the return value is between 1 and 23, inclusive.
The return value of the function is  1 upon an error.
inet6 rthdr getaddr struct in6 addr
inet6 rthdr getaddr(struct cmsghdr  cmsg, int index); This function returns a pointer to the IPv6 address specified by index (which must have a value between 1 and the value returned by inet6 rthdr segments()) in the Routing header described by cmsg.
An application should first call inet6 rthdr segments() to obtain the number of segments in the Routing header.
Upon an error the return value of the function is NULL.
inet6 rthdr getflags int inet6 rthdr
getflags(const struct cmsghdr  cmsg, int index); This function returns the flags value specified by index (which must have a value between 0 and the value returned by inet6 rthdr segments()) in the Routing header described by cmsg.
For an IPv6 Type 0 Routing header the return value will be either IPV6 RTHDR LOOSE or IPV6 RTHDR STRICT.
Upon an error the return value of the function is  1.
(Note: Addresses are indexed starting at 1, and flags starting at 0, to maintain consistency with the terminology and figures in [RFC  1883].)
As an example of these Routing header functions, we go through the function calls for the example on p. 18 of [RFC 1883].
The source is S, the destination is D, and the three intermediate nodes are I1, I2, and I3.
f0, f1, f2, and f3 are the Strict/Loose flags for each hop.
, A[2], and A[3] are the three addresses in the Routing header.
#seg is the Segments Left field in the Routing header.
check indicates which bit of the Strict/Loose Bit Map (0 through 3, specified as f0 through f3) that node checks.
The six values in the column beneath node S are the values in the Routing header specified by the application using sendmsg().
The function calls by the sender would look like: void   ptr; struct msghdr  msg; struct cmsghdr
struct sockaddr in6  I1, I2, I3, D; unsigned int  f0, f1, f2, f3; ptr   malloc(inet6 rthdr space(IPV6 RTHDR TYPE 0, 3)); cmsgptr
/ We also assume that the source address for the socket is not specified (i.e., the asterisk in the figure).
The four columns of six values that are then shown between the five nodes are the values of the fields in the packet while the packet is in transit between the two nodes.
that before the packet is sent by the source node S, the source address is chosen (replacing the asterisk), I1 becomes the destination address of the datagram, the two addresses A[2] and A[3] are "shifted up", and D is moved to A[3].
If f0 is IPV6 RTHDR STRICT, then I1 must be a neighbor of S.
The columns of values that are shown beneath the destination node are the values returned by recvmsg(), assuming the application has enabled both the IPV6 PKTINFO and IPV6 RTHDR socket options.
The source address is S (contained in the sockaddr in6 structure pointed to by the msg name member), the destination address is D (returned as an ancillary data object in an in6 pktinfo structure), and the ancillary data object specifying the Routing header will contain three addresses (I1, I2, and I3) and four flags (f0, f1, f2, and f3).
The number of segments in the Routing header is known from the Hdr Ext Len field in the Routing header (a value of 6, indicating 3 addresses).
The return value from inet6 rthdr segments() will be 3 and inet6 rthdr getaddr(1)
inet6 rthdr getaddr(2) will return I2, and inet6 rthdr getaddr(3) will return I3, The return value from inet6 rthdr flags(0) will be f0, inet6 rthdr flags(1) will return f1, inet6 rthdr flags(2) will return f2, and inet6 rthdr flags(3) will return f3.
If the receiving application then calls inet6 rthdr reverse(), the order of the three addresses will become I3, I2, and I1, and the order of the four Strict/Loose flags will become f3, f2, f1, and f0.
We can also show what an implementation might store in the ancillary data object as the Routing header is being built by the sending process.
If we assume a 32 bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4 byte boundaries, then the call to inet6 rthdr space(3) returns 68: 12 bytes for the cmsghdr structure and 56 bytes for the Routing header (8   3 16).
The first call to inet6 rthdr add() adds I1 to the list.
Bit 0 of the Strict/Loose Bit Map contains the value f0, which we just mark as X.  cmsg len is incremented by 16, the Hdr Ext Len field is incremented by 2, and the Segments Left field is incremented by 1.
The next call to inet6 rthdr add() adds I2 to the list.
The next bit of the Strict/Loose Bit Map contains the value f1.
cmsg len is incremented by 16, the Hdr Ext Len field is incremented by 2, and the Segments Left field is incremented by 1.
The last call to inet6 rthdr add() adds I3 to the list.
The next bit of the Strict/Loose Bit Map contains the value f2.
cmsg len is incremented by 16, the Hdr Ext Len field is incremented by 2, and the Segments Left field is incremented by 1.
Finally, the call to inet6 rthdr lasthop() sets the next bit of the Strict/Loose Bit Map to the value specified by f3.
All the lengths remain unchanged.
Ordering of Ancillary Data and IPv6 Extension Headers
Three IPv6 extension headers can be specified by the application and returned to the application using ancillary data with sendmsg() and recvmsg():
Hop by Hop options, Destination options, and the Routing header.
When multiple ancillary data objects are transferred via sendmsg() or recvmsg() and these objects represent any of these three extension headers, their placement in the control buffer is directly tied to their location in the corresponding IPv6 datagram.
This API imposes some ordering constraints when using multiple ancillary data objects with sendmsg().
When multiple IPv6 Hop by Hop options having the same option type are specified, these options will be inserted into the Hop by Hop options header in the same order as they appear in the control buffer.
But when multiple Hop by Hop options having different option types are specified, these options may be reordered by the kernel to reduce padding in the Hop by Hop options header.
Hop by Hop options may appear anywhere in the control buffer and will always be collected by the kernel and placed into a single Hop by Hop options header that immediately follows the IPv6 header.
Similar rules apply to the Destination options: (1) those of the same type will appear in the same order as they are specified, and (2) those of differing types may be reordered.
But the kernel will build up to two Destination options headers: one to precede the Routing header and one to follow the Routing header.
If the application specifies a Routing header then all Destination options that appear in the control buffer before the Routing header will appear in a Destination options header before the Routing header and these options might be reordered, subject to the two rules that we just stated.
Similarly all Destination options that appear in the control buffer after the Routing header will appear in a Destination options header after the Routing header, and these options might be reordered, subject to the two rules that we just stated.
As an example, assume that an application specifies control information to sendmsg() containing six ancillary data objects: the first containing two Hop by Hop options, the second containing one Destination option, the third containing two Destination options, the fourth containing a Routing header, the fifth containing a Hop by Hop option, and the sixth containing two Destination options.
We also assume that all the Hop by Hop options are of different types, as are all the Destination options.
We number these options 1 9, corresponding to their order in the control buffer, and show them on the left below.
In the middle we show the final arrangement of the options in the extension headers built by the kernel.
On the right we show the four ancillary data objects returned to the receiving application.
The sender's two Hop by Hop ancillary data objects are reordered, as are the first two Destination ancillary data objects.
We also show a Jumbo Payload option (denoted as J) inserted by the kernel before the sender's three Hop by Hop options.
The first three Destination options must appear in a Destination header before the Routing header, and the final two Destination options must appear in a Destination header after the Routing header.
If Destination options are specified in the control buffer after a Routing header, or if Destination options are specified without a Routing header, the kernel will place those Destination options after an authentication header and/or an encapsulating security payload header, if present.
IPv6 Specific Options with IPv4 Mapped IPv6 Addresses The various socket options and ancillary data specifications defined in this document apply only to true IPv6 sockets.
It is possible to create an IPv6 socket that actually sends and receives IPv4 packets, using IPv4 mapped IPv6 addresses, but the mapping of the options defined in this document to an IPv4 datagram is beyond the scope of this document.
In general, attempting to specify an IPv6 only option, such as the Hop by Hop options, Destination options, or Routing header on an IPv6 socket that is using IPv4 mapped IPv6 addresses, will probably result in an error.
Some implementations, however, may provide access to the packet information (source/destination address, send/receive interface, and hop limit) on an IPv6 socket that is using IPv4 mapped IPv6 addresses.
The rresvport() function is used by the rcmd() function, and this function is in turn called by many of the "r" commands such as rlogin.
While new applications are not being written to use the rcmd() function, legacy applications such as rlogin will continue to use it and these will be ported to IPv6.
rresvport() creates an IPv4/TCP socket and binds a "reserved port" to the socket.
Instead of defining an IPv6 version of this function we define a new function that takes an address family as its argument.
af(int  port, int family); This function behaves the same as the existing rresvport() function, but instead of creating an IPv4/TCP socket, it can also create an IPv6/TCP socket.
The family argument is either AF INET or AF INET6, and a new error return is EAFNOSUPPORT if the address family is not supported.
(Note: There is little consensus on which header defines the rresvport() and rcmd() function prototypes.
4.4BSD defines it in <unistd.h>, others in <netdb.h>,
and others don't define the function prototypes at all.)
(Note: We define this function only, and do not define something like rcmd af() or rcmd6().
The reason is that rcmd() calls gethostbyname(), which returns the type of address: AF INET or AF INET6.
It should therefore be possible to modify rcmd() to support either IPv4 or IPv6, based on the address family returned by gethostbyname().)
Some additional items may require standardization, but no concrete proposals have been made for the API to perform these tasks.
These may be addressed in a later document.
Earlier revisions of this document specified a set of inet6 flow XXX() functions to assign, share, and free IPv6 flow labels.
Consensus, however, indicated that it was premature to specify this part of the API.
Path MTU Discovery and UDP A standard method may be desirable for a UDP application to determine the "maximum send transport message size" (Section 5.1 of [RFC 1981]) to a given destination.
This would let the UDP application send smaller datagrams to the destination, avoiding fragmentation.
Neighbor Reachability and UDP A standard method may be desirable for a UDP application to tell the kernel that it is making forward progress with a given peer (Section 7.3.1 of [RFC 1970]).
This could save unneeded neighbor solicitations and neighbor advertisements.
The following list summarizes the constants and structure, definitions discussed in this memo, sorted by header.
/icmp6.h> ICMP6 DST UNREACH ADMIN <netinet/icmp6.h
DST UNREACH NOPORT <netinet/icmp6.h> ICMP6
> ICMP6 PACKET TOO BIG <netinet/icmp6.h
> ICMP6 PARAMPROB HEADER <netinet/icmp6.h
/icmp6.h> ICMP6 PARAMPROB OPTION <netinet/icmp6.h
> ICMP6 TIME EXCEEDED <netinet
> ICMP6 TIME EXCEED REASSEMBLY <netinet/icmp6.h> ICMP6 TIME EXCEED TRANSIT <
ND NA FLAG ROUTER <netinet/icmp6.h
ND NA FLAG SOLICITED <netinet/icmp6.h
> ND OPT MTU <netinet/icmp6.h
ND OPT PI FLAG AUTO
ND OPT PI FLAG ONLINK <netinet/icmp6.h
ND OPT PREFIX INFORMATION <netinet/icmp6.h
ND OPT REDIRECTED HEADER <netinet/icmp6.h
ND OPT SOURCE LINKADDR <netinet/icmp6.h
> ND OPT TARGET LINKADDR <netinet/icmp6.h
> ND RA FLAG OTHER <netinet/icmp6.h
ND ROUTER SOLICIT <netinet/icmp6.h> struct icmp6 filter{};
> struct nd router solicit{};
IPV6 RTHDR TYPE 0 <
struct msghdr{}; The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.
SETBLOCK(int, struct icmp6 filter  );
alloc(struct cmsghdr  , int, int, int); <netinet/in.h>
append(struct cmsghdr  , const uint8
t  , int, int); <netinet/in.h>
find(const struct cmsghdr  , uint8 t  , int); <netinet/in.h>
in6 addr inet6 rthdr getaddr(struct cmsghdr  , int); <netinet/in.h>
getflags(const struct cmsghdr  , int); <netinet/in.h>
lasthop(struct cmsghdr  , unsigned int); <netinet/in.h>
The setting of certain Hop by Hop options and Destination options may be restricted to privileged processes.
Similarly some Hop by Hop options and Destination options may not be returned to nonprivileged applications.
Change History Changes from the June 1997 Edition ( 03 draft)  Added a note that defined constants for multibyte fields are in network byte order.
This affects the ip6f offlg member of the Fragment header (Section 2.1.2) and the nd na flags reserved member of the nd neighbor advert structure (Section 2.2.2).
the ipi6 ifindex member of the in6 pktinfo structure should be "unsigned int" instead of "int", for consistency with the interface indexes in [RFC 2133].
the three calls to inet6 option space() in the examples needed to be arguments to malloc().
The final one of these was missing the "6" in the name "inet6 option space".
the function prototype for inet6 rthdr segments() was missing the ending semicolon.
Changes from the March 1997 Edition ( 02 draft)
In May 1997 Draft 6.6 of Posix 1003.1g (called Posix.1g herein) passed ballot and will be forwarded to the IEEE Standards Board later in 1997 for final approval.
Some changes made for this final Posix draft are incorporated into this Internet Draft, specifically the datatypes mentioned in Section 1 (and used throughout the text), and the socklen t datatype used in Section 4.1 and 4.2.
Section 1: Added the intN t signed datatypes, changed the datatype u intN t to uintN t (no underscore after the "u"), and removed the datatype u intNm t, as per Draft 6.6 of Posix.1g.
Name space issues for structure and constant names in Section 2: Many of the structure member names and constant names were changed so that the prefixes are the same.
All constants have the prefixes "ICMP6 " and "ND ".
Section 2.1.2: contains definitions for the IPv6 extension headers, other than AH and ESP.
Section 2.2.2: contains additional structures and constants for the neighbor discovery option header and redirected header.
the enum for the neighbor discovery option field was changed to be a set of #define constants.
Changed the word "function" to "macro" for references to all the uppercase names in Sections 2.3 (IN6 ARE ADDR EQUAL), 3.2 (ICMPV6 FILTER xxx), and 4.3 (CMSG xxx).
Added more protocols to the /etc/protocols file (Section 2.4) and changed the name of "icmpv6" to "ipv6 icmp".
Made it more explicit that an application cannot read or write entire IPv6 packets, that all extension headers are passed as ancillary data.
Added a sentence that the kernel fragments packets written to an IPv6 raw socket when necessary.
Added a note that IPPROTO RAW raw IPv6 sockets are not special.
Explicitly stated that the checksum option applies to both outgoing packets and received packets.
Section 3.2: Changed the array name within the icmp6 filter structure from "data" to "icmp6 filt".
Changes the prefix for the filter macros from "ICMPV6 " to "ICMP6 ", for consistency with the names in Section 2.2.
Changed the example from a ping program to a program that wants to receive only router advertisements.
Changed msg namelen and msg controllen from size t to the Posix.1g socklen t datatype.
Updated the Note that follows.
Changed cmsg len from size t to the Posix.1g socklen t datatype.
Updated the Note that follows.
Section 4.4: Added a Note that the second and third arguments to getsockopt() and setsockopt() are intentionally the same as the cmsg level and cmsg type members.
Reorganized the section into a description of the option, followed by the TCP semantics, and the UDP and raw socket semantics.
Added a sentence on how to clear all the sticky options.
Added a note that TCP need not save the options from the most recently received segment until the application says to do so.
Added the statement that ancillary data is never passed with sendmsg() or recvmsg() on a TCP socket.
Simplified the interaction of the sticky options with ancillary data for UDP or raw IP: none of the sticky options are sent if ancillary data is specified.
Final paragraph of Section 5.1:
ipi6 index should be ipi6 ifindex.
Section 5.4: Added a note on the term "privileged".
Noted that the errors listed are examples, and the actual errors depend on the implementation.
Removed Section 6 ("Flow Labels")
as the consensus is that it is premature to try and specify an API for this feature.
Access to the flow label field in the IPv6 header is still provided through the sin6 flowinfo member of the IPv6 socket address structure in [RFC 2133].
Added a subsection to Section 13 that this is a future item.
All remaining changes are identified by their section number in the previous draft.
With the removal of Section 6, the section numbers are decremented by one.
Section 7.3.7: the calls to malloc() in all three examples should be calls to inet6 option space() instead.
The two calls to inet6 option append() in the third example should be calls to inet6 option alloc().
The two calls to CMSG SPACE() in the first and third examples
should be calls to CMSG LEN().
The second call to CMSG SPACE
() in the second example should be a call to CMSG LEN().
All the opt X  and opt Y
structure member names were changed to be
ip6 X opt  and ip6 Y opt .
The two structure names ipv6 opt
Y were changed to ip6 X opt and ip6 Y opt.
The constants beginning with IPV6 OPT X  and IPV6 OPT Y  were changed to begin with IP6 X OPT  and IP6 Y OPT .
"Routing header" throughout the draft, instead of "source routing".
Changed the names of the eight inet6 srcrt XXX() functions in Section 9 to inet6 rthdr XXX().
Changed the name of the socket option from IPV6 SRCRT to IPV6 RTHDR, and the names of the three IPV6 SRCRT xxx constants in Section 9 to IPV6 RTHDR xxx.
Added a paragraph to Section 9 on how to receive and send a Routing header.
inet6 rthdr add() and inet6 rthdr reverse()
so that they return  1 upon an error, instead of an Exxx errno value.
In the description of inet6 rthdr space() in Section 9.1, added the qualifier "For an IPv6 Type 0 Routing header" to the restriction of between 1 and 23 segments.
Refer to final function argument in Sections 9.7 and 9.8 as index, not offset.
Updated Section 14 with new names from Section 2.
Changed the References from "[n]" to "[RFC abcd]".
Changes from the February 1997 Edition ( 01 draft)  Changed the name of the ip6hdr structure to ip6 hdr (Section 2.1) for consistency with the icmp6hdr structure.
Also changed the name of the ip6hdrctl structure contained within the ip6 hdr structure to ip6 hdrctl (Section 2.1).
Finally, changed the name of the icmp6hdr structure to icmp6 hdr (Section 2.2).
All other occurrences of this structure name, within the Neighbor Discovery structures in Section 2.2.1, already contained the underscore.
The "struct nd router solicit" and "struct nd router advert" should both begin with "nd6 ".
Changed the name of in6 are addr equal to IN6
ARE ADDR EQUAL (Section 2.3) for consistency with basic API address testing functions.
The header defining this macro is <netinet/in.h
getprotobyname("ipv6") now returns 41, not 0 (Section 2.4).
The first occurrence of "struct icmpv6 filter" in Section 3.2 should be "struct icmp6 filter".
Changed the name of the CMSG LENGTH
() macro to CMSG LEN() (Section 4.3.5), since LEN is used throughout the <netinet/ .h
Corrected the argument name for the sample implementations of the CMSG SPACE() and
CMSG LEN() macros to be "length" (Sections 4.3.4 and 4.3.5).
Corrected the socket option mentioned in Section 5.1 to specify the interface for multicasting from IPV6 ADD MEMBERSHIP to IPV6 MULTICAST IF.
There were numerous errors in the previous draft that specified <netinet/ip6.h>
that should have been <netinet/in.h>.
These have all been corrected and the locations of all definitions is now summarized in the new Section 14 ("Summary of New Definitions").
Changes from the October 1996 Edition ( 00 draft)
Added note that not all errors may be defined.
Added note about ICMPv4, IGMPv4, and ARPv4 terminology.
Changed the name of <netinet/ip6 icmp.h> to <netinet/icmp6.h
Changed some names in Section 2.2.1:
ICMPV6 PKT TOOBIG to ICMPV6
ICMPV6 TIME EXCEED to ICMPV6 TIME EXCEEDED,
ICMPV6 ECHORQST to ICMPV6 ECHOREQUEST, ICMPV6 ECHORPLY to ICMPV6 ECHOREPLY, ICMPV6 PARAMPROB HDR
to ICMPV6 PARAMPROB HEADER, ICMPV6 PARAMPROB NXT HDR
to ICMPV6 PARAMPROB NEXTHEADER, and ICMPV6 PARAMPROB OPTS to ICMPV6 PARAMPROB OPTION.
Prepend the prefix "icmp6 " to the three members of the icmp6 dataun union of the icmp6hdr structure (Section 2.2).
Moved the neighbor discovery definitions into the <netinet/icmp6.h> header, instead of being in their own header (Section 2.2.1).
Changed Section 2.3 ("Address Testing").
The basic macros are now in the basic API.
Added the new Section 2.4 on "Protocols File".
Added note to raw sockets description that something like BPF or DLPI must be used to read or write entire IPv6 packets.
Corrected example of IPV6 CHECKSUM socket option (Section 3.1).
Also defined value of  1 to disable.
Noted that <netinet/icmp6.h> defines all the ICMPv6 filtering constants, macros, and structures (Section 3.2).
Added note on magic number 10240 for amount of ancillary data (Section 4.1).
Added possible padding to picture of ancillary data (Section 4.2).
> header for CMSG xxx() functions (Section 4.2).
Note that the data returned by getsockopt(IPV6 PKTOPTIONS) for a TCP socket is just from the optional headers, if present, of the most recently received segment.
Also note that control information is never returned by recvmsg() for a TCP socket.
Changed header for struct in6 pktinfo from <
Removed the old Sections 5.1 and 5.2, because the interface identification functions went into the basic API.
Redid Section 5 to support the hop limit field.
New Section 5.4 ("Next Hop Address").
New Section 6 ("Flow Labels").
Changed all of Sections 7 and 8 dealing with Hop by Hop and Destination options.
We now define a set of inet6 option XXX() functions.
Changed header for IPV6 SRCRT xxx constants from <
Add inet6 rthdr lasthop() function, and fix errors in description of Routing header (Section 9).
Reworded some of the Routing header descriptions to conform to the terminology in [RFC 1883].
Added the example from [RFC 1883] for the Routing header (Section 9.9).
Expanded the example in Section 10 to show multiple options per ancillary data object, and to show the receiver's ancillary data objects.
New Section 11 ("IPv6 Specific Options with IPv4 Mapped IPv6 Addresses").
New Section 12 ("rresvport af").
Redid old Section 10 ("Additional Items") into new Section 13 ("Future Items").
