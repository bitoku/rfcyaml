- title: __initial_text__
  contents:
  - "   SCHC: Generic Framework for Static Context Header Compression and\n      \
    \                       Fragmentation\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines the Static Context Header Compression and\n\
    \   fragmentation (SCHC) framework, which provides both a header\n   compression\
    \ mechanism and an optional fragmentation mechanism.  SCHC\n   has been designed\
    \ with Low-Power Wide Area Networks (LPWANs) in mind.\n   SCHC compression is\
    \ based on a common static context stored both in\n   the LPWAN device and in\
    \ the network infrastructure side.  This\n   document defines a generic header\
    \ compression mechanism and its\n   application to compress IPv6/UDP headers.\n\
    \   This document also specifies an optional fragmentation and reassembly\n  \
    \ mechanism.  It can be used to support the IPv6 MTU requirement over\n   the\
    \ LPWAN technologies.  Fragmentation is needed for IPv6 datagrams\n   that, after\
    \ SCHC compression or when such compression was not\n   possible, still exceed\
    \ the Layer 2 maximum payload size.\n   The SCHC header compression and fragmentation\
    \ mechanisms are\n   independent of the specific LPWAN technology over which they\
    \ are\n   used.  This document defines generic functionalities and offers\n  \
    \ flexibility with regard to parameter settings and mechanism choices.\n   This\
    \ document standardizes the exchange over the LPWAN between two\n   SCHC entities.\
    \  Settings and choices specific to a technology or a\n   product are expected\
    \ to be grouped into profiles, which are specified\n   in other documents.  Data\
    \ models for the context and profiles are out\n   of scope.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8724.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n   2.  Requirements Notation\n   3. \
    \ LPWAN Architecture\n   4.  Terminology\n   5.  SCHC Overview\n     5.1.  SCHC\
    \ Packet Format\n     5.2.  Functional Mapping\n   6.  RuleID\n   7.  Compression/Decompression\n\
    \     7.1.  SCHC C/D Rules\n     7.2.  Packet Processing\n     7.3.  Matching\
    \ Operators\n     7.4.  Compression/Decompression Actions (CDA)\n       7.4.1.\
    \  Processing Fixed-Length Fields\n       7.4.2.  Processing Variable-Length Fields\n\
    \       7.4.3.  Not-Sent CDA\n       7.4.4.  Value-Sent CDA\n       7.4.5.  Mapping-Sent\
    \ CDA\n       7.4.6.  LSB CDA\n       7.4.7.  DevIID, AppIID CDA\n       7.4.8.\
    \  Compute-*\n   8.  Fragmentation/Reassembly\n     8.1.  Overview\n     8.2.\
    \  SCHC F/R Protocol Elements\n       8.2.1.  Messages\n       8.2.2.  Tiles,\
    \ Windows, Bitmaps, Timers, Counters\n       8.2.3.  Integrity Checking\n    \
    \   8.2.4.  Header Fields\n     8.3.  SCHC F/R Message Formats\n       8.3.1.\
    \  SCHC Fragment Format\n       8.3.2.  SCHC ACK Format\n       8.3.3.  SCHC ACK\
    \ REQ Format\n       8.3.4.  SCHC Sender-Abort Format\n       8.3.5.  SCHC Receiver-Abort\
    \ Format\n     8.4.  SCHC F/R Modes\n       8.4.1.  No-ACK Mode\n       8.4.2.\
    \  ACK-Always Mode\n       8.4.3.  ACK-on-Error Mode\n   9.  Padding Management\n\
    \   10. SCHC Compression for IPv6 and UDP Headers\n     10.1.  IPv6 Version Field\n\
    \     10.2.  IPv6 Traffic Class Field\n     10.3.  Flow Label Field\n     10.4.\
    \  Payload Length Field\n     10.5.  Next Header Field\n     10.6.  Hop Limit\
    \ Field\n     10.7.  IPv6 Addresses Fields\n       10.7.1.  IPv6 Source and Destination\
    \ Prefixes\n       10.7.2.  IPv6 Source and Destination IID\n     10.8.  IPv6\
    \ Extension Headers\n     10.9.  UDP Source and Destination Ports\n     10.10.\
    \ UDP Length Field\n     10.11. UDP Checksum Field\n   11. IANA Considerations\n\
    \   12. Security Considerations\n     12.1.  Security Considerations for SCHC\
    \ Compression/Decompression\n       12.1.1.  Forged SCHC Packet\n       12.1.2.\
    \  Compressed Packet Size as a Side Channel to Guess a\n               Secret\
    \ Token\n       12.1.3.  Decompressed Packet Different from the Original Packet\n\
    \     12.2.  Security Considerations for SCHC Fragmentation/Reassembly\n     \
    \  12.2.1.  Buffer Reservation Attack\n       12.2.2.  Corrupt Fragment Attack\n\
    \       12.2.3.  Fragmentation as a Way to Bypass Network Inspection\n       12.2.4.\
    \  Privacy Issues Associated with SCHC Header Fields\n   13. References\n    \
    \ 13.1.  Normative References\n     13.2.  Informative References\n   Appendix\
    \ A.  Compression Examples\n   Appendix B.  Fragmentation Examples\n   Appendix\
    \ C.  Fragmentation State Machines\n   Appendix D.  SCHC Parameters\n   Appendix\
    \ E.  Supporting Multiple Window Sizes for Fragmentation\n   Appendix F.  ACK-Always\
    \ and ACK-on-Error on Quasi-Bidirectional\n           Links\n   Acknowledgements\n\
    \   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines the Static Context Header Compression\
    \ and\n   fragmentation (SCHC) framework, which provides both a header\n   compression\
    \ mechanism and an optional fragmentation mechanism.  SCHC\n   has been designed\
    \ with Low-Power Wide Area Networks (LPWANs) in mind.\n   LPWAN technologies impose\
    \ some strict limitations on traffic.  For\n   instance, devices sleep most of\
    \ the time and may only receive data\n   during short periods of time after transmission,\
    \ in order to preserve\n   battery.  LPWAN technologies are also characterized\
    \ by a greatly\n   reduced data unit and/or payload size (see [RFC8376]).\n  \
    \ Header compression is needed for efficient Internet connectivity to a\n   node\
    \ within an LPWAN.  The following properties of LPWANs can be\n   exploited to\
    \ get an efficient header compression:\n   *  The network topology is star-oriented,\
    \ which means that all\n      packets between the same source-destination pair\
    \ follow the same\n      path.  For the needs of this document, the architecture\
    \ can simply\n      be described as Devices (Dev) exchanging information with\
    \ LPWAN\n      Application Servers (Apps) through a Network Gateway (NGW).\n \
    \  *  Because devices embed built-in applications, the traffic flows to\n    \
    \  be compressed are known in advance.  Indeed, new applications are\n      less\
    \ frequently installed in an LPWAN device than they are in a\n      general-purpose\
    \ computer or smartphone.\n   SCHC compression uses a Context (a set of Rules)\
    \ in which information\n   about header fields is stored.  This Context is static:\
    \ the values of\n   the header fields and the actions to do compression/decompression\
    \ do\n   not change over time.  This avoids the need for complex\n   resynchronization\
    \ mechanisms.  Indeed, a return path may be more\n   restricted/expensive, or\
    \ may sometimes be completely unavailable\n   [RFC8376].  A compression protocol\
    \ that relies on feedback is not\n   compatible with the characteristics of such\
    \ LPWANs.\n   In most cases, a small Rule identifier is enough to represent the\n\
    \   full IPv6/UDP headers.  The SCHC header compression mechanism is\n   independent\
    \ of the specific LPWAN technology over which it is used.\n   Furthermore, some\
    \ LPWAN technologies do not provide a fragmentation\n   functionality; to support\
    \ the IPv6 MTU requirement of 1280 bytes\n   [RFC8200], they require a fragmentation\
    \ protocol at the adaptation\n   layer below IPv6.  Accordingly, this document\
    \ defines an optional\n   fragmentation/reassembly mechanism to help LPWAN technologies\
    \ support\n   the IPv6 MTU requirement.\n   This document defines generic functionality\
    \ and offers flexibility\n   with regard to parameter settings and mechanism choices.\
    \  Technology-\n   specific settings are expected to be grouped into Profiles\
    \ specified\n   in other documents.\n"
- title: 2.  Requirements Notation
  contents:
  - "2.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 3.  LPWAN Architecture
  contents:
  - "3.  LPWAN Architecture\n   LPWAN architectures are similar among them, but each\
    \ LPWAN technology\n   names architecture elements differently.  In this document,\
    \ we use\n   terminology from [RFC8376], which identifies the following entities\n\
    \   in a typical LPWAN (see Figure 1):\n   *  Devices (Dev) are the end-devices\
    \ or hosts (e.g., sensors,\n      actuators, etc.).  There can be a very high\
    \ density of devices per\n      Radio Gateway.\n   *  The Radio Gateway (RGW)\
    \ is the endpoint of the constrained link.\n   *  The Network Gateway (NGW) is\
    \ the interconnection node between the\n      Radio Gateway and the Internet.\n\
    \   *  The Application Server (App) is the endpoint of the application-\n    \
    \  level protocol on the Internet side.\n    ()   ()   ()       |\n    Dev   \
    \         RGWs             NGW                      App\n   Figure 1: LPWAN Architecture\
    \ (Simplified from That Shown in RFC 8376)\n"
- title: 4.  Terminology
  contents:
  - "4.  Terminology\n   This section defines terminology and abbreviations used in\
    \ this\n   document.  It extends the terminology of [RFC8376].\n   The SCHC acronym\
    \ is pronounced like \"sheek\" in English (or \"chic\" in\n   French).  Therefore,\
    \ this document writes \"a SCHC Packet\" instead of\n   \"an SCHC Packet\".\n\
    \   App:     LPWAN Application Server, as defined by [RFC8376].  It runs\n   \
    \         an application sending/receiving packets to/from the Dev.\n   AppIID:\
    \  Application Interface Identifier.  The IID that identifies\n            the\
    \ App interface.\n   Compression Residue:  The bits that remain to be sent (beyond\
    \ the\n            RuleID itself) after applying the SCHC compression.\n   Context:\
    \  A set of Rules used to compress/decompress headers, or to\n            fragment/reassemble\
    \ a packet.\n   Dev:     Device, as defined by [RFC8376].\n   DevIID:  Device\
    \ Interface Identifier.  The IID that identifies the\n            Dev interface.\n\
    \   Downlink:  From the App to the Dev.\n   IID:     Interface Identifier.  See\
    \ the IPv6 addressing architecture\n            [RFC7136].\n   L2:      Layer\
    \ 2.  The immediate lower layer that SCHC interfaces\n            with, for example\
    \ an underlying LPWAN technology.  It does\n            not necessarily correspond\
    \ to the OSI model definition of\n            Layer 2.\n   L2 Word:  This is the\
    \ minimum subdivision of payload data that the L2\n            will carry.  In\
    \ most L2 technologies, the L2 Word is an\n            octet.  In bit-oriented\
    \ radio technologies, the L2 Word\n            might be a single bit.  The L2\
    \ Word size is assumed to be\n            constant over time for each device.\n\
    \   Padding:  Extra bits that may be appended by SCHC to a data unit that\n  \
    \          it passes down to L2 for transmission.  SCHC itself operates\n    \
    \        on bits, not bytes, and does not have any alignment\n            prerequisite.\
    \  See Section 9.\n   Profile:  SCHC offers variations in the way it is operated,\
    \ with a\n            number of parameters listed in Appendix D.  A Profile\n\
    \            indicates a particular setting of all these parameters.\n       \
    \     Both ends of a SCHC communication must be provisioned with\n           \
    \ the same Profile information and with the same set of Rules\n            before\
    \ the communication starts, so that there is no\n            ambiguity in how\
    \ they expect to communicate.\n   Rule:    Part of the Context that describes\
    \ how a packet is\n            compressed/decompressed or fragmented/reassembled.\n\
    \   RuleID:  Rule Identifier.  An identifier for a Rule.\n   SCHC:    Static Context\
    \ Header Compression and fragmentation (SCHC),\n            a generic framework.\n\
    \   SCHC C/D:  SCHC Compressor/Decompressor, or SCHC Compression/\n          \
    \  Decompression.  The SCHC entity or mechanism used on both\n            sides,\
    \ at the Dev and at the network, to achieve\n            compression/decompression\
    \ of headers.\n   SCHC F/R:  SCHC Fragmenter/Reassembler or SCHC Fragmentation/\n\
    \            Reassembly.  The SCHC entity or mechanism used on both\n        \
    \    sides, at the Dev and at the network, to achieve\n            fragmentation/reassembly\
    \ of SCHC Packets.\n   SCHC Packet:  A packet (e.g., an IPv6 packet) whose header\
    \ has been\n            compressed as per the header compression mechanism defined\n\
    \            in this document.  If the header compression process is\n       \
    \     unable to actually compress the packet header, the packet\n            with\
    \ the uncompressed header is still called a SCHC Packet\n            (in this\
    \ case, a RuleID is used to indicate that the packet\n            header has not\
    \ been compressed).  See Section 7 for more\n            details.\n   Uplink:\
    \  From the Dev to the App.\n   Additional terminology for the optional SCHC F/R\
    \ is found in\n   Section 8.2.\n   Additional terminology for SCHC C/D is found\
    \ in Section 7.1.\n"
- title: 5.  SCHC Overview
  contents:
  - "5.  SCHC Overview\n   SCHC can be characterized as an adaptation layer between\
    \ an upper\n   layer (for example, IPv6) and an underlying layer (for example,\
    \ an\n   LPWAN technology).  SCHC comprises two sublayers (i.e., the\n   Compression\
    \ sublayer and the Fragmentation sublayer), as shown in\n   Figure 2.\n      \
    \          |      IPv6      |\n             |  |   Compression  |\n       SCHC\
    \ <   +----------------+\n             |  |  Fragmentation |\n               \
    \ |LPWAN technology|\n     Figure 2: Example of Protocol Stack Comprising IPv6,\
    \ SCHC, and an\n                              LPWAN Technology\n   Before an upper\
    \ layer packet (e.g., an IPv6 packet) is transmitted to\n   the underlying layer,\
    \ header compression is first attempted.  The\n   resulting packet is called a\
    \ \"SCHC Packet\", whether or not any\n   compression is performed.  If needed\
    \ by the underlying layer, the\n   optional SCHC fragmentation MAY be applied\
    \ to the SCHC Packet.  The\n   inverse operations take place at the receiver.\
    \  This process is\n   illustrated in Figure 3.\n   A packet (e.g., an IPv6 packet)\n\
    \            v                                           |\n   | SCHC Compression\
    \ |                      | SCHC Decompression |\n            |   If no fragmentation\
    \ (*)                 |\n            +-------------- SCHC Packet  -------------->|\n\
    \            v                                           |\n   | SCHC Fragmentation\
    \ |                       | SCHC Reassembly |\n         |     +---------- SCHC\
    \ ACK (+) -------------+     |\n         +-------------- SCHC Fragments -------------------+\n\
    \           Sender                                    Receiver\n   *: the decision\
    \ not to use SCHC fragmentation is left to each Profile\n   +: optional, depends\
    \ on Fragmentation mode\n          Figure 3: SCHC Operations at the Sender and\
    \ the Receiver\n"
- title: 5.1.  SCHC Packet Format
  contents:
  - "5.1.  SCHC Packet Format\n   The SCHC Packet is composed of the Compressed Header\
    \ followed by the\n   payload from the original packet (see Figure 4).  The Compressed\n\
    \   Header itself is composed of the RuleID and a Compression Residue,\n   which\
    \ is the output of compressing the packet header with the Rule\n   identified\
    \ by that RuleID (see Section 7).  The Compression Residue\n   may be empty. \
    \ Both the RuleID and the Compression Residue\n   potentially have a variable\
    \ size, and are not necessarily a multiple\n   of bytes in size.\n   |-------\
    \ Compressed Header -------|\n   |  RuleID  |  Compression Residue |      Payload\
    \       |\n                           Figure 4: SCHC Packet\n"
- title: 5.2.  Functional Mapping
  contents:
  - "5.2.  Functional Mapping\n   Figure 5 maps the functional elements of Figure\
    \ 3 onto the LPWAN\n   architecture elements of Figure 1.\n           Dev    \
    \                                           App\n   | App1 App2 App3 |       \
    \                        |App1| |App2| |App3|\n   |       UDP      |         \
    \                      |UDP | |UDP | |UDP |\n   |      IPv6      |           \
    \                    |IPv6| |IPv6| |IPv6|\n   |SCHC C/D and F/R|             \
    \                  |    | |    | |    |\n            +~ |RGW| === |NGW| == |SCHC|\
    \ == |SCHC|..... Internet ....\n                      Figure 5: Architectural\
    \ Mapping\n   SCHC C/D and SCHC F/R are located on both sides of the LPWAN\n \
    \  transmission, hereafter called the \"Dev side\" and the \"Network\n   Infrastructure\
    \ side\".\n   The operation in the Uplink direction is as follows.  The Device\n\
    \   application uses IPv6 or IPv6/UDP protocols.  Before sending the\n   packets,\
    \ the Dev compresses their headers using SCHC C/D; if the SCHC\n   Packet resulting\
    \ from the compression needs to be fragmented by SCHC,\n   SCHC F/R is performed\
    \ (see Section 8).  The resulting SCHC Fragments\n   are sent to an LPWAN Radio\
    \ Gateway (RGW), which forwards them to a\n   Network Gateway (NGW).  The NGW\
    \ sends the data to a SCHC F/R for\n   reassembly (if needed) and then to the\
    \ SCHC C/D for decompression.\n   After decompression, the packet can be sent\
    \ over the Internet to one\n   or several Apps.\n   The SCHC F/R and SCHC C/D\
    \ on the Network Infrastructure side can be\n   part of the NGW or located in\
    \ the Internet as long as a tunnel is\n   established between them and the NGW.\
    \  For some LPWAN technologies,\n   it may be suitable to locate the SCHC F/R\
    \ functionality nearer the\n   NGW, in order to better deal with time constraints\
    \ of such\n   technologies.\n   The SCHC C/Ds on both sides MUST share the same\
    \ set of Rules.  So\n   MUST the SCHC F/Rs on both sides.\n   The operation in\
    \ the Downlink direction is similar to that in the\n   Uplink direction, only\
    \ reversing the order in which the architecture\n   elements are traversed.\n"
- title: 6.  RuleID
  contents:
  - "6.  RuleID\n   RuleIDs identify the Rules used for compression/decompression\
    \ or for\n   fragmentation/reassembly.\n   The scope of the RuleID of a compression/decompression\
    \ Rule is the\n   link between the SCHC C/D in a given Dev and the corresponding\
    \ SCHC\n   C/D in the Network Infrastructure side.  The scope of the RuleID of\
    \ a\n   fragmentation/reassembly Rule is the link between the SCHC F/R in a\n\
    \   given Dev and the corresponding SCHC F/R in the Network\n   Infrastructure\
    \ side.  If such a link is bidirectional, the scope\n   includes both directions.\n\
    \   The RuleIDs are therefore specific to the Context related to one Dev.\n  \
    \ Hence, multiple Dev instances, which refer to different Contexts, MAY\n   reuse\
    \ the same RuleID for different Rules.  On the Network\n   Infrastructure side,\
    \ in order to identify the correct Rule to be\n   applied to Uplink traffic, the\
    \ SCHC C/D or SCHC F/R needs to\n   associate the RuleID with the Dev identifier.\
    \  Similarly, for\n   Downlink traffic, the SCHC C/D or SCHC F/R on the Network\n\
    \   Infrastructure side first needs to identify the destination Dev\n   before\
    \ looking for the appropriate Rule (and associated RuleID) in\n   the Context\
    \ of that Dev.\n   Inside their scopes, Rules for compression/decompression and\
    \ Rules\n   for fragmentation/reassembly share the same RuleID space.\n   The\
    \ size of the RuleIDs is not specified in this document, as it is\n   implementation-specific\
    \ and can vary according to the LPWAN\n   technology and the number of Rules,\
    \ among other things.  It is\n   defined in Profiles.\n   The RuleIDs are used:\n\
    \   *  For SCHC C/D, to identify the Rule that is used to compress a\n      packet\
    \ header.\n      -  At least one RuleID MUST be allocated to tagging packets for\n\
    \         which SCHC compression was not possible (i.e., no matching\n       \
    \  compression Rule was found).\n   *  In SCHC F/R, to identify the specific mode\
    \ and settings of\n      fragmentation/reassembly for one direction of data traffic\
    \ (Uplink\n      or Downlink).\n      -  When SCHC F/R is used for both communication\
    \ directions, at\n         least two RuleID values are needed for fragmentation/\n\
    \         reassembly: one per direction of data traffic.  This is because\n  \
    \       fragmentation/reassembly may entail control messages flowing in\n    \
    \     the reverse direction compared to data traffic.\n"
- title: 7.  Compression/Decompression
  contents:
  - "7.  Compression/Decompression\n   Compression with SCHC is based on using a set\
    \ of Rules, which\n   constitutes the Context of SCHC C/D, to compress or decompress\n\
    \   headers.  SCHC avoids Context synchronization traffic, which consumes\n  \
    \ considerable bandwidth in other header compression mechanisms such as\n   RObust\
    \ Header Compression (RoHC) [RFC5795].  Since the content of\n   packets is highly\
    \ predictable in LPWANs, static Contexts can be\n   stored beforehand.  The Contexts\
    \ MUST be stored at both ends, and\n   they can be learned by a provisioning protocol,\
    \ by out-of-band means,\n   or by pre-provisioning.  The way the Contexts are\
    \ provisioned is out\n   of the scope of this document.\n"
- title: 7.1.  SCHC C/D Rules
  contents:
  - "7.1.  SCHC C/D Rules\n   The main idea of the SCHC compression scheme is to transmit\
    \ the\n   RuleID to the other end instead of sending known field values.  This\n\
    \   RuleID identifies a Rule that matches the original packet values.\n   Hence,\
    \ when a value is known by both ends, it is only necessary to\n   send the corresponding\
    \ RuleID over the LPWAN.  The manner by which\n   Rules are generated is out of\
    \ the scope of this document.  The Rules\n   MAY be changed at run-time, but the\
    \ mechanism is out of scope of this\n   document.\n   The SCHC C/D Context is\
    \ a set of Rules.  See Figure 6 for a high-\n   level, abstract representation\
    \ of the Context.  The formal\n   specification of the representation of the Rules\
    \ is outside the scope\n   of this document.\n   Each Rule itself contains a list\
    \ of Field Descriptors composed of a\n   Field Identifier (FID), a Field Length\
    \ (FL), a Field Position (FP), a\n   Direction Indicator (DI), a Target Value\
    \ (TV), a Matching Operator\n   (MO), and a Compression/Decompression Action (CDA).\n\
    \     |                         Rule N                                  |\n  \
    \  |                       Rule i                                    ||\n   |\
    \  (FID)            Rule 1                                        |||\n   ||Field\
    \ 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||\n   ||Field 2|FL|FP|DI|Target\
    \ Value|Matching Operator|Comp/Decomp Act||||\n   ||Field N|FL|FP|DI|Target Value|Matching\
    \ Operator|Comp/Decomp Act|||\n                        Figure 6: A SCHC C/D Context\n\
    \   A Rule does not describe how the compressor parses a packet header to\n  \
    \ find and identify each field (e.g., the IPv6 Source Address, the UDP\n   Destination\
    \ Port, or a CoAP URI path option).  It is assumed that\n   there is a protocol\
    \ parser alongside SCHC that is able to identify\n   all the fields encountered\
    \ in the headers to be compressed, and to\n   label them with a Field ID.  Rules\
    \ only describe the compression/\n   decompression behavior for each header field,\
    \ after it has been\n   identified.\n   In a Rule, the Field Descriptors are listed\
    \ in the order in which the\n   fields appear in the packet header.  The Field\
    \ Descriptors describe\n   the header fields with the following entries:\n   *\
    \  Field Identifier (FID) designates a protocol and field (e.g., UDP\n      Destination\
    \ Port), unambiguously among all protocols that a SCHC\n      compressor processes.\
    \  In the presence of protocol nesting, the\n      Field ID also identifies the\
    \ nesting.\n   *  Field Length (FL) represents the length of the original field.\
    \  It\n      can be either a fixed value (in bits) if the length is known when\n\
    \      the Rule is created or a type if the length is variable.  The\n      length\
    \ of a header field is defined by its own protocol\n      specification (e.g.,\
    \ IPv6 or UDP).  If the length is variable, the\n      type defines the process\
    \ to compute the length and its unit (bits,\n      bytes...).\n   *  Field Position\
    \ (FP): most often, a field only occurs once in a\n      packet header.  However,\
    \ some fields may occur multiple times.  An\n      example is the uri-path of\
    \ CoAP.  FP indicates which occurrence\n      this Field Descriptor applies to.\
    \  The default value is 1.  The\n      value 1 designates the first occurrence.\
    \  The value 0 is special.\n      It means \"don't care\", see Section 7.2.\n\
    \   *  A Direction Indicator (DI) indicates the packet direction(s) this\n   \
    \   Field Descriptor applies to.  It allows for asymmetric processing,\n     \
    \ using the same Rule.  Three values are possible:\n      Up:  this Field Descriptor\
    \ is only applicable to packets traveling\n         Uplink.\n      Dw:  this Field\
    \ Descriptor is only applicable to packets traveling\n         Downlink.\n   \
    \   Bi:  this Field Descriptor is applicable to packets traveling\n         Uplink\
    \ or Downlink.\n   *  Target Value (TV) is the value used to match against the\
    \ packet\n      header field.  The Target Value can be a scalar value of any type\n\
    \      (integer, strings, etc.) or a more complex structure (array, list,\n  \
    \    etc.).  The types and representations are out of scope for this\n      document.\n\
    \   *  Matching Operator (MO) is the operator used to match the field\n      value\
    \ and the Target Value.  The Matching Operator may require\n      some parameters.\
    \  The set of MOs defined in this document can be\n      found in Section 7.3.\n\
    \   *  Compression/Decompression Action (CDA) describes the pair of\n      actions\
    \ that are performed at the compressor to compress a header\n      field and at\
    \ the decompressor to recover the original value of the\n      header field. \
    \ Some CDAs might use parameter values for their\n      operation.  The set of\
    \ CDAs defined in this document can be found\n      in Section 7.4.\n"
- title: 7.2.  Packet Processing
  contents:
  - "7.2.  Packet Processing\n   The compression/decompression process follows several\
    \ phases:\n   Compression Rule selection:  the general idea is to browse the Rule\n\
    \      set to find a Rule that has a matching Field Descriptor (given the\n  \
    \    DI and FP) for all and only those header fields that appear in the\n    \
    \  packet being compressed.  The detailed algorithm is the following:\n      *\
    \  The first step is to check the FIDs.  If any header field of\n         the\
    \ packet being examined cannot be matched with a Field\n         Descriptor with\
    \ the correct FID, the Rule MUST be disregarded.\n         If any Field Descriptor\
    \ in the Rule has a FID that cannot be\n         matched to one of the header\
    \ fields of the packet being\n         examined, the Rule MUST be disregarded.\n\
    \      *  The next step is to match the Field Descriptors by their\n         direction,\
    \ using the DI.  If any field of the packet header\n         cannot be matched\
    \ with a Field Descriptor with the correct FID\n         and DI, the Rule MUST\
    \ be disregarded.\n      *  Then, the Field Descriptors are further selected according\
    \ to\n         FP.  If any field of the packet header cannot be matched with a\n\
    \         Field Descriptor with the correct FID, DI and FP, the Rule MUST\n  \
    \       be disregarded.\n         The value 0 for FP means \"don't care\", i.e.,\
    \ the comparison of\n         this Field Descriptor's FP with the position of\
    \ the field of\n         the packet header being compressed returns True, whatever\
    \ that\n         position.  FP=0 can be useful to build compression Rules for\n\
    \         protocol headers in which some fields order is irrelevant.  An\n   \
    \      example could be uri-queries in CoAP.  Care needs to be\n         exercised\
    \ when writing Rules containing FP=0 values.  Indeed,\n         it may result\
    \ in decompressed packets having fields ordered\n         differently compared\
    \ to the original packet.\n      *  Once each header field has been associated\
    \ with a Field\n         Descriptor with matching FID, DI, and FP, each packet\
    \ field's\n         value is then compared to the corresponding TV stored in the\n\
    \         Rule for that specific field, using the MO.  If every field in\n   \
    \      the packet header satisfies the corresponding MOs of a Rule\n         (i.e.,\
    \ all MO results are True), that Rule is valid for use to\n         compress the\
    \ header.  Otherwise, the Rule MUST be disregarded.\n         This specification\
    \ does not prevent multiple Rules from\n         matching the above steps and,\
    \ therefore, being valid for use.\n         Which Rule to use among multiple valid\
    \ Rules is left to the\n         implementation.  As long as the same Rule set\
    \ is installed at\n         both ends, this degree of freedom does not constitute\
    \ an\n         interoperability issue.\n      *  If no valid compression Rule\
    \ is found, then the packet MUST be\n         sent uncompressed using the RuleID\
    \ dedicated to this purpose\n         (see Section 6).  The entire packet header\
    \ is the Compression\n         Residue (see Figure 4).  Sending an uncompressed\
    \ header is\n         likely to require SCHC F/R.\n   Compression:  if a valid\
    \ Rule is found, each field of the header is\n      compressed according to the\
    \ CDAs of the Rule.  The fields are\n      compressed in the order that the Field\
    \ Descriptors appear in the\n      Rule.  The compression of each field results\
    \ in a residue, which\n      may be empty.  The Compression Residue for the packet\
    \ header is\n      the concatenation of the non-empty residues for each field\
    \ of the\n      header, in the order the Field Descriptors appear in the Rule.\n\
    \      The order in which the Field Descriptors appear in the Rule is\n      therefore\
    \ semantically important.\n       |------------------- Compression Residue -------------------|\n\
    \       | field 1 residue | field 2 residue | ... | field N residue |\n      \
    \            Figure 7: Compression Residue Structure\n   Sending:  The RuleID\
    \ is sent to the other end jointly with the\n      Compression Residue (which\
    \ could be empty) or the uncompressed\n      header, and directly followed by\
    \ the payload (see Figure 4).  The\n      way the RuleID is sent will be specified\
    \ in the Profile and is out\n      of the scope of the present document.  For\
    \ example, it could be\n      included in an L2 header or sent as part of the\
    \ L2 payload.\n   Decompression:  when decompressing, on the Network Infrastructure\n\
    \      side, the SCHC C/D needs to find the correct Rule based on the L2\n   \
    \   address of the Dev.  On the Dev side, only the RuleID is needed to\n     \
    \ identify the correct Rule since the Dev typically only holds Rules\n      that\
    \ apply to itself.\n      This Rule describes the compressed header format.  From\
    \ this, the\n      decompressor determines the order of the residues, the fixed-size\n\
    \      or variable-size nature of each residue (see Section 7.4.2), and\n    \
    \  the size of the fixed-size residues.\n      Therefore, from the received compressed\
    \ header, it can retrieve\n      all the residue values and associate them to\
    \ the corresponding\n      header fields.\n      For each field in the header,\
    \ the receiver applies the CDA action\n      associated with that field in order\
    \ to reconstruct the original\n      header field value.  The CDA application\
    \ order can be different\n      from the order in which the fields are listed\
    \ in the Rule.  In\n      particular, Compute-* MUST be applied after the application\
    \ of the\n      CDAs of all the fields it computes on.\n"
- title: 7.3.  Matching Operators
  contents:
  - "7.3.  Matching Operators\n   MOs are functions used at the compression side of\
    \ SCHC C/D.  They are\n   not typed and can be applied to integer, string or any\
    \ other data\n   type.  The result of the operation can either be True or False.\
    \  The\n   following MOs are defined:\n   equal:  The match result is True if\
    \ the field value in the packet\n      matches the TV.\n   ignore:  No matching\
    \ is attempted between the field value in the\n      packet and the TV in the\
    \ Rule.  The result is always True.\n   MSB(x):  A match is obtained if the most\
    \ significant (leftmost) x\n      bits of the packet header field value are equal\
    \ to the TV in the\n      Rule.  The x parameter of the MSB MO indicates how many\
    \ bits are\n      involved in the comparison.  If the FL is described as variable,\n\
    \      the x parameter must be a multiple of the FL unit.  For example, x\n  \
    \    must be multiple of 8 if the unit of the variable length is bytes.\n   match-mapping:\
    \  With match-mapping, TV is a list of values.  Each\n      value of the list\
    \ is identified by an index.  Compression is\n      achieved by sending the index\
    \ instead of the original header field\n      value.  This operator matches if\
    \ the header field value is equal\n      to one of the values in the target list.\n"
- title: 7.4.  Compression/Decompression Actions (CDA)
  contents:
  - "7.4.  Compression/Decompression Actions (CDA)\n   The CDA specifies the actions\
    \ taken during the compression of header\n   fields and the inverse action taken\
    \ by the decompressor to restore\n   the original value.  The CDAs defined by\
    \ this document are described\n   in detail in Section 7.4.3 to Section 7.4.8.\
    \  They are summarized in\n   Table 1.\n     | Action       | Compression    \
    \        | Decompression         |\n     | not-sent     | elided             \
    \    | use TV stored in Rule |\n     | value-sent   | send                   |\
    \ use received value    |\n     | mapping-sent | send index             | retrieve\
    \ value from   |\n     | LSB          | send least significant | concatenate TV\
    \ and    |\n     |              | bits (LSB)             | received value    \
    \    |\n     | compute-*    | elided                 | recompute at          |\n\
    \     | DevIID       | elided                 | build IID from L2 Dev |\n    \
    \ | AppIID       | elided                 | build IID from L2 App |\n        \
    \       Table 1: Compression and Decompression Actions\n   The first column shows\
    \ the action's name.  The second and third\n   columns show the compression and\
    \ decompression behaviors for each\n   action.\n"
- title: 7.4.1.  Processing Fixed-Length Fields
  contents:
  - "7.4.1.  Processing Fixed-Length Fields\n   If the field is identified in the\
    \ Field Descriptor as being of fixed\n   length, then applying the CDA to compress\
    \ this field results in a\n   fixed amount of bits.  The residue for that field\
    \ is simply the bits\n   resulting from applying the CDA to the field.  This value\
    \ may be\n   empty (e.g., not-sent CDA), in which case the field residue is absent\n\
    \   from the Compression Residue.\n   |- field residue -|\n   +-----------------+\n\
    \   |      value      |\n   +-----------------+\n                Figure 8: Fixed-Size\
    \ Field Residue Structure\n"
- title: 7.4.2.  Processing Variable-Length Fields
  contents:
  - "7.4.2.  Processing Variable-Length Fields\n   If the field is identified in the\
    \ Field Descriptor as being of\n   variable length, then applying the CDA to compress\
    \ this field may\n   result in a value of fixed size (e.g., not-sent or mapping-sent)\
    \ or\n   of variable size (e.g., value-sent or LSB).  In the latter case, the\n\
    \   residue for that field is the bits that result from applying the CDA\n   to\
    \ the field, preceded with the size of the value.  The most\n   significant bit\
    \ of the size is stored to the left (leftmost bit of\n   the residue field).\n\
    \   |--- field residue ---|\n   +-------+-------------+\n   |  size |    value\
    \    |\n   +-------+-------------+\n              Figure 9: Variable-Size Field\
    \ Residue Structure\n   The size (using the unit defined in the FL) is encoded\
    \ on 4, 12, or\n   28 bits as follows:\n   *  If the size is between 0 and 14,\
    \ it is encoded as a 4-bit unsigned\n      integer.\n   *  Sizes between 15 and\
    \ 254 are encoded as 0b1111 followed by the\n      8-bit unsigned integer.\n \
    \  *  Larger sizes are encoded as 0xfff followed by the 16-bit unsigned\n    \
    \  integer.\n   If the field is identified in the Field Descriptor as being of\n\
    \   variable length and this field is not present in the packet header\n   being\
    \ compressed, size 0 MUST be sent to denote its absence.\n"
- title: 7.4.3.  Not-Sent CDA
  contents:
  - "7.4.3.  Not-Sent CDA\n   The not-sent action can be used when the field value\
    \ is specified in\n   a Rule and, therefore, known by both the Compressor and\
    \ the\n   Decompressor.  This action SHOULD be used with the \"equal\" MO.  If\
    \ MO\n   is \"ignore\", there is a risk of having a decompressed field value\n\
    \   that is different from the original field that was compressed.\n   The compressor\
    \ does not send any residue for a field on which not-\n   sent compression is\
    \ applied.\n   The decompressor restores the field value with the TV stored in\
    \ the\n   matched Rule identified by the received RuleID.\n"
- title: 7.4.4.  Value-Sent CDA
  contents:
  - "7.4.4.  Value-Sent CDA\n   The value-sent action can be used when the field value\
    \ is not known\n   by both the Compressor and the Decompressor.  The field is\
    \ sent in\n   its entirety, using the same bit order as in the original packet\n\
    \   header.\n   If this action is performed on a variable-length field, the size\
    \ of\n   the residue value (using the units defined in FL) MUST be sent as\n \
    \  described in Section 7.4.2.\n   This action is generally used with the \"ignore\"\
    \ MO.\n"
- title: 7.4.5.  Mapping-Sent CDA
  contents:
  - "7.4.5.  Mapping-Sent CDA\n   The mapping-sent action is used to send an index\
    \ (the index into the\n   TV list of values) instead of the original value.  This\
    \ action is\n   used together with the \"match-mapping\" MO.\n   On the compressor\
    \ side, the match-mapping MO searches the TV for a\n   match with the header field\
    \ value.  The mapping-sent CDA then sends\n   the corresponding index as the field\
    \ residue.  The most significant\n   bit of the index is stored to the left (leftmost\
    \ bit of the residue\n   field).\n   On the decompressor side, the CDA uses the\
    \ received index to restore\n   the field value by looking up the list in the\
    \ TV.\n   The number of bits sent is the minimal size for coding all the\n   possible\
    \ indices.\n   The first element in the list MUST be represented by index value\
    \ 0,\n   and successive elements in the list MUST have indices incremented by\n\
    \   1.\n"
- title: 7.4.6.  LSB CDA
  contents:
  - "7.4.6.  LSB CDA\n   The LSB action is used together with the \"MSB(x)\" MO to\
    \ avoid sending\n   the most significant part of the packet field if that part\
    \ is already\n   known by the receiving end.\n   The compressor sends the LSBs\
    \ as the field residue value.  The number\n   of bits sent is the original header\
    \ field length minus the length\n   specified in the MSB(x) MO.  The bits appear\
    \ in the residue in the\n   same bit order as in the original packet header.\n\
    \   The decompressor concatenates the x most significant bits of the TV\n   and\
    \ the received residue value.\n   If this action is performed on a variable-length\
    \ field, the size of\n   the residue value (using the units defined in FL) MUST\
    \ be sent as\n   described in Section 7.4.2.\n"
- title: 7.4.7.  DevIID, AppIID CDA
  contents:
  - "7.4.7.  DevIID, AppIID CDA\n   These actions are used to process the DevIID and\
    \ AppIID of the IPv6\n   addresses, respectively.  AppIID CDA is less common since\
    \ most\n   current LPWAN technologies frames contain a single L2 address, which\n\
    \   is the Dev's address.\n   The DevIID value MAY be computed from the Dev ID\
    \ present in the L2\n   header, or from some other stable identifier.  The computation\
    \ is\n   specific to each Profile and MAY depend on the Dev ID size.\n   In the\
    \ Downlink direction, at the compressor, the DevIID CDA may be\n   used to generate\
    \ the L2 addresses on the LPWAN, based on the packet's\n   Destination Address.\n"
- title: 7.4.8.  Compute-*
  contents:
  - "7.4.8.  Compute-*\n   Some fields can be elided at the compressor and recomputed\
    \ locally at\n   the decompressor.\n   Because the field is uniquely identified\
    \ by its FID (e.g., IPv6\n   length), the relevant protocol specification unambiguously\
    \ defines\n   the algorithm for such computation.\n   An example of a field that\
    \ knows how to recompute itself is IPv6\n   length.\n"
- title: 8.  Fragmentation/Reassembly
  contents:
  - '8.  Fragmentation/Reassembly

    '
- title: 8.1.  Overview
  contents:
  - "8.1.  Overview\n   In LPWAN technologies, the L2 MTU typically ranges from tens\
    \ to\n   hundreds of bytes.  Some of these technologies do not have an\n   internal\
    \ fragmentation/reassembly mechanism.\n   The optional SCHC F/R functionality\
    \ enables such LPWAN technologies\n   to comply with the IPv6 MTU requirement\
    \ of 1280 bytes [RFC8200].  It\n   is OPTIONAL to implement per this specification,\
    \ but Profiles may\n   specify that it is REQUIRED.\n   This specification includes\
    \ several SCHC F/R modes, which allow for a\n   range of reliability options such\
    \ as optional SCHC Fragment\n   retransmission.  More modes may be defined in\
    \ the future.\n   The same SCHC F/R mode MUST be used for all SCHC Fragments of\
    \ a given\n   SCHC Packet.  This document does not specify which mode(s) must\
    \ be\n   implemented and used over a specific LPWAN technology.  That\n   information\
    \ will be given in Profiles.\n   SCHC allows transmitting non-fragmented SCHC\
    \ Packet concurrently with\n   fragmented SCHC Packets.  In addition, SCHC F/R\
    \ provides protocol\n   elements that allow transmitting several fragmented SCHC\
    \ Packets\n   concurrently, i.e., interleaving the transmission of fragments from\n\
    \   different fragmented SCHC Packets.  A Profile MAY restrict the latter\n  \
    \ behavior.\n   The L2 Word size (see Section 4) determines the encoding of some\n\
    \   messages.  SCHC F/R usually generates SCHC Fragments and SCHC ACKs\n   that\
    \ are multiples of L2 Words.\n"
- title: 8.2.  SCHC F/R Protocol Elements
  contents:
  - "8.2.  SCHC F/R Protocol Elements\n   This subsection describes the different\
    \ elements that are used to\n   enable the SCHC F/R functionality defined in this\
    \ document.  These\n   elements include the SCHC F/R messages, tiles, windows,\
    \ bitmaps,\n   counters, timers, and header fields.\n   The elements are described\
    \ here in a generic manner.  Their\n   application to each SCHC F/R mode is found\
    \ in Section 8.4.\n"
- title: 8.2.1.  Messages
  contents:
  - "8.2.1.  Messages\n   SCHC F/R defines the following messages:\n   SCHC Fragment:\
    \  A message that carries part of a SCHC Packet from the\n      sender to the\
    \ receiver.\n   SCHC ACK:  An acknowledgement for fragmentation, by the receiver\
    \ to\n      the sender.  This message is used to indicate whether or not the\n\
    \      reception of pieces of, or the whole of, the fragmented SCHC\n      Packet\
    \ was successful.\n   SCHC ACK REQ:  A request by the sender for a SCHC ACK from\
    \ the\n      receiver.\n   SCHC Sender-Abort:  A message by the sender telling\
    \ the receiver that\n      it has aborted the transmission of a fragmented SCHC\
    \ Packet.\n   SCHC Receiver-Abort:  A message by the receiver to tell the sender\
    \ to\n      abort the transmission of a fragmented SCHC Packet.\n   The format\
    \ of these messages is provided in Section 8.3.\n"
- title: 8.2.2.  Tiles, Windows, Bitmaps, Timers, Counters
  contents:
  - '8.2.2.  Tiles, Windows, Bitmaps, Timers, Counters

    '
- title: 8.2.2.1.  Tiles
  contents:
  - "8.2.2.1.  Tiles\n   The SCHC Packet is fragmented into pieces, hereafter called\
    \ \"tiles\".\n   The tiles MUST be non-empty and pairwise disjoint.  Their union\
    \ MUST\n   be equal to the SCHC Packet.\n   See Figure 10 for an example.\n  \
    \ Tiles   |    |  |     |   |    | |   |     |        |    |   |      |\n    \
    \             Figure 10: SCHC Packet Fragmented in Tiles\n   Modes (see Section\
    \ 8.4) MAY place additional constraints on tile\n   sizes.\n   Each SCHC Fragment\
    \ message carries at least one tile in its Payload,\n   if the Payload field is\
    \ present.\n"
- title: 8.2.2.2.  Windows
  contents:
  - "8.2.2.2.  Windows\n   Some SCHC F/R modes may handle successive tiles in groups,\
    \ called\n   windows.\n   If windows are used:\n   *  all the windows of a SCHC\
    \ Packet, except the last one, MUST\n      contain the same number of tiles. \
    \ This number is WINDOW_SIZE.\n   *  WINDOW_SIZE MUST be specified in a Profile.\n\
    \   *  the windows are numbered.\n   *  their numbers MUST increment by 1 from\
    \ 0 upward, from the start of\n      the SCHC Packet to its end.\n   *  the last\
    \ window MUST contain WINDOW_SIZE tiles or less.\n   *  tiles are numbered within\
    \ each window.\n   *  the tile indices MUST decrement by 1 from WINDOW_SIZE -\
    \ 1\n      downward, looking from the start of the SCHC Packet toward its\n  \
    \    end.\n   *  therefore, each tile of a SCHC Packet is uniquely identified\
    \ by a\n      window number and a tile index within this window.\n   See Figure\
    \ 11 for an example.\n   Tile#   | 4 | 3 | 2 | 1 | 0 | 4 | 3 | 2 | 1 | 0 | 4 |\
    \     | 0 | 4 |3|\n   Window# |-------- 0 --------|-------- 1 --------|- 2  ...\
    \ 27 -|- 28-|\n     Figure 11: SCHC Packet Fragmented in Tiles Grouped in 29 Windows,\n\
    \                            with WINDOW_SIZE = 5\n   Appendix E discusses the\
    \ benefits of selecting one among multiple\n   window sizes depending on the size\
    \ of the SCHC Packet to be\n   fragmented.\n   When windows are used:\n   *  Bitmaps\
    \ (see Section 8.2.2.3) MAY be sent back by the receiver to\n      the sender\
    \ in a SCHC ACK message.\n   *  A Bitmap corresponds to exactly one Window.\n"
- title: 8.2.2.3.  Bitmaps
  contents:
  - "8.2.2.3.  Bitmaps\n   Each bit in the Bitmap for a window corresponds to a tile\
    \ in the\n   window.  Therefore, each Bitmap has WINDOW_SIZE bits.  The bit at\
    \ the\n   leftmost position corresponds to the tile numbered WINDOW_SIZE - 1.\n\
    \   Consecutive bits, going right, correspond to sequentially decreasing\n   tile\
    \ indices.  In Bitmaps for windows that are not the last one of a\n   SCHC Packet,\
    \ the bit at the rightmost position corresponds to the\n   tile numbered 0.  In\
    \ the Bitmap for the last window, the bit at the\n   rightmost position corresponds\
    \ either to the tile numbered 0 or to a\n   tile that is sent/received as \"the\
    \ last one of the SCHC Packet\"\n   without explicitly stating its number (see\
    \ Section 8.3.1.2).\n   At the receiver:\n   *  a bit set to 1 in the Bitmap indicates\
    \ that a tile associated with\n      that bit position has been correctly received\
    \ for that window.\n   *  a bit set to 0 in the Bitmap indicates that there has\
    \ been no tile\n      correctly received, associated with that bit position, for\
    \ that\n      window.  Possible reasons include that the tile was not sent at\n\
    \      all, not received, or received with errors.\n"
- title: 8.2.2.4.  Timers and Counters
  contents:
  - "8.2.2.4.  Timers and Counters\n   Some SCHC F/R modes can use the following timers\
    \ and counters:\n   Inactivity Timer:  a SCHC Fragment receiver uses this timer\
    \ to abort\n      waiting for a SCHC F/R message.\n   Retransmission Timer:  a\
    \ SCHC Fragment sender uses this timer to\n      abort waiting for an expected\
    \ SCHC ACK.\n   Attempts:  this counter counts the requests for SCHC ACKs, up\
    \ to\n      MAX_ACK_REQUESTS.\n"
- title: 8.2.3.  Integrity Checking
  contents:
  - "8.2.3.  Integrity Checking\n   The integrity of the fragmentation-reassembly\
    \ process of a SCHC\n   Packet MUST be checked at the receive end.  A Profile\
    \ MUST specify\n   how integrity checking is performed.\n   It is RECOMMENDED\
    \ that integrity checking be performed by computing a\n   Reassembly Check Sequence\
    \ (RCS) based on the SCHC Packet at the\n   sender side and transmitting it to\
    \ the receiver for comparison with\n   the RCS locally computed after reassembly.\n\
    \   The RCS supports UDP checksum elision by SCHC C/D (see\n   Section 10.11).\n\
    \   The CRC32 polynomial 0xEDB88320 (i.e., the reversed polynomial\n   representation,\
    \ which is used in the Ethernet standard [ETHERNET]) is\n   RECOMMENDED as the\
    \ default algorithm for computing the RCS.\n   The RCS MUST be computed on the\
    \ full SCHC Packet concatenated with\n   the padding bits, if any, of the SCHC\
    \ Fragment carrying the last\n   tile.  The rationale is that the SCHC reassembler\
    \ has no way of\n   knowing the boundary between the last tile and the padding\
    \ bits.\n   Indeed, this requires decompressing the SCHC Packet, which is out\
    \ of\n   the scope of the SCHC reassembler.\n   The concatenation of the complete\
    \ SCHC Packet and any padding bits,\n   if present, of the last SCHC Fragment\
    \ does not generally constitute\n   an integer number of bytes.  CRC libraries\
    \ are usually byte oriented.\n   It is RECOMMENDED that the concatenation of the\
    \ complete SCHC Packet\n   and any last fragment padding bits be zero-extended\
    \ to the next byte\n   boundary and that the RCS be computed on that byte array.\n"
- title: 8.2.4.  Header Fields
  contents:
  - "8.2.4.  Header Fields\n   The SCHC F/R messages contain the following fields\
    \ (see the formats\n   in Section 8.3):\n   RuleID:  this field is present in\
    \ all the SCHC F/R messages.  The\n      Rule identifies:\n      *  that a SCHC\
    \ F/R message is being carried, as opposed to an\n         unfragmented SCHC Packet,\n\
    \      *  which SCHC F/R mode is used,\n      *  in case this mode uses windows,\
    \ what the value of WINDOW_SIZE\n         is, and\n      *  what other optional\
    \ fields are present and what the field sizes\n         are.\n      The Rule tells\
    \ apart a non-fragmented SCHC Packet from SCHC\n      Fragments.  It will also\
    \ tell apart SCHC Fragments of fragmented\n      SCHC Packets that use different\
    \ SCHC F/R modes or different\n      parameters.  Therefore, interleaved transmission\
    \ of these is\n      possible.\n      All SCHC F/R messages pertaining to the\
    \ same SCHC Packet MUST bear\n      the same RuleID.\n   Datagram Tag (DTag):\
    \  This field allows differentiating SCHC F/R\n      messages belonging to different\
    \ SCHC Packets that may be using the\n      same RuleID simultaneously.  Hence,\
    \ it allows interleaving\n      fragments of a new SCHC Packet with fragments\
    \ of a previous SCHC\n      Packet under the same RuleID.\n      The size of the\
    \ DTag field (called \"T\", in bits) is defined by\n      each Profile for each\
    \ RuleID.  When T is 0, the DTag field does\n      not appear in the SCHC F/R\
    \ messages and the DTag value is defined\n      as 0.\n      When T is 0, there\
    \ can be no more than one fragmented SCHC Packet\n      in transit for each fragmentation\
    \ RuleID.\n      If T is not 0, DTag:\n      *  MUST be set to the same value\
    \ for all the SCHC F/R messages\n         related to the same fragmented SCHC\
    \ Packet, and\n      *  MUST be set to different values for SCHC F/R messages\
    \ related\n         to different SCHC Packets that are being fragmented under\
    \ the\n         same RuleID and whose transmission may overlap.\n   W:  The W\
    \ field is optional.  It is only present if windows are used.\n      Its presence\
    \ and size (called \"M\", in bits) is defined by each\n      SCHC F/R mode and\
    \ each Profile for each RuleID.\n      This field carries information pertaining\
    \ to the window a SCHC F/R\n      message relates to.  If present, W MUST carry\
    \ the same value for\n      all the SCHC F/R messages related to the same window.\
    \  Depending\n      on the mode and Profile, W may carry the full window number,\
    \ or\n      just the LSB or any other partial representation of the window\n \
    \     number.\n   Fragment Compressed Number (FCN):  The FCN field is present\
    \ in the\n      SCHC Fragment Header.  Its size (called \"N\", in bits) is defined\n\
    \      by each Profile for each RuleID.\n      This field conveys information\
    \ about the progress in the sequence\n      of tiles being transmitted by SCHC\
    \ Fragment messages.  For\n      example, it can contain a partial, efficient\
    \ representation of a\n      larger-sized tile index.  The description of the\
    \ exact use of the\n      FCN field is left to each SCHC F/R mode.  However, two\
    \ values are\n      reserved for special purposes.  They help control the SCHC\
    \ F/R\n      process:\n      *  The FCN value with all the bits equal to 1 (called\
    \ \"All-1\")\n         signals that the very last tile of a SCHC Packet has been\n\
    \         transmitted.  By extension, if windows are used, the last\n        \
    \ window of a packet is called the \"All-1\" window.\n      *  If windows are\
    \ used, the FCN value with all the bits equal to 0\n         (called \"All-0\"\
    ) signals the last tile of a window that is not\n         the last one of the\
    \ SCHC packet.  By extension, such a window\n         is called an \"All-0 window\"\
    .\n   Reassembly Check Sequence (RCS):  This field only appears in the\n     \
    \ All-1 SCHC Fragments.  Its size (called \"U\", in bits) is defined\n      by\
    \ each Profile for each RuleID.\n      See Section 8.2.3 for the RCS default size,\
    \ default polynomial and\n      details on RCS computation.\n   C (integrity Check):\
    \  C is a 1-bit field.  This field is used in the\n      SCHC ACK message to report\
    \ on the reassembled SCHC Packet\n      integrity check (see Section 8.2.3).\n\
    \      A value of 1 tells that the integrity check was performed and is\n    \
    \  successful.  A value of 0 tells that the integrity check was not\n      performed\
    \ or that it was a failure.\n   Compressed Bitmap:  The Compressed Bitmap is used\
    \ together with\n      windows and Bitmaps (see Section 8.2.2.3).  Its presence\
    \ and size\n      is defined for each SCHC F/R mode for each RuleID.\n      This\
    \ field appears in the SCHC ACK message to report on the\n      receiver Bitmap\
    \ (see Section 8.3.2.1).\n"
- title: 8.3.  SCHC F/R Message Formats
  contents:
  - "8.3.  SCHC F/R Message Formats\n   This section defines the SCHC Fragment formats,\
    \ the SCHC ACK format,\n   the SCHC ACK REQ format and the SCHC Abort formats.\n"
- title: 8.3.1.  SCHC Fragment Format
  contents:
  - "8.3.1.  SCHC Fragment Format\n   A SCHC Fragment conforms to the general format\
    \ shown in Figure 12.\n   It comprises a SCHC Fragment Header and a SCHC Fragment\
    \ Payload.  The\n   SCHC Fragment Payload carries one or several tile(s).\n  \
    \ | Fragment Header | Fragment Payload      | padding (as needed)\n          \
    \        Figure 12: SCHC Fragment General Format\n"
- title: 8.3.1.1.  Regular SCHC Fragment
  contents:
  - "8.3.1.1.  Regular SCHC Fragment\n   The Regular SCHC Fragment format is shown\
    \ in Figure 13.  Regular SCHC\n   Fragments are generally used to carry tiles\
    \ that are not the last one\n   of a SCHC Packet.  The DTag field and the W field\
    \ are OPTIONAL, their\n   presence is specified by each mode and Profile.\n  \
    \ |-- SCHC Fragment Header ----|\n            |-- T --|-M-|-- N --|\n   | RuleID\
    \ | DTag  | W |  FCN  | Fragment Payload | padding (as needed)\n        Figure\
    \ 13: Detailed Header Format for Regular SCHC Fragments\n   The FCN field MUST\
    \ NOT contain all bits set to 1.\n   Profiles MUST ensure that a SCHC Fragment\
    \ with FCN equal to 0 (called\n   an \"All-0 SCHC Fragment\") is distinguishable\
    \ by size, even in the\n   presence of padding, from a SCHC ACK REQ message (see\
    \ Section 8.3.3)\n   with the same RuleID value and with the same T, M, and N\
    \ values.\n   This condition is met if the Payload is at least the size of an\
    \ L2\n   Word.  This condition is also met if the SCHC Fragment Header is a\n\
    \   multiple of L2 Words.\n"
- title: 8.3.1.2.  All-1 SCHC Fragment
  contents:
  - "8.3.1.2.  All-1 SCHC Fragment\n   The All-1 SCHC Fragment format is shown in\
    \ Figure 14.  The sender\n   uses the All-1 SCHC Fragment format for the message\
    \ that completes\n   the emission of a fragmented SCHC Packet.  The DTag field,\
    \ the W\n   field, the RCS field and the Payload are OPTIONAL, their presence\
    \ is\n   specified by each mode and Profile.  At least one of RCS field or\n \
    \  Fragment Payload MUST be present.  The FCN field is all ones.\n   |-------\
    \ SCHC Fragment Header -------|\n            |-- T --|-M-|-- N --|-- U --|\n \
    \  | RuleID | DTag  | W | 11..1 |  RCS  | FragPayload | pad. (as needed)\n   \
    \                       (FCN)\n       Figure 14: Detailed Header Format for the\
    \ All-1 SCHC Fragment\n   Profiles MUST ensure that an All-1 SCHC Fragment message\
    \ is\n   distinguishable by size, even in the presence of padding, from a SCHC\n\
    \   Sender-Abort message (see Section 8.3.4) with the same RuleID value\n   and\
    \ with the same T, M, and N values.  This condition is met if the\n   RCS is present\
    \ and is at least the size of an L2 Word or if the\n   Payload is present and\
    \ is at least the size an L2 Word.  This\n   condition is also met if the SCHC\
    \ Sender-Abort Header is a multiple\n   of L2 Words.\n"
- title: 8.3.2.  SCHC ACK Format
  contents:
  - "8.3.2.  SCHC ACK Format\n   The SCHC ACK message is shown in Figure 15.  The\
    \ DTag field and the W\n   field are OPTIONAL, their presence is specified by\
    \ each mode and\n   Profile.  The Compressed Bitmap field MUST be present in SCHC\
    \ F/R\n   modes that use windows and MUST NOT be present in other modes.\n   |---\
    \ SCHC ACK Header ----|\n            |-- T --|-M-| 1 |\n   | RuleID |  DTag |\
    \ W |C=1| padding as needed                (success)\n   | RuleID |  DTag | W\
    \ |C=0|Compressed Bitmap| pad. as needed (failure)\n                 Figure 15:\
    \ Format of the SCHC ACK Message\n   The SCHC ACK Header contains a C bit (see\
    \ Section 8.2.4).\n   If the C bit is set to 1 (integrity check successful), no\
    \ Bitmap is\n   carried.\n   If the C bit is set to 0 (integrity check not performed\
    \ or failed)\n   and if windows are used, a Compressed Bitmap for the window referred\n\
    \   to by the W field is transmitted as specified in Section 8.3.2.1.\n"
- title: 8.3.2.1.  Bitmap Compression
  contents:
  - "8.3.2.1.  Bitmap Compression\n   For transmission, the Compressed Bitmap in the\
    \ SCHC ACK message is\n   defined by the following algorithm (see Figure 16 for\
    \ a follow-along\n   example):\n   *  Build a temporary SCHC ACK message that\
    \ contains the Header\n      followed by the original Bitmap (see Section 8.2.2.3\
    \ for a\n      description of Bitmaps).\n   *  Position scissors at the end of\
    \ the Bitmap, after its last bit.\n   *  While the bit on the left of the scissors\
    \ is 1 and belongs to the\n      Bitmap, keep moving left, then stop.\n   *  Then,\
    \ while the scissors are not on an L2 Word boundary of the\n      SCHC ACK message\
    \ and there is a Bitmap bit on the right of the\n      scissors, keep moving right,\
    \ then stop.\n   *  At this point, cut and drop off any bits to the right of the\n\
    \      scissors.\n   When one or more bits have effectively been dropped off as\
    \ a result\n   of the above algorithm, the SCHC ACK message is a multiple of L2\n\
    \   Words; no padding bits will be appended.\n   Because the SCHC Fragment sender\
    \ knows the size of the original\n   Bitmap, it can reconstruct the original Bitmap\
    \ from the Compressed\n   Bitmap received in the SCHC ACK message.\n   Figure\
    \ 16 shows an example where L2 Words are actually bytes and\n   where the original\
    \ Bitmap contains 17 bits, the last 15 of which are\n   all set to 1.\n   |---\
    \ SCHC ACK Header ----|--------      Bitmap     --------|\n            |-- T --|-M-|\
    \ 1 |\n   | RuleID |  DTag | W |C=0|1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1|\n     \
    \     next L2 Word boundary ->|\n            Figure 16: SCHC ACK Header Plus Uncompressed\
    \ Bitmap\n   Figure 17 shows that the last 14 bits are not sent.\n   |--- SCHC\
    \ ACK Header ----|CpBmp|\n            |-- T --|-M-| 1 |\n   | RuleID |  DTag |\
    \ W |C=0|1 0 1|\n          next L2 Word boundary ->|\n        Figure 17: Resulting\
    \ SCHC ACK Message with Compressed Bitmap\n   Figure 18 shows an example of a\
    \ SCHC ACK with tile indices ranging\n   from 6 down to 0, where the Bitmap indicates\
    \ that the second and the\n   fourth tile of the window have not been correctly\
    \ received.\n   |--- SCHC ACK Header ----|--- Bitmap --|\n            |-- T --|-M-|\
    \ 1 |6 5 4 3 2 1 0| (tile #)\n   | RuleID |  DTag | W |C=0|1 0 1 0 1 1 1|    \
    \ uncompressed Bitmap\n      next L2 Word boundary ->|<-- L2 Word --->|\n   |\
    \ RuleID |  DTag | W |C=0|1 0 1 0 1 1 1|pad.| transmitted SCHC ACK\n      next\
    \ L2 Word boundary ->|<-- L2 Word --->|\n          Figure 18: Example of a SCHC\
    \ ACK Message, Missing Tiles\n   Figure 19 shows an example of a SCHC ACK with\
    \ tile indices ranging\n   from 6 down to 0, where integrity check has not been\
    \ performed or has\n   failed and the Bitmap indicates that there is no missing\
    \ tile in that\n   window.\n   |--- SCHC ACK Header ----|--- Bitmap --|\n    \
    \        |-- T --|-M-| 1 |6 5 4 3 2 1 0| (tile #)\n   | RuleID |  DTag | W |C=0|1\
    \ 1 1 1 1 1 1|  with uncompressed Bitmap\n      next L2 Word boundary ->|\n  \
    \ | RuleID |  DTag | W |C=0|1|                  transmitted SCHC ACK\n      next\
    \ L2 Word boundary ->|\n         Figure 19: Example of a SCHC ACK Message, No\
    \ Missing Tile\n"
- title: 8.3.3.  SCHC ACK REQ Format
  contents:
  - "8.3.3.  SCHC ACK REQ Format\n   The SCHC ACK REQ is used by a sender to request\
    \ a SCHC ACK from the\n   receiver.  Its format is shown in Figure 20.  The DTag\
    \ field and the\n   W field are OPTIONAL, their presence is specified by each\
    \ mode and\n   Profile.  The FCN field is all zero.\n   |--- SCHC ACK REQ Header\
    \ ----|\n            |-- T --|-M-|-- N --|\n   | RuleID | DTag  | W |  0..0 |\
    \ padding (as needed)      (no payload)\n                       Figure 20: SCHC\
    \ ACK REQ Format\n"
- title: 8.3.4.  SCHC Sender-Abort Format
  contents:
  - "8.3.4.  SCHC Sender-Abort Format\n   When a SCHC Fragment sender needs to abort\
    \ an ongoing fragmented SCHC\n   Packet transmission, it sends a SCHC Sender-Abort\
    \ message to the SCHC\n   Fragment receiver.\n   The SCHC Sender-Abort format\
    \ is shown in Figure 21.  The DTag field\n   and the W field are OPTIONAL, their\
    \ presence is specified by each\n   mode and Profile.  The FCN field is all ones.\n\
    \   |--- Sender-Abort Header ----|\n            |-- T --|-M-|-- N --|\n   | RuleID\
    \ | DTag  | W | 11..1 | padding (as needed)\n                    Figure 21: SCHC\
    \ Sender-Abort Format\n   If the W field is present:\n   *  the fragment sender\
    \ MUST set it to all ones.  Other values are\n      RESERVED.\n   *  the fragment\
    \ receiver MUST check its value.  If the value is\n      different from all ones,\
    \ the message MUST be ignored.\n   The SCHC Sender-Abort MUST NOT be acknowledged.\n"
- title: 8.3.5.  SCHC Receiver-Abort Format
  contents:
  - "8.3.5.  SCHC Receiver-Abort Format\n   When a SCHC Fragment receiver needs to\
    \ abort an ongoing fragmented\n   SCHC Packet transmission, it transmits a SCHC\
    \ Receiver-Abort message\n   to the SCHC Fragment sender.\n   The SCHC Receiver-Abort\
    \ format is shown in Figure 22.  The DTag field\n   and the W field are OPTIONAL,\
    \ their presence is specified by each\n   mode and Profile.\n   |-- Receiver-Abort\
    \ Header ---|\n              |--- T ---|-M-| 1 |\n   |  RuleID  |   DTag  | W\
    \ |C=1| 1..1|      1..1     |\n              next L2 Word boundary ->|<-- L2 Word\
    \ -->|\n                   Figure 22: SCHC Receiver-Abort Format\n   If the W\
    \ field is present:\n   *  the fragment receiver MUST set it to all ones.  Other\
    \ values are\n      RESERVED.\n   *  if the value is different from all ones,\
    \ the fragment sender MUST\n      ignore the message.\n   The SCHC Receiver-Abort\
    \ has the same header as a SCHC ACK message.\n   The bits that follow the SCHC\
    \ Receiver-Abort Header MUST be as\n   follows:\n   *  if the Header does not\
    \ end at an L2 Word boundary, append bits set\n      to 1 as needed to reach the\
    \ next L2 Word boundary.\n   *  append exactly one more L2 Word with bits all\
    \ set to ones.\n   Such a bit pattern never occurs in a legitimate SCHC ACK. \
    \ This is\n   how the fragment sender recognizes a SCHC Receiver-Abort.\n   The\
    \ SCHC Receiver-Abort MUST NOT be acknowledged.\n"
- title: 8.4.  SCHC F/R Modes
  contents:
  - "8.4.  SCHC F/R Modes\n   This specification includes several SCHC F/R modes that:\n\
    \   *  allow for a range of reliability options, such as optional SCHC\n     \
    \ Fragment retransmission.\n   *  support various LPWAN characteristics, such\
    \ as links with variable\n      MTU or unidirectional links.\n   More modes may\
    \ be defined in the future.\n   Appendix B provides examples of fragmentation\
    \ sessions based on the\n   modes described hereafter.\n   Appendix C provides\
    \ examples of Finite State Machines implementing\n   the SCHC F/R modes described\
    \ hereafter.\n"
- title: 8.4.1.  No-ACK Mode
  contents:
  - "8.4.1.  No-ACK Mode\n   The No-ACK mode has been designed under the assumption\
    \ that data unit\n   out-of-sequence delivery does not occur between the entity\
    \ performing\n   fragmentation and the entity performing reassembly.  This mode\n\
    \   supports L2 technologies that have a variable MTU.\n   In No-ACK mode, there\
    \ is no communication from the fragment receiver\n   to the fragment sender. \
    \ The sender transmits all the SCHC Fragments\n   without expecting any acknowledgement.\
    \  Therefore, No-ACK does not\n   require bidirectional links: unidirectional\
    \ links are just fine.\n   In No-ACK mode, only the All-1 SCHC Fragment is padded\
    \ as needed.\n   The other SCHC Fragments are intrinsically aligned to L2 Words.\n\
    \   The tile sizes are not required to be uniform.  Windows are not used.\n  \
    \ The Retransmission Timer is not used.  The Attempts counter is not\n   used.\n\
    \   Each Profile MUST specify which RuleID value(s) corresponds to SCHC\n   F/R\
    \ messages operating in this mode.\n   The W field MUST NOT be present in the\
    \ SCHC F/R messages.  SCHC ACK\n   MUST NOT be sent.  SCHC ACK REQ MUST NOT be\
    \ sent.  SCHC Sender-Abort\n   MAY be sent.  SCHC Receiver-Abort MUST NOT be sent.\n\
    \   The value of N (size of the FCN field) is RECOMMENDED to be 1.\n   Each Profile,\
    \ for each RuleID value, MUST define:\n   *  the size of the DTag field,\n   *\
    \  the size and algorithm for the RCS field, and\n   *  the expiration time of\
    \ the Inactivity Timer.\n   Each Profile, for each RuleID value, MAY define\n\
    \   *  a value of N different from the recommended one, and\n   *  the meaning\
    \ of values sent in the FCN field, for values different\n      from the All-1\
    \ value.\n   For each active pair of RuleID and DTag values, the receiver MUST\n\
    \   maintain an Inactivity Timer.  If the receiver is under-resourced to\n   do\
    \ this, it MUST silently drop the related messages.\n"
- title: 8.4.1.1.  Sender Behavior
  contents:
  - "8.4.1.1.  Sender Behavior\n   At the beginning of the fragmentation of a new\
    \ SCHC Packet, the\n   fragment sender MUST select a RuleID and DTag value pair\
    \ for this\n   SCHC Packet.\n   Each SCHC Fragment MUST contain exactly one tile\
    \ in its Payload.  The\n   tile MUST be at least the size of an L2 Word.  The\
    \ sender MUST\n   transmit the SCHC Fragments messages in the order that the tiles\n\
    \   appear in the SCHC Packet.  Except for the last tile of a SCHC\n   Packet,\
    \ each tile MUST be of a size that complements the SCHC\n   Fragment Header so\
    \ that the SCHC Fragment is a multiple of L2 Words\n   without the need for padding\
    \ bits.  Except for the last one, the SCHC\n   Fragments MUST use the Regular\
    \ SCHC Fragment format specified in\n   Section 8.3.1.1.  The SCHC Fragment that\
    \ carries the last tile MUST\n   be an All-1 SCHC Fragment, described in Section\
    \ 8.3.1.2.\n   The sender MAY transmit a SCHC Sender-Abort.\n   Figure 39 shows\
    \ an example of a corresponding state machine.\n"
- title: 8.4.1.2.  Receiver Behavior
  contents:
  - "8.4.1.2.  Receiver Behavior\n   Upon receiving each Regular SCHC Fragment:\n\
    \   *  the receiver MUST reset the Inactivity Timer.\n   *  the receiver assembles\
    \ the payloads of the SCHC Fragments.\n   On receiving an All-1 SCHC Fragment:\n\
    \   *  the receiver MUST append the All-1 SCHC Fragment Payload and the\n    \
    \  padding bits to the previously received SCHC Fragment Payloads for\n      this\
    \ SCHC Packet.\n   *  the receiver MUST perform the integrity check.\n   *  if\
    \ integrity checking fails, the receiver MUST drop the\n      reassembled SCHC\
    \ Packet.\n   *  the reassembly operation concludes.\n   On expiration of the\
    \ Inactivity Timer, the receiver MUST drop the\n   SCHC Packet being reassembled.\n\
    \   On receiving a SCHC Sender-Abort, the receiver MAY drop the SCHC\n   Packet\
    \ being reassembled.\n   Figure 40 shows an example of a corresponding state machine.\n"
- title: 8.4.2.  ACK-Always Mode
  contents:
  - "8.4.2.  ACK-Always Mode\n   The ACK-Always mode has been designed under the following\n\
    \   assumptions:\n   *  Data unit out-of-sequence delivery does not occur between\
    \ the\n      entity performing fragmentation and the entity performing\n     \
    \ reassembly,\n   *  The L2 MTU value does not change while the fragments of a\
    \ SCHC\n      Packet are being transmitted, and\n   *  There is a feedback path\
    \ from the reassembler to the fragmenter.\n      See Appendix F for a discussion\
    \ on using ACK-Always mode on quasi-\n      bidirectional links.\n   In ACK-Always\
    \ mode, windows are used.  An acknowledgement, positive\n   or negative, is transmitted\
    \ by the fragment receiver to the fragment\n   sender at the end of the transmission\
    \ of each window of SCHC\n   Fragments.\n   The tiles are not required to be of\
    \ uniform size.  In ACK-Always\n   mode, only the All-1 SCHC Fragment is padded\
    \ as needed.  The other\n   SCHC Fragments are intrinsically aligned to L2 Words.\n\
    \   Briefly, the algorithm is as follows: after a first blind\n   transmission\
    \ of all the tiles of a window, the fragment sender\n   iterates retransmitting\
    \ the tiles that are reported missing until the\n   fragment receiver reports\
    \ that all the tiles belonging to the window\n   have been correctly received\
    \ or until too many attempts were made.\n   The fragment sender only advances\
    \ to the next window of tiles when it\n   has ascertained that all the tiles belonging\
    \ to the current window\n   have been fully and correctly received.  This results\
    \ in a per-window\n   lock-step behavior between the sender and the receiver.\n\
    \   Each Profile MUST specify which RuleID value(s) correspond to SCHC F/\n  \
    \ R messages operating in this mode.\n   The W field MUST be present and its size\
    \ M MUST be 1 bit.\n   Each Profile, for each RuleID value, MUST define:\n   *\
    \  the value of N,\n   *  the value of WINDOW_SIZE, which MUST be strictly less\
    \ than 2^N,\n   *  the size and algorithm for the RCS field,\n   *  the value\
    \ of T,\n   *  the value of MAX_ACK_REQUESTS,\n   *  the expiration time of the\
    \ Retransmission Timer, and\n   *  the expiration time of the Inactivity Timer.\n\
    \   For each active pair of RuleID and DTag values, the sender MUST\n   maintain:\n\
    \   *  one Attempts counter\n   *  one Retransmission Timer\n   For each active\
    \ pair of RuleID and DTag values, the receiver MUST\n   maintain\n   *  one Inactivity\
    \ Timer, and\n   *  one Attempts counter.\n"
- title: 8.4.2.1.  Sender Behavior
  contents:
  - "8.4.2.1.  Sender Behavior\n   At the beginning of the fragmentation of a new\
    \ SCHC Packet, the\n   fragment sender MUST select a RuleID and DTag value pair\
    \ for this\n   SCHC Packet.\n   Each SCHC Fragment MUST contain exactly one tile\
    \ in its Payload.  All\n   tiles with the index 0, as well as the last tile, MUST\
    \ be at least\n   the size of an L2 Word.\n   In all SCHC Fragment messages, the\
    \ W field MUST be filled with the\n   LSB of the window number that the sender\
    \ is currently processing.\n   For a SCHC Fragment that carries a tile other than\
    \ the last one of\n   the SCHC Packet:\n   *  the Fragment MUST be of the Regular\
    \ type specified in\n      Section 8.3.1.1.\n   *  the FCN field MUST contain\
    \ the tile index.\n   *  each tile MUST be of a size that complements the SCHC\
    \ Fragment\n      Header so that the SCHC Fragment is a multiple of L2 Words without\n\
    \      the need for padding bits.\n   The SCHC Fragment that carries the last\
    \ tile MUST be an All-1 SCHC\n   Fragment, described in Section 8.3.1.2.\n   The\
    \ fragment sender MUST start by transmitting the window numbered 0.\n   All message\
    \ receptions being discussed in the rest of this section\n   are to be understood\
    \ as \"matching the RuleID and DTag pair being\n   processed\", even if not spelled\
    \ out, for brevity.\n   The sender starts by a \"blind transmission\" phase, in\
    \ which it MUST\n   transmit all the tiles composing the window, in decreasing\
    \ tile index\n   order.\n   Then, it enters a \"retransmission phase\" in which\
    \ it MUST initialize\n   an Attempts counter to 0, it MUST start a Retransmission\
    \ Timer and it\n   MUST await a SCHC ACK.\n   *  Then, upon receiving a SCHC ACK:\n\
    \      -  if the SCHC ACK indicates that some tiles are missing at the\n     \
    \    receiver, then the sender MUST transmit all the tiles that have\n       \
    \  been reported missing, it MUST increment Attempts, it MUST\n         reset\
    \ the Retransmission Timer, and MUST await the next SCHC\n         ACK.\n    \
    \  -  if the current window is not the last one and the SCHC ACK\n         indicates\
    \ that all tiles were correctly received, the sender\n         MUST stop the Retransmission\
    \ Timer, it MUST advance to the next\n         fragmentation window, and it MUST\
    \ start a blind transmission\n         phase as described above.\n      -  if\
    \ the current window is the last one and the SCHC ACK\n         indicates that\
    \ more tiles were received than the sender sent,\n         the fragment sender\
    \ MUST send a SCHC Sender-Abort, and it MAY\n         exit with an error condition.\n\
    \      -  if the current window is the last one and the SCHC ACK\n         indicates\
    \ that all tiles were correctly received, yet the\n         integrity check was\
    \ a failure, the fragment sender MUST send a\n         SCHC Sender-Abort, and\
    \ it MAY exit with an error condition.\n      -  if the current window is the\
    \ last one and the SCHC ACK\n         indicates that integrity checking was successful,\
    \ the sender\n         exits successfully.\n   *  on Retransmission Timer expiration:\n\
    \      -  if Attempts is strictly less that MAX_ACK_REQUESTS, the\n         fragment\
    \ sender MUST send a SCHC ACK REQ and MUST increment the\n         Attempts counter.\n\
    \      -  otherwise, the fragment sender MUST send a SCHC Sender-Abort,\n    \
    \     and it MAY exit with an error condition.\n   At any time:\n   *  on receiving\
    \ a SCHC Receiver-Abort, the fragment sender MAY exit\n      with an error condition.\n\
    \   *  on receiving a SCHC ACK that bears a W value different from the W\n   \
    \   value that it currently uses, the fragment sender MUST silently\n      discard\
    \ and ignore that SCHC ACK.\n   Figure 41 shows an example of a corresponding\
    \ state machine.\n"
- title: 8.4.2.2.  Receiver Behavior
  contents:
  - "8.4.2.2.  Receiver Behavior\n   On receiving a SCHC Fragment with a RuleID and\
    \ DTag pair not being\n   processed at that time:\n   *  the receiver SHOULD check\
    \ if the DTag value has not recently been\n      used for that RuleID value, thereby\
    \ ensuring that the received\n      SCHC Fragment is not a remnant of a prior\
    \ fragmented SCHC Packet\n      transmission.  The initial value of the Inactivity\
    \ Timer is the\n      RECOMMENDED lifetime for the DTag value at the receiver.\
    \  If the\n      SCHC Fragment is determined to be such a remnant, the receiver\
    \ MAY\n      silently ignore it and discard it.\n   *  the receiver MUST start\
    \ a process to assemble a new SCHC Packet\n      with that RuleID and DTag value\
    \ pair.\n   *  the receiver MUST start an Inactivity Timer for that RuleID and\n\
    \      DTag pair.  It MUST initialize an Attempts counter to 0 for that\n    \
    \  RuleID and DTag pair.  It MUST initialize a window counter to 0.\n      If\
    \ the receiver is under-resourced to do this, it MUST respond to\n      the sender\
    \ with a SCHC Receiver-Abort.\n   In the rest of this section, \"local W bit\"\
    \ means the least\n   significant bit of the window counter of the receiver.\n\
    \   On reception of any SCHC F/R message for the RuleID and DTag pair\n   being\
    \ processed, the receiver MUST reset the Inactivity Timer\n   pertaining to that\
    \ RuleID and DTag pair.\n   All message receptions being discussed in the rest\
    \ of this section\n   are to be understood as \"matching the RuleID and DTag pair\
    \ being\n   processed\", even if not spelled out, for brevity.\n   The receiver\
    \ MUST first initialize an empty Bitmap for the first\n   window then enter an\
    \ \"acceptance phase\", in which:\n   *  on receiving a SCHC Fragment or a SCHC\
    \ ACK REQ, either one having\n      the W bit different from the local W bit,\
    \ the receiver MUST\n      silently ignore and discard that message.\n   *  on\
    \ receiving a SCHC ACK REQ with the W bit equal to the local W\n      bit, the\
    \ receiver MUST send a SCHC ACK for this window.\n   *  on receiving a SCHC Fragment\
    \ with the W bit equal to the local W\n      bit, the receiver MUST assemble the\
    \ received tile based on the\n      window counter and on the FCN field in the\
    \ SCHC Fragment, and it\n      MUST update the Bitmap.\n      -  if the SCHC Fragment\
    \ received is an All-0 SCHC Fragment, the\n         current window is determined\
    \ to be a not-last window, the\n         receiver MUST send a SCHC ACK for this\
    \ window and it MUST enter\n         the \"retransmission phase\" for this window.\n\
    \      -  if the SCHC Fragment received is an All-1 SCHC Fragment, the\n     \
    \    current window is determined to be the last window, the padding\n       \
    \  bits of the All-1 SCHC Fragment MUST be assembled after the\n         received\
    \ tile, the receiver MUST perform the integrity check\n         and it MUST send\
    \ a SCHC ACK for this window.  Then:\n         o  If the integrity check indicates\
    \ that the full SCHC Packet\n            has been correctly reassembled, the receiver\
    \ MUST enter the\n            \"clean-up phase\" for this window.\n         o\
    \  If the integrity check indicates that the full SCHC Packet\n            has\
    \ not been correctly reassembled, the receiver enters the\n            \"retransmission\
    \ phase\" for this window.\n   In the \"retransmission phase\":\n   *  if the\
    \ window is a not-last window:\n      -  on receiving a SCHC Fragment that is\
    \ not All-0 or All-1 and\n         that has a W bit different from the local W\
    \ bit, the receiver\n         MUST increment its window counter and allocate a\
    \ fresh Bitmap,\n         it MUST assemble the tile received and update the Bitmap,\
    \ and\n         it MUST enter the \"acceptance phase\" for that new window.\n\
    \      -  on receiving a SCHC ACK REQ with a W bit different from the\n      \
    \   local W bit, the receiver MUST increment its window counter and\n        \
    \ allocate a fresh Bitmap, it MUST send a SCHC ACK for that new\n         window,\
    \ and it MUST enter the \"acceptance phase\" for that new\n         window.\n\
    \      -  on receiving a SCHC All-0 Fragment with a W bit different from\n   \
    \      the local W bit, the receiver MUST increment its window counter\n     \
    \    and allocate a fresh Bitmap, it MUST assemble the tile received\n       \
    \  and update the Bitmap, it MUST send a SCHC ACK for that new\n         window,\
    \ and it MUST stay in the \"retransmission phase\" for that\n         new window.\n\
    \      -  on receiving a SCHC All-1 Fragment with a W bit different from\n   \
    \      the local W bit, the receiver MUST increment its window counter\n     \
    \    and allocate a fresh Bitmap; it MUST assemble the tile\n         received,\
    \ including the padding bits; it MUST update the Bitmap\n         and perform\
    \ the integrity check; it MUST send a SCHC ACK for\n         the new window, which\
    \ is determined to be the last window.\n         Then:\n         o  If the integrity\
    \ check indicates that the full SCHC Packet\n            has been correctly reassembled,\
    \ the receiver MUST enter the\n            \"clean-up phase\" for that new window.\n\
    \         o  If the integrity check indicates that the full SCHC Packet\n    \
    \        has not been correctly reassembled, the receiver enters the\n       \
    \     \"retransmission phase\" for that new window.\n      -  on receiving a SCHC\
    \ Fragment with a W bit equal to the local W\n         bit:\n         o  if the\
    \ SCHC Fragment received is an All-1 SCHC Fragment, the\n            receiver\
    \ MUST silently ignore it and discard it.\n         o  otherwise, the receiver\
    \ MUST assemble the tile received and\n            update the Bitmap.  If the\
    \ Bitmap becomes fully populated\n            with 1's or if the SCHC Fragment\
    \ is an All-0, the receiver\n            MUST send a SCHC ACK for this window.\n\
    \      -  on receiving a SCHC ACK REQ with the W bit equal to the local W\n  \
    \       bit, the receiver MUST send a SCHC ACK for this window.\n   *  if the\
    \ window is the last window:\n      -  on receiving a SCHC Fragment or a SCHC\
    \ ACK REQ, either one\n         having a W bit different from the local W bit,\
    \ the receiver\n         MUST silently ignore and discard that message.\n    \
    \  -  on receiving a SCHC ACK REQ with the W bit equal to the local W\n      \
    \   bit, the receiver MUST send a SCHC ACK for this window.\n      -  on receiving\
    \ a SCHC Fragment with a W bit equal to the local W\n         bit:\n         o\
    \  if the SCHC Fragment received is an All-0 SCHC Fragment, the\n            receiver\
    \ MUST silently ignore it and discard it.\n         o  otherwise, the receiver\
    \ MUST update the Bitmap, and it MUST\n            assemble the tile received.\
    \  If the SCHC Fragment received\n            is an All-1 SCHC Fragment, the receiver\
    \ MUST assemble the\n            padding bits of the All-1 SCHC Fragment after\
    \ the received\n            tile, it MUST perform the integrity check and:\n \
    \           +  if the integrity check indicates that the full SCHC\n         \
    \      Packet has been correctly reassembled, the receiver MUST\n            \
    \   send a SCHC ACK and it enters the \"clean-up phase\".\n            +  if the\
    \ integrity check indicates that the full SCHC\n               Packet has not\
    \ been correctly reassembled:\n               *  if the SCHC Fragment received\
    \ was an All-1 SCHC\n                  Fragment, the receiver MUST send a SCHC\
    \ ACK for this\n                  window.\n   In the \"clean-up phase\":\n   *\
    \  On receiving an All-1 SCHC Fragment or a SCHC ACK REQ, either one\n      having\
    \ the W bit equal to the local W bit, the receiver MUST send\n      a SCHC ACK.\n\
    \   *  Any other SCHC Fragment received MUST be silently ignored and\n      discarded.\n\
    \   At any time, on sending a SCHC ACK, the receiver MUST increment the\n   Attempts\
    \ counter.\n   At any time, on incrementing its window counter, the receiver MUST\n\
    \   reset the Attempts counter.\n   At any time, on expiration of the Inactivity\
    \ Timer, on receiving a\n   SCHC Sender-Abort or when Attempts reaches MAX_ACK_REQUESTS,\
    \ the\n   receiver MUST send a SCHC Receiver-Abort, and it MAY exit the receive\n\
    \   process for that SCHC Packet.\n   Figure 42 shows an example of a corresponding\
    \ state machine.\n"
- title: 8.4.3.  ACK-on-Error Mode
  contents:
  - "8.4.3.  ACK-on-Error Mode\n   The ACK-on-Error mode supports L2 technologies\
    \ that have variable MTU\n   and out-of-order delivery.  It requires an L2 that\
    \ provides a\n   feedback path from the reassembler to the fragmenter.  See Appendix\
    \ F\n   for a discussion on using ACK-on-Error mode on quasi-bidirectional\n \
    \  links.\n   In ACK-on-Error mode, windows are used.\n   All tiles except the\
    \ last one and the penultimate one MUST be of\n   equal size, hereafter called\
    \ \"regular\".  The size of the last tile\n   MUST be smaller than or equal to\
    \ the regular tile size.  Regarding\n   the penultimate tile, a Profile MUST pick\
    \ one of the following two\n   options:\n   *  The penultimate tile size MUST\
    \ be the regular tile size, or\n   *  the penultimate tile size MUST be either\
    \ the regular tile size or\n      the regular tile size minus one L2 Word.\n \
    \  A SCHC Fragment message carries one or several contiguous tiles,\n   which\
    \ may span multiple windows.  A SCHC ACK reports on the reception\n   of exactly\
    \ one window of tiles.\n   See Figure 23 for an example.\n   Tile#   | 4 | 3 |\
    \ 2 | 1 | 0 | 4 | 3 | 2 | 1 | 0 | 4 |     | 0 | 4 |3|\n   Window# |-------- 0\
    \ --------|-------- 1 --------|- 2  ... 27 -|- 28-|\n   SCHC Fragment msg   |-----------|\n\
    \       Figure 23: SCHC Packet Fragmented in Tiles, ACK-on-Error Mode\n   The\
    \ W field is wide enough that it unambiguously represents an\n   absolute window\
    \ number.  The fragment receiver sends SCHC ACKs to the\n   fragment sender about\
    \ windows for which tiles are missing.  No SCHC\n   ACK is sent by the fragment\
    \ receiver for windows that it knows have\n   been fully received.\n   The fragment\
    \ sender retransmits SCHC Fragments for tiles that are\n   reported missing. \
    \ It can advance to next windows even before it has\n   ascertained that all tiles\
    \ belonging to previous windows have been\n   correctly received, and it can still\
    \ later retransmit SCHC Fragments\n   with tiles belonging to previous windows.\
    \  Therefore, the sender and\n   the receiver may operate in a decoupled fashion.\
    \  The fragmented SCHC\n   Packet transmission concludes when:\n   *  integrity\
    \ checking shows that the fragmented SCHC Packet has been\n      correctly reassembled\
    \ at the receive end, and this information has\n      been conveyed back to the\
    \ sender, or\n   *  too many retransmission attempts were made, or\n   *  the\
    \ receiver determines that the transmission of this fragmented\n      SCHC Packet\
    \ has been inactive for too long.\n   Each Profile MUST specify which RuleID value(s)\
    \ corresponds to SCHC\n   F/R messages operating in this mode.\n   The W field\
    \ MUST be present in the SCHC F/R messages.\n   Each Profile, for each RuleID\
    \ value, MUST define:\n   *  the tile size (a tile does not need to be multiple\
    \ of an L2 Word,\n      but it MUST be at least the size of an L2 Word),\n   *\
    \  the value of M,\n   *  the value of N,\n   *  the value of WINDOW_SIZE, which\
    \ MUST be strictly less than 2^N,\n   *  the size and algorithm for the RCS field,\n\
    \   *  the value of T,\n   *  the value of MAX_ACK_REQUESTS,\n   *  the expiration\
    \ time of the Retransmission Timer,\n   *  the expiration time of the Inactivity\
    \ Timer,\n   *  if the last tile is carried in a Regular SCHC Fragment or an All-1\n\
    \      SCHC Fragment (see Section 8.4.3.1), and\n   *  if the penultimate tile\
    \ MAY be one L2 Word smaller than the\n      regular tile size.  In this case,\
    \ the regular tile size MUST be at\n      least twice the L2 Word size.\n   For\
    \ each active pair of RuleID and DTag values, the sender MUST\n   maintain:\n\
    \   *  one Attempts counter, and\n   *  one Retransmission Timer.\n   For each\
    \ active pair of RuleID and DTag values, the receiver MUST\n   maintain:\n   *\
    \  one Inactivity Timer, and\n   *  one Attempts counter.\n"
- title: 8.4.3.1.  Sender Behavior
  contents:
  - "8.4.3.1.  Sender Behavior\n   At the beginning of the fragmentation of a new\
    \ SCHC Packet:\n   *  the fragment sender MUST select a RuleID and DTag value\
    \ pair for\n      this SCHC Packet.  A Rule MUST NOT be selected if the values\
    \ of M\n      and WINDOW_SIZE for that Rule are such that the SCHC Packet cannot\n\
    \      be fragmented in (2^M) * WINDOW_SIZE tiles or less.\n   *  the fragment\
    \ sender MUST initialize the Attempts counter to 0 for\n      that RuleID and\
    \ DTag value pair.\n   A Regular SCHC Fragment message carries in its payload\
    \ one or more\n   tiles.  If more than one tile is carried in one Regular SCHC\n\
    \   Fragment:\n   *  the selected tiles MUST be contiguous in the original SCHC\
    \ Packet,\n      and\n   *  they MUST be placed in the SCHC Fragment Payload adjacent\
    \ to one\n      another, in the order they appear in the SCHC Packet, from the\n\
    \      start of the SCHC Packet toward its end.\n   Tiles that are not the last\
    \ one MUST be sent in Regular SCHC\n   Fragments specified in Section 8.3.1.1.\
    \  The FCN field MUST contain\n   the tile index of the first tile sent in that\
    \ SCHC Fragment.\n   In a Regular SCHC Fragment message, the sender MUST fill\
    \ the W field\n   with the window number of the first tile sent in that SCHC Fragment.\n\
    \   A Profile MUST define if the last tile of a SCHC Packet is sent:\n   *  in\
    \ a Regular SCHC Fragment, alone or as part of a multi-tiles\n      Payload,\n\
    \   *  alone in an All-1 SCHC Fragment, or\n   *  with any of the above two methods.\n\
    \   In an All-1 SCHC Fragment message, the sender MUST fill the W field\n   with\
    \ the window number of the last tile of the SCHC Packet.\n   The fragment sender\
    \ MUST send SCHC Fragments such that, all together,\n   they contain all the tiles\
    \ of the fragmented SCHC Packet.\n   The fragment sender MUST send at least one\
    \ All-1 SCHC Fragment.\n   In doing the two items above, the sender MUST ascertain\
    \ that the\n   receiver will not receive the last tile through both a Regular\
    \ SCHC\n   Fragment and an All-1 SCHC Fragment.\n   The fragment sender MUST listen\
    \ for SCHC ACK messages after having\n   sent:\n   *  an All-1 SCHC Fragment,\
    \ or\n   *  a SCHC ACK REQ.\n   A Profile MAY specify other times at which the\
    \ fragment sender MUST\n   listen for SCHC ACK messages.  For example, this could\
    \ be after\n   sending a complete window of tiles.\n   Each time a fragment sender\
    \ sends an All-1 SCHC Fragment or a SCHC\n   ACK REQ:\n   *  it MUST increment\
    \ the Attempts counter, and\n   *  it MUST reset the Retransmission Timer.\n \
    \  On Retransmission Timer expiration:\n   *  if the Attempts counter is strictly\
    \ less than MAX_ACK_REQUESTS,\n      the fragment sender MUST send either the\
    \ All-1 SCHC Fragment or a\n      SCHC ACK REQ with the W field corresponding\
    \ to the last window,\n   *  otherwise, the fragment sender MUST send a SCHC Sender-Abort,\
    \ and\n      it MAY exit with an error condition.\n   All message receptions being\
    \ discussed in the rest of this section\n   are to be understood as \"matching\
    \ the RuleID and DTag pair being\n   processed\", even if not spelled out, for\
    \ brevity.\n   On receiving a SCHC ACK:\n   *  if the W field in the SCHC ACK\
    \ corresponds to the last window of\n      the SCHC Packet:\n      -  if the C\
    \ bit is set, the sender MAY exit successfully.\n      -  otherwise:\n       \
    \  o  if the Profile mandates that the last tile be sent in an\n            All-1\
    \ SCHC Fragment:\n            +  if the SCHC ACK shows no missing tile at the\
    \ receiver,\n               the sender:\n               *  MUST send a SCHC Sender-Abort,\
    \ and\n               *  MAY exit with an error condition.\n            +  otherwise:\n\
    \               *  the fragment sender MUST send SCHC Fragment messages\n    \
    \              containing all the tiles that are reported missing in\n       \
    \           the SCHC ACK.\n               *  if the last of these SCHC Fragment\
    \ messages is not an\n                  All-1 SCHC Fragment, then the fragment\
    \ sender MUST in\n                  addition send after it a SCHC ACK REQ with\
    \ the W field\n                  corresponding to the last window.\n         \
    \      *  in doing the two items above, the sender MUST\n                  ascertain\
    \ that the receiver will not receive the last\n                  tile through\
    \ both a Regular SCHC Fragment and an All-1\n                  SCHC Fragment.\n\
    \         o  otherwise:\n            +  if the SCHC ACK shows no missing tile\
    \ at the receiver,\n               the sender MUST send the All-1 SCHC Fragment\n\
    \            +  otherwise:\n               *  the fragment sender MUST send SCHC\
    \ Fragment messages\n                  containing all the tiles that are reported\
    \ missing in\n                  the SCHC ACK.\n               *  the fragment\
    \ sender MUST then send either the All-1\n                  SCHC Fragment or a\
    \ SCHC ACK REQ with the W field\n                  corresponding to the last window.\n\
    \   *  otherwise, the fragment sender:\n      -  MUST send SCHC Fragment messages\
    \ containing the tiles that are\n         reported missing in the SCHC ACK.\n\
    \      -  then, it MAY send a SCHC ACK REQ with the W field corresponding\n  \
    \       to the last window.\n   See Figure 43 for one among several possible examples\
    \ of a Finite\n   State Machine implementing a sender behavior obeying this\n\
    \   specification.\n"
- title: 8.4.3.2.  Receiver Behavior
  contents:
  - "8.4.3.2.  Receiver Behavior\n   On receiving a SCHC Fragment with a RuleID and\
    \ DTag pair not being\n   processed at that time:\n   *  the receiver SHOULD check\
    \ if the DTag value has not recently been\n      used for that RuleID value, thereby\
    \ ensuring that the received\n      SCHC Fragment is not a remnant of a prior\
    \ fragmented SCHC Packet\n      transmission.  The initial value of the Inactivity\
    \ Timer is the\n      RECOMMENDED lifetime for the DTag value at the receiver.\
    \  If the\n      SCHC Fragment is determined to be such a remnant, the receiver\
    \ MAY\n      silently ignore it and discard it.\n   *  the receiver MUST start\
    \ a process to assemble a new SCHC Packet\n      with that RuleID and DTag value\
    \ pair.  The receiver MUST start an\n      Inactivity Timer for that RuleID and\
    \ DTag value pair.  It MUST\n      initialize an Attempts counter to 0 for that\
    \ RuleID and DTag value\n      pair.  If the receiver is under-resourced to do\
    \ this, it MUST\n      respond to the sender with a SCHC Receiver-Abort.\n   On\
    \ reception of any SCHC F/R message for the RuleID and DTag pair\n   being processed,\
    \ the receiver MUST reset the Inactivity Timer\n   pertaining to that RuleID and\
    \ DTag pair.\n   All message receptions being discussed in the rest of this section\n\
    \   are to be understood as \"matching the RuleID and DTag pair being\n   processed\"\
    , even if not spelled out, for brevity.\n   On receiving a SCHC Fragment message,\
    \ the receiver determines what\n   tiles were received, based on the payload length\
    \ and on the W and FCN\n   fields of the SCHC Fragment.\n   *  if the FCN is All-1,\
    \ if a Payload is present, the full SCHC\n      Fragment Payload MUST be assembled\
    \ including the padding bits.\n      This is because the size of the last tile\
    \ is not known by the\n      receiver; therefore, padding bits are indistinguishable\
    \ from the\n      tile data bits, at this stage.  They will be removed by the\
    \ SCHC\n      C/D sublayer.  If the size of the SCHC Fragment Payload exceeds\
    \ or\n      equals the size of one regular tile plus the size of an L2 Word,\n\
    \      this SHOULD raise an error flag.\n   *  otherwise, tiles MUST be assembled\
    \ based on the a priori known\n      tile size.\n      -  If allowed by the Profile,\
    \ the end of the payload MAY contain\n         the last tile, which may be shorter.\
    \  Padding bits are\n         indistinguishable from the tile data bits, at this\
    \ stage.\n      -  The payload may contain the penultimate tile that, if allowed\n\
    \         by the Profile, MAY be exactly one L2 Word shorter than the\n      \
    \   regular tile size.\n      -  Otherwise, padding bits MUST be discarded.  This\
    \ is possible\n         because:\n         o  the size of the tiles is known a\
    \ priori,\n         o  tiles are larger than an L2 Word, and\n         o  padding\
    \ bits are always strictly less than an L2 Word.\n   On receiving a SCHC ACK REQ\
    \ or an All-1 SCHC Fragment:\n   *  if the receiver knows of any windows with\
    \ missing tiles for the\n      packet being reassembled, it MUST return a SCHC\
    \ ACK for the\n      lowest-numbered such window:\n   *  otherwise:\n      - \
    \ if it has received at least one tile, it MUST return a SCHC ACK\n         for\
    \ the highest-numbered window it currently has tiles for,\n      -  otherwise,\
    \ it MUST return a SCHC ACK for window numbered 0.\n   A Profile MAY specify other\
    \ times and circumstances at which a\n   receiver sends a SCHC ACK, and which\
    \ window the SCHC ACK reports\n   about in these circumstances.\n   Upon sending\
    \ a SCHC ACK, the receiver MUST increase the Attempts\n   counter.\n   After receiving\
    \ an All-1 SCHC Fragment, a receiver MUST check the\n   integrity of the reassembled\
    \ SCHC Packet at least every time it\n   prepares for sending a SCHC ACK for the\
    \ last window.\n   Upon receiving a SCHC Sender-Abort, the receiver MAY exit with\
    \ an\n   error condition.\n   Upon expiration of the Inactivity Timer, the receiver\
    \ MUST send a\n   SCHC Receiver-Abort, and it MAY exit with an error condition.\n\
    \   On the Attempts counter exceeding MAX_ACK_REQUESTS, the receiver MUST\n  \
    \ send a SCHC Receiver-Abort, and it MAY exit with an error condition.\n   Reassembly\
    \ of the SCHC Packet concludes when:\n   *  a Sender-Abort has been received,\
    \ or\n   *  the Inactivity Timer has expired, or\n   *  the Attempts counter has\
    \ exceeded MAX_ACK_REQUESTS, or\n   *  at least an All-1 SCHC Fragment has been\
    \ received and integrity\n      checking of the reassembled SCHC Packet is successful.\n\
    \   See Figure 44 for one among several possible examples of a Finite\n   State\
    \ Machine implementing a receiver behavior obeying this\n   specification.  The\
    \ example provided is meant to match the sender\n   Finite State Machine of Figure\
    \ 43.\n"
- title: 9.  Padding Management
  contents:
  - "9.  Padding Management\n   SCHC C/D and SCHC F/R operate on bits, not bytes.\
    \  SCHC itself does\n   not have any alignment prerequisite.  The size of SCHC\
    \ Packets can be\n   any number of bits.\n   If the L2 constrains the payload\
    \ to align to coarser boundaries (for\n   example, bytes), the SCHC messages MUST\
    \ be padded.  When padding\n   occurs, the number of appended bits MUST be strictly\
    \ less than the L2\n   Word size.\n   If a SCHC Packet is sent unfragmented (see\
    \ Figure 24), it is padded\n   as needed for transmission.\n   If a SCHC Packet\
    \ needs to be fragmented for transmission, it is not\n   padded in itself.  Only\
    \ the SCHC F/R messages are padded as needed\n   for transmission.  Some SCHC\
    \ F/R messages are intrinsically aligned\n   to L2 Words.\n   A packet (e.g.,\
    \ an IPv6 packet)\n            v                                           | \
    \      dropped)\n   | SCHC Compression |                      | SCHC Decompression\
    \ |\n            |   If no fragmentation,                    |\n            +----\
    \ SCHC Packet + padding as needed ----->|\n            v                     \
    \                      |  checked)\n   | SCHC Fragmentation |                \
    \       | SCHC Reassembly |\n        |       +--- SCHC ACK + padding as needed\
    \ --+       |\n        +------- SCHC Fragments + padding as needed---------+\n\
    \           Sender                                    Receiver\n          Figure\
    \ 24: SCHC Operations, Including Padding as Needed\n   Each Profile MUST specify\
    \ the size of the L2 Word.  The L2 Word might\n   actually be a single bit, in\
    \ which case no padding will take place at\n   all.\n   A Profile MUST define\
    \ the value of the padding bits if the L2 Word is\n   wider than a single bit.\
    \  The RECOMMENDED value is 0.\n"
- title: 10.  SCHC Compression for IPv6 and UDP Headers
  contents:
  - "10.  SCHC Compression for IPv6 and UDP Headers\n   This section lists the IPv6\
    \ and UDP header fields and describes how\n   they can be compressed.  An example\
    \ of a set of Rules for UDP/IPv6\n   header compression is provided in Appendix\
    \ A.\n"
- title: 10.1.  IPv6 Version Field
  contents:
  - "10.1.  IPv6 Version Field\n   The IPv6 version field is labeled by the protocol\
    \ parser as being the\n   \"version\" field of the IPv6 protocol.  Therefore,\
    \ it only exists for\n   IPv6 packets.  In the Rule, TV is set to 6, MO to \"\
    ignore\" and CDA to\n   \"not-sent\".\n"
- title: 10.2.  IPv6 Traffic Class Field
  contents:
  - "10.2.  IPv6 Traffic Class Field\n   If the Diffserv field does not vary and is\
    \ known by both sides, the\n   Field Descriptor in the Rule SHOULD contain a TV\
    \ with this well-known\n   value, an \"equal\" MO, and a \"not-sent\" CDA.\n \
    \  Otherwise (e.g., ECN bits are to be transmitted), two possibilities\n   can\
    \ be considered depending on the variability of the value:\n   *  One possibility\
    \ is to not compress the field and send the original\n      value.  In the Rule,\
    \ TV is not set to any particular value, MO is\n      set to \"ignore\", and CDA\
    \ is set to \"value-sent\".\n   *  If some upper bits in the field are constant\
    \ and known, a better\n      option is to only send the LSBs.  In the Rule, TV\
    \ is set to a\n      value with the stable known upper part, MO is set to MSB(x),\
    \ and\n      CDA to LSB.\n      ECN functionality depends on both bits of the\
    \ ECN field, which are\n      the 2 LSBs of this field; hence, sending only a\
    \ single LSB of this\n      field is NOT RECOMMENDED.\n"
- title: 10.3.  Flow Label Field
  contents:
  - "10.3.  Flow Label Field\n   If the flow label is not set, i.e., its value is\
    \ zero, the Field\n   Descriptor in the Rule SHOULD contain a TV set to zero,\
    \ an \"equal\"\n   MO, and a \"not-sent\" CDA.\n   If the flow label is set to\
    \ a pseudorandom value according to\n   [RFC6437], in the Rule, TV is not set\
    \ to any particular value, MO is\n   set to \"ignore\", and CDA is set to \"value-sent\"\
    .\n   If the flow label is set according to some prior agreement, i.e., by\n \
    \  a flow state establishment method as allowed by [RFC6437], the Field\n   Descriptor\
    \ in the Rule SHOULD contain a TV with this agreed-upon\n   value, an \"equal\"\
    \ MO, and a \"not-sent\" CDA.\n"
- title: 10.4.  Payload Length Field
  contents:
  - "10.4.  Payload Length Field\n   This field can be elided for the transmission\
    \ on the LPWAN.  The SCHC\n   C/D recomputes the original payload length value.\
    \  In the Field\n   Descriptor, TV is not set, MO is set to \"ignore\", and CDA\
    \ is\n   \"compute-*\".\n"
- title: 10.5.  Next Header Field
  contents:
  - "10.5.  Next Header Field\n   If the Next Header field does not vary and is known\
    \ by both sides,\n   the Field Descriptor in the Rule SHOULD contain a TV with\
    \ this Next\n   Header value, the MO SHOULD be \"equal\", and the CDA SHOULD be\
    \ \"not-\n   sent\".\n   Otherwise, TV is not set in the Field Descriptor, MO\
    \ is set to\n   \"ignore\", and CDA is set to \"value-sent\".  Alternatively,\
    \ a matching-\n   list MAY also be used.\n"
- title: 10.6.  Hop Limit Field
  contents:
  - "10.6.  Hop Limit Field\n   The field behavior for this field is different for\
    \ Uplink and\n   Downlink.  In Uplink, since there is no IP forwarding between\
    \ the Dev\n   and the SCHC C/D, the value is relatively constant.  On the other\n\
    \   hand, the Downlink value depends on Internet routing and can change\n   more\
    \ frequently.  The DI can be used to distinguish both directions:\n   *  in an\
    \ Up Field Descriptor, elide the field: the TV is set to the\n      known constant\
    \ value, the MO is set to \"equal\" and the CDA is set\n      to \"not-sent\"\
    .\n   *  in a Dw Field Descriptor, the Hop Limit is elided for transmission\n\
    \      and forced to 1 at the receiver, by setting TV to 1, MO to\n      \"ignore\"\
    \ and CDA to \"not-sent\".  This prevents any further\n      forwarding.\n"
- title: 10.7.  IPv6 Addresses Fields
  contents:
  - "10.7.  IPv6 Addresses Fields\n   As in 6LoWPAN [RFC4944], IPv6 addresses are\
    \ split into two 64-bit-\n   long fields; one for the prefix and one for the Interface\
    \ Identifier\n   (IID).  These fields SHOULD be compressed.  To allow for a single\n\
    \   Rule being used for both directions, these values are identified by\n   their\
    \ role (Dev or App) and not by their position in the header\n   (source or destination).\n"
- title: 10.7.1.  IPv6 Source and Destination Prefixes
  contents:
  - "10.7.1.  IPv6 Source and Destination Prefixes\n   Both ends MUST be configured\
    \ with the appropriate prefixes.  For a\n   specific flow, the source and destination\
    \ prefixes can be unique and\n   stored in the Context.  In that case, the TV\
    \ for the source and\n   destination prefixes contain the values, the MO is set\
    \ to \"equal\" and\n   the CDA is set to \"not-sent\".\n   If the Rule is intended\
    \ to compress packets with different prefix\n   values, match-mapping SHOULD be\
    \ used.  The different prefixes are\n   listed in the TV, the MO is set to \"\
    match-mapping\" and the CDA is set\n   to \"mapping-sent\".  See Figure 26.\n\
    \   Otherwise, the TV is not set, the MO is set to \"ignore\", and the CDA\n \
    \  is set to \"value-sent\".\n"
- title: 10.7.2.  IPv6 Source and Destination IID
  contents:
  - "10.7.2.  IPv6 Source and Destination IID\n   If the Dev or App IID are based\
    \ on an L2 address, then the IID can be\n   reconstructed with information coming\
    \ from the L2 header.  In that\n   case, the TV is not set, the MO is set to \"\
    ignore\" and the CDA is set\n   to \"DevIID\" or \"AppIID\".  On LPWAN technologies\
    \ where the frames\n   carry a single identifier (corresponding to the Dev), AppIID\
    \ cannot\n   be used.\n   As described in [RFC8065], it may be undesirable to\
    \ build the Dev\n   IPv6 IID out of the Dev address.  Another static value is\
    \ used\n   instead.  In that case, the TV contains the static value, the MO\n\
    \   operator is set to \"equal\" and the CDA is set to \"not-sent\".\n   If several\
    \ IIDs are possible, then the TV contains the list of\n   possible IIDs, the MO\
    \ is set to \"match-mapping\" and the CDA is set to\n   \"mapping-sent\".\n  \
    \ It may also happen that the IID variability only expresses itself on\n   a few\
    \ bytes.  In that case, the TV is set to the stable part of the\n   IID, the MO\
    \ is set to \"MSB\" and the CDA is set to \"LSB\".\n   Finally, the IID can be\
    \ sent in its entirety on the L2.  In that\n   case, the TV is not set, the MO\
    \ is set to \"ignore\", and the CDA is\n   set to \"value-sent\".\n"
- title: 10.8.  IPv6 Extension Headers
  contents:
  - "10.8.  IPv6 Extension Headers\n   This document does not provide recommendations\
    \ on how to compress\n   IPv6 extension headers.\n"
- title: 10.9.  UDP Source and Destination Ports
  contents:
  - "10.9.  UDP Source and Destination Ports\n   To allow for a single Rule being\
    \ used for both directions, the UDP\n   port values are identified by their role\
    \ (Dev or App) and not by\n   their position in the header (source or destination).\
    \  The SCHC C/D\n   MUST be aware of the traffic direction (Uplink, Downlink)\
    \ to select\n   the appropriate field.  The following Rules apply for Dev and\
    \ App\n   port numbers.\n   If both ends know the port number, it can be elided.\
    \  The TV contains\n   the port number, the MO is set to \"equal\", and the CDA\
    \ is set to\n   \"not-sent\".\n   If the port variation is on few bits, the TV\
    \ contains the stable part\n   of the port number, the MO is set to \"MSB\", and\
    \ the CDA is set to\n   \"LSB\".\n   If some well-known values are used, the TV\
    \ can contain the list of\n   these values, the MO is set to \"match-mapping\"\
    , and the CDA is set to\n   \"mapping-sent\".\n   Otherwise, the port numbers\
    \ are sent over the L2.  The TV is not set,\n   the MO is set to \"ignore\" and\
    \ the CDA is set to \"value-sent\".\n"
- title: 10.10.  UDP Length Field
  contents:
  - "10.10.  UDP Length Field\n   The parser MUST NOT label this field unless the\
    \ UDP Length value\n   matches the Payload Length value from the IPv6 header.\
    \  The TV is not\n   set, the MO is set to \"ignore\", and the CDA is set to \"\
    compute-*\".\n"
- title: 10.11.  UDP Checksum Field
  contents:
  - "10.11.  UDP Checksum Field\n   The UDP checksum operation is mandatory with IPv6\
    \ for most packets,\n   but there are exceptions [RFC8200].\n   For instance,\
    \ protocols that use UDP as a tunnel encapsulation may\n   enable zero-checksum\
    \ mode for a specific port (or set of ports) for\n   sending and/or receiving.\
    \  [RFC8200] requires any node implementing\n   zero-checksum mode to follow the\
    \ requirements specified in\n   \"Applicability Statement for the Use of IPv6\
    \ UDP Datagrams with Zero\n   Checksums\" [RFC6936].\n   6LoWPAN Header Compression\
    \ [RFC6282] also specifies that a UDP\n   checksum can be elided by the compressor\
    \ and recomputed by the\n   decompressor when an upper layer guarantees the integrity\
    \ of the UDP\n   payload and pseudo-header.  A specific example of this is when\
    \ a\n   message integrity check protects the compressed message between the\n\
    \   compressor that elides the UDP checksum and the decompressor that\n   computes\
    \ it, with a strength that is identical or better to the UDP\n   checksum.\n \
    \  Similarly, a SCHC compressor MAY elide the UDP checksum when another\n   layer\
    \ guarantees at least equal integrity protection for the UDP\n   payload and the\
    \ pseudo-header.  In this case, the TV is not set, the\n   MO is set to \"ignore\"\
    , and the CDA is set to \"compute-*\".\n   In particular, when SCHC fragmentation\
    \ is used, a fragmentation RCS\n   of 2 bytes or more provides equal or better\
    \ protection than the UDP\n   checksum; in that case, if the compressor is collocated\
    \ with the\n   fragmentation point and the decompressor is collocated with the\n\
    \   packet reassembly point, and if the SCHC Packet is fragmented even\n   when\
    \ it would fit unfragmented in the L2 MTU, then the compressor MAY\n   verify\
    \ and then elide the UDP checksum.  Whether and when the UDP\n   Checksum is elided\
    \ is to be specified in the Profile.\n   Since the compression happens before\
    \ the fragmentation, implementers\n   should understand the risks when dealing\
    \ with unprotected data below\n   the transport layer and take special care when\
    \ manipulating that\n   data.\n   In other cases, the checksum SHOULD be explicitly\
    \ sent.  The TV is\n   not set, the MO is set to \"ignore\" and the CDA is set\
    \ to \"value-\n   sent\".\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   As explained in Section 5, SCHC is expected\
    \ to be implemented on top\n   of LPWAN technologies, which are expected to implement\
    \ security\n   measures.\n   In this section, we analyze the potential security\
    \ threats that could\n   be introduced into an LPWAN by adding the SCHC functionalities.\n"
- title: 12.1.  Security Considerations for SCHC Compression/Decompression
  contents:
  - '12.1.  Security Considerations for SCHC Compression/Decompression

    '
- title: 12.1.1.  Forged SCHC Packet
  contents:
  - "12.1.1.  Forged SCHC Packet\n   Let's assume that an attacker is able to send\
    \ a forged SCHC Packet to\n   a SCHC decompressor.\n   Let's first consider the\
    \ case where the RuleID contained in that\n   forged SCHC Packet does not correspond\
    \ to a Rule allocated in the\n   Rule table.  An implementation should detect\
    \ that the RuleID is\n   invalid and should silently drop the offending SCHC Packet.\n\
    \   Let's now consider that the RuleID corresponds to a Rule in the\n   table.\
    \  With the CDAs defined in this document, the reconstructed\n   packet is, at\
    \ most, a constant number of bits bigger than the SCHC\n   Packet that was received.\
    \  This assumes that the compute-*\n   decompression actions produce a bounded\
    \ number of bits, irrespective\n   of the incoming SCHC Packet.  This property\
    \ is true for IPv6 Length,\n   UDP Length, and UDP Checksum, for which the compute-*\
    \ CDA is\n   recommended by this document.\n   As a consequence, SCHC decompression\
    \ does not amplify attacks, beyond\n   adding a bounded number of bits to the\
    \ SCHC Packet received.  This\n   bound is determined by the Rule stored in the\
    \ receiving device.\n   As a general safety measure, a SCHC decompressor should\
    \ never\n   reconstruct a packet larger than MAX_PACKET_SIZE (defined in a\n \
    \  Profile, with 1500 bytes as generic default).\n"
- title: 12.1.2.  Compressed Packet Size as a Side Channel to Guess a Secret
  contents:
  - "12.1.2.  Compressed Packet Size as a Side Channel to Guess a Secret\n       \
    \  Token\n   Some packet compression methods are known to be susceptible to\n\
    \   attacks, such as BREACH and CRIME.  The attack involves injecting\n   arbitrary\
    \ data into the packet and observing the resulting compressed\n   packet size.\
    \  The observed size potentially reflects correlation\n   between the arbitrary\
    \ data and some content that was meant to remain\n   secret, such as a security\
    \ token, thereby allowing the attacker to\n   get at the secret.\n   By contrast,\
    \ SCHC compression takes place header field by header\n   field, with the SCHC\
    \ Packet being a mere concatenation of the\n   compression residues of each of\
    \ the individual field.  Any\n   correlation between header fields does not result\
    \ in a change in the\n   SCHC Packet size compressed under the same Rule.\n  \
    \ If SCHC C/D is used to compress packets that include a secret\n   information\
    \ field, such as a token, the Rule set should be designed\n   so that the size\
    \ of the compression residue for the field to remain\n   secret is the same irrespective\
    \ of the value of the secret\n   information.  This is achieved by, e.g., sending\
    \ this field in\n   extenso with the \"ignore\" MO and the \"value-sent\" CDA.\
    \  This\n   recommendation is disputable if it is ascertained that the Rule set\n\
    \   itself will remain secret.\n"
- title: 12.1.3.  Decompressed Packet Different from the Original Packet
  contents:
  - "12.1.3.  Decompressed Packet Different from the Original Packet\n   As explained\
    \ in Section 7.2, using FPs with value 0 in Field\n   Descriptors in a Rule may\
    \ result in header fields appearing in the\n   decompressed packet in an order\
    \ different from that in the original\n   packet.  Likewise, as stated in Section\
    \ 7.4.3, using an \"ignore\" MO\n   together with a \"not-sent\" CDA will result\
    \ in the header field taking\n   the TV value, which is likely to be different\
    \ from the original\n   value.\n   Depending on the protocol, the order of header\
    \ fields in the packet\n   may or may not be functionally significant.\n   Furthermore,\
    \ if the packet is protected by a checksum or a similar\n   integrity protection\
    \ mechanism, and if the checksum is transmitted\n   instead of being recomputed\
    \ as part of the decompression, these\n   situations may result in the packet\
    \ being considered corrupt and\n   dropped.\n"
- title: 12.2.  Security Considerations for SCHC Fragmentation/Reassembly
  contents:
  - '12.2.  Security Considerations for SCHC Fragmentation/Reassembly

    '
- title: 12.2.1.  Buffer Reservation Attack
  contents:
  - "12.2.1.  Buffer Reservation Attack\n   Let's assume that an attacker is able\
    \ to send a forged SCHC Fragment\n   to a SCHC reassembler.\n   A node can perform\
    \ a buffer reservation attack: the receiver will\n   reserve buffer space for\
    \ the SCHC Packet.  If the implementation has\n   only one buffer, other incoming\
    \ fragmented SCHC Packets will be\n   dropped while the reassembly buffer is occupied\
    \ during the reassembly\n   timeout.  Once that timeout expires, the attacker\
    \ can repeat the same\n   procedure, and iterate, thus, creating a denial-of-service\
    \ attack.\n   An implementation may have multiple reassembly buffers.  The cost\
    \ to\n   mount this attack is linear with the number of buffers at the target\n\
    \   node.  Better, the cost for an attacker can be increased if\n   individual\
    \ fragments of multiple SCHC Packets can be stored in the\n   reassembly buffer.\
    \  The finer grained the reassembly buffer (down to\n   the smallest tile size),\
    \ the higher the cost of the attack.  If\n   buffer overload does occur, a smart\
    \ receiver could selectively\n   discard SCHC Packets being reassembled based\
    \ on the sender behavior,\n   which may help identify which SCHC Fragments have\
    \ been sent by the\n   attacker.  Another mild countermeasure is for the target\
    \ to abort the\n   fragmentation/reassembly session as early as it detects a non-\n\
    \   identical SCHC Fragment duplicate, anticipating for an eventual\n   corrupt\
    \ SCHC Packet, so as to save the sender the hassle of sending\n   the rest of\
    \ the fragments for this SCHC Packet.\n"
- title: 12.2.2.  Corrupt Fragment Attack
  contents:
  - "12.2.2.  Corrupt Fragment Attack\n   Let's assume that an attacker is able to\
    \ send a forged SCHC Fragment\n   to a SCHC reassembler.  The malicious node is\
    \ additionally assumed to\n   be able to hear an incoming communication destined\
    \ to the target\n   node.\n   It can then send a forged SCHC Fragment that looks\
    \ like it belongs to\n   a SCHC Packet already being reassembled at the target\
    \ node.  This can\n   cause the SCHC Packet to be considered corrupt and to be\
    \ dropped by\n   the receiver.  The amplification happens here by a single spoofed\n\
    \   SCHC Fragment rendering a full sequence of legitimate SCHC Fragments\n   useless.\
    \  If the target uses ACK-Always or ACK-on-Error mode, such a\n   malicious node\
    \ can also interfere with the acknowledgement and\n   repetition algorithm of\
    \ SCHC F/R.  A single spoofed ACK, with all\n   Bitmap bits set to 0, will trigger\
    \ the repetition of WINDOW_SIZE\n   tiles.  This protocol loop amplification depletes\
    \ the energy source\n   of the target node and consumes the channel bandwidth.\
    \  Similarly, a\n   spoofed ACK REQ will trigger the sending of a SCHC ACK, which\
    \ may be\n   much larger than the ACK REQ if WINDOW_SIZE is large.  These\n  \
    \ consequences should be borne in mind when defining profiles for SCHC\n   over\
    \ specific LPWAN technologies.\n"
- title: 12.2.3.  Fragmentation as a Way to Bypass Network Inspection
  contents:
  - "12.2.3.  Fragmentation as a Way to Bypass Network Inspection\n   Fragmentation\
    \ is known for potentially allowing one to force through\n   a Network Inspection\
    \ device (e.g., firewall) packets that would be\n   rejected if unfragmented.\
    \  This involves sending overlapping\n   fragments to rewrite fields whose initial\
    \ value led the Network\n   Inspection device to allow the flow to go through.\n\
    \   SCHC F/R is expected to be used over one LPWAN link, where no Network\n  \
    \ Inspection device is expected to sit.  As described in Section 5.2,\n   even\
    \ if the SCHC F/R on the Network Infrastructure side is located in\n   the Internet,\
    \ a tunnel is to be established between it and the NGW.\n"
- title: 12.2.4.  Privacy Issues Associated with SCHC Header Fields
  contents:
  - "12.2.4.  Privacy Issues Associated with SCHC Header Fields\n   SCHC F/R allocates\
    \ a DTag value to fragments belonging to the same\n   SCHC Packet.  Concerns were\
    \ raised that, if DTag is a wide counter\n   that is incremented in a predictable\
    \ fashion for each new fragmented\n   SCHC Packet, it might lead to a privacy\
    \ issue, such as enabling\n   tracking of a device across LPWANs.\n   However,\
    \ SCHC F/R is expected to be used over exactly one LPWAN link.\n   As described\
    \ in Section 5.2, even if the SCHC F/R on the Network\n   Infrastructure side\
    \ is located in the Internet, a tunnel is to be\n   established between it and\
    \ the NGW.  Therefore, assuming the tunnel\n   provides confidentiality, neither\
    \ the DTag field nor any other SCHC-\n   introduced field is visible over the\
    \ Internet.\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC6936]  Fairhurst, G. and M. Westerlund, \"Applicability Statement\n  \
    \            for the Use of IPv6 UDP Datagrams with Zero Checksums\",\n      \
    \        RFC 6936, DOI 10.17487/RFC6936, April 2013,\n              <https://www.rfc-editor.org/info/rfc6936>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8200]  Deering,\
    \ S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6) Specification\"\
    , STD 86, RFC 8200,\n              DOI 10.17487/RFC8200, July 2017,\n        \
    \      <https://www.rfc-editor.org/info/rfc8200>.\n   [RFC8376]  Farrell, S.,\
    \ Ed., \"Low-Power Wide Area Network (LPWAN)\n              Overview\", RFC 8376,\
    \ DOI 10.17487/RFC8376, May 2018,\n              <https://www.rfc-editor.org/info/rfc8376>.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [ETHERNET] IEEE, \"IEEE Standard for Ethernet\"\
    ,\n              DOI 10.1109/IEEESTD.2012.6419735, IEEE\n              Standard\
    \ 802.3-2012, December 2012,\n              <https://ieeexplore.ieee.org/document/6419735>.\n\
    \   [RFC4944]  Montenegro, G., Kushalnagar, N., Hui, J., and D. Culler,\n    \
    \          \"Transmission of IPv6 Packets over IEEE 802.15.4\n              Networks\"\
    , RFC 4944, DOI 10.17487/RFC4944, September 2007,\n              <https://www.rfc-editor.org/info/rfc4944>.\n\
    \   [RFC5795]  Sandlund, K., Pelletier, G., and L-E. Jonsson, \"The RObust\n \
    \             Header Compression (ROHC) Framework\", RFC 5795,\n             \
    \ DOI 10.17487/RFC5795, March 2010,\n              <https://www.rfc-editor.org/info/rfc5795>.\n\
    \   [RFC6282]  Hui, J., Ed. and P. Thubert, \"Compression Format for IPv6\n  \
    \            Datagrams over IEEE 802.15.4-Based Networks\", RFC 6282,\n      \
    \        DOI 10.17487/RFC6282, September 2011,\n              <https://www.rfc-editor.org/info/rfc6282>.\n\
    \   [RFC6437]  Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme,\n     \
    \         \"IPv6 Flow Label Specification\", RFC 6437,\n              DOI 10.17487/RFC6437,\
    \ November 2011,\n              <https://www.rfc-editor.org/info/rfc6437>.\n \
    \  [RFC7136]  Carpenter, B. and S. Jiang, \"Significance of IPv6\n           \
    \   Interface Identifiers\", RFC 7136, DOI 10.17487/RFC7136,\n              February\
    \ 2014, <https://www.rfc-editor.org/info/rfc7136>.\n   [RFC8065]  Thaler, D.,\
    \ \"Privacy Considerations for IPv6 Adaptation-\n              Layer Mechanisms\"\
    , RFC 8065, DOI 10.17487/RFC8065,\n              February 2017, <https://www.rfc-editor.org/info/rfc8065>.\n"
- title: Appendix A.  Compression Examples
  contents:
  - "Appendix A.  Compression Examples\n   This section gives some scenarios of the\
    \ compression mechanism for\n   IPv6/UDP.  The goal is to illustrate the behavior\
    \ of SCHC.\n   The mechanisms defined in this document can be applied to a Dev\
    \ that\n   embeds some applications running over CoAP.  In this example, three\n\
    \   flows are considered.  The first flow is for the device management\n   based\
    \ on CoAP using Link Local IPv6 addresses and UDP ports 123 and\n   124 for Dev\
    \ and App, respectively.  The second flow is a CoAP server\n   for measurements\
    \ done by the Dev (using ports 5683) and Global IPv6\n   Address prefixes alpha::IID/64\
    \ to beta::1/64.  The last flow is for\n   legacy applications using different\
    \ ports numbers, the destination\n   IPv6 address prefix is gamma::1/64.\n   Figure\
    \ 25 presents the protocol stack.  IPv6 and UDP are represented\n   with dotted\
    \ lines since these protocols are compressed on the radio\n   link.\n    Management\
    \   Data\n   |   CoAP   |  CoAP   | legacy  |\n   .   UDP    .  UDP    |   UDP\
    \   |\n   .   IPv6   .  IPv6   .  IPv6   .\n   |    SCHC Header compression  \
    \ |\n   |      and fragmentation       |\n   |      LPWAN L2 technologies   |\n\
    \            Dev or NGW\n              Figure 25: Simplified Protocol Stack for\
    \ LP-WAN\n   Rule 0\n     Special RuleID used to tag an uncompressed UDP/IPV6\
    \ packet.\n   Rule 1\n    |       FID      |FL|FP|DI|    TV   |   MO   |     CDA\
    \    || Sent |\n    |IPv6 Version    |4 |1 |Bi|6        | ignore | not-sent  \
    \ ||      |\n    |IPv6 Diffserv   |8 |1 |Bi|0        | equal  | not-sent   ||\
    \      |\n    |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||   \
    \   |\n    |IPv6 Length     |16|1 |Bi|         | ignore | compute-*  ||      |\n\
    \    |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |\n   \
    \ |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |\n    |IPv6\
    \ DevPrefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |\n    |IPv6 DevIID\
    \     |64|1 |Bi|         | ignore | DevIID     ||      |\n    |IPv6 AppPrefix\
    \  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |\n    |IPv6 AppIID     |64|1\
    \ |Bi|::1      | equal  | not-sent   ||      |\n    |UDP DevPort     |16|1 |Bi|123\
    \      | equal  | not-sent   ||      |\n    |UDP AppPort     |16|1 |Bi|124   \
    \   | equal  | not-sent   ||      |\n    |UDP Length      |16|1 |Bi|         |\
    \ ignore | compute-*  ||      |\n    |UDP checksum    |16|1 |Bi|         | ignore\
    \ | compute-*  ||      |\n                Figure 26: Context Rules - Rule 0 and\
    \ Rule 1\n    Rule 2\n    |       FID      |FL|FP|DI|    TV   |   MO   |     CDA\
    \    || Sent |\n    |IPv6 Version    |4 |1 |Bi|6        | ignore | not-sent  \
    \ ||      |\n    |IPv6 Diffserv   |8 |1 |Bi|0        | equal  | not-sent   ||\
    \      |\n    |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||   \
    \   |\n    |IPv6 Length     |16|1 |Bi|         | ignore | compute-*  ||      |\n\
    \    |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |\n   \
    \ |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |\n    |IPv6\
    \ DevPrefix  |64|1 |Bi|[alpha/64, match- |mapping-sent||   1  |\n    |       \
    \         |  |  |  |fe80::/64] mapping|            ||      |\n    |IPv6 DevIID\
    \     |64|1 |Bi|         | ignore | DevIID     ||      |\n    |IPv6 AppPrefix\
    \  |64|1 |Bi|[beta/64,| match- |mapping-sent||   2  |\n    |                |\
    \  |  |  |alpha/64,| mapping|            ||      |\n    |                |  |\
    \  |  |fe80::64]|        |            ||      |\n    |IPv6 AppIID     |64|1 |Bi|::1000\
    \   | equal  | not-sent   ||      |\n    |UDP DevPort     |16|1 |Bi|5683     |\
    \ equal  | not-sent   ||      |\n    |UDP AppPort     |16|1 |Bi|5683     | equal\
    \  | not-sent   ||      |\n    |UDP Length      |16|1 |Bi|         | ignore |\
    \ compute-*  ||      |\n    |UDP checksum    |16|1 |Bi|         | ignore | compute-*\
    \  ||      |\n                     Figure 27: Context Rules - Rule 2\n    Rule\
    \ 3\n    |       FID      |FL|FP|DI|    TV   |   MO   |     CDA    || Sent |\n\
    \    |IPv6 Version    |4 |1 |Bi|6        | ignore | not-sent   ||      |\n   \
    \ |IPv6 Diffserv   |8 |1 |Bi|0        | equal  | not-sent   ||      |\n    |IPv6\
    \ Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |\n    |IPv6 Length\
    \     |16|1 |Bi|         | ignore | compute-*  ||      |\n    |IPv6 Next Header|8\
    \ |1 |Bi|17       | equal  | not-sent   ||      |\n    |IPv6 Hop Limit  |8 |1\
    \ |Up|255      | ignore | not-sent   ||      |\n    |IPv6 Hop Limit  |8 |1 |Dw|\
    \         | ignore | value-sent ||   8  |\n    |IPv6 DevPrefix  |64|1 |Bi|alpha/64\
    \ | equal  | not-sent   ||      |\n    |IPv6 DevIID     |64|1 |Bi|         | ignore\
    \ | DevIID     ||      |\n    |IPv6 AppPrefix  |64|1 |Bi|gamma/64 | equal  | not-sent\
    \   ||      |\n    |IPv6 AppIID     |64|1 |Bi|::1000   | equal  | not-sent   ||\
    \      |\n    |UDP DevPort     |16|1 |Bi|8720     | MSB(12)| LSB        ||   4\
    \  |\n    |UDP AppPort     |16|1 |Bi|8720     | MSB(12)| LSB        ||   4  |\n\
    \    |UDP Length      |16|1 |Bi|         | ignore | compute-*  ||      |\n   \
    \ |UDP checksum    |16|1 |Bi|         | ignore | compute-*  ||      |\n      \
    \               Figure 28: Context Rules - Rule 3\n   Figures 26 to 28 describe\
    \ an example of a Rule set.\n   In this example, 0 was chosen as the special RuleID\
    \ that tags packets\n   that cannot be compressed with any compression Rule.\n\
    \   All the fields described in Rules 1-3 are present in the IPv6 and UDP\n  \
    \ headers.  The DevIID value is inferred from the L2 header.\n   Rules 2-3 use\
    \ global addresses.  The way the Dev learns the prefix is\n   not in the scope\
    \ of the document.\n   Rule 3 compresses each port number to 4 bits.\n"
- title: Appendix B.  Fragmentation Examples
  contents:
  - "Appendix B.  Fragmentation Examples\n   This section provides examples for the\
    \ various fragment reliability\n   modes specified in this document.  In the drawings,\
    \ Bitmaps are shown\n   in their uncompressed form.\n   Figure 29 illustrates\
    \ the transmission in No-ACK mode of a SCHC\n   Packet that needs 11 SCHC Fragments.\
    \  FCN is 1 bit wide.\n           Sender               Receiver\n            \
    \ |-------FCN=0-------->|\n             |-------FCN=0-------->|\n            \
    \ |-------FCN=0-------->|\n             |-------FCN=0-------->|\n            \
    \ |-------FCN=0-------->|\n             |-------FCN=0-------->|\n            \
    \ |-------FCN=0-------->|\n             |-------FCN=0-------->|\n            \
    \ |-------FCN=0-------->|\n             |-------FCN=0-------->|\n            \
    \ |-----FCN=1 + RCS --->| Integrity check: success\n           (End)\n       \
    \          Figure 29: No-ACK Mode, 11 SCHC Fragments\n   In the following examples,\
    \ N (the size of the FCN field) is 3 bits.\n   The All-1 FCN value is therefore\
    \ 7.\n   Figure 30 illustrates the transmission in ACK-on-Error mode of a SCHC\n\
    \   Packet fragmented in 11 tiles, with one tile per SCHC Fragment,\n   WINDOW_SIZE=7\
    \ and no lost SCHC Fragment.\n           Sender               Receiver\n     \
    \        |-----W=0, FCN=6----->|\n             |-----W=0, FCN=5----->|\n     \
    \        |-----W=0, FCN=4----->|\n             |-----W=0, FCN=3----->|\n     \
    \        |-----W=0, FCN=2----->|\n             |-----W=0, FCN=1----->|\n     \
    \        |-----W=0, FCN=0----->|\n         (no ACK)\n             |-----W=1, FCN=6----->|\n\
    \             |-----W=1, FCN=5----->|\n             |-----W=1, FCN=4----->|\n\
    \             |--W=1, FCN=7 + RCS-->| Integrity check: success\n             |<--\
    \ ACK, W=1, C=1 ---| C=1\n           (End)\n         Figure 30: ACK-on-Error Mode,\
    \ 11 Tiles, One Tile per SCHC\n                      Fragment, No Lost SCHC Fragment\n\
    \   Figure 31 illustrates the transmission in ACK-on-Error mode of a SCHC\n  \
    \ Packet fragmented in 11 tiles, with one tile per SCHC Fragment,\n   WINDOW_SIZE=7,\
    \ and three lost SCHC Fragments.\n           Sender               Receiver\n \
    \            |-----W=0, FCN=6----->|\n             |-----W=0, FCN=5----->|\n \
    \            |-----W=0, FCN=4--X-->|\n             |-----W=0, FCN=3----->|\n \
    \            |-----W=0, FCN=2--X-->|\n             |-----W=0, FCN=1----->|\n \
    \            |-----W=0, FCN=0----->|        6543210\n             |<-- ACK, W=0,\
    \ C=0 ---| Bitmap:1101011\n             |-----W=0, FCN=4----->|\n            \
    \ |-----W=0, FCN=2----->|\n         (no ACK)\n             |-----W=1, FCN=6----->|\n\
    \             |-----W=1, FCN=5----->|\n             |-----W=1, FCN=4--X-->|\n\
    \             |- W=1, FCN=7 + RCS ->| Integrity check: failure\n             |<--\
    \ ACK, W=1, C=0 ---| C=0, Bitmap:1100001\n             |-----W=1, FCN=4----->|\
    \ Integrity check: success\n             |<-- ACK, W=1, C=1 ---| C=1\n       \
    \    (End)\n         Figure 31: ACK-on-Error Mode, 11 Tiles, One Tile per SCHC\n\
    \                       Fragment, Lost SCHC Fragments\n   Figure 32 shows an example\
    \ of a transmission in ACK-on-Error mode of\n   a SCHC Packet fragmented in 73\
    \ tiles, with N=5, WINDOW_SIZE=28, M=2,\n   and three lost SCHC Fragments.\n \
    \     Sender               Receiver\n       |-----W=0, FCN=27----->| 4 tiles sent\n\
    \       |-----W=0, FCN=23----->| 4 tiles sent\n       |-----W=0, FCN=19----->|\
    \ 4 tiles sent\n       |-----W=0, FCN=15--X-->| 4 tiles sent (not received)\n\
    \       |-----W=0, FCN=11----->| 4 tiles sent\n       |-----W=0, FCN=7 ----->|\
    \ 4 tiles sent\n       |-----W=0, FCN=3 ----->| 4 tiles sent\n       |-----W=1,\
    \ FCN=27----->| 4 tiles sent\n       |-----W=1, FCN=23----->| 4 tiles sent\n \
    \      |-----W=1, FCN=19----->| 4 tiles sent\n       |-----W=1, FCN=15----->|\
    \ 4 tiles sent\n       |-----W=1, FCN=11----->| 4 tiles sent\n       |-----W=1,\
    \ FCN=7 ----->| 4 tiles sent\n       |-----W=1, FCN=3 --X-->| 4 tiles sent (not\
    \ received)\n       |-----W=2, FCN=27----->| 4 tiles sent\n       |-----W=2, FCN=23----->|\
    \ 4 tiles sent\n   ^   |-----W=2, FCN=19----->| 1 tile sent\n   |   |-----W=2,\
    \ FCN=18----->| 1 tile sent\n   |   |-----W=2, FCN=17----->| 1 tile sent\n   \
    \    |-----W=2, FCN=16----->| 1 tile sent\n   s   |-----W=2, FCN=15----->| 1 tile\
    \ sent\n   m   |-----W=2, FCN=14----->| 1 tile sent\n   a   |-----W=2, FCN=13--X-->|\
    \ 1 tile sent (not received)\n   l   |-----W=2, FCN=12----->| 1 tile sent\n  \
    \ l   |---W=2, FCN=31 + RCS->| Integrity check: failure\n   e   |<--- ACK, W=0,\
    \ C=0 ---| C=0, Bitmap:1111111111110000111111111111\n   r   |-----W=0, FCN=15----->|\
    \ 1 tile sent\n       |-----W=0, FCN=14----->| 1 tile sent\n   L   |-----W=0,\
    \ FCN=13----->| 1 tile sent\n   2   |-----W=0, FCN=12----->| 1 tile sent\n   \
    \    |<--- ACK, W=1, C=0 ---| C=0, Bitmap:1111111111111111111111110000\n   M \
    \  |-----W=1, FCN=3 ----->| 1 tile sent\n   T   |-----W=1, FCN=2 ----->| 1 tile\
    \ sent\n   U   |-----W=1, FCN=1 ----->| 1 tile sent\n       |-----W=1, FCN=0 ----->|\
    \ 1 tile sent\n   |   |<--- ACK, W=2, C=0 ---| C=0, Bitmap:1111111111111101000000000001\n\
    \   |   |-----W=2, FCN=13----->| Integrity check: success\n   V   |<--- ACK, W=2,\
    \ C=1 ---| C=1\n     (End)\n                 Figure 32: ACK-on-Error Mode, Variable\
    \ MTU\n   In this example, the L2 MTU becomes reduced just before sending the\n\
    \   \"W=2, FCN=19\" fragment, leaving space for only one tile in each\n   forthcoming\
    \ SCHC Fragment.  Before retransmissions, the 73 tiles are\n   carried by a total\
    \ of 25 SCHC Fragments, the last nine being of\n   smaller size.\n   Note: other\
    \ sequences of events (e.g., regarding when ACKs are sent\n   by the Receiver)\
    \ are also allowed by this specification.  Profiles\n   may restrict this flexibility.\n\
    \   Figure 33 illustrates the transmission in ACK-Always mode of a SCHC\n   Packet\
    \ fragmented in 11 tiles, with one tile per SCHC Fragment, with\n   N=3, WINDOW_SIZE=7,\
    \ and no loss.\n           Sender               Receiver\n             |-----W=0,\
    \ FCN=6----->|\n             |-----W=0, FCN=5----->|\n             |-----W=0,\
    \ FCN=4----->|\n             |-----W=0, FCN=3----->|\n             |-----W=0,\
    \ FCN=2----->|\n             |-----W=0, FCN=1----->|\n             |-----W=0,\
    \ FCN=0----->|\n             |<-- ACK, W=0, C=0 ---| Bitmap:1111111\n        \
    \     |-----W=1, FCN=6----->|\n             |-----W=1, FCN=5----->|\n        \
    \     |-----W=1, FCN=4----->|\n             |--W=1, FCN=7 + RCS-->| Integrity\
    \ check: success\n             |<-- ACK, W=1, C=1 ---| C=1\n           (End)\n\
    \     Figure 33: ACK-Always Mode, 11 Tiles, One Tile per SCHC Fragment,\n   Figure\
    \ 34 illustrates the transmission in ACK-Always mode of a SCHC\n   Packet fragmented\
    \ in 11 tiles, with one tile per SCHC Fragment, N=3,\n   WINDOW_SIZE=7 and three\
    \ lost SCHC Fragments.\n           Sender               Receiver\n           \
    \  |-----W=0, FCN=6----->|\n             |-----W=0, FCN=5----->|\n           \
    \  |-----W=0, FCN=4--X-->|\n             |-----W=0, FCN=3----->|\n           \
    \  |-----W=0, FCN=2--X-->|\n             |-----W=0, FCN=1----->|\n           \
    \  |-----W=0, FCN=0----->|        6543210\n             |<-- ACK, W=0, C=0 ---|\
    \ Bitmap:1101011\n             |-----W=0, FCN=4----->|\n             |-----W=0,\
    \ FCN=2----->|\n             |<-- ACK, W=0, C=0 ---| Bitmap:1111111\n        \
    \     |-----W=1, FCN=6----->|\n             |-----W=1, FCN=5----->|\n        \
    \     |-----W=1, FCN=4--X-->|\n             |--W=1, FCN=7 + RCS-->| Integrity\
    \ check: failure\n             |<-- ACK, W=1, C=0 ---| C=0, Bitmap:11000001\n\
    \             |-----W=1, FCN=4----->| Integrity check: success\n             |<--\
    \ ACK, W=1, C=1 ---| C=1\n           (End)\n     Figure 34: ACK-Always Mode, 11\
    \ Tiles, One Tile per SCHC Fragment,\n                         Three Lost SCHC\
    \ Fragments\n   Figure 35 illustrates the transmission in ACK-Always mode of a\
    \ SCHC\n   Packet fragmented in six tiles, with one tile per SCHC Fragment, N=3,\n\
    \   WINDOW_SIZE=7, three lost SCHC Fragments, and only one retry needed\n   to\
    \ recover each lost SCHC Fragment.\n             Sender                Receiver\n\
    \                |-----W=0, FCN=6----->|\n                |-----W=0, FCN=5----->|\n\
    \                |-----W=0, FCN=4--X-->|\n                |-----W=0, FCN=3--X-->|\n\
    \                |-----W=0, FCN=2--X-->|\n                |--W=0, FCN=7 + RCS-->|\
    \ Integrity check: failure\n                |<-- ACK, W=0, C=0 ---| C=0, Bitmap:1100001\n\
    \                |-----W=0, FCN=4----->| Integrity check: failure\n          \
    \      |-----W=0, FCN=3----->| Integrity check: failure\n                |-----W=0,\
    \ FCN=2----->| Integrity check: success\n                |<-- ACK, W=0, C=1 ---|\
    \ C=1\n              (End)\n          Figure 35: ACK-Always Mode, Six Tiles, One\
    \ Tile per SCHC\n                    Fragment, Three Lost SCHC Fragments\n   Figure\
    \ 36 illustrates the transmission in ACK-Always mode of a SCHC\n   Packet fragmented\
    \ in six tiles, with one tile per SCHC Fragment, N=3,\n   WINDOW_SIZE=7, three\
    \ lost SCHC Fragments, and the second SCHC ACK\n   lost.\n             Sender\
    \                Receiver\n                |-----W=0, FCN=6----->|\n         \
    \       |-----W=0, FCN=5----->|\n                |-----W=0, FCN=4--X-->|\n   \
    \             |-----W=0, FCN=3--X-->|\n                |-----W=0, FCN=2--X-->|\n\
    \                |--W=0, FCN=7 + RCS-->| Integrity check: failure\n          \
    \      |<-- ACK, W=0, C=0 ---| C=0, Bitmap:1100001\n                |-----W=0,\
    \ FCN=4----->| Integrity check: failure\n                |-----W=0, FCN=3----->|\
    \ Integrity check: failure\n                |-----W=0, FCN=2----->| Integrity\
    \ check: success\n                |<-X-ACK, W=0, C=1 ---| C=1\n       timeout\
    \  |                     |\n                |--- W=0, ACK REQ --->| ACK REQ\n\
    \                |<-- ACK, W=0, C=1 ---| C=1\n              (End)\n          Figure\
    \ 36: ACK-Always Mode, Six Tiles, One Tile per SCHC\n                        \
    \  Fragment, SCHC ACK Loss\n   Figure 37 illustrates the transmission in ACK-Always\
    \ mode of a SCHC\n   Packet fragmented in six tiles, with N=3, WINDOW_SIZE=7,\
    \ with three\n   lost SCHC Fragments, and one retransmitted SCHC Fragment lost\
    \ again.\n              Sender                Receiver\n                |-----W=0,\
    \ FCN=6----->|\n                |-----W=0, FCN=5----->|\n                |-----W=0,\
    \ FCN=4--X-->|\n                |-----W=0, FCN=3--X-->|\n                |-----W=0,\
    \ FCN=2--X-->|\n                |--W=0, FCN=7 + RCS-->| Integrity check: failure\n\
    \                |<-- ACK, W=0, C=0 ---| C=0, Bitmap:1100001\n               \
    \ |-----W=0, FCN=4----->| Integrity check: failure\n                |-----W=0,\
    \ FCN=3----->| Integrity check: failure\n                |-----W=0, FCN=2--X-->|\n\
    \         timeout|                     |\n                |--- W=0, ACK REQ --->|\
    \ ACK REQ\n                |<-- ACK, W=0, C=0 ---| C=0, Bitmap: 1111101\n    \
    \            |-----W=0, FCN=2----->| Integrity check: success\n              \
    \  |<-- ACK, W=0, C=1 ---| C=1\n              (End)\n         Figure 37: ACK-Always\
    \ Mode, Six Tiles, Retransmitted SCHC\n                            Fragment Lost\
    \ Again\n   Figure 38 illustrates the transmission in ACK-Always mode of a SCHC\n\
    \   Packet fragmented in 28 tiles, with one tile per SCHC Fragment, N=5,\n   WINDOW_SIZE=24,\
    \ and two lost SCHC Fragments.\n         Sender               Receiver\n     \
    \      |-----W=0, FCN=23----->|\n           |-----W=0, FCN=22----->|\n       \
    \    |-----W=0, FCN=21--X-->|\n           |-----W=0, FCN=20----->|\n         \
    \  |-----W=0, FCN=19----->|\n           |-----W=0, FCN=18----->|\n           |-----W=0,\
    \ FCN=17----->|\n           |-----W=0, FCN=16----->|\n           |-----W=0, FCN=15----->|\n\
    \           |-----W=0, FCN=14----->|\n           |-----W=0, FCN=13----->|\n  \
    \         |-----W=0, FCN=12----->|\n           |-----W=0, FCN=11----->|\n    \
    \       |-----W=0, FCN=10--X-->|\n           |-----W=0, FCN=9 ----->|\n      \
    \     |-----W=0, FCN=8 ----->|\n           |-----W=0, FCN=7 ----->|\n        \
    \   |-----W=0, FCN=6 ----->|\n           |-----W=0, FCN=5 ----->|\n          \
    \ |-----W=0, FCN=4 ----->|\n           |-----W=0, FCN=3 ----->|\n           |-----W=0,\
    \ FCN=2 ----->|\n           |-----W=0, FCN=1 ----->|\n           |-----W=0, FCN=0\
    \ ----->|\n           |<--- ACK, W=0, C=0 ---| Bitmap:110111111111101111111111\n\
    \           |-----W=0, FCN=21----->|\n           |-----W=0, FCN=10----->|\n  \
    \         |<--- ACK, W=0, C=0 ---| Bitmap:111111111111111111111111\n         \
    \  |-----W=1, FCN=23----->|\n           |-----W=1, FCN=22----->|\n           |-----W=1,\
    \ FCN=21----->|\n           |--W=1, FCN=31 + RCS-->| Integrity check: success\n\
    \           |<--- ACK, W=1, C=1 ---| C=1\n         (End)\n     Figure 38: ACK-Always\
    \ Mode, 28 Tiles, One Tile per SCHC Fragment,\n                            Lost\
    \ SCHC Fragments\n"
- title: Appendix C.  Fragmentation State Machines
  contents:
  - "Appendix C.  Fragmentation State Machines\n   The fragmentation state machines\
    \ of the sender and the receiver, one\n   for each of the different reliability\
    \ modes, are described in the\n   following figures:\n                +===========+\n\
    \   +------------+  Init     |\n   |  FCN=0     +===========+\n   |  No Window\n\
    \   |  No Bitmap\n   +--------> |   Send    |      send Fragment (FCN=0)\n   \
    \           +===+=======+\n                  |  last fragment\n              \
    \    |  FCN = 1\n                  v  send fragment+RCS\n              +============+\n\
    \              |    END     |\n              +============+\n            Figure\
    \ 39: Sender State Machine for the No-ACK Mode\n              |  RCV Frag  +-------+\n\
    \      All-1 &   |   |              |RCS correct\n    RCS wrong   |   |Inactivity\
    \    |\n                |   |Timer Exp.    |\n                v   |          \
    \    |\n     |   Error   |<-+     +========+==+\n     +===========+        | \
    \   END    |\n           Figure 40: Receiver State Machine for the No-ACK Mode\n\
    \                 +=======+\n                 | INIT  |       FCN!=0 & more frags\n\
    \                    W=0 |   |  | FCN-\n     Clear lcl_bm       |   |  v set lcl_bm\n\
    \          FCN=max value |  ++==+========+\n   |      FCN==0 & more frags |  \
    \ | last frag\n   |               set lcl_bm |   | set lcl_bm\n   |   send wnd\
    \ + frag(all-0) |   | send wnd+frag(all-1)+RCS\n   |       set Retrans_Timer \
    \ |   | set Retrans_Timer\n   |Recv_wnd == wnd &         |   |\n   |lcl_bm==recv_bm\
    \ &         |   |  +----------------------+\n   |more frag                 | \
    \  |  | lcl_bm!=rcv-bm       |\n   |Stop Retrans_Timer        |   |  | Attempt++\
    \            v\n   |clear lcl_bm              v   v  |                +=====+=+\n\
    \   |window=next_window   +====+===+==+===+            |Resend |\n           \
    \         +----+     Wait      |            |Frag   |\n   not expected wnd | \
    \   |    Bitmap     |            +=======+\n       discard frag      +==+=+===+=+==+=+|\
    \ ~~~~~~~~~~~~~~~~~ |\n     C_bit==1 &             | |   | +-------------------------+\n\
    \   Recv_window==window &    | |   |   all missing frags sent\n              \
    \  no more frag| |   |   ~~~~~~~~~~~~~~~~~~~~~~\n          Stop Retrans_Timer|\
    \ |   |\n    |     END     +<--------+ |   |\n               All-1 Window & |\
    \   | ~~~~~~~~~~~~~~~~~~\n                  C_bit ==0 & |   v Send Abort\n   \
    \          lcl_bm==recv_bm  | +=+===========+\n                   Send Abort \
    \  +=============+\n          Figure 41: Sender State Machine for the ACK-Always\
    \ Mode\n    Not All- & w=expected +---+   +---+w = Not expected\n    Set lcl_bm(FCN)\
    \       |   v   v   |discard\n   +---------------------+     Rcv      +--->* ABORT\n\
    \   |  +------------------+   Window     |\n   |  |       All-0 & w=expect | \
    \ ^ w =next & not-All\n   |  |    set lcl_bm(FCN)     |  |expected = next window\n\
    \   |  |      send lcl_bm       |  |Clear lcl_bm\n   |  | w=expected & not-All\
    \   |  |\n   |  |     set lcl_bm(FCN)+-+ |  | +--+ w=next & All-0\n   |  |   \
    \  if lcl_bm full | | |  | |  | ~~~~~~~~~~~~~~~\n   |  |     send lcl_bm    |\
    \ | |  | |  | expected = nxt wnd\n   |  |                    v | v  | |  | Clear\
    \ lcl_bm\n   |  |w=expected& All-1 +=+=+=+==+=++ | set lcl_bm(FCN)\n   |  |  ~~~~~~~~~~~\
    \  +->+    Wait   +<+ send lcl_bm\n   |  |    discard    +--|    Next   |\n  \
    \ |  | All-0  +---------+  Window   +--->* ABORT\n   |  | snd lcl_bm  All-1 &\
    \ w=next| |  All-1 & w=nxt\n   |  |                & RCS wrong| |  & RCS right\n\
    \   |  |            set lcl_bm(FCN)| |set lcl_bm(FCN)\n   |  |               \
    \ send lcl_bm| |send lcl_bm\n   |  |All-1 & w=expected         |             \
    \           |\n   |  |& RCS wrong                v   +---+ w=expected &   |\n\
    \   |  |set lcl_bm(FCN)       |          +<+ ~~~~~~~~~~~~~~ |\n   |  |send lcl_bm\
    \           | Wait End |   set lcl_bm(FCN)|\n   |      w=expected & RCS right\
    \ |    +---+   send lcl_bm  |\n   |       set lcl_bm(FCN)       | +-+ Not All-1\
    \           |\n   |        send lcl_bm          | | | ~~~~~~~~~           |\n\
    \   |All-1&w=expected & RCS right | | |                     |\n   |set lcl_bm(FCN)\
    \            +=+=+=+=+==+ |~~~~~~~~~     |\n   |send lcl_bm                | \
    \         +<+Send lcl_bm   |\n          --->* ABORT\n          In any state\n\
    \             on receiving a SCHC ACK REQ\n                Send a SCHC ACK for\
    \ the current window\n         Figure 42: Receiver State Machine for the ACK-Always\
    \ Mode\n                     +=======+\n                     |       |\n     \
    \                | INIT  |\n        Frag RuleID trigger |   +--+ Send cur_W +\
    \ frag(FCN);\n     cur_W=0; FCN=max_value;|   |  | set [cur_W, cur_Bmp]\n    \
    \   clear [cur_W, Bmp_n];|   |  v\n             clear rcv_Bmp  |  ++==+==========+\
    \       **BACK_TO_SEND\n         **BACK_TO_SEND        |     SEND     |   [cur_W,Bmp_n]==rcv_Bmp\n\
    \   |  |      FCN==0 & more frags|  |last frag     clear [cur_W, Bmp_n]\n   |\
    \  |        set cur_Bmp;     |  |set [cur_W, Bmp_n];\n   |  |send cur_W + frag(All-0);|\
    \  |send cur_W + frag(All-1)+RCS;\n   |  |        set Retrans_Timer|  |set Retrans_Timer\n\
    \   |  |Retrans_Timer expires &  |  | |   rcv_W & [cur_W,Bmp_n]!=rcv_Bmp|\n  \
    \ |  |more Frags               |  | |  ~~~~~~~~~~~~~~~~~~~            |\n   |\
    \  |stop Retrans_Timer;      |  | | +--------+           rcv_W==Wn &|\n   |  |[cur_W,Bmp_n]==cur_Bmp;\
    \  v  v | |        v   [Wn,Bmp_n]!=rcv_Bmp|\n   |  |cur_W++            +=====+==+=+=+==+\
    \   +=+=========+ ~~~~~~~~~~~|\n   +----------------------+   Wait x ACK  |  \
    \ | Missing   |       W=Wn |\n   |         rcv_W==Wn &+-+               |   +======+====+\n\
    \   | [Wn,Bmp_n]!=rcv_Bmp| ++=+===+===+==+=+          |\n   |        send (cur_W,+--+\
    \ |   |   |  +------------+\n   |        ALL-0-empty)     |   |   |     all missing\
    \ frag sent(W)\n   |  Retrans_Timer expires &|   |   |     set Retrans_Timer\n\
    \   |            No more Frags|   |   |\n   |      stop Retrans_Timer;|   |  \
    \ |\n   |(re)send frag(All-1)+RCS |   |   |\n                    cur_W==rcv_W&|\
    \   |\n          [cur_W,Bmp_n]==rcv_Bmp&|   | Attempts > MAX_ACK_REQUESTS\n  \
    \   No more Frags & RCS flag==OK|   | ~~~~~~~~~~\n    +=========+stop Retrans_Timer|\
    \   |  +===========+\n    |   END   +<-----------------+   +->+   ERROR   |\n\
    \         Figure 43: Sender State Machine for the ACK-on-Error Mode\n   This is\
    \ an example only.  It is not normative.  The specification in\n   Section 8.4.3.1\
    \ allows for sequences of operations different from the\n   one shown here.\n\
    \                    | INIT  +-------+cur_W=0;clear([cur_W,Bmp_n]);\n       Not\
    \ All* & rcv_W==cur_W+---+ | +--+\n         set[cur_W,Bmp_n(FCN)]|   v v v  |\n\
    \      |           ABORT *<---+  Rcv Window |  | ~~~~~~~~~~\n      |  | All-0\
    \ empty(Wn)|    | | | ^ ^\n      |  | sendACK([Wn,Bmp_n])   | | | |& Full([cur_W,Bmp_n])\n\
    \      |  |    All* & rcv_W==cur_W|(C)| |sendACK([cur_W,Bmp_n]);\n      |  | \
    \             & sync==0| | | |cur_W++; clear([cur_W,Bmp_n])\n      |  |&no_full([cur_W,Bmp_n])|\
    \ |(E)|\n      |  | sendACK([cur_W,Bmp_n])| | | |              | Error/ |\n  \
    \    |  | All-0 empty(Wn)+->| Missing Frags |<-+         |\n      |  | sendACK([Wn,Bmp_n])\
    \             +--------------+\n      v  v\n     (A)(B)\n       (C) All* & sync>0\
    \                  & rcv_W!=cur_W & sync>0\n           Wn=oldest[not full(W)];\
    \        ~~~~~~~~~~~~~~~~~~~~\n           sendACK([Wn,Bmp_n])            Wn=oldest[not\
    \ full(W)];\n       (E) Not All* & rcv_W!=cur_W        || Attempts > MAX_ACK_REQUESTS\n\
    \           sync++; cur_W=rcv_W;           send Abort\n           set[cur_W,Bmp_n(FCN)]\n\
    \     (A)(B)\n      |  |\n      |  | All-1 & rcv_W==cur_W & RCS!=OK        All-0\
    \ empty(Wn)\n      |  | sendACK([cur_W,Bmp_n],C=0)       | v  sendACK([Wn,Bmp_n])\n\
    \      |     rcv_W==cur_W & RCS==OK    | |    ^   | & rcv_W==cur_W\n      |  sendACK([cur_W,Bmp_n],C=1)\
    \   | |          ~~~~~~~~~~~~~~~~~~~\n      |All-1 & Full([cur_W,Bmp_n])    |\
    \ |\n      |& RCS==OK & sync==0            | +-->* ABORT\n      |sendACK([cur_W,Bmp_n],C=1)\
    \   +=+=========+\n        Figure 44: Receiver State Machine for the ACK-on-Error\
    \ Mode\n"
- title: Appendix D.  SCHC Parameters
  contents:
  - "Appendix D.  SCHC Parameters\n   This section lists the information that needs\
    \ to be provided in the\n   LPWAN technology-specific documents.\n   *  Most common\
    \ uses cases, deployment scenarios.\n   *  Mapping of the SCHC architectural elements\
    \ onto the LPWAN\n      architecture.\n   *  Assessment of LPWAN integrity checking.\n\
    \   *  Various potential channel conditions for the technology and the\n     \
    \ corresponding recommended use of SCHC C/D and SCHC F/R.\n   This section lists\
    \ the parameters that need to be defined in the\n   Profile.\n   *  RuleID numbering\
    \ scheme, fixed-size or variable-size RuleIDs,\n      number of Rules, the way\
    \ the RuleID is transmitted.\n   *  maximum packet size that should ever be reconstructed\
    \ by SCHC\n      decompression (MAX_PACKET_SIZE).  See Section 12.\n   *  Padding:\
    \ size of the L2 Word (for most LPWAN technologies, this\n      would be a byte;\
    \ for some technologies, a bit).\n   *  Decision to use SCHC fragmentation mechanism\
    \ or not.  If yes, the\n      document must describe:\n      -  reliability mode(s)\
    \ used, in which cases (e.g., based on link\n         channel condition).\n  \
    \    -  RuleID values assigned to each mode in use.\n      -  presence and number\
    \ of bits for DTag (T) for each RuleID value,\n         lifetime of DTag at the\
    \ receiver.\n      -  support for interleaved packet transmission, to what extent.\n\
    \      -  WINDOW_SIZE, for modes that use windows.\n      -  number of bits for\
    \ W (M) for each RuleID value, for modes that\n         use windows.\n      -\
    \  number of bits for FCN (N) for each RuleID value, meaning of\n         the\
    \ FCN values.\n      -  what makes an All-0 SCHC Fragment and a SCHC ACK REQ\n\
    \         distinguishable (see Section 8.3.1.1).\n      -  what makes an All-1\
    \ SCHC Fragment and a SCHC Sender-Abort\n         distinguishable (see Section\
    \ 8.3.1.2).\n      -  for RuleIDs that use ACK-on-Error mode: when the last tile\
    \ of a\n         SCHC Packet is to be sent in a Regular SCHC Fragment, alone in\n\
    \         an All-1 SCHC Fragment or with any of these two methods.\n      -  for\
    \ RuleIDs that use ACK-on-Error mode: if the penultimate tile\n         of a SCHC\
    \ Packet is of the regular size only or if it can also\n         be one L2 Word\
    \ shorter.\n      -  for RuleIDs that use ACK-on-Error mode: times at which the\n\
    \         sender must listen for SCHC ACKs.\n      -  size of RCS and algorithm\
    \ for its computation, for each RuleID,\n         if different from the default\
    \ CRC32.  Byte fill-up with zeroes\n         or other mechanism, to be specified.\
    \  Support for UDP checksum\n         elision.\n      -  Retransmission Timer\
    \ duration for each RuleID value, if\n         applicable to the SCHC F/R mode.\n\
    \      -  Inactivity Timer duration for each RuleID value, if applicable\n   \
    \      to the SCHC F/R mode.\n      -  MAX_ACK_REQUESTS value for each RuleID\
    \ value, if applicable to\n         the SCHC F/R mode.\n   *  if L2 Word is wider\
    \ than a bit and SCHC fragmentation is used,\n      value of the padding bits\
    \ (0 or 1).\n   A Profile may define a delay to be added after each SCHC message\n\
    \   transmission for compliance with local regulations or other\n   constraints\
    \ imposed by the applications.\n   *  In some LPWAN technologies, as part of energy-saving\
    \ techniques,\n      Downlink transmission is only possible immediately after\
    \ an Uplink\n      transmission.  In order to avoid potentially high delay in\
    \ the\n      Downlink transmission of a fragmented SCHC Packet, the SCHC\n   \
    \   Fragment receiver may perform an Uplink transmission as soon as\n      possible\
    \ after reception of a SCHC Fragment that is not the last\n      one.  Such Uplink\
    \ transmission may be triggered by the L2 (e.g.,\n      an L2 ACK sent in response\
    \ to a SCHC Fragment encapsulated in a L2\n      PDU that requires an L2 ACK)\
    \ or it may be triggered from an upper\n      layer.  See Appendix F.\n   *  the\
    \ following parameters need to be addressed in documents other\n      than this\
    \ one but not necessarily in the LPWAN technology-specific\n      documents:\n\
    \      -  The way the Contexts are provisioned.\n      -  The way the Rules are\
    \ generated.\n"
- title: Appendix E.  Supporting Multiple Window Sizes for Fragmentation
  contents:
  - "Appendix E.  Supporting Multiple Window Sizes for Fragmentation\n   For ACK-Always\
    \ or ACK-on-Error, implementers may opt to support a\n   single window size or\
    \ multiple window sizes.  The latter, when\n   feasible, may provide performance\
    \ optimizations.  For example, a\n   large WINDOW_SIZE should be used for packets\
    \ that need to be split\n   into a large number of tiles.  However, when the number\
    \ of tiles\n   required to carry a packet is low, a smaller WINDOW_SIZE and, thus,\
    \ a\n   shorter Bitmap, may be sufficient to provide reception status on all\n\
    \   tiles.  If multiple window sizes are supported, the RuleID signals\n   what\
    \ WINDOW_SIZE is in use for a specific packet transmission.\n"
- title: Appendix F.  ACK-Always and ACK-on-Error on Quasi-Bidirectional Links
  contents:
  - "Appendix F.  ACK-Always and ACK-on-Error on Quasi-Bidirectional Links\n   The\
    \ ACK-Always and ACK-on-Error modes of SCHC F/R are bidirectional\n   protocols:\
    \ they require a feedback path from the reassembler to the\n   fragmenter.\n \
    \  Some LPWAN technologies provide quasi-bidirectional connectivity,\n   whereby\
    \ a Downlink transmission from the Network Infrastructure can\n   only take place\
    \ right after an Uplink transmission by the Dev.\n   When using SCHC F/R to send\
    \ fragmented SCHC Packets Downlink over\n   these quasi-bidirectional links, the\
    \ following situation may arise:\n   if an Uplink SCHC ACK is lost, the SCHC ACK\
    \ REQ message by the sender\n   could be stuck indefinitely in the Downlink queue\
    \ at the Network\n   Infrastructure, waiting for a transmission opportunity.\n\
    \   There are many ways by which this deadlock can be avoided.  The Dev\n   application\
    \ might be sending recurring Uplink messages such as keep-\n   alive, or the Dev\
    \ application stack might be sending other recurring\n   Uplink messages as part\
    \ of its operation.  However, these are out of\n   the control of this generic\
    \ SCHC specification.\n   In order to cope with quasi-bidirectional links, a SCHC-over-foo\n\
    \   specification may want to amend the SCHC F/R specification to add a\n   timer-based\
    \ retransmission of the SCHC ACK.  Below is an example of\n   the suggested behavior\
    \ for ACK-Always mode.  Because it is an\n   example, [RFC2119] language is deliberately\
    \ not used here.\n   For Downlink transmission of a fragmented SCHC Packet in\
    \ ACK-Always\n   mode, the SCHC Fragment receiver may support timer-based SCHC\
    \ ACK\n   retransmission.  In this mechanism, the SCHC Fragment receiver\n   initializes\
    \ and starts a timer (the UplinkACK Timer) after the\n   transmission of a SCHC\
    \ ACK, except when the SCHC ACK is sent in\n   response to the last SCHC Fragment\
    \ of a packet (All-1 fragment).  In\n   the latter case, the SCHC Fragment receiver\
    \ does not start a timer\n   after transmission of the SCHC ACK.\n   If, after\
    \ transmission of a SCHC ACK that is not an All-1 fragment,\n   and before expiration\
    \ of the corresponding UplinkACK timer, the SCHC\n   Fragment receiver receives\
    \ a SCHC Fragment that belongs to the\n   current window (e.g., a missing SCHC\
    \ Fragment from the current\n   window) or to the next window, the UplinkACK timer\
    \ for the SCHC ACK\n   is stopped.  However, if the UplinkACK timer expires, the\
    \ SCHC ACK is\n   resent and the UplinkACK timer is reinitialized and restarted.\n\
    \   The default initial value for the UplinkACK Timer, as well as the\n   maximum\
    \ number of retries for a specific SCHC ACK, denoted\n   MAX_ACK_REQUESTS, is\
    \ to be defined in a Profile.  The initial value\n   of the UplinkACK timer is\
    \ expected to be greater than that of the\n   Retransmission timer, in order to\
    \ make sure that a (buffered) SCHC\n   Fragment to be retransmitted finds an opportunity\
    \ for that\n   transmission.  One exception to this recommendation is the special\n\
    \   case of the All-1 SCHC Fragment transmission.\n   When the SCHC Fragment sender\
    \ transmits the All-1 SCHC Fragment, it\n   starts its Retransmission Timer with\
    \ a large timeout value (e.g.,\n   several times that of the initial UplinkACK\
    \ Timer).  If a SCHC ACK is\n   received before expiration of this timer, the\
    \ SCHC Fragment sender\n   retransmits any lost SCHC Fragments as reported by\
    \ the SCHC ACK, or\n   if the SCHC ACK confirms successful reception of all SCHC\
    \ Fragments\n   of the last window, the transmission of the fragmented SCHC Packet\
    \ is\n   considered complete.  If the timer expires, and no SCHC ACK has been\n\
    \   received since the start of the timer, the SCHC Fragment sender\n   assumes\
    \ that the All-1 SCHC Fragment has been successfully received\n   (and possibly,\
    \ the last SCHC ACK has been lost: this mechanism\n   assumes that the Retransmission\
    \ Timer for the All-1 SCHC Fragment is\n   long enough to allow several SCHC ACK\
    \ retries if the All-1 SCHC\n   Fragment has not been received by the SCHC Fragment\
    \ receiver, and it\n   also assumes that it is unlikely that several ACKs become\
    \ all lost).\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Thanks to (in alphabetical order) Sergio Aguilar Romero,\
    \ David Black,\n   Carsten Bormann, Deborah Brungard, Brian Carpenter, Philippe\
    \ Clavier,\n   Alissa Cooper, Roman Danyliw, Daniel Ducuara Beltran, Diego Dujovne,\n\
    \   Eduardo Ingles Sanchez, Rahul Jadhav, Benjamin Kaduk, Arunprabhu\n   Kandasamy,\
    \ Suresh Krishnan, Mirja Kuehlewind, Barry Leiba, Sergio\n   Lopez Bernal, Antoni\
    \ Markovski, Alexey Melnikov, Georgios\n   Papadopoulos, Alexander Pelov, Charles\
    \ Perkins, Edgar Ramos, Alvaro\n   Retana, Adam Roach, Shoichi Sakane, Joseph\
    \ Salowey, Pascal Thubert,\n   and Eric Vyncke for useful design considerations,\
    \ reviews and\n   comments.\n   Carles Gomez has been funded in part by the Spanish\
    \ Government\n   (Ministerio de Educacion, Cultura y Deporte) through the Jose\n\
    \   Castillejo grant CAS15/00336 and by the ERDF and the Spanish\n   Government\
    \ through project TEC2016-79988-P.  Part of his contribution\n   to this work\
    \ has been carried out during his stay as a visiting\n   scholar at the Computer\
    \ Laboratory of the University of Cambridge.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Ana Minaburo\n   Acklio\n   1137A avenue des Champs Blancs\n\
    \   35510 Cesson-Sevigne Cedex\n   France\n   Email: ana@ackl.io\n   Laurent Toutain\n\
    \   IMT Atlantique\n   2 rue de la Chataigneraie\n   CS 17607\n   35576 Cesson-Sevigne\
    \ Cedex\n   France\n   Email: Laurent.Toutain@imt-atlantique.fr\n   Carles Gomez\n\
    \   Universitat Politecnica de Catalunya\n   C/Esteve Terradas, 7\n   08860 Castelldefels\n\
    \   Spain\n   Email: carlesgo@entel.upc.edu\n   Dominique Barthel\n   Orange Labs\n\
    \   28 chemin du Vieux Chene\n   38243 Meylan\n   France\n   Email: dominique.barthel@orange.com\n\
    \   Juan Carlos Zuniga\n   SIGFOX\n   425 rue Jean Rostand\n   31670 Labege\n"
