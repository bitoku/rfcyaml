- title: __initial_text__
  contents:
  - '           Uniform Resource Identifier (URI): Generic Syntax

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   A Uniform Resource Identifier (URI) is a compact sequence of\n \
    \  characters that identifies an abstract or physical resource.  This\n   specification\
    \ defines the generic URI syntax and a process for\n   resolving URI references\
    \ that might be in relative form, along with\n   guidelines and security considerations\
    \ for the use of URIs on the\n   Internet.  The URI syntax defines a grammar that\
    \ is a superset of all\n   valid URIs, allowing an implementation to parse the\
    \ common components\n   of a URI reference without knowing the scheme-specific\
    \ requirements\n   of every possible identifier.  This specification does not\
    \ define a\n   generative grammar for URIs; that task is performed by the individual\n\
    \   specifications of each URI scheme.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n       1.1.  Overview of URIs . . . . . . . . . . . . . . .\
    \ . . . . .  4\n             1.1.1.  Generic Syntax . . . . . . . . . . . . .\
    \ . . . .  6\n             1.1.2.  Examples . . . . . . . . . . . . . . . . .\
    \ . . .  7\n             1.1.3.  URI, URL, and URN  . . . . . . . . . . . . .\
    \ . .  7\n       1.2.  Design Considerations  . . . . . . . . . . . . . . . .\
    \ .  8\n             1.2.1.  Transcription  . . . . . . . . . . . . . . . . .\
    \  8\n             1.2.2.  Separating Identification from Interaction . . .  9\n\
    \             1.2.3.  Hierarchical Identifiers . . . . . . . . . . . . 10\n  \
    \     1.3.  Syntax Notation  . . . . . . . . . . . . . . . . . . . . 11\n   2.\
    \  Characters . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n       2.1.\
    \  Percent-Encoding . . . . . . . . . . . . . . . . . . . . 12\n       2.2.  Reserved\
    \ Characters  . . . . . . . . . . . . . . . . . . 12\n       2.3.  Unreserved\
    \ Characters  . . . . . . . . . . . . . . . . . 13\n       2.4.  When to Encode\
    \ or Decode . . . . . . . . . . . . . . . . 14\n       2.5.  Identifying Data\
    \ . . . . . . . . . . . . . . . . . . . . 14\n   3.  Syntax Components  . . .\
    \ . . . . . . . . . . . . . . . . . . . 16\n       3.1.  Scheme . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . 17\n       3.2.  Authority  . . . . . .\
    \ . . . . . . . . . . . . . . . . . 17\n             3.2.1.  User Information\
    \ . . . . . . . . . . . . . . . . 18\n             3.2.2.  Host . . . . . . .\
    \ . . . . . . . . . . . . . . . 18\n             3.2.3.  Port . . . . . . . .\
    \ . . . . . . . . . . . . . . 22\n       3.3.  Path . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . 22\n       3.4.  Query  . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . 23\n       3.5.  Fragment . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 24\n   4.  Usage  . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 25\n       4.1.  URI Reference  . . . . . . . . . . . .\
    \ . . . . . . . . . 25\n       4.2.  Relative Reference . . . . . . . . . . .\
    \ . . . . . . . . 26\n       4.3.  Absolute URI . . . . . . . . . . . . . . .\
    \ . . . . . . . 27\n       4.4.  Same-Document Reference  . . . . . . . . . .\
    \ . . . . . . 27\n       4.5.  Suffix Reference . . . . . . . . . . . . . . .\
    \ . . . . . 27\n   5.  Reference Resolution . . . . . . . . . . . . . . . . .\
    \ . . . . 28\n       5.1.  Establishing a Base URI  . . . . . . . . . . . . .\
    \ . . . 28\n             5.1.1.  Base URI Embedded in Content . . . . . . . .\
    \ . . 29\n             5.1.2.  Base URI from the Encapsulating Entity . . . .\
    \ . 29\n             5.1.3.  Base URI from the Retrieval URI  . . . . . . . .\
    \ 30\n             5.1.4.  Default Base URI . . . . . . . . . . . . . . . . 30\n\
    \       5.2.  Relative Resolution  . . . . . . . . . . . . . . . . . . 30\n  \
    \           5.2.1.  Pre-parse the Base URI . . . . . . . . . . . . . 31\n    \
    \         5.2.2.  Transform References . . . . . . . . . . . . . . 31\n      \
    \       5.2.3.  Merge Paths  . . . . . . . . . . . . . . . . . . 32\n        \
    \     5.2.4.  Remove Dot Segments  . . . . . . . . . . . . . . 33\n       5.3.\
    \  Component Recomposition  . . . . . . . . . . . . . . . . 35\n       5.4.  Reference\
    \ Resolution Examples  . . . . . . . . . . . . . 35\n             5.4.1.  Normal\
    \ Examples  . . . . . . . . . . . . . . . . 36\n             5.4.2.  Abnormal\
    \ Examples  . . . . . . . . . . . . . . . 36\n   6.  Normalization and Comparison\
    \ . . . . . . . . . . . . . . . . . 38\n       6.1.  Equivalence  . . . . . .\
    \ . . . . . . . . . . . . . . . . 38\n       6.2.  Comparison Ladder  . . . .\
    \ . . . . . . . . . . . . . . . 39\n             6.2.1.  Simple String Comparison\
    \ . . . . . . . . . . . . 39\n             6.2.2.  Syntax-Based Normalization\
    \ . . . . . . . . . . . 40\n             6.2.3.  Scheme-Based Normalization .\
    \ . . . . . . . . . . 41\n             6.2.4.  Protocol-Based Normalization .\
    \ . . . . . . . . . 42\n   7.  Security Considerations  . . . . . . . . . . .\
    \ . . . . . . . . 43\n       7.1.  Reliability and Consistency  . . . . . . .\
    \ . . . . . . . 43\n       7.2.  Malicious Construction . . . . . . . . . . .\
    \ . . . . . . 43\n       7.3.  Back-End Transcoding . . . . . . . . . . . . .\
    \ . . . . . 44\n       7.4.  Rare IP Address Formats  . . . . . . . . . . . .\
    \ . . . . 45\n       7.5.  Sensitive Information  . . . . . . . . . . . . . .\
    \ . . . 45\n       7.6.  Semantic Attacks . . . . . . . . . . . . . . . . . .\
    \ . . 45\n   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . .\
    \ . 46\n   9.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . .\
    \ 46\n   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n\
    \       10.1. Normative References . . . . . . . . . . . . . . . . . . 46\n  \
    \     10.2. Informative References . . . . . . . . . . . . . . . . . 47\n   A.\
    \  Collected ABNF for URI . . . . . . . . . . . . . . . . . . . . 49\n   B.  Parsing\
    \ a URI Reference with a Regular Expression  . . . . . . 50\n   C.  Delimiting\
    \ a URI in Context  . . . . . . . . . . . . . . . . . 51\n   D.  Changes from\
    \ RFC 2396  . . . . . . . . . . . . . . . . . . . . 53\n       D.1.  Additions\
    \  . . . . . . . . . . . . . . . . . . . . . . . 53\n       D.2.  Modifications\
    \  . . . . . . . . . . . . . . . . . . . . . 53\n   Index  . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . 56\n   Authors' Addresses . . . . .\
    \ . . . . . . . . . . . . . . . . . . . 60\n   Full Copyright Statement . . .\
    \ . . . . . . . . . . . . . . . . . . 61\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   A Uniform Resource Identifier (URI) provides a simple and\
    \ extensible\n   means for identifying a resource.  This specification of URI\
    \ syntax\n   and semantics is derived from concepts introduced by the World Wide\n\
    \   Web global information initiative, whose use of these identifiers\n   dates\
    \ from 1990 and is described in \"Universal Resource Identifiers\n   in WWW\"\
    \ [RFC1630].  The syntax is designed to meet the\n   recommendations laid out\
    \ in \"Functional Recommendations for Internet\n   Resource Locators\" [RFC1736]\
    \ and \"Functional Requirements for Uniform\n   Resource Names\" [RFC1737].\n\
    \   This document obsoletes [RFC2396], which merged \"Uniform Resource\n   Locators\"\
    \ [RFC1738] and \"Relative Uniform Resource Locators\"\n   [RFC1808] in order\
    \ to define a single, generic syntax for all URIs.\n   It obsoletes [RFC2732],\
    \ which introduced syntax for an IPv6 address.\n   It excludes portions of RFC\
    \ 1738 that defined the specific syntax of\n   individual URI schemes; those portions\
    \ will be updated as separate\n   documents.  The process for registration of\
    \ new URI schemes is\n   defined separately by [BCP35].  Advice for designers\
    \ of new URI\n   schemes can be found in [RFC2718].  All significant changes from\
    \ RFC\n   2396 are noted in Appendix D.\n   This specification uses the terms\
    \ \"character\" and \"coded character\n   set\" in accordance with the definitions\
    \ provided in [BCP19], and\n   \"character encoding\" in place of what [BCP19]\
    \ refers to as a\n   \"charset\".\n"
- title: 1.1.  Overview of URIs
  contents:
  - "1.1.  Overview of URIs\n   URIs are characterized as follows:\n   Uniform\n \
    \     Uniformity provides several benefits.  It allows different types\n     \
    \ of resource identifiers to be used in the same context, even when\n      the\
    \ mechanisms used to access those resources may differ.  It\n      allows uniform\
    \ semantic interpretation of common syntactic\n      conventions across different\
    \ types of resource identifiers.  It\n      allows introduction of new types of\
    \ resource identifiers without\n      interfering with the way that existing identifiers\
    \ are used.  It\n      allows the identifiers to be reused in many different contexts,\n\
    \      thus permitting new applications or protocols to leverage a pre-\n    \
    \  existing, large, and widely used set of resource identifiers.\n   Resource\n\
    \      This specification does not limit the scope of what might be a\n      resource;\
    \ rather, the term \"resource\" is used in a general sense\n      for whatever\
    \ might be identified by a URI.  Familiar examples\n      include an electronic\
    \ document, an image, a source of information\n      with a consistent purpose\
    \ (e.g., \"today's weather report for Los\n      Angeles\"), a service (e.g.,\
    \ an HTTP-to-SMS gateway), and a\n      collection of other resources.  A resource\
    \ is not necessarily\n      accessible via the Internet; e.g., human beings, corporations,\
    \ and\n      bound books in a library can also be resources.  Likewise,\n    \
    \  abstract concepts can be resources, such as the operators and\n      operands\
    \ of a mathematical equation, the types of a relationship\n      (e.g., \"parent\"\
    \ or \"employee\"), or numeric values (e.g., zero,\n      one, and infinity).\n\
    \   Identifier\n      An identifier embodies the information required to distinguish\n\
    \      what is being identified from all other things within its scope of\n  \
    \    identification.  Our use of the terms \"identify\" and \"identifying\"\n\
    \      refer to this purpose of distinguishing one resource from all\n      other\
    \ resources, regardless of how that purpose is accomplished\n      (e.g., by name,\
    \ address, or context).  These terms should not be\n      mistaken as an assumption\
    \ that an identifier defines or embodies\n      the identity of what is referenced,\
    \ though that may be the case\n      for some identifiers.  Nor should it be assumed\
    \ that a system\n      using URIs will access the resource identified: in many\
    \ cases,\n      URIs are used to denote resources without any intention that they\n\
    \      be accessed.  Likewise, the \"one\" resource identified might not be\n\
    \      singular in nature (e.g., a resource might be a named set or a\n      mapping\
    \ that varies over time).\n   A URI is an identifier consisting of a sequence\
    \ of characters\n   matching the syntax rule named <URI> in Section 3.  It enables\n\
    \   uniform identification of resources via a separately defined\n   extensible\
    \ set of naming schemes (Section 3.1).  How that\n   identification is accomplished,\
    \ assigned, or enabled is delegated to\n   each scheme specification.\n   This\
    \ specification does not place any limits on the nature of a\n   resource, the\
    \ reasons why an application might seek to refer to a\n   resource, or the kinds\
    \ of systems that might use URIs for the sake of\n   identifying resources.  This\
    \ specification does not require that a\n   URI persists in identifying the same\
    \ resource over time, though that\n   is a common goal of all URI schemes.  Nevertheless,\
    \ nothing in this\n   specification prevents an application from limiting itself\
    \ to\n   particular types of resources, or to a subset of URIs that maintains\n\
    \   characteristics desired by that application.\n   URIs have a global scope\
    \ and are interpreted consistently regardless\n   of context, though the result\
    \ of that interpretation may be in\n   relation to the end-user's context.  For\
    \ example, \"http://localhost/\"\n   has the same interpretation for every user\
    \ of that reference, even\n   though the network interface corresponding to \"\
    localhost\" may be\n   different for each end-user: interpretation is independent\
    \ of access.\n   However, an action made on the basis of that reference will take\n\
    \   place in relation to the end-user's context, which implies that an\n   action\
    \ intended to refer to a globally unique thing must use a URI\n   that distinguishes\
    \ that resource from all other things.  URIs that\n   identify in relation to\
    \ the end-user's local context should only be\n   used when the context itself\
    \ is a defining aspect of the resource,\n   such as when an on-line help manual\
    \ refers to a file on the end-\n   user's file system (e.g., \"file:///etc/hosts\"\
    ).\n"
- title: 1.1.1.  Generic Syntax
  contents:
  - "1.1.1.  Generic Syntax\n   Each URI begins with a scheme name, as defined in\
    \ Section 3.1, that\n   refers to a specification for assigning identifiers within\
    \ that\n   scheme.  As such, the URI syntax is a federated and extensible naming\n\
    \   system wherein each scheme's specification may further restrict the\n   syntax\
    \ and semantics of identifiers using that scheme.\n   This specification defines\
    \ those elements of the URI syntax that are\n   required of all URI schemes or\
    \ are common to many URI schemes.  It\n   thus defines the syntax and semantics\
    \ needed to implement a scheme-\n   independent parsing mechanism for URI references,\
    \ by which the\n   scheme-dependent handling of a URI can be postponed until the\n\
    \   scheme-dependent semantics are needed.  Likewise, protocols and data\n   formats\
    \ that make use of URI references can refer to this\n   specification as a definition\
    \ for the range of syntax allowed for all\n   URIs, including those schemes that\
    \ have yet to be defined.  This\n   decouples the evolution of identification\
    \ schemes from the evolution\n   of protocols, data formats, and implementations\
    \ that make use of\n   URIs.\n   A parser of the generic URI syntax can parse\
    \ any URI reference into\n   its major components.  Once the scheme is determined,\
    \ further\n   scheme-specific parsing can be performed on the components.  In\
    \ other\n   words, the URI generic syntax is a superset of the syntax of all URI\n\
    \   schemes.\n"
- title: 1.1.2.  Examples
  contents:
  - "1.1.2.  Examples\n   The following example URIs illustrate several URI schemes\
    \ and\n   variations in their common syntax components:\n      ftp://ftp.is.co.za/rfc/rfc1808.txt\n\
    \      http://www.ietf.org/rfc/rfc2396.txt\n      ldap://[2001:db8::7]/c=GB?objectClass?one\n\
    \      mailto:John.Doe@example.com\n      news:comp.infosystems.www.servers.unix\n\
    \      tel:+1-816-555-1212\n      telnet://192.0.2.16:80/\n      urn:oasis:names:specification:docbook:dtd:xml:4.1.2\n"
- title: 1.1.3.  URI, URL, and URN
  contents:
  - "1.1.3.  URI, URL, and URN\n   A URI can be further classified as a locator, a\
    \ name, or both.  The\n   term \"Uniform Resource Locator\" (URL) refers to the\
    \ subset of URIs\n   that, in addition to identifying a resource, provide a means\
    \ of\n   locating the resource by describing its primary access mechanism\n  \
    \ (e.g., its network \"location\").  The term \"Uniform Resource Name\"\n   (URN)\
    \ has been used historically to refer to both URIs under the\n   \"urn\" scheme\
    \ [RFC2141], which are required to remain globally unique\n   and persistent even\
    \ when the resource ceases to exist or becomes\n   unavailable, and to any other\
    \ URI with the properties of a name.\n   An individual scheme does not have to\
    \ be classified as being just one\n   of \"name\" or \"locator\".  Instances of\
    \ URIs from any given scheme may\n   have the characteristics of names or locators\
    \ or both, often\n   depending on the persistence and care in the assignment of\n\
    \   identifiers by the naming authority, rather than on any quality of\n   the\
    \ scheme.  Future specifications and related documentation should\n   use the\
    \ general term \"URI\" rather than the more restrictive terms\n   \"URL\" and\
    \ \"URN\" [RFC3305].\n"
- title: 1.2.  Design Considerations
  contents:
  - '1.2.  Design Considerations

    '
- title: 1.2.1.  Transcription
  contents:
  - "1.2.1.  Transcription\n   The URI syntax has been designed with global transcription\
    \ as one of\n   its main considerations.  A URI is a sequence of characters from\
    \ a\n   very limited set: the letters of the basic Latin alphabet, digits,\n \
    \  and a few special characters.  A URI may be represented in a variety\n   of\
    \ ways; e.g., ink on paper, pixels on a screen, or a sequence of\n   character\
    \ encoding octets.  The interpretation of a URI depends only\n   on the characters\
    \ used and not on how those characters are\n   represented in a network protocol.\n\
    \   The goal of transcription can be described by a simple scenario.\n   Imagine\
    \ two colleagues, Sam and Kim, sitting in a pub at an\n   international conference\
    \ and exchanging research ideas.  Sam asks Kim\n   for a location to get more\
    \ information, so Kim writes the URI for the\n   research site on a napkin.  Upon\
    \ returning home, Sam takes out the\n   napkin and types the URI into a computer,\
    \ which then retrieves the\n   information to which Kim referred.\n   There are\
    \ several design considerations revealed by the scenario:\n   o  A URI is a sequence\
    \ of characters that is not always represented\n      as a sequence of octets.\n\
    \   o  A URI might be transcribed from a non-network source and thus\n      should\
    \ consist of characters that are most likely able to be\n      entered into a\
    \ computer, within the constraints imposed by\n      keyboards (and related input\
    \ devices) across languages and\n      locales.\n   o  A URI often has to be remembered\
    \ by people, and it is easier for\n      people to remember a URI when it consists\
    \ of meaningful or\n      familiar components.\n   These design considerations\
    \ are not always in alignment.  For\n   example, it is often the case that the\
    \ most meaningful name for a URI\n   component would require characters that cannot\
    \ be typed into some\n   systems.  The ability to transcribe a resource identifier\
    \ from one\n   medium to another has been considered more important than having\
    \ a\n   URI consist of the most meaningful of components.\n   In local or regional\
    \ contexts and with improving technology, users\n   might benefit from being able\
    \ to use a wider range of characters;\n   such use is not defined by this specification.\
    \  Percent-encoded\n   octets (Section 2.1) may be used within a URI to represent\
    \ characters\n   outside the range of the US-ASCII coded character set if this\n\
    \   representation is allowed by the scheme or by the protocol element in\n  \
    \ which the URI is referenced.  Such a definition should specify the\n   character\
    \ encoding used to map those characters to octets prior to\n   being percent-encoded\
    \ for the URI.\n"
- title: 1.2.2.  Separating Identification from Interaction
  contents:
  - "1.2.2.  Separating Identification from Interaction\n   A common misunderstanding\
    \ of URIs is that they are only used to refer\n   to accessible resources.  The\
    \ URI itself only provides\n   identification; access to the resource is neither\
    \ guaranteed nor\n   implied by the presence of a URI.  Instead, any operation\
    \ associated\n   with a URI reference is defined by the protocol element, data\
    \ format\n   attribute, or natural language text in which it appears.\n   Given\
    \ a URI, a system may attempt to perform a variety of operations\n   on the resource,\
    \ as might be characterized by words such as \"access\",\n   \"update\", \"replace\"\
    , or \"find attributes\".  Such operations are\n   defined by the protocols that\
    \ make use of URIs, not by this\n   specification.  However, we do use a few general\
    \ terms for describing\n   common operations on URIs.  URI \"resolution\" is the\
    \ process of\n   determining an access mechanism and the appropriate parameters\n\
    \   necessary to dereference a URI; this resolution may require several\n   iterations.\
    \  To use that access mechanism to perform an action on the\n   URI's resource\
    \ is to \"dereference\" the URI.\n   When URIs are used within information retrieval\
    \ systems to identify\n   sources of information, the most common form of URI\
    \ dereference is\n   \"retrieval\": making use of a URI in order to retrieve a\n\
    \   representation of its associated resource.  A \"representation\" is a\n  \
    \ sequence of octets, along with representation metadata describing\n   those\
    \ octets, that constitutes a record of the state of the resource\n   at the time\
    \ when the representation is generated.  Retrieval is\n   achieved by a process\
    \ that might include using the URI as a cache key\n   to check for a locally cached\
    \ representation, resolution of the URI\n   to determine an appropriate access\
    \ mechanism (if any), and\n   dereference of the URI for the sake of applying\
    \ a retrieval\n   operation.  Depending on the protocols used to perform the retrieval,\n\
    \   additional information might be supplied about the resource (resource\n  \
    \ metadata) and its relation to other resources.\n   URI references in information\
    \ retrieval systems are designed to be\n   late-binding: the result of an access\
    \ is generally determined when it\n   is accessed and may vary over time or due\
    \ to other aspects of the\n   interaction.  These references are created in order\
    \ to be used in the\n   future: what is being identified is not some specific\
    \ result that was\n   obtained in the past, but rather some characteristic that\
    \ is expected\n   to be true for future results.  In such cases, the resource\
    \ referred\n   to by the URI is actually a sameness of characteristics as observed\n\
    \   over time, perhaps elucidated by additional comments or assertions\n   made\
    \ by the resource provider.\n   Although many URI schemes are named after protocols,\
    \ this does not\n   imply that use of these URIs will result in access to the\
    \ resource\n   via the named protocol.  URIs are often used simply for the sake\
    \ of\n   identification.  Even when a URI is used to retrieve a representation\n\
    \   of a resource, that access might be through gateways, proxies,\n   caches,\
    \ and name resolution services that are independent of the\n   protocol associated\
    \ with the scheme name.  The resolution of some\n   URIs may require the use of\
    \ more than one protocol (e.g., both DNS\n   and HTTP are typically used to access\
    \ an \"http\" URI's origin server\n   when a representation isn't found in a local\
    \ cache).\n"
- title: 1.2.3.  Hierarchical Identifiers
  contents:
  - "1.2.3.  Hierarchical Identifiers\n   The URI syntax is organized hierarchically,\
    \ with components listed in\n   order of decreasing significance from left to\
    \ right.  For some URI\n   schemes, the visible hierarchy is limited to the scheme\
    \ itself:\n   everything after the scheme component delimiter (\":\") is considered\n\
    \   opaque to URI processing.  Other URI schemes make the hierarchy\n   explicit\
    \ and visible to generic parsing algorithms.\n   The generic syntax uses the slash\
    \ (\"/\"), question mark (\"?\"), and\n   number sign (\"#\") characters to delimit\
    \ components that are\n   significant to the generic parser's hierarchical interpretation\
    \ of an\n   identifier.  In addition to aiding the readability of such\n   identifiers\
    \ through the consistent use of familiar syntax, this\n   uniform representation\
    \ of hierarchy across naming schemes allows\n   scheme-independent references\
    \ to be made relative to that hierarchy.\n   It is often the case that a group\
    \ or \"tree\" of documents has been\n   constructed to serve a common purpose,\
    \ wherein the vast majority of\n   URI references in these documents point to\
    \ resources within the tree\n   rather than outside it.  Similarly, documents\
    \ located at a particular\n   site are much more likely to refer to other resources\
    \ at that site\n   than to resources at remote sites.  Relative referencing of\
    \ URIs\n   allows document trees to be partially independent of their location\n\
    \   and access scheme.  For instance, it is possible for a single set of\n   hypertext\
    \ documents to be simultaneously accessible and traversable\n   via each of the\
    \ \"file\", \"http\", and \"ftp\" schemes if the documents\n   refer to each other\
    \ with relative references.  Furthermore, such\n   document trees can be moved,\
    \ as a whole, without changing any of the\n   relative references.\n   A relative\
    \ reference (Section 4.2) refers to a resource by describing\n   the difference\
    \ within a hierarchical name space between the reference\n   context and the target\
    \ URI.  The reference resolution algorithm,\n   presented in Section 5, defines\
    \ how such a reference is transformed\n   to the target URI.  As relative references\
    \ can only be used within\n   the context of a hierarchical URI, designers of\
    \ new URI schemes\n   should use a syntax consistent with the generic syntax's\
    \ hierarchical\n   components unless there are compelling reasons to forbid relative\n\
    \   referencing within that scheme.\n      NOTE: Previous specifications used\
    \ the terms \"partial URI\" and\n      \"relative URI\" to denote a relative reference\
    \ to a URI.  As some\n      readers misunderstood those terms to mean that relative\
    \ URIs are a\n      subset of URIs rather than a method of referencing URIs, this\n\
    \      specification simply refers to them as relative references.\n   All URI\
    \ references are parsed by generic syntax parsers when used.\n   However, because\
    \ hierarchical processing has no effect on an absolute\n   URI used in a reference\
    \ unless it contains one or more dot-segments\n   (complete path segments of \"\
    .\" or \"..\", as described in Section 3.3),\n   URI scheme specifications can\
    \ define opaque identifiers by\n   disallowing use of slash characters, question\
    \ mark characters, and\n   the URIs \"scheme:.\" and \"scheme:..\".\n"
- title: 1.3.  Syntax Notation
  contents:
  - "1.3.  Syntax Notation\n   This specification uses the Augmented Backus-Naur Form\
    \ (ABNF)\n   notation of [RFC2234], including the following core ABNF syntax rules\n\
    \   defined by that specification: ALPHA (letters), CR (carriage return),\n  \
    \ DIGIT (decimal digits), DQUOTE (double quote), HEXDIG (hexadecimal\n   digits),\
    \ LF (line feed), and SP (space).  The complete URI syntax is\n   collected in\
    \ Appendix A.\n"
- title: 2.  Characters
  contents:
  - "2.  Characters\n   The URI syntax provides a method of encoding data, presumably\
    \ for the\n   sake of identifying a resource, as a sequence of characters.  The\
    \ URI\n   characters are, in turn, frequently encoded as octets for transport\n\
    \   or presentation.  This specification does not mandate any particular\n   character\
    \ encoding for mapping between URI characters and the octets\n   used to store\
    \ or transmit those characters.  When a URI appears in a\n   protocol element,\
    \ the character encoding is defined by that protocol;\n   without such a definition,\
    \ a URI is assumed to be in the same\n   character encoding as the surrounding\
    \ text.\n   The ABNF notation defines its terminal values to be non-negative\n\
    \   integers (codepoints) based on the US-ASCII coded character set\n   [ASCII].\
    \  Because a URI is a sequence of characters, we must invert\n   that relation\
    \ in order to understand the URI syntax.  Therefore, the\n   integer values used\
    \ by the ABNF must be mapped back to their\n   corresponding characters via US-ASCII\
    \ in order to complete the syntax\n   rules.\n   A URI is composed from a limited\
    \ set of characters consisting of\n   digits, letters, and a few graphic symbols.\
    \  A reserved subset of\n   those characters may be used to delimit syntax components\
    \ within a\n   URI while the remaining characters, including both the unreserved\
    \ set\n   and those reserved characters not acting as delimiters, define each\n\
    \   component's identifying data.\n"
- title: 2.1.  Percent-Encoding
  contents:
  - "2.1.  Percent-Encoding\n   A percent-encoding mechanism is used to represent\
    \ a data octet in a\n   component when that octet's corresponding character is\
    \ outside the\n   allowed set or is being used as a delimiter of, or within, the\n\
    \   component.  A percent-encoded octet is encoded as a character\n   triplet,\
    \ consisting of the percent character \"%\" followed by the two\n   hexadecimal\
    \ digits representing that octet's numeric value.  For\n   example, \"%20\" is\
    \ the percent-encoding for the binary octet\n   \"00100000\" (ABNF: %x20), which\
    \ in US-ASCII corresponds to the space\n   character (SP).  Section 2.4 describes\
    \ when percent-encoding and\n   decoding is applied.\n      pct-encoded = \"%\"\
    \ HEXDIG HEXDIG\n   The uppercase hexadecimal digits 'A' through 'F' are equivalent\
    \ to\n   the lowercase digits 'a' through 'f', respectively.  If two URIs\n  \
    \ differ only in the case of hexadecimal digits used in percent-encoded\n   octets,\
    \ they are equivalent.  For consistency, URI producers and\n   normalizers should\
    \ use uppercase hexadecimal digits for all percent-\n   encodings.\n"
- title: 2.2.  Reserved Characters
  contents:
  - "2.2.  Reserved Characters\n   URIs include components and subcomponents that\
    \ are delimited by\n   characters in the \"reserved\" set.  These characters are\
    \ called\n   \"reserved\" because they may (or may not) be defined as delimiters\
    \ by\n   the generic syntax, by each scheme-specific syntax, or by the\n   implementation-specific\
    \ syntax of a URI's dereferencing algorithm.\n   If data for a URI component would\
    \ conflict with a reserved\n   character's purpose as a delimiter, then the conflicting\
    \ data must be\n   percent-encoded before the URI is formed.\n      reserved \
    \   = gen-delims / sub-delims\n      gen-delims  = \":\" / \"/\" / \"?\" / \"\
    #\" / \"[\" / \"]\" / \"@\"\n      sub-delims  = \"!\" / \"$\" / \"&\" / \"'\"\
    \ / \"(\" / \")\"\n                  / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\
    \   The purpose of reserved characters is to provide a set of delimiting\n   characters\
    \ that are distinguishable from other data within a URI.\n   URIs that differ\
    \ in the replacement of a reserved character with its\n   corresponding percent-encoded\
    \ octet are not equivalent.  Percent-\n   encoding a reserved character, or decoding\
    \ a percent-encoded octet\n   that corresponds to a reserved character, will change\
    \ how the URI is\n   interpreted by most applications.  Thus, characters in the\
    \ reserved\n   set are protected from normalization and are therefore safe to\
    \ be\n   used by scheme-specific and producer-specific algorithms for\n   delimiting\
    \ data subcomponents within a URI.\n   A subset of the reserved characters (gen-delims)\
    \ is used as\n   delimiters of the generic URI components described in Section\
    \ 3.  A\n   component's ABNF syntax rule will not use the reserved or gen-delims\n\
    \   rule names directly; instead, each syntax rule lists the characters\n   allowed\
    \ within that component (i.e., not delimiting it), and any of\n   those characters\
    \ that are also in the reserved set are \"reserved\" for\n   use as subcomponent\
    \ delimiters within the component.  Only the most\n   common subcomponents are\
    \ defined by this specification; other\n   subcomponents may be defined by a URI\
    \ scheme's specification, or by\n   the implementation-specific syntax of a URI's\
    \ dereferencing\n   algorithm, provided that such subcomponents are delimited\
    \ by\n   characters in the reserved set allowed within that component.\n   URI\
    \ producing applications should percent-encode data octets that\n   correspond\
    \ to characters in the reserved set unless these characters\n   are specifically\
    \ allowed by the URI scheme to represent data in that\n   component.  If a reserved\
    \ character is found in a URI component and\n   no delimiting role is known for\
    \ that character, then it must be\n   interpreted as representing the data octet\
    \ corresponding to that\n   character's encoding in US-ASCII.\n"
- title: 2.3.  Unreserved Characters
  contents:
  - "2.3.  Unreserved Characters\n   Characters that are allowed in a URI but do not\
    \ have a reserved\n   purpose are called unreserved.  These include uppercase\
    \ and lowercase\n   letters, decimal digits, hyphen, period, underscore, and tilde.\n\
    \      unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   URIs that\
    \ differ in the replacement of an unreserved character with\n   its corresponding\
    \ percent-encoded US-ASCII octet are equivalent: they\n   identify the same resource.\
    \  However, URI comparison implementations\n   do not always perform normalization\
    \ prior to comparison (see Section\n   6).  For consistency, percent-encoded octets\
    \ in the ranges of ALPHA\n   (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D),\
    \ period (%2E),\n   underscore (%5F), or tilde (%7E) should not be created by\
    \ URI\n   producers and, when found in a URI, should be decoded to their\n   corresponding\
    \ unreserved characters by URI normalizers.\n"
- title: 2.4.  When to Encode or Decode
  contents:
  - "2.4.  When to Encode or Decode\n   Under normal circumstances, the only time\
    \ when octets within a URI\n   are percent-encoded is during the process of producing\
    \ the URI from\n   its component parts.  This is when an implementation determines\
    \ which\n   of the reserved characters are to be used as subcomponent delimiters\n\
    \   and which can be safely used as data.  Once produced, a URI is always\n  \
    \ in its percent-encoded form.\n   When a URI is dereferenced, the components\
    \ and subcomponents\n   significant to the scheme-specific dereferencing process\
    \ (if any)\n   must be parsed and separated before the percent-encoded octets\
    \ within\n   those components can be safely decoded, as otherwise the data may\
    \ be\n   mistaken for component delimiters.  The only exception is for\n   percent-encoded\
    \ octets corresponding to characters in the unreserved\n   set, which can be decoded\
    \ at any time.  For example, the octet\n   corresponding to the tilde (\"~\")\
    \ character is often encoded as \"%7E\"\n   by older URI processing implementations;\
    \ the \"%7E\" can be replaced by\n   \"~\" without changing its interpretation.\n\
    \   Because the percent (\"%\") character serves as the indicator for\n   percent-encoded\
    \ octets, it must be percent-encoded as \"%25\" for that\n   octet to be used\
    \ as data within a URI.  Implementations must not\n   percent-encode or decode\
    \ the same string more than once, as decoding\n   an already decoded string might\
    \ lead to misinterpreting a percent\n   data octet as the beginning of a percent-encoding,\
    \ or vice versa in\n   the case of percent-encoding an already percent-encoded\
    \ string.\n"
- title: 2.5.  Identifying Data
  contents:
  - "2.5.  Identifying Data\n   URI characters provide identifying data for each of\
    \ the URI\n   components, serving as an external interface for identification\n\
    \   between systems.  Although the presence and nature of the URI\n   production\
    \ interface is hidden from clients that use its URIs (and is\n   thus beyond the\
    \ scope of the interoperability requirements defined by\n   this specification),\
    \ it is a frequent source of confusion and errors\n   in the interpretation of\
    \ URI character issues.  Implementers have to\n   be aware that there are multiple\
    \ character encodings involved in the\n   production and transmission of URIs:\
    \ local name and data encoding,\n   public interface encoding, URI character encoding,\
    \ data format\n   encoding, and protocol encoding.\n   Local names, such as file\
    \ system names, are stored with a local\n   character encoding.  URI producing\
    \ applications (e.g., origin\n   servers) will typically use the local encoding\
    \ as the basis for\n   producing meaningful names.  The URI producer will transform\
    \ the\n   local encoding to one that is suitable for a public interface and\n\
    \   then transform the public interface encoding into the restricted set\n   of\
    \ URI characters (reserved, unreserved, and percent-encodings).\n   Those characters\
    \ are, in turn, encoded as octets to be used as a\n   reference within a data\
    \ format (e.g., a document charset), and such\n   data formats are often subsequently\
    \ encoded for transmission over\n   Internet protocols.\n   For most systems,\
    \ an unreserved character appearing within a URI\n   component is interpreted\
    \ as representing the data octet corresponding\n   to that character's encoding\
    \ in US-ASCII.  Consumers of URIs assume\n   that the letter \"X\" corresponds\
    \ to the octet \"01011000\", and even\n   when that assumption is incorrect, there\
    \ is no harm in making it.  A\n   system that internally provides identifiers\
    \ in the form of a\n   different character encoding, such as EBCDIC, will generally\
    \ perform\n   character translation of textual identifiers to UTF-8 [STD63] (or\n\
    \   some other superset of the US-ASCII character encoding) at an\n   internal\
    \ interface, thereby providing more meaningful identifiers\n   than those resulting\
    \ from simply percent-encoding the original\n   octets.\n   For example, consider\
    \ an information service that provides data,\n   stored locally using an EBCDIC-based\
    \ file system, to clients on the\n   Internet through an HTTP server.  When an\
    \ author creates a file with\n   the name \"Laguna Beach\" on that file system,\
    \ the \"http\" URI\n   corresponding to that resource is expected to contain the\
    \ meaningful\n   string \"Laguna%20Beach\".  If, however, that server produces\
    \ URIs by\n   using an overly simplistic raw octet mapping, then the result would\n\
    \   be a URI containing \"%D3%81%87%A4%95%81@%C2%85%81%83%88\".  An\n   internal\
    \ transcoding interface fixes this problem by transcoding the\n   local name to\
    \ a superset of US-ASCII prior to producing the URI.\n   Naturally, proper interpretation\
    \ of an incoming URI on such an\n   interface requires that percent-encoded octets\
    \ be decoded (e.g.,\n   \"%20\" to SP) before the reverse transcoding is applied\
    \ to obtain the\n   local name.\n   In some cases, the internal interface between\
    \ a URI component and the\n   identifying data that it has been crafted to represent\
    \ is much less\n   direct than a character encoding translation.  For example,\
    \ portions\n   of a URI might reflect a query on non-ASCII data, or numeric\n\
    \   coordinates on a map.  Likewise, a URI scheme may define components\n   with\
    \ additional encoding requirements that are applied prior to\n   forming the component\
    \ and producing the URI.\n   When a new URI scheme defines a component that represents\
    \ textual\n   data consisting of characters from the Universal Character Set [UCS],\n\
    \   the data should first be encoded as octets according to the UTF-8\n   character\
    \ encoding [STD63]; then only those octets that do not\n   correspond to characters\
    \ in the unreserved set should be percent-\n   encoded.  For example, the character\
    \ A would be represented as \"A\",\n   the character LATIN CAPITAL LETTER A WITH\
    \ GRAVE would be represented\n   as \"%C3%80\", and the character KATAKANA LETTER\
    \ A would be represented\n   as \"%E3%82%A2\".\n"
- title: 3.  Syntax Components
  contents:
  - "3.  Syntax Components\n   The generic URI syntax consists of a hierarchical sequence\
    \ of\n   components referred to as the scheme, authority, path, query, and\n \
    \  fragment.\n      URI         = scheme \":\" hier-part [ \"?\" query ] [ \"\
    #\" fragment ]\n      hier-part   = \"//\" authority path-abempty\n          \
    \        / path-absolute\n                  / path-rootless\n                \
    \  / path-empty\n   The scheme and path components are required, though the path\
    \ may be\n   empty (no characters).  When authority is present, the path must\n\
    \   either be empty or begin with a slash (\"/\") character.  When\n   authority\
    \ is not present, the path cannot begin with two slash\n   characters (\"//\"\
    ).  These restrictions result in five different ABNF\n   rules for a path (Section\
    \ 3.3), only one of which will match any\n   given URI reference.\n   The following\
    \ are two example URIs and their component parts:\n         foo://example.com:8042/over/there?name=ferret#nose\n\
    \         \\_/   \\______________/\\_________/ \\_________/ \\__/\n          |\
    \           |            |            |        |\n       scheme     authority\
    \       path        query   fragment\n          |   _____________________|__\n\
    \         / \\ /                        \\\n         urn:example:animal:ferret:nose\n"
- title: 3.1.  Scheme
  contents:
  - "3.1.  Scheme\n   Each URI begins with a scheme name that refers to a specification\
    \ for\n   assigning identifiers within that scheme.  As such, the URI syntax is\n\
    \   a federated and extensible naming system wherein each scheme's\n   specification\
    \ may further restrict the syntax and semantics of\n   identifiers using that\
    \ scheme.\n   Scheme names consist of a sequence of characters beginning with\
    \ a\n   letter and followed by any combination of letters, digits, plus\n   (\"\
    +\"), period (\".\"), or hyphen (\"-\").  Although schemes are case-\n   insensitive,\
    \ the canonical form is lowercase and documents that\n   specify schemes must\
    \ do so with lowercase letters.  An implementation\n   should accept uppercase\
    \ letters as equivalent to lowercase in scheme\n   names (e.g., allow \"HTTP\"\
    \ as well as \"http\") for the sake of\n   robustness but should only produce\
    \ lowercase scheme names for\n   consistency.\n      scheme      = ALPHA *( ALPHA\
    \ / DIGIT / \"+\" / \"-\" / \".\" )\n   Individual schemes are not specified by\
    \ this document.  The process\n   for registration of new URI schemes is defined\
    \ separately by [BCP35].\n   The scheme registry maintains the mapping between\
    \ scheme names and\n   their specifications.  Advice for designers of new URI\
    \ schemes can be\n   found in [RFC2718].  URI scheme specifications must define\
    \ their own\n   syntax so that all strings matching their scheme-specific syntax\
    \ will\n   also match the <absolute-URI> grammar, as described in Section 4.3.\n\
    \   When presented with a URI that violates one or more scheme-specific\n   restrictions,\
    \ the scheme-specific resolution process should flag the\n   reference as an error\
    \ rather than ignore the unused parts; doing so\n   reduces the number of equivalent\
    \ URIs and helps detect abuses of the\n   generic syntax, which might indicate\
    \ that the URI has been\n   constructed to mislead the user (Section 7.6).\n"
- title: 3.2.  Authority
  contents:
  - "3.2.  Authority\n   Many URI schemes include a hierarchical element for a naming\n\
    \   authority so that governance of the name space defined by the\n   remainder\
    \ of the URI is delegated to that authority (which may, in\n   turn, delegate\
    \ it further).  The generic syntax provides a common\n   means for distinguishing\
    \ an authority based on a registered name or\n   server address, along with optional\
    \ port and user information.\n   The authority component is preceded by a double\
    \ slash (\"//\") and is\n   terminated by the next slash (\"/\"), question mark\
    \ (\"?\"), or number\n   sign (\"#\") character, or by the end of the URI.\n \
    \     authority   = [ userinfo \"@\" ] host [ \":\" port ]\n   URI producers and\
    \ normalizers should omit the \":\" delimiter that\n   separates host from port\
    \ if the port component is empty.  Some\n   schemes do not allow the userinfo\
    \ and/or port subcomponents.\n   If a URI contains an authority component, then\
    \ the path component\n   must either be empty or begin with a slash (\"/\") character.\
    \  Non-\n   validating parsers (those that merely separate a URI reference into\n\
    \   its major components) will often ignore the subcomponent structure of\n  \
    \ authority, treating it as an opaque string from the double-slash to\n   the\
    \ first terminating delimiter, until such time as the URI is\n   dereferenced.\n"
- title: 3.2.1.  User Information
  contents:
  - "3.2.1.  User Information\n   The userinfo subcomponent may consist of a user\
    \ name and, optionally,\n   scheme-specific information about how to gain authorization\
    \ to access\n   the resource.  The user information, if present, is followed by\
    \ a\n   commercial at-sign (\"@\") that delimits it from the host.\n      userinfo\
    \    = *( unreserved / pct-encoded / sub-delims / \":\" )\n   Use of the format\
    \ \"user:password\" in the userinfo field is\n   deprecated.  Applications should\
    \ not render as clear text any data\n   after the first colon (\":\") character\
    \ found within a userinfo\n   subcomponent unless the data after the colon is\
    \ the empty string\n   (indicating no password).  Applications may choose to ignore\
    \ or\n   reject such data when it is received as part of a reference and\n   should\
    \ reject the storage of such data in unencrypted form.  The\n   passing of authentication\
    \ information in clear text has proven to be\n   a security risk in almost every\
    \ case where it has been used.\n   Applications that render a URI for the sake\
    \ of user feedback, such as\n   in graphical hypertext browsing, should render\
    \ userinfo in a way that\n   is distinguished from the rest of a URI, when feasible.\
    \  Such\n   rendering will assist the user in cases where the userinfo has been\n\
    \   misleadingly crafted to look like a trusted domain name\n   (Section 7.6).\n"
- title: 3.2.2.  Host
  contents:
  - "3.2.2.  Host\n   The host subcomponent of authority is identified by an IP literal\n\
    \   encapsulated within square brackets, an IPv4 address in dotted-\n   decimal\
    \ form, or a registered name.  The host subcomponent is case-\n   insensitive.\
    \  The presence of a host subcomponent within a URI does\n   not imply that the\
    \ scheme requires access to the given host on the\n   Internet.  In many cases,\
    \ the host syntax is used only for the sake\n   of reusing the existing registration\
    \ process created and deployed for\n   DNS, thus obtaining a globally unique name\
    \ without the cost of\n   deploying another registry.  However, such use comes\
    \ with its own\n   costs: domain name ownership may change over time for reasons\
    \ not\n   anticipated by the URI producer.  In other cases, the data within the\n\
    \   host component identifies a registered name that has nothing to do\n   with\
    \ an Internet host.  We use the name \"host\" for the ABNF rule\n   because that\
    \ is its most common purpose, not its only purpose.\n      host        = IP-literal\
    \ / IPv4address / reg-name\n   The syntax rule for host is ambiguous because it\
    \ does not completely\n   distinguish between an IPv4address and a reg-name. \
    \ In order to\n   disambiguate the syntax, we apply the \"first-match-wins\" algorithm:\n\
    \   If host matches the rule for IPv4address, then it should be\n   considered\
    \ an IPv4 address literal and not a reg-name.  Although host\n   is case-insensitive,\
    \ producers and normalizers should use lowercase\n   for registered names and\
    \ hexadecimal addresses for the sake of\n   uniformity, while only using uppercase\
    \ letters for percent-encodings.\n   A host identified by an Internet Protocol\
    \ literal address, version 6\n   [RFC3513] or later, is distinguished by enclosing\
    \ the IP literal\n   within square brackets (\"[\" and \"]\").  This is the only\
    \ place where\n   square bracket characters are allowed in the URI syntax.  In\n\
    \   anticipation of future, as-yet-undefined IP literal address formats,\n   an\
    \ implementation may use an optional version flag to indicate such a\n   format\
    \ explicitly rather than rely on heuristic determination.\n      IP-literal =\
    \ \"[\" ( IPv6address / IPvFuture  ) \"]\"\n      IPvFuture  = \"v\" 1*HEXDIG\
    \ \".\" 1*( unreserved / sub-delims / \":\" )\n   The version flag does not indicate\
    \ the IP version; rather, it\n   indicates future versions of the literal format.\
    \  As such,\n   implementations must not provide the version flag for the existing\n\
    \   IPv4 and IPv6 literal address forms described below.  If a URI\n   containing\
    \ an IP-literal that starts with \"v\" (case-insensitive),\n   indicating that\
    \ the version flag is present, is dereferenced by an\n   application that does\
    \ not know the meaning of that version flag, then\n   the application should return\
    \ an appropriate error for \"address\n   mechanism not supported\".\n   A host\
    \ identified by an IPv6 literal address is represented inside\n   the square brackets\
    \ without a preceding version flag.  The ABNF\n   provided here is a translation\
    \ of the text definition of an IPv6\n   literal address provided in [RFC3513].\
    \  This syntax does not support\n   IPv6 scoped addressing zone identifiers.\n\
    \   A 128-bit IPv6 address is divided into eight 16-bit pieces.  Each\n   piece\
    \ is represented numerically in case-insensitive hexadecimal,\n   using one to\
    \ four hexadecimal digits (leading zeroes are permitted).\n   The eight encoded\
    \ pieces are given most-significant first, separated\n   by colon characters.\
    \  Optionally, the least-significant two pieces\n   may instead be represented\
    \ in IPv4 address textual format.  A\n   sequence of one or more consecutive zero-valued\
    \ 16-bit pieces within\n   the address may be elided, omitting all their digits\
    \ and leaving\n   exactly two consecutive colons in their place to mark the elision.\n\
    \      IPv6address =                            6( h16 \":\" ) ls32\n        \
    \          /                       \"::\" 5( h16 \":\" ) ls32\n              \
    \    / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n                  / [\
    \ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n                  / [ *2(\
    \ h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n                  / [ *3( h16\
    \ \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n                  / [ *4( h16 \":\"\
    \ ) h16 ] \"::\"              ls32\n                  / [ *5( h16 \":\" ) h16\
    \ ] \"::\"              h16\n                  / [ *6( h16 \":\" ) h16 ] \"::\"\
    \n      ls32        = ( h16 \":\" h16 ) / IPv4address\n                  ; least-significant\
    \ 32 bits of address\n      h16         = 1*4HEXDIG\n                  ; 16 bits\
    \ of address represented in hexadecimal\n   A host identified by an IPv4 literal\
    \ address is represented in\n   dotted-decimal notation (a sequence of four decimal\
    \ numbers in the\n   range 0 to 255, separated by \".\"), as described in [RFC1123]\
    \ by\n   reference to [RFC0952].  Note that other forms of dotted notation may\n\
    \   be interpreted on some platforms, as described in Section 7.4, but\n   only\
    \ the dotted-decimal form of four octets is allowed by this\n   grammar.\n   \
    \   IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\n\
    \      dec-octet   = DIGIT                 ; 0-9\n                  / %x31-39\
    \ DIGIT         ; 10-99\n                  / \"1\" 2DIGIT            ; 100-199\n\
    \                  / \"2\" %x30-34 DIGIT     ; 200-249\n                  / \"\
    25\" %x30-35          ; 250-255\n   A host identified by a registered name is\
    \ a sequence of characters\n   usually intended for lookup within a locally defined\
    \ host or service\n   name registry, though the URI's scheme-specific semantics\
    \ may require\n   that a specific registry (or fixed name table) be used instead.\
    \  The\n   most common name registry mechanism is the Domain Name System (DNS).\n\
    \   A registered name intended for lookup in the DNS uses the syntax\n   defined\
    \ in Section 3.5 of [RFC1034] and Section 2.1 of [RFC1123].\n   Such a name consists\
    \ of a sequence of domain labels separated by \".\",\n   each domain label starting\
    \ and ending with an alphanumeric character\n   and possibly also containing \"\
    -\" characters.  The rightmost domain\n   label of a fully qualified domain name\
    \ in DNS may be followed by a\n   single \".\" and should be if it is necessary\
    \ to distinguish between\n   the complete domain name and some local domain.\n\
    \      reg-name    = *( unreserved / pct-encoded / sub-delims )\n   If the URI\
    \ scheme defines a default for host, then that default\n   applies when the host\
    \ subcomponent is undefined or when the\n   registered name is empty (zero length).\
    \  For example, the \"file\" URI\n   scheme is defined so that no authority, an\
    \ empty host, and\n   \"localhost\" all mean the end-user's machine, whereas the\
    \ \"http\"\n   scheme considers a missing authority or empty host invalid.\n \
    \  This specification does not mandate a particular registered name\n   lookup\
    \ technology and therefore does not restrict the syntax of reg-\n   name beyond\
    \ what is necessary for interoperability.  Instead, it\n   delegates the issue\
    \ of registered name syntax conformance to the\n   operating system of each application\
    \ performing URI resolution, and\n   that operating system decides what it will\
    \ allow for the purpose of\n   host identification.  A URI resolution implementation\
    \ might use DNS,\n   host tables, yellow pages, NetInfo, WINS, or any other system\
    \ for\n   lookup of registered names.  However, a globally scoped naming\n   system,\
    \ such as DNS fully qualified domain names, is necessary for\n   URIs intended\
    \ to have global scope.  URI producers should use names\n   that conform to the\
    \ DNS syntax, even when use of DNS is not\n   immediately apparent, and should\
    \ limit these names to no more than\n   255 characters in length.\n   The reg-name\
    \ syntax allows percent-encoded octets in order to\n   represent non-ASCII registered\
    \ names in a uniform way that is\n   independent of the underlying name resolution\
    \ technology.  Non-ASCII\n   characters must first be encoded according to UTF-8\
    \ [STD63], and then\n   each octet of the corresponding UTF-8 sequence must be\
    \ percent-\n   encoded to be represented as URI characters.  URI producing\n \
    \  applications must not use percent-encoding in host unless it is used\n   to\
    \ represent a UTF-8 character sequence.  When a non-ASCII registered\n   name\
    \ represents an internationalized domain name intended for\n   resolution via\
    \ the DNS, the name must be transformed to the IDNA\n   encoding [RFC3490] prior\
    \ to name lookup.  URI producers should\n   provide these registered names in\
    \ the IDNA encoding, rather than a\n   percent-encoding, if they wish to maximize\
    \ interoperability with\n   legacy URI resolvers.\n"
- title: 3.2.3.  Port
  contents:
  - "3.2.3.  Port\n   The port subcomponent of authority is designated by an optional\
    \ port\n   number in decimal following the host and delimited from it by a\n \
    \  single colon (\":\") character.\n      port        = *DIGIT\n   A scheme may\
    \ define a default port.  For example, the \"http\" scheme\n   defines a default\
    \ port of \"80\", corresponding to its reserved TCP\n   port number.  The type\
    \ of port designated by the port number (e.g.,\n   TCP, UDP, SCTP) is defined\
    \ by the URI scheme.  URI producers and\n   normalizers should omit the port component\
    \ and its \":\" delimiter if\n   port is empty or if its value would be the same\
    \ as that of the\n   scheme's default.\n"
- title: 3.3.  Path
  contents:
  - "3.3.  Path\n   The path component contains data, usually organized in hierarchical\n\
    \   form, that, along with data in the non-hierarchical query component\n   (Section\
    \ 3.4), serves to identify a resource within the scope of the\n   URI's scheme\
    \ and naming authority (if any).  The path is terminated\n   by the first question\
    \ mark (\"?\") or number sign (\"#\") character, or\n   by the end of the URI.\n\
    \   If a URI contains an authority component, then the path component\n   must\
    \ either be empty or begin with a slash (\"/\") character.  If a URI\n   does\
    \ not contain an authority component, then the path cannot begin\n   with two\
    \ slash characters (\"//\").  In addition, a URI reference\n   (Section 4.1) may\
    \ be a relative-path reference, in which case the\n   first path segment cannot\
    \ contain a colon (\":\") character.  The ABNF\n   requires five separate rules\
    \ to disambiguate these cases, only one of\n   which will match the path substring\
    \ within a given URI reference.  We\n   use the generic term \"path component\"\
    \ to describe the URI substring\n   matched by the parser to one of these rules.\n\
    \      path          = path-abempty    ; begins with \"/\" or is empty\n     \
    \               / path-absolute   ; begins with \"/\" but not \"//\"\n       \
    \             / path-noscheme   ; begins with a non-colon segment\n          \
    \          / path-rootless   ; begins with a segment\n                    / path-empty\
    \      ; zero characters\n      path-abempty  = *( \"/\" segment )\n      path-absolute\
    \ = \"/\" [ segment-nz *( \"/\" segment ) ]\n      path-noscheme = segment-nz-nc\
    \ *( \"/\" segment )\n      path-rootless = segment-nz *( \"/\" segment )\n  \
    \    path-empty    = 0<pchar>\n      segment       = *pchar\n      segment-nz\
    \    = 1*pchar\n      segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims\
    \ / \"@\" )\n                    ; non-zero-length segment without any colon \"\
    :\"\n      pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"\
    @\"\n   A path consists of a sequence of path segments separated by a slash\n\
    \   (\"/\") character.  A path is always defined for a URI, though the\n   defined\
    \ path may be empty (zero length).  Use of the slash character\n   to indicate\
    \ hierarchy is only required when a URI will be used as the\n   context for relative\
    \ references.  For example, the URI\n   <mailto:fred@example.com> has a path of\
    \ \"fred@example.com\", whereas\n   the URI <foo://info.example.com?fred> has\
    \ an empty path.\n   The path segments \".\" and \"..\", also known as dot-segments,\
    \ are\n   defined for relative reference within the path name hierarchy.  They\n\
    \   are intended for use at the beginning of a relative-path reference\n   (Section\
    \ 4.2) to indicate relative position within the hierarchical\n   tree of names.\
    \  This is similar to their role within some operating\n   systems' file directory\
    \ structures to indicate the current directory\n   and parent directory, respectively.\
    \  However, unlike in a file\n   system, these dot-segments are only interpreted\
    \ within the URI path\n   hierarchy and are removed as part of the resolution\
    \ process (Section\n   5.2).\n   Aside from dot-segments in hierarchical paths,\
    \ a path segment is\n   considered opaque by the generic syntax.  URI producing\
    \ applications\n   often use the reserved characters allowed in a segment to delimit\n\
    \   scheme-specific or dereference-handler-specific subcomponents.  For\n   example,\
    \ the semicolon (\";\") and equals (\"=\") reserved characters are\n   often used\
    \ to delimit parameters and parameter values applicable to\n   that segment. \
    \ The comma (\",\") reserved character is often used for\n   similar purposes.\
    \  For example, one URI producer might use a segment\n   such as \"name;v=1.1\"\
    \ to indicate a reference to version 1.1 of\n   \"name\", whereas another might\
    \ use a segment such as \"name,1.1\" to\n   indicate the same.  Parameter types\
    \ may be defined by scheme-specific\n   semantics, but in most cases the syntax\
    \ of a parameter is specific to\n   the implementation of the URI's dereferencing\
    \ algorithm.\n"
- title: 3.4.  Query
  contents:
  - "3.4.  Query\n   The query component contains non-hierarchical data that, along\
    \ with\n   data in the path component (Section 3.3), serves to identify a\n  \
    \ resource within the scope of the URI's scheme and naming authority\n   (if any).\
    \  The query component is indicated by the first question\n   mark (\"?\") character\
    \ and terminated by a number sign (\"#\") character\n   or by the end of the URI.\n\
    \      query       = *( pchar / \"/\" / \"?\" )\n   The characters slash (\"/\"\
    ) and question mark (\"?\") may represent data\n   within the query component.\
    \  Beware that some older, erroneous\n   implementations may not handle such data\
    \ correctly when it is used as\n   the base URI for relative references (Section\
    \ 5.1), apparently\n   because they fail to distinguish query data from path data\
    \ when\n   looking for hierarchical separators.  However, as query components\n\
    \   are often used to carry identifying information in the form of\n   \"key=value\"\
    \ pairs and one frequently used value is a reference to\n   another URI, it is\
    \ sometimes better for usability to avoid percent-\n   encoding those characters.\n"
- title: 3.5.  Fragment
  contents:
  - "3.5.  Fragment\n   The fragment identifier component of a URI allows indirect\n\
    \   identification of a secondary resource by reference to a primary\n   resource\
    \ and additional identifying information.  The identified\n   secondary resource\
    \ may be some portion or subset of the primary\n   resource, some view on representations\
    \ of the primary resource, or\n   some other resource defined or described by\
    \ those representations.  A\n   fragment identifier component is indicated by\
    \ the presence of a\n   number sign (\"#\") character and terminated by the end\
    \ of the URI.\n      fragment    = *( pchar / \"/\" / \"?\" )\n   The semantics\
    \ of a fragment identifier are defined by the set of\n   representations that\
    \ might result from a retrieval action on the\n   primary resource.  The fragment's\
    \ format and resolution is therefore\n   dependent on the media type [RFC2046]\
    \ of a potentially retrieved\n   representation, even though such a retrieval\
    \ is only performed if the\n   URI is dereferenced.  If no such representation\
    \ exists, then the\n   semantics of the fragment are considered unknown and are\
    \ effectively\n   unconstrained.  Fragment identifier semantics are independent\
    \ of the\n   URI scheme and thus cannot be redefined by scheme specifications.\n\
    \   Individual media types may define their own restrictions on or\n   structures\
    \ within the fragment identifier syntax for specifying\n   different types of\
    \ subsets, views, or external references that are\n   identifiable as secondary\
    \ resources by that media type.  If the\n   primary resource has multiple representations,\
    \ as is often the case\n   for resources whose representation is selected based\
    \ on attributes of\n   the retrieval request (a.k.a., content negotiation), then\
    \ whatever is\n   identified by the fragment should be consistent across all of\
    \ those\n   representations.  Each representation should either define the\n \
    \  fragment so that it corresponds to the same secondary resource,\n   regardless\
    \ of how it is represented, or should leave the fragment\n   undefined (i.e.,\
    \ not found).\n   As with any URI, use of a fragment identifier component does\
    \ not\n   imply that a retrieval action will take place.  A URI with a fragment\n\
    \   identifier may be used to refer to the secondary resource without any\n  \
    \ implication that the primary resource is accessible or will ever be\n   accessed.\n\
    \   Fragment identifiers have a special role in information retrieval\n   systems\
    \ as the primary form of client-side indirect referencing,\n   allowing an author\
    \ to specifically identify aspects of an existing\n   resource that are only indirectly\
    \ provided by the resource owner.  As\n   such, the fragment identifier is not\
    \ used in the scheme-specific\n   processing of a URI; instead, the fragment identifier\
    \ is separated\n   from the rest of the URI prior to a dereference, and thus the\n\
    \   identifying information within the fragment itself is dereferenced\n   solely\
    \ by the user agent, regardless of the URI scheme.  Although\n   this separate\
    \ handling is often perceived to be a loss of\n   information, particularly for\
    \ accurate redirection of references as\n   resources move over time, it also\
    \ serves to prevent information\n   providers from denying reference authors the\
    \ right to refer to\n   information within a resource selectively.  Indirect referencing\
    \ also\n   provides additional flexibility and extensibility to systems that use\n\
    \   URIs, as new media types are easier to define and deploy than new\n   schemes\
    \ of identification.\n   The characters slash (\"/\") and question mark (\"?\"\
    ) are allowed to\n   represent data within the fragment identifier.  Beware that\
    \ some\n   older, erroneous implementations may not handle this data correctly\n\
    \   when it is used as the base URI for relative references (Section\n   5.1).\n"
- title: 4.  Usage
  contents:
  - "4.  Usage\n   When applications make reference to a URI, they do not always use\
    \ the\n   full form of reference defined by the \"URI\" syntax rule.  To save\n\
    \   space and take advantage of hierarchical locality, many Internet\n   protocol\
    \ elements and media type formats allow an abbreviation of a\n   URI, whereas\
    \ others restrict the syntax to a particular form of URI.\n   We define the most\
    \ common forms of reference syntax in this\n   specification because they impact\
    \ and depend upon the design of the\n   generic syntax, requiring a uniform parsing\
    \ algorithm in order to be\n   interpreted consistently.\n"
- title: 4.1.  URI Reference
  contents:
  - "4.1.  URI Reference\n   URI-reference is used to denote the most common usage\
    \ of a resource\n   identifier.\n      URI-reference = URI / relative-ref\n  \
    \ A URI-reference is either a URI or a relative reference.  If the\n   URI-reference's\
    \ prefix does not match the syntax of a scheme followed\n   by its colon separator,\
    \ then the URI-reference is a relative\n   reference.\n   A URI-reference is typically\
    \ parsed first into the five URI\n   components, in order to determine what components\
    \ are present and\n   whether the reference is relative.  Then, each component\
    \ is parsed\n   for its subparts and their validation.  The ABNF of URI-reference,\n\
    \   along with the \"first-match-wins\" disambiguation rule, is sufficient\n \
    \  to define a validating parser for the generic syntax.  Readers\n   familiar\
    \ with regular expressions should see Appendix B for an\n   example of a non-validating\
    \ URI-reference parser that will take any\n   given string and extract the URI\
    \ components.\n"
- title: 4.2.  Relative Reference
  contents:
  - "4.2.  Relative Reference\n   A relative reference takes advantage of the hierarchical\
    \ syntax\n   (Section 1.2.3) to express a URI reference relative to the name space\n\
    \   of another hierarchical URI.\n      relative-ref  = relative-part [ \"?\"\
    \ query ] [ \"#\" fragment ]\n      relative-part = \"//\" authority path-abempty\n\
    \                    / path-absolute\n                    / path-noscheme\n  \
    \                  / path-empty\n   The URI referred to by a relative reference,\
    \ also known as the target\n   URI, is obtained by applying the reference resolution\
    \ algorithm of\n   Section 5.\n   A relative reference that begins with two slash\
    \ characters is termed\n   a network-path reference; such references are rarely\
    \ used.  A\n   relative reference that begins with a single slash character is\n\
    \   termed an absolute-path reference.  A relative reference that does\n   not\
    \ begin with a slash character is termed a relative-path reference.\n   A path\
    \ segment that contains a colon character (e.g., \"this:that\")\n   cannot be\
    \ used as the first segment of a relative-path reference, as\n   it would be mistaken\
    \ for a scheme name.  Such a segment must be\n   preceded by a dot-segment (e.g.,\
    \ \"./this:that\") to make a relative-\n   path reference.\n"
- title: 4.3.  Absolute URI
  contents:
  - "4.3.  Absolute URI\n   Some protocol elements allow only the absolute form of\
    \ a URI without\n   a fragment identifier.  For example, defining a base URI for\
    \ later\n   use by relative references calls for an absolute-URI syntax rule that\n\
    \   does not allow a fragment.\n      absolute-URI  = scheme \":\" hier-part [\
    \ \"?\" query ]\n   URI scheme specifications must define their own syntax so\
    \ that all\n   strings matching their scheme-specific syntax will also match the\n\
    \   <absolute-URI> grammar.  Scheme specifications will not define\n   fragment\
    \ identifier syntax or usage, regardless of its applicability\n   to resources\
    \ identifiable via that scheme, as fragment identification\n   is orthogonal to\
    \ scheme definition.  However, scheme specifications\n   are encouraged to include\
    \ a wide range of examples, including\n   examples that show use of the scheme's\
    \ URIs with fragment identifiers\n   when such usage is appropriate.\n"
- title: 4.4.  Same-Document Reference
  contents:
  - "4.4.  Same-Document Reference\n   When a URI reference refers to a URI that is,\
    \ aside from its fragment\n   component (if any), identical to the base URI (Section\
    \ 5.1), that\n   reference is called a \"same-document\" reference.  The most\
    \ frequent\n   examples of same-document references are relative references that\
    \ are\n   empty or include only the number sign (\"#\") separator followed by\
    \ a\n   fragment identifier.\n   When a same-document reference is dereferenced\
    \ for a retrieval\n   action, the target of that reference is defined to be within\
    \ the same\n   entity (representation, document, or message) as the reference;\n\
    \   therefore, a dereference should not result in a new retrieval action.\n  \
    \ Normalization of the base and target URIs prior to their comparison,\n   as\
    \ described in Sections 6.2.2 and 6.2.3, is allowed but rarely\n   performed in\
    \ practice.  Normalization may increase the set of same-\n   document references,\
    \ which may be of benefit to some caching\n   applications.  As such, reference\
    \ authors should not assume that a\n   slightly different, though equivalent,\
    \ reference URI will (or will\n   not) be interpreted as a same-document reference\
    \ by any given\n   application.\n"
- title: 4.5.  Suffix Reference
  contents:
  - "4.5.  Suffix Reference\n   The URI syntax is designed for unambiguous reference\
    \ to resources and\n   extensibility via the URI scheme.  However, as URI identification\
    \ and\n   usage have become commonplace, traditional media (television, radio,\n\
    \   newspapers, billboards, etc.) have increasingly used a suffix of the\n   URI\
    \ as a reference, consisting of only the authority and path\n   portions of the\
    \ URI, such as\n      www.w3.org/Addressing/\n   or simply a DNS registered name\
    \ on its own.  Such references are\n   primarily intended for human interpretation\
    \ rather than for machines,\n   with the assumption that context-based heuristics\
    \ are sufficient to\n   complete the URI (e.g., most registered names beginning\
    \ with \"www\"\n   are likely to have a URI prefix of \"http://\").  Although\
    \ there is no\n   standard set of heuristics for disambiguating a URI suffix,\
    \ many\n   client implementations allow them to be entered by the user and\n \
    \  heuristically resolved.\n   Although this practice of using suffix references\
    \ is common, it\n   should be avoided whenever possible and should never be used\
    \ in\n   situations where long-term references are expected.  The heuristics\n\
    \   noted above will change over time, particularly when a new URI scheme\n  \
    \ becomes popular, and are often incorrect when used out of context.\n   Furthermore,\
    \ they can lead to security issues along the lines of\n   those described in [RFC1535].\n\
    \   As a URI suffix has the same syntax as a relative-path reference, a\n   suffix\
    \ reference cannot be used in contexts where a relative\n   reference is expected.\
    \  As a result, suffix references are limited to\n   places where there is no\
    \ defined base URI, such as dialog boxes and\n   off-line advertisements.\n"
- title: 5.  Reference Resolution
  contents:
  - "5.  Reference Resolution\n   This section defines the process of resolving a\
    \ URI reference within\n   a context that allows relative references so that the\
    \ result is a\n   string matching the <URI> syntax rule of Section 3.\n"
- title: 5.1.  Establishing a Base URI
  contents:
  - "5.1.  Establishing a Base URI\n   The term \"relative\" implies that a \"base\
    \ URI\" exists against which\n   the relative reference is applied.  Aside from\
    \ fragment-only\n   references (Section 4.4), relative references are only usable\
    \ when a\n   base URI is known.  A base URI must be established by the parser\n\
    \   prior to parsing URI references that might be relative.  A base URI\n   must\
    \ conform to the <absolute-URI> syntax rule (Section 4.3).  If the\n   base URI\
    \ is obtained from a URI reference, then that reference must\n   be converted\
    \ to absolute form and stripped of any fragment component\n   prior to its use\
    \ as a base URI.\n   The base URI of a reference can be established in one of\
    \ four ways,\n   discussed below in order of precedence.  The order of precedence\
    \ can\n   be thought of in terms of layers, where the innermost defined base\n\
    \   URI has the highest precedence.  This can be visualized graphically\n   as\
    \ follows:\n         .----------------------------------------------------------.\n\
    \         |  .----------------------------------------------------.  |\n     \
    \    |  |  .----------------------------------------------.  |  |\n         |\
    \  |  |  .----------------------------------------.  |  |  |\n         |  |  |\
    \  |  .----------------------------------.  |  |  |  |\n         |  |  |  |  |\
    \       <relative-reference>       |  |  |  |  |\n         |  |  |  |  `----------------------------------'\
    \  |  |  |  |\n         |  |  |  | (5.1.1) Base URI embedded in content   |  |\
    \  |  |\n         |  |  |  `----------------------------------------'  |  |  |\n\
    \         |  |  | (5.1.2) Base URI of the encapsulating entity |  |  |\n     \
    \    |  |  |         (message, representation, or none)   |  |  |\n         |\
    \  |  `----------------------------------------------'  |  |\n         |  | (5.1.3)\
    \ URI used to retrieve the entity            |  |\n         |  `----------------------------------------------------'\
    \  |\n         | (5.1.4) Default Base URI (application-dependent)         |\n\
    \         `----------------------------------------------------------'\n"
- title: 5.1.1.  Base URI Embedded in Content
  contents:
  - "5.1.1.  Base URI Embedded in Content\n   Within certain media types, a base URI\
    \ for relative references can be\n   embedded within the content itself so that\
    \ it can be readily obtained\n   by a parser.  This can be useful for descriptive\
    \ documents, such as\n   tables of contents, which may be transmitted to others\
    \ through\n   protocols other than their usual retrieval context (e.g., email\
    \ or\n   USENET news).\n   It is beyond the scope of this specification to specify\
    \ how, for each\n   media type, a base URI can be embedded.  The appropriate syntax,\
    \ when\n   available, is described by the data format specification associated\n\
    \   with each media type.\n"
- title: 5.1.2.  Base URI from the Encapsulating Entity
  contents:
  - "5.1.2.  Base URI from the Encapsulating Entity\n   If no base URI is embedded,\
    \ the base URI is defined by the\n   representation's retrieval context.  For\
    \ a document that is enclosed\n   within another entity, such as a message or\
    \ archive, the retrieval\n   context is that entity.  Thus, the default base URI\
    \ of a\n   representation is the base URI of the entity in which the\n   representation\
    \ is encapsulated.\n   A mechanism for embedding a base URI within MIME container\
    \ types\n   (e.g., the message and multipart types) is defined by MHTML\n   [RFC2557].\
    \  Protocols that do not use the MIME message header syntax,\n   but that do allow\
    \ some form of tagged metadata to be included within\n   messages, may define\
    \ their own syntax for defining a base URI as part\n   of a message.\n"
- title: 5.1.3.  Base URI from the Retrieval URI
  contents:
  - "5.1.3.  Base URI from the Retrieval URI\n   If no base URI is embedded and the\
    \ representation is not encapsulated\n   within some other entity, then, if a\
    \ URI was used to retrieve the\n   representation, that URI shall be considered\
    \ the base URI.  Note that\n   if the retrieval was the result of a redirected\
    \ request, the last URI\n   used (i.e., the URI that resulted in the actual retrieval\
    \ of the\n   representation) is the base URI.\n"
- title: 5.1.4.  Default Base URI
  contents:
  - "5.1.4.  Default Base URI\n   If none of the conditions described above apply,\
    \ then the base URI is\n   defined by the context of the application.  As this\
    \ definition is\n   necessarily application-dependent, failing to define a base\
    \ URI by\n   using one of the other methods may result in the same content being\n\
    \   interpreted differently by different types of applications.\n   A sender of\
    \ a representation containing relative references is\n   responsible for ensuring\
    \ that a base URI for those references can be\n   established.  Aside from fragment-only\
    \ references, relative\n   references can only be used reliably in situations\
    \ where the base URI\n   is well defined.\n"
- title: 5.2.  Relative Resolution
  contents:
  - "5.2.  Relative Resolution\n   This section describes an algorithm for converting\
    \ a URI reference\n   that might be relative to a given base URI into the parsed\
    \ components\n   of the reference's target.  The components can then be recomposed,\
    \ as\n   described in Section 5.3, to form the target URI.  This algorithm\n \
    \  provides definitive results that can be used to test the output of\n   other\
    \ implementations.  Applications may implement relative reference\n   resolution\
    \ by using some other algorithm, provided that the results\n   match what would\
    \ be given by this one.\n"
- title: 5.2.1.  Pre-parse the Base URI
  contents:
  - "5.2.1.  Pre-parse the Base URI\n   The base URI (Base) is established according\
    \ to the procedure of\n   Section 5.1 and parsed into the five main components\
    \ described in\n   Section 3.  Note that only the scheme component is required\
    \ to be\n   present in a base URI; the other components may be empty or\n   undefined.\
    \  A component is undefined if its associated delimiter does\n   not appear in\
    \ the URI reference; the path component is never\n   undefined, though it may\
    \ be empty.\n   Normalization of the base URI, as described in Sections 6.2.2\
    \ and\n   6.2.3, is optional.  A URI reference must be transformed to its\n  \
    \ target URI before it can be normalized.\n"
- title: 5.2.2.  Transform References
  contents:
  - "5.2.2.  Transform References\n   For each URI reference (R), the following pseudocode\
    \ describes an\n   algorithm for transforming R into its target URI (T):\n   \
    \   -- The URI reference is parsed into the five URI components\n      --\n  \
    \    (R.scheme, R.authority, R.path, R.query, R.fragment) = parse(R);\n      --\
    \ A non-strict parser may ignore a scheme in the reference\n      -- if it is\
    \ identical to the base URI's scheme.\n      --\n      if ((not strict) and (R.scheme\
    \ == Base.scheme)) then\n         undefine(R.scheme);\n      endif;\n      if\
    \ defined(R.scheme) then\n         T.scheme    = R.scheme;\n         T.authority\
    \ = R.authority;\n         T.path      = remove_dot_segments(R.path);\n      \
    \   T.query     = R.query;\n      else\n         if defined(R.authority) then\n\
    \            T.authority = R.authority;\n            T.path      = remove_dot_segments(R.path);\n\
    \            T.query     = R.query;\n         else\n            if (R.path ==\
    \ \"\") then\n               T.path = Base.path;\n               if defined(R.query)\
    \ then\n                  T.query = R.query;\n               else\n          \
    \        T.query = Base.query;\n               endif;\n            else\n    \
    \           if (R.path starts-with \"/\") then\n                  T.path = remove_dot_segments(R.path);\n\
    \               else\n                  T.path = merge(Base.path, R.path);\n \
    \                 T.path = remove_dot_segments(T.path);\n               endif;\n\
    \               T.query = R.query;\n            endif;\n            T.authority\
    \ = Base.authority;\n         endif;\n         T.scheme = Base.scheme;\n     \
    \ endif;\n      T.fragment = R.fragment;\n"
- title: 5.2.3.  Merge Paths
  contents:
  - "5.2.3.  Merge Paths\n   The pseudocode above refers to a \"merge\" routine for\
    \ merging a\n   relative-path reference with the path of the base URI.  This is\n\
    \   accomplished as follows:\n   o  If the base URI has a defined authority component\
    \ and an empty\n      path, then return a string consisting of \"/\" concatenated\
    \ with the\n      reference's path; otherwise,\n   o  return a string consisting\
    \ of the reference's path component\n      appended to all but the last segment\
    \ of the base URI's path (i.e.,\n      excluding any characters after the right-most\
    \ \"/\" in the base URI\n      path, or excluding the entire base URI path if\
    \ it does not contain\n      any \"/\" characters).\n"
- title: 5.2.4.  Remove Dot Segments
  contents:
  - "5.2.4.  Remove Dot Segments\n   The pseudocode also refers to a \"remove_dot_segments\"\
    \ routine for\n   interpreting and removing the special \".\" and \"..\" complete\
    \ path\n   segments from a referenced path.  This is done after the path is\n\
    \   extracted from a reference, whether or not the path was relative, in\n   order\
    \ to remove any invalid or extraneous dot-segments prior to\n   forming the target\
    \ URI.  Although there are many ways to accomplish\n   this removal process, we\
    \ describe a simple method using two string\n   buffers.\n   1.  The input buffer\
    \ is initialized with the now-appended path\n       components and the output\
    \ buffer is initialized to the empty\n       string.\n   2.  While the input buffer\
    \ is not empty, loop as follows:\n       A.  If the input buffer begins with a\
    \ prefix of \"../\" or \"./\",\n           then remove that prefix from the input\
    \ buffer; otherwise,\n       B.  if the input buffer begins with a prefix of \"\
    /./\" or \"/.\",\n           where \".\" is a complete path segment, then replace\
    \ that\n           prefix with \"/\" in the input buffer; otherwise,\n       C.\
    \  if the input buffer begins with a prefix of \"/../\" or \"/..\",\n        \
    \   where \"..\" is a complete path segment, then replace that\n           prefix\
    \ with \"/\" in the input buffer and remove the last\n           segment and its\
    \ preceding \"/\" (if any) from the output\n           buffer; otherwise,\n  \
    \     D.  if the input buffer consists only of \".\" or \"..\", then remove\n\
    \           that from the input buffer; otherwise,\n       E.  move the first\
    \ path segment in the input buffer to the end of\n           the output buffer,\
    \ including the initial \"/\" character (if\n           any) and any subsequent\
    \ characters up to, but not including,\n           the next \"/\" character or\
    \ the end of the input buffer.\n   3.  Finally, the output buffer is returned\
    \ as the result of\n       remove_dot_segments.\n   Note that dot-segments are\
    \ intended for use in URI references to\n   express an identifier relative to\
    \ the hierarchy of names in the base\n   URI.  The remove_dot_segments algorithm\
    \ respects that hierarchy by\n   removing extra dot-segments rather than treat\
    \ them as an error or\n   leaving them to be misinterpreted by dereference implementations.\n\
    \   The following illustrates how the above steps are applied for two\n   examples\
    \ of merged paths, showing the state of the two buffers after\n   each step.\n\
    \      STEP   OUTPUT BUFFER         INPUT BUFFER\n       1 :                 \
    \        /a/b/c/./../../g\n       2E:   /a                    /b/c/./../../g\n\
    \       2E:   /a/b                  /c/./../../g\n       2E:   /a/b/c        \
    \        /./../../g\n       2B:   /a/b/c                /../../g\n       2C: \
    \  /a/b                  /../g\n       2C:   /a                    /g\n      \
    \ 2E:   /a/g\n      STEP   OUTPUT BUFFER         INPUT BUFFER\n       1 :    \
    \                     mid/content=5/../6\n       2E:   mid                   /content=5/../6\n\
    \       2E:   mid/content=5         /../6\n       2C:   mid                  \
    \ /6\n       2E:   mid/6\n   Some applications may find it more efficient to implement\
    \ the\n   remove_dot_segments algorithm by using two segment stacks rather than\n\
    \   strings.\n      Note: Beware that some older, erroneous implementations will\
    \ fail\n      to separate a reference's query component from its path component\n\
    \      prior to merging the base and reference paths, resulting in an\n      interoperability\
    \ failure if the query component contains the\n      strings \"/../\" or \"/./\"\
    .\n"
- title: 5.3.  Component Recomposition
  contents:
  - "5.3.  Component Recomposition\n   Parsed URI components can be recomposed to\
    \ obtain the corresponding\n   URI reference string.  Using pseudocode, this would\
    \ be:\n      result = \"\"\n      if defined(scheme) then\n         append scheme\
    \ to result;\n         append \":\" to result;\n      endif;\n      if defined(authority)\
    \ then\n         append \"//\" to result;\n         append authority to result;\n\
    \      endif;\n      append path to result;\n      if defined(query) then\n  \
    \       append \"?\" to result;\n         append query to result;\n      endif;\n\
    \      if defined(fragment) then\n         append \"#\" to result;\n         append\
    \ fragment to result;\n      endif;\n      return result;\n   Note that we are\
    \ careful to preserve the distinction between a\n   component that is undefined,\
    \ meaning that its separator was not\n   present in the reference, and a component\
    \ that is empty, meaning that\n   the separator was present and was immediately\
    \ followed by the next\n   component separator or the end of the reference.\n"
- title: 5.4.  Reference Resolution Examples
  contents:
  - "5.4.  Reference Resolution Examples\n   Within a representation with a well defined\
    \ base URI of\n      http://a/b/c/d;p?q\n   a relative reference is transformed\
    \ to its target URI as follows.\n"
- title: 5.4.1.  Normal Examples
  contents:
  - "5.4.1.  Normal Examples\n      \"g:h\"           =  \"g:h\"\n      \"g\"    \
    \         =  \"http://a/b/c/g\"\n      \"./g\"           =  \"http://a/b/c/g\"\
    \n      \"g/\"            =  \"http://a/b/c/g/\"\n      \"/g\"            =  \"\
    http://a/g\"\n      \"//g\"           =  \"http://g\"\n      \"?y\"          \
    \  =  \"http://a/b/c/d;p?y\"\n      \"g?y\"           =  \"http://a/b/c/g?y\"\n\
    \      \"#s\"            =  \"http://a/b/c/d;p?q#s\"\n      \"g#s\"          \
    \ =  \"http://a/b/c/g#s\"\n      \"g?y#s\"         =  \"http://a/b/c/g?y#s\"\n\
    \      \";x\"            =  \"http://a/b/c/;x\"\n      \"g;x\"           =  \"\
    http://a/b/c/g;x\"\n      \"g;x?y#s\"       =  \"http://a/b/c/g;x?y#s\"\n    \
    \  \"\"              =  \"http://a/b/c/d;p?q\"\n      \".\"             =  \"\
    http://a/b/c/\"\n      \"./\"            =  \"http://a/b/c/\"\n      \"..\"  \
    \          =  \"http://a/b/\"\n      \"../\"           =  \"http://a/b/\"\n  \
    \    \"../g\"          =  \"http://a/b/g\"\n      \"../..\"         =  \"http://a/\"\
    \n      \"../../\"        =  \"http://a/\"\n      \"../../g\"       =  \"http://a/g\"\
    \n"
- title: 5.4.2.  Abnormal Examples
  contents:
  - "5.4.2.  Abnormal Examples\n   Although the following abnormal examples are unlikely\
    \ to occur in\n   normal practice, all URI parsers should be capable of resolving\
    \ them\n   consistently.  Each example uses the same base as that above.\n   Parsers\
    \ must be careful in handling cases where there are more \"..\"\n   segments in\
    \ a relative-path reference than there are hierarchical\n   levels in the base\
    \ URI's path.  Note that the \"..\" syntax cannot be\n   used to change the authority\
    \ component of a URI.\n      \"../../../g\"    =  \"http://a/g\"\n      \"../../../../g\"\
    \ =  \"http://a/g\"\n   Similarly, parsers must remove the dot-segments \".\"\
    \ and \"..\" when\n   they are complete components of a path, but not when they\
    \ are only\n   part of a segment.\n      \"/./g\"          =  \"http://a/g\"\n\
    \      \"/../g\"         =  \"http://a/g\"\n      \"g.\"            =  \"http://a/b/c/g.\"\
    \n      \".g\"            =  \"http://a/b/c/.g\"\n      \"g..\"           =  \"\
    http://a/b/c/g..\"\n      \"..g\"           =  \"http://a/b/c/..g\"\n   Less likely\
    \ are cases where the relative reference uses unnecessary\n   or nonsensical forms\
    \ of the \".\" and \"..\" complete path segments.\n      \"./../g\"        = \
    \ \"http://a/b/g\"\n      \"./g/.\"         =  \"http://a/b/c/g/\"\n      \"g/./h\"\
    \         =  \"http://a/b/c/g/h\"\n      \"g/../h\"        =  \"http://a/b/c/h\"\
    \n      \"g;x=1/./y\"     =  \"http://a/b/c/g;x=1/y\"\n      \"g;x=1/../y\"  \
    \  =  \"http://a/b/c/y\"\n   Some applications fail to separate the reference's\
    \ query and/or\n   fragment components from the path component before merging\
    \ it with\n   the base path and removing dot-segments.  This error is rarely\n\
    \   noticed, as typical usage of a fragment never includes the hierarchy\n   (\"\
    /\") character and the query component is not normally used within\n   relative\
    \ references.\n      \"g?y/./x\"       =  \"http://a/b/c/g?y/./x\"\n      \"g?y/../x\"\
    \      =  \"http://a/b/c/g?y/../x\"\n      \"g#s/./x\"       =  \"http://a/b/c/g#s/./x\"\
    \n      \"g#s/../x\"      =  \"http://a/b/c/g#s/../x\"\n   Some parsers allow\
    \ the scheme name to be present in a relative\n   reference if it is the same\
    \ as the base URI scheme.  This is\n   considered to be a loophole in prior specifications\
    \ of partial URI\n   [RFC1630].  Its use should be avoided but is allowed for\
    \ backward\n   compatibility.\n      \"http:g\"        =  \"http:g\"         ;\
    \ for strict parsers\n                      /  \"http://a/b/c/g\" ; for backward\
    \ compatibility\n"
- title: 6.  Normalization and Comparison
  contents:
  - "6.  Normalization and Comparison\n   One of the most common operations on URIs\
    \ is simple comparison:\n   determining whether two URIs are equivalent without\
    \ using the URIs to\n   access their respective resource(s).  A comparison is\
    \ performed every\n   time a response cache is accessed, a browser checks its\
    \ history to\n   color a link, or an XML parser processes tags within a namespace.\n\
    \   Extensive normalization prior to comparison of URIs is often used by\n   spiders\
    \ and indexing engines to prune a search space or to reduce\n   duplication of\
    \ request actions and response storage.\n   URI comparison is performed for some\
    \ particular purpose.  Protocols\n   or implementations that compare URIs for\
    \ different purposes will\n   often be subject to differing design trade-offs\
    \ in regards to how\n   much effort should be spent in reducing aliased identifiers.\
    \  This\n   section describes various methods that may be used to compare URIs,\n\
    \   the trade-offs between them, and the types of applications that might\n  \
    \ use them.\n"
- title: 6.1.  Equivalence
  contents:
  - "6.1.  Equivalence\n   Because URIs exist to identify resources, presumably they\
    \ should be\n   considered equivalent when they identify the same resource.  However,\n\
    \   this definition of equivalence is not of much practical use, as there\n  \
    \ is no way for an implementation to compare two resources unless it\n   has full\
    \ knowledge or control of them.  For this reason,\n   determination of equivalence\
    \ or difference of URIs is based on string\n   comparison, perhaps augmented by\
    \ reference to additional rules\n   provided by URI scheme definitions.  We use\
    \ the terms \"different\" and\n   \"equivalent\" to describe the possible outcomes\
    \ of such comparisons,\n   but there are many application-dependent versions of\
    \ equivalence.\n   Even though it is possible to determine that two URIs are equivalent,\n\
    \   URI comparison is not sufficient to determine whether two URIs\n   identify\
    \ different resources.  For example, an owner of two different\n   domain names\
    \ could decide to serve the same resource from both,\n   resulting in two different\
    \ URIs.  Therefore, comparison methods are\n   designed to minimize false negatives\
    \ while strictly avoiding false\n   positives.\n   In testing for equivalence,\
    \ applications should not directly compare\n   relative references; the references\
    \ should be converted to their\n   respective target URIs before comparison. \
    \ When URIs are compared to\n   select (or avoid) a network action, such as retrieval\
    \ of a\n   representation, fragment components (if any) should be excluded from\n\
    \   the comparison.\n"
- title: 6.2.  Comparison Ladder
  contents:
  - "6.2.  Comparison Ladder\n   A variety of methods are used in practice to test\
    \ URI equivalence.\n   These methods fall into a range, distinguished by the amount\
    \ of\n   processing required and the degree to which the probability of false\n\
    \   negatives is reduced.  As noted above, false negatives cannot be\n   eliminated.\
    \  In practice, their probability can be reduced, but this\n   reduction requires\
    \ more processing and is not cost-effective for all\n   applications.\n   If this\
    \ range of comparison practices is considered as a ladder, the\n   following discussion\
    \ will climb the ladder, starting with practices\n   that are cheap but have a\
    \ relatively higher chance of producing false\n   negatives, and proceeding to\
    \ those that have higher computational\n   cost and lower risk of false negatives.\n"
- title: 6.2.1.  Simple String Comparison
  contents:
  - "6.2.1.  Simple String Comparison\n   If two URIs, when considered as character\
    \ strings, are identical,\n   then it is safe to conclude that they are equivalent.\
    \  This type of\n   equivalence test has very low computational cost and is in\
    \ wide use\n   in a variety of applications, particularly in the domain of parsing.\n\
    \   Testing strings for equivalence requires some basic precautions.\n   This\
    \ procedure is often referred to as \"bit-for-bit\" or\n   \"byte-for-byte\" comparison,\
    \ which is potentially misleading.  Testing\n   strings for equality is normally\
    \ based on pair comparison of the\n   characters that make up the strings, starting\
    \ from the first and\n   proceeding until both strings are exhausted and all characters\
    \ are\n   found to be equal, until a pair of characters compares unequal, or\n\
    \   until one of the strings is exhausted before the other.\n   This character\
    \ comparison requires that each pair of characters be\n   put in comparable form.\
    \  For example, should one URI be stored in a\n   byte array in EBCDIC encoding\
    \ and the second in a Java String object\n   (UTF-16), bit-for-bit comparisons\
    \ applied naively will produce\n   errors.  It is better to speak of equality\
    \ on a character-for-\n   character basis rather than on a byte-for-byte or bit-for-bit\
    \ basis.\n   In practical terms, character-by-character comparisons should be\
    \ done\n   codepoint-by-codepoint after conversion to a common character\n   encoding.\n\
    \   False negatives are caused by the production and use of URI aliases.\n   Unnecessary\
    \ aliases can be reduced, regardless of the comparison\n   method, by consistently\
    \ providing URI references in an already-\n   normalized form (i.e., a form identical\
    \ to what would be produced\n   after normalization is applied, as described below).\n\
    \   Protocols and data formats often limit some URI comparisons to simple\n  \
    \ string comparison, based on the theory that people and\n   implementations will,\
    \ in their own best interest, be consistent in\n   providing URI references, or\
    \ at least consistent enough to negate any\n   efficiency that might be obtained\
    \ from further normalization.\n"
- title: 6.2.2.  Syntax-Based Normalization
  contents:
  - "6.2.2.  Syntax-Based Normalization\n   Implementations may use logic based on\
    \ the definitions provided by\n   this specification to reduce the probability\
    \ of false negatives.\n   This processing is moderately higher in cost than character-for-\n\
    \   character string comparison.  For example, an application using this\n   approach\
    \ could reasonably consider the following two URIs equivalent:\n      example://a/b/c/%7Bfoo%7D\n\
    \      eXAMPLE://a/./b/../b/%63/%7bfoo%7d\n   Web user agents, such as browsers,\
    \ typically apply this type of URI\n   normalization when determining whether\
    \ a cached response is\n   available.  Syntax-based normalization includes such\
    \ techniques as\n   case normalization, percent-encoding normalization, and removal\
    \ of\n   dot-segments.\n"
- title: 6.2.2.1.  Case Normalization
  contents:
  - "6.2.2.1.  Case Normalization\n   For all URIs, the hexadecimal digits within\
    \ a percent-encoding\n   triplet (e.g., \"%3a\" versus \"%3A\") are case-insensitive\
    \ and therefore\n   should be normalized to use uppercase letters for the digits\
    \ A-F.\n   When a URI uses components of the generic syntax, the component\n \
    \  syntax equivalence rules always apply; namely, that the scheme and\n   host\
    \ are case-insensitive and therefore should be normalized to\n   lowercase.  For\
    \ example, the URI <HTTP://www.EXAMPLE.com/> is\n   equivalent to <http://www.example.com/>.\
    \  The other generic syntax\n   components are assumed to be case-sensitive unless\
    \ specifically\n   defined otherwise by the scheme (see Section 6.2.3).\n"
- title: 6.2.2.2.  Percent-Encoding Normalization
  contents:
  - "6.2.2.2.  Percent-Encoding Normalization\n   The percent-encoding mechanism (Section\
    \ 2.1) is a frequent source of\n   variance among otherwise identical URIs.  In\
    \ addition to the case\n   normalization issue noted above, some URI producers\
    \ percent-encode\n   octets that do not require percent-encoding, resulting in\
    \ URIs that\n   are equivalent to their non-encoded counterparts.  These URIs\
    \ should\n   be normalized by decoding any percent-encoded octet that corresponds\n\
    \   to an unreserved character, as described in Section 2.3.\n"
- title: 6.2.2.3.  Path Segment Normalization
  contents:
  - "6.2.2.3.  Path Segment Normalization\n   The complete path segments \".\" and\
    \ \"..\" are intended only for use\n   within relative references (Section 4.1)\
    \ and are removed as part of\n   the reference resolution process (Section 5.2).\
    \  However, some\n   deployed implementations incorrectly assume that reference\
    \ resolution\n   is not necessary when the reference is already a URI and thus\
    \ fail to\n   remove dot-segments when they occur in non-relative paths.  URI\n\
    \   normalizers should remove dot-segments by applying the\n   remove_dot_segments\
    \ algorithm to the path, as described in\n   Section 5.2.4.\n"
- title: 6.2.3.  Scheme-Based Normalization
  contents:
  - "6.2.3.  Scheme-Based Normalization\n   The syntax and semantics of URIs vary\
    \ from scheme to scheme, as\n   described by the defining specification for each\
    \ scheme.\n   Implementations may use scheme-specific rules, at further processing\n\
    \   cost, to reduce the probability of false negatives.  For example,\n   because\
    \ the \"http\" scheme makes use of an authority component, has a\n   default port\
    \ of \"80\", and defines an empty path to be equivalent to\n   \"/\", the following\
    \ four URIs are equivalent:\n      http://example.com\n      http://example.com/\n\
    \      http://example.com:/\n      http://example.com:80/\n   In general, a URI\
    \ that uses the generic syntax for authority with an\n   empty path should be\
    \ normalized to a path of \"/\".  Likewise, an\n   explicit \":port\", for which\
    \ the port is empty or the default for the\n   scheme, is equivalent to one where\
    \ the port and its \":\" delimiter are\n   elided and thus should be removed by\
    \ scheme-based normalization.  For\n   example, the second URI above is the normal\
    \ form for the \"http\"\n   scheme.\n   Another case where normalization varies\
    \ by scheme is in the handling\n   of an empty authority component or empty host\
    \ subcomponent.  For many\n   scheme specifications, an empty authority or host\
    \ is considered an\n   error; for others, it is considered equivalent to \"localhost\"\
    \ or the\n   end-user's host.  When a scheme defines a default for authority and\
    \ a\n   URI reference to that default is desired, the reference should be\n  \
    \ normalized to an empty authority for the sake of uniformity, brevity,\n   and\
    \ internationalization.  If, however, either the userinfo or port\n   subcomponents\
    \ are non-empty, then the host should be given explicitly\n   even if it matches\
    \ the default.\n   Normalization should not remove delimiters when their associated\n\
    \   component is empty unless licensed to do so by the scheme\n   specification.\
    \  For example, the URI \"http://example.com/?\" cannot be\n   assumed to be equivalent\
    \ to any of the examples above.  Likewise, the\n   presence or absence of delimiters\
    \ within a userinfo subcomponent is\n   usually significant to its interpretation.\
    \  The fragment component is\n   not subject to any scheme-based normalization;\
    \ thus, two URIs that\n   differ only by the suffix \"#\" are considered different\
    \ regardless of\n   the scheme.\n   Some schemes define additional subcomponents\
    \ that consist of case-\n   insensitive data, giving an implicit license to normalizers\
    \ to\n   convert this data to a common case (e.g., all lowercase).  For\n   example,\
    \ URI schemes that define a subcomponent of path to contain an\n   Internet hostname,\
    \ such as the \"mailto\" URI scheme, cause that\n   subcomponent to be case-insensitive\
    \ and thus subject to case\n   normalization (e.g., \"mailto:Joe@Example.COM\"\
    \ is equivalent to\n   \"mailto:Joe@example.com\", even though the generic syntax\
    \ considers\n   the path component to be case-sensitive).\n   Other scheme-specific\
    \ normalizations are possible.\n"
- title: 6.2.4.  Protocol-Based Normalization
  contents:
  - "6.2.4.  Protocol-Based Normalization\n   Substantial effort to reduce the incidence\
    \ of false negatives is\n   often cost-effective for web spiders.  Therefore,\
    \ they implement even\n   more aggressive techniques in URI comparison.  For example,\
    \ if they\n   observe that a URI such as\n      http://example.com/data\n   redirects\
    \ to a URI differing only in the trailing slash\n      http://example.com/data/\n\
    \   they will likely regard the two as equivalent in the future.  This\n   kind\
    \ of technique is only appropriate when equivalence is clearly\n   indicated by\
    \ both the result of accessing the resources and the\n   common conventions of\
    \ their scheme's dereference algorithm (in this\n   case, use of redirection by\
    \ HTTP origin servers to avoid problems\n   with relative references).\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   A URI does not in itself pose a security threat.\
    \  However, as URIs\n   are often used to provide a compact set of instructions\
    \ for access to\n   network resources, care must be taken to properly interpret\
    \ the data\n   within a URI, to prevent that data from causing unintended access,\n\
    \   and to avoid including data that should not be revealed in plain\n   text.\n"
- title: 7.1.  Reliability and Consistency
  contents:
  - "7.1.  Reliability and Consistency\n   There is no guarantee that once a URI has\
    \ been used to retrieve\n   information, the same information will be retrievable\
    \ by that URI in\n   the future.  Nor is there any guarantee that the information\n\
    \   retrievable via that URI in the future will be observably similar to\n   that\
    \ retrieved in the past.  The URI syntax does not constrain how a\n   given scheme\
    \ or authority apportions its namespace or maintains it\n   over time.  Such guarantees\
    \ can only be obtained from the person(s)\n   controlling that namespace and the\
    \ resource in question.  A specific\n   URI scheme may define additional semantics,\
    \ such as name persistence,\n   if those semantics are required of all naming\
    \ authorities for that\n   scheme.\n"
- title: 7.2.  Malicious Construction
  contents:
  - "7.2.  Malicious Construction\n   It is sometimes possible to construct a URI\
    \ so that an attempt to\n   perform a seemingly harmless, idempotent operation,\
    \ such as the\n   retrieval of a representation, will in fact cause a possibly\
    \ damaging\n   remote operation.  The unsafe URI is typically constructed by\n\
    \   specifying a port number other than that reserved for the network\n   protocol\
    \ in question.  The client unwittingly contacts a site running\n   a different\
    \ protocol service, and data within the URI contains\n   instructions that, when\
    \ interpreted according to this other protocol,\n   cause an unexpected operation.\
    \  A frequent example of such abuse has\n   been the use of a protocol-based scheme\
    \ with a port component of\n   \"25\", thereby fooling user agent software into\
    \ sending an unintended\n   or impersonating message via an SMTP server.\n   Applications\
    \ should prevent dereference of a URI that specifies a TCP\n   port number within\
    \ the \"well-known port\" range (0 - 1023) unless the\n   protocol being used\
    \ to dereference that URI is compatible with the\n   protocol expected on that\
    \ well-known port.  Although IANA maintains a\n   registry of well-known ports,\
    \ applications should make such\n   restrictions user-configurable to avoid preventing\
    \ the deployment of\n   new services.\n   When a URI contains percent-encoded\
    \ octets that match the delimiters\n   for a given resolution or dereference protocol\
    \ (for example, CR and\n   LF characters for the TELNET protocol), these percent-encodings\
    \ must\n   not be decoded before transmission across that protocol.  Transfer\
    \ of\n   the percent-encoding, which might violate the protocol, is less\n   harmful\
    \ than allowing decoded octets to be interpreted as additional\n   operations\
    \ or parameters, perhaps triggering an unexpected and\n   possibly harmful remote\
    \ operation.\n"
- title: 7.3.  Back-End Transcoding
  contents:
  - "7.3.  Back-End Transcoding\n   When a URI is dereferenced, the data within it\
    \ is often parsed by\n   both the user agent and one or more servers.  In HTTP,\
    \ for example, a\n   typical user agent will parse a URI into its five major components,\n\
    \   access the authority's server, and send it the data within the\n   authority,\
    \ path, and query components.  A typical server will take\n   that information,\
    \ parse the path into segments and the query into\n   key/value pairs, and then\
    \ invoke implementation-specific handlers to\n   respond to the request.  As a\
    \ result, a common security concern for\n   server implementations that handle\
    \ a URI, either as a whole or split\n   into separate components, is proper interpretation\
    \ of the octet data\n   represented by the characters and percent-encodings within\
    \ that URI.\n   Percent-encoded octets must be decoded at some point during the\n\
    \   dereference process.  Applications must split the URI into its\n   components\
    \ and subcomponents prior to decoding the octets, as\n   otherwise the decoded\
    \ octets might be mistaken for delimiters.\n   Security checks of the data within\
    \ a URI should be applied after\n   decoding the octets.  Note, however, that\
    \ the \"%00\" percent-encoding\n   (NUL) may require special handling and should\
    \ be rejected if the\n   application is not expecting to receive raw data within\
    \ a component.\n   Special care should be taken when the URI path interpretation\
    \ process\n   involves the use of a back-end file system or related system\n \
    \  functions.  File systems typically assign an operational meaning to\n   special\
    \ characters, such as the \"/\", \"\\\", \":\", \"[\", and \"]\"\n   characters,\
    \ and to special device names like \".\", \"..\", \"...\", \"aux\",\n   \"lpt\"\
    , etc.  In some cases, merely testing for the existence of such\n   a name will\
    \ cause the operating system to pause or invoke unrelated\n   system calls, leading\
    \ to significant security concerns regarding\n   denial of service and unintended\
    \ data transfer.  It would be\n   impossible for this specification to list all\
    \ such significant\n   characters and device names.  Implementers should research\
    \ the\n   reserved names and characters for the types of storage device that\n\
    \   may be attached to their applications and restrict the use of data\n   obtained\
    \ from URI components accordingly.\n"
- title: 7.4.  Rare IP Address Formats
  contents:
  - "7.4.  Rare IP Address Formats\n   Although the URI syntax for IPv4address only\
    \ allows the common\n   dotted-decimal form of IPv4 address literal, many implementations\n\
    \   that process URIs make use of platform-dependent system routines,\n   such\
    \ as gethostbyname() and inet_aton(), to translate the string\n   literal to an\
    \ actual IP address.  Unfortunately, such system routines\n   often allow and\
    \ process a much larger set of formats than those\n   described in Section 3.2.2.\n\
    \   For example, many implementations allow dotted forms of three\n   numbers,\
    \ wherein the last part is interpreted as a 16-bit quantity\n   and placed in\
    \ the right-most two bytes of the network address (e.g.,\n   a Class B network).\
    \  Likewise, a dotted form of two numbers means\n   that the last part is interpreted\
    \ as a 24-bit quantity and placed in\n   the right-most three bytes of the network\
    \ address (Class A), and a\n   single number (without dots) is interpreted as\
    \ a 32-bit quantity and\n   stored directly in the network address.  Adding further\
    \ to the\n   confusion, some implementations allow each dotted part to be\n  \
    \ interpreted as decimal, octal, or hexadecimal, as specified in the C\n   language\
    \ (i.e., a leading 0x or 0X implies hexadecimal; a leading 0\n   implies octal;\
    \ otherwise, the number is interpreted as decimal).\n   These additional IP address\
    \ formats are not allowed in the URI syntax\n   due to differences between platform\
    \ implementations.  However, they\n   can become a security concern if an application\
    \ attempts to filter\n   access to resources based on the IP address in string\
    \ literal format.\n   If this filtering is performed, literals should be converted\
    \ to\n   numeric form and filtered based on the numeric value, and not on a\n\
    \   prefix or suffix of the string form.\n"
- title: 7.5.  Sensitive Information
  contents:
  - "7.5.  Sensitive Information\n   URI producers should not provide a URI that contains\
    \ a username or\n   password that is intended to be secret.  URIs are frequently\n\
    \   displayed by browsers, stored in clear text bookmarks, and logged by\n   user\
    \ agent history and intermediary applications (proxies).  A\n   password appearing\
    \ within the userinfo component is deprecated and\n   should be considered an\
    \ error (or simply ignored) except in those\n   rare cases where the 'password'\
    \ parameter is intended to be public.\n"
- title: 7.6.  Semantic Attacks
  contents:
  - "7.6.  Semantic Attacks\n   Because the userinfo subcomponent is rarely used and\
    \ appears before\n   the host in the authority component, it can be used to construct\
    \ a\n   URI intended to mislead a human user by appearing to identify one\n  \
    \ (trusted) naming authority while actually identifying a different\n   authority\
    \ hidden behind the noise.  For example\n      ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm\n\
    \   might lead a human user to assume that the host is 'cnn.example.com',\n  \
    \ whereas it is actually '10.0.0.1'.  Note that a misleading userinfo\n   subcomponent\
    \ could be much longer than the example above.\n   A misleading URI, such as that\
    \ above, is an attack on the user's\n   preconceived notions about the meaning\
    \ of a URI rather than an attack\n   on the software itself.  User agents may\
    \ be able to reduce the impact\n   of such attacks by distinguishing the various\
    \ components of the URI\n   when they are rendered, such as by using a different\
    \ color or tone to\n   render userinfo if any is present, though there is no panacea.\
    \  More\n   information on URI-based semantic attacks can be found in [Siedzik].\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   URI scheme names, as defined by <scheme> in Section\
    \ 3.1, form a\n   registered namespace that is managed by IANA according to the\n\
    \   procedures defined in [BCP35].  No IANA actions are required by this\n   document.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   This specification is derived from RFC 2396 [RFC2396],\
    \ RFC 1808\n   [RFC1808], and RFC 1738 [RFC1738]; the acknowledgements in those\n\
    \   documents still apply.  It also incorporates the update (with\n   corrections)\
    \ for IPv6 literals in the host syntax, as defined by\n   Robert M. Hinden, Brian\
    \ E. Carpenter, and Larry Masinter in\n   [RFC2732].  In addition, contributions\
    \ by Gisle Aas, Reese Anschultz,\n   Daniel Barclay, Tim Bray, Mike Brown, Rob\
    \ Cameron, Jeremy Carroll,\n   Dan Connolly, Adam M. Costello, John Cowan, Jason\
    \ Diamond, Martin\n   Duerst, Stefan Eissing, Clive D.W. Feather, Al Gilman, Tony\
    \ Hammond,\n   Elliotte Harold, Pat Hayes, Henry Holtzman, Ian B. Jacobs, Michael\n\
    \   Kay, John C. Klensin, Graham Klyne, Dan Kohn, Bruce Lilly, Andrew\n   Main,\
    \ Dave McAlpin, Ira McDonald, Michael Mealling, Ray Merkert,\n   Stephen Pollei,\
    \ Julian Reschke, Tomas Rokicki, Miles Sabin, Kai\n   Schaetzl, Mark Thomson,\
    \ Ronald Tschalaer, Norm Walsh, Marc Warne,\n   Stuart Williams, and Henry Zongaro\
    \ are gratefully acknowledged.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [ASCII]    American National Standards Institute,\
    \ \"Coded Character\n              Set -- 7-bit American Standard Code for Information\n\
    \              Interchange\", ANSI X3.4, 1986.\n   [RFC2234]  Crocker, D. and\
    \ P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\"\
    , RFC 2234, November 1997.\n   [STD63]    Yergeau, F., \"UTF-8, a transformation\
    \ format of\n              ISO 10646\", STD 63, RFC 3629, November 2003.\n   [UCS]\
    \      International Organization for Standardization,\n              \"Information\
    \ Technology - Universal Multiple-Octet Coded\n              Character Set (UCS)\"\
    , ISO/IEC 10646:2003, December 2003.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [BCP19]    Freed, N. and J. Postel, \"IANA\
    \ Charset Registration\n              Procedures\", BCP 19, RFC 2978, October\
    \ 2000.\n   [BCP35]    Petke, R. and I. King, \"Registration Procedures for URL\n\
    \              Scheme Names\", BCP 35, RFC 2717, November 1999.\n   [RFC0952]\
    \  Harrenstien, K., Stahl, M., and E. Feinler, \"DoD Internet\n              host\
    \ table specification\", RFC 952, October 1985.\n   [RFC1034]  Mockapetris, P.,\
    \ \"Domain names - concepts and facilities\",\n              STD 13, RFC 1034,\
    \ November 1987.\n   [RFC1123]  Braden, R., \"Requirements for Internet Hosts\
    \ - Application\n              and Support\", STD 3, RFC 1123, October 1989.\n\
    \   [RFC1535]  Gavron, E., \"A Security Problem and Proposed Correction\n    \
    \          With Widely Deployed DNS Software\", RFC 1535,\n              October\
    \ 1993.\n   [RFC1630]  Berners-Lee, T., \"Universal Resource Identifiers in WWW:\
    \ A\n              Unifying Syntax for the Expression of Names and Addresses\n\
    \              of Objects on the Network as used in the World-Wide Web\",\n  \
    \            RFC 1630, June 1994.\n   [RFC1736]  Kunze, J., \"Functional Recommendations\
    \ for Internet\n              Resource Locators\", RFC 1736, February 1995.\n\
    \   [RFC1737]  Sollins, K. and L. Masinter, \"Functional Requirements for\n  \
    \            Uniform Resource Names\", RFC 1737, December 1994.\n   [RFC1738]\
    \  Berners-Lee, T., Masinter, L., and M. McCahill, \"Uniform\n              Resource\
    \ Locators (URL)\", RFC 1738, December 1994.\n   [RFC1808]  Fielding, R., \"Relative\
    \ Uniform Resource Locators\",\n              RFC 1808, June 1995.\n   [RFC2046]\
    \  Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n              Extensions\
    \ (MIME) Part Two: Media Types\", RFC 2046,\n              November 1996.\n  \
    \ [RFC2141]  Moats, R., \"URN Syntax\", RFC 2141, May 1997.\n   [RFC2396]  Berners-Lee,\
    \ T., Fielding, R., and L. Masinter, \"Uniform\n              Resource Identifiers\
    \ (URI): Generic Syntax\", RFC 2396,\n              August 1998.\n   [RFC2518]\
    \  Goland, Y., Whitehead, E., Faizi, A., Carter, S., and D.\n              Jensen,\
    \ \"HTTP Extensions for Distributed Authoring --\n              WEBDAV\", RFC\
    \ 2518, February 1999.\n   [RFC2557]  Palme, J., Hopmann, A., and N. Shelness,\
    \ \"MIME\n              Encapsulation of Aggregate Documents, such as HTML\n \
    \             (MHTML)\", RFC 2557, March 1999.\n   [RFC2718]  Masinter, L., Alvestrand,\
    \ H., Zigmond, D., and R. Petke,\n              \"Guidelines for new URL Schemes\"\
    , RFC 2718, November 1999.\n   [RFC2732]  Hinden, R., Carpenter, B., and L. Masinter,\
    \ \"Format for\n              Literal IPv6 Addresses in URL's\", RFC 2732, December\
    \ 1999.\n   [RFC3305]  Mealling, M. and R. Denenberg, \"Report from the Joint\n\
    \              W3C/IETF URI Planning Interest Group: Uniform Resource\n      \
    \        Identifiers (URIs), URLs, and Uniform Resource Names\n              (URNs):\
    \ Clarifications and Recommendations\", RFC 3305,\n              August 2002.\n\
    \   [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,\n              \"\
    Internationalizing Domain Names in Applications (IDNA)\",\n              RFC 3490,\
    \ March 2003.\n   [RFC3513]  Hinden, R. and S. Deering, \"Internet Protocol Version\
    \ 6\n              (IPv6) Addressing Architecture\", RFC 3513, April 2003.\n \
    \  [Siedzik]  Siedzik, R., \"Semantic Attacks: What's in a URL?\",\n         \
    \     April 2001, <http://www.giac.org/practical/gsec/\n              Richard_Siedzik_GSEC.pdf>.\n"
- title: Appendix A.  Collected ABNF for URI
  contents:
  - "Appendix A.  Collected ABNF for URI\n   URI           = scheme \":\" hier-part\
    \ [ \"?\" query ] [ \"#\" fragment ]\n   hier-part     = \"//\" authority path-abempty\n\
    \                 / path-absolute\n                 / path-rootless\n        \
    \         / path-empty\n   URI-reference = URI / relative-ref\n   absolute-URI\
    \  = scheme \":\" hier-part [ \"?\" query ]\n   relative-ref  = relative-part\
    \ [ \"?\" query ] [ \"#\" fragment ]\n   relative-part = \"//\" authority path-abempty\n\
    \                 / path-absolute\n                 / path-noscheme\n        \
    \         / path-empty\n   scheme        = ALPHA *( ALPHA / DIGIT / \"+\" / \"\
    -\" / \".\" )\n   authority     = [ userinfo \"@\" ] host [ \":\" port ]\n   userinfo\
    \      = *( unreserved / pct-encoded / sub-delims / \":\" )\n   host         \
    \ = IP-literal / IPv4address / reg-name\n   port          = *DIGIT\n   IP-literal\
    \    = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n   IPvFuture     = \"v\" 1*HEXDIG\
    \ \".\" 1*( unreserved / sub-delims / \":\" )\n   IPv6address   =            \
    \                6( h16 \":\" ) ls32\n                 /                     \
    \  \"::\" 5( h16 \":\" ) ls32\n                 / [               h16 ] \"::\"\
    \ 4( h16 \":\" ) ls32\n                 / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16\
    \ \":\" ) ls32\n                 / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\"\
    \ ) ls32\n                 / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\
    \                 / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n       \
    \          / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n               \
    \  / [ *6( h16 \":\" ) h16 ] \"::\"\n   h16           = 1*4HEXDIG\n   ls32   \
    \       = ( h16 \":\" h16 ) / IPv4address\n   IPv4address   = dec-octet \".\"\
    \ dec-octet \".\" dec-octet \".\" dec-octet\n   dec-octet     = DIGIT        \
    \         ; 0-9\n                 / %x31-39 DIGIT         ; 10-99\n          \
    \       / \"1\" 2DIGIT            ; 100-199\n                 / \"2\" %x30-34\
    \ DIGIT     ; 200-249\n                 / \"25\" %x30-35          ; 250-255\n\
    \   reg-name      = *( unreserved / pct-encoded / sub-delims )\n   path      \
    \    = path-abempty    ; begins with \"/\" or is empty\n                 / path-absolute\
    \   ; begins with \"/\" but not \"//\"\n                 / path-noscheme   ; begins\
    \ with a non-colon segment\n                 / path-rootless   ; begins with a\
    \ segment\n                 / path-empty      ; zero characters\n   path-abempty\
    \  = *( \"/\" segment )\n   path-absolute = \"/\" [ segment-nz *( \"/\" segment\
    \ ) ]\n   path-noscheme = segment-nz-nc *( \"/\" segment )\n   path-rootless =\
    \ segment-nz *( \"/\" segment )\n   path-empty    = 0<pchar>\n   segment     \
    \  = *pchar\n   segment-nz    = 1*pchar\n   segment-nz-nc = 1*( unreserved / pct-encoded\
    \ / sub-delims / \"@\" )\n                 ; non-zero-length segment without any\
    \ colon \":\"\n   pchar         = unreserved / pct-encoded / sub-delims / \":\"\
    \ / \"@\"\n   query         = *( pchar / \"/\" / \"?\" )\n   fragment      = *(\
    \ pchar / \"/\" / \"?\" )\n   pct-encoded   = \"%\" HEXDIG HEXDIG\n   unreserved\
    \    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   reserved      = gen-delims\
    \ / sub-delims\n   gen-delims    = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"\
    ]\" / \"@\"\n   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\
    \                 / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n"
- title: Appendix B.  Parsing a URI Reference with a Regular Expression
  contents:
  - "Appendix B.  Parsing a URI Reference with a Regular Expression\n   As the \"\
    first-match-wins\" algorithm is identical to the \"greedy\"\n   disambiguation\
    \ method used by POSIX regular expressions, it is\n   natural and commonplace\
    \ to use a regular expression for parsing the\n   potential five components of\
    \ a URI reference.\n   The following line is the regular expression for breaking-down\
    \ a\n   well-formed URI reference into its components.\n      ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\
    ?([^#]*))?(#(.*))?\n       12            3  4          5       6  7        8 9\n\
    \   The numbers in the second line above are only to assist readability;\n   they\
    \ indicate the reference points for each subexpression (i.e., each\n   paired\
    \ parenthesis).  We refer to the value matched for subexpression\n   <n> as $<n>.\
    \  For example, matching the above expression to\n      http://www.ics.uci.edu/pub/ietf/uri/#Related\n\
    \   results in the following subexpression matches:\n      $1 = http:\n      $2\
    \ = http\n      $3 = //www.ics.uci.edu\n      $4 = www.ics.uci.edu\n      $5 =\
    \ /pub/ietf/uri/\n      $6 = <undefined>\n      $7 = <undefined>\n      $8 = #Related\n\
    \      $9 = Related\n   where <undefined> indicates that the component is not\
    \ present, as is\n   the case for the query component in the above example.  Therefore,\
    \ we\n   can determine the value of the five components as\n      scheme    =\
    \ $2\n      authority = $4\n      path      = $5\n      query     = $7\n     \
    \ fragment  = $9\n   Going in the opposite direction, we can recreate a URI reference\
    \ from\n   its components by using the algorithm of Section 5.3.\n"
- title: Appendix C.  Delimiting a URI in Context
  contents:
  - "Appendix C.  Delimiting a URI in Context\n   URIs are often transmitted through\
    \ formats that do not provide a\n   clear context for their interpretation.  For\
    \ example, there are many\n   occasions when a URI is included in plain text;\
    \ examples include text\n   sent in email, USENET news, and on printed paper.\
    \  In such cases, it\n   is important to be able to delimit the URI from the rest\
    \ of the text,\n   and in particular from punctuation marks that might be mistaken\
    \ for\n   part of the URI.\n   In practice, URIs are delimited in a variety of\
    \ ways, but usually\n   within double-quotes \"http://example.com/\", angle brackets\n\
    \   <http://example.com/>, or just by using whitespace:\n      http://example.com/\n\
    \   These wrappers do not form part of the URI.\n   In some cases, extra whitespace\
    \ (spaces, line-breaks, tabs, etc.) may\n   have to be added to break a long URI\
    \ across lines.  The whitespace\n   should be ignored when the URI is extracted.\n\
    \   No whitespace should be introduced after a hyphen (\"-\") character.\n   Because\
    \ some typesetters and printers may (erroneously) introduce a\n   hyphen at the\
    \ end of line when breaking it, the interpreter of a URI\n   containing a line\
    \ break immediately after a hyphen should ignore all\n   whitespace around the\
    \ line break and should be aware that the hyphen\n   may or may not actually be\
    \ part of the URI.\n   Using <> angle brackets around each URI is especially recommended\
    \ as\n   a delimiting style for a reference that contains embedded whitespace.\n\
    \   The prefix \"URL:\" (with or without a trailing space) was formerly\n   recommended\
    \ as a way to help distinguish a URI from other bracketed\n   designators, though\
    \ it is not commonly used in practice and is no\n   longer recommended.\n   For\
    \ robustness, software that accepts user-typed URI should attempt\n   to recognize\
    \ and strip both delimiters and embedded whitespace.\n   For example, the text\n\
    \      Yes, Jim, I found it under \"http://www.w3.org/Addressing/\",\n      but\
    \ you can probably pick it up from <ftp://foo.example.\n      com/rfc/>.  Note\
    \ the warning in <http://www.ics.uci.edu/pub/\n      ietf/uri/historical.html#WARNING>.\n\
    \   contains the URI references\n      http://www.w3.org/Addressing/\n      ftp://foo.example.com/rfc/\n\
    \      http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING\n"
- title: Appendix D.  Changes from RFC 2396
  contents:
  - 'Appendix D.  Changes from RFC 2396

    '
- title: D.1.  Additions
  contents:
  - "D.1.  Additions\n   An ABNF rule for URI has been introduced to correspond to\
    \ one common\n   usage of the term: an absolute URI with optional fragment.\n\
    \   IPv6 (and later) literals have been added to the list of possible\n   identifiers\
    \ for the host portion of an authority component, as\n   described by [RFC2732],\
    \ with the addition of \"[\" and \"]\" to the\n   reserved set and a version flag\
    \ to anticipate future versions of IP\n   literals.  Square brackets are now specified\
    \ as reserved within the\n   authority component and are not allowed outside their\
    \ use as\n   delimiters for an IP literal within host.  In order to make this\n\
    \   change without changing the technical definition of the path, query,\n   and\
    \ fragment components, those rules were redefined to directly\n   specify the\
    \ characters allowed.\n   As [RFC2732] defers to [RFC3513] for definition of an\
    \ IPv6 literal\n   address, which, unfortunately, lacks an ABNF description of\n\
    \   IPv6address, we created a new ABNF rule for IPv6address that matches\n   the\
    \ text representations defined by Section 2.2 of [RFC3513].\n   Likewise, the\
    \ definition of IPv4address has been improved in order to\n   limit each decimal\
    \ octet to the range 0-255.\n   Section 6, on URI normalization and comparison,\
    \ has been completely\n   rewritten and extended by using input from Tim Bray\
    \ and discussion\n   within the W3C Technical Architecture Group.\n"
- title: D.2.  Modifications
  contents:
  - "D.2.  Modifications\n   The ad-hoc BNF syntax of RFC 2396 has been replaced with\
    \ the ABNF of\n   [RFC2234].  This change required all rule names that formerly\n\
    \   included underscore characters to be renamed with a dash instead.  In\n  \
    \ addition, a number of syntax rules have been eliminated or simplified\n   to\
    \ make the overall grammar more comprehensible.  Specifications that\n   refer\
    \ to the obsolete grammar rules may be understood by replacing\n   those rules\
    \ according to the following table:\n   +----------------+--------------------------------------------------+\n\
    \   | obsolete rule  | translation                                      |\n  \
    \ +----------------+--------------------------------------------------+\n   |\
    \ absoluteURI    | absolute-URI                                     |\n   | relativeURI\
    \    | relative-part [ \"?\" query ]                      |\n   | hier_part  \
    \    | ( \"//\" authority path-abempty /                  |\n   |            \
    \    | path-absolute ) [ \"?\" query ]                    |\n   |            \
    \    |                                                  |\n   | opaque_part  \
    \  | path-rootless [ \"?\" query ]                      |\n   | net_path     \
    \  | \"//\" authority path-abempty                      |\n   | abs_path     \
    \  | path-absolute                                    |\n   | rel_path       |\
    \ path-rootless                                    |\n   | rel_segment    | segment-nz-nc\
    \                                    |\n   | reg_name       | reg-name       \
    \                                  |\n   | server         | authority        \
    \                                |\n   | hostport       | host [ \":\" port ]\
    \                                |\n   | hostname       | reg-name           \
    \                              |\n   | path_segments  | path-abempty         \
    \                            |\n   | param          | *<pchar excluding \";\"\
    >                           |\n   |                |                         \
    \                         |\n   | uric           | unreserved / pct-encoded /\
    \ \";\" / \"?\" / \":\"       |\n   |                |  / \"@\" / \"&\" / \"=\"\
    \ / \"+\" / \"$\" / \",\" / \"/\"       |\n   |                |             \
    \                                     |\n   | uric_no_slash  | unreserved / pct-encoded\
    \ / \";\" / \"?\" / \":\"       |\n   |                |  / \"@\" / \"&\" / \"\
    =\" / \"+\" / \"$\" / \",\"             |\n   |                |             \
    \                                     |\n   | mark           | \"-\" / \"_\" /\
    \ \".\" / \"!\" / \"~\" / \"*\" / \"'\"          |\n   |                |  / \"\
    (\" / \")\"                                     |\n   |                |     \
    \                                             |\n   | escaped        | pct-encoded\
    \                                      |\n   | hex            | HEXDIG       \
    \                                    |\n   | alphanum       | ALPHA / DIGIT  \
    \                                  |\n   +----------------+--------------------------------------------------+\n\
    \   Use of the above obsolete rules for the definition of scheme-specific\n  \
    \ syntax is deprecated.\n   Section 2, on characters, has been rewritten to explain\
    \ what\n   characters are reserved, when they are reserved, and why they are\n\
    \   reserved, even when they are not used as delimiters by the generic\n   syntax.\
    \  The mark characters that are typically unsafe to decode,\n   including the\
    \ exclamation mark (\"!\"), asterisk (\"*\"), single-quote\n   (\"'\"), and open\
    \ and close parentheses (\"(\" and \")\"), have been moved\n   to the reserved\
    \ set in order to clarify the distinction between\n   reserved and unreserved\
    \ and, hopefully, to answer the most common\n   question of scheme designers.\
    \  Likewise, the section on\n   percent-encoded characters has been rewritten,\
    \ and URI normalizers\n   are now given license to decode any percent-encoded\
    \ octets\n   corresponding to unreserved characters.  In general, the terms\n\
    \   \"escaped\" and \"unescaped\" have been replaced with \"percent-encoded\"\n\
    \   and \"decoded\", respectively, to reduce confusion with other forms of\n \
    \  escape mechanisms.\n   The ABNF for URI and URI-reference has been redesigned\
    \ to make them\n   more friendly to LALR parsers and to reduce complexity.  As\
    \ a result,\n   the layout form of syntax description has been removed, along\
    \ with\n   the uric, uric_no_slash, opaque_part, net_path, abs_path, rel_path,\n\
    \   path_segments, rel_segment, and mark rules.  All references to\n   \"opaque\"\
    \ URIs have been replaced with a better description of how the\n   path component\
    \ may be opaque to hierarchy.  The relativeURI rule has\n   been replaced with\
    \ relative-ref to avoid unnecessary confusion over\n   whether they are a subset\
    \ of URI.  The ambiguity regarding the\n   parsing of URI-reference as a URI or\
    \ a relative-ref with a colon in\n   the first segment has been eliminated through\
    \ the use of five\n   separate path matching rules.\n   The fragment identifier\
    \ has been moved back into the section on\n   generic syntax components and within\
    \ the URI and relative-ref rules,\n   though it remains excluded from absolute-URI.\
    \  The number sign (\"#\")\n   character has been moved back to the reserved set\
    \ as a result of\n   reintegrating the fragment syntax.\n   The ABNF has been\
    \ corrected to allow the path component to be empty.\n   This also allows an absolute-URI\
    \ to consist of nothing after the\n   \"scheme:\", as is present in practice with\
    \ the \"dav:\" namespace\n   [RFC2518] and with the \"about:\" scheme used internally\
    \ by many WWW\n   browser implementations.  The ambiguity regarding the boundary\n\
    \   between authority and path has been eliminated through the use of\n   five\
    \ separate path matching rules.\n   Registry-based naming authorities that use\
    \ the generic syntax are now\n   defined within the host rule.  This change allows\
    \ current\n   implementations, where whatever name provided is simply fed to the\n\
    \   local name resolution mechanism, to be consistent with the\n   specification.\
    \  It also removes the need to re-specify DNS name\n   formats here.  Furthermore,\
    \ it allows the host component to contain\n   percent-encoded octets, which is\
    \ necessary to enable\n   internationalized domain names to be provided in URIs,\
    \ processed in\n   their native character encodings at the application layers\
    \ above URI\n   processing, and passed to an IDNA library as a registered name\
    \ in the\n   UTF-8 character encoding.  The server, hostport, hostname,\n   domainlabel,\
    \ toplabel, and alphanum rules have been removed.\n   The resolving relative references\
    \ algorithm of [RFC2396] has been\n   rewritten with pseudocode for this revision\
    \ to improve clarity and\n   fix the following issues:\n   o  [RFC2396] section\
    \ 5.2, step 6a, failed to account for a base URI\n      with no path.\n   o  Restored\
    \ the behavior of [RFC1808] where, if the reference\n      contains an empty path\
    \ and a defined query component, the target\n      URI inherits the base URI's\
    \ path component.\n   o  The determination of whether a URI reference is a same-document\n\
    \      reference has been decoupled from the URI parser, simplifying the\n   \
    \   URI processing interface within applications in a way consistent\n      with\
    \ the internal architecture of deployed URI processing\n      implementations.\
    \  The determination is now based on comparison to\n      the base URI after transforming\
    \ a reference to absolute form,\n      rather than on the format of the reference\
    \ itself.  This change\n      may result in more references being considered \"\
    same-document\"\n      under this specification than there would be under the\
    \ rules given\n      in RFC 2396, especially when normalization is used to reduce\n\
    \      aliases.  However, it does not change the status of existing\n      same-document\
    \ references.\n   o  Separated the path merge routine into two routines: merge,\
    \ for\n      describing combination of the base URI path with a relative-path\n\
    \      reference, and remove_dot_segments, for describing how to remove\n    \
    \  the special \".\" and \"..\" segments from a composed path.  The\n      remove_dot_segments\
    \ algorithm is now applied to all URI reference\n      paths in order to match\
    \ common implementations and to improve the\n      normalization of URIs in practice.\
    \  This change only impacts the\n      parsing of abnormal references and same-scheme\
    \ references wherein\n      the base URI has a non-hierarchical path.\n"
- title: Index
  contents:
  - "Index\n   A\n      ABNF  11\n      absolute  27\n      absolute-path  26\n  \
    \    absolute-URI  27\n      access  9\n      authority  17, 18\n   B\n      base\
    \ URI  28\n   C\n      character encoding  4\n      character  4\n      characters\
    \  8, 11\n      coded character set  4\n   D\n      dec-octet  20\n      dereference\
    \  9\n      dot-segments  23\n   F\n      fragment  16, 24\n   G\n      gen-delims\
    \  13\n      generic syntax  6\n   H\n      h16  20\n      hier-part  16\n   \
    \   hierarchical  10\n      host  18\n   I\n      identifier  5\n      IP-literal\
    \  19\n      IPv4  20\n      IPv4address  19, 20\n      IPv6  19\n      IPv6address\
    \  19, 20\n      IPvFuture  19\n   L\n      locator  7\n      ls32  20\n   M\n\
    \      merge  32\n   N\n      name  7\n      network-path  26\n   P\n      path\
    \  16, 22, 26\n         path-abempty  22\n         path-absolute  22\n       \
    \  path-empty  22\n         path-noscheme  22\n         path-rootless  22\n  \
    \    path-abempty  16, 22, 26\n      path-absolute  16, 22, 26\n      path-empty\
    \  16, 22, 26\n      path-rootless  16, 22\n      pchar  23\n      pct-encoded\
    \  12\n      percent-encoding  12\n      port  22\n   Q\n      query  16, 23\n\
    \   R\n      reg-name  21\n      registered name  20\n      relative  10, 28\n\
    \      relative-path  26\n      relative-ref  26\n      remove_dot_segments  33\n\
    \      representation  9\n      reserved  12\n      resolution  9, 28\n      resource\
    \  5\n      retrieval  9\n   S\n      same-document  27\n      sameness  9\n \
    \     scheme  16, 17\n      segment  22, 23\n         segment-nz  23\n       \
    \  segment-nz-nc  23\n      sub-delims  13\n      suffix  27\n   T\n      transcription\
    \  8\n   U\n      uniform  4\n      unreserved  13\n      URI grammar\n      \
    \   absolute-URI  27\n         ALPHA  11\n         authority  18\n         CR\
    \  11\n         dec-octet  20\n         DIGIT  11\n         DQUOTE  11\n     \
    \    fragment  24\n         gen-delims  13\n         h16  20\n         HEXDIG\
    \  11\n         hier-part  16\n         host  19\n         IP-literal  19\n  \
    \       IPv4address  20\n         IPv6address  20\n         IPvFuture  19\n  \
    \       LF  11\n         ls32  20\n         OCTET  11\n         path  22\n   \
    \      path-abempty  22\n         path-absolute  22\n         path-empty  22\n\
    \         path-noscheme  22\n         path-rootless  22\n         pchar  23\n\
    \         pct-encoded  12\n         port  22\n         query  24\n         reg-name\
    \  21\n         relative-ref  26\n         reserved  13\n         scheme  17\n\
    \         segment  23\n         segment-nz  23\n         segment-nz-nc  23\n \
    \        SP  11\n         sub-delims  13\n         unreserved  13\n         URI\
    \  16\n         URI-reference  25\n         userinfo  18\n      URI  16\n    \
    \  URI-reference  25\n      URL  7\n      URN  7\n      userinfo  18\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Tim Berners-Lee\n   World Wide Web Consortium\n   Massachusetts\
    \ Institute of Technology\n   77 Massachusetts Avenue\n   Cambridge, MA  02139\n\
    \   USA\n   Phone: +1-617-253-5702\n   Fax:   +1-617-258-5999\n   EMail: timbl@w3.org\n\
    \   URI:   http://www.w3.org/People/Berners-Lee/\n   Roy T. Fielding\n   Day Software\n\
    \   5251 California Ave., Suite 110\n   Irvine, CA  92617\n   USA\n   Phone: +1-949-679-2960\n\
    \   Fax:   +1-949-679-2972\n   EMail: fielding@gbiv.com\n   URI:   http://roy.gbiv.com/\n\
    \   Larry Masinter\n   Adobe Systems Incorporated\n   345 Park Ave\n   San Jose,\
    \ CA  95110\n   USA\n   Phone: +1-408-536-3024\n   EMail: LMM@acm.org\n   URI:\
    \   http://larry.masinter.net/\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ IETF's procedures with respect to rights in IETF Documents can\n   be found\
    \ in BCP 78 and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat\
    \ and any\n   assurances of licenses to be made available, or the result of an\n\
    \   attempt made to obtain a general license or permission for the use of\n  \
    \ such proprietary rights by implementers or users of this\n   specification can\
    \ be obtained from the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n\
    \   The IETF invites any interested party to bring to its attention any\n   copyrights,\
    \ patents or patent applications, or other proprietary\n   rights that may cover\
    \ technology that may be required to implement\n   this standard.  Please address\
    \ the information to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
