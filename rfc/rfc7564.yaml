- title: __initial_text__
  contents:
  - "     PRECIS Framework: Preparation, Enforcement, and Comparison of\n        \
    \   Internationalized Strings in Application Protocols\n"
- title: Abstract
  contents:
  - "Abstract\n   Application protocols using Unicode characters in protocol strings\n\
    \   need to properly handle such strings in order to enforce\n   internationalization\
    \ rules for strings placed in various protocol\n   slots (such as addresses and\
    \ identifiers) and to perform valid\n   comparison operations (e.g., for purposes\
    \ of authentication or\n   authorization).  This document defines a framework\
    \ enabling\n   application protocols to perform the preparation, enforcement,\
    \ and\n   comparison of internationalized strings (\"PRECIS\") in a way that\n\
    \   depends on the properties of Unicode characters and thus is agile\n   with\
    \ respect to versions of Unicode.  As a result, this framework\n   provides a\
    \ more sustainable approach to the handling of\n   internationalized strings than\
    \ the previous framework, known as\n   Stringprep (RFC 3454).  This document obsoletes\
    \ RFC 3454.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7564.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Terminology .....................................................7\n  \
    \ 3. Preparation, Enforcement, and Comparison ........................7\n   4.\
    \ String Classes ..................................................8\n      4.1.\
    \ Overview ...................................................8\n      4.2. IdentifierClass\
    \ ............................................9\n           4.2.1. Valid ...............................................9\n\
    \           4.2.2. Contextual Rule Required ...........................10\n  \
    \         4.2.3. Disallowed .........................................10\n    \
    \       4.2.4. Unassigned .........................................11\n      \
    \     4.2.5. Examples ...........................................11\n      4.3.\
    \ FreeformClass .............................................11\n           4.3.1.\
    \ Valid ..............................................11\n           4.3.2. Contextual\
    \ Rule Required ...........................12\n           4.3.3. Disallowed .........................................12\n\
    \           4.3.4. Unassigned .........................................12\n  \
    \         4.3.5. Examples ...........................................12\n   5.\
    \ Profiles .......................................................13\n      5.1.\
    \ Profiles Must Not Be Multiplied beyond Necessity ..........13\n      5.2. Rules\
    \ .....................................................14\n           5.2.1. Width\
    \ Mapping Rule .................................14\n           5.2.2. Additional\
    \ Mapping Rule ............................14\n           5.2.3. Case Mapping\
    \ Rule ..................................14\n           5.2.4. Normalization Rule\
    \ .................................15\n           5.2.5. Directionality Rule ................................15\n\
    \      5.3. A Note about Spaces .......................................16\n  \
    \ 6. Applications ...................................................17\n    \
    \  6.1. How to Use PRECIS in Applications .........................17\n      6.2.\
    \ Further Excluded Characters ...............................18\n      6.3. Building\
    \ Application-Layer Constructs .....................18\n   7. Order of Operations\
    \ ............................................19\n   8. Code Point Properties\
    \ ..........................................20\n   9. Category Definitions Used\
    \ to Calculate Derived Property ........22\n      9.1. LetterDigits (A) ..........................................23\n\
    \      9.2. Unstable (B) ..............................................23\n  \
    \    9.3. IgnorableProperties (C) ...................................23\n    \
    \  9.4. IgnorableBlocks (D) .......................................23\n      9.5.\
    \ LDH (E) ...................................................23\n      9.6. Exceptions\
    \ (F) ............................................23\n      9.7. BackwardCompatible\
    \ (G) ....................................23\n      9.8. JoinControl (H) ...........................................24\n\
    \      9.9. OldHangulJamo (I) .........................................24\n  \
    \    9.10. Unassigned (J) ...........................................24\n    \
    \  9.11. ASCII7 (K) ...............................................24\n      9.12.\
    \ Controls (L) .............................................24\n      9.13. PrecisIgnorableProperties\
    \ (M) ............................24\n      9.14. Spaces (N) ...............................................25\n\
    \      9.15. Symbols (O) ..............................................25\n  \
    \    9.16. Punctuation (P) ..........................................25\n    \
    \  9.17. HasCompat (Q) ............................................25\n      9.18.\
    \ OtherLetterDigits (R) ....................................25\n   10. Guidelines\
    \ for Designated Experts .............................26\n   11. IANA Considerations\
    \ ...........................................27\n      11.1. PRECIS Derived Property\
    \ Value Registry ...................27\n      11.2. PRECIS Base Classes Registry\
    \ .............................27\n      11.3. PRECIS Profiles Registry .................................28\n\
    \   12. Security Considerations .......................................29\n  \
    \    12.1. General Issues ...........................................29\n    \
    \  12.2. Use of the IdentifierClass ...............................30\n      12.3.\
    \ Use of the FreeformClass .................................30\n      12.4. Local\
    \ Character Set Issues ...............................31\n      12.5. Visually\
    \ Similar Characters ..............................31\n      12.6. Security of\
    \ Passwords ....................................33\n   13. Interoperability Considerations\
    \ ...............................34\n      13.1. Encoding .................................................34\n\
    \      13.2. Character Sets ...........................................34\n  \
    \    13.3. Unicode Versions .........................................34\n    \
    \  13.4. Potential Changes to Handling of Certain Unicode\n            Code Points\
    \ ..............................................34\n   14. References ....................................................35\n\
    \      14.1. Normative References .....................................35\n  \
    \    14.2. Informative References ...................................36\n   Acknowledgements\
    \ ..................................................40\n   Authors' Addresses\
    \ ................................................40\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Application protocols using Unicode characters [Unicode]\
    \ in protocol\n   strings need to properly handle such strings in order to enforce\n\
    \   internationalization rules for strings placed in various protocol\n   slots\
    \ (such as addresses and identifiers) and to perform valid\n   comparison operations\
    \ (e.g., for purposes of authentication or\n   authorization).  This document\
    \ defines a framework enabling\n   application protocols to perform the preparation,\
    \ enforcement, and\n   comparison of internationalized strings (\"PRECIS\") in\
    \ a way that\n   depends on the properties of Unicode characters and thus is agile\n\
    \   with respect to versions of Unicode.\n   As described in the PRECIS problem\
    \ statement [RFC6885], many IETF\n   protocols have used the Stringprep framework\
    \ [RFC3454] as the basis\n   for preparing, enforcing, and comparing protocol\
    \ strings that contain\n   Unicode characters, especially characters outside the\
    \ ASCII range\n   [RFC20].  The Stringprep framework was developed during work\
    \ on the\n   original technology for internationalized domain names (IDNs), here\n\
    \   called \"IDNA2003\" [RFC3490], and Nameprep [RFC3491] was the\n   Stringprep\
    \ profile for IDNs.  At the time, Stringprep was designed as\n   a general framework\
    \ so that other application protocols could define\n   their own Stringprep profiles.\
    \  Indeed, a number of application\n   protocols defined such profiles.\n   After\
    \ the publication of [RFC3454] in 2002, several significant\n   issues arose with\
    \ the use of Stringprep in the IDN case, as\n   documented in the IAB's recommendations\
    \ regarding IDNs [RFC4690]\n   (most significantly, Stringprep was tied to Unicode\
    \ version 3.2).\n   Therefore, the newer IDNA specifications, here called \"IDNA2008\"\
    \n   ([RFC5890], [RFC5891], [RFC5892], [RFC5893], [RFC5894]), no longer\n   use\
    \ Stringprep and Nameprep.  This migration away from Stringprep for\n   IDNs prompted\
    \ other \"customers\" of Stringprep to consider new\n   approaches to the preparation,\
    \ enforcement, and comparison of\n   internationalized strings, as described in\
    \ [RFC6885].\n   This document defines a framework for a post-Stringprep approach\
    \ to\n   the preparation, enforcement, and comparison of internationalized\n \
    \  strings in application protocols, based on several principles:\n   1.  Define\
    \ a small set of string classes that specify the Unicode\n       characters (i.e.,\
    \ specific \"code points\") appropriate for common\n       application protocol\
    \ constructs.\n   2.  Define each PRECIS string class in terms of Unicode code\
    \ points\n       and their properties so that an algorithm can be used to\n  \
    \     determine whether each code point or character category is\n       (a) valid,\
    \ (b) allowed in certain contexts, (c) disallowed, or\n       (d) unassigned.\n\
    \   3.  Use an \"inclusion model\" such that a string class consists only\n  \
    \     of code points that are explicitly allowed, with the result that\n     \
    \  any code point not explicitly allowed is forbidden.\n   4.  Enable application\
    \ protocols to define profiles of the PRECIS\n       string classes if necessary\
    \ (addressing matters such as width\n       mapping, case mapping, Unicode normalization,\
    \ and directionality)\n       but strongly discourage the multiplication of profiles\
    \ beyond\n       necessity in order to avoid violations of the \"Principle of\
    \ Least\n       Astonishment\".\n   It is expected that this framework will yield\
    \ the following benefits:\n   o  Application protocols will be agile with regard\
    \ to Unicode\n      versions.\n   o  Implementers will be able to share code point\
    \ tables and software\n      code across application protocols, most likely by\
    \ means of\n      software libraries.\n   o  End users will be able to acquire\
    \ more accurate expectations about\n      the characters that are acceptable in\
    \ various contexts.  Given\n      this more uniform set of string classes, it\
    \ is also expected that\n      copy/paste operations between software implementing\
    \ different\n      application protocols will be more predictable and coherent.\n\
    \   Whereas the string classes define the \"baseline\" code points for a\n   range\
    \ of applications, profiling enables application protocols to\n   apply the string\
    \ classes in ways that are appropriate for common\n   constructs such as usernames\
    \ [PRECIS-Users-Pwds], opaque strings such\n   as passwords [PRECIS-Users-Pwds],\
    \ and nicknames [PRECIS-Nickname].\n   Profiles are responsible for defining the\
    \ handling of right-to-left\n   characters as well as various mapping operations\
    \ of the kind also\n   discussed for IDNs in [RFC5895], such as case preservation\
    \ or\n   lowercasing, Unicode normalization, mapping of certain characters to\n\
    \   other characters or to nothing, and mapping of fullwidth and\n   halfwidth\
    \ characters.\n   When an application applies a profile of a PRECIS string class,\
    \ it\n   transforms an input string (which might or might not be conforming)\n\
    \   into an output string that definitively conforms to the profile.  In\n   particular,\
    \ this document focuses on the resulting ability to achieve\n   the following\
    \ objectives:\n   a.  Enforcing all the rules of a profile for a single output\
    \ string\n       (e.g., to determine if a string can be included in a protocol\n\
    \       slot, communicated to another entity within a protocol, stored in\n  \
    \     a retrieval system, etc.).\n   b.  Comparing two output strings to determine\
    \ if they are equivalent,\n       typically through octet-for-octet matching to\
    \ test for\n       \"bit-string identity\" (e.g., to make an access decision for\n\
    \       purposes of authentication or authorization as further described\n   \
    \    in [RFC6943]).\n   The opportunity to define profiles naturally introduces\
    \ the\n   possibility of a proliferation of profiles, thus potentially\n   mitigating\
    \ the benefits of common code and violating user\n   expectations.  See Section\
    \ 5 for a discussion of this important\n   topic.\n   In addition, it is extremely\
    \ important for protocol designers and\n   application developers to understand\
    \ that the transformation of an\n   input string to an output string is rarely\
    \ reversible.  As one\n   relatively simple example, case mapping would transform\
    \ an input\n   string of \"StPeter\" to \"stpeter\", and information about the\n\
    \   capitalization of the first and third characters would be lost.\n   Similar\
    \ considerations apply to other forms of mapping and\n   normalization.\n   Although\
    \ this framework is similar to IDNA2008 and includes by\n   reference some of\
    \ the character categories defined in [RFC5892], it\n   defines additional character\
    \ categories to meet the needs of common\n   application protocols other than\
    \ DNS.\n   The character categories and calculation rules defined under\n   Sections\
    \ 8 and 9 are normative and apply to all Unicode code points.\n   The code point\
    \ table that results from applying the character\n   categories and calculation\
    \ rules to the latest version of Unicode can\n   be found in an IANA registry.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   Many important terms used in this document are defined in\
    \ [RFC5890],\n   [RFC6365], [RFC6885], and [Unicode].  The terms \"left-to-right\"\
    \ (LTR)\n   and \"right-to-left\" (RTL) are defined in Unicode Standard Annex\
    \ #9\n   [UAX9].\n   As of the date of writing, the version of Unicode published\
    \ by the\n   Unicode Consortium is 7.0 [Unicode7.0]; however, PRECIS is not tied\n\
    \   to a specific version of Unicode.  The latest version of Unicode is\n   always\
    \ available [Unicode].\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   [RFC2119].\n"
- title: 3.  Preparation, Enforcement, and Comparison
  contents:
  - "3.  Preparation, Enforcement, and Comparison\n   This document distinguishes\
    \ between three different actions that an\n   entity can take with regard to a\
    \ string:\n   o  Enforcement entails applying all of the rules specified for a\n\
    \      particular string class or profile thereof to an individual\n      string,\
    \ for the purpose of determining if the string can be used\n      in a given protocol\
    \ slot.\n   o  Comparison entails applying all of the rules specified for a\n\
    \      particular string class or profile thereof to two separate\n      strings,\
    \ for the purpose of determining if the two strings are\n      equivalent.\n \
    \  o  Preparation entails only ensuring that the characters in an\n      individual\
    \ string are allowed by the underlying PRECIS string\n      class.\n   In most\
    \ cases, authoritative entities such as servers are responsible\n   for enforcement,\
    \ whereas subsidiary entities such as clients are\n   responsible only for preparation.\
    \  The rationale for this distinction\n   is that clients might not have the facilities\
    \ (in terms of device\n   memory and processing power) to enforce all the rules\
    \ regarding\n   internationalized strings (such as width mapping and Unicode\n\
    \   normalization), although they can more easily limit the repertoire of\n  \
    \ characters they offer to an end user.  By contrast, it is assumed\n   that a\
    \ server would have more capacity to enforce the rules, and in\n   any case acts\
    \ as an authority regarding allowable strings in protocol\n   slots such as addresses\
    \ and endpoint identifiers.  In addition, a\n   client cannot necessarily be trusted\
    \ to properly generate such\n   strings, especially for security-sensitive contexts\
    \ such as\n   authentication and authorization.\n"
- title: 4.  String Classes
  contents:
  - '4.  String Classes

    '
- title: 4.1.  Overview
  contents:
  - "4.1.  Overview\n   Starting in 2010, various \"customers\" of Stringprep began\
    \ to discuss\n   the need to define a post-Stringprep approach to the preparation\
    \ and\n   comparison of internationalized strings other than IDNs.  This\n   community\
    \ analyzed the existing Stringprep profiles and also weighed\n   the costs and\
    \ benefits of defining a relatively small set of Unicode\n   characters that would\
    \ minimize the potential for user confusion\n   caused by visually similar characters\
    \ (and thus be relatively \"safe\")\n   vs. defining a much larger set of Unicode\
    \ characters that would\n   maximize the potential for user creativity (and thus\
    \ be relatively\n   \"expressive\").  As a result, the community concluded that\
    \ most\n   existing uses could be addressed by two string classes:\n   IdentifierClass:\
    \  a sequence of letters, numbers, and some symbols\n      that is used to identify\
    \ or address a network entity such as a\n      user account, a venue (e.g., a\
    \ chatroom), an information source\n      (e.g., a data feed), or a collection\
    \ of data (e.g., a file); the\n      intent is that this class will minimize user\
    \ confusion in a wide\n      variety of application protocols, with the result\
    \ that safety has\n      been prioritized over expressiveness for this class.\n\
    \   FreeformClass:  a sequence of letters, numbers, symbols, spaces, and\n   \
    \   other characters that is used for free-form strings, including\n      passwords\
    \ as well as display elements such as human-friendly\n      nicknames for devices\
    \ or for participants in a chatroom; the\n      intent is that this class will\
    \ allow nearly any Unicode character,\n      with the result that expressiveness\
    \ has been prioritized over\n      safety for this class.  Note well that protocol\
    \ designers,\n      application developers, service providers, and end users might\
    \ not\n      understand or be able to enter all of the characters that can be\n\
    \      included in the FreeformClass -- see Section 12.3 for details.\n   Future\
    \ specifications might define additional PRECIS string classes,\n   such as a\
    \ class that falls somewhere between the IdentifierClass and\n   the FreeformClass.\
    \  At this time, it is not clear how useful such a\n   class would be.  In any\
    \ case, because application developers are able\n   to define profiles of PRECIS\
    \ string classes, a protocol needing a\n   construct between the IdentifierClass\
    \ and the FreeformClass could\n   define a restricted profile of the FreeformClass\
    \ if needed.\n   The following subsections discuss the IdentifierClass and\n \
    \  FreeformClass in more detail, with reference to the dimensions\n   described\
    \ in Section 5 of [RFC6885].  Each string class is defined by\n   the following\
    \ behavioral rules:\n   Valid:  Defines which code points are treated as valid\
    \ for the\n      string.\n   Contextual Rule Required:  Defines which code points\
    \ are treated as\n      allowed only if the requirements of a contextual rule\
    \ are met\n      (i.e., either CONTEXTJ or CONTEXTO).\n   Disallowed:  Defines\
    \ which code points need to be excluded from the\n      string.\n   Unassigned:\
    \  Defines application behavior in the presence of code\n      points that are\
    \ unknown (i.e., not yet designated) for the version\n      of Unicode used by\
    \ the application.\n   This document defines the valid, contextual rule required,\n\
    \   disallowed, and unassigned rules for the IdentifierClass and\n   FreeformClass.\
    \  As described under Section 5, profiles of these\n   string classes are responsible\
    \ for defining the width mapping,\n   additional mappings, case mapping, normalization,\
    \ and directionality\n   rules.\n"
- title: 4.2.  IdentifierClass
  contents:
  - "4.2.  IdentifierClass\n   Most application technologies need strings that can\
    \ be used to refer\n   to, include, or communicate protocol strings like usernames,\n\
    \   filenames, data feed identifiers, and chatroom names.  We group such\n   strings\
    \ into a class called \"IdentifierClass\" having the following\n   features.\n"
- title: 4.2.1.  Valid
  contents:
  - "4.2.1.  Valid\n   o  Code points traditionally used as letters and numbers in\
    \ writing\n      systems, i.e., the LetterDigits (\"A\") category first defined\
    \ in\n      [RFC5892] and listed here under Section 9.1.\n   o  Code points in\
    \ the range U+0021 through U+007E, i.e., the\n      (printable) ASCII7 (\"K\"\
    ) category defined under Section 9.11.\n      These code points are \"grandfathered\"\
    \ into PRECIS and thus are\n      valid even if they would otherwise be disallowed\
    \ according to the\n      property-based rules specified in the next section.\n\
    \      Note: Although the PRECIS IdentifierClass reuses the LetterDigits\n   \
    \   category from IDNA2008, the range of characters allowed in the\n      IdentifierClass\
    \ is wider than the range of characters allowed in\n      IDNA2008.  The main\
    \ reason is that IDNA2008 applies the Unstable\n      category before the LetterDigits\
    \ category, thus disallowing\n      uppercase characters, whereas the IdentifierClass\
    \ does not apply\n      the Unstable category.\n"
- title: 4.2.2.  Contextual Rule Required
  contents:
  - "4.2.2.  Contextual Rule Required\n   o  A number of characters from the Exceptions\
    \ (\"F\") category defined\n      under Section 9.6 (see Section 9.6 for a full\
    \ list).\n   o  Joining characters, i.e., the JoinControl (\"H\") category defined\n\
    \      under Section 9.8.\n"
- title: 4.2.3.  Disallowed
  contents:
  - "4.2.3.  Disallowed\n   o  Old Hangul Jamo characters, i.e., the OldHangulJamo\
    \ (\"I\") category\n      defined under Section 9.9.\n   o  Control characters,\
    \ i.e., the Controls (\"L\") category defined\n      under Section 9.12.\n   o\
    \  Ignorable characters, i.e., the PrecisIgnorableProperties (\"M\")\n      category\
    \ defined under Section 9.13.\n   o  Space characters, i.e., the Spaces (\"N\"\
    ) category defined under\n      Section 9.14.\n   o  Symbol characters, i.e.,\
    \ the Symbols (\"O\") category defined under\n      Section 9.15.\n   o  Punctuation\
    \ characters, i.e., the Punctuation (\"P\") category\n      defined under Section\
    \ 9.16.\n   o  Any character that has a compatibility equivalent, i.e., the\n\
    \      HasCompat (\"Q\") category defined under Section 9.17.  These code\n  \
    \    points are disallowed even if they would otherwise be valid\n      according\
    \ to the property-based rules specified in the previous\n      section.\n   o\
    \  Letters and digits other than the \"traditional\" letters and digits\n    \
    \  allowed in IDNs, i.e., the OtherLetterDigits (\"R\") category\n      defined\
    \ under Section 9.18.\n"
- title: 4.2.4.  Unassigned
  contents:
  - "4.2.4.  Unassigned\n   Any code points that are not yet designated in the Unicode\
    \ character\n   set are considered unassigned for purposes of the IdentifierClass,\n\
    \   and such code points are to be treated as disallowed.  See\n   Section 9.10.\n"
- title: 4.2.5.  Examples
  contents:
  - "4.2.5.  Examples\n   As described in the Introduction to this document, the string\
    \ classes\n   do not handle all issues related to string preparation and comparison\n\
    \   (such as case mapping); instead, such issues are handled at the level\n  \
    \ of profiles.  Examples for profiles of the IdentifierClass can be\n   found\
    \ in [PRECIS-Users-Pwds] (the UsernameCaseMapped and\n   UsernameCasePreserved\
    \ profiles).\n"
- title: 4.3.  FreeformClass
  contents:
  - "4.3.  FreeformClass\n   Some application technologies need strings that can be\
    \ used in a\n   free-form way, e.g., as a password in an authentication exchange\
    \ (see\n   [PRECIS-Users-Pwds]) or a nickname in a chatroom (see\n   [PRECIS-Nickname]).\
    \  We group such things into a class called\n   \"FreeformClass\" having the following\
    \ features.\n      Security Warning: As mentioned, the FreeformClass prioritizes\n\
    \      expressiveness over safety; Section 12.3 describes some of the\n      security\
    \ hazards involved with using or profiling the\n      FreeformClass.\n      Security\
    \ Warning: Consult Section 12.6 for relevant security\n      considerations when\
    \ strings conforming to the FreeformClass, or a\n      profile thereof, are used\
    \ as passwords.\n"
- title: 4.3.1.  Valid
  contents:
  - "4.3.1.  Valid\n   o  Traditional letters and numbers, i.e., the LetterDigits\
    \ (\"A\")\n      category first defined in [RFC5892] and listed here under\n \
    \     Section 9.1.\n   o  Letters and digits other than the \"traditional\" letters\
    \ and digits\n      allowed in IDNs, i.e., the OtherLetterDigits (\"R\") category\n\
    \      defined under Section 9.18.\n   o  Code points in the range U+0021 through\
    \ U+007E, i.e., the\n      (printable) ASCII7 (\"K\") category defined under Section\
    \ 9.11.\n   o  Any character that has a compatibility equivalent, i.e., the\n\
    \      HasCompat (\"Q\") category defined under Section 9.17.\n   o  Space characters,\
    \ i.e., the Spaces (\"N\") category defined under\n      Section 9.14.\n   o \
    \ Symbol characters, i.e., the Symbols (\"O\") category defined under\n      Section\
    \ 9.15.\n   o  Punctuation characters, i.e., the Punctuation (\"P\") category\n\
    \      defined under Section 9.16.\n"
- title: 4.3.2.  Contextual Rule Required
  contents:
  - "4.3.2.  Contextual Rule Required\n   o  A number of characters from the Exceptions\
    \ (\"F\") category defined\n      under Section 9.6 (see Section 9.6 for a full\
    \ list).\n   o  Joining characters, i.e., the JoinControl (\"H\") category defined\n\
    \      under Section 9.8.\n"
- title: 4.3.3.  Disallowed
  contents:
  - "4.3.3.  Disallowed\n   o  Old Hangul Jamo characters, i.e., the OldHangulJamo\
    \ (\"I\") category\n      defined under Section 9.9.\n   o  Control characters,\
    \ i.e., the Controls (\"L\") category defined\n      under Section 9.12.\n   o\
    \  Ignorable characters, i.e., the PrecisIgnorableProperties (\"M\")\n      category\
    \ defined under Section 9.13.\n"
- title: 4.3.4.  Unassigned
  contents:
  - "4.3.4.  Unassigned\n   Any code points that are not yet designated in the Unicode\
    \ character\n   set are considered unassigned for purposes of the FreeformClass,\
    \ and\n   such code points are to be treated as disallowed.\n"
- title: 4.3.5.  Examples
  contents:
  - "4.3.5.  Examples\n   As described in the Introduction to this document, the string\
    \ classes\n   do not handle all issues related to string preparation and comparison\n\
    \   (such as case mapping); instead, such issues are handled at the level\n  \
    \ of profiles.  Examples for profiles of the FreeformClass can be found\n   in\
    \ [PRECIS-Users-Pwds] (the OpaqueString profile) and\n   [PRECIS-Nickname] (the\
    \ Nickname profile).\n"
- title: 5.  Profiles
  contents:
  - "5.  Profiles\n   This framework document defines the valid, contextual-rule-required,\n\
    \   disallowed, and unassigned rules for the IdentifierClass and the\n   FreeformClass.\
    \  A profile of a PRECIS string class MUST define the\n   width mapping, additional\
    \ mappings (if any), case mapping,\n   normalization, and directionality rules.\
    \  A profile MAY also restrict\n   the allowable characters above and beyond the\
    \ definition of the\n   relevant PRECIS string class (but MUST NOT add as valid\
    \ any code\n   points that are disallowed by the relevant PRECIS string class).\n\
    \   These matters are discussed in the following subsections.\n   Profiles of\
    \ the PRECIS string classes are registered with the IANA as\n   described under\
    \ Section 11.3.  Profile names use the following\n   convention: they are of the\
    \ form \"Profilename of BaseClass\", where\n   the \"Profilename\" string is a\
    \ differentiator and \"BaseClass\" is the\n   name of the PRECIS string class\
    \ being profiled; for example, the\n   profile of the FreeformClass used for opaque\
    \ strings such as\n   passwords is the OpaqueString profile [PRECIS-Users-Pwds].\n"
- title: 5.1.  Profiles Must Not Be Multiplied beyond Necessity
  contents:
  - "5.1.  Profiles Must Not Be Multiplied beyond Necessity\n   The risk of profile\
    \ proliferation is significant because having too\n   many profiles will result\
    \ in different behavior across various\n   applications, thus violating what is\
    \ known in user interface design\n   as the \"Principle of Least Astonishment\"\
    .\n   Indeed, we already have too many profiles.  Ideally we would have at\n \
    \  most two or three profiles.  Unfortunately, numerous application\n   protocols\
    \ exist with their own quirks regarding protocol strings.\n   Domain names, email\
    \ addresses, instant messaging addresses, chatroom\n   nicknames, filenames, authentication\
    \ identifiers, passwords, and\n   other strings are already out there in the wild\
    \ and need to be\n   supported in existing application protocols such as DNS,\
    \ SMTP, the\n   Extensible Messaging and Presence Protocol (XMPP), Internet Relay\n\
    \   Chat (IRC), NFS, the Internet Small Computer System Interface\n   (iSCSI),\
    \ the Extensible Authentication Protocol (EAP), and the Simple\n   Authentication\
    \ and Security Layer (SASL), among others.\n   Nevertheless, profiles must not\
    \ be multiplied beyond necessity.\n   To help prevent profile proliferation, this\
    \ document recommends\n   sensible defaults for the various options offered to\
    \ profile creators\n   (such as width mapping and Unicode normalization).  In\
    \ addition, the\n   guidelines for designated experts provided under Section 10\
    \ are meant\n   to encourage a high level of due diligence regarding new profiles.\n"
- title: 5.2.  Rules
  contents:
  - '5.2.  Rules

    '
- title: 5.2.1.  Width Mapping Rule
  contents:
  - "5.2.1.  Width Mapping Rule\n   The width mapping rule of a profile specifies\
    \ whether width mapping\n   is performed on the characters of a string, and how\
    \ the mapping is\n   done.  Typically, such mapping consists of mapping fullwidth\
    \ and\n   halfwidth characters, i.e., code points with a Decomposition Type of\n\
    \   Wide or Narrow, to their decomposition mappings; as an example,\n   FULLWIDTH\
    \ DIGIT ZERO (U+FF10) would be mapped to DIGIT ZERO (U+0030).\n   The normalization\
    \ form specified by a profile (see below) has an\n   impact on the need for width\
    \ mapping.  Because width mapping is\n   performed as a part of compatibility\
    \ decomposition, a profile\n   employing either normalization form KD (NFKD) or\
    \ normalization form\n   KC (NFKC) does not need to specify width mapping.  However,\
    \ if\n   Unicode normalization form C (NFC) is used (as is recommended) then\n\
    \   the profile needs to specify whether to apply width mapping; in this\n   case,\
    \ width mapping is in general RECOMMENDED because allowing\n   fullwidth and halfwidth\
    \ characters to remain unmapped to their\n   compatibility variants would violate\
    \ the \"Principle of Least\n   Astonishment\".  For more information about the\
    \ concept of width in\n   East Asian scripts within Unicode, see Unicode Standard\
    \ Annex #11\n   [UAX11].\n"
- title: 5.2.2.  Additional Mapping Rule
  contents:
  - "5.2.2.  Additional Mapping Rule\n   The additional mapping rule of a profile\
    \ specifies whether additional\n   mappings are performed on the characters of\
    \ a string, such as:\n      Mapping of delimiter characters (such as '@', ':',\
    \ '/', '+',\n      and '-')\n      Mapping of special characters (e.g., non-ASCII\
    \ space characters to\n      ASCII space or control characters to nothing).\n\
    \   The PRECIS mappings document [PRECIS-Mappings] describes such\n   mappings\
    \ in more detail.\n"
- title: 5.2.3.  Case Mapping Rule
  contents:
  - "5.2.3.  Case Mapping Rule\n   The case mapping rule of a profile specifies whether\
    \ case mapping\n   (instead of case preservation) is performed on the characters\
    \ of a\n   string, and how the mapping is applied (e.g., mapping uppercase and\n\
    \   titlecase characters to their lowercase equivalents).\n   If case mapping\
    \ is desired (instead of case preservation), it is\n   RECOMMENDED to use Unicode\
    \ Default Case Folding as defined in the\n   Unicode Standard [Unicode] (at the\
    \ time of this writing, the\n   algorithm is specified in Chapter 3 of [Unicode7.0]).\n\
    \      Note: Unicode Default Case Folding is not designed to handle\n      various\
    \ localization issues (such as so-called \"dotless i\" in\n      several Turkic\
    \ languages).  The PRECIS mappings document\n      [PRECIS-Mappings] describes\
    \ these issues in greater detail and\n      defines a \"local case mapping\" method\
    \ that handles some locale-\n      dependent and context-dependent mappings.\n\
    \   In order to maximize entropy and minimize the potential for false\n   positives,\
    \ it is NOT RECOMMENDED for application protocols to map\n   uppercase and titlecase\
    \ code points to their lowercase equivalents\n   when strings conforming to the\
    \ FreeformClass, or a profile thereof,\n   are used in passwords; instead, it\
    \ is RECOMMENDED to preserve the\n   case of all code points contained in such\
    \ strings and then perform\n   case-sensitive comparison.  See also the related\
    \ discussion in\n   Section 12.6 and in [PRECIS-Users-Pwds].\n"
- title: 5.2.4.  Normalization Rule
  contents:
  - "5.2.4.  Normalization Rule\n   The normalization rule of a profile specifies\
    \ which Unicode\n   normalization form (D, KD, C, or KC) is to be applied (see\
    \ Unicode\n   Standard Annex #15 [UAX15] for background information).\n   In accordance\
    \ with [RFC5198], normalization form C (NFC) is\n   RECOMMENDED.\n"
- title: 5.2.5.  Directionality Rule
  contents:
  - "5.2.5.  Directionality Rule\n   The directionality rule of a profile specifies\
    \ how to treat strings\n   containing what are often called \"right-to-left\"\
    \ (RTL) characters\n   (see Unicode Standard Annex #9 [UAX9]).  RTL characters\
    \ come from\n   scripts that are normally written from right to left and are\n\
    \   considered by Unicode to, themselves, have right-to-left\n   directionality.\
    \  Some strings containing RTL characters also contain\n   \"left-to-right\" (LTR)\
    \ characters, such as numerals, as well as\n   characters without directional\
    \ properties.  Consequently, such\n   strings are known as \"bidirectional strings\"\
    .\n   Presenting bidirectional strings in different layout systems (e.g., a\n\
    \   user interface that is configured to handle primarily an RTL script\n   vs.\
    \ an interface that is configured to handle primarily an LTR\n   script) can yield\
    \ display results that, while predictable to those\n   who understand the display\
    \ rules, are counter-intuitive to casual\n   users.  In particular, the same bidirectional\
    \ string (in PRECIS\n   terms) might not be presented in the same way to users\
    \ of those\n   different layout systems, even though the presentation is consistent\n\
    \   within any particular layout system.  In some applications, these\n   presentation\
    \ differences might be considered problematic and thus the\n   application designers\
    \ might wish to restrict the use of bidirectional\n   strings by specifying a\
    \ directionality rule.  In other applications,\n   these presentation differences\
    \ might not be considered problematic\n   (this especially tends to be true of\
    \ more \"free-form\" strings) and\n   thus no directionality rule is needed.\n\
    \   The PRECIS framework does not directly address how to deal with\n   bidirectional\
    \ strings across all string classes and profiles, and\n   does not define any\
    \ new directionality rules, since at present there\n   is no widely accepted and\
    \ implemented solution for the safe display\n   of arbitrary bidirectional strings\
    \ beyond the Unicode bidirectional\n   algorithm [UAX9].  Although rules for management\
    \ and display of\n   bidirectional strings have been defined for domain name labels\
    \ and\n   similar identifiers through the \"Bidi Rule\" specified in the IDNA2008\n\
    \   specification on right-to-left scripts [RFC5893], those rules are\n   quite\
    \ restrictive and are not necessarily applicable to all\n   bidirectional strings.\n\
    \   The authors of a PRECIS profile might believe that they need to\n   define\
    \ a new directionality rule of their own.  Because of the\n   complexity of the\
    \ issues involved, such a belief is almost always\n   misguided, even if the authors\
    \ have done a great deal of careful\n   research into the challenges of displaying\
    \ bidirectional strings.\n   This document strongly suggests that profile authors\
    \ who are thinking\n   about defining a new directionality rule think again, and\
    \ instead\n   consider using the \"Bidi Rule\" [RFC5893] (for profiles based on\
    \ the\n   IdentifierClass) or following the Unicode bidirectional algorithm\n\
    \   [UAX9] (for profiles based on the FreeformClass or in situations\n   where\
    \ the IdentifierClass is not appropriate).\n"
- title: 5.3.  A Note about Spaces
  contents:
  - "5.3.  A Note about Spaces\n   With regard to the IdentifierClass, the consensus\
    \ of the PRECIS\n   Working Group was that spaces are problematic for many reasons,\n\
    \   including the following:\n   o  Many Unicode characters are confusable with\
    \ ASCII space.\n   o  Even if non-ASCII space characters are mapped to ASCII space\n\
    \      (U+0020), space characters are often not rendered in user\n      interfaces,\
    \ leading to the possibility that a human user might\n      consider a string\
    \ containing spaces to be equivalent to the same\n      string without spaces.\n\
    \   o  In some locales, some devices are known to generate a character\n     \
    \ other than ASCII space (such as ZERO WIDTH JOINER, U+200D) when a\n      user\
    \ performs an action like hitting the space bar on a keyboard.\n   One consequence\
    \ of disallowing space characters in the\n   IdentifierClass might be to effectively\
    \ discourage their use within\n   identifiers created in newer application protocols;\
    \ given the\n   challenges involved with properly handling space characters\n\
    \   (especially non-ASCII space characters) in identifiers and other\n   protocol\
    \ strings, the PRECIS Working Group considered this to be a\n   feature, not a\
    \ bug.\n   However, the FreeformClass does allow spaces, which enables\n   application\
    \ protocols to define profiles of the FreeformClass that\n   are more flexible\
    \ than any profiles of the IdentifierClass.  In\n   addition, as explained in\
    \ Section 6.3, application protocols can also\n   define application-layer constructs\
    \ containing spaces.\n"
- title: 6.  Applications
  contents:
  - '6.  Applications

    '
- title: 6.1.  How to Use PRECIS in Applications
  contents:
  - "6.1.  How to Use PRECIS in Applications\n   Although PRECIS has been designed\
    \ with applications in mind,\n   internationalization is not suddenly made easy\
    \ through the use of\n   PRECIS.  Application developers still need to give some\
    \ thought to\n   how they will use the PRECIS string classes, or profiles thereof,\
    \ in\n   their applications.  This section provides some guidelines to\n   application\
    \ developers (and to expert reviewers of application\n   protocol specifications).\n\
    \   o  Don't define your own profile unless absolutely necessary (see\n      Section\
    \ 5.1).  Existing profiles have been designed for wide\n      reuse.  It is highly\
    \ likely that an existing profile will meet\n      your needs, especially given\
    \ the ability to specify further\n      excluded characters (Section 6.2) and\
    \ to build application-layer\n      constructs (see Section 6.3).\n   o  Do specify:\n\
    \      *  Exactly which entities are responsible for preparation,\n         enforcement,\
    \ and comparison of internationalized strings (e.g.,\n         servers or clients).\n\
    \      *  Exactly when those entities need to complete their tasks (e.g.,\n  \
    \       a server might need to enforce the rules of a profile before\n       \
    \  allowing a client to gain network access).\n      *  Exactly which protocol\
    \ slots need to be checked against which\n         profiles (e.g., checking the\
    \ address of a message's intended\n         recipient against the UsernameCaseMapped\
    \ profile\n         [PRECIS-Users-Pwds] of the IdentifierClass, or checking the\n\
    \         password of a user against the OpaqueString profile\n         [PRECIS-Users-Pwds]\
    \ of the FreeformClass).\n      See [PRECIS-Users-Pwds] and [XMPP-Addr-Format]\
    \ for definitions of\n      these matters for several applications.\n"
- title: 6.2.  Further Excluded Characters
  contents:
  - "6.2.  Further Excluded Characters\n   An application protocol that uses a profile\
    \ MAY specify particular\n   code points that are not allowed in relevant slots\
    \ within that\n   application protocol, above and beyond those excluded by the\
    \ string\n   class or profile.\n   That is, an application protocol MAY do either\
    \ of the following:\n   1.  Exclude specific code points that are allowed by the\
    \ relevant\n       string class.\n   2.  Exclude characters matching certain Unicode\
    \ properties (e.g.,\n       math symbols) that are included in the relevant PRECIS\
    \ string\n       class.\n   As a result of such exclusions, code points that are\
    \ defined as valid\n   for the PRECIS string class or profile will be defined\
    \ as disallowed\n   for the relevant protocol slot.\n   Typically, such exclusions\
    \ are defined for the purpose of backward\n   compatibility with legacy formats\
    \ within an application protocol.\n   These are defined for application protocols,\
    \ not profiles, in order\n   to prevent multiplication of profiles beyond necessity\
    \ (see\n   Section 5.1).\n"
- title: 6.3.  Building Application-Layer Constructs
  contents:
  - "6.3.  Building Application-Layer Constructs\n   Sometimes, an application-layer\
    \ construct does not map in a\n   straightforward manner to one of the base string\
    \ classes or a profile\n   thereof.  Consider, for example, the \"simple user\
    \ name\" construct in\n   the Simple Authentication and Security Layer (SASL)\
    \ [RFC4422].\n   Depending on the deployment, a simple user name might take the\
    \ form\n   of a user's full name (e.g., the user's personal name followed by a\n\
    \   space and then the user's family name).  Such a simple user name\n   cannot\
    \ be defined as an instance of the IdentifierClass or a profile\n   thereof, since\
    \ space characters are not allowed in the\n   IdentifierClass; however, it could\
    \ be defined using a space-separated\n   sequence of IdentifierClass instances,\
    \ as in the following ABNF\n   [RFC5234] from [PRECIS-Users-Pwds]:\n      username\
    \   = userpart *(1*SP userpart)\n      userpart   = 1*(idbyte)\n             \
    \      ;\n                   ; an \"idbyte\" is a byte used to represent a\n \
    \                  ; UTF-8 encoded Unicode code point that can be\n          \
    \         ; contained in a string that conforms to the\n                   ; PRECIS\
    \ \"IdentifierClass\"\n                   ;\n   Similar techniques could be used\
    \ to define many application-layer\n   constructs, say of the form \"user@domain\"\
    \ or \"/path/to/file\".\n"
- title: 7.  Order of Operations
  contents:
  - "7.  Order of Operations\n   To ensure proper comparison, the rules specified\
    \ for a particular\n   string class or profile MUST be applied in the following\
    \ order:\n   1.  Width Mapping Rule\n   2.  Additional Mapping Rule\n   3.  Case\
    \ Mapping Rule\n   4.  Normalization Rule\n   5.  Directionality Rule\n   6. \
    \ Behavioral rules for determining whether a code point is valid,\n       allowed\
    \ under a contextual rule, disallowed, or unassigned\n   As already described,\
    \ the width mapping, additional mapping, case\n   mapping, normalization, and\
    \ directionality rules are specified for\n   each profile, whereas the behavioral\
    \ rules are specified for each\n   string class.  Some of the logic behind this\
    \ order is provided under\n   Section 5.2.1 (see also the PRECIS mappings document\n\
    \   [PRECIS-Mappings]).\n"
- title: 8.  Code Point Properties
  contents:
  - "8.  Code Point Properties\n   In order to implement the string classes described\
    \ above, this\n   document does the following:\n   1.  Reviews and classifies\
    \ the collections of code points in the\n       Unicode character set by examining\
    \ various code point properties.\n   2.  Defines an algorithm for determining\
    \ a derived property value,\n       which can vary depending on the string class\
    \ being used by the\n       relevant application protocol.\n   This document is\
    \ not intended to specify precisely how derived\n   property values are to be\
    \ applied in protocol strings.  That\n   information is the responsibility of\
    \ the protocol specification that\n   uses or profiles a PRECIS string class from\
    \ this document.  The value\n   of the property is to be interpreted as follows.\n\
    \   PROTOCOL VALID  Those code points that are allowed to be used in any\n   \
    \   PRECIS string class (currently, IdentifierClass and\n      FreeformClass).\
    \  The abbreviated term \"PVALID\" is used to refer to\n      this value in the\
    \ remainder of this document.\n   SPECIFIC CLASS PROTOCOL VALID  Those code points\
    \ that are allowed to\n      be used in specific string classes.  In the remainder\
    \ of this\n      document, the abbreviated term *_PVAL is used, where * = (ID\
    \ |\n      FREE), i.e., either \"FREE_PVAL\" or \"ID_PVAL\".  In practice, the\n\
    \      derived property ID_PVAL is not used in this specification, since\n   \
    \   every ID_PVAL code point is PVALID.\n   CONTEXTUAL RULE REQUIRED  Some characteristics\
    \ of the character, such\n      as its being invisible in certain contexts or\
    \ problematic in\n      others, require that it not be used in labels unless specific\n\
    \      other characters or properties are present.  As in IDNA2008, there\n  \
    \    are two subdivisions of CONTEXTUAL RULE REQUIRED -- the first for\n     \
    \ Join_controls (called \"CONTEXTJ\") and the second for other\n      characters\
    \ (called \"CONTEXTO\").  A character with the derived\n      property value CONTEXTJ\
    \ or CONTEXTO MUST NOT be used unless an\n      appropriate rule has been established\
    \ and the context of the\n      character is consistent with that rule.  The most\
    \ notable of the\n      CONTEXTUAL RULE REQUIRED characters are the Join Control\n\
    \      characters U+200D ZERO WIDTH JOINER and U+200C ZERO WIDTH\n      NON-JOINER,\
    \ which have a derived property value of CONTEXTJ.  See\n      Appendix A of [RFC5892]\
    \ for more information.\n   DISALLOWED  Those code points that are not permitted\
    \ in any PRECIS\n      string class.\n   SPECIFIC CLASS DISALLOWED  Those code\
    \ points that are not to be\n      included in one of the string classes but that\
    \ might be permitted\n      in others.  In the remainder of this document, the\
    \ abbreviated\n      term *_DIS is used, where * = (ID | FREE), i.e., either \"\
    FREE_DIS\"\n      or \"ID_DIS\".  In practice, the derived property FREE_DIS is\
    \ not\n      used in this specification, since every FREE_DIS code point is\n\
    \      DISALLOWED.\n   UNASSIGNED  Those code points that are not designated (i.e.,\
    \ are\n      unassigned) in the Unicode Standard.\n   The algorithm to calculate\
    \ the value of the derived property is as\n   follows (implementations MUST NOT\
    \ modify the order of operations\n   within this algorithm, since doing so would\
    \ cause inconsistent\n   results across implementations):\n   If .cp. .in. Exceptions\
    \ Then Exceptions(cp);\n   Else If .cp. .in. BackwardCompatible Then BackwardCompatible(cp);\n\
    \   Else If .cp. .in. Unassigned Then UNASSIGNED;\n   Else If .cp. .in. ASCII7\
    \ Then PVALID;\n   Else If .cp. .in. JoinControl Then CONTEXTJ;\n   Else If .cp.\
    \ .in. OldHangulJamo Then DISALLOWED;\n   Else If .cp. .in. PrecisIgnorableProperties\
    \ Then DISALLOWED;\n   Else If .cp. .in. Controls Then DISALLOWED;\n   Else If\
    \ .cp. .in. HasCompat Then ID_DIS or FREE_PVAL;\n   Else If .cp. .in. LetterDigits\
    \ Then PVALID;\n   Else If .cp. .in. OtherLetterDigits Then ID_DIS or FREE_PVAL;\n\
    \   Else If .cp. .in. Spaces Then ID_DIS or FREE_PVAL;\n   Else If .cp. .in. Symbols\
    \ Then ID_DIS or FREE_PVAL;\n   Else If .cp. .in. Punctuation Then ID_DIS or FREE_PVAL;\n\
    \   Else DISALLOWED;\n   The value of the derived property calculated can depend\
    \ on the string\n   class; for example, if an identifier used in an application\
    \ protocol\n   is defined as profiling the PRECIS IdentifierClass then a space\n\
    \   character such as U+0020 would be assigned to ID_DIS, whereas if an\n   identifier\
    \ is defined as profiling the PRECIS FreeformClass then the\n   character would\
    \ be assigned to FREE_PVAL.  For the sake of brevity,\n   the designation \"FREE_PVAL\"\
    \ is used herein, instead of the longer\n   designation \"ID_DIS or FREE_PVAL\"\
    .  In practice, the derived\n   properties ID_PVAL and FREE_DIS are not used in\
    \ this specification,\n   since every ID_PVAL code point is PVALID and every FREE_DIS\
    \ code\n   point is DISALLOWED.\n   Use of the name of a rule (such as \"Exceptions\"\
    ) implies the set of\n   code points that the rule defines, whereas the same name\
    \ as a\n   function call (such as \"Exceptions(cp)\") implies the value that the\n\
    \   code point has in the Exceptions table.\n   The mechanisms described here\
    \ allow determination of the value of the\n   property for future versions of\
    \ Unicode (including characters added\n   after Unicode 5.2 or 7.0 depending on\
    \ the category, since some\n   categories mentioned in this document are simply\
    \ pointers to IDNA2008\n   and therefore were defined at the time of Unicode 5.2).\
    \  Changes in\n   Unicode properties that do not affect the outcome of this process\n\
    \   therefore do not affect this framework.  For example, a character can\n  \
    \ have its Unicode General_Category value (at the time of this writing,\n   see\
    \ Chapter 4 of [Unicode7.0]) change from So to Sm, or from Lo to\n   Ll, without\
    \ affecting the algorithm results.  Moreover, even if such\n   changes were to\
    \ result, the BackwardCompatible list (Section 9.7) can\n   be adjusted to ensure\
    \ the stability of the results.\n"
- title: 9.  Category Definitions Used to Calculate Derived Property
  contents:
  - "9.  Category Definitions Used to Calculate Derived Property\n   The derived property\
    \ obtains its value based on a two-step procedure:\n   1.  Characters are placed\
    \ in one or more character categories either\n       (1) based on core properties\
    \ defined by the Unicode Standard or\n       (2) by treating the code point as\
    \ an exception and addressing the\n       code point based on its code point value.\
    \  These categories are\n       not mutually exclusive.\n   2.  Set operations\
    \ are used with these categories to determine the\n       values for a property\
    \ specific to a given string class.  These\n       operations are specified under\
    \ Section 8.\n      Note: Unicode property names and property value names might\
    \ have\n      short abbreviations, such as \"gc\" for the General_Category\n \
    \     property and \"Ll\" for the Lowercase_Letter property value of the\n   \
    \   gc property.\n   In the following specification of character categories, the\
    \ operation\n   that returns the value of a particular Unicode character property\
    \ for\n   a code point is designated by using the formal name of that property\n\
    \   (from the Unicode PropertyAliases.txt file [PropertyAliases] followed\n  \
    \ by \"(cp)\" for \"code point\".  For example, the value of the\n   General_Category\
    \ property for a code point is indicated by\n   General_Category(cp).\n   The\
    \ first ten categories (A-J) shown below were previously defined\n   for IDNA2008\
    \ and are referenced from [RFC5892] to ease the\n   understanding of how PRECIS\
    \ handles various characters.  Some of\n   these categories are reused in PRECIS,\
    \ and some of them are not;\n   however, the lettering of categories is retained\
    \ to prevent overlap\n   and to ease implementation of both IDNA2008 and PRECIS\
    \ in a single\n   software application.  The next eight categories (K-R) are specific\n\
    \   to PRECIS.\n"
- title: 9.1.  LetterDigits (A)
  contents:
  - "9.1.  LetterDigits (A)\n   This category is defined in Section 2.1 of [RFC5892]\
    \ and is included\n   by reference for use in PRECIS.\n"
- title: 9.2.  Unstable (B)
  contents:
  - "9.2.  Unstable (B)\n   This category is defined in Section 2.2 of [RFC5892].\
    \  However, it is\n   not used in PRECIS.\n"
- title: 9.3.  IgnorableProperties (C)
  contents:
  - "9.3.  IgnorableProperties (C)\n   This category is defined in Section 2.3 of\
    \ [RFC5892].  However, it is\n   not used in PRECIS.\n   Note: See the PrecisIgnorableProperties\
    \ (\"M\") category below for a\n   more inclusive category used in PRECIS identifiers.\n"
- title: 9.4.  IgnorableBlocks (D)
  contents:
  - "9.4.  IgnorableBlocks (D)\n   This category is defined in Section 2.4 of [RFC5892].\
    \  However, it is\n   not used in PRECIS.\n"
- title: 9.5.  LDH (E)
  contents:
  - "9.5.  LDH (E)\n   This category is defined in Section 2.5 of [RFC5892].  However,\
    \ it is\n   not used in PRECIS.\n   Note: See the ASCII7 (\"K\") category below\
    \ for a more inclusive\n   category used in PRECIS identifiers.\n"
- title: 9.6.  Exceptions (F)
  contents:
  - "9.6.  Exceptions (F)\n   This category is defined in Section 2.6 of [RFC5892]\
    \ and is included\n   by reference for use in PRECIS.\n"
- title: 9.7.  BackwardCompatible (G)
  contents:
  - "9.7.  BackwardCompatible (G)\n   This category is defined in Section 2.7 of [RFC5892]\
    \ and is included\n   by reference for use in PRECIS.\n   Note: Management of\
    \ this category is handled via the processes\n   specified in [RFC5892].  At the\
    \ time of this writing (and also at the\n   time that RFC 5892 was published),\
    \ this category consisted of the\n   empty set; however, that is subject to change\
    \ as described in\n   RFC 5892.\n"
- title: 9.8.  JoinControl (H)
  contents:
  - "9.8.  JoinControl (H)\n   This category is defined in Section 2.8 of [RFC5892]\
    \ and is included\n   by reference for use in PRECIS.\n"
- title: 9.9.  OldHangulJamo (I)
  contents:
  - "9.9.  OldHangulJamo (I)\n   This category is defined in Section 2.9 of [RFC5892]\
    \ and is included\n   by reference for use in PRECIS.\n"
- title: 9.10.  Unassigned (J)
  contents:
  - "9.10.  Unassigned (J)\n   This category is defined in Section 2.10 of [RFC5892]\
    \ and is included\n   by reference for use in PRECIS.\n"
- title: 9.11.  ASCII7 (K)
  contents:
  - "9.11.  ASCII7 (K)\n   This PRECIS-specific category consists of all printable,\
    \ non-space\n   characters from the 7-bit ASCII range.  By applying this category,\n\
    \   the algorithm specified under Section 8 exempts these characters from\n  \
    \ other rules that might be applied during PRECIS processing, on the\n   assumption\
    \ that these code points are in such wide use that\n   disallowing them would\
    \ be counter-productive.\n   K: cp is in {0021..007E}\n"
- title: 9.12.  Controls (L)
  contents:
  - "9.12.  Controls (L)\n   This PRECIS-specific category consists of all control\
    \ characters.\n   L: Control(cp) = True\n"
- title: 9.13.  PrecisIgnorableProperties (M)
  contents:
  - "9.13.  PrecisIgnorableProperties (M)\n   This PRECIS-specific category is used\
    \ to group code points that are\n   discouraged from use in PRECIS string classes.\n\
    \   M: Default_Ignorable_Code_Point(cp) = True or\n      Noncharacter_Code_Point(cp)\
    \ = True\n   The definition for Default_Ignorable_Code_Point can be found in the\n\
    \   DerivedCoreProperties.txt file [DerivedCoreProperties].\n"
- title: 9.14.  Spaces (N)
  contents:
  - "9.14.  Spaces (N)\n   This PRECIS-specific category is used to group code points\
    \ that are\n   space characters.\n   N: General_Category(cp) is in {Zs}\n"
- title: 9.15.  Symbols (O)
  contents:
  - "9.15.  Symbols (O)\n   This PRECIS-specific category is used to group code points\
    \ that are\n   symbols.\n   O: General_Category(cp) is in {Sm, Sc, Sk, So}\n"
- title: 9.16.  Punctuation (P)
  contents:
  - "9.16.  Punctuation (P)\n   This PRECIS-specific category is used to group code\
    \ points that are\n   punctuation characters.\n   P: General_Category(cp) is in\
    \ {Pc, Pd, Ps, Pe, Pi, Pf, Po}\n"
- title: 9.17.  HasCompat (Q)
  contents:
  - "9.17.  HasCompat (Q)\n   This PRECIS-specific category is used to group code\
    \ points that have\n   compatibility equivalents as explained in the Unicode Standard\
    \ (at\n   the time of this writing, see Chapters 2 and 3 of [Unicode7.0]).\n \
    \  Q: toNFKC(cp) != cp\n   The toNFKC() operation returns the code point in normalization\n\
    \   form KC.  For more information, see Section 5 of Unicode Standard\n   Annex\
    \ #15 [UAX15].\n"
- title: 9.18.  OtherLetterDigits (R)
  contents:
  - "9.18.  OtherLetterDigits (R)\n   This PRECIS-specific category is used to group\
    \ code points that are\n   letters and digits other than the \"traditional\" letters\
    \ and digits\n   grouped under the LetterDigits (A) class (see Section 9.1).\n\
    \   R: General_Category(cp) is in {Lt, Nl, No, Me}\n"
- title: 10.  Guidelines for Designated Experts
  contents:
  - "10.  Guidelines for Designated Experts\n   Experience with internationalization\
    \ in application protocols has\n   shown that protocol designers and application\
    \ developers usually do\n   not understand the subtleties and tradeoffs involved\
    \ with\n   internationalization and that they need considerable guidance in\n\
    \   making reasonable decisions with regard to the options before them.\n   Therefore:\n\
    \   o  Protocol designers are strongly encouraged to question the\n      assumption\
    \ that they need to define new profiles, since existing\n      profiles are designed\
    \ for wide reuse (see Section 5 for further\n      discussion).\n   o  Those who\
    \ persist in defining new profiles are strongly encouraged\n      to clearly explain\
    \ a strong justification for doing so, and to\n      publish a stable specification\
    \ that provides all of the\n      information described under Section 11.3.\n\
    \   o  The designated experts for profile registration requests ought to\n   \
    \   seek answers to all of the questions provided under Section 11.3\n      and\
    \ to encourage applicants to provide a stable specification\n      documenting\
    \ the profile (even though the registration policy for\n      PRECIS profiles\
    \ is Expert Review and a stable specification is not\n      strictly required).\n\
    \   o  Developers of applications that use PRECIS are strongly encouraged\n  \
    \    to apply the guidelines provided under Section 6 and to seek out\n      the\
    \ advice of the designated experts or other knowledgeable\n      individuals in\
    \ doing so.\n   o  All parties are strongly encouraged to help prevent the\n \
    \     multiplication of profiles beyond necessity, as described under\n      Section\
    \ 5.1, and to use PRECIS in ways that will minimize user\n      confusion and\
    \ insecure application behavior.\n   Internationalization can be difficult and\
    \ contentious; designated\n   experts, profile registrants, and application developers\
    \ are strongly\n   encouraged to work together in a spirit of good faith and mutual\n\
    \   understanding to achieve rough consensus on profile registration\n   requests\
    \ and the use of PRECIS in particular applications.  They are\n   also encouraged\
    \ to bring additional expertise into the discussion if\n   that would be helpful\
    \ in adding perspective or otherwise resolving\n   issues.\n"
- title: 11.  IANA Considerations
  contents:
  - '11.  IANA Considerations

    '
- title: 11.1.  PRECIS Derived Property Value Registry
  contents:
  - "11.1.  PRECIS Derived Property Value Registry\n   IANA has created and now maintains\
    \ the \"PRECIS Derived Property\n   Value\" registry that records the derived\
    \ properties for the versions\n   of Unicode that are released after (and including)\
    \ version 7.0.  The\n   derived property value is to be calculated in cooperation\
    \ with a\n   designated expert [RFC5226] according to the rules specified under\n\
    \   Sections 8 and 9.\n   The IESG is to be notified if backward-incompatible\
    \ changes to the\n   table of derived properties are discovered or if other problems\
    \ arise\n   during the process of creating the table of derived property values\n\
    \   or during expert review.  Changes to the rules defined under\n   Sections\
    \ 8 and 9 require IETF Review.\n"
- title: 11.2.  PRECIS Base Classes Registry
  contents:
  - "11.2.  PRECIS Base Classes Registry\n   IANA has created the \"PRECIS Base Classes\"\
    \ registry.  In accordance\n   with [RFC5226], the registration policy is \"RFC\
    \ Required\".\n   The registration template is as follows:\n   Base Class:  [the\
    \ name of the PRECIS string class]\n   Description:  [a brief description of the\
    \ PRECIS string class and its\n      intended use, e.g., \"A sequence of letters,\
    \ numbers, and symbols\n      that is used to identify or address a network entity.\"\
    ]\n   Specification:  [the RFC number]\n   The initial registrations are as follows:\n\
    \   Base Class: FreeformClass.\n   Description: A sequence of letters, numbers,\
    \ symbols, spaces, and\n         other code points that is used for free-form\
    \ strings.\n   Specification: Section 4.3 of RFC 7564.\n   Base Class: IdentifierClass.\n\
    \   Description: A sequence of letters, numbers, and symbols that is\n       \
    \  used to identify or address a network entity.\n   Specification: Section 4.2\
    \ of RFC 7564.\n"
- title: 11.3.  PRECIS Profiles Registry
  contents:
  - "11.3.  PRECIS Profiles Registry\n   IANA has created the \"PRECIS Profiles\"\
    \ registry to identify profiles\n   that use the PRECIS string classes.  In accordance\
    \ with [RFC5226],\n   the registration policy is \"Expert Review\".  This policy\
    \ was chosen\n   in order to ease the burden of registration while ensuring that\n\
    \   \"customers\" of PRECIS receive appropriate guidance regarding the\n   sometimes\
    \ complex and subtle internationalization issues related to\n   profiles of PRECIS\
    \ string classes.\n   The registration template is as follows:\n   Name:  [the\
    \ name of the profile]\n   Base Class:  [which PRECIS string class is being profiled]\n\
    \   Applicability:  [the specific protocol elements to which this profile\n  \
    \    applies, e.g., \"Localparts in XMPP addresses.\"]\n   Replaces:  [the Stringprep\
    \ profile that this PRECIS profile replaces,\n      if any]\n   Width Mapping\
    \ Rule:  [the behavioral rule for handling of width,\n      e.g., \"Map fullwidth\
    \ and halfwidth characters to their\n      compatibility variants.\"]\n   Additional\
    \ Mapping Rule:  [any additional mappings that are required\n      or recommended,\
    \ e.g., \"Map non-ASCII space characters to ASCII\n      space.\"]\n   Case Mapping\
    \ Rule:  [the behavioral rule for handling of case, e.g.,\n      \"Unicode Default\
    \ Case Folding\"]\n   Normalization Rule:  [which Unicode normalization form is\
    \ applied,\n      e.g., \"NFC\"]\n   Directionality Rule:  [the behavioral rule\
    \ for handling of right-to-\n      left code points, e.g., \"The 'Bidi Rule' defined\
    \ in RFC 5893\n      applies.\"]\n   Enforcement:  [which entities enforce the\
    \ rules, and when that\n      enforcement occurs during protocol operations]\n\
    \   Specification:  [a pointer to relevant documentation, such as an RFC\n   \
    \   or Internet-Draft]\n   In order to request a review, the registrant shall\
    \ send a completed\n   template to the precis@ietf.org list or its designated\
    \ successor.\n   Factors to focus on while defining profiles and reviewing profile\n\
    \   registrations include the following:\n   o  Would an existing PRECIS string\
    \ class or profile solve the\n      problem?  If not, why not?  (See Section 5.1\
    \ for related\n      considerations.)\n   o  Is the problem being addressed by\
    \ this profile well defined?\n   o  Does the specification define what kinds of\
    \ applications are\n      involved and the protocol elements to which this profile\
    \ applies?\n   o  Is the profile clearly defined?\n   o  Is the profile based\
    \ on an appropriate dividing line between user\n      interface (culture, context,\
    \ intent, locale, device limitations,\n      etc.) and the use of conformant strings\
    \ in protocol elements?\n   o  Are the width mapping, case mapping, additional\
    \ mappings,\n      normalization, and directionality rules appropriate for the\n\
    \      intended use?\n   o  Does the profile explain which entities enforce the\
    \ rules, and\n      when such enforcement occurs during protocol operations?\n\
    \   o  Does the profile reduce the degree to which human users could be\n    \
    \  surprised or confused by application behavior (the \"Principle of\n      Least\
    \ Astonishment\")?\n   o  Does the profile introduce any new security concerns\
    \ such as those\n      described under Section 12 of this document (e.g., false\
    \ positives\n      for authentication or authorization)?\n"
- title: 12.  Security Considerations
  contents:
  - '12.  Security Considerations

    '
- title: 12.1.  General Issues
  contents:
  - "12.1.  General Issues\n   If input strings that appear \"the same\" to users\
    \ are programmatically\n   considered to be distinct in different systems, or\
    \ if input strings\n   that appear distinct to users are programmatically considered\
    \ to be\n   \"the same\" in different systems, then users can be confused.  Such\n\
    \   confusion can have security implications, such as the false positives\n  \
    \ and false negatives discussed in [RFC6943].  One starting goal of\n   work on\
    \ the PRECIS framework was to limit the number of times that\n   users are confused\
    \ (consistent with the \"Principle of Least\n   Astonishment\").  Unfortunately,\
    \ this goal has been difficult to\n   achieve given the large number of application\
    \ protocols already in\n   existence.  Despite these difficulties, profiles should\
    \ not be\n   multiplied beyond necessity (see Section 5.1).  In particular,\n\
    \   application protocol designers should think long and hard before\n   defining\
    \ a new profile instead of using one that has already been\n   defined, and if\
    \ they decide to define a new profile then they should\n   clearly explain their\
    \ reasons for doing so.\n   The security of applications that use this framework\
    \ can depend in\n   part on the proper preparation, enforcement, and comparison\
    \ of\n   internationalized strings.  For example, such strings can be used to\n\
    \   make authentication and authorization decisions, and the security of\n   an\
    \ application could be compromised if an entity providing a given\n   string is\
    \ connected to the wrong account or online resource based on\n   different interpretations\
    \ of the string (again, see [RFC6943]).\n   Specifications of application protocols\
    \ that use this framework are\n   strongly encouraged to describe how internationalized\
    \ strings are\n   used in the protocol, including the security implications of\
    \ any\n   false positives and false negatives that might result from various\n\
    \   enforcement and comparison operations.  For some helpful guidelines,\n   refer\
    \ to [RFC6943], [RFC5890], [UTR36], and [UTS39].\n"
- title: 12.2.  Use of the IdentifierClass
  contents:
  - "12.2.  Use of the IdentifierClass\n   Strings that conform to the IdentifierClass\
    \ and any profile thereof\n   are intended to be relatively safe for use in a\
    \ broad range of\n   applications, primarily because they include only letters,\
    \ digits,\n   and \"grandfathered\" non-space characters from the ASCII range;\
    \ thus,\n   they exclude spaces, characters with compatibility equivalents, and\n\
    \   almost all symbols and punctuation marks.  However, because such\n   strings\
    \ can still include so-called confusable characters (see\n   Section 12.5), protocol\
    \ designers and implementers are encouraged to\n   pay close attention to the\
    \ security considerations described\n   elsewhere in this document.\n"
- title: 12.3.  Use of the FreeformClass
  contents:
  - "12.3.  Use of the FreeformClass\n   Strings that conform to the FreeformClass\
    \ and many profiles thereof\n   can include virtually any Unicode character. \
    \ This makes the\n   FreeformClass quite expressive, but also problematic from\
    \ the\n   perspective of possible user confusion.  Protocol designers are\n  \
    \ hereby warned that the FreeformClass contains code points they might\n   not\
    \ understand, and are encouraged to profile the IdentifierClass\n   wherever feasible;\
    \ however, if an application protocol requires more\n   code points than are allowed\
    \ by the IdentifierClass, protocol\n   designers are encouraged to define a profile\
    \ of the FreeformClass\n   that restricts the allowable code points as tightly\
    \ as possible.\n   (The PRECIS Working Group considered the option of allowing\n\
    \   \"superclasses\" as well as profiles of PRECIS string classes, but\n   decided\
    \ against allowing superclasses to reduce the likelihood of\n   security and interoperability\
    \ problems.)\n"
- title: 12.4.  Local Character Set Issues
  contents:
  - "12.4.  Local Character Set Issues\n   When systems use local character sets other\
    \ than ASCII and Unicode,\n   this specification leaves the problem of converting\
    \ between the local\n   character set and Unicode up to the application or local\
    \ system.  If\n   different applications (or different versions of one application)\n\
    \   implement different rules for conversions among coded character sets,\n  \
    \ they could interpret the same name differently and contact different\n   application\
    \ servers or other network entities.  This problem is not\n   solved by security\
    \ protocols, such as Transport Layer Security (TLS)\n   [RFC5246] and the Simple\
    \ Authentication and Security Layer (SASL)\n   [RFC4422], that do not take local\
    \ character sets into account.\n"
- title: 12.5.  Visually Similar Characters
  contents:
  - "12.5.  Visually Similar Characters\n   Some characters are visually similar and\
    \ thus can cause confusion\n   among humans.  Such characters are often called\
    \ \"confusable\n   characters\" or \"confusables\".\n   The problem of confusable\
    \ characters is not necessarily caused by the\n   use of Unicode code points outside\
    \ the ASCII range.  For example, in\n   some presentations and to some individuals\
    \ the string \"ju1iet\"\n   (spelled with DIGIT ONE, U+0031, as the third character)\
    \ might appear\n   to be the same as \"juliet\" (spelled with LATIN SMALL LETTER\
    \ L,\n   U+006C), especially on casual visual inspection.  This phenomenon is\n\
    \   sometimes called \"typejacking\".\n   However, the problem is made more serious\
    \ by introducing the full\n   range of Unicode code points into protocol strings.\
    \  For example, the\n   characters U+13DA U+13A2 U+13B5 U+13AC U+13A2 U+13AC U+13D2\
    \ from the\n   Cherokee block look similar to the ASCII characters \"STPETER\"\
    \ as they\n   might appear when presented using a \"creative\" font family.\n\
    \   In some examples of confusable characters, it is unlikely that the\n   average\
    \ human could tell the difference between the real string and\n   the fake string.\
    \  (Indeed, there is no programmatic way to\n   distinguish with full certainty\
    \ which is the fake string and which is\n   the real string; in some contexts,\
    \ the string formed of Cherokee\n   characters might be the real string and the\
    \ string formed of ASCII\n   characters might be the fake string.)  Because PRECIS-compliant\n\
    \   strings can contain almost any properly encoded Unicode code point,\n   it\
    \ can be relatively easy to fake or mimic some strings in systems\n   that use\
    \ the PRECIS framework.  The fact that some strings are easily\n   confused introduces\
    \ security vulnerabilities of the kind that have\n   also plagued the World Wide\
    \ Web, specifically the phenomenon known as\n   phishing.\n   Despite the fact\
    \ that some specific suggestions about identification\n   and handling of confusable\
    \ characters appear in the Unicode Security\n   Considerations [UTR36] and the\
    \ Unicode Security Mechanisms [UTS39],\n   it is also true (as noted in [RFC5890])\
    \ that \"there are no\n   comprehensive technical solutions to the problems of\
    \ confusable\n   characters.\"  Because it is impossible to map visually similar\n\
    \   characters without a great deal of context (such as knowing the font\n   families\
    \ used), the PRECIS framework does nothing to map similar-\n   looking characters\
    \ together, nor does it prohibit some characters\n   because they look like others.\n\
    \   Nevertheless, specifications for application protocols that use this\n   framework\
    \ are strongly encouraged to describe how confusable\n   characters can be abused\
    \ to compromise the security of systems that\n   use the protocol in question,\
    \ along with any protocol-specific\n   suggestions for overcoming those threats.\
    \  In particular, software\n   implementations and service deployments that use\
    \ PRECIS-based\n   technologies are strongly encouraged to define and implement\n\
    \   consistent policies regarding the registration, storage, and\n   presentation\
    \ of visually similar characters.  The following\n   recommendations are appropriate:\n\
    \   1.  An application service SHOULD define a policy that specifies the\n   \
    \    scripts or blocks of characters that the service will allow to be\n     \
    \  registered (e.g., in an account name) or stored (e.g., in a\n       filename).\
    \  Such a policy SHOULD be informed by the languages and\n       scripts that\
    \ are used to write registered account names; in\n       particular, to reduce\
    \ confusion, the service SHOULD forbid\n       registration or storage of strings\
    \ that contain characters from\n       more than one script and SHOULD restrict\
    \ registrations to\n       characters drawn from a very small number of scripts\
    \ (e.g.,\n       scripts that are well understood by the administrators of the\n\
    \       service, to improve manageability).\n   2.  User-oriented application\
    \ software SHOULD define a policy that\n       specifies how internationalized\
    \ strings will be presented to a\n       human user.  Because every human user\
    \ of such software has a\n       preferred language or a small set of preferred\
    \ languages, the\n       software SHOULD gather that information either explicitly\
    \ from\n       the user or implicitly via the operating system of the user's\n\
    \       device.  Furthermore, because most languages are typically\n       represented\
    \ by a single script or a small set of scripts, and\n       because most scripts\
    \ are typically contained in one or more\n       blocks of characters, the software\
    \ SHOULD warn the user when\n       presenting a string that mixes characters\
    \ from more than one\n       script or block, or that uses characters outside\
    \ the normal range\n       of the user's preferred language(s).  (Such a recommendation\
    \ is\n       not intended to discourage communication across different\n     \
    \  communities of language users; instead, it recognizes the\n       existence\
    \ of such communities and encourages due caution when\n       presenting unfamiliar\
    \ scripts or characters to human users.)\n   The challenges inherent in supporting\
    \ the full range of Unicode code\n   points have in the past led some to hope\
    \ for a way to\n   programmatically negotiate more restrictive ranges based on\
    \ locale,\n   script, or other relevant factors; to tag the locale associated\
    \ with\n   a particular string; etc.  As a general-purpose internationalization\n\
    \   technology, the PRECIS framework does not include such mechanisms.\n"
- title: 12.6.  Security of Passwords
  contents:
  - "12.6.  Security of Passwords\n   Two goals of passwords are to maximize the amount\
    \ of entropy and to\n   minimize the potential for false positives.  These goals\
    \ can be\n   achieved in part by allowing a wide range of code points and by\n\
    \   ensuring that passwords are handled in such a way that code points\n   are\
    \ not compared aggressively.  Therefore, it is NOT RECOMMENDED for\n   application\
    \ protocols to profile the FreeformClass for use in\n   passwords in a way that\
    \ removes entire categories (e.g., by\n   disallowing symbols or punctuation).\
    \  Furthermore, it is NOT\n   RECOMMENDED for application protocols to map uppercase\
    \ and titlecase\n   code points to their lowercase equivalents in such strings;\
    \ instead,\n   it is RECOMMENDED to preserve the case of all code points contained\n\
    \   in such strings and to compare them in a case-sensitive manner.\n   That said,\
    \ software implementers need to be aware that there exist\n   tradeoffs between\
    \ entropy and usability.  For example, allowing a\n   user to establish a password\
    \ containing \"uncommon\" code points might\n   make it difficult for the user\
    \ to access a service when using an\n   unfamiliar or constrained input device.\n\
    \   Some application protocols use passwords directly, whereas others\n   reuse\
    \ technologies that themselves process passwords (one example of\n   such a technology\
    \ is the Simple Authentication and Security Layer\n   [RFC4422]).  Moreover, passwords\
    \ are often carried by a sequence of\n   protocols with backend authentication\
    \ systems or data storage systems\n   such as RADIUS [RFC2865] and the Lightweight\
    \ Directory Access\n   Protocol (LDAP) [RFC4510].  Developers of application protocols\
    \ are\n   encouraged to look into reusing these profiles instead of defining\n\
    \   new ones, so that end-user expectations about passwords are\n   consistent\
    \ no matter which application protocol is used.\n   In protocols that provide\
    \ passwords as input to a cryptographic\n   algorithm such as a hash function,\
    \ the client will need to perform\n   proper preparation of the password before\
    \ applying the algorithm,\n   since the password is not available to the server\
    \ in plaintext form.\n   Further discussion of password handling can be found\
    \ in\n   [PRECIS-Users-Pwds].\n"
- title: 13.  Interoperability Considerations
  contents:
  - '13.  Interoperability Considerations

    '
- title: 13.1.  Encoding
  contents:
  - "13.1.  Encoding\n   Although strings that are consumed in PRECIS-based application\n\
    \   protocols are often encoded using UTF-8 [RFC3629], the exact encoding\n  \
    \ is a matter for the application protocol that uses PRECIS, not for\n   the PRECIS\
    \ framework.\n"
- title: 13.2.  Character Sets
  contents:
  - "13.2.  Character Sets\n   It is known that some existing systems are unable to\
    \ support the full\n   Unicode character set, or even any characters outside the\
    \ ASCII\n   range.  If two (or more) applications need to interoperate when\n\
    \   exchanging data (e.g., for the purpose of authenticating a username\n   or\
    \ password), they will naturally need to have in common at least one\n   coded\
    \ character set (as defined by [RFC6365]).  Establishing such a\n   baseline is\
    \ a matter for the application protocol that uses PRECIS,\n   not for the PRECIS\
    \ framework.\n"
- title: 13.3.  Unicode Versions
  contents:
  - "13.3.  Unicode Versions\n   Changes to the properties of Unicode code points\
    \ can occur as the\n   Unicode Standard is modified from time to time.  For example,\
    \ three\n   code points underwent changes in their GeneralCategory between\n \
    \  Unicode 5.2 (current at the time IDNA2008 was originally published)\n   and\
    \ Unicode 6.0, as described in [RFC6452].  Implementers might need\n   to be aware\
    \ that the treatment of these characters differs depending\n   on which version\
    \ of Unicode is available on the system that is using\n   IDNA2008 or PRECIS.\
    \  Other such differences might arise between the\n   version of Unicode current\
    \ at the time of this writing (7.0) and\n   future versions.\n"
- title: 13.4.  Potential Changes to Handling of Certain Unicode Code Points
  contents:
  - "13.4.  Potential Changes to Handling of Certain Unicode Code Points\n   As part\
    \ of the review of Unicode 7.0 for IDNA, a question was raised\n   about a newly\
    \ added code point that led to a re-analysis of the\n   normalization rules used\
    \ by IDNA and inherited by this document\n   (Section 5.2.4).  Some of the general\
    \ issues are described in\n   [IAB-Statement] and pursued in more detail in [IDNA-Unicode].\n\
    \   At the time of writing, these issues have yet to be settled.\n   However,\
    \ implementers need to be aware that this specification is\n   likely to be updated\
    \ in the future to address these issues.  The\n   potential changes include the\
    \ following:\n   o  The range of characters in the LetterDigits category\n   \
    \   (Sections 4.2.1 and 9.1) might be narrowed.\n   o  Some characters with special\
    \ properties that are now allowed might\n      be excluded.\n   o  More \"Additional\
    \ Mapping Rules\" (Section 5.2.2) might be defined.\n   o  Alternative normalization\
    \ methods might be added.\n   Nevertheless, implementations and deployments that\
    \ are sensitive to\n   the advice given in this specification are unlikely to\
    \ encounter\n   significant problems as a consequence of these issues or potential\n\
    \   changes -- specifically, the advice to use the more restrictive\n   IdentifierClass\
    \ whenever possible or, if using the FreeformClass, to\n   allow only a restricted\
    \ set of characters, particularly avoiding\n   characters whose implications they\
    \ do not actually understand.\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [RFC20]    Cerf, V., \"ASCII format for network\
    \ interchange\", STD 80,\n              RFC 20, DOI 10.17487/RFC0020, October\
    \ 1969,\n              <http://www.rfc-editor.org/info/rfc20>.\n   [RFC2119] \
    \ Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement\
    \ Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n\
    \              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC5198]  Klensin,\
    \ J. and M. Padlipsky, \"Unicode Format for Network\n              Interchange\"\
    , RFC 5198, DOI 10.17487/RFC5198, March 2008,\n              <http://www.rfc-editor.org/info/rfc5198>.\n\
    \   [RFC6365]  Hoffman, P. and J. Klensin, \"Terminology Used in\n           \
    \   Internationalization in the IETF\", BCP 166, RFC 6365,\n              DOI\
    \ 10.17487/RFC6365, September 2011,\n              <http://www.rfc-editor.org/info/rfc6365>.\n\
    \   [Unicode]  The Unicode Consortium, \"The Unicode Standard\",\n           \
    \   <http://www.unicode.org/versions/latest/>.\n   [Unicode7.0]\n            \
    \  The Unicode Consortium, \"The Unicode Standard, Version\n              7.0.0\"\
    , (Mountain View, CA: The Unicode Consortium, 2014\n              ISBN 978-1-936213-09-2),\n\
    \              <http://www.unicode.org/versions/Unicode7.0.0/>.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [DerivedCoreProperties]\n              The\
    \ Unicode Consortium, \"DerivedCoreProperties-7.0.0.txt\",\n              Unicode\
    \ Character Database, February 2014,\n              <http://www.unicode.org/Public/UCD/latest/ucd/\n\
    \              DerivedCoreProperties.txt>.\n   [IAB-Statement]\n             \
    \ Internet Architecture Board, \"IAB Statement on Identifiers\n              and\
    \ Unicode 7.0.0\", February 2015, <https://www.iab.org/\n              documents/correspondence-reports-documents/\n\
    \              2015-2/iab-statement-on-identifiers-and-unicode-7-0-0/>.\n   [IDNA-Unicode]\n\
    \              Klensin, J. and P. Faltstrom, \"IDNA Update for Unicode\n     \
    \         7.0.0\", Work in Progress,\n              draft-klensin-idna-5892upd-unicode70-04,\
    \ March 2015.\n   [PRECIS-Mappings]\n              Yoneya, Y. and T. Nemoto, \"\
    Mapping characters for PRECIS\n              classes\", Work in Progress, draft-ietf-precis-mappings-10,\n\
    \              May 2015.\n   [PRECIS-Nickname]\n              Saint-Andre, P.,\
    \ \"Preparation, Enforcement, and Comparison\n              of Internationalized\
    \ Strings Representing Nicknames\", Work\n              in Progress, draft-ietf-precis-nickname-17,\
    \ April 2015.\n   [PRECIS-Users-Pwds]\n              Saint-Andre, P. and A. Melnikov,\
    \ \"Preparation,\n              Enforcement, and Comparison of Internationalized\
    \ Strings\n              Representing Usernames and Passwords\", Work in Progress,\n\
    \              draft-ietf-precis-saslprepbis-17, May 2015.\n   [PropertyAliases]\n\
    \              The Unicode Consortium, \"PropertyAliases-7.0.0.txt\",\n      \
    \        Unicode Character Database, November 2013,\n              <http://www.unicode.org/Public/UCD/latest/ucd/\n\
    \              PropertyAliases.txt>.\n   [RFC2865]  Rigney, C., Willens, S., Rubens,\
    \ A., and W. Simpson,\n              \"Remote Authentication Dial In User Service\
    \ (RADIUS)\",\n              RFC 2865, DOI 10.17487/RFC2865, June 2000,\n    \
    \          <http://www.rfc-editor.org/info/rfc2865>.\n   [RFC3454]  Hoffman, P.\
    \ and M. Blanchet, \"Preparation of\n              Internationalized Strings (\"\
    stringprep\")\", RFC 3454,\n              DOI 10.17487/RFC3454, December 2002,\n\
    \              <http://www.rfc-editor.org/info/rfc3454>.\n   [RFC3490]  Faltstrom,\
    \ P., Hoffman, P., and A. Costello,\n              \"Internationalizing Domain\
    \ Names in Applications (IDNA)\",\n              RFC 3490, DOI 10.17487/RFC3490,\
    \ March 2003,\n              <http://www.rfc-editor.org/info/rfc3490>.\n   [RFC3491]\
    \  Hoffman, P. and M. Blanchet, \"Nameprep: A Stringprep\n              Profile\
    \ for Internationalized Domain Names (IDN)\",\n              RFC 3491, DOI 10.17487/RFC3491,\
    \ March 2003,\n              <http://www.rfc-editor.org/info/rfc3491>.\n   [RFC3629]\
    \  Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\"\
    , STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n              2003, <http://www.rfc-editor.org/info/rfc3629>.\n\
    \   [RFC4422]  Melnikov, A., Ed., and K. Zeilenga, Ed., \"Simple\n           \
    \   Authentication and Security Layer (SASL)\", RFC 4422,\n              DOI 10.17487/RFC4422,\
    \ June 2006,\n              <http://www.rfc-editor.org/info/rfc4422>.\n   [RFC4510]\
    \  Zeilenga, K., Ed., \"Lightweight Directory Access Protocol\n              (LDAP):\
    \ Technical Specification Road Map\", RFC 4510,\n              DOI 10.17487/RFC4510,\
    \ June 2006,\n              <http://www.rfc-editor.org/info/rfc4510>.\n   [RFC4690]\
    \  Klensin, J., Faltstrom, P., Karp, C., and IAB, \"Review and\n             \
    \ Recommendations for Internationalized Domain Names\n              (IDNs)\",\
    \ RFC 4690, DOI 10.17487/RFC4690, September 2006,\n              <http://www.rfc-editor.org/info/rfc4690>.\n\
    \   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n   \
    \           IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n       \
    \       DOI 10.17487/RFC5226, May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n\
    \   [RFC5234]  Crocker, D., Ed., and P. Overell, \"Augmented BNF for\n       \
    \       Syntax Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,\
    \ January 2008,\n              <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC5246]\
    \  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)\
    \ Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August\
    \ 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5890]\
    \  Klensin, J., \"Internationalized Domain Names for\n              Applications\
    \ (IDNA): Definitions and Document Framework\",\n              RFC 5890, DOI 10.17487/RFC5890,\
    \ August 2010,\n              <http://www.rfc-editor.org/info/rfc5890>.\n   [RFC5891]\
    \  Klensin, J., \"Internationalized Domain Names in\n              Applications\
    \ (IDNA): Protocol\", RFC 5891,\n              DOI 10.17487/RFC5891, August 2010,\n\
    \              <http://www.rfc-editor.org/info/rfc5891>.\n   [RFC5892]  Faltstrom,\
    \ P., Ed., \"The Unicode Code Points and\n              Internationalized Domain\
    \ Names for Applications (IDNA)\",\n              RFC 5892, DOI 10.17487/RFC5892,\
    \ August 2010,\n              <http://www.rfc-editor.org/info/rfc5892>.\n   [RFC5893]\
    \  Alvestrand, H., Ed., and C. Karp, \"Right-to-Left Scripts\n              for\
    \ Internationalized Domain Names for Applications\n              (IDNA)\", RFC\
    \ 5893, DOI 10.17487/RFC5893, August 2010,\n              <http://www.rfc-editor.org/info/rfc5893>.\n\
    \   [RFC5894]  Klensin, J., \"Internationalized Domain Names for\n           \
    \   Applications (IDNA): Background, Explanation, and\n              Rationale\"\
    , RFC 5894, DOI 10.17487/RFC5894, August 2010,\n              <http://www.rfc-editor.org/info/rfc5894>.\n\
    \   [RFC5895]  Resnick, P. and P. Hoffman, \"Mapping Characters for\n        \
    \      Internationalized Domain Names in Applications (IDNA)\n              2008\"\
    , RFC 5895, DOI 10.17487/RFC5895, September 2010,\n              <http://www.rfc-editor.org/info/rfc5895>.\n\
    \   [RFC6452]  Faltstrom, P., Ed., and P. Hoffman, Ed., \"The Unicode Code\n \
    \             Points and Internationalized Domain Names for Applications\n   \
    \           (IDNA) - Unicode 6.0\", RFC 6452, DOI 10.17487/RFC6452,\n        \
    \      November 2011, <http://www.rfc-editor.org/info/rfc6452>.\n   [RFC6885]\
    \  Blanchet, M. and A. Sullivan, \"Stringprep Revision and\n              Problem\
    \ Statement for the Preparation and Comparison of\n              Internationalized\
    \ Strings (PRECIS)\", RFC 6885,\n              DOI 10.17487/RFC6885, March 2013,\n\
    \              <http://www.rfc-editor.org/info/rfc6885>.\n   [RFC6943]  Thaler,\
    \ D., Ed., \"Issues in Identifier Comparison for\n              Security Purposes\"\
    , RFC 6943, DOI 10.17487/RFC6943, May\n              2013, <http://www.rfc-editor.org/info/rfc6943>.\n\
    \   [UAX11]    Unicode Standard Annex #11, \"East Asian Width\", edited by\n \
    \             Ken Lunde. An integral part of The Unicode Standard,\n         \
    \     <http://unicode.org/reports/tr11/>.\n   [UAX15]    Unicode Standard Annex\
    \ #15, \"Unicode Normalization Forms\",\n              edited by Mark Davis and\
    \ Ken Whistler. An integral part of\n              The Unicode Standard, <http://unicode.org/reports/tr15/>.\n\
    \   [UAX9]     Unicode Standard Annex #9, \"Unicode Bidirectional\n          \
    \    Algorithm\", edited by Mark Davis, Aharon Lanin, and Andrew\n           \
    \   Glass. An integral part of The Unicode Standard,\n              <http://unicode.org/reports/tr9/>.\n\
    \   [UTR36]    Unicode Technical Report #36, \"Unicode Security\n            \
    \  Considerations\", by Mark Davis and Michel Suignard,\n              <http://unicode.org/reports/tr36/>.\n\
    \   [UTS39]    Unicode Technical Standard #39, \"Unicode Security\n          \
    \    Mechanisms\", edited by Mark Davis and Michel Suignard,\n              <http://unicode.org/reports/tr39/>.\n\
    \   [XMPP-Addr-Format]\n              Saint-Andre, P., \"Extensible Messaging\
    \ and Presence\n              Protocol (XMPP): Address Format\", Work in Progress,\n\
    \              draft-ietf-xmpp-6122bis-22, May 2015.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to acknowledge the comments and contributions\n\
    \   of the following individuals during working group discussion: David\n   Black,\
    \ Edward Burns, Dan Chiba, Mark Davis, Alan DeKok, Martin\n   Duerst, Patrik Faltstrom,\
    \ Ted Hardie, Joe Hildebrand, Bjoern\n   Hoehrmann, Paul Hoffman, Jeffrey Hutzelman,\
    \ Simon Josefsson, John\n   Klensin, Alexey Melnikov, Takahiro Nemoto, Yoav Nir,\
    \ Mike Parker,\n   Pete Resnick, Andrew Sullivan, Dave Thaler, Yoshiro Yoneya,\
    \ and\n   Florian Zeitz.\n   Special thanks are due to John Klensin and Patrik\
    \ Faltstrom for their\n   challenging feedback and detailed reviews.\n   Charlie\
    \ Kaufman, Tom Taylor, and Tim Wicinski reviewed the document\n   on behalf of\
    \ the Security Directorate, the General Area Review Team,\n   and the Operations\
    \ and Management Directorate, respectively.\n   During IESG review, Alissa Cooper,\
    \ Stephen Farrell, and Barry Leiba\n   provided comments that led to further improvements.\n\
    \   Some algorithms and textual descriptions have been borrowed from\n   [RFC5892].\
    \  Some text regarding security has been borrowed from\n   [RFC5890], [PRECIS-Users-Pwds],\
    \ and [XMPP-Addr-Format].\n   Peter Saint-Andre wishes to acknowledge Cisco Systems,\
    \ Inc., for\n   employing him during his work on earlier draft versions of this\n\
    \   document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Peter Saint-Andre\n   &yet\n   EMail: peter@andyet.com\n\
    \   URI:   https://andyet.com/\n   Marc Blanchet\n   Viagenie\n   246 Aberdeen\n\
    \   Quebec, QC  G1R 2E1\n   Canada\n   EMail: Marc.Blanchet@viagenie.ca\n   URI:\
    \   http://www.viagenie.ca/\n"
