- title: __initial_text__
  contents:
  - '                             Multicast DNS

    '
- title: Abstract
  contents:
  - "Abstract\n   As networked devices become smaller, more portable, and more\n \
    \  ubiquitous, the ability to operate with less configured\n   infrastructure\
    \ is increasingly important.  In particular, the ability\n   to look up DNS resource\
    \ record data types (including, but not limited\n   to, host names) in the absence\
    \ of a conventional managed DNS server\n   is useful.\n   Multicast DNS (mDNS)\
    \ provides the ability to perform DNS-like\n   operations on the local link in\
    \ the absence of any conventional\n   Unicast DNS server.  In addition, Multicast\
    \ DNS designates a portion\n   of the DNS namespace to be free for local use,\
    \ without the need to\n   pay any annual fee, and without the need to set up delegations\
    \ or\n   otherwise configure a conventional DNS server to answer for those\n \
    \  names.\n   The primary benefits of Multicast DNS names are that (i) they require\n\
    \   little or no administration or configuration to set them up, (ii)\n   they\
    \ work when no infrastructure is present, and (iii) they work\n   during infrastructure\
    \ failures.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6762.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Conventions and Terminology Used in This Document ...............4\n  \
    \ 3. Multicast DNS Names .............................................5\n   4.\
    \ Reverse Address Mapping .........................................7\n   5. Querying\
    \ ........................................................8\n   6. Responding\
    \ .....................................................13\n   7. Traffic Reduction\
    \ ..............................................22\n   8. Probing and Announcing\
    \ on Startup ..............................25\n   9. Conflict Resolution ............................................31\n\
    \   10. Resource Record TTL Values and Cache Coherency ................33\n  \
    \ 11. Source Address Check ..........................................38\n   12.\
    \ Special Characteristics of Multicast DNS Domains ..............40\n   13. Enabling\
    \ and Disabling Multicast DNS ..........................41\n   14. Considerations\
    \ for Multiple Interfaces ........................42\n   15. Considerations for\
    \ Multiple Responders on the Same Machine ....43\n   16. Multicast DNS Character\
    \ Set ...................................45\n   17. Multicast DNS Message Size\
    \ ....................................46\n   18. Multicast DNS Message Format\
    \ ..................................47\n   19. Summary of Differences between\
    \ Multicast DNS and Unicast DNS ..51\n   20. IPv6 Considerations ...........................................52\n\
    \   21. Security Considerations .......................................52\n  \
    \ 22. IANA Considerations ...........................................53\n   23.\
    \ Acknowledgments ...............................................56\n   24. References\
    \ ....................................................56\n   Appendix A. Design\
    \ Rationale for Choice of UDP Port Number ........60\n   Appendix B. Design Rationale\
    \ for Not Using Hashed Multicast\n               Addresses .............................................61\n\
    \   Appendix C. Design Rationale for Maximum Multicast DNS Name\n            \
    \   Length ................................................62\n   Appendix D.\
    \ Benefits of Multicast Responses .......................64\n   Appendix E. Design\
    \ Rationale for Encoding Negative Responses ......65\n   Appendix F. Use of UTF-8\
    \ ..........................................66\n   Appendix G. Private DNS Namespaces\
    \ ................................67\n   Appendix H. Deployment History ....................................67\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Multicast DNS and its companion technology DNS-Based Service\n\
    \   Discovery [RFC6763] were created to provide IP networking with the\n   ease-of-use\
    \ and autoconfiguration for which AppleTalk was well-known\n   [RFC6760].  When\
    \ reading this document, familiarity with the concepts\n   of Zero Configuration\
    \ Networking [Zeroconf] and automatic link-local\n   addressing [RFC3927] [RFC4862]\
    \ is helpful.\n   Multicast DNS borrows heavily from the existing DNS protocol\n\
    \   [RFC1034] [RFC1035] [RFC6195], using the existing DNS message\n   structure,\
    \ name syntax, and resource record types.  This document\n   specifies no new\
    \ operation codes or response codes.  This document\n   describes how clients\
    \ send DNS-like queries via IP multicast, and how\n   a collection of hosts cooperate\
    \ to collectively answer those queries\n   in a useful manner.\n"
- title: 2.  Conventions and Terminology Used in This Document
  contents:
  - "2.  Conventions and Terminology Used in This Document\n   The key words \"MUST\"\
    , \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to\
    \ be interpreted as described in \"Key words for use in\n   RFCs to Indicate Requirement\
    \ Levels\" [RFC2119].\n   When this document uses the term \"Multicast DNS\",\
    \ it should be taken\n   to mean: \"Clients performing DNS-like queries for DNS-like\
    \ resource\n   records by sending DNS-like UDP query and response messages over\
    \ IP\n   Multicast to UDP port 5353\".  The design rationale for selecting UDP\n\
    \   port 5353 is discussed in Appendix A.\n   This document uses the term \"host\
    \ name\" in the strict sense to mean a\n   fully qualified domain name that has\
    \ an IPv4 or IPv6 address record.\n   It does not use the term \"host name\" in\
    \ the commonly used but\n   incorrect sense to mean just the first DNS label of\
    \ a host's fully\n   qualified domain name.\n   A DNS (or mDNS) packet contains\
    \ an IP Time to Live (TTL) in the IP\n   header, which is effectively a hop-count\
    \ limit for the packet, to\n   guard against routing loops.  Each resource record\
    \ also contains a\n   TTL, which is the number of seconds for which the resource\
    \ record may\n   be cached.  This document uses the term \"IP TTL\" to refer to\
    \ the IP\n   header TTL (hop limit), and the term \"RR TTL\" or just \"TTL\" to\
    \ refer\n   to the resource record TTL (cache lifetime).\n   DNS-format messages\
    \ contain a header, a Question Section, then\n   Answer, Authority, and Additional\
    \ Record Sections.  The Answer,\n   Authority, and Additional Record Sections\
    \ all hold resource records\n   in the same format.  Where this document describes\
    \ issues that apply\n   equally to all three sections, it uses the term \"Resource\
    \ Record\n   Sections\" to refer collectively to these three sections.\n   This\
    \ document uses the terms \"shared\" and \"unique\" when referring to\n   resource\
    \ record sets [RFC1034]:\n      A \"shared\" resource record set is one where\
    \ several Multicast DNS\n      responders may have records with the same name,\
    \ rrtype, and\n      rrclass, and several responders may respond to a particular\
    \ query.\n      A \"unique\" resource record set is one where all the records\
    \ with\n      that name, rrtype, and rrclass are conceptually under the control\n\
    \      or ownership of a single responder, and it is expected that at\n      most\
    \ one responder should respond to a query for that name,\n      rrtype, and rrclass.\
    \  Before claiming ownership of a unique\n      resource record set, a responder\
    \ MUST probe to verify that no\n      other responder already claims ownership\
    \ of that set, as described\n      in Section 8.1, \"Probing\".  (For fault-tolerance\
    \ and other\n      reasons, sometimes it is permissible to have more than one\n\
    \      responder answering for a particular \"unique\" resource record set,\n\
    \      but such cooperating responders MUST give answers containing\n      identical\
    \ rdata for these records.  If they do not give answers\n      containing identical\
    \ rdata, then the probing step will reject the\n      data as being inconsistent\
    \ with what is already being advertised\n      on the network for those names.)\n\
    \   Strictly speaking, the terms \"shared\" and \"unique\" apply to resource\n\
    \   record sets, not to individual resource records.  However, it is\n   sometimes\
    \ convenient to talk of \"shared resource records\" and \"unique\n   resource\
    \ records\".  When used this way, the terms should be\n   understood to mean a\
    \ record that is a member of a \"shared\" or\n   \"unique\" resource record set,\
    \ respectively.\n"
- title: 3.  Multicast DNS Names
  contents:
  - "3.  Multicast DNS Names\n   A host that belongs to an organization or individual\
    \ who has control\n   over some portion of the DNS namespace can be assigned a\
    \ globally\n   unique name within that portion of the DNS namespace, such as,\n\
    \   \"cheshire.example.com.\".  For those of us who have this luxury, this\n \
    \  works very well.  However, the majority of home computer users do not\n   have\
    \ easy access to any portion of the global DNS namespace within\n   which they\
    \ have the authority to create names.  This leaves the\n   majority of home computers\
    \ effectively anonymous for practical\n   purposes.\n   To remedy this problem,\
    \ this document allows any computer user to\n   elect to give their computers\
    \ link-local Multicast DNS host names of\n   the form: \"single-dns-label.local.\"\
    .  For example, a laptop computer\n   may answer to the name \"MyComputer.local.\"\
    .  Any computer user is\n   granted the authority to name their computer this\
    \ way, provided that\n   the chosen host name is not already in use on that link.\
    \  Having\n   named their computer this way, the user has the authority to continue\n\
    \   utilizing that name until such time as a name conflict occurs on the\n   link\
    \ that is not resolved in the user's favor.  If this happens, the\n   computer\
    \ (or its human user) MUST cease using the name, and SHOULD\n   attempt to allocate\
    \ a new unique name for use on that link.  These\n   conflicts are expected to\
    \ be relatively rare for people who choose\n   reasonably imaginative names, but\
    \ it is still important to have a\n   mechanism in place to handle them when they\
    \ happen.\n   This document specifies that the DNS top-level domain \".local.\"\
    \ is a\n   special domain with special semantics, namely that any fully\n   qualified\
    \ name ending in \".local.\" is link-local, and names within\n   this domain are\
    \ meaningful only on the link where they originate.\n   This is analogous to IPv4\
    \ addresses in the 169.254/16 prefix or IPv6\n   addresses in the FE80::/10 prefix,\
    \ which are link-local and\n   meaningful only on the link where they originate.\n\
    \   Any DNS query for a name ending with \".local.\" MUST be sent to the\n   mDNS\
    \ IPv4 link-local multicast address 224.0.0.251 (or its IPv6\n   equivalent FF02::FB).\
    \  The design rationale for using a fixed\n   multicast address instead of selecting\
    \ from a range of multicast\n   addresses using a hash function is discussed in\
    \ Appendix B.\n   Implementers MAY choose to look up such names concurrently via\
    \ other\n   mechanisms (e.g., Unicast DNS) and coalesce the results in some\n\
    \   fashion.  Implementers choosing to do this should be aware of the\n   potential\
    \ for user confusion when a given name can produce different\n   results depending\
    \ on external network conditions (such as, but not\n   limited to, which name\
    \ lookup mechanism responds faster).\n   It is unimportant whether a name ending\
    \ with \".local.\" occurred\n   because the user explicitly typed in a fully qualified\
    \ domain name\n   ending in \".local.\", or because the user entered an unqualified\n\
    \   domain name and the host software appended the suffix \".local.\"\n   because\
    \ that suffix appears in the user's search list.  The \".local.\"\n   suffix could\
    \ appear in the search list because the user manually\n   configured it, or because\
    \ it was received via DHCP [RFC2132] or via\n   any other mechanism for configuring\
    \ the DNS search list.  In this\n   respect the \".local.\" suffix is treated\
    \ no differently from any other\n   search domain that might appear in the DNS\
    \ search list.\n   DNS queries for names that do not end with \".local.\" MAY\
    \ be sent to\n   the mDNS multicast address, if no other conventional DNS server\
    \ is\n   available.  This can allow hosts on the same link to continue\n   communicating\
    \ using each other's globally unique DNS names during\n   network outages that\
    \ disrupt communication with the greater Internet.\n   When resolving global names\
    \ via local multicast, it is even more\n   important to use DNS Security Extensions\
    \ (DNSSEC) [RFC4033] or other\n   security mechanisms to ensure that the response\
    \ is trustworthy.\n   Resolving global names via local multicast is a contentious\
    \ issue,\n   and this document does not discuss it further, instead concentrating\n\
    \   on the issue of resolving local names using DNS messages sent to a\n   multicast\
    \ address.\n   This document recommends a single flat namespace for dot-local\
    \ host\n   names, (i.e., the names of DNS \"A\" and \"AAAA\" records, which map\n\
    \   names to IPv4 and IPv6 addresses), but other DNS record types (such\n   as\
    \ those used by DNS-Based Service Discovery [RFC6763]) may contain\n   as many\
    \ labels as appropriate for the desired usage, up to a maximum\n   of 255 bytes,\
    \ plus a terminating zero byte at the end.  Name length\n   issues are discussed\
    \ further in Appendix C.\n   Enforcing uniqueness of host names is probably desirable\
    \ in the\n   common case, but this document does not mandate that.  It is\n  \
    \ permissible for a collection of coordinated hosts to agree to\n   maintain multiple\
    \ DNS address records with the same name, possibly\n   for load-balancing or fault-tolerance\
    \ reasons.  This document does\n   not take a position on whether that is sensible.\
    \  It is important\n   that both modes of operation be supported.  The Multicast\
    \ DNS\n   protocol allows hosts to verify and maintain unique names for\n   resource\
    \ records where that behavior is desired, and it also allows\n   hosts to maintain\
    \ multiple resource records with a single shared name\n   where that behavior\
    \ is desired.  This consideration applies to all\n   resource records, not just\
    \ address records (host names).  In summary:\n   It is required that the protocol\
    \ have the ability to detect and\n   handle name conflicts, but it is not required\
    \ that this ability be\n   used for every record.\n"
- title: 4.  Reverse Address Mapping
  contents:
  - "4.  Reverse Address Mapping\n   Like \".local.\", the IPv4 and IPv6 reverse mapping\
    \ domains are also\n   defined to be link-local:\n      Any DNS query for a name\
    \ ending with \"254.169.in-addr.arpa.\" MUST\n      be sent to the mDNS IPv4 link-local\
    \ multicast address 224.0.0.251\n      or the mDNS IPv6 multicast address FF02::FB.\
    \  Since names under\n      this domain correspond to IPv4 link-local addresses,\
    \ it is logical\n      that the local link is the best place to find information\n\
    \      pertaining to those names.\n      Likewise, any DNS query for a name within\
    \ the reverse mapping\n      domains for IPv6 link-local addresses (\"8.e.f.ip6.arpa.\"\
    ,\n      \"9.e.f.ip6.arpa.\", \"a.e.f.ip6.arpa.\", and \"b.e.f.ip6.arpa.\") MUST\n\
    \      be sent to the mDNS IPv6 link-local multicast address FF02::FB or\n   \
    \   the mDNS IPv4 link-local multicast address 224.0.0.251.\n"
- title: 5.  Querying
  contents:
  - "5.  Querying\n   There are two kinds of Multicast DNS queries: one-shot queries\
    \ of the\n   kind made by legacy DNS resolvers, and continuous, ongoing Multicast\n\
    \   DNS queries made by fully compliant Multicast DNS queriers, which\n   support\
    \ asynchronous operations including DNS-Based Service Discovery\n   [RFC6763].\n\
    \   Except in the rare case of a Multicast DNS responder that is\n   advertising\
    \ only shared resource records and no unique records, a\n   Multicast DNS responder\
    \ MUST also implement a Multicast DNS querier\n   so that it can first verify\
    \ the uniqueness of those records before it\n   begins answering queries for them.\n"
- title: 5.1.  One-Shot Multicast DNS Queries
  contents:
  - "5.1.  One-Shot Multicast DNS Queries\n   The most basic kind of Multicast DNS\
    \ client may simply send standard\n   DNS queries blindly to 224.0.0.251:5353,\
    \ without necessarily even\n   being aware of what a multicast address is.  This\
    \ change can\n   typically be implemented with just a few lines of code in an\
    \ existing\n   DNS resolver library.  If a name being queried falls within one\
    \ of\n   the reserved Multicast DNS domains (see Sections 3 and 4), then,\n  \
    \ rather than using the configured Unicast DNS server address, the\n   query is\
    \ instead sent to 224.0.0.251:5353 (or its IPv6 equivalent\n   [FF02::FB]:5353).\
    \  Typically, the timeout would also be shortened to\n   two or three seconds.\
    \  It's possible to make a minimal Multicast DNS\n   resolver with only these\
    \ simple changes.  These queries are typically\n   done using a high-numbered\
    \ ephemeral UDP source port, but regardless\n   of whether they are sent from\
    \ a dynamic port or from a fixed port,\n   these queries MUST NOT be sent using\
    \ UDP source port 5353, since\n   using UDP source port 5353 signals the presence\
    \ of a fully compliant\n   Multicast DNS querier, as described below.\n   A simple\
    \ DNS resolver like this will typically just take the first\n   response it receives.\
    \  It will not listen for additional UDP\n   responses, but in many instances\
    \ this may not be a serious problem.\n   If a user types \"http://MyPrinter.local.\"\
    \ into their web browser, and\n   their simple DNS resolver just takes the first\
    \ response it receives,\n   and the user gets to see the status and configuration\
    \ web page for\n   their printer, then the protocol has met the user's needs in\
    \ this\n   case.\n   While a basic DNS resolver like this may be adequate for\
    \ simple host\n   name lookup, it may not get ideal behavior in other cases.\n\
    \   Additional refinements to create a fully compliant Multicast DNS\n   querier\
    \ are described below.\n"
- title: 5.2.  Continuous Multicast DNS Querying
  contents:
  - "5.2.  Continuous Multicast DNS Querying\n   In one-shot queries, the underlying\
    \ assumption is that the\n   transaction begins when the application issues a\
    \ query, and ends when\n   the first response is received.  There is another type\
    \ of query\n   operation that is more asynchronous, in which having received one\n\
    \   response is not necessarily an indication that there will be no more\n   relevant\
    \ responses, and the querying operation continues until no\n   further responses\
    \ are required.  Determining when no further\n   responses are required depends\
    \ on the type of operation being\n   performed.  If the operation is looking up\
    \ the IPv4 and IPv6\n   addresses of another host, then no further responses are\
    \ required\n   once a successful connection has been made to one of those IPv4\
    \ or\n   IPv6 addresses.  If the operation is browsing to present the user\n \
    \  with a list of DNS-SD services found on the network [RFC6763], then\n   no\
    \ further responses are required once the user indicates this to the\n   user-interface\
    \ software, e.g., by closing the network browsing window\n   that was displaying\
    \ the list of discovered services.\n   Imagine some hypothetical software that\
    \ allows users to discover\n   network printers.  The user wishes to discover\
    \ all printers on the\n   local network, not only the printer that is quickest\
    \ to respond.\n   When the user is actively looking for a network printer to use,\
    \ they\n   open a network browsing window that displays the list of discovered\n\
    \   printers.  It would be convenient for the user if they could rely on\n   this\
    \ list of network printers to stay up to date as network printers\n   come and\
    \ go, rather than displaying out-of-date stale information,\n   and requiring\
    \ the user explicitly to click a \"refresh\" button any\n   time they want to\
    \ see accurate information (which, from the moment it\n   is displayed, is itself\
    \ already beginning to become out-of-date and\n   stale).  If we are to display\
    \ a continuously updated live list like\n   this, we need to be able to do it\
    \ efficiently, without naive constant\n   polling, which would be an unreasonable\
    \ burden on the network.  It is\n   not expected that all users will be browsing\
    \ to discover new printers\n   all the time, but when a user is browsing to discover\
    \ service\n   instances for an extended period, we want to be able to support\
    \ that\n   operation efficiently.\n   Therefore, when retransmitting Multicast\
    \ DNS queries to implement\n   this kind of continuous monitoring, the interval\
    \ between the first\n   two queries MUST be at least one second, the intervals\
    \ between\n   successive queries MUST increase by at least a factor of two, and\
    \ the\n   querier MUST implement Known-Answer Suppression, as described below\n\
    \   in Section 7.1.  The Known-Answer Suppression mechanism tells\n   responders\
    \ which answers are already known to the querier, thereby\n   allowing responders\
    \ to avoid wasting network capacity with pointless\n   repeated transmission of\
    \ those answers.  A querier retransmits its\n   question because it wishes to\
    \ receive answers it may have missed the\n   first time, not because it wants\
    \ additional duplicate copies of\n   answers it already received.  Failure to\
    \ implement Known-Answer\n   Suppression can result in unacceptable levels of\
    \ network traffic.\n   When the interval between queries reaches or exceeds 60\
    \ minutes, a\n   querier MAY cap the interval to a maximum of 60 minutes, and\
    \ perform\n   subsequent queries at a steady-state rate of one query per hour.\
    \  To\n   avoid accidental synchronization when, for some reason, multiple\n \
    \  clients begin querying at exactly the same moment (e.g., because of\n   some\
    \ common external trigger event), a Multicast DNS querier SHOULD\n   also delay\
    \ the first query of the series by a randomly chosen amount\n   in the range 20-120\
    \ ms.\n   When a Multicast DNS querier receives an answer, the answer contains\n\
    \   a TTL value that indicates for how many seconds this answer is valid.\n  \
    \ After this interval has passed, the answer will no longer be valid\n   and SHOULD\
    \ be deleted from the cache.  Before the record expiry time\n   is reached, a\
    \ Multicast DNS querier that has local clients with an\n   active interest in\
    \ the state of that record (e.g., a network browsing\n   window displaying a list\
    \ of discovered services to the user) SHOULD\n   reissue its query to determine\
    \ whether the record is still valid.\n   To perform this cache maintenance, a\
    \ Multicast DNS querier should\n   plan to retransmit its query after at least\
    \ 50% of the record\n   lifetime has elapsed.  This document recommends the following\n\
    \   specific strategy.\n   The querier should plan to issue a query at 80% of\
    \ the record\n   lifetime, and then if no answer is received, at 85%, 90%, and\
    \ 95%.\n   If an answer is received, then the remaining TTL is reset to the\n\
    \   value given in the answer, and this process repeats for as long as\n   the\
    \ Multicast DNS querier has an ongoing interest in the record.  If\n   no answer\
    \ is received after four queries, the record is deleted when\n   it reaches 100%\
    \ of its lifetime.  A Multicast DNS querier MUST NOT\n   perform this cache maintenance\
    \ for records for which it has no local\n   clients with an active interest. \
    \ If the expiry of a particular\n   record from the cache would result in no net\
    \ effect to any client\n   software running on the querier device, and no visible\
    \ effect to the\n   human user, then there is no reason for the Multicast DNS\
    \ querier to\n   waste network capacity checking whether the record remains valid.\n\
    \   To avoid the case where multiple Multicast DNS queriers on a network\n   all\
    \ issue their queries simultaneously, a random variation of 2% of\n   the record\
    \ TTL should be added, so that queries are scheduled to be\n   performed at 80-82%,\
    \ 85-87%, 90-92%, and then 95-97% of the TTL.\n   An additional efficiency optimization\
    \ SHOULD be performed when a\n   Multicast DNS response is received containing\
    \ a unique answer (as\n   indicated by the cache-flush bit being set, described\
    \ in Section\n   10.2, \"Announcements to Flush Outdated Cache Entries\").  In\
    \ this\n   case, there is no need for the querier to continue issuing a stream\n\
    \   of queries with exponentially increasing intervals, since the receipt\n  \
    \ of a unique answer is a good indication that no other answers will be\n   forthcoming.\
    \  In this case, the Multicast DNS querier SHOULD plan to\n   issue its next query\
    \ for this record at 80-82% of the record's TTL,\n   as described above.\n   A\
    \ compliant Multicast DNS querier, which implements the rules\n   specified in\
    \ this document, MUST send its Multicast DNS queries from\n   UDP source port\
    \ 5353 (the well-known port assigned to mDNS), and MUST\n   listen for Multicast\
    \ DNS replies sent to UDP destination port 5353 at\n   the mDNS link-local multicast\
    \ address (224.0.0.251 and/or its IPv6\n   equivalent FF02::FB).\n"
- title: 5.3.  Multiple Questions per Query
  contents:
  - "5.3.  Multiple Questions per Query\n   Multicast DNS allows a querier to place\
    \ multiple questions in the\n   Question Section of a single Multicast DNS query\
    \ message.\n   The semantics of a Multicast DNS query message containing multiple\n\
    \   questions is identical to a series of individual DNS query messages\n   containing\
    \ one question each.  Combining multiple questions into a\n   single message is\
    \ purely an efficiency optimization and has no other\n   semantic significance.\n"
- title: 5.4.  Questions Requesting Unicast Responses
  contents:
  - "5.4.  Questions Requesting Unicast Responses\n   Sending Multicast DNS responses\
    \ via multicast has the benefit that\n   all the other hosts on the network get\
    \ to see those responses,\n   enabling them to keep their caches up to date and\
    \ detect conflicting\n   responses.\n   However, there are situations where all\
    \ the other hosts on the\n   network don't need to see every response.  Some examples\
    \ are a laptop\n   computer waking from sleep, the Ethernet cable being connected\
    \ to a\n   running machine, or a previously inactive interface being activated\n\
    \   through a configuration change.  At the instant of wake-up or link\n   activation,\
    \ the machine is a brand new participant on a new network.\n   Its Multicast DNS\
    \ cache for that interface is empty, and it has no\n   knowledge of its peers\
    \ on that link.  It may have a significant\n   number of questions that it wants\
    \ answered right away, to discover\n   information about its new surroundings\
    \ and present that information\n   to the user.  As a new participant on the network,\
    \ it has no idea\n   whether the exact same questions may have been asked and\
    \ answered\n   just seconds ago.  In this case, triggering a large sudden flood\
    \ of\n   multicast responses may impose an unreasonable burden on the network.\n\
    \   To avoid large floods of potentially unnecessary responses in these\n   cases,\
    \ Multicast DNS defines the top bit in the class field of a DNS\n   question as\
    \ the unicast-response bit.  When this bit is set in a\n   question, it indicates\
    \ that the querier is willing to accept unicast\n   replies in response to this\
    \ specific query, as well as the usual\n   multicast responses.  These questions\
    \ requesting unicast responses\n   are referred to as \"QU\" questions, to distinguish\
    \ them from the more\n   usual questions requesting multicast responses (\"QM\"\
    \ questions).  A\n   Multicast DNS querier sending its initial batch of questions\n\
    \   immediately on wake from sleep or interface activation SHOULD set the\n  \
    \ unicast-response bit in those questions.\n   When a question is retransmitted\
    \ (as described in Section 5.2), the\n   unicast-response bit SHOULD NOT be set\
    \ in subsequent retransmissions\n   of that question.  Subsequent retransmissions\
    \ SHOULD be usual \"QM\"\n   questions.  After the first question has received\
    \ its responses, the\n   querier should have a large Known-Answer list (Section\
    \ 7.1) so that\n   subsequent queries should elicit few, if any, further responses.\n\
    \   Reverting to multicast responses as soon as possible is important\n   because\
    \ of the benefits that multicast responses provide (see\n   Appendix D).  In addition,\
    \ the unicast-response bit SHOULD be set\n   only for questions that are active\
    \ and ready to be sent the moment of\n   wake from sleep or interface activation.\
    \  New questions created by\n   local clients afterwards should be treated as\
    \ normal \"QM\" questions\n   and SHOULD NOT have the unicast-response bit set\
    \ on the first\n   question of the series.\n   When receiving a question with\
    \ the unicast-response bit set, a\n   responder SHOULD usually respond with a\
    \ unicast packet directed back\n   to the querier.  However, if the responder\
    \ has not multicast that\n   record recently (within one quarter of its TTL),\
    \ then the responder\n   SHOULD instead multicast the response so as to keep all\
    \ the peer\n   caches up to date, and to permit passive conflict detection.  In\
    \ the\n   case of answering a probe question (Section 8.1) with the unicast-\n\
    \   response bit set, the responder should always generate the requested\n   unicast\
    \ response, but it may also send a multicast announcement if\n   the time since\
    \ the last multicast announcement of that record is more\n   than a quarter of\
    \ its TTL.\n   Unicast replies are subject to all the same packet generation rules\n\
    \   as multicast replies, including the cache-flush bit (Section 10.2)\n   and\
    \ (except when defending a unique name against a probe from another\n   host)\
    \ randomized delays to reduce network collisions (Section 6).\n"
- title: 5.5.  Direct Unicast Queries to Port 5353
  contents:
  - "5.5.  Direct Unicast Queries to Port 5353\n   In specialized applications there\
    \ may be rare situations where it\n   makes sense for a Multicast DNS querier\
    \ to send its query via unicast\n   to a specific machine.  When a Multicast DNS\
    \ responder receives a\n   query via direct unicast, it SHOULD respond as it would\
    \ for \"QU\"\n   questions, as described above in Section 5.4.  Since it is possible\n\
    \   for a unicast query to be received from a machine outside the local\n   link,\
    \ responders SHOULD check that the source address in the query\n   packet matches\
    \ the local subnet for that link (or, in the case of\n   IPv6, the source address\
    \ has an on-link prefix) and silently ignore\n   the packet if not.\n   There\
    \ may be specialized situations, outside the scope of this\n   document, where\
    \ it is intended and desirable to create a responder\n   that does answer queries\
    \ originating outside the local link.  Such a\n   responder would need to ensure\
    \ that these non-local queries are\n   always answered via unicast back to the\
    \ querier, since an answer sent\n   via link-local multicast would not reach a\
    \ querier outside the local\n   link.\n"
- title: 6.  Responding
  contents:
  - "6.  Responding\n   When a Multicast DNS responder constructs and sends a Multicast\
    \ DNS\n   response message, the Resource Record Sections of that message must\n\
    \   contain only records for which that responder is explicitly\n   authoritative.\
    \  These answers may be generated because the record\n   answers a question received\
    \ in a Multicast DNS query message, or at\n   certain other times that the responder\
    \ determines than an unsolicited\n   announcement is warranted.  A Multicast DNS\
    \ responder MUST NOT place\n   records from its cache, which have been learned\
    \ from other responders\n   on the network, in the Resource Record Sections of\
    \ outgoing response\n   messages.  Only an authoritative source for a given record\
    \ is allowed\n   to issue responses containing that record.\n   The determination\
    \ of whether a given record answers a given question\n   is made using the standard\
    \ DNS rules: the record name must match the\n   question name, the record rrtype\
    \ must match the question qtype unless\n   the qtype is \"ANY\" (255) or the rrtype\
    \ is \"CNAME\" (5), and the record\n   rrclass must match the question qclass\
    \ unless the qclass is \"ANY\"\n   (255).  As with Unicast DNS, generally only\
    \ DNS class 1 (\"Internet\")\n   is used, but should client software use classes\
    \ other than 1, the\n   matching rules described above MUST be used.\n   A Multicast\
    \ DNS responder MUST only respond when it has a positive,\n   non-null response\
    \ to send, or it authoritatively knows that a\n   particular record does not exist.\
    \  For unique records, where the host\n   has already established sole ownership\
    \ of the name, it MUST return\n   negative answers to queries for records that\
    \ it knows not to exist.\n   For example, a host with no IPv6 address, that has\
    \ claimed sole\n   ownership of the name \"host.local.\" for all rrtypes, MUST\
    \ respond to\n   AAAA queries for \"host.local.\" by sending a negative answer\n\
    \   indicating that no AAAA records exist for that name.  See Section\n   6.1,\
    \ \"Negative Responses\".  For shared records, which are owned by no\n   single\
    \ host, the nonexistence of a given record is ascertained by the\n   failure of\
    \ any machine to respond to the Multicast DNS query, not by\n   any explicit negative\
    \ response.  For shared records, NXDOMAIN and\n   other error responses MUST NOT\
    \ be sent.\n   Multicast DNS responses MUST NOT contain any questions in the\n\
    \   Question Section.  Any questions in the Question Section of a\n   received\
    \ Multicast DNS response MUST be silently ignored.  Multicast\n   DNS queriers\
    \ receiving Multicast DNS responses do not care what\n   question elicited the\
    \ response; they care only that the information\n   in the response is true and\
    \ accurate.\n   A Multicast DNS responder on Ethernet [IEEE.802.3] and similar\
    \ shared\n   multiple access networks SHOULD have the capability of delaying its\n\
    \   responses by up to 500 ms, as described below.\n   If a large number of Multicast\
    \ DNS responders were all to respond\n   immediately to a particular query, a\
    \ collision would be virtually\n   guaranteed.  By imposing a small random delay,\
    \ the number of\n   collisions is dramatically reduced.  On a full-sized Ethernet\
    \ using\n   the maximum cable lengths allowed and the maximum number of repeaters\n\
    \   allowed, an Ethernet frame is vulnerable to collisions during the\n   transmission\
    \ of its first 256 bits.  On 10 Mb/s Ethernet, this\n   equates to a vulnerable\
    \ time window of 25.6 microseconds.  On higher-\n   speed variants of Ethernet,\
    \ the vulnerable time window is shorter.\n   In the case where a Multicast DNS\
    \ responder has good reason to\n   believe that it will be the only responder\
    \ on the link that will send\n   a response (i.e., because it is able to answer\
    \ every question in the\n   query message, and for all of those answer records\
    \ it has previously\n   verified that the name, rrtype, and rrclass are unique\
    \ on the link),\n   it SHOULD NOT impose any random delay before responding, and\
    \ SHOULD\n   normally generate its response within at most 10 ms.  In particular,\n\
    \   this applies to responding to probe queries with the unicast-response\n  \
    \ bit set.  Since receiving a probe query gives a clear indication that\n   some\
    \ other responder is planning to start using this name in the very\n   near future,\
    \ answering such probe queries to defend a unique record\n   is a high priority\
    \ and needs to be done without delay.  A probe query\n   can be distinguished\
    \ from a normal query by the fact that a probe\n   query contains a proposed record\
    \ in the Authority Section that\n   answers the question in the Question Section\
    \ (for more details, see\n   Section 8.2, \"Simultaneous Probe Tiebreaking\").\n\
    \   Responding without delay is appropriate for records like the address\n   record\
    \ for a particular host name, when the host name has been\n   previously verified\
    \ unique.  Responding without delay is *not*\n   appropriate for things like looking\
    \ up PTR records used for DNS-Based\n   Service Discovery [RFC6763], where a large\
    \ number of responses may be\n   anticipated.\n   In any case where there may\
    \ be multiple responses, such as queries\n   where the answer is a member of a\
    \ shared resource record set, each\n   responder SHOULD delay its response by\
    \ a random amount of time\n   selected with uniform random distribution in the\
    \ range 20-120 ms.\n   The reason for requiring that the delay be at least 20\
    \ ms is to\n   accommodate the situation where two or more query packets are sent\n\
    \   back-to-back, because in that case we want a responder with answers\n   to\
    \ more than one of those queries to have the opportunity to\n   aggregate all\
    \ of its answers into a single response message.\n   In the case where the query\
    \ has the TC (truncated) bit set,\n   indicating that subsequent Known-Answer\
    \ packets will follow,\n   responders SHOULD delay their responses by a random\
    \ amount of time\n   selected with uniform random distribution in the range 400-500\
    \ ms, to\n   allow enough time for all the Known-Answer packets to arrive, as\n\
    \   described in Section 7.2, \"Multipacket Known-Answer Suppression\".\n   The\
    \ source UDP port in all Multicast DNS responses MUST be 5353 (the\n   well-known\
    \ port assigned to mDNS).  Multicast DNS implementations\n   MUST silently ignore\
    \ any Multicast DNS responses they receive where\n   the source UDP port is not\
    \ 5353.\n   The destination UDP port in all Multicast DNS responses MUST be 5353,\n\
    \   and the destination address MUST be the mDNS IPv4 link-local\n   multicast\
    \ address 224.0.0.251 or its IPv6 equivalent FF02::FB, except\n   when generating\
    \ a reply to a query that explicitly requested a\n   unicast response:\n     \
    \ * via the unicast-response bit,\n      * by virtue of being a legacy query (Section\
    \ 6.7), or\n      * by virtue of being a direct unicast query.\n   Except for\
    \ these three specific cases, responses MUST NOT be sent via\n   unicast, because\
    \ then the \"Passive Observation of Failures\"\n   mechanisms described in Section\
    \ 10.5 would not work correctly.  Other\n   benefits of sending responses via\
    \ multicast are discussed in Appendix\n   D.  A Multicast DNS querier MUST only\
    \ accept unicast responses if\n   they answer a recently sent query (e.g., sent\
    \ within the last two\n   seconds) that explicitly requested unicast responses.\
    \  A Multicast\n   DNS querier MUST silently ignore all other unicast responses.\n\
    \   To protect the network against excessive packet flooding due to\n   software\
    \ bugs or malicious attack, a Multicast DNS responder MUST NOT\n   (except in\
    \ the one special case of answering probe queries) multicast\n   a record on a\
    \ given interface until at least one second has elapsed\n   since the last time\
    \ that record was multicast on that particular\n   interface.  A legitimate querier\
    \ on the network should have seen the\n   previous transmission and cached it.\
    \  A querier that did not receive\n   and cache the previous transmission will\
    \ retry its request and\n   receive a subsequent response.  In the special case\
    \ of answering\n   probe queries, because of the limited time before the probing\
    \ host\n   will make its decision about whether or not to use the name, a\n  \
    \ Multicast DNS responder MUST respond quickly.  In this special case\n   only,\
    \ when responding via multicast to a probe, a Multicast DNS\n   responder is only\
    \ required to delay its transmission as necessary to\n   ensure an interval of\
    \ at least 250 ms since the last time the record\n   was multicast on that interface.\n"
- title: 6.1.  Negative Responses
  contents:
  - "6.1.  Negative Responses\n   In the early design of Multicast DNS it was assumed\
    \ that explicit\n   negative responses would never be needed.  A host can assert\
    \ the\n   existence of the set of records that it claims to exist, and the\n \
    \  union of all such sets on a link is the set of Multicast DNS records\n   that\
    \ exist on that link.  Asserting the nonexistence of every record\n   in the complement\
    \ of that set -- i.e., all possible Multicast DNS\n   records that could exist\
    \ on this link but do not at this moment --\n   was felt to be impractical and\
    \ unnecessary.  The nonexistence of a\n   record would be ascertained by a querier\
    \ querying for it and failing\n   to receive a response from any of the hosts\
    \ currently attached to the\n   link.\n   However, operational experience showed\
    \ that explicit negative\n   responses can sometimes be valuable.  One such example\
    \ is when a\n   querier is querying for a AAAA record, and the host name in question\n\
    \   has no associated IPv6 addresses.  In this case, the responding host\n   knows\
    \ it currently has exclusive ownership of that name, and it knows\n   that it\
    \ currently does not have any IPv6 addresses, so an explicit\n   negative response\
    \ is preferable to the querier having to retransmit\n   its query multiple times,\
    \ and eventually give up with a timeout,\n   before it can conclude that a given\
    \ AAAA record does not exist.\n   Any time a responder receives a query for a\
    \ name for which it has\n   verified exclusive ownership, for a type for which\
    \ that name has no\n   records, the responder MUST (except as allowed in (a) below)\
    \ respond\n   asserting the nonexistence of that record using a DNS NSEC record\n\
    \   [RFC4034].  In the case of Multicast DNS the NSEC record is not being\n  \
    \ used for its usual DNSSEC [RFC4033] security properties, but simply\n   as a\
    \ way of expressing which records do or do not exist with a given\n   name.\n\
    \   On receipt of a question for a particular name, rrtype, and rrclass,\n   for\
    \ which a responder does have one or more unique answers, the\n   responder MAY\
    \ also include an NSEC record in the Additional Record\n   Section indicating\
    \ the nonexistence of other rrtypes for that name\n   and rrclass.\n   Implementers\
    \ working with devices with sufficient memory and CPU\n   resources MAY choose\
    \ to implement code to handle the full generality\n   of the DNS NSEC record [RFC4034],\
    \ including bitmaps up to 65,536 bits\n   long.  To facilitate use by devices\
    \ with limited memory and CPU\n   resources, Multicast DNS queriers are only REQUIRED\
    \ to be able to\n   parse a restricted form of the DNS NSEC record.  All compliant\n\
    \   Multicast DNS implementations MUST at least correctly generate and\n   parse\
    \ the restricted DNS NSEC record format described below:\n      o The 'Next Domain\
    \ Name' field contains the record's own name.\n        When used with name compression,\
    \ this means that the 'Next\n        Domain Name' field always takes exactly two\
    \ bytes in the\n        message.\n      o The Type Bit Map block number is 0.\n\
    \      o The Type Bit Map block length byte is a value in the range 1-32.\n  \
    \    o The Type Bit Map data is 1-32 bytes, as indicated by length\n        byte.\n\
    \   Because this restricted form of the DNS NSEC record is limited to\n   Type\
    \ Bit Map block number zero, it cannot express the existence of\n   rrtypes above\
    \ 255.  Consequently, if a Multicast DNS responder were\n   to have records with\
    \ rrtypes above 255, it MUST NOT generate these\n   restricted-form NSEC records\
    \ for those names, since to do so would\n   imply that the name has no records\
    \ with rrtypes above 255, which\n   would be false.  In such cases a Multicast\
    \ DNS responder MUST either\n   (a) emit no NSEC record for that name, or (b)\
    \ emit a full NSEC record\n   containing the appropriate Type Bit Map block(s)\
    \ with the correct\n   bits set for all the record types that exist.  In practice\
    \ this is\n   not a significant limitation, since rrtypes above 255 are not\n\
    \   currently in widespread use.\n   If a Multicast DNS implementation receives\
    \ an NSEC record where the\n   'Next Domain Name' field is not the record's own\
    \ name, then the\n   implementation SHOULD ignore the 'Next Domain Name' field\
    \ and process\n   the remainder of the NSEC record as usual.  In Multicast DNS\
    \ the\n   'Next Domain Name' field is not currently used, but it could be used\n\
    \   in a future version of this protocol, which is why a Multicast DNS\n   implementation\
    \ MUST NOT reject or ignore an NSEC record it receives\n   just because it finds\
    \ an unexpected value in the 'Next Domain Name'\n   field.\n   If a Multicast\
    \ DNS implementation receives an NSEC record containing\n   more than one Type\
    \ Bit Map, or where the Type Bit Map block number is\n   not zero, or where the\
    \ block length is not in the range 1-32, then\n   the Multicast DNS implementation\
    \ MAY silently ignore the entire NSEC\n   record.  A Multicast DNS implementation\
    \ MUST NOT ignore an entire\n   message just because that message contains one\
    \ or more NSEC record(s)\n   that the Multicast DNS implementation cannot parse.\
    \  This provision\n   is to allow future enhancements to the protocol to be introduced\
    \ in a\n   backwards-compatible way that does not break compatibility with older\n\
    \   Multicast DNS implementations.\n   To help differentiate these synthesized\
    \ NSEC records (generated\n   programmatically on-the-fly) from conventional Unicast\
    \ DNS NSEC\n   records (which actually exist in a signed DNS zone), the synthesized\n\
    \   Multicast DNS NSEC records MUST NOT have the NSEC bit set in the Type\n  \
    \ Bit Map, whereas conventional Unicast DNS NSEC records do have the\n   NSEC\
    \ bit set.\n   The TTL of the NSEC record indicates the intended lifetime of the\n\
    \   negative cache entry.  In general, the TTL given for an NSEC record\n   SHOULD\
    \ be the same as the TTL that the record would have had, had it\n   existed. \
    \ For example, the TTL for address records in Multicast DNS\n   is typically 120\
    \ seconds (see Section 10), so the negative cache\n   lifetime for an address\
    \ record that does not exist should also be 120\n   seconds.\n   A responder MUST\
    \ only generate negative responses to queries for\n   which it has legitimate\
    \ ownership of the name, rrtype, and rrclass in\n   question, and can legitimately\
    \ assert that no record with that name,\n   rrtype, and rrclass exists.  A responder\
    \ can assert that a specified\n   rrtype does not exist for one of its names if\
    \ it knows a priori that\n   it has exclusive ownership of that name (e.g., names\
    \ of reverse\n   address mapping PTR records, which are derived from IP addresses,\n\
    \   which should be unique on the local link) or if it previously claimed\n  \
    \ unique ownership of that name using probe queries for rrtype \"ANY\".\n   (If\
    \ it were to use probe queries for a specific rrtype, then it would\n   only own\
    \ the name for that rrtype, and could not assert that other\n   rrtypes do not\
    \ exist.)\n   The design rationale for this mechanism for encoding negative\n\
    \   responses is discussed further in Appendix E.\n"
- title: 6.2.  Responding to Address Queries
  contents:
  - "6.2.  Responding to Address Queries\n   When a Multicast DNS responder sends\
    \ a Multicast DNS response message\n   containing its own address records, it\
    \ MUST include all addresses\n   that are valid on the interface on which it is\
    \ sending the message,\n   and MUST NOT include addresses that are not valid on\
    \ that interface\n   (such as addresses that may be configured on the host's other\n\
    \   interfaces).  For example, if an interface has both an IPv6 link-\n   local\
    \ and an IPv6 routable address, both should be included in the\n   response message\
    \ so that queriers receive both and can make their own\n   choice about which\
    \ to use.  This allows a querier that only has an\n   IPv6 link-local address\
    \ to connect to the link-local address, and a\n   different querier that has an\
    \ IPv6 routable address to connect to the\n   IPv6 routable address instead.\n\
    \   When a Multicast DNS responder places an IPv4 or IPv6 address record\n   (rrtype\
    \ \"A\" or \"AAAA\") into a response message, it SHOULD also place\n   any records\
    \ of the other address type with the same name into the\n   additional section,\
    \ if there is space in the message.  This is to\n   provide fate sharing, so that\
    \ all a device's addresses are delivered\n   atomically in a single message, to\
    \ reduce the risk that packet loss\n   could cause a querier to receive only the\
    \ IPv4 addresses and not the\n   IPv6 addresses, or vice versa.\n   In the event\
    \ that a device has only IPv4 addresses but no IPv6\n   addresses, or vice versa,\
    \ then the appropriate NSEC record SHOULD be\n   placed into the additional section,\
    \ so that queriers can know with\n   certainty that the device has no addresses\
    \ of that kind.\n   Some Multicast DNS responders treat a physical interface with\
    \ both\n   IPv4 and IPv6 address as a single interface with two addresses.\n \
    \  Other Multicast DNS responders may treat this case as logically two\n   interfaces\
    \ (one with one or more IPv4 addresses, and the other with\n   one or more IPv6\
    \ addresses), but responders that operate this way\n   MUST NOT put the corresponding\
    \ automatic NSEC records in replies they\n   send (i.e., a negative IPv4 assertion\
    \ in their IPv6 responses, and a\n   negative IPv6 assertion in their IPv4 responses)\
    \ because this would\n   cause incorrect operation in responders on the network\
    \ that work the\n   former way.\n"
- title: 6.3.  Responding to Multiquestion Queries
  contents:
  - "6.3.  Responding to Multiquestion Queries\n   Multicast DNS responders MUST correctly\
    \ handle DNS query messages\n   containing more than one question, by answering\
    \ any or all of the\n   questions to which they have answers.  Unlike single-question\n\
    \   queries, where responding without delay is allowed in appropriate\n   cases,\
    \ for query messages containing more than one question, all\n   (non-defensive)\
    \ answers SHOULD be randomly delayed in the range\n   20-120 ms, or 400-500 ms\
    \ if the TC (truncated) bit is set.  This is\n   because when a query message\
    \ contains more than one question, a\n   Multicast DNS responder cannot generally\
    \ be certain that other\n   responders will not also be simultaneously generating\
    \ answers to\n   other questions in that query message.  (Answers defending a\
    \ name, in\n   response to a probe for that name, are not subject to this delay\
    \ rule\n   and are still sent immediately.)\n"
- title: 6.4.  Response Aggregation
  contents:
  - "6.4.  Response Aggregation\n   When possible, a responder SHOULD, for the sake\
    \ of network\n   efficiency, aggregate as many responses as possible into a single\n\
    \   Multicast DNS response message.  For example, when a responder has\n   several\
    \ responses it plans to send, each delayed by a different\n   interval, then earlier\
    \ responses SHOULD be delayed by up to an\n   additional 500 ms if that will permit\
    \ them to be aggregated with\n   other responses scheduled to go out a little\
    \ later.\n"
- title: 6.5.  Wildcard Queries (qtype "ANY" and qclass "ANY")
  contents:
  - "6.5.  Wildcard Queries (qtype \"ANY\" and qclass \"ANY\")\n   When responding\
    \ to queries using qtype \"ANY\" (255) and/or qclass\n   \"ANY\" (255), a Multicast\
    \ DNS responder MUST respond with *ALL* of its\n   records that match the query.\
    \  This is subtly different from how\n   qtype \"ANY\" and qclass \"ANY\" work\
    \ in Unicast DNS.\n   A common misconception is that a Unicast DNS query for qtype\
    \ \"ANY\"\n   will elicit a response containing all matching records.  This is\n\
    \   incorrect.  If there are any records that match the query, the\n   response\
    \ is required only to contain at least one of them, not\n   necessarily all of\
    \ them.\n   This somewhat surprising behavior is commonly seen with caching\n\
    \   (i.e., \"recursive\") name servers.  If a caching server receives a\n   qtype\
    \ \"ANY\" query for which it has at least one valid answer, it is\n   allowed\
    \ to return only those matching answers it happens to have\n   already in its\
    \ cache, and it is not required to reconsult the\n   authoritative name server\
    \ to check if there are any more records that\n   also match the qtype \"ANY\"\
    \ query.\n   For example, one might imagine that a query for qtype \"ANY\" for\
    \ name\n   \"host.example.com\" would return both the IPv4 (A) and the IPv6 (AAAA)\n\
    \   address records for that host.  In reality, what happens is that it\n   depends\
    \ on the history of what queries have been previously received\n   by intervening\
    \ caching servers.  If a caching server has no records\n   for \"host.example.com\"\
    , then it will consult another server (usually\n   the authoritative name server\
    \ for the name in question), and, in that\n   case, it will typically return all\
    \ IPv4 and IPv6 address records.\n   However, if some other host has recently\
    \ done a query for qtype \"A\"\n   for name \"host.example.com\", so that the\
    \ caching server already has\n   IPv4 address records for \"host.example.com\"\
    \ in its cache but no IPv6\n   address records, then it will return only the IPv4\
    \ address records it\n   already has cached, and no IPv6 address records.\n  \
    \ Multicast DNS does not share this property that qtype \"ANY\" and\n   qclass\
    \ \"ANY\" queries return some undefined subset of the matching\n   records.  When\
    \ responding to queries using qtype \"ANY\" (255) and/or\n   qclass \"ANY\" (255),\
    \ a Multicast DNS responder MUST respond with *ALL*\n   of its records that match\
    \ the query.\n"
- title: 6.6.  Cooperating Multicast DNS Responders
  contents:
  - "6.6.  Cooperating Multicast DNS Responders\n   If a Multicast DNS responder (\"\
    A\") observes some other Multicast DNS\n   responder (\"B\") send a Multicast\
    \ DNS response message containing a\n   resource record with the same name, rrtype,\
    \ and rrclass as one of A's\n   resource records, but *different* rdata, then:\n\
    \      o If A's resource record is intended to be a shared resource\n        record,\
    \ then this is no conflict, and no action is required.\n      o If A's resource\
    \ record is intended to be a member of a unique\n        resource record set owned\
    \ solely by that responder, then this is\n        a conflict and MUST be handled\
    \ as described in Section 9,\n        \"Conflict Resolution\".\n   If a Multicast\
    \ DNS responder (\"A\") observes some other Multicast DNS\n   responder (\"B\"\
    ) send a Multicast DNS response message containing a\n   resource record with\
    \ the same name, rrtype, and rrclass as one of A's\n   resource records, and *identical*\
    \ rdata, then:\n      o If the TTL of B's resource record given in the message\
    \ is at\n        least half the true TTL from A's point of view, then no action\n\
    \        is required.\n      o If the TTL of B's resource record given in the\
    \ message is less\n        than half the true TTL from A's point of view, then\
    \ A MUST mark\n        its record to be announced via multicast.  Queriers receiving\n\
    \        the record from B would use the TTL given by B and, hence, may\n    \
    \    delete the record sooner than A expects.  By sending its own\n        multicast\
    \ response correcting the TTL, A ensures that the record\n        will be retained\
    \ for the desired time.\n   These rules allow multiple Multicast DNS responders\
    \ to offer the same\n   data on the network (perhaps for fault-tolerance reasons)\
    \ without\n   conflicting with each other.\n"
- title: 6.7.  Legacy Unicast Responses
  contents:
  - "6.7.  Legacy Unicast Responses\n   If the source UDP port in a received Multicast\
    \ DNS query is not port\n   5353, this indicates that the querier originating\
    \ the query is a\n   simple resolver such as described in Section 5.1, \"One-Shot\
    \ Multicast\n   DNS Queries\", which does not fully implement all of Multicast\
    \ DNS.\n   In this case, the Multicast DNS responder MUST send a UDP response\n\
    \   directly back to the querier, via unicast, to the query packet's\n   source\
    \ IP address and port.  This unicast response MUST be a\n   conventional unicast\
    \ response as would be generated by a conventional\n   Unicast DNS server; for\
    \ example, it MUST repeat the query ID and the\n   question given in the query\
    \ message.  In addition, the cache-flush\n   bit described in Section 10.2, \"\
    Announcements to Flush Outdated Cache\n   Entries\", MUST NOT be set in legacy\
    \ unicast responses.\n   The resource record TTL given in a legacy unicast response\
    \ SHOULD NOT\n   be greater than ten seconds, even if the true TTL of the Multicast\n\
    \   DNS resource record is higher.  This is because Multicast DNS\n   responders\
    \ that fully participate in the protocol use the cache\n   coherency mechanisms\
    \ described in Section 10, \"Resource Record TTL\n   Values and Cache Coherency\"\
    , to update and invalidate stale data.\n   Were unicast responses sent to legacy\
    \ resolvers to use the same high\n   TTLs, these legacy resolvers, which do not\
    \ implement these cache\n   coherency mechanisms, could retain stale cached resource\
    \ record data\n   long after it is no longer valid.\n"
- title: 7.  Traffic Reduction
  contents:
  - "7.  Traffic Reduction\n   A variety of techniques are used to reduce the amount\
    \ of traffic on\n   the network.\n"
- title: 7.1.  Known-Answer Suppression
  contents:
  - "7.1.  Known-Answer Suppression\n   When a Multicast DNS querier sends a query\
    \ to which it already knows\n   some answers, it populates the Answer Section\
    \ of the DNS query\n   message with those answers.\n   Generally, this applies\
    \ only to Shared records, not Unique records,\n   since if a Multicast DNS querier\
    \ already has at least one Unique\n   record in its cache then it should not be\
    \ expecting further different\n   answers to this question, since the Unique record(s)\
    \ it already has\n   comprise the complete answer, so it has no reason to be sending\
    \ the\n   query at all.  In contrast, having some Shared records in its cache\n\
    \   does not necessarily imply that a Multicast DNS querier will not\n   receive\
    \ further answers to this query, and it is in this case that it\n   is beneficial\
    \ to use the Known-Answer list to suppress repeated\n   sending of redundant answers\
    \ that the querier already knows.\n   A Multicast DNS responder MUST NOT answer\
    \ a Multicast DNS query if\n   the answer it would give is already included in\
    \ the Answer Section\n   with an RR TTL at least half the correct value.  If the\
    \ RR TTL of the\n   answer as given in the Answer Section is less than half of\
    \ the true\n   RR TTL as known by the Multicast DNS responder, the responder MUST\n\
    \   send an answer so as to update the querier's cache before the record\n   becomes\
    \ in danger of expiration.\n   Because a Multicast DNS responder will respond\
    \ if the remaining TTL\n   given in the Known-Answer list is less than half the\
    \ true TTL, it is\n   superfluous for the querier to include such records in the\
    \ Known-\n   Answer list.  Therefore, a Multicast DNS querier SHOULD NOT include\n\
    \   records in the Known-Answer list whose remaining TTL is less than\n   half\
    \ of their original TTL.  Doing so would simply consume space in\n   the message\
    \ without achieving the goal of suppressing responses and\n   would, therefore,\
    \ be a pointless waste of network capacity.\n   A Multicast DNS querier MUST NOT\
    \ cache resource records observed in\n   the Known-Answer Section of other Multicast\
    \ DNS queries.  The Answer\n   Section of Multicast DNS queries is not authoritative.\
    \  By placing\n   information in the Answer Section of a Multicast DNS query,\
    \ the\n   querier is stating that it *believes* the information to be true.  It\n\
    \   is not asserting that the information *is* true.  Some of those\n   records\
    \ may have come from other hosts that are no longer on the\n   network.  Propagating\
    \ that stale information to other Multicast DNS\n   queriers on the network would\
    \ not be helpful.\n"
- title: 7.2.  Multipacket Known-Answer Suppression
  contents:
  - "7.2.  Multipacket Known-Answer Suppression\n   Sometimes a Multicast DNS querier\
    \ will already have too many answers\n   to fit in the Known-Answer Section of\
    \ its query packets.  In this\n   case, it should issue a Multicast DNS query\
    \ containing a question and\n   as many Known-Answer records as will fit.  It\
    \ MUST then set the TC\n   (Truncated) bit in the header before sending the query.\
    \  It MUST\n   immediately follow the packet with another query packet containing\
    \ no\n   questions and as many more Known-Answer records as will fit.  If\n  \
    \ there are still too many records remaining to fit in the packet, it\n   again\
    \ sets the TC bit and continues until all the Known-Answer\n   records have been\
    \ sent.\n   A Multicast DNS responder seeing a Multicast DNS query with the TC\n\
    \   bit set defers its response for a time period randomly selected in\n   the\
    \ interval 400-500 ms.  This gives the Multicast DNS querier time\n   to send\
    \ additional Known-Answer packets before the responder\n   responds.  If the responder\
    \ sees any of its answers listed in the\n   Known-Answer lists of subsequent packets\
    \ from the querying host, it\n   MUST delete that answer from the list of answers\
    \ it is planning to\n   give (provided that no other host on the network has also\
    \ issued a\n   query for that record and is waiting to receive an answer).\n \
    \  If the responder receives additional Known-Answer packets with the TC\n   bit\
    \ set, it SHOULD extend the delay as necessary to ensure a pause of\n   400-500\
    \ ms after the last such packet before it sends its answer.\n   This opens the\
    \ potential risk that a continuous stream of Known-\n   Answer packets could,\
    \ theoretically, prevent a responder from\n   answering indefinitely.  In practice,\
    \ answers are never actually\n   delayed significantly, and should a situation\
    \ arise where significant\n   delays did happen, that would be a scenario where\
    \ the network is so\n   overloaded that it would be desirable to err on the side\
    \ of caution.\n   The consequence of delaying an answer may be that it takes a\
    \ user\n   longer than usual to discover all the services on the local network;\n\
    \   in contrast, the consequence of incorrectly answering before all the\n   Known-Answer\
    \ packets have been received would be wasted capacity\n   sending unnecessary\
    \ answers on an already overloaded network.  In\n   this (rare) situation, sacrificing\
    \ speed to preserve reliable network\n   operation is the right trade-off.\n"
- title: 7.3.  Duplicate Question Suppression
  contents:
  - "7.3.  Duplicate Question Suppression\n   If a host is planning to transmit (or\
    \ retransmit) a query, and it\n   sees another host on the network send a query\
    \ containing the same\n   \"QM\" question, and the Known-Answer Section of that\
    \ query does not\n   contain any records that this host would not also put in\
    \ its own\n   Known-Answer Section, then this host SHOULD treat its own query\
    \ as\n   having been sent.  When multiple queriers on the network are querying\n\
    \   for the same resource records, there is no need for them to all be\n   repeatedly\
    \ asking the same question.\n"
- title: 7.4.  Duplicate Answer Suppression
  contents:
  - "7.4.  Duplicate Answer Suppression\n   If a host is planning to send an answer,\
    \ and it sees another host on\n   the network send a response message containing\
    \ the same answer\n   record, and the TTL in that record is not less than the\
    \ TTL this host\n   would have given, then this host SHOULD treat its own answer\
    \ as\n   having been sent, and not also send an identical answer itself.  When\n\
    \   multiple responders on the network have the same data, there is no\n   need\
    \ for all of them to respond.\n   The opportunity for duplicate answer suppression\
    \ occurs when a host\n   has received a query, and is delaying its response for\
    \ some pseudo-\n   random interval up to 500 ms, as described elsewhere in this\n\
    \   document, and then, before the host sends its response, it sees some\n   other\
    \ host on the network send a response message containing the same\n   answer record.\n\
    \   This feature is particularly useful when Multicast DNS Proxy Servers\n   are\
    \ in use, where there could be more than one proxy on the network\n   giving Multicast\
    \ DNS answers on behalf of some other host (e.g.,\n   because that other host\
    \ is currently asleep and is not itself\n   responding to queries).\n"
- title: 8.  Probing and Announcing on Startup
  contents:
  - "8.  Probing and Announcing on Startup\n   Typically a Multicast DNS responder\
    \ should have, at the very least,\n   address records for all of its active interfaces.\
    \  Creating and\n   advertising an HINFO record on each interface as well can\
    \ be useful\n   to network administrators.\n   Whenever a Multicast DNS responder\
    \ starts up, wakes up from sleep,\n   receives an indication of a network interface\
    \ \"Link Change\" event, or\n   has any other reason to believe that its network\
    \ connectivity may\n   have changed in some relevant way, it MUST perform the\
    \ two startup\n   steps below: Probing (Section 8.1) and Announcing (Section 8.3).\n"
- title: 8.1.  Probing
  contents:
  - "8.1.  Probing\n   The first startup step is that, for all those resource records\
    \ that a\n   Multicast DNS responder desires to be unique on the local link, it\n\
    \   MUST send a Multicast DNS query asking for those resource records, to\n  \
    \ see if any of them are already in use.  The primary example of this\n   is a\
    \ host's address records, which map its unique host name to its\n   unique IPv4\
    \ and/or IPv6 addresses.  All probe queries SHOULD be done\n   using the desired\
    \ resource record name and class (usually class 1,\n   \"Internet\"), and query\
    \ type \"ANY\" (255), to elicit answers for all\n   types of records with that\
    \ name.  This allows a single question to be\n   used in place of several questions,\
    \ which is more efficient on the\n   network.  It also allows a host to verify\
    \ exclusive ownership of a\n   name for all rrtypes, which is desirable in most\
    \ cases.  It would be\n   confusing, for example, if one host owned the \"A\"\
    \ record for\n   \"myhost.local.\", but a different host owned the \"AAAA\" record\
    \ for\n   that name.\n   The ability to place more than one question in a Multicast\
    \ DNS query\n   is useful here, because it can allow a host to use a single message\n\
    \   to probe for all of its resource records instead of needing a\n   separate\
    \ message for each.  For example, a host can simultaneously\n   probe for uniqueness\
    \ of its \"A\" record and all its SRV records\n   [RFC6763] in the same query\
    \ message.\n   When ready to send its Multicast DNS probe packet(s) the host should\n\
    \   first wait for a short random delay time, uniformly distributed in\n   the\
    \ range 0-250 ms.  This random delay is to guard against the case\n   where several\
    \ devices are powered on simultaneously, or several\n   devices are connected\
    \ to an Ethernet hub, which is then powered on,\n   or some other external event\
    \ happens that might cause a group of\n   hosts to all send synchronized probes.\n\
    \   250 ms after the first query, the host should send a second; then,\n   250\
    \ ms after that, a third.  If, by 250 ms after the third probe, no\n   conflicting\
    \ Multicast DNS responses have been received, the host may\n   move to the next\
    \ step, announcing.  (Note that probing is the one\n   exception from the normal\
    \ rule that there should be at least one\n   second between repetitions of the\
    \ same question, and the interval\n   between subsequent repetitions should at\
    \ least double.)\n   When sending probe queries, a host MUST NOT consult its cache\
    \ for\n   potential answers.  Only conflicting Multicast DNS responses received\n\
    \   \"live\" from the network are considered valid for the purposes of\n   determining\
    \ whether probing has succeeded or failed.\n   In order to allow services to announce\
    \ their presence without\n   unreasonable delay, the time window for probing is\
    \ intentionally set\n   quite short.  As a result of this, from the time the first\
    \ probe\n   packet is sent, another device on the network using that name has\n\
    \   just 750 ms to respond to defend its name.  On networks that are\n   slow,\
    \ or busy, or both, it is possible for round-trip latency to\n   account for a\
    \ few hundred milliseconds, and software delays in slow\n   devices can add additional\
    \ delay.  Hence, it is important that when a\n   device receives a probe query\
    \ for a name that it is currently using,\n   it SHOULD generate its response to\
    \ defend that name immediately and\n   send it as quickly as possible.  The usual\
    \ rules about random delays\n   before responding, to avoid sudden bursts of simultaneous\
    \ answers\n   from different hosts, do not apply here since normally at most one\n\
    \   host should ever respond to a given probe question.  Even when a\n   single\
    \ DNS query message contains multiple probe questions, it would\n   be unusual\
    \ for that message to elicit a defensive response from more\n   than one other\
    \ host.  Because of the mDNS multicast rate-limiting\n   rules, the probes SHOULD\
    \ be sent as \"QU\" questions with the unicast-\n   response bit set, to allow\
    \ a defending host to respond immediately\n   via unicast, instead of potentially\
    \ having to wait before replying\n   via multicast.\n   During probing, from the\
    \ time the first probe packet is sent until\n   250 ms after the third probe,\
    \ if any conflicting Multicast DNS\n   response is received, then the probing\
    \ host MUST defer to the\n   existing host, and SHOULD choose new names for some\
    \ or all of its\n   resource records as appropriate.  Apparently conflicting Multicast\n\
    \   DNS responses received *before* the first probe packet is sent MUST\n   be\
    \ silently ignored (see discussion of stale probe packets in Section\n   8.2,\
    \ \"Simultaneous Probe Tiebreaking\", below).  In the case of a host\n   probing\
    \ using query type \"ANY\" as recommended above, any answer\n   containing a record\
    \ with that name, of any type, MUST be considered a\n   conflicting response and\
    \ handled accordingly.\n   If fifteen conflicts occur within any ten-second period,\
    \ then the\n   host MUST wait at least five seconds before each successive\n \
    \  additional probe attempt.  This is to help ensure that, in the event\n   of\
    \ software bugs or other unanticipated problems, errant hosts do not\n   flood\
    \ the network with a continuous stream of multicast traffic.  For\n   very simple\
    \ devices, a valid way to comply with this requirement is\n   to always wait five\
    \ seconds after any failed probe attempt before\n   trying again.\n   If a responder\
    \ knows by other means that its unique resource record\n   set name, rrtype, and\
    \ rrclass cannot already be in use by any other\n   responder on the network,\
    \ then it SHOULD skip the probing step for\n   that resource record set.  For\
    \ example, when creating the reverse\n   address mapping PTR records, the host\
    \ can reasonably assume that no\n   other host will be trying to create those\
    \ same PTR records, since\n   that would imply that the two hosts were trying\
    \ to use the same IP\n   address, and if that were the case, the two hosts would\
    \ be suffering\n   communication problems beyond the scope of what Multicast DNS\
    \ is\n   designed to solve.  Similarly, if a responder is acting as a proxy,\n\
    \   taking over from another Multicast DNS responder that has already\n   verified\
    \ the uniqueness of the record, then the proxy SHOULD NOT\n   repeat the probing\
    \ step for those records.\n"
- title: 8.2.  Simultaneous Probe Tiebreaking
  contents:
  - "8.2.  Simultaneous Probe Tiebreaking\n   The astute reader will observe that\
    \ there is a race condition\n   inherent in the previous description.  If two\
    \ hosts are probing for\n   the same name simultaneously, neither will receive\
    \ any response to\n   the probe, and the hosts could incorrectly conclude that\
    \ they may\n   both proceed to use the name.  To break this symmetry, each host\n\
    \   populates the query message's Authority Section with the record or\n   records\
    \ with the rdata that it would be proposing to use, should its\n   probing be\
    \ successful.  The Authority Section is being used here in a\n   way analogous\
    \ to the way it is used as the \"Update Section\" in a DNS\n   Update message\
    \ [RFC2136] [RFC3007].\n   When a host is probing for a group of related records\
    \ with the same\n   name (e.g., the SRV and TXT record describing a DNS-SD service),\
    \ only\n   a single question need be placed in the Question Section, since query\n\
    \   type \"ANY\" (255) is used, which will elicit answers for all records\n  \
    \ with that name.  However, for tiebreaking to work correctly in all\n   cases,\
    \ the Authority Section must contain *all* the records and\n   proposed rdata\
    \ being probed for uniqueness.\n   When a host that is probing for a record sees\
    \ another host issue a\n   query for the same record, it consults the Authority\
    \ Section of that\n   query.  If it finds any resource record(s) there which answers\
    \ the\n   query, then it compares the data of that (those) resource record(s)\n\
    \   with its own tentative data.  We consider first the simple case of a\n   host\
    \ probing for a single record, receiving a simultaneous probe from\n   another\
    \ host also probing for a single record.  The two records are\n   compared and\
    \ the lexicographically later data wins.  This means that\n   if the host finds\
    \ that its own data is lexicographically later, it\n   simply ignores the other\
    \ host's probe.  If the host finds that its\n   own data is lexicographically\
    \ earlier, then it defers to the winning\n   host by waiting one second, and then\
    \ begins probing for this record\n   again.  The logic for waiting one second\
    \ and then trying again is to\n   guard against stale probe packets on the network\
    \ (possibly even stale\n   probe packets sent moments ago by this host itself,\
    \ before some\n   configuration change, which may be echoed back after a short\
    \ delay by\n   some Ethernet switches and some 802.11 base stations).  If the\n\
    \   winning simultaneous probe was from a real other host on the network,\n  \
    \ then after one second it will have completed its probing, and will\n   answer\
    \ subsequent probes.  If the apparently winning simultaneous\n   probe was in\
    \ fact just an old stale packet on the network (maybe from\n   the host itself),\
    \ then when it retries its probing in one second, its\n   probes will go unanswered,\
    \ and it will successfully claim the name.\n   The determination of \"lexicographically\
    \ later\" is performed by first\n   comparing the record class (excluding the\
    \ cache-flush bit described\n   in Section 10.2), then the record type, then raw\
    \ comparison of the\n   binary content of the rdata without regard for meaning\
    \ or structure.\n   If the record classes differ, then the numerically greater\
    \ class is\n   considered \"lexicographically later\".  Otherwise, if the record\
    \ types\n   differ, then the numerically greater type is considered\n   \"lexicographically\
    \ later\".  If the rrtype and rrclass both match,\n   then the rdata is compared.\n\
    \   In the case of resource records containing rdata that is subject to\n   name\
    \ compression [RFC1035], the names MUST be uncompressed before\n   comparison.\
    \  (The details of how a particular name is compressed is\n   an artifact of how\
    \ and where the record is written into the DNS\n   message; it is not an intrinsic\
    \ property of the resource record\n   itself.)\n   The bytes of the raw uncompressed\
    \ rdata are compared in turn,\n   interpreting the bytes as eight-bit UNSIGNED\
    \ values, until a byte is\n   found whose value is greater than that of its counterpart\
    \ (in which\n   case, the rdata whose byte has the greater value is deemed\n \
    \  lexicographically later) or one of the resource records runs out of\n   rdata\
    \ (in which case, the resource record which still has remaining\n   data first\
    \ is deemed lexicographically later).  The following is an\n   example of a conflict:\n\
    \     MyPrinter.local. A 169.254.99.200\n     MyPrinter.local. A 169.254.200.50\n\
    \   In this case, 169.254.200.50 is lexicographically later (the third\n   byte,\
    \ with value 200, is greater than its counterpart with value 99),\n   so it is\
    \ deemed the winner.\n   Note that it is vital that the bytes are interpreted\
    \ as UNSIGNED\n   values in the range 0-255, or the wrong outcome may result.\
    \  In the\n   example above, if the byte with value 200 had been incorrectly\n\
    \   interpreted as a signed eight-bit value, then it would be interpreted\n  \
    \ as value -56, and the wrong address record would be deemed the\n   winner.\n"
- title: 8.2.1.  Simultaneous Probe Tiebreaking for Multiple Records
  contents:
  - "8.2.1.  Simultaneous Probe Tiebreaking for Multiple Records\n   When a host is\
    \ probing for a set of records with the same name, or a\n   message is received\
    \ containing multiple tiebreaker records answering\n   a given probe question\
    \ in the Question Section, the host's records\n   and the tiebreaker records from\
    \ the message are each sorted into\n   order, and then compared pairwise, using\
    \ the same comparison\n   technique described above, until a difference is found.\n\
    \   The records are sorted using the same lexicographical order as\n   described\
    \ above, that is, if the record classes differ, the record\n   with the lower\
    \ class number comes first.  If the classes are the same\n   but the rrtypes differ,\
    \ the record with the lower rrtype number comes\n   first.  If the class and rrtype\
    \ match, then the rdata is compared\n   bytewise until a difference is found.\
    \  For example, in the common\n   case of advertising DNS-SD services with a TXT\
    \ record and an SRV\n   record, the TXT record comes first (the rrtype value for\
    \ TXT is 16)\n   and the SRV record comes second (the rrtype value for SRV is\
    \ 33).\n   When comparing the records, if the first records match perfectly,\n\
    \   then the second records are compared, and so on.  If either list of\n   records\
    \ runs out of records before any difference is found, then the\n   list with records\
    \ remaining is deemed to have won the tiebreak.  If\n   both lists run out of\
    \ records at the same time without any difference\n   being found, then this indicates\
    \ that two devices are advertising\n   identical sets of records, as is sometimes\
    \ done for fault tolerance,\n   and there is, in fact, no conflict.\n"
- title: 8.3.  Announcing
  contents:
  - "8.3.  Announcing\n   The second startup step is that the Multicast DNS responder\
    \ MUST send\n   an unsolicited Multicast DNS response containing, in the Answer\n\
    \   Section, all of its newly registered resource records (both shared\n   records,\
    \ and unique records that have completed the probing step).\n   If there are too\
    \ many resource records to fit in a single packet,\n   multiple packets should\
    \ be used.\n   In the case of shared records (e.g., the PTR records used by DNS-\n\
    \   Based Service Discovery [RFC6763]), the records are simply placed as\n   is\
    \ into the Answer Section of the DNS response.\n   In the case of records that\
    \ have been verified to be unique in the\n   previous step, they are placed into\
    \ the Answer Section of the DNS\n   response with the most significant bit of\
    \ the rrclass set to one.\n   The most significant bit of the rrclass for a record\
    \ in the Answer\n   Section of a response message is the Multicast DNS cache-flush\
    \ bit\n   and is discussed in more detail below in Section 10.2, \"Announcements\n\
    \   to Flush Outdated Cache Entries\".\n   The Multicast DNS responder MUST send\
    \ at least two unsolicited\n   responses, one second apart.  To provide increased\
    \ robustness against\n   packet loss, a responder MAY send up to eight unsolicited\
    \ responses,\n   provided that the interval between unsolicited responses increases\
    \ by\n   at least a factor of two with every response sent.\n   A Multicast DNS\
    \ responder MUST NOT send announcements in the absence\n   of information that\
    \ its network connectivity may have changed in some\n   relevant way.  In particular,\
    \ a Multicast DNS responder MUST NOT send\n   regular periodic announcements as\
    \ a matter of course.\n   Whenever a Multicast DNS responder receives any Multicast\
    \ DNS\n   response (solicited or otherwise) containing a conflicting resource\n\
    \   record, the conflict MUST be resolved as described in Section 9,\n   \"Conflict\
    \ Resolution\".\n"
- title: 8.4.  Updating
  contents:
  - "8.4.  Updating\n   At any time, if the rdata of any of a host's Multicast DNS\
    \ records\n   changes, the host MUST repeat the Announcing step described above\
    \ to\n   update neighboring caches.  For example, if any of a host's IP\n   addresses\
    \ change, it MUST re-announce those address records.  The\n   host does not need\
    \ to repeat the Probing step because it has already\n   established unique ownership\
    \ of that name.\n   In the case of shared records, a host MUST send a \"goodbye\"\
    \n   announcement with RR TTL zero (see Section 10.1, \"Goodbye Packets\")\n \
    \  for the old rdata, to cause it to be deleted from peer caches, before\n   announcing\
    \ the new rdata.  In the case of unique records, a host\n   SHOULD omit the \"\
    goodbye\" announcement, since the cache-flush bit on\n   the newly announced records\
    \ will cause old rdata to be flushed from\n   peer caches anyway.\n   A host may\
    \ update the contents of any of its records at any time,\n   though a host SHOULD\
    \ NOT update records more frequently than ten\n   times per minute.  Frequent\
    \ rapid updates impose a burden on the\n   network.  If a host has information\
    \ to disseminate which changes more\n   frequently than ten times per minute,\
    \ then it may be more appropriate\n   to design a protocol for that specific purpose.\n"
- title: 9.  Conflict Resolution
  contents:
  - "9.  Conflict Resolution\n   A conflict occurs when a Multicast DNS responder\
    \ has a unique record\n   for which it is currently authoritative, and it receives\
    \ a Multicast\n   DNS response message containing a record with the same name,\
    \ rrtype\n   and rrclass, but inconsistent rdata.  What may be considered\n  \
    \ inconsistent is context sensitive, except that resource records with\n   identical\
    \ rdata are never considered inconsistent, even if they\n   originate from different\
    \ hosts.  This is to permit use of proxies and\n   other fault-tolerance mechanisms\
    \ that may cause more than one\n   responder to be capable of issuing identical\
    \ answers on the network.\n   A common example of a resource record type that\
    \ is intended to be\n   unique, not shared between hosts, is the address record\
    \ that maps a\n   host's name to its IP address.  Should a host witness another\
    \ host\n   announce an address record with the same name but a different IP\n\
    \   address, then that is considered inconsistent, and that address\n   record\
    \ is considered to be in conflict.\n   Whenever a Multicast DNS responder receives\
    \ any Multicast DNS\n   response (solicited or otherwise) containing a conflicting\
    \ resource\n   record in any of the Resource Record Sections, the Multicast DNS\n\
    \   responder MUST immediately reset its conflicted unique record to\n   probing\
    \ state, and go through the startup steps described above in\n   Section 8, \"\
    Probing and Announcing on Startup\".  The protocol used in\n   the Probing phase\
    \ will determine a winner and a loser, and the loser\n   MUST cease using the\
    \ name, and reconfigure.\n   It is very important that any host receiving a resource\
    \ record that\n   conflicts with one of its own MUST take action as described\
    \ above.\n   In the case of two hosts using the same host name, where one has\
    \ been\n   configured to require a unique host name and the other has not, the\n\
    \   one that has not been configured to require a unique host name will\n   not\
    \ perceive any conflict, and will not take any action.  By\n   reverting to Probing\
    \ state, the host that desires a unique host name\n   will go through the necessary\
    \ steps to ensure that a unique host name\n   is obtained.\n   The recommended\
    \ course of action after probing and failing is as\n   follows:\n      1. Programmatically\
    \ change the resource record name in an attempt\n         to find a new name that\
    \ is unique.  This could be done by\n         adding some further identifying\
    \ information (e.g., the model\n         name of the hardware) if it is not already\
    \ present in the name,\n         or appending the digit \"2\" to the name, or\
    \ incrementing a\n         number at the end of the name if one is already present.\n\
    \      2. Probe again, and repeat as necessary until a unique name is\n      \
    \   found.\n      3. Once an available unique name has been determined, by probing\n\
    \         without receiving any conflicting response, record this newly\n    \
    \     chosen name in persistent storage so that the device will use\n        \
    \ the same name the next time it is power-cycled.\n      4. Display a message\
    \ to the user or operator informing them of the\n         name change.  For example:\n\
    \            The name \"Bob's Music\" is in use by another music server on\n \
    \           the network.  Your music collection has been renamed to\n        \
    \    \"Bob's Music (2)\".  If you want to change this name, use\n            [describe\
    \ appropriate menu item or preference dialog here].\n         The details of how\
    \ the user or operator is informed of the new\n         name depends on context.\
    \  A desktop computer with a screen\n         might put up a dialog box.  A headless\
    \ server in the closet may\n         write a message to a log file, or use whatever\
    \ mechanism\n         (email, SNMP trap, etc.) it uses to inform the administrator\
    \ of\n         error conditions.  On the other hand, a headless server in the\n\
    \         closet may not inform the user at all -- if the user cares,\n      \
    \   they will notice the name has changed, and connect to the\n         server\
    \ in the usual way (e.g., via web browser) to configure a\n         new name.\n\
    \      5. After one minute of probing, if the Multicast DNS responder has\n  \
    \       been unable to find any unused name, it should log an error\n        \
    \ message to inform the user or operator of this fact.  This\n         situation\
    \ should never occur in normal operation.  The only\n         situations that\
    \ would cause this to happen would be either a\n         deliberate denial-of-service\
    \ attack, or some kind of very\n         obscure hardware or software bug that\
    \ acts like a deliberate\n         denial-of-service attack.\n   These considerations\
    \ apply to address records (i.e., host names) and\n   to all resource records\
    \ where uniqueness (or maintenance of some\n   other defined constraint) is desired.\n"
- title: 10.  Resource Record TTL Values and Cache Coherency
  contents:
  - "10.  Resource Record TTL Values and Cache Coherency\n   As a general rule, the\
    \ recommended TTL value for Multicast DNS\n   resource records with a host name\
    \ as the resource record's name\n   (e.g., A, AAAA, HINFO) or a host name contained\
    \ within the resource\n   record's rdata (e.g., SRV, reverse mapping PTR record)\
    \ SHOULD be 120\n   seconds.\n   The recommended TTL value for other Multicast\
    \ DNS resource records is\n   75 minutes.\n   A querier with an active outstanding\
    \ query will issue a query message\n   when one or more of the resource records\
    \ in its cache are 80% of the\n   way to expiry.  If the TTL on those records\
    \ is 75 minutes, this\n   ongoing cache maintenance process yields a steady-state\
    \ query rate of\n   one query every 60 minutes.\n   Any distributed cache needs\
    \ a cache coherency protocol.  If Multicast\n   DNS resource records follow the\
    \ recommendation and have a TTL of 75\n   minutes, that means that stale data\
    \ could persist in the system for a\n   little over an hour.  Making the default\
    \ RR TTL significantly lower\n   would reduce the lifetime of stale data, but\
    \ would produce too much\n   extra traffic on the network.  Various techniques\
    \ are available to\n   minimize the impact of such stale data, outlined in the\
    \ five\n   subsections below.\n"
- title: 10.1.  Goodbye Packets
  contents:
  - "10.1.  Goodbye Packets\n   In the case where a host knows that certain resource\
    \ record data is\n   about to become invalid (for example, when the host is undergoing\
    \ a\n   clean shutdown), the host SHOULD send an unsolicited Multicast DNS\n \
    \  response packet, giving the same resource record name, rrtype,\n   rrclass,\
    \ and rdata, but an RR TTL of zero.  This has the effect of\n   updating the TTL\
    \ stored in neighboring hosts' cache entries to zero,\n   causing that cache entry\
    \ to be promptly deleted.\n   Queriers receiving a Multicast DNS response with\
    \ a TTL of zero SHOULD\n   NOT immediately delete the record from the cache, but\
    \ instead record\n   a TTL of 1 and then delete the record one second later. \
    \ In the case\n   of multiple Multicast DNS responders on the network described\
    \ in\n   Section 6.6 above, if one of the responders shuts down and\n   incorrectly\
    \ sends goodbye packets for its records, it gives the other\n   cooperating responders\
    \ one second to send out their own response to\n   \"rescue\" the records before\
    \ they expire and are deleted.\n"
- title: 10.2.  Announcements to Flush Outdated Cache Entries
  contents:
  - "10.2.  Announcements to Flush Outdated Cache Entries\n   Whenever a host has\
    \ a resource record with new data, or with what\n   might potentially be new data\
    \ (e.g., after rebooting, waking from\n   sleep, connecting to a new network link,\
    \ or changing IP address), the\n   host needs to inform peers of that new data.\
    \  In cases where the host\n   has not been continuously connected and participating\
    \ on the network\n   link, it MUST first probe to re-verify uniqueness of its\
    \ unique\n   records, as described above in Section 8.1, \"Probing\".\n   Having\
    \ completed the Probing step, if necessary, the host MUST then\n   send a series\
    \ of unsolicited announcements to update cache entries in\n   its neighbor hosts.\
    \  In these unsolicited announcements, if the\n   record is one that has been\
    \ verified unique, the host sets the most\n   significant bit of the rrclass field\
    \ of the resource record.  This\n   bit, the cache-flush bit, tells neighboring\
    \ hosts that this is not a\n   shared record type.  Instead of merging this new\
    \ record additively\n   into the cache in addition to any previous records with\
    \ the same\n   name, rrtype, and rrclass, all old records with that name, rrtype,\n\
    \   and rrclass that were received more than one second ago are declared\n   invalid,\
    \ and marked to expire from the cache in one second.\n   The semantics of the\
    \ cache-flush bit are as follows: normally when a\n   resource record appears\
    \ in a Resource Record Section of the DNS\n   response it means, \"This is an\
    \ assertion that this information is\n   true\".  When a resource record appears\
    \ in a Resource Record Section\n   of the DNS response with the cache-flush bit\
    \ set, it means, \"This is\n   an assertion that this information is the truth\
    \ and the whole truth,\n   and anything you may have heard more than a second\
    \ ago regarding\n   records of this name/rrtype/rrclass is no longer true\".\n\
    \   To accommodate the case where the set of records from one host\n   constituting\
    \ a single unique RRSet is too large to fit in a single\n   packet, only cache\
    \ records that are more than one second old are\n   flushed.  This allows the\
    \ announcing host to generate a quick burst\n   of packets back-to-back on the\
    \ wire containing all the members of the\n   RRSet.  When receiving records with\
    \ the cache-flush bit set, all\n   records older than one second are marked to\
    \ be deleted one second in\n   the future.  One second after the end of the little\
    \ packet burst, any\n   records not represented within that packet burst will\
    \ then be expired\n   from all peer caches.\n   Any time a host sends a response\
    \ packet containing some members of a\n   unique RRSet, it MUST send the entire\
    \ RRSet, preferably in a single\n   packet, or if the entire RRSet will not fit\
    \ in a single packet, in a\n   quick burst of packets sent as close together as\
    \ possible.  The host\n   MUST set the cache-flush bit on all members of the unique\
    \ RRSet.\n   Another reason for waiting one second before deleting stale records\n\
    \   from the cache is to accommodate bridged networks.  For example, a\n   host's\
    \ address record announcement on a wireless interface may be\n   bridged onto\
    \ a wired Ethernet and may cause that same host's Ethernet\n   address records\
    \ to be flushed from peer caches.  The one-second delay\n   gives the host the\
    \ chance to see its own announcement arrive on the\n   wired Ethernet, and immediately\
    \ re-announce its Ethernet interface's\n   address records so that both sets remain\
    \ valid and live in peer\n   caches.\n   These rules, about when to set the cache-flush\
    \ bit and about sending\n   the entire rrset, apply regardless of *why* the response\
    \ message is\n   being generated.  They apply to startup announcements as described\
    \ in\n   Section 8.3, \"Announcing\", and to responses generated as a result of\n\
    \   receiving query messages.\n   The cache-flush bit is only set in records in\
    \ the Resource Record\n   Sections of Multicast DNS responses sent to UDP port\
    \ 5353.\n   The cache-flush bit MUST NOT be set in any resource records in a\n\
    \   response message sent in legacy unicast responses to UDP ports other\n   than\
    \ 5353.\n   The cache-flush bit MUST NOT be set in any resource records in the\n\
    \   Known-Answer list of any query message.\n   The cache-flush bit MUST NOT ever\
    \ be set in any shared resource\n   record.  To do so would cause all the other\
    \ shared versions of this\n   resource record with different rdata from different\
    \ responders to be\n   immediately deleted from all the caches on the network.\n\
    \   The cache-flush bit does *not* apply to questions listed in the\n   Question\
    \ Section of a Multicast DNS message.  The top bit of the\n   rrclass field in\
    \ questions is used for an entirely different purpose\n   (see Section 5.4, \"\
    Questions Requesting Unicast Responses\").\n   Note that the cache-flush bit is\
    \ NOT part of the resource record\n   class.  The cache-flush bit is the most\
    \ significant bit of the second\n   16-bit word of a resource record in a Resource\
    \ Record Section of a\n   Multicast DNS message (the field conventionally referred\
    \ to as the\n   rrclass field), and the actual resource record class is the least\n\
    \   significant fifteen bits of this field.  There is no Multicast DNS\n   resource\
    \ record class 0x8001.  The value 0x8001 in the rrclass field\n   of a resource\
    \ record in a Multicast DNS response message indicates a\n   resource record with\
    \ class 1, with the cache-flush bit set.  When\n   receiving a resource record\
    \ with the cache-flush bit set,\n   implementations should take care to mask off\
    \ that bit before storing\n   the resource record in memory, or otherwise ensure\
    \ that it is given\n   the correct semantic interpretation.\n   The reuse of the\
    \ top bit of the rrclass field only applies to\n   conventional resource record\
    \ types that are subject to caching, not\n   to pseudo-RRs like OPT [RFC2671],\
    \ TSIG [RFC2845], TKEY [RFC2930],\n   SIG0 [RFC2931], etc., that pertain only\
    \ to a particular transport\n   level message and not to any actual DNS data.\
    \  Since pseudo-RRs\n   should never go into the Multicast DNS cache, the concept\
    \ of a cache-\n   flush bit for these types is not applicable.  In particular,\
    \ the\n   rrclass field of an OPT record encodes the sender's UDP payload size,\n\
    \   and should be interpreted as a sixteen-bit length value in the range\n   0-65535,\
    \ not a one-bit flag and a fifteen-bit length.\n"
- title: 10.3.  Cache Flush on Topology change
  contents:
  - "10.3.  Cache Flush on Topology change\n   If the hardware on a given host is\
    \ able to indicate physical changes\n   of connectivity, then when the hardware\
    \ indicates such a change, the\n   host should take this information into account\
    \ in its Multicast DNS\n   cache management strategy.  For example, a host may\
    \ choose to\n   immediately flush all cache records received on a particular\n\
    \   interface when that cable is disconnected.  Alternatively, a host may\n  \
    \ choose to adjust the remaining TTL on all those records to a few\n   seconds\
    \ so that if the cable is not reconnected quickly, those\n   records will expire\
    \ from the cache.\n   Likewise, when a host reboots, wakes from sleep, or undergoes\
    \ some\n   other similar discontinuous state change, the cache management\n  \
    \ strategy should take that information into account.\n"
- title: 10.4.  Cache Flush on Failure Indication
  contents:
  - "10.4.  Cache Flush on Failure Indication\n   Sometimes a cache record can be\
    \ determined to be stale when a client\n   attempts to use the rdata it contains,\
    \ and the client finds that\n   rdata to be incorrect.\n   For example, the rdata\
    \ in an address record can be determined to be\n   incorrect if attempts to contact\
    \ that host fail, either because (for\n   an IPv4 address on a local subnet) ARP\
    \ requests for that address go\n   unanswered, because (for an IPv6 address with\
    \ an on-link prefix) ND\n   requests for that address go unanswered, or because\
    \ (for an address\n   on a remote network) a router returns an ICMP \"Host Unreachable\"\
    \n   error.\n   The rdata in an SRV record can be determined to be incorrect if\n\
    \   attempts to communicate with the indicated service at the host and\n   port\
    \ number indicated are not successful.\n   The rdata in a DNS-SD PTR record can\
    \ be determined to be incorrect if\n   attempts to look up the SRV record it references\
    \ are not successful.\n   The software implementing the Multicast DNS resource\
    \ record cache\n   should provide a mechanism so that clients detecting stale\
    \ rdata can\n   inform the cache.\n   When the cache receives this hint that it\
    \ should reconfirm some\n   record, it MUST issue two or more queries for the\
    \ resource record in\n   dispute.  If no response is received within ten seconds,\
    \ then, even\n   though its TTL may indicate that it is not yet due to expire,\
    \ that\n   record SHOULD be promptly flushed from the cache.\n   The end result\
    \ of this is that if a printer suffers a sudden power\n   failure or other abrupt\
    \ disconnection from the network, its name may\n   continue to appear in DNS-SD\
    \ browser lists displayed on users'\n   screens.  Eventually, that entry will\
    \ expire from the cache\n   naturally, but if a user tries to access the printer\
    \ before that\n   happens, the failure to successfully contact the printer will\
    \ trigger\n   the more hasty demise of its cache entries.  This is a sensible\n\
    \   trade-off between good user experience and good network efficiency.\n   If\
    \ we were to insist that printers should disappear from the printer\n   list within\
    \ 30 seconds of becoming unavailable, for all failure\n   modes, the only way\
    \ to achieve this would be for the client to poll\n   the printer at least every\
    \ 30 seconds, or for the printer to announce\n   its presence at least every 30\
    \ seconds, both of which would be an\n   unreasonable burden on most networks.\n"
- title: 10.5.  Passive Observation Of Failures (POOF)
  contents:
  - "10.5.  Passive Observation Of Failures (POOF)\n   A host observes the multicast\
    \ queries issued by the other hosts on\n   the network.  One of the major benefits\
    \ of also sending responses\n   using multicast is that it allows all hosts to\
    \ see the responses (or\n   lack thereof) to those queries.\n   If a host sees\
    \ queries, for which a record in its cache would be\n   expected to be given as\
    \ an answer in a multicast response, but no\n   such answer is seen, then the\
    \ host may take this as an indication\n   that the record may no longer be valid.\n\
    \   After seeing two or more of these queries, and seeing no multicast\n   response\
    \ containing the expected answer within ten seconds, then even\n   though its\
    \ TTL may indicate that it is not yet due to expire, that\n   record SHOULD be\
    \ flushed from the cache.  The host SHOULD NOT perform\n   its own queries to\
    \ reconfirm that the record is truly gone.  If every\n   host on a large network\
    \ were to do this, it would cause a lot of\n   unnecessary multicast traffic.\
    \  If host A sends multicast queries\n   that remain unanswered, then there is\
    \ no reason to suppose that host\n   B or any other host is likely to be any more\
    \ successful.\n   The previous section, \"Cache Flush on Failure Indication\"\
    , describes\n   a situation where a user trying to print discovers that the printer\n\
    \   is no longer available.  By implementing the passive observation\n   described\
    \ here, when one user fails to contact the printer, all hosts\n   on the network\
    \ observe that failure and update their caches\n   accordingly.\n"
- title: 11.  Source Address Check
  contents:
  - "11.  Source Address Check\n   All Multicast DNS responses (including responses\
    \ sent via unicast)\n   SHOULD be sent with IP TTL set to 255.  This is recommended\
    \ to\n   provide backwards-compatibility with older Multicast DNS queriers\n \
    \  (implementing a draft version of this document, posted in February\n   2004)\
    \ that check the IP TTL on reception to determine whether the\n   packet originated\
    \ on the local link.  These older queriers discard\n   all packets with TTLs other\
    \ than 255.\n   A host sending Multicast DNS queries to a link-local destination\n\
    \   address (including the 224.0.0.251 and FF02::FB link-local multicast\n   addresses)\
    \ MUST only accept responses to that query that originate\n   from the local link,\
    \ and silently discard any other response packets.\n   Without this check, it\
    \ could be possible for remote rogue hosts to\n   send spoof answer packets (perhaps\
    \ unicast to the victim host), which\n   the receiving machine could misinterpret\
    \ as having originated on the\n   local link.\n   The test for whether a response\
    \ originated on the local link is done\n   in two ways:\n      * All responses\
    \ received with a destination address in the IP\n        header that is the mDNS\
    \ IPv4 link-local multicast address\n        224.0.0.251 or the mDNS IPv6 link-local\
    \ multicast address\n        FF02::FB are necessarily deemed to have originated\
    \ on the local\n        link, regardless of source IP address.  This is essential\
    \ to\n        allow devices to work correctly and reliably in unusual\n      \
    \  configurations, such as multiple logical IP subnets overlayed on\n        a\
    \ single link, or in cases of severe misconfiguration, where\n        devices\
    \ are physically connected to the same link, but are\n        currently misconfigured\
    \ with completely unrelated IP addresses\n        and subnet masks.\n      * For\
    \ responses received with a unicast destination address in the\n        IP header,\
    \ the source IP address in the packet is checked to see\n        if it is an address\
    \ on a local subnet.  An IPv4 source address\n        is determined to be on a\
    \ local subnet if, for (one of) the\n        address(es) configured on the interface\
    \ receiving the packet, (I\n        & M) == (P & M), where I and M are the interface\
    \ address and\n        subnet mask respectively, P is the source IP address from\
    \ the\n        packet, '&' represents the bitwise logical 'and' operation, and\n\
    \        '==' represents a bitwise equality test.  An IPv6 source address\n  \
    \      is determined to be on the local link if, for any of the on-link\n    \
    \    IPv6 prefixes on the interface receiving the packet (learned via\n      \
    \  IPv6 router advertisements or otherwise configured on the host),\n        the\
    \ first 'n' bits of the IPv6 source address match the first\n        'n' bits\
    \ of the prefix address, where 'n' is the length of the\n        prefix being\
    \ considered.\n   Since queriers will ignore responses apparently originating\
    \ outside\n   the local subnet, a responder SHOULD avoid generating responses\
    \ that\n   it can reasonably predict will be ignored.  This applies particularly\n\
    \   in the case of overlayed subnets.  If a responder receives a query\n   addressed\
    \ to the mDNS IPv4 link-local multicast address 224.0.0.251,\n   from a source\
    \ address not apparently on the same subnet as the\n   responder (or, in the case\
    \ of IPv6, from a source IPv6 address for\n   which the responder does not have\
    \ any address with the same prefix on\n   that interface), then even if the query\
    \ indicates that a unicast\n   response is preferred (see Section 5.4, \"Questions\
    \ Requesting Unicast\n   Responses\"), the responder SHOULD elect to respond by\
    \ multicast\n   anyway, since it can reasonably predict that a unicast response\
    \ with\n   an apparently non-local source address will probably be ignored.\n"
- title: 12.  Special Characteristics of Multicast DNS Domains
  contents:
  - "12.  Special Characteristics of Multicast DNS Domains\n   Unlike conventional\
    \ DNS names, names that end in \".local.\" have only\n   local significance. \
    \ The same is true of names within the IPv4 link-\n   local reverse mapping domain\
    \ \"254.169.in-addr.arpa.\" and the IPv6\n   link-local reverse mapping domains\
    \ \"8.e.f.ip6.arpa.\",\n   \"9.e.f.ip6.arpa.\", \"a.e.f.ip6.arpa.\", and \"b.e.f.ip6.arpa.\"\
    .\n   These names function primarily as protocol identifiers, rather than\n  \
    \ as user-visible identifiers.  Even though they may occasionally be\n   visible\
    \ to end users, that is not their primary purpose.  As such,\n   these names should\
    \ be treated as opaque identifiers.  In particular,\n   the string \"local\" should\
    \ not be translated or localized into\n   different languages, much as the name\
    \ \"localhost\" is not translated\n   or localized into different languages.\n\
    \   Conventional Unicast DNS seeks to provide a single unified namespace,\n  \
    \ where a given DNS query yields the same answer no matter where on the\n   planet\
    \ it is performed or to which recursive DNS server the query is\n   sent.  In\
    \ contrast, each IP link has its own private \".local.\",\n   \"254.169.in-addr.arpa.\"\
    \ and IPv6 link-local reverse mapping\n   namespaces, and the answer to any query\
    \ for a name within those\n   domains depends on where that query is asked.  (This\
    \ characteristic\n   is not unique to Multicast DNS.  Although the original concept\
    \ of DNS\n   was a single global namespace, in recent years, split views,\n  \
    \ firewalls, intranets, DNS geolocation, and the like have increasingly\n   meant\
    \ that the answer to a given DNS query has become dependent on\n   the location\
    \ of the querier.)\n   The IPv4 name server address for a Multicast DNS domain\
    \ is\n   224.0.0.251.  The IPv6 name server address for a Multicast DNS domain\n\
    \   is FF02::FB.  These are multicast addresses; therefore, they identify\n  \
    \ not a single host but a collection of hosts, working in cooperation\n   to maintain\
    \ some reasonable facsimile of a competently managed DNS\n   zone.  Conceptually,\
    \ a Multicast DNS domain is a single DNS zone;\n   however, its server is implemented\
    \ as a distributed process running\n   on a cluster of loosely cooperating CPUs\
    \ rather than as a single\n   process running on a single CPU.\n   Multicast DNS\
    \ domains are not delegated from their parent domain via\n   use of NS (Name Server)\
    \ records, and there is also no concept of\n   delegation of subdomains within\
    \ a Multicast DNS domain.  Just because\n   a particular host on the network may\
    \ answer queries for a particular\n   record type with the name \"example.local.\"\
    \ does not imply anything\n   about whether that host will answer for the name\n\
    \   \"child.example.local.\", or indeed for other record types with the\n   name\
    \ \"example.local.\".\n   There are no NS records anywhere in Multicast DNS domains.\
    \  Instead,\n   the Multicast DNS domains are reserved by IANA, and there is\n\
    \   effectively an implicit delegation of all Multicast DNS domains to\n   the\
    \ 224.0.0.251:5353 and [FF02::FB]:5353 multicast groups, by virtue\n   of client\
    \ software implementing the protocol rules specified in this\n   document.\n \
    \  Multicast DNS zones have no SOA (Start of Authority) record.  A\n   conventional\
    \ DNS zone's SOA record contains information such as the\n   email address of\
    \ the zone administrator and the monotonically\n   increasing serial number of\
    \ the last zone modification.  There is no\n   single human administrator for\
    \ any given Multicast DNS zone, so there\n   is no email address.  Because the\
    \ hosts managing any given Multicast\n   DNS zone are only loosely coordinated,\
    \ there is no readily available\n   monotonically increasing serial number to\
    \ determine whether or not\n   the zone contents have changed.  A host holding\
    \ part of the shared\n   zone could crash or be disconnected from the network\
    \ at any time\n   without informing the other hosts.  There is no reliable way\
    \ to\n   provide a zone serial number that would, whenever such a crash or\n \
    \  disconnection occurred, immediately change to indicate that the\n   contents\
    \ of the shared zone had changed.\n   Zone transfers are not possible for any\
    \ Multicast DNS zone.\n"
- title: 13.  Enabling and Disabling Multicast DNS
  contents:
  - "13.  Enabling and Disabling Multicast DNS\n   The option to fail-over to Multicast\
    \ DNS for names not ending in\n   \".local.\" SHOULD be a user-configured option,\
    \ and SHOULD be disabled\n   by default because of the possible security issues\
    \ related to\n   unintended local resolution of apparently global names.  Enabling\n\
    \   Multicast DNS for names not ending in \".local.\" may be appropriate on\n\
    \   a secure isolated network, or on some future network were machines\n   exclusively\
    \ use DNSSEC for all DNS queries, and have Multicast DNS\n   responders capable\
    \ of generating the appropriate cryptographic DNSSEC\n   signatures, thereby guarding\
    \ against spoofing.\n   The option to look up unqualified (relative) names by\
    \ appending\n   \".local.\" (or not) is controlled by whether \".local.\" appears\
    \ (or\n   not) in the client's DNS search list.\n   No special control is needed\
    \ for enabling and disabling Multicast DNS\n   for names explicitly ending with\
    \ \".local.\" as entered by the user.\n   The user doesn't need a way to disable\
    \ Multicast DNS for names ending\n   with \".local.\", because if the user doesn't\
    \ want to use Multicast\n   DNS, they can achieve this by simply not using those\
    \ names.  If a\n   user *does* enter a name ending in \".local.\", then we can\
    \ safely\n   assume the user's intention was probably that it should work.  Having\n\
    \   user configuration options that can be (intentionally or\n   unintentionally)\
    \ set so that local names don't work is just one more\n   way of frustrating the\
    \ user's ability to perform the tasks they want,\n   perpetuating the view that,\
    \ \"IP networking is too complicated to\n   configure and too hard to use\".\n"
- title: 14.  Considerations for Multiple Interfaces
  contents:
  - "14.  Considerations for Multiple Interfaces\n   A host SHOULD defend its dot-local\
    \ host name on all active interfaces\n   on which it is answering Multicast DNS\
    \ queries.\n   In the event of a name conflict on *any* interface, a host should\n\
    \   configure a new host name, if it wishes to maintain uniqueness of its\n  \
    \ host name.\n   A host may choose to use the same name (or set of names) for\
    \ all of\n   its address records on all interfaces, or it may choose to manage\
    \ its\n   Multicast DNS interfaces independently, potentially answering to a\n\
    \   different name (or set of names) on different interfaces.\n   Except in the\
    \ case of proxying and other similar specialized uses,\n   addresses in IPv4 or\
    \ IPv6 address records in Multicast DNS responses\n   MUST be valid for use on\
    \ the interface on which the response is being\n   sent.\n   Just as the same\
    \ link-local IP address may validly be in use\n   simultaneously on different\
    \ links by different hosts, the same link-\n   local host name may validly be\
    \ in use simultaneously on different\n   links, and this is not an error.  A multihomed\
    \ host with connections\n   to two different links may be able to communicate\
    \ with two different\n   hosts that are validly using the same name.  While this\
    \ kind of name\n   duplication should be rare, it means that a host that wants\
    \ to fully\n   support this case needs network programming APIs that allow\n \
    \  applications to specify on what interface to perform a link-local\n   Multicast\
    \ DNS query, and to discover on what interface a Multicast\n   DNS response was\
    \ received.\n   There is one other special precaution that multihomed hosts need\
    \ to\n   take.  It's common with today's laptop computers to have an Ethernet\n\
    \   connection and an 802.11 [IEEE.802.11] wireless connection active at\n   the\
    \ same time.  What the software on the laptop computer can't easily\n   tell is\
    \ whether the wireless connection is in fact bridged onto the\n   same network\
    \ segment as its Ethernet connection.  If the two networks\n   are bridged together,\
    \ then packets the host sends on one interface\n   will arrive on the other interface\
    \ a few milliseconds later, and care\n   must be taken to ensure that this bridging\
    \ does not cause problems:\n   When the host announces its host name (i.e., its\
    \ address records) on\n   its wireless interface, those announcement records are\
    \ sent with the\n   cache-flush bit set, so when they arrive on the Ethernet segment,\n\
    \   they will cause all the peers on the Ethernet to flush the host's\n   Ethernet\
    \ address records from their caches.  The Multicast DNS\n   protocol has a safeguard\
    \ to protect against this situation: when\n   records are received with the cache-flush\
    \ bit set, other records are\n   not deleted from peer caches immediately, but\
    \ are marked for deletion\n   in one second.  When the host sees its own wireless\
    \ address records\n   arrive on its Ethernet interface, with the cache-flush bit\
    \ set, this\n   one-second grace period gives the host time to respond and re-\n\
    \   announce its Ethernet address records, to reinstate those records in\n   peer\
    \ caches before they are deleted.\n   As described, this solves one problem, but\
    \ creates another, because\n   when those Ethernet announcement records arrive\
    \ back on the wireless\n   interface, the host would again respond defensively\
    \ to reinstate its\n   wireless records, and this process would continue forever,\n\
    \   continuously flooding the network with traffic.  The Multicast DNS\n   protocol\
    \ has a second safeguard, to solve this problem: the cache-\n   flush bit does\
    \ not apply to records received very recently, within\n   the last second.  This\
    \ means that when the host sees its own Ethernet\n   address records arrive on\
    \ its wireless interface, with the cache-\n   flush bit set, it knows there's\
    \ no need to re-announce its wireless\n   address records again because it already\
    \ sent them less than a second\n   ago, and this makes them immune from deletion\
    \ from peer caches.  (See\n   Section 10.2.)\n"
- title: 15.  Considerations for Multiple Responders on the Same Machine
  contents:
  - "15.  Considerations for Multiple Responders on the Same Machine\n   It is possible\
    \ to have more than one Multicast DNS responder and/or\n   querier implementation\
    \ coexist on the same machine, but there are\n   some known issues.\n"
- title: 15.1.  Receiving Unicast Responses
  contents:
  - "15.1.  Receiving Unicast Responses\n   In most operating systems, incoming *multicast*\
    \ packets can be\n   delivered to *all* open sockets bound to the right port number,\n\
    \   provided that the clients take the appropriate steps to allow this.\n   For\
    \ this reason, all Multicast DNS implementations SHOULD use the\n   SO_REUSEPORT\
    \ and/or SO_REUSEADDR options (or equivalent as\n   appropriate for the operating\
    \ system in question) so they will all be\n   able to bind to UDP port 5353 and\
    \ receive incoming multicast packets\n   addressed to that port.  However, unlike\
    \ multicast packets, incoming\n   unicast UDP packets are typically delivered\
    \ only to the first socket\n   to bind to that port.  This means that \"QU\" responses\
    \ and other\n   packets sent via unicast will be received only by the first Multicast\n\
    \   DNS responder and/or querier on a system.  This limitation can be\n   partially\
    \ mitigated if Multicast DNS implementations detect when they\n   are not the\
    \ first to bind to port 5353, and in that case they do not\n   request \"QU\"\
    \ responses.  One way to detect if there is another\n   Multicast DNS implementation\
    \ already running is to attempt binding to\n   port 5353 without using SO_REUSEPORT\
    \ and/or SO_REUSEADDR, and if that\n   fails it indicates that some other socket\
    \ is already bound to this\n   port.\n"
- title: 15.2.  Multipacket Known-Answer lists
  contents:
  - "15.2.  Multipacket Known-Answer lists\n   When a Multicast DNS querier issues\
    \ a query with too many Known\n   Answers to fit into a single packet, it divides\
    \ the Known-Answer list\n   into two or more packets.  Multicast DNS responders\
    \ associate the\n   initial truncated query with its continuation packets by examining\n\
    \   the source IP address in each packet.  Since two independent\n   Multicast\
    \ DNS queriers running on the same machine will be sending\n   packets with the\
    \ same source IP address, from an outside perspective\n   they appear to be a\
    \ single entity.  If both queriers happened to send\n   the same multipacket query\
    \ at the same time, with different Known-\n   Answer lists, then they could each\
    \ end up suppressing answers that\n   the other needs.\n"
- title: 15.3.  Efficiency
  contents:
  - "15.3.  Efficiency\n   If different clients on a machine were each to have their\
    \ own\n   independent Multicast DNS implementation, they would lose certain\n\
    \   efficiency benefits.  Apart from the unnecessary code duplication,\n   memory\
    \ usage, and CPU load, the clients wouldn't get the benefit of a\n   shared system-wide\
    \ cache, and they would not be able to aggregate\n   separate queries into single\
    \ packets to reduce network traffic.\n"
- title: 15.4.  Recommendation
  contents:
  - "15.4.  Recommendation\n   Because of these issues, this document encourages implementers\
    \ to\n   design systems with a single Multicast DNS implementation that\n   provides\
    \ Multicast DNS services shared by all clients on that\n   machine, much as most\
    \ operating systems today have a single TCP\n   implementation, which is shared\
    \ between all clients on that machine.\n   Due to engineering constraints, there\
    \ may be situations where\n   embedding a \"user-level\" Multicast DNS implementation\
    \ in the client\n   application software is the most expedient solution, and while\
    \ this\n   will usually work in practice, implementers should be aware of the\n\
    \   issues outlined in this section.\n"
- title: 16.  Multicast DNS Character Set
  contents:
  - "16.  Multicast DNS Character Set\n   Historically, Unicast DNS has been used\
    \ with a very restricted set of\n   characters.  Indeed, conventional DNS is usually\
    \ limited to just\n   twenty-six letters, ten digits and the hyphen character,\
    \ not even\n   allowing spaces or other punctuation.  Attempts to remedy this\
    \ for\n   Unicast DNS have been badly constrained by the perceived need to\n \
    \  accommodate old buggy legacy DNS implementations.  In reality, the\n   DNS\
    \ specification itself actually imposes no limits on what\n   characters may be\
    \ used in names, and good DNS implementations handle\n   any arbitrary eight-bit\
    \ data without trouble.  \"Clarifications to the\n   DNS Specification\" [RFC2181]\
    \ directly discusses the subject of\n   allowable character set in Section 11\
    \ (\"Name syntax\"), and explicitly\n   states that DNS names may contain arbitrary\
    \ eight-bit data.  However,\n   the old rules for ARPANET host names back in the\
    \ 1980s required host\n   names to be just letters, digits, and hyphens [RFC1034],\
    \ and since\n   the predominant use of DNS is to store host address records, many\n\
    \   have assumed that the DNS protocol itself suffers from the same\n   limitation.\
    \  It might be accurate to say that there could be\n   hypothetical bad implementations\
    \ that do not handle eight-bit data\n   correctly, but it would not be accurate\
    \ to say that the protocol\n   doesn't allow names containing eight-bit data.\n\
    \   Multicast DNS is a new protocol and doesn't (yet) have old buggy\n   legacy\
    \ implementations to constrain the design choices.  Accordingly,\n   it adopts\
    \ the simple obvious elegant solution: all names in Multicast\n   DNS MUST be\
    \ encoded as precomposed UTF-8 [RFC3629] \"Net-Unicode\"\n   [RFC5198] text.\n\
    \   Some users of 16-bit Unicode have taken to stuffing a \"zero-width\n   nonbreaking\
    \ space\" character (U+FEFF) at the start of each UTF-16\n   file, as a hint to\
    \ identify whether the data is big-endian or little-\n   endian, and calling it\
    \ a \"Byte Order Mark\" (BOM).  Since there is\n   only one possible byte order\
    \ for UTF-8 data, a BOM is neither\n   necessary nor permitted.  Multicast DNS\
    \ names MUST NOT contain a\n   \"Byte Order Mark\".  Any occurrence of the Unicode\
    \ character U+FEFF at\n   the start or anywhere else in a Multicast DNS name MUST\
    \ be\n   interpreted as being an actual intended part of the name,\n   representing\
    \ (just as for any other legal unicode value) an actual\n   literal instance of\
    \ that character (in this case a zero-width non-\n   breaking space character).\n\
    \   For names that are restricted to US-ASCII [RFC0020] letters, digits,\n   and\
    \ hyphens, the UTF-8 encoding is identical to the US-ASCII\n   encoding, so this\
    \ is entirely compatible with existing host names.\n   For characters outside\
    \ the US-ASCII range, UTF-8 encoding is used.\n   Multicast DNS implementations\
    \ MUST NOT use any other encodings apart\n   from precomposed UTF-8 (US-ASCII\
    \ being considered a compatible subset\n   of UTF-8).  The reasons for selecting\
    \ UTF-8 instead of Punycode\n   [RFC3492] are discussed further in Appendix F.\n\
    \   The simple rules for case-insensitivity in Unicast DNS [RFC1034]\n   [RFC1035]\
    \ also apply in Multicast DNS; that is to say, in name\n   comparisons, the lowercase\
    \ letters \"a\" to \"z\" (0x61 to 0x7A) match\n   their uppercase equivalents\
    \ \"A\" to \"Z\" (0x41 to 0x5A).  Hence, if a\n   querier issues a query for an\
    \ address record with the name\n   \"myprinter.local.\", then a responder having\
    \ an address record with\n   the name \"MyPrinter.local.\" should issue a response.\
    \  No other\n   automatic equivalences should be assumed.  In particular, all\
    \ UTF-8\n   multibyte characters (codes 0x80 and higher) are compared by simple\n\
    \   binary comparison of the raw byte values.  Accented characters are\n   *not*\
    \ defined to be automatically equivalent to their unaccented\n   counterparts.\
    \  Where automatic equivalences are desired, this may be\n   achieved through\
    \ the use of programmatically generated CNAME records.\n   For example, if a responder\
    \ has an address record for an accented\n   name Y, and a querier issues a query\
    \ for a name X, where X is the\n   same as Y with all the accents removed, then\
    \ the responder may issue\n   a response containing two resource records: a CNAME\
    \ record \"X CNAME\n   Y\", asserting that the requested name X (unaccented) is\
    \ an alias for\n   the true (accented) name Y, followed by the address record\
    \ for Y.\n"
- title: 17.  Multicast DNS Message Size
  contents:
  - "17.  Multicast DNS Message Size\n   The 1987 DNS specification [RFC1035] restricts\
    \ DNS messages carried\n   by UDP to no more than 512 bytes (not counting the\
    \ IP or UDP\n   headers).  For UDP packets carried over the wide-area Internet\
    \ in\n   1987, this was appropriate.  For link-local multicast packets on\n  \
    \ today's networks, there is no reason to retain this restriction.\n   Given that\
    \ the packets are by definition link-local, there are no\n   Path MTU issues to\
    \ consider.\n   Multicast DNS messages carried by UDP may be up to the IP MTU\
    \ of the\n   physical interface, less the space required for the IP header (20\n\
    \   bytes for IPv4; 40 bytes for IPv6) and the UDP header (8 bytes).\n   In the\
    \ case of a single Multicast DNS resource record that is too\n   large to fit\
    \ in a single MTU-sized multicast response packet, a\n   Multicast DNS responder\
    \ SHOULD send the resource record alone, in a\n   single IP datagram, using multiple\
    \ IP fragments.  Resource records\n   this large SHOULD be avoided, except in\
    \ the very rare cases where\n   they really are the appropriate solution to the\
    \ problem at hand.\n   Implementers should be aware that many simple devices do\
    \ not\n   reassemble fragmented IP datagrams, so large resource records SHOULD\n\
    \   NOT be used except in specialized cases where the implementer knows\n   that\
    \ all receivers implement reassembly, or where the large resource\n   record contains\
    \ optional data which is not essential for correct\n   operation of the client.\n\
    \   A Multicast DNS packet larger than the interface MTU, which is sent\n   using\
    \ fragments, MUST NOT contain more than one resource record.\n   Even when fragmentation\
    \ is used, a Multicast DNS packet, including IP\n   and UDP headers, MUST NOT\
    \ exceed 9000 bytes.\n   Note that 9000 bytes is also the maximum payload size\
    \ of an Ethernet\n   \"Jumbo\" packet [Jumbo].  However, in practice Ethernet\
    \ \"Jumbo\"\n   packets are not widely used, so it is advantageous to keep packets\n\
    \   under 1500 bytes whenever possible.  Even on hosts that normally\n   handle\
    \ Ethernet \"Jumbo\" packets and IP fragment reassembly, it is\n   becoming more\
    \ common for these hosts to implement power-saving modes\n   where the main CPU\
    \ goes to sleep and hands off packet reception tasks\n   to a more limited processor\
    \ in the network interface hardware, which\n   may not support Ethernet \"Jumbo\"\
    \ packets or IP fragment reassembly.\n"
- title: 18.  Multicast DNS Message Format
  contents:
  - "18.  Multicast DNS Message Format\n   This section describes specific rules pertaining\
    \ to the allowable\n   values for the header fields of a Multicast DNS message,\
    \ and other\n   message format considerations.\n"
- title: 18.1.  ID (Query Identifier)
  contents:
  - "18.1.  ID (Query Identifier)\n   Multicast DNS implementations SHOULD listen\
    \ for unsolicited responses\n   issued by hosts booting up (or waking up from\
    \ sleep or otherwise\n   joining the network).  Since these unsolicited responses\
    \ may contain\n   a useful answer to a question for which the querier is currently\n\
    \   awaiting an answer, Multicast DNS implementations SHOULD examine all\n   received\
    \ Multicast DNS response messages for useful answers, without\n   regard to the\
    \ contents of the ID field or the Question Section.  In\n   Multicast DNS, knowing\
    \ which particular query message (if any) is\n   responsible for eliciting a particular\
    \ response message is less\n   interesting than knowing whether the response message\
    \ contains useful\n   information.\n   Multicast DNS implementations MAY cache\
    \ data from any or all\n   Multicast DNS response messages they receive, for possible\
    \ future\n   use, provided of course that normal TTL aging is performed on these\n\
    \   cached resource records.\n   In multicast query messages, the Query Identifier\
    \ SHOULD be set to\n   zero on transmission.\n   In multicast responses, including\
    \ unsolicited multicast responses,\n   the Query Identifier MUST be set to zero\
    \ on transmission, and MUST be\n   ignored on reception.\n   In legacy unicast\
    \ response messages generated specifically in\n   response to a particular (unicast\
    \ or multicast) query, the Query\n   Identifier MUST match the ID from the query\
    \ message.\n"
- title: 18.2.  QR (Query/Response) Bit
  contents:
  - "18.2.  QR (Query/Response) Bit\n   In query messages the QR bit MUST be zero.\n\
    \   In response messages the QR bit MUST be one.\n"
- title: 18.3.  OPCODE
  contents:
  - "18.3.  OPCODE\n   In both multicast query and multicast response messages, the\
    \ OPCODE\n   MUST be zero on transmission (only standard queries are currently\n\
    \   supported over multicast).  Multicast DNS messages received with an\n   OPCODE\
    \ other than zero MUST be silently ignored.\n"
- title: 18.4.  AA (Authoritative Answer) Bit
  contents:
  - "18.4.  AA (Authoritative Answer) Bit\n   In query messages, the Authoritative\
    \ Answer bit MUST be zero on\n   transmission, and MUST be ignored on reception.\n\
    \   In response messages for Multicast domains, the Authoritative Answer\n   bit\
    \ MUST be set to one (not setting this bit would imply there's some\n   other\
    \ place where \"better\" information may be found) and MUST be\n   ignored on\
    \ reception.\n"
- title: 18.5.  TC (Truncated) Bit
  contents:
  - "18.5.  TC (Truncated) Bit\n   In query messages, if the TC bit is set, it means\
    \ that additional\n   Known-Answer records may be following shortly.  A responder\
    \ SHOULD\n   record this fact, and wait for those additional Known-Answer records,\n\
    \   before deciding whether to respond.  If the TC bit is clear, it means\n  \
    \ that the querying host has no additional Known Answers.\n   In multicast response\
    \ messages, the TC bit MUST be zero on\n   transmission, and MUST be ignored on\
    \ reception.\n   In legacy unicast response messages, the TC bit has the same\
    \ meaning\n   as in conventional Unicast DNS: it means that the response was too\n\
    \   large to fit in a single packet, so the querier SHOULD reissue its\n   query\
    \ using TCP in order to receive the larger response.\n"
- title: 18.6.  RD (Recursion Desired) Bit
  contents:
  - "18.6.  RD (Recursion Desired) Bit\n   In both multicast query and multicast response\
    \ messages, the\n   Recursion Desired bit SHOULD be zero on transmission, and\
    \ MUST be\n   ignored on reception.\n"
- title: 18.7.  RA (Recursion Available) Bit
  contents:
  - "18.7.  RA (Recursion Available) Bit\n   In both multicast query and multicast\
    \ response messages, the\n   Recursion Available bit MUST be zero on transmission,\
    \ and MUST be\n   ignored on reception.\n"
- title: 18.8.  Z (Zero) Bit
  contents:
  - "18.8.  Z (Zero) Bit\n   In both query and response messages, the Zero bit MUST\
    \ be zero on\n   transmission, and MUST be ignored on reception.\n"
- title: 18.9.  AD (Authentic Data) Bit
  contents:
  - "18.9.  AD (Authentic Data) Bit\n   In both multicast query and multicast response\
    \ messages, the\n   Authentic Data bit [RFC2535] MUST be zero on transmission,\
    \ and MUST\n   be ignored on reception.\n"
- title: 18.10.  CD (Checking Disabled) Bit
  contents:
  - "18.10.  CD (Checking Disabled) Bit\n   In both multicast query and multicast\
    \ response messages, the Checking\n   Disabled bit [RFC2535] MUST be zero on transmission,\
    \ and MUST be\n   ignored on reception.\n"
- title: 18.11.  RCODE (Response Code)
  contents:
  - "18.11.  RCODE (Response Code)\n   In both multicast query and multicast response\
    \ messages, the Response\n   Code MUST be zero on transmission.  Multicast DNS\
    \ messages received\n   with non-zero Response Codes MUST be silently ignored.\n"
- title: 18.12.  Repurposing of Top Bit of qclass in Question Section
  contents:
  - "18.12.  Repurposing of Top Bit of qclass in Question Section\n   In the Question\
    \ Section of a Multicast DNS query, the top bit of the\n   qclass field is used\
    \ to indicate that unicast responses are preferred\n   for this particular question.\
    \  (See Section 5.4.)\n"
- title: 18.13.  Repurposing of Top Bit of rrclass in Resource Record Sections
  contents:
  - "18.13.  Repurposing of Top Bit of rrclass in Resource Record Sections\n   In\
    \ the Resource Record Sections of a Multicast DNS response, the top\n   bit of\
    \ the rrclass field is used to indicate that the record is a\n   member of a unique\
    \ RRSet, and the entire RRSet has been sent together\n   (in the same packet,\
    \ or in consecutive packets if there are too many\n   records to fit in a single\
    \ packet).  (See Section 10.2.)\n"
- title: 18.14.  Name Compression
  contents:
  - "18.14.  Name Compression\n   When generating Multicast DNS messages, implementations\
    \ SHOULD use\n   name compression wherever possible to compress the names of resource\n\
    \   records, by replacing some or all of the resource record name with a\n   compact\
    \ two-byte reference to an appearance of that data somewhere\n   earlier in the\
    \ message [RFC1035].\n   This applies not only to Multicast DNS responses, but\
    \ also to\n   queries.  When a query contains more than one question, successive\n\
    \   questions in the same message often contain similar names, and\n   consequently\
    \ name compression SHOULD be used, to save bytes.  In\n   addition, queries may\
    \ also contain Known Answers in the Answer\n   Section, or probe tiebreaking data\
    \ in the Authority Section, and\n   these names SHOULD similarly be compressed\
    \ for network efficiency.\n   In addition to compressing the *names* of resource\
    \ records, names\n   that appear within the *rdata* of the following rrtypes SHOULD\
    \ also\n   be compressed in all Multicast DNS messages:\n     NS, CNAME, PTR,\
    \ DNAME, SOA, MX, AFSDB, RT, KX, RP, PX, SRV, NSEC\n   Until future IETF Standards\
    \ Action [RFC5226] specifying that names in\n   the rdata of other types should\
    \ be compressed, names that appear\n   within the rdata of any type not listed\
    \ above MUST NOT be compressed.\n   Implementations receiving Multicast DNS messages\
    \ MUST correctly\n   decode compressed names appearing in the Question Section,\
    \ and\n   compressed names of resource records appearing in other sections.\n\
    \   In addition, implementations MUST correctly decode compressed names\n   appearing\
    \ within the *rdata* of the rrtypes listed above.  Where\n   possible, implementations\
    \ SHOULD also correctly decode compressed\n   names appearing within the *rdata*\
    \ of other rrtypes known to the\n   implementers at the time of implementation,\
    \ because such forward-\n   thinking planning helps facilitate the deployment\
    \ of future\n   implementations that may have reason to compress those rrtypes.\
    \  It\n   is possible that no future IETF Standards Action [RFC5226] will be\n\
    \   created that mandates or permits the compression of rdata in new\n   types,\
    \ but having implementations designed such that they are capable\n   of decompressing\
    \ all known types helps keep future options open.\n   One specific difference\
    \ between Unicast DNS and Multicast DNS is that\n   Unicast DNS does not allow\
    \ name compression for the target host in an\n   SRV record, because Unicast DNS\
    \ implementations before the first SRV\n   specification in 1996 [RFC2052] may\
    \ not decode these compressed\n   records properly.  Since all Multicast DNS implementations\
    \ were\n   created after 1996, all Multicast DNS implementations are REQUIRED\
    \ to\n   decode compressed SRV records correctly.\n   In legacy unicast responses\
    \ generated to answer legacy queries, name\n   compression MUST NOT be performed\
    \ on SRV records.\n"
- title: 19.  Summary of Differences between Multicast DNS and Unicast DNS
  contents:
  - "19.  Summary of Differences between Multicast DNS and Unicast DNS\n   Multicast\
    \ DNS shares, as much as possible, the familiar APIs, naming\n   syntax, resource\
    \ record types, etc., of Unicast DNS.  There are, of\n   course, necessary differences\
    \ by virtue of it using multicast, and by\n   virtue of it operating in a community\
    \ of cooperating peers, rather\n   than a precisely defined hierarchy controlled\
    \ by a strict chain of\n   formal delegations from the root.  These differences\
    \ are summarized\n   below:\n   Multicast DNS...\n   * uses multicast\n   * uses\
    \ UDP port 5353 instead of port 53\n   * operates in well-defined parts of the\
    \ DNS namespace\n   * has no SOA (Start of Authority) records\n   * uses UTF-8,\
    \ and only UTF-8, to encode resource record names\n   * allows names up to 255\
    \ bytes plus a terminating zero byte\n   * allows name compression in rdata for\
    \ SRV and other record types\n   * allows larger UDP packets\n   * allows more\
    \ than one question in a query message\n   * defines consistent results for qtype\
    \ \"ANY\" and qclass \"ANY\" queries\n   * uses the Answer Section of a query\
    \ to list Known Answers\n   * uses the TC bit in a query to indicate additional\
    \ Known Answers\n   * uses the Authority Section of a query for probe tiebreaking\n\
    \   * ignores the Query ID field (except for generating legacy responses)\n  \
    \ * doesn't require the question to be repeated in the response message\n   *\
    \ uses unsolicited responses to announce new records\n   * uses NSEC records to\
    \ signal nonexistence of records\n   * defines a unicast-response bit in the rrclass\
    \ of query questions\n   * defines a cache-flush bit in the rrclass of response\
    \ records\n   * uses DNS RR TTL 0 to indicate that a record has been deleted\n\
    \   * recommends AAAA records in the additional section when responding\n    \
    \ to rrtype \"A\" queries, and vice versa\n   * monitors queries to perform Duplicate\
    \ Question Suppression\n   * monitors responses to perform Duplicate Answer Suppression...\n\
    \   * ... and Ongoing Conflict Detection\n   * ... and Opportunistic Caching\n"
- title: 20.  IPv6 Considerations
  contents:
  - "20.  IPv6 Considerations\n   An IPv4-only host and an IPv6-only host behave as\
    \ \"ships that pass in\n   the night\".  Even if they are on the same Ethernet,\
    \ neither is aware\n   of the other's traffic.  For this reason, each physical\
    \ link may have\n   *two* unrelated \".local.\" zones, one for IPv4 and one for\
    \ IPv6.\n   Since for practical purposes, a group of IPv4-only hosts and a group\n\
    \   of IPv6-only hosts on the same Ethernet act as if they were on two\n   entirely\
    \ separate Ethernet segments, it is unsurprising that their\n   use of the \"\
    .local.\" zone should occur exactly as it would if they\n   really were on two\
    \ entirely separate Ethernet segments.\n   A dual-stack (v4/v6) host can participate\
    \ in both \".local.\" zones,\n   and should register its name(s) and perform its\
    \ lookups both using\n   IPv4 and IPv6.  This enables it to reach, and be reached\
    \ by, both\n   IPv4-only and IPv6-only hosts.  In effect, this acts like a\n \
    \  multihomed host, with one connection to the logical \"IPv4 Ethernet\n   segment\"\
    , and a connection to the logical \"IPv6 Ethernet segment\".\n   When such a host\
    \ generates NSEC records, if it is using the same host\n   name for its IPv4 addresses\
    \ and its IPv6 addresses on that network\n   interface, its NSEC records should\
    \ indicate that the host name has\n   both A and AAAA records.\n"
- title: 21.  Security Considerations
  contents:
  - "21.  Security Considerations\n   The algorithm for detecting and resolving name\
    \ conflicts is, by its\n   very nature, an algorithm that assumes cooperating\
    \ participants.  Its\n   purpose is to allow a group of hosts to arrive at a mutually\
    \ disjoint\n   set of host names and other DNS resource record names, in the absence\n\
    \   of any central authority to coordinate this or mediate disputes.  In\n   the\
    \ absence of any higher authority to resolve disputes, the only\n   alternative\
    \ is that the participants must work together cooperatively\n   to arrive at a\
    \ resolution.\n   In an environment where the participants are mutually antagonistic\n\
    \   and unwilling to cooperate, other mechanisms are appropriate, like\n   manually\
    \ configured DNS.\n   In an environment where there is a group of cooperating\
    \ participants,\n   but clients cannot be sure that there are no antagonistic\
    \ hosts on\n   the same physical link, the cooperating participants need to use\n\
    \   IPsec signatures and/or DNSSEC [RFC4033] signatures so that they can\n   distinguish\
    \ Multicast DNS messages from trusted participants (which\n   they process as\
    \ usual) from Multicast DNS messages from untrusted\n   participants (which they\
    \ silently discard).\n   If DNS queries for *global* DNS names are sent to the\
    \ mDNS multicast\n   address (during network outages which disrupt communication\
    \ with the\n   greater Internet) it is *especially* important to use DNSSEC, because\n\
    \   the user may have the impression that he or she is communicating with\n  \
    \ some authentic host, when in fact he or she is really communicating\n   with\
    \ some local host that is merely masquerading as that name.  This\n   is less\
    \ critical for names ending with \".local.\", because the user\n   should be aware\
    \ that those names have only local significance and no\n   global authority is\
    \ implied.\n   Most computer users neglect to type the trailing dot at the end\
    \ of a\n   fully qualified domain name, making it a relative domain name (e.g.,\n\
    \   \"www.example.com\").  In the event of network outage, attempts to\n   positively\
    \ resolve the name as entered will fail, resulting in\n   application of the search\
    \ list, including \".local.\", if present.  A\n   malicious host could masquerade\
    \ as \"www.example.com.\" by answering\n   the resulting Multicast DNS query for\
    \ \"www.example.com.local.\".  To\n   avoid this, a host MUST NOT append the search\
    \ suffix \".local.\", if\n   present, to any relative (partially qualified) host\
    \ name containing\n   two or more labels.  Appending \".local.\" to single-label\
    \ relative\n   host names is acceptable, since the user should have no expectation\n\
    \   that a single-label host name will resolve as is.  However, users who\n  \
    \ have both \"example.com\" and \"local\" in their search lists should be\n  \
    \ aware that if they type \"www\" into their web browser, it may not be\n   immediately\
    \ clear to them whether the page that appears is\n   \"www.example.com\" or \"\
    www.local\".\n   Multicast DNS uses UDP port 5353.  On operating systems where\
    \ only\n   privileged processes are allowed to use ports below 1024, no such\n\
    \   privilege is required to use port 5353.\n"
- title: 22.  IANA Considerations
  contents:
  - "22.  IANA Considerations\n   IANA has allocated the UDP port 5353 for the Multicast\
    \ DNS protocol\n   described in this document [SN].\n   IANA has allocated the\
    \ IPv4 link-local multicast address 224.0.0.251\n   for the use described in this\
    \ document [MC4].\n   IANA has allocated the IPv6 multicast address set FF0X::FB\
    \ (where \"X\"\n   indicates any hexadecimal digit from '1' to 'F') for the use\n\
    \   described in this document [MC6].  Only address FF02::FB (link-local\n   scope)\
    \ is currently in use by deployed software, but it is possible\n   that in the\
    \ future implementers may experiment with Multicast DNS\n   using larger-scoped\
    \ addresses, such as FF05::FB (site-local scope)\n   [RFC4291].\n   IANA has implemented\
    \ the following DNS records:\n      MDNS.MCAST.NET.            IN  A    224.0.0.251\n\
    \      251.0.0.224.IN-ADDR.ARPA.  IN  PTR  MDNS.MCAST.NET.\n   Entries for the\
    \ AAAA and corresponding PTR records have not been made\n   as there is not yet\
    \ an RFC providing direction for the management of\n   the IP6.ARPA domain relating\
    \ to the IPv6 multicast address space.\n   The reuse of the top bit of the rrclass\
    \ field in the Question and\n   Resource Record Sections means that Multicast\
    \ DNS can only carry DNS\n   records with classes in the range 0-32767.  Classes\
    \ in the range\n   32768 to 65535 are incompatible with Multicast DNS.  IANA has\
    \ noted\n   this fact, and if IANA receives a request to allocate a DNS class\n\
    \   value above 32767, IANA will make sure the requester is aware of this\n  \
    \ implication before proceeding.  This does not mean that allocations\n   of DNS\
    \ class values above 32767 should be denied, only that they\n   should not be\
    \ allowed until the requester has indicated that they are\n   aware of how this\
    \ allocation will interact with Multicast DNS.\n   However, to date, only three\
    \ DNS classes have been assigned by IANA\n   (1, 3, and 4), and only one (1, \"\
    Internet\") is actually in widespread\n   use, so this issue is likely to remain\
    \ a purely theoretical one.\n   IANA has recorded the list of domains below as\
    \ being Special-Use\n   Domain Names [RFC6761]:\n      .local.\n      .254.169.in-addr.arpa.\n\
    \      .8.e.f.ip6.arpa.\n      .9.e.f.ip6.arpa.\n      .a.e.f.ip6.arpa.\n    \
    \  .b.e.f.ip6.arpa.\n"
- title: 22.1.  Domain Name Reservation Considerations
  contents:
  - "22.1.  Domain Name Reservation Considerations\n   The six domains listed above,\
    \ and any names falling within those\n   domains (e.g., \"MyPrinter.local.\",\
    \ \"34.12.254.169.in-addr.arpa.\",\n   \"Ink-Jet._pdl-datastream._tcp.local.\"\
    ) are special [RFC6761] in the\n   following ways:\n      1. Users may use these\
    \ names as they would other DNS names,\n         entering them anywhere that they\
    \ would otherwise enter a\n         conventional DNS name, or a dotted decimal\
    \ IPv4 address, or a\n         literal IPv6 address.\n         Since there is\
    \ no central authority responsible for assigning\n         dot-local names, and\
    \ all devices on the local network are\n         equally entitled to claim any\
    \ dot-local name, users SHOULD be\n         aware of this and SHOULD exercise\
    \ appropriate caution.  In an\n         untrusted or unfamiliar network environment,\
    \ users SHOULD be\n         aware that using a name like \"www.local\" may not\
    \ actually\n         connect them to the web site they expected, and could easily\n\
    \         connect them to a different web page, or even a fake or spoof\n    \
    \     of their intended web site, designed to trick them into\n         revealing\
    \ confidential information.  As always with networking,\n         end-to-end cryptographic\
    \ security can be a useful tool.  For\n         example, when connecting with\
    \ ssh, the ssh host key\n         verification process will inform the user if\
    \ it detects that\n         the identity of the entity they are communicating\
    \ with has\n         changed since the last time they connected to that name.\n\
    \      2. Application software may use these names as they would other\n     \
    \    similar DNS names, and is not required to recognize the names\n         and\
    \ treat them specially.  Due to the relative ease of spoofing\n         dot-local\
    \ names, end-to-end cryptographic security remains\n         important when communicating\
    \ across a local network, just as it\n         is when communicating across the\
    \ global Internet.\n      3. Name resolution APIs and libraries SHOULD recognize\
    \ these names\n         as special and SHOULD NOT send queries for these names\
    \ to their\n         configured (unicast) caching DNS server(s).  This is to avoid\n\
    \         unnecessary load on the root name servers and other name\n         servers,\
    \ caused by queries for which those name servers do not\n         have useful\
    \ non-negative answers to give, and will not ever\n         have useful non-negative\
    \ answers to give.\n      4. Caching DNS servers SHOULD recognize these names\
    \ as special and\n         SHOULD NOT attempt to look up NS records for them,\
    \ or otherwise\n         query authoritative DNS servers in an attempt to resolve\
    \ these\n         names.  Instead, caching DNS servers SHOULD generate immediate\n\
    \         NXDOMAIN responses for all such queries they may receive (from\n   \
    \      misbehaving name resolver libraries).  This is to avoid\n         unnecessary\
    \ load on the root name servers and other name\n         servers.\n      5. Authoritative\
    \ DNS servers SHOULD NOT by default be configurable\n         to answer queries\
    \ for these names, and, like caching DNS\n         servers, SHOULD generate immediate\
    \ NXDOMAIN responses for all\n         such queries they may receive.  DNS server\
    \ software MAY provide\n         a configuration option to override this default,\
    \ for testing\n         purposes or other specialized uses.\n      6. DNS server\
    \ operators SHOULD NOT attempt to configure\n         authoritative DNS servers\
    \ to act as authoritative for any of\n         these names.  Configuring an authoritative\
    \ DNS server to act as\n         authoritative for any of these names may not,\
    \ in many cases,\n         yield the expected result.  Since name resolver libraries\
    \ and\n         caching DNS servers SHOULD NOT send queries for those names\n\
    \         (see 3 and 4 above), such queries SHOULD be suppressed before\n    \
    \     they even reach the authoritative DNS server in question, and\n        \
    \ consequently it will not even get an opportunity to answer\n         them.\n\
    \      7. DNS Registrars MUST NOT allow any of these names to be\n         registered\
    \ in the normal way to any person or entity.  These\n         names are reserved\
    \ protocol identifiers with special meaning\n         and fall outside the set\
    \ of names available for allocation by\n         registrars.  Attempting to allocate\
    \ one of these names as if it\n         were a normal domain name will probably\
    \ not work as desired,\n         for reasons 3, 4, and 6 above.\n"
- title: 23.  Acknowledgments
  contents:
  - "23.  Acknowledgments\n   The concepts described in this document have been explored,\n\
    \   developed, and implemented with help from Ran Atkinson, Richard\n   Brown,\
    \ Freek Dijkstra, Erik Guttman, Kyle McKay, Pasi Sarolahti,\n   Pekka Savola,\
    \ Robby Simpson, Mark Townsley, Paul Vixie, Bill\n   Woodcock, and others.  Special\
    \ thanks go to Bob Bradley, Josh\n   Graessley, Scott Herscher, Rory McGuire,\
    \ Roger Pantos, and Kiren\n   Sekar for their significant contributions.  Special\
    \ thanks also to\n   Kerry Lynn for converting the document to xml2rfc form in\
    \ May 2010,\n   and to Area Director Ralph Droms for shepherding the document\
    \ through\n   its final steps.\n"
- title: 24.  References
  contents:
  - '24.  References

    '
- title: 24.1.  Normative References
  contents:
  - "24.1.  Normative References\n   [MC4]      IANA, \"IPv4 Multicast Address Space\
    \ Registry\",\n              <http://www.iana.org/assignments/multicast-addresses/>.\n\
    \   [MC6]      IANA, \"IPv6 Multicast Address Space Registry\",\n            \
    \  <http://www.iana.org/assignments/\n              ipv6-multicast-addresses/>.\n\
    \   [RFC0020]  Cerf, V., \"ASCII format for network interchange\", RFC 20,\n \
    \             October 1969.\n   [RFC1034]  Mockapetris, P., \"Domain names - concepts\
    \ and facilities\",\n              STD 13, RFC 1034, November 1987.\n   [RFC1035]\
    \  Mockapetris, P., \"Domain names - implementation and\n              specification\"\
    , STD 13, RFC 1035, November 1987.\n   [RFC2119]  Bradner, S., \"Key words for\
    \ use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of\
    \ ISO\n              10646\", STD 63, RFC 3629, November 2003.\n   [RFC4034] \
    \ Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,\
    \ \"Resource Records for the DNS Security Extensions\",\n              RFC 4034,\
    \ March 2005.\n   [RFC5198]  Klensin, J. and M. Padlipsky, \"Unicode Format for\
    \ Network\n              Interchange\", RFC 5198, March 2008.\n   [RFC6195]  Eastlake\
    \ 3rd, D., \"Domain Name System (DNS) IANA\n              Considerations\", BCP\
    \ 42, RFC 6195, March 2011.\n   [RFC6761]  Cheshire, S. and M. Krochmal, \"Special-Use\
    \ Domain Names\",\n              RFC 6761, February 2013.\n   [SN]       IANA,\
    \ \"Service Name and Transport Protocol Port Number\n              Registry\"\
    , <http://www.iana.org/assignments/\n              service-names-port-numbers/>.\n"
- title: 24.2.  Informative References
  contents:
  - "24.2.  Informative References\n   [B4W]      \"Bonjour for Windows\",\n     \
    \         <http://en.wikipedia.org/wiki/Bonjour_(software)>.\n   [BJ]       Apple\
    \ Bonjour Open Source Software,\n              <http://developer.apple.com/bonjour/>.\n\
    \   [IEEE.802.3]\n              \"Information technology - Telecommunications\
    \ and\n              information exchange between systems - Local and\n      \
    \        metropolitan area networks - Specific requirements - Part\n         \
    \     3: Carrier Sense Multiple Access with Collision Detection\n            \
    \  (CMSA/CD) Access Method and Physical Layer\n              Specifications\"\
    , IEEE Std 802.3-2008, December 2008,\n              <http://standards.ieee.org/getieee802/802.3.html>.\n\
    \   [IEEE.802.11]\n              \"Information technology - Telecommunications\
    \ and\n              information exchange between systems - Local and\n      \
    \        metropolitan area networks - Specific requirements - Part\n         \
    \     11: Wireless LAN Medium Access Control (MAC) and Physical\n            \
    \  Layer (PHY) Specifications\", IEEE Std 802.11-2007, June\n              2007,\
    \ <http://standards.ieee.org/getieee802/802.11.html>.\n   [Jumbo]    \"Ethernet\
    \ Jumbo Frames\", November 2009,\n              <http://www.ethernetalliance.org/library/whitepaper/\n\
    \              ethernet-jumbo-frames/>.\n   [NIAS]     Cheshire, S. \"Discovering\
    \ Named Instances of Abstract\n              Services using DNS\", Work in Progress,\
    \ July 2001.\n   [NSD]      \"NsdManager | Android Developer\", June 2012,\n \
    \             <http://developer.android.com/reference/\n              android/net/nsd/NsdManager.html>.\n\
    \   [RFC2052]  Gulbrandsen, A. and P. Vixie, \"A DNS RR for specifying the\n \
    \             location of services (DNS SRV)\", RFC 2052, October 1996.\n   [RFC2132]\
    \  Alexander, S. and R. Droms, \"DHCP Options and BOOTP Vendor\n             \
    \ Extensions\", RFC 2132, March 1997.\n   [RFC2136]  Vixie, P., Ed., Thomson,\
    \ S., Rekhter, Y., and J. Bound,\n              \"Dynamic Updates in the Domain\
    \ Name System (DNS UPDATE)\",\n              RFC 2136, April 1997.\n   [RFC2181]\
    \  Elz, R. and R. Bush, \"Clarifications to the DNS\n              Specification\"\
    , RFC 2181, July 1997.\n   [RFC2535]  Eastlake 3rd, D., \"Domain Name System Security\n\
    \              Extensions\", RFC 2535, March 1999.\n   [RFC2671]  Vixie, P., \"\
    Extension Mechanisms for DNS (EDNS0)\", RFC\n              2671, August 1999.\n\
    \   [RFC2845]  Vixie, P., Gudmundsson, O., Eastlake 3rd, D., and B.\n        \
    \      Wellington, \"Secret Key Transaction Authentication for DNS\n         \
    \     (TSIG)\", RFC 2845, May 2000.\n   [RFC2930]  Eastlake 3rd, D., \"Secret\
    \ Key Establishment for DNS (TKEY\n              RR)\", RFC 2930, September 2000.\n\
    \   [RFC2931]  Eastlake 3rd, D., \"DNS Request and Transaction Signatures\n  \
    \            ( SIG(0)s )\", RFC 2931, September 2000.\n   [RFC3007]  Wellington,\
    \ B., \"Secure Domain Name System (DNS) Dynamic\n              Update\", RFC 3007,\
    \ November 2000.\n   [RFC3492]  Costello, A., \"Punycode: A Bootstring encoding\
    \ of Unicode\n              for Internationalized Domain Names in Applications\n\
    \              (IDNA)\", RFC 3492, March 2003.\n   [RFC3927]  Cheshire, S., Aboba,\
    \ B., and E. Guttman, \"Dynamic\n              Configuration of IPv4 Link-Local\
    \ Addresses\", RFC 3927, May\n              2005.\n   [RFC4033]  Arends, R., Austein,\
    \ R., Larson, M., Massey, D., and S.\n              Rose, \"DNS Security Introduction\
    \ and Requirements\", RFC\n              4033, March 2005.\n   [RFC4291]  Hinden,\
    \ R. and S. Deering, \"IP Version 6 Addressing\n              Architecture\",\
    \ RFC 4291, February 2006.\n   [RFC4795]  Aboba, B., Thaler, D., and L. Esibov,\
    \ \"Link-local\n              Multicast Name Resolution (LLMNR)\", RFC 4795, January\n\
    \              2007.\n   [RFC4861]  Narten, T., Nordmark, E., Simpson, W., and\
    \ H. Soliman,\n              \"Neighbor Discovery for IP version 6 (IPv6)\", RFC\
    \ 4861,\n              September 2007.\n   [RFC4862]  Thomson, S., Narten, T.,\
    \ and T. Jinmei, \"IPv6 Stateless\n              Address Autoconfiguration\",\
    \ RFC 4862, September 2007.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an\n              IANA Considerations Section in RFCs\", BCP 26,\
    \ RFC 5226,\n              May 2008.\n   [RFC5890]  Klensin, J., \"Internationalized\
    \ Domain Names for\n              Applications (IDNA): Definitions and Document\
    \ Framework\",\n              RFC 5890, August 2010.\n   [RFC6281]  Cheshire,\
    \ S., Zhu, Z., Wakikawa, R., and L. Zhang,\n              \"Understanding Apple's\
    \ Back to My Mac (BTMM) Service\", RFC\n              6281, June 2011.\n   [RFC6760]\
    \  Cheshire, S. and M. Krochmal, \"Requirements for a Protocol\n             \
    \ to Replace the AppleTalk Name Binding Protocol (NBP)\", RFC\n              6760,\
    \ February 2013.\n   [RFC6763]  Cheshire, S. and M. Krochmal, \"DNS-Based Service\n\
    \              Discovery\", RFC 6763, February 2013.\n   [Zeroconf] Cheshire,\
    \ S. and D. Steinberg, \"Zero Configuration\n              Networking: The Definitive\
    \ Guide\", O'Reilly Media, Inc.,\n              ISBN 0-596-10100-7, December 2005.\n"
- title: Appendix A.  Design Rationale for Choice of UDP Port Number
  contents:
  - "Appendix A.  Design Rationale for Choice of UDP Port Number\n   Arguments were\
    \ made for and against using UDP port 53, the standard\n   Unicast DNS port. \
    \ Some of the arguments are given below.  The\n   arguments for using a different\
    \ port were greater in number and more\n   compelling, so that option was ultimately\
    \ selected.  The UDP port\n   \"5353\" was selected for its mnemonic similarity\
    \ to \"53\".\n   Arguments for using UDP port 53:\n   * This is \"just DNS\",\
    \ so it should be the same port.\n   * There is less work to be done updating\
    \ old resolver libraries to do\n     simple Multicast DNS queries.  Only the destination\
    \ address need be\n     changed.  In some cases, this can be achieved without\
    \ any code\n     changes, just by adding the address 224.0.0.251 to a configuration\n\
    \     file.\n   Arguments for using a different port (UDP port 5353):\n   * This\
    \ is not \"just DNS\".  This is a DNS-like protocol, but\n     different.\n  \
    \ * Changing resolver library code to use a different port number is\n     not\
    \ hard.  In some cases, this can be achieved without any code\n     changes, just\
    \ by adding the address 224.0.0.251:5353 to a\n     configuration file.\n   *\
    \ Using the same port number makes it hard to run a Multicast DNS\n     responder\
    \ and a conventional Unicast DNS server on the same\n     machine.  If a conventional\
    \ Unicast DNS server wishes to implement\n     Multicast DNS as well, it can still\
    \ do that, by opening two\n     sockets.  Having two different port numbers allows\
    \ this\n     flexibility.\n   * Some VPN software hijacks all outgoing traffic\
    \ to port 53 and\n     redirects it to a special DNS server set up to serve those\
    \ VPN\n     clients while they are connected to the corporate network.  It is\n\
    \     questionable whether this is the right thing to do, but it is\n     common,\
    \ and redirecting link-local multicast DNS packets to a\n     remote server rarely\
    \ produces any useful results.  It does mean,\n     for example, that a user of\
    \ such VPN software becomes unable to\n     access their local network printer\
    \ sitting on their desk right next\n     to their computer.  Using a different\
    \ UDP port helps avoid this\n     particular problem.\n   * On many operating\
    \ systems, unprivileged software may not send or\n     receive packets on low-numbered\
    \ ports.  This means that any\n     software sending or receiving Multicast DNS\
    \ packets on port 53\n     would have to run as \"root\", which is an undesirable\
    \ security risk.\n     Using a higher-numbered UDP port avoids this restriction.\n"
- title: Appendix B.  Design Rationale for Not Using Hashed Multicast Addresses
  contents:
  - "Appendix B.  Design Rationale for Not Using Hashed Multicast Addresses\n   Some\
    \ discovery protocols use a range of multicast addresses, and\n   determine the\
    \ address to be used by a hash function of the name being\n   sought.  Queries\
    \ are sent via multicast to the address as indicated\n   by the hash function,\
    \ and responses are returned to the querier via\n   unicast.  Particularly in\
    \ IPv6, where multicast addresses are\n   extremely plentiful, this approach is\
    \ frequently advocated.  For\n   example, IPv6 Neighbor Discovery [RFC4861] sends\
    \ Neighbor\n   Solicitation messages to the \"solicited-node multicast address\"\
    ,\n   which is computed as a function of the solicited IPv6 address.\n   There\
    \ are some disadvantages to using hashed multicast addresses like\n   this in\
    \ a service discovery protocol:\n   * When a host has a large number of records\
    \ with different names, the\n     host may have to join a large number of multicast\
    \ groups.  Each\n     time a host joins or leaves a multicast group, this results\
    \ in\n     Internet Group Management Protocol (IGMP) or Multicast Listener\n \
    \    Discovery (MLD) traffic on the network announcing this fact.\n     Joining\
    \ a large number of multicast groups can place undue burden\n     on the Ethernet\
    \ hardware, which typically supports a limited number\n     of multicast addresses\
    \ efficiently.  When this number is exceeded,\n     the Ethernet hardware may\
    \ have to resort to receiving all\n     multicasts and passing them up to the\
    \ host networking code for\n     filtering in software, thereby defeating much\
    \ of the point of using\n     a multicast address range in the first place.  Finally,\
    \ many IPv6\n     stacks have a fixed limit IPV6_MAX_MEMBERSHIPS, and the code\
    \ simply\n     fails with an error if a client attempts to exceed this limit.\n\
    \     Common values for IPV6_MAX_MEMBERSHIPS are 20 or 31.\n   * Multiple questions\
    \ cannot be placed in one packet if they don't all\n     hash to the same multicast\
    \ address.\n   * Duplicate Question Suppression doesn't work if queriers are not\n\
    \     seeing each other's queries.\n   * Duplicate Answer Suppression doesn't\
    \ work if responders are not\n     seeing each other's responses.\n   * Opportunistic\
    \ Caching doesn't work.\n   * Ongoing Conflict Detection doesn't work.\n"
- title: Appendix C.  Design Rationale for Maximum Multicast DNS Name Length
  contents:
  - "Appendix C.  Design Rationale for Maximum Multicast DNS Name Length\n   Multicast\
    \ DNS names may be up to 255 bytes long (in the on-the-wire\n   message format),\
    \ not counting the terminating zero byte at the end.\n   \"Domain Names - Implementation\
    \ and Specification\" [RFC1035] says:\n      Various objects and parameters in\
    \ the DNS have size limits.  They\n      are listed below.  Some could be easily\
    \ changed, others are more\n      fundamental.\n      labels          63 octets\
    \ or less\n      names           255 octets or less\n      ...\n      the total\
    \ length of a domain name (i.e., label octets and label\n      length octets)\
    \ is restricted to 255 octets or less.\n   This text does not state whether this\
    \ 255-byte limit includes the\n   terminating zero at the end of every name.\n\
    \   Several factors lead us to conclude that the 255-byte limit does\n   *not*\
    \ include the terminating zero:\n   o It is common in software engineering to\
    \ have size limits that are a\n     power of two, or a multiple of a power of\
    \ two, for efficiency.  For\n     example, an integer on a modern processor is\
    \ typically 2, 4, or 8\n     bytes, not 3 or 5 bytes.  The number 255 is not a\
    \ power of two, nor\n     is it to most people a particularly noteworthy number.\
    \  It is\n     noteworthy to computer scientists for only one reason -- because\
    \ it\n     is exactly one *less* than a power of two.  When a size limit is\n\
    \     exactly one less than a power of two, that suggests strongly that\n    \
    \ the one extra byte is being reserved for some specific reason -- in\n     this\
    \ case reserved, perhaps, to leave room for a terminating zero\n     at the end.\n\
    \   o In the case of DNS label lengths, the stated limit is 63 bytes.  As\n  \
    \   with the total name length, this limit is exactly one less than a\n     power\
    \ of two.  This label length limit also excludes the label\n     length byte at\
    \ the start of every label.  Including that extra\n     byte, a 63-byte label\
    \ takes 64 bytes of space in memory or in a DNS\n     message.\n   o It is common\
    \ in software engineering for the semantic \"length\" of\n     an object to be\
    \ one less than the number of bytes it takes to store\n     that object.  For\
    \ example, in C, strlen(\"foo\") is 3, but\n     sizeof(\"foo\") (which includes\
    \ the terminating zero byte at the end)\n     is 4.\n   o The text describing\
    \ the total length of a domain name mentions\n     explicitly that label length\
    \ and data octets are included, but does\n     not mention the terminating zero\
    \ at the end.  The zero byte at the\n     end of a domain name is not a label\
    \ length.  Indeed, the value zero\n     is chosen as the terminating marker precisely\
    \ because it is not a\n     legal length byte value -- DNS prohibits empty labels.\
    \  For\n     example, a name like \"bad..name.\" is not a valid domain name\n\
    \     because it contains a zero-length label in the middle, which cannot\n  \
    \   be expressed in a DNS message, because software parsing the message\n    \
    \ would misinterpret a zero label-length byte as being a zero \"end of\n     name\"\
    \ marker instead.\n   Finally, \"Clarifications to the DNS Specification\" [RFC2181]\
    \ offers\n   additional confirmation that, in the context of DNS specifications,\n\
    \   the stated \"length\" of a domain name does not include the terminating\n\
    \   zero byte at the end.  That document refers to the root name, which\n   is\
    \ typically written as \".\" and is represented in a DNS message by a\n   single\
    \ lone zero byte (i.e., zero bytes of data plus a terminating\n   zero), as the\
    \ \"zero length full name\":\n      The zero length full name is defined as representing\
    \ the root of\n      the DNS tree, and is typically written and displayed as \"\
    .\".\n   This wording supports the interpretation that, in a DNS context, when\n\
    \   talking about lengths of names, the terminating zero byte at the end\n   is\
    \ not counted.  If the root name (\".\") is considered to be zero\n   length,\
    \ then to be consistent, the length (for example) of \"org\" has\n   to be 4 and\
    \ the length of \"ietf.org\" has to be 9, as shown below:\n                  \
    \                                ------\n                                    \
    \             | 0x00 |   length = 0\n                                        \
    \          ------\n                             ------------------   ------\n\
    \                            | 0x03 | o | r | g | | 0x00 |   length = 4\n    \
    \                         ------------------   ------\n      -----------------------------------------\
    \   ------\n     | 0x04 | i | e | t | f | 0x03 | o | r | g | | 0x00 |   length\
    \ = 9\n      -----------------------------------------   ------\n   This means\
    \ that the maximum length of a domain name, as represented\n   in a Multicast\
    \ DNS message, up to but not including the final\n   terminating zero, must not\
    \ exceed 255 bytes.\n   However, many Unicast DNS implementers have read these\
    \ RFCs\n   differently, and argue that the 255-byte limit does include the\n \
    \  terminating zero, and that the \"Clarifications to the DNS\n   Specification\"\
    \ [RFC2181] statement that \".\" is the \"zero length full\n   name\" was simply\
    \ a mistake.\n   Hence, implementers should be aware that other Unicast DNS\n\
    \   implementations may limit the maximum domain name to 254 bytes plus a\n  \
    \ terminating zero, depending on how that implementer interpreted the\n   DNS\
    \ specifications.\n   Compliant Multicast DNS implementations MUST support names\
    \ up to 255\n   bytes plus a terminating zero, i.e., 256 bytes total.\n"
- title: Appendix D.  Benefits of Multicast Responses
  contents:
  - "Appendix D.  Benefits of Multicast Responses\n   Some people have argued that\
    \ sending responses via multicast is\n   inefficient on the network.  In fact,\
    \ using multicast responses can\n   result in a net lowering of overall multicast\
    \ traffic for a variety\n   of reasons, and provides other benefits too:\n   *\
    \ Opportunistic Caching.  One multicast response can update the\n     caches on\
    \ all machines on the network.  If another machine later\n     wants to issue\
    \ the same query, and it already has the answer in its\n     cache, it may not\
    \ need to even transmit that multicast query on the\n     network at all.\n  \
    \ * Duplicate Query Suppression.  When more than one machine has the\n     same\
    \ ongoing long-lived query running, every machine does not have\n     to transmit\
    \ its own independent query.  When one machine transmits\n     a query, all the\
    \ other hosts see the answers, so they can suppress\n     their own queries.\n\
    \   * Passive Observation Of Failures (POOF).  When a host sees a\n     multicast\
    \ query, but does not see the corresponding multicast\n     response, it can use\
    \ this information to promptly delete stale data\n     from its cache.  To achieve\
    \ the same level of user-interface\n     quality and responsiveness without multicast\
    \ responses would\n     require lower cache lifetimes and more frequent network\
    \ polling,\n     resulting in a higher packet rate.\n   * Passive Conflict Detection.\
    \  Just because a name has been\n     previously verified to be unique does not\
    \ guarantee it will\n     continue to be so indefinitely.  By allowing all Multicast\
    \ DNS\n     responders to constantly monitor their peers' responses, conflicts\n\
    \     arising out of network topology changes can be promptly detected\n     and\
    \ resolved.  If responses were not sent via multicast, some other\n     conflict\
    \ detection mechanism would be needed, imposing its own\n     additional burden\
    \ on the network.\n   * Use on devices with constrained memory resources: When\
    \ using\n     delayed responses to reduce network collisions, responders need\
    \ to\n     maintain a list recording to whom each answer should be sent.  The\n\
    \     option of multicast responses allows responders with limited\n     storage,\
    \ which cannot store an arbitrarily long list of response\n     addresses, to\
    \ choose to fail-over to a single multicast response in\n     place of multiple\
    \ unicast responses, when appropriate.\n   * Overlayed Subnets.  In the case of\
    \ overlayed subnets, multicast\n     responses allow a receiver to know with certainty\
    \ that a response\n     originated on the local link, even when its source address\
    \ may\n     apparently suggest otherwise.\n   * Robustness in the face of misconfiguration:\
    \ Link-local multicast\n     transcends virtually every conceivable network misconfiguration.\n\
    \     Even if you have a collection of devices where every device's IP\n     address,\
    \ subnet mask, default gateway, and DNS server address are\n     all wrong, packets\
    \ sent by any of those devices addressed to a\n     link-local multicast destination\
    \ address will still be delivered to\n     all peers on the local link.  This\
    \ can be extremely helpful when\n     diagnosing and rectifying network problems,\
    \ since it facilitates a\n     direct communication channel between client and\
    \ server that works\n     without reliance on ARP, IP routing tables, etc.  Being\
    \ able to\n     discover what IP address a device has (or thinks it has) is\n\
    \     frequently a very valuable first step in diagnosing why it is\n     unable\
    \ to communicate on the local network.\n"
- title: Appendix E.  Design Rationale for Encoding Negative Responses
  contents:
  - "Appendix E.  Design Rationale for Encoding Negative Responses\n   Alternative\
    \ methods of asserting nonexistence were considered, such\n   as using an NXDOMAIN\
    \ response, or emitting a resource record with\n   zero-length rdata.\n   Using\
    \ an NXDOMAIN response does not work well with Multicast DNS.  A\n   Unicast DNS\
    \ NXDOMAIN response applies to the entire message, but for\n   efficiency Multicast\
    \ DNS allows (and encourages) multiple responses\n   in a single message.  If\
    \ the error code in the header were NXDOMAIN,\n   it would not be clear to which\
    \ name(s) that error code applied.\n   Asserting nonexistence by emitting a resource\
    \ record with zero-length\n   rdata would mean that there would be no way to differentiate\
    \ between\n   a record that doesn't exist, and a record that does exist, with\
    \ zero-\n   length rdata.  By analogy, most file systems today allow empty files,\n\
    \   so a file that exists with zero bytes of data is not considered\n   equivalent\
    \ to a filename that does not exist.\n   A benefit of asserting nonexistence through\
    \ NSEC records instead of\n   through NXDOMAIN responses is that NSEC records\
    \ can be added to the\n   Additional Section of a DNS response to offer additional\
    \ information\n   beyond what the querier explicitly requested.  For example,\
    \ in\n   response to an SRV query, a responder should include A record(s)\n  \
    \ giving its IPv4 addresses in the Additional Section, and an NSEC\n   record\
    \ indicating which other types it does or does not have for this\n   name.  If\
    \ the responder is running on a host that does not support\n   IPv6 (or does support\
    \ IPv6 but currently has no IPv6 address on that\n   interface) then this NSEC\
    \ record in the Additional Section will\n   indicate this absence of AAAA records.\
    \  In effect, the responder is\n   saying, \"Here's my SRV record, and here are\
    \ my IPv4 addresses, and\n   no, I don't have any IPv6 addresses, so don't waste\
    \ your time\n   asking\".  Without this information in the Additional Section,\
    \ it\n   would take the querier an additional round-trip to perform an\n   additional\
    \ query to ascertain that the target host has no AAAA\n   records.  (Arguably\
    \ Unicast DNS could also benefit from this ability\n   to express nonexistence\
    \ in the Additional Section, but that is\n   outside the scope of this document.)\n"
- title: Appendix F.  Use of UTF-8
  contents:
  - "Appendix F.  Use of UTF-8\n   After many years of debate, as a result of the\
    \ perceived need to\n   accommodate certain DNS implementations that apparently\
    \ couldn't\n   handle any character that's not a letter, digit, or hyphen (and\n\
    \   apparently never would be updated to remedy this limitation), the\n   Unicast\
    \ DNS community settled on an extremely baroque encoding called\n   \"Punycode\"\
    \ [RFC3492].  Punycode is a remarkably ingenious encoding\n   solution, but it\
    \ is complicated, hard to understand, and hard to\n   implement, using sophisticated\
    \ techniques including insertion unsort\n   coding, generalized variable-length\
    \ integers, and bias adaptation.\n   The resulting encoding is remarkably compact\
    \ given the constraints,\n   but it's still not as good as simple straightforward\
    \ UTF-8, and it's\n   hard even to predict whether a given input string will encode\
    \ to a\n   Punycode string that fits within DNS's 63-byte limit, except by\n \
    \  simply trying the encoding and seeing whether it fits.  Indeed, the\n   encoded\
    \ size depends not only on the input characters, but on the\n   order they appear,\
    \ so the same set of characters may or may not\n   encode to a legal Punycode\
    \ string that fits within DNS's 63-byte\n   limit, depending on the order the\
    \ characters appear.  This is\n   extremely hard to present in a user interface\
    \ that explains to users\n   why one name is allowed, but another name containing\
    \ the exact same\n   characters is not.  Neither Punycode nor any other of the\
    \ \"ASCII-\n   Compatible Encodings\" [RFC5890] proposed for Unicast DNS may be\
    \ used\n   in Multicast DNS messages.  Any text being represented internally in\n\
    \   some other representation must be converted to canonical precomposed\n   UTF-8\
    \ before being placed in any Multicast DNS message.\n"
- title: Appendix G.  Private DNS Namespaces
  contents:
  - "Appendix G.  Private DNS Namespaces\n   The special treatment of names ending\
    \ in \".local.\" has been\n   implemented in Macintosh computers since the days\
    \ of Mac OS 9, and\n   continues today in Mac OS X and iOS.  There are also implementations\n\
    \   for Microsoft Windows [B4W], Linux, and other platforms.\n   Some network\
    \ operators setting up private internal networks\n   (\"intranets\") have used\
    \ unregistered top-level domains, and some may\n   have used the \".local\" top-level\
    \ domain.  Using \".local\" as a private\n   top-level domain conflicts with Multicast\
    \ DNS and may cause problems\n   for users.  Clients can be configured to send\
    \ both Multicast and\n   Unicast DNS queries in parallel for these names, and\
    \ this does allow\n   names to be looked up both ways, but this results in additional\n\
    \   network traffic and additional delays in name resolution, as well as\n   potentially\
    \ creating user confusion when it is not clear whether any\n   given result was\
    \ received via link-local multicast from a peer on the\n   same link, or from\
    \ the configured unicast name server.  Because of\n   this, we recommend against\
    \ using \".local\" as a private Unicast DNS\n   top-level domain.  We do not recommend\
    \ use of unregistered top-level\n   domains at all, but should network operators\
    \ decide to do this, the\n   following top-level domains have been used on private\
    \ internal\n   networks without the problems caused by trying to reuse \".local.\"\
    \ for\n   this purpose:\n      .intranet.\n      .internal.\n      .private.\n\
    \      .corp.\n      .home.\n      .lan.\n"
- title: Appendix H.  Deployment History
  contents:
  - "Appendix H.  Deployment History\n   In July 1997, in an email to the net-thinkers@thumper.vmeng.com\n\
    \   mailing list, Stuart Cheshire first proposed the idea of running the\n   AppleTalk\
    \ Name Binding Protocol [RFC6760] over IP.  As a result of\n   this and related\
    \ IETF discussions, the IETF Zeroconf working group\n   was chartered September\
    \ 1999.  After various working group\n   discussions and other informal IETF discussions,\
    \ several Internet-\n   Drafts were written that were loosely related to the general\
    \ themes\n   of DNS and multicast, but did not address the service discovery\n\
    \   aspect of NBP.\n   In April 2000, Stuart Cheshire registered IPv4 multicast\
    \ address\n   224.0.0.251 with IANA [MC4] and began writing code to test and\n\
    \   develop the idea of performing NBP-like service discovery using\n   Multicast\
    \ DNS, which was documented in a group of three Internet-\n   Drafts:\n   o \"\
    Requirements for a Protocol to Replace the AppleTalk Name Binding\n     Protocol\
    \ (NBP)\" [RFC6760] is an overview explaining the AppleTalk\n     Name Binding\
    \ Protocol, because many in the IETF community had\n     little first-hand experience\
    \ using AppleTalk, and confusion in the\n     IETF community about what AppleTalk\
    \ NBP did was causing confusion\n     about what would be required in an IP-based\
    \ replacement.\n   o \"Discovering Named Instances of Abstract Services using\
    \ DNS\" [NIAS]\n     proposed a way to perform NBP-like service discovery using\
    \ DNS-\n     compatible names and record types.\n   o \"Multicast DNS\" (this\
    \ document) specifies a way to transport those\n     DNS-compatible queries and\
    \ responses using IP multicast, for zero-\n     configuration environments where\
    \ no conventional Unicast DNS server\n     was available.\n   In 2001, an update\
    \ to Mac OS 9 added resolver library support for\n   host name lookup using Multicast\
    \ DNS.  If the user typed a name such\n   as \"MyPrinter.local.\" into any piece\
    \ of networking software that used\n   the standard Mac OS 9 name lookup APIs,\
    \ then those name lookup APIs\n   would recognize the name as a dot-local name\
    \ and query for it by\n   sending simple one-shot Multicast DNS queries to 224.0.0.251:5353.\n\
    \   This enabled the user to, for example, enter the name\n   \"MyPrinter.local.\"\
    \ into their web browser in order to view a\n   printer's status and configuration\
    \ web page, or enter the name\n   \"MyPrinter.local.\" into the printer setup\
    \ utility to create a print\n   queue for printing documents on that printer.\n\
    \   Multicast DNS responder software, with full service discovery, first\n   began\
    \ shipping to end users in volume with the launch of Mac OS X\n   10.2 \"Jaguar\"\
    \ in August 2002, and network printer makers (who had\n   historically supported\
    \ AppleTalk in their network printers and were\n   receptive to IP-based technologies\
    \ that could offer them similar\n   ease-of-use) started adopting Multicast DNS\
    \ shortly thereafter.\n   In September 2002, Apple released the source code for\
    \ the\n   mDNSResponder daemon as Open Source under Apple's standard Apple\n \
    \  Public Source License (APSL).\n   Multicast DNS responder software became available\
    \ for Microsoft\n   Windows users in June 2004 with the launch of Apple's \"Rendezvous\
    \ for\n   Windows\" (now \"Bonjour for Windows\"), both in executable form (a\n\
    \   downloadable installer for end users) and as Open Source (one of the\n   supported\
    \ platforms within Apple's body of cross-platform code in the\n   publicly accessible\
    \ mDNSResponder CVS source code repository) [BJ].\n   In August 2006, Apple re-licensed\
    \ the cross-platform mDNSResponder\n   source code under the Apache License, Version\
    \ 2.0.\n   In addition to desktop and laptop computers running Mac OS X and\n\
    \   Microsoft Windows, Multicast DNS is now implemented in a wide range\n   of\
    \ hardware devices, such as Apple's \"AirPort\" wireless base\n   stations, iPhone\
    \ and iPad, and in home gateways from other vendors,\n   network printers, network\
    \ cameras, TiVo DVRs, etc.\n   The Open Source community has produced many independent\n\
    \   implementations of Multicast DNS, some in C like Apple's\n   mDNSResponder\
    \ daemon, and others in a variety of different languages\n   including Java, Python,\
    \ Perl, and C#/Mono.\n   In January 2007, the IETF published the Informational\
    \ RFC \"Link-Local\n   Multicast Name Resolution (LLMNR)\" [RFC4795], which is\
    \ substantially\n   similar to Multicast DNS, but incompatible in some small but\n\
    \   important ways.  In particular, the LLMNR design explicitly excluded\n   support\
    \ for service discovery, which made it an unsuitable candidate\n   for a protocol\
    \ to replace AppleTalk NBP [RFC6760].\n   While the original focus of Multicast\
    \ DNS and DNS-Based Service\n   Discovery was for zero-configuration environments\
    \ without a\n   conventional Unicast DNS server, DNS-Based Service Discovery also\n\
    \   works using Unicast DNS servers, using DNS Update [RFC2136] [RFC3007]\n  \
    \ to create service discovery records and standard DNS queries to query\n   for\
    \ them.  Apple's Back to My Mac service, launched with Mac OS X\n   10.5 \"Leopard\"\
    \ in October 2007, uses DNS-Based Service Discovery over\n   Unicast DNS [RFC6281].\n\
    \   In June 2012, Google's Android operating system added native support\n   for\
    \ DNS-SD and Multicast DNS with the android.net.nsd.NsdManager\n   class in Android\
    \ 4.1 \"Jelly Bean\" (API Level 16) [NSD].\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Stuart Cheshire\n   Apple Inc.\n   1 Infinite Loop\n \
    \  Cupertino, CA  95014\n   USA\n   Phone: +1 408 974 3207\n   EMail: cheshire@apple.com\n\
    \   Marc Krochmal\n   Apple Inc.\n   1 Infinite Loop\n   Cupertino, CA  95014\n\
    \   USA\n   Phone: +1 408 974 4368\n   EMail: marc@apple.com\n"
