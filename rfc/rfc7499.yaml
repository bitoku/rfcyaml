- title: __initial_text__
  contents:
  - '               Support of Fragmentation of RADIUS Packets

    '
- title: Abstract
  contents:
  - "Abstract\n   The Remote Authentication Dial-In User Service (RADIUS) protocol\
    \ is\n   limited to a total packet size of 4096 bytes.  Provisions exist for\n\
    \   fragmenting large amounts of authentication data across multiple\n   packets,\
    \ via Access-Challenge packets.  No similar provisions exist\n   for fragmenting\
    \ large amounts of authorization data.  This document\n   specifies how existing\
    \ RADIUS mechanisms can be leveraged to provide\n   that functionality.  These\
    \ mechanisms are largely compatible with\n   existing implementations, and they\
    \ are designed to be invisible to\n   proxies and \"fail-safe\" to legacy RADIUS\
    \ Clients and Servers.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7499.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Requirements Language ......................................6\n  \
    \ 2. Status of This Document .........................................6\n   3.\
    \ Scope of This Document ..........................................7\n   4. Overview\
    \ .......................................................10\n   5. Fragmentation\
    \ of Packets .......................................13\n      5.1. Pre-Authorization\
    \ .........................................14\n      5.2. Post-Authorization ........................................18\n\
    \   6. Chunk Size .....................................................21\n  \
    \ 7. Allowed Large Packet Size ......................................22\n   8.\
    \ Handling Special Attributes ....................................23\n      8.1.\
    \ Proxy-State Attribute .....................................23\n      8.2. State\
    \ Attribute ...........................................24\n      8.3. Service-Type\
    \ Attribute ....................................25\n      8.4. Rebuilding the\
    \ Original Large Packet ......................25\n   9. New T Flag for the Long\
    \ Extended Type Attribute Definition .....26\n   10. New Attribute Definition\
    \ ......................................26\n      10.1. Frag-Status Attribute\
    \ ....................................27\n      10.2. Proxy-State-Length Attribute\
    \ .............................28\n      10.3. Table of Attributes ......................................29\n\
    \   11. Operation with Proxies ........................................29\n  \
    \    11.1. Legacy Proxies ...........................................29\n    \
    \  11.2. Updated Proxies ..........................................29\n   12.\
    \ General Considerations ........................................31\n      12.1.\
    \ T Flag ...................................................31\n      12.2. Violation\
    \ of RFC 2865 ....................................32\n      12.3. Proxying Based\
    \ on User-Name ..............................32\n      12.4. Transport Behavior\
    \ .......................................33\n   13. Security Considerations .......................................33\n\
    \   14. IANA Considerations ...........................................34\n  \
    \ 15. References ....................................................35\n    \
    \  15.1. Normative References .....................................35\n      15.2.\
    \ Informative References ...................................35\n   Acknowledgements\
    \ ..................................................37\n   Authors' Addresses\
    \ ................................................37\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The RADIUS [RFC2865] protocol carries authentication, authorization,\n\
    \   and accounting information between a RADIUS Client and a RADIUS\n   Server.\
    \  Information is exchanged between them through RADIUS\n   packets.  Each RADIUS\
    \ packet is composed of a header, and zero or\n   more attributes, up to a maximum\
    \ packet size of 4096 bytes.  The\n   protocol is a request/response protocol,\
    \ as described in the\n   operational model ([RFC6158], Section 3.1).\n   The\
    \ intention of the above packet size limitation was to avoid UDP\n   fragmentation\
    \ as much as possible.  Back then, a size of 4096 bytes\n   seemed large enough\
    \ for any purpose.  Now, new scenarios are emerging\n   that require the exchange\
    \ of authorization information exceeding this\n   4096-byte limit.  For instance,\
    \ the Application Bridging for\n   Federated Access Beyond web (ABFAB) IETF working\
    \ group defines the\n   transport of Security Assertion Markup Language (SAML)\
    \ statements\n   from the RADIUS Server to the RADIUS Client [SAML-RADIUS].  This\n\
    \   assertion is likely to be larger than 4096 bytes.\n   This means that peers\
    \ desiring to send large amounts of data must\n   fragment it across multiple\
    \ packets.  For example, RADIUS-EAP\n   [RFC3579] defines how an Extensible Authentication\
    \ Protocol (EAP)\n   exchange occurs across multiple Access-Request / Access-Challenge\n\
    \   sequences.  No such exchange is possible for accounting or\n   authorization\
    \ data.  [RFC6158], Section 3.1 suggests that exchanging\n   large amounts of\
    \ authorization data is unnecessary in RADIUS.\n   Instead, the data should be\
    \ referenced by name.  This requirement\n   allows large policies to be pre-provisioned\
    \ and then referenced in an\n   Access-Accept.  In some cases, however, the authorization\
    \ data sent\n   by the RADIUS Server is large and highly dynamic.  In other cases,\n\
    \   the RADIUS Client needs to send large amounts of authorization data\n   to\
    \ the RADIUS Server.  Neither of these cases is met by the\n   requirements in\
    \ [RFC6158].  As noted in that document, the practical\n   limit on RADIUS packet\
    \ sizes is governed by the Path MTU (PMTU),\n   which may be significantly smaller\
    \ than 4096 bytes.  The combination\n   of the two limitations means that there\
    \ is a pressing need for a\n   method to send large amounts of authorization data\
    \ between RADIUS\n   Client and Server, with no accompanying solution.\n   [RFC6158],\
    \ Section 3.1 recommends three approaches for the\n   transmission of large amounts\
    \ of data within RADIUS.  However, they\n   are not applicable to the problem\
    \ statement of this document for the\n   following reasons:\n   o  The first approach\
    \ (utilization of a sequence of packets) does not\n      talk about large amounts\
    \ of data sent from the RADIUS Client to a\n      RADIUS Server.  Leveraging EAP\
    \ (request/challenge) to send the\n      data is not feasible, as EAP already\
    \ fills packets to PMTU, and\n      not all authentications use EAP.  Moreover,\
    \ as noted for the\n      NAS-Filter-Rule attribute ([RFC4849]), this approach\
    \ does not\n      entirely solve the problem of sending large amounts of data\
    \ from a\n      RADIUS Server to a RADIUS Client, as many current RADIUS\n   \
    \   attributes are not permitted in Access-Challenge packets.\n   o  The second\
    \ approach (utilization of names rather than values) is\n      not usable either,\
    \ as using names rather than values is difficult\n      when the nature of the\
    \ data to be sent is highly dynamic (e.g., a\n      SAML statement or NAS-Filter-Rule\
    \ attributes).  URLs could be used\n      as a pointer to the location of the\
    \ actual data, but their use\n      would require them to be (a) dynamically created\
    \ and modified,\n      (b) securely accessed, and (c) accessible from remote systems.\n\
    \      Satisfying these constraints would require the modification of\n      several\
    \ networking systems (e.g., firewalls and web servers).\n      Furthermore, the\
    \ setup of an additional trust infrastructure\n      (e.g., Public Key Infrastructure\
    \ (PKI)) would be required to allow\n      secure retrieval of the information\
    \ from the web server.\n   o  PMTU discovery does not solve the problem, as it\
    \ does not allow\n      the sending of data larger than the minimum of (PMTU or\
    \ 4096)\n      bytes.\n   This document provides a mechanism to allow RADIUS peers\
    \ to exchange\n   large amounts of authorization data exceeding the 4096-byte\
    \ limit by\n   fragmenting it across several exchanges.  The proposed solution\
    \ does\n   not impose any additional requirements to the RADIUS system\n   administrators\
    \ (e.g., need to modify firewall rules, set up web\n   servers, configure routers,\
    \ or modify any application server).  It\n   maintains compatibility with intra-packet\
    \ fragmentation mechanisms\n   (like those defined in [RFC3579] or [RFC6929]).\
    \  It is also\n   transparent to existing RADIUS proxies, which do not implement\
    \ this\n   specification.  The only systems needing to implement this RFC are\n\
    \   the ones that either generate or consume the fragmented data being\n   transmitted.\
    \  Intermediate proxies just pass the packets without\n   changes.  Nevertheless,\
    \ if a proxy supports this specification, it\n   may reassemble the data in order\
    \ to examine and/or modify it.\n   A different approach to deal with RADIUS packets\
    \ above the 4096-byte\n   limit is described in [RADIUS-Larger-Pkts], which proposes\
    \ to extend\n   RADIUS over TCP by allowing the Length field in the RADIUS header\
    \ to\n   take values up to 65535 bytes.  This provides a simpler operation,\n\
    \   but it has the drawback of requiring every RADIUS proxy in the path\n   between\
    \ the RADIUS Client and the RADIUS Server to implement the\n   extension as well.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n   When these words appear in lower case, they have\
    \ their natural\n   language meaning.\n"
- title: 2.  Status of This Document
  contents:
  - "2.  Status of This Document\n   This document is an Experimental RFC.  It defines\
    \ a proposal to allow\n   the sending and receiving of data exceeding the 4096-byte\
    \ limit in\n   RADIUS packets imposed by [RFC2865], without requiring the\n  \
    \ modification of intermediary proxies.\n   The experiment consists of verifying\
    \ whether the approach is usable\n   in a large-scale environment, by observing\
    \ the uptake, usability, and\n   operational behavior it shows in large-scale,\
    \ real-life deployments.\n   In that sense, so far the main use case for this\
    \ specification is the\n   transportation of large SAML statements defined within\
    \ the ABFAB\n   architecture [ABFAB-Arch].  Hence, it can be tested wherever an\
    \ ABFAB\n   deployment is being piloted.\n   Besides, this proposal defines some\
    \ experimental features that will\n   need to be tested and verified before the\
    \ document can be considered\n   for the Standards Track.  The first one of them\
    \ is the requirement of\n   updating [RFC2865] in order to relax the sentence\
    \ defined in\n   Section 4.1 of that document that states that \"An Access-Request\
    \ MUST\n   contain either a User-Password or a CHAP-Password or a State.\"  This\n\
    \   specification might generate Access-Request packets without any of\n   these\
    \ attributes.  Although all known implementations have chosen the\n   philosophy\
    \ of \"be liberal in what you accept,\" we need to gain more\n   operational experience\
    \ to verify that unmodified proxies do not drop\n   these types of packets.  More\
    \ details on this aspect can be found in\n   Section 12.2.\n   Another experimental\
    \ feature of this specification is that it\n   requires proxies to base their\
    \ routing decisions on the value of the\n   RADIUS User-Name attribute.  Our experience\
    \ is that this is the\n   common behavior; thus, no issues are expected.  However,\
    \ it needs to\n   be confirmed after using different implementations of intermediate\n\
    \   proxies.  More details on this aspect can be found in Section 12.3.\n   Moreover,\
    \ this document requires two minor updates to Standards Track\n   documents. \
    \ First, it modifies the definition of the Reserved field\n   of the Long Extended\
    \ Type attribute [RFC6929] by allocating an\n   additional flag called the T (Truncation)\
    \ flag.  No issues are\n   expected with this update, although some proxies might\
    \ drop packets\n   that do not have the Reserved field set to 0.  More details\
    \ on this\n   aspect can be found in Section 12.1.\n   The other Standards Track\
    \ document that requires a minor update is\n   [RFC6158].  It states that \"attribute\
    \ designers SHOULD NOT assume\n   that a RADIUS implementation can successfully\
    \ process RADIUS packets\n   larger than 4096 bytes,\" something no longer true\
    \ if this document\n   advances.\n   A proper \"Updates\" clause will be included\
    \ for these modifications\n   when/if the experiment is successful and this document\
    \ is reissued as\n   a Standards Track document.\n"
- title: 3.  Scope of This Document
  contents:
  - "3.  Scope of This Document\n   This specification describes how a RADIUS Client\
    \ and a RADIUS Server\n   can exchange data exceeding the 4096-byte limit imposed\
    \ by one\n   packet.  However, the mechanism described in this specification\n\
    \   SHOULD NOT be used to exchange more than 100 kilobytes of data.  Any\n   more\
    \ than this may turn RADIUS into a generic transport protocol,\n   such as TCP\
    \ or the Stream Control Transmission Protocol (SCTP), which\n   is undesirable.\
    \  Experience shows that attempts to transport bulk\n   data across the Internet\
    \ with UDP will inevitably fail, unless these\n   transport attempts reimplement\
    \ all of the behavior of TCP.  The\n   underlying design of RADIUS lacks the proper\
    \ retransmission policies\n   or congestion control mechanisms that would make\
    \ it a competitor\n   of TCP.\n   Therefore, RADIUS/UDP transport is by design\
    \ unable to transport bulk\n   data.  It is both undesirable and impossible to\
    \ change the protocol\n   at this point in time.  This specification is intended\
    \ to allow the\n   transport of more than 4096 bytes of data through existing\
    \ RADIUS/UDP\n   proxies.  Other solutions such as RADIUS/TCP MUST be used when\
    \ a\n   \"green field\" deployment requires the transport of bulk data.\n   Section\
    \ 7, below, describes in further detail what is considered to\n   be a reasonable\
    \ amount of data and recommends that administrators\n   adjust limitations on\
    \ data transfer according to the specific\n   capabilities of their existing systems\
    \ in terms of memory and\n   processing power.\n   Moreover, its scope is limited\
    \ to the exchange of authorization data,\n   as other exchanges do not require\
    \ such a mechanism.  In particular,\n   authentication exchanges have already\
    \ been defined to overcome this\n   limitation (e.g., RADIUS-EAP).  Moreover,\
    \ as they represent the most\n   critical part of a RADIUS conversation, it is\
    \ preferable to not\n   introduce into their operation any modification that may\
    \ affect\n   existing equipment.\n   There is no need to fragment accounting packets\
    \ either.  While the\n   accounting process can send large amounts of data, that\
    \ data is\n   typically composed of many small updates.  That is, there is no\n\
    \   demonstrated need to send indivisible blocks of more than 4 kilobytes\n  \
    \ of data.  The need to send large amounts of data per user session\n   often\
    \ originates from the need for flow-based accounting.  In this\n   use case, the\
    \ RADIUS Client may send accounting data for many\n   thousands of flows, where\
    \ all those flows are tied to one user\n   session.  The existing Acct-Multi-Session-Id\
    \ attribute defined in\n   [RFC2866], Section 5.11 has been proven to work here.\n\
    \   Similarly, there is no need to fragment Change-of-Authorization (CoA)\n  \
    \ [RFC5176] packets.  Instead, according to [RFC5176], the CoA client\n   will\
    \ send a CoA-Request packet containing session identification\n   attributes,\
    \ along with Service-Type = Additional-Authorization, and a\n   State attribute.\
    \  Implementations not supporting fragmentation will\n   respond with a CoA-NAK\
    \ and an Error-Cause of Unsupported-Service.\n   The above requirement does not\
    \ assume that the CoA client and the\n   RADIUS Server are co-located.  They may,\
    \ in fact, be run on separate\n   parts of the infrastructure, or even by separate\
    \ administrators.\n   There is, however, a requirement that the two communicate.\
    \  We can\n   see that the CoA client needs to send session identification\n \
    \  attributes in order to send CoA packets.  These attributes cannot be\n   known\
    \ a priori by the CoA client and can only come from the RADIUS\n   Server.  Therefore,\
    \ even when the two systems are not co-located,\n   they must be able to communicate\
    \ in order to operate in unison.  The\n   alternative is for the two systems to\
    \ have differing views of the\n   users' authorization parameters; such a scenario\
    \ would be a security\n   disaster.\n   This specification does not allow for\
    \ fragmentation of CoA packets.\n   Allowing for fragmented CoA packets would\
    \ involve changing multiple\n   parts of the RADIUS protocol; such changes introduce\
    \ the risk of\n   implementation issues, mistakes, etc.\n   Where CoA clients\
    \ (i.e., RADIUS Servers) need to send large amounts\n   of authorization data\
    \ to a CoA server (i.e., RADIUS Client), they\n   need only send a minimal CoA-Request\
    \ packet containing a Service-Type\n   of Authorize Only, as per [RFC5176], along\
    \ with session\n   identification attributes.  This CoA packet serves as a signal\
    \ to the\n   RADIUS Client that the users' session requires re-authorization.\n\
    \   When the RADIUS Client re-authorizes the user via Access-Request, the\n  \
    \ RADIUS Server can perform fragmentation and send large amounts of\n   authorization\
    \ data to the RADIUS Client.\n   The assumption in the above scenario is that\
    \ the CoA client and\n   RADIUS Server are co-located, or at least strongly coupled.\
    \  That is,\n   the path from CoA client to CoA server SHOULD be the exact reverse\
    \ of\n   the path from RADIUS Client to RADIUS Server.  The following diagram\n\
    \   will hopefully clarify the roles:\n                              +----------------+\n\
    \                              | RADIUS   CoA   |\n                          \
    \    | Client  Server |\n                              +----------------+\n  \
    \                               |        ^\n                 Access-Request  |\
    \        |   CoA-Request\n                                 v        |\n      \
    \                        +----------------+\n                              | RADIUS\
    \   CoA   |\n                              | Server  Client |\n              \
    \                +----------------+\n   Where there is a proxy involved:\n   \
    \                           +----------------+\n                             \
    \ | RADIUS   CoA   |\n                              | Client  Server |\n     \
    \                         +----------------+\n                               \
    \  |        ^\n                 Access-Request  |        |   CoA-Request\n   \
    \                              v        |\n                              +----------------+\n\
    \                              | RADIUS   CoA   |\n                          \
    \    | Proxy   Proxy  |\n                              +----------------+\n  \
    \                               |        ^\n                 Access-Request  |\
    \        |   CoA-Request\n                                 v        |\n      \
    \                        +----------------+\n                              | RADIUS\
    \   CoA   |\n                              | Server  Client |\n              \
    \                +----------------+\n   That is, the RADIUS and CoA subsystems\
    \ at each hop are strongly\n   connected.  Where they are not strongly connected,\
    \ it will be\n   impossible to use CoA-Request packets to transport large amounts\
    \ of\n   authorization data.\n   This design is more complicated than allowing\
    \ for fragmented CoA\n   packets.  However, the CoA client and the RADIUS Server\
    \ must\n   communicate even when not using this specification.  We believe that\n\
    \   standardizing that communication and using one method for exchange of\n  \
    \ large data are preferred to unspecified communication methods and\n   multiple\
    \ ways of achieving the same result.  If we were to allow\n   fragmentation of\
    \ data over CoA packets, the size and complexity of\n   this specification would\
    \ increase significantly.\n   The above requirement solves a number of issues.\
    \  It clearly\n   separates session identification from authorization.  Without\
    \ this\n   separation, it is difficult to both identify a session and change its\n\
    \   authorization using the same attribute.  It also ensures that the\n   authorization\
    \ process is the same for initial authentication and\n   for CoA.\n"
- title: 4.  Overview
  contents:
  - "4.  Overview\n   Authorization exchanges can occur either before or after end-user\n\
    \   authentication has been completed.  An authorization exchange before\n   authentication\
    \ allows a RADIUS Client to provide the RADIUS Server\n   with information that\
    \ MAY modify how the authentication process will\n   be performed (e.g., it may\
    \ affect the selection of the EAP method).\n   An authorization exchange after\
    \ authentication allows the RADIUS\n   Server to provide the RADIUS Client with\
    \ information about the end\n   user, the results of the authentication process,\
    \ and/or obligations\n   to be enforced.  In this specification, we refer to\n\
    \   \"pre-authorization\" as the exchange of authorization information\n   before\
    \ the end-user authentication has started (from the RADIUS\n   Client to the RADIUS\
    \ Server), whereas the term \"post-authorization\"\n   is used to refer to an\
    \ authorization exchange happening after this\n   authentication process (from\
    \ the RADIUS Server to the RADIUS Client).\n   In this specification, we refer\
    \ to the \"size limit\" as the practical\n   limit on RADIUS packet sizes.  This\
    \ limit is the minimum between\n   4096 bytes and the current PMTU.  We define\
    \ below a method that uses\n   Access-Request and Access-Accept in order to exchange\
    \ fragmented\n   data.  The RADIUS Client and Server exchange a series of\n  \
    \ Access-Request / Access-Accept packets, until such time as all of the\n   fragmented\
    \ data has been transported.  Each packet contains a\n   Frag-Status attribute,\
    \ which lets the other party know if\n   fragmentation is desired, ongoing, or\
    \ finished.  Each packet may also\n   contain the fragmented data or may instead\
    \ be an \"ACK\" to a previous\n   fragment from the other party.  Each Access-Request\
    \ contains a\n   User-Name attribute, allowing the packet to be proxied if necessary\n\
    \   (see Section 11.1).  Each Access-Request may also contain a State\n   attribute,\
    \ which serves to tie it to a previous Access-Accept.  Each\n   Access-Accept\
    \ contains a State attribute, for use by the RADIUS\n   Client in a later Access-Request.\
    \  Each Access-Accept contains a\n   Service-Type attribute with the \"Additional-Authorization\"\
    \ value.\n   This indicates that the service being provided is part of a\n   fragmented\
    \ exchange and that the Access-Accept should not be\n   interpreted as providing\
    \ network access to the end user.\n   When a RADIUS Client or RADIUS Server needs\
    \ to send data that exceeds\n   the size limit, the mechanism proposed in this\
    \ document is used.\n   Instead of encoding one large RADIUS packet, a series\
    \ of smaller\n   RADIUS packets of the same type are encoded.  Each smaller packet\
    \ is\n   called a \"chunk\" in this specification, in order to distinguish it\n\
    \   from traditional RADIUS packets.  The encoding process is a simple\n   linear\
    \ walk over the attributes to be encoded.  This walk preserves\n   the order of\
    \ the attributes of the same type, as required by\n   [RFC2865].  The number of\
    \ attributes encoded in a particular chunk\n   depends on the size limit, the\
    \ size of each attribute, the number of\n   proxies between the RADIUS Client\
    \ and RADIUS Server, and the overhead\n   for fragmentation-signaling attributes.\
    \  Specific details are given\n   in Section 6.  A new attribute called Frag-Status\
    \ (Section 10.1)\n   signals the fragmentation status.\n   After the first chunk\
    \ is encoded, it is sent to the other party.  The\n   packet is identified as\
    \ a chunk via the Frag-Status attribute.  The\n   other party then requests additional\
    \ chunks, again using the\n   Frag-Status attribute.  This process is repeated\
    \ until all the\n   attributes have been sent from one party to the other.  When\
    \ all the\n   chunks have been received, the original list of attributes is\n\
    \   reconstructed and processed as if it had been received in one packet.\n  \
    \ The reconstruction process is performed by simply appending all of\n   the chunks\
    \ together.  Unlike IPv4 fragmentation, there is no Fragment\n   Offset field.\
    \  The chunks in this specification are explicitly\n   ordered, as RADIUS is a\
    \ lock-step protocol, as noted in Section 12.4.\n   That is, chunk N+1 cannot\
    \ be sent until all of the chunks up to and\n   including N have been received\
    \ and acknowledged.\n   When multiple chunks are sent, a special situation may\
    \ occur for Long\n   Extended Type attributes as defined in [RFC6929].  The fragmentation\n\
    \   process may split a fragmented attribute across two or more chunks,\n   which\
    \ is not permitted by that specification.  We address this issue\n   by using\
    \ the newly defined T flag in the Reserved field of the Long\n   Extended Type\
    \ attribute format (see Section 9 for further details on\n   this flag).\n   This\
    \ last situation is expected to be the most common occurrence in\n   chunks. \
    \ Typically, packet fragmentation will occur as a consequence\n   of a desire\
    \ to send one or more large (and therefore fragmented)\n   attributes.  The large\
    \ attribute will likely be split into two or\n   more pieces.  Where chunking\
    \ does not split a fragmented attribute,\n   no special treatment is necessary.\n\
    \   The setting of the T flag is the only case where the chunking process\n  \
    \ affects the content of an attribute.  Even then, the Value fields of\n   all\
    \ attributes remain unchanged.  Any per-packet security attributes,\n   such as\
    \ Message-Authenticator, are calculated for each chunk\n   independently.  Neither\
    \ integrity checks nor security checks are\n   performed on the \"original\" packet.\n\
    \   Each RADIUS packet sent or received as part of the chunking process\n   MUST\
    \ be a valid packet, subject to all format and security\n   requirements.  This\
    \ requirement ensures that a \"transparent\" proxy\n   not implementing this specification\
    \ can receive and send compliant\n   packets.  That is, a proxy that simply forwards\
    \ packets without\n   detailed examination or any modification will be able to\
    \ proxy\n   \"chunks\".\n"
- title: 5.  Fragmentation of Packets
  contents:
  - "5.  Fragmentation of Packets\n   When the RADIUS Client or the RADIUS Server\
    \ desires to send a packet\n   that exceeds the size limit, it is split into chunks\
    \ and sent via\n   multiple client/server exchanges.  The exchange is indicated\
    \ via the\n   Frag-Status attribute, which has value More-Data-Pending for all\
    \ but\n   the last chunk of the series.  The chunks are tied together via the\n\
    \   State attribute.\n   The delivery of a large fragmented RADIUS packet with\
    \ authorization\n   data can happen before or after the end user has been authenticated\n\
    \   by the RADIUS Server.  We can distinguish two phases, which can be\n   omitted\
    \ if there is no authorization data to be sent:\n   1.  Pre-authorization.  In\
    \ this phase, the RADIUS Client MAY send a\n       large packet with authorization\
    \ information to the RADIUS Server\n       before the end user is authenticated.\
    \  Only the RADIUS Client is\n       allowed to send authorization data during\
    \ this phase.\n   2.  Post-authorization.  In this phase, the RADIUS Server MAY\
    \ send a\n       large packet with authorization data to the RADIUS Client after\n\
    \       the end user has been authenticated.  Only the RADIUS Server is\n    \
    \   allowed to send authorization data during this phase.\n   The following subsections\
    \ describe how to perform fragmentation for\n   packets for these two phases.\
    \  We give the packet type, along with a\n   RADIUS Identifier, to indicate that\
    \ requests and responses are\n   connected.  We then give a list of attributes.\
    \  We do not give values\n   for most attributes, as we wish to concentrate on\
    \ the fragmentation\n   behavior rather than packet contents.  Attribute values\
    \ are given for\n   attributes relevant to the fragmentation process.  Where \"\
    long\n   extended\" attributes are used, we indicate the M (More) and T\n   (Truncation)\
    \ flags as optional square brackets after the attribute\n   name.  As no \"long\
    \ extended\" attributes have yet been defined, we use\n   example attributes,\
    \ named as \"Example-Long-1\", etc.  For the sake of\n   simplicity, the maximum\
    \ chunk size is established in terms of the\n   number of attributes (11).\n"
- title: 5.1.  Pre-Authorization
  contents:
  - "5.1.  Pre-Authorization\n   When the RADIUS Client needs to send a large amount\
    \ of data to the\n   RADIUS Server, the data to be sent is split into chunks and\
    \ sent to\n   the RADIUS Server via multiple Access-Request / Access-Accept\n\
    \   exchanges.  The example below shows this exchange.\n   The following is an\
    \ Access-Request that the RADIUS Client intends to\n   send to a RADIUS Server.\
    \  However, due to a combination of issues\n   (PMTU, large attributes, etc.),\
    \ the content does not fit into one\n   Access-Request packet.\n   Access-Request\n\
    \       User-Name\n       NAS-Identifier\n       Calling-Station-Id\n       Example-Long-1\
    \ [M]\n       Example-Long-1 [M]\n       Example-Long-1 [M]\n       Example-Long-1\
    \ [M]\n       Example-Long-1 [M]\n       Example-Long-1 [M]\n       Example-Long-1\
    \ [M]\n       Example-Long-1 [M]\n       Example-Long-1\n       Example-Long-2\
    \ [M]\n       Example-Long-2 [M]\n       Example-Long-2\n                    \
    \ Figure 1: Desired Access-Request\n   The RADIUS Client therefore must send the\
    \ attributes listed above in\n   a series of chunks.  The first chunk contains\
    \ eight (8) attributes\n   from the original Access-Request, and a Frag-Status\
    \ attribute.  Since\n   the last attribute is \"Example-Long-1\" with the M flag\
    \ set, the\n   chunking process also sets the T flag in that attribute.  The\n\
    \   Access-Request is sent with a RADIUS Identifier field having\n   value 23.\
    \  The Frag-Status attribute has value More-Data-Pending, to\n   indicate that\
    \ the RADIUS Client wishes to send more data in a\n   subsequent Access-Request.\
    \  The RADIUS Client also adds a\n   Service-Type attribute, which indicates that\
    \ it is part of the\n   chunking process.  The packet is signed with the\n   Message-Authenticator\
    \ attribute, completing the maximum number of\n   attributes (11).\n   Access-Request\
    \ (ID = 23)\n       User-Name\n       NAS-Identifier\n       Calling-Station-Id\n\
    \       Example-Long-1 [M]\n       Example-Long-1 [M]\n       Example-Long-1 [M]\n\
    \       Example-Long-1 [M]\n       Example-Long-1 [MT]\n       Frag-Status = More-Data-Pending\n\
    \       Service-Type = Additional-Authorization\n       Message-Authenticator\n\
    \                    Figure 2: Access-Request (Chunk 1)\n   Compliant RADIUS Servers\
    \ (i.e., servers implementing fragmentation)\n   receiving this packet will see\
    \ the Frag-Status attribute and will\n   postpone all authorization and authentication\
    \ handling until all of\n   the chunks have been received.  This postponement\
    \ also applies to the\n   verification that the Access-Request packet contains\
    \ some kind of\n   authentication attribute (e.g., User-Password, CHAP-Password,\
    \ State,\n   or other future attribute), as required by [RFC2865] (see\n   Section\
    \ 12.2 for more information on this).\n   Non-compliant RADIUS Servers (i.e.,\
    \ servers not implementing\n   fragmentation) should also see the Service-Type\
    \ requesting\n   provisioning for an unknown service and return Access-Reject.\
    \  Other\n   non-compliant RADIUS Servers may return an Access-Reject or\n   Access-Challenge,\
    \ or they may return an Access-Accept with a\n   particular Service-Type other\
    \ than Additional-Authorization.\n   Compliant RADIUS Client implementations MUST\
    \ treat these responses as\n   if they had received Access-Reject instead.\n \
    \  Compliant RADIUS Servers who wish to receive all of the chunks will\n   respond\
    \ with the following packet.  The value of the State here is\n   arbitrary and\
    \ serves only as a unique token for example purposes.  We\n   only note that it\
    \ MUST be temporally unique to the RADIUS Server.\n   Access-Accept (ID = 23)\n\
    \       Frag-Status = More-Data-Request\n       Service-Type = Additional-Authorization\n\
    \       State = 0xabc00001\n       Message-Authenticator\n                   \
    \  Figure 3: Access-Accept (Chunk 1)\n   The RADIUS Client will see this response\
    \ and use the RADIUS\n   Identifier field to associate it with an ongoing chunking\
    \ session.\n   Compliant RADIUS Clients will then continue the chunking process.\n\
    \   Non-compliant RADIUS Clients will never see a response such as this,\n   as\
    \ they will never send a Frag-Status attribute.  The Service-Type\n   attribute\
    \ is included in the Access-Accept in order to signal that\n   the response is\
    \ part of the chunking process.  This packet therefore\n   does not provision\
    \ any network service for the end user.\n   The RADIUS Client continues the process\
    \ by sending the next chunk,\n   which includes an additional six (6) attributes\
    \ from the original\n   packet.  It again includes the User-Name attribute, so\
    \ that\n   non-compliant proxies can process the packet (see Section 11.1).  It\n\
    \   sets the Frag-Status attribute to More-Data-Pending, as more data is\n   pending.\
    \  It includes a Service-Type, for the reasons described\n   above.  It includes\
    \ the State attribute from the previous\n   Access-Accept.  It signs the packet\
    \ with Message-Authenticator, as\n   there are no authentication attributes in\
    \ the packet.  It uses a new\n   RADIUS Identifier field.\n   Access-Request (ID\
    \ = 181)\n       User-Name\n       Example-Long-1 [M]\n       Example-Long-1 [M]\n\
    \       Example-Long-1 [M]\n       Example-Long-1\n       Example-Long-2 [M]\n\
    \       Example-Long-2 [MT]\n       Frag-Status = More-Data-Pending\n       Service-Type\
    \ = Additional-Authorization\n       State = 0xabc000001\n       Message-Authenticator\n\
    \                    Figure 4: Access-Request (Chunk 2)\n   Compliant RADIUS Servers\
    \ receiving this packet will see the\n   Frag-Status attribute and look for a\
    \ State attribute.  Since one\n   exists and it matches a State sent in an Access-Accept,\
    \ this packet\n   is part of a chunking process.  The RADIUS Server will associate\
    \ the\n   attributes with the previous chunk.  Since the Frag-Status attribute\n\
    \   has value More-Data-Request, the RADIUS Server will respond with an\n   Access-Accept\
    \ as before.  It MUST include a State attribute, with a\n   value different from\
    \ the previous Access-Accept.  This State MUST\n   again be globally and temporally\
    \ unique.\n   Access-Accept (ID = 181)\n       Frag-Status = More-Data-Request\n\
    \       Service-Type = Additional-Authorization\n       State = 0xdef00002\n \
    \      Message-Authenticator\n                     Figure 5: Access-Accept (Chunk\
    \ 2)\n   The RADIUS Client will see this response and use the RADIUS\n   Identifier\
    \ field to associate it with an ongoing chunking session.\n   The RADIUS Client\
    \ continues the chunking process by sending the next\n   chunk, with the final\
    \ attribute(s) from the original packet, and\n   again includes the original User-Name\
    \ attribute.  The Frag-Status\n   attribute is not included in the next Access-Request,\
    \ as no more\n   chunks are available for sending.  The RADIUS Client includes\
    \ the\n   State attribute from the previous Access-Accept.  It signs the packet\n\
    \   with Message-Authenticator, as there are no authentication attributes\n  \
    \ in the packet.  It again uses a new RADIUS Identifier field.\n   Access-Request\
    \ (ID = 241)\n       User-Name\n       Example-Long-2\n       State = 0xdef00002\n\
    \       Message-Authenticator\n                    Figure 6: Access-Request (Chunk\
    \ 3)\n   On reception of this last chunk, the RADIUS Server matches it with an\n\
    \   ongoing session via the State attribute and sees that there is no\n   Frag-Status\
    \ attribute present.  It then processes the received\n   attributes as if they\
    \ had been sent in one RADIUS packet.  See\n   Section 8.4 for further details\
    \ on this process.  It generates the\n   appropriate response, which can be either\
    \ Access-Accept or\n   Access-Reject.  In this example, we show an Access-Accept.\
    \  The\n   RADIUS Server MUST send a State attribute, which allows linking the\n\
    \   received data with the authentication process.\n   Access-Accept (ID = 241)\n\
    \       State = 0x98700003\n       Message-Authenticator\n                   \
    \  Figure 7: Access-Accept (Chunk 3)\n   The above example shows in practice how\
    \ the chunking process works.\n   We reiterate the implementation and security\
    \ requirements here.\n   Each chunk is a valid RADIUS packet (see Section 12.2\
    \ for some\n   considerations about this), and all RADIUS format and security\n\
    \   requirements MUST be followed before any chunking process is applied.\n  \
    \ Every chunk except for the last one from a RADIUS Client MUST include\n   a\
    \ Frag-Status attribute, with value More-Data-Pending.  The last\n   chunk MUST\
    \ NOT contain a Frag-Status attribute.  Each chunk except\n   for the last one\
    \ from a RADIUS Client MUST include a Service-Type\n   attribute, with value Additional-Authorization.\
    \  Each chunk MUST\n   include a User-Name attribute, which MUST be identical\
    \ in all chunks.\n   Each chunk except for the first one from a RADIUS Client\
    \ MUST include\n   a State attribute, which MUST be copied from a previous\n \
    \  Access-Accept.\n   Each Access-Accept MUST include a State attribute.  The\
    \ value for\n   this attribute MUST change in every new Access-Accept and MUST\
    \ be\n   globally and temporally unique.\n"
- title: 5.2.  Post-Authorization
  contents:
  - "5.2.  Post-Authorization\n   When the RADIUS Server wants to send a large amount\
    \ of authorization\n   data to the RADIUS Client after authentication, the operation\
    \ is very\n   similar to the pre-authorization process.  The presence of a\n \
    \  Service-Type = Additional-Authorization attribute ensures that a\n   RADIUS\
    \ Client not supporting this specification will treat that\n   unrecognized Service-Type\
    \ as though an Access-Reject had been\n   received instead ([RFC2865], Section\
    \ 5.6).  If the original large\n   Access-Accept packet contained a Service-Type\
    \ attribute, it will be\n   included with its original value in the last transmitted\
    \ chunk, to\n   avoid confusion with the one used for fragmentation signaling.\
    \  It is\n   RECOMMENDED that RADIUS Servers include a State attribute in their\n\
    \   original Access-Accept packets, even if fragmentation is not taking\n   place,\
    \ to allow the RADIUS Client to send additional authorization\n   data in subsequent\
    \ exchanges.  This State attribute would be included\n   in the last transmitted\
    \ chunk, to avoid confusion with the ones used\n   for fragmentation signaling.\n\
    \   Clients supporting this specification MUST include a Frag-Status =\n   Fragmentation-Supported\
    \ attribute in the first Access-Request sent to\n   the RADIUS Server, in order\
    \ to indicate that they would accept\n   fragmented data from the server.  This\
    \ is not required if the\n   pre-authorization process was carried out, as it\
    \ is implicit.\n   The following is an Access-Accept that the RADIUS Server intends\
    \ to\n   send to a RADIUS Client.  However, due to a combination of issues\n \
    \  (PMTU, large attributes, etc.), the content does not fit into one\n   Access-Accept\
    \ packet.\n   Access-Accept\n       User-Name\n       EAP-Message\n       Service-Type\
    \ = Login\n       Example-Long-1 [M]\n       Example-Long-1 [M]\n       Example-Long-1\
    \ [M]\n       Example-Long-1 [M]\n       Example-Long-1 [M]\n       Example-Long-1\
    \ [M]\n       Example-Long-1 [M]\n       Example-Long-1 [M]\n       Example-Long-1\n\
    \       Example-Long-2 [M]\n       Example-Long-2 [M]\n       Example-Long-2\n\
    \       State = 0xcba00003\n                      Figure 8: Desired Access-Accept\n\
    \   The RADIUS Server therefore must send the attributes listed above in\n   a\
    \ series of chunks.  The first chunk contains seven (7) attributes\n   from the\
    \ original Access-Accept, and a Frag-Status attribute.  Since\n   the last attribute\
    \ is \"Example-Long-1\" with the M flag set, the\n   chunking process also sets\
    \ the T flag in that attribute.  The\n   Access-Accept is sent with a RADIUS Identifier\
    \ field having value 30,\n   corresponding to a previous Access-Request not depicted.\
    \  The\n   Frag-Status attribute has value More-Data-Pending, to indicate that\n\
    \   the RADIUS Server wishes to send more data in a subsequent\n   Access-Accept.\
    \  The RADIUS Server also adds a Service-Type attribute\n   with value Additional-Authorization,\
    \ which indicates that it is part\n   of the chunking process.  Note that the\
    \ original Service-Type is not\n   included in this chunk.  Finally, a State attribute\
    \ is included to\n   allow matching subsequent requests with this conversation,\
    \ and the\n   packet is signed with the Message-Authenticator attribute, completing\n\
    \   the maximum number of attributes (11).\n   Access-Accept (ID = 30)\n     \
    \  User-Name\n       EAP-Message\n       Example-Long-1 [M]\n       Example-Long-1\
    \ [M]\n       Example-Long-1 [M]\n       Example-Long-1 [M]\n       Example-Long-1\
    \ [MT]\n       Frag-Status = More-Data-Pending\n       Service-Type = Additional-Authorization\n\
    \       State = 0xcba00004\n       Message-Authenticator\n                   \
    \  Figure 9: Access-Accept (Chunk 1)\n   Compliant RADIUS Clients receiving this\
    \ packet will see the\n   Frag-Status attribute and suspend all authorization\
    \ handling until\n   all of the chunks have been received.  Non-compliant RADIUS\
    \ Clients\n   should also see the Service-Type indicating the provisioning for\
    \ an\n   unknown service and will treat it as an Access-Reject.\n   RADIUS Clients\
    \ who wish to receive all of the chunks will respond\n   with the following packet,\
    \ where the value of the State attribute is\n   taken from the received Access-Accept.\
    \  They will also include the\n   User-Name attribute so that non-compliant proxies\
    \ can process the\n   packet (Section 11.1).\n   Access-Request (ID = 131)\n \
    \      User-Name\n       Frag-Status = More-Data-Request\n       Service-Type\
    \ = Additional-Authorization\n       State = 0xcba00004\n       Message-Authenticator\n\
    \                    Figure 10: Access-Request (Chunk 1)\n   The RADIUS Server\
    \ receives this request and uses the State attribute\n   to associate it with\
    \ an ongoing chunking session.  Compliant RADIUS\n   Servers will then continue\
    \ the chunking process.  Non-compliant\n   RADIUS Servers will never see a response\
    \ such as this, as they will\n   never send a Frag-Status attribute.\n   The RADIUS\
    \ Server continues the chunking process by sending the next\n   chunk, with the\
    \ final attribute(s) from the original packet.  The\n   value of the Identifier\
    \ field is taken from the received\n   Access-Request.  A Frag-Status attribute\
    \ is not included in the next\n   Access-Accept, as no more chunks are available\
    \ for sending.  The\n   RADIUS Server includes the original State attribute to\
    \ allow the\n   RADIUS Client to send additional authorization data.  The original\n\
    \   Service-Type attribute is included as well.\n   Access-Accept (ID = 131)\n\
    \       Example-Long-1 [M]\n       Example-Long-1 [M]\n       Example-Long-1 [M]\n\
    \       Example-Long-1\n       Example-Long-2 [M]\n       Example-Long-2 [M]\n\
    \       Example-Long-2\n       Service-Type = Login\n       State = 0xfda000003\n\
    \       Message-Authenticator\n                    Figure 11: Access-Accept (Chunk\
    \ 2)\n   On reception of this last chunk, the RADIUS Client matches it with an\n\
    \   ongoing session via the Identifier field and sees that there is no\n   Frag-Status\
    \ attribute present.  It then processes the received\n   attributes as if they\
    \ had been sent in one RADIUS packet.  See\n   Section 8.4 for further details\
    \ on this process.\n"
- title: 6.  Chunk Size
  contents:
  - "6.  Chunk Size\n   In an ideal scenario, each intermediate chunk would be exactly\
    \ the\n   size limit in length.  In this way, the number of round trips\n   required\
    \ to send a large packet would be optimal.  However, this is\n   not possible\
    \ for several reasons.\n   1.  RADIUS attributes have a variable length and must\
    \ be included\n       completely in a chunk.  Thus, it is possible that, even\
    \ if there\n       is some free space in the chunk, it is not enough to include\
    \ the\n       next attribute.  This can generate up to 254 bytes of spare space\n\
    \       in every chunk.\n   2.  RADIUS fragmentation requires the introduction\
    \ of some extra\n       attributes for signaling.  Specifically, a Frag-Status\
    \ attribute\n       (7 bytes) is included in every chunk of a packet, except the\
    \ last\n       one.  A RADIUS State attribute (from 3 to 255 bytes) is also\n\
    \       included in most chunks, to allow the RADIUS Server to bind an\n     \
    \  Access-Request with a previous Access-Challenge.  User-Name\n       attributes\
    \ (from 3 to 255 bytes) are included in every chunk the\n       RADIUS Client\
    \ sends, as they are required by the proxies to route\n       the packet to its\
    \ destination.  Together, these attributes can\n       generate from up to 13\
    \ to 517 bytes of signaling data, reducing\n       the amount of payload information\
    \ that can be sent in each chunk.\n   3.  RADIUS packets SHOULD be adjusted to\
    \ avoid exceeding the network\n       MTU.  Otherwise, IP fragmentation may occur,\
    \ with undesirable\n       consequences.  Hence, maximum chunk size would be decreased\
    \ from\n       4096 to the actual MTU of the network.\n   4.  The inclusion of\
    \ Proxy-State attributes by intermediary proxies\n       can decrease the availability\
    \ of usable space in the chunk.  This\n       is described in further detail in\
    \ Section 8.1.\n"
- title: 7.  Allowed Large Packet Size
  contents:
  - "7.  Allowed Large Packet Size\n   There are no provisions for signaling how much\
    \ data is to be sent via\n   the fragmentation process as a whole.  It is difficult\
    \ to define what\n   is meant by the \"length\" of any fragmented data.  That\
    \ data can be\n   multiple attributes and can include RADIUS attribute header\
    \ fields,\n   or it can be one or more \"large\" attributes (more than 256 bytes\
    \ in\n   length).  Proxies can also filter these attributes, to modify, add,\n\
    \   or delete them and their contents.  These proxies act on a \"packet by\n \
    \  packet\" basis and cannot know what kind of filtering actions they\n   will\
    \ take on future packets.  As a result, it is impossible to signal\n   any meaningful\
    \ value for the total amount of additional data.\n   Unauthenticated end users\
    \ are permitted to trigger the exchange of\n   large amounts of fragmented data\
    \ between the RADIUS Client and the\n   RADIUS Server, having the potential to\
    \ allow denial-of-service (DoS)\n   attacks.  An attacker could initiate a large\
    \ number of connections,\n   each of which requests the RADIUS Server to store\
    \ a large amount of\n   data.  This data could cause memory exhaustion on the\
    \ RADIUS Server\n   and result in authentic users being denied access.  It is\
    \ worth\n   noting that authentication mechanisms are already designed to avoid\n\
    \   exceeding the size limit.\n   Hence, implementations of this specification\
    \ MUST limit the total\n   amount of data they send and/or receive via this specification.\
    \  Its\n   default value SHOULD be 100 kilobytes.  Any more than this may turn\n\
    \   RADIUS into a generic transport protocol, which is undesirable.  This\n  \
    \ limit SHOULD be configurable, so that it can be changed if necessary.\n   Implementations\
    \ of this specification MUST limit the total number of\n   round trips used during\
    \ the fragmentation process.  Its default value\n   SHOULD be 25.  Any more than\
    \ this may indicate an implementation\n   error, misconfiguration, or DoS attack.\
    \  This limit SHOULD be\n   configurable, so that it can be changed if necessary.\n\
    \   For instance, let's imagine that the RADIUS Server wants to transport\n  \
    \ a SAML assertion that is 15000 bytes long to the RADIUS Client.  In\n   this\
    \ hypothetical scenario, we assume that there are three\n   intermediate proxies,\
    \ each one inserting a Proxy-State attribute of\n   20 bytes.  Also, we assume\
    \ that the State attributes generated by the\n   RADIUS Server have a size of\
    \ 6 bytes and the User-Name attribute\n   takes 50 bytes.  Therefore, the amount\
    \ of free space in a chunk for\n   the transport of the SAML assertion attributes\
    \ is as follows:\n   Total (4096 bytes) - RADIUS header (20 bytes) - User-Name\
    \ (50 bytes)\n   - Frag-Status (7 bytes) - Service-Type (6 bytes) - State (6 bytes)\
    \ -\n   Proxy-State (20 bytes) - Proxy-State (20 bytes) - Proxy-State\n   (20\
    \ bytes) - Message-Authenticator (18 bytes), resulting in a total\n   of 3929\
    \ bytes.  This amount of free space allows the transmission of\n   up to 15 attributes\
    \ of 255 bytes each.\n   According to [RFC6929], a Long-Extended-Type provides\
    \ a payload of\n   251 bytes.  Therefore, the SAML assertion described above would\n\
    \   result in 60 attributes, requiring four round trips to be completely\n   transmitted.\n"
- title: 8.  Handling Special Attributes
  contents:
  - '8.  Handling Special Attributes

    '
- title: 8.1.  Proxy-State Attribute
  contents:
  - "8.1.  Proxy-State Attribute\n   RADIUS proxies may introduce Proxy-State attributes\
    \ into any\n   Access-Request packet they forward.  If they are unable to add\
    \ this\n   information to the packet, they may silently discard it rather than\n\
    \   forward it to its destination; this would lead to DoS situations.\n   Moreover,\
    \ any Proxy-State attribute received by a RADIUS Server in an\n   Access-Request\
    \ packet MUST be copied into the corresponding reply\n   packet.  For these reasons,\
    \ Proxy-State attributes require special\n   treatment within the packet fragmentation\
    \ mechanism.\n   When the RADIUS Server replies to an Access-Request packet as\
    \ part of\n   a conversation involving a fragmentation (either a chunk or a request\n\
    \   for chunks), it MUST include every Proxy-State attribute received in\n   the\
    \ reply packet.  This means that the RADIUS Server MUST take into\n   account\
    \ the size of these Proxy-State attributes in order to\n   calculate the size\
    \ of the next chunk to be sent.\n   However, while a RADIUS Server will always\
    \ know how much space MUST\n   be left in each reply packet for Proxy-State attributes\
    \ (as they are\n   directly included by the RADIUS Server), a RADIUS Client cannot\
    \ know\n   this information, as Proxy-State attributes are removed from the\n\
    \   reply packet by their respective proxies before forwarding them back.\n  \
    \ Hence, RADIUS Clients need a mechanism to discover the amount of\n   space required\
    \ by proxies to introduce their Proxy-State attributes.\n   In the following paragraphs,\
    \ we describe a new mechanism to perform\n   such a discovery:\n   1.  When a\
    \ RADIUS Client does not know how much space will be\n       required by intermediate\
    \ proxies for including their Proxy-State\n       attributes, it SHOULD start\
    \ using a conservative value (e.g.,\n       1024 bytes) as the chunk size.\n \
    \  2.  When the RADIUS Server receives a chunk from the RADIUS Client,\n     \
    \  it can calculate the total size of the Proxy-State attributes\n       that\
    \ have been introduced by intermediary proxies along the path.\n       This information\
    \ MUST be returned to the RADIUS Client in the\n       next reply packet, encoded\
    \ into a new attribute called\n       Proxy-State-Length.  The RADIUS Server MAY\
    \ artificially increase\n       this quantity in order to handle situations where\
    \ proxies behave\n       inconsistently (e.g., they generate Proxy-State attributes\
    \ with a\n       different size for each packet) or where intermediary proxies\n\
    \       remove Proxy-State attributes generated by other proxies.\n       Increasing\
    \ this value would make the RADIUS Client leave some\n       free space for these\
    \ situations.\n   3.  The RADIUS Client SHOULD respond to the reception of this\n\
    \       attribute by adjusting the maximum size for the next chunk\n       accordingly.\
    \  However, as the Proxy-State-Length offers just an\n       estimation of the\
    \ space required by the proxies, the RADIUS\n       Client MAY select a smaller\
    \ amount in environments known to be\n       problematic.\n"
- title: 8.2.  State Attribute
  contents:
  - "8.2.  State Attribute\n   This RADIUS fragmentation mechanism makes use of the\
    \ State attribute\n   to link all the chunks belonging to the same fragmented\
    \ packet.\n   However, some considerations are required when the RADIUS Server\
    \ is\n   fragmenting a packet that already contains a State attribute for\n  \
    \ other purposes not related to the fragmentation.  If the procedure\n   described\
    \ in Section 5 is followed, two different State attributes\n   could be included\
    \ in a single chunk.  This is something explicitly\n   forbidden in [RFC2865].\n\
    \   A straightforward solution consists of making the RADIUS Server send\n   the\
    \ original State attribute in the last chunk of the sequence\n   (attributes can\
    \ be reordered as specified in [RFC2865]).  As the last\n   chunk (when generated\
    \ by the RADIUS Server) does not contain any\n   State attribute due to the fragmentation\
    \ mechanism, both situations\n   described above are avoided.\n   Something similar\
    \ happens when the RADIUS Client has to send a\n   fragmented packet that contains\
    \ a State attribute in it.  The RADIUS\n   Client MUST ensure that this original\
    \ State is included in the first\n   chunk sent to the RADIUS Server (as this\
    \ one never contains any State\n   attribute due to fragmentation).\n"
- title: 8.3.  Service-Type Attribute
  contents:
  - "8.3.  Service-Type Attribute\n   This RADIUS fragmentation mechanism makes use\
    \ of the Service-Type\n   attribute to indicate that an Access-Accept packet is\
    \ not granting\n   access to the service yet, since an additional authorization\
    \ exchange\n   needs to be performed.  Similarly to the State attribute, the RADIUS\n\
    \   Server has to send the original Service-Type attribute in the last\n   Access-Accept\
    \ of the RADIUS conversation to avoid ambiguity.\n"
- title: 8.4.  Rebuilding the Original Large Packet
  contents:
  - "8.4.  Rebuilding the Original Large Packet\n   The RADIUS Client stores the RADIUS\
    \ attributes received in each chunk\n   in a list, in order to be able to rebuild\
    \ the original large packet\n   after receiving the last chunk.  However, some\
    \ of these received\n   attributes MUST NOT be stored in that list, as they have\
    \ been\n   introduced as part of the fragmentation signaling and hence are not\n\
    \   part of the original packet.\n   o  State (except the one in the last chunk,\
    \ if present)\n   o  Service-Type = Additional-Authorization\n   o  Frag-Status\n\
    \   o  Proxy-State-Length\n   Similarly, the RADIUS Server MUST NOT store the\
    \ following attributes\n   as part of the original large packet:\n   o  State\
    \ (except the one in the first chunk, if present)\n   o  Service-Type = Additional-Authorization\n\
    \   o  Frag-Status\n   o  Proxy-State (except the ones in the last chunk)\n  \
    \ o  User-Name (except the one in the first chunk)\n"
- title: 9.  New T Flag for the Long Extended Type Attribute Definition
  contents:
  - "9.  New T Flag for the Long Extended Type Attribute Definition\n   This document\
    \ defines a new field in the Long Extended Type attribute\n   format.  This field\
    \ is one bit in size and is called \"T\" for\n   Truncation.  It indicates that\
    \ the attribute is intentionally\n   truncated in this chunk and is to be continued\
    \ in the next chunk of\n   the sequence.  The combination of the M flag and the\
    \ T flag indicates\n   that the attribute is fragmented (M flag) but that all\
    \ the fragments\n   are not available in this chunk (T flag).  Proxies implementing\n\
    \   [RFC6929] will see these attributes as invalid (they will not be able\n  \
    \ to reconstruct them), but they will still forward them, as\n   Section 5.2 of\
    \ [RFC6929] indicates that they SHOULD forward unknown\n   attributes anyway.\n\
    \   As a consequence of this addition, the Reserved field is now 6 bits\n   long\
    \ (see Section 12.1 for some considerations).  The following\n   figure represents\
    \ the new attribute format:\n       0                   1                   2\
    \                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Type      |    Length     | Extended-Type |M|T| Reserved  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \     Value ...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure 12: Updated Long Extended Type Attribute Format\n"
- title: 10.  New Attribute Definition
  contents:
  - "10.  New Attribute Definition\n   This document proposes the definition of two\
    \ new extended type\n   attributes, called Frag-Status and Proxy-State-Length.\
    \  The format of\n   these attributes follows the indications for an Extended\
    \ Type\n   attribute defined in [RFC6929].\n"
- title: 10.1.  Frag-Status Attribute
  contents:
  - "10.1.  Frag-Status Attribute\n   This attribute is used for fragmentation signaling,\
    \ and its meaning\n   depends on the code value transported within it.  The following\n\
    \   figure represents the format of the Frag-Status attribute:\n       0     \
    \              1                   2                   3\n       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type        |    Length     | Extended-Type |     Code\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        Code (cont)                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 13: Frag-Status Format\n   Type\n      241\n  \
    \ Length\n      7\n   Extended-Type\n      1\n   Code\n      4 bytes.  Integer\
    \ indicating the code.  The values defined in this\n      specification are:\n\
    \         0 - Reserved\n         1 - Fragmentation-Supported\n         2 - More-Data-Pending\n\
    \         3 - More-Data-Request\n   This attribute MAY be present in Access-Request,\
    \ Access-Challenge,\n   and Access-Accept packets.  It MUST NOT be included in\
    \ Access-Reject\n   packets.  RADIUS Clients supporting this specification MUST\
    \ include a\n   Frag-Status = Fragmentation-Supported attribute in the first\n\
    \   Access-Request sent to the RADIUS Server, in order to indicate that\n   they\
    \ would accept fragmented data from the server.\n"
- title: 10.2.  Proxy-State-Length Attribute
  contents:
  - "10.2.  Proxy-State-Length Attribute\n   This attribute indicates to the RADIUS\
    \ Client the length of the\n   Proxy-State attributes received by the RADIUS Server.\
    \  This\n   information is useful for adjusting the length of the chunks sent\
    \ by\n   the RADIUS Client.  The format of this Proxy-State-Length attribute\n\
    \   is as follows:\n       0                   1                   2         \
    \          3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type        |    Length     | Extended-Type |     Value\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Value (cont)                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 14: Proxy-State-Length Format\n   Type\n      241\n\
    \   Length\n      7\n   Extended-Type\n      2\n   Value\n      4 bytes.  Total\
    \ length (in bytes) of received Proxy-State\n      attributes (including headers).\
    \  As the RADIUS Length field cannot\n      take values over 4096 bytes, values\
    \ of Proxy-State-Length MUST be\n      less than that maximum length.\n   This\
    \ attribute MAY be present in Access-Challenge and Access-Accept\n   packets.\
    \  It MUST NOT be included in Access-Request or Access-Reject\n   packets.\n"
- title: 10.3.  Table of Attributes
  contents:
  - "10.3.  Table of Attributes\n   The following table shows the different attributes\
    \ defined in this\n   document, along with the types of RADIUS packets in which\
    \ they can be\n   present.\n                            |     Type of Packet \
    \   |\n                            +-----+-----+-----+-----+\n      Attribute\
    \ Name        | Req | Acc | Rej | Cha |\n      ----------------------+-----+-----+-----+-----+\n\
    \      Frag-Status           | 0-1 | 0-1 |  0  | 0-1 |\n      ----------------------+-----+-----+-----+-----+\n\
    \      Proxy-State-Length    | 0   | 0-1 |  0  | 0-1 |\n      ----------------------+-----+-----+-----+-----+\n"
- title: 11.  Operation with Proxies
  contents:
  - "11.  Operation with Proxies\n   The fragmentation mechanism defined above is\
    \ designed to be\n   transparent to legacy proxies, as long as they do not want\
    \ to modify\n   any fragmented attribute.  Nevertheless, updated proxies supporting\n\
    \   this specification can even modify fragmented attributes.\n"
- title: 11.1.  Legacy Proxies
  contents:
  - "11.1.  Legacy Proxies\n   As every chunk is indeed a RADIUS packet, legacy proxies\
    \ treat them\n   as they would the rest of the packets, routing them to their\n\
    \   destination.  Proxies can introduce Proxy-State attributes into\n   Access-Request\
    \ packets, even if they are indeed chunks.  This will\n   not affect how fragmentation\
    \ is managed.  The RADIUS Server will\n   include all the received Proxy-State\
    \ attributes in the generated\n   response, as described in [RFC2865].  Hence,\
    \ proxies do not\n   distinguish between a regular RADIUS packet and a chunk.\n"
- title: 11.2.  Updated Proxies
  contents:
  - "11.2.  Updated Proxies\n   Updated proxies can interact with RADIUS Clients and\
    \ Servers in order\n   to obtain the complete large packet before starting to\
    \ forward it.\n   In this way, proxies can manipulate (modify and/or remove) any\n\
    \   attribute of the packet or introduce new attributes, without worrying\n  \
    \ about crossing the boundaries of the chunk size.  Once the\n   manipulated packet\
    \ is ready, it is sent to the original destination\n   using the fragmentation\
    \ mechanism (if required).  The example in\n   Figure 15 shows how an updated\
    \ proxy interacts with the RADIUS Client\n   to (1) obtain a large Access-Request\
    \ packet and (2) modify an\n   attribute, resulting in an even larger packet.\
    \  The proxy then\n   interacts with the RADIUS Server to complete the transmission\
    \ of the\n   modified packet, as shown in Figure 16.\n     +-+-+-+-+-+       \
    \                                   +-+-+-+-+-+\n     | RADIUS  |            \
    \                              | RADIUS  |\n     | Client  |                 \
    \                         | Proxy   |\n     +-+-+-+-+-+                      \
    \                    +-+-+-+-+-+\n         |                                 \
    \                   |\n         | Access-Request(1){User-Name,Calling-Station-Id,\
    \    |\n         |        Example-Long-1[M],Example-Long-1[M],        |\n    \
    \     |        Example-Long-1[M],Example-Long-1[M],        |\n         |     \
    \   Example-Long-1[MT],Frag-Status(MDP)}        |\n         |--------------------------------------------------->|\n\
    \         |                                                    |\n         | \
    \                    Access-Challenge(1){User-Name, |\n         |            \
    \               Frag-Status(MDR),State1} |\n         |<---------------------------------------------------|\n\
    \         |                                                    |\n         | Access-Request(2){User-Name,State1,\
    \                |\n         |        Example-Long-1[M],Example-Long-1[M],   \
    \     |\n         |        Example-Long-1[M],Example-Long-1}           |\n   \
    \      |--------------------------------------------------->|\n              Proxy\
    \ Modifies Attribute Data, Increasing Its\n                 Size from 9 Fragments\
    \ to 11 Fragments\n           Figure 15: Updated Proxy Interacts with RADIUS Client\n\
    \     +-+-+-+-+-+                                          +-+-+-+-+-+\n     |\
    \ RADIUS  |                                          | RADIUS  |\n     | Proxy\
    \   |                                          | Server  |\n     +-+-+-+-+-+ \
    \                                         +-+-+-+-+-+\n         |            \
    \                                        |\n         | Access-Request(3){User-Name,Calling-Station-Id,\
    \    |\n         |        Example-Long-1[M],Example-Long-1[M],        |\n    \
    \     |        Example-Long-1[M],Example-Long-1[M],        |\n         |     \
    \   Example-Long-1[MT],Frag-Status(MDP)}        |\n         |--------------------------------------------------->|\n\
    \         |                                                    |\n         | \
    \                    Access-Challenge(1){User-Name, |\n         |            \
    \               Frag-Status(MDR),State2} |\n         |<---------------------------------------------------|\n\
    \         |                                                    |\n         | Access-Request(4){User-Name,State2,\
    \                |\n         |        Example-Long-1[M],Example-Long-1[M],   \
    \     |\n         |        Example-Long-1[M],Example-Long-1[M],        |\n   \
    \      |        Example-Long-1[MT],Frag-Status(MDP)}        |\n         |--------------------------------------------------->|\n\
    \         |                                                    |\n         | \
    \                    Access-Challenge(1){User-Name, |\n         |            \
    \               Frag-Status(MDR),State3} |\n         |<---------------------------------------------------|\n\
    \         |                                                    |\n         | Access-Request(5){User-Name,State3,Example-Long-1}\
    \ |\n         |--------------------------------------------------->|\n       \
    \    Figure 16: Updated Proxy Interacts with RADIUS Server\n"
- title: 12.  General Considerations
  contents:
  - '12.  General Considerations

    '
- title: 12.1.  T Flag
  contents:
  - "12.1.  T Flag\n   As described in Section 9, this document modifies the definition\
    \ of\n   the Reserved field of the Long Extended Type attribute [RFC6929] by\n\
    \   allocating an additional flag called the T flag.  The meaning and\n   position\
    \ of this flag are defined in this document, and nowhere else.\n   This might\
    \ cause an issue if subsequent specifications want to\n   allocate a new flag\
    \ as well, as there would be no direct way for them\n   to know which parts of\
    \ the Reserved field have already been defined.\n   An immediate and reasonable\
    \ solution for this issue would be\n   declaring that this RFC updates [RFC6929].\
    \  In this way, [RFC6929]\n   would include an \"Updated by\" clause that will\
    \ point readers to this\n   document.  Another alternative would be creating an\
    \ IANA registry for\n   the Reserved field.  However, the RADIUS Extensions (RADEXT)\
    \ working\n   group thinks that would be overkill, as a large number of\n   specifications\
    \ extending that field are not expected.\n   In the end, the proposed solution\
    \ is that this experimental RFC\n   should not update RFC 6929.  Instead, we rely\
    \ on the collective mind\n   of the working group to remember that this T flag\
    \ is being used as\n   specified by this Experimental document.  If the experiment\
    \ is\n   successful, the T flag will be properly assigned.\n"
- title: 12.2.  Violation of RFC 2865
  contents:
  - "12.2.  Violation of RFC 2865\n   Section 5.1 indicates that all authorization\
    \ and authentication\n   handling will be postponed until all the chunks have\
    \ been received.\n   This postponement also applies to the verification that the\n\
    \   Access-Request packet contains some kind of authentication attribute\n   (e.g.,\
    \ User-Password, CHAP-Password, State, or other future\n   attribute), as required\
    \ by [RFC2865].  This checking will therefore\n   be delayed until the original\
    \ large packet has been rebuilt, as some\n   of the chunks may not contain any\
    \ of them.\n   The authors acknowledge that this specification violates the \"\
    MUST\"\n   requirement of [RFC2865], Section 4.1 that states that \"An\n   Access-Request\
    \ MUST contain either a User-Password or a CHAP-Password\n   or a State.\"  We\
    \ note that a proxy that enforces that requirement\n   would be unable to support\
    \ future RADIUS authentication extensions.\n   Extensions to the protocol would\
    \ therefore be impossible to deploy.\n   All known implementations have chosen\
    \ the philosophy of \"be liberal\n   in what you accept.\"  That is, they accept\
    \ traffic that violates the\n   requirement of [RFC2865], Section 4.1.  We therefore\
    \ expect to see no\n   operational issues with this specification.  After we gain\
    \ more\n   operational experience with this specification, it can be reissued\
    \ as\n   a Standards Track document and can update [RFC2865].\n"
- title: 12.3.  Proxying Based on User-Name
  contents:
  - "12.3.  Proxying Based on User-Name\n   This proposal assumes that legacy proxies\
    \ base their routing\n   decisions on the value of the User-Name attribute.  For\
    \ this reason,\n   every packet sent from the RADIUS Client to the RADIUS Server\
    \ (either\n   chunks or requests for more chunks) MUST contain a User-Name\n \
    \  attribute.\n"
- title: 12.4.  Transport Behavior
  contents:
  - "12.4.  Transport Behavior\n   This proposal does not modify the way RADIUS interacts\
    \ with the\n   underlying transport (UDP).  That is, RADIUS keeps following a\n\
    \   lock-step behavior that requires receiving an explicit\n   acknowledgement\
    \ for each chunk sent.  Hence, bursts of traffic\n   that could congest links\
    \ between peers are not an issue.\n   Another benefit of the lock-step nature\
    \ of RADIUS is that there are\n   no security issues with overlapping fragments.\
    \  Each chunk simply has\n   a length, with no Fragment Offset field as with IPv4.\
    \  The order of\n   the fragments is determined by the order in which they are\
    \ received.\n   There is no ambiguity about the size or placement of each chunk,\
    \ and\n   therefore no security issues associated with overlapping chunks.\n"
- title: 13.  Security Considerations
  contents:
  - "13.  Security Considerations\n   As noted in many earlier specifications ([RFC5080],\
    \ [RFC6158], etc.),\n   RADIUS security is problematic.  This specification changes\
    \ nothing\n   related to the security of the RADIUS protocol.  It requires that\
    \ all\n   Access-Request packets associated with fragmentation are\n   authenticated\
    \ using the existing Message-Authenticator attribute.\n   This signature prevents\
    \ forging and replay, to the limits of the\n   existing security.\n   The ability\
    \ to send bulk data from one party to another creates new\n   security considerations.\
    \  RADIUS Clients and Servers may have to\n   store large amounts of data per\
    \ session.  The amount of this data can\n   be significant, leading to the potential\
    \ for resource exhaustion.  We\n   therefore suggest that implementations limit\
    \ the amount of bulk data\n   stored per session.  The exact method for this limitation\
    \ is\n   implementation-specific.  Section 7 gives some indications of what\n\
    \   could be reasonable limits.\n   The bulk data can often be pushed off to storage\
    \ methods other than\n   the memory of the RADIUS implementation.  For example,\
    \ it can be\n   stored in an external database or in files.  This approach mitigates\n\
    \   the resource exhaustion issue, as RADIUS Servers today already store\n   large\
    \ amounts of accounting data.\n"
- title: 14.  IANA Considerations
  contents:
  - "14.  IANA Considerations\n   The Internet Assigned Numbers Authority (IANA) has\
    \ registered the\n   Attribute Types and Attribute Values defined in this document\
    \ in the\n   RADIUS namespaces as described in the \"IANA Considerations\" section\n\
    \   of [RFC3575], in accordance with BCP 26 [RFC5226].  For RADIUS\n   packets,\
    \ attributes, and registries created by this document, IANA\n   has updated <http://www.iana.org/assignments/radius-types>\n\
    \   accordingly.\n   In particular, this document defines two new RADIUS attributes,\n\
    \   entitled \"Frag-Status\" (value 241.1) and \"Proxy-State-Length\"\n   (value\
    \ 241.2), which have been allocated from the short extended\n   space as described\
    \ in [RFC6929]:\n   Type     Name                 Length  Meaning\n   ----   \
    \  ----                 ------  -------\n   241.1    Frag-Status          7  \
    \     Signals fragmentation\n   241.2    Proxy-State-Length   7       Indicates\
    \ the length of the\n                                         received Proxy-State\
    \ attributes\n   The Frag-Status attribute also defines an 8-bit \"Code\" field,\
    \ for\n   which IANA has created and now maintains a new sub-registry entitled\n\
    \   \"Code Values for RADIUS Attribute 241.1, Frag-Status\".  Initial\n   values\
    \ for the RADIUS Frag-Status \"Code\" registry are given below;\n   future assignments\
    \ are to be made through \"RFC Required\" [RFC5226].\n   Assignments consist of\
    \ a Frag-Status \"Code\" name and its associated\n   value.\n         Value  \
    \  Frag-Status Code Name           Definition\n         ----     ------------------------\
    \        ----------\n         0        Reserved                        See Section\
    \ 10.1\n         1        Fragmentation-Supported         See Section 10.1\n \
    \        2        More-Data-Pending               See Section 10.1\n         3\
    \        More-Data-Request               See Section 10.1\n         4-255    Unassigned\n\
    \   Additionally, IANA has allocated a new Service-Type value for\n   \"Additional-Authorization\"\
    .\n         Value    Service Type Value              Definition\n         ----\
    \     ------------------------        ----------\n         19       Additional-Authorization\
    \        See Section 5.1\n"
- title: 15.  References
  contents:
  - '15.  References

    '
- title: 15.1.  Normative References
  contents:
  - "15.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC2865]\
    \  Rigney, C., Willens, S., Rubens, A., and W. Simpson,\n              \"Remote\
    \ Authentication Dial In User Service (RADIUS)\",\n              RFC 2865, June\
    \ 2000, <http://www.rfc-editor.org/\n              info/rfc2865>.\n   [RFC3575]\
    \  Aboba, B., \"IANA Considerations for RADIUS (Remote\n              Authentication\
    \ Dial In User Service)\", RFC 3575,\n              July 2003, <http://www.rfc-editor.org/info/rfc3575>.\n\
    \   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n   \
    \           IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n       \
    \       May 2008, <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC6158]  DeKok,\
    \ A., Ed., and G. Weber, \"RADIUS Design Guidelines\",\n              BCP 158,\
    \ RFC 6158, March 2011,\n              <http://www.rfc-editor.org/info/rfc6158>.\n\
    \   [RFC6929]  DeKok, A. and A. Lior, \"Remote Authentication Dial In User\n \
    \             Service (RADIUS) Protocol Extensions\", RFC 6929,\n            \
    \  April 2013, <http://www.rfc-editor.org/info/rfc6929>.\n"
- title: 15.2.  Informative References
  contents:
  - "15.2.  Informative References\n   [ABFAB-Arch]\n              Howlett, J., Hartman,\
    \ S., Tschofenig, H., Lear, E., and J.\n              Schaad, \"Application Bridging\
    \ for Federated Access Beyond\n              Web (ABFAB) Architecture\", Work\
    \ in Progress,\n              draft-ietf-abfab-arch-13, July 2014.\n   [RADIUS-Larger-Pkts]\n\
    \              Hartman, S., \"Larger Packets for RADIUS over TCP\", Work in\n\
    \              Progress, draft-ietf-radext-bigger-packets-03, March 2015.\n  \
    \ [RFC2866]  Rigney, C., \"RADIUS Accounting\", RFC 2866, June 2000,\n       \
    \       <http://www.rfc-editor.org/info/rfc2866>.\n   [RFC3579]  Aboba, B. and\
    \ P. Calhoun, \"RADIUS (Remote Authentication\n              Dial In User Service)\
    \ Support For Extensible\n              Authentication Protocol (EAP)\", RFC 3579,\
    \ September 2003,\n              <http://www.rfc-editor.org/info/rfc3579>.\n \
    \  [RFC4849]  Congdon, P., Sanchez, M., and B. Aboba, \"RADIUS Filter\n      \
    \        Rule Attribute\", RFC 4849, April 2007,\n              <http://www.rfc-editor.org/info/rfc4849>.\n\
    \   [RFC5080]  Nelson, D. and A. DeKok, \"Common Remote Authentication\n     \
    \         Dial In User Service (RADIUS) Implementation Issues and\n          \
    \    Suggested Fixes\", RFC 5080, December 2007,\n              <http://www.rfc-editor.org/info/rfc5080>.\n\
    \   [RFC5176]  Chiba, M., Dommety, G., Eklund, M., Mitton, D., and B.\n      \
    \        Aboba, \"Dynamic Authorization Extensions to Remote\n              Authentication\
    \ Dial In User Service (RADIUS)\", RFC 5176,\n              January 2008, <http://www.rfc-editor.org/info/rfc5176>.\n\
    \   [SAML-RADIUS]\n              Howlett, J., Hartman, S., and A. Perez-Mendez,\
    \ Ed., \"A\n              RADIUS Attribute, Binding, Profiles, Name Identifier\n\
    \              Format, and Confirmation Methods for SAML\", Work in\n        \
    \      Progress, draft-ietf-abfab-aaa-saml-10, February 2015.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to thank the members of the RADEXT\
    \ working\n   group who have contributed to the development of this specification\n\
    \   by either participating in the discussions on the mailing lists or\n   sending\
    \ comments about our RFC.\n   The authors also thank David Cuenca (University\
    \ of Murcia) for\n   implementing a proof-of-concept implementation of this RFC\
    \ that has\n   been useful to improve the quality of the specification.\n   This\
    \ work has been partly funded by the GEANT GN3+ SA5 and CLASSe\n   (<http://www.um.es/classe/>)\
    \ projects.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Alejandro Perez-Mendez (editor)\n   University of Murcia\n\
    \   Campus de Espinardo S/N, Faculty of Computer Science\n   Murcia  30100\n \
    \  Spain\n   Phone: +34 868 88 46 44\n   EMail: alex@um.es\n   Rafa Marin-Lopez\n\
    \   University of Murcia\n   Campus de Espinardo S/N, Faculty of Computer Science\n\
    \   Murcia  30100\n   Spain\n   Phone: +34 868 88 85 01\n   EMail: rafa@um.es\n\
    \   Fernando Pereniguez-Garcia\n   University of Murcia\n   Campus de Espinardo\
    \ S/N, Faculty of Computer Science\n   Murcia  30100\n   Spain\n   Phone: +34\
    \ 868 88 78 82\n   EMail: pereniguez@um.es\n   Gabriel Lopez-Millan\n   University\
    \ of Murcia\n   Campus de Espinardo S/N, Faculty of Computer Science\n   Murcia\
    \  30100\n   Spain\n   Phone: +34 868 88 85 04\n   EMail: gabilm@um.es\n   Diego\
    \ R. Lopez\n   Telefonica I+D\n   Don Ramon de la Cruz, 84\n   Madrid  28006\n\
    \   Spain\n   Phone: +34 913 129 041\n   EMail: diego@tid.es\n   Alan DeKok\n\
    \   Network RADIUS SARL\n   57bis Boulevard des Alpes\n   Meylan  38240\n   France\n\
    \   EMail: aland@networkradius.com\n   URI:   http://networkradius.com\n"
