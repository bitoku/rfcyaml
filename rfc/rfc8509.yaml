- contents:
  - '              A Root Key Trust Anchor Sentinel for DNSSEC

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The DNS Security Extensions (DNSSEC) were developed to provide origin\n
    \  authentication and integrity protection for DNS data by using digital\n   signatures.
    \ These digital signatures can be verified by building a\n   chain of trust starting
    from a trust anchor and proceeding down to a\n   particular node in the DNS.  This
    document specifies a mechanism that\n   will allow an end user and third parties
    to determine the trusted key\n   state for the root key of the resolvers that
    handle that user's DNS\n   queries.  Note that this method is only applicable
    for determining\n   which keys are in the trust store for the root key.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8509.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n     1.1.  Terminology . . . . . . . . . . . . . . . . . . . .
    . . .   4\n   2.  Sentinel Mechanism in Resolvers . . . . . . . . . . . . . .
    .   4\n     2.1.  Preconditions . . . . . . . . . . . . . . . . . . . . . .   5\n
    \    2.2.  Special Processing  . . . . . . . . . . . . . . . . . . .   6\n   3.
    \ Sentinel Tests for a Single DNS Resolver  . . . . . . . . . .   7\n     3.1.
    \ Forwarders  . . . . . . . . . . . . . . . . . . . . . . .   9\n   4.  Sentinel
    Tests for Multiple Resolvers . . . . . . . . . . . .  10\n     4.1.  Test Scenario
    and Objective . . . . . . . . . . . . . . .  11\n     4.2.  Test Assumptions  .
    . . . . . . . . . . . . . . . . . . .  11\n     4.3.  Test Procedure  . . . .
    . . . . . . . . . . . . . . . . .  12\n   5.  Security Considerations . . . .
    . . . . . . . . . . . . . . .  13\n   6.  Privacy Considerations  . . . . . .
    . . . . . . . . . . . . .  14\n   7.  IANA Considerations . . . . . . . . . .
    . . . . . . . . . . .  14\n   8.  References  . . . . . . . . . . . . . . . .
    . . . . . . . . .  14\n     8.1.  Normative References  . . . . . . . . . . .
    . . . . . . .  14\n     8.2.  Informative References  . . . . . . . . . . . .
    . . . . .  15\n   Appendix A.  Protocol Walk-Through Example  . . . . . . . .
    . . .  16\n   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . .
    .  19\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  19\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The DNS Security Extensions (DNSSEC) [RFC4033], [RFC4034],
    and\n   [RFC4035] were developed to provide origin authentication and\n   integrity
    protection for DNS data by using digital signatures.\n   DNSSEC uses Key Tags
    to efficiently match signatures to the keys from\n   which they are generated.
    \ The Key Tag is a 16-bit value computed\n   from the RDATA of a DNSKEY Resource
    Record (RR) as described in\n   Appendix B of [RFC4034].  RRSIG RRs contain a
    Key Tag field whose\n   value is equal to the Key Tag of the DNSKEY RR that was
    used to\n   generate the corresponding signature.\n   This document specifies
    how security-aware DNS resolvers that perform\n   validation of their responses
    can respond to certain queries in a\n   manner that allows an agent performing
    the queries to deduce whether\n   a particular key for the root has been loaded
    into that resolver's\n   trusted-key store.  This document also describes a procedure
    where a\n   collection of resolvers can be tested to determine whether at least\n
    \  one of these resolvers has loaded a given key into its trusted-key\n   store.
    \ These tests can be used to determine whether a certain root\n   zone Key Signing
    Key (KSK) is ready to be used as a trusted key,\n   within the context of a planned
    root zone KSK roll.\n   There are two primary use cases for this mechanism:\n
    \  o  Users may wish to ascertain whether their DNS resolution\n      environment's
    resolver is ready for an upcoming root KSK rollover.\n   o  Researchers want to
    perform Internet-wide studies about the\n      proportion of users who will be
    negatively impacted by an upcoming\n      root KSK rollover.\n   The mechanism
    described in this document satisfies the requirements\n   of both these use cases.
    \ This mechanism is OPTIONAL to implement and\n   use.  If implemented, this mechanism
    SHOULD be enabled by default to\n   facilitate Internet-wide measurement.  Configuration
    options MAY be\n   provided to disable the mechanism for reasons of local policy.\n
    \  The KSK sentinel tests described in this document use a test\n   comprising
    a set of DNS queries to domain names that have special\n   values for the leftmost
    label.  The test relies on recursive\n   resolvers supporting a mechanism that
    recognizes this special name\n   pattern in queries; under certain defined circumstances,
    it will\n   return a DNS SERVFAIL response code (RCODE 2), mimicking the response\n
    \  code that is returned by security-aware resolvers when DNSSEC\n   validation
    fails.\n   If a browser or operating system is configured with multiple\n   resolvers,
    and those resolvers have different properties (for\n   example, one performs DNSSEC
    validation and one does not), the\n   sentinel test described in this document
    can still be used.  The\n   sentinel test makes a number of assumptions about
    DNS resolution\n   behavior that may not necessarily hold in all environments;
    if these\n   assumptions do not hold, then this test may produce indeterminate
    or\n   inconsistent results.  This might occur, for example, if the stub\n   resolver
    is required to query the next recursive resolver in the\n   locally configured
    set upon receipt of a SERVFAIL response code.  In\n   some cases where these assumptions
    do not hold, repeating the same\n   test query set may generate different results.\n
    \  Note that the measurements facilitated by the mechanism described in\n   this
    document are different from those of [RFC8145].  RFC 8145 relies\n   on resolvers
    reporting towards the root servers a list of locally\n   cached trust anchors
    for the root zone.  Those reports can be used to\n   infer how many resolvers
    may be impacted by a KSK roll but not what\n   the user impact of the KSK roll
    will be.\n"
  - contents:
    - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
      \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
      in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n
      \  capitals, as shown here.\n   This document contains a number of terms related
      to the DNS.  The\n   current definitions of these terms can be found in [RFC7719].\n"
    title: 1.1.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Sentinel Mechanism in Resolvers\n   DNSSEC-validating resolvers that implement
    this mechanism MUST\n   perform validation of responses in accordance with the
    DNSSEC\n   response validation specification [RFC4035].\n   This sentinel mechanism
    makes use of two special labels:\n   o  root-key-sentinel-is-ta-<key-tag>\n   o
    \ root-key-sentinel-not-ta-<key-tag>\n   These labels trigger special processing
    in the validating DNS\n   resolver when responses from authoritative servers are
    received.\n   Labels containing \"root-key-sentinel-is-ta-<key-tag>\" are used
    to\n   answer the question, \"Is this the Key Tag of a key that the\n   validating
    DNS resolver is currently trusting as a trust anchor?\"\n   Labels containing
    \"root-key-sentinel-not-ta-<key-tag>\" are used to\n   answer the question, \"Is
    this the Key Tag of a key that the\n   validating DNS resolver is *not* currently
    trusting as a trust\n   anchor?\"\n   The special labels defined here were chosen
    after extensive IETF\n   evaluation of alternative patterns and approaches in
    light of the\n   desired behavior (Sections 2.1 and 2.2) within the resolver and
    the\n   applied testing methodology (Section 4.3).  As one example,\n   underscore-prefixed
    names were rejected because some browsers and\n   operating systems would not
    fetch them because they are domain names\n   but not valid hostnames (see [RFC7719]
    for these definitions).\n   Consideration was given to local collisions and the
    reservation of\n   leftmost labels of a domain name, as well as the impact upon
    zone\n   operators who might desire to use a similarly constructed hostname\n
    \  for a purpose other than those documented here.  Therefore, it is\n   important
    to note that the reservation of the labels in this manner\n   is definitely not
    considered \"best practice\".\n"
  - contents:
    - "2.1.  Preconditions\n   All of the following conditions must be met to trigger
      special\n   processing inside resolver code:\n   o  The DNS response is DNSSEC
      validated.\n   o  The result of validation is \"Secure\".\n   o  The Extension
      Mechanisms for DNS (EDNS(0)) Checking Disabled (CD)\n      bit in the query
      is not set.\n   o  The QTYPE is either A or AAAA (Query Type value 1 or 28).\n
      \  o  The OPCODE is QUERY.\n   o  The leftmost label of the original QNAME (the
      name sent in the\n      Question Section in the original query) is either \"root-key-\n
      \     sentinel-is-ta-<key-tag>\" or \"root-key-sentinel-not-ta-<key-tag>\".\n
      \  If any one of the preconditions is not met, the resolver MUST NOT\n   alter
      the DNS response based on the mechanism in this document.\n   Note that the
      <key-tag> is specified in the DNS label as an unsigned\n   decimal integer (as
      described in [RFC4034], Section 5.3) but is zero-\n   padded to five digits
      (for example, a Key Tag value of 42 would be\n   represented in the label as
      00042).  The precise specification of the\n   special labels above should be
      followed exactly.  For example, a\n   label that does not include a Key Tag
      zero-padded to five digits does\n   not match this specification and should
      not be processed as if it did\n   -- in other words, such queries should be
      handled as any other label\n   and not according to Section 2.2.\n"
    title: 2.1.  Preconditions
  - contents:
    - "2.2.  Special Processing\n   Responses that fulfill all of the preconditions
      in Section 2.1\n   require special processing, depending on the leftmost label
      in the\n   QNAME.\n   First, the resolver determines if the numerical value
      of <key-tag> is\n   equal to any of the Key Tag values of an active root zone
      KSK that is\n   currently trusted by the local resolver and stored in its store
      of\n   trusted keys.  An active root zone KSK is one that could currently be\n
      \  used for validation (that is, a key that is not in either the AddPend\n   or
      Revoked state, as described in [RFC5011]).\n   Second, the resolver alters the
      response being sent to the original\n   query based on both the leftmost label
      and the presence of a key with\n   given Key Tag in the trust-anchor store.
      \ Two labels and two possible\n   states of the corresponding key generate four
      possible combinations,\n   summarized in the table:\n    Label      | Key is
      trusted          | Key is not trusted\n    ------------------------------------------------------------------\n
      \   is-ta      | return original answer  | return SERVFAIL\n    not-ta     |
      return SERVFAIL         | return original answer\n   The instruction \"return
      SERVFAIL\" means that the resolver MUST set\n   RCODE=SERVFAIL (value 2) and
      the Answer Section of the DNS response\n   MUST be empty, ignoring all other
      documents that specify the content\n   of the Answer Section.\n   The instruction
      \"return original answer\" means that the resolver MUST\n   process the query
      without any further special processing, that is,\n   exactly as if the mechanism
      described in this document was not\n   implemented or was disabled.  The answer
      for the A or AAAA query is\n   sent on to the client.\n"
    title: 2.2.  Special Processing
  title: 2.  Sentinel Mechanism in Resolvers
- contents:
  - "3.  Sentinel Tests for a Single DNS Resolver\n   This section describes the use
    of the sentinel detection mechanism\n   against a single DNS recursive resolver
    in order to determine whether\n   this resolver is using a particular trust anchor
    to validate DNSSEC-\n   signed responses.\n   Note that the test in this section
    applies to a single DNS resolver.\n   The test described in Section 4 applies
    instead to a collection of\n   DNS resolvers, as might be found in the DNS configuration
    of an end-\n   user environment.\n   The critical aspect of the DNS names used
    in this mechanism is that\n   they contain the specified label for either the
    positive or negative\n   test as the leftmost label in the query name.\n   The
    sentinel detection procedure can test a DNS resolver using three\n   queries:\n
    \  o  A query name containing the leftmost label \"root-key-sentinel-is-\n      ta-<key-tag>\".
    \ This corresponds to a validly signed name in the\n      parent zone, so that
    responses associated with this query name can\n      be authenticated by a DNSSEC-validating
    resolver.  Any validly\n      signed DNS zone can be used as the parent zone for
    this test.\n   o  A query name containing the leftmost label \"root-key-sentinel-not-\n
    \     ta-<key-tag>\".  This also corresponds to a validly signed name.\n      Any
    validly signed DNS zone can be used as the parent zone for\n      this test.\n
    \  o  A query name that is signed with a DNSSEC signature that cannot be\n      validated
    (described as a \"bogus\" RRset in Section 5 of [RFC4033]\n      when, for example,
    an RRset is associated with a zone that is not\n      signed with a valid RRSIG
    record).\n   The responses received from queries to resolve each of these query\n
    \  names can be evaluated to infer a trust key state of the DNS\n   resolver.\n
    \  An essential assumption here is that this technique relies on\n   security-aware
    (DNSSEC-validating) resolvers responding with a\n   SERVFAIL response code to
    queries where DNSSEC checking is requested\n   and the response cannot be validated.
    \ Note that other issues can\n   also cause a resolver to return SERVFAIL responses,
    and so the\n   sentinel processing may sometimes result in incorrect or\n   indeterminate
    conclusions.\n   To describe this process of classification, DNS resolvers are\n
    \  classified by five distinct behavior types using the labels: \"Vnew\",\n   \"Vold\",
    \"Vind\", \"nonV\", and \"other\".  These labels correspond to\n   resolver-system
    behavior types as follows:\n   Vnew:  A DNS resolver that is configured to implement
    this mechanism\n      and has loaded the nominated key into its local trusted-key
    stores\n      will respond with an A or AAAA RRset response for the associated\n
    \     \"root-key-sentinel-is-ta\" queries, SERVFAIL for \"root-key-\n      sentinel-not-ta\"
    queries, and SERVFAIL for the signed name queries\n      that return \"bogus\"
    validation status.\n   Vold:  A DNS resolver that is configured to implement this
    mechanism\n      and has not loaded the nominated key into its local trusted-key\n
    \     stores will respond with a SERVFAIL for the associated \"root-key-\n      sentinel-is-ta\"
    queries, an A or AAAA RRset response for \"root-\n      key-sentinel-not-ta\"
    queries, and SERVFAIL for the signed name\n      queries that return \"bogus\"
    validation status.\n   Vind:  A DNS resolver that is not configured to implement
    this\n      mechanism will respond with an A or AAAA RRset response for \"root-\n
    \     key-sentinel-is-ta\", an A or AAAA RRset response for \"root-key-\n      sentinel-not-ta\",
    and SERVFAIL for the name that returns \"bogus\"\n      validation status.  This
    set of responses does not give any\n      information about the trust anchors
    used by this resolver.\n   nonV:  A non-security-aware DNS resolver will respond
    with an A or\n      AAAA RRset response for \"root-key-sentinel-is-ta\", an A
    or AAAA\n      RRset response for \"root-key-sentinel-not-ta\" and an A or AAAA\n
    \     RRset response for the name that returns \"bogus\" validation\n      status.\n
    \  other:  There is the potential to admit other combinations of\n      responses
    to these three queries.  While this may appear self-\n      contradictory, there
    are cases where such an outcome is possible.\n      For example, in DNS resolver
    farms, what appears to be a single\n      DNS resolver that responds to queries
    passed to a single IP\n      address is in fact constructed as a collection of
    slave resolvers,\n      and the query is passed to one of these internal resolver
    engines.\n      If these individual slave resolvers in the farm do not behave\n
    \     identically, then other sets of results can be expected from these\n      three
    queries.  In such a case, no determination about the\n      capabilities of this
    DNS resolver farm can be made.\n   Note that SERVFAIL might be cached according
    to Section 7 of\n   [RFC2308] for up to 5 minutes and a positive answer for up
    to its\n   TTL.\n   If a client directs these three queries to a single resolver,
    the\n   responses should allow the client to determine the capability of the\n
    \  resolver and, if it supports this sentinel mechanism, whether or not\n   it
    has a particular key in its trust-anchor store, as in the\n   following table:\n
    \                                   Query\n                      +----------+-----------+------------+\n
    \                     |  is-ta   |  not-ta   |   bogus    |\n              +-------+----------+-----------+------------+\n
    \             | Vnew  |    Y     |  SERVFAIL |  SERVFAIL  |\n              | Vold
    \ | SERVFAIL |      Y    |  SERVFAIL  |\n        Type  | Vind  |    Y     |      Y
    \   |  SERVFAIL  |\n              | nonV  |    Y     |      Y    |     Y      |\n
    \             | other |    *     |      *    |     *      |\n              +-------+----------+-----------+------------+\n
    \  In this table, the \"Y\" response denotes an A or AAAA RRset response\n   (depending
    on the query type of A or AAAA records), \"SERVFAIL\"\n   denotes a DNS SERVFAIL
    response code (RCODE 2), and \"*\" denotes\n   either response.\n   Vnew:  The
    nominated key is trusted by the resolver.\n   Vold:  The nominated key is not
    yet trusted by the resolver.\n   Vind:  There is no information about the trust
    anchors of the\n          resolver.\n   nonV:  The resolver does not perform DNSSEC
    validation.\n   other: The properties of the resolver cannot be analyzed by this\n
    \         protocol.\n"
  - contents:
    - "3.1.  Forwarders\n   Some resolvers are configured not to answer queries using
      the\n   recursive algorithm first described in [RFC1034], Section 4.3.2 but\n
      \  instead relay queries to one or more other resolvers.  Resolvers\n   configured
      in this manner are referred to in this document as\n   \"forwarders\".\n   If
      the resolver is non-validating and has a single forwarder, then it\n   will
      presumably mirror the capabilities of the forwarder's target\n   resolver.\n
      \  If the validating resolver has a forwarding configuration, and it\n   sets
      the EDNS(0) Checking Disabled (CD) bit as described in\n   Section 3.2.2 of
      [RFC4035] on all forwarded queries, then this\n   resolver is acting in a manner
      that is identical to a standalone\n   resolver.\n   A more complex case is where
      all of the following conditions hold:\n   o  Both the validating resolver and
      the forwarder target resolver\n      support this trusted key sentinel mechanism.\n
      \  o  The local resolver's queries do not have the EDNS(0) CD bit set.\n   o
      \ The trusted key state differs between the forwarding resolver and\n      the
      forwarder's target resolver.\n   In such a case, either the outcome is indeterminate
      validating\n   (\"Vind\") or there are mixed signals such as SERVFAIL in all
      three\n   responses (\"other\"), which is similarly an indeterminate response\n
      \  with respect to the trusted key state.\n"
    title: 3.1.  Forwarders
  title: 3.  Sentinel Tests for a Single DNS Resolver
- contents:
  - "4.  Sentinel Tests for Multiple Resolvers\n   Section 3 describes a trust-anchor
    test that can be used in the\n   simple situation where the test queries are being
    passed to a single\n   recursive resolver that directly queries authoritative
    name servers.\n   However, the common end-user scenario is where a user's local
    DNS\n   resolution environment is configured to use more than one recursive\n
    \  resolver.  The single-resolver test technique will not function\n   reliably
    in such cases, as a SERVFAIL response from one resolver may\n   cause the local
    stub resolver to repeat the query against one of the\n   other configured resolvers,
    and the results may be inconclusive.\n   In describing a test procedure that can
    be used for a set of DNS\n   resolvers, there are some necessary changes to the
    nature of the\n   question that this test can answer, the assumptions about the\n
    \  behavior of the DNS resolution environment, and some further\n   observations
    about potential variability in the test outcomes.\n"
  - contents:
    - "4.1.  Test Scenario and Objective\n   This test is not intended to expose which
      trust anchors are used by\n   any single DNS resolver.\n   The test scenario
      is explicitly restricted to that of the KSK\n   environment where a current,
      active KSK (called \"KSK-current\") is to\n   be replaced with a new KSK (called
      \"KSK-new\").  The test is designed\n   to be run between when KSK-new is introduced
      into the root zone and\n   when the root zone is signed with KSK-new.\n   The
      objective of the test is to determine if the user will be\n   negatively impacted
      by the KSK roll.  A \"negative impact\" for the\n   user is defined such that
      all the configured resolvers are security-\n   aware resolvers that perform
      validation of DNSSEC-signed responses,\n   and none of these resolvers have
      loaded KSK-new into their local\n   trust-anchor set.  In this situation, it
      is anticipated that once the\n   KSK is rolled, the entire set of the user's
      resolvers will not be\n   able to validate the contents of the root zone, and
      the user is\n   likely to lose DNS service as a result of this inability to
      perform\n   successful DNSSEC validation.\n"
    title: 4.1.  Test Scenario and Objective
  - contents:
    - "4.2.  Test Assumptions\n   There are a number of assumptions about the DNS
      environment used in\n   this test.  Where these assumptions do not hold, the
      results of the\n   test will be indeterminate.\n   o  When a recursive resolver
      returns SERVFAIL to the user's stub\n      resolver, the stub resolver will
      send the same query to the next\n      resolver in the locally configured resolver
      set.  It will continue\n      to do this until it either gets a non-SERVFAIL
      response or runs\n      out of resolvers to try.\n   o  When the user's stub
      resolver passes a query to a resolver in the\n      configured resolver set,
      it will get a consistent answer over the\n      time frame of the queries.  This
      assumption implies that if the\n      same query is asked by the same stub resolver
      multiple times in\n      succession to the same recursive resolver, the recursive\n
      \     resolver's response will be the same for each of these queries.\n   o
      \ All DNSSEC-validating resolvers have KSK-current in their local\n      trust-anchor
      cache.\n   There is no current published measurement data that indicates to
      what\n   extent the first two assumptions listed here are valid or how many\n
      \  end users may be impacted by these assumptions.  In particular, the\n   first
      assumption, that a consistent SERVFAIL response will cause the\n   local stub
      DNS resolution environment to query all of its configured\n   recursive resolvers
      before concluding that the name cannot be\n   resolved, is a critical assumption
      for this test.\n   Note that additional precision/determinism may be achievable
      by\n   bypassing the normal OS behavior and explicitly testing using each\n
      \  configured recursive resolver (e.g., using \"dig\").\n"
    title: 4.2.  Test Assumptions
  - contents:
    - "4.3.  Test Procedure\n   The sentinel detection process tests a DNS resolution
      environment\n   with three query names.  Note that these are the same general\n
      \  categories of query as in Section 3, but the Key Tag used is\n   different
      for some queries:\n   o  A query name that is signed with a DNSSEC signature
      that cannot be\n      validated (described as a \"bogus\" RRset in Section 5
      of [RFC4033]\n      when, for example, an RRset is not signed with a valid RRSIG\n
      \     record).\n   o  A query name containing the leftmost label \"root-key-sentinel-not-\n
      \     ta-<key-tag-of-KSK-current>\".  This name MUST be a validly signed\n      name.
      \ Any validly signed DNS zone can be used for this test.\n   o  A query name
      containing the leftmost label \"root-key-sentinel-is-\n      ta-<key-tag-of-KSK-new>\".
      \ This name MUST be a validly signed\n      name.  Any validly signed DNS zone
      can be used for this test.\n   The responses received from queries to resolve
      each of these names\n   can be evaluated to infer a trust key state of the user's
      DNS\n   resolution environment.\n   The responses to these queries are described
      using a simplified\n   notation.  Each query will result in either a SERVFAIL
      response\n   (denoted \"S\"), indicating that all of the resolvers in the recursive\n
      \  resolver set returned the SERVFAIL response code, or a response with\n   the
      desired RRset value (denoted \"A\").  The queries are ordered by\n   the \"invalid\"
      name, the \"root-key-sentinel-not-ta\" label, then the\n   \"root-key-sentinel-is-ta\"
      label, and a triplet notation denotes a\n   particular response.  For example,
      the triplet \"(S S A)\" denotes a\n   SERVFAIL response to the invalid query,
      a SERVFAIL response to the\n   \"root-key-sentinel-not-ta\" query, and an RRset
      response to the \"root-\n   key-sentinel-is-ta\" query.\n   The set of all possible
      responses to these three queries are:\n   (A * *):  If any resolver returns
      an \"A\" response for the query for\n      the invalid name, then the resolver
      set contains at least one\n      non-validating DNS resolver, and the user will
      not be impacted by\n      the KSK roll.\n   (S A *):  If any of the resolvers
      returns an \"A\" response for the\n      \"root-key-sentinel-not-ta\" query,
      then at least one of the\n      resolvers does not recognize the sentinel mechanism,
      and the\n      behavior of the collection of resolvers during the KSK roll cannot\n
      \     be reliably determined.\n   (S S A):  This case implies that all of the
      resolvers in the set\n      perform DNSSEC validation, all of the resolvers
      are aware of the\n      sentinel mechanism, and at least one resolver has loaded
      KSK-new\n      as a local trust anchor.  The user will not be impacted by the
      KSK\n      roll.\n   (S S S):  This case implies that all of the resolvers in
      the set\n      perform DNSSEC validation, all of the resolvers are aware of
      the\n      sentinel mechanism, and none of the resolvers has loaded KSK-new\n
      \     as a local trust anchor.  The user will be negatively impacted by\n      the
      KSK roll.\n"
    title: 4.3.  Test Procedure
  title: 4.  Sentinel Tests for Multiple Resolvers
- contents:
  - "5.  Security Considerations\n   This document describes a mechanism for allowing
    users to determine\n   the trust-anchor state of root zone key signing keys in
    the DNS\n   resolution system that they use.  If the user executes third-party\n
    \  code, then this information may also be available to the third party.\n   The
    mechanism does not require resolvers to set otherwise-\n   unauthenticated responses
    to be marked as authenticated and does not\n   alter the security properties of
    DNSSEC with respect to the\n   interpretation of the authenticity of responses
    that are so marked.\n   The mechanism does not require any further significant
    processing of\n   DNS responses, and queries of the form described in this document
    do\n   not impose any additional load that could be exploited in an attack\n   over
    the normal DNSSEC-validation processing load.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  Privacy Considerations\n   The mechanism in this document enables third parties
    (with either\n   good or bad intentions) to learn something about the security\n
    \  configuration of recursive DNS resolvers.  That is, someone who can\n   cause
    an Internet user to make specific DNS queries (e.g., via web-\n   based advertisements
    or JavaScript in web pages) can, under certain\n   specific circumstances that
    include additional knowledge of the\n   resolvers that are invoked by the user,
    determine which trust anchors\n   are configured in these resolvers.  Without
    this additional\n   knowledge, the third party can infer the aggregate capabilities
    of\n   the user's DNS resolution environment but cannot necessarily infer\n   the
    trust configuration of any recursive name server.\n"
  title: 6.  Privacy Considerations
- contents:
  - "7.  IANA Considerations\n   This document has no IANA actions.\n"
  title: 7.  IANA Considerations
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names -
      concepts and facilities\",\n              STD 13, RFC 1034, DOI 10.17487/RFC1034,
      November 1987,\n              <https://www.rfc-editor.org/info/rfc1034>.\n   [RFC2119]
      \ Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2308]  Andrews,
      M., \"Negative Caching of DNS Queries (DNS\n              NCACHE)\", RFC 2308,
      DOI 10.17487/RFC2308, March 1998,\n              <https://www.rfc-editor.org/info/rfc2308>.\n
      \  [RFC4033]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,
      \"DNS Security Introduction and Requirements\",\n              RFC 4033, DOI
      10.17487/RFC4033, March 2005,\n              <https://www.rfc-editor.org/info/rfc4033>.\n
      \  [RFC4034]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,
      \"Resource Records for the DNS Security Extensions\",\n              RFC 4034,
      DOI 10.17487/RFC4034, March 2005,\n              <https://www.rfc-editor.org/info/rfc4034>.\n
      \  [RFC4035]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,
      \"Protocol Modifications for the DNS Security\n              Extensions\", RFC
      4035, DOI 10.17487/RFC4035, March 2005,\n              <https://www.rfc-editor.org/info/rfc4035>.\n
      \  [RFC5011]  StJohns, M., \"Automated Updates of DNS Security (DNSSEC)\n              Trust
      Anchors\", STD 74, RFC 5011, DOI 10.17487/RFC5011,\n              September
      2007, <https://www.rfc-editor.org/info/rfc5011>.\n   [RFC8174]  Leiba, B., \"Ambiguity
      of Uppercase vs Lowercase in RFC\n              2119 Key Words\", BCP 14, RFC
      8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [RFC7719]  Hoffman, P., Sullivan, A., and
      K. Fujiwara, \"DNS\n              Terminology\", RFC 7719, DOI 10.17487/RFC7719,
      December\n              2015, <https://www.rfc-editor.org/info/rfc7719>.\n   [RFC8145]
      \ Wessels, D., Kumari, W., and P. Hoffman, \"Signaling Trust\n              Anchor
      Knowledge in DNS Security Extensions (DNSSEC)\",\n              RFC 8145, DOI
      10.17487/RFC8145, April 2017,\n              <https://www.rfc-editor.org/info/rfc8145>.\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "Appendix A.  Protocol Walk-Through Example\n   This appendix provides a non-normative
    example of how the sentinel\n   mechanism could be used and what each participant
    does.  It is\n   provided in a conversational tone to be easier to follow.  The\n
    \  examples here all assume that each person has just one resolver or a\n   system
    of resolvers that have the same properties.\n   Alice is in charge of the DNS
    root KSK (Key Signing Key) and would\n   like to roll/replace the key with a new
    one.  She publishes the new\n   KSK but would like to be able to predict/measure
    what the impact will\n   be before removing/revoking the old key.  The current
    KSK has a Key\n   Tag of 11112; the new KSK has a Key Tag of 02323.  Users want
    to\n   verify that their resolver will not break after Alice rolls the root\n
    \  KSK (that is, starts signing with just the KSK whose Key Tag is\n   02323).\n
    \  Bob, Charlie, Dave, and Ed are all users.  They use the DNS recursive\n   resolvers
    supplied by their ISPs.  They would like to confirm that\n   their ISPs have picked
    up the new KSK.  Bob's ISP does not perform\n   validation.  Charlie's ISP does
    validate, but the resolvers have not\n   yet been upgraded to support this mechanism.
    \ Dave and Ed's resolvers\n   have been upgraded to support this mechanism; Dave's
    resolver has the\n   new KSK, but Ed's resolver hasn't managed to install the
    02323 KSK in\n   its trust store yet.\n   Geoff is a researcher.  He would like
    to both provide a means for\n   Bob, Charlie, Dave, and Ed to perform tests and
    himself be able to\n   perform Internet-wide measurements of what the impact will
    be (and\n   report this back to Alice).\n   Geoff sets an authoritative DNS server
    for example.com and also a web\n   server (www.example.com).  He adds three address
    records to\n   example.com:\n      bogus.example.com.  IN AAAA 2001:db8::1\n      root-key-sentinel-is-ta-02323.example.com.
    \ IN AAAA 2001:db8::1\n      root-key-sentinel-not-ta-11112.example.com.  IN AAAA
    2001:db8::1\n   Note that the use of \"example.com\" names and the addresses here
    are\n   examples, and \"bogus\" intentionally has invalid DNSSEC signatures.\n
    \  In a real deployment, the domain names need to be under the control\n   of
    the researcher, and the addresses must be real, reachable\n   addresses.\n   Geoff
    then DNSSEC signs the example.com zone and intentionally makes\n   the bogus.example.com
    record have bogus validation status (for\n   example, by editing the signed zone
    and entering garbage for the\n   signature).  Geoff also configures his web server
    to listen on\n   2001:db8::1 and serve a resource (for example, a 1x1 GIF, 1x1.gif)\n
    \  for all of these names.  The web server also serves a web page\n   (www.example.com)
    that contains links to these three resources\n   (http://bogus.example.com/1x1.gif,
    http://root-key-sentinel-is-ta-\n   02323.example.com/1x1.gif, and http://root-key-sentinel-not-ta-\n
    \  11112.example.com/1x1.gif).\n   Geoff then asks Bob, Charlie, Dave, and Ed
    to browse to\n   www.example.com.  Using the methods described in this document,
    the\n   users can figure out what their fate will be when the 11112 KSK is\n   removed.\n
    \  Bob is not using a validating resolver.  This means that he will be\n   able
    to resolve bogus.example.com (and fetch the 1x1 GIF); this tells\n   him that
    the KSK roll does not affect him, and so he will be OK.\n   Charlie's resolvers
    are validating, but they have not been upgraded\n   to support the KSK sentinel
    mechanism.  Charlie will not be able to\n   fetch the http://bogus.example.com/1x1.gif
    resource (the\n   bogus.example.com record is bogus, and none of his resolvers
    will\n   resolve it).  He is able to fetch both of the other resources; from\n
    \  this, he knows (see the logic in the body of this document) that he\n   is
    using validating resolvers but that at least one of these\n   resolvers is not
    configured to perform sentinel processing.  The KSK\n   sentinel method cannot
    provide him with a definitive answer to the\n   question of whether he will be
    impacted by the KSK roll.\n   Dave's resolvers implement the sentinel method and
    have picked up the\n   new KSK.  For the same reason as Charlie, he cannot fetch
    the \"bogus\"\n   resource.  His resolver resolves the root-key-sentinel-is-ta-\n
    \  02323.example.com name normally (it contacts the example.com\n   authoritative
    servers, etc.); as it supports the sentinel mechanism,\n   just before Dave's
    recursive resolver sends the reply to Dave's stub,\n   it performs the KSK sentinel
    check.  The QNAME starts with \"root-key-\n   sentinel-is-ta-\", and the recursive
    resolver does indeed have a key\n   with the Key Tag of 02323 in its root trust
    store.  This means that\n   this part of the KSK sentinel check passes (it is
    true that Key Tag\n   02323 is in the trust-anchor store), and the recursive resolver\n
    \  replies normally (with the answer provided by the authoritative\n   server).
    \ Dave's recursive resolver then resolves the root-key-\n   sentinel-not-ta-11112.example.com
    name.  Once again, it performs the\n   normal resolution process, but because
    it implements KSK sentinel\n   (and the QNAME starts with \"root-key-sentinel-not-ta-\"),
    just before\n   sending the reply, it performs the KSK sentinel check.  As it
    has the\n   key with key-tag 11112 in its trust-anchor store, the answer to \"is\n
    \  this *not* a trust anchor\" is false, and so the recursive resolver\n   does
    not reply with the answer from the authoritative server.\n   Instead, it replies
    with a SERVFAIL (note that replying with SERVFAIL\n   instead of the original
    answer is the only mechanism that KSK\n   Sentinel uses).  This means that Dave
    cannot fetch \"bogus\", he can\n   fetch \"root-key-sentinel-is-ta-02323\", but
    he cannot fetch \"root-key-\n   sentinel-not-ta-11112\".  From this, Dave knows
    that he is behind a\n   collection of resolvers that all validate, all have the
    key with Key\n   Tag 11112 loaded, and at least one of these resolvers has loaded
    the\n   key with Key Tag 02323 into its local trust-anchor cache.  Dave will\n
    \  not be impacted by the KSK roll.\n   Just like Charlie and Dave, Ed cannot
    fetch the \"bogus\" record.  This\n   tells him that his resolvers are validating.
    \ When his (sentinel-\n   aware) resolvers perform the KSK sentinel check for
    \"root-key-\n   sentinel-is-ta-02323\", none of them have loaded the new key with
    Key\n   Tag 02323 in their local trust-anchor store.  This means the check\n   fails,
    and Ed's recursive resolver converts the (valid) answer into a\n   SERVFAIL error
    response.  It performs the same check for root-key-\n   sentinel-not-ta-11112.example.com,
    and as all of Ed's resolvers both\n   perform DNSSEC validation and recognize
    the sentinel label, Ed will\n   be unable to fetch the \"root-key-sentinel-not-ta-11112\"
    resource.\n   This tells Ed that his resolvers have not installed the new KSK
    and\n   he will be negatively impacted by the KSK roll.\n   Geoff would like to
    do a large-scale test and provide the information\n   back to Alice.  He uses
    some mechanism such as causing users to go to\n   a web page to cause a large
    number of users to attempt to resolve the\n   three resources, and he then analyzes
    the results of the tests to\n   determine what percentage of users will be affected
    by the KSK\n   rollover event.\n   This description is a simplified example.  It
    is not anticipated that\n   Bob, Charlie, Dave, and Ed will actually look for
    the absence or\n   presence of web resources; instead, the web page that they
    load would\n   likely contain JavaScript (or similar) that displays the result
    of\n   the tests, sends the results to Geoff, or both.  This sentinel\n   mechanism
    does not rely on the web: it can equally be used by trying\n   to resolve the
    names (for example, using the common \"dig\" command)\n   and checking which names
    result in a SERVFAIL.\n"
  title: Appendix A.  Protocol Walk-Through Example
- contents:
  - "Acknowledgements\n   This document has borrowed extensively from [RFC8145] for
    the\n   introductory text, and the authors would like to acknowledge and\n   thank
    the authors of that document both for some text excerpts and\n   for the more
    general stimulation of thoughts about monitoring the\n   progress of a roll of
    the KSK of the root zone of the DNS.\n   The authors would like to thank Joe Abley,
    Mehmet Akcin, Mark\n   Andrews, Richard Barnes, Ray Bellis, Stephane Bortzmeyer,
    David\n   Conrad, Ralph Dolmans, John Dickinson, Steinar Haug, Bob Harold, Wes\n
    \  Hardaker, Paul Hoffman, Matt Larson, Jinmei Tatuya, Edward Lewis,\n   George
    Michaelson, Benno Overeinder, Matthew Pounsett, Hugo Salgado-\n   Hernandez, Andreas
    Schulze, Mukund Sivaraman, Petr Spacek, Job\n   Snijders, Andrew Sullivan, Ondrej
    Sury, Paul Vixie, Duane Wessels,\n   and Paul Wouters for their helpful feedback.\n
    \  The authors would like to especially call out Paul Hoffman and Duane\n   Wessels
    for providing comments in the form of pull requests.  Joe\n   Abley also helpfully
    provided extensive review and OLD / NEW text.\n   Petr Spacek wrote some very
    early implementations and provided\n   significant feedback -- including pointing
    out when the test bed\n   didn't match the document!\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Geoff Huston\n   Email: gih@apnic.net\n   URI:   http://www.apnic.net\n
    \  Joao Silva Damas\n   Email: joao@apnic.net\n   URI:   http://www.apnic.net\n
    \  Warren Kumari\n   Email: warren@kumari.net\n"
  title: Authors' Addresses
