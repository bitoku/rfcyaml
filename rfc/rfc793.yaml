- title: __initial_text__
  contents:
  - "                     TRANSMISSION CONTROL PROTOCOL\n                        \
    \ DARPA INTERNET PROGRAM\n                         PROTOCOL SPECIFICATION\n  \
    \                           September 1981\n                              prepared\
    \ for\n               Defense Advanced Research Projects Agency\n            \
    \    Information Processing Techniques Office\n                         1400 Wilson\
    \ Boulevard\n                       Arlington, Virginia  22209\n             \
    \        Information Sciences Institute\n                                    \
    \       Transmission Control Protocol\n                           TABLE OF CONTENTS\n\
    \    PREFACE ........................................................ iii\n"
- title: 1.  INTRODUCTION ..................................................... 1
  contents:
  - "1.  INTRODUCTION ..................................................... 1\n  1.1\
    \  Motivation .................................................... 1\n  1.2  Scope\
    \ ......................................................... 2\n  1.3  About This\
    \ Document ........................................... 2\n  1.4  Interfaces ....................................................\
    \ 3\n  1.5  Operation ..................................................... 3\n"
- title: 2.  PHILOSOPHY ....................................................... 7
  contents:
  - "2.  PHILOSOPHY ....................................................... 7\n  2.1\
    \  Elements of the Internetwork System ........................... 7\n  2.2  Model\
    \ of Operation ............................................ 7\n  2.3  The Host\
    \ Environment .......................................... 8\n  2.4  Interfaces\
    \ .................................................... 9\n  2.5  Relation to Other\
    \ Protocols ................................... 9\n  2.6  Reliable Communication\
    \ ........................................ 9\n  2.7  Connection Establishment\
    \ and Clearing ........................ 10\n  2.8  Data Communication ...........................................\
    \ 12\n  2.9  Precedence and Security ...................................... 13\n\
    \  2.10 Robustness Principle ......................................... 13\n"
- title: 3.  FUNCTIONAL SPECIFICATION ........................................ 15
  contents:
  - "3.  FUNCTIONAL SPECIFICATION ........................................ 15\n  3.1\
    \  Header Format ................................................ 15\n  3.2  Terminology\
    \ .................................................. 19\n  3.3  Sequence Numbers\
    \ ............................................. 24\n  3.4  Establishing a connection\
    \ .................................... 30\n  3.5  Closing a Connection .........................................\
    \ 37\n  3.6  Precedence and Security ...................................... 40\n\
    \  3.7  Data Communication ........................................... 40\n  3.8\
    \  Interfaces ................................................... 44\n  3.9  Event\
    \ Processing ............................................. 52\n"
- title: GLOSSARY ............................................................ 79
  contents:
  - 'GLOSSARY ............................................................ 79

    '
- title: REFERENCES .......................................................... 85
  contents:
  - 'REFERENCES .......................................................... 85

    '
- title: Transmission Control Protocol
  contents:
  - "Transmission Control Protocol\n                                           Transmission\
    \ Control Protocol\n                                PREFACE\n"
- title: This document describes the DoD Standard Transmission Control Protocol
  contents:
  - 'This document describes the DoD Standard Transmission Control Protocol

    '
- title: (TCP).  There have been nine earlier editions of the ARPA TCP
  contents:
  - '(TCP).  There have been nine earlier editions of the ARPA TCP

    '
- title: specification on which this standard is based, and the present text
  contents:
  - 'specification on which this standard is based, and the present text

    '
- title: draws heavily from them.  There have been many contributors to this work
  contents:
  - 'draws heavily from them.  There have been many contributors to this work

    '
- title: both in terms of concepts and in terms of text.  This edition clarifies
  contents:
  - 'both in terms of concepts and in terms of text.  This edition clarifies

    '
- title: several details and removes the end-of-letter buffer-size adjustments,
  contents:
  - 'several details and removes the end-of-letter buffer-size adjustments,

    '
- title: and redescribes the letter mechanism as a push function.
  contents:
  - "and redescribes the letter mechanism as a push function.\n                  \
    \                                         Jon Postel\n                       \
    \                                    Editor\n"
- title: 'RFC:  793'
  contents:
  - 'RFC:  793

    '
- title: 'Replaces: RFC 761'
  contents:
  - 'Replaces: RFC 761

    '
- title: 'IENs:  129, 124, 112, 81,'
  contents:
  - 'IENs:  129, 124, 112, 81,

    '
- title: 55, 44, 40, 27, 21, 5
  contents:
  - "55, 44, 40, 27, 21, 5\n                     TRANSMISSION CONTROL PROTOCOL\n \
    \                        DARPA INTERNET PROGRAM\n                         PROTOCOL\
    \ SPECIFICATION\n                            1.  INTRODUCTION\n"
- title: The Transmission Control Protocol (TCP) is intended for use as a highly
  contents:
  - 'The Transmission Control Protocol (TCP) is intended for use as a highly

    '
- title: reliable host-to-host protocol between hosts in packet-switched computer
  contents:
  - 'reliable host-to-host protocol between hosts in packet-switched computer

    '
- title: communication networks, and in interconnected systems of such networks.
  contents:
  - 'communication networks, and in interconnected systems of such networks.

    '
- title: This document describes the functions to be performed by the
  contents:
  - 'This document describes the functions to be performed by the

    '
- title: Transmission Control Protocol, the program that implements it, and its
  contents:
  - 'Transmission Control Protocol, the program that implements it, and its

    '
- title: interface to programs or users that require its services.
  contents:
  - 'interface to programs or users that require its services.

    '
- title: 1.1.  Motivation
  contents:
  - "1.1.  Motivation\n  Computer communication systems are playing an increasingly\
    \ important\n  role in military, government, and civilian environments.  This\n\
    \  document focuses its attention primarily on military computer\n  communication\
    \ requirements, especially robustness in the presence of\n  communication unreliability\
    \ and availability in the presence of\n  congestion, but many of these problems\
    \ are found in the civilian and\n  government sector as well.\n  As strategic\
    \ and tactical computer communication networks are\n  developed and deployed,\
    \ it is essential to provide means of\n  interconnecting them and to provide standard\
    \ interprocess\n  communication protocols which can support a broad range of\n\
    \  applications.  In anticipation of the need for such standards, the\n  Deputy\
    \ Undersecretary of Defense for Research and Engineering has\n  declared the Transmission\
    \ Control Protocol (TCP) described herein to\n  be a basis for DoD-wide inter-process\
    \ communication protocol\n  standardization.\n  TCP is a connection-oriented,\
    \ end-to-end reliable protocol designed to\n  fit into a layered hierarchy of\
    \ protocols which support multi-network\n  applications.  The TCP provides for\
    \ reliable inter-process\n  communication between pairs of processes in host computers\
    \ attached to\n  distinct but interconnected computer communication networks.\
    \  Very few\n  assumptions are made as to the reliability of the communication\n\
    \  protocols below the TCP layer.  TCP assumes it can obtain a simple,\n  potentially\
    \ unreliable datagram service from the lower level\n  protocols.  In principle,\
    \ the TCP should be able to operate above a\n  wide spectrum of communication\
    \ systems ranging from hard-wired\n  connections to packet-switched or circuit-switched\
    \ networks.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Introduction
  contents:
  - "Introduction\n  TCP is based on concepts first described by Cerf and Kahn in\
    \ [1].  The\n  TCP fits into a layered protocol architecture just above a basic\n\
    \  Internet Protocol [2] which provides a way for the TCP to send and\n  receive\
    \ variable-length segments of information enclosed in internet\n  datagram \"\
    envelopes\".  The internet datagram provides a means for\n  addressing source\
    \ and destination TCPs in different networks.  The\n  internet protocol also deals\
    \ with any fragmentation or reassembly of\n  the TCP segments required to achieve\
    \ transport and delivery through\n  multiple networks and interconnecting gateways.\
    \  The internet protocol\n  also carries information on the precedence, security\
    \ classification\n  and compartmentation of the TCP segments, so this information\
    \ can be\n  communicated end-to-end across multiple networks.\n              \
    \             Protocol Layering\n                        +---------------------+\n\
    \                        |     higher-level    |\n                        +---------------------+\n\
    \                        |        TCP          |\n                        +---------------------+\n\
    \                        |  internet protocol  |\n                        +---------------------+\n\
    \                        |communication network|\n                        +---------------------+\n\
    \                                Figure 1\n  Much of this document is written\
    \ in the context of TCP implementations\n  which are co-resident with higher level\
    \ protocols in the host\n  computer.  Some computer systems will be connected\
    \ to networks via\n  front-end computers which house the TCP and internet protocol\
    \ layers,\n  as well as network specific software.  The TCP specification describes\n\
    \  an interface to the higher level protocols which appears to be\n  implementable\
    \ even for the front-end case, as long as a suitable\n  host-to-front end protocol\
    \ is implemented.\n"
- title: 1.2.  Scope
  contents:
  - "1.2.  Scope\n  The TCP is intended to provide a reliable process-to-process\n\
    \  communication service in a multinetwork environment.  The TCP is\n  intended\
    \ to be a host-to-host protocol in common use in multiple\n  networks.\n"
- title: 1.3.  About this Document
  contents:
  - "1.3.  About this Document\n  This document represents a specification of the\
    \ behavior required of\n  any TCP implementation, both in its interactions with\
    \ higher level\n  protocols and in its interactions with other TCPs.  The rest\
    \ of this\n                                           Transmission Control Protocol\n\
    \                                                            Introduction\n  section\
    \ offers a very brief view of the protocol interfaces and\n  operation.  Section\
    \ 2 summarizes the philosophical basis for the TCP\n  design.  Section 3 offers\
    \ both a detailed description of the actions\n  required of TCP when various events\
    \ occur (arrival of new segments,\n  user calls, errors, etc.) and the details\
    \ of the formats of TCP\n  segments.\n"
- title: 1.4.  Interfaces
  contents:
  - "1.4.  Interfaces\n  The TCP interfaces on one side to user or application processes\
    \ and on\n  the other side to a lower level protocol such as Internet Protocol.\n\
    \  The interface between an application process and the TCP is\n  illustrated\
    \ in reasonable detail.  This interface consists of a set of\n  calls much like\
    \ the calls an operating system provides to an\n  application process for manipulating\
    \ files.  For example, there are\n  calls to open and close connections and to\
    \ send and receive data on\n  established connections.  It is also expected that\
    \ the TCP can\n  asynchronously communicate with application programs.  Although\n\
    \  considerable freedom is permitted to TCP implementors to design\n  interfaces\
    \ which are appropriate to a particular operating system\n  environment, a minimum\
    \ functionality is required at the TCP/user\n  interface for any valid implementation.\n\
    \  The interface between TCP and lower level protocol is essentially\n  unspecified\
    \ except that it is assumed there is a mechanism whereby the\n  two levels can\
    \ asynchronously pass information to each other.\n  Typically, one expects the\
    \ lower level protocol to specify this\n  interface.  TCP is designed to work\
    \ in a very general environment of\n  interconnected networks.  The lower level\
    \ protocol which is assumed\n  throughout this document is the Internet Protocol\
    \ [2].\n"
- title: 1.5.  Operation
  contents:
  - "1.5.  Operation\n  As noted above, the primary purpose of the TCP is to provide\
    \ reliable,\n  securable logical circuit or connection service between pairs of\n\
    \  processes.  To provide this service on top of a less reliable internet\n  communication\
    \ system requires facilities in the following areas:\n    Basic Data Transfer\n\
    \    Reliability\n    Flow Control\n    Multiplexing\n    Connections\n    Precedence\
    \ and Security\n  The basic operation of the TCP in each of these areas is described\
    \ in\n  the following paragraphs.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Introduction
  contents:
  - "Introduction\n  Basic Data Transfer:\n    The TCP is able to transfer a continuous\
    \ stream of octets in each\n    direction between its users by packaging some\
    \ number of octets into\n    segments for transmission through the internet system.\
    \  In general,\n    the TCPs decide when to block and forward data at their own\n\
    \    convenience.\n    Sometimes users need to be sure that all the data they\
    \ have\n    submitted to the TCP has been transmitted.  For this purpose a push\n\
    \    function is defined.  To assure that data submitted to a TCP is\n    actually\
    \ transmitted the sending user indicates that it should be\n    pushed through\
    \ to the receiving user.  A push causes the TCPs to\n    promptly forward and\
    \ deliver data up to that point to the receiver.\n    The exact push point might\
    \ not be visible to the receiving user and\n    the push function does not supply\
    \ a record boundary marker.\n  Reliability:\n    The TCP must recover from data\
    \ that is damaged, lost, duplicated, or\n    delivered out of order by the internet\
    \ communication system.  This\n    is achieved by assigning a sequence number\
    \ to each octet\n    transmitted, and requiring a positive acknowledgment (ACK)\
    \ from the\n    receiving TCP.  If the ACK is not received within a timeout\n\
    \    interval, the data is retransmitted.  At the receiver, the sequence\n   \
    \ numbers are used to correctly order segments that may be received\n    out of\
    \ order and to eliminate duplicates.  Damage is handled by\n    adding a checksum\
    \ to each segment transmitted, checking it at the\n    receiver, and discarding\
    \ damaged segments.\n    As long as the TCPs continue to function properly and\
    \ the internet\n    system does not become completely partitioned, no transmission\n\
    \    errors will affect the correct delivery of data.  TCP recovers from\n   \
    \ internet communication system errors.\n  Flow Control:\n    TCP provides a means\
    \ for the receiver to govern the amount of data\n    sent by the sender.  This\
    \ is achieved by returning a \"window\" with\n    every ACK indicating a range\
    \ of acceptable sequence numbers beyond\n    the last segment successfully received.\
    \  The window indicates an\n    allowed number of octets that the sender may transmit\
    \ before\n    receiving further permission.\n                                \
    \           Transmission Control Protocol\n                                  \
    \                          Introduction\n  Multiplexing:\n    To allow for many\
    \ processes within a single Host to use TCP\n    communication facilities simultaneously,\
    \ the TCP provides a set of\n    addresses or ports within each host.  Concatenated\
    \ with the network\n    and host addresses from the internet communication layer,\
    \ this forms\n    a socket.  A pair of sockets uniquely identifies each connection.\n\
    \    That is, a socket may be simultaneously used in multiple\n    connections.\n\
    \    The binding of ports to processes is handled independently by each\n    Host.\
    \  However, it proves useful to attach frequently used processes\n    (e.g., a\
    \ \"logger\" or timesharing service) to fixed sockets which are\n    made known\
    \ to the public.  These services can then be accessed\n    through the known addresses.\
    \  Establishing and learning the port\n    addresses of other processes may involve\
    \ more dynamic mechanisms.\n  Connections:\n    The reliability and flow control\
    \ mechanisms described above require\n    that TCPs initialize and maintain certain\
    \ status information for\n    each data stream.  The combination of this information,\
    \ including\n    sockets, sequence numbers, and window sizes, is called a connection.\n\
    \    Each connection is uniquely specified by a pair of sockets\n    identifying\
    \ its two sides.\n    When two processes wish to communicate, their TCP's must\
    \ first\n    establish a connection (initialize the status information on each\n\
    \    side).  When their communication is complete, the connection is\n    terminated\
    \ or closed to free the resources for other uses.\n    Since connections must\
    \ be established between unreliable hosts and\n    over the unreliable internet\
    \ communication system, a handshake\n    mechanism with clock-based sequence numbers\
    \ is used to avoid\n    erroneous initialization of connections.\n  Precedence\
    \ and Security:\n    The users of TCP may indicate the security and precedence\
    \ of their\n    communication.  Provision is made for default values to be used\
    \ when\n    these features are not needed.\n"
- title: Transmission Control Protocol
  contents:
  - "Transmission Control Protocol\n                                           Transmission\
    \ Control Protocol\n                             2.  PHILOSOPHY\n"
- title: 2.1.  Elements of the Internetwork System
  contents:
  - "2.1.  Elements of the Internetwork System\n  The internetwork environment consists\
    \ of hosts connected to networks\n  which are in turn interconnected via gateways.\
    \  It is assumed here\n  that the networks may be either local networks (e.g.,\
    \ the ETHERNET) or\n  large networks (e.g., the ARPANET), but in any case are\
    \ based on\n  packet switching technology.  The active agents that produce and\n\
    \  consume messages are processes.  Various levels of protocols in the\n  networks,\
    \ the gateways, and the hosts support an interprocess\n  communication system\
    \ that provides two-way data flow on logical\n  connections between process ports.\n\
    \  The term packet is used generically here to mean the data of one\n  transaction\
    \ between a host and its network.  The format of data blocks\n  exchanged within\
    \ the a network will generally not be of concern to us.\n  Hosts are computers\
    \ attached to a network, and from the communication\n  network's point of view,\
    \ are the sources and destinations of packets.\n  Processes are viewed as the\
    \ active elements in host computers (in\n  accordance with the fairly common definition\
    \ of a process as a program\n  in execution).  Even terminals and files or other\
    \ I/O devices are\n  viewed as communicating with each other through the use of\
    \ processes.\n  Thus, all communication is viewed as inter-process communication.\n\
    \  Since a process may need to distinguish among several communication\n  streams\
    \ between itself and another process (or processes), we imagine\n  that each process\
    \ may have a number of ports through which it\n  communicates with the ports of\
    \ other processes.\n"
- title: 2.2.  Model of Operation
  contents:
  - "2.2.  Model of Operation\n  Processes transmit data by calling on the TCP and\
    \ passing buffers of\n  data as arguments.  The TCP packages the data from these\
    \ buffers into\n  segments and calls on the internet module to transmit each segment\
    \ to\n  the destination TCP.  The receiving TCP places the data from a segment\n\
    \  into the receiving user's buffer and notifies the receiving user.  The\n  TCPs\
    \ include control information in the segments which they use to\n  ensure reliable\
    \ ordered data transmission.\n  The model of internet communication is that there\
    \ is an internet\n  protocol module associated with each TCP which provides an\
    \ interface\n  to the local network.  This internet module packages TCP segments\n\
    \  inside internet datagrams and routes these datagrams to a destination\n  internet\
    \ module or intermediate gateway.  To transmit the datagram\n  through the local\
    \ network, it is embedded in a local network packet.\n  The packet switches may\
    \ perform further packaging, fragmentation, or\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Philosophy
  contents:
  - "Philosophy\n  other operations to achieve the delivery of the local packet to\
    \ the\n  destination internet module.\n  At a gateway between networks, the internet\
    \ datagram is \"unwrapped\"\n  from its local packet and examined to determine\
    \ through which network\n  the internet datagram should travel next.  The internet\
    \ datagram is\n  then \"wrapped\" in a local packet suitable to the next network\
    \ and\n  routed to the next gateway, or to the final destination.\n  A gateway\
    \ is permitted to break up an internet datagram into smaller\n  internet datagram\
    \ fragments if this is necessary for transmission\n  through the next network.\
    \  To do this, the gateway produces a set of\n  internet datagrams; each carrying\
    \ a fragment.  Fragments may be\n  further broken into smaller fragments at subsequent\
    \ gateways.  The\n  internet datagram fragment format is designed so that the\
    \ destination\n  internet module can reassemble fragments into internet datagrams.\n\
    \  A destination internet module unwraps the segment from the datagram\n  (after\
    \ reassembling the datagram, if necessary) and passes it to the\n  destination\
    \ TCP.\n  This simple model of the operation glosses over many details.  One\n\
    \  important feature is the type of service.  This provides information\n  to\
    \ the gateway (or internet module) to guide it in selecting the\n  service parameters\
    \ to be used in traversing the next network.\n  Included in the type of service\
    \ information is the precedence of the\n  datagram.  Datagrams may also carry\
    \ security information to permit\n  host and gateways that operate in multilevel\
    \ secure environments to\n  properly segregate datagrams for security considerations.\n"
- title: 2.3.  The Host Environment
  contents:
  - "2.3.  The Host Environment\n  The TCP is assumed to be a module in an operating\
    \ system.  The users\n  access the TCP much like they would access the file system.\
    \  The TCP\n  may call on other operating system functions, for example, to manage\n\
    \  data structures.  The actual interface to the network is assumed to be\n  controlled\
    \ by a device driver module.  The TCP does not call on the\n  network device driver\
    \ directly, but rather calls on the internet\n  datagram protocol module which\
    \ may in turn call on the device driver.\n  The mechanisms of TCP do not preclude\
    \ implementation of the TCP in a\n  front-end processor.  However, in such an\
    \ implementation, a\n  host-to-front-end protocol must provide the functionality\
    \ to support\n  the type of TCP-user interface described in this document.\n \
    \                                          Transmission Control Protocol\n   \
    \                                                           Philosophy\n"
- title: 2.4.  Interfaces
  contents:
  - "2.4.  Interfaces\n  The TCP/user interface provides for calls made by the user\
    \ on the TCP\n  to OPEN or CLOSE a connection, to SEND or RECEIVE data, or to\
    \ obtain\n  STATUS about a connection.  These calls are like other calls from\
    \ user\n  programs on the operating system, for example, the calls to open, read\n\
    \  from, and close a file.\n  The TCP/internet interface provides calls to send\
    \ and receive\n  datagrams addressed to TCP modules in hosts anywhere in the internet\n\
    \  system.  These calls have parameters for passing the address, type of\n  service,\
    \ precedence, security, and other control information.\n"
- title: 2.5.  Relation to Other Protocols
  contents:
  - "2.5.  Relation to Other Protocols\n  The following diagram illustrates the place\
    \ of the TCP in the protocol\n  hierarchy:\n       +------+ +-----+ +-----+  \
    \     +-----+                    \n       |Telnet| | FTP | |Voice|  ...  |   \
    \  |  Application Level \n       +------+ +-----+ +-----+       +-----+      \
    \              \n             |   |         |             |                  \
    \     \n            +-----+     +-----+       +-----+                    \n  \
    \          | TCP |     | RTP |  ...  |     |  Host Level        \n           \
    \ +-----+     +-----+       +-----+                    \n               |    \
    \       |             |                       \n            +-------------------------------+\
    \                    \n            |    Internet Protocol & ICMP   |  Gateway\
    \ Level     \n            +-------------------------------+                  \
    \  \n                           |                                     \n     \
    \         +---------------------------+                      \n              |\
    \   Local Network Protocol  |    Network Level     \n              +---------------------------+\
    \                      \n                         Protocol Relationships\n   \
    \                            Figure 2.\n  It is expected that the TCP will be\
    \ able to support higher level\n  protocols efficiently.  It should be easy to\
    \ interface higher level\n  protocols like the ARPANET Telnet or AUTODIN II THP\
    \ to the TCP.\n"
- title: 2.6.  Reliable Communication
  contents:
  - "2.6.  Reliable Communication\n  A stream of data sent on a TCP connection is\
    \ delivered reliably and in\n  order at the destination.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Philosophy
  contents:
  - "Philosophy\n  Transmission is made reliable via the use of sequence numbers and\n\
    \  acknowledgments.  Conceptually, each octet of data is assigned a\n  sequence\
    \ number.  The sequence number of the first octet of data in a\n  segment is transmitted\
    \ with that segment and is called the segment\n  sequence number.  Segments also\
    \ carry an acknowledgment number which\n  is the sequence number of the next expected\
    \ data octet of\n  transmissions in the reverse direction.  When the TCP transmits\
    \ a\n  segment containing data, it puts a copy on a retransmission queue and\n\
    \  starts a timer; when the acknowledgment for that data is received, the\n  segment\
    \ is deleted from the queue.  If the acknowledgment is not\n  received before\
    \ the timer runs out, the segment is retransmitted.\n  An acknowledgment by TCP\
    \ does not guarantee that the data has been\n  delivered to the end user, but\
    \ only that the receiving TCP has taken\n  the responsibility to do so.\n  To\
    \ govern the flow of data between TCPs, a flow control mechanism is\n  employed.\
    \  The receiving TCP reports a \"window\" to the sending TCP.\n  This window specifies\
    \ the number of octets, starting with the\n  acknowledgment number, that the receiving\
    \ TCP is currently prepared to\n  receive.\n"
- title: 2.7.  Connection Establishment and Clearing
  contents:
  - "2.7.  Connection Establishment and Clearing\n  To identify the separate data\
    \ streams that a TCP may handle, the TCP\n  provides a port identifier.  Since\
    \ port identifiers are selected\n  independently by each TCP they might not be\
    \ unique.  To provide for\n  unique addresses within each TCP, we concatenate\
    \ an internet address\n  identifying the TCP with a port identifier to create\
    \ a socket which\n  will be unique throughout all networks connected together.\n\
    \  A connection is fully specified by the pair of sockets at the ends.  A\n  local\
    \ socket may participate in many connections to different foreign\n  sockets.\
    \  A connection can be used to carry data in both directions,\n  that is, it is\
    \ \"full duplex\".\n  TCPs are free to associate ports with processes however\
    \ they choose.\n  However, several basic concepts are necessary in any implementation.\n\
    \  There must be well-known sockets which the TCP associates only with\n  the\
    \ \"appropriate\" processes by some means.  We envision that processes\n  may\
    \ \"own\" ports, and that processes can initiate connections only on\n  the ports\
    \ they own.  (Means for implementing ownership is a local\n  issue, but we envision\
    \ a Request Port user command, or a method of\n  uniquely allocating a group of\
    \ ports to a given process, e.g., by\n  associating the high order bits of a port\
    \ name with a given process.)\n  A connection is specified in the OPEN call by\
    \ the local port and\n  foreign socket arguments.  In return, the TCP supplies\
    \ a (short) local\n                                           Transmission Control\
    \ Protocol\n                                                              Philosophy\n\
    \  connection name by which the user refers to the connection in\n  subsequent\
    \ calls.  There are several things that must be remembered\n  about a connection.\
    \  To store this information we imagine that there\n  is a data structure called\
    \ a Transmission Control Block (TCB).  One\n  implementation strategy would have\
    \ the local connection name be a\n  pointer to the TCB for this connection.  The\
    \ OPEN call also specifies\n  whether the connection establishment is to be actively\
    \ pursued, or to\n  be passively waited for.\n  A passive OPEN request means that\
    \ the process wants to accept incoming\n  connection requests rather than attempting\
    \ to initiate a connection.\n  Often the process requesting a passive OPEN will\
    \ accept a connection\n  request from any caller.  In this case a foreign socket\
    \ of all zeros\n  is used to denote an unspecified socket.  Unspecified foreign\
    \ sockets\n  are allowed only on passive OPENs.\n  A service process that wished\
    \ to provide services for unknown other\n  processes would issue a passive OPEN\
    \ request with an unspecified\n  foreign socket.  Then a connection could be made\
    \ with any process that\n  requested a connection to this local socket.  It would\
    \ help if this\n  local socket were known to be associated with this service.\n\
    \  Well-known sockets are a convenient mechanism for a priori associating\n  a\
    \ socket address with a standard service.  For instance, the\n  \"Telnet-Server\"\
    \ process is permanently assigned to a particular\n  socket, and other sockets\
    \ are reserved for File Transfer, Remote Job\n  Entry, Text Generator, Echoer,\
    \ and Sink processes (the last three\n  being for test purposes).  A socket address\
    \ might be reserved for\n  access to a \"Look-Up\" service which would return\
    \ the specific socket\n  at which a newly created service would be provided. \
    \ The concept of a\n  well-known socket is part of the TCP specification, but\
    \ the assignment\n  of sockets to services is outside this specification.  (See\
    \ [4].)\n  Processes can issue passive OPENs and wait for matching active OPENs\n\
    \  from other processes and be informed by the TCP when connections have\n  been\
    \ established.  Two processes which issue active OPENs to each\n  other at the\
    \ same time will be correctly connected.  This flexibility\n  is critical for\
    \ the support of distributed computing in which\n  components act asynchronously\
    \ with respect to each other.\n  There are two principal cases for matching the\
    \ sockets in the local\n  passive OPENs and an foreign active OPENs.  In the first\
    \ case, the\n  local passive OPENs has fully specified the foreign socket.  In\
    \ this\n  case, the match must be exact.  In the second case, the local passive\n\
    \  OPENs has left the foreign socket unspecified.  In this case, any\n  foreign\
    \ socket is acceptable as long as the local sockets match.\n  Other possibilities\
    \ include partially restricted matches.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Philosophy
  contents:
  - "Philosophy\n  If there are several pending passive OPENs (recorded in TCBs) with\
    \ the\n  same local socket, an foreign active OPEN will be matched to a TCB\n\
    \  with the specific foreign socket in the foreign active OPEN, if such a\n  TCB\
    \ exists, before selecting a TCB with an unspecified foreign socket.\n  The procedures\
    \ to establish connections utilize the synchronize (SYN)\n  control flag and involves\
    \ an exchange of three messages.  This\n  exchange has been termed a three-way\
    \ hand shake [3].\n  A connection is initiated by the rendezvous of an arriving\
    \ segment\n  containing a SYN and a waiting TCB entry each created by a user OPEN\n\
    \  command.  The matching of local and foreign sockets determines when a\n  connection\
    \ has been initiated.  The connection becomes \"established\"\n  when sequence\
    \ numbers have been synchronized in both directions.\n  The clearing of a connection\
    \ also involves the exchange of segments,\n  in this case carrying the FIN control\
    \ flag.\n"
- title: 2.8.  Data Communication
  contents:
  - "2.8.  Data Communication\n  The data that flows on a connection may be thought\
    \ of as a stream of\n  octets.  The sending user indicates in each SEND call whether\
    \ the data\n  in that call (and any preceeding calls) should be immediately pushed\n\
    \  through to the receiving user by the setting of the PUSH flag.\n  A sending\
    \ TCP is allowed to collect data from the sending user and to\n  send that data\
    \ in segments at its own convenience, until the push\n  function is signaled,\
    \ then it must send all unsent data.  When a\n  receiving TCP sees the PUSH flag,\
    \ it must not wait for more data from\n  the sending TCP before passing the data\
    \ to the receiving process.\n  There is no necessary relationship between push\
    \ functions and segment\n  boundaries.  The data in any particular segment may\
    \ be the result of a\n  single SEND call, in whole or part, or of multiple SEND\
    \ calls.\n  The purpose of push function and the PUSH flag is to push data through\n\
    \  from the sending user to the receiving user.  It does not provide a\n  record\
    \ service.\n  There is a coupling between the push function and the use of buffers\n\
    \  of data that cross the TCP/user interface.  Each time a PUSH flag is\n  associated\
    \ with data placed into the receiving user's buffer, the\n  buffer is returned\
    \ to the user for processing even if the buffer is\n  not filled.  If data arrives\
    \ that fills the user's buffer before a\n  PUSH is seen, the data is passed to\
    \ the user in buffer size units.\n  TCP also provides a means to communicate to\
    \ the receiver of data that\n  at some point further along in the data stream\
    \ than the receiver is\n                                           Transmission\
    \ Control Protocol\n                                                         \
    \     Philosophy\n  currently reading there is urgent data.  TCP does not attempt\
    \ to\n  define what the user specifically does upon being notified of pending\n\
    \  urgent data, but the general notion is that the receiving process will\n  take\
    \ action to process the urgent data quickly.\n"
- title: 2.9.  Precedence and Security
  contents:
  - "2.9.  Precedence and Security\n  The TCP makes use of the internet protocol type\
    \ of service field and\n  security option to provide precedence and security on\
    \ a per connection\n  basis to TCP users.  Not all TCP modules will necessarily\
    \ function in\n  a multilevel secure environment; some may be limited to unclassified\n\
    \  use only, and others may operate at only one security level and\n  compartment.\
    \  Consequently, some TCP implementations and services to\n  users may be limited\
    \ to a subset of the multilevel secure case.\n  TCP modules which operate in a\
    \ multilevel secure environment must\n  properly mark outgoing segments with the\
    \ security, compartment, and\n  precedence.  Such TCP modules must also provide\
    \ to their users or\n  higher level protocols such as Telnet or THP an interface\
    \ to allow\n  them to specify the desired security level, compartment, and\n \
    \ precedence of connections.\n"
- title: 2.10.  Robustness Principle
  contents:
  - "2.10.  Robustness Principle\n  TCP implementations will follow a general principle\
    \ of robustness:  be\n  conservative in what you do, be liberal in what you accept\
    \ from\n  others.\n"
- title: Transmission Control Protocol
  contents:
  - "Transmission Control Protocol\n                                           Transmission\
    \ Control Protocol\n                      3.  FUNCTIONAL SPECIFICATION\n"
- title: 3.1.  Header Format
  contents:
  - "3.1.  Header Format\n  TCP segments are sent as internet datagrams.  The Internet\
    \ Protocol\n  header carries several information fields, including the source\
    \ and\n  destination host addresses [2].  A TCP header follows the internet\n\
    \  header, supplying information specific to the TCP protocol.  This\n  division\
    \ allows for the existence of host level protocols other than\n  TCP.\n  TCP Header\
    \ Format\n    0                   1                   2                   3  \
    \ \n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Source Port          |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Acknowledgment Number                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Data |           |U|A|P|R|S|F|                               |\n   | Offset|\
    \ Reserved  |R|C|S|S|Y|I|            Window             |\n   |       |      \
    \     |G|K|H|T|N|N|                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Checksum            |         Urgent Pointer        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                            TCP Header Format\n          Note that one tick mark\
    \ represents one bit position.\n                               Figure 3.\n  Source\
    \ Port:  16 bits\n    The source port number.\n  Destination Port:  16 bits\n\
    \    The destination port number.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  Sequence Number:  32 bits\n    The sequence number\
    \ of the first data octet in this segment (except\n    when SYN is present). If\
    \ SYN is present the sequence number is the\n    initial sequence number (ISN)\
    \ and the first data octet is ISN+1.\n  Acknowledgment Number:  32 bits\n    If\
    \ the ACK control bit is set this field contains the value of the\n    next sequence\
    \ number the sender of the segment is expecting to\n    receive.  Once a connection\
    \ is established this is always sent.\n  Data Offset:  4 bits\n    The number\
    \ of 32 bit words in the TCP Header.  This indicates where\n    the data begins.\
    \  The TCP header (even one including options) is an\n    integral number of 32\
    \ bits long.\n  Reserved:  6 bits\n    Reserved for future use.  Must be zero.\n\
    \  Control Bits:  6 bits (from left to right):\n    URG:  Urgent Pointer field\
    \ significant\n    ACK:  Acknowledgment field significant\n    PSH:  Push Function\n\
    \    RST:  Reset the connection\n    SYN:  Synchronize sequence numbers\n    FIN:\
    \  No more data from sender\n  Window:  16 bits\n    The number of data octets\
    \ beginning with the one indicated in the\n    acknowledgment field which the\
    \ sender of this segment is willing to\n    accept.\n  Checksum:  16 bits\n  \
    \  The checksum field is the 16 bit one's complement of the one's\n    complement\
    \ sum of all 16 bit words in the header and text.  If a\n    segment contains\
    \ an odd number of header and text octets to be\n    checksummed, the last octet\
    \ is padded on the right with zeros to\n    form a 16 bit word for checksum purposes.\
    \  The pad is not\n    transmitted as part of the segment.  While computing the\
    \ checksum,\n    the checksum field itself is replaced with zeros.\n    The checksum\
    \ also covers a 96 bit pseudo header conceptually\n                          \
    \                 Transmission Control Protocol\n                            \
    \                    Functional Specification\n    prefixed to the TCP header.\
    \  This pseudo header contains the Source\n    Address, the Destination Address,\
    \ the Protocol, and TCP length.\n    This gives the TCP protection against misrouted\
    \ segments.  This\n    information is carried in the Internet Protocol and is\
    \ transferred\n    across the TCP/Network interface in the arguments or results\
    \ of\n    calls by the TCP on the IP.\n                     +--------+--------+--------+--------+\n\
    \                     |           Source Address          |\n                \
    \     +--------+--------+--------+--------+\n                     |         Destination\
    \ Address       |\n                     +--------+--------+--------+--------+\n\
    \                     |  zero  |  PTCL  |    TCP Length   |\n                \
    \     +--------+--------+--------+--------+\n      The TCP Length is the TCP header\
    \ length plus the data length in\n      octets (this is not an explicitly transmitted\
    \ quantity, but is\n      computed), and it does not count the 12 octets of the\
    \ pseudo\n      header.\n  Urgent Pointer:  16 bits\n    This field communicates\
    \ the current value of the urgent pointer as a\n    positive offset from the sequence\
    \ number in this segment.  The\n    urgent pointer points to the sequence number\
    \ of the octet following\n    the urgent data.  This field is only be interpreted\
    \ in segments with\n    the URG control bit set.\n  Options:  variable\n    Options\
    \ may occupy space at the end of the TCP header and are a\n    multiple of 8 bits\
    \ in length.  All options are included in the\n    checksum.  An option may begin\
    \ on any octet boundary.  There are two\n    cases for the format of an option:\n\
    \      Case 1:  A single octet of option-kind.\n      Case 2:  An octet of option-kind,\
    \ an octet of option-length, and\n               the actual option-data octets.\n\
    \    The option-length counts the two octets of option-kind and\n    option-length\
    \ as well as the option-data octets.\n    Note that the list of options may be\
    \ shorter than the data offset\n    field might imply.  The content of the header\
    \ beyond the\n    End-of-Option option must be header padding (i.e., zero).\n\
    \    A TCP must implement all options.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n    Currently defined options include (kind indicated\
    \ in octal):\n      Kind     Length    Meaning\n      ----     ------    -------\n\
    \       0         -       End of option list.\n       1         -       No-Operation.\n\
    \       2         4       Maximum Segment Size.\n    Specific Option Definitions\n\
    \      End of Option List\n        +--------+\n        |00000000|\n        +--------+\n\
    \         Kind=0\n        This option code indicates the end of the option list.\
    \  This\n        might not coincide with the end of the TCP header according to\n\
    \        the Data Offset field.  This is used at the end of all options,\n   \
    \     not the end of each option, and need only be used if the end of\n      \
    \  the options would not otherwise coincide with the end of the TCP\n        header.\n\
    \      No-Operation\n        +--------+\n        |00000001|\n        +--------+\n\
    \         Kind=1\n        This option code may be used between options, for example,\
    \ to\n        align the beginning of a subsequent option on a word boundary.\n\
    \        There is no guarantee that senders will use this option, so\n       \
    \ receivers must be prepared to process options even if they do\n        not begin\
    \ on a word boundary.\n      Maximum Segment Size\n        +--------+--------+---------+--------+\n\
    \        |00000010|00000100|   max seg size   |\n        +--------+--------+---------+--------+\n\
    \         Kind=2   Length=4\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n        Maximum Segment Size Option Data:  16 bits\n        \
    \  If this option is present, then it communicates the maximum\n          receive\
    \ segment size at the TCP which sends this segment.\n          This field must\
    \ only be sent in the initial connection request\n          (i.e., in segments\
    \ with the SYN control bit set).  If this\n          option is not used, any segment\
    \ size is allowed.\n  Padding:  variable\n    The TCP header padding is used to\
    \ ensure that the TCP header ends\n    and data begins on a 32 bit boundary. \
    \ The padding is composed of\n    zeros.\n"
- title: 3.2.  Terminology
  contents:
  - "3.2.  Terminology\n  Before we can discuss very much about the operation of the\
    \ TCP we need\n  to introduce some detailed terminology.  The maintenance of a\
    \ TCP\n  connection requires the remembering of several variables.  We conceive\n\
    \  of these variables being stored in a connection record called a\n  Transmission\
    \ Control Block or TCB.  Among the variables stored in the\n  TCB are the local\
    \ and remote socket numbers, the security and\n  precedence of the connection,\
    \ pointers to the user's send and receive\n  buffers, pointers to the retransmit\
    \ queue and to the current segment.\n  In addition several variables relating\
    \ to the send and receive\n  sequence numbers are stored in the TCB.\n    Send\
    \ Sequence Variables\n      SND.UNA - send unacknowledged\n      SND.NXT - send\
    \ next\n      SND.WND - send window\n      SND.UP  - send urgent pointer\n   \
    \   SND.WL1 - segment sequence number used for last window update\n      SND.WL2\
    \ - segment acknowledgment number used for last window\n                update\n\
    \      ISS     - initial send sequence number\n    Receive Sequence Variables\n\
    \      RCV.NXT - receive next\n      RCV.WND - receive window\n      RCV.UP  -\
    \ receive urgent pointer\n      IRS     - initial receive sequence number\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  The following diagrams may help to relate some of\
    \ these variables to\n  the sequence space.\n  Send Sequence Space\n         \
    \          1         2          3          4      \n              ----------|----------|----------|----------\
    \ \n                     SND.UNA    SND.NXT    SND.UNA        \n             \
    \                             +SND.WND        \n        1 - old sequence numbers\
    \ which have been acknowledged  \n        2 - sequence numbers of unacknowledged\
    \ data            \n        3 - sequence numbers allowed for new data transmission\
    \ \n        4 - future sequence numbers which are not yet allowed  \n        \
    \                  Send Sequence Space\n                               Figure\
    \ 4.\n  The send window is the portion of the sequence space labeled 3 in\n  figure\
    \ 4.\n  Receive Sequence Space\n                       1          2          3\
    \      \n                   ----------|----------|---------- \n              \
    \            RCV.NXT    RCV.NXT        \n                                    +RCV.WND\
    \        \n        1 - old sequence numbers which have been acknowledged  \n \
    \       2 - sequence numbers allowed for new reception         \n        3 - future\
    \ sequence numbers which are not yet allowed  \n                         Receive\
    \ Sequence Space\n                               Figure 5.\n  The receive window\
    \ is the portion of the sequence space labeled 2 in\n  figure 5.\n  There are\
    \ also some variables used frequently in the discussion that\n  take their values\
    \ from the fields of the current segment.\n                                  \
    \         Transmission Control Protocol\n                                    \
    \            Functional Specification\n    Current Segment Variables\n      SEG.SEQ\
    \ - segment sequence number\n      SEG.ACK - segment acknowledgment number\n \
    \     SEG.LEN - segment length\n      SEG.WND - segment window\n      SEG.UP \
    \ - segment urgent pointer\n      SEG.PRC - segment precedence value\n  A connection\
    \ progresses through a series of states during its\n  lifetime.  The states are:\
    \  LISTEN, SYN-SENT, SYN-RECEIVED,\n  ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT,\
    \ CLOSING, LAST-ACK,\n  TIME-WAIT, and the fictional state CLOSED.  CLOSED is\
    \ fictional\n  because it represents the state when there is no TCB, and therefore,\n\
    \  no connection.  Briefly the meanings of the states are:\n    LISTEN - represents\
    \ waiting for a connection request from any remote\n    TCP and port.\n    SYN-SENT\
    \ - represents waiting for a matching connection request\n    after having sent\
    \ a connection request.\n    SYN-RECEIVED - represents waiting for a confirming\
    \ connection\n    request acknowledgment after having both received and sent a\n\
    \    connection request.\n    ESTABLISHED - represents an open connection, data\
    \ received can be\n    delivered to the user.  The normal state for the data transfer\
    \ phase\n    of the connection.\n    FIN-WAIT-1 - represents waiting for a connection\
    \ termination request\n    from the remote TCP, or an acknowledgment of the connection\n\
    \    termination request previously sent.\n    FIN-WAIT-2 - represents waiting\
    \ for a connection termination request\n    from the remote TCP.\n    CLOSE-WAIT\
    \ - represents waiting for a connection termination request\n    from the local\
    \ user.\n    CLOSING - represents waiting for a connection termination request\n\
    \    acknowledgment from the remote TCP.\n    LAST-ACK - represents waiting for\
    \ an acknowledgment of the\n    connection termination request previously sent\
    \ to the remote TCP\n    (which includes an acknowledgment of its connection termination\n\
    \    request).\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n    TIME-WAIT - represents waiting for enough time\
    \ to pass to be sure\n    the remote TCP received the acknowledgment of its connection\n\
    \    termination request.\n    CLOSED - represents no connection state at all.\n\
    \  A TCP connection progresses from one state to another in response to\n  events.\
    \  The events are the user calls, OPEN, SEND, RECEIVE, CLOSE,\n  ABORT, and STATUS;\
    \ the incoming segments, particularly those\n  containing the SYN, ACK, RST and\
    \ FIN flags; and timeouts.\n  The state diagram in figure 6 illustrates only state\
    \ changes, together\n  with the causing events and resulting actions, but addresses\
    \ neither\n  error conditions nor actions which are not connected with state\n\
    \  changes.  In a later section, more detail is offered with respect to\n  the\
    \ reaction of the TCP to events.\n  NOTE BENE:  this diagram is only a summary\
    \ and must not be taken as\n  the total specification.\n                     \
    \                      Transmission Control Protocol\n                       \
    \                         Functional Specification\n                         \
    \     +---------+ ---------\\      active OPEN  \n                           \
    \   |  CLOSED |            \\    -----------  \n                             \
    \ +---------+<---------\\   \\   create TCB  \n                              \
    \  |     ^              \\   \\  snd SYN    \n                   passive OPEN\
    \ |     |   CLOSE        \\   \\           \n                   ------------ |\
    \     | ----------       \\   \\         \n                    create TCB  | \
    \    | delete TCB         \\   \\       \n                                V  \
    \   |                      \\   \\     \n                              +---------+\
    \            CLOSE    |    \\   \n                              |  LISTEN |  \
    \        ---------- |     |  \n                              +---------+     \
    \     delete TCB |     |  \n                   rcv SYN      |     |     SEND \
    \             |     |  \n                  -----------   |     |    -------  \
    \          |     V  \n +---------+      snd SYN,ACK  /       \\   snd SYN    \
    \      +---------+\n |         |<-----------------           ------------------>|\
    \         |\n |   SYN   |                    rcv SYN                     |   SYN\
    \   |\n |   RCVD  |<-----------------------------------------------|   SENT  |\n\
    \ |         |                    snd ACK                     |         |\n | \
    \        |------------------           -------------------|         |\n +---------+\
    \   rcv ACK of SYN  \\       /  rcv SYN,ACK       +---------+\n   |          \
    \ --------------   |     |   -----------                  \n   |             \
    \     x         |     |     snd ACK                    \n   |                \
    \            V     V                                \n   |  CLOSE            \
    \       +---------+                              \n   | -------              \
    \    |  ESTAB  |                              \n   | snd FIN                 \
    \ +---------+                              \n   |                   CLOSE    |\
    \     |    rcv FIN                     \n   V                  -------   |   \
    \  |    -------                     \n +---------+          snd FIN  /       \\\
    \   snd ACK          +---------+\n |  FIN    |<-----------------           ------------------>|\
    \  CLOSE  |\n | WAIT-1  |------------------                              |   WAIT\
    \  |\n +---------+          rcv FIN  \\                            +---------+\n\
    \   | rcv ACK of FIN   -------   |                            CLOSE  |  \n   |\
    \ --------------   snd ACK   |                           ------- |  \n   V   \
    \     x                   V                           snd FIN V  \n +---------+\
    \                  +---------+                   +---------+\n |FINWAIT-2|   \
    \               | CLOSING |                   | LAST-ACK|\n +---------+      \
    \            +---------+                   +---------+\n   |                rcv\
    \ ACK of FIN |                 rcv ACK of FIN |  \n   |  rcv FIN       --------------\
    \ |    Timeout=2MSL -------------- |  \n   |  -------              x       V \
    \   ------------        x       V  \n    \\ snd ACK                 +---------+delete\
    \ TCB         +---------+\n     ------------------------>|TIME WAIT|------------------>|\
    \ CLOSED  |\n                              +---------+                   +---------+\n\
    \                      TCP Connection State Diagram\n                        \
    \       Figure 6.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - 'Functional Specification

    '
- title: 3.3.  Sequence Numbers
  contents:
  - "3.3.  Sequence Numbers\n  A fundamental notion in the design is that every octet\
    \ of data sent\n  over a TCP connection has a sequence number.  Since every octet\
    \ is\n  sequenced, each of them can be acknowledged.  The acknowledgment\n  mechanism\
    \ employed is cumulative so that an acknowledgment of sequence\n  number X indicates\
    \ that all octets up to but not including X have been\n  received.  This mechanism\
    \ allows for straight-forward duplicate\n  detection in the presence of retransmission.\
    \  Numbering of octets\n  within a segment is that the first data octet immediately\
    \ following\n  the header is the lowest numbered, and the following octets are\n\
    \  numbered consecutively.\n  It is essential to remember that the actual sequence\
    \ number space is\n  finite, though very large.  This space ranges from 0 to 2**32\
    \ - 1.\n  Since the space is finite, all arithmetic dealing with sequence\n  numbers\
    \ must be performed modulo 2**32.  This unsigned arithmetic\n  preserves the relationship\
    \ of sequence numbers as they cycle from\n  2**32 - 1 to 0 again.  There are some\
    \ subtleties to computer modulo\n  arithmetic, so great care should be taken in\
    \ programming the\n  comparison of such values.  The symbol \"=<\" means \"less\
    \ than or equal\"\n  (modulo 2**32).\n  The typical kinds of sequence number comparisons\
    \ which the TCP must\n  perform include:\n    (a)  Determining that an acknowledgment\
    \ refers to some sequence\n         number sent but not yet acknowledged.\n  \
    \  (b)  Determining that all sequence numbers occupied by a segment\n        \
    \ have been acknowledged (e.g., to remove the segment from a\n         retransmission\
    \ queue).\n    (c)  Determining that an incoming segment contains sequence numbers\n\
    \         which are expected (i.e., that the segment \"overlaps\" the\n      \
    \   receive window).\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n  In response to sending data the TCP will receive acknowledgments.\
    \  The\n  following comparisons are needed to process the acknowledgments.\n \
    \   SND.UNA = oldest unacknowledged sequence number\n    SND.NXT = next sequence\
    \ number to be sent\n    SEG.ACK = acknowledgment from the receiving TCP (next\
    \ sequence\n              number expected by the receiving TCP)\n    SEG.SEQ =\
    \ first sequence number of a segment\n    SEG.LEN = the number of octets occupied\
    \ by the data in the segment\n              (counting SYN and FIN)\n    SEG.SEQ+SEG.LEN-1\
    \ = last sequence number of a segment\n  A new acknowledgment (called an \"acceptable\
    \ ack\"), is one for which\n  the inequality below holds:\n    SND.UNA < SEG.ACK\
    \ =< SND.NXT\n  A segment on the retransmission queue is fully acknowledged if\
    \ the sum\n  of its sequence number and length is less or equal than the\n  acknowledgment\
    \ value in the incoming segment.\n  When data is received the following comparisons\
    \ are needed:\n    RCV.NXT = next sequence number expected on an incoming segments,\
    \ and\n        is the left or lower edge of the receive window\n    RCV.NXT+RCV.WND-1\
    \ = last sequence number expected on an incoming\n        segment, and is the\
    \ right or upper edge of the receive window\n    SEG.SEQ = first sequence number\
    \ occupied by the incoming segment\n    SEG.SEQ+SEG.LEN-1 = last sequence number\
    \ occupied by the incoming\n        segment\n  A segment is judged to occupy a\
    \ portion of valid receive sequence\n  space if\n    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND\n\
    \  or\n    RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  The first part of this test checks to see if the\
    \ beginning of the\n  segment falls in the window, the second part of the test\
    \ checks to see\n  if the end of the segment falls in the window; if the segment\
    \ passes\n  either part of the test it contains data in the window.\n  Actually,\
    \ it is a little more complicated than this.  Due to zero\n  windows and zero\
    \ length segments, we have four cases for the\n  acceptability of an incoming\
    \ segment:\n    Segment Receive  Test\n    Length  Window\n    ------- -------\
    \  -------------------------------------------\n       0       0     SEG.SEQ =\
    \ RCV.NXT\n       0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND\n      >0\
    \       0     not acceptable\n      >0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND\n\
    \                  or RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND\n  Note that\
    \ when the receive window is zero no segments should be\n  acceptable except ACK\
    \ segments.  Thus, it is be possible for a TCP to\n  maintain a zero receive window\
    \ while transmitting data and receiving\n  ACKs.  However, even when the receive\
    \ window is zero, a TCP must\n  process the RST and URG fields of all incoming\
    \ segments.\n  We have taken advantage of the numbering scheme to protect certain\n\
    \  control information as well.  This is achieved by implicitly including\n  some\
    \ control flags in the sequence space so they can be retransmitted\n  and acknowledged\
    \ without confusion (i.e., one and only one copy of the\n  control will be acted\
    \ upon).  Control information is not physically\n  carried in the segment data\
    \ space.  Consequently, we must adopt rules\n  for implicitly assigning sequence\
    \ numbers to control.  The SYN and FIN\n  are the only controls requiring this\
    \ protection, and these controls\n  are used only at connection opening and closing.\
    \  For sequence number\n  purposes, the SYN is considered to occur before the\
    \ first actual data\n  octet of the segment in which it occurs, while the FIN\
    \ is considered\n  to occur after the last actual data octet in a segment in which\
    \ it\n  occurs.  The segment length (SEG.LEN) includes both data and sequence\n\
    \  space occupying controls.  When a SYN is present then SEG.SEQ is the\n  sequence\
    \ number of the SYN.\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n  Initial Sequence Number Selection\n  The protocol places no\
    \ restriction on a particular connection being\n  used over and over again.  A\
    \ connection is defined by a pair of\n  sockets.  New instances of a connection\
    \ will be referred to as\n  incarnations of the connection.  The problem that\
    \ arises from this is\n  -- \"how does the TCP identify duplicate segments from\
    \ previous\n  incarnations of the connection?\"  This problem becomes apparent\
    \ if the\n  connection is being opened and closed in quick succession, or if the\n\
    \  connection breaks with loss of memory and is then reestablished.\n  To avoid\
    \ confusion we must prevent segments from one incarnation of a\n  connection from\
    \ being used while the same sequence numbers may still\n  be present in the network\
    \ from an earlier incarnation.  We want to\n  assure this, even if a TCP crashes\
    \ and loses all knowledge of the\n  sequence numbers it has been using.  When\
    \ new connections are created,\n  an initial sequence number (ISN) generator is\
    \ employed which selects a\n  new 32 bit ISN.  The generator is bound to a (possibly\
    \ fictitious) 32\n  bit clock whose low order bit is incremented roughly every\
    \ 4\n  microseconds.  Thus, the ISN cycles approximately every 4.55 hours.\n \
    \ Since we assume that segments will stay in the network no more than\n  the Maximum\
    \ Segment Lifetime (MSL) and that the MSL is less than 4.55\n  hours we can reasonably\
    \ assume that ISN's will be unique.\n  For each connection there is a send sequence\
    \ number and a receive\n  sequence number.  The initial send sequence number (ISS)\
    \ is chosen by\n  the data sending TCP, and the initial receive sequence number\
    \ (IRS) is\n  learned during the connection establishing procedure.\n  For a connection\
    \ to be established or initialized, the two TCPs must\n  synchronize on each other's\
    \ initial sequence numbers.  This is done in\n  an exchange of connection establishing\
    \ segments carrying a control bit\n  called \"SYN\" (for synchronize) and the\
    \ initial sequence numbers.  As a\n  shorthand, segments carrying the SYN bit\
    \ are also called \"SYNs\".\n  Hence, the solution requires a suitable mechanism\
    \ for picking an\n  initial sequence number and a slightly involved handshake\
    \ to exchange\n  the ISN's.\n  The synchronization requires each side to send\
    \ it's own initial\n  sequence number and to receive a confirmation of it in acknowledgment\n\
    \  from the other side.  Each side must also receive the other side's\n  initial\
    \ sequence number and send a confirming acknowledgment.\n    1) A --> B  SYN my\
    \ sequence number is X\n    2) A <-- B  ACK your sequence number is X\n    3)\
    \ A <-- B  SYN my sequence number is Y\n    4) A --> B  ACK your sequence number\
    \ is Y\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  Because steps 2 and 3 can be combined in a single\
    \ message this is\n  called the three way (or three message) handshake.\n  A three\
    \ way handshake is necessary because sequence numbers are not\n  tied to a global\
    \ clock in the network, and TCPs may have different\n  mechanisms for picking\
    \ the ISN's.  The receiver of the first SYN has\n  no way of knowing whether the\
    \ segment was an old delayed one or not,\n  unless it remembers the last sequence\
    \ number used on the connection\n  (which is not always possible), and so it must\
    \ ask the sender to\n  verify this SYN.  The three way handshake and the advantages\
    \ of a\n  clock-driven scheme are discussed in [3].\n  Knowing When to Keep Quiet\n\
    \  To be sure that a TCP does not create a segment that carries a\n  sequence\
    \ number which may be duplicated by an old segment remaining in\n  the network,\
    \ the TCP must keep quiet for a maximum segment lifetime\n  (MSL) before assigning\
    \ any sequence numbers upon starting up or\n  recovering from a crash in which\
    \ memory of sequence numbers in use was\n  lost.  For this specification the MSL\
    \ is taken to be 2 minutes.  This\n  is an engineering choice, and may be changed\
    \ if experience indicates\n  it is desirable to do so.  Note that if a TCP is\
    \ reinitialized in some\n  sense, yet retains its memory of sequence numbers in\
    \ use, then it need\n  not wait at all; it must only be sure to use sequence numbers\
    \ larger\n  than those recently used.\n  The TCP Quiet Time Concept\n    This\
    \ specification provides that hosts which \"crash\" without\n    retaining any\
    \ knowledge of the last sequence numbers transmitted on\n    each active (i.e.,\
    \ not closed) connection shall delay emitting any\n    TCP segments for at least\
    \ the agreed Maximum Segment Lifetime (MSL)\n    in the internet system of which\
    \ the host is a part.  In the\n    paragraphs below, an explanation for this specification\
    \ is given.\n    TCP implementors may violate the \"quiet time\" restriction,\
    \ but only\n    at the risk of causing some old data to be accepted as new or\
    \ new\n    data rejected as old duplicated by some receivers in the internet\n\
    \    system.\n    TCPs consume sequence number space each time a segment is formed\
    \ and\n    entered into the network output queue at a source host. The\n    duplicate\
    \ detection and sequencing algorithm in the TCP protocol\n    relies on the unique\
    \ binding of segment data to sequence space to\n    the extent that sequence numbers\
    \ will not cycle through all 2**32\n    values before the segment data bound to\
    \ those sequence numbers has\n    been delivered and acknowledged by the receiver\
    \ and all duplicate\n    copies of the segments have \"drained\" from the internet.\
    \  Without\n    such an assumption, two distinct TCP segments could conceivably\
    \ be\n                                           Transmission Control Protocol\n\
    \                                                Functional Specification\n  \
    \  assigned the same or overlapping sequence numbers, causing confusion\n    at\
    \ the receiver as to which data is new and which is old.  Remember\n    that each\
    \ segment is bound to as many consecutive sequence numbers\n    as there are octets\
    \ of data in the segment.\n    Under normal conditions, TCPs keep track of the\
    \ next sequence number\n    to emit and the oldest awaiting acknowledgment so\
    \ as to avoid\n    mistakenly using a sequence number over before its first use\
    \ has\n    been acknowledged.  This alone does not guarantee that old duplicate\n\
    \    data is drained from the net, so the sequence space has been made\n    very\
    \ large to reduce the probability that a wandering duplicate will\n    cause trouble\
    \ upon arrival.  At 2 megabits/sec. it takes 4.5 hours\n    to use up 2**32 octets\
    \ of sequence space.  Since the maximum segment\n    lifetime in the net is not\
    \ likely to exceed a few tens of seconds,\n    this is deemed ample protection\
    \ for foreseeable nets, even if data\n    rates escalate to l0's of megabits/sec.\
    \  At 100 megabits/sec, the\n    cycle time is 5.4 minutes which may be a little\
    \ short, but still\n    within reason.\n    The basic duplicate detection and\
    \ sequencing algorithm in TCP can be\n    defeated, however, if a source TCP does\
    \ not have any memory of the\n    sequence numbers it last used on a given connection.\
    \ For example, if\n    the TCP were to start all connections with sequence number\
    \ 0, then\n    upon crashing and restarting, a TCP might re-form an earlier\n\
    \    connection (possibly after half-open connection resolution) and emit\n  \
    \  packets with sequence numbers identical to or overlapping with\n    packets\
    \ still in the network which were emitted on an earlier\n    incarnation of the\
    \ same connection.  In the absence of knowledge\n    about the sequence numbers\
    \ used on a particular connection, the TCP\n    specification recommends that\
    \ the source delay for MSL seconds\n    before emitting segments on the connection,\
    \ to allow time for\n    segments from the earlier connection incarnation to drain\
    \ from the\n    system.\n    Even hosts which can remember the time of day and\
    \ used it to select\n    initial sequence number values are not immune from this\
    \ problem\n    (i.e., even if time of day is used to select an initial sequence\n\
    \    number for each new connection incarnation).\n    Suppose, for example, that\
    \ a connection is opened starting with\n    sequence number S.  Suppose that this\
    \ connection is not used much\n    and that eventually the initial sequence number\
    \ function (ISN(t))\n    takes on a value equal to the sequence number, say S1,\
    \ of the last\n    segment sent by this TCP on a particular connection.  Now suppose,\n\
    \    at this instant, the host crashes, recovers, and establishes a new\n    incarnation\
    \ of the connection. The initial sequence number chosen is\n    S1 = ISN(t) --\
    \ last used sequence number on old incarnation of\n    connection!  If the recovery\
    \ occurs quickly enough, any old\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n    duplicates in the net bearing sequence numbers\
    \ in the neighborhood\n    of S1 may arrive and be treated as new packets by the\
    \ receiver of\n    the new incarnation of the connection.\n    The problem is\
    \ that the recovering host may not know for how long it\n    crashed nor does\
    \ it know whether there are still old duplicates in\n    the system from earlier\
    \ connection incarnations.\n    One way to deal with this problem is to deliberately\
    \ delay emitting\n    segments for one MSL after recovery from a crash- this is\
    \ the \"quite\n    time\" specification.  Hosts which prefer to avoid waiting\
    \ are\n    willing to risk possible confusion of old and new packets at a given\n\
    \    destination may choose not to wait for the \"quite time\".\n    Implementors\
    \ may provide TCP users with the ability to select on a\n    connection by connection\
    \ basis whether to wait after a crash, or may\n    informally implement the \"\
    quite time\" for all connections.\n    Obviously, even where a user selects to\
    \ \"wait,\" this is not\n    necessary after the host has been \"up\" for at least\
    \ MSL seconds.\n    To summarize: every segment emitted occupies one or more sequence\n\
    \    numbers in the sequence space, the numbers occupied by a segment are\n  \
    \  \"busy\" or \"in use\" until MSL seconds have passed, upon crashing a\n   \
    \ block of space-time is occupied by the octets of the last emitted\n    segment,\
    \ if a new connection is started too soon and uses any of the\n    sequence numbers\
    \ in the space-time footprint of the last segment of\n    the previous connection\
    \ incarnation, there is a potential sequence\n    number overlap area which could\
    \ cause confusion at the receiver.\n"
- title: 3.4.  Establishing a connection
  contents:
  - "3.4.  Establishing a connection\n  The \"three-way handshake\" is the procedure\
    \ used to establish a\n  connection.  This procedure normally is initiated by\
    \ one TCP and\n  responded to by another TCP.  The procedure also works if two\
    \ TCP\n  simultaneously initiate the procedure.  When simultaneous attempt\n \
    \ occurs, each TCP receives a \"SYN\" segment which carries no\n  acknowledgment\
    \ after it has sent a \"SYN\".  Of course, the arrival of\n  an old duplicate\
    \ \"SYN\" segment can potentially make it appear, to the\n  recipient, that a\
    \ simultaneous connection initiation is in progress.\n  Proper use of \"reset\"\
    \ segments can disambiguate these cases.\n  Several examples of connection initiation\
    \ follow.  Although these\n  examples do not show connection synchronization using\
    \ data-carrying\n  segments, this is perfectly legitimate, so long as the receiving\
    \ TCP\n  doesn't deliver the data to the user until it is clear the data is\n\
    \  valid (i.e., the data must be buffered at the receiver until the\n  connection\
    \ reaches the ESTABLISHED state).  The three-way handshake\n  reduces the possibility\
    \ of false connections.  It is the\n                                         \
    \  Transmission Control Protocol\n                                           \
    \     Functional Specification\n  implementation of a trade-off between memory\
    \ and messages to provide\n  information for this checking.\n  The simplest three-way\
    \ handshake is shown in figure 7 below.  The\n  figures should be interpreted\
    \ in the following way.  Each line is\n  numbered for reference purposes.  Right\
    \ arrows (-->) indicate\n  departure of a TCP segment from TCP A to TCP B, or\
    \ arrival of a\n  segment at B from A.  Left arrows (<--), indicate the reverse.\n\
    \  Ellipsis (...) indicates a segment which is still in the network\n  (delayed).\
    \  An \"XXX\" indicates a segment which is lost or rejected.\n  Comments appear\
    \ in parentheses.  TCP states represent the state AFTER\n  the departure or arrival\
    \ of the segment (whose contents are shown in\n  the center of each line).  Segment\
    \ contents are shown in abbreviated\n  form, with sequence number, control flags,\
    \ and ACK field.  Other\n  fields such as window, addresses, lengths, and text\
    \ have been left out\n  in the interest of clarity.\n      TCP A             \
    \                                   TCP B\n  1.  CLOSED                      \
    \                         LISTEN\n  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>   \
    \            --> SYN-RECEIVED\n  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>\
    \  <-- SYN-RECEIVED\n  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       -->\
    \ ESTABLISHED\n  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED\n\
    \          Basic 3-Way Handshake for Connection Synchronization\n            \
    \                    Figure 7.\n  In line 2 of figure 7, TCP A begins by sending\
    \ a SYN segment\n  indicating that it will use sequence numbers starting with\
    \ sequence\n  number 100.  In line 3, TCP B sends a SYN and acknowledges the SYN\
    \ it\n  received from TCP A.  Note that the acknowledgment field indicates TCP\n\
    \  B is now expecting to hear sequence 101, acknowledging the SYN which\n  occupied\
    \ sequence 100.\n  At line 4, TCP A responds with an empty segment containing\
    \ an ACK for\n  TCP B's SYN; and in line 5, TCP A sends some data.  Note that\
    \ the\n  sequence number of the segment in line 5 is the same as in line 4\n \
    \ because the ACK does not occupy sequence number space (if it did, we\n  would\
    \ wind up ACKing ACK's!).\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  Simultaneous initiation is only slightly more complex,\
    \ as is shown in\n  figure 8.  Each TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED\
    \ to\n  ESTABLISHED.\n      TCP A                                            TCP\
    \ B\n  1.  CLOSED                                           CLOSED\n  2.  SYN-SENT\
    \     --> <SEQ=100><CTL=SYN>              ...\n  3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>\
    \              <-- SYN-SENT\n  4.               ... <SEQ=100><CTL=SYN>       \
    \       --> SYN-RECEIVED\n  5.  SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK>\
    \ ...\n  6.  ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED\n\
    \  7.               ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED\n    \
    \            Simultaneous Connection Synchronization\n                       \
    \        Figure 8.\n  The principle reason for the three-way handshake is to prevent\
    \ old\n  duplicate connection initiations from causing confusion.  To deal with\n\
    \  this, a special control message, reset, has been devised.  If the\n  receiving\
    \ TCP is in a  non-synchronized state (i.e., SYN-SENT,\n  SYN-RECEIVED), it returns\
    \ to LISTEN on receiving an acceptable reset.\n  If the TCP is in one of the synchronized\
    \ states (ESTABLISHED,\n  FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,\
    \ TIME-WAIT), it\n  aborts the connection and informs its user.  We discuss this\
    \ latter\n  case under \"half-open\" connections below.\n                    \
    \                       Transmission Control Protocol\n                      \
    \                          Functional Specification\n      TCP A             \
    \                                   TCP B\n  1.  CLOSED                      \
    \                         LISTEN\n  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>   \
    \            ...\n  3.  (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED\n\
    \  4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED\n  5.\
    \  SYN-SENT    --> <SEQ=91><CTL=RST>               --> LISTEN\n  6.          \
    \    ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED\n  7.  SYN-SENT   \
    \ <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\n  8.  ESTABLISHED -->\
    \ <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED\n                    Recovery\
    \ from Old Duplicate SYN\n                               Figure 9.\n  As a simple\
    \ example of recovery from old duplicates, consider\n  figure 9.  At line 3, an\
    \ old duplicate SYN arrives at TCP B.  TCP B\n  cannot tell that this is an old\
    \ duplicate, so it responds normally\n  (line 4).  TCP A detects that the ACK\
    \ field is incorrect and returns a\n  RST (reset) with its SEQ field selected\
    \ to make the segment\n  believable.  TCP B, on receiving the RST, returns to\
    \ the LISTEN state.\n  When the original SYN (pun intended) finally arrives at\
    \ line 6, the\n  synchronization proceeds normally.  If the SYN at line 6 had\
    \ arrived\n  before the RST, a more complex exchange might have occurred with\
    \ RST's\n  sent in both directions.\n  Half-Open Connections and Other Anomalies\n\
    \  An established connection is said to be  \"half-open\" if one of the\n  TCPs\
    \ has closed or aborted the connection at its end without the\n  knowledge of\
    \ the other, or if the two ends of the connection have\n  become desynchronized\
    \ owing to a crash that resulted in loss of\n  memory.  Such connections will\
    \ automatically become reset if an\n  attempt is made to send data in either direction.\
    \  However, half-open\n  connections are expected to be unusual, and the recovery\
    \ procedure is\n  mildly involved.\n  If at site A the connection no longer exists,\
    \ then an attempt by the\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  user at site B to send any data on it will result\
    \ in the site B TCP\n  receiving a reset control message.  Such a message indicates\
    \ to the\n  site B TCP that something is wrong, and it is expected to abort the\n\
    \  connection.\n  Assume that two user processes A and B are communicating with\
    \ one\n  another when a crash occurs causing loss of memory to A's TCP.\n  Depending\
    \ on the operating system supporting A's TCP, it is likely\n  that some error\
    \ recovery mechanism exists.  When the TCP is up again,\n  A is likely to start\
    \ again from the beginning or from a recovery\n  point.  As a result, A will probably\
    \ try to OPEN the connection again\n  or try to SEND on the connection it believes\
    \ open.  In the latter\n  case, it receives the error message \"connection not\
    \ open\" from the\n  local (A's) TCP.  In an attempt to establish the connection,\
    \ A's TCP\n  will send a segment containing SYN.  This scenario leads to the\n\
    \  example shown in figure 10.  After TCP A crashes, the user attempts to\n  re-open\
    \ the connection.  TCP B, in the meantime, thinks the connection\n  is open.\n\
    \      TCP A                                           TCP B\n  1.  (CRASH)  \
    \                             (send 300,receive 100)\n  2.  CLOSED           \
    \                                ESTABLISHED\n  3.  SYN-SENT --> <SEQ=400><CTL=SYN>\
    \              --> (??)\n  4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <--\
    \ ESTABLISHED\n  5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)\n\
    \  6.  SYN-SENT                                         CLOSED\n  7.  SYN-SENT\
    \ --> <SEQ=400><CTL=SYN>              -->\n                     Half-Open Connection\
    \ Discovery\n                               Figure 10.\n  When the SYN arrives\
    \ at line 3, TCP B, being in a synchronized state,\n  and the incoming segment\
    \ outside the window, responds with an\n  acknowledgment indicating what sequence\
    \ it next expects to hear (ACK\n  100).  TCP A sees that this segment does not\
    \ acknowledge anything it\n  sent and, being unsynchronized, sends a reset (RST)\
    \ because it has\n  detected a half-open connection.  TCP B aborts at line 5.\
    \  TCP A will\n                                           Transmission Control\
    \ Protocol\n                                                Functional Specification\n\
    \  continue to try to establish the connection; the problem is now\n  reduced\
    \ to the basic 3-way handshake of figure 7.\n  An interesting alternative case\
    \ occurs when TCP A crashes and TCP B\n  tries to send data on what it thinks\
    \ is a synchronized connection.\n  This is illustrated in figure 11.  In this\
    \ case, the data arriving at\n  TCP A from TCP B (line 2) is unacceptable because\
    \ no such connection\n  exists, so TCP A sends a RST.  The RST is acceptable so\
    \ TCP B\n  processes it and aborts the connection.\n        TCP A            \
    \                                  TCP B\n  1.  (CRASH)                      \
    \             (send 300,receive 100)\n  2.  (??)    <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK>\
    \ <-- ESTABLISHED\n  3.          --> <SEQ=100><CTL=RST>                   -->\
    \ (ABORT!!)\n           Active Side Causes Half-Open Connection Discovery\n  \
    \                             Figure 11.\n  In figure 12, we find the two TCPs\
    \ A and B with passive connections\n  waiting for SYN.  An old duplicate arriving\
    \ at TCP B (line 2) stirs B\n  into action.  A SYN-ACK is returned (line 3) and\
    \ causes TCP A to\n  generate a RST (the ACK in line 3 is not acceptable).  TCP\
    \ B accepts\n  the reset and returns to its passive LISTEN state.\n      TCP A\
    \                                         TCP B\n  1.  LISTEN                \
    \                        LISTEN\n  2.       ... <SEQ=Z><CTL=SYN>             \
    \   -->  SYN-RECEIVED\n  3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED\n\
    \  4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)\n  5.\
    \  LISTEN                                        LISTEN\n       Old Duplicate\
    \ SYN Initiates a Reset on two Passive Sockets\n                             \
    \  Figure 12.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  A variety of other cases are possible, all of which\
    \ are accounted for\n  by the following rules for RST generation and processing.\n\
    \  Reset Generation\n  As a general rule, reset (RST) must be sent whenever a\
    \ segment arrives\n  which apparently is not intended for the current connection.\
    \  A reset\n  must not be sent if it is not clear that this is the case.\n  There\
    \ are three groups of states:\n    1.  If the connection does not exist (CLOSED)\
    \ then a reset is sent\n    in response to any incoming segment except another\
    \ reset.  In\n    particular, SYNs addressed to a non-existent connection are\
    \ rejected\n    by this means.\n    If the incoming segment has an ACK field,\
    \ the reset takes its\n    sequence number from the ACK field of the segment,\
    \ otherwise the\n    reset has sequence number zero and the ACK field is set to\
    \ the sum\n    of the sequence number and segment length of the incoming segment.\n\
    \    The connection remains in the CLOSED state.\n    2.  If the connection is\
    \ in any non-synchronized state (LISTEN,\n    SYN-SENT, SYN-RECEIVED), and the\
    \ incoming segment acknowledges\n    something not yet sent (the segment carries\
    \ an unacceptable ACK), or\n    if an incoming segment has a security level or\
    \ compartment which\n    does not exactly match the level and compartment requested\
    \ for the\n    connection, a reset is sent.\n    If our SYN has not been acknowledged\
    \ and the precedence level of the\n    incoming segment is higher than the precedence\
    \ level requested then\n    either raise the local precedence level (if allowed\
    \ by the user and\n    the system) or send a reset; or if the precedence level\
    \ of the\n    incoming segment is lower than the precedence level requested then\n\
    \    continue as if the precedence matched exactly (if the remote TCP\n    cannot\
    \ raise the precedence level to match ours this will be\n    detected in the next\
    \ segment it sends, and the connection will be\n    terminated then).  If our\
    \ SYN has been acknowledged (perhaps in this\n    incoming segment) the precedence\
    \ level of the incoming segment must\n    match the local precedence level exactly,\
    \ if it does not a reset\n    must be sent.\n    If the incoming segment has an\
    \ ACK field, the reset takes its\n    sequence number from the ACK field of the\
    \ segment, otherwise the\n    reset has sequence number zero and the ACK field\
    \ is set to the sum\n    of the sequence number and segment length of the incoming\
    \ segment.\n    The connection remains in the same state.\n                  \
    \                         Transmission Control Protocol\n                    \
    \                            Functional Specification\n    3.  If the connection\
    \ is in a synchronized state (ESTABLISHED,\n    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT,\
    \ CLOSING, LAST-ACK, TIME-WAIT),\n    any unacceptable segment (out of window\
    \ sequence number or\n    unacceptible acknowledgment number) must elicit only\
    \ an empty\n    acknowledgment segment containing the current send-sequence number\n\
    \    and an acknowledgment indicating the next sequence number expected\n    to\
    \ be received, and the connection remains in the same state.\n    If an incoming\
    \ segment has a security level, or compartment, or\n    precedence which does\
    \ not exactly match the level, and compartment,\n    and precedence requested\
    \ for the connection,a reset is sent and\n    connection goes to the CLOSED state.\
    \  The reset takes its sequence\n    number from the ACK field of the incoming\
    \ segment.\n  Reset Processing\n  In all states except SYN-SENT, all reset (RST)\
    \ segments are validated\n  by checking their SEQ-fields.  A reset is valid if\
    \ its sequence number\n  is in the window.  In the SYN-SENT state (a RST received\
    \ in response\n  to an initial SYN), the RST is acceptable if the ACK field\n\
    \  acknowledges the SYN.\n  The receiver of a RST first validates it, then changes\
    \ state.  If the\n  receiver was in the LISTEN state, it ignores it.  If the receiver\
    \ was\n  in SYN-RECEIVED state and had previously been in the LISTEN state,\n\
    \  then the receiver returns to the LISTEN state, otherwise the receiver\n  aborts\
    \ the connection and goes to the CLOSED state.  If the receiver\n  was in any\
    \ other state, it aborts the connection and advises the user\n  and goes to the\
    \ CLOSED state.\n"
- title: 3.5.  Closing a Connection
  contents:
  - "3.5.  Closing a Connection\n  CLOSE is an operation meaning \"I have no more\
    \ data to send.\"  The\n  notion of closing a full-duplex connection is subject\
    \ to ambiguous\n  interpretation, of course, since it may not be obvious how to\
    \ treat\n  the receiving side of the connection.  We have chosen to treat CLOSE\n\
    \  in a simplex fashion.  The user who CLOSEs may continue to RECEIVE\n  until\
    \ he is told that the other side has CLOSED also.  Thus, a program\n  could initiate\
    \ several SENDs followed by a CLOSE, and then continue to\n  RECEIVE until signaled\
    \ that a RECEIVE failed because the other side\n  has CLOSED.  We assume that\
    \ the TCP will signal a user, even if no\n  RECEIVEs are outstanding, that the\
    \ other side has closed, so the user\n  can terminate his side gracefully.  A\
    \ TCP will reliably deliver all\n  buffers SENT before the connection was CLOSED\
    \ so a user who expects no\n  data in return need only wait to hear the connection\
    \ was CLOSED\n  successfully to know that all his data was received at the destination\n\
    \  TCP.  Users must keep reading connections they close for sending until\n  the\
    \ TCP says no more data.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  There are essentially three cases:\n    1) The user\
    \ initiates by telling the TCP to CLOSE the connection\n    2) The remote TCP\
    \ initiates by sending a FIN control signal\n    3) Both users CLOSE simultaneously\n\
    \  Case 1:  Local user initiates the close\n    In this case, a FIN segment can\
    \ be constructed and placed on the\n    outgoing segment queue.  No further SENDs\
    \ from the user will be\n    accepted by the TCP, and it enters the FIN-WAIT-1\
    \ state.  RECEIVEs\n    are allowed in this state.  All segments preceding and\
    \ including FIN\n    will be retransmitted until acknowledged.  When the other\
    \ TCP has\n    both acknowledged the FIN and sent a FIN of its own, the first\
    \ TCP\n    can ACK this FIN.  Note that a TCP receiving a FIN will ACK but not\n\
    \    send its own FIN until its user has CLOSED the connection also.\n  Case 2:\
    \  TCP receives a FIN from the network\n    If an unsolicited FIN arrives from\
    \ the network, the receiving TCP\n    can ACK it and tell the user that the connection\
    \ is closing.  The\n    user will respond with a CLOSE, upon which the TCP can\
    \ send a FIN to\n    the other TCP after sending any remaining data.  The TCP\
    \ then waits\n    until its own FIN is acknowledged whereupon it deletes the\n\
    \    connection.  If an ACK is not forthcoming, after the user timeout\n    the\
    \ connection is aborted and the user is told.\n  Case 3:  both users close simultaneously\n\
    \    A simultaneous CLOSE by users at both ends of a connection causes\n    FIN\
    \ segments to be exchanged.  When all segments preceding the FINs\n    have been\
    \ processed and acknowledged, each TCP can ACK the FIN it\n    has received. \
    \ Both will, upon receiving these ACKs, delete the\n    connection.\n        \
    \                                   Transmission Control Protocol\n          \
    \                                      Functional Specification\n      TCP A \
    \                                               TCP B\n  1.  ESTABLISHED     \
    \                                     ESTABLISHED\n  2.  (Close)\n      FIN-WAIT-1\
    \  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT\n  3.  FIN-WAIT-2  <--\
    \ <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT\n  4.                      \
    \                                 (Close)\n      TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>\
    \  <-- LAST-ACK\n  5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED\n\
    \  6.  (2 MSL)\n      CLOSED                                                 \
    \     \n                         Normal Close Sequence\n                     \
    \          Figure 13.\n      TCP A                                           \
    \     TCP B\n  1.  ESTABLISHED                                          ESTABLISHED\n\
    \  2.  (Close)                                              (Close)\n      FIN-WAIT-1\
    \  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1\n                  <--\
    \ <SEQ=300><ACK=100><CTL=FIN,ACK>  <--\n                  ... <SEQ=100><ACK=300><CTL=FIN,ACK>\
    \  -->\n  3.  CLOSING     --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING\n \
    \                 <-- <SEQ=301><ACK=101><CTL=ACK>      <--\n                 \
    \ ... <SEQ=101><ACK=301><CTL=ACK>      -->\n  4.  TIME-WAIT                  \
    \                          TIME-WAIT\n      (2 MSL)                          \
    \                    (2 MSL)\n      CLOSED                                   \
    \            CLOSED\n                      Simultaneous Close Sequence\n     \
    \                          Figure 14.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - 'Functional Specification

    '
- title: 3.6.  Precedence and Security
  contents:
  - "3.6.  Precedence and Security\n  The intent is that connection be allowed only\
    \ between ports operating\n  with exactly the same security and compartment values\
    \ and at the\n  higher of the precedence level requested by the two ports.\n \
    \ The precedence and security parameters used in TCP are exactly those\n  defined\
    \ in the Internet Protocol (IP) [2].  Throughout this TCP\n  specification the\
    \ term \"security/compartment\" is intended to indicate\n  the security parameters\
    \ used in IP including security, compartment,\n  user group, and handling restriction.\n\
    \  A connection attempt with mismatched security/compartment values or a\n  lower\
    \ precedence value must be rejected by sending a reset.  Rejecting\n  a connection\
    \ due to too low a precedence only occurs after an\n  acknowledgment of the SYN\
    \ has been received.\n  Note that TCP modules which operate only at the default\
    \ value of\n  precedence will still have to check the precedence of incoming\n\
    \  segments and possibly raise the precedence level they use on the\n  connection.\n\
    \  The security paramaters may be used even in a non-secure environment\n  (the\
    \ values would indicate unclassified data), thus hosts in\n  non-secure environments\
    \ must be prepared to receive the security\n  parameters, though they need not\
    \ send them.\n"
- title: 3.7.  Data Communication
  contents:
  - "3.7.  Data Communication\n  Once the connection is established data is communicated\
    \ by the\n  exchange of segments.  Because segments may be lost due to errors\n\
    \  (checksum test failure), or network congestion, TCP uses\n  retransmission\
    \ (after a timeout) to ensure delivery of every segment.\n  Duplicate segments\
    \ may arrive due to network or TCP retransmission.\n  As discussed in the section\
    \ on sequence numbers the TCP performs\n  certain tests on the sequence and acknowledgment\
    \ numbers in the\n  segments to verify their acceptability.\n  The sender of data\
    \ keeps track of the next sequence number to use in\n  the variable SND.NXT. \
    \ The receiver of data keeps track of the next\n  sequence number to expect in\
    \ the variable RCV.NXT.  The sender of data\n  keeps track of the oldest unacknowledged\
    \ sequence number in the\n  variable SND.UNA.  If the data flow is momentarily\
    \ idle and all data\n  sent has been acknowledged then the three variables will\
    \ be equal.\n  When the sender creates a segment and transmits it the sender advances\n\
    \  SND.NXT.  When the receiver accepts a segment it advances RCV.NXT and\n  sends\
    \ an acknowledgment.  When the data sender receives an\n                     \
    \                      Transmission Control Protocol\n                       \
    \                         Functional Specification\n  acknowledgment it advances\
    \ SND.UNA.  The extent to which the values of\n  these variables differ is a measure\
    \ of the delay in the communication.\n  The amount by which the variables are\
    \ advanced is the length of the\n  data in the segment.  Note that once in the\
    \ ESTABLISHED state all\n  segments must carry current acknowledgment information.\n\
    \  The CLOSE user call implies a push function, as does the FIN control\n  flag\
    \ in an incoming segment.\n  Retransmission Timeout\n  Because of the variability\
    \ of the networks that compose an\n  internetwork system and the wide range of\
    \ uses of TCP connections the\n  retransmission timeout must be dynamically determined.\
    \  One procedure\n  for determining a retransmission time out is given here as\
    \ an\n  illustration.\n    An Example Retransmission Timeout Procedure\n     \
    \ Measure the elapsed time between sending a data octet with a\n      particular\
    \ sequence number and receiving an acknowledgment that\n      covers that sequence\
    \ number (segments sent do not have to match\n      segments received).  This\
    \ measured elapsed time is the Round Trip\n      Time (RTT).  Next compute a Smoothed\
    \ Round Trip Time (SRTT) as:\n        SRTT = ( ALPHA * SRTT ) + ((1-ALPHA) * RTT)\n\
    \      and based on this, compute the retransmission timeout (RTO) as:\n     \
    \   RTO = min[UBOUND,max[LBOUND,(BETA*SRTT)]]\n      where UBOUND is an upper\
    \ bound on the timeout (e.g., 1 minute),\n      LBOUND is a lower bound on the\
    \ timeout (e.g., 1 second), ALPHA is\n      a smoothing factor (e.g., .8 to .9),\
    \ and BETA is a delay variance\n      factor (e.g., 1.3 to 2.0).\n  The Communication\
    \ of Urgent Information\n  The objective of the TCP urgent mechanism is to allow\
    \ the sending user\n  to stimulate the receiving user to accept some urgent data\
    \ and to\n  permit the receiving TCP to indicate to the receiving user when all\n\
    \  the currently known urgent data has been received by the user.\n  This mechanism\
    \ permits a point in the data stream to be designated as\n  the end of urgent\
    \ information.  Whenever this point is in advance of\n  the receive sequence number\
    \ (RCV.NXT) at the receiving TCP, that TCP\n  must tell the user to go into \"\
    urgent mode\"; when the receive sequence\n  number catches up to the urgent pointer,\
    \ the TCP must tell user to go\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  into \"normal mode\".  If the urgent pointer is updated\
    \ while the user\n  is in \"urgent mode\", the update will be invisible to the\
    \ user.\n  The method employs a urgent field which is carried in all segments\n\
    \  transmitted.  The URG control flag indicates that the urgent field is\n  meaningful\
    \ and must be added to the segment sequence number to yield\n  the urgent pointer.\
    \  The absence of this flag indicates that there is\n  no urgent data outstanding.\n\
    \  To send an urgent indication the user must also send at least one data\n  octet.\
    \  If the sending user also indicates a push, timely delivery of\n  the urgent\
    \ information to the destination process is enhanced.\n  Managing the Window\n\
    \  The window sent in each segment indicates the range of sequence\n  numbers\
    \ the sender of the window (the data receiver) is currently\n  prepared to accept.\
    \  There is an assumption that this is related to\n  the currently available data\
    \ buffer space available for this\n  connection.\n  Indicating a large window\
    \ encourages transmissions.  If more data\n  arrives than can be accepted, it\
    \ will be discarded.  This will result\n  in excessive retransmissions, adding\
    \ unnecessarily to the load on the\n  network and the TCPs.  Indicating a small\
    \ window may restrict the\n  transmission of data to the point of introducing\
    \ a round trip delay\n  between each new segment transmitted.\n  The mechanisms\
    \ provided allow a TCP to advertise a large window and to\n  subsequently advertise\
    \ a much smaller window without having accepted\n  that much data.  This, so called\
    \ \"shrinking the window,\" is strongly\n  discouraged.  The robustness principle\
    \ dictates that TCPs will not\n  shrink the window themselves, but will be prepared\
    \ for such behavior\n  on the part of other TCPs.\n  The sending TCP must be prepared\
    \ to accept from the user and send at\n  least one octet of new data even if the\
    \ send window is zero.  The\n  sending TCP must regularly retransmit to the receiving\
    \ TCP even when\n  the window is zero.  Two minutes is recommended for the retransmission\n\
    \  interval when the window is zero.  This retransmission is essential to\n  guarantee\
    \ that when either TCP has a zero window the re-opening of the\n  window will\
    \ be reliably reported to the other.\n  When the receiving TCP has a zero window\
    \ and a segment arrives it must\n  still send an acknowledgment showing its next\
    \ expected sequence number\n  and current window (zero).\n  The sending TCP packages\
    \ the data to be transmitted into segments\n                                 \
    \          Transmission Control Protocol\n                                   \
    \             Functional Specification\n  which fit the current window, and may\
    \ repackage segments on the\n  retransmission queue.  Such repackaging is not\
    \ required, but may be\n  helpful.\n  In a connection with a one-way data flow,\
    \ the window information will\n  be carried in acknowledgment segments that all\
    \ have the same sequence\n  number so there will be no way to reorder them if\
    \ they arrive out of\n  order.  This is not a serious problem, but it will allow\
    \ the window\n  information to be on occasion temporarily based on old reports\
    \ from\n  the data receiver.  A refinement to avoid this problem is to act on\n\
    \  the window information from segments that carry the highest\n  acknowledgment\
    \ number (that is segments with acknowledgment number\n  equal or greater than\
    \ the highest previously received).\n  The window management procedure has significant\
    \ influence on the\n  communication performance.  The following comments are suggestions\
    \ to\n  implementers.\n    Window Management Suggestions\n      Allocating a very\
    \ small window causes data to be transmitted in\n      many small segments when\
    \ better performance is achieved using\n      fewer large segments.\n      One\
    \ suggestion for avoiding small windows is for the receiver to\n      defer updating\
    \ a window until the additional allocation is at\n      least X percent of the\
    \ maximum allocation possible for the\n      connection (where X might be 20 to\
    \ 40).\n      Another suggestion is for the sender to avoid sending small\n  \
    \    segments by waiting until the window is large enough before\n      sending\
    \ data.  If the the user signals a push function then the\n      data must be\
    \ sent even if it is a small segment.\n      Note that the acknowledgments should\
    \ not be delayed or unnecessary\n      retransmissions will result.  One strategy\
    \ would be to send an\n      acknowledgment when a small segment arrives (with\
    \ out updating the\n      window information), and then to send another acknowledgment\
    \ with\n      new window information when the window is larger.\n      The segment\
    \ sent to probe a zero window may also begin a break up\n      of transmitted\
    \ data into smaller and smaller segments.  If a\n      segment containing a single\
    \ data octet sent to probe a zero window\n      is accepted, it consumes one octet\
    \ of the window now available.\n      If the sending TCP simply sends as much\
    \ as it can whenever the\n      window is non zero, the transmitted data will\
    \ be broken into\n      alternating big and small segments.  As time goes on,\
    \ occasional\n      pauses in the receiver making window allocation available\
    \ will\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n      result in breaking the big segments into a small\
    \ and not quite so\n      big pair. And after a while the data transmission will\
    \ be in\n      mostly small segments.\n      The suggestion here is that the TCP\
    \ implementations need to\n      actively attempt to combine small window allocations\
    \ into larger\n      windows, since the mechanisms for managing the window tend\
    \ to lead\n      to many small windows in the simplest minded implementations.\n"
- title: 3.8.  Interfaces
  contents:
  - "3.8.  Interfaces\n  There are of course two interfaces of concern:  the user/TCP\
    \ interface\n  and the TCP/lower-level interface.  We have a fairly elaborate\
    \ model\n  of the user/TCP interface, but the interface to the lower level\n \
    \ protocol module is left unspecified here, since it will be specified\n  in detail\
    \ by the specification of the lowel level protocol.  For the\n  case that the\
    \ lower level is IP we note some of the parameter values\n  that TCPs might use.\n\
    \  User/TCP Interface\n    The following functional description of user commands\
    \ to the TCP is,\n    at best, fictional, since every operating system will have\
    \ different\n    facilities.  Consequently, we must warn readers that different\
    \ TCP\n    implementations may have different user interfaces.  However, all\n\
    \    TCPs must provide a certain minimum set of services to guarantee\n    that\
    \ all TCP implementations can support the same protocol\n    hierarchy.  This\
    \ section specifies the functional interfaces\n    required of all TCP implementations.\n\
    \    TCP User Commands\n      The following sections functionally characterize\
    \ a USER/TCP\n      interface.  The notation used is similar to most procedure\
    \ or\n      function calls in high level languages, but this usage is not\n  \
    \    meant to rule out trap type service calls (e.g., SVCs, UUOs,\n      EMTs).\n\
    \      The user commands described below specify the basic functions the\n   \
    \   TCP must perform to support interprocess communication.\n      Individual\
    \ implementations must define their own exact format, and\n      may provide combinations\
    \ or subsets of the basic functions in\n      single calls.  In particular, some\
    \ implementations may wish to\n      automatically OPEN a connection on the first\
    \ SEND or RECEIVE\n      issued by the user for a given connection.\n        \
    \                                   Transmission Control Protocol\n          \
    \                                      Functional Specification\n      In providing\
    \ interprocess communication facilities, the TCP must\n      not only accept commands,\
    \ but must also return information to the\n      processes it serves.  The latter\
    \ consists of:\n        (a) general information about a connection (e.g., interrupts,\n\
    \        remote close, binding of unspecified foreign socket).\n        (b) replies\
    \ to specific user commands indicating success or\n        various types of failure.\n\
    \      Open\n        Format:  OPEN (local port, foreign socket, active/passive\n\
    \        [, timeout] [, precedence] [, security/compartment] [, options])\n  \
    \      -> local connection name\n        We assume that the local TCP is aware\
    \ of the identity of the\n        processes it serves and will check the authority\
    \ of the process\n        to use the connection specified.  Depending upon the\n\
    \        implementation of the TCP, the local network and TCP identifiers\n  \
    \      for the source address will either be supplied by the TCP or the\n    \
    \    lower level protocol (e.g., IP).  These considerations are the\n        result\
    \ of concern about security, to the extent that no TCP be\n        able to masquerade\
    \ as another one, and so on.  Similarly, no\n        process can masquerade as\
    \ another without the collusion of the\n        TCP.\n        If the active/passive\
    \ flag is set to passive, then this is a\n        call to LISTEN for an incoming\
    \ connection.  A passive open may\n        have either a fully specified foreign\
    \ socket to wait for a\n        particular connection or an unspecified foreign\
    \ socket to wait\n        for any call.  A fully specified passive call can be\
    \ made active\n        by the subsequent execution of a SEND.\n        A transmission\
    \ control block (TCB) is created and partially\n        filled in with data from\
    \ the OPEN command parameters.\n        On an active OPEN command, the TCP will\
    \ begin the procedure to\n        synchronize (i.e., establish) the connection\
    \ at once.\n        The timeout, if present, permits the caller to set up a timeout\n\
    \        for all data submitted to TCP.  If data is not successfully\n       \
    \ delivered to the destination within the timeout period, the TCP\n        will\
    \ abort the connection.  The present global default is five\n        minutes.\n\
    \        The TCP or some component of the operating system will verify\n     \
    \   the users authority to open a connection with the specified\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n        precedence or security/compartment.  The absence\
    \ of precedence\n        or security/compartment specification in the OPEN call\
    \ indicates\n        the default values must be used.\n        TCP will accept\
    \ incoming requests as matching only if the\n        security/compartment information\
    \ is exactly the same and only if\n        the precedence is equal to or higher\
    \ than the precedence\n        requested in the OPEN call.\n        The precedence\
    \ for the connection is the higher of the values\n        requested in the OPEN\
    \ call and received from the incoming\n        request, and fixed at that value\
    \ for the life of the\n        connection.Implementers may want to give the user\
    \ control of\n        this precedence negotiation.  For example, the user might\
    \ be\n        allowed to specify that the precedence must be exactly matched,\n\
    \        or that any attempt to raise the precedence be confirmed by the\n   \
    \     user.\n        A local connection name will be returned to the user by the\
    \ TCP.\n        The local connection name can then be used as a short hand term\n\
    \        for the connection defined by the <local socket, foreign socket>\n  \
    \      pair.\n      Send\n        Format:  SEND (local connection name, buffer\
    \ address, byte\n        count, PUSH flag, URGENT flag [,timeout])\n        This\
    \ call causes the data contained in the indicated user buffer\n        to be sent\
    \ on the indicated connection.  If the connection has\n        not been opened,\
    \ the SEND is considered an error.  Some\n        implementations may allow users\
    \ to SEND first; in which case, an\n        automatic OPEN would be done.  If\
    \ the calling process is not\n        authorized to use this connection, an error\
    \ is returned.\n        If the PUSH flag is set, the data must be transmitted\
    \ promptly\n        to the receiver, and the PUSH bit will be set in the last\
    \ TCP\n        segment created from the buffer.  If the PUSH flag is not set,\n\
    \        the data may be combined with data from subsequent SENDs for\n      \
    \  transmission efficiency.\n        If the URGENT flag is set, segments sent\
    \ to the destination TCP\n        will have the urgent pointer set.  The receiving\
    \ TCP will signal\n        the urgent condition to the receiving process if the\
    \ urgent\n        pointer indicates that data preceding the urgent pointer has\
    \ not\n        been consumed by the receiving process.  The purpose of urgent\n\
    \        is to stimulate the receiver to process the urgent data and to\n    \
    \    indicate to the receiver when all the currently known urgent\n          \
    \                                 Transmission Control Protocol\n            \
    \                                    Functional Specification\n        data has\
    \ been received.  The number of times the sending user's\n        TCP signals\
    \ urgent will not necessarily be equal to the number\n        of times the receiving\
    \ user will be notified of the presence of\n        urgent data.\n        If no\
    \ foreign socket was specified in the OPEN, but the\n        connection is established\
    \ (e.g., because a LISTENing connection\n        has become specific due to a\
    \ foreign segment arriving for the\n        local socket), then the designated\
    \ buffer is sent to the implied\n        foreign socket.  Users who make use of\
    \ OPEN with an unspecified\n        foreign socket can make use of SEND without\
    \ ever explicitly\n        knowing the foreign socket address.\n        However,\
    \ if a SEND is attempted before the foreign socket\n        becomes specified,\
    \ an error will be returned.  Users can use the\n        STATUS call to determine\
    \ the status of the connection.  In some\n        implementations the TCP may\
    \ notify the user when an unspecified\n        socket is bound.\n        If a\
    \ timeout is specified, the current user timeout for this\n        connection\
    \ is changed to the new one.\n        In the simplest implementation, SEND would\
    \ not return control to\n        the sending process until either the transmission\
    \ was complete\n        or the timeout had been exceeded.  However, this simple\
    \ method\n        is both subject to deadlocks (for example, both sides of the\n\
    \        connection might try to do SENDs before doing any RECEIVEs) and\n   \
    \     offers poor performance, so it is not recommended.  A more\n        sophisticated\
    \ implementation would return immediately to allow\n        the process to run\
    \ concurrently with network I/O, and,\n        furthermore, to allow multiple\
    \ SENDs to be in progress.\n        Multiple SENDs are served in first come, first\
    \ served order, so\n        the TCP will queue those it cannot service immediately.\n\
    \        We have implicitly assumed an asynchronous user interface in\n      \
    \  which a SEND later elicits some kind of SIGNAL or\n        pseudo-interrupt\
    \ from the serving TCP.  An alternative is to\n        return a response immediately.\
    \  For instance, SENDs might return\n        immediate local acknowledgment, even\
    \ if the segment sent had not\n        been acknowledged by the distant TCP. \
    \ We could optimistically\n        assume eventual success.  If we are wrong,\
    \ the connection will\n        close anyway due to the timeout.  In implementations\
    \ of this\n        kind (synchronous), there will still be some asynchronous\n\
    \        signals, but these will deal with the connection itself, and not\n  \
    \      with specific segments or buffers.\n        In order for the process to\
    \ distinguish among error or success\n        indications for different SENDs,\
    \ it might be appropriate for the\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n        buffer address to be returned along with the\
    \ coded response to\n        the SEND request.  TCP-to-user signals are discussed\
    \ below,\n        indicating the information which should be returned to the\n\
    \        calling process.\n      Receive\n        Format:  RECEIVE (local connection\
    \ name, buffer address, byte\n        count) -> byte count, urgent flag, push\
    \ flag\n        This command allocates a receiving buffer associated with the\n\
    \        specified connection.  If no OPEN precedes this command or the\n    \
    \    calling process is not authorized to use this connection, an\n        error\
    \ is returned.\n        In the simplest implementation, control would not return\
    \ to the\n        calling program until either the buffer was filled, or some\n\
    \        error occurred, but this scheme is highly subject to deadlocks.\n   \
    \     A more sophisticated implementation would permit several\n        RECEIVEs\
    \ to be outstanding at once.  These would be filled as\n        segments arrive.\
    \  This strategy permits increased throughput at\n        the cost of a more elaborate\
    \ scheme (possibly asynchronous) to\n        notify the calling program that a\
    \ PUSH has been seen or a buffer\n        filled.\n        If enough data arrive\
    \ to fill the buffer before a PUSH is seen,\n        the PUSH flag will not be\
    \ set in the response to the RECEIVE.\n        The buffer will be filled with\
    \ as much data as it can hold.  If\n        a PUSH is seen before the buffer is\
    \ filled the buffer will be\n        returned partially filled and PUSH indicated.\n\
    \        If there is urgent data the user will have been informed as soon\n  \
    \      as it arrived via a TCP-to-user signal.  The receiving user\n        should\
    \ thus be in \"urgent mode\".  If the URGENT flag is on,\n        additional urgent\
    \ data remains.  If the URGENT flag is off, this\n        call to RECEIVE has\
    \ returned all the urgent data, and the user\n        may now leave \"urgent mode\"\
    .  Note that data following the\n        urgent pointer (non-urgent data) cannot\
    \ be delivered to the user\n        in the same buffer with preceeding urgent\
    \ data unless the\n        boundary is clearly marked for the user.\n        To\
    \ distinguish among several outstanding RECEIVEs and to take\n        care of\
    \ the case that a buffer is not completely filled, the\n        return code is\
    \ accompanied by both a buffer pointer and a byte\n        count indicating the\
    \ actual length of the data received.\n        Alternative implementations of\
    \ RECEIVE might have the TCP\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n        allocate buffer storage, or the TCP might share a ring\
    \ buffer\n        with the user.\n      Close\n        Format:  CLOSE (local connection\
    \ name)\n        This command causes the connection specified to be closed.  If\n\
    \        the connection is not open or the calling process is not\n        authorized\
    \ to use this connection, an error is returned.\n        Closing connections is\
    \ intended to be a graceful operation in\n        the sense that outstanding SENDs\
    \ will be transmitted (and\n        retransmitted), as flow control permits, until\
    \ all have been\n        serviced.  Thus, it should be acceptable to make several\
    \ SEND\n        calls, followed by a CLOSE, and expect all the data to be sent\n\
    \        to the destination.  It should also be clear that users should\n    \
    \    continue to RECEIVE on CLOSING connections, since the other side\n      \
    \  may be trying to transmit the last of its data.  Thus, CLOSE\n        means\
    \ \"I have no more to send\" but does not mean \"I will not\n        receive any\
    \ more.\"  It may happen (if the user level protocol is\n        not well thought\
    \ out) that the closing side is unable to get rid\n        of all its data before\
    \ timing out.  In this event, CLOSE turns\n        into ABORT, and the closing\
    \ TCP gives up.\n        The user may CLOSE the connection at any time on his\
    \ own\n        initiative, or in response to various prompts from the TCP\n  \
    \      (e.g., remote close executed, transmission timeout exceeded,\n        destination\
    \ inaccessible).\n        Because closing a connection requires communication\
    \ with the\n        foreign TCP, connections may remain in the closing state for\
    \ a\n        short time.  Attempts to reopen the connection before the TCP\n \
    \       replies to the CLOSE command will result in error responses.\n       \
    \ Close also implies push function.\n      Status\n        Format:  STATUS (local\
    \ connection name) -> status data\n        This is an implementation dependent\
    \ user command and could be\n        excluded without adverse effect.  Information\
    \ returned would\n        typically come from the TCB associated with the connection.\n\
    \        This command returns a data block containing the following\n        information:\n\
    \          local socket,\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n          foreign socket,\n          local connection\
    \ name,\n          receive window,\n          send window,\n          connection\
    \ state,\n          number of buffers awaiting acknowledgment,\n          number\
    \ of buffers pending receipt,\n          urgent state,\n          precedence,\n\
    \          security/compartment,\n          and transmission timeout.\n      \
    \  Depending on the state of the connection, or on the\n        implementation\
    \ itself, some of this information may not be\n        available or meaningful.\
    \  If the calling process is not\n        authorized to use this connection, an\
    \ error is returned.  This\n        prevents unauthorized processes from gaining\
    \ information about a\n        connection.\n      Abort\n        Format:  ABORT\
    \ (local connection name)\n        This command causes all pending SENDs and RECEIVES\
    \ to be\n        aborted, the TCB to be removed, and a special RESET message to\n\
    \        be sent to the TCP on the other side of the connection.\n        Depending\
    \ on the implementation, users may receive abort\n        indications for each\
    \ outstanding SEND or RECEIVE, or may simply\n        receive an ABORT-acknowledgment.\n\
    \    TCP-to-User Messages\n      It is assumed that the operating system environment\
    \ provides a\n      means for the TCP to asynchronously signal the user program.\
    \  When\n      the TCP does signal a user program, certain information is passed\n\
    \      to the user.  Often in the specification the information will be\n    \
    \  an error message.  In other cases there will be information\n      relating\
    \ to the completion of processing a SEND or RECEIVE or\n      other user call.\n\
    \      The following information is provided:\n        Local Connection Name \
    \                   Always\n        Response String                          Always\n\
    \        Buffer Address                           Send & Receive\n        Byte\
    \ count (counts bytes received)       Receive\n        Push flag             \
    \                   Receive\n        Urgent flag                             \
    \ Receive\n                                           Transmission Control Protocol\n\
    \                                                Functional Specification\n  TCP/Lower-Level\
    \ Interface\n    The TCP calls on a lower level protocol module to actually send\
    \ and\n    receive information over a network.  One case is that of the ARPA\n\
    \    internetwork system where the lower level module is the Internet\n    Protocol\
    \ (IP) [2].\n    If the lower level protocol is IP it provides arguments for a\
    \ type\n    of service and for a time to live.  TCP uses the following settings\n\
    \    for these parameters:\n      Type of Service = Precedence: routine, Delay:\
    \ normal, Throughput:\n      normal, Reliability: normal; or 00000000.\n     \
    \ Time to Live    = one minute, or 00111100.\n        Note that the assumed maximum\
    \ segment lifetime is two minutes.\n        Here we explicitly ask that a segment\
    \ be destroyed if it cannot\n        be delivered by the internet system within\
    \ one minute.\n    If the lower level is IP (or other protocol that provides this\n\
    \    feature) and source routing is used, the interface must allow the\n    route\
    \ information to be communicated.  This is especially important\n    so that the\
    \ source and destination addresses used in the TCP\n    checksum be the originating\
    \ source and ultimate destination. It is\n    also important to preserve the return\
    \ route to answer connection\n    requests.\n    Any lower level protocol will\
    \ have to provide the source address,\n    destination address, and protocol fields,\
    \ and some way to determine\n    the \"TCP length\", both to provide the functional\
    \ equivlent service\n    of IP and to be used in the TCP checksum.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - 'Functional Specification

    '
- title: 3.9.  Event Processing
  contents:
  - "3.9.  Event Processing\n  The processing depicted in this section is an example\
    \ of one possible\n  implementation.  Other implementations may have slightly\
    \ different\n  processing sequences, but they should differ from those in this\n\
    \  section only in detail, not in substance.\n  The activity of the TCP can be\
    \ characterized as responding to events.\n  The events that occur can be cast\
    \ into three categories:  user calls,\n  arriving segments, and timeouts.  This\
    \ section describes the\n  processing the TCP does in response to each of the\
    \ events.  In many\n  cases the processing required depends on the state of the\
    \ connection.\n    Events that occur:\n      User Calls\n        OPEN\n      \
    \  SEND\n        RECEIVE\n        CLOSE\n        ABORT\n        STATUS\n     \
    \ Arriving Segments\n        SEGMENT ARRIVES\n      Timeouts\n        USER TIMEOUT\n\
    \        RETRANSMISSION TIMEOUT\n        TIME-WAIT TIMEOUT\n  The model of the\
    \ TCP/user interface is that user commands receive an\n  immediate return and\
    \ possibly a delayed response via an event or\n  pseudo interrupt.  In the following\
    \ descriptions, the term \"signal\"\n  means cause a delayed response.\n  Error\
    \ responses are given as character strings.  For example, user\n  commands referencing\
    \ connections that do not exist receive \"error:\n  connection not open\".\n \
    \ Please note in the following that all arithmetic on sequence numbers,\n  acknowledgment\
    \ numbers, windows, et cetera, is modulo 2**32 the size\n  of the sequence number\
    \ space.  Also note that \"=<\" means less than or\n  equal to (modulo 2**32).\n\
    \                                           Transmission Control Protocol\n  \
    \                                              Functional Specification\n  A natural\
    \ way to think about processing incoming segments is to\n  imagine that they are\
    \ first tested for proper sequence number (i.e.,\n  that their contents lie in\
    \ the range of the expected \"receive window\"\n  in the sequence number space)\
    \ and then that they are generally queued\n  and processed in sequence number\
    \ order.\n  When a segment overlaps other already received segments we reconstruct\n\
    \  the segment to contain just the new data, and adjust the header fields\n  to\
    \ be consistent.\n  Note that if no state change is mentioned the TCP stays in\
    \ the same\n  state.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \             OPEN Call\n  OPEN Call\n    CLOSED STATE (i.e., TCB does not exist)\n\
    \      Create a new transmission control block (TCB) to hold connection\n    \
    \  state information.  Fill in local socket identifier, foreign\n      socket,\
    \ precedence, security/compartment, and user timeout\n      information.  Note\
    \ that some parts of the foreign socket may be\n      unspecified in a passive\
    \ OPEN and are to be filled in by the\n      parameters of the incoming SYN segment.\
    \  Verify the security and\n      precedence requested are allowed for this user,\
    \ if not return\n      \"error:  precedence not allowed\" or \"error:  security/compartment\n\
    \      not allowed.\"  If passive enter the LISTEN state and return.  If\n   \
    \   active and the foreign socket is unspecified, return \"error:\n      foreign\
    \ socket unspecified\"; if active and the foreign socket is\n      specified,\
    \ issue a SYN segment.  An initial send sequence number\n      (ISS) is selected.\
    \  A SYN segment of the form <SEQ=ISS><CTL=SYN>\n      is sent.  Set SND.UNA to\
    \ ISS, SND.NXT to ISS+1, enter SYN-SENT\n      state, and return.\n      If the\
    \ caller does not have access to the local socket specified,\n      return \"\
    error:  connection illegal for this process\".  If there is\n      no room to\
    \ create a new connection, return \"error:  insufficient\n      resources\".\n\
    \    LISTEN STATE\n      If active and the foreign socket is specified, then change\
    \ the\n      connection from passive to active, select an ISS.  Send a SYN\n \
    \     segment, set SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT\n      state.\
    \  Data associated with SEND may be sent with SYN segment or\n      queued for\
    \ transmission after entering ESTABLISHED state.  The\n      urgent bit if requested\
    \ in the command must be sent with the data\n      segments sent as a result of\
    \ this command.  If there is no room to\n      queue the request, respond with\
    \ \"error:  insufficient resources\".\n      If Foreign socket was not specified,\
    \ then return \"error:  foreign\n      socket unspecified\".\n               \
    \                            Transmission Control Protocol\n                 \
    \                               Functional Specification\n"
- title: OPEN Call
  contents:
  - "OPEN Call\n    SYN-SENT STATE\n    SYN-RECEIVED STATE\n    ESTABLISHED STATE\n\
    \    FIN-WAIT-1 STATE\n    FIN-WAIT-2 STATE\n    CLOSE-WAIT STATE\n    CLOSING\
    \ STATE\n    LAST-ACK STATE\n    TIME-WAIT STATE\n      Return \"error:  connection\
    \ already exists\".\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \             SEND Call\n  SEND Call\n    CLOSED STATE (i.e., TCB does not exist)\n\
    \      If the user does not have access to such a connection, then return\n  \
    \    \"error:  connection illegal for this process\".\n      Otherwise, return\
    \ \"error:  connection does not exist\".\n    LISTEN STATE\n      If the foreign\
    \ socket is specified, then change the connection\n      from passive to active,\
    \ select an ISS.  Send a SYN segment, set\n      SND.UNA to ISS, SND.NXT to ISS+1.\
    \  Enter SYN-SENT state.  Data\n      associated with SEND may be sent with SYN\
    \ segment or queued for\n      transmission after entering ESTABLISHED state.\
    \  The urgent bit if\n      requested in the command must be sent with the data\
    \ segments sent\n      as a result of this command.  If there is no room to queue\
    \ the\n      request, respond with \"error:  insufficient resources\".  If\n \
    \     Foreign socket was not specified, then return \"error:  foreign\n      socket\
    \ unspecified\".\n    SYN-SENT STATE\n    SYN-RECEIVED STATE\n      Queue the\
    \ data for transmission after entering ESTABLISHED state.\n      If no space to\
    \ queue, respond with \"error:  insufficient\n      resources\".\n    ESTABLISHED\
    \ STATE\n    CLOSE-WAIT STATE\n      Segmentize the buffer and send it with a\
    \ piggybacked\n      acknowledgment (acknowledgment value = RCV.NXT).  If there\
    \ is\n      insufficient space to remember this buffer, simply return \"error:\n\
    \      insufficient resources\".\n      If the urgent flag is set, then SND.UP\
    \ <- SND.NXT-1 and set the\n      urgent pointer in the outgoing segments.\n \
    \                                          Transmission Control Protocol\n   \
    \                                             Functional Specification\n"
- title: SEND Call
  contents:
  - "SEND Call\n    FIN-WAIT-1 STATE\n    FIN-WAIT-2 STATE\n    CLOSING STATE\n  \
    \  LAST-ACK STATE\n    TIME-WAIT STATE\n      Return \"error:  connection closing\"\
    \ and do not service request.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \          RECEIVE Call\n  RECEIVE Call\n    CLOSED STATE (i.e., TCB does not\
    \ exist)\n      If the user does not have access to such a connection, return\n\
    \      \"error:  connection illegal for this process\".\n      Otherwise return\
    \ \"error:  connection does not exist\".\n    LISTEN STATE\n    SYN-SENT STATE\n\
    \    SYN-RECEIVED STATE\n      Queue for processing after entering ESTABLISHED\
    \ state.  If there\n      is no room to queue this request, respond with \"error:\n\
    \      insufficient resources\".\n    ESTABLISHED STATE\n    FIN-WAIT-1 STATE\n\
    \    FIN-WAIT-2 STATE\n      If insufficient incoming segments are queued to satisfy\
    \ the\n      request, queue the request.  If there is no queue space to\n    \
    \  remember the RECEIVE, respond with \"error:  insufficient\n      resources\"\
    .\n      Reassemble queued incoming segments into receive buffer and return\n\
    \      to user.  Mark \"push seen\" (PUSH) if this is the case.\n      If RCV.UP\
    \ is in advance of the data currently being passed to the\n      user notify the\
    \ user of the presence of urgent data.\n      When the TCP takes responsibility\
    \ for delivering data to the user\n      that fact must be communicated to the\
    \ sender via an\n      acknowledgment.  The formation of such an acknowledgment\
    \ is\n      described below in the discussion of processing an incoming\n    \
    \  segment.\n                                           Transmission Control Protocol\n\
    \                                                Functional Specification\n"
- title: RECEIVE Call
  contents:
  - "RECEIVE Call\n    CLOSE-WAIT STATE\n      Since the remote side has already sent\
    \ FIN, RECEIVEs must be\n      satisfied by text already on hand, but not yet\
    \ delivered to the\n      user.  If no text is awaiting delivery, the RECEIVE\
    \ will get a\n      \"error:  connection closing\" response.  Otherwise, any remaining\n\
    \      text can be used to satisfy the RECEIVE.\n    CLOSING STATE\n    LAST-ACK\
    \ STATE\n    TIME-WAIT STATE\n      Return \"error:  connection closing\".\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \            CLOSE Call\n  CLOSE Call\n    CLOSED STATE (i.e., TCB does not exist)\n\
    \      If the user does not have access to such a connection, return\n      \"\
    error:  connection illegal for this process\".\n      Otherwise, return \"error:\
    \  connection does not exist\".\n    LISTEN STATE\n      Any outstanding RECEIVEs\
    \ are returned with \"error:  closing\"\n      responses.  Delete TCB, enter CLOSED\
    \ state, and return.\n    SYN-SENT STATE\n      Delete the TCB and return \"error:\
    \  closing\" responses to any\n      queued SENDs, or RECEIVEs.\n    SYN-RECEIVED\
    \ STATE\n      If no SENDs have been issued and there is no pending data to send,\n\
    \      then form a FIN segment and send it, and enter FIN-WAIT-1 state;\n    \
    \  otherwise queue for processing after entering ESTABLISHED state.\n    ESTABLISHED\
    \ STATE\n      Queue this until all preceding SENDs have been segmentized, then\n\
    \      form a FIN segment and send it.  In any case, enter FIN-WAIT-1\n      state.\n\
    \    FIN-WAIT-1 STATE\n    FIN-WAIT-2 STATE\n      Strictly speaking, this is\
    \ an error and should receive a \"error:\n      connection closing\" response.\
    \  An \"ok\" response would be\n      acceptable, too, as long as a second FIN\
    \ is not emitted (the first\n      FIN may be retransmitted though).\n       \
    \                                    Transmission Control Protocol\n         \
    \                                       Functional Specification\n"
- title: CLOSE Call
  contents:
  - "CLOSE Call\n    CLOSE-WAIT STATE\n      Queue this request until all preceding\
    \ SENDs have been\n      segmentized; then send a FIN segment, enter CLOSING state.\n\
    \    CLOSING STATE\n    LAST-ACK STATE\n    TIME-WAIT STATE\n      Respond with\
    \ \"error:  connection closing\".\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \            ABORT Call\n  ABORT Call\n    CLOSED STATE (i.e., TCB does not exist)\n\
    \      If the user should not have access to such a connection, return\n     \
    \ \"error:  connection illegal for this process\".\n      Otherwise return \"\
    error:  connection does not exist\".\n    LISTEN STATE\n      Any outstanding\
    \ RECEIVEs should be returned with \"error:\n      connection reset\" responses.\
    \  Delete TCB, enter CLOSED state, and\n      return.\n    SYN-SENT STATE\n  \
    \    All queued SENDs and RECEIVEs should be given \"connection reset\"\n    \
    \  notification, delete the TCB, enter CLOSED state, and return.\n    SYN-RECEIVED\
    \ STATE\n    ESTABLISHED STATE\n    FIN-WAIT-1 STATE\n    FIN-WAIT-2 STATE\n \
    \   CLOSE-WAIT STATE\n      Send a reset segment:\n        <SEQ=SND.NXT><CTL=RST>\n\
    \      All queued SENDs and RECEIVEs should be given \"connection reset\"\n  \
    \    notification; all segments queued for transmission (except for the\n    \
    \  RST formed above) or retransmission should be flushed, delete the\n      TCB,\
    \ enter CLOSED state, and return.\n    CLOSING STATE\n    LAST-ACK STATE\n   \
    \ TIME-WAIT STATE\n      Respond with \"ok\" and delete the TCB, enter CLOSED\
    \ state, and\n      return.\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n"
- title: STATUS Call
  contents:
  - "STATUS Call\n  STATUS Call\n    CLOSED STATE (i.e., TCB does not exist)\n   \
    \   If the user should not have access to such a connection, return\n      \"\
    error:  connection illegal for this process\".\n      Otherwise return \"error:\
    \  connection does not exist\".\n    LISTEN STATE\n      Return \"state = LISTEN\"\
    , and the TCB pointer.\n    SYN-SENT STATE\n      Return \"state = SYN-SENT\"\
    , and the TCB pointer.\n    SYN-RECEIVED STATE\n      Return \"state = SYN-RECEIVED\"\
    , and the TCB pointer.\n    ESTABLISHED STATE\n      Return \"state = ESTABLISHED\"\
    , and the TCB pointer.\n    FIN-WAIT-1 STATE\n      Return \"state = FIN-WAIT-1\"\
    , and the TCB pointer.\n    FIN-WAIT-2 STATE\n      Return \"state = FIN-WAIT-2\"\
    , and the TCB pointer.\n    CLOSE-WAIT STATE\n      Return \"state = CLOSE-WAIT\"\
    , and the TCB pointer.\n    CLOSING STATE\n      Return \"state = CLOSING\", and\
    \ the TCB pointer.\n    LAST-ACK STATE\n      Return \"state = LAST-ACK\", and\
    \ the TCB pointer.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \           STATUS Call\n    TIME-WAIT STATE\n      Return \"state = TIME-WAIT\"\
    , and the TCB pointer.\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n  SEGMENT ARRIVES\n    If the state is CLOSED (i.e., TCB does\
    \ not exist) then\n      all data in the incoming segment is discarded.  An incoming\n\
    \      segment containing a RST is discarded.  An incoming segment not\n     \
    \ containing a RST causes a RST to be sent in response.  The\n      acknowledgment\
    \ and sequence field values are selected to make the\n      reset sequence acceptable\
    \ to the TCP that sent the offending\n      segment.\n      If the ACK bit is\
    \ off, sequence number zero is used,\n        <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n\
    \      If the ACK bit is on,\n        <SEQ=SEG.ACK><CTL=RST>\n      Return.\n\
    \    If the state is LISTEN then\n      first check for an RST\n        An incoming\
    \ RST should be ignored.  Return.\n      second check for an ACK\n        Any\
    \ acknowledgment is bad if it arrives on a connection still in\n        the LISTEN\
    \ state.  An acceptable reset segment should be formed\n        for any arriving\
    \ ACK-bearing segment.  The RST should be\n        formatted as follows:\n   \
    \       <SEQ=SEG.ACK><CTL=RST>\n        Return.\n      third check for a SYN\n\
    \        If the SYN bit is set, check the security.  If the\n        security/compartment\
    \ on the incoming segment does not exactly\n        match the security/compartment\
    \ in the TCB then send a reset and\n        return.\n          <SEQ=SEG.ACK><CTL=RST>\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n        If the SEG.PRC is greater than the TCB.PRC then\
    \ if allowed by\n        the user and the system set TCB.PRC<-SEG.PRC, if not\
    \ allowed\n        send a reset and return.\n          <SEQ=SEG.ACK><CTL=RST>\n\
    \        If the SEG.PRC is less than the TCB.PRC then continue.\n        Set RCV.NXT\
    \ to SEG.SEQ+1, IRS is set to SEG.SEQ and any other\n        control or text should\
    \ be queued for processing later.  ISS\n        should be selected and a SYN segment\
    \ sent of the form:\n          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n        SND.NXT\
    \ is set to ISS+1 and SND.UNA to ISS.  The connection\n        state should be\
    \ changed to SYN-RECEIVED.  Note that any other\n        incoming control or data\
    \ (combined with SYN) will be processed\n        in the SYN-RECEIVED state, but\
    \ processing of SYN and ACK should\n        not be repeated.  If the listen was\
    \ not fully specified (i.e.,\n        the foreign socket was not fully specified),\
    \ then the\n        unspecified fields should be filled in now.\n      fourth\
    \ other text or control\n        Any other control or text-bearing segment (not\
    \ containing SYN)\n        must have an ACK and thus would be discarded by the\
    \ ACK\n        processing.  An incoming RST segment could not be valid, since\n\
    \        it could not have been sent in response to anything sent by this\n  \
    \      incarnation of the connection.  So you are unlikely to get here,\n    \
    \    but if you do, drop the segment, and return.\n    If the state is SYN-SENT\
    \ then\n      first check the ACK bit\n        If the ACK bit is set\n       \
    \   If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless\n          the\
    \ RST bit is set, if so drop the segment and return)\n            <SEQ=SEG.ACK><CTL=RST>\n\
    \          and discard the segment.  Return.\n          If SND.UNA =< SEG.ACK\
    \ =< SND.NXT then the ACK is acceptable.\n      second check the RST bit\n   \
    \                                        Transmission Control Protocol\n     \
    \                                           Functional Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n        If the RST bit is set\n          If the ACK was acceptable\
    \ then signal the user \"error:\n          connection reset\", drop the segment,\
    \ enter CLOSED state,\n          delete TCB, and return.  Otherwise (no ACK) drop\
    \ the segment\n          and return.\n      third check the security and precedence\n\
    \        If the security/compartment in the segment does not exactly\n       \
    \ match the security/compartment in the TCB, send a reset\n          If there\
    \ is an ACK\n            <SEQ=SEG.ACK><CTL=RST>\n          Otherwise\n       \
    \     <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n        If there is an ACK\n\
    \          The precedence in the segment must match the precedence in the\n  \
    \        TCB, if not, send a reset\n            <SEQ=SEG.ACK><CTL=RST>\n     \
    \   If there is no ACK\n          If the precedence in the segment is higher than\
    \ the precedence\n          in the TCB then if allowed by the user and the system\
    \ raise\n          the precedence in the TCB to that in the segment, if not\n\
    \          allowed to raise the prec then send a reset.\n            <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n\
    \          If the precedence in the segment is lower than the precedence\n   \
    \       in the TCB continue.\n        If a reset was sent, discard the segment\
    \ and return.\n      fourth check the SYN bit\n        This step should be reached\
    \ only if the ACK is ok, or there is\n        no ACK, and it the segment did not\
    \ contain a RST.\n        If the SYN bit is on and the security/compartment and\
    \ precedence\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n        are acceptable then, RCV.NXT is set to SEG.SEQ+1,\
    \ IRS is set to\n        SEG.SEQ.  SND.UNA should be advanced to equal SEG.ACK\
    \ (if there\n        is an ACK), and any segments on the retransmission queue\
    \ which\n        are thereby acknowledged should be removed.\n        If SND.UNA\
    \ > ISS (our SYN has been ACKed), change the connection\n        state to ESTABLISHED,\
    \ form an ACK segment\n          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n       \
    \ and send it.  Data or controls which were queued for\n        transmission may\
    \ be included.  If there are other controls or\n        text in the segment then\
    \ continue processing at the sixth step\n        below where the URG bit is checked,\
    \ otherwise return.\n        Otherwise enter SYN-RECEIVED, form a SYN,ACK segment\n\
    \          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n        and send it.  If there\
    \ are other controls or text in the\n        segment, queue them for processing\
    \ after the ESTABLISHED state\n        has been reached, return.\n      fifth,\
    \ if neither of the SYN or RST bits is set then drop the\n      segment and return.\n\
    \                                           Transmission Control Protocol\n  \
    \                                              Functional Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n    Otherwise,\n    first check sequence number\n      SYN-RECEIVED\
    \ STATE\n      ESTABLISHED STATE\n      FIN-WAIT-1 STATE\n      FIN-WAIT-2 STATE\n\
    \      CLOSE-WAIT STATE\n      CLOSING STATE\n      LAST-ACK STATE\n      TIME-WAIT\
    \ STATE\n        Segments are processed in sequence.  Initial tests on arrival\n\
    \        are used to discard old duplicates, but further processing is\n     \
    \   done in SEG.SEQ order.  If a segment's contents straddle the\n        boundary\
    \ between old and new, only the new parts should be\n        processed.\n    \
    \    There are four cases for the acceptability test for an incoming\n       \
    \ segment:\n        Segment Receive  Test\n        Length  Window\n        -------\
    \ -------  -------------------------------------------\n           0       0 \
    \    SEG.SEQ = RCV.NXT\n           0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND\n\
    \          >0       0     not acceptable\n          >0      >0     RCV.NXT =<\
    \ SEG.SEQ < RCV.NXT+RCV.WND\n                      or RCV.NXT =< SEG.SEQ+SEG.LEN-1\
    \ < RCV.NXT+RCV.WND\n        If the RCV.WND is zero, no segments will be acceptable,\
    \ but\n        special allowance should be made to accept valid ACKs, URGs and\n\
    \        RSTs.\n        If an incoming segment is not acceptable, an acknowledgment\n\
    \        should be sent in reply (unless the RST bit is set, if so drop\n    \
    \    the segment and return):\n          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\
    \        After sending the acknowledgment, drop the unacceptable segment\n   \
    \     and return.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n        In the following it is assumed that the segment\
    \ is the idealized\n        segment that begins at RCV.NXT and does not exceed\
    \ the window.\n        One could tailor actual segments to fit this assumption\
    \ by\n        trimming off any portions that lie outside the window (including\n\
    \        SYN and FIN), and only processing further if the segment then\n     \
    \   begins at RCV.NXT.  Segments with higher begining sequence\n        numbers\
    \ may be held for later processing.\n    second check the RST bit,\n      SYN-RECEIVED\
    \ STATE\n        If the RST bit is set\n          If this connection was initiated\
    \ with a passive OPEN (i.e.,\n          came from the LISTEN state), then return\
    \ this connection to\n          LISTEN state and return.  The user need not be\
    \ informed.  If\n          this connection was initiated with an active OPEN (i.e.,\
    \ came\n          from SYN-SENT state) then the connection was refused, signal\n\
    \          the user \"connection refused\".  In either case, all segments\n  \
    \        on the retransmission queue should be removed.  And in the\n        \
    \  active OPEN case, enter the CLOSED state and delete the TCB,\n          and\
    \ return.\n      ESTABLISHED\n      FIN-WAIT-1\n      FIN-WAIT-2\n      CLOSE-WAIT\n\
    \        If the RST bit is set then, any outstanding RECEIVEs and SEND\n     \
    \   should receive \"reset\" responses.  All segment queues should be\n      \
    \  flushed.  Users should also receive an unsolicited general\n        \"connection\
    \ reset\" signal.  Enter the CLOSED state, delete the\n        TCB, and return.\n\
    \      CLOSING STATE\n      LAST-ACK STATE\n      TIME-WAIT\n        If the RST\
    \ bit is set then, enter the CLOSED state, delete the\n        TCB, and return.\n\
    \                                           Transmission Control Protocol\n  \
    \                                              Functional Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n    third check security and precedence\n      SYN-RECEIVED\n\
    \        If the security/compartment and precedence in the segment do not\n  \
    \      exactly match the security/compartment and precedence in the TCB\n    \
    \    then send a reset, and return.\n      ESTABLISHED STATE\n        If the security/compartment\
    \ and precedence in the segment do not\n        exactly match the security/compartment\
    \ and precedence in the TCB\n        then send a reset, any outstanding RECEIVEs\
    \ and SEND should\n        receive \"reset\" responses.  All segment queues should\
    \ be\n        flushed.  Users should also receive an unsolicited general\n   \
    \     \"connection reset\" signal.  Enter the CLOSED state, delete the\n     \
    \   TCB, and return.\n      Note this check is placed following the sequence check\
    \ to prevent\n      a segment from an old connection between these ports with\
    \ a\n      different security or precedence from causing an abort of the\n   \
    \   current connection.\n    fourth, check the SYN bit,\n      SYN-RECEIVED\n\
    \      ESTABLISHED STATE\n      FIN-WAIT STATE-1\n      FIN-WAIT STATE-2\n   \
    \   CLOSE-WAIT STATE\n      CLOSING STATE\n      LAST-ACK STATE\n      TIME-WAIT\
    \ STATE\n        If the SYN is in the window it is an error, send a reset, any\n\
    \        outstanding RECEIVEs and SEND should receive \"reset\" responses,\n \
    \       all segment queues should be flushed, the user should also\n        receive\
    \ an unsolicited general \"connection reset\" signal, enter\n        the CLOSED\
    \ state, delete the TCB, and return.\n        If the SYN is not in the window\
    \ this step would not be reached\n        and an ack would have been sent in the\
    \ first step (sequence\n        number check).\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n    fifth check the ACK field,\n      if the ACK bit\
    \ is off drop the segment and return\n      if the ACK bit is on\n        SYN-RECEIVED\
    \ STATE\n          If SND.UNA =< SEG.ACK =< SND.NXT then enter ESTABLISHED state\n\
    \          and continue processing.\n            If the segment acknowledgment\
    \ is not acceptable, form a\n            reset segment,\n              <SEQ=SEG.ACK><CTL=RST>\n\
    \            and send it.\n        ESTABLISHED STATE\n          If SND.UNA < SEG.ACK\
    \ =< SND.NXT then, set SND.UNA <- SEG.ACK.\n          Any segments on the retransmission\
    \ queue which are thereby\n          entirely acknowledged are removed.  Users\
    \ should receive\n          positive acknowledgments for buffers which have been\
    \ SENT and\n          fully acknowledged (i.e., SEND buffer should be returned\
    \ with\n          \"ok\" response).  If the ACK is a duplicate\n          (SEG.ACK\
    \ < SND.UNA), it can be ignored.  If the ACK acks\n          something not yet\
    \ sent (SEG.ACK > SND.NXT) then send an ACK,\n          drop the segment, and\
    \ return.\n          If SND.UNA < SEG.ACK =< SND.NXT, the send window should be\n\
    \          updated.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ and\n       \
    \   SND.WL2 =< SEG.ACK)), set SND.WND <- SEG.WND, set\n          SND.WL1 <- SEG.SEQ,\
    \ and set SND.WL2 <- SEG.ACK.\n          Note that SND.WND is an offset from SND.UNA,\
    \ that SND.WL1\n          records the sequence number of the last segment used\
    \ to update\n          SND.WND, and that SND.WL2 records the acknowledgment number\
    \ of\n          the last segment used to update SND.WND.  The check here\n   \
    \       prevents using old segments to update the window.\n                  \
    \                         Transmission Control Protocol\n                    \
    \                            Functional Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n        FIN-WAIT-1 STATE\n          In addition to the processing\
    \ for the ESTABLISHED state, if\n          our FIN is now acknowledged then enter\
    \ FIN-WAIT-2 and continue\n          processing in that state.\n        FIN-WAIT-2\
    \ STATE\n          In addition to the processing for the ESTABLISHED state, if\n\
    \          the retransmission queue is empty, the user's CLOSE can be\n      \
    \    acknowledged (\"ok\") but do not delete the TCB.\n        CLOSE-WAIT STATE\n\
    \          Do the same processing as for the ESTABLISHED state.\n        CLOSING\
    \ STATE\n          In addition to the processing for the ESTABLISHED state, if\n\
    \          the ACK acknowledges our FIN then enter the TIME-WAIT state,\n    \
    \      otherwise ignore the segment.\n        LAST-ACK STATE\n          The only\
    \ thing that can arrive in this state is an\n          acknowledgment of our FIN.\
    \  If our FIN is now acknowledged,\n          delete the TCB, enter the CLOSED\
    \ state, and return.\n        TIME-WAIT STATE\n          The only thing that can\
    \ arrive in this state is a\n          retransmission of the remote FIN.  Acknowledge\
    \ it, and restart\n          the 2 MSL timeout.\n    sixth, check the URG bit,\n\
    \      ESTABLISHED STATE\n      FIN-WAIT-1 STATE\n      FIN-WAIT-2 STATE\n   \
    \     If the URG bit is set, RCV.UP <- max(RCV.UP,SEG.UP), and signal\n      \
    \  the user that the remote side has urgent data if the urgent\n        pointer\
    \ (RCV.UP) is in advance of the data consumed.  If the\n        user has already\
    \ been signaled (or is still in the \"urgent\n        mode\") for this continuous\
    \ sequence of urgent data, do not\n        signal the user again.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n      CLOSE-WAIT STATE\n      CLOSING STATE\n      LAST-ACK\
    \ STATE\n      TIME-WAIT\n        This should not occur, since a FIN has been\
    \ received from the\n        remote side.  Ignore the URG.\n    seventh, process\
    \ the segment text,\n      ESTABLISHED STATE\n      FIN-WAIT-1 STATE\n      FIN-WAIT-2\
    \ STATE\n        Once in the ESTABLISHED state, it is possible to deliver segment\n\
    \        text to user RECEIVE buffers.  Text from segments can be moved\n    \
    \    into buffers until either the buffer is full or the segment is\n        empty.\
    \  If the segment empties and carries an PUSH flag, then\n        the user is\
    \ informed, when the buffer is returned, that a PUSH\n        has been received.\n\
    \        When the TCP takes responsibility for delivering the data to the\n  \
    \      user it must also acknowledge the receipt of the data.\n        Once the\
    \ TCP takes responsibility for the data it advances\n        RCV.NXT over the\
    \ data accepted, and adjusts RCV.WND as\n        apporopriate to the current buffer\
    \ availability.  The total of\n        RCV.NXT and RCV.WND should not be reduced.\n\
    \        Please note the window management suggestions in section 3.7.\n     \
    \   Send an acknowledgment of the form:\n          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\
    \        This acknowledgment should be piggybacked on a segment being\n      \
    \  transmitted if possible without incurring undue delay.\n                  \
    \                         Transmission Control Protocol\n                    \
    \                            Functional Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n      CLOSE-WAIT STATE\n      CLOSING STATE\n      LAST-ACK\
    \ STATE\n      TIME-WAIT STATE\n        This should not occur, since a FIN has\
    \ been received from the\n        remote side.  Ignore the segment text.\n   \
    \ eighth, check the FIN bit,\n      Do not process the FIN if the state is CLOSED,\
    \ LISTEN or SYN-SENT\n      since the SEG.SEQ cannot be validated; drop the segment\
    \ and\n      return.\n      If the FIN bit is set, signal the user \"connection\
    \ closing\" and\n      return any pending RECEIVEs with same message, advance\
    \ RCV.NXT\n      over the FIN, and send an acknowledgment for the FIN.  Note that\n\
    \      FIN implies PUSH for any segment text not yet delivered to the\n      user.\n\
    \        SYN-RECEIVED STATE\n        ESTABLISHED STATE\n          Enter the CLOSE-WAIT\
    \ state.\n        FIN-WAIT-1 STATE\n          If our FIN has been ACKed (perhaps\
    \ in this segment), then\n          enter TIME-WAIT, start the time-wait timer,\
    \ turn off the other\n          timers; otherwise enter the CLOSING state.\n \
    \       FIN-WAIT-2 STATE\n          Enter the TIME-WAIT state.  Start the time-wait\
    \ timer, turn\n          off the other timers.\n        CLOSE-WAIT STATE\n   \
    \       Remain in the CLOSE-WAIT state.\n        CLOSING STATE\n          Remain\
    \ in the CLOSING state.\n        LAST-ACK STATE\n          Remain in the LAST-ACK\
    \ state.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n        TIME-WAIT STATE\n          Remain in the TIME-WAIT\
    \ state.  Restart the 2 MSL time-wait\n          timeout.\n    and return.\n \
    \                                          Transmission Control Protocol\n   \
    \                                             Functional Specification\n"
- title: USER TIMEOUT
  contents:
  - "USER TIMEOUT\n  USER TIMEOUT\n    For any state if the user timeout expires,\
    \ flush all queues, signal\n    the user \"error:  connection aborted due to user\
    \ timeout\" in general\n    and for any outstanding calls, delete the TCB, enter\
    \ the CLOSED\n    state and return.\n  RETRANSMISSION TIMEOUT\n    For any state\
    \ if the retransmission timeout expires on a segment in\n    the retransmission\
    \ queue, send the segment at the front of the\n    retransmission queue again,\
    \ reinitialize the retransmission timer,\n    and return.\n  TIME-WAIT TIMEOUT\n\
    \    If the time-wait timeout expires on a connection delete the TCB,\n    enter\
    \ the CLOSED state and return.\n"
- title: Transmission Control Protocol
  contents:
  - "Transmission Control Protocol\n                                           Transmission\
    \ Control Protocol\n                                GLOSSARY\n"
- title: '1822'
  contents:
  - "1822\n          BBN Report 1822, \"The Specification of the Interconnection of\n\
    \          a Host and an IMP\".  The specification of interface between a\n  \
    \        host and the ARPANET.\n"
- title: ACK
  contents:
  - "ACK\n          A control bit (acknowledge) occupying no sequence space, which\n\
    \          indicates that the acknowledgment field of this segment\n         \
    \ specifies the next sequence number the sender of this segment\n          is\
    \ expecting to receive, hence acknowledging receipt of all\n          previous\
    \ sequence numbers.\n"
- title: ARPANET message
  contents:
  - "ARPANET message\n          The unit of transmission between a host and an IMP\
    \ in the\n          ARPANET.  The maximum size is about 1012 octets (8096 bits).\n"
- title: ARPANET packet
  contents:
  - "ARPANET packet\n          A unit of transmission used internally in the ARPANET\
    \ between\n          IMPs.  The maximum size is about 126 octets (1008 bits).\n"
- title: connection
  contents:
  - "connection\n          A logical communication path identified by a pair of sockets.\n"
- title: datagram
  contents:
  - "datagram\n          A message sent in a packet switched computer communications\n\
    \          network.\n"
- title: Destination Address
  contents:
  - "Destination Address\n          The destination address, usually the network and\
    \ host\n          identifiers.\n"
- title: FIN
  contents:
  - "FIN\n          A control bit (finis) occupying one sequence number, which\n \
    \         indicates that the sender will send no more data or control\n      \
    \    occupying sequence space.\n"
- title: fragment
  contents:
  - "fragment\n          A portion of a logical unit of data, in particular an internet\n\
    \          fragment is a portion of an internet datagram.\n"
- title: FTP
  contents:
  - "FTP\n          A file transfer protocol.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Glossary
  contents:
  - 'Glossary

    '
- title: header
  contents:
  - "header\n          Control information at the beginning of a message, segment,\n\
    \          fragment, packet or block of data.\n"
- title: host
  contents:
  - "host\n          A computer.  In particular a source or destination of messages\n\
    \          from the point of view of the communication network.\n"
- title: Identification
  contents:
  - "Identification\n          An Internet Protocol field.  This identifying value\
    \ assigned\n          by the sender aids in assembling the fragments of a datagram.\n"
- title: IMP
  contents:
  - "IMP\n          The Interface Message Processor, the packet switch of the\n  \
    \        ARPANET.\n"
- title: internet address
  contents:
  - "internet address\n          A source or destination address specific to the host\
    \ level.\n"
- title: internet datagram
  contents:
  - "internet datagram\n          The unit of data exchanged between an internet module\
    \ and the\n          higher level protocol together with the internet header.\n"
- title: internet fragment
  contents:
  - "internet fragment\n          A portion of the data of an internet datagram with\
    \ an internet\n          header.\n"
- title: IP
  contents:
  - "IP\n          Internet Protocol.\n"
- title: IRS
  contents:
  - "IRS\n          The Initial Receive Sequence number.  The first sequence\n   \
    \       number used by the sender on a connection.\n"
- title: ISN
  contents:
  - "ISN\n          The Initial Sequence Number.  The first sequence number used\n\
    \          on a connection, (either ISS or IRS).  Selected on a clock\n      \
    \    based procedure.\n"
- title: ISS
  contents:
  - "ISS\n          The Initial Send Sequence number.  The first sequence number\n\
    \          used by the sender on a connection.\n"
- title: leader
  contents:
  - "leader\n          Control information at the beginning of a message or block\
    \ of\n          data.  In particular, in the ARPANET, the control information\n\
    \          on an ARPANET message at the host-IMP interface.\n                \
    \                           Transmission Control Protocol\n                  \
    \                                              Glossary\n"
- title: left sequence
  contents:
  - "left sequence\n          This is the next sequence number to be acknowledged\
    \ by the\n          data receiving TCP (or the lowest currently unacknowledged\n\
    \          sequence number) and is sometimes referred to as the left edge\n  \
    \        of the send window.\n"
- title: local packet
  contents:
  - "local packet\n          The unit of transmission within a local network.\n"
- title: module
  contents:
  - "module\n          An implementation, usually in software, of a protocol or other\n\
    \          procedure.\n"
- title: MSL
  contents:
  - "MSL\n          Maximum Segment Lifetime, the time a TCP segment can exist in\n\
    \          the internetwork system.  Arbitrarily defined to be 2 minutes.\n"
- title: octet
  contents:
  - "octet\n          An eight bit byte.\n"
- title: Options
  contents:
  - "Options\n          An Option field may contain several options, and each option\n\
    \          may be several octets in length.  The options are used\n          primarily\
    \ in testing situations; for example, to carry\n          timestamps.  Both the\
    \ Internet Protocol and TCP provide for\n          options fields.\n"
- title: packet
  contents:
  - "packet\n          A package of data with a header which may or may not be\n \
    \         logically complete.  More often a physical packaging than a\n      \
    \    logical packaging of data.\n"
- title: port
  contents:
  - "port\n          The portion of a socket that specifies which logical input or\n\
    \          output channel of a process is associated with the data.\n"
- title: process
  contents:
  - "process\n          A program in execution.  A source or destination of data from\n\
    \          the point of view of the TCP or other host-to-host protocol.\n"
- title: PUSH
  contents:
  - "PUSH\n          A control bit occupying no sequence space, indicating that\n\
    \          this segment contains data that must be pushed through to the\n   \
    \       receiving user.\n"
- title: RCV.NXT
  contents:
  - "RCV.NXT\n          receive next sequence number\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Glossary
  contents:
  - 'Glossary

    '
- title: RCV.UP
  contents:
  - "RCV.UP\n          receive urgent pointer\n"
- title: RCV.WND
  contents:
  - "RCV.WND\n          receive window\n"
- title: receive next sequence number
  contents:
  - "receive next sequence number\n          This is the next sequence number the\
    \ local TCP is expecting to\n          receive.\n"
- title: receive window
  contents:
  - "receive window\n          This represents the sequence numbers the local (receiving)\
    \ TCP\n          is willing to receive.  Thus, the local TCP considers that\n\
    \          segments overlapping the range RCV.NXT to\n          RCV.NXT + RCV.WND\
    \ - 1 carry acceptable data or control.\n          Segments containing sequence\
    \ numbers entirely outside of this\n          range are considered duplicates\
    \ and discarded.\n"
- title: RST
  contents:
  - "RST\n          A control bit (reset), occupying no sequence space, indicating\n\
    \          that the receiver should delete the connection without further\n  \
    \        interaction.  The receiver can determine, based on the\n          sequence\
    \ number and acknowledgment fields of the incoming\n          segment, whether\
    \ it should honor the reset command or ignore\n          it.  In no case does\
    \ receipt of a segment containing RST give\n          rise to a RST in response.\n"
- title: RTP
  contents:
  - "RTP\n          Real Time Protocol:  A host-to-host protocol for communication\n\
    \          of time critical information.\n"
- title: SEG.ACK
  contents:
  - "SEG.ACK\n          segment acknowledgment\n"
- title: SEG.LEN
  contents:
  - "SEG.LEN\n          segment length\n"
- title: SEG.PRC
  contents:
  - "SEG.PRC\n          segment precedence value\n"
- title: SEG.SEQ
  contents:
  - "SEG.SEQ\n          segment sequence\n"
- title: SEG.UP
  contents:
  - "SEG.UP\n          segment urgent pointer field\n                            \
    \               Transmission Control Protocol\n                              \
    \                                  Glossary\n"
- title: SEG.WND
  contents:
  - "SEG.WND\n          segment window field\n"
- title: segment
  contents:
  - "segment\n          A logical unit of data, in particular a TCP segment is the\n\
    \          unit of data transfered between a pair of TCP modules.\n"
- title: segment acknowledgment
  contents:
  - "segment acknowledgment\n          The sequence number in the acknowledgment field\
    \ of the\n          arriving segment.\n"
- title: segment length
  contents:
  - "segment length\n          The amount of sequence number space occupied by a segment,\n\
    \          including any controls which occupy sequence space.\n"
- title: segment sequence
  contents:
  - "segment sequence\n          The number in the sequence field of the arriving\
    \ segment.\n"
- title: send sequence
  contents:
  - "send sequence\n          This is the next sequence number the local (sending)\
    \ TCP will\n          use on the connection.  It is initially selected from an\n\
    \          initial sequence number curve (ISN) and is incremented for\n      \
    \    each octet of data or sequenced control transmitted.\n"
- title: send window
  contents:
  - "send window\n          This represents the sequence numbers which the remote\n\
    \          (receiving) TCP is willing to receive.  It is the value of the\n  \
    \        window field specified in segments from the remote (data\n          receiving)\
    \ TCP.  The range of new sequence numbers which may\n          be emitted by a\
    \ TCP lies between SND.NXT and\n          SND.UNA + SND.WND - 1. (Retransmissions\
    \ of sequence numbers\n          between SND.UNA and SND.NXT are expected, of\
    \ course.)\n"
- title: SND.NXT
  contents:
  - "SND.NXT\n          send sequence\n"
- title: SND.UNA
  contents:
  - "SND.UNA\n          left sequence\n"
- title: SND.UP
  contents:
  - "SND.UP\n          send urgent pointer\n"
- title: SND.WL1
  contents:
  - "SND.WL1\n          segment sequence number at last window update\n"
- title: SND.WL2
  contents:
  - "SND.WL2\n          segment acknowledgment number at last window update\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Glossary
  contents:
  - 'Glossary

    '
- title: SND.WND
  contents:
  - "SND.WND\n          send window\n"
- title: socket
  contents:
  - "socket\n          An address which specifically includes a port identifier, that\n\
    \          is, the concatenation of an Internet Address with a TCP port.\n"
- title: Source Address
  contents:
  - "Source Address\n          The source address, usually the network and host identifiers.\n"
- title: SYN
  contents:
  - "SYN\n          A control bit in the incoming segment, occupying one sequence\n\
    \          number, used at the initiation of a connection, to indicate\n     \
    \     where the sequence numbering will start.\n"
- title: TCB
  contents:
  - "TCB\n          Transmission control block, the data structure that records\n\
    \          the state of a connection.\n"
- title: TCB.PRC
  contents:
  - "TCB.PRC\n          The precedence of the connection.\n"
- title: TCP
  contents:
  - "TCP\n          Transmission Control Protocol:  A host-to-host protocol for\n\
    \          reliable communication in internetwork environments.\n"
- title: TOS
  contents:
  - "TOS\n          Type of Service, an Internet Protocol field.\n"
- title: Type of Service
  contents:
  - "Type of Service\n          An Internet Protocol field which indicates the type\
    \ of service\n          for this internet fragment.\n"
- title: URG
  contents:
  - "URG\n          A control bit (urgent), occupying no sequence space, used to\n\
    \          indicate that the receiving user should be notified to do\n       \
    \   urgent processing as long as there is data to be consumed with\n         \
    \ sequence numbers less than the value indicated in the urgent\n          pointer.\n"
- title: urgent pointer
  contents:
  - "urgent pointer\n          A control field meaningful only when the URG bit is\
    \ on.  This\n          field communicates the value of the urgent pointer which\n\
    \          indicates the data octet associated with the sending user's\n     \
    \     urgent call.\n                                           Transmission Control\
    \ Protocol\n                               REFERENCES\n"
- title: '[1]  Cerf, V., and R. Kahn, "A Protocol for Packet Network'
  contents:
  - "[1]  Cerf, V., and R. Kahn, \"A Protocol for Packet Network\n     Intercommunication\"\
    , IEEE Transactions on Communications,\n     Vol. COM-22, No. 5, pp 637-648, May\
    \ 1974.\n"
- title: '[2]  Postel, J. (ed.), "Internet Protocol - DARPA Internet Program'
  contents:
  - "[2]  Postel, J. (ed.), \"Internet Protocol - DARPA Internet Program\n     Protocol\
    \ Specification\", RFC 791, USC/Information Sciences\n     Institute, September\
    \ 1981.\n"
- title: '[3]  Dalal, Y. and C. Sunshine, "Connection Management in Transport'
  contents:
  - "[3]  Dalal, Y. and C. Sunshine, \"Connection Management in Transport\n     Protocols\"\
    , Computer Networks, Vol. 2, No. 6, pp. 454-473,\n     December 1978.\n"
- title: '[4]  Postel, J., "Assigned Numbers", RFC 790, USC/Information Sciences'
  contents:
  - "[4]  Postel, J., \"Assigned Numbers\", RFC 790, USC/Information Sciences\n  \
    \   Institute, September 1981.\n"
