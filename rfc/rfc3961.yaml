- contents:
  - "                 Encryption and Checksum Specifications\n                             for
    Kerberos 5\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes a framework for defining encryption and\n
    \  checksum mechanisms for use with the Kerberos protocol, defining an\n   abstraction
    layer between the Kerberos protocol and related\n   protocols, and the actual
    mechanisms themselves.  The document also\n   defines several mechanisms.  Some
    are taken from RFC 1510, modified\n   in form to fit this new framework and occasionally
    modified in\n   content when the old specification was incorrect.  New mechanisms
    are\n   presented here as well.  This document does NOT indicate which\n   mechanisms
    may be considered \"required to implement\".\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .  2\n   2.  Concepts  . . . . . . . . . . . . . . . . . . . . . . . .
    . .  2\n   3.  Encryption Algorithm Profile  . . . . . . . . . . . . . . . .  4\n
    \  4.  Checksum Algorithm Profile  . . . . . . . . . . . . . . . . .  9\n   5.
    \ Simplified Profile for CBC Ciphers with Key Derivation  . . . 10\n       5.1.
    \ A Key Derivation Function . . . . . . . . . . . . . . . 10\n       5.2.  Simplified
    Profile Parameters . . . . . . . . . . . . . 12\n       5.3.  Cryptosystem Profile
    Based on Simplified Profile  . . . 13\n       5.4.  Checksum Profiles Based on
    Simplified Profile . . . . . 16\n   6.  Profiles for Kerberos Encryption and Checksum
    Algorithms  . . 16\n       6.1.  Unkeyed Checksums . . . . . . . . . . . . . .
    . . . . . 17\n       6.2.  DES-based Encryption and Checksum Types . . . . . .
    . . 18\n       6.3.  Triple-DES Based Encryption and Checksum Types  . . . . 28\n
    \  7.  Use of Kerberos Encryption Outside This Specification . . . . 30\n   8.
    \ Assigned Numbers  . . . . . . . . . . . . . . . . . . . . . . 31\n   9.  Implementation
    Notes  . . . . . . . . . . . . . . . . . . . . 32\n   10. Security Considerations
    . . . . . . . . . . . . . . . . . . . 33\n   11. IANA Considerations . . . . .
    . . . . . . . . . . . . . . . . 35\n   12. Acknowledgements. . . . . . . . . .
    . . . . . . . . . . . . . 36\n   A.  Test vectors  . . . . . . . . . . . . . .
    . . . . . . . . . . 38\n       A.1.  n-fold  . . . . . . . . . . . . . . . . .
    . . . . . . . 38\n       A.2.  mit_des_string_to_key . . . . . . . . . . . . .
    . . . . 39\n       A.3.  DES3 DR and DK  . . . . . . . . . . . . . . . . . . .
    . 43\n       A.4.  DES3string_to_key . . . . . . . . . . . . . . . . . . . 44\n
    \      A.5.  Modified CRC-32 . . . . . . . . . . . . . . . . . . . . 44\n   B.
    \ Significant Changes from RFC 1510 . . . . . . . . . . . . . . 45\n   Notes .
    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n   Normative References.
    . . . . . . . . . . . . . . . . . . . . . . 47\n   Informative References. . .
    . . . . . . . . . . . . . . . . . . . 48\n   Editor's Address. . . . . . . . .
    . . . . . . . . . . . . . . . . 49\n   Full Copyright Statement. . . . . . . .
    . . . . . . . . . . . . . 50\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Kerberos protocols [Kerb] are designed to encrypt messages
    of\n   arbitrary sizes, using block encryption ciphers or, less commonly,\n   stream
    encryption ciphers.  Encryption is used to prove the\n   identities of the network
    entities participating in message\n   exchanges.  However, nothing in the Kerberos
    protocol requires that\n   any specific encryption algorithm be used, as long
    as the algorithm\n   includes certain operations.\n   The following sections specify
    the encryption and checksum mechanisms\n   currently defined for Kerberos, as
    well as a framework for defining\n   future mechanisms.  The encoding, chaining,
    padding, and other\n   requirements for each are described.  Appendix A gives
    test vectors\n   for several functions.\n"
  title: 1.  Introduction
- contents:
  - "2.  Concepts\n   Both encryption and checksum mechanisms are profiled in later\n
    \  sections.  Each profile specifies a collection of operations and\n   attributes
    that must be defined for a mechanism.  A Kerberos\n   encryption or checksum mechanism
    specification is not complete if it\n   does not define all of these operations
    and attributes.\n   An encryption mechanism must provide for confidentiality and\n
    \  integrity of the original plaintext.  (Incorporating a checksum may\n   permit
    integrity checking, if the encryption mode does not provide an\n   integrity check
    itself.)  It must also provide non-malleability\n   [Bellare98] [Dolev91].  Use
    of a random confounder prepended to the\n   plaintext is recommended.  It should
    not be possible to determine if\n   two ciphertexts correspond to the same plaintext
    without the key.\n   A checksum mechanism [1] must provide proof of the integrity
    of the\n   associated message and must preserve the confidentiality of the\n   message
    in case it is not sent in the clear.  Finding two plaintexts\n   with the same
    checksum should be infeasible.  It is NOT required that\n   an eavesdropper be
    unable to determine whether two checksums are for\n   the same message, as the
    messages themselves would presumably be\n   visible to any such eavesdropper.\n
    \  Due to advances in cryptography, some cryptographers consider using\n   the
    same key for multiple purposes unwise.  Since keys are used in\n   performing
    a number of different functions in Kerberos, it is\n   desirable to use different
    keys for each of these purposes, even\n   though we start with a single long-term
    or session key.\n   We do this by enumerating the different uses of keys within
    Kerberos\n   and by making the \"usage number\" an input to the encryption or\n
    \  checksum mechanisms; such enumeration is outside the scope of this\n   document.
    \ Later sections define simplified profile templates for\n   encryption and checksum
    mechanisms that use a key derivation function\n   applied to a CBC mode (or similar)
    cipher and a checksum or hash\n   algorithm.\n   We distinguish the \"base key\"
    specified by other documents from the\n   \"specific key\" for a specific encryption
    or checksum operation.  It\n   is expected but not required that the specific
    key be one or more\n   separate keys derived from the original protocol key and
    the key\n   usage number.  The specific key should not be explicitly referenced\n
    \  outside of this document.  The typical language used in other\n   documents
    should be something like, \"encrypt this octet string using\n   this key and this
    usage number\"; generation of the specific key and\n   cipher state (described
    in the next section) are implicit.  The\n   creation of a new cipher-state object,
    or the re-use of one from a\n   previous encryption operation, may also be explicit.\n
    \  New protocols defined in terms of the Kerberos encryption and\n   checksum
    types should use their own key usage values.  Key usages are\n   unsigned 32-bit
    integers; zero is not permitted.\n   All data is assumed to be in the form of
    strings of octets or eight-\n   bit bytes.  Environments with other byte sizes
    will have to emulate\n   this behavior in order to get correct results.\n   Each
    algorithm is assigned an encryption type (or \"etype\") or\n   checksum type number,
    for algorithm identification within the\n   Kerberos protocol.  The full list
    of current type number assignments\n   is given in section 8.\n"
  title: 2.  Concepts
- contents:
  - "3.  Encryption Algorithm Profile\n   An encryption mechanism profile must define
    the following attributes\n   and operations.  The operations must be defined as
    functions in the\n   mathematical sense.  No additional or implicit inputs (such
    as\n   Kerberos principal names or message sequence numbers) are permitted.\n
    \  protocol key format\n      This describes which octet string values represent
    valid keys.\n      For encryption mechanisms that don't have perfectly dense key\n
    \     spaces, this will describe the representation used for encoding\n      keys.
    \ It need not describe invalid specific values; all key\n      generation routines
    should avoid such values.\n   specific key structure\n      This is not a protocol
    format at all, but a description of the\n      keying material derived from the
    chosen key and used to encrypt or\n      decrypt data or compute or verify a checksum.
    \ It may, for\n      example, be a single key, a set of keys, or a combination
    of the\n      original key with additional data.  The authors recommend using\n
    \     one or more keys derived from the original key via one-way key\n      derivation
    functions.\n   required checksum mechanism\n      This indicates a checksum mechanism
    that must be available when\n      this encryption mechanism is used.  Since Kerberos
    has no built in\n      mechanism for negotiating checksum mechanisms, once an
    encryption\n      mechanism is decided, the corresponding checksum mechanism can
    be\n      used.\n   key-generation seed length, K\n      This is the length of
    the random bitstring needed to generate a\n      key with the encryption scheme's
    random-to-key function (described\n      below).  This must be a fixed value so
    that various techniques for\n      producing a random bitstring of a given length
    may be used with\n      key generation functions.\n   key generation functions\n
    \     Keys must be generated in a number of cases, from different types\n      of
    inputs.  All function specifications must indicate how to\n      generate keys
    in the proper wire format and must avoid generating\n      keys that significantly
    compromise the confidentiality of\n      encrypted data, if the cryptosystem has
    such.  Entropy from each\n      source should be preserved as much as possible.
    \ Many of the\n      inputs, although unknown, may be at least partly predictable\n
    \     (e.g., a password string is likely to be entirely in the ASCII\n      subset
    and of fairly short length in many environments; a semi-\n      random string
    may include time stamps).  The benefit of such\n      predictability to an attacker
    must be minimized.\n   string-to-key (UTF-8 string, UTF-8 string, opaque)->(protocol-key)\n
    \     This function generates a key from two UTF-8 strings and an opaque\n      octet
    string.  One of the strings is usually the principal's pass\n      phrase, but
    generally it is merely a secret string.  The other\n      string is a \"salt\"
    string intended to produce different keys from\n      the same password for different
    users or realms.  Although the\n      strings provided will use UTF-8 encoding,
    no specific version of\n      Unicode should be assumed; all valid UTF-8 strings
    should be\n      allowed.  Strings provided in other encodings MUST first be\n
    \     converted to UTF-8 before applying this function.\n      The third argument,
    the octet string, may be used to pass\n      mechanism-specific parameters into
    this function.  Since doing so\n      implies knowledge of the specific encryption
    system, generating\n      non-default parameter values should be an uncommon operation,
    and\n      normal Kerberos applications should be able to treat this\n      parameter
    block as an opaque object supplied by the Key\n      Distribution Center or defaulted
    to some mechanism-specific\n      constant value.\n      The string-to-key function
    should be a one-way function so that\n      compromising a user's key in one realm
    does not compromise it in\n      another, even if the same password (but a different
    salt) is used.\n   random-to-key (bitstring[K])->(protocol-key)\n      This function
    generates a key from a random bitstring of a\n      specific size.  All the bits
    of the input string are assumed to be\n      equally random, even though the entropy
    present in the random\n      source may be limited.\n   key-derivation (protocol-key,
    integer)->(specific-key)\n      In this function, the integer input is the key
    usage value, as\n      described above.  An attacker is assumed to know the usage
    values.\n      The specific-key output value was described in section 2.\n   string-to-key
    parameter format\n      This describes the format of the block of data that can
    be passed\n      to the string-to-key function above to configure additional\n
    \     parameters for that function.  Along with the mechanism of\n      encoding
    parameter values, bounds on the allowed parameters should\n      also be described
    to avoid allowing a spoofed KDC to compromise\n      the user's password.  If
    practical it may be desirable to\n      construct the encoding so that values
    unacceptably weakening the\n      resulting key cannot be encoded.\n      Local
    security policy might permit tighter bounds to avoid excess\n      resource consumption.
    \ If so, the specification should recommended\n      defaults for these bounds.
    \ The description should also outline\n      possible weaknesses if bounds checks
    or other validations are not\n      applied to a parameter string received from
    the network.\n      As mentioned above, this should be considered opaque to most\n
    \     normal applications.\n   default string-to-key parameters (octet string)\n
    \     This default value for the \"params\" argument to the string-to-key\n      function
    should be used when the application protocol (Kerberos or\n      other) does not
    explicitly set the parameter value.  As indicated\n      above, in most cases
    this parameter block should be treated as an\n      opaque object.\n   cipher
    state\n      This describes any information that can be carried over from one\n
    \     encryption or decryption operation to the next, for use with a\n      given
    specific key.  For example, a block cipher used in CBC mode\n      may put an
    initial vector of one block in the cipher state.  Other\n      encryption modes
    may track nonces or other data.\n      This state must be non-empty and must influence
    encryption so that\n      messages are decrypted in the same order they were a
    encrypted, if\n      the cipher state is carried over from one encryption to the
    next.\n      Distinguishing out-of-order or missing messages from corrupted\n
    \     messages is not required.  If desired, this can be done at a\n      higher
    level by including sequence numbers and not \"chaining\" the\n      cipher state
    between encryption operations.\n      The cipher state may not be reused in multiple
    encryption or\n      decryption operations.  These operations all generate a new
    cipher\n      state that may be used for following operations using the same key\n
    \     and operation.\n      The contents of the cipher state must be treated as
    opaque outside\n      of encryption system specifications.\n   initial cipher
    state (specific-key, direction)->(state)\n      This describes the generation
    of the initial value for the cipher\n      state if it is not being carried over
    from a previous encryption\n      or decryption operation.\n      This describes
    any initial state setup needed before encrypting\n      arbitrary amounts of data
    with a given specific key.  The specific\n      key and the direction of operations
    to be performed (encrypt\n      versus decrypt) must be the only input needed
    for this\n      initialization.\n      This state should be treated as opaque
    in any uses outside of an\n      encryption algorithm definition.\n      IMPLEMENTATION
    NOTE: [Kerb1510] was vague on whether and to what\n      degree an application
    protocol could exercise control over the\n      initial vector used in DES CBC
    operations.  Some existing\n      implementations permit setting the initial vector.
    \ This framework\n      does not provide for application control of the cipher
    state\n      (beyond \"initialize\" and \"carry over from previous encryption\"),\n
    \     as the form and content of the initial cipher state can vary\n      between
    encryption systems and may not always be a single block of\n      random data.\n
    \     New Kerberos application protocols should not assume control over\n      the
    initial vector, or that one even exists.  However, a general-\n      purpose implementation
    may wish to provide the capability, in case\n      applications explicitly setting
    it are encountered.\n   encrypt (specific-key, state, octet string)->(state, octet
    string)\n      This function takes the specific key, cipher state, and a non-\n
    \     empty plaintext string as input and generates ciphertext and a new\n      cipher
    state as outputs.  If the basic encryption algorithm itself\n      does not provide
    for integrity protection (e.g., DES in CBC mode),\n      then some form of verifiable
    MAC or checksum must be included.\n      Some random factor such as a confounder
    should be included so that\n      an observer cannot know if two messages contain
    the same\n      plaintext, even if the cipher state and specific keys are the\n
    \     same.  The exact length of the plaintext need not be encoded, but\n      if
    it is not and if padding is required, the padding must be added\n      at the
    end of the string so that the decrypted version may be\n      parsed from the
    beginning.\n      The specification of the encryption function must indicate not\n
    \     only the precise contents of the output octet string, but also the\n      output
    cipher state.  The application protocol may carry the\n      output cipher state
    forward from one encryption with a given\n      specific key to another; the effect
    of this \"chaining\" must be\n      defined [2].\n      Assuming that values for
    the specific key and cipher state are\n      correctly-produced, no input octet
    string may result in an error\n      indication.\n   decrypt (specific-key, state,
    octet string)->(state, octet string)\n      This function takes the specific key,
    cipher state, and ciphertext\n      as inputs and verifies the integrity of the
    supplied ciphertext.\n      If the ciphertext's integrity is intact, this function
    produces\n      the plaintext and a new cipher state as outputs; otherwise, an\n
    \     error indication must be returned, and the data discarded.\n      The result
    of the decryption may be longer than the original\n      plaintext, as, for example,
    when the encryption mode adds padding\n      to reach a multiple of a block size.
    \ If this is the case, any\n      extra octets must come after the decoded plaintext.
    \ An\n      application protocol that needs to know the exact length of the\n
    \     message must encode a length or recognizable \"end of message\"\n      marker
    within the plaintext [3].\n      As with the encryption function, a correct specification
    for this\n      function must indicate not only the contents of the output octet\n
    \     string, but also the resulting cipher state.\n   pseudo-random (protocol-key,
    octet-string)->(octet-string)\n      This pseudo-random function should generate
    an octet string of\n      some size that is independent of the octet string input.
    \ The PRF\n      output string should be suitable for use in key generation, even\n
    \     if the octet string input is public.  It should not reveal the\n      input
    key, even if the output is made public.\n   These operations and attributes are
    all that is required to support\n   Kerberos and various proposed preauthentication
    schemes.\n   For convenience of certain application protocols that may wish to
    use\n   the encryption profile, we add the constraint that, for any given\n   plaintext
    input size, a message size must exist between that given\n   size and that size
    plus 65,535 such that the length of the decrypted\n   version of the ciphertext
    will never have extra octets at the end.\n   Expressed mathematically, for every
    message length L1, there exists a\n   message size L2 such that\n      L2 >= L1\n
    \     L2 < L1 + 65,536\n      for every message M with |M| = L2, decrypt(encrypt(M))
    = M\n   A document defining a new encryption type should also describe known\n
    \  weaknesses or attacks, so that its security may be fairly assessed,\n   and
    should include test vectors or other validation procedures for\n   the operations
    defined.  Specific references to information that is\n   readily available elsewhere
    are sufficient.\n"
  title: 3.  Encryption Algorithm Profile
- contents:
  - "4.  Checksum Algorithm Profile\n   A checksum mechanism profile must define the
    following attributes and\n   operations:\n   associated encryption algorithm(s)\n
    \     This indicates the types of encryption keys this checksum\n      mechanism
    can be used with.\n      A keyed checksum mechanism may have more than one associated\n
    \     encryption algorithm if they share the same wire-key format,\n      string-to-key
    function, default string-to-key-parameters, and key\n      derivation function.
    \ (This combination means that, for example, a\n      checksum type, key usage
    value, and password are adequate to get\n      the specific key used to compute
    a checksum.)\n      An unkeyed checksum mechanism can be used with any encryption\n
    \     type, as the key is ignored, but its use must be limited to cases\n      where
    the checksum itself is protected, to avoid trivial attacks.\n   get_mic function\n
    \     This function generates a MIC token for a given specific key (see\n      section
    3) and message (represented as an octet string) that may\n      be used to verify
    the integrity of the associated message.  This\n      function is not required
    to return the same deterministic result\n      for each use; it need only generate
    a token that the verify_mic\n      routine can check.\n      The output of this
    function will also dictate the size of the\n      checksum.  It must be no larger
    than 65,535 octets.\n   verify_mic function\n      Given a specific key, message,
    and MIC token, this function\n      ascertains whether the message integrity has
    been compromised.\n      For a deterministic get_mic routine, the corresponding
    verify_mic\n      may simply generate another checksum and compare the two.\n
    \  The get_mic and verify_mic operations must allow inputs of arbitrary\n   length;
    if any padding is needed, the padding scheme must be\n   specified as part of
    these functions.\n   These operations and attributes are all that should be required
    to\n   support Kerberos and various proposed preauthentication schemes.\n   As
    with encryption mechanism definition documents, documents defining\n   new checksum
    mechanisms should indicate validation processes and\n   known weaknesses.\n"
  title: 4.  Checksum Algorithm Profile
- contents:
  - "5.  Simplified Profile for CBC Ciphers with Key Derivation\n   The profile outlined
    in sections 3 and 4 describes a large number of\n   operations that must be defined
    for encryption and checksum\n   algorithms to be used with Kerberos.  Here we
    describe a simpler\n   profile that can generate both encryption and checksum
    mechanism\n   definitions, filling in uses of key derivation in appropriate places,\n
    \  providing integrity protection, and defining multiple operations for\n   the
    cryptosystem profile based on a smaller set of operations.  Not\n   all of the
    existing cryptosystems for Kerberos fit into this\n   simplified profile, but
    we recommend that future cryptosystems use it\n   or something based on it [4].\n
    \  Not all the operations in the complete profiles are defined through\n   this
    mechanism; several must still be defined for each new algorithm\n   pair.\n"
  - contents:
    - "5.1.  A Key Derivation Function\n   Rather than define some scheme by which
      a \"protocol key\" is composed\n   of a large number of encryption keys, we
      use keys derived from a base\n   key to perform cryptographic operations.  The
      base key must be used\n   only for generating the derived keys, and this derivation
      must be\n   non-invertible and entropy preserving.  Given these restrictions,\n
      \  compromise of one derived key does not compromise others.  Attack of\n   the
      base key is limited, as it is only used for derivation and is not\n   exposed
      to any user data.\n   To generate a derived key from a base key, we generate
      a pseudorandom\n   octet string by using an algorithm DR, described below, and
      generate\n   a key from that octet string by using a function dependent on the\n
      \  encryption algorithm.  The input length needed for that function,\n   which
      is also dependent on the encryption algorithm, dictates the\n   length of the
      string to be generated by the DR algorithm (the value\n   \"k\" below).  These
      procedures are based on the key derivation in\n   [Blumenthal96].\n      Derived
      Key = DK(Base Key, Well-Known Constant)\n      DK(Key, Constant) = random-to-key(DR(Key,
      Constant))\n      DR(Key, Constant) = k-truncate(E(Key, Constant,\n                                       initial-cipher-state))\n
      \  Here DR is the random-octet generation function described below, and\n   DK
      is the key-derivation function produced from it.  In this\n   construction,
      E(Key, Plaintext, CipherState) is a cipher, Constant is\n   a well-known constant
      determined by the specific usage of this\n   function, and k-truncate truncates
      its argument by taking the first k\n   bits.  Here, k is the key generation
      seed length needed for the\n   encryption system.\n   The output of the DR function
      is a string of bits; the actual key is\n   produced by applying the cryptosystem's
      random-to-key operation on\n   this bitstring.\n   If the Constant is smaller
      than the cipher block size of E, then it\n   must be expanded with n-fold()
      so it can be encrypted.  If the output\n   of E is shorter than k bits, it is
      fed back into the encryption as\n   many times as necessary.  The construct
      is as follows (where |\n   indicates concatentation):\n      K1 = E(Key, n-fold(Constant),
      initial-cipher-state)\n      K2 = E(Key, K1, initial-cipher-state)\n      K3
      = E(Key, K2, initial-cipher-state)\n      K4 = ...\n      DR(Key, Constant)
      = k-truncate(K1 | K2 | K3 | K4 ...)\n   n-fold is an algorithm that takes m
      input bits and \"stretches\" them\n   to form n output bits with equal contribution
      from each input bit to\n   the output, as described in [Blumenthal96]:\n      We
      first define a primitive called n-folding, which takes a\n      variable-length
      input block and produces a fixed-length output\n      sequence.  The intent
      is to give each input bit approximately\n      equal weight in determining the
      value of each output bit.  Note\n      that whenever we need to treat a string
      of octets as a number, the\n      assumed representation is Big-Endian -- Most
      Significant Byte\n      first.\n      To n-fold a number X, replicate the input
      value to a length that\n      is the least common multiple of n and the length
      of X.  Before\n      each repetition, the input is rotated to the right by 13
      bit\n      positions.  The successive n-bit chunks are added together using\n
      \     1's-complement addition (that is, with end-around carry) to yield\n      a
      n-bit result....\n   Test vectors for n-fold are supplied in appendix A [5].\n
      \  In this section, n-fold is always used to produce c bits of output,\n   where
      c is the cipher block size of E.\n   The size of the Constant must not be larger
      than c, because reducing\n   the length of the Constant by n-folding can cause
      collisions.\n   If the size of the Constant is smaller than c, then the Constant
      must\n   be n-folded to length c.  This string is used as input to E.  If the\n
      \  block size of E is less than the random-to-key input size, then the\n   output
      from E is taken as input to a second invocation of E.  This\n   process is repeated
      until the number of bits accumulated is greater\n   than or equal to the random-to-key
      input size.  When enough bits have\n   been computed, the first k are taken
      as the random data used to\n   create the key with the algorithm-dependent random-to-key
      function.\n   As the derived key is the result of one or more encryptions in
      the\n   base key, deriving the base key from the derived key is equivalent to\n
      \  determining the key from a very small number of plaintext/ciphertext\n   pairs.
      \ Thus, this construction is as strong as the cryptosystem\n   itself.\n"
    title: 5.1.  A Key Derivation Function
  - contents:
    - "5.2.  Simplified Profile Parameters\n   These are the operations and attributes
      that must be defined:\n   protocol key format\n   string-to-key function\n   default
      string-to-key parameters\n   key-generation seed length, k\n   random-to-key
      function\n      As above for the normal encryption mechanism profile.\n   unkeyed
      hash algorithm, H\n      This should be a collision-resistant hash algorithm
      with fixed-\n      size output, suitable for use in an HMAC [HMAC].  It must
      support\n      inputs of arbitrary length.  Its output must be at least the\n
      \     message block size (below).\n   HMAC output size, h\n      This indicates
      the size of the leading substring output by the\n      HMAC function that should
      be used in transmitted messages.  It\n      should be at least half the output
      size of the hash function H,\n      and at least 80 bits; it need not match
      the output size.\n   message block size, m\n      This is the size of the smallest
      units the cipher can handle in\n      the mode in which it is being used.  Messages
      will be padded to a\n      multiple of this size.  If a block cipher is used
      in a mode that\n      can handle messages that are not multiples of the cipher
      block\n      size, such as CBC mode with cipher text stealing (CTS, see [RC5]),\n
      \     this value would be one octet.  For traditional CBC mode with\n      padding,
      it would be the underlying cipher's block size.\n      This value must be a
      multiple of eight bits (one octet).\n   encryption/decryption functions, E and
      D\n      These are basic encryption and decryption functions for messages\n
      \     of sizes that are multiples of the message block size.  No\n      integrity
      checking or confounder should be included here.  For\n      inputs these functions
      take the IV or similar data, a protocol-\n      format key, and an octet string,
      returning a new IV and octet\n      string.\n      The encryption function is
      not required to use CBC mode but is\n      assumed to be using something with
      similar properties.  In\n      particular, prepending a cipher block-size confounder
      to the\n      plaintext should alter the entire ciphertext (comparable to\n
      \     choosing and including a random initial vector for CBC mode).\n      The
      result of encrypting one cipher block (of size c, above) must\n      be deterministic
      for the random octet generation function DR in\n      the previous section to
      work.  For best security, it should also\n      be no larger than c.\n   cipher
      block size, c\n      This is the block size of the block cipher underlying the\n
      \     encryption and decryption functions indicated above, used for key\n      derivation
      and for the size of the message confounder and initial\n      vector.  (If a
      block cipher is not in use, some comparable\n      parameter should be determined.)
      \ It must be at least 5 octets.\n      This is not actually an independent parameter;
      rather, it is a\n      property of the functions E and D.  It is listed here
      to clarify\n      the distinction between it and the message block size, m.\n
      \  Although there are still a number of properties to specify, they are\n   fewer
      and simpler than in the full profile.\n"
    title: 5.2.  Simplified Profile Parameters
  - contents:
    - "5.3.  Cryptosystem Profile Based on Simplified Profile\n   The above key derivation
      function is used to produce three\n   intermediate keys.  One is used for computing
      checksums of\n   unencrypted data.  The other two are used for encrypting and\n
      \  checksumming plaintext to be sent encrypted.\n   The ciphertext output is
      the concatenation of the output of the basic\n   encryption function E and a
      (possibly truncated) HMAC using the\n   specified hash function H, both applied
      to the plaintext with a\n   random confounder prefix and sufficient padding
      to bring it to a\n   multiple of the message block size.  When the HMAC is computed,
      the\n   key is used in the protocol key form.\n   Decryption is performed by
      removing the (partial) HMAC, decrypting\n   the remainder, and verifying the
      HMAC.  The cipher state is an\n   initial vector, initialized to zero.\n   The
      substring notation \"[1..h]\" in the following table should be read\n   as using
      1-based indexing; leading substrings are used.\n                   Cryptosystem
      from Simplified Profile\n"
    - '------------------------------------------------------------------------

      '
    - 'protocol key format       As given.

      '
    - 'specific key structure    Three protocol-format keys: { Kc, Ke, Ki }.

      '
    - 'key-generation seed       As given.

      '
    - 'length

      '
    - 'required checksum         As defined below in section 5.4.

      '
    - 'mechanism

      '
    - 'cipher state              Initial vector (usually of length c)

      '
    - 'initial cipher state      All bits zero

      '
    - "encryption function       conf = Random string of length c\n                          pad
      \ = Shortest string to bring confounder\n                                 and
      plaintext to a length that's a\n                                 multiple of
      m.\n                          (C1, newIV) = E(Ke, conf | plaintext | pad,\n
      \                                         oldstate.ivec)\n                          H1
      = HMAC(Ki, conf | plaintext | pad)\n                          ciphertext =  C1
      | H1[1..h]\n                          newstate.ivec = newIV\n"
    - "decryption function       (C1,H1) = ciphertext\n                          (P1,
      newIV) = D(Ke, C1, oldstate.ivec)\n                          if (H1 != HMAC(Ki,
      P1)[1..h])\n                             report error\n                          newstate.ivec
      = newIV\n"
    - 'default string-to-key     As given.

      '
    - 'params

      '
    - "pseudo-random function    tmp1 = H(octet-string)\n                          tmp2
      = truncate tmp1 to multiple of m\n                          PRF = E(DK(protocol-key,
      prfconstant),\n                                  tmp2, initial-cipher-state)\n
      \  The \"prfconstant\" used in the PRF operation is the three-octet string\n
      \  \"prf\".\n                   Cryptosystem from Simplified Profile\n"
    - '------------------------------------------------------------------------

      '
    - 'key generation functions:

      '
    - 'string-to-key function    As given.

      '
    - 'random-to-key function    As given.

      '
    - "key-derivation function   The \"well-known constant\" used for the DK\n                          function
      is the key usage number, expressed as\n                          four octets
      in big-endian order, followed by\n                          one octet indicated
      below.\n                          Kc = DK(base-key, usage | 0x99);\n                          Ke
      = DK(base-key, usage | 0xAA);\n                          Ki = DK(base-key, usage
      | 0x55);\n"
    title: 5.3.  Cryptosystem Profile Based on Simplified Profile
  - contents:
    - "5.4.  Checksum Profiles Based on Simplified Profile\n   When an encryption
      system is defined with the simplified profile\n   given in section 5.2, a checksum
      algorithm may be defined for it as\n   follows:\n                Checksum Mechanism
      from Simplified Profile\n             --------------------------------------------------\n
      \            associated cryptosystem   As defined above.\n             get_mic
      \                  HMAC(Kc, message)[1..h]\n             verify_mic                get_mic
      and compare\n   The HMAC function and key Kc are as described in section 5.3.\n"
    title: 5.4.  Checksum Profiles Based on Simplified Profile
  title: 5.  Simplified Profile for CBC Ciphers with Key Derivation
- contents:
  - "6.  Profiles for Kerberos Encryption and Checksum Algorithms\n   These profiles
    describe the encryption and checksum systems defined\n   for Kerberos.  The astute
    reader will notice that some of them do not\n   fulfill all the requirements outlined
    in previous sections.  These\n   systems are defined for backward compatibility;
    newer implementations\n   should (whenever possible) attempt to utilize encryption
    systems that\n   satisfy all the profile requirements.\n   The full list of current
    encryption and checksum type number\n   assignments, including values currently
    reserved but not defined in\n   this document, is given in section 8.\n"
  - contents:
    - "6.1.  Unkeyed Checksums\n   These checksum types use no encryption keys and
      thus can be used in\n   combination with any encryption type, but they may only
      be used with\n   caution, in limited circumstances where the lack of a key does
      not\n   provide a window for an attack, preferably as part of an encrypted\n
      \  message [6].  Keyed checksum algorithms are recommended.\n"
    - contents:
      - "6.1.1.  The RSA MD5 Checksum\n   The RSA-MD5 checksum calculates a checksum
        by using the RSA MD5\n   algorithm [MD5-92].  The algorithm takes as input
        an input message of\n   arbitrary length and produces as output a 128-bit
        (sixteen octet)\n   checksum.\n                                  rsa-md5\n
        \              ----------------------------------------------\n               associated
        cryptosystem   any\n               get_mic                   rsa-md5(msg)\n
        \              verify_mic                get_mic and compare\n   The rsa-md5
        checksum algorithm is assigned a checksum type number of\n   seven (7).\n"
      title: 6.1.1.  The RSA MD5 Checksum
    - contents:
      - "6.1.2.  The RSA MD4 Checksum\n   The RSA-MD4 checksum calculates a checksum
        using the RSA MD4\n   algorithm [MD4-92].  The algorithm takes as input an
        input message of\n   arbitrary length and produces as output a 128-bit (sixteen
        octet)\n   checksum.\n                                  rsa-md4\n               ----------------------------------------------\n
        \              associated cryptosystem   any\n               get_mic                   md4(msg)\n
        \              verify_mic                get_mic and compare\n   The rsa-md4
        checksum algorithm is assigned a checksum type number of\n   two (2).\n"
      title: 6.1.2.  The RSA MD4 Checksum
    - contents:
      - "6.1.3.  CRC-32 Checksum\n   This CRC-32 checksum calculates a checksum based
        on a cyclic\n   redundancy check as described in ISO 3309 [CRC] but modified
        as\n   described below.  The resulting checksum is four (4) octets in\n   length.
        \ The CRC-32 is neither keyed nor collision-proof; thus, the\n   use of this
        checksum is not recommended.  An attacker using a\n   probabilistic chosen-plaintext
        attack as described in [SG92] might be\n   able to generate an alternative
        message that satisfies the checksum.\n   The CRC-32 checksum used in the des-cbc-crc
        encryption mode is\n   identical to the 32-bit FCS described in ISO 3309 with
        two\n   exceptions: The sum with the all-ones polynomial times x**k is\n   omitted,
        and the final remainder is not ones-complemented.  ISO 3309\n   describes
        the FCS in terms of bits, whereas this document describes\n   the Kerberos
        protocol in terms of octets.  To clarify the ISO 3309\n   definition for the
        purpose of computing the CRC-32 in the des-cbc-crc\n   encryption mode, the
        ordering of bits in each octet shall be assumed\n   to be LSB first.  Given
        this assumed ordering of bits within an\n   octet, the mapping of bits to
        polynomial coefficients shall be\n   identical to that specified in ISO 3309.\n
        \  Test values for this modified CRC function are included in appendix\n   A.5.\n
        \                                  crc32\n               ----------------------------------------------\n
        \              associated cryptosystem   any\n               get_mic                   crc32(msg)\n
        \              verify_mic                get_mic and compare\n   The crc32
        checksum algorithm is assigned a checksum type number of\n   one (1).\n"
      title: 6.1.3.  CRC-32 Checksum
    title: 6.1.  Unkeyed Checksums
  - contents:
    - "6.2.  DES-Based Encryption and Checksum Types\n   These encryption systems
      encrypt information under the Data\n   Encryption Standard [DES77] by using
      the cipher block chaining mode\n   [DESM80].  A checksum is computed as described
      below and placed in\n   the cksum field.  DES blocks are eight bytes.  As a
      result, the data\n   to be encrypted (the concatenation of confounder, checksum,
      and\n   message) must be padded to an eight byte boundary before encryption.\n
      \  The values of the padding bytes are unspecified.\n   Plaintext and DES ciphertext
      are encoded as blocks of eight octets,\n   which are concatenated to make the
      64-bit inputs for the DES\n   algorithms.  The first octet supplies the eight
      most significant bits\n   (with the octet's MSB used as the DES input block's
      MSB, etc.), the\n   second octet the next eight bits, and so on.  The eighth
      octet\n   supplies the 8 least significant bits.\n   Encryption under DES using
      cipher block chaining requires an\n   additional input in the form of an initialization
      vector; this vector\n   is specified below for each encryption system.\n   The
      DES specifications [DESI81] identify four 'weak' and twelve\n   'semi-weak'
      keys; these keys SHALL NOT be used for encrypting\n   messages for use in Kerberos.
      \ The \"variant keys\" generated for the\n   RSA-MD5-DES, RSA-MD4-DES, and DES-MAC
      checksum types by an\n   eXclusive-OR of a DES key with a constant are not checked
      for this\n   property.\n   A DES key is eight octets of data.  This consists
      of 56 bits of\n   actual key data, and eight parity bits, one per octet.  The
      key is\n   encoded as a series of eight octets written in MSB-first order.  The\n
      \  bits within the key are also encoded in MSB order.  For example, if\n   the
      encryption key is\n   (B1,B2,...,B7,P1,B8,...,B14,P2,B15,...,B49,P7,B50,...,B56,P8),
      where\n   B1,B2,...,B56 are the key bits in MSB order, and P1,P2,...,P8 are
      the\n   parity bits, the first octet of the key would be B1,B2,...,B7,P1\n   (with
      B1 as the most significant bit).  See the [DESM80] introduction\n   for reference.\n
      \  Encryption Data Format\n   The format for the data to be encrypted includes
      a one-block\n   confounder, a checksum, the encoded plaintext, and any necessary\n
      \  padding, as described in the following diagram.  The msg-seq field\n   contains
      the part of the protocol message to be encrypted.\n                  +-----------+----------+---------+-----+\n
      \                 |confounder | checksum | msg-seq | pad |\n                  +-----------+----------+---------+-----+\n
      \  One generates a random confounder of one block, placing it in\n   'confounder';
      zeros out the 'checksum' field (of length appropriate\n   to exactly hold the
      checksum to be computed); adds the necessary\n   padding; calculates the appropriate
      checksum over the whole sequence,\n   placing the result in 'checksum'; and
      then encrypts using the\n   specified encryption type and the appropriate key.\n
      \  String or Random-Data to Key Transformation\n   To generate a DES key from
      two UTF-8 text strings (password and\n   salt), the two strings are concatenated,
      password first, and the\n   result is then padded with zero-valued octets to
      a multiple of eight\n   octets.\n   The top bit of each octet (always zero if
      the password is plain\n   ASCII, as was assumed when the original specification
      was written) is\n   discarded, and the remaining seven bits of each octet form
      a\n   bitstring.  This is then fan-folded and eXclusive-ORed with itself to\n
      \  produce a 56-bit string.  An eight-octet key is formed from this\n   string,
      each octet using seven bits from the bitstring, leaving the\n   least significant
      bit unassigned.  The key is then \"corrected\" by\n   correcting the parity
      on the key, and if the key matches a 'weak' or\n   'semi-weak' key as described
      in the DES specification, it is\n   eXclusive-ORed with the constant 0x00000000000000F0.
      \ This key is\n   then used to generate a DES CBC checksum on the initial string
      with\n   the salt appended.  The result of the CBC checksum is then\n   \"corrected\"
      as described above to form the result, which is returned\n   as the key.\n   For
      purposes of the string-to-key function, the DES CBC checksum is\n   calculated
      by CBC encrypting a string using the key as IV and the\n   final eight byte
      block as the checksum.\n   Pseudocode follows:\n        removeMSBits(8byteblock)
      {\n          /* Treats a 64 bit block as 8 octets and removes the MSB in\n             each
      octet (in big endian mode) and concatenates the\n             result.  E.g.,
      the input octet string:\n                01110000 01100001 11110011  01110011
      11110111 01101111\n                11110010 01100100\n             results in
      the output bitstring:\n                1110000 1100001 1110011  1110011 1110111
      1101111\n                1110010 1100100  */\n        }\n        reverse(56bitblock)
      {\n          /* Treats a 56-bit block as a binary string and reverses it.\n
      \            E.g., the input string:\n                1000001 1010100 1001000
      \ 1000101 1001110 1000001\n                0101110 1001101\n             results
      in the output string:\n                1011001 0111010 1000001  0111001 1010001
      0001001\n                0010101 1000001  */\n        }\n        add_parity_bits(56bitblock)
      {\n          /* Copies a 56-bit block into a 64-bit block, left shifts\n             content
      in each octet, and add DES parity bit.\n             E.g., the input string:\n
      \               1100000 0001111 0011100  0110100 1000101 1100100\n                0110110
      0010111\n             results in the output string:\n                11000001
      00011111 00111000  01101000 10001010 11001000\n                01101101 00101111
      \ */\n        }\n        key_correction(key) {\n             fixparity(key);\n
      \            if (is_weak_key(key))\n                  key = key XOR 0xF0;\n
      \            return(key);\n        }\n        mit_des_string_to_key(string,salt)
      {\n             odd = 1;\n             s = string | salt;\n             tempstring
      = 0; /* 56-bit string */\n             pad(s); /* with nulls to 8 byte boundary
      */\n             for (8byteblock in s) {\n                  56bitstring = removeMSBits(8byteblock);\n
      \                 if (odd == 0) reverse(56bitstring);\n                  odd
      = ! odd;\n                  tempstring = tempstring XOR 56bitstring;\n             }\n
      \            tempkey = key_correction(add_parity_bits(tempstring));\n             key
      = key_correction(DES-CBC-check(s,tempkey));\n             return(key);\n        }\n
      \       des_string_to_key(string,salt,params) {\n             if (length(params)
      == 0)\n                  type = 0;\n             else if (length(params) ==
      1)\n                  type = params[0];\n             else\n                  error(\"invalid
      params\");\n             if (type == 0)\n                  mit_des_string_to_key(string,salt);\n
      \            else\n                  error(\"invalid params\");\n        }\n
      \  One common extension is to support the \"AFS string-to-key\" algorithm,\n
      \  which is not defined here, if the type value above is one (1).\n   For generation
      of a key from a random bitstring, we start with a 56-\n   bit string and, as
      with the string-to-key operation above, insert\n   parity bits.  If the result
      is a weak or semi-weak key, we modify it\n   by eXclusive-OR with the constant
      0x00000000000000F0:\n        des_random_to_key(bitstring) {\n             return
      key_correction(add_parity_bits(bitstring));\n        }\n"
    - contents:
      - "6.2.1.  DES with MD5\n   The des-cbc-md5 encryption mode encrypts information
        under DES in CBC\n   mode with an all-zero initial vector and with an MD5
        checksum\n   (described in [MD5-92]) computed and placed in the checksum field.\n
        \  The encryption system parameters for des-cbc-md5 are as follows:\n                               des-cbc-md5\n
        \  --------------------------------------------------------------------\n
        \  protocol key format      8 bytes, parity in low bit of each\n   specific
        key structure   copy of original key\n   required checksum        rsa-md5-des\n
        \  mechanism\n   key-generation seed      8 bytes\n   length\n   cipher state
        \            8 bytes (CBC initial vector)\n   initial cipher state     all-zero\n
        \  encryption function      des-cbc(confounder | checksum | msg | pad,\n                                    ivec=oldstate)\n
        \                           where\n                            checksum =
        md5(confounder | 0000...\n                                           | msg
        | pad)\n                            newstate = last block of des-cbc output\n
        \  decryption function      decrypt encrypted text and verify checksum\n                            newstate
        = last block of ciphertext\n                               des-cbc-md5\n   --------------------------------------------------------------------\n
        \  default string-to-key    empty string\n   params\n   pseudo-random function
        \  des-cbc(md5(input-string), ivec=0)\n   key generation functions:\n   string-to-key
        \           des_string_to_key\n   random-to-key            des_random_to_key\n
        \  key-derivation           identity\n   The des-cbc-md5 encryption type is
        assigned the etype value three\n   (3).\n"
      title: 6.2.1.  DES with MD5
    - contents:
      - "6.2.2.  DES with MD4\n   The des-cbc-md4 encryption mode also encrypts information
        under DES\n   in CBC mode, with an all-zero initial vector.  An MD4 checksum\n
        \  (described in [MD4-92]) is computed and placed in the checksum field.\n
        \                              des-cbc-md4\n   --------------------------------------------------------------------\n
        \  protocol key format      8 bytes, parity in low bit of each\n   specific
        key structure   copy of original key\n   required checksum        rsa-md4-des\n
        \  mechanism\n   key-generation seed      8 bytes\n   length\n   cipher state
        \            8 bytes (CBC initial vector)\n   initial cipher state     all-zero\n
        \  encryption function      des-cbc(confounder | checksum | msg | pad,\n                                    ivec=oldstate)\n
        \                           where\n                            checksum =
        md4(confounder | 0000...\n                                           | msg
        | pad)\n                            newstate = last block of des-cbc output\n
        \                              des-cbc-md4\n   --------------------------------------------------------------------\n
        \  decryption function      decrypt encrypted text and verify checksum\n                            newstate
        = last block of ciphertext\n   default string-to-key    empty string\n   params\n
        \  pseudo-random function   des-cbc(md5(input-string), ivec=0)\n   key generation
        functions:\n   string-to-key            des_string_to_key\n   random-to-key
        \           copy input, then fix parity bits\n   key-derivation           identity\n
        \  Note that des-cbc-md4 uses md5, not md4, in the PRF definition.\n   The
        des-cbc-md4 encryption algorithm is assigned the etype value two\n   (2).\n"
      title: 6.2.2.  DES with MD4
    - contents:
      - "6.2.3.  DES with CRC\n   The des-cbc-crc encryption type uses DES in CBC
        mode with the key\n   used as the initialization vector, with a four-octet
        CRC-based\n   checksum computed as described in section 6.1.3.  Note that
        this is\n   not a standard CRC-32 checksum, but a slightly modified one.\n
        \                              des-cbc-crc\n   --------------------------------------------------------------------\n
        \  protocol key format      8 bytes, parity in low bit of each\n   specific
        key structure   copy of original key\n   required checksum        rsa-md5-des\n
        \  mechanism\n   key-generation seed      8 bytes\n   length\n   cipher state
        \            8 bytes (CBC initial vector)\n                               des-cbc-crc\n
        \  --------------------------------------------------------------------\n
        \  initial cipher state     copy of original key\n   encryption function      des-cbc(confounder
        | checksum | msg | pad,\n                                    ivec=oldstate)\n
        \                           where\n                            checksum =
        crc(confounder | 00000000\n                                           | msg
        | pad)\n                            newstate = last block of des-cbc output\n
        \  decryption function      decrypt encrypted text and verify checksum\n                            newstate
        = last block of ciphertext\n   default string-to-key    empty string\n   params\n
        \  pseudo-random function   des-cbc(md5(input-string), ivec=0)\n   key generation
        functions:\n   string-to-key            des_string_to_key\n   random-to-key
        \           copy input, then fix parity bits\n   key-derivation           identity\n
        \  The des-cbc-crc encryption algorithm is assigned the etype value one\n
        \  (1).\n"
      title: 6.2.3.  DES with CRC
    - contents:
      - "6.2.4.  RSA MD5 Cryptographic Checksum Using DES\n   The RSA-MD5-DES checksum
        calculates a keyed collision-proof checksum\n   by prepending an eight octet
        confounder before the text, applying the\n   RSA MD5 checksum algorithm, and
        encrypting the confounder and the\n   checksum by using DES in cipher-block-chaining
        (CBC) mode with a\n   variant of the key, where the variant is computed by
        eXclusive-ORing\n   the key with the hexadecimal constant 0xF0F0F0F0F0F0F0F0.
        \ The\n   initialization vector should be zero.  The resulting checksum is
        24\n   octets long.\n                                rsa-md5-des\n      ----------------------------------------------------------------\n
        \     associated cryptosystem   des-cbc-md5, des-cbc-md4, des-cbc-crc\n      get_mic
        \                  des-cbc(key XOR 0xF0F0F0F0F0F0F0F0,\n                                        conf
        | rsa-md5(conf | msg))\n      verify_mic                decrypt and verify
        rsa-md5 checksum\n   The rsa-md5-des checksum algorithm is assigned a checksum
        type number\n   of eight (8).\n"
      title: 6.2.4.  RSA MD5 Cryptographic Checksum Using DES
    - contents:
      - "6.2.5.  RSA MD4 Cryptographic Checksum Using DES\n   The RSA-MD4-DES checksum
        calculates a keyed collision-proof checksum\n   by prepending an eight octet
        confounder before the text, applying the\n   RSA MD4 checksum algorithm [MD4-92],
        and encrypting the confounder\n   and the checksum using DES in cipher-block-chaining
        (CBC) mode with a\n   variant of the key, where the variant is computed by
        eXclusive-ORing\n   the key with the constant 0xF0F0F0F0F0F0F0F0 [7].  The
        initialization\n   vector should be zero.  The resulting checksum is 24 octets
        long.\n                                rsa-md4-des\n      ----------------------------------------------------------------\n
        \     associated cryptosystem   des-cbc-md5, des-cbc-md4, des-cbc-crc\n      get_mic
        \                  des-cbc(key XOR 0xF0F0F0F0F0F0F0F0,\n                                        conf
        | rsa-md4(conf | msg),\n                                        ivec=0)\n
        \     verify_mic                decrypt and verify rsa-md4 checksum\n   The
        rsa-md4-des checksum algorithm is assigned a checksum type number\n   of three
        (3).\n"
      title: 6.2.5.  RSA MD4 Cryptographic Checksum Using DES
    - contents:
      - "6.2.6.  RSA MD4 Cryptographic Checksum Using DES Alternative\n   The RSA-MD4-DES-K
        checksum calculates a keyed collision-proof\n   checksum by applying the RSA
        MD4 checksum algorithm and encrypting\n   the results by using DES in cipher
        block chaining (CBC) mode with a\n   DES key as both key and initialization
        vector.  The resulting\n   checksum is 16 octets long.  This checksum is tamper-proof
        and\n   believed to be collision-proof.  Note that this checksum type is the\n
        \  old method for encoding the RSA-MD4-DES checksum; it is no longer\n   recommended.\n
        \                              rsa-md4-des-k\n      ----------------------------------------------------------------\n
        \     associated cryptosystem   des-cbc-md5, des-cbc-md4, des-cbc-crc\n      get_mic
        \                  des-cbc(key, md4(msg), ivec=key)\n      verify_mic                decrypt,
        compute checksum and compare\n   The rsa-md4-des-k checksum algorithm is assigned
        a checksum type\n   number of six (6).\n"
      title: 6.2.6.  RSA MD4 Cryptographic Checksum Using DES Alternative
    - contents:
      - "6.2.7.  DES CBC Checksum\n   The DES-MAC checksum is computed by prepending
        an eight octet\n   confounder to the plaintext, padding with zero-valued octets
        if\n   necessary to bring the length to a multiple of eight octets,\n   performing
        a DES CBC-mode encryption on the result by using the key\n   and an initialization
        vector of zero, taking the last block of the\n   ciphertext, prepending the
        same confounder, and encrypting the pair\n   by using DES in cipher-block-chaining
        (CBC) mode with a variant of\n   the key, where the variant is computed by
        eXclusive-ORing the key\n   with the constant 0xF0F0F0F0F0F0F0F0.  The initialization
        vector\n   should be zero.  The resulting checksum is 128 bits (sixteen octets)\n
        \  long, 64 bits of which are redundant.  This checksum is tamper-proof\n
        \  and collision-proof.\n                                  des-mac\n   ---------------------------------------------------------------------\n
        \  associated     des-cbc-md5, des-cbc-md4, des-cbc-crc\n   cryptosystem\n
        \  get_mic        des-cbc(key XOR 0xF0F0F0F0F0F0F0F0,\n                          conf
        | des-mac(key, conf | msg | pad, ivec=0),\n                          ivec=0)\n
        \  verify_mic     decrypt, compute DES MAC using confounder, compare\n   The
        des-mac checksum algorithm is assigned a checksum type number of\n   four
        (4).\n"
      title: 6.2.7.  DES CBC Checksum
    - contents:
      - "6.2.8.  DES CBC Checksum Alternative\n   The DES-MAC-K checksum is computed
        by performing a DES CBC-mode\n   encryption of the plaintext, with zero-valued
        padding bytes if\n   necessary to bring the length to a multiple of eight
        octets, and by\n   using the last block of the ciphertext as the checksum
        value.  It is\n   keyed with an encryption key that is also used as the initialization\n
        \  vector.  The resulting checksum is 64 bits (eight octets) long.  This\n
        \  checksum is tamper-proof and collision-proof.  Note that this\n   checksum
        type is the old method for encoding the DESMAC checksum; it\n   is no longer
        recommended.\n                                 des-mac-k\n      ----------------------------------------------------------------\n
        \     associated cryptosystem   des-cbc-md5, des-cbc-md4, des-cbc-crc\n      get_mic
        \                  des-mac(key, msg | pad, ivec=key)\n      verify_mic                compute
        MAC and compare\n   The des-mac-k checksum algorithm is assigned a checksum
        type number\n   of five (5).\n"
      title: 6.2.8.  DES CBC Checksum Alternative
    title: 6.2.  DES-Based Encryption and Checksum Types
  - contents:
    - "6.3.  Triple-DES Based Encryption and Checksum Types\n   This encryption and
      checksum type pair is based on the Triple DES\n   cryptosystem in Outer-CBC
      mode and on the HMAC-SHA1 message\n   authentication algorithm.\n   A Triple
      DES key is the concatenation of three DES keys as described\n   above for des-cbc-md5.
      \ A Triple DES key is generated from random\n   data by creating three DES keys
      from separate sequences of random\n   data.\n   Encrypted data using this type
      must be generated as described in\n   section 5.3.  If the length of the input
      data is not a multiple of\n   the block size, zero-valued octets must be used
      to pad the plaintext\n   to the next eight-octet boundary.  The confounder must
      be eight\n   random octets (one block).\n   The simplified profile for Triple
      DES, with key derivation as defined\n   in section 5, is as follows:\n                 des3-cbc-hmac-sha1-kd,
      hmac-sha1-des3-kd\n              ------------------------------------------------\n
      \             protocol key format     24 bytes, parity in low\n                                      bit
      of each\n              key-generation seed     21 bytes\n              length\n
      \                des3-cbc-hmac-sha1-kd, hmac-sha1-des3-kd\n              ------------------------------------------------\n
      \             hash function           SHA-1\n              HMAC output size
      \       160 bits\n              message block size      8 bytes\n              default
      string-to-key   empty string\n              params\n              encryption
      and          triple-DES encrypt and\n              decryption functions    decrypt,
      in outer-CBC\n                                      mode (cipher block size\n
      \                                     8 octets)\n              key generation
      functions:\n              random-to-key           DES3random-to-key (see\n                                      below)\n
      \             string-to-key           DES3string-to-key (see\n                                      below)\n
      \  The des3-cbc-hmac-sha1-kd encryption type is assigned the value\n   sixteen
      (16).  The hmac-sha1-des3-kd checksum algorithm is assigned a\n   checksum type
      number of twelve (12).\n"
    - contents:
      - "6.3.1.  Triple DES Key Production (random-to-key, string-to-key)\n   The
        168 bits of random key data are converted to a protocol key value\n   as follows.
        \ First, the 168 bits are divided into three groups of 56\n   bits, which
        are expanded individually into 64 bits as follows:\n   DES3random-to-key:\n
        \        1  2  3  4  5  6  7  p\n         9 10 11 12 13 14 15  p\n        17
        18 19 20 21 22 23  p\n        25 26 27 28 29 30 31  p\n        33 34 35 36
        37 38 39  p\n        41 42 43 44 45 46 47  p\n        49 50 51 52 53 54 55
        \ p\n        56 48 40 32 24 16  8  p\n   The \"p\" bits are parity bits computed
        over the data bits.  The output\n   of the three expansions, each corrected
        to avoid \"weak\" and \"semi-\n   weak\" keys as in section 6.2, are concatenated
        to form the protocol\n   key value.\n   The string-to-key function is used
        to transform UTF-8 passwords into\n   DES3 keys.  The DES3 string-to-key function
        relies on the \"N-fold\"\n   algorithm and DK function, described in section
        5.\n   The n-fold algorithm is applied to the password string concatenated\n
        \  with a salt value.  For 3-key triple DES, the operation will involve\n
        \  a 168-fold of the input password string, to generate an intermediate\n
        \  key, from which the user's long-term key will be derived with the DK\n
        \  function.  The DES3 string-to-key function is shown here in\n   pseudocode:\n
        \        DES3string-to-key(passwordString, salt, params)\n             if
        (params != emptyString)\n              error(\"invalid params\");\n             s
        = passwordString + salt\n             tmpKey = random-to-key(168-fold(s))\n
        \            key = DK (tmpKey, KerberosConstant)\n   Weak key checking is
        performed in the random-to-key and DK\n   operations.  The KerberosConstant
        value is the byte string {0x6b 0x65\n   0x72 0x62 0x65 0x72 0x6f 0x73}.  These
        values correspond to the ASCII\n   encoding for the string \"kerberos\".\n"
      title: 6.3.1.  Triple DES Key Production (random-to-key, string-to-key)
    title: 6.3.  Triple-DES Based Encryption and Checksum Types
  title: 6.  Profiles for Kerberos Encryption and Checksum Algorithms
- contents:
  - "7.  Use of Kerberos Encryption Outside This Specification\n   Several Kerberos-based
    application protocols and preauthentication\n   systems have been designed and
    deployed that perform encryption and\n   message integrity checks in various ways.
    \ Although in some cases\n   there may be good reason for specifying these protocols
    in terms of\n   specific encryption or checksum algorithms, we anticipate that
    in\n   many cases this will not be true, and more generic approaches\n   independent
    of particular algorithms will be desirable.  Rather than\n   have each protocol
    designer reinvent schemes for protecting data,\n   using multiple keys, etc.,
    we have attempted to present in this\n   section a general framework that should
    be sufficient not only for\n   the Kerberos protocol itself but also for many
    preauthentication\n   systems and application protocols, while trying to avoid
    some of the\n   assumptions that can work their way into such protocol designs.\n
    \  Some problematic assumptions we've seen (and sometimes made) include\n   the
    following: a random bitstring is always valid as a key (not true\n   for DES keys
    with parity); the basic block encryption chaining mode\n   provides no integrity
    checking, or can easily be separated from such\n   checking (not true for many
    modes in development that do both\n   simultaneously); a checksum for a message
    always results in the same\n   value (not true if a confounder is incorporated);
    an initial vector\n   is used (may not be true if a block cipher in CBC mode is
    not in\n   use).\n   Although such assumptions the may hold for any given set
    of\n   encryption and checksum algorithms, they may not be true of the next\n
    \  algorithms to be defined, leaving the application protocol unable to\n   make
    use of those algorithms without updates to its specification.\n   The Kerberos
    protocol uses only the attributes and operations\n   described in sections 3 and
    4.  Preauthentication systems and\n   application protocols making use of Kerberos
    are encouraged to use\n   them as well.  The specific key and string-to-key parameters
    should\n   generally be treated as opaque.  Although the string-to-key\n   parameters
    are manipulated as an octet string, the representation for\n   the specific key
    structure is implementation defined; it may not even\n   be a single object.\n
    \  We don't recommend doing so, but some application protocols will\n   undoubtedly
    continue to use the key data directly, even if only in\n   some of the currently
    existing protocol specifications.  An\n   implementation intended to support general
    Kerberos applications may\n   therefore need to make the key data available, as
    well as the\n   attributes and operations described in sections 3 and 4 [8].\n"
  title: 7.  Use of Kerberos Encryption Outside This Specification
- contents:
  - "8.  Assigned Numbers\n   The following encryption-type numbers are already assigned
    or\n   reserved for use in Kerberos and related protocols.\n      encryption type
    \               etype      section or comment\n      -----------------------------------------------------------------\n
    \     des-cbc-crc                        1             6.2.3\n      des-cbc-md4
    \                       2             6.2.2\n      des-cbc-md5                        3
    \            6.2.1\n      [reserved]                         4\n      des3-cbc-md5
    \                      5\n      [reserved]                         6\n      des3-cbc-sha1
    \                     7\n      dsaWithSHA1-CmsOID                 9           (pkinit)\n
    \     md5WithRSAEncryption-CmsOID       10           (pkinit)\n      sha1WithRSAEncryption-CmsOID
    \     11           (pkinit)\n      rc2CBC-EnvOID                     12           (pkinit)\n
    \     rsaEncryption-EnvOID              13   (pkinit from PKCS#1 v1.5)\n      rsaES-OAEP-ENV-OID
    \               14   (pkinit from PKCS#1 v2.0)\n      des-ede3-cbc-Env-OID              15
    \          (pkinit)\n      des3-cbc-sha1-kd                  16              6.3\n
    \     aes128-cts-hmac-sha1-96           17          [KRB5-AES]\n      aes256-cts-hmac-sha1-96
    \          18          [KRB5-AES]\n      rc4-hmac                          23
    \         (Microsoft)\n      rc4-hmac-exp                      24          (Microsoft)\n
    \     subkey-keymaterial                65     (opaque; PacketCable)\n   (The
    \"des3-cbc-sha1\" assignment is a deprecated version using no key\n   derivation.
    \ It should not be confused with des3-cbc-sha1-kd.)\n   Several numbers have been
    reserved for use in encryption systems not\n   defined here.  Encryption-type
    numbers have unfortunately been\n   overloaded on occasion in Kerberos-related
    protocols, so some of the\n   reserved numbers do not and will not correspond
    to encryption systems\n   fitting the profile presented here.\n   The following
    checksum-type numbers are assigned or reserved.  As\n   with encryption-type numbers,
    some overloading of checksum numbers\n   has occurred.\n   Checksum type              sumtype
    \       checksum         section or\n                                value            size
    \        reference\n   ---------------------------------------------------------------------\n
    \  CRC32                            1               4           6.1.3\n   rsa-md4
    \                         2              16           6.1.2\n   rsa-md4-des                      3
    \             24           6.2.5\n   des-mac                          4              16
    \          6.2.7\n   des-mac-k                        5               8           6.2.8\n
    \  rsa-md4-des-k                    6              16           6.2.6\n   rsa-md5
    \                         7              16           6.1.1\n   rsa-md5-des                      8
    \             24           6.2.4\n   rsa-md5-des3                     9              24
    \            ??\n   sha1 (unkeyed)                  10              20             ??\n
    \  hmac-sha1-des3-kd               12              20            6.3\n   hmac-sha1-des3
    \                 13              20             ??\n   sha1 (unkeyed)                  14
    \             20             ??\n   hmac-sha1-96-aes128             15              20
    \        [KRB5-AES]\n   hmac-sha1-96-aes256             16              20         [KRB5-AES]\n
    \  [reserved]                  0x8003               ?         [GSS-KRB5]\n   Encryption
    and checksum-type numbers are signed 32-bit values.  Zero\n   is invalid, and
    negative numbers are reserved for local use.  All\n   standardized values must
    be positive.\n"
  title: 8.  Assigned Numbers
- contents:
  - "9.  Implementation Notes\n   The \"interface\" described here is the minimal
    information that must\n   be defined to make a cryptosystem useful within Kerberos
    in an\n   interoperable fashion.  The use of functional notation used in some\n
    \  places is not an attempt to define an API for cryptographic\n   functionality
    within Kerberos.  Actual implementations providing\n   clean APIs will probably
    make additional information available, that\n   could be derived from a specification
    written to the framework given\n   here.  For example, an application designer
    may wish to determine the\n   largest number of bytes that can be encrypted without
    overflowing a\n   certain size output buffer or conversely, the maximum number
    of bytes\n   that might be obtained by decrypting a ciphertext message of a given\n
    \  size.  (In fact, an implementation of the GSS-API Kerberos mechanism\n   [GSS-KRB5]
    will require some of these.)\n   The presence of a mechanism in this document
    should not be taken to\n   indicate that it must be implemented for compliance
    with any\n   specification; required mechanisms will be specified elsewhere.\n
    \  Indeed, some of the mechanisms described here for backward\n   compatibility
    are now considered rather weak for protecting critical\n   data.\n"
  title: 9.  Implementation Notes
- contents:
  - "10.  Security Considerations\n   Recent years have brought so many advancements
    in large-scale attacks\n   capability against DES that it is no longer considered
    a strong\n   encryption mechanism.  Triple-DES is generally preferred in its\n
    \  place, despite its poorer performance.  See [ESP-DES] for a summary\n   of
    some of the potential attacks and [EFF-DES] for a detailed\n   discussion of the
    implementation of particular attacks.  However,\n   most Kerberos implementations
    still have DES as their primary\n   interoperable encryption type.\n   DES has
    four 'weak' keys and twelve 'semi-weak' keys, and the use of\n   single-DES here
    avoids them.  However, DES also has 48 'possibly-\n   weak' keys [Schneier96]
    (note that the tables in many editions of the\n   reference contains errors) that
    are not avoided.\n   DES weak keys have the property that E1(E1(P)) = P (where
    E1 denotes\n   encryption of a single block with key 1).  DES semi-weak keys,
    or\n   \"dual\" keys, are pairs of keys with the property that E1(P) = D2(P),\n
    \  and thus E2(E1(P)) = P.  Because of the use of CBC mode and the\n   leading
    random confounder, however, these properties are unlikely to\n   present a security
    problem.\n   Many of the choices concerning when to perform weak-key corrections\n
    \  relate more to compatibility with existing implementations than to\n   any
    risk analysis.\n   Although checks are also done for the component DES keys in
    a\n   triple-DES key, the nature of the weak keys make it extremely\n   unlikely
    that they will weaken the triple-DES encryption.  It is only\n   slightly more
    likely than having the middle of the three sub-keys\n   match one of the other
    two, which effectively converts the encryption\n   to single-DES - a case we make
    no effort to avoid.\n   The true CRC-32 checksum is not collision-proof; an attacker
    could\n   use a probabilistic chosen-plaintext attack to generate a valid\n   message
    even if a confounder is used [SG92].  The use of collision-\n   proof checksums
    is of course recommended for environments where such\n   attacks represent a significant
    threat.  The \"simplifications\" (read:\n   bugs) introduced when CRC-32 was implemented
    for Kerberos cause\n   leading zeros effectively to be ignored, so messages differing
    only\n   in leading zero bits will have the same checksum.\n   [HMAC] and [IPSEC-HMAC]
    discuss weaknesses of the HMAC algorithm.\n   Unlike [IPSEC-HMAC], the triple-DES
    specification here does not use\n   the suggested truncation of the HMAC output.
    \ As pointed out in\n   [IPSEC-HMAC], SHA-1 was not developed for use as a keyed
    hash\n   function, which is a criterion of HMAC.  [HMAC-TEST] contains test\n
    \  vectors for HMAC-SHA-1.\n   The mit_des_string_to_key function was originally
    constructed with\n   the assumption that all input would be ASCII; it ignores
    the top bit\n   of each input byte.  Folding with XOR is also not an especially
    good\n   mixing mechanism for preserving randomness.\n   The n-fold function used
    in the string-to-key operation for des3-\n   cbc-hmac-sha1-kd was designed to
    cause each bit of input to\n   contribute equally to the output.  It was not designed
    to maximize or\n   equally distribute randomness in the input, and conceivably\n
    \  randomness may be lost in cases of partially structured input.  This\n   should
    only be an issue for highly structured passwords, however.\n   [RFC1851] discusses
    the relative strength of triple-DES encryption.\n   The relatively slow speed
    of triple-DES encryption may also be an\n   issue for some applications.\n   [Bellovin91]
    suggests that analyses of encryption schemes include a\n   model of an attacker
    capable of submitting known plaintexts to be\n   encrypted with an unknown key,
    as well as be able to perform many\n   types of operations on known protocol messages.
    \ Recent experiences\n   with the chosen-plaintext attacks on Kerberos version
    4 bear out the\n   value of this suggestion.\n   The use of unkeyed encrypted
    checksums, such as those used in the\n   single-DES cryptosystems specified in
    [Kerb1510], allows for cut-\n   and-paste attacks, especially if a confounder
    is not used.  In\n   addition, unkeyed encrypted checksums are vulnerable to chosen-\n
    \  plaintext attacks: An attacker with access to an encryption oracle\n   can
    easily encrypt the required unkeyed checksum along with the\n   chosen plaintext.
    [Bellovin99]  These weaknesses, combined with a\n   common implementation design
    choice described below, allow for a\n   cross-protocol attack from version 4 to
    version 5.\n   The use of a random confounder is an important means to prevent
    an\n   attacker from making effective use of protocol exchanges as an\n   encryption
    oracle.  In Kerberos version 4, the encryption of constant\n   plaintext to constant
    ciphertext makes an effective encryption oracle\n   for an attacker.  The use
    of random confounders in [Kerb1510]\n   frustrates this sort of chosen-plaintext
    attack.\n   Using the same key for multiple purposes can enable or increase the\n
    \  scope of chosen-plaintext attacks.  Some software that implements\n   both
    versions 4 and 5 of the Kerberos protocol uses the same keys for\n   both versions.
    \ This enables the encryption oracle of version 4 to be\n   used to attack version
    5.  Vulnerabilities to attacks such as this\n   cross-protocol attack make it
    unwise to use a key for multiple\n   purposes.\n   This document, like the Kerberos
    protocol, does not address limiting\n   the amount of data a key may be used with
    to a quantity based on the\n   robustness of the algorithm or size of the key.
    \ It is assumed that\n   any defined algorithms and key sizes will be strong enough
    to support\n   very large amounts of data, or they will be deprecated once\n   significant
    attacks are known.\n   This document also places no bounds on the amount of data
    that can be\n   handled in various operations.  To avoid denial of service attacks,\n
    \  implementations will probably seek to restrict message sizes at some\n   higher
    level.\n"
  title: 10.  Security Considerations
- contents:
  - "11.  IANA Considerations\n   Two registries for numeric values have been created:
    Kerberos\n   Encryption Type Numbers and Kerberos Checksum Type Numbers.  These\n
    \  are signed values ranging from -2147483648 to 2147483647.  Positive\n   values
    should be assigned only for algorithms specified in accordance\n   with this specification
    for use with Kerberos or related protocols.\n   Negative values are for private
    use; local and experimental\n   algorithms should use these values.  Zero is reserved
    and may not be\n   assigned.\n   Positive encryption- and checksum-type numbers
    may be assigned\n   following either of two policies described in [BCP26].\n   Standards-track
    specifications may be assigned values under the\n   Standards Action policy.\n
    \  Specifications in non-standards track RFCs may be assigned values\n   after
    Expert Review.  A non-IETF specification may be assigned values\n   by publishing
    an Informational or standards-track RFC referencing the\n   external specification;
    that specification must be public and\n   published in some permanent record,
    much like the IETF RFCs.  It is\n   highly desirable, though not required, that
    the full specification be\n   published as an IETF RFC.\n   Smaller encryption
    type values should be used for IETF standards-\n   track mechanisms, and much
    higher values (16777216 and above) for\n   other mechanisms.  (Rationale: In the
    Kerberos ASN.1 encoding,\n   smaller numbers encode to smaller octet sequences,
    so this favors\n   standards-track mechanisms with slightly smaller messages.)
    \ Aside\n   from that guideline, IANA may choose numbers as it sees fit.\n   Internet-Draft
    specifications should not include values for\n   encryption- and checksum-type
    numbers.  Instead, they should indicate\n   that values would be assigned by IANA
    when the document is approved\n   as an RFC.  For development and interoperability
    testing, values in\n   the private-use range (negative values) may be used but
    should not be\n   included in the draft specification.\n   Each registered value
    should have an associated unique reference\n   name.  The lists given in section
    8 were used to create the initial\n   registry; they include reservations for
    specifications in progress in\n   parallel with this document, and certain other
    values believed to\n   already be in use.\n"
  title: 11.  IANA Considerations
- contents:
  - "12.  Acknowledgements\n   This document is an extension of the encryption specification\n
    \  included in [Kerb1510] by B. Clifford Neuman and John Kohl, and much\n   of
    the text of the background, concepts, and DES specifications is\n   drawn directly
    from that document.\n   The abstract framework presented in this document was
    put together by\n   Jeff Altman, Sam Hartman, Jeff Hutzelman, Cliff Neuman, Ken
    Raeburn,\n   and Tom Yu, and the details were refined several times based on\n
    \  comments from John Brezak and others.\n   Marc Horowitz wrote the original
    specification of triple-DES and key\n   derivation in a pair of Internet-Drafts
    (under the names draft-\n   horowitz-key-derivation and draft-horowitz-kerb-key-derivation)
    that\n   were later folded into a draft revision of [Kerb1510], from which\n   this
    document was later split off.\n   Tom Yu provided the text describing the modifications
    to the standard\n   CRC algorithm as Kerberos implementations actually use it,
    and some\n   of the text in the Security Considerations section.\n   Miroslav
    Jurisic provided information for one of the UTF-8 test cases\n   for the string-to-key
    functions.\n   Marcus Watts noticed some errors in earlier versions and pointed
    out\n   that the simplified profile could easily be modified to support\n   cipher
    text stealing modes.\n   Simon Josefsson contributed some clarifications to the
    DES \"CBC\n   checksum\" and string-to-key and weak key descriptions, and some
    test\n   vectors.\n   Simon Josefsson, Louis LeVay, and others also caught some
    errors in\n   earlier versions of this document.\n"
  - "A.  Test Vectors\n   This section provides test vectors for various functions
    defined or\n   described in this document.  For convenience, most inputs are ASCII\n
    \  strings, though some UTF-8 samples are provided for string-to-key\n   functions.
    \ Keys and other binary data are specified as hexadecimal\n   strings.\n"
  - contents:
    - "A.1.  n-fold\n   The n-fold function is defined in section 5.1.  As noted there,
      the\n   sample vector in the original paper defining the algorithm appears to\n
      \  be incorrect.  Here are some test cases provided by Marc Horowitz and\n   Simon
      Josefsson:\n      64-fold(\"012345\") =\n      64-fold(303132333435) = be072631276b1955\n
      \     56-fold(\"password\") =\n      56-fold(70617373776f7264) = 78a07b6caf85fa\n
      \     64-fold(\"Rough Consensus, and Running Code\") =\n      64-fold(526f75676820436f6e73656e7375732c20616e642052756e\n
      \             6e696e6720436f6465) = bb6ed30870b7f0e0\n      168-fold(\"password\")
      =\n      168-fold(70617373776f7264) =\n               59e4a8ca7c0385c3c37b3f6d2000247cb6e6bd5b3e\n
      \     192-fold(\"MASSACHVSETTS INSTITVTE OF TECHNOLOGY\")\n      192-fold(4d41535341434856534554545320494e5354495456544520\n
      \              4f4620544543484e4f4c4f4759) =\n               db3b0d8f0b061e603282b308a50841229ad798fab9540c1b\n
      \     168-fold(\"Q\") =\n      168-fold(51) =\n               518a54a2 15a8452a
      518a54a2 15a8452a\n               518a54a2 15\n      168-fold(\"ba\") =\n      168-fold(6261)
      =\n               fb25d531 ae897449 9f52fd92 ea9857c4\n               ba24cf29
      7e\n   Here are some additional values corresponding to folded values of the\n
      \  string \"kerberos\"; the 64-bit form is used in the des3 string-to-key\n
      \  (section 6.3.1).\n      64-fold(\"kerberos\") =\n               6b657262
      65726f73\n      128-fold(\"kerberos\") =\n               6b657262 65726f73 7b9b5b2b
      93132b93\n      168-fold(\"kerberos\") =\n               8372c236 344e5f15 50cd0747
      e15d62ca\n               7a5a3bce a4\n      256-fold(\"kerberos\") =\n               6b657262
      65726f73 7b9b5b2b 93132b93\n               5c9bdcda d95c9899 c4cae4de e6d6cae4\n
      \  Note that the initial octets exactly match the input string when the\n   output
      length is a multiple of the input length.\n"
    title: A.1.  n-fold
  - contents:
    - "A.2.  mit_des_string_to_key\n   The function mit_des_string_to_key is defined
      in section 6.2.  We\n   present here several test values, with some of the intermediate\n
      \  results.  The fourth test demonstrates the use of UTF-8 with three\n   characters.
      \ The last two tests are specifically constructed so as to\n   trigger the weak-key
      fixups for the intermediate key produced by\n   fan-folding; we have no test
      cases that cause such fixups for the\n   final key.\n"
    - 'UTF-8 encodings used in test vector:

      '
    - 'eszett    U+00DF   C3 9F   s-caron   U+0161    C5 A1

      '
    - 'c-acute   U+0107   C4 87   g-clef    U+1011E   F0 9D 84 9E

      '
    - 'Test vector:

      '
    - "salt:        \"ATHENA.MIT.EDUraeburn\"\n                           415448454e412e4d49542e4544557261656275726e\n"
    - 'password:    "password"    70617373776f7264

      '
    - 'fan-fold result:           c01e38688ac86c2e

      '
    - 'intermediate key:          c11f38688ac86d2f

      '
    - 'DES key:                   cbc22fae235298e3

      '
    - "salt:       \"WHITEHOUSE.GOVdanny\"\n                        5748495445484f5553452e474f5664616e6e79\n"
    - 'password:   "potatoe"   706f7461746f65

      '
    - 'fan-fold result:        a028944ee63c0416

      '
    - 'intermediate key:       a129944fe63d0416

      '
    - 'DES key:                df3d32a74fd92a01

      '
    - 'salt:      "EXAMPLE.COMpianist"  4558414D504C452E434F4D7069616E697374

      '
    - 'password:  g-clef (U+1011E)      f09d849e

      '
    - 'fan-fold result:                 3c4a262c18fab090

      '
    - 'intermediate key:                3d4a262c19fbb091

      '
    - 'DES key:                         4ffb26bab0cd9413

      '
    - "salt: \"ATHENA.MIT.EDUJuri\" + s-caron(U+0161) + \"i\" + c-acute(U+0107)\n
      \                        415448454e412e4d49542e4544554a757269c5a169c487\n"
    - "password:       eszett(U+00DF)\n                                c39f\n"
    - 'fan-fold result:b8f6c40e305afc9e

      '
    - 'intermediate key:               b9f7c40e315bfd9e

      '
    - 'DES key:                        62c81a5232b5e69d

      '
    - 'salt:       "AAAAAAAA"   4141414141414141

      '
    - 'password:   "11119999"   3131313139393939

      '
    - 'fan-fold result:         e0e0e0e0f0f0f0f0

      '
    - 'intermediate key:        e0e0e0e0f1f1f101

      '
    - 'DES key:                 984054d0f1a73e31

      '
    - 'salt:       "FFFFAAAA"   4646464641414141

      '
    - 'password:   "NNNN6666"   4e4e4e4e36363636

      '
    - 'fan-fold result:         1e1e1e1e0e0e0e0e

      '
    - 'intermediate key:        1f1f1f1f0e0e0efe

      '
    - "DES key:                 c4bf6b25adf7a4f8\n   This trace provided by Simon
      Josefsson shows the intermediate\n   processing stages of one of the test inputs:\n
      \     string_to_key (des-cbc-md5, string, salt)\n             ;; string:\n             ;;
      `password' (length 8 bytes)\n             ;; 70 61 73 73 77 6f 72 64\n             ;;
      salt:\n             ;; `ATHENA.MIT.EDUraeburn' (length 21 bytes)\n             ;;
      41 54 48 45 4e 41 2e 4d  49 54 2e 45 44 55 72 61\n             ;; 65 62 75 72
      6e\n      des_string_to_key (string, salt)\n             ;; String:\n             ;;
      `password' (length 8 bytes)\n             ;; 70 61 73 73 77 6f 72 64\n             ;;
      Salt:\n             ;; `ATHENA.MIT.EDUraeburn' (length 21 bytes)\n             ;;
      41 54 48 45 4e 41 2e 4d  49 54 2e 45 44 55 72 61\n             ;; 65 62 75 72
      6e\n      odd = 1;\n      s = string | salt;\n      tempstring = 0; /* 56-bit
      string */\n      pad(s); /* with nulls to 8 byte boundary */\n             ;;
      s = pad(string|salt):\n             ;; `passwordATHENA.MIT.EDUraeburn\\x00\\x00\\x00'\n
      \            ;; (length 32 bytes)\n             ;; 70 61 73 73 77 6f 72 64  41
      54 48 45 4e 41 2e 4d\n             ;; 49 54 2e 45 44 55 72 61  65 62 75 72 6e
      00 00 00\n      for (8byteblock in s) {\n             ;; loop iteration 0\n
      \            ;; 8byteblock:\n             ;; `password' (length 8 bytes)\n             ;;
      70 61 73 73 77 6f 72 64\n             ;; 01110000 01100001 01110011  01110011
      01110111 01101111\n             ;; 01110010 01100100\n      56bitstring = removeMSBits(8byteblock);\n
      \            ;; 56bitstring:\n             ;; 1110000 1100001 1110011  1110011
      1110111 1101111\n             ;; 1110010 1100100\n      if (odd == 0) reverse(56bitstring);
      \   ;; odd=1\n      odd = ! odd\n      tempstring = tempstring XOR 56bitstring;\n
      \            ;; tempstring\n             ;; 1110000 1100001 1110011  1110011
      1110111 1101111\n             ;; 1110010 1100100\n      for (8byteblock in s)
      {\n             ;; loop iteration 1\n             ;; 8byteblock:\n             ;;
      `ATHENA.M' (length 8 bytes)\n             ;; 41 54 48 45 4e 41 2e 4d\n             ;;
      01000001 01010100 01001000  01000101 01001110 01000001\n             ;; 00101110
      01001101\n      56bitstring = removeMSBits(8byteblock);\n             ;; 56bitstring:\n
      \            ;; 1000001 1010100 1001000  1000101 1001110 1000001\n             ;;
      0101110 1001101\n      if (odd == 0) reverse(56bitstring);    ;; odd=0\n      reverse(56bitstring)\n
      \            ;; 56bitstring after reverse\n             ;; 1011001 0111010 1000001
      \ 0111001 1010001 0001001\n             ;; 0010101 1000001\n      odd = ! odd\n
      \     tempstring = tempstring XOR 56bitstring;\n             ;; tempstring\n
      \            ;; 0101001 1011011 0110010  1001010 0100110 1100110\n             ;;
      1100111 0100101\n      for (8byteblock in s) {\n             ;; loop iteration
      2\n             ;; 8byteblock:\n             ;; `IT.EDUra' (length 8 bytes)\n
      \            ;; 49 54 2e 45 44 55 72 61\n             ;; 01001001 01010100 00101110
      \ 01000101 01000100 01010101\n             ;; 01110010 01100001\n      56bitstring
      = removeMSBits(8byteblock);\n             ;; 56bitstring:\n             ;; 1001001
      1010100 0101110  1000101 1000100 1010101\n             ;; 1110010 1100001\n
      \     if (odd == 0) reverse(56bitstring);    ;; odd=1\n      odd = ! odd\n      tempstring
      = tempstring XOR 56bitstring;\n             ;; tempstring\n             ;; 1100000
      0001111 0011100  0001111 1100010 0110011\n             ;; 0010101 1000100\n
      \     for (8byteblock in s) {\n             ;; loop iteration 3\n             ;;
      8byteblock:\n             ;; `eburn\\x00\\x00\\x00' (length 8 bytes)\n             ;;
      65 62 75 72 6e 00 00 00\n             ;; 01100101 01100010 01110101  01110010
      01101110 00000000\n             ;; 00000000 00000000\n      56bitstring = removeMSBits(8byteblock);\n
      \            ;; 56bitstring:\n             ;; 1100101 1100010 1110101  1110010
      1101110 0000000\n             ;; 0000000 0000000\n      if (odd == 0) reverse(56bitstring);
      \   ;; odd=0\n      reverse(56bitstring)\n             ;; 56bitstring after
      reverse\n             ;; 0000000 0000000 0000000  0111011 0100111 1010111\n
      \            ;; 0100011 1010011\n      odd = ! odd\n      tempstring = tempstring
      XOR 56bitstring;\n             ;; tempstring\n             ;; 1100000 0001111
      0011100  0110100 1000101 1100100\n             ;; 0110110 0010111\n      for
      (8byteblock in s) {\n      }\n             ;; for loop terminated\n      tempkey
      = key_correction(add_parity_bits(tempstring));\n             ;; tempkey\n             ;;
      `\\xc1\\x1f8h\\x8a\\xc8m\\x2f' (length 8 bytes)\n             ;; c1 1f 38 68
      8a c8 6d 2f\n             ;; 11000001 00011111 00111000  01101000 10001010 11001000\n
      \            ;; 01101101 00101111\n      key = key_correction(DES-CBC-check(s,tempkey));\n
      \            ;; key\n             ;; `\\xcb\\xc2\\x2f\\xae\\x23R\\x98\\xe3'
      (length 8 bytes)\n             ;; cb c2 2f ae 23 52 98 e3\n             ;; 11001011
      11000010 00101111  10101110 00100011 01010010\n             ;; 10011000 11100011\n
      \            ;; string_to_key key:\n             ;; `\\xcb\\xc2\\x2f\\xae\\x23R\\x98\\xe3'
      (length 8 bytes)\n             ;; cb c2 2f ae 23 52 98 e3\n"
    title: A.2.  mit_des_string_to_key
  - contents:
    - "A.3.  DES3 DR and DK\n   These tests show the derived-random and derived-key
      values for the\n   des3-hmac-sha1-kd encryption scheme, using the DR and DK
      functions\n   defined in section 6.3.1.  The input keys were randomly generated;\n
      \  the usage values are from this specification.\n   key:                 dce06b1f64c857a11c3db57c51899b2cc1791008ce973b92\n
      \  usage:               0000000155\n   DR:                  935079d14490a75c3093c4a6e8c3b049c71e6ee705\n
      \  DK:                  925179d04591a79b5d3192c4a7e9c289b049c71f6ee604cd\n   key:
      \                5e13d31c70ef765746578531cb51c15bf11ca82c97cee9f2\n   usage:
      \              00000001aa\n   DR:                  9f58e5a047d894101c469845d67ae3c5249ed812f2\n
      \  DK:                  9e58e5a146d9942a101c469845d67a20e3c4259ed913f207\n   key:
      \                98e6fd8a04a4b6859b75a176540b9752bad3ecd610a252bc\n   usage:
      \              0000000155\n   DR:                  12fff90c773f956d13fc2ca0d0840349dbd39908eb\n
      \  DK:                  13fef80d763e94ec6d13fd2ca1d085070249dad39808eabf\n   key:
      \                622aec25a2fe2cad7094680b7c64940280084c1a7cec92b5\n   usage:
      \              00000001aa\n   DR:                  f8debf05b097e7dc0603686aca35d91fd9a5516a70\n
      \  DK:                  f8dfbf04b097e6d9dc0702686bcb3489d91fd9a4516b703e\n   key:
      \                d3f8298ccb166438dcb9b93ee5a7629286a491f838f802fb\n   usage:
      \              6b65726265726f73 (\"kerberos\")\n   DR:                  2270db565d2a3d64cfbfdc5305d4f778a6de42d9da\n
      \  DK:                  2370da575d2a3da864cebfdc5204d56df779a7df43d9da43\n   key:
      \                c1081649ada74362e6a1459d01dfd30d67c2234c940704da\n   usage:
      \              0000000155\n   DR:                  348056ec98fcc517171d2b4d7a9493af482d999175\n
      \  DK:                  348057ec98fdc48016161c2a4c7a943e92ae492c989175f7\n   key:
      \                5d154af238f46713155719d55e2f1f790dd661f279a7917c\n   usage:
      \              00000001aa\n   DR:                  a8818bc367dadacbe9a6c84627fb60c294b01215e5\n
      \  DK:                  a8808ac267dada3dcbe9a7c84626fbc761c294b01315e5c1\n   key:
      \                798562e049852f57dc8c343ba17f2ca1d97394efc8adc443\n   usage:
      \              0000000155\n   DR:                  c813f88b3be2b2f75424ce9175fbc8483b88c8713a\n
      \  DK:                  c813f88a3be3b334f75425ce9175fbe3c8493b89c8703b49\n   key:
      \                26dce334b545292f2feab9a8701a89a4b99eb9942cecd016\n   usage:
      \              00000001aa\n   DR:                  f58efc6f83f93e55e695fd252cf8fe59f7d5ba37ec\n
      \  DK:                  f48ffd6e83f83e7354e694fd252cf83bfe58f7d5ba37ec5d\n"
    title: A.3.  DES3 DR and DK
  - contents:
    - "A.4.  DES3string_to_key\n   These are the keys generated for some of the above
      input strings for\n   triple-DES with key derivation as defined in section 6.3.1.\n
      \  salt:   \"ATHENA.MIT.EDUraeburn\"\n   passwd: \"password\"\n   key:    850bb51358548cd05e86768c313e3bfef7511937dcf72c3e\n
      \  salt:   \"WHITEHOUSE.GOVdanny\"\n   passwd: \"potatoe\"\n   key:    dfcd233dd0a43204ea6dc437fb15e061b02979c1f74f377a\n
      \  salt:   \"EXAMPLE.COMbuckaroo\"\n   passwd: \"penny\"\n   key:    6d2fcdf2d6fbbc3ddcadb5da5710a23489b0d3b69d5d9d4a\n
      \  salt:   \"ATHENA.MIT.EDUJuri\" + s-caron(U+0161) + \"i\"\n            + c-acute(U+0107)\n
      \  passwd: eszett(U+00DF)\n   key:    16d5a40e1ce3bacb61b9dce00470324c831973a7b952feb0\n
      \  salt:   \"EXAMPLE.COMpianist\"\n   passwd: g-clef(U+1011E)\n   key:    85763726585dbc1cce6ec43e1f751f07f1c4cbb098f40b19\n"
    title: A.4.  DES3string_to_key
  - contents:
    - "A.5.  Modified CRC-32\n   Below are modified-CRC32 values for various ASCII
      and octet strings.\n   Only the printable ASCII characters are checksummed,
      without a C-\n   style trailing zero-valued octet.  The 32-bit modified CRC
      and the\n   sequence of output bytes as used in Kerberos are shown.  (The octet\n
      \  values are separated here to emphasize that they are octet values and\n   not
      32-bit numbers, which will be the most convenient form for\n   manipulation
      in some implementations.  The bit and byte order used\n   internally for such
      a number is irrelevant; the octet sequence\n   generated is what is important.)\n
      \  mod-crc-32(\"foo\") =                                     33 bc 32 73\n   mod-crc-32(\"test0123456789\")
      =                          d6 88 3e b8\n   mod-crc-32(\"MASSACHVSETTS INSTITVTE
      OF TECHNOLOGY\") =   f7 80 41 e3\n   mod-crc-32(8000) =                                      4b
      98 83 3b\n   mod-crc-32(0008) =                                      32 88 db
      0e\n   mod-crc-32(0080) =                                      20 83 b8 ed\n
      \  mod-crc-32(80) =                                        20 83 b8 ed\n   mod-crc-32(80000000)
      =                                  3b b6 59 ed\n   mod-crc-32(00000001) =                                  96
      30 07 77\n"
    title: A.5.  Modified CRC-32
  title: 12.  Acknowledgements
- contents:
  - "B.  Significant Changes from RFC 1510\n   The encryption and checksum mechanism
    profiles are new.  The old\n   specification defined a few operations for various
    mechanisms but\n   didn't outline what abstract properties should be required
    of new\n   mechanisms, or how to ensure that a mechanism specification is\n   complete
    enough for interoperability between implementations.  The\n   new profiles differ
    from the old specification in a few ways:\n      Some message definitions in [Kerb1510]
    could be read as permitting\n      the initial vector to be specified by the application;
    the text\n      was too vague.  It is explicitly not permitted in this\n      specification.
    \ Some encryption algorithms may not use\n      initialization vectors, so relying
    on chosen, secret\n      initialization vectors for security is unwise.  Also,
    the\n      prepended confounder in the existing algorithms is roughly\n      equivalent
    to a per-message initialization vector that is revealed\n      in encrypted form.
    \ However, carrying state across from one\n      encryption to another is explicitly
    permitted through the opaque\n      \"cipher state\" object.\n      The use of
    key derivation is new.\n      Several new methods are introduced, including generation
    of a key\n      in wire-protocol format from random input data.\n      The means
    for influencing the string-to-key algorithm are laid out\n      more clearly.\n
    \  Triple-DES support is new.\n   The pseudo-random function is new.\n   The des-cbc-crc,
    DES string-to-key and CRC descriptions have been\n   updated to align them with
    existing implementations.\n   [Kerb1510] did not indicate what character set or
    encoding might be\n   used for pass phrases and salts.\n   In [Kerb1510], key
    types, encryption algorithms, and checksum\n   algorithms were only loosely associated,
    and the association was not\n   well described.  In this specification, key types
    and encryption\n   algorithms have a one-to-one correspondence, and associations
    between\n   encryption and checksum algorithms are described so that checksums\n
    \  can be computed given negotiated keys, without requiring further\n   negotiation
    for checksum types.\n"
  title: B.  Significant Changes from RFC 1510
- contents:
  - "Notes\n   [1] Although Message Authentication Code (MAC) or Message Integrity\n
    \      Check (MIC) would be more appropriate terms for many of the uses\n       in
    this document, we continue to use the term checksum for\n       historical reasons.\n
    \  [2] Extending CBC mode across messages would be one obvious example\n       of
    this chaining.  Another might be the use of counter mode, with\n       a counter
    randomly initialized and attached to the ciphertext; a\n       second message
    could continue incrementing the counter when\n       chaining the cipher state,
    thus avoiding having to transmit\n       another counter value.  However, this
    chaining is only useful for\n       uninterrupted, ordered sequences of messages.\n
    \  [3] In the case of Kerberos, the encrypted objects will generally be\n       ASN.1
    DER encodings, which contain indications of their length in\n       the first
    few octets.\n   [4] As of the time of this writing, new modes of operation have
    been\n       proposed, some of which may permit encryption and integrity\n       protection
    simultaneously.  After some of these proposals have\n       been subjected to
    adequate analysis, we may wish to formulate a\n       new simplified profile based
    on one of them.\n   [5] It should be noted that the sample vector in appendix
    B.2 of the\n       original paper appears to be incorrect.  Two independent\n
    \      implementations from the specification (one in C by Marc\n       Horowitz,
    and another in Scheme by Bill Sommerfeld) agree on a\n       value different from
    that in [Blumenthal96].\n   [6] For example, in MIT's implementation of [Kerb1510],
    the rsa-md5\n       unkeyed checksum of application data may be included in an\n
    \      authenticator encrypted in a service's key.\n   [7] Using a variant of
    the key limits the use of a key to a\n       particular function, separating the
    functions of generating a\n       checksum from other encryption performed using
    the session key.\n       The constant 0xF0F0F0F0F0F0F0F0 was chosen because it
    maintains\n       key parity.  The properties of DES precluded the use of the\n
    \      complement.  The same constant is used for similar purpose in the\n       Message
    Integrity Check in the Privacy Enhanced Mail standard.\n   [8] Perhaps one of
    the more common reasons for directly performing\n       encryption is direct control
    over the negotiation and to select a\n       \"sufficiently strong\" encryption
    algorithm (whatever that means\n       in the context of a given application).
    \ Although Kerberos\n       directly provides no direct facility for negotiating
    encryption\n       types between the application client and server, there are
    other\n       means to accomplish similar goals (for example, requesting only\n
    \      \"strong\" session key types from the KDC, and assuming that the\n       type
    actually returned by the KDC will be understood and\n       supported by the application
    server).\n"
  title: Notes
- contents:
  - "Normative References\n   [BCP26]        Narten, T. and H. Alvestrand, \"Guidelines
    for Writing\n                  an IANA Considerations Section in RFCs\", BCP 26,
    RFC\n                  2434, October 1998.\n   [Bellare98]    Bellare, M., Desai,
    A., Pointcheval, D., and P.\n                  Rogaway, \"Relations Among Notions
    of Security for\n                  Public-Key Encryption Schemes\".  Extended
    abstract\n                  published in Advances in Cryptology-Crypto 98\n                  Proceedings,
    Lecture Notes in Computer Science Vol.\n                  1462, H. Krawcyzk ed.,
    Springer-Verlag, 1998.\n   [Blumenthal96] Blumenthal, U. and S. Bellovin, \"A
    Better Key Schedule\n                  for DES-Like Ciphers\", Proceedings of
    PRAGOCRYPT '96,\n                  1996.\n   [CRC]          International Organization
    for Standardization, \"ISO\n                  Information Processing Systems -
    Data Communication -\n                  High-Level Data Link Control Procedure
    - Frame\n                  Structure,\" IS 3309, 3rd Edition, October 1984.\n
    \  [DES77]        National Bureau of Standards, U.S. Department of\n                  Commerce,
    \"Data Encryption Standard,\" Federal\n                  Information Processing
    Standards Publication 46,\n                  Washington, DC, 1977.\n   [DESI81]
    \      National Bureau of Standards, U.S. Department of\n                  Commerce,
    \"Guidelines for implementing and using NBS\n                  Data Encryption
    Standard,\" Federal Information\n                  Processing Standards Publication
    74, Washington, DC,\n                  1981.\n   [DESM80]       National Bureau
    of Standards, U.S. Department of\n                  Commerce, \"DES Modes of Operation,\"
    Federal\n                  Information Processing Standards Publication 81,\n
    \                 Springfield, VA, December 1980.\n   [Dolev91]      Dolev, D.,
    Dwork, C., and M. Naor, \"Non-malleable\n                  cryptography\", Proceedings
    of the 23rd Annual\n                  Symposium on Theory of Computing, ACM, 1991.\n
    \  [HMAC]         Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC:\n                  Keyed-Hashing
    for Message Authentication\", RFC 2104,\n                  February 1997.\n   [KRB5-AES]
    \    Raeburn, K., \"Advanced Encryption Standard (AES)\n                  Encryption
    for Kerberos 5\", RFC 3962, February 2005.\n   [MD4-92]       Rivest, R., \"The
    MD4 Message-Digest Algorithm\", RFC\n                  1320, April 1992.\n   [MD5-92]
    \      Rivest, R., \"The MD5 Message-Digest Algorithm \", RFC\n                  1321,
    April 1992.\n   [SG92]         Stubblebine, S. and V. D. Gligor, \"On Message\n
    \                 Integrity in Cryptographic Protocols,\" in Proceedings\n                  of
    the IEEE Symposium on Research in Security and\n                  Privacy, Oakland,
    California, May 1992.\n"
  title: Normative References
- contents:
  - "Informative References\n   [Bellovin91]   Bellovin, S. M. and M. Merrit, \"Limitations
    of the\n                  Kerberos Authentication System\", in Proceedings of
    the\n                  Winter 1991 Usenix Security Conference, January, 1991.\n
    \  [Bellovin99]   Bellovin, S. M. and D. Atkins, private communications,\n                  1999.\n
    \  [EFF-DES]      Electronic Frontier Foundation, \"Cracking DES: Secrets\n                  of
    Encryption Research, Wiretap Politics, and Chip\n                  Design\", O'Reilly
    & Associates, Inc., May 1998.\n   [ESP-DES]      Madson, C. and N. Doraswamy,
    \"The ESP DES-CBC Cipher\n                  Algorithm With Explicit IV\", RFC
    2405, November 1998.\n   [GSS-KRB5]     Linn, J., \"The Kerberos Version 5 GSS-API
    Mechanism\",\n                  RFC 1964, June 1996.\n   [HMAC-TEST]    Cheng,
    P. and R. Glenn, \"Test Cases for HMAC-MD5 and\n                  HMAC-SHA-1\",
    RFC 2202, September 1997.\n   [IPSEC-HMAC]   Madson, C. and R. Glenn, \"The Use
    of HMAC-SHA-1-96\n                  within ESP and AH\", RFC 2404, November 1998.\n
    \  [Kerb]         Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The\n                  Kerberos
    Network Authentication Service (V5)\", Work in\n                  Progress, September
    2004.\n   [Kerb1510]     Kohl, J. and C. Neuman, \"The Kerberos Network\n                  Authentication
    Service (V5)\", RFC 1510, September\n                  1993.\n   [RC5]          Baldwin,
    R. and R. Rivest, \"The RC5, RC5-CBC, RC5-\n                  CBC-Pad, and RC5-CTS
    Algorithms\", RFC 2040, October\n                  1996.\n   [RFC1851]      Karn,
    P., Metzger, P., and W. Simpson, \"The ESP Triple\n                  DES Transform\",
    RFC 1851, September 1995.\n   [Schneier96]   Schneier, B., \"Applied Cryptography
    Second Edition\",\n                  John Wiley & Sons, New York, NY, 1996.  ISBN
    0-471-\n                  12845-7.\n"
  title: Informative References
- contents:
  - "Editor's Address\n   Kenneth Raeburn\n   Massachusetts Institute of Technology\n
    \  77 Massachusetts Avenue\n   Cambridge, MA 02139\n   EMail: raeburn@mit.edu\n"
  title: Editor's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the IETF's procedures with respect
    to rights in IETF Documents can\n   be found in BCP 78 and BCP 79.\n   Copies
    of IPR disclosures made to the IETF Secretariat and any\n   assurances of licenses
    to be made available, or the result of an\n   attempt made to obtain a general
    license or permission for the use of\n   such proprietary rights by implementers
    or users of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
