- contents:
  - "            Resource Reservation Protocol (RSVP) Extensions\n                 for
    Path-Triggered RSVP Receiver Proxy\n"
  title: __initial_text__
- contents:
  - "Abstract\n   Resource Reservation Protocol (RSVP) signaling can be used to make\n
    \  end-to-end resource reservations in an IP network in order to\n   guarantee
    the Quality of Service (QoS) required by certain flows.\n   With conventional
    RSVP, both the data sender and receiver of a given\n   flow take part in RSVP
    signaling.  Yet, there are many use cases\n   where resource reservation is required,
    but the receiver, the sender,\n   or both, is not RSVP-capable.  Where the receiver
    is not RSVP-\n   capable, an RSVP router may behave as an RSVP Receiver Proxy,
    thereby\n   performing RSVP signaling on behalf of the receiver.  This allows\n
    \  resource reservations to be established on the segment of the end-to-\n   end
    path from the sender to the RSVP Receiver Proxy.  However, as\n   discussed in
    the companion document \"RSVP Proxy Approaches\", RSVP\n   extensions are needed
    to facilitate operations with an RSVP Receiver\n   Proxy whose signaling is triggered
    by receipt of RSVP Path messages\n   from the sender.  This document specifies
    these extensions.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5946.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Conventions Used in This Document ..........................7\n   2.
    Terminology .....................................................7\n   3. RSVP
    Extensions for Sender Notification .........................8\n      3.1. Sender
    Notification via PathErr Message ...................11\n           3.1.1. Composition
    of SESSION and Sender Descriptor .......14\n           3.1.2. Composition of ERROR_SPEC
    ..........................14\n           3.1.3. Use of Path_State_Removed Flag
    .....................15\n           3.1.4. Use of PathErr by Regular Receivers
    ................16\n      3.2. Sender Notification via Notify Message ....................17\n
    \  4. Mechanisms for Maximizing the Reservation Span .................23\n      4.1.
    Dynamic Discovery of Downstream RSVP Functionality ........24\n      4.2. Receiver
    Proxy Control Policy Element .....................26\n           4.2.1. Default
    Handling ...................................29\n   5. Security Considerations
    ........................................29\n      5.1. Security Considerations
    for the Sender\n           Notification via Notify Message ...........................30\n
    \     5.2. Security Considerations for the Receiver Proxy\n           Control
    Policy Element ....................................31\n   6. IANA Considerations
    ............................................32\n      6.1. RSVP Error Codes ..........................................32\n
    \     6.2. Policy Element ............................................32\n   7.
    Acknowledgments ................................................33\n   8. References
    .....................................................33\n      8.1. Normative
    References ......................................33\n      8.2. Informative References
    ....................................34\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Guaranteed Quality of Service (QoS) for some applications
    with tight\n   QoS requirements may be achieved by reserving resources in each
    node\n   on the end-to-end path.  The main IETF protocol for these resource\n
    \  reservations is the Resource Reservation Protocol (RSVP), as\n   specified
    in [RFC2205].  RSVP does not require that all intermediate\n   nodes support RSVP,
    but it assumes that both the sender and the\n   receiver of the data flow support
    RSVP.  However, there are\n   environments where it would be useful to be able
    to reserve resources\n   for a flow (at least a subset of the flow path) even
    when the sender\n   or the receiver (or both) is not RSVP-capable.\n   Since both
    the data sender and receiver may be unaware of RSVP, there\n   are two types of
    RSVP Proxies.  In the first case, an entity in the\n   network needs to invoke
    RSVP on behalf of the data sender and thus\n   generate RSVP Path messages, and
    eventually receive, process, and\n   sink Resv messages.  We refer to this entity
    as the RSVP Sender\n   Proxy.  In the second case, an entity in the network needs
    to operate\n   RSVP on behalf of the receiver and thus receive Path messages sent
    by\n   a data sender (or by an RSVP Sender Proxy), and reply to those with\n   Resv
    messages generated on behalf of the data receiver(s).  We refer\n   to this entity
    as the RSVP Receiver Proxy.\n   RSVP Proxy approaches are presented in [RFC5945].
    \ That document also\n   discusses, for each approach, how the reservations controlled
    by the\n   RSVP Proxy can be synchronized with the application requirements\n
    \  (e.g., when to establish, maintain, and tear down the RSVP\n   reservation
    to satisfy application requirements).\n   One RSVP Proxy approach is referred
    to as the Path-Triggered RSVP\n   Receiver Proxy approach.  With this approach,
    the RSVP Receiver Proxy\n   uses the RSVP Path messages generated by the sender
    (or RSVP Sender\n   Proxy) as the cue for establishing the RSVP reservation on
    behalf of\n   the non-RSVP-capable receiver(s).  The RSVP Receiver Proxy is\n
    \  effectively acting as an intermediary making reservations (on behalf\n   of
    the receiver) under the sender's control (or RSVP Sender Proxy's\n   control).
    \ This somewhat changes the usual RSVP reservation model\n   where reservations
    are normally controlled by receivers.  Such a\n   change greatly facilitates operations
    in the scenario of interest\n   here, which is where the receiver is not RSVP-capable.
    \ Indeed it\n   allows the RSVP Receiver Proxy to remain application-unaware by\n
    \  taking advantage of the application awareness and RSVP awareness of\n   the
    sender (or RSVP Sender Proxy).\n   Since the synchronization between an RSVP reservation
    and an\n   application is now effectively performed by the sender (or RSVP\n   Sender
    Proxy), it is important that the sender (or RSVP Sender Proxy)\n   is aware of
    the reservation state.  However, as conventional RSVP\n   assumes that the reservation
    is to be controlled by the receiver,\n   some notifications about reservation
    state (notably the error message\n   sent in the case of admission control rejection
    of the reservation)\n   are only sent towards the receiver and therefore, in our
    case, sunk\n   by the RSVP Receiver Proxy.  Section 3 of this document specifies\n
    \  extensions to RSVP procedures allowing such notifications to be also\n   conveyed
    towards the sender.  This facilitates synchronization by the\n   sender (or RSVP
    Sender Proxy) between the RSVP reservation and the\n   application requirements,
    and it facilitates sender-driven control of\n   reservation in scenarios involving
    a Path-Triggered RSVP Receiver\n   Proxy.\n   With unicast applications in the
    presence of RSVP Receiver Proxies,\n   if the sender is notified about the state
    of the reservation towards\n   the receiver (as enabled by this document), the
    sender is generally\n   in a good position to synchronize the reservation with
    the\n   application and to perform efficient sender-driven reservation: the\n
    \  sender can control the establishment or removal of the reservation\n   towards
    the receiver by sending Path or PathTear messages,\n   respectively.  For example,
    if the sender is notified that the\n   reservation for a point-to-point audio
    session towards the receiver\n   is rejected, the sender may trigger rejection
    of the session at the\n   application layer and may issue a PathTear message to
    remove any\n   corresponding RSVP state (e.g., Path states) previously established.\n
    \  However, we note that multicast applications do not always coexist\n   well
    with RSVP Receiver Proxies, since sender notification about\n   reservation state
    towards each RSVP Receiver Proxy may not be\n   sufficient to achieve tight application-level
    synchronization by\n   multicast senders.  These limitations stem from the fact
    that\n   multicast operation is receiver driven and, while end-to-end RSVP is\n
    \  also receiver driven (precisely to deal with multicast efficiently),\n   the
    use of RSVP Receiver Proxies only allows sender-driven\n   reservation.  For example,
    a sender generally is not aware of which\n   receivers have joined downstream
    of a given RSVP Receiver Proxy, or\n   even which RSVP Receiver Proxies have joined
    downstream of a given\n   failure point.  Therefore, it may not be possible to
    support a mode\n   of operation whereby a given receiver only joins a group if
    that\n   receiver benefits from a reservation.  Additionally, a sender may\n   have
    no recourse if only a subset of RSVP Receiver Proxies return\n   successful reservations
    (even if application-level signaling runs\n   between the sender and receivers),
    since the sender may not be able\n   to correctly identify the set of receivers
    who do not have\n   reservations.  However, it is possible to support a mode of
    operation\n   whereby multicast traffic is transmitted if and only if all receivers\n
    \  benefit from a reservation (from sender to their respective RSVP\n   Receiver
    Proxy): the sender can ensure this by sending a PathTear\n   message and stopping
    transmission whenever it gets a notification for\n   reservation reject for one
    or more RSVP Receiver Proxies.  It is also\n   possible to support a mode of operation
    whereby receivers join\n   independently of whether or not they can benefit from
    a reservation\n   (to their respective RSVP Receiver Proxy), but do benefit from
    a\n   reservation whenever the corresponding resources are reservable on\n   the
    relevant path.\n   This document discusses extensions to facilitate operations
    in the\n   presence of a Path-Triggered RSVP Receiver Proxy.  As pointed out\n
    \  previously, those apply equally whether RSVP signaling is initiated\n   by
    a regular RSVP sender or by an RSVP Sender Proxy (with some means\n   to synchronize
    reservation state with application-level requirements\n   that are outside the
    scope of this document).  For readability, the\n   rest of this document discusses
    operations assuming a regular RSVP\n   sender; however, such an operation is equally
    applicable where an\n   RSVP Sender Proxy is used to initiated RSVP signaling
    on behalf of a\n   non-RSVP-capable sender.\n   As discussed in [RFC5945], it
    is important to keep in mind that the\n   strongly recommended RSVP deployment
    model remains end to end as\n   assumed in [RFC2205] with RSVP support on the
    sender and the\n   receiver.  The end-to-end model allows the most effective\n
    \  synchronization between the reservation and application requirements.\n   Also,
    when compared to the end-to-end RSVP model, the use of RSVP\n   Proxies involves
    additional operational burden and/or imposes some\n   topological constraints.
    \ Thus, the purpose of this document is only\n   to allow RSVP deployment in special
    environments where RSVP just\n   cannot be used on some senders and/or some receivers
    for reasons\n   specific to the environment.\n   Section 4.1.1 of [RFC5945] discusses
    mechanisms allowing the RSVP\n   reservation for a given flow to be dynamically
    extended downstream of\n   an RSVP Proxy whenever possible (i.e., when the receiver
    is RSVP-\n   capable or when there is another RSVP Receiver Proxy downstream).\n
    \  This can considerably alleviate the operational burden and the\n   topological
    constraints associated with Path-Triggered RSVP Receiver\n   Proxies.  This allows
    (without corresponding manual configuration) an\n   RSVP reservation to dynamically
    span as much of the corresponding\n   flow path as possible, with any arbitrary
    number of RSVP Receiver\n   Proxies on the flow path and whether or not the receiver
    is RSVP-\n   capable.  In turn, this facilitates migration from an RSVP deployment\n
    \  model based on Path-Triggered Receiver Proxies to an end-to-end RSVP\n   model,
    since receivers can gradually and independently be upgraded to\n   support RSVP
    and then instantaneously benefit from end-to-end\n   reservations.  Section 4
    of this document specifies these mechanisms\n   and associated RSVP extensions.\n"
  - contents:
    - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
      as described in [RFC2119].\n"
    title: 1.1.  Conventions Used in This Document
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The following terminology is borrowed from [RFC5945] and
    is used\n   extensively in this document:\n   o  RSVP-capable (or RSVP-aware):
    supporting the RSVP protocol as per\n      [RFC2205].\n   o  RSVP Receiver Proxy:
    an RSVP-capable router performing, on behalf\n      of a receiver, the RSVP operations
    that would normally be\n      performed by an RSVP-capable receiver if end-to-end
    RSVP signaling\n      were used.  Note that while RSVP is used upstream of the
    RSVP\n      Receiver Proxy, RSVP is not used downstream of the RSVP Receiver\n
    \     Proxy.\n   o  RSVP Sender Proxy: an RSVP-capable router performing, on behalf
    of\n      a sender, the RSVP operations that normally would be performed by\n
    \     an RSVP-capable sender if end-to-end RSVP signaling were used.\n      Note
    that while RSVP is used downstream of the RSVP Sender Proxy,\n      RSVP is not
    used upstream of the RSVP Sender Proxy.\n   o  Regular RSVP Router: an RSVP-capable
    router that is not behaving\n      as an RSVP Receiver Proxy nor as an RSVP Sender
    Proxy.\n   Note that the roles of the RSVP Receiver Proxy, RSVP Sender Proxy,\n
    \  and regular RSVP Router are all relative to one unidirectional flow.\n   A
    given router may act as the RSVP Receiver Proxy for a flow, as the\n   RSVP Sender
    Proxy for another flow, and as a regular RSVP router for\n   yet another flow.\n
    \  The following terminology is also used in this document:\n   o  Regular RSVP
    sender: an RSVP-capable host behaving as the sender\n      for the considered
    flow and participating in RSVP signaling in\n      accordance with the sender
    behavior specified in [RFC2205].\n   o  Regular RSVP receiver: an RSVP-capable
    host behaving as the\n      receiver for the considered flow and participating
    in RSVP\n      signaling in accordance with the receiver behavior specified in\n
    \     [RFC2205].\n"
  title: 2.  Terminology
- contents:
  - "3.  RSVP Extensions for Sender Notification\n   This section defines extensions
    to RSVP procedures allowing sender\n   notification of reservation failure.  This
    facilitates\n   synchronization by the sender between RSVP reservation and\n   application
    requirements in scenarios involving a Path-Triggered RSVP\n   Receiver Proxy.\n
    \  As discussed in [RFC5945], with the Path-Triggered RSVP Receiver\n   Proxy
    approach, the RSVP router may be configured to use receipt of a\n   regular RSVP
    Path message as the trigger for RSVP Receiver Proxy\n   behavior.  On receipt
    of the RSVP Path message, the RSVP Receiver\n   Proxy:\n   1.  establishes the
    RSVP Path state as per regular RSVP processing.\n   2.  identifies the downstream
    interface towards the receiver.\n   3.  sinks the Path message.\n   4.  behaves
    as if a corresponding Resv message (on its way upstream\n       from the receiver)
    was received on the downstream interface.\n       This includes performing admission
    control on the downstream\n       interface, establishing a Resv state (in the
    case of successful\n       admission control), and forwarding the Resv message
    upstream,\n       sending periodic refreshes of the Resv message and tearing down\n
    \      the reservation if the Path state is torn down.\n   Operation of the Path-Triggered
    Receiver Proxy in the case of a\n   successful reservation is illustrated in Figure
    1.\n |****|        ***        ***        ***        |**********|      |----|\n
    | S  |--------*r*--------*r*--------*r*--------| RSVP     |------| R  |\n |****|
    \       ***        ***        ***        | Receiver |      |----|\n                                                |
    Proxy    |\n                                                |**********|\n      --Path--->
    --Path---> --Path---> --Path--->\n      <---Resv-- <---Resv-- <---Resv-- <---Resv--\n
    \     ===================RSVP===================>\n      ************************************************************>\n
    |****| RSVP-capable     |----| Non-RSVP-capable        ***\n | S  | Sender           |
    R  | Receiver                *r* regular RSVP\n |****|                  |----|
    \                        *** router\n ***> media flow\n ==>  segment of flow path
    benefiting from an RSVP reservation\n                     Figure 1: Successful
    Reservation\n   We observe that, in the case of successful reservation, conventional\n
    \  RSVP procedures ensure that the sender is notified of the successful\n   reservation
    establishment.  Thus, no extensions are required in the\n   presence of a Path-Triggered
    RSVP Receiver Proxy in the case of\n   successful reservation establishment.\n
    \  However, in the case of reservation failure, conventional RSVP\n   procedures
    ensure only that the receiver (or the RSVP Receiver Proxy)\n   is notified of
    the reservation failure.  Specifically, in the case of\n   an admission control
    rejection on a regular RSVP router, a ResvErr\n   message is sent downstream towards
    the receiver.  In the presence of\n   an RSVP Receiver Proxy, if we simply follow
    conventional RSVP\n   procedures, this means that the RSVP Receiver Proxy is notified
    of\n   the reservation failure, but the sender is not.  Operation of the\n   Path-Triggered
    RSVP Receiver Proxy in the case of an admission\n   control failure, assuming
    conventional RSVP procedures, is\n   illustrated in Figure 2.\n |****|        ***
    \       ***        ***        |**********|      |----|\n | S  |--------*r*--------*r*--------*r*--------|
    RSVP     |------| R  |\n |****|        ***        ***        ***        | Receiver
    |      |----|\n                                                | Proxy    |\n
    \                                               |**********|\n      --Path--->
    --Path---> --Path---> --Path--->\n                            <---Resv-- <---Resv--\n
    \                           -ResvErr-> -ResvErr->\n      ===================RSVP===================>\n
    \     ************************************************************>\n |****| RSVP-capable
    \ |----| Non-RSVP-capable   ***\n | S  | Sender        | R  | Receiver           *r*
    regular RSVP\n |****|               |----|                    *** router\n ***>
    media flow\n ==>  segment of flow path benefiting from an RSVP reservation\n           Figure
    2: Reservation Failure with Conventional RSVP\n   While the sender could infer
    reservation failure from the fact that\n   it has not received a Resv message
    after a certain time, there are\n   clear benefits to ensuring that the sender
    gets a prompt, explicit\n   notification in the case of reservation failure.  This
    includes\n   faster end-user notification at the application layer (e.g., busy\n
    \  signal) and faster application-level reaction (e.g., application-\n   level
    rerouting), as well as faster release of application-level\n   resources.\n   Section
    3.1 defines a method that can be used to achieve sender\n   notification of reservation
    failure.  A router implementation\n   claiming compliance with this document MUST
    support the method\n   defined in Section 3.1.\n   Section 3.2 defines another
    method that can be used to achieve sender\n   notification of reservation failure.
    \ A router implementation\n   claiming compliance with this document MAY support
    the method defined\n   in Section 3.2.\n   In a given network environment, a network
    administrator may elect to\n   use the method defined in Section 3.1, the method
    defined in\n   Section 3.2, or possibly combine the two.\n"
  - contents:
    - "3.1.  Sender Notification via PathErr Message\n   With this method, the RSVP
      Receiver Proxy MUST generate a PathErr\n   message whenever the two following
      conditions are met:\n   1.  The reservation establishment has failed (or the
      previously\n       established reservation has been torn down).\n   2.  The
      RSVP Receiver Proxy determines that it cannot re-establish\n       the reservation
      (e.g., by adapting its reservation request in\n       reaction to the error
      code provided in the received ResvErr in\n       accordance with local policy).\n
      \  Note that this notion of generating a PathErr message upstream in\n   order
      to notify the sender about a reservation failure is not\n   completely new.
      \ It is borrowed from [RFC3209] where it was\n   introduced in order to satisfy
      a similar requirement, which is to\n   allow an MPLS Traffic Engineering (TE)
      Label Switching Router to\n   notify the TE Tunnel head-end (i.e., the sender)
      of a failure to\n   establish (or maintain) a TE Tunnel Label Switch Path.\n
      \  Operation of the Path-Triggered RSVP Receiver Proxy in the case of an\n   admission
      control failure, using sender notification via a PathErr\n   message, is illustrated
      in Figure 3.\n |****|        ***        ***        ***        |**********|      |----|\n
      | S  |--------*r*--------*r*--------*r*--------| RSVP     |------| R  |\n |****|
      \       ***        ***        ***        | Receiver |      |----|\n                                                |
      Proxy    |\n                                                |**********|\n      --Path--->
      --Path---> --Path---> --Path--->\n                            <---Resv-- <---Resv--\n
      \                           -ResvErr-> -ResvErr->\n      <-PathErr- <-PathErr-
      <-PathErr- <-PathErr-\n      ===================RSVP===================>\n      ************************************************************>\n
      |****| RSVP-capable  |----| Non-RSVP-capable   ***\n | S  | Sender        |
      R  | Receiver           *r* regular RSVP\n |****|               |----|                    ***
      router\n ***> media flow\n ==>  segment of flow path benefiting from RSVP\n
      \     (but not benefiting from a reservation in this case)\n    Figure 3: Reservation
      Failure with Sender Notification via PathErr\n   The role of this PathErr is
      to notify the sender that the reservation\n   was not established or was torn
      down.  This may be in the case of\n   receipt of a ResvErr, or because of local
      failure on the Receiver\n   Proxy.  On receipt of a ResvErr, in all situations
      where the\n   reservation cannot be installed, the Receiver Proxy MUST generate
      a\n   PathErr towards the sender.  For local failures on the Receiver Proxy\n
      \  node, if a similar failure on an RSVP midpoint would cause the\n   generation
      of a ResvErr (for example, admission control failure), the\n   Receiver Proxy
      MUST generate a PathErr towards the sender.  The\n   Receiver Proxy MAY additionally
      generate a PathErr upon local\n   failures that would not ordinarily cause generation
      of a ResvErr\n   message, such as those described in Appendix B of [RFC2205].\n
      \  The PathErr generated by the Receiver Proxy corresponds to the\n   sender(s)
      that triggered generation of Resv messages that failed.\n   For FF-style (Fixed-Filter)
      reservations, the Receiver Proxy MUST\n   send a PathErr towards the (single)
      sender matching the failed\n   reservation.  For SE-style (Shared-Explicit)
      reservations, the\n   Receiver Proxy MUST send the PathErr(s) towards the set
      of senders\n   that triggered reservations that failed.  This may be a subset
      of\n   senders sharing the same reservation, in which case the remaining\n   senders
      would have their reservation intact and would not receive a\n   PathErr.  In
      both cases, the rules described in Section 3.1.8 of\n   [RFC2205] for generating
      flow descriptors in ResvErr messages also\n   apply when generating sender descriptors
      in PathErr messages.\n   For WF-style (Wildcard-Filter) reservations, it is
      not always\n   possible for the Receiver Proxy to reliably know which sender
      caused\n   the reservation failure.  Therefore, the Receiver Proxy SHOULD send
      a\n   PathErr towards each sender.  This means that all the senders will\n   receive
      a notification that the reservation is not established,\n   including senders
      that did not cause the reservation failure.\n   Therefore, the method of sender
      notification via a PathErr message is\n   somewhat overly conservative (i.e.,
      in some cases, rejecting\n   reservations from some senders when those could
      have actually been\n   established) when used in combination with the Wildcard-Filter
      style\n   (and when there is more than one sender).\n   The sender notification
      via the PathErr method applies to both\n   unicast and multicast sessions.  However,
      for a multicast session, it\n   is possible that reservation failure (e.g.,
      admission control\n   failure) in a node close to a sender may cause ResvErr
      messages to be\n   sent to a large group of Receiver Proxies.  These Receiver
      Proxies\n   would, in turn, all send PathErr messages back to the same sender,\n
      \  which could cause a scalability issue in some environments.\n   From the
      perspective of the sender, errors that prevent a reservation\n   from being
      set up can be classified in two ways:\n   1.  Errors that the sender can attempt
      to correct.  The error code\n       for these errors should explicitly be communicated
      back to the\n       sender.  An example of this is \"Code 1: Admission Control\n
      \      Failure\", because the sender could potentially resend a Path\n       message
      with smaller traffic parameters.\n   2.  Errors over which the sender has no
      control.  For these errors,\n       it is sufficient to notify the sender that
      the reservation was\n       not set up successfully.  An example of this is
      \"Code 13: Unknown\n       Object\", because the sender has no control over
      the objects\n       inserted into the reservation by the Receiver Proxy.\n   The
      PathErr message generated by the Receiver Proxy has the same\n   format as regular
      PathErr messages defined in [RFC2205].  The\n   SESSION, ERROR_SPEC, and sender
      descriptor are composed by the\n   Receiver Proxy as specified in the following
      subsections.  The\n   Receiver Proxy MAY reflect back towards the sender in
      the PathErr any\n   POLICY_DATA objects received in the ResvErr.\n"
    - contents:
      - "3.1.1.  Composition of SESSION and Sender Descriptor\n   The Receiver Proxy
        MUST insert the SESSION object corresponding to\n   the failed reservation
        into the PathErr.  For FF-style reservations,\n   the Receiver Proxy MUST
        insert a sender descriptor corresponding to\n   the failed reservation into
        the PathErr.  This is equal to the error\n   flow descriptor in the ResvErr
        received by the Receiver Proxy.  For\n   SE-style reservations, the Receiver
        Proxy MUST insert a sender\n   descriptor corresponding to the sender triggering
        the failed\n   reservation into the PathErr.  This is equal to the error flow\n
        \  descriptor in the ResvErr received by the Receiver Proxy.  If\n   multiple
        flow descriptors could not be admitted at a midpoint node,\n   that node would
        generate multiple ResvErr messages towards the\n   receiver as per Section
        3.1.8 of [RFC2205].  Each ResvErr would\n   contain an error flow descriptor
        that matches a specific sender.  The\n   Receiver Proxy MUST generate a PathErr
        for each ResvErr received\n   towards the corresponding sender.  As specified
        earlier, for WF-style\n   reservations, the Receiver Proxy SHOULD send a PathErr
        to each\n   sender.\n"
      title: 3.1.1.  Composition of SESSION and Sender Descriptor
    - contents:
      - "3.1.2.  Composition of ERROR_SPEC\n   The Receiver Proxy MUST compose the
        ERROR_SPEC to be inserted into\n   the PathErr as follows:\n   1.  If the
        Receiver Proxy receives a ResvErr with either of these\n       error codes
        -- \"Code 1: Admission Control Failure\" or \"Code 2:\n       Policy Control
        Failure\" -- then the Receiver Proxy copies the\n       error code and value
        from the ERROR_SPEC in the ResvErr into the\n       ERROR_SPEC of the PathErr
        message.  The error node in the PathErr\n       MUST be set to the address
        of the Receiver Proxy.  This procedure\n       MUST also be followed for a
        local error on the Receiver Proxy\n       that would ordinarily cause a midpoint
        to generate a ResvErr with\n       one of the above codes.\n   2.  If the
        Receiver Proxy receives a ResvErr with any error code\n       except the ones
        listed in item 1 above, it composes a new\n       ERROR_SPEC with error code
        \"36: Unrecoverable Receiver Proxy\n       Error\".  The error node address
        in the PathErr MUST be set to the\n       address of the Receiver Proxy.  This
        procedure MUST also be\n       followed for a local error on the Receiver
        Proxy that would\n       ordinarily cause a midpoint to generate a ResvErr
        with any error\n       code other than those listed in item 1 above, or if
        the Receiver\n       Proxy generates a PathErr for a local error that ordinarily
        would\n       not cause generation of a ResvErr.  In some cases, it may be\n
        \      predetermined that the PathErr will not reach the sender.  For\n       example,
        a node receiving a ResvErr with \"Code 3: No Path for\n       Resv\", knows
        a priori that the PathErr message it generates\n       cannot be forwarded
        by the same node that could not process the\n       Resv.  Nevertheless, the
        procedures above MUST be followed.  For\n       the error code \"36: Unrecoverable
        Receiver Proxy Error\", the 16\n       bits of the Error Value field are:\n
        \      *  hhhh hhhh llll llll\n       where the bits are:\n       *  hhhh
        hhhh = 0000 0000: then the low order 8 bits (llll llll)\n          MUST be
        set by Receiver Proxy to 0000 0000 and MUST be ignored\n          by the sender.\n
        \      *  hhhh hhhh = 0000 0001: then the low order 8 bits (llll llll)\n          MUST
        be set by the Receiver Proxy to the value of the error\n          code received
        in the ResvErr ERROR_SPEC (or, in case the\n          Receiver Proxy generated
        the PathErr without having received a\n          ResvErr, to the error code
        value that would have been included\n          by the Receiver Proxy in the
        ERROR_SPEC in similar conditions\n          if it was to generate a ResvErr).
        \ This error value MAY be\n          used by the sender to further interpret
        the reason for the\n          reservation failure.\n       *  hhhh hhhh =
        any other value: reserved.\n   3.  If the Receiver Proxy receives a ResvErr
        with the InPlace flag\n       set in the ERROR_SPEC, it MUST also set the
        InPlace flag in the\n       ERROR_SPEC of the PathErr.\n"
      title: 3.1.2.  Composition of ERROR_SPEC
    - contents:
      - "3.1.3.  Use of Path_State_Removed Flag\n   [RFC3473] defines an optional
        behavior whereby a node forwarding a\n   PathErr message can remove the Path
        state associated with the PathErr\n   message and indicate so by including
        the Path_State_Removed flag in\n   the ERROR_SPEC object of the PathErr message.
        \ This can be used in\n   some situations to expedite release of resources
        and minimize\n   signaling load.\n   This section discusses aspects of the
        use of the Path_State_Removed\n   flag that are specific to the RSVP Receiver
        Proxy.  In any other\n   aspects, the Path_State_Removed flag operates as
        per [RFC3473].\n   By default, the RSVP Receiver Proxy MUST NOT include the\n
        \  Path_State_Removed flag in the ERROR_SPEC of the PathErr message.\n   This
        ensures predictable operations in all environments including\n   those where
        some RSVP routers do not understand the\n   Path_State_Removed flag.\n   The
        RSVP Receiver Proxy MAY support an OPTIONAL mode (to be activated\n   by configuration)
        whereby the RSVP Receiver Proxy includes the\n   Path_State_Removed flag in
        the ERROR_SPEC of the PathErr message and\n   removes its local Path state.
        \ When all routers on the path of a\n   reservation support the Path_State_Removed
        flag, its use will indeed\n   result in expedited resource release and reduced
        signaling.  However,\n   if there are one or more RSVP routers on the path
        of the reservation\n   that do not support the Path_State_Removed flag (we
        refer to such\n   routers as \"old RSVP routers\"), the use of the Path_State_Removed\n
        \  flag will actually result in slower resource release and increased\n   signaling.
        \ This is because the Path_State_Removed flag will be\n   propagated upstream
        by an old RSVP router (even if it does not\n   understand it and does not
        tear its Path state).  Thus, the sender\n   will not send a Path Tear, and
        the old RSVP router will release its\n   Path state only through refresh time-out.
        \ A network administrator\n   needs to keep these considerations in mind when
        deciding whether to\n   activate the use of the Path_State_Removed flag on
        the RSVP Receiver\n   Proxy.  In a controlled environment where all routers
        are known to\n   support the Path_State_Removed flag, its use can be safely
        activated\n   on the RSVP Receiver Proxy.  In other environments, the network\n
        \  administrator needs to assess whether the improvement achieved with\n   some
        reservations outweighs the degradation experienced by other\n   reservations.\n"
      title: 3.1.3.  Use of Path_State_Removed Flag
    - contents:
      - "3.1.4.  Use of PathErr by Regular Receivers\n   Note that while this document
        specifies that an RSVP Receiver Proxy\n   generates a PathErr upstream in
        the case of reservation failure, this\n   document does NOT propose that the
        same be done by regular receivers.\n   In other words, this document does
        NOT propose modifying the behavior\n   of regular receivers as currently specified
        in [RFC2205].  The\n   rationale for this includes the following:\n   o  When
        the receiver is RSVP-capable, the current receiver-driven\n      model of
        [RFC2205] is fully applicable because the receiver can\n      synchronize
        RSVP reservation state and application state (since it\n      participates
        in both).  The sender(s) need not be aware of the\n      RSVP reservation
        state.  Thus, we can retain the benefits of\n      receiver-driven operations
        that were explicitly sought by\n      [RFC2205], which states, \"In order
        to efficiently accommodate\n      large groups, dynamic group membership,
        and heterogeneous receiver\n      requirements, RSVP makes receivers responsible
        for requesting a\n      specific QoS\".  But even for the simplest single_sender/\n
        \     single_receiver reservations, the current receiver-driven model\n      reduces
        signaling load and per-hop RSVP processing by not sending\n      any error
        message to the sender in case of admission control\n      reject.\n   o  The
        motivation for adding sender error notification in the case of\n      an RSVP
        Receiver Proxy lies in the fact that the actual receiver\n      can no longer
        synchronize the RSVP reservation with application\n      state (since the
        receiver does not participate in RSVP signaling),\n      while the sender
        can.  This motivation does not apply in the case\n      of a regular receiver.\n
        \  o  There is a lot of existing code and deployed systems successfully\n
        \     working under the current [RFC2205] model in the absence of proxy\n
        \     today.  The current behavior of existing deployed systems should\n      not
        be changed unless there were a very strong motivation.\n"
      title: 3.1.4.  Use of PathErr by Regular Receivers
    title: 3.1.  Sender Notification via PathErr Message
  - contents:
    - "3.2.  Sender Notification via Notify Message\n   The OPTIONAL method for sender
      notification of reservation failure\n   defined in this section aims to provide
      a more efficient method than\n   the one defined in Section 3.1.  Its objectives
      include:\n   o  allowing the failure notification to be sent directly upstream
      to\n      the sender by the router where the failure occurs (as opposed to\n
      \     first traveling downstream towards the Receiver Proxy and then\n      traveling
      upstream from the Receiver Proxy to the sender, as\n      effectively happens
      with the method defined in Section 3.1).\n   o  allowing the failure notification
      to travel without hop-by-hop\n      RSVP processing.\n   o  ensuring that such
      a notification is sent to senders that are\n      capable and willing to process
      it (i.e., to synchronize\n      reservation status with application).\n   o
      \ ensuring that such a notification is only sent in case the\n      receiver
      is not itself capable and willing to do the\n      synchronization with the
      application (i.e., because we are in the\n      presence of a Receiver Proxy
      so that RSVP signaling is not visible\n      to the receiver).\n   Note, however,
      that such benefits come at the cost of:\n   o  a requirement for RSVP routers
      and senders to support the Notify\n      messages and procedures defined in
      [RFC3473].\n   o  a requirement for senders to process Notify messages traveling\n
      \     upstream but conveying a downstream notification.\n   [RFC3473] defines
      (in Section 4.3, \"Notify Messages\") the Notify\n   message that provides a
      mechanism to inform non-adjacent nodes of\n   events related to the RSVP reservation.
      \ The Notify message differs\n   from the error messages defined in [RFC2205]
      (i.e., PathErr and\n   ResvErr messages) in that it can be \"targeted\" to a
      node other than\n   the immediate upstream or downstream neighbor and that it
      is a\n   generalized notification mechanism.  Notify messages are normally\n
      \  generated only after a Notify Request object has been received.\n   This
      section discusses aspects of the use of the Notify message that\n   are specific
      to the RSVP Receiver Proxy.  In any other aspects, the\n   Notify message operates
      as per [RFC3473].\n   In order to achieve sender notification of reservation
      failure in the\n   context of this document:\n   o  An RSVP sender interested
      in being notified of reservation failure\n      MUST include a Notify Request
      object (containing the sender's IP\n      address) in the Path messages it generates.\n
      \  o  Upon receiving a Path message with a Notify Request object, the\n      RSVP
      Receiver Proxy MUST include a Notify Request object in the\n      Resv messages
      it generates.  This Notify Request object MUST\n      contain either:\n      *
      \ the address that was included in the Notify Request of the\n         received
      Path message, a.k.a. the sender's address.  We refer\n         to this approach
      as the \"Direct Notify\" approach, or\n      *  an address of the Receiver Proxy.
      \ We refer to this approach as\n         the \"Indirect Notify\" approach.\n
      \  o  Upon receiving a downstream error notification (whether in the\n      form
      of a Notify, ResvErr, or both), the RSVP Receiver Proxy:\n      *  MUST generate
      a Notify message with upstream notification to\n         the corresponding sender,
      if the sender included a Notify\n         Request object in its Path messages
      and if Indirect\n         Notification is used.\n      *  SHOULD generate a
      Notify message with upstream notification to\n         the corresponding sender,
      if the sender included a Notify\n         Request object in its Path messages
      and if Direct Notification\n         is used.  The reason for this recommendation
      is that the\n         failure node may not support Notify, so that even if Direct\n
      \        Notification was requested by the RSVP Receiver Proxy, the\n         sender
      may not actually have received a Notify from the failure\n         node: generating
      a Notify from the Receiver Proxy will\n         accelerate sender notification,
      as compared to simply relying\n         on PathErr, in this situation.  In controlled
      environments\n         where all the nodes are known to support Notify, the
      Receiver\n         Proxy MAY be configured to not generate the Notify with\n
      \        upstream notification when Direct Notification is used, in\n         order
      to avoid duplication of Notify messages (i.e., the sender\n         receiving
      both a Notify from the failure node and from the\n         Receiver Proxy).\n
      \  As a result of these sender and Receiver Proxy behaviors, as per\n   existing
      Notify procedures, if an RSVP router detects an error\n   relating to a Resv
      state (e.g., admission control rejection after IP\n   reroute), the RSVP router
      will send a Notify message (conveying the\n   downstream notification with the
      ResvErr error code) to the IP\n   address contained in the Resv Notify Request
      object.  If this address\n   has been set by the RSVP Receiver Proxy to the
      sender's address\n   (Direct Notify), the Notify message is sent directly to
      the sender.\n   If this address has been set by the RSVP Receiver Proxy to one
      of its\n   own addresses (Indirect Notify), the Notify message is sent to the\n
      \  RSVP Receiver Proxy that, in turn, will generate a Notify message\n   directly
      addressed to the sender.\n   Operation of the Path-Triggered RSVP Receiver Proxy
      in the case of an\n   admission control failure, using sender notification via
      Direct\n   Notify, is illustrated in Figure 4.\n |****|        ***        ***
      \       ***        |**********|      |----|\n | S  |--------*r*--------*r*--------*r*--------|
      RSVP     |------| R  |\n |****|        ***        ***        ***        | Receiver
      |      |----|\n                                                | Proxy    |\n
      \                                               |**********|\n      --Path*-->
      --Path*--> --Path*--> --Path*-->\n                            <--Resv*-- <--Resv*--\n
      \     <------NotifyD--------\n                            -ResvErr-> -ResvErr->\n
      \     <------------------NotifyU------------------\n      <-PathErr- <-PathErr-
      <-PathErr- <-PathErr-\n      ===================RSVP===================>\n      ************************************************************>\n
      |****| RSVP-capable  |----| Non-RSVP-capable   ***\n | S  | Sender        |
      R  | Receiver           *r* regular RSVP\n |****|               |----|                    ***
      router\n ***> media flow\n ==>  segment of flow path benefiting from RSVP\n
      \     (but not benefiting from a reservation in this case)\n Path*  = Path message
      containing a Notify Request object\n          with sender IP Address\n Resv*
      \ = Resv message containing a Notify Request object\n          with sender IP
      address\n NotifyD = Notify message containing a downstream notification\n NotifyU
      = Notify message containing an upstream notification\n          Figure 4: Reservation
      Failure with Sender Notification\n                             via Direct Notify\n
      \  Operation of the Path-Triggered RSVP Receiver Proxy in the case of an\n   admission
      control failure, using sender notification via Indirect\n   Notify, is illustrated
      in Figure 5.\n |****|        ***        ***        ***        |**********|      |----|\n
      | S  |--------*r*--------*r*--------*r*--------| RSVP     |------| R  |\n |****|
      \       ***        ***        ***        | Receiver |      |----|\n                                                |
      Proxy    |\n                                                |**********|\n      --Path*-->
      --Path*--> --Path*--> --Path*-->\n                            <--Resv*-- <--Resv*--\n
      \                           -------NotifyD------->\n      <------------------NotifyU------------------\n
      \                           -ResvErr-> -ResvErr->\n      <-PathErr- <-PathErr-
      <-PathErr- <-PathErr-\n      ===================RSVP===================>\n      ************************************************************>\n
      |****| RSVP-capable  |----| Non-RSVP-capable   ***\n | S  | Sender        |
      R  | Receiver           *r* regular RSVP\n |****|               |----|                    ***
      router\n ***> media flow\n ==>  segment of flow path benefiting from RSVP\n
      \     (but not benefiting from a reservation in this case)\n Path*  = Path message
      containing a Notify Request object\n          with sender IP Address\n Resv*
      \ = Resv message containing a Notify Request object\n          with RSVP Receiver
      Proxy IP address\n NotifyD = Notify message containing a downstream notification\n
      NotifyU = Notify message containing an upstream notification\n          Figure
      5: Reservation Failure with Sender Notification\n                            via
      Indirect Notify\n   For local failures on the Receiver Proxy node, if a similar
      failure\n   on an RSVP midpoint would cause the generation of a ResvErr (for\n
      \  example, admission control failure), the Receiver Proxy MUST generate\n   a
      Notify towards the sender.  The Receiver Proxy MAY additionally\n   generate
      a Notify upon local failures that would not ordinarily cause\n   generation
      of a ResvErr message, such as those described in\n   Appendix B of [RFC2205].\n
      \  When the method of sender notification via a Notify message is used,\n   it
      is RECOMMENDED that the RSVP Receiver Proxy also issue a sender\n   notification
      via a PathErr message.  This maximizes the chances that\n   the notification
      will reach the sender in all situations (e.g., even\n   if some RSVP routers
      do not support the Notify procedure, or if a\n   Notify message gets dropped).
      \ However, for controlled environments\n   (e.g., where all RSVP routers are
      known to support Notify procedures)\n   and where it is desirable to minimize
      the volume of signaling, the\n   RSVP Receiver Proxy MAY rely exclusively on
      sender notification via a\n   Notify message and thus not issue sender notification
      via a PathErr\n   message.\n   In environments where there are both RSVP-capable
      receivers and RSVP\n   Receiver Proxies acting on behalf of non-RSVP-capable
      receivers, a\n   sender does not know whether a given reservation is established
      with\n   an RSVP-capable receiver or with an RSVP Receiver Proxy.  Thus, a\n
      \  sender that supports the procedures defined in this section may\n   include
      a Notify Request object in Path messages for a reservation\n   that happens
      to be controlled by an RSVP-capable receiver.  This\n   document does not define,
      nor expect, any change in existing receiver\n   behavior.  As a result, in this
      case, the sender will not receive\n   Notify messages conveying downstream notifications.
      \ However, this is\n   perfectly fine because the synchronization between the
      RSVP\n   reservation state and the application requirement can be performed
      by\n   the actual receiver in this case as per the regular end-to-end RSVP\n
      \  model, so that in this case, the sender need not care about\n   downstream
      notifications.\n   A sender that does not support the procedures defined in
      this section\n   might include a Notify Request object in Path messages for
      a\n   reservation simply because it is interested in getting upstream\n   notifications
      faster.  If the reservation is controlled by an RSVP\n   Receiver Proxy supporting
      the procedures defined in this section, the\n   sender will also receive unexpected
      Notify messages containing\n   downstream notifications.  It is expected that
      such a sender will\n   simply naturally drop such downstream notifications as
      invalid.\n   Because it is RECOMMENDED above that the RSVP Receiver Proxy also\n
      \  issue a sender notification via a PathErr message even when sender\n   notification
      is effected via a Notify message, the sender will still\n   be notified of a
      reservation failure in accordance with the \"sender\n   notification via PathErr\"
      method.  In summary, activating the\n   OPTIONAL \"sender notification via Notify\"
      method on a Receiver Proxy\n   does not prevent a sender that does not support
      this method from\n   relying on the MANDATORY \"sender notification via PathErr\"
      method.\n   It would, however, allow a sender supporting the \"sender notification\n
      \  via Notify\" method to take advantage of this OPTIONAL method.\n   With Direct
      Notification, the downstream notification generated by\n   the RSVP router where
      the failure occurs is sent to the IP address\n   contained in the Notification
      Request Object of the corresponding\n   Resv message.  In the presence of multiple
      senders towards the same\n   session, it cannot be generally assumed that a
      separate Resv message\n   is used for each sender (in fact, with WF and SE there
      is a single\n   Resv message for all senders, and with FF the downstream router
      has\n   the choice of generating separate Resv messages or a single one).\n
      \  Hence, in the presence of multiple senders, Direct Notification\n   cannot
      guarantee notification of all affected senders.  Therefore,\n   Direct Notification
      is better suited to single-sender applications.\n   With Indirect Notification,
      the RSVP Receiver Proxy can generate\n   Notify messages with the same logic
      that is used to generate PathErr\n   messages in the \"Sender Notification via
      PathErr\" method (in fact,\n   those are conveying the same error information,
      only the Notify is\n   directly addressed to the sender while the PathErr travels
      hop-by-\n   hop).  Therefore, operations of the Indirect Notify method in the\n
      \  presence of multiple senders is similar to that of the PathErr method\n   as
      discussed in Section 3.1: with FF or SE, a Notify MUST be sent to\n   the sender
      or the set of affected senders, respectively.  With WF,\n   the RSVP Receiver
      Proxy SHOULD send a Notify to each sender, again\n   resulting in a somewhat
      overly conservative behavior in the presence\n   of multiple senders.\n"
    title: 3.2.  Sender Notification via Notify Message
  title: 3.  RSVP Extensions for Sender Notification
- contents:
  - "4.  Mechanisms for Maximizing the Reservation Span\n   This section defines extensions
    to RSVP procedures allowing an RSVP\n   reservation to span as much of the flow
    path as possible, with any\n   arbitrary number of RSVP Receiver Proxies on the
    flow path and\n   whether or not the receiver is RSVP-capable.  This facilitates\n
    \  deployment and operations of Path-Triggered RSVP Receiver Proxies\n   since
    it alleviates the topological constraints and/or configuration\n   load otherwise
    associated with Receiver Proxies (e.g., make sure\n   there is no RSVP Receiver
    Proxy for a flow upstream of a given\n   Receiver Proxy, ensure there is no Receiver
    Proxy for a flow if the\n   receiver is RSVP-capable).  This also facilitates
    migration from an\n   RSVP deployment model based on Path-Triggered Receiver Proxies
    to an\n   end-to-end RSVP model, since receivers can gradually and\n   independently
    be upgraded to support RSVP and then instantaneously\n   benefit from end-to-end
    reservations.\n   Section 4.1 defines a method that allows a Path-Triggered Receiver\n
    \  Proxy function to discover whether there is another Receiver Proxy or\n   an
    RSVP-capable receiver downstream and then dynamically extend the\n   span of the
    RSVP reservation downstream.  A router implementation\n   claiming compliance
    with this document SHOULD support the method\n   defined in Section 4.1.\n   Section
    4.2 defines a method that allows a sender to control whether\n   or not an RSVP
    router supporting the Path-Triggered Receiver Proxy\n   function is to behave
    as a Receiver Proxy for a given flow.  A router\n   implementation claiming compliance
    with this document MAY support the\n   method defined in Section 4.2.\n   In a
    given network environment, a network administrator may elect to\n   use the method
    defined in Section 4.1, or the method defined in\n   Section 4.2, or possibly
    combine the two.\n"
  - contents:
    - "4.1.  Dynamic Discovery of Downstream RSVP Functionality\n   When generating
      a proxy Resv message upstream, a Receiver Proxy\n   supporting dynamic discovery
      of downstream RSVP functionality MUST\n   forward the Path message downstream
      instead of terminating it (unless\n   dynamic discovery of downstream RSVP functionality
      is explicitly\n   disabled).  If the destination endpoint supports RSVP (or
      there is\n   another Receiver Proxy downstream), it will receive the Path and\n
      \  generate a Resv upstream.  When this Resv message reaches the\n   Receiver
      Proxy, it recognizes the presence of an RSVP-capable\n   receiver (or of another
      RSVP Receiver Proxy) downstream and MUST\n   internally convert its state from
      a proxied reservation to a regular\n   midpoint RSVP behavior.  From then on,
      the RSVP router MUST behave as\n   a regular RSVP router for that reservation
      (i.e., as if the RSVP\n   router never behaved as an RSVP Receiver Proxy for
      that flow).  This\n   method is illustrated in Figure 6.\n      |****|         ***
      \        |**********|   |----|\n      | S  |---------*r*---------| RSVP     |---|
      R1 |\n      |****|         ***         | Receiver |   |----|\n                                 |
      Proxy    |\n                                 |          |\n                                 |
      \         |            |****|\n                                 |          |------------|
      R2 |\n                                 |**********|            |****|\n           ---Path--->
      \ --Path--->\n              (R1)        (R1)    \\-------Path-->\n                                  /
      \      (R1)\n           <--Resv---  <---Resv---\n          ================RSVP===>\n
      \         **************************************>\n           ---Path--->  --Path--->\n
      \             (R2)        (R2)    \\-------------Path---->\n                                  /
      \            (R2)\n           <--Resv---  <---Resv---\n                                             <----Resv---\n
      \         ================RSVP===========================>\n          ***********************************************>\n
      \  |****| RSVP-capable  |----| non-RSVP-capable  |****| RSVP-capable\n   | S
      \ | Sender        | R  | Receiver          | R  | Receiver\n   |****|               |----|
      \                  |****|\n   ***\n   *r* regular RSVP\n   *** router\n   (R1)
      = Path message contains a Session object whose destination is R1\n   ***> media
      flow\n   ==>  segment of flow path protected by RSVP reservation\n       Figure
      6: Dynamic Discovery of Downstream RSVP Functionality\n   If there is no RSVP-capable
      receiver (or other Receiver Proxy)\n   downstream of the Receiver Proxy, then
      the Path messages sent by the\n   Receiver Proxy every RSVP refresh interval
      (e.g., 30 seconds by\n   default) will never be responded to.  However, these
      messages consume\n   a small amount of bandwidth, and in addition would install
      some RSVP\n   state on RSVP-capable midpoint nodes downstream of the first Receiver\n
      \  Proxy.  This is seen as a very minor sub-optimality; however, to\n   mitigate
      this, the Receiver Proxy MAY tear down any unanswered\n   downstream Path state
      after a predetermined time (that SHOULD be\n   greater or equal to the Path
      refresh interval), and MAY stop sending\n   Path messages for the flow (or MAY
      only send them at much lower\n   frequency).\n   This approach only requires
      support of the behavior described in the\n   previous paragraph and does not
      require any new RSVP extensions.\n"
    title: 4.1.  Dynamic Discovery of Downstream RSVP Functionality
  - contents:
    - "4.2.  Receiver Proxy Control Policy Element\n   [RFC2750] defines extensions
      for supporting generic policy-based\n   admission control in RSVP.  These extensions
      include the standard\n   format of POLICY_DATA objects and a description of
      RSVP handling of\n   policy events.\n   The POLICY_DATA object contains one
      or more policy elements, each\n   representing a different (and perhaps orthogonal)
      policy.  As an\n   example, [RFC3181] specifies the preemption priority policy
      element.\n   This document defines a new policy element called the Receiver
      Proxy\n   Control policy element.  This document only defines the use of this\n
      \  policy element in Path messages and for unicast reservations.  Other\n   usage
      is outside the scope of this document.\n   The format of the Receiver Proxy
      Control policy element is as shown\n   in Figure 7:\n          0           0
      0           1 1           2 2           3\n          0  . . .    7 8   . . .
      \  5 6    . . .  3 4  . . .    1\n         +-------------+-------------+-------------+-------------+\n
      \        |     Length                | P-Type=REC_PROXY_CONTROL  |\n         +-------------+-------------+-------------+-------------+\n
      \        |              Reserved                   |Control-Value|\n         +---------------------------+---------------------------+\n
      \             Figure 7: Receiver Proxy Control Policy Element\n   where:\n   o
      \ Length: 16 bits\n      *  Always 8.  The overall length of the policy element,
      in bytes.\n   o  P-Type: 16 bits\n      *  REC_PROXY_CONTROL = 0x07 (see the
      \"IANA Considerations\"\n         section).\n   o  Reserved: 24 bits\n      *
      \ SHALL be set to zero on transmit and SHALL be ignored on\n         reception.\n
      \  o  Control-Value: 8 bits (unsigned)\n      *  0 (Reserved): An RSVP Receiver
      Proxy that understands this\n         policy element MUST ignore the policy
      element if its Control-\n         Value is set to that value.\n      *  1 (Receiver-Proxy-Needed):
      An RSVP Receiver Proxy that\n         understands this policy element MUST attempt
      to insert itself\n         as a Receiver Proxy for that flow if the corresponding
      Path\n         message contains this Control-Value.  If the Receiver Proxy\n
      \        also supports dynamic discovery of downstream RSVP\n         functionality
      as specified in Section 4.1, it MUST still send\n         the Path message downstream
      and attempt to extend the\n         reservation downstream so that the reservation
      can be extended\n         to the last Receiver Proxy).  An RSVP sender MAY insert
      the\n         Receiver Proxy Control policy element with this Control-Value\n
      \        when it knows (say, by other means, such as application-level\n         signaling)
      that the receiver is not RSVP-capable.\n      *  2 (Receiver-Proxy-Not-Needed):
      An RSVP Receiver Proxy that\n         understands this policy element MUST NOT
      attempt to insert\n         itself as a Receiver Proxy for that flow if the
      corresponding\n         Path message contains this Control-Value.  An RSVP sender
      MAY\n         insert the Receiver Proxy Control policy element with this\n         Control-Value
      when it knows (say, by other means, such as\n         application-level signaling)
      that the receiver is RSVP-capable.\n   Figure 8 illustrates the method based
      on the Receiver Proxy Control\n   policy element that allows a sender to control
      whether or not an RSVP\n   router supporting the Path-Triggered Receiver Proxy
      function is to\n   behave as a Receiver Proxy for a given flow.\n      |****|
      \        ***         |**********|   |----|\n      | S  |---------*r*---------|
      RSVP     |---| R1 |\n      |****|         ***         | Receiver |   |----|\n
      \                                | Proxy    |\n                                 |
      \         |\n                                 |          |            |****|\n
      \                                |          |------------| R2 |\n                                 |**********|
      \           |****|\n           ---Path--->  --Path--->\n            (R1/N)      (R1/N)\n
      \          <--Resv---  <---Resv---\n          ================RSVP===>\n          **************************************>\n
      \          ---Path--->  --Path--->          ----Path---->\n            (R2/NN)
      \     (R2/NN)               (R2/NN)\n           <--Resv---  <---Resv---          <----Resv----\n
      \         ================RSVP===========================>\n          ***********************************************>\n
      \  |****| RSVP-capable  |----| non-RSVP-capable  |****| RSVP-capable\n   | S
      \ | Sender        | R  | Receiver          | R  | Receiver\n   |****|               |----|
      \                  |****|\n   ***\n   *r* regular RSVP\n   *** router\n   (R1)
      = Path message contains a Session object whose destination is R1\n   (N)  =
      Path message contains a Receiver Proxy Control policy element\n        whose
      Control-Value is set to Receiver-Proxy-Needed\n   (NN) = Path message contains
      a Receiver Proxy Control policy element\n        whose Control-Value is set
      to Receiver-Proxy-Not-Needed\n   ***> media flow\n   ==>  segment of flow path
      protected by RSVP reservation\n                Figure 8: Receiver Proxy Control
      by Sender\n"
    - contents:
      - "4.2.1.  Default Handling\n   As specified in Section 4.2 of [RFC2750], Policy-Ignorant
        Nodes\n   (PINs) implement a default handling of POLICY_DATA objects ensuring\n
        \  that those objects can traverse PINs in transit from one Policy\n   Enforcement
        Point (PEP) to another.  This applies to the situations\n   in which POLICY_DATA
        objects contain the Receiver Proxy Control\n   policy element specified in
        this document, so that those objects can\n   traverse PINs.\n   Section 4.2
        of [RFC2750] also defines a similar default behavior for\n   policy-capable
        nodes that do not recognize a particular policy\n   element.  This applies
        to the Receiver Proxy Control policy element\n   specified in this document,
        so that messages carrying the element can\n   traverse policy-capable nodes
        that do not support the extensions\n   described in this document.\n"
      title: 4.2.1.  Default Handling
    title: 4.2.  Receiver Proxy Control Policy Element
  title: 4.  Mechanisms for Maximizing the Reservation Span
- contents:
  - "5.  Security Considerations\n   As this document defines extensions to RSVP,
    the security\n   considerations of RSVP apply, which are discussed in [RFC2205],\n
    \  [RFC4230], and [SEC-GRP-KEY].  Approaches for addressing those\n   concerns
    are discussed further below.\n   The RSVP authentication mechanisms defined in
    [RFC2747] and [RFC3097]\n   protect RSVP message integrity hop-by-hop and provide
    node\n   authentication as well as replay protection, thereby protecting\n   against
    corruption and spoofing of RSVP messages.  These hop-by-hop\n   integrity mechanisms
    can be used to protect RSVP reservations\n   established using an RSVP Receiver
    Proxy in accordance with this\n   document.  [SEC-GRP-KEY] discusses key types
    and key provisioning\n   methods as well as their respective applicability to
    RSVP\n   authentication.  RSVP authentication (defined in [RFC2747] and\n   [RFC3097])
    SHOULD be supported by an implementation of this document.\n   [SEC-GRP-KEY] also
    discusses applicability of IPsec mechanisms\n   ([RFC4302], [RFC4303]) and associated
    key provisioning methods for\n   security protection of RSVP.  This discussion
    applies to the\n   protection of RSVP in the presence of Path-Triggered RSVP Receiver\n
    \  Proxies as defined in this document.\n   A subset of RSVP messages are signaled
    with the IP router alert\n   option ([RFC2113], [RFC2711]).  Based on the current
    security\n   concerns associated with the use of the IP router alert option, the\n
    \  applicability of RSVP (and therefore of the RSVP Proxy approaches\n   discussed
    in this document) is limited to controlled environments\n   (i.e., where the security
    risks associated with the use of the IP\n   router alert option are understood
    and protected against).  The\n   security aspects and common practices around
    the use of the current\n   IP router alert option, and consequences of using the
    IP router alert\n   option by applications such as RSVP, are discussed in detail
    in\n   [RTR-ALERT].\n   When an RSVP Receiver Proxy is used, the RSVP reservation
    is no\n   longer controlled by the receiver, but rather is controlled by the\n
    \  Receiver Proxy (using hints received from the sender in the Path\n   message)
    on behalf of the sender.  Thus, the Receiver Proxy ought to\n   be trusted by
    the end-systems to control the RSVP reservation\n   appropriately.  However, basic
    RSVP operation already assumes a trust\n   model where end-systems trust RSVP
    nodes to appropriately perform\n   RSVP reservations.  So the use of an RSVP Receiver
    Proxy is not seen\n   as introducing any significant additional security threat
    or as\n   modifying the RSVP trust model.\n   In fact, there are situations in
    which the use of an RSVP Receiver\n   Proxy reduces the security risks.  One example
    is where a network\n   operator relies on RSVP to perform resource reservation
    and admission\n   control within a network and where RSVP senders and RSVP routers
    are\n   located in the operator's premises, while the many RSVP receivers are\n
    \  located in the operator's customers' premises.  Such an environment\n   is
    further illustrated in Appendix A.1, \"RSVP-Based VoD Admission\n   Control in
    Broadband Aggregation Networks\", of [RFC5945].  From the\n   operator's perspective,
    the RSVP routers and RSVP senders are in\n   physically secured locations and
    therefore exposed to a lower risk of\n   being tampered with, while the receivers
    are in locations that are\n   physically unsecured and therefore subject to a
    higher risk of being\n   tampered with.  The use of an RSVP Receiver Proxy function\n
    \  effectively increases the security of the operator's reservation and\n   admission
    control solution by completely excluding receivers from its\n   operation.  Filters
    can be placed at the edge of the operator\n   network, discarding any RSVP message
    received from end-users.  This\n   provides a very simple and effective protection
    of the RSVP\n   reservation and admission control solution operating inside the\n
    \  operator's network.\n"
  - contents:
    - "5.1.  Security Considerations for the Sender Notification via Notify\n      Message\n
      \  This document defines, in Section 3.2, an optional method relying on\n   the
      use of the Notify message specified in [RFC3473].  The Notify\n   message can
      be sent in a non-hop-by-hop fashion that precludes the\n   use of the RSVP hop-by-hop
      integrity and authentication model.  The\n   approaches and considerations for
      addressing this issue presented in\n   the Security Considerations section of
      [RFC3473] apply.  In\n   particular, where the Notify messages are transmitted
      non-hop-by-hop\n   and the same level of security provided by [RFC2747] is desired,\n
      \  IPsec-based integrity and authentication can be used ([RFC4302] or\n   [RFC4303]).
      \ Alternatively, the sending of non-hop-by-hop Notify\n   messages can be disabled.
      \ Finally, [SEC-GRP-KEY] discusses the\n   applicability of group keying for
      non-hop-by-hop Notify messages.\n"
    title: 5.1.  Security Considerations for the Sender Notification via Notify
  - contents:
    - "5.2.  Security Considerations for the Receiver Proxy Control Policy\n      Element\n
      \  This document also defines, in Section 4.2, the optional Receiver\n   Proxy
      Control policy element.  Policy elements are signaled by RSVP\n   through encapsulation
      in a Policy Data object as defined in\n   [RFC2750].  Therefore, like any other
      policy elements, the integrity\n   of the Receiver Proxy Control policy element
      can be protected as\n   discussed in Section 6 of [RFC2750] by two optional
      security\n   mechanisms.\n   The first mechanism relies on the RSVP authentication
      discussed above\n   that provides a chain of trust when all RSVP nodes are policy\n
      \  capable.  With this mechanism, the INTEGRITY object is carried inside\n   RSVP
      messages.\n   The second mechanism relies on the INTEGRITY object within the\n
      \  POLICY_DATA object to guarantee integrity between RSVP Policy\n   Enforcement
      Points (PEPs) that are not RSVP neighbors.  This is\n   useful only when some
      RSVP nodes are Policy-Ignorant Nodes (PINs).\n   The INTEGRITY object within
      the POLICY_DATA object MAY be supported\n   by an implementation of this document.\n
      \  Details for the computation of the content of the INTEGRITY object\n   can
      be found in Appendix B of [RFC2750].  This states that the Policy\n   Decision
      Point (PDP), at its discretion, and based on destination\n   PEP/PDP or other
      criteria, selects an Authentication Key and the hash\n   algorithm to be used.
      \ Keys to be used between PDPs can be\n   distributed manually or via a standard
      key management protocol for\n   secure key distribution.\n   Note that where
      non-RSVP hops may exist in between RSVP hops, as well\n   as where RSVP-capable
      Policy-Ignorant Nodes (PINs) may exist in\n   between PEPs, it may be difficult
      for the PDP to determine what the\n   destination PDP is for a POLICY_DATA object
      contained in some RSVP\n   messages (such as a Path message).  This is because
      in those cases,\n   the next PEP is not known at the time of forwarding the
      message.  In\n   this situation, a key shared across multiple PDPs may be used.
      \ This\n   is conceptually similar to the use of a key shared across multiple\n
      \  RSVP neighbors, as discussed in [SEC-GRP-KEY].  We also observe that\n   this
      issue may not exist in some deployment scenarios where a single\n   PDP (or
      a low number of PDPs) is used to control all the PEPs of a\n   region (such
      as an administrative domain).  In such scenarios, it may\n   be easy for a PDP
      to determine what the next-hop PDP is, even when\n   the next-hop PEP is not
      known, simply by determining what the next\n   region is that will be traversed
      (say, based on the destination\n   address).\n"
    title: 5.2.  Security Considerations for the Receiver Proxy Control Policy
  title: 5.  Security Considerations
- contents:
  - '6.  IANA Considerations

    '
  - contents:
    - "6.1.  RSVP Error Codes\n   Since, as discussed in Section 3.1.2, this document
      allows two error\n   codes to be used in PathErr messages while [RFC2205] only
      specified\n   their use in ResvErr messages, IANA has updated the existing entries\n
      \  for these two error codes under the \"Error Codes and Globally-Defined\n
      \  Error Value Sub-Codes\" registry.  Each entry refers to this document,\n
      \  in addition to referring to [RFC2205].  Specifically, the entry for\n   Error
      Code 1 and Error Code 2 read:\n   1 Admission Control Failure [RFC2205] [RFC5946]\n
      \  2 Policy Control Failure [RFC2205] [RFC5946]\n   IANA has also allocated
      a new RSVP Error Code \"36;: Unrecoverable\n   Receiver Proxy Error\", as discussed
      in Section 3.1.2.  This error\n   code has been allocated under the \"Error
      Codes and Globally-Defined\n   Error Value Sub-Codes\" registry.  The entry
      for this error code\n   reads:\n   36 Unrecoverable Receiver Proxy Error [RFC5946]\n
      \  The sixteen bits of the Error Value field are defined in [RFC5946]\n"
    title: 6.1.  RSVP Error Codes
  - contents:
    - "6.2.  Policy Element\n   This document defines, in Section 4.2, a new policy
      element called\n   the Receiver Proxy Control policy element.  As specified
      in\n   [RFC2750], standard RSVP policy elements (P-Type values) are to be\n
      \  assigned by IANA as per \"IETF Consensus\" policy following the\n   policies
      outlined in [RFC2434] (this policy is now called \"IETF\n   Review\" as per
      [RFC5226]).\n   Thus, IANA has allocated one P-Type to the Receiver Proxy Control\n
      \  policy element from the standard RSVP policy element range.\n   In Section
      4.2, this document defines a Control-Value field inside\n   the Receiver Proxy
      Control policy element.  IANA has created the\n   \"Receiver Proxy Control Policy
      Element (P-Type 0x07) Control-Value\n   field\" registry and allocated the following
      values:\n   o  0 : Reserved\n   o  1 : Receiver-Proxy-Needed\n   o  2 : Receiver-Proxy-Not-Needed\n
      \  Following the policies outlined in [RFC5226], numbers in the range\n   3-127
      are allocated according to the \"IETF Review\" policy, numbers in\n   the range
      128-240 are assigned on a \"First Come First Served\" basis,\n   and numbers
      in the range 241-255 are reserved for \"Private Use\".\n"
    title: 6.2.  Policy Element
  title: 6.  IANA Considerations
- contents:
  - "7.  Acknowledgments\n   This document benefited from discussions with Carol Iturralde
    and\n   Anca Zamfir.  Lou Berger, Adrian Farrel, and John Drake provided\n   review
    and guidance, in particular on the usage of the\n   Path_State_Removed flag and
    of the Notify message, both borrowed from\n   [RFC3473].  We also thank Stephen
    Kent, Ken Carlberg, and Tim Polk\n   for their valuable input and proposed enhancements.
    \ Finally, we\n   thank Cullen Jennings, Magnus Westerlund, and Robert Sparks
    for\n   stimulating the work on extensions maximizing the reservation span\n   and
    facilitating migration from the Proxy model to the end-to-end\n   RSVP model.\n"
  title: 7.  Acknowledgments
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [RFC2113]     Katz, D., \"IP Router Alert Option\",
      RFC 2113,\n                 February 1997.\n   [RFC2119]     Bradner, S., \"Key
      words for use in RFCs to Indicate\n                 Requirement Levels\", BCP
      14, RFC 2119, March 1997.\n   [RFC2205]     Braden, B., Zhang, L., Berson, S.,
      Herzog, S., and S.\n                 Jamin, \"Resource ReSerVation Protocol
      (RSVP) -- Version\n                 1 Functional Specification\", RFC 2205,
      September 1997.\n   [RFC2434]     Narten, T. and H. Alvestrand, \"Guidelines
      for Writing\n                 an IANA Considerations Section in RFCs\", BCP
      26,\n                 RFC 2434, October 1998.\n   [RFC2711]     Partridge, C.
      and A. Jackson, \"IPv6 Router Alert\n                 Option\", RFC 2711, October
      1999.\n   [RFC2747]     Baker, F., Lindell, B., and M. Talwar, \"RSVP\n                 Cryptographic
      Authentication\", RFC 2747, January 2000.\n   [RFC2750]     Herzog, S., \"RSVP
      Extensions for Policy Control\",\n                 RFC 2750, January 2000.\n
      \  [RFC3097]     Braden, R. and L. Zhang, \"RSVP Cryptographic\n                 Authentication
      -- Updated Message Type Value\",\n                 RFC 3097, April 2001.\n   [RFC3209]
      \    Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan,\n                 V.,
      and G. Swallow, \"RSVP-TE: Extensions to RSVP for\n                 LSP Tunnels\",
      RFC 3209, December 2001.\n   [RFC3473]     Berger, L., \"Generalized Multi-Protocol
      Label Switching\n                 (GMPLS) Signaling Resource ReserVation Protocol-Traffic\n
      \                Engineering (RSVP-TE) Extensions\", RFC 3473,\n                 January
      2003.\n   [RFC4302]     Kent, S., \"IP Authentication Header\", RFC 4302,\n
      \                December 2005.\n   [RFC4303]     Kent, S., \"IP Encapsulating
      Security Payload (ESP)\",\n                 RFC 4303, December 2005.\n   [RFC5226]
      \    Narten, T. and H. Alvestrand, \"Guidelines for Writing\n                 an
      IANA Considerations Section in RFCs\", BCP 26,\n                 RFC 5226, May
      2008.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [RFC3181]     Herzog, S., \"Signaled Preemption
      Priority Policy\n                 Element\", RFC 3181, October 2001.\n   [RFC4230]
      \    Tschofenig, H. and R. Graveman, \"RSVP Security\n                 Properties\",
      RFC 4230, December 2005.\n   [RFC5945]     Le Faucheur, F., Manner, J., Wing,
      D., and A. Guillou,\n                 \"Resource Reservation Protocol (RSVP)
      Proxy\n                 Approaches\", RFC 5945, October 2010.\n   [RTR-ALERT]
      \  Le Faucheur, F., \"IP Router Alert Considerations and\n                 Usage\",
      Work in Progress, October 2009.\n   [SEC-GRP-KEY] Behringer, M. and F. Le Faucheur,
      \"Applicability of\n                 Keying Methods for RSVP Security\", Work
      in Progress,\n                 June 2010.\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "Authors' Addresses\n   Francois Le Faucheur\n   Cisco Systems\n   Greenside,
    400 Avenue de Roumanille\n   Sophia Antipolis  06410\n   France\n   Phone: +33
    4 97 23 26 19\n   EMail: flefauch@cisco.com\n   Jukka Manner\n   Aalto University\n
    \  Department of Communications and Networking (Comnet)\n   P.O. Box 13000\n   FIN-00076
    Aalto\n   Finland\n   Phone: +358 9 470 22481\n   EMail: jukka.manner@tkk.fi\n
    \  URI:   http://www.netlab.tkk.fi/~jmanner/\n   Ashok Narayanan\n   Cisco Systems\n
    \  300 Beaver Brook Road\n   Boxborough, MA  01719\n   United States\n   EMail:
    ashokn@cisco.com\n   Allan Guillou\n   SFR\n   40-42 Quai du Point du Jour\n   Boulogne-Billancourt
    \ 92659\n   France\n   EMail: allan.guillou@sfr.com\n   Hemant Malik\n   Bharti
    Airtel, Ltd.\n   4th Floor, Plot No. 16\n   Udyog Vihar, Phase IV\n   Gurgaon,
    \  122015\n   India\n   EMail: Hemant.Malik@airtel.in\n"
  title: Authors' Addresses
