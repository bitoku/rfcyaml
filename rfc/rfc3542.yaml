- title: __initial_text__
  contents:
  - '     Advanced Sockets Application Program Interface (API) for IPv6

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document provides sockets Application Program Interface (API)\
    \ to\n   support \"advanced\" IPv6 applications, as a supplement to a separate\n\
    \   specification, RFC 3493.  The expected applications include Ping,\n   Traceroute,\
    \ routing daemons and the like, which typically use raw\n   sockets to access\
    \ IPv6 or ICMPv6 header fields.  This document\n   proposes some portable interfaces\
    \ for applications that use raw\n   sockets under IPv6.  There are other features\
    \ of IPv6 that some\n   applications will need to access: interface identification\n\
    \   (specifying the outgoing interface and determining the incoming\n   interface),\
    \ IPv6 extension headers, and path Maximum Transmission\n   Unit (MTU) information.\
    \  This document provides API access to these\n   features too.  Additionally,\
    \ some extended interfaces to libraries\n   for the \"r\" commands are defined.\
    \  The extension will provide better\n   backward compatibility to existing implementations\
    \ that are not\n   IPv6-capable.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.   Introduction ..............................................\
    \  3\n   2.   Common Structures and Definitions .........................  5\n\
    \        2.1  The ip6_hdr Structure ................................  6\n    \
    \         2.1.1  IPv6 Next Header Values .......................  6\n        \
    \     2.1.2  IPv6 Extension Headers ........................  7\n            \
    \ 2.1.3  IPv6 Options ..................................  8\n        2.2  The\
    \ icmp6_hdr Structure .............................. 10\n             2.2.1  ICMPv6\
    \ Type and Code Values ................... 10\n             2.2.2  ICMPv6 Neighbor\
    \ Discovery Definitions ......... 11\n             2.2.3  Multicast Listener Discovery\
    \ Definitions ...... 14\n             2.2.4  ICMPv6 Router Renumbering Definitions\
    \ ......... 14\n        2.3  Address Testing Macros ...............................\
    \ 16\n        2.4  Protocols File ....................................... 16\n\
    \   3.   IPv6 Raw Sockets .......................................... 17\n    \
    \    3.1  Checksums ............................................ 18\n        3.2\
    \  ICMPv6 Type Filtering ................................ 19\n        3.3  ICMPv6\
    \ Verification of Received Packets .............. 22\n   4.   Access to IPv6 and\
    \ Extension Headers ...................... 22\n        4.1  TCP Implications .....................................\
    \ 24\n        4.2  UDP and Raw Socket Implications ...................... 25\n\
    \   5.   Extensions to Socket Ancillary Data ....................... 26\n    \
    \    5.1  CMSG_NXTHDR .......................................... 26\n        5.2\
    \  CMSG_SPACE ........................................... 26\n        5.3  CMSG_LEN\
    \ ............................................. 27\n   6.   Packet Information\
    \ ........................................ 27\n        6.1  Specifying/Receiving\
    \ the Interface ................... 28\n        6.2  Specifying/Receiving Source/Destination\
    \ Address ...... 29\n        6.3  Specifying/Receiving the Hop Limit ...................\
    \ 29\n        6.4  Specifying the Next Hop Address ...................... 30\n\
    \        6.5  Specifying/Receiving the Traffic Class value ......... 31\n    \
    \    6.6  Additional Errors with sendmsg() and setsockopt() .... 32\n        6.7\
    \  Summary of Outgoing Interface Selection .............. 32\n   7.   Routing\
    \ Header Option ..................................... 33\n        7.1  inet6_rth_space\
    \ ...................................... 35\n        7.2  inet6_rth_init .......................................\
    \ 35\n        7.3  inet6_rth_add ........................................ 36\n\
    \        7.4  inet6_rth_reverse .................................... 36\n    \
    \    7.5  inet6_rth_segments ................................... 36\n        7.6\
    \  inet6_rth_getaddr .................................... 36\n   8.   Hop-By-Hop\
    \ Options ........................................ 37\n        8.1  Receiving\
    \ Hop-by-Hop Options ......................... 38\n        8.2  Sending Hop-by-Hop\
    \ Options ........................... 38\n   9.   Destination Options .......................................\
    \ 39\n        9.1  Receiving Destination Options ........................ 39\n\
    \        9.2  Sending Destination Options .......................... 39\n   10.\
    \  Hop-by-Hop and Destination Options Processing ............. 40\n        10.1\
    \  inet6_opt_init ...................................... 41\n        10.2  inet6_opt_append\
    \ .................................... 41\n        10.3  inet6_opt_finish ....................................\
    \ 42\n        10.4  inet6_opt_set_val ................................... 42\n\
    \        10.5  inet6_opt_next ...................................... 42\n    \
    \    10.6  inet6_opt_find ...................................... 43\n        10.7\
    \  inet6_opt_get_val ................................... 43\n   11.  Additional\
    \ Advanced API Functions ......................... 44\n        11.1  Sending with\
    \ the Minimum MTU ........................ 44\n        11.2  Sending without Fragmentation\
    \ ....................... 45\n        11.3  Path MTU Discovery and UDP ..........................\
    \ 46\n        11.4  Determining the Current Path MTU .................... 47\n\
    \   12.  Ordering of Ancillary Data and IPv6 Extension Headers ..... 48\n   13.\
    \  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses ..... 50\n   14.  Extended\
    \ interfaces for rresvport, rcmd and rexec ......... 51\n        14.1  rresvport_af\
    \ ........................................ 51\n        14.2  rcmd_af .............................................\
    \ 51\n        14.3  rexec_af ............................................ 52\n\
    \   15.  Summary of New Definitions ................................ 52\n   16.\
    \  Security Considerations ................................... 56\n   17.  Changes\
    \ from RFC 2292 ..................................... 57\n   18.  References ................................................\
    \ 59\n   19.  Acknowledgments ........................................... 59\n\
    \   20.  Appendix A: Ancillary Data Overview ....................... 60\n    \
    \    20.1  The msghdr Structure ................................ 60\n        20.2\
    \  The cmsghdr Structure ............................... 61\n        20.3  Ancillary\
    \ Data Object Macros ........................ 62\n              20.3.1  CMSG_FIRSTHDR\
    \ ............................... 63\n              20.3.2  CMSG_NXTHDR .................................\
    \ 64\n              20.3.3  CMSG_DATA ................................... 65\n\
    \              20.3.4  CMSG_SPACE .................................. 65\n    \
    \          20.3.5  CMSG_LEN .................................... 65\n   21.  Appendix\
    \ B: Examples Using the inet6_rth_XXX() Functions .. 65\n        21.1  Sending\
    \ a Routing Header ............................ 65\n        21.2  Receiving Routing\
    \ Headers ........................... 70\n   22.  Appendix C: Examples Using the\
    \ inet6_opt_XXX() Functions .. 72\n        22.1  Building Options ....................................\
    \ 72\n        22.2  Parsing Received Options ............................ 74\n\
    \   23.  Authors' Addresses ........................................ 76\n   24.\
    \  Full Copyright Statement .................................. 77\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   A separate specification [RFC-3493] contains changes to\
    \ the sockets\n   API to support IP version 6.  Those changes are for TCP and\
    \ UDP-based\n   applications.  This document defines some of the \"advanced\"\
    \ features\n   of the sockets API that are required for applications to take\n\
    \   advantage of additional features of IPv6.\n   Today, the portability of applications\
    \ using IPv4 raw sockets is\n   quite high, but this is mainly because most IPv4\
    \ implementations\n   started from a common base (the Berkeley source code) or\
    \ at least\n   started with the Berkeley header files.  This allows programs such\
    \ as\n   Ping and Traceroute, for example, to compile with minimal effort on\n\
    \   many hosts that support the sockets API.  With IPv6, however, there\n   is\
    \ no common source code base that implementors are starting from,\n   and the\
    \ possibility for divergence at this level between different\n   implementations\
    \ is high.  To avoid a complete lack of portability\n   amongst applications that\
    \ use raw IPv6 sockets, some standardization\n   is necessary.\n   There are also\
    \ features from the basic IPv6 specification that are\n   not addressed in [RFC-3493]:\
    \ sending and receiving Routing headers,\n   Hop-by-Hop options, and Destination\
    \ options, specifying the outgoing\n   interface, being told of the receiving\
    \ interface, and control of path\n   MTU information.\n   This document updates\
    \ and replaces RFC 2292.  This revision is based\n   on implementation experience\
    \ of RFC 2292, as well as some additional\n   extensions that have been found\
    \ to be useful through the IPv6\n   deployment.  Note, however, that further work\
    \ on this document may\n   still be needed.  Once the API specification becomes\
    \ mature and is\n   deployed among implementations, it may be formally standardized\
    \ by a\n   more appropriate body, such as has been done with the Basic API\n \
    \  [RFC-3493].\n   This document can be divided into the following main sections.\n\
    \   1. Definitions of the basic constants and structures required for\n      applications\
    \ to use raw IPv6 sockets.  This includes structure\n      definitions for the\
    \ IPv6 and ICMPv6 headers and all associated\n      constants (e.g., values for\
    \ the Next Header field).\n   2. Some basic semantic definitions for IPv6 raw\
    \ sockets.  For\n      example, a raw ICMPv4 socket requires the application to\
    \ calculate\n      and store the ICMPv4 header checksum.  But with IPv6 this would\n\
    \      require the application to choose the source IPv6 address because\n   \
    \   the source address is part of the pseudo header that ICMPv6 now\n      uses\
    \ for its checksum computation.  It should be defined that with\n      a raw ICMPv6\
    \ socket the kernel always calculates and stores the\n      ICMPv6 header checksum.\n\
    \   3. Packet information: how applications can obtain the received\n      interface,\
    \ destination address, and received hop limit, along with\n      specifying these\
    \ values on a per-packet basis.  There are a class\n      of applications that\
    \ need this capability and the technique should\n      be portable.\n   4. Access\
    \ to the optional Routing header, Hop-by-Hop options, and\n      Destination options\
    \ extension headers.\n   5. Additional features required for improved IPv6 application\n\
    \      portability.\n   The packet information along with access to the extension\
    \ headers\n   (Routing header, Hop-by-Hop options, and Destination options) are\n\
    \   specified using the \"ancillary data\" fields that were added to the\n   4.3BSD\
    \ Reno sockets API in 1990.  The reason is that these ancillary\n   data fields\
    \ are part of the Posix standard [POSIX] and should\n   therefore be adopted by\
    \ most vendors.\n   This document does not address application access to either\
    \ the\n   authentication header or the encapsulating security payload header.\n\
    \   Many examples in this document omit error checking in favor of\n   brevity\
    \ and clarity.\n   We note that some of the functions and socket options defined\
    \ in this\n   document may have error returns that are not defined in this\n \
    \  document.  Some of these possible error returns will be recognized\n   only\
    \ as implementations proceed.\n   Datatypes in this document follow the Posix\
    \ format: intN_t means a\n   signed integer of exactly N bits (e.g., int16_t)\
    \ and uintN_t means an\n   unsigned integer of exactly N bits (e.g., uint32_t).\n\
    \   Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and\n   ARPv4\
    \ to avoid any confusion with the newer ICMPv6 protocol.\n"
- title: 2.  Common Structures and Definitions
  contents:
  - "2.  Common Structures and Definitions\n   Many advanced applications examine\
    \ fields in the IPv6 header and set\n   and examine fields in the various ICMPv6\
    \ headers.  Common structure\n   definitions for these protocol headers are required,\
    \ along with\n   common constant definitions for the structure members.\n   This\
    \ API assumes that the fields in the protocol headers are left in\n   the network\
    \ byte order, which is big-endian for the Internet\n   protocols.  If not, then\
    \ either these constants or the fields being\n   tested must be converted at run-time,\
    \ using something like htons() or\n   htonl().\n   Two new header files are defined:\
    \ <netinet/ip6.h> and\n   <netinet/icmp6.h>.\n   When an include file is specified,\
    \ that include file is allowed to\n   include other files that do the actual declaration\
    \ or definition.\n"
- title: 2.1.  The ip6_hdr Structure
  contents:
  - "2.1.  The ip6_hdr Structure\n   The following structure is defined as a result\
    \ of including\n   <netinet/ip6.h>.  Note that this is a new header.\n      struct\
    \ ip6_hdr {\n        union {\n          struct ip6_hdrctl {\n            uint32_t\
    \ ip6_un1_flow; /* 4 bits version, 8 bits TC, 20 bits\n                      \
    \                flow-ID */\n            uint16_t ip6_un1_plen; /* payload length\
    \ */\n            uint8_t  ip6_un1_nxt;  /* next header */\n            uint8_t\
    \  ip6_un1_hlim; /* hop limit */\n          } ip6_un1;\n          uint8_t ip6_un2_vfc;\
    \     /* 4 bits version, top 4 bits\n                                      tclass\
    \ */\n        } ip6_ctlun;\n        struct in6_addr ip6_src;   /* source address\
    \ */\n        struct in6_addr ip6_dst;   /* destination address */\n      };\n\
    \      #define ip6_vfc   ip6_ctlun.ip6_un2_vfc\n      #define ip6_flow  ip6_ctlun.ip6_un1.ip6_un1_flow\n\
    \      #define ip6_plen  ip6_ctlun.ip6_un1.ip6_un1_plen\n      #define ip6_nxt\
    \   ip6_ctlun.ip6_un1.ip6_un1_nxt\n      #define ip6_hlim  ip6_ctlun.ip6_un1.ip6_un1_hlim\n\
    \      #define ip6_hops  ip6_ctlun.ip6_un1.ip6_un1_hlim\n"
- title: 2.1.1.  IPv6 Next Header Values
  contents:
  - "2.1.1.  IPv6 Next Header Values\n   IPv6 defines many new values for the Next\
    \ Header field.  The\n   following constants are defined as a result of including\n\
    \   <netinet/in.h>.\n      #define IPPROTO_HOPOPTS   0   /* IPv6 Hop-by-Hop options\
    \ */\n      #define IPPROTO_IPV6     41   /* IPv6 header */\n      #define IPPROTO_ROUTING\
    \  43   /* IPv6 Routing header */\n      #define IPPROTO_FRAGMENT 44   /* IPv6\
    \ fragment header */\n      #define IPPROTO_ESP      50   /* encapsulating security\
    \ payload */\n      #define IPPROTO_AH       51   /* authentication header */\n\
    \      #define IPPROTO_ICMPV6   58   /* ICMPv6 */\n      #define IPPROTO_NONE\
    \     59   /* IPv6 no next header */\n      #define IPPROTO_DSTOPTS  60   /* IPv6\
    \ Destination options */\n   Berkeley-derived IPv4 implementations also define\
    \ IPPROTO_IP to be 0.\n   This should not be a problem since IPPROTO_IP is used\
    \ only with IPv4\n   sockets and IPPROTO_HOPOPTS only with IPv6 sockets.\n"
- title: 2.1.2.  IPv6 Extension Headers
  contents:
  - "2.1.2.  IPv6 Extension Headers\n   Six extension headers are defined for IPv6.\
    \  We define structures for\n   all except the Authentication header and Encapsulating\
    \ Security\n   Payload header, both of which are beyond the scope of this document.\n\
    \   The following structures are defined as a result of including\n   <netinet/ip6.h>.\n\
    \      /* Hop-by-Hop options header */\n      struct ip6_hbh {\n        uint8_t\
    \  ip6h_nxt;        /* next header */\n        uint8_t  ip6h_len;        /* length\
    \ in units of 8 octets */\n          /* followed by options */\n      };\n   \
    \   /* Destination options header */\n      struct ip6_dest {\n        uint8_t\
    \  ip6d_nxt;        /* next header */\n        uint8_t  ip6d_len;        /* length\
    \ in units of 8 octets */\n          /* followed by options */\n      };\n   \
    \   /* Routing header */\n      struct ip6_rthdr {\n        uint8_t  ip6r_nxt;\
    \        /* next header */\n        uint8_t  ip6r_len;        /* length in units\
    \ of 8 octets */\n        uint8_t  ip6r_type;       /* routing type */\n     \
    \   uint8_t  ip6r_segleft;    /* segments left */\n          /* followed by routing\
    \ type specific data */\n      };\n      /* Type 0 Routing header */\n      struct\
    \ ip6_rthdr0 {\n        uint8_t  ip6r0_nxt;       /* next header */\n        uint8_t\
    \  ip6r0_len;       /* length in units of 8 octets */\n        uint8_t  ip6r0_type;\
    \      /* always zero */\n        uint8_t  ip6r0_segleft;   /* segments left */\n\
    \        uint32_t ip6r0_reserved;  /* reserved field */\n          /* followed\
    \ by up to 127 struct in6_addr */\n      };\n      /* Fragment header */\n   \
    \   struct ip6_frag {\n        uint8_t   ip6f_nxt;       /* next header */\n \
    \       uint8_t   ip6f_reserved;  /* reserved field */\n        uint16_t  ip6f_offlg;\
    \     /* offset, reserved, and flag */\n        uint32_t  ip6f_ident;     /* identification\
    \ */\n      };\n      #if     BYTE_ORDER == BIG_ENDIAN\n      #define IP6F_OFF_MASK\
    \       0xfff8  /* mask out offset from\n                                    \
    \         ip6f_offlg */\n      #define IP6F_RESERVED_MASK  0x0006  /* reserved\
    \ bits in\n                                             ip6f_offlg */\n      #define\
    \ IP6F_MORE_FRAG      0x0001  /* more-fragments flag */\n      #else   /* BYTE_ORDER\
    \ == LITTLE_ENDIAN */\n      #define IP6F_OFF_MASK       0xf8ff  /* mask out offset\
    \ from\n                                             ip6f_offlg */\n      #define\
    \ IP6F_RESERVED_MASK  0x0600  /* reserved bits in\n                          \
    \                   ip6f_offlg */\n      #define IP6F_MORE_FRAG      0x0100  /*\
    \ more-fragments flag */\n      #endif\n"
- title: 2.1.3.  IPv6 Options
  contents:
  - "2.1.3.  IPv6 Options\n   Several options are defined for IPv6, and we define\
    \ structures and\n   macro definitions for some of them below.  The following\
    \ structures\n   are defined as a result of including <netinet/ip6.h>.\n     \
    \ /* IPv6 options */\n      struct ip6_opt {\n        uint8_t  ip6o_type;\n  \
    \      uint8_t  ip6o_len;\n      };\n      /*\n       * The high-order 3 bits\
    \ of the option type define the behavior\n       * when processing an unknown\
    \ option and whether or not the option\n       * content changes in flight.\n\
    \       */\n      #define IP6OPT_TYPE(o)        ((o) & 0xc0)\n      #define IP6OPT_TYPE_SKIP\
    \      0x00\n      #define IP6OPT_TYPE_DISCARD   0x40\n      #define IP6OPT_TYPE_FORCEICMP\
    \ 0x80\n      #define IP6OPT_TYPE_ICMP      0xc0\n      #define IP6OPT_MUTABLE\
    \        0x20\n      #define IP6OPT_PAD1           0x00  /* 00 0 00000 */\n  \
    \    #define IP6OPT_PADN           0x01  /* 00 0 00001 */\n      #define IP6OPT_JUMBO\
    \          0xc2  /* 11 0 00010 */\n      #define IP6OPT_NSAP_ADDR      0xc3  /*\
    \ 11 0 00011 */\n      #define IP6OPT_TUNNEL_LIMIT   0x04  /* 00 0 00100 */\n\
    \      #define IP6OPT_ROUTER_ALERT   0x05  /* 00 0 00101 */\n      /* Jumbo Payload\
    \ Option */\n      struct ip6_opt_jumbo {\n        uint8_t  ip6oj_type;\n    \
    \    uint8_t  ip6oj_len;\n        uint8_t  ip6oj_jumbo_len[4];\n      };\n   \
    \   #define IP6OPT_JUMBO_LEN   6\n      /* NSAP Address Option */\n      struct\
    \ ip6_opt_nsap {\n        uint8_t  ip6on_type;\n        uint8_t  ip6on_len;\n\
    \        uint8_t  ip6on_src_nsap_len;\n        uint8_t  ip6on_dst_nsap_len;\n\
    \          /* followed by source NSAP */\n          /* followed by destination\
    \ NSAP */\n      };\n      /* Tunnel Limit Option */\n      struct ip6_opt_tunnel\
    \ {\n        uint8_t  ip6ot_type;\n        uint8_t  ip6ot_len;\n        uint8_t\
    \  ip6ot_encap_limit;\n      };\n      /* Router Alert Option */\n      struct\
    \ ip6_opt_router {\n        uint8_t  ip6or_type;\n        uint8_t  ip6or_len;\n\
    \        uint8_t  ip6or_value[2];\n      };\n      /* Router alert values (in\
    \ network byte order) */\n      #ifdef _BIG_ENDIAN\n      #define IP6_ALERT_MLD\
    \      0x0000\n      #define IP6_ALERT_RSVP     0x0001\n      #define  IP6_ALERT_AN\
    \      0x0002\n      #else\n      #define IP6_ALERT_MLD      0x0000\n      #define\
    \ IP6_ALERT_RSVP     0x0100\n      #define IP6_ALERT_AN       0x0200\n      #endif\n"
- title: 2.2.  The icmp6_hdr Structure
  contents:
  - "2.2.  The icmp6_hdr Structure\n   The ICMPv6 header is needed by numerous IPv6\
    \ applications including\n   Ping, Traceroute, router discovery daemons, and neighbor\
    \ discovery\n   daemons.  The following structure is defined as a result of including\n\
    \   <netinet/icmp6.h>.  Note that this is a new header.\n      struct icmp6_hdr\
    \ {\n        uint8_t     icmp6_type;   /* type field */\n        uint8_t     icmp6_code;\
    \   /* code field */\n        uint16_t    icmp6_cksum;  /* checksum field */\n\
    \        union {\n          uint32_t  icmp6_un_data32[1]; /* type-specific field\
    \ */\n          uint16_t  icmp6_un_data16[2]; /* type-specific field */\n    \
    \      uint8_t   icmp6_un_data8[4];  /* type-specific field */\n        } icmp6_dataun;\n\
    \      };\n      #define icmp6_data32    icmp6_dataun.icmp6_un_data32\n      #define\
    \ icmp6_data16    icmp6_dataun.icmp6_un_data16\n      #define icmp6_data8    \
    \ icmp6_dataun.icmp6_un_data8\n      #define icmp6_pptr      icmp6_data32[0] \
    \ /* parameter prob */\n      #define icmp6_mtu       icmp6_data32[0]  /* packet\
    \ too big */\n      #define icmp6_id        icmp6_data16[0]  /* echo request/reply\
    \ */\n      #define icmp6_seq       icmp6_data16[1]  /* echo request/reply */\n\
    \      #define icmp6_maxdelay  icmp6_data16[0]  /* mcast group\n             \
    \                                     membership */\n"
- title: 2.2.1.  ICMPv6 Type and Code Values
  contents:
  - "2.2.1.  ICMPv6 Type and Code Values\n   In addition to a common structure for\
    \ the ICMPv6 header, common\n   definitions are required for the ICMPv6 type and\
    \ code fields.  The\n   following constants are also defined as a result of including\n\
    \   <netinet/icmp6.h>.\n      #define ICMP6_DST_UNREACH             1\n      #define\
    \ ICMP6_PACKET_TOO_BIG          2\n      #define ICMP6_TIME_EXCEEDED         \
    \  3\n      #define ICMP6_PARAM_PROB              4\n      #define ICMP6_INFOMSG_MASK\
    \  0x80    /* all informational\n                                            \
    \ messages */\n      #define ICMP6_ECHO_REQUEST          128\n      #define ICMP6_ECHO_REPLY\
    \            129\n      #define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to\n\
    \                                                 destination */\n      #define\
    \ ICMP6_DST_UNREACH_ADMIN       1 /* communication with\n                    \
    \                             destination */\n                               \
    \               /* admin. prohibited */\n      #define ICMP6_DST_UNREACH_BEYONDSCOPE\
    \ 2 /* beyond scope of source\n                                              \
    \   address */\n      #define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable\
    \ */\n      #define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */\n      #define\
    \ ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in\n                     \
    \                            transit */\n      #define ICMP6_TIME_EXCEED_REASSEMBLY\
    \  1 /* Reassembly time out */\n      #define ICMP6_PARAMPROB_HEADER        0\
    \ /* erroneous header\n                                                 field\
    \ */\n      #define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized\n        \
    \                                         Next Header */\n      #define ICMP6_PARAMPROB_OPTION\
    \        2 /* unrecognized\n                                                 IPv6\
    \ option */\n   The five ICMP message types defined by IPv6 neighbor discovery\
    \ (133-\n   137) are defined in the next section.\n"
- title: 2.2.2.  ICMPv6 Neighbor Discovery Definitions
  contents:
  - "2.2.2.  ICMPv6 Neighbor Discovery Definitions\n   The following structures and\
    \ definitions are defined as a result of\n   including <netinet/icmp6.h>.\n  \
    \    #define ND_ROUTER_SOLICIT           133\n      #define ND_ROUTER_ADVERT \
    \           134\n      #define ND_NEIGHBOR_SOLICIT         135\n      #define\
    \ ND_NEIGHBOR_ADVERT          136\n      #define ND_REDIRECT                 137\n\
    \      struct nd_router_solicit {     /* router solicitation */\n        struct\
    \ icmp6_hdr  nd_rs_hdr;\n          /* could be followed by options */\n      };\n\
    \      #define nd_rs_type               nd_rs_hdr.icmp6_type\n      #define nd_rs_code\
    \               nd_rs_hdr.icmp6_code\n      #define nd_rs_cksum              nd_rs_hdr.icmp6_cksum\n\
    \      #define nd_rs_reserved           nd_rs_hdr.icmp6_data32[0]\n      struct\
    \ nd_router_advert {      /* router advertisement */\n        struct icmp6_hdr\
    \  nd_ra_hdr;\n        uint32_t   nd_ra_reachable;   /* reachable time */\n  \
    \      uint32_t   nd_ra_retransmit;  /* retransmit timer */\n          /* could\
    \ be followed by options */\n      };\n      #define nd_ra_type              \
    \ nd_ra_hdr.icmp6_type\n      #define nd_ra_code               nd_ra_hdr.icmp6_code\n\
    \      #define nd_ra_cksum              nd_ra_hdr.icmp6_cksum\n      #define nd_ra_curhoplimit\
    \        nd_ra_hdr.icmp6_data8[0]\n      #define nd_ra_flags_reserved     nd_ra_hdr.icmp6_data8[1]\n\
    \      #define ND_RA_FLAG_MANAGED       0x80\n      #define ND_RA_FLAG_OTHER \
    \        0x40\n      #define nd_ra_router_lifetime    nd_ra_hdr.icmp6_data16[1]\n\
    \      struct nd_neighbor_solicit {   /* neighbor solicitation */\n        struct\
    \ icmp6_hdr  nd_ns_hdr;\n        struct in6_addr   nd_ns_target; /* target address\
    \ */\n          /* could be followed by options */\n      };\n      #define nd_ns_type\
    \               nd_ns_hdr.icmp6_type\n      #define nd_ns_code               nd_ns_hdr.icmp6_code\n\
    \      #define nd_ns_cksum              nd_ns_hdr.icmp6_cksum\n      #define nd_ns_reserved\
    \           nd_ns_hdr.icmp6_data32[0]\n      struct nd_neighbor_advert {    /*\
    \ neighbor advertisement */\n        struct icmp6_hdr  nd_na_hdr;\n        struct\
    \ in6_addr   nd_na_target; /* target address */\n          /* could be followed\
    \ by options */\n      };\n      #define nd_na_type               nd_na_hdr.icmp6_type\n\
    \      #define nd_na_code               nd_na_hdr.icmp6_code\n      #define nd_na_cksum\
    \              nd_na_hdr.icmp6_cksum\n      #define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]\n\
    \      #if     BYTE_ORDER == BIG_ENDIAN\n      #define ND_NA_FLAG_ROUTER     \
    \   0x80000000\n      #define ND_NA_FLAG_SOLICITED     0x40000000\n      #define\
    \ ND_NA_FLAG_OVERRIDE      0x20000000\n      #else   /* BYTE_ORDER == LITTLE_ENDIAN\
    \ */\n      #define ND_NA_FLAG_ROUTER        0x00000080\n      #define ND_NA_FLAG_SOLICITED\
    \     0x00000040\n      #define ND_NA_FLAG_OVERRIDE      0x00000020\n      #endif\n\
    \      struct nd_redirect {           /* redirect */\n        struct icmp6_hdr\
    \  nd_rd_hdr;\n        struct in6_addr   nd_rd_target; /* target address */\n\
    \        struct in6_addr   nd_rd_dst;    /* destination address */\n         \
    \ /* could be followed by options */\n      };\n      #define nd_rd_type     \
    \          nd_rd_hdr.icmp6_type\n      #define nd_rd_code               nd_rd_hdr.icmp6_code\n\
    \      #define nd_rd_cksum              nd_rd_hdr.icmp6_cksum\n      #define nd_rd_reserved\
    \           nd_rd_hdr.icmp6_data32[0]\n      struct nd_opt_hdr {         /* Neighbor\
    \ discovery option header */\n        uint8_t  nd_opt_type;\n        uint8_t \
    \ nd_opt_len;      /* in units of 8 octets */\n          /* followed by option\
    \ specific data */\n      };\n      #define  ND_OPT_SOURCE_LINKADDR       1\n\
    \      #define  ND_OPT_TARGET_LINKADDR       2\n      #define  ND_OPT_PREFIX_INFORMATION\
    \    3\n      #define  ND_OPT_REDIRECTED_HEADER     4\n      #define  ND_OPT_MTU\
    \                   5\n      struct nd_opt_prefix_info {    /* prefix information\
    \ */\n        uint8_t   nd_opt_pi_type;\n        uint8_t   nd_opt_pi_len;\n  \
    \      uint8_t   nd_opt_pi_prefix_len;\n        uint8_t   nd_opt_pi_flags_reserved;\n\
    \        uint32_t  nd_opt_pi_valid_time;\n        uint32_t  nd_opt_pi_preferred_time;\n\
    \        uint32_t  nd_opt_pi_reserved2;\n        struct in6_addr  nd_opt_pi_prefix;\n\
    \      };\n      #define ND_OPT_PI_FLAG_ONLINK        0x80\n      #define ND_OPT_PI_FLAG_AUTO\
    \          0x40\n      struct nd_opt_rd_hdr {         /* redirected header */\n\
    \        uint8_t   nd_opt_rh_type;\n        uint8_t   nd_opt_rh_len;\n       \
    \ uint16_t  nd_opt_rh_reserved1;\n        uint32_t  nd_opt_rh_reserved2;\n   \
    \       /* followed by IP header and data */\n      };\n      struct nd_opt_mtu\
    \ {            /* MTU option */\n        uint8_t   nd_opt_mtu_type;\n        uint8_t\
    \   nd_opt_mtu_len;\n        uint16_t  nd_opt_mtu_reserved;\n        uint32_t\
    \  nd_opt_mtu_mtu;\n      };\n   We note that the nd_na_flags_reserved flags have\
    \ the same byte\n   ordering problems as we showed with ip6f_offlg.\n"
- title: 2.2.3.  Multicast Listener Discovery Definitions
  contents:
  - "2.2.3.  Multicast Listener Discovery Definitions\n   The following structures\
    \ and definitions are defined as a result of\n   including <netinet/icmp6.h>.\n\
    \      #define MLD_LISTENER_QUERY          130\n      #define MLD_LISTENER_REPORT\
    \         131\n      #define MLD_LISTENER_REDUCTION      132\n      struct mld_hdr\
    \ {\n        struct icmp6_hdr  mld_icmp6_hdr;\n        struct in6_addr   mld_addr;\
    \ /* multicast address */\n      };\n      #define mld_type                 mld_icmp6_hdr.icmp6_type\n\
    \      #define mld_code                 mld_icmp6_hdr.icmp6_code\n      #define\
    \ mld_cksum                mld_icmp6_hdr.icmp6_cksum\n      #define mld_maxdelay\
    \             mld_icmp6_hdr.icmp6_data16[0]\n      #define mld_reserved      \
    \       mld_icmp6_hdr.icmp6_data16[1]\n"
- title: 2.2.4.  ICMPv6 Router Renumbering Definitions
  contents:
  - "2.2.4.  ICMPv6 Router Renumbering Definitions\n   The following structures and\
    \ definitions are defined as a result of\n   including <netinet/icmp6.h>.\n  \
    \    #define ICMP6_ROUTER_RENUMBERING    138   /* router renumbering */\n    \
    \  struct icmp6_router_renum {  /* router renumbering header */\n        struct\
    \ icmp6_hdr  rr_hdr;\n        uint8_t           rr_segnum;\n        uint8_t  \
    \         rr_flags;\n        uint16_t          rr_maxdelay;\n        uint32_t\
    \          rr_reserved;\n      };\n      #define rr_type                  rr_hdr.icmp6_type\n\
    \      #define rr_code                  rr_hdr.icmp6_code\n      #define rr_cksum\
    \                 rr_hdr.icmp6_cksum\n      #define rr_seqnum                rr_hdr.icmp6_data32[0]\n\
    \      /* Router renumbering flags */\n      #define ICMP6_RR_FLAGS_TEST     \
    \   0x80\n      #define ICMP6_RR_FLAGS_REQRESULT   0x40\n      #define ICMP6_RR_FLAGS_FORCEAPPLY\
    \  0x20\n      #define ICMP6_RR_FLAGS_SPECSITE    0x10\n      #define ICMP6_RR_FLAGS_PREVDONE\
    \    0x08\n      struct rr_pco_match {    /* match prefix part */\n        uint8_t\
    \          rpm_code;\n        uint8_t          rpm_len;\n        uint8_t     \
    \     rpm_ordinal;\n        uint8_t          rpm_matchlen;\n        uint8_t  \
    \        rpm_minlen;\n        uint8_t          rpm_maxlen;\n        uint16_t \
    \        rpm_reserved;\n        struct in6_addr  rpm_prefix;\n      };\n     \
    \ /* PCO code values */\n      #define RPM_PCO_ADD              1\n      #define\
    \ RPM_PCO_CHANGE           2\n      #define RPM_PCO_SETGLOBAL        3\n     \
    \ struct rr_pco_use {    /* use prefix part */\n        uint8_t          rpu_uselen;\n\
    \        uint8_t          rpu_keeplen;\n        uint8_t          rpu_ramask;\n\
    \        uint8_t          rpu_raflags;\n        uint32_t         rpu_vltime;\n\
    \        uint32_t         rpu_pltime;\n        uint32_t         rpu_flags;\n \
    \       struct in6_addr  rpu_prefix;\n      };\n      #define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK\
    \   0x20\n      #define ICMP6_RR_PCOUSE_RAFLAGS_AUTO     0x10\n      #if BYTE_ORDER\
    \ == BIG_ENDIAN\n      #define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80000000\n \
    \     #define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40000000\n      #elif BYTE_ORDER\
    \ == LITTLE_ENDIAN\n      #define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80\n    \
    \  #define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40\n      #endif\n      struct rr_result\
    \ {    /* router renumbering result message */\n        uint16_t         rrr_flags;\n\
    \        uint8_t          rrr_ordinal;\n        uint8_t          rrr_matchedlen;\n\
    \        uint32_t         rrr_ifid;\n        struct in6_addr  rrr_prefix;\n  \
    \    };\n      #if BYTE_ORDER == BIG_ENDIAN\n      #define ICMP6_RR_RESULT_FLAGS_OOB\
    \        0x0002\n      #define ICMP6_RR_RESULT_FLAGS_FORBIDDEN  0x0001\n     \
    \ #elif BYTE_ORDER == LITTLE_ENDIAN\n      #define ICMP6_RR_RESULT_FLAGS_OOB \
    \       0x0200\n      #define ICMP6_RR_RESULT_FLAGS_FORBIDDEN  0x0100\n      #endif\n"
- title: 2.3.  Address Testing Macros
  contents:
  - "2.3.  Address Testing Macros\n   The basic API ([RFC-3493]) defines some macros\
    \ for testing an IPv6\n   address for certain properties.  This API extends those\
    \ definitions\n   with additional address testing macros, defined as a result\
    \ of\n   including <netinet/in.h>.\n      int  IN6_ARE_ADDR_EQUAL(const struct\
    \ in6_addr *,\n                              const struct in6_addr *);\n   This\
    \ macro returns non-zero if the addresses are equal; otherwise it\n   returns\
    \ zero.\n"
- title: 2.4.  Protocols File
  contents:
  - "2.4.  Protocols File\n   Many hosts provide the file /etc/protocols that contains\
    \ the names of\n   the various IP protocols and their protocol number (e.g., the\
    \ value\n   of the protocol field in the IPv4 header for that protocol, such as\
    \ 1\n   for ICMP).  Some programs then call the function getprotobyname() to\n\
    \   obtain the protocol value that is then specified as the third\n   argument\
    \ to the socket() function.  For example, the Ping program\n   contains code of\
    \ the form\n      struct protoent  *proto;\n      proto = getprotobyname(\"icmp\"\
    );\n      s = socket(AF_INET, SOCK_RAW, proto->p_proto);\n   Common names are\
    \ required for the new IPv6 protocols in this file, to\n   provide portability\
    \ of applications that call the getprotoXXX()\n   functions.\n   We define the\
    \ following protocol names with the values shown.  These\n   are taken under http://www.iana.org/numbers.html.\n\
    \      hopopt           0    # hop-by-hop options for ipv6\n      ipv6       \
    \     41    # ipv6\n      ipv6-route      43    # routing header for ipv6\n  \
    \    ipv6-frag       44    # fragment header for ipv6\n      esp             50\
    \    # encapsulating security payload for ipv6\n      ah              51    #\
    \ authentication header for ipv6\n      ipv6-icmp       58    # icmp for ipv6\n\
    \      ipv6-nonxt      59    # no next header for ipv6\n      ipv6-opts      \
    \ 60    # destination options for ipv6\n"
- title: 3.  IPv6 Raw Sockets
  contents:
  - "3.  IPv6 Raw Sockets\n   Raw sockets bypass the transport layer (TCP or UDP).\
    \  With IPv4, raw\n   sockets are used to access ICMPv4, IGMPv4, and to read and\
    \ write IPv4\n   datagrams containing a protocol field that the kernel does not\n\
    \   process.  An example of the latter is a routing daemon for OSPF,\n   since\
    \ it uses IPv4 protocol field 89.  With IPv6 raw sockets will be\n   used for\
    \ ICMPv6 and to read and write IPv6 datagrams containing a\n   Next Header field\
    \ that the kernel does not process.  Examples of the\n   latter are a routing\
    \ daemon for OSPF for IPv6 and RSVP (protocol\n   field 46).\n   All data sent\
    \ via raw sockets must be in network byte order and all\n   data received via\
    \ raw sockets will be in network byte order.  This\n   differs from the IPv4 raw\
    \ sockets, which did not specify a byte\n   ordering and used the host's byte\
    \ order for certain IP header fields.\n   Another difference from IPv4 raw sockets\
    \ is that complete packets\n   (that is, IPv6 packets with extension headers)\
    \ cannot be sent or\n   received using the IPv6 raw sockets API.  Instead, ancillary\
    \ data\n   objects are used to transfer the extension headers and hoplimit\n \
    \  information, as described in Section 6.  Should an application need\n   access\
    \ to the complete IPv6 packet, some other technique, such as the\n   datalink\
    \ interfaces BPF or DLPI, must be used.\n   All fields except the flow label in\
    \ the IPv6 header that an\n   application might want to change (i.e., everything\
    \ other than the\n   version number) can be modified using ancillary data and/or\
    \ socket\n   options by the application for output.  All fields except the flow\n\
    \   label in a received IPv6 header (other than the version number and\n   Next\
    \ Header fields) and all extension headers that an application\n   might want\
    \ to know are also made available to the application as\n   ancillary data on\
    \ input.  Hence there is no need for a socket option\n   similar to the IPv4 IP_HDRINCL\
    \ socket option and on receipt the\n   application will only receive the payload\
    \ i.e., the data after the\n   IPv6 header and all the extension headers.\n  \
    \ This API does not define access to the flow label field, because\n   today there\
    \ is no standard usage of the field.\n   When writing to a raw socket the kernel\
    \ will automatically fragment\n   the packet if its size exceeds the path MTU,\
    \ inserting the required\n   fragment headers.  On input the kernel reassembles\
    \ received\n   fragments, so the reader of a raw socket never sees any fragment\n\
    \   headers.\n   When we say \"an ICMPv6 raw socket\" we mean a socket created\
    \ by\n   calling the socket function with the three arguments AF_INET6,\n   SOCK_RAW,\
    \ and IPPROTO_ICMPV6.\n   Most IPv4 implementations give special treatment to\
    \ a raw socket\n   created with a third argument to socket() of IPPROTO_RAW, whose\
    \ value\n   is normally 255, to have it mean that the application will send down\n\
    \   complete packets including the IPv4 header.  (Note: This feature was\n   added\
    \ to IPv4 in 1988 by Van Jacobson to support traceroute, allowing\n   a complete\
    \ IP header to be passed by the application, before the\n   IP_HDRINCL socket\
    \ option was added.)  We note that IPPROTO_RAW has no\n   special meaning to an\
    \ IPv6 raw socket (and the IANA currently\n   reserves the value of 255 when used\
    \ as a next-header field).\n"
- title: 3.1.  Checksums
  contents:
  - "3.1.  Checksums\n   The kernel will calculate and insert the ICMPv6 checksum\
    \ for ICMPv6\n   raw sockets, since this checksum is mandatory.\n   For other\
    \ raw IPv6 sockets (that is, for raw IPv6 sockets created\n   with a third argument\
    \ other than IPPROTO_ICMPV6), the application\n   must set the new IPV6_CHECKSUM\
    \ socket option to have the kernel (1)\n   compute and store a checksum for output,\
    \ and (2) verify the received\n   checksum on input, discarding the packet if\
    \ the checksum is in error.\n   This option prevents applications from having\
    \ to perform source\n   address selection on the packets they send.  The checksum\
    \ will\n   incorporate the IPv6 pseudo-header, defined in Section 8.1 of [RFC-\n\
    \   2460].  This new socket option also specifies an integer offset into\n   the\
    \ user data of where the checksum is located.\n      int  offset = 2;\n      setsockopt(fd,\
    \ IPPROTO_IPV6, IPV6_CHECKSUM, &offset,\n                 sizeof(offset));\n \
    \  By default, this socket option is disabled.  Setting the offset to -1\n   also\
    \ disables the option.  By disabled we mean (1) the kernel will\n   not calculate\
    \ and store a checksum for outgoing packets, and (2) the\n   kernel will not verify\
    \ a checksum for received packets.\n   This option assumes the use of the 16-bit\
    \ one's complement of the\n   one's complement sum as the checksum algorithm and\
    \ that the checksum\n   field is aligned on a 16-bit boundary.  Thus, specifying\
    \ a positive\n   odd value as offset is invalid, and setsockopt() will fail for\
    \ such\n   offset values.\n   An attempt to set IPV6_CHECKSUM for an ICMPv6 socket\
    \ will fail.\n   Also, an attempt to set or get IPV6_CHECKSUM for a non-raw IPv6\n\
    \   socket will fail.\n   (Note: Since the checksum is always calculated by the\
    \ kernel for an\n   ICMPv6 socket, applications are not able to generate ICMPv6\
    \ packets\n   with incorrect checksums (presumably for testing purposes) using\
    \ this\n   API.)\n"
- title: 3.2.  ICMPv6 Type Filtering
  contents:
  - "3.2.  ICMPv6 Type Filtering\n   ICMPv4 raw sockets receive most ICMPv4 messages\
    \ received by the\n   kernel.  (We say \"most\" and not \"all\" because Berkeley-derived\n\
    \   kernels never pass echo requests, timestamp requests, or address mask\n  \
    \ requests to a raw socket.  Instead these three messages are processed\n   entirely\
    \ by the kernel.)  But ICMPv6 is a superset of ICMPv4, also\n   including the\
    \ functionality of IGMPv4 and ARPv4.  This means that an\n   ICMPv6 raw socket\
    \ can potentially receive many more messages than\n   would be received with an\
    \ ICMPv4 raw socket: ICMP messages similar to\n   ICMPv4, along with neighbor\
    \ solicitations, neighbor advertisements,\n   and the three multicast listener\
    \ discovery messages.\n   Most applications using an ICMPv6 raw socket care about\
    \ only a small\n   subset of the ICMPv6 message types.  To transfer extraneous\
    \ ICMPv6\n   messages from the kernel to user can incur a significant overhead.\n\
    \   Therefore this API includes a method of filtering ICMPv6 messages by\n   the\
    \ ICMPv6 type field.\n   Each ICMPv6 raw socket has an associated filter whose\
    \ datatype is\n   defined as\n      struct icmp6_filter;\n   This structure, along\
    \ with the macros and constants defined later in\n   this section, are defined\
    \ as a result of including the\n   <netinet/icmp6.h>.\n   The current filter is\
    \ fetched and stored using getsockopt() and\n   setsockopt() with a level of IPPROTO_ICMPV6\
    \ and an option name of\n   ICMP6_FILTER.\n   Six macros operate on an icmp6_filter\
    \ structure:\n      void ICMP6_FILTER_SETPASSALL (struct icmp6_filter *);\n  \
    \    void ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);\n      void ICMP6_FILTER_SETPASS\
    \ ( int, struct icmp6_filter *);\n      void ICMP6_FILTER_SETBLOCK( int, struct\
    \ icmp6_filter *);\n      int  ICMP6_FILTER_WILLPASS (int,\n                 \
    \                 const struct icmp6_filter *);\n      int  ICMP6_FILTER_WILLBLOCK(int,\n\
    \                                  const struct icmp6_filter *);\n   The first\
    \ argument to the last four macros (an integer) is an ICMPv6\n   message type,\
    \ between 0 and 255.  The pointer argument to all six\n   macros is a pointer\
    \ to a filter that is modified by the first four\n   macros and is examined by\
    \ the last two macros.\n   The first two macros, SETPASSALL and SETBLOCKALL, let\
    \ us specify that\n   all ICMPv6 messages are passed to the application or that\
    \ all ICMPv6\n   messages are blocked from being passed to the application.\n\
    \   The next two macros, SETPASS and SETBLOCK, let us specify that\n   messages\
    \ of a given ICMPv6 type should be passed to the application\n   or not passed\
    \ to the application (blocked).\n   The final two macros, WILLPASS and WILLBLOCK,\
    \ return true or false\n   depending whether the specified message type is passed\
    \ to the\n   application or blocked from being passed to the application by the\n\
    \   filter pointed to by the second argument.\n   When an ICMPv6 raw socket is\
    \ created, it will by default pass all\n   ICMPv6 message types to the application.\n\
    \   As an example, a program that wants to receive only router\n   advertisements\
    \ could execute the following:\n      struct icmp6_filter  myfilt;\n      fd =\
    \ socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n      ICMP6_FILTER_SETBLOCKALL(&myfilt);\n\
    \      ICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &myfilt);\n      setsockopt(fd,\
    \ IPPROTO_ICMPV6, ICMP6_FILTER, &myfilt,\n                 sizeof(myfilt));\n\
    \   The filter structure is declared and then initialized to block all\n   messages\
    \ types.  The filter structure is then changed to allow router\n   advertisement\
    \ messages to be passed to the application and the filter\n   is installed using\
    \ setsockopt().\n   In order to clear an installed filter the application can\
    \ issue a\n   setsockopt for ICMP6_FILTER with a zero length.  When no such filter\n\
    \   has been installed, getsockopt() will return the kernel default\n   filter.\n\
    \   The icmp6_filter structure is similar to the fd_set datatype used\n   with\
    \ the select() function in the sockets API.  The icmp6_filter\n   structure is\
    \ an opaque datatype and the application should not care\n   how it is implemented.\
    \  All the application does with this datatype\n   is allocate a variable of this\
    \ type, pass a pointer to a variable of\n   this type to getsockopt() and setsockopt(),\
    \ and operate on a variable\n   of this type using the six macros that we just\
    \ defined.\n   Nevertheless, it is worth showing a simple implementation of this\n\
    \   datatype and the six macros.\n      struct icmp6_filter {\n        uint32_t\
    \  icmp6_filt[8];  /* 8*32 = 256 bits */\n      };\n      #define ICMP6_FILTER_WILLPASS(type,\
    \ filterp) \\\n        ((((filterp)->icmp6_filt[(type) >> 5]) & \\\n         \
    \ (1 << ((type) & 31))) != 0)\n      #define ICMP6_FILTER_WILLBLOCK(type, filterp)\
    \ \\\n        ((((filterp)->icmp6_filt[(type) >> 5]) & \\\n          (1 << ((type)\
    \ & 31))) == 0)\n      #define ICMP6_FILTER_SETPASS(type, filterp) \\\n      \
    \  ((((filterp)->icmp6_filt[(type) >> 5]) |= \\\n          (1 << ((type) & 31))))\n\
    \      #define ICMP6_FILTER_SETBLOCK(type, filterp) \\\n        ((((filterp)->icmp6_filt[(type)\
    \ >> 5]) &= \\\n          ~(1 << ((type) & 31))))\n      #define ICMP6_FILTER_SETPASSALL(filterp)\
    \ \\\n        memset((filterp), 0xFF, sizeof(struct icmp6_filter))\n      #define\
    \ ICMP6_FILTER_SETBLOCKALL(filterp) \\\n        memset((filterp), 0, sizeof(struct\
    \ icmp6_filter))\n   (Note: These sample definitions have two limitations that\
    \ an\n   implementation may want to change.  The first four macros evaluate\n\
    \   their first argument two times.  The second two macros require the\n   inclusion\
    \ of the <string.h> header for the memset() function.)\n"
- title: 3.3.  ICMPv6 Verification of Received Packets
  contents:
  - "3.3.  ICMPv6 Verification of Received Packets\n   The protocol stack will verify\
    \ the ICMPv6 checksum and discard any\n   packets with invalid checksums.\n  \
    \ An implementation might perform additional validity checks on the\n   ICMPv6\
    \ message content and discard malformed packets.  However, a\n   portable application\
    \ must not assume that such validity checks have\n   been performed.\n   The protocol\
    \ stack should not automatically discard packets if the\n   ICMP type is unknown\
    \ to the stack.  For extensibility reasons\n   received ICMP packets with any\
    \ type (informational or error) must be\n   passed to the applications (subject\
    \ to ICMP6_FILTER filtering on the\n   type value and the checksum verification).\n"
- title: 4.  Access to IPv6 and Extension Headers
  contents:
  - "4.  Access to IPv6 and Extension Headers\n   Applications need to be able to\
    \ control IPv6 header and extension\n   header content when sending as well as\
    \ being able to receive the\n   content of these headers.  This is done by defining\
    \ socket option\n   types which can be used both with setsockopt and with ancillary\
    \ data.\n   Ancillary data is discussed in Appendix A.  The following optional\n\
    \   information can be exchanged between the application and the kernel:\n   1.\
    \ The send/receive interface and source/destination address,\n   2. The hop limit,\n\
    \   3. Next hop address,\n   4. The traffic class,\n   5. Routing header,\n  \
    \ 6. Hop-by-Hop options header, and\n   7. Destination options header.\n   First,\
    \ to receive any of this optional information (other than the\n   next hop address,\
    \ which can only be set) on a UDP or raw socket, the\n   application must call\
    \ setsockopt() to turn on the corresponding flag:\n      int  on = 1;\n      setsockopt(fd,\
    \ IPPROTO_IPV6, IPV6_RECVPKTINFO,  &on, sizeof(on));\n      setsockopt(fd, IPPROTO_IPV6,\
    \ IPV6_RECVHOPLIMIT, &on, sizeof(on));\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVRTHDR,\
    \    &on, sizeof(on));\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS, \
    \ &on, sizeof(on));\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS,  &on,\
    \ sizeof(on));\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS,   &on, sizeof(on));\n\
    \   When any of these options are enabled, the corresponding data is\n   returned\
    \ as control information by recvmsg(), as one or more\n   ancillary data objects.\n\
    \   This document does not define how to receive the optional information\n  \
    \ on a TCP socket.  See Section 4.1 for more details.\n   Two different mechanisms\
    \ exist for sending this optional information:\n   1. Using setsockopt to specify\
    \ the option content for a socket.\n      These are known \"sticky\" options since\
    \ they affect all transmitted\n      packets on the socket until either a new\
    \ setsockopt is done or the\n      options are overridden using ancillary data.\n\
    \   2. Using ancillary data to specify the option content for a single\n     \
    \ datagram.  This only applies to datagram and raw sockets; not to\n      TCP\
    \ sockets.\n   The three socket option parameters and the three cmsghdr fields\
    \ that\n   describe the options/ancillary data objects are summarized as:\n  \
    \    opt level/    optname/          optval/\n      cmsg_level    cmsg_type  \
    \       cmsg_data[]\n      ------------  ------------      ------------------------\n\
    \      IPPROTO_IPV6  IPV6_PKTINFO      in6_pktinfo structure\n      IPPROTO_IPV6\
    \  IPV6_HOPLIMIT     int\n      IPPROTO_IPV6  IPV6_NEXTHOP      socket address\
    \ structure\n      IPPROTO_IPV6  IPV6_RTHDR        ip6_rthdr structure\n     \
    \ IPPROTO_IPV6  IPV6_HOPOPTS      ip6_hbh structure\n      IPPROTO_IPV6  IPV6_DSTOPTS\
    \      ip6_dest structure\n      IPPROTO_IPV6  IPV6_RTHDRDSTOPTS ip6_dest structure\n\
    \      IPPROTO_IPV6  IPV6_TCLASS       int\n      (Note: IPV6_HOPLIMIT can be\
    \ used as ancillary data items only)\n   All these options are described in detail\
    \ in Section 6, 7, 8 and 9.\n   All the constants beginning with IPV6_ are defined\
    \ as a result of\n   including <netinet/in.h>.\n   Note: We intentionally use\
    \ the same constant for the cmsg_level\n   member as is used as the second argument\
    \ to getsockopt() and\n   setsockopt() (what is called the \"level\"), and the\
    \ same constant for\n   the cmsg_type member as is used as the third argument\
    \ to getsockopt()\n   and setsockopt() (what is called the \"option name\").\n\
    \   Issuing getsockopt() for the above options will return the sticky\n   option\
    \ value i.e., the value set with setsockopt().  If no sticky\n   option value\
    \ has been set getsockopt() will return the following\n   values:\n   -  For the\
    \ IPV6_PKTINFO option, it will return an in6_pktinfo\n      structure with ipi6_addr\
    \ being in6addr_any and ipi6_ifindex being\n      zero.\n   -  For the IPV6_TCLASS\
    \ option, it will return the kernel default\n      value.\n   -  For other options,\
    \ it will indicate the lack of the option value\n      with optlen being zero.\n\
    \   The application does not explicitly need to access the data\n   structures\
    \ for the Routing header, Hop-by-Hop options header, and\n   Destination options\
    \ header, since the API to these features is\n   through a set of inet6_rth_XXX()\
    \ and inet6_opt_XXX() functions that\n   we define in Section 7 and Section 10.\
    \  Those functions simplify the\n   interface to these features instead of requiring\
    \ the application to\n   know the intimate details of the extension header formats.\n\
    \   When specifying extension headers, this API assumes the header\n   ordering\
    \ and the number of occurrences of each header as described in\n   [RFC-2460].\
    \  More details about the ordering issue will be discussed\n   in Section 12.\n"
- title: 4.1.  TCP Implications
  contents:
  - "4.1.  TCP Implications\n   It is not possible to use ancillary data to transmit\
    \ the above\n   options for TCP since there is not a one-to-one mapping between\
    \ send\n   operations and the TCP segments being transmitted.  Instead an\n  \
    \ application can use setsockopt to specify them as sticky options.\n   When the\
    \ application uses setsockopt to specify the above options it\n   is expected\
    \ that TCP will start using the new information when\n   sending segments.  However,\
    \ TCP may or may not use the new\n   information when retransmitting segments\
    \ that were originally sent\n   when the old sticky options were in effect.\n\
    \   It is unclear how a TCP application can use received information\n   (such\
    \ as extension headers) due to the lack of mapping between\n   received TCP segments\
    \ and receive operations.  In particular, the\n   received information could not\
    \ be used for access control purposes\n   like on UDP and raw sockets.\n   This\
    \ specification therefore does not define how to get the received\n   information\
    \ on TCP sockets.  The result of the IPV6_RECVxxx options\n   on a TCP socket\
    \ is undefined as well.\n"
- title: 4.2.  UDP and Raw Socket Implications
  contents:
  - "4.2.  UDP and Raw Socket Implications\n   The receive behavior for UDP and raw\
    \ sockets is quite\n   straightforward.  After the application has enabled an\
    \ IPV6_RECVxxx\n   socket option it will receive ancillary data items for every\n\
    \   recvmsg() call containing the requested information.  However, if the\n  \
    \ information is not present in the packet the ancillary data item will\n   not\
    \ be included.  For example, if the application enables\n   IPV6_RECVRTHDR and\
    \ a received datagram does not contain a Routing\n   header there will not be\
    \ an IPV6_RTHDR ancillary data item.  Note\n   that due to buffering in the socket\
    \ implementation there might be\n   some packets queued when an IPV6_RECVxxx option\
    \ is enabled and they\n   might not have the ancillary data information.\n   For\
    \ sending the application has the choice between using sticky\n   options and\
    \ ancillary data.  The application can also use both having\n   the sticky options\
    \ specify the \"default\" and using ancillary data to\n   override the default\
    \ options.\n   When an ancillary data item is specified in a call to sendmsg(),\
    \ the\n   item will override an existing sticky option of the same name (if\n\
    \   previously specified).  For example, if the application has set\n   IPV6_RTHDR\
    \ using a sticky option and later passes IPV6_RTHDR as\n   ancillary data this\
    \ will override the IPV6_RTHDR sticky option and\n   the routing header of the\
    \ outgoing packet will be from the ancillary\n   data item, not from the sticky\
    \ option.  Note, however, that other\n   sticky options than IPV6_RTHDR will not\
    \ be affected by the IPV6_RTHDR\n   ancillary data item; the overriding mechanism\
    \ only works for the same\n   type of sticky options and ancillary data items.\n\
    \   (Note: the overriding rule is different from the one in RFC 2292.  In\n  \
    \ RFC 2292, an ancillary data item overrode all sticky options\n   previously\
    \ defined.  This was reasonable, because sticky options\n   could only be specified\
    \ as a set by a single socket option.  However,\n   in this API, each option is\
    \ separated so that it can be specified as\n   a single sticky option.  Additionally,\
    \ there are much more ancillary\n   data items and sticky options than in RFC\
    \ 2292, including ancillary-\n   only one.  Thus, it should be natural for application\
    \ programmers to\n   separate the overriding rule as well.)\n   An application\
    \ can also temporarily disable a particular sticky\n   option by specifying a\
    \ corresponding ancillary data item that could\n   disable the sticky option when\
    \ being used as an argument for a socket\n   option.  For example, if the application\
    \ has set IPV6_HOPOPTS as a\n   sticky option and later passes IPV6_HOPOPTS with\
    \ a zero length as an\n   ancillary data item, the packet will not have a Hop-by-Hop\
    \ options\n   header.\n"
- title: 5.  Extensions to Socket Ancillary Data
  contents:
  - "5.  Extensions to Socket Ancillary Data\n   This specification uses ancillary\
    \ data as defined in Posix with some\n   compatible extensions, which are described\
    \ in the following\n   subsections.  Section 20 will provide a detailed overview\
    \ of\n   ancillary data and related structures and macros, including the\n   extensions.\n"
- title: 5.1.  CMSG_NXTHDR
  contents:
  - "5.1.  CMSG_NXTHDR\n      struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,\n\
    \                                  const struct cmsghdr *cmsg);\n   CMSG_NXTHDR()\
    \ returns a pointer to the cmsghdr structure describing\n   the next ancillary\
    \ data object.  Mhdr is a pointer to a msghdr\n   structure and cmsg is a pointer\
    \ to a cmsghdr structure.  If there is\n   not another ancillary data object,\
    \ the return value is NULL.\n   The following behavior of this macro is new to\
    \ this API: if the value\n   of the cmsg pointer is NULL, a pointer to the cmsghdr\
    \ structure\n   describing the first ancillary data object is returned.  That\
    \ is,\n   CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr).  If\n\
    \   there are no ancillary data objects, the return value is NULL.\n"
- title: 5.2.  CMSG_SPACE
  contents:
  - "5.2.  CMSG_SPACE\n   socklen_t CMSG_SPACE(socklen_t length);\n   This macro is\
    \ new with this API.  Given the length of an ancillary\n   data object, CMSG_SPACE()\
    \ returns an upper bound on the space\n   required by the object and its cmsghdr\
    \ structure, including any\n   padding needed to satisfy alignment requirements.\
    \  This macro can be\n   used, for example, when allocating space dynamically\
    \ for the\n   ancillary data.  This macro should not be used to initialize the\n\
    \   cmsg_len member of a cmsghdr structure; instead use the CMSG_LEN()\n   macro.\n"
- title: 5.3.  CMSG_LEN
  contents:
  - "5.3.  CMSG_LEN\n   socklen_t CMSG_LEN(socklen_t length);\n   This macro is new\
    \ with this API.  Given the length of an ancillary\n   data object, CMSG_LEN()\
    \ returns the value to store in the cmsg_len\n   member of the cmsghdr structure,\
    \ taking into account any padding\n   needed to satisfy alignment requirements.\n\
    \   Note the difference between CMSG_SPACE() and CMSG_LEN(), shown also\n   in\
    \ the figure in Section 20.2: the former accounts for any required\n   padding\
    \ at the end of the ancillary data object and the latter is the\n   actual length\
    \ to store in the cmsg_len member of the ancillary data\n   object.\n"
- title: 6.  Packet Information
  contents:
  - "6.  Packet Information\n   There are five pieces of information that an application\
    \ can specify\n   for an outgoing packet using ancillary data:\n      1.  the\
    \ source IPv6 address,\n      2.  the outgoing interface index,\n      3.  the\
    \ outgoing hop limit,\n      4.  the next hop address, and\n      5.  the outgoing\
    \ traffic class value.\n   Four similar pieces of information can be returned\
    \ for a received\n   packet as ancillary data:\n      1.  the destination IPv6\
    \ address,\n      2.  the arriving interface index,\n      3.  the arriving hop\
    \ limit, and\n      4.  the arriving traffic class value.\n   The first two pieces\
    \ of information are contained in an in6_pktinfo\n   structure that is set with\
    \ setsockopt() or sent as ancillary data\n   with sendmsg() and received as ancillary\
    \ data with recvmsg().  This\n   structure is defined as a result of including\
    \ <netinet/in.h>.\n      struct in6_pktinfo {\n        struct in6_addr ipi6_addr;\
    \    /* src/dst IPv6 address */\n        unsigned int    ipi6_ifindex; /* send/recv\
    \ interface index */\n      };\n   In the socket option and cmsghdr level will\
    \ be IPPROTO_IPV6, the type\n   will be IPV6_PKTINFO, and the first byte of the\
    \ option value and\n   cmsg_data[] will be the first byte of the in6_pktinfo structure.\
    \  An\n   application can clear any sticky IPV6_PKTINFO option by doing a\n  \
    \ \"regular\" setsockopt with ipi6_addr being in6addr_any and\n   ipi6_ifindex\
    \ being zero.\n   This information is returned as ancillary data by recvmsg()\
    \ only if\n   the application has enabled the IPV6_RECVPKTINFO socket option:\n\
    \      int  on = 1;\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,\
    \ sizeof(on));\n   (Note: The hop limit is not contained in the in6_pktinfo structure\n\
    \   for the following reason.  Some UDP servers want to respond to client\n  \
    \ requests by sending their reply out the same interface on which the\n   request\
    \ was received and with the source IPv6 address of the reply\n   equal to the\
    \ destination IPv6 address of the request.  To do this the\n   application can\
    \ enable just the IPV6_RECVPKTINFO socket option and\n   then use the received\
    \ control information from recvmsg() as the\n   outgoing control information for\
    \ sendmsg().  The application need not\n   examine or modify the in6_pktinfo structure\
    \ at all.  But if the hop\n   limit were contained in this structure, the application\
    \ would have to\n   parse the received control information and change the hop\
    \ limit\n   member, since the received hop limit is not the desired value for\
    \ an\n   outgoing packet.)\n"
- title: 6.1.  Specifying/Receiving the Interface
  contents:
  - "6.1.  Specifying/Receiving the Interface\n   Interfaces on an IPv6 node are identified\
    \ by a small positive\n   integer, as described in Section 4 of [RFC-3493].  That\
    \ document also\n   describes a function to map an interface name to its interface\
    \ index,\n   a function to map an interface index to its interface name, and a\n\
    \   function to return all the interface names and indexes.  Notice from\n   this\
    \ document that no interface is ever assigned an index of 0.\n   When specifying\
    \ the outgoing interface, if the ipi6_ifindex value is\n   0, the kernel will\
    \ choose the outgoing interface.\n   The ordering among various options that can\
    \ specify the outgoing\n   interface, including IPV6_PKTINFO, is defined in Section\
    \ 6.7.\n   When the IPV6_RECVPKTINFO socket option is enabled, the received\n\
    \   interface index is always returned as the ipi6_ifindex member of the\n   in6_pktinfo\
    \ structure.\n"
- title: 6.2.  Specifying/Receiving Source/Destination Address
  contents:
  - "6.2.  Specifying/Receiving Source/Destination Address\n   The source IPv6 address\
    \ can be specified by calling bind() before\n   each output operation, but supplying\
    \ the source address together with\n   the data requires less overhead (i.e.,\
    \ fewer system calls) and\n   requires less state to be stored and protected in\
    \ a multithreaded\n   application.\n   When specifying the source IPv6 address\
    \ as ancillary data, if the\n   ipi6_addr member of the in6_pktinfo structure\
    \ is the unspecified\n   address (IN6ADDR_ANY_INIT or in6addr_any), then (a) if\
    \ an address is\n   currently bound to the socket, it is used as the source address,\
    \ or\n   (b) if no address is currently bound to the socket, the kernel will\n\
    \   choose the source address.  If the ipi6_addr member is not the\n   unspecified\
    \ address, but the socket has already bound a source\n   address, then the ipi6_addr\
    \ value overrides the already-bound source\n   address for this output operation\
    \ only.\n   The kernel must verify that the requested source address is indeed\
    \ a\n   unicast address assigned to the node.  When the address is a scoped\n\
    \   one, there may be ambiguity about its scope zone.  This is\n   particularly\
    \ the case for link-local addresses.  In such a case, the\n   kernel must first\
    \ determine the appropriate scope zone based on the\n   zone of the destination\
    \ address or the outgoing interface (if known),\n   then qualify the address.\
    \  This also means that it is not feasible to\n   specify the source address for\
    \ a non-binding socket by the\n   IPV6_PKTINFO sticky option, unless the outgoing\
    \ interface is also\n   specified.  The application should simply use bind() for\
    \ such\n   purposes.\n   IPV6_PKTINFO can also be used as a sticky option for\
    \ specifying the\n   socket's default source address.  However, the ipi6_addr\
    \ member must\n   be the unspecified address for TCP sockets, because it is not\n\
    \   possible to dynamically change the source address of a TCP\n   connection.\
    \  When the IPV6_PKTINFO option is specified for a TCP\n   socket with a non-unspecified\
    \ address, the call will fail.  This\n   restriction should be applied even before\
    \ the socket binds a specific\n   address.\n   When the in6_pktinfo structure\
    \ is returned as ancillary data by\n   recvmsg(), the ipi6_addr member contains\
    \ the destination IPv6 address\n   from the received packet.\n"
- title: 6.3.  Specifying/Receiving the Hop Limit
  contents:
  - "6.3.  Specifying/Receiving the Hop Limit\n   The outgoing hop limit is normally\
    \ specified with either the\n   IPV6_UNICAST_HOPS socket option or the IPV6_MULTICAST_HOPS\
    \ socket\n   option, both of which are described in [RFC-3493].  Specifying the\n\
    \   hop limit as ancillary data lets the application override either the\n   kernel's\
    \ default or a previously specified value, for either a\n   unicast destination\
    \ or a multicast destination, for a single output\n   operation.  Returning the\
    \ received hop limit is useful for IPv6\n   applications that need to verify that\
    \ the received hop limit is 255\n   (e.g., that the packet has not been forwarded).\n\
    \   The received hop limit is returned as ancillary data by recvmsg()\n   only\
    \ if the application has enabled the IPV6_RECVHOPLIMIT socket\n   option:\n  \
    \    int  on = 1;\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on,\
    \ sizeof(on));\n   In the cmsghdr structure containing this ancillary data, the\n\
    \   cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be\n   IPV6_HOPLIMIT,\
    \ and the first byte of cmsg_data[] will be the first\n   byte of the integer\
    \ hop limit.\n   Nothing special need be done to specify the outgoing hop limit:\
    \ just\n   specify the control information as ancillary data for sendmsg().  As\n\
    \   specified in [RFC-3493], the interpretation of the integer hop limit\n   value\
    \ is\n      x < -1:        return an error of EINVAL\n      x == -1:       use\
    \ kernel default\n      0 <= x <= 255: use x\n      x >= 256:      return an error\
    \ of EINVAL\n   This API defines IPV6_HOPLIMIT as an ancillary-only option, that\
    \ is,\n   the option name cannot be used as a socket option.  This is because\n\
    \   [RFC-3493] has more fine-grained socket options; IPV6_UNICAST_HOPS\n   and\
    \ IPV6_MULTICAST_HOPS.\n"
- title: 6.4.  Specifying the Next Hop Address
  contents:
  - "6.4.  Specifying the Next Hop Address\n   The IPV6_NEXTHOP ancillary data object\
    \ specifies the next hop for the\n   datagram as a socket address structure. \
    \ In the cmsghdr structure\n   containing this ancillary data, the cmsg_level\
    \ member will be\n   IPPROTO_IPV6, the cmsg_type member will be IPV6_NEXTHOP,\
    \ and the\n   first byte of cmsg_data[] will be the first byte of the socket\n\
    \   address structure.\n   This is a privileged option.  (Note: It is implementation\
    \ defined and\n   beyond the scope of this document to define what \"privileged\"\
    \ means.\n   Unix systems use this term to mean the process must have an effective\n\
    \   user ID of 0.)\n   This API only defines the case where the socket address\
    \ contains an\n   IPv6 address (i.e., the sa_family member is AF_INET6).  And,\
    \ in this\n   case, the node identified by that address must be a neighbor of\
    \ the\n   sending host.  If that address equals the destination IPv6 address of\n\
    \   the datagram, then this is equivalent to the existing SO_DONTROUTE\n   socket\
    \ option.\n   This option does not have any meaning for multicast destinations.\
    \  In\n   such a case, the specified next hop will be ignored.\n   When the outgoing\
    \ interface is specified by IPV6_PKTINFO as well, the\n   next hop specified by\
    \ this option must be reachable via the specified\n   interface.\n   In order\
    \ to clear a sticky IPV6_NEXTHOP option the application must\n   issue a setsockopt\
    \ for IPV6_NEXTHOP with a zero length.\n"
- title: 6.5.  Specifying/Receiving the Traffic Class value
  contents:
  - "6.5.  Specifying/Receiving the Traffic Class value\n   The outgoing traffic class\
    \ is normally set to 0.  Specifying the\n   traffic class as ancillary data lets\
    \ the application override either\n   the kernel's default or a previously specified\
    \ value, for either a\n   unicast destination or a multicast destination, for\
    \ a single output\n   operation.  Returning the received traffic class is useful\
    \ for\n   programs such as a diffserv debugging tool and for user level ECN\n\
    \   (explicit congestion notification) implementation.\n   The received traffic\
    \ class is returned as ancillary data by recvmsg()\n   only if the application\
    \ has enabled the IPV6_RECVTCLASS socket\n   option:\n      int  on = 1;\n   \
    \   setsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS, &on, sizeof(on));\n   In the\
    \ cmsghdr structure containing this ancillary data, the\n   cmsg_level member\
    \ will be IPPROTO_IPV6, the cmsg_type member will be\n   IPV6_TCLASS, and the\
    \ first byte of cmsg_data[] will be the first byte\n   of the integer traffic\
    \ class.\n   To specify the outgoing traffic class value, just specify the control\n\
    \   information as ancillary data for sendmsg() or using setsockopt().\n   Just\
    \ like the hop limit value, the interpretation of the integer\n   traffic class\
    \ value is\n      x < -1:        return an error of EINVAL\n      x == -1:   \
    \    use kernel default\n      0 <= x <= 255: use x\n      x >= 256:      return\
    \ an error of EINVAL\n   In order to clear a sticky IPV6_TCLASS option the application\
    \ can\n   specify -1 as the value.\n   There are cases where the kernel needs\
    \ to control the traffic class\n   value and conflicts with the user-specified\
    \ value on the outgoing\n   traffic.  An example is an implementation of ECN in\
    \ the kernel,\n   setting 2 bits of the traffic class value.  In such cases, the\
    \ kernel\n   should override the user-specified value.  On the incoming traffic,\n\
    \   the kernel may mask some of the bits in the traffic class field.\n"
- title: 6.6.  Additional Errors with sendmsg() and setsockopt()
  contents:
  - "6.6.  Additional Errors with sendmsg() and setsockopt()\n   With the IPV6_PKTINFO\
    \ socket option there are no additional errors\n   possible with the call to recvmsg().\
    \  But when specifying the\n   outgoing interface or the source address, additional\
    \ errors are\n   possible from sendmsg() or setsockopt().  Note that some\n  \
    \ implementations might only be able to return this type of errors for\n   setsockopt().\
    \  The following are examples, but some of these may not\n   be provided by some\
    \ implementations, and some implementations may\n   define additional errors:\n\
    \   ENXIO         The interface specified by ipi6_ifindex does not exist.\n  \
    \ ENETDOWN      The interface specified by ipi6_ifindex is not enabled\n     \
    \            for IPv6 use.\n   EADDRNOTAVAIL ipi6_ifindex specifies an interface\
    \ but the address\n                 ipi6_addr is not available for use on that\
    \ interface.\n   EHOSTUNREACH  No route to the destination exists over the interface\n\
    \                 specified by ipi6_ifindex.\n"
- title: 6.7.  Summary of Outgoing Interface Selection
  contents:
  - "6.7.  Summary of Outgoing Interface Selection\n   This document and [RFC-3493]\
    \ specify various methods that affect the\n   selection of the packet's outgoing\
    \ interface.  This subsection\n   summarizes the ordering among those in order\
    \ to ensure deterministic\n   behavior.\n   For a given outgoing packet on a given\
    \ socket, the outgoing interface\n   is determined in the following order:\n \
    \  1. if an interface is specified in an IPV6_PKTINFO ancillary data\n      item,\
    \ the interface is used.\n   2. otherwise, if an interface is specified in an\
    \ IPV6_PKTINFO sticky\n      option, the interface is used.\n   3. otherwise,\
    \ if the destination address is a multicast address and\n      the IPV6_MULTICAST_IF\
    \ socket option is specified for the socket,\n      the interface is used.\n \
    \  4. otherwise, if an IPV6_NEXTHOP ancillary data item is specified,\n      the\
    \ interface to the next hop is used.\n   5. otherwise, if an IPV6_NEXTHOP sticky\
    \ option is specified, the\n      interface to the next hop is used.\n   6. otherwise,\
    \ the outgoing interface should be determined in an\n      implementation dependent\
    \ manner.\n   The ordering above particularly means if the application specifies\
    \ an\n   interface by the IPV6_MULTICAST_IF socket option (described in [RFC-\n\
    \   3493]) as well as specifying a different interface by the\n   IPV6_PKTINFO\
    \ sticky option, the latter will override the former for\n   every multicast packet\
    \ on the corresponding socket.  The reason for\n   the ordering comes from expectation\
    \ that the source address is\n   specified as well and that the pair of the address\
    \ and the outgoing\n   interface should be preferred.\n   In any case, the kernel\
    \ must also verify that the source and\n   destination addresses do not break\
    \ their scope zones with regard to\n   the outgoing interface.\n"
- title: 7.  Routing Header Option
  contents:
  - "7.  Routing Header Option\n   Source routing in IPv6 is accomplished by specifying\
    \ a Routing header\n   as an extension header.  There can be different types of\
    \ Routing\n   headers, but IPv6 currently defines only the Type 0 Routing header\n\
    \   [RFC-2460].  This type supports up to 127 intermediate nodes (limited\n  \
    \ by the length field in the extension header).  With this maximum\n   number\
    \ of intermediate nodes, a source, and a destination, there are\n   128 hops.\n\
    \   Source routing with the IPv4 sockets API (the IP_OPTIONS socket\n   option)\
    \ requires the application to build the source route in the\n   format that appears\
    \ as the IPv4 header option, requiring intimate\n   knowledge of the IPv4 options\
    \ format.  This IPv6 API, however,\n   defines six functions that the application\
    \ calls to build and examine\n   a Routing header, and the ability to use sticky\
    \ options or ancillary\n   data to communicate this information between the application\
    \ and the\n   kernel using the IPV6_RTHDR option.\n   Three functions build a\
    \ Routing header:\n      inet6_rth_space()    - return #bytes required for Routing\
    \ header\n      inet6_rth_init()     - initialize buffer data for Routing header\n\
    \      inet6_rth_add()      - add one IPv6 address to the Routing header\n   Three\
    \ functions deal with a returned Routing header:\n      inet6_rth_reverse()  -\
    \ reverse a Routing header\n      inet6_rth_segments() - return #segments in a\
    \ Routing header\n      inet6_rth_getaddr()  - fetch one address from a Routing\
    \ header\n   The function prototypes for these functions are defined as a result\n\
    \   of including <netinet/in.h>.\n   To receive a Routing header the application\
    \ must enable the\n   IPV6_RECVRTHDR socket option:\n      int  on = 1;\n    \
    \  setsockopt(fd, IPPROTO_IPV6, IPV6_RECVRTHDR, &on, sizeof(on));\n   Each received\
    \ Routing header is returned as one ancillary data object\n   described by a cmsghdr\
    \ structure with cmsg_type set to IPV6_RTHDR.\n   When multiple Routing headers\
    \ are received, multiple ancillary data\n   objects (with cmsg_type set to IPV6_RTHDR)\
    \ will be returned to the\n   application.\n   To send a Routing header the application\
    \ specifies it either as\n   ancillary data in a call to sendmsg() or using setsockopt().\
    \  For the\n   sending side, this API assumes the number of occurrences of the\n\
    \   Routing header as described in [RFC-2460].  That is, applications can\n  \
    \ only specify at most one outgoing Routing header.\n   The application can remove\
    \ any sticky Routing header by calling\n   setsockopt() for IPV6_RTHDR with a\
    \ zero option length.\n   When using ancillary data a Routing header is passed\
    \ between the\n   application and the kernel as follows: The cmsg_level member\
    \ has a\n   value of IPPROTO_IPV6 and the cmsg_type member has a value of\n  \
    \ IPV6_RTHDR.  The contents of the cmsg_data[] member is implementation\n   dependent\
    \ and should not be accessed directly by the application, but\n   should be accessed\
    \ using the six functions that we are about to\n   describe.\n   The following\
    \ constant is defined as a result of including the\n   <netinet/in.h>:\n     \
    \ #define IPV6_RTHDR_TYPE_0    0 /* IPv6 Routing header type 0 */\n   When a Routing\
    \ header is specified, the destination address specified\n   for connect(), sendto(),\
    \ or sendmsg() is the final destination\n   address of the datagram.  The Routing\
    \ header then contains the\n   addresses of all the intermediate nodes.\n"
- title: 7.1.  inet6_rth_space
  contents:
  - "7.1.  inet6_rth_space\n      socklen_t inet6_rth_space(int type, int segments);\n\
    \   This function returns the number of bytes required to hold a Routing\n   header\
    \ of the specified type containing the specified number of\n   segments (addresses).\
    \  For an IPv6 Type 0 Routing header, the number\n   of segments must be between\
    \ 0 and 127, inclusive.  The return value\n   is just the space for the Routing\
    \ header.  When the application uses\n   ancillary data it must pass the returned\
    \ length to CMSG_SPACE() to\n   determine how much memory is needed for the ancillary\
    \ data object\n   (including the cmsghdr structure).\n   If the return value is\
    \ 0, then either the type of the Routing header\n   is not supported by this implementation\
    \ or the number of segments is\n   invalid for this type of Routing header.\n\
    \   (Note: This function returns the size but does not allocate the space\n  \
    \ required for the ancillary data.  This allows an application to\n   allocate\
    \ a larger buffer, if other ancillary data objects are\n   desired, since all\
    \ the ancillary data objects must be specified to\n   sendmsg() as a single msg_control\
    \ buffer.)\n"
- title: 7.2.  inet6_rth_init
  contents:
  - "7.2.  inet6_rth_init\n      void *inet6_rth_init(void *bp, socklen_t bp_len,\
    \ int type,\n                           int segments);\n   This function initializes\
    \ the buffer pointed to by bp to contain a\n   Routing header of the specified\
    \ type and sets ip6r_len based on the\n   segments parameter.  bp_len is only\
    \ used to verify that the buffer is\n   large enough.  The ip6r_segleft field\
    \ is set to zero; inet6_rth_add()\n   will increment it.\n   When the application\
    \ uses ancillary data the application must\n   initialize any cmsghdr fields.\n\
    \   The caller must allocate the buffer and its size can be determined by\n  \
    \ calling inet6_rth_space().\n   Upon success the return value is the pointer\
    \ to the buffer (bp), and\n   this is then used as the first argument to the inet6_rth_add()\n\
    \   function.  Upon an error the return value is NULL.\n"
- title: 7.3.  inet6_rth_add
  contents:
  - "7.3.  inet6_rth_add\n      int inet6_rth_add(void *bp, const struct in6_addr\
    \ *addr);\n   This function adds the IPv6 address pointed to by addr to the end\
    \ of\n   the Routing header being constructed.\n   If successful, the segleft\
    \ member of the Routing Header is updated to\n   account for the new address in\
    \ the Routing header and the return\n   value of the function is 0.  Upon an error\
    \ the return value of the\n   function is -1.\n"
- title: 7.4.  inet6_rth_reverse
  contents:
  - "7.4.  inet6_rth_reverse\n      int inet6_rth_reverse(const void *in, void *out);\n\
    \   This function takes a Routing header extension header (pointed to by\n   the\
    \ first argument) and writes a new Routing header that sends\n   datagrams along\
    \ the reverse of that route.  The function reverses the\n   order of the addresses\
    \ and sets the segleft member in the new Routing\n   header to the number of segments.\
    \  Both arguments are allowed to\n   point to the same buffer (that is, the reversal\
    \ can occur in place).\n   The return value of the function is 0 on success, or\
    \ -1 upon an\n   error.\n"
- title: 7.5.  inet6_rth_segments
  contents:
  - "7.5.  inet6_rth_segments\n      int inet6_rth_segments(const void *bp);\n   This\
    \ function returns the number of segments (addresses) contained in\n   the Routing\
    \ header described by bp.  On success the return value is\n   zero or greater.\
    \  The return value of the function is -1 upon an\n   error.\n"
- title: 7.6.  inet6_rth_getaddr
  contents:
  - "7.6.  inet6_rth_getaddr\n      struct in6_addr *inet6_rth_getaddr(const void\
    \ *bp, int index);\n   This function returns a pointer to the IPv6 address specified\
    \ by\n   index (which must have a value between 0 and one less than the value\n\
    \   returned by inet6_rth_segments()) in the Routing header described by\n   bp.\
    \  An application should first call inet6_rth_segments() to obtain\n   the number\
    \ of segments in the Routing header.\n   Upon an error the return value of the\
    \ function is NULL.\n"
- title: 8.  Hop-By-Hop Options
  contents:
  - "8.  Hop-By-Hop Options\n   A variable number of Hop-by-Hop options can appear\
    \ in a single Hop-\n   by-Hop options header.  Each option in the header is TLV-encoded\
    \ with\n   a type, length, and value.  This IPv6 API defines seven functions\n\
    \   that the application calls to build and examine a Hop-by_Hop options\n   header,\
    \ and the ability to use sticky options or ancillary data to\n   communicate this\
    \ information between the application and the kernel.\n   This uses the IPV6_HOPOPTS\
    \ for a Hop-by-Hop options header.\n   Today several Hop-by-Hop options are defined\
    \ for IPv6.  Two pad\n   options, Pad1 and PadN, are for alignment purposes and\
    \ are\n   automatically inserted by the inet6_opt_XXX() routines and ignored by\n\
    \   the inet6_opt_XXX() routines on the receive side.  This section of\n   the\
    \ API is therefore defined for other (and future) Hop-by-Hop\n   options that\
    \ an application may need to specify and receive.\n   Four functions build an\
    \ options header:\n      inet6_opt_init()     - initialize buffer data for options\
    \ header\n      inet6_opt_append()   - add one TLV option to the options header\n\
    \      inet6_opt_finish()   - finish adding TLV options to the options\n     \
    \                        header\n      inet6_opt_set_val()  - add one component\
    \ of the option content to\n                             the option\n      Three\
    \ functions deal with a returned options header:\n      inet6_opt_next()     -\
    \ extract the next option from the options\n                             header\n\
    \      inet6_opt_find()     - extract an option of a specified type from\n   \
    \                          the header\n      inet6_opt_get_val()  - retrieve one\
    \ component of the option\n                             content\n   Individual\
    \ Hop-by-Hop options (and Destination options, which are\n   described in Section\
    \ 9 and are very similar to the Hop-by-Hop\n   options) may have specific alignment\
    \ requirements.  For example, the\n   4-byte Jumbo Payload length should appear\
    \ on a 4-byte boundary, and\n   IPv6 addresses are normally aligned on an 8-byte\
    \ boundary.  These\n   requirements and the terminology used with these options\
    \ are\n   discussed in Section 4.2 and Appendix B of [RFC-2460].  The alignment\n\
    \   of first byte of each option is specified by two values, called x and\n  \
    \ y, written as \"xn + y\".  This states that the option must appear at\n   an\
    \ integer multiple of x bytes from the beginning of the options\n   header (x\
    \ can have the values 1, 2, 4, or 8), plus y bytes (y can\n   have a value between\
    \ 0 and 7, inclusive).  The Pad1 and PadN options\n   are inserted as needed to\
    \ maintain the required alignment.  The\n   functions below need to know the alignment\
    \ of the end of the option\n   (which is always in the form \"xn,\" where x can\
    \ have the values 1, 2,\n   4, or 8) and the total size of the data portion of\
    \ the option.  These\n   are passed as the \"align\" and \"len\" arguments to\
    \ inet6_opt_append().\n   Multiple Hop-by-Hop options must be specified by the\
    \ application by\n   placing them in a single extension header.\n   Finally, we\
    \ note that use of some Hop-by-Hop options or some\n   Destination options, might\
    \ require special privilege.  That is,\n   normal applications (without special\
    \ privilege) might be forbidden\n   from setting certain options in outgoing packets,\
    \ and might never see\n   certain options in received packets.\n"
- title: 8.1.  Receiving Hop-by-Hop Options
  contents:
  - "8.1.  Receiving Hop-by-Hop Options\n   To receive a Hop-by-Hop options header\
    \ the application must enable\n   the IPV6_RECVHOPOPTS socket option:\n      int\
    \  on = 1;\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &on, sizeof(on));\n\
    \   When using ancillary data a Hop-by-hop options header is passed\n   between\
    \ the application and the kernel as follows: The cmsg_level\n   member will be\
    \ IPPROTO_IPV6 and the cmsg_type member will be\n   IPV6_HOPOPTS.  These options\
    \ are then processed by calling the\n   inet6_opt_next(), inet6_opt_find(), and\
    \ inet6_opt_get_val()\n   functions, described in Section 10.\n"
- title: 8.2.  Sending Hop-by-Hop Options
  contents:
  - "8.2.  Sending Hop-by-Hop Options\n   To send a Hop-by-Hop options header, the\
    \ application specifies the\n   header either as ancillary data in a call to sendmsg()\
    \ or using\n   setsockopt().\n   The application can remove any sticky Hop-by-Hop\
    \ options header by\n   calling setsockopt() for IPV6_HOPOPTS with a zero option\
    \ length.\n   All the Hop-by-Hop options must be specified by a single ancillary\n\
    \   data object.  The cmsg_level member is set to IPPROTO_IPV6 and the\n   cmsg_type\
    \ member is set to IPV6_HOPOPTS.  The option is normally\n   constructed using\
    \ the inet6_opt_init(), inet6_opt_append(),\n   inet6_opt_finish(), and inet6_opt_set_val()\
    \ functions, described in\n   Section 10.\n   Additional errors may be possible\
    \ from sendmsg() and setsockopt() if\n   the specified option is in error.\n"
- title: 9.  Destination Options
  contents:
  - "9.  Destination Options\n   A variable number of Destination options can appear\
    \ in one or more\n   Destination options headers.  As defined in [RFC-2460], a\
    \ Destination\n   options header appearing before a Routing header is processed\
    \ by the\n   first destination plus any subsequent destinations specified in the\n\
    \   Routing header, while a Destination options header that is not\n   followed\
    \ by a Routing header is processed only by the final\n   destination.  As with\
    \ the Hop-by-Hop options, each option in a\n   Destination options header is TLV-encoded\
    \ with a type, length, and\n   value.\n"
- title: 9.1.  Receiving Destination Options
  contents:
  - "9.1.  Receiving Destination Options\n   To receive Destination options header\
    \ the application must enable the\n   IPV6_RECVDSTOPTS socket option:\n      int\
    \  on = 1;\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &on, sizeof(on));\n\
    \   Each Destination options header is returned as one ancillary data\n   object\
    \ described by a cmsghdr structure with cmsg_level set to\n   IPPROTO_IPV6 and\
    \ cmsg_type set to IPV6_DSTOPTS.\n   These options are then processed by calling\
    \ the inet6_opt_next(),\n   inet6_opt_find(), and inet6_opt_get_value() functions.\n"
- title: 9.2.  Sending Destination Options
  contents:
  - "9.2.  Sending Destination Options\n   To send a Destination options header, the\
    \ application specifies it\n   either as ancillary data in a call to sendmsg()\
    \ or using\n   setsockopt().\n   The application can remove any sticky Destination\
    \ options header by\n   calling setsockopt() for IPV6_RTHDRDSTOPTS/IPV6_DSTOPTS\
    \ with a zero\n   option length.\n   This API assumes the ordering about extension\
    \ headers as described in\n   [RFC-2460].  Thus, one set of Destination options\
    \ can only appear\n   before a Routing header, and one set can only appear after\
    \ a Routing\n   header (or in a packet with no Routing header).  Each set can\
    \ consist\n   of one or more options but each set is a single extension header.\n\
    \   Today all destination options that an application may want to specify\n  \
    \ can be put after (or without) a Routing header.  Thus, applications\n   should\
    \ usually need IPV6_DSTOPTS only and should avoid using\n   IPV6_RTHDRDSTOPTS\
    \ whenever possible.\n   When using ancillary data a Destination options header\
    \ is passed\n   between the application and the kernel as follows: The set preceding\n\
    \   a Routing header are specified with the cmsg_level member set to\n   IPPROTO_IPV6\
    \ and the cmsg_type member set to IPV6_RTHDRDSTOPTS.  Any\n   setsockopt or ancillary\
    \ data for IPV6_RTHDRDSTOPTS is silently\n   ignored when sending packets unless\
    \ a Routing header is also\n   specified.  Note that the \"Routing header\" here\
    \ means the one\n   specified by this API.  Even when the kernel inserts a routing\
    \ header\n   in its internal routine (e.g., in a mobile IPv6 stack), the\n   Destination\
    \ options header specified by IPV6_RTHDRDSTOPTS will still\n   be ignored unless\
    \ the application explicitly specifies its own\n   Routing header.\n   The set\
    \ of Destination options after a Routing header, which are also\n   used when\
    \ no Routing header is present, are specified with the\n   cmsg_level member is\
    \ set to IPPROTO_IPV6 and the cmsg_type member is\n   set to IPV6_DSTOPTS.\n \
    \  The Destination options are normally constructed using the\n   inet6_opt_init(),\
    \ inet6_opt_append(), inet6_opt_finish(), and\n   inet6_opt_set_val() functions,\
    \ described in Section 10.\n   Additional errors may be possible from sendmsg()\
    \ and setsockopt() if\n   the specified option is in error.\n"
- title: 10.  Hop-by-Hop and Destination Options Processing
  contents:
  - "10.  Hop-by-Hop and Destination Options Processing\n   Building and parsing the\
    \ Hop-by-Hop and Destination options is\n   complicated for the reasons given\
    \ earlier.  We therefore define a set\n   of functions to help the application.\
    \  These functions assume the\n   formatting rules specified in Appendix B in\
    \ [RFC-2460] i.e., that the\n   largest field is placed last in the option.\n\
    \   The function prototypes for these functions are defined as a result\n   of\
    \ including <netinet/in.h>.\n   The first 3 functions (init, append, and finish)\
    \ are used both to\n   calculate the needed buffer size for the options, and to\
    \ actually\n   encode the options once the application has allocated a buffer\
    \ for\n   the header.  In order to only calculate the size the application must\n\
    \   pass a NULL extbuf and a zero extlen to those functions.\n"
- title: 10.1.  inet6_opt_init
  contents:
  - "10.1.  inet6_opt_init\n      int inet6_opt_init(void *extbuf, socklen_t extlen);\n\
    \   This function returns the number of bytes needed for the empty\n   extension\
    \ header i.e., without any options.  If extbuf is not NULL it\n   also initializes\
    \ the extension header to have the correct length\n   field.  In that case if\
    \ the extlen value is not a positive (i.e.,\n   non-zero) multiple of 8 the function\
    \ fails and returns -1.\n   (Note: since the return value on success is based\
    \ on a \"constant\"\n   parameter, i.e., the empty extension header, an implementation\
    \ may\n   return a constant value.  However, this specification does not\n   require\
    \ the value be constant, and leaves it as implementation\n   dependent.  The application\
    \ should not assume a particular constant\n   value as a successful return value\
    \ of this function.)\n"
- title: 10.2.  inet6_opt_append
  contents:
  - "10.2.  inet6_opt_append\n      int inet6_opt_append(void *extbuf, socklen_t extlen,\
    \ int offset,\n                           uint8_t type, socklen_t len, uint_t\
    \ align,\n                           void **databufp);\n   Offset should be the\
    \ length returned by inet6_opt_init() or a\n   previous inet6_opt_append().  This\
    \ function returns the updated total\n   length taking into account adding an\
    \ option with length 'len' and\n   alignment 'align'.  If extbuf is not NULL then,\
    \ in addition to\n   returning the length, the function inserts any needed pad\
    \ option,\n   initializes the option (setting the type and length fields) and\n\
    \   returns a pointer to the location for the option content in databufp.\n  \
    \ If the option does not fit in the extension header buffer the\n   function returns\
    \ -1.\n   Type is the 8-bit option type.  Len is the length of the option data\n\
    \   (i.e., excluding the option type and option length fields).\n   Once inet6_opt_append()\
    \ has been called the application can use the\n   databuf directly, or use inet6_opt_set_val()\
    \ to specify the content\n   of the option.\n   The option type must have a value\
    \ from 2 to 255, inclusive.  (0 and 1\n   are reserved for the Pad1 and PadN options,\
    \ respectively.)\n   The option data length must have a value between 0 and 255,\n\
    \   inclusive, and is the length of the option data that follows.\n   The align\
    \ parameter must have a value of 1, 2, 4, or 8.  The align\n   value can not exceed\
    \ the value of len.\n"
- title: 10.3.  inet6_opt_finish
  contents:
  - "10.3.  inet6_opt_finish\n      int inet6_opt_finish(void *extbuf, socklen_t extlen,\
    \ int offset);\n   Offset should be the length returned by inet6_opt_init() or\n\
    \   inet6_opt_append().  This function returns the updated total length\n   taking\
    \ into account the final padding of the extension header to make\n   it a multiple\
    \ of 8 bytes.  If extbuf is not NULL the function also\n   initializes the option\
    \ by inserting a Pad1 or PadN option of the\n   proper length.\n   If the necessary\
    \ pad does not fit in the extension header buffer the\n   function returns -1.\n"
- title: 10.4.  inet6_opt_set_val
  contents:
  - "10.4.  inet6_opt_set_val\n      int inet6_opt_set_val(void *databuf, int offset,\
    \ void *val,\n                            socklen_t vallen);\n   Databuf should\
    \ be a pointer returned by inet6_opt_append().  This\n   function inserts data\
    \ items of various sizes in the data portion of\n   the option.  Val should point\
    \ to the data to be inserted.  Offset\n   specifies where in the data portion\
    \ of the option the value should be\n   inserted; the first byte after the option\
    \ type and length is accessed\n   by specifying an offset of zero.\n   The caller\
    \ should ensure that each field is aligned on its natural\n   boundaries as described\
    \ in Appendix B of [RFC-2460], but the function\n   must not rely on the caller's\
    \ behavior.  Even when the alignment\n   requirement is not satisfied, inet6_opt_set_val\
    \ should just copy the\n   data as required.\n   The function returns the offset\
    \ for the next field (i.e., offset +\n   vallen) which can be used when composing\
    \ option content with multiple\n   fields.\n"
- title: 10.5.  inet6_opt_next
  contents:
  - "10.5.  inet6_opt_next\n      int inet6_opt_next(void *extbuf, socklen_t extlen,\
    \ int offset,\n                         uint8_t *typep, socklen_t *lenp,\n   \
    \                      void **databufp);\n   This function parses received option\
    \ extension headers returning the\n   next option.  Extbuf and extlen specifies\
    \ the extension header.\n   Offset should either be zero (for the first option)\
    \ or the length\n   returned by a previous call to inet6_opt_next() or inet6_opt_find().\n\
    \   It specifies the position where to continue scanning the extension\n   buffer.\
    \  The next option is returned by updating typep, lenp, and\n   databufp.  Typep\
    \ stores the option type, lenp stores the length of\n   the option data (i.e.,\
    \ excluding the option type and option length\n   fields), and databufp points\
    \ the data field of the option.  This\n   function returns the updated \"previous\"\
    \ length computed by advancing\n   past the option that was returned.  This returned\
    \ \"previous\" length\n   can then be passed to subsequent calls to inet6_opt_next().\
    \  This\n   function does not return any PAD1 or PADN options.  When there are\
    \ no\n   more options or if the option extension header is malformed the\n   return\
    \ value is -1.\n"
- title: 10.6.  inet6_opt_find
  contents:
  - "10.6.  inet6_opt_find\n      int inet6_opt_find(void *extbuf, socklen_t extlen,\
    \ int offset,\n                         uint8_t type, socklen_t *lenp,\n     \
    \                    void **databufp);\n   This function is similar to the previously\
    \ described inet6_opt_next()\n   function, except this function lets the caller\
    \ specify the option\n   type to be searched for, instead of always returning\
    \ the next option\n   in the extension header.\n   If an option of the specified\
    \ type is located, the function returns\n   the updated \"previous\" total length\
    \ computed by advancing past the\n   option that was returned and past any options\
    \ that didn't match the\n   type.  This returned \"previous\" length can then\
    \ be passed to\n   subsequent calls to inet6_opt_find() for finding the next occurrence\n\
    \   of the same option type.\n   If an option of the specified type is not located,\
    \ the return value\n   is -1.  If the option extension header is malformed, the\
    \ return value\n   is -1.\n"
- title: 10.7.  inet6_opt_get_val
  contents:
  - "10.7.  inet6_opt_get_val\n      int inet6_opt_get_val(void *databuf, int offset,\
    \ void *val,\n                            socklen_t vallen);\n   Databuf should\
    \ be a pointer returned by inet6_opt_next() or\n   inet6_opt_find().  This function\
    \ extracts data items of various sizes\n   in the data portion of the option.\
    \  Val should point to the\n   destination for the extracted data.  Offset specifies\
    \ from where in\n   the data portion of the option the value should be extracted;\
    \ the\n   first byte after the option type and length is accessed by specifying\n\
    \   an offset of zero.\n   It is expected that each field is aligned on its natural\
    \ boundaries\n   as described in Appendix B of [RFC-2460], but the function must\
    \ not\n   rely on the alignment.\n   The function returns the offset for the next\
    \ field (i.e., offset +\n   vallen) which can be used when extracting option content\
    \ with\n   multiple fields.\n"
- title: 11.  Additional Advanced API Functions
  contents:
  - '11.  Additional Advanced API Functions

    '
- title: 11.1.  Sending with the Minimum MTU
  contents:
  - "11.1.  Sending with the Minimum MTU\n   Unicast applications should usually let\
    \ the kernel perform path MTU\n   discovery [RFC-1981], as long as the kernel\
    \ supports it, and should\n   not care about the path MTU.  Some applications,\
    \ however, might not\n   want to incur the overhead of path MTU discovery, especially\
    \ if the\n   applications only send a single datagram to a destination.  A\n \
    \  potential example is a DNS server.\n   [RFC-1981] describes how path MTU discovery\
    \ works for multicast\n   destinations.  From practice in using IPv4 multicast,\
    \ however, many\n   careless applications that send large multicast packets on\
    \ the wire\n   have caused implosion of ICMPv4 error messages.  The situation\
    \ can be\n   worse when there is a filtering node that blocks the ICMPv4 messages.\n\
    \   Though the filtering issue applies to unicast as well, the impact is\n   much\
    \ larger in the multicast cases.\n   Thus, applications sending multicast traffic\
    \ should explicitly enable\n   path MTU discovery only when they understand that\
    \ the benefit of\n   possibly larger MTU usage outweighs the possible impact of\
    \ MTU\n   discovery for active sources across the delivery tree(s).  This\n  \
    \ default behavior is based on the today's practice with IPv4 multicast\n   and\
    \ path MTU discovery.  The behavior may change in the future once\n   it is found\
    \ that path MTU discovery effectively works with actual\n   multicast applications\
    \ and network configurations.\n   This specification defines a mechanism to avoid\
    \ path MTU discovery by\n   sending at the minimum IPv6 MTU [RFC-2460].  If the\
    \ packet is larger\n   than the minimum MTU and this feature has been enabled\
    \ the IP layer\n   will fragment to the minimum MTU.  To control the policy about\
    \ path\n   MTU discovery, applications can use the IPV6_USE_MIN_MTU socket\n \
    \  option.\n   As described above, the default policy should depend on whether\
    \ the\n   destination is unicast or multicast.  For unicast destinations path\n\
    \   MTU discovery should be performed by default.  For multicast\n   destinations\
    \ path MTU discovery should be disabled by default.  This\n   option thus takes\
    \ the following three types of integer arguments:\n   -1: perform path MTU discovery\
    \ for unicast destinations but do not\n       perform it for multicast destinations.\
    \  Packets to multicast\n       destinations are therefore sent with the minimum\
    \ MTU.\n   0: always perform path MTU discovery.\n   1: always disable path MTU\
    \ discovery and send packets at the minimum\n       MTU.\n   The default value\
    \ of this option is -1.  Values other than -1, 0, and\n   1 are invalid, and an\
    \ error EINVAL will be returned for those values.\n   As an example, if a unicast\
    \ application intentionally wants to\n   disable path MTU discovery, it will add\
    \ the following lines:\n      int  on = 1;\n      setsockopt(fd, IPPROTO_IPV6,\
    \ IPV6_USE_MIN_MTU, &on, sizeof(on));\n   Note that this API intentionally excludes\
    \ the case where the\n   application wants to perform path MTU discovery for multicast\
    \ but to\n   disable it for unicast.  This is because such usage is not feasible\n\
    \   considering a scale of performance issues around whether to do path\n   MTU\
    \ discovery or not.  When path MTU discovery makes sense to a\n   destination\
    \ but not to a different destination, regardless of whether\n   the destination\
    \ is unicast or multicast, applications either need to\n   toggle the option between\
    \ sending such packets on the same socket, or\n   use different sockets for the\
    \ two classes of destinations.\n   This option can also be sent as ancillary data.\
    \  In the cmsghdr\n   structure containing this ancillary data, the cmsg_level\
    \ member will\n   be IPPROTO_IPV6, the cmsg_type member will be IPV6_USE_MIN_MTU,\
    \ and\n   the first byte of cmsg_data[] will be the first byte of the integer.\n"
- title: 11.2.  Sending without Fragmentation
  contents:
  - "11.2.  Sending without Fragmentation\n   In order to provide for easy porting\
    \ of existing UDP and raw socket\n   applications IPv6 implementations will, when\
    \ originating packets,\n   automatically insert a fragment header in the packet\
    \ if the packet is\n   too big for the path MTU.\n   Some applications might not\
    \ want this behavior.  An example is\n   traceroute which might want to discover\
    \ the actual path MTU.\n   This specification defines a mechanism to turn off\
    \ the automatic\n   inserting of a fragment header for UDP and raw sockets.  This\
    \ can be\n   enabled using the IPV6_DONTFRAG socket option.\n      int on = 1;\n\
    \      setsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &on, sizeof(on));\n   By default,\
    \ this socket option is disabled.  Setting the value to 0\n   also disables the\
    \ option i.e., reverts to the default behavior of\n   automatic inserting.  This\
    \ option can also be sent as ancillary data.\n   In the cmsghdr structure containing\
    \ this ancillary data, the\n   cmsg_level member will be IPPROTO_IPV6, the cmsg_type\
    \ member will be\n   IPV6_DONTFRAG, and the first byte of cmsg_data[] will be\
    \ the first\n   byte of the integer.  This API only specifies the use of this\
    \ option\n   for UDP and raw sockets, and does not define the usage for TCP\n\
    \   sockets.\n   When the data size is larger than the MTU of the outgoing interface,\n\
    \   the packet will be discarded.  Applications can know the result by\n   enabling\
    \ the IPV6_RECVPATHMTU option described below and receiving\n   the corresponding\
    \ ancillary data items.  An additional error EMSGSIZE\n   may also be returned\
    \ in some implementations.  Note, however, that\n   some other implementations\
    \ might not be able to return this\n   additional error when sending a message.\n"
- title: 11.3.  Path MTU Discovery and UDP
  contents:
  - "11.3.  Path MTU Discovery and UDP\n   UDP and raw socket applications need to\
    \ be able to  determine the\n   \"maximum send transport-message size\" (Section\
    \ 5.1 of [RFC-1981]) to\n   a given destination so that those applications can\
    \ participate in\n   path MTU discovery.  This lets those applications send smaller\n\
    \   datagrams to the destination, avoiding fragmentation.\n   This is accomplished\
    \ using a new ancillary data item (IPV6_PATHMTU)\n   which is delivered to recvmsg()\
    \ without any actual data.  The\n   application can enable the receipt of IPV6_PATHMTU\
    \ ancillary data\n   items by setting the IPV6_RECVPATHMTU socket option.\n  \
    \    int  on = 1;\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPATHMTU, &on, sizeof(on));\n\
    \   By default, this socket option is disabled.  Setting the value to 0\n   also\
    \ disables the option.  This API only specifies the use of this\n   option for\
    \ UDP and raw sockets, and does not define the usage for TCP\n   sockets.\n  \
    \ When the application is sending packets too big for the path MTU\n   recvmsg()\
    \ will return zero (indicating no data) but there will be a\n   cmsghdr with cmsg_type\
    \ set to IPV6_PATHMTU, and cmsg_len will\n   indicate that cmsg_data is sizeof(struct\
    \ ip6_mtuinfo) bytes long.\n   This can happen when the sending node receives\
    \ a corresponding ICMPv6\n   packet too big error, or when the packet is sent\
    \ from a socket with\n   the IPV6_DONTFRAG option being on and the packet size\
    \ is larger than\n   the MTU of the outgoing interface.  This indication is considered\
    \ as\n   an ancillary data item for a separate (empty) message.  Thus, when\n\
    \   there are buffered messages (i.e., messages that the application has\n   not\
    \ received yet) on the socket the application will first receive\n   the buffered\
    \ messages and then receive the indication.\n   The first byte of cmsg_data[]\
    \ will point to a struct ip6_mtuinfo\n   carrying the path MTU to use together\
    \ with the IPv6 destination\n   address.\n      struct ip6_mtuinfo {\n       \
    \ struct sockaddr_in6 ip6m_addr; /* dst address including\n                  \
    \                        zone ID */\n        uint32_t            ip6m_mtu;  /*\
    \ path MTU in host byte order */\n      };\n   This cmsghdr will be passed to\
    \ every socket that sets the\n   IPV6_RECVPATHMTU socket option, even if the socket\
    \ is non-connected.\n   Note that this also means an application that sets the\
    \ option may\n   receive an IPV6_MTU ancillary data item for each ICMP too big\
    \ error\n   the node receives, including such ICMP errors caused by other\n  \
    \ applications on the node.  Thus, an application that wants to perform\n   the\
    \ path MTU discovery by itself needs to keep history of\n   destinations that\
    \ it has actually sent to and to compare the address\n   returned in the ip6_mtuinfo\
    \ structure to the history.  An\n   implementation may choose not to delivery\
    \ data to a connected socket\n   that has a foreign address that is different\
    \ than the address\n   specified in the ip6m_addr structure.\n   When an application\
    \ sends a packet with a routing header, the final\n   destination stored in the\
    \ ip6m_addr member does not necessarily\n   contain complete information of the\
    \ entire path.\n"
- title: 11.4.  Determining the Current Path MTU
  contents:
  - "11.4.  Determining the Current Path MTU\n   Some applications might need to determine\
    \ the current path MTU e.g.,\n   applications using IPV6_RECVPATHMTU might want\
    \ to pick a good\n   starting value.\n   This specification defines a get-only\
    \ socket option to retrieve the\n   current path MTU value for the destination\
    \ of a given connected\n   socket.  If the IP layer does not have a cached path\
    \ MTU value it\n   will return the interface MTU for the interface that will be\
    \ used\n   when sending to the destination address.\n   This information is retrieved\
    \ using the IPV6_PATHMTU socket option.\n   This option takes a pointer to the\
    \ ip6_mtuinfo structure as the\n   fourth argument, and the size of the structure\
    \ should be passed as a\n   value-result parameter in the fifth argument.\n  \
    \    struct ip6_mtuinfo mtuinfo;\n      socklen_t infolen = sizeof(mtuinfo);\n\
    \      getsockopt(fd, IPPROTO_IPV6, IPV6_PATHMTU, &mtuinfo, &infolen);\n   When\
    \ the call succeeds, the path MTU value is stored in the ip6m_mtu\n   member of\
    \ the ip6_mtuinfo structure.  Since the socket is connected,\n   the ip6m_addr\
    \ member is meaningless and should not be referred to by\n   the application.\n\
    \   This option can only be used for a connected socket, because a non-\n   connected\
    \ socket does not have the information of the destination and\n   there is no\
    \ way to pass the destination via getsockopt().  When\n   getsockopt() for this\
    \ option is issued on a non-connected socket, the\n   call will fail.  Despite\
    \ this limitation, this option is still useful\n   from a practical point of view,\
    \ because applications that care about\n   the path MTU tend to send a lot of\
    \ packets to a single destination\n   and to connect the socket to the destination\
    \ for performance reasons.\n   If the application needs to get the MTU value in\
    \ a more generic way,\n   it should use a more generic interface, such as routing\
    \ sockets\n   [TCPIPILLUST].\n"
- title: 12.  Ordering of Ancillary Data and IPv6 Extension Headers
  contents:
  - "12.  Ordering of Ancillary Data and IPv6 Extension Headers\n   Three IPv6 extension\
    \ headers can be specified by the application and\n   returned to the application\
    \ using ancillary data with sendmsg() and\n   recvmsg(): the Routing header, Hop-by-Hop\
    \ options header, and\n   Destination options header.  When multiple ancillary\
    \ data objects are\n   transferred via recvmsg() and these objects represent any\
    \ of these\n   three extension headers, their placement in the control buffer\
    \ is\n   directly tied to their location in the corresponding IPv6 datagram.\n\
    \   For example, when the application has enabled the IPV6_RECVRTHDR and\n   IPV6_RECVDSTOPTS\
    \ options and later receives an IPv6 packet with\n   extension headers in the\
    \ following order:\n      The IPv6 header\n      A Hop-by-Hop options header\n\
    \      A Destination options header (1)\n      A Routing header\n      An Authentication\
    \ header\n      A Destination options header (2)\n      A UDP header and UDP data\n\
    \   then the application will receive three ancillary data objects in the\n  \
    \ following order:\n      an object with cmsg_type set to IPV6_DSTOPTS, which\
    \ represents\n      the destination options header (1)\n      an object with cmsg_type\
    \ set to IPV6_RTHDR, which represents the\n      Routing header\n      an object\
    \ with cmsg_type set to IPV6_DSTOPTS, which represents the\n      destination\
    \ options header (2)\n   This example follows the header ordering described in\
    \ [RFC-2460], but\n   the receiving side of this specification does not assume\
    \ the\n   ordering.  Applications may receive any numbers of objects in any\n\
    \   order according to the ordering of the received IPv6 datagram.\n   For the\
    \ sending side, however, this API imposes some ordering\n   constraints according\
    \ to [RFC-2460].  Applications using this API\n   cannot make a packet with extension\
    \ headers that do not follow the\n   ordering.  Note, however, that this does\
    \ not mean applications must\n   always follow the restriction.  This is just\
    \ a limitation in this API\n   in order to give application programmers a guideline\
    \ to construct\n   headers in a practical manner.  Should an application need\
    \ to make an\n   outgoing packet in an arbitrary order about the extension headers,\n\
    \   some other technique, such as the datalink interfaces BPF or DLPI,\n   must\
    \ be used.\n   The followings are more details about the constraints:\n   -  Each\
    \ IPV6_xxx ancillary data object for a particular type of\n      extension header\
    \ can be specified at most once in a single control\n      buffer.\n   -  IPV6_xxx\
    \ ancillary data objects can appear in any order in a\n      control buffer, because\
    \ there is no ambiguity of the ordering.\n   -  Each set of IPV6_xxx ancillary\
    \ data objects and sticky options\n      will be put in the outgoing packet along\
    \ with the header ordering\n      described in [RFC-2460].\n   -  An ancillary\
    \ data object or a sticky option of IPV6_RTHDRDSTOPTS\n      will affect the outgoing\
    \ packet only when a Routing header is\n      specified as an ancillary data object\
    \ or a sticky option.\n      Otherwise, the specified value for IPV6_RTHDRDSTOPTS\
    \ will be\n      ignored.\n   For example, when an application sends a UDP datagram\
    \ with a control\n   data buffer containing ancillary data objects in the following\
    \ order:\n      an object with cmsg_type set to IPV6_DSTOPTS\n      an object\
    \ with cmsg_type set to IPV6_RTHDRDSTOPTS\n      an object with cmsg_type set\
    \ to IPV6_HOPOPTS\n   and the sending socket does not have any sticky options,\
    \ then the\n   outgoing packet would be constructed as follows:\n      The IPv6\
    \ header\n      A Hop-by-Hop options header\n      A Destination options header\n\
    \      A UDP header and UDP data\n   where the destination options header corresponds\
    \ to the ancillary\n   data object with the type IPV6_DSTOPTS.\n   Note that the\
    \ constraints above do not necessarily mean that the\n   outgoing packet sent\
    \ on the wire always follows the header ordering\n   specified in this API document.\
    \  The kernel may insert additional\n   headers that break the ordering as a result.\
    \  For example, if the\n   kernel supports Mobile IPv6, an additional destination\
    \ options header\n   may be inserted before an authentication header, even without\
    \ a\n   routing header.\n   This API does not provide access to any other extension\
    \ headers than\n   the supported three types of headers.  In particular, no information\n\
    \   is provided about the IP security headers on an incoming packet, nor\n   can\
    \ be specified for an outgoing packet.  This API is for\n   applications that\
    \ do not care about the existence of IP security\n   headers.\n"
- title: 13.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses
  contents:
  - "13.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses\n   The various socket\
    \ options and ancillary data specifications defined\n   in this document apply\
    \ only to true IPv6 sockets.  It is possible to\n   create an IPv6 socket that\
    \ actually sends and receives IPv4 packets,\n   using IPv4-mapped IPv6 addresses,\
    \ but the mapping of the options\n   defined in this document to an IPv4 datagram\
    \ is beyond the scope of\n   this document.\n   In general, attempting to specify\
    \ an IPv6-only option, such as the\n   Hop-by-Hop options, Destination options,\
    \ or Routing header on an IPv6\n   socket that is using IPv4-mapped IPv6 addresses,\
    \ will probably result\n   in an error.  Some implementations, however, may provide\
    \ access to\n   the packet information (source/destination address, send/receive\n\
    \   interface, and hop limit) on an IPv6 socket that is using IPv4-mapped\n  \
    \ IPv6 addresses.\n"
- title: 14.  Extended interfaces for rresvport, rcmd and rexec
  contents:
  - "14.  Extended interfaces for rresvport, rcmd and rexec\n   Library functions\
    \ that support the \"r\" commands hide the creation of\n   a socket and the name\
    \ resolution procedure from an application.  When\n   the libraries return an\
    \ AF_INET6 socket to an application that do not\n   support the address family,\
    \ the application may encounter an\n   unexpected result when, e.g., calling getpeername()\
    \ for the socket.\n   In order to support AF_INET6 sockets for the \"r\" commands\
    \ while\n   keeping backward compatibility, this section defines some extensions\n\
    \   to the libraries.\n"
- title: 14.1.  rresvport_af
  contents:
  - "14.1.  rresvport_af\n   The rresvport() function is used by the rcmd() function,\
    \ and this\n   function is in turn called by many of the \"r\" commands such as\n\
    \   rlogin.  While new applications are not being written to use the\n   rcmd()\
    \ function, legacy applications such as rlogin will continue to\n   use it and\
    \ these will be ported to IPv6.\n   rresvport() creates an IPv4/TCP socket and\
    \ binds a \"reserved port\" to\n   the socket.  Instead of defining an IPv6 version\
    \ of this function we\n   define a new function that takes an address family as\
    \ its argument.\n      #include <unistd.h>\n      int  rresvport_af(int *port,\
    \ int family);\n   This function behaves the same as the existing rresvport()\
    \ function,\n   but instead of creating an AF_INET TCP socket, it can also create\
    \ an\n   AF_INET6 TCP socket.  The family argument is either AF_INET or\n   AF_INET6,\
    \ and a new error return is EAFNOSUPPORT if the address\n   family is not supported.\n\
    \   (Note: There is little consensus on which header defines the\n   rresvport()\
    \ and rcmd() function prototypes.  4.4BSD defines it in\n   <unistd.h>, others\
    \ in <netdb.h>, and others don't define the function\n   prototypes at all.)\n"
- title: 14.2.  rcmd_af
  contents:
  - "14.2.  rcmd_af\n   The existing rcmd() function can not transparently use AF_INET6\n\
    \   sockets since an application would not be prepared to handle AF_INET6\n  \
    \ addresses returned by e.g., getpeername() on the file descriptor\n   created\
    \ by rcmd().  Thus a new function is needed.\n      int rcmd_af(char **ahost,\
    \ unsigned short rport,\n                  const char *locuser, const char *remuser,\n\
    \                  const char *cmd, int *fd2p, int af)\n   This function behaves\
    \ the same as the existing rcmd() function, but\n   instead of creating an AF_INET\
    \ TCP socket, it can also create an\n   AF_INET6 TCP socket.  The family argument\
    \ is AF_INET, AF_INET6, or\n   AF_UNSPEC.  When either AF_INET or AF_INET6 is\
    \ specified, this\n   function will create a socket of the specified address family.\
    \  When\n   AF_UNSPEC is specified, it will try all possible address families\n\
    \   until a connection can be established, and will return the associated\n  \
    \ socket of the connection.  A new error EAFNOSUPPORT will be returned\n   if\
    \ the address family is not supported.\n"
- title: 14.3.  rexec_af
  contents:
  - "14.3.  rexec_af\n   The existing rexec() function can not transparently use AF_INET6\n\
    \   sockets since an application would not be prepared to handle AF_INET6\n  \
    \ addresses returned by e.g., getpeername() on the file descriptor\n   created\
    \ by rexec().  Thus a new function is needed.\n      int rexec_af(char **ahost,\
    \ unsigned short rport, const char *name,\n                   const char *pass,\
    \ const char *cmd, int *fd2p, int af)\n   This function behaves the same as the\
    \ existing rexec() function, but\n   instead of creating an AF_INET TCP socket,\
    \ it can also create an\n   AF_INET6 TCP socket.  The family argument is AF_INET,\
    \ AF_INET6, or\n   AF_UNSPEC.  When either AF_INET or AF_INET6 is specified, this\n\
    \   function will create a socket of the specified address family.  When\n   AF_UNSPEC\
    \ is specified, it will try all possible address families\n   until a connection\
    \ can be established, and will return the associated\n   socket of the connection.\
    \  A new error EAFNOSUPPORT will be returned\n   if the address family is not\
    \ supported.\n"
- title: 15.  Summary of New Definitions
  contents:
  - "15.  Summary of New Definitions\n   The following list summarizes the constants\
    \ and structure,\n   definitions discussed in this memo, sorted by header.\n \
    \     <netinet/icmp6.h> ICMP6_DST_UNREACH\n      <netinet/icmp6.h> ICMP6_DST_UNREACH_ADDR\n\
    \      <netinet/icmp6.h> ICMP6_DST_UNREACH_ADMIN\n      <netinet/icmp6.h> ICMP6_DST_UNREACH_BEYONDSCOPE\n\
    \      <netinet/icmp6.h> ICMP6_DST_UNREACH_NOPORT\n      <netinet/icmp6.h> ICMP6_DST_UNREACH_NOROUTE\n\
    \      <netinet/icmp6.h> ICMP6_ECHO_REPLY\n      <netinet/icmp6.h> ICMP6_ECHO_REQUEST\n\
    \      <netinet/icmp6.h> ICMP6_INFOMSG_MASK\n      <netinet/icmp6.h> ICMP6_PACKET_TOO_BIG\n\
    \      <netinet/icmp6.h> ICMP6_PARAMPROB_HEADER\n      <netinet/icmp6.h> ICMP6_PARAMPROB_NEXTHEADER\n\
    \      <netinet/icmp6.h> ICMP6_PARAMPROB_OPTION\n      <netinet/icmp6.h> ICMP6_PARAM_PROB\n\
    \      <netinet/icmp6.h> ICMP6_ROUTER_RENUMBERING\n      <netinet/icmp6.h> ICMP6_RR_FLAGS_FORCEAPPLY\n\
    \      <netinet/icmp6.h> ICMP6_RR_FLAGS_PREVDONE\n      <netinet/icmp6.h> ICMP6_RR_FLAGS_REQRESULT\n\
    \      <netinet/icmp6.h> ICMP6_RR_FLAGS_SPECSITE\n      <netinet/icmp6.h> ICMP6_RR_FLAGS_TEST\n\
    \      <netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME\n      <netinet/icmp6.h>\
    \ ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME\n      <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_AUTO\n\
    \      <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_ONLINK\n      <netinet/icmp6.h>\
    \ ICMP6_RR_RESULT_FLAGS_FORBIDDEN\n      <netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_OOB\n\
    \      <netinet/icmp6.h> ICMP6_TIME_EXCEEDED\n      <netinet/icmp6.h> ICMP6_TIME_EXCEED_REASSEMBLY\n\
    \      <netinet/icmp6.h> ICMP6_TIME_EXCEED_TRANSIT\n      <netinet/icmp6.h> MLD_LISTENER_QUERY\n\
    \      <netinet/icmp6.h> MLD_LISTENER_REDUCTION\n      <netinet/icmp6.h> MLD_LISTENER_REPORT\n\
    \      <netinet/icmp6.h> ND_NA_FLAG_OVERRIDE\n      <netinet/icmp6.h> ND_NA_FLAG_ROUTER\n\
    \      <netinet/icmp6.h> ND_NA_FLAG_SOLICITED\n      <netinet/icmp6.h> ND_NEIGHBOR_ADVERT\n\
    \      <netinet/icmp6.h> ND_NEIGHBOR_SOLICIT\n      <netinet/icmp6.h> ND_OPT_MTU\n\
    \      <netinet/icmp6.h> ND_OPT_PI_FLAG_AUTO\n      <netinet/icmp6.h> ND_OPT_PI_FLAG_ONLINK\n\
    \      <netinet/icmp6.h> ND_OPT_PREFIX_INFORMATION\n      <netinet/icmp6.h> ND_OPT_REDIRECTED_HEADER\n\
    \      <netinet/icmp6.h> ND_OPT_SOURCE_LINKADDR\n      <netinet/icmp6.h> ND_OPT_TARGET_LINKADDR\n\
    \      <netinet/icmp6.h> ND_RA_FLAG_MANAGED\n      <netinet/icmp6.h> ND_RA_FLAG_OTHER\n\
    \      <netinet/icmp6.h> ND_REDIRECT\n      <netinet/icmp6.h> ND_ROUTER_ADVERT\n\
    \      <netinet/icmp6.h> ND_ROUTER_SOLICIT\n      <netinet/icmp6.h> struct icmp6_filter{};\n\
    \      <netinet/icmp6.h> struct icmp6_hdr{};\n      <netinet/icmp6.h> struct icmp6_router_renum{};\n\
    \      <netinet/icmp6.h> struct mld_hdr{};\n      <netinet/icmp6.h> struct nd_neighbor_advert{};\n\
    \      <netinet/icmp6.h> struct nd_neighbor_solicit{};\n      <netinet/icmp6.h>\
    \ struct nd_opt_hdr{};\n      <netinet/icmp6.h> struct nd_opt_mtu{};\n      <netinet/icmp6.h>\
    \ struct nd_opt_prefix_info{};\n      <netinet/icmp6.h> struct nd_opt_rd_hdr{};\n\
    \      <netinet/icmp6.h> struct nd_redirect{};\n      <netinet/icmp6.h> struct\
    \ nd_router_advert{};\n      <netinet/icmp6.h> struct nd_router_solicit{};\n \
    \     <netinet/icmp6.h> struct rr_pco_match{};\n      <netinet/icmp6.h> struct\
    \ rr_pco_use{};\n      <netinet/icmp6.h> struct rr_result{};\n      <netinet/in.h>\
    \    IPPROTO_AH\n      <netinet/in.h>    IPPROTO_DSTOPTS\n      <netinet/in.h>\
    \    IPPROTO_ESP\n      <netinet/in.h>    IPPROTO_FRAGMENT\n      <netinet/in.h>\
    \    IPPROTO_HOPOPTS\n      <netinet/in.h>    IPPROTO_ICMPV6\n      <netinet/in.h>\
    \    IPPROTO_IPV6\n      <netinet/in.h>    IPPROTO_NONE\n      <netinet/in.h>\
    \    IPPROTO_ROUTING\n      <netinet/in.h>    IPV6_CHECKSUM\n      <netinet/in.h>\
    \    IPV6_DONTFRAG\n      <netinet/in.h>    IPV6_DSTOPTS\n      <netinet/in.h>\
    \    IPV6_HOPLIMIT\n      <netinet/in.h>    IPV6_HOPOPTS\n      <netinet/in.h>\
    \    IPV6_NEXTHOP\n      <netinet/in.h>    IPV6_PATHMTU\n      <netinet/in.h>\
    \    IPV6_PKTINFO\n      <netinet/in.h>    IPV6_RECVDSTOPTS\n      <netinet/in.h>\
    \    IPV6_RECVHOPLIMIT\n      <netinet/in.h>    IPV6_RECVHOPOPTS\n      <netinet/in.h>\
    \    IPV6_RECVPKTINFO\n      <netinet/in.h>    IPV6_RECVRTHDR\n      <netinet/in.h>\
    \    IPV6_RECVTCLASS\n      <netinet/in.h>    IPV6_RTHDR\n      <netinet/in.h>\
    \    IPV6_RTHDRDSTOPTS\n      <netinet/in.h>    IPV6_RTHDR_TYPE_0\n      <netinet/in.h>\
    \    IPV6_RECVPATHMTU\n      <netinet/in.h>    IPV6_TCLASS\n      <netinet/in.h>\
    \    IPV6_USE_MIN_MTU\n      <netinet/in.h>    struct in6_pktinfo{};\n      <netinet/in.h>\
    \    struct ip6_mtuinfo{};\n      <netinet/ip6.h>   IP6F_MORE_FRAG\n      <netinet/ip6.h>\
    \   IP6F_OFF_MASK\n      <netinet/ip6.h>   IP6F_RESERVED_MASK\n      <netinet/ip6.h>\
    \   IP6OPT_JUMBO\n      <netinet/ip6.h>   IP6OPT_JUMBO_LEN\n      <netinet/ip6.h>\
    \   IP6OPT_MUTABLE\n      <netinet/ip6.h>   IP6OPT_NSAP_ADDR\n      <netinet/ip6.h>\
    \   IP6OPT_PAD1\n      <netinet/ip6.h>   IP6OPT_PADN\n      <netinet/ip6.h>  \
    \ IP6OPT_ROUTER_ALERT\n      <netinet/ip6.h>   IP6OPT_TUNNEL_LIMIT\n      <netinet/ip6.h>\
    \   IP6OPT_TYPE_DISCARD\n      <netinet/ip6.h>   IP6OPT_TYPE_FORCEICMP\n     \
    \ <netinet/ip6.h>   IP6OPT_TYPE_ICMP\n      <netinet/ip6.h>   IP6OPT_TYPE_SKIP\n\
    \      <netinet/ip6.h>   IP6_ALERT_AN\n      <netinet/ip6.h>   IP6_ALERT_MLD\n\
    \      <netinet/ip6.h>   IP6_ALERT_RSVP\n      <netinet/ip6.h>   struct ip6_dest{};\n\
    \      <netinet/ip6.h>   struct ip6_frag{};\n      <netinet/ip6.h>   struct ip6_hbh{};\n\
    \      <netinet/ip6.h>   struct ip6_hdr{};\n      <netinet/ip6.h>   struct ip6_opt{};\n\
    \      <netinet/ip6.h>   struct ip6_opt_jumbo{};\n      <netinet/ip6.h>   struct\
    \ ip6_opt_nsap{};\n      <netinet/ip6.h>   struct ip6_opt_router{};\n      <netinet/ip6.h>\
    \   struct ip6_opt_tunnel{};\n      <netinet/ip6.h>   struct ip6_rthdr{};\n  \
    \    <netinet/ip6.h>   struct ip6_rthdr0{};\n   The following list summarizes\
    \ the function and macro prototypes\n   discussed in this memo, sorted by header.\n\
    \      <netinet/icmp6.h> void ICMP6_FILTER_SETBLOCK(int, struct\n            \
    \                                   icmp6_filter *);\n      <netinet/icmp6.h>\
    \ void\n                        ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);\n\
    \      <netinet/icmp6.h> void\n                        ICMP6_FILTER_SETPASS(int,\n\
    \                                             struct icmp6_filter *);\n      <netinet/icmp6.h>\
    \ void\n                        ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);\n\
    \      <netinet/icmp6.h> int  ICMP6_FILTER_WILLBLOCK(int,\n                  \
    \                         const struct icmp6_filter *);\n      <netinet/icmp6.h>\
    \ int  ICMP6_FILTER_WILLPASS(int,\n                                          \
    \ const struct icmp6_filter *);\n      <netinet/in.h>    int IN6_ARE_ADDR_EQUAL(const\
    \ struct in6_addr *,\n                                           const struct\
    \ in6_addr *);\n      <netinet/in.h>    int inet6_opt_append(void *, socklen_t,\
    \ int,\n                                             uint8_t, socklen_t, uint_t,\n\
    \                                             void **);\n      <netinet/in.h>\
    \    int inet6_opt_get_val(void *, int, void *,\n                            \
    \                  socklen_t);\n      <netinet/in.h>    int inet6_opt_find(void\
    \ *, socklen_t,\n                                           int, uint8_t ,\n \
    \                                          socklen_t *, void **);\n      <netinet/in.h>\
    \    int inet6_opt_finish(void *, socklen_t, int);\n      <netinet/in.h>    int\
    \ inet6_opt_init(void *, socklen_t);\n      <netinet/in.h>    int inet6_opt_next(void\
    \ *, socklen_t,\n                                           int, uint8_t *,\n\
    \                                           socklen_t *, void **);\n      <netinet/in.h>\
    \    int inet6_opt_set_val(void *, int,\n                                    \
    \          void *, socklen_t);\n      <netinet/in.h>    int inet6_rth_add(void\
    \ *,\n                                          const struct in6_addr *);\n  \
    \    <netinet/in.h>    struct in6_addr inet6_rth_getaddr(const void *,\n     \
    \                                                     int);\n      <netinet/in.h>\
    \    void *inet6_rth_init(void *, socklen_t,\n                               \
    \              int, int);\n      <netinet/in.h>    int inet6_rth_reverse(const\
    \ void *, void *);\n      <netinet/in.h>    int inet6_rth_segments(const void\
    \ *);\n      <netinet/in.h>    soccklen_t inet6_rth_space(int, int);\n      <netinet/ip6.h>\
    \   int  IP6OPT_TYPE(uint8_t);\n      <sys/socket.h>    socklen_t CMSG_LEN(socklen_t);\n\
    \      <sys/socket.h>    socklen_t CMSG_SPACE(socklen_t);\n      <unistd.h>  \
    \      int rresvport_af(int *, int);\n      <unistd.h>        int rcmd_af(char\
    \ **, unsigned short,\n                                    const char *, const\
    \ char *,\n                                    const char *, int *, int);\n  \
    \    <unistd.h>        int rexec_af(char **, unsigned short,\n               \
    \                      const char *, const char *,\n                         \
    \            const char *, int *, int);\n"
- title: 16.  Security Considerations
  contents:
  - "16.  Security Considerations\n   The setting of certain Hop-by-Hop options and\
    \ Destination options may\n   be restricted to privileged processes.  Similarly\
    \ some Hop-by-Hop\n   options and Destination options may not be returned to non-privileged\n\
    \   applications.\n   The ability to specify an arbitrary source address using\
    \ IPV6_PKTINFO\n   must be prevented; at least for non-privileged processes.\n"
- title: 17.  Changes from RFC 2292
  contents:
  - "17.  Changes from RFC 2292\n   Significant changes that affect the compatibility\
    \ to RFC 2292:\n   -  Removed the IPV6_PKTOPTIONS socket option by allowing sticky\n\
    \      options to be set with individual setsockopt() calls.\n   -  Removed the\
    \ ability to be able to specify Hop-by-Hop and\n      Destination options using\
    \ multiple ancillary data items.  The\n      application, using the inet6_opt_xxx()\
    \ routines (see below), is\n      responsible for formatting the whole extension\
    \ header.\n   -  Removed the support for the loose/strict Routing header since\
    \ that\n      has been removed from the IPv6 specification.\n   -  Loosened the\
    \ constraints for jumbo payload option that this option\n      was always hidden\
    \ from applications.\n   -  Disabled the use of the IPV6_HOPLIMIT sticky option.\n\
    \   -  Removed ip6r0_addr field from the ip6_rthdr structure.\n   -  Intentionally\
    \ unspecified how to get received packet's information\n      on TCP sockets.\n\
    \   New features:\n   -  Added IPV6_RTHDRDSTOPTS to specify a Destination Options\
    \ header\n      before the Routing header.\n   -  Added separate IPV6_RECVxxx\
    \ options to enable the receipt of the\n      corresponding ancillary data items.\n\
    \   -  Added inet6_rth_xxx() and inet6_opt_xxx() functions to deal with\n    \
    \  routing or IPv6 options headers.\n   -  Added extensions of libraries for the\
    \ \"r\" commands.\n   -  Introduced additional IPv6 option definitions such as\
    \ IP6OPT_PAD1.\n   -  Added MLD and router renumbering definitions.\n   -  Added\
    \ MTU-related socket options and ancillary data items.\n   -  Added options and\
    \ ancillary data items to manipulate the traffic\n      class field.\n   -  Changed\
    \ the name of ICMPv6 unreachable code 2 to be \"beyond scope\n      of source\
    \ address.\"  ICMP6_DST_UNREACH_NOTNEIGHBOR was removed\n      with this change.\n\
    \   Clarifications:\n   -  Added clarifications on extension headers ordering;\
    \ for the\n      sending side, assume the recommended ordering described in RFC\n\
    \      2460.  For the receiving side, do not assume any ordering and pass\n  \
    \    all headers to the application in the received order.\n   -  Added a summary\
    \ about the interface selection rule.\n   -  Clarified the ordering between IPV6_MULTICAST_IF\
    \ and the\n      IPV6_PKTINFO sticky option for multicast packets.\n   -  Clarified\
    \ how sticky options and the ICMPv6 filter are turned off\n      and that getsockopt()\
    \ of a sticky option returns what was set with\n      setsockopt().\n   -  Clarified\
    \ that IPV6_NEXTHOP should be ignored for a multicast\n      destination, that\
    \ it should not contradict with the specified\n      outgoing interface, and that\
    \ the next hop should be a sockaddr_in6\n      structure.\n   -  Clarified corner\
    \ cases of IPV6_CHECKSUM.\n   -  Aligned with the POSIX standard.\n   Editorial\
    \ changes:\n   -  Replaced MUST with must (since this is an informational document).\n\
    \   -  Revised abstract to be more clear and concise, particularly\n      concentrating\
    \ on differences from RFC 2292.\n   -  Made the URL of assigned numbers less specific\
    \ so that it would be\n      more robust for future changes.\n   -  Updated the\
    \ reference to the basic API.\n   -  Added a reference to the latest POSIX standard.\n\
    \   -  Moved general specifications of ancillary data and CMSG macros to\n   \
    \   the appendix.\n"
- title: 18.  References
  contents:
  - "18.  References\n   [RFC-1981]    McCann, J., Deering, S. and J. Mogul, \"Path\
    \ MTU\n                 Discovery for IP version 6\", RFC 1981, August 1996.\n\
    \   [RFC-2460]    Deering, S. and R. Hinden, \"Internet Protocol, Version\n  \
    \               6 (IPv6) Specification\", RFC 2460, December 1998.\n   [RFC-3493]\
    \    Gilligan, R., Thomson, S., Bound, J., McCann, J.  and\n                 W.\
    \ Stevens, \"Basic Socket Interface Extensions for\n                 IPv6\", RFC\
    \ 3493, March 2003.\n   [POSIX]       IEEE Std. 1003.1-2001 Standard for Information\n\
    \                 Technology -- Portable Operating System Interface\n        \
    \         (POSIX). Open group Technical Standard: Base\n                 Specifications,\
    \ Issue 6, December 2001. ISO/IEC\n                 9945:2002. http://www.opengroup.org/austin\n\
    \   [TCPIPILLUST] Wright, G., Stevens, W., \"TCP/IP Illustrated, Volume 2:\n \
    \                The Implementation\", Addison Wesley, 1994.\n"
- title: 19.  Acknowledgments
  contents:
  - "19.  Acknowledgments\n   Matt Thomas and Jim Bound have been working on the technical\
    \ details\n   in this document for over a year.  Keith Sklower is the original\n\
    \   implementor of ancillary data in the BSD networking code.  Craig Metz\n  \
    \ provided lots of feedback, suggestions, and comments based on his\n   implementing\
    \ many of these features as the document was being\n   written.  Mark Andrews\
    \ first proposed the idea of the\n   IPV6_USE_MIN_MTU option.  Jun-ichiro Hagino\
    \ contributed text for the\n   traffic class API from a document of his own.\n\
    \   The following provided comments on earlier drafts: Pascal Anelli,\n   Hamid\
    \ Asayesh, Ran Atkinson, Karl Auerbach, Hamid Asayesh, Don\n   Coolidge, Matt\
    \ Crawford, Sam T. Denton, Richard Draves, Francis\n   Dupont, Toerless Eckert,\
    \ Lilian Fernandes, Bob Gilligan, Gerri\n   Harter, Tim Hartrick, Bob Halley,\
    \ Masaki Hirabaru, Michael Hunter,\n   Yoshinobu Inoue, Mukesh Kacker, A. N. Kuznetsov,\
    \ Sam Manthorpe, Pedro\n   Marques, Jack McCann, der Mouse, John Moy, Lori Napoli,\
    \ Thomas\n   Narten, Atsushi Onoe, Steve Parker, Charles Perkins, Ken Powell,\
    \ Tom\n   Pusateri, Pedro Roque, Sameer Shah, Peter Sjodin, Stephen P.\n   Spackman,\
    \ Jinmei Tatuya, Karen Tracey, Sowmini Varadhan, Quaizar\n   Vohra, Carl Williams,\
    \ Steve Wise, Eric Wong, Farrell Woods, Kazu\n   Yamamoto, Vladislav Yasevich,\
    \ and Yoshifuji Hideaki.\n"
- title: '20.  Appendix A: Ancillary Data Overview'
  contents:
  - "20.  Appendix A: Ancillary Data Overview\n   4.2BSD allowed file descriptors\
    \ to be transferred between separate\n   processes across a UNIX domain socket\
    \ using the sendmsg() and\n   recvmsg() functions.  Two members of the msghdr\
    \ structure,\n   msg_accrights and msg_accrightslen, were used to send and receive\
    \ the\n   descriptors.  When the OSI protocols were added to 4.3BSD Reno in\n\
    \   1990 the names of these two fields in the msghdr structure were\n   changed\
    \ to msg_control and msg_controllen, because they were used by\n   the OSI protocols\
    \ for \"control information\", although the comments in\n   the source code call\
    \ this \"ancillary data\".\n   Other than the OSI protocols, the use of ancillary\
    \ data has been\n   rare.  In 4.4BSD, for example, the only use of ancillary data\
    \ with\n   IPv4 is to return the destination address of a received UDP datagram\n\
    \   if the IP_RECVDSTADDR socket option is set.  With Unix domain sockets\n  \
    \ ancillary data is still used to send and receive descriptors.\n   Nevertheless\
    \ the ancillary data fields of the msghdr structure\n   provide a clean way to\
    \ pass information in addition to the data that\n   is being read or written.\
    \  The inclusion of the msg_control and\n   msg_controllen members of the msghdr\
    \ structure along with the cmsghdr\n   structure that is pointed to by the msg_control\
    \ member is required by\n   the Posix sockets API standard.\n"
- title: 20.1.  The msghdr Structure
  contents:
  - "20.1.  The msghdr Structure\n   The msghdr structure is used by the recvmsg()\
    \ and sendmsg()\n   functions.  Its Posix definition is:\n      struct msghdr\
    \ {\n        void      *msg_name;        /* ptr to socket address\n          \
    \                             structure */\n        socklen_t  msg_namelen;  \
    \   /* size of socket address\n                                       structure\
    \ */\n        struct iovec  *msg_iov;     /* scatter/gather array */\n       \
    \ int        msg_iovlen;      /* # elements in msg_iov */\n        void      *msg_control;\
    \     /* ancillary data */\n        socklen_t  msg_controllen;  /* ancillary data\
    \ buffer length */\n        int        msg_flags;       /* flags on received message\
    \ */\n      };\n   The structure is declared as a result of including <sys/socket.h>.\n\
    \   (Note: Before Posix the two \"void *\" pointers were typically \"char\n  \
    \ *\", and the two socklen_t members were typically integers.  Earlier\n   drafts\
    \ of Posix had the two socklen_t members as size_t, but it then\n   changed these\
    \ to socklen_t to simplify binary portability for 64-bit\n   implementations and\
    \ to align Posix with X/Open's Networking Services,\n   Issue 5.  The change in\
    \ msg_control to a \"void *\" pointer affects any\n   code that increments this\
    \ pointer.)\n   Most Berkeley-derived implementations limit the amount of ancillary\n\
    \   data in a call to sendmsg() to no more than 108 bytes (an mbuf).\n   This\
    \ API requires a minimum of 10240 bytes of ancillary data, but it\n   is recommended\
    \ that the amount be limited only by the buffer space\n   reserved by the socket\
    \ (which can be modified by the SO_SNDBUF socket\n   option).  (Note: This magic\
    \ number 10240 was picked as a value that\n   should always be large enough. \
    \ 108 bytes is clearly too small as the\n   maximum size of a Routing header is\
    \ 2048 bytes.)\n"
- title: 20.2.  The cmsghdr Structure
  contents:
  - "20.2.  The cmsghdr Structure\n   The cmsghdr structure describes ancillary data\
    \ objects transferred by\n   recvmsg() and sendmsg().  Its Posix definition is:\n\
    \      struct cmsghdr {\n        socklen_t  cmsg_len;   /* #bytes, including this\
    \ header */\n        int        cmsg_level; /* originating protocol */\n     \
    \   int        cmsg_type;  /* protocol-specific type */\n                   /*\
    \ followed by unsigned char cmsg_data[]; */\n      };\n   This structure is declared\
    \ as a result of including <sys/socket.h>.\n   (Note: Before Posix the cmsg_len\
    \ member was an integer, and not a\n   socklen_t.  See the Note in the previous\
    \ section for why socklen_t is\n   used here.)\n   As shown in this definition,\
    \ normally there is no member with the\n   name cmsg_data[].  Instead, the data\
    \ portion is accessed using the\n   CMSG_xxx() macros, as described in Section\
    \ 20.3.  Nevertheless, it is\n   common to refer to the cmsg_data[] member.\n\
    \   When ancillary data is sent or received, any number of ancillary data\n  \
    \ objects can be specified by the msg_control and msg_controllen\n   members of\
    \ the msghdr structure, because each object is preceded by a\n   cmsghdr structure\
    \ defining the object's length (the cmsg_len member).\n   Historically Berkeley-derived\
    \ implementations have passed only one\n   object at a time, but this API allows\
    \ multiple objects to be passed\n   in a single call to sendmsg() or recvmsg().\
    \  The following example\n   shows two ancillary data objects in a control buffer.\n"
- title: '|<--------------------------- msg_controllen ------------------------->|'
  contents:
  - '|<--------------------------- msg_controllen ------------------------->|

    '
- title: '|                                 OR                                   |'
  contents:
  - '|                                 OR                                   |

    '
- title: '|<--------------------------- msg_controllen ---------------------->|'
  contents:
  - '|<--------------------------- msg_controllen ---------------------->|

    '
- title: '|                                                                      |'
  contents:
  - '|                                                                      |

    '
- title: '|<----- ancillary data object ----->|<---- ancillary data object ----->|'
  contents:
  - '|<----- ancillary data object ----->|<---- ancillary data object ----->|

    '
- title: '|<------ min CMSG_SPACE() --------->|<----- min CMSG_SPACE() --------->|'
  contents:
  - '|<------ min CMSG_SPACE() --------->|<----- min CMSG_SPACE() --------->|

    '
- title: '|                                   |                                  |'
  contents:
  - '|                                   |                                  |

    '
- title: '|<---------- cmsg_len ---------->|  |<-------- cmsg_len ----------->|  |'
  contents:
  - '|<---------- cmsg_len ---------->|  |<-------- cmsg_len ----------->|  |

    '
- title: '|<--------- CMSG_LEN() --------->|  |<------- CMSG_LEN() ---------->|  |'
  contents:
  - '|<--------- CMSG_LEN() --------->|  |<------- CMSG_LEN() ---------->|  |

    '
- title: '|                                |  |                               |  |'
  contents:
  - '|                                |  |                               |  |

    '
- title: +-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+
  contents:
  - '+-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+

    '
- title: '|cmsg_|cmsg_|cmsg_|XX|   cmsg_   |XX|cmsg_|cmsg_|cmsg_|XX|  cmsg_   |XX|'
  contents:
  - '|cmsg_|cmsg_|cmsg_|XX|   cmsg_   |XX|cmsg_|cmsg_|cmsg_|XX|  cmsg_   |XX|

    '
- title: '|len  |level|type |XX|   data[]  |XX|len  |level|type |XX|  data[]  |XX|'
  contents:
  - '|len  |level|type |XX|   data[]  |XX|len  |level|type |XX|  data[]  |XX|

    '
- title: +-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+
  contents:
  - '+-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+

    '
- title: ^
  contents:
  - '^

    '
- title: '|'
  contents:
  - '|

    '
- title: msg_control
  contents:
  - 'msg_control

    '
- title: points here
  contents:
  - "points here\n   The fields shown as \"XX\" are possible padding, between the\
    \ cmsghdr\n   structure and the data, and between the data and the next cmsghdr\n\
    \   structure, if required by the implementation.  While sending an\n   application\
    \ may or may not include padding at the end of last\n   ancillary data in msg_controllen\
    \ and implementations must accept both\n   as valid.  On receiving a portable\
    \ application must provide space for\n   padding at the end of the last ancillary\
    \ data as implementations may\n   copy out the padding at the end of the control\
    \ message buffer and\n   include it in the received msg_controllen.  When recvmsg()\
    \ is called\n   if msg_controllen is too small for all the ancillary data items\n\
    \   including any trailing padding after the last item an implementation\n   may\
    \ set MSG_CTRUNC.\n"
- title: 20.3.  Ancillary Data Object Macros
  contents:
  - "20.3.  Ancillary Data Object Macros\n   To aid in the manipulation of ancillary\
    \ data objects, three macros\n   from 4.4BSD are defined by Posix: CMSG_DATA(),\
    \ CMSG_NXTHDR(), and\n   CMSG_FIRSTHDR().  Before describing these macros, we\
    \ show the\n   following example of how they might be used with a call to recvmsg().\n\
    \      struct msghdr   msg;\n      struct cmsghdr  *cmsgptr;\n      /* fill in\
    \ msg */\n      /* call recvmsg() */\n      for (cmsgptr = CMSG_FIRSTHDR(&msg);\
    \ cmsgptr != NULL;\n           cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {\n     \
    \     if (cmsgptr->cmsg_len == 0) {\n              /* Error handling */\n    \
    \       break;\n          }\n          if (cmsgptr->cmsg_level == ... &&\n   \
    \           cmsgptr->cmsg_type == ... ) {\n              u_char  *ptr;\n     \
    \         ptr = CMSG_DATA(cmsgptr);\n              /* process data pointed to\
    \ by ptr */\n          }\n      }\n   We now describe the three Posix macros,\
    \ followed by two more that are\n   new with this API: CMSG_SPACE() and CMSG_LEN().\
    \  All these macros are\n   defined as a result of including <sys/socket.h>.\n"
- title: 20.3.1.  CMSG_FIRSTHDR
  contents:
  - "20.3.1.  CMSG_FIRSTHDR\n      struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr\
    \ *mhdr);\n   CMSG_FIRSTHDR() returns a pointer to the first cmsghdr structure\
    \ in\n   the msghdr structure pointed to by mhdr.  The macro returns NULL if\n\
    \   there is no ancillary data pointed to by the msghdr structure (that\n   is,\
    \ if either msg_control is NULL or if msg_controllen is less than\n   the size\
    \ of a cmsghdr structure).\n   One possible implementation could be\n      #define\
    \ CMSG_FIRSTHDR(mhdr) \\\n          ( (mhdr)->msg_controllen >= sizeof(struct\
    \ cmsghdr) ? \\\n            (struct cmsghdr *)(mhdr)->msg_control : \\\n    \
    \        (struct cmsghdr *)NULL )\n   (Note: Most existing implementations do\
    \ not test the value of\n   msg_controllen, and just return the value of msg_control.\
    \  The value\n   of msg_controllen must be tested, because if the application\
    \ asks\n   recvmsg() to return ancillary data, by setting msg_control to point\n\
    \   to the application's buffer and setting msg_controllen to the length\n   of\
    \ this buffer, the kernel indicates that no ancillary data is\n   available by\
    \ setting msg_controllen to 0 on return.  It is also\n   easier to put this test\
    \ into this macro, than making the application\n   perform the test.)\n"
- title: 20.3.2.  CMSG_NXTHDR
  contents:
  - "20.3.2.  CMSG_NXTHDR\n   As described in Section 5.1, CMSG_NXTHDR has been extended\
    \ to handle\n   a NULL 2nd argument to mean \"get the first header\".  This provides\
    \ an\n   alternative way of coding the processing loop shown earlier:\n      struct\
    \ msghdr  msg;\n      struct cmsghdr  *cmsgptr = NULL;\n      /* fill in msg */\n\
    \      /* call recvmsg() */\n      while ((cmsgptr = CMSG_NXTHDR(&msg, cmsgptr))\
    \ != NULL) {\n          if (cmsgptr->cmsg_len == 0) {\n              /* Error\
    \ handling */\n           break;\n          }\n          if (cmsgptr->cmsg_level\
    \ == ... &&\n              cmsgptr->cmsg_type == ... ) {\n              u_char\
    \  *ptr;\n              ptr = CMSG_DATA(cmsgptr);\n              /* process data\
    \ pointed to by ptr */\n          }\n      }\n   One possible implementation could\
    \ be:\n      #define CMSG_NXTHDR(mhdr, cmsg) \\\n        (((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr)\
    \ : \\\n         (((u_char *)(cmsg) + ALIGN_H((cmsg)->cmsg_len) \\\n         \
    \                   + ALIGN_D(sizeof(struct cmsghdr)) > \\\n           (u_char\
    \ *)((mhdr)->msg_control) + (mhdr)->msg_controllen) ? \\\n          (struct cmsghdr\
    \ *)NULL : \\\n          (struct cmsghdr *)((u_char *)(cmsg) + \\\n          \
    \                              ALIGN_H((cmsg)->cmsg_len))))\n   The macros ALIGN_H()\
    \ and ALIGN_D(), which are implementation\n   dependent, round their arguments\
    \ up to the next even multiple of\n   whatever alignment is required for the start\
    \ of the cmsghdr structure\n   and the data, respectively.  (This is probably\
    \ a multiple of 4 or 8\n   bytes.)  They are often the same macro in implementations\
    \ platforms\n   where alignment requirement for header and data is chosen to be\n\
    \   identical.\n"
- title: 20.3.3.  CMSG_DATA
  contents:
  - "20.3.3.  CMSG_DATA\n      unsigned char *CMSG_DATA(const struct cmsghdr *cmsg);\n\
    \   CMSG_DATA() returns a pointer to the data (what is called the\n   cmsg_data[]\
    \ member, even though such a member is not defined in the\n   structure) following\
    \ a cmsghdr structure.\n   One possible implementation could be:\n      #define\
    \ CMSG_DATA(cmsg) ( (u_char *)(cmsg) + \\\n                                ALIGN_D(sizeof(struct\
    \ cmsghdr)) )\n"
- title: 20.3.4.  CMSG_SPACE
  contents:
  - "20.3.4.  CMSG_SPACE\n   CMSG_SPACE is new with this API (see Section 5.2).  It\
    \ is used to\n   determine how much space needs to be allocated for an ancillary\
    \ data\n   item.\n   One possible implementation could be:\n      #define CMSG_SPACE(length)\
    \ ( ALIGN_D(sizeof(struct cmsghdr)) + \\\n                                   ALIGN_H(length)\
    \ )\n"
- title: 20.3.5.  CMSG_LEN
  contents:
  - "20.3.5.  CMSG_LEN\n   CMSG_LEN is new with this API (see Section 5.3).  It  returns\
    \ the\n   value to store in the cmsg_len member of the cmsghdr structure,\n  \
    \ taking into account any padding needed to satisfy alignment\n   requirements.\n\
    \   One possible implementation could be:\n      #define CMSG_LEN(length) ( ALIGN_D(sizeof(struct\
    \ cmsghdr)) + \\\n                                 length )\n"
- title: '21.  Appendix B: Examples Using the inet6_rth_XXX() Functions'
  contents:
  - "21.  Appendix B: Examples Using the inet6_rth_XXX() Functions\n   Here we show\
    \ an example for both sending Routing headers and\n   processing and reversing\
    \ a received Routing header.\n"
- title: 21.1.  Sending a Routing Header
  contents:
  - "21.1.  Sending a Routing Header\n   As an example of these Routing header functions\
    \ defined in this\n   document, we go through the function calls for the example\
    \ on p. 17\n   of [RFC-2460].  The source is S, the destination is D, and the\
    \ three\n   intermediate nodes are I1, I2, and I3.\n              S -----> I1\
    \ -----> I2 -----> I3 -----> D\n      src:    *    S         S         S     \
    \    S   S\n      dst:    D   I1        I2        I3         D   D\n      A[1]:\
    \  I1   I2        I1        I1        I1  I1\n      A[2]:  I2   I3        I3 \
    \       I2        I2  I2\n      A[3]:  I3    D         D         D        I3 \
    \ I3\n      #seg:   3    3         2         1         0   3\n   src and dst are\
    \ the source and destination IPv6 addresses in the IPv6\n   header.  A[1], A[2],\
    \ and A[3] are the three addresses in the Routing\n   header.  #seg is the Segments\
    \ Left field in the Routing header.\n   The six values in the column beneath node\
    \ S are the values in the\n   Routing header specified by the sending application\
    \ using sendmsg()\n   of setsockopt().  The function calls by the sender would\
    \ look like:\n      void  *extptr;\n      socklen_t   extlen;\n      struct msghdr\
    \  msg;\n      struct cmsghdr  *cmsgptr;\n      int   cmsglen;\n      struct sockaddr_in6\
    \  I1, I2, I3, D;\n      extlen = inet6_rth_space(IPV6_RTHDR_TYPE_0, 3);\n   \
    \   cmsglen = CMSG_SPACE(extlen);\n      cmsgptr = malloc(cmsglen);\n      cmsgptr->cmsg_len\
    \ = CMSG_LEN(extlen);\n      cmsgptr->cmsg_level = IPPROTO_IPV6;\n      cmsgptr->cmsg_type\
    \ = IPV6_RTHDR;\n      extptr = CMSG_DATA(cmsgptr);\n      extptr = inet6_rth_init(extptr,\
    \ extlen, IPV6_RTHDR_TYPE_0, 3);\n      inet6_rth_add(extptr, &I1.sin6_addr);\n\
    \      inet6_rth_add(extptr, &I2.sin6_addr);\n      inet6_rth_add(extptr, &I3.sin6_addr);\n\
    \      msg.msg_control = cmsgptr;\n      msg.msg_controllen = cmsglen;\n     \
    \ /* finish filling in msg{}, msg_name = D */\n      /* call sendmsg() */\n  \
    \ We also assume that the source address for the socket is not\n   specified (i.e.,\
    \ the asterisk in the figure).\n   The four columns of six values that are then\
    \ shown between the five\n   nodes are the values of the fields in the packet\
    \ while the packet is\n   in transit between the two nodes.  Notice that before\
    \ the packet is\n   sent by the source node S, the source address is chosen (replacing\n\
    \   the asterisk), I1 becomes the destination address of the datagram,\n   the\
    \ two addresses A[2] and A[3] are \"shifted up\", and D is moved to\n   A[3].\n\
    \   The columns of values that are shown beneath the destination node are\n  \
    \ the values returned by recvmsg(), assuming the application has\n   enabled both\
    \ the IPV6_RECVPKTINFO and IPV6_RECVRTHDR socket options.\n   The source address\
    \ is S (contained in the sockaddr_in6 structure\n   pointed to by the msg_name\
    \ member), the destination address is D\n   (returned as an ancillary data object\
    \ in an in6_pktinfo structure),\n   and the ancillary data object specifying the\
    \ Routing header will\n   contain three addresses (I1, I2, and I3).  The number\
    \ of segments in\n   the Routing header is known from the Hdr Ext Len field in\
    \ the Routing\n   header (a value of 6, indicating 3 addresses).\n   The return\
    \ value from inet6_rth_segments() will be 3 and\n   inet6_rth_getaddr(0) will\
    \ return I1, inet6_rth_getaddr(1) will return\n   I2, and inet6_rth_getaddr(2)\
    \ will return I3,\n   If the receiving application then calls inet6_rth_reverse(),\
    \ the\n   order of the three addresses will become I3, I2, and I1.\n   We can\
    \ also show what an implementation might store in the ancillary\n   data object\
    \ as the Routing header is being built by the sending\n   process.  If we assume\
    \ a 32-bit architecture where sizeof(struct\n   cmsghdr) equals 12, with a desired\
    \ alignment of 4-byte boundaries,\n   then the call to inet6_rth_space(3) returns\
    \ 68: 12 bytes for the\n   cmsghdr structure and 56 bytes for the Routing header\
    \ (8 + 3*16).\n   The call to inet6_rth_init() initializes the ancillary data\
    \ object to\n   contain a Type 0 Routing header:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |       cmsg_len = 20                                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \       cmsg_level = IPPROTO_IPV6                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |       cmsg_type = IPV6_RTHDR                                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=0   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           Reserved                            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The\
    \ first call to inet6_rth_add() adds I1 to the list.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |       cmsg_len = 36                                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \       cmsg_level = IPPROTO_IPV6                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |       cmsg_type = IPV6_RTHDR                                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=1   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           Reserved                            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      +   \
    \                                                            +\n      |      \
    \                                                         |\n      +         \
    \                  Address[1] = I1                     +\n      |            \
    \                                                   |\n      +               \
    \                                                +\n      |                  \
    \                                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   cmsg_len is incremented by 16, and the Segments Left field is\n   incremented\
    \ by 1.\n   The next call to inet6_rth_add() adds I2 to the list.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |       cmsg_len = 52                                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \       cmsg_level = IPPROTO_IPV6                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |       cmsg_type = IPV6_RTHDR                                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=2   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           Reserved                            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      +   \
    \                                                            +\n      |      \
    \                                                         |\n      +         \
    \                  Address[1] = I1                     +\n      |            \
    \                                                   |\n      +               \
    \                                                +\n      |                  \
    \                                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   +                                                               +\n      |\
    \                                                               |\n      +   \
    \                        Address[2] = I2                     +\n      |      \
    \                                                         |\n      +         \
    \                                                      +\n      |            \
    \                                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   cmsg_len is incremented by 16, and the Segments Left field is\n   incremented\
    \ by 1.\n   The last call to inet6_rth_add() adds I3 to the list.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |       cmsg_len = 68                                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \       cmsg_level = IPPROTO_IPV6                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |       cmsg_type = IPV6_RTHDR                                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=3   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           Reserved                            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      +   \
    \                                                            +\n      |      \
    \                                                         |\n      +         \
    \                  Address[1] = I1                     +\n      |            \
    \                                                   |\n      +               \
    \                                                +\n      |                  \
    \                                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   +                                                               +\n      |\
    \                                                               |\n      +   \
    \                        Address[2] = I2                     +\n      |      \
    \                                                         |\n      +         \
    \                                                      +\n      |            \
    \                                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   +                                                               +\n      |\
    \                                                               |\n      +   \
    \                        Address[3] = I3                     +\n      |      \
    \                                                         |\n      +         \
    \                                                      +\n      |            \
    \                                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   cmsg_len is incremented by 16, and the Segments Left field is\n   incremented\
    \ by 1.\n"
- title: 21.2.  Receiving Routing Headers
  contents:
  - "21.2.  Receiving Routing Headers\n   This example assumes that the application\
    \ has enabled IPV6_RECVRTHDR\n   socket option.  The application prints and reverses\
    \ a source route\n   and uses that to echo the received data.\n      struct sockaddr_in6\
    \     addr;\n      struct msghdr           msg;\n      struct iovec          \
    \  iov;\n      struct cmsghdr          *cmsgptr;\n      socklen_t            \
    \   cmsgspace;\n      void                    *extptr;\n      int            \
    \         extlen;\n      int                     segments;\n      int        \
    \             i;\n      char                    databuf[8192];\n      segments\
    \ = 100;        /* Enough */\n      extlen = inet6_rth_space(IPV6_RTHDR_TYPE_0,\
    \ segments);\n      cmsgspace = CMSG_SPACE(extlen);\n      cmsgptr = malloc(cmsgspace);\n\
    \      if (cmsgptr == NULL) {\n              perror(\"malloc\");\n           \
    \   exit(1);\n      }\n      extptr = CMSG_DATA(cmsgptr);\n      msg.msg_control\
    \ = cmsgptr;\n      msg.msg_controllen = cmsgspace;\n      msg.msg_name = (struct\
    \ sockaddr *)&addr;\n      msg.msg_namelen = sizeof (addr);\n      msg.msg_iov\
    \ = &iov;\n      msg.msg_iovlen = 1;\n      iov.iov_base = databuf;\n      iov.iov_len\
    \ = sizeof (databuf);\n      msg.msg_flags = 0;\n      if (recvmsg(s, &msg, 0)\
    \ == -1) {\n              perror(\"recvmsg\");\n              return;\n      }\n\
    \      if (msg.msg_controllen != 0 &&\n          cmsgptr->cmsg_level == IPPROTO_IPV6\
    \ &&\n          cmsgptr->cmsg_type == IPV6_RTHDR) {\n              struct in6_addr\
    \ *in6;\n              char asciiname[INET6_ADDRSTRLEN];\n              struct\
    \ ip6_rthdr *rthdr;\n              rthdr = (struct ip6_rthdr *)extptr;\n     \
    \         segments = inet6_rth_segments(extptr);\n              printf(\"route\
    \ (%d segments, %d left): \",\n                  segments, rthdr->ip6r_segleft);\n\
    \              for (i = 0; i < segments; i++) {\n                      in6 = inet6_rth_getaddr(extptr,\
    \ i);\n                      if (in6 == NULL)\n                              printf(\"\
    <NULL> \");\n                      else\n                              printf(\"\
    %s \", inet_ntop(AF_INET6,\n                                  (void *)in6->s6_addr,\n\
    \                                  asciiname, INET6_ADDRSTRLEN));\n          \
    \    }\n              if (inet6_rth_reverse(extptr, extptr) == -1) {\n       \
    \               printf(\"reverse failed\");\n                      return;\n \
    \             }\n      }\n      iov.iov_base = databuf;\n      iov.iov_len = strlen(databuf);\n\
    \      if (sendmsg(s, &msg, 0) == -1)\n              perror(\"sendmsg\");\n  \
    \    if (cmsgptr != NULL)\n              free(cmsgptr);\n   Note: The above example\
    \ is a simple illustration.  It skips some\n   error checks, including those involving\
    \ the MSG_TRUNC and MSG_CTRUNC\n   flags.  It also leaves some type mismatches\
    \ in favor of brevity.\n"
- title: '22.  Appendix C: Examples Using the inet6_opt_XXX() Functions'
  contents:
  - "22.  Appendix C: Examples Using the inet6_opt_XXX() Functions\n   This shows\
    \ how Hop-by-Hop and Destination options can be both built\n   as well as parsed\
    \ using the inet6_opt_XXX() functions.  These\n   examples assume that there are\
    \ defined values for OPT_X and OPT_Y.\n   Note: The example is a simple illustration.\
    \  It skips some error\n   checks and leaves some type mismatches in favor of\
    \ brevity.\n"
- title: 22.1.  Building Options
  contents:
  - "22.1.  Building Options\n   We now provide an example that builds two Hop-by-Hop\
    \ options using\n   the example in Appendix B of [RFC-2460].\n      void *extbuf;\n\
    \      socklen_t extlen;\n      int currentlen;\n      void *databuf;\n      int\
    \ offset;\n      uint8_t value1;\n      uint16_t value2;\n      uint32_t value4;\n\
    \      uint64_t value8;\n      /* Estimate the length */\n      currentlen = inet6_opt_init(NULL,\
    \ 0);\n      if (currentlen == -1)\n              return (-1);\n      currentlen\
    \ = inet6_opt_append(NULL, 0, currentlen, OPT_X,\n                           \
    \         12, 8, NULL);\n      if (currentlen == -1)\n              return (-1);\n\
    \      currentlen = inet6_opt_append(NULL, 0, currentlen, OPT_Y,\n           \
    \                         7, 4, NULL);\n      if (currentlen == -1)\n        \
    \      return (-1);\n      currentlen = inet6_opt_finish(NULL, 0, currentlen);\n\
    \      if (currentlen == -1)\n              return (-1);\n      extlen = currentlen;\n\
    \      extbuf = malloc(extlen);\n      if (extbuf == NULL) {\n              perror(\"\
    malloc\");\n              return (-1);\n      }\n      currentlen = inet6_opt_init(extbuf,\
    \ extlen);\n      if (currentlen == -1)\n              return (-1);\n      currentlen\
    \ = inet6_opt_append(extbuf, extlen, currentlen,\n          OPT_X, 12, 8, &databuf);\n\
    \      if (currentlen == -1)\n              return (-1);\n      /* Insert value\
    \ 0x12345678 for 4-octet field */\n      offset = 0;\n      value4 = 0x12345678;\n\
    \      offset = inet6_opt_set_val(databuf, offset,\n                         \
    \        &value4, sizeof (value4));\n      /* Insert value 0x0102030405060708\
    \ for 8-octet field */\n      value8 = 0x0102030405060708;\n      offset = inet6_opt_set_val(databuf,\
    \ offset,\n                                 &value8, sizeof (value8));\n     \
    \ currentlen = inet6_opt_append(extbuf, extlen, currentlen,\n          OPT_Y,\
    \ 7, 4, &databuf);\n      if (currentlen == -1)\n              return (-1);\n\
    \      /* Insert value 0x01 for 1-octet field */\n      offset = 0;\n      value1\
    \ = 0x01;\n      offset = inet6_opt_set_val(databuf, offset,\n               \
    \                  &value1, sizeof (value1));\n      /* Insert value 0x1331 for\
    \ 2-octet field */\n      value2 = 0x1331;\n      offset = inet6_opt_set_val(databuf,\
    \ offset,\n                                 &value2, sizeof (value2));\n     \
    \ /* Insert value 0x01020304 for 4-octet field */\n      value4 = 0x01020304;\n\
    \      offset = inet6_opt_set_val(databuf, offset,\n                         \
    \        &value4, sizeof (value4));\n      currentlen = inet6_opt_finish(extbuf,\
    \ extlen, currentlen);\n      if (currentlen == -1)\n              return (-1);\n\
    \      /* extbuf and extlen are now completely formatted */\n"
- title: 22.2.  Parsing Received Options
  contents:
  - "22.2.  Parsing Received Options\n   This example parses and prints the content\
    \ of the two options in the\n   previous example.\n      int\n      print_opt(void\
    \ *extbuf, socklen_t extlen)\n      {\n              struct ip6_dest *ext;\n \
    \             int currentlen;\n              uint8_t type;\n              socklen_t\
    \ len;\n              void *databuf;\n              int offset;\n            \
    \  uint8_t value1;\n              uint16_t value2;\n              uint32_t value4;\n\
    \              uint64_t value8;\n              ext = (struct ip6_dest *)extbuf;\n\
    \              printf(\"nxt %u, len %u (bytes %d)\\n\", ext->ip6d_nxt,\n     \
    \             ext->ip6d_len, (ext->ip6d_len + 1) * 8);\n              currentlen\
    \ = 0;\n              while (1) {\n                      currentlen = inet6_opt_next(extbuf,\
    \ extlen,\n                                                  currentlen, &type,\n\
    \                                                  &len, &databuf);\n        \
    \              if (currentlen == -1)\n                              break;\n \
    \                     printf(\"Received opt %u len %u\\n\",\n                \
    \          type, len);\n                      switch (type) {\n              \
    \        case OPT_X:\n                              offset = 0;\n            \
    \                  offset =\n                                  inet6_opt_get_val(databuf,\
    \ offset,\n                                                    &value4,\n    \
    \                                                sizeof (value4));\n         \
    \                     printf(\"X 4-byte field %x\\n\", value4);\n            \
    \                  offset =\n                                  inet6_opt_get_val(databuf,\
    \ offset,\n                                                    &value8,\n    \
    \                                                sizeof (value8));\n         \
    \                     printf(\"X 8-byte field %llx\\n\", value8);\n          \
    \                    break;\n                      case OPT_Y:\n             \
    \                 offset = 0;\n                              offset =\n      \
    \                            inet6_opt_get_val(databuf, offset,\n            \
    \                                        &value1,\n                          \
    \                          sizeof (value1));\n                              printf(\"\
    Y 1-byte field %x\\n\", value1);\n                              offset =\n   \
    \                               inet6_opt_get_val(databuf, offset,\n         \
    \                                           &value2,\n                       \
    \                             sizeof (value2));\n                            \
    \  printf(\"Y 2-byte field %x\\n\", value2);\n                              offset\
    \ =\n                                  inet6_opt_get_val(databuf, offset,\n  \
    \                                                  &value4,\n                \
    \                                    sizeof (value4));\n                     \
    \         printf(\"Y 4-byte field %x\\n\", value4);\n                        \
    \      break;\n                      default:\n                              printf(\"\
    Unknown option %u\\n\", type);\n                              break;\n       \
    \               }\n              }\n              return (0);\n      }\n"
- title: 23. Authors' Addresses
  contents:
  - "23. Authors' Addresses\n   W. Richard Stevens (deceased)\n   Matt Thomas\n  \
    \ 3am Software Foundry\n   8053 Park Villa Circle\n   Cupertino, CA 95014\n  \
    \ EMail: matt@3am-software.com\n   Erik Nordmark\n   Sun Microsystems Laboratories,\
    \ Europe\n   180, avenue de l'Europe\n   38334 SAINT ISMIER Cedex, France\n  \
    \ Phone: +33 (0)4 74 18 88 03\n   Fax:   +33 (0)4 76 18 88 88\n   EMail: Erik.Nordmark@sun.com\n\
    \   Tatuya JINMEI\n   Corporate Research & Development Center, Toshiba Corporation\n\
    \   1 Komukai Toshiba-cho, Kawasaki-shi\n   Kanagawa 212-8582, Japan\n   EMail:\
    \ jinmei@isl.rdc.toshiba.co.jp\n"
- title: 24. Full Copyright Statement
  contents:
  - "24. Full Copyright Statement\n   Copyright (C) The Internet Society (2003). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
