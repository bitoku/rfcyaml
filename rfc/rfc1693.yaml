- title: __initial_text__
  contents:
  - '              An Extension to TCP : Partial Order Service

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  This memo does not specify an Internet standard of any\n   kind.\
    \  Discussion and suggestions for improvement are requested.\n   Distribution\
    \ of this memo is unlimited\n   Note that the work contained in this memo does\
    \ not describe an\n   Internet standard.  The Transport AD and Transport Directorate\
    \ do not\n   recommend the implementation of the TCP modifications described.\n\
    \   However, outside the context of TCP, we find that the memo offers a\n   useful\
    \ analysis of how misordered and incomplete data may be handled.\n   See, for\
    \ example, the discussion of Application Layer Framing by D.\n   Clark and D.\
    \ Tennenhouse in, \"Architectural Considerations for a New\n   Generation of Protocols\"\
    , SIGCOM 90 Proceedings, ACM, September 1990.\n"
- title: Abstract
  contents:
  - "Abstract\n   This RFC introduces a new transport mechanism for TCP based upon\n\
    \   partial ordering.  The aim is to present the concepts of partial\n   ordering\
    \ and promote discussions on its usefulness in network\n   communications.  Distribution\
    \ of this memo is unlimited.\n"
- title: Introduction
  contents:
  - "Introduction\n   A service which allows partial order delivery and partial reliability\n\
    \   is one which requires some, but not all objects to be received in the\n  \
    \ order transmitted while also allowing objects to be transmitted\n   unreliably\
    \ (i.e., some may be lost).\n   The realization of such a service requires, (1)\
    \ communication and/or\n   negotiation of what constitutes a valid ordering and/or\
    \ loss-level,\n   and (2) an algorithm which enables the receiver to ascertain\
    \ the\n   deliverability of objects as they arrive.  These issues are addressed\n\
    \   here - both conceptually and formally - summarizing the results of\n   research\
    \ and initial implementation efforts.\n   The authors envision the use of a partial\
    \ order service within a\n   connection-oriented, transport protocol such as TCP\
    \ providing a\n   further level of granularity to the transport user in terms\
    \ of the\n   type and quality of offered service.  This RFC focuses specifically\n\
    \   on extending TCP to provide partial order connections.\n   The idea of a partial\
    \ order service is not limited to TCP. It may be\n   considered a useful option\
    \ for any transport protocol and we\n   encourage researchers and practitioners\
    \ to investigate further the\n   most effective uses for partial ordering whether\
    \ in a next-generation\n   TCP, or another general purpose protocol such as XTP,\
    \ or perhaps\n   within a \"special purpose\" protocol tailored to a specific\n\
    \   application and network profile.\n   Finally, while the crux of this RFC relates\
    \ to and introduces a new\n   way of considering object ordering, a number of\
    \ other classic\n   transport mechanisms are also seen in a new light - among\
    \ these are\n   reliability, window management and data acknowledgments.\n   Keywords:\
    \ partial order, quality of service, reliability, multimedia,\n   client/server\
    \ database, Windows, transport protocol\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction and motivation ..................................\
    \  3\n   2. Partial Order Delivery .......................................  4\n\
    \   2.1 Example 1: Remote Database ..................................  4\n   2.2\
    \ Example 2: Multimedia .......................................  8\n   2.3 Example\
    \ 3: Windows Screen Refresh ...........................  9\n   2.4 Potential Savings\
    \ ........................................... 10\n   3. Reliability vs. Order\
    \ ........................................ 12\n   3.1 Reliability Classes .........................................\
    \ 13\n   4. Partial Order Connection ..................................... 15\n\
    \   4.1 Connection Establishment .................................... 16\n   4.2\
    \ Data Transmission ........................................... 19\n   4.2.1 Sender\
    \ .................................................... 22\n   4.2.2 Receiver ..................................................\
    \ 25\n   5. Quantifying and Comparing Partial Order Services ............. 30\n\
    \   6. Future Direction ............................................. 31\n   7.\
    \ Summary ...................................................... 32\n   8. References\
    \ ................................................... 34\n   Security Considerations\
    \ ......................................... 35\n   Authors' Addresses ..............................................\
    \ 36\n"
- title: 1. Introduction and motivation
  contents:
  - "1. Introduction and motivation\n   Current applications that need to communicate\
    \ objects (i.e., octets,\n   packets, frames, protocol data units) usually choose\
    \ between a fully\n   ordered service such as that currently provided by TCP and\
    \ one that\n   does not guarantee any ordering such as that provided by UDP. \
    \ A\n   similar \"all-or-nothing\" choice is made for object reliability -\n \
    \  reliable connections which guarantee all objects will be delivered\n   verses\
    \ unreliable data transport which makes no guarantee.  What is\n   more appropriate\
    \ for some applications is a partial order and/or\n   partial reliability service\
    \ where a subset of objects being\n   communicated must arrive in the order transmitted,\
    \ yet some objects\n   may arrive in a different order, and some (well specified\
    \ subset) of\n   the objects may not arrive at all.\n   One motivating application\
    \ for a partial order service is the\n   emerging area of multimedia communications.\
    \  Multimedia traffic is\n   often characterized either by periodic, synchronized\
    \ parallel streams\n   of information (e.g., combined audio-video), or by structured\
    \ image\n   streams (e.g., displays of multiple overlapping and nonoverlapping\n\
    \   windows).  These applications have a high degree of tolerance for\n   less-than-fully-ordered\
    \ data transport as well as data loss.  Thus\n   they are ideal candidates for\
    \ using a partial order, partial\n   reliability service.  In general, any application\
    \ which communicates\n   parallel and/or independent data structures may potentially\
    \ be able\n   to profit from a partial order service.\n   A second application\
    \ that could benefit from a partial order service\n   involves remote or distributed\
    \ databases.  Imagine the case where a\n   database user transmitting queries\
    \ to a remote server expects objects\n   (or records) to be returned in some order,\
    \ although not necessarily\n   total order.  For example a user writing an SQL\
    \ data query might\n   specify this with the \"order by\" clause.  There exist\
    \ today a great\n   number of commercial implementations of distributed databases\
    \ which\n   utilize - and thus are penalized by - an ordered delivery service.\n\
    \   Currently these applications must use and pay for a fully\n   ordered/fully\
    \ reliable service even though they do not need it.  The\n   introduction of partial\
    \ services allows applications to lower the\n   demanded quality of service (QOS)\
    \ of the communication assuming that\n   such a service is more efficient and\
    \ less costly.  In effect, a\n   partial order extends the service level from\
    \ two extremes - ordered\n   and unordered - to a range of discreet values encompassing\
    \ both of\n   the extremes and all possible partial orderings in between.  A\n\
    \   similar phenomenon is demonstrated in the area of reliability.\n   It is worth\
    \ mentioning that a TCP implementation providing a partial\n   order service,\
    \ as described here, would be able to communicate with a\n   non-partial order\
    \ implementation simply by recognizing this fact at\n   connection establishment\
    \ - hence this extension is backward\n   compatible with earlier versions of TCP.\
    \  Furthermore, it is\n   conceivable for a host to support the sending-half (or\
    \ receiving-\n   half) of a partial order connection alone to reduce the size\
    \ of the\n   TCP as well as the effort involved in the implementation.  Similar\n\
    \   \"levels of conformance\" have been proposed in other internet\n   extensions\
    \ such as [Dee89] involving IP multicasting.\n   This RFC proceeds as follows.\
    \  The principles of partial order\n   delivery, published in [ACCD93a], are presented\
    \ in Section 2.  The\n   notion of partial reliability, published in [ACCD93b],\
    \ is introduced\n   in Section 3 followed by an explanation of \"reliability classes\"\
    .\n   Then, the practical issues involved with setting up and maintaining a\n\
    \   Partial Order Connection (POC) within a TCP framework are addressed\n   in\
    \ Section 4 looking first at connection establishment, and then\n   discussing\
    \ the sender's role and the receiver's role.  Section 5\n   provides insights\
    \ into the expected performance improvements of a\n   partial order service over\
    \ an ordered service and Section 6 discusses\n   some future directions.  Concluding\
    \ remarks are given in Section 7.\n"
- title: 2. Partial Order Delivery
  contents:
  - "2. Partial Order Delivery\n   Partial order services are needed and can be employed\
    \ as soon as a\n   complete ordering is not mandatory.  When two objects can be\n\
    \   delivered in either order, there is no need to use an ordered service\n  \
    \ that must delay delivery of the second one transmitted until the\n   first arrives\
    \ as the following examples demonstrate.\n"
- title: '2.1 Example 1: Remote Database'
  contents:
  - "2.1 Example 1: Remote Database\n   Simpson's Sporting Goods (SSG) has recently\
    \ installed a state-of-\n   the-art enterprise-wide network.  Their first \"network\
    \ application\"\n   is a client/server SQL database with the following four records,\n\
    \   numbered {1 2 3 4} for convenience:\n         SALESPERSON    LOCATION    \
    \       CHARGES    DESCRIPTION\n         -------------  -----------------  ---------\
    \  -----------------\n      1  Anderson       Atlanta, GA        $4,200     Camping\
    \ Gear\n      2  Baker          Boston, MA           $849     Camping Gear\n \
    \     3  Crowell        Boston, MA         $9,500     Sportswear\n      4  Dykstra\
    \        Wash., DC          $1,000     Sportswear\n   SSG employees running the\
    \ client-side of the application can query\n   the database server from any location\
    \ in the enterprise net using\n   standard SQL commands and the results will be\
    \ displayed on their\n   screen.  From the employee's perspective, the network\
    \ is completely\n   reliable and delivers data (records) in an order that conforms\
    \ to\n   their SQL request.  In reality though, it is the transport layer\n  \
    \ protocol which provides the reliability and order on top of an\n   unreliable\
    \ network layer - one which introduces loss, duplication,\n   and disorder.\n\
    \   Consider the four cases in Figure 1 - in the first query (1.a),\n   ordered\
    \ by SALESPERSON, the records have only one acceptable order at\n   the destination,\
    \ 1,2,3,4.  This is evident due to the fact that there\n   are four distinct salespersons.\
    \  If record 2 is received before\n   record 1 due to a network loss during transmission,\
    \ the transport\n   service can not deliver it and must therefore buffer it until\
    \ record\n   1 arrives.  An ordered service, also referred to as a virtual circuit\n\
    \   or FIFO channel, provides the desired level of service in this case.\n   At\
    \ the other extreme, an unordered service is motivated in Figure 1.d\n   where\
    \ the employee has implicitly specified that any ordering is\n   valid simply\
    \ by omitting the \"order by\" clause.  Here any of 4! = 24\n   delivery orderings\
    \ would satisfy the application, or from the\n   transport layer's point of view,\
    \ all records are immediately\n   deliverable as soon as they arrive from the\
    \ network.  No record needs\n   to buffered should it arrive out of sequential\
    \ order.  As notation, 4\n   ordered objects are written 1;2;3;4 and 4 unordered\
    \ objects are\n   written using a parallel operator: 1||2||3||4.\n   Figures 1.b\
    \ and 1.c demonstrate two possible partial orders that\n   permit 2 and 4 orderings\
    \ respectively at the destination.  Using the\n   notation just described, the\
    \ valid orderings for the query in 1.b are\n   specified as 1;(2||3);4, which\
    \ is to say that record 1 must be\n   delivered first followed by record 2 and\
    \ 3 in either order followed\n   by record 4.  Likewise, the ordering for 1.c\
    \ is (1||2);(3||4).  In\n   these two cases, an ordered service is too strict\
    \ and an unordered\n   service is not strict enough.\n   +-----------------------------------------------------------------+\n\
    \   |    SELECT SALESPERSON, LOCATION, CHARGES, DESCRIPTION           |\n   |\
    \    FROM BILLING_TABLE                                           |\n   |    \
    \                                                             |\n   |    SALESPERSON\
    \    LOCATION           CHARGES    DESCRIPTION     |\n   |    -------------  -----------------\
    \  ---------  --------------- |\n   | 1  Anderson       Atlanta, GA        $4,200\
    \     Camping Gear    |\n   | 2  Baker          Boston, MA           $849    \
    \ Camping Gear    |\n   | 3  Crowell        Boston, MA         $9,500     Sportswear\
    \      |\n   | 4  Dykstra        Wash., DC          $1,000     Sportswear    \
    \  |\n   +=================================================================+\n\
    \   |a -  ORDER BY SALESPERSON                                        |\n   |\
    \                                                                 |\n   |  1,2,3,4\
    \                                          1,2,3,4       |\n   |             \
    \                                                    |\n   | Sender ----------->\
    \   NETWORK   -------------->   Receiver      |\n   |                        \
    \                      (1 valid ordering) |\n   +-----------------------------------------------------------------+\n\
    \   |b -  ORDER BY LOCATION                                           |\n   |\
    \                                                   1,2,3,4       |\n   |  1,2,3,4\
    \                                          1,3,2,4       |\n   |             \
    \                                                    |\n   | Sender ----------->\
    \   NETWORK   -------------->   Receiver      |\n   |                        \
    \                     (2 valid orderings) |\n   +-----------------------------------------------------------------+\n\
    \   |c -  ORDER BY DESCRIPTION                                        |\n   |\
    \                                                   1,2,3,4       |\n   |    \
    \                                               2,1,3,4       |\n   | 1,2,3,4\
    \                                           1,2,4,3       |\n   |            \
    \                                       2,1,4,3       |\n   |                \
    \                                                 |\n   | Sender ----------->\
    \   NETWORK   -------------->   Receiver      |\n   |                        \
    \                     (4 valid orderings) |\n   +-----------------------------------------------------------------+\n\
    \   |d - (no order by clause)                                         |\n   |\
    \                                                   1,2,3,4       |\n   |    \
    \                                               1,2,4,3       |\n   | 1,2,3,4\
    \                                             ...         |\n   |            \
    \                                       4,3,2,1       |\n   |                \
    \                                                 |\n   | Sender ----------->\
    \   NETWORK   -------------->   Receiver      |\n   |                        \
    \                 (4!=24 valid orderings) |\n   +-----------------------------------------------------------------+\n\
    \      Figure 1: Ordered vs. Partial Ordered vs. Unordered Delivery\n   It is\
    \ vital for the transport layer to recognize the exact\n   requirements of the\
    \ application and to ensure that these are met.\n   However, there is no inherent\
    \ need to exceed these requirements; on\n   the contrary, by exceeding these requirements\
    \ unecessary resources\n   are consumed.  This example application requires a\
    \ reliable\n   connection - all records must eventually be delivered - but has\
    \ some\n   flexibility when it comes to record ordering.\n   In this example,\
    \ each query has a different partial order.  In total,\n   there exist 16 different\
    \ partial orders for the desired 4 records.\n   For an arbitrary number of objects\
    \ N, there exist many possible\n   partial orders each of which accepts some number\
    \ of valid orderings\n   between 1 and N!  (which correspond to the ordered and\
    \ unordered\n   cases respectively).  For some classes of partial orders, the\
    \ number\n   of valid orderings can be calculated easily, for others this\n  \
    \ calculation is intractable.  An in-depth discussion on calculating\n   and comparing\
    \ the number of orderings for a given partial order can\n   be found in [ACCD93a].\n"
- title: '2.2 Example 2: Multimedia'
  contents:
  - "2.2 Example 2: Multimedia\n   A second example application that motivates a partial\
    \ order service\n   is a multimedia broadcast involving video, audio and text\
    \ components.\n   Consider an extended presentation of the evening news - extended\
    \ to\n   include two distinct audio channels, a text subtitle and a closed-\n\
    \   captioned sign language video for the hearing impaired, in addition\n   to\
    \ the normal video signal, as modeled by the following diagram.\n            (left\
    \ audio)                     (right audio)\n              +------+           \
    \              +------+\n              | ++++ |                         | ++++\
    \ |\n              | ++++ |                         | ++++ |\n              +------+\
    \                         +------+\n         ===================================================\n\
    \         I                                +---------------+I\n         I    \
    \                            |               |I\n         I                  \
    \              |  (hand signs) |I\n         I                                |\
    \               |I\n         I                                +---------------+I\n\
    \         I                                                 I\n         I    \
    \                                             I\n         I          (Main Video)\
    \                           I\n         I                                    \
    \             I\n         I                                                 I\n\
    \         I                                                 I\n         I    \
    \                                             I\n         I  +------------------------------------------+\
    \   I\n         I  |     (text subtitle)                      |   I\n        \
    \ I  +------------------------------------------+   I\n         I            \
    \                                     I\n         ===================================================\n\
    \            Figure 2: Multimedia broadcast example\n  The multimedia signals\
    \ have differing characteristics.  The main video\n  signal may consist of full\
    \ image graphics at a rate of 30 images/sec\n  while the video of hand signs requires\
    \ a lower quality, say 10\n  images/sec.  Assume the audio signals are each divided\
    \ into 60 sound\n  fragments/sec and the text object each second consists of either\
    \ (1)\n  new text, (2) a command to keep the previous second of text, or (3) a\n\
    \  command for no subtitle.\n  During a one-second interval of the broadcast,\
    \ a sender transmits 30\n  full-motion video images, 10 closed-captioned hand\
    \ sign images, 60\n  packets of a digitized audio signal for each of the audio\
    \ streams and\n  a single text packet.  The following diagram then might represent\
    \ the\n  characteristics of the multimedia presentation in terms of the media\n\
    \  types, the number of each, and their ordering.  Objects connected by a\n  horizontal\
    \ line must be received in order, while those in parallel\n  have no inherent\
    \ ordering requirement.\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                                                                      |'
  contents:
  - '|                                                                      |

    '
- title: '|  |-o-|-o-|-o-|-o-|-o-|-o-|-o-|-o-|-o-...-o-|-o-|-o-|  right audio    |'
  contents:
  - '|  |-o-|-o-|-o-|-o-|-o-|-o-|-o-|-o-|-o-...-o-|-o-|-o-|  right audio    |

    '
- title: '|  |   |   |   |   |   |   |   |   |         |   |   |  (60/sec)       |'
  contents:
  - '|  |   |   |   |   |   |   |   |   |         |   |   |  (60/sec)       |

    '
- title: '|  |   |   |   |   |   |   |   |   |         |   |   |                 |'
  contents:
  - '|  |   |   |   |   |   |   |   |   |         |   |   |                 |

    '
- title: '|  |-o-|-o-|-o-|-o-|-o-|-o-|-o-|-o-|-o-...-o-|-o-|-o-|  left audio     |'
  contents:
  - '|  |-o-|-o-|-o-|-o-|-o-|-o-|-o-|-o-|-o-...-o-|-o-|-o-|  left audio     |

    '
- title: '|  |       |       |       |       |         |       |  (60/sec)       |'
  contents:
  - '|  |       |       |       |       |         |       |  (60/sec)       |

    '
- title: '|  |       |       |       |       |         |       |                 |'
  contents:
  - '|  |       |       |       |       |         |       |                 |

    '
- title: '|  |---o---|---o---|---o---|---o---|---...---|---o---|  normal video   |'
  contents:
  - '|  |---o---|---o---|---o---|---o---|---...---|---o---|  normal video   |

    '
- title: '|  |                       |                         |  (30/sec)       |'
  contents:
  - '|  |                       |                         |  (30/sec)       |

    '
- title: '|  |                       |                         |                 |'
  contents:
  - '|  |                       |                         |                 |

    '
- title: '|  |-----------o-----------|--------o--...--------o--|  hand signs     |'
  contents:
  - '|  |-----------o-----------|--------o--...--------o--|  hand signs     |

    '
- title: '|  |                                                 |  (10/sec)       |'
  contents:
  - '|  |                                                 |  (10/sec)       |

    '
- title: '|  |                                                 |                 |'
  contents:
  - '|  |                                                 |                 |

    '
- title: '|  |-----------------------------o-----...-----------|  text           |'
  contents:
  - '|  |-----------------------------o-----...-----------|  text           |

    '
- title: '|  |                                                 |  (1/sec)        |'
  contents:
  - '|  |                                                 |  (1/sec)        |

    '
- title: '|                                                                      |'
  contents:
  - '|                                                                      |

    '
- title: +----------------------------------------------------------------------+
  contents:
  - "+----------------------------------------------------------------------+\n  \
    \        Figure 3: Object ordering in multimedia application\n   Of particular\
    \ interest to our discussion of partial ordering is the\n   fact that, while objects\
    \ of a given media type generally must be\n   received in order, there exists\
    \ flexibility between the separate\n   \"streams\" of multimedia data (where a\
    \ \"stream\" represents the\n   sequence of objects for a specific media type).\
    \  Another significant\n   characteristic of this example is the repeating nature\
    \ of the object\n   orderings.  Figure 3 represents a single, one-second, partial\
    \ order\n   snapshot in a stream of possibly thousands of repeating sequential\n\
    \   periods of communication.\n   It is assumed that further synchronization concerns\
    \ in presenting the\n   objects are addressed by a service provided on top of\
    \ the proposed\n   partial order service.  Temporal ordering for synchronized\
    \ playback\n   is considered, for example, in [AH91, HKN91].\n"
- title: '2.3 Example 3: Windows Screen Refresh'
  contents:
  - "2.3 Example 3: Windows Screen Refresh\n   A third example to motivate a partial\
    \ order service involves\n   refreshing a workstation screen/display containing\
    \ multiple windows\n   from a remote source.  In this case, objects (icons, still\
    \ or video\n   images) that do not overlap have a \"parallel\" relationship (i.e.,\n\
    \   their order of refreshing is independent) while overlapping screen\n   objects\
    \ have a \"sequential\" relationship and should be delivered in\n   order.  Therefore,\
    \ the way in which the windows overlap induces a\n   partial order.\n   Consider\
    \ the two cases in Figure 4.  A sender wishes to refresh a\n   remote display\
    \ that contains four active windows (objects) named {1 2\n   3 4}.  Assume the\
    \ windows are transmitted in numerical order and the\n   receiving application\
    \ refreshes windows as soon as the transport\n   service delivers them.  If the\
    \ windows are configured as in Figure\n   4a, then there exist two different orderings\
    \ for redisplay, namely\n   1,2,3,4 or 1,3,2,4.  If window 2 is received before\
    \ window 1, the\n   transport service cannot deliver it or an incorrect image\
    \ will be\n   displayed.  In Figure 4b, the structure of the windows results in\
    \ six\n   possible orderings - 1,2,3,4 or 1,3,2,4 or 1,3,4,2 or 3,4,1,2 or\n \
    \  3,1,4,2 or 3,1,2,4.\n       +================================+============================+\n\
    \       |a       +-----------+           |b   +----------+            |\n    \
    \   |        | 1         |           |    | 1        |            |\n       |\
    \        |           |           |    |     +----------+      |\n       |  +---------+\
    \    +----------+   |    +-----| 2        |      |\n       |  | 2       |----|\
    \ 3        |   |          |          |      |\n       |  |     +-----------+ \
    \      |   |          +----------+      |\n       |  |     | 4         |     \
    \  |   |    +----------+            |\n       |  +-----|           |-------+ \
    \  |    | 3        |            |\n       |        |           |           | \
    \   |      +----------+     |\n       |        +-----------+           |    +------|\
    \ 4        |     |\n       |                                |           |    \
    \      |     |\n       |                                |           +----------+\
    \     |\n       |                                |                           \
    \ |\n       |        1;(2||3);4              |       (1;2)||(3;4)         |\n\
    \       +================================+============================+\n    \
    \                 Figure 4: Window screen refresh\n"
- title: 2.4 Potential Savings
  contents:
  - "2.4 Potential Savings\n   In each of these examples, the valid orderings are\
    \ strictly dependent\n   upon, and must be specified by the application.  Intuitively,\
    \ as the\n   number of acceptable orderings increases, the amount of resources\n\
    \   utilized by a partial order transport service, in terms of buffers\n   and\
    \ retransmissions, should decrease as compared to a fully ordered\n   transport\
    \ service thus also decreasing the overall cost of the\n   connection.  Just how\
    \ much lower will depend largely upon the\n   flexibility of the application and\
    \ the quality of the underlying\n   network.\n   As an indication of the potential\
    \ for improved service, let us\n   briefly look at the case where a database has\
    \ the following 14\n   records.\n          SALESPERSON    LOCATION           CHARGES\
    \    DESCRIPTION\n          -------------  -----------------  ---------  ---------------\n\
    \       1  Anderson       Washington          $4,200    Camping Gear\n       2\
    \  Anderson       Philadelphia        $2,000    Golf Equipment\n       3  Anderson\
    \       Boston                $450    Bowling shoes\n       4  Baker         \
    \ Boston                $849    Sportswear\n       5  Baker          Washington\
    \          $3,100    Weights\n       6  Baker          Washington           $2000\
    \    Camping Gear\n       7  Baker          Atlanta               $290    Baseball\
    \ Gloves\n       8  Baker          Boston              $1,500    Sportswear\n\
    \       9  Crowell        Boston              $9,500    Camping Gear\n      10\
    \  Crowell        Philadelphia        $6,000    Exercise Bikes\n      11  Crowell\
    \        New York            $1,500    Sportswear\n      12  Dykstra        Atlanta\
    \             $1,000    Sportswear\n      13  Dykstra        Dallas          \
    \   $15,000    Rodeo Gear\n      14  Dykstra        Miami               $3,200\
    \    Golf Equipment\n   Using formulas derived in [ACCD93a] one may calculate\
    \ the total\n   number of valid orderings for any partial order that can be\n\
    \   represented in the notation mentioned previously.  For the case where\n  \
    \ a user specifies \"ORDER BY SALESPERSON\", the partial order above can\n   be\
    \ expressed as,\n          (1||2||3);(4||5||6||7||8);(9||10||11);(12||13||14)\n\
    \   Of the 14!=87,178,291,200 total possible combinations, there exist\n   25,920\
    \ valid orderings at the destination.  A service that may\n   deliver the records\
    \ in any of these 25,920 orderings has a great deal\n   more flexibility than\
    \ in the ordered case where there is only 1 valid\n   order for 14 objects.  It\
    \ is interesting to consider the real\n   possibility of hundreds or even thousands\
    \ of objects and the\n   potential savings in communication costs.\n   In all\
    \ cases, the underlying network is assumed to be unreliable and\n   may thus introduce\
    \ loss, duplication, and disorder.  It makes no\n   sense to put a partial order\
    \ service on top of a reliable network.\n   While the exact amount of unreliability\
    \ in a network may vary and is\n   not always well understood, initial experimental\
    \ research indicates\n   that real world networks, for example the service provided\
    \ by the\n   Internet's IP level, \"yield high losses, duplicates and reorderings\n\
    \   of packets\" [AS93,BCP93].  The authors plan to conduct further\n   experimentation\
    \ into measuring Internet network unreliability.  This\n   information would say\
    \ a great deal about the practical merit of a\n   partial order service.\n"
- title: 3. Reliability vs. Order
  contents:
  - "3. Reliability vs. Order\n   While TCP avoids the loss of even a single object,\
    \ in fact for many\n   applications, there exists a genuine ability to tolerate\
    \ loss.\n   Losing one frame per second in a 30 frame per second video or losing\n\
    \   a segment of its accompanying audio channel is usually not a problem.\n  \
    \ Bearing this in mind, it is of value to consider a quality of service\n   that\
    \ combines a partial order with a level of tolerated loss (partial\n   reliability).\
    \  Traditionally there exist 4 services: reliable-\n   ordered, reliable-unordered,\
    \ unreliable-ordered, and unreliable-\n   unordered. See Figure 5.  Reliable-ordered\
    \ service (denoted by a\n   single point) represents the case where all objects\
    \ are delivered in\n   the order transmitted.  File transfer is an example application\n\
    \   requiring such a service.\n                   reliable-ordered           \
    \       reliable-unordered\n                      |                          \
    \       |\n                      |                                 |\n       \
    \               v                                 v\n          zero loss-->*---------------------------------*\n\
    \           min loss-->|<--                              |<--\n              \
    \  .     |                                 |\n                .     |<--     \
    \                         |<--\n                      |                      \
    \           |\n                      |<-- unreliable-                  |<-- unreliable-\n\
    \     RELIABILITY      |      ordered                    |     unordered\n   \
    \                   |<--                              |<--\n                 \
    \     |                                 |\n                      |<--        \
    \                      |<--\n           max loss-->|                         \
    \        |\n                      +-+--+--+--+--+--+--+--+--+--+--+-+\n      \
    \             ordered       partial ordered     unordered\n                  \
    \                 ORDER\n         Figure 5: Quality Of Service: Reliability vs.\
    \ Order -\n                   Traditional Service Types\n   In a reliable-unordered\
    \ service (also a single point), all objects\n   must be delivered, but not necessarily\
    \ according to the order\n   transmitted; in fact, any order will suffice.  Some\
    \ transaction\n   processing applications such as credit card verification require\
    \ such\n   a service.\n   Unreliable-ordered service allows some objects to be\
    \ lost.  Those\n   that are delivered, however, must arrive in relative order\
    \ (An\n   \"unreliable\" service does not necessarily lose objects; rather, it\n\
    \   may do so without failing to provide its advertised quality of\n   service;\
    \ e.g., the postal system provides an unreliable service).\n   Since there are\
    \ varying degrees of unreliability, this service is\n   represented by a set of\
    \ points in Figure 5.  An unreliable-ordered\n   service is applicable to packet-voice\
    \ or teleconferencing\n   applications.\n   Finally unreliable-unordered service\
    \ allows objects to be lost and\n   delivered in any order.  This is the kind\
    \ of service used for normal\n   e-mail (without acknowledgment receipts) and\
    \ electronic announcements\n   or junk e-mail.\n   As mentioned previously, the\
    \ concept of a partial order expands the\n   order dimension from the two extremes\
    \ of ordered and unordered to a\n   range of discrete possibilities as depicted\
    \ in Figure 6.\n   Additionally, as will be discussed presently, the notion of\n\
    \   reliability is extended to allow for varying degrees of reliability\n   on\
    \ a per-object basis providing even greater flexibility and improved\n   resource\
    \ utilization.\n                                reliable-PO\n                \
    \      |  |  |  |  |  |  |  |  |  |  |   |\n                      |  |  |  | \
    \ |  |  |  |  |  |  |   |\n                      v  v  v  v  v  v  v  v  v  v\
    \  v   v\n          zero loss-->*---------------------------------*\n        \
    \   min loss-->| .  .  .  .  .  .  .  .  .  .  . |\n                .     | .\
    \  .  .  .  .  .  .  .  .  .  . |\n                .     | .  .  .  .  .  .  .\
    \  .  .  .  . |\n                      | .  .  .                 .  .  . |\n \
    \    RELIABILITY      | .  .  .  unreliable-PO  .  .  . |\n                  \
    \    | .  .  .  .  .  .  .  .  .  .  . |\n                      | .  .  .  . \
    \ .  .  .  .  .  .  . |\n                      | .  .  .  .  .  .  .  .  .  .\
    \  . |\n                      | .  .  .  .  .  .  .  .  .  .  . |\n          \
    \ max loss-->| .  .  .  .  .  .  .  .  .  .  . |\n                      +-+--+--+--+--+--+--+--+--+--+--+-+\n\
    \                   ordered       partial ordered     unordered\n            \
    \                       ORDER\n         Figure 6: Quality Of Service: Reliability\
    \ vs. Order - Partial\n                   Order Service\n"
- title: 3.1 Reliability Classes
  contents:
  - "3.1 Reliability Classes\n   When considering unreliable service, one cannot assume\
    \ that all\n   objects are equal with regards to their reliability.  This\n  \
    \ classification is reasonable if all objects are identical (e.g.,\n   video frames\
    \ in a 30 frame/second film).  Many applications, such as\n   multimedia systems,\
    \ however, often contain a variety of object types.\n   Thus three object reliability\
    \ classes are proposed: BART-NL, BART-L,\n   and NBART-L.  Objects are assigned\
    \ to one of these classes depending\n   on their temporal value as will be show\
    \ presently.\n   BART-NL objects must be delivered to the destination.  These\
    \ objects\n   have temporal value that lasts for an entire established connection\n\
    \   and require reliable delivery (NL =  No Loss allowed).  An example of\n  \
    \ BART-NL objects would be the database records in Example 2.1 or the\n   windows\
    \ in the screen refresh in Example 2.3.  If all objects are of\n   type BART-NL,\
    \ the service is reliable.  One possible way to assure\n   eventual delivery of\
    \ a BART-NL object in a protocol is for the sender\n   to buffer it, start a timeout\
    \ timer, and retransmit it if no ACK\n   arrives before the timeout.  The receiver\
    \ in turn returns an ACK when\n   the object has safely arrived and been delivered\
    \ (BART = Buffers,\n   ACKs, Retransmissions, Timers).\n   BART-L objects are\
    \ those that have temporal value over some\n   intermediate amount of time - enough\
    \ to permit timeout and\n   retransmission, but not everlasting.  Once the temporal\
    \ value of\n   these objects has expired, it is better to presume them lost than\
    \ to\n   delay further the delivery pipeline of information.  One possibility\n\
    \   for deciding when an object's usefulness has expired is to require\n   each\
    \ object to contain information defining its precise temporal\n   value [DS93].\
    \  An example of a BART-L object would be a movie\n   subtitle, sent in parallel\
    \ with associated film images, which is\n   valuable any time during a twenty\
    \ second film sequence.  If not\n   delivered sometime during the first ten seconds,\
    \ the subtitle loses\n   its value and can be presumed lost.  These objects are\
    \ buffered-\n   ACKed-retransmitted up to a certain point in time and then presumed\n\
    \   lost.\n   NBART-L objects are those with temporal values too short to bother\n\
    \   timing out and retransmitting.  An example of a NBART-L object would\n   be\
    \ a single packet of speech in a packetized phone conversation or\n   one image\
    \ in a 30 image/sec film.  A sender transmits these objects\n   once and the service\
    \ makes a best effort to deliver them.  If the one\n   attempt is unsuccessful,\
    \ no further attempts are made.\n   An obvious question comes to mind - what about\
    \ NBART-NL objects?  Do\n   such objects exist?  The authors have considered the\
    \ notion of\n   communicating an object without the use of BART and still being\
    \ able\n   to provide a service without loss.  Perhaps with the use of forward\n\
    \   error correction this may become a viable alternative and could\n   certainly\
    \ be included in the protocol.  However, for our purposes in\n   this document,\
    \ only the first three classifications will be\n   considered.\n   While classic\
    \ transport protocols generally treat all objects\n   equally, the sending and\
    \ receiving functions of a protocol providing\n   partial order/partial reliability\
    \ service will behave differently for\n   each class of object.  For example,\
    \ a sender buffers and, if\n   necessary, retransmits any BART-NL or BART-L objects\
    \ that are not\n   acknowledged within a predefined timeout period.  On the contrary,\n\
    \   NBART-L objects are forgotten as soon as they are transmitted.\n"
- title: 4. Partial Order Connection
  contents:
  - "4. Partial Order Connection\n   The implementation of a protocol that provides\
    \ partial order service\n   requires, at a minimum, (1) communication of the partial\
    \ ordering\n   between the two endpoints, and (2) dynamic evaluation of the\n\
    \   deliverability of objects as they arrive at the receiver.  In\n   addition,\
    \ this RFC describes the mechanisms needed to (3) initiate a\n   connection, (4)\
    \ provide varying degrees of reliability for the\n   objects being transmitted,\
    \ and (5) improve buffer utilization at the\n   sender based on object reliability.\n\
    \   Throughout the discussion of these issues, the authors use the\n   generic\
    \ notion of \"objects\" in describing the service details.  Thus,\n   one of the\
    \ underlying requirements of a partial order service is the\n   ability to handle\
    \ such an abstraction (e.g., recognize object\n   boundaries).  The details of\
    \ object management are implementation\n   dependent and thus are not specified\
    \ in this RFC.  However, as this\n   represents a potential fundamental change\
    \ to the TCP protocol, some\n   discussion is in order.\n   At one extreme, it\
    \ is possible to consider octets as objects and\n   require that the application\
    \ specify the partial order accordingly\n   (octet by octet).  This likely would\
    \ entail an inordinate amount of\n   overhead, processing each octet on an individual\
    \ basis (literally\n   breaking up contiguous segments to determine which, if\
    \ any, octets\n   are deliverable and which are not).  At the other extreme, the\n\
    \   transport protocol could maintain object atomicity regardless of size\n  \
    \ - passing arbitrarily large data structures to IP for transmission.\n   At the\
    \ sending side of the connection this would actually work since\n   IP is prepared\
    \ to perform source fragmentation, however, there is no\n   guarantee that the\
    \ receiving IP will be able to reassemble the\n   fragments!  IP relies on the\
    \ TCP max segment size to prevent this\n   situation from occurring[LMKQ89].\n\
    \   A more realistic approach given the existing IP constraints might be\n   to\
    \ maintain the current notion of a TCP max segment size for the\n   lower-layer\
    \ interface with IP while allowing a much larger object\n   size at the upper-layer\
    \ interface.  Of course this presents some\n   additional complexities.  First\
    \ of all, the transport layer will now\n   have to be concerned with fragmentation/reassembly\
    \ of objects larger\n   than the max segment size and secondly, the increased\
    \ object sizes\n   will require significantly more buffer space at the receiver\
    \ if we\n   want to buffer the object until it arrives in entirety.\n   Alternatively,\
    \ one may consider delivering \"fragments\" of an object\n   as they arrive as\
    \ long as the ordering of the fragments is correct\n   and the application is\
    \ able to process the fragments (this notion of\n   fragmented delivery is discussed\
    \ further in Section 6).\n"
- title: 4.1 Connection Establishment
  contents:
  - "4.1 Connection Establishment\n   By extending the transport paradigm to allow\
    \ partial ordering and\n   reliability classes, a user application may be able\
    \ to take advantage\n   of a more efficient data transport facility by negotiating\
    \ the\n   optimal service level which is required - no more, no less.  This is\n\
    \   accomplished by specifying these variables as QOS parameters or, in\n   TCP\
    \ terminology, as options to be included in the TCP header [Pos81].\n   A TCP\
    \ implementation that provides a partial order service requires\n   the use of\
    \ two new TCP options.  The first is an enabling option\n   \"POC-permitted\"\
    \ (Partial Order Connection Permitted) that may be used\n   in a SYN segment to\
    \ request a partial order service.  The other is\n   the \"POC-service-profile\"\
    \ option which is used periodically to\n   communicate the service characteristics.\
    \  This second option may be\n   sent only after successful transmission and acknowledgment\
    \ of the\n   POC-permitted option.\n   A user process issuing either an active\
    \ or passive OPEN may choose to\n   include the POC-permitted option if the application\
    \ can benefit from\n   the use of a partial order service and in fact, in cases\
    \ where the\n   viability of such service is unknown, it is suggested that the\
    \ option\n   be used and that the decision be left to the user's peer.\n   For\
    \ example, a multimedia server might issue a passive <SYN> with the\n   POC-permitted\
    \ option in preparation for the connection by a remote\n   user.\n   Upon reception\
    \ of a <SYN> segment with the POC-permitted option, the\n   receiving user has\
    \ the option to respond with a similar POC-permitted\n   indication or may reject\
    \ a partial order connection if the\n   application does not warrant the service\
    \ or the receiving user is\n   simply unable to provide such a service (e.g.,\
    \ does not recognize the\n   POC-permitted option).\n   In the event that simultaneous\
    \ initial <SYN> segments are exchanged,\n   the TCP will initiate a partial order\
    \ connection only if both sides\n   include the POC-permitted option.\n   A brief\
    \ example should help to demonstrate this procedure.  The\n   following notation\
    \ (a slight simplification on that employed in RFC\n   793) will be used.  Each\
    \ line is numbered for reference purposes.\n   TCP-A (on the left) will play the\
    \ role of the receiver and TCP-B will\n   be the sender.  Right arrows  (-->)\
    \ indicate departure of a TCP\n   segment from TCP-A to TCP-B, or arrival of a\
    \ segment at B from A.\n   Left arrows indicate the reverse.  TCP states represent\
    \ the state\n   AFTER the departure or arrival of the segment (whose contents\
    \ are\n   shown in the center of the line).  Liberties are taken with the\n  \
    \ contents of the segments where only the fields of interest are shown.\n    \
    \     TCP-A                                              TCP-B\n      1. CLOSED\
    \                                             LISTEN\n      2. SYN-SENT    -->\
    \ <CTL=SYN><POC-perm>            --> SYN-RECEIVED\n      3. ESTABLISHED <-- <CTL=SYN,ACK><POC-perm>\
    \        <-- SYN-RECEIVED\n      4. ESTABLISHED --> <CTL=ACK>                \
    \      --> ESTABLISHED\n        Figure 7. Basic 3-Way handshake for a partial\
    \ order connection\n   In line 1 of Figure 7, the sending user has already issued\
    \ a passive\n   OPEN with the POC-permitted option and is waiting for a connection.\n\
    \   In line 2, the receiving user issues an active OPEN with the same\n   option\
    \ which in turn prompts TCP-A to send a SYN segment with the\n   POC-permitted\
    \ option and enter the SYN-SENT state.  TCP-B is able to\n   confirm the use of\
    \ a PO connection and does so in line 3, after which\n   TCP-A enters the established\
    \ state and completes the connection with\n   an ACK segment in line 4.\n   In\
    \ the event that either side is unable to provide partial order\n   service, the\
    \ POC-permitted option will be omitted and normal TCP\n   processing will ensue.\n\
    \   For completeness, the authors include the following specification for\n  \
    \ both the POC-permitted option and the POC-service-profile option in a\n   format\
    \ consistent with the TCP specification document [Pos81].\n      TCP POC-permitted\
    \ Option:\n         Kind: 9  Length: - 2 bytes\n             +-----------+-------------+\n\
    \             |  Kind=9   |  Length=2   |\n             +-----------+-------------+\n\
    \      TCP POC-service-profile Option:\n         Kind: 10  Length: 3 bytes\n \
    \                                      1 bit        1 bit    6 bits\n        \
    \     +----------+----------+------------+----------+--------+\n             |\
    \  Kind=10 | Length=3 | Start_flag | End_flag | Filler |\n             +----------+----------+------------+----------+--------+\n\
    \   The first option represents a simple indicator communicated between\n   the\
    \ two peer transport entities and needs no further explanation.\n   The second\
    \ option serves to communicate the information necessary to\n   carry out the\
    \ job of the protocol - the type of information which is\n   typically found in\
    \ the header of a TCP segment - and raises some\n   interesting questions.\n \
    \  Standard TCP maintains a 60-byte maximum header size on all segments.\n   The\
    \ obvious intuition behind this rule is that one would like to\n   minimize the\
    \ amount of overhead information present in each packet\n   while simultaneously\
    \ increasing the payload, or data, section.  While\n   this is acceptable for\
    \ most TCP connections today, a partial-order\n   service would necessarily require\
    \ that significantly more control\n   information be passed between transport\
    \ entities at certain points\n   during a connection.  Maintaining the strict\
    \ interpretation of this\n   rule would prove to be inefficient.  If, for example,\
    \ the service\n   profile occupied a total of 400 bytes (a modest amount as will\
    \ be\n   confirmed in the next section), then one would have to fragment this\n\
    \   information across at least 10 segments, allocating 20 bytes per\n   segment\
    \ for the normal TCP header.\n   Instead, the authors propose that the service\
    \ profile be carried in\n   the data section of the segment and that the 3-byte\
    \ POC-service-\n   profile option described above be placed in the header to indicate\n\
    \   the presence of this information.  Upon reception of such a segment,\n   the\
    \ TCP extracts the service profile and uses it appropriately as\n   will be discussed\
    \ in the following sections.\n   The option itself, as shown here, contains two\
    \ 1-bit flags necessary\n   to handle the case where the service profile does\
    \ not fit in a single\n   TCP segment.  The \"Start_flag\" indicates that the\
    \ information in the\n   data section represents the beginning of the service\
    \ profile and the\n   \"End_flag\" represents the converse.  For service profiles\
    \ which fit\n   completely in a single segment, both flags will be set to 1.\n\
    \   Otherwise, the Start_flag is set in the initial segment and the\n   End_flag\
    \ in the final segment allowing the peer entity to reconstrcut\n   the entire\
    \ service profile (using the normal sequence numbers in the\n   segment header).\
    \  The \"Filler\" field serves merely to complete the\n   third byte of the option.\n\
    \   Note that the length of the service profile may vary during the\n   connection\
    \ as the order or reliability requirements of the user\n   change but this length\
    \ must not exceed the buffering ability of the\n   peer TCP entity since the entire\
    \ profile must be stored.  The exact\n   makeup of this data structure is presented\
    \ in Section 4.2.\n"
- title: 4.2 Data Transmission
  contents:
  - "4.2 Data Transmission\n   Examining the characteristics of a partial order TCP\
    \ in chronological\n   fashion, one would start off with the establishment of\
    \ a connection\n   as described in Section 4.1.  After which, although both ends\
    \ have\n   acknowledged the acceptability of partial order transport, neither\n\
    \   has actually begun a partial order transmission - in other words,\n   both\
    \ the sending-side and the receiving-side are operating in a\n   normal, ordered-reliable\
    \ mode.  For the subsequent discussion, an\n   important distinction is made in\
    \ the terms sending-side and\n   receiving-side which refer to the data flow from\
    \ the sender and that\n   from the receiver, respectively.\n   For the partial\
    \ ordering to commence, the TCP must be made aware of\n   the acceptable object\
    \ orderings and reliability for both the send-\n   side and receive-side of the\
    \ connection for a given set of objects\n   (hereafter referred to as a \"period\"\
    ).  This information is contained\n   in the service profile and it is the responsibility\
    \ of the user\n   application to define this profile.  Unlike standard TCP where\n\
    \   applications implicitly define a reliable, ordered profile; with\n   partial\
    \ order TCP, the application must explicity define a profile.\n   The representation\
    \ of the service profile is one of the concerns for\n   the transport protocol.\
    \  It would be useful if the TCP could encode a\n   partial ordering in as few\
    \ bits as possible since these bits will be\n   transmitted to the destination\
    \ each time the partial order changes.\n   A matrix representation appears to\
    \ be well-suited to encoding the\n   partial order and a vector has been proposed\
    \ to communicate and\n   manage the reliability aspects of the service.  Temporal\
    \ values may\n   be included within the objects themselves or may be defined as\
    \ a\n   function of the state of the connection [DS93].  Using these data\n  \
    \ structures, the complete service profile would include (1) a partial\n   order\
    \ matrix, (2) a reliability vector and (3) an object_sizes vector\n   which represents\
    \ the size of the objects in octets (see\n   [ACCD93a,CAC93] for a discussion\
    \ on alternative structures for these\n   variables).\n   Throughout this section,\
    \ we use the following service profile as a\n   running example.  Shown here is\
    \ a partial order matrix and graphical\n   representation for a simple partial\
    \ order with 6 objects -\n   ((1;2)||(3;4)||5);6.  In the graphical diagram, arrows\
    \ (-->) denote\n   sequential order and objects in parallel can be delivered in\
    \ either\n   order.  So in this example, object 2 must be delivered after object\n\
    \   1, object 4 must be delivered after object 3, and object 6 must be\n   delivered\
    \ after objects 1 through 5 have all been delivered.  Among\n   the 6 objects,\
    \ there are 30 valid orderings for this partial order\n   (each valid ordering\
    \ is known as a linear extension of the partial\n   order).\n                1\
    \ 2 3 4 5 6\n              +-------------+\n            1 | - 1 0 0 0 1 |    \
    \     |               |       |\n            2 | - - 0 0 0 1 |         |-->1-->|-->2-->|\
    \       |\n            3 | - - - 1 0 1 |         |               |       |\n \
    \           4 | - - - - 0 1 |         |-->3-->|-->4-->|-->6-->|\n            5\
    \ | - - - - - 1 |         |               |       |\n            6 | - - - - -\
    \ - |         |------>5------>|       |\n              +-------------+       \
    \  |               |       |\n                 PO Matrix                 PO Graph\n\
    \   In the matrix, a 1 in row i of column j denotes that object i must be\n  \
    \ delivered before object j.  Note that if objects are numbered in any\n   way\
    \ such that 1,2,3,...,N is a valid ordering, only the upper right\n   triangle\
    \ of the transitively closed matrix is needed [ACCD93a].\n   Thus, for N objects,\
    \ the partial order can be encoded in (N*(N-1)/2)\n   bits.\n   The reliability\
    \ vector for the case where reliability classes are\n   enumerated types such\
    \ as {BART-NL=1, BART-L=2, NBART-L = 3} and all\n   objects are BART-NL would\
    \ simply be, <1, 1, 1, 1, 1, 1>.  Together\n   with the object_sizes vector, the\
    \ complete service profile is\n   described.\n   This information must be packaged\
    \ and communicated to the sending TCP\n   before the first object is transmitted\
    \ using a TCP service primitive\n   or comparable means depending upon the User/TCP\
    \ interface.  Once the\n   service profile has been specified to the TCP, it remains\
    \ in effect\n   until the connection is closed or the sending user specifies a\
    \ new\n   service profile.  In the event that the largest object size can not\n\
    \   be processed by the receiving TCP, the user application is informed\n   that\
    \ the connection cannot be maintained and the normal connection\n   close procedure\
    \ is followed.\n   Typically, as has been described here, the service profile\
    \ definition\n   and specification is handled at the sending end of the connection,\n\
    \   but there could be applications (such as the screen refresh) where\n   the\
    \ receiving user has this knowledge.  Under these circumstances the\n   receiving\
    \ user is obliged to transmit the object ordering on the\n   return side of the\
    \ connection (e.g., when making the request for a\n   screen refresh) and have\
    \ the sender interpret this data to be used on\n   the send side of the connection.\n\
    \   Requiring that the sending application specify the service profile is\n  \
    \ not an arbitrary choice.  To ensure proper object identification, the\n   receiving\
    \ application must transmit the new object numbering to the\n   sending application\
    \ (not the sending transport layer).  Since the\n   sending application must receive\
    \ this information in any case, it\n   simplifies matters greatly to require that\
    \ the sending application be\n   the only side that may specify the service profile\
    \ to the transport\n   layer.\n   Consider now the layered architecture diagram\
    \ in Figure 8 and assume\n   that a connection already is established.  Let us\
    \ now say that UserA\n   specifies the service profile for the sending-side of\
    \ the connection\n   via its interface with TCP-A. TCP-A places the profile in\
    \ the header\n   of one or more data packets (depending upon the size of the service\n\
    \   profile, the profile may require several packets), sets the POC-\n   service-profile\
    \ option and passes it to IP for transmission over the\n   network.  This packet\
    \ must be transmitted reliably, therefore TCP-A\n   buffers it and starts a normal\
    \ retransmit timer.  Subsequently, the\n   service profile arrives at the destination\
    \ node and is handed to\n   TCP-B (as indicated by the arrows in Figure 8).  TCP-B\
    \ returns an\n   acknowledgment and immediately adopts the service profile for\
    \ one\n   direction of data flow over the connection.  When the acknowledgment\n\
    \   arrives back at TCP-A, the cycle is complete and both sides are now\n   able\
    \ to use the partial order service.\n                 +--------+             \
    \   +----------+\n        Service  | UserA  |                | UserB    |\n  \
    \      Profile  +--------+                +----------+\n          |          |\
    \                           |\n          |          |                        \
    \   |\n          v          |                           |\n          |      +---------+\
    \               +-----------+    Service\n          |      |  TCP-A  |       \
    \        |  TCP-B    |    Profile\n          |      +---------+              \
    \ +-----------+       ^\n          |          |                           |  \
    \           |\n          |          |                           |            \
    \ |\n          |          |                           |             |\n      \
    \    |      +---------------------------------------+     |\n          v     \
    \ |                                       |     |\n          ------>| ---- Service\
    \ Profile ------------->   |----->\n                 +---------------------------------------+\n\
    \          Figure 8. Layered Communication Architecture\n   Note that one of the\
    \ TCP entities learns of the profile via its user\n   interface, while the other\
    \ TCP entity is informed via its network\n   interface.\n   For the remaining\
    \ discussions, we will assume that a partial order\n   profile has been successfully\
    \ negotiated for a single direction of\n   the connection (as depicted in Figure\
    \ 8) and that we may now speak of\n   a \"sending TCP\" (TCP-A) and a \"receiving\
    \ TCP\" (TCP-B).  As such,\n   TCP-A refers to the partial order data stream as\
    \ the \"send-side\" of\n   the connection, while TCP-B refers to the same data\
    \ stream as the\n   \"receive-side\".\n   Having established a partial order connection,\
    \ the communicating TCPs\n   each have their respective jobs to perform to ensure\
    \ proper data\n   delivery.  The sending TCP ascertains the object ordering and\n\
    \   reliability from the service profile and uses this information in its\n  \
    \ buffering/retransmission policy.  The receiver modifications are more\n   significant,\
    \ particularly the issues of object deliverability and\n   reliability.  And both\
    \ sides will need to redefine the notion of\n   window management.  Let us look\
    \ specifically at how each side of the\n   TCP connection is managed under this\
    \ new paradigm.\n"
- title: 4.2.1 Sender
  contents:
  - "4.2.1 Sender\n   The sender's concerns are still essentially four-fold - transmitting\n\
    \   data, managing buffer space, processing acknowledgments and\n   retransmitting\
    \ after a time-out - however, each takes on a new\n   meaning in a partial order\
    \ service.  Additionally, the management of\n   the service profile represents\
    \ a fifth duty not previously needed.\n   Taking a rather simplistic view, normal\
    \ TCP output processing\n   involves (1) setting up the header, (2) copying user\
    \ data into the\n   outgoing segment, (3) sending the segment, (4) making a copy\
    \ in a\n   send buffer for retransmission and (5) starting a retransmission\n\
    \   timer.  The only difference with a partial order service is that the\n   reliability\
    \ vector must be examined to determine whether or not to\n   buffer the object\
    \ and start a timer - if the object is classified as\n   NBART-L, then steps 4\
    \ and 5 are omitted.\n   Buffer management at the sending end of a partial order\
    \ connection is\n   dependent upon the object reliability class and the object\
    \ size.\n   When transmitting NBART-L objects the sender need not store the data\n\
    \   for later possible retransmission since NBART-L objects are never\n   retransmitted.\
    \  The details of buffer management - such as whether to\n   allocate fixed-size\
    \ pools of memory, or perhaps utilize a dynamic\n   heap allocation strategy -\
    \ are left to the particular system\n   implementer.\n   Acknowledgment processing\
    \ remains essentially intact -\n   acknowledgments are cumulative and specify\
    \ the peer TCP's window\n   advertisement.  However, determination of this advertisement\
    \ is no\n   longer a trivial process dependent only upon the available buffer\n\
    \   space (this is discussed further in Section 4.2.2).  Moreover, it\n   should\
    \ be noted that the introduction of partial ordering and partial\n   reliability\
    \ presents several new and interesting alternatives for the\n   acknowledgment\
    \ policy.  The authors are investigating several of\n   these strategies through\
    \ a simulation model and have included a brief\n   discussion of these issues\
    \ in Section 6.\n   The retransmit function of the TCP is entirely unchanged and\
    \ is\n   therefore not discussed further.\n   For some applications, it may be\
    \ possible to maintain the same\n   partial order for multiple periods (e.g.,\
    \ the application repeats the\n   same partial order).  In the general case, however,\
    \ the protocol must\n   be able to change the service profile during an existing\
    \ connection.\n   When a change in the service profile is requested, the sending\
    \ TCP is\n   obliged to complete the processing of the current partial order\n\
    \   before commencing with a new one.  This ensures consistency between\n   the\
    \ user applications in the event of a connection failure and\n   simplifies the\
    \ protocol (future study is planned to investigate the\n   performance improvement\
    \ gained by allowing concurrent different\n   partial orders).  The current partial\
    \ order is complete when all\n   sending buffers are free.  Then negotiation \
    \ of the new service\n   profile is performed in the same manner as with the initial\
    \ profile.\n   Combining these issues, we propose the following simplified state\n\
    \   machine for the protocol (connection establishment and tear down\n   remains\
    \ the same and is not show here).\n               (1)Send Request            \
    \                (5)Ack Arrival\n                  +------+                  \
    \              +-----------+\n                  |      |                     \
    \           |           |\n                  |      V                        \
    \        |           |\n                +----------+  (4) New PO Profile    +----------+\
    \      |\n          +---->|          |----------------------->|   PO     |<-----+\n\
    \          |     |  ESTAB   |                        |          |\n      (2) |\
    \     |          |                        |  SETUP   |\n      Ack +-----|    \
    \      |<-----------------------|          |<-----+\n      Arrival   +----------+\
    \  (7)PO Setup Complete  +----------+      |\n                  ^      |     \
    \                             |         |\n                  |      |        \
    \                          |         |\n                  +------+           \
    \                       +---------+\n                (3)Timeout              \
    \                    (6)Timeout\n   Event (1) - User Makes a Data Send Request\n\
    \   =========\n      If Piggyback Timer is set then\n           cancel piggyback\
    \ timer\n      Package and send the object (with ACK for receive-side)\n     \
    \ If object type = (BART-L,BART-NL) then\n           Store the object and start\
    \ a retransmit timer\n      If sending window is full then\n           Block Event\
    \ (1) - allow no further send requests from user\n   Event (2) - ACK Arrives\n\
    \   =========\n      If ACKed object(s) is buffered then\n           Release the\
    \ buffer(s) and stop the retransmit timer(s)\n      Extract the peer TCP's window\
    \ advertisement\n      If remote TCP's window advertisement > sending window then\n\
    \           Enable Event (1)\n      If remote TCP's window advertisement <= sending\
    \ window then\n           Block Event (1) - allow no further send requests from\
    \ user\n      Adjust sending window based on received window advertisement\n \
    \  Event (3) - Retransmit Timer Expires\n   =========\n      If Piggyback Timer\
    \ is set then\n           cancel piggyback timer\n      Re-transmit the segment\
    \ (with ACK for receive-side)\n      Restart the timer\n   Event (4) - PO Service\
    \ Profile Arrives at the User Interface\n   =========\n      Transition to the\
    \ PO SETUP state\n      Store the Send-side PO service profile\n      Package\
    \ the profile into 1 or more segments, setting the\n           POC-Service-Profile\
    \ option on each\n      If Piggyback Timer is set then\n           cancel piggyback\
    \ timer\n      Send the segment(s) (with ACK for receive-side)\n      Store the\
    \ segment(s) and start a retransmit timer\n   Event (5) - ACK Arrival\n   =========\n\
    \      If ACKed object(s) is buffered then\n           Release the buffer(s) and\
    \ stop the retransmit timer(s)\n      Extract the peer TCP's window advertisement\n\
    \      If all objects from previous service profile have been ACKed and\n    \
    \  the new service profile has been ACKed then enable Event (7)\n   Event (6)\
    \ - Retransmit Timer Expires\n   =========\n      If Piggyback Timer is set then\n\
    \           cancel piggyback timer\n      Re-transmit the segment (with ACK for\
    \ receive-side)\n      Restart the timer\n   Event (7) - PO Setup Completed\n\
    \   =========\n      Transition to the ESTAB state and begin processing new service\n\
    \      profile\n"
- title: 4.2.2 Receiver
  contents:
  - "4.2.2 Receiver\n   The receiving TCP has additional decisions to make involving\
    \ object\n   deliverability, reliability and window management.  Additionally,\
    \ the\n   service profile must be established (and re-established) periodically\n\
    \   and some special processing must be performed at the end of each\n   period.\n\
    \   When an object arrives, the question is no longer, \"is this the next\n  \
    \ deliverable object?\", but rather, \"is this ONE OF the next\n   deliverable\
    \ objects?\"  Hence, it is convenient to think of a\n   \"Deliverable Set\" of\
    \ objects with a partial order protocol.  To\n   determine the elements of this\
    \ set and answer the question of\n   deliverability, the receiver relies upon\
    \ the partial order matrix\n   but, unlike the sender, the receiver dynamically\
    \ updates the matrix\n   as objects are processed thus making other objects (possibly\
    \ already\n   buffered objects) deliverable as well.  A check of the object type\n\
    \   also must be performed since BART-NL and BART-L objects require an\n   ACK\
    \ to be returned to the sender but NBART-L do not.  Consider our\n   example from\
    \ the previous section.\n                1 2 3 4 5 6\n              +-------------+\n\
    \            1 | - 1 0 0 0 1 |         |               |       |\n           \
    \ 2 | - - 0 0 0 1 |         |-->1-->|-->2-->|       |\n            3 | - - - 1\
    \ 0 1 |         |               |       |\n            4 | - - - - 0 1 |     \
    \    |-->3-->|-->4-->|-->6-->|\n            5 | - - - - - 1 |         |      \
    \         |       |\n            6 | - - - - - - |         |------>5------>| \
    \      |\n              +-------------+         |               |       |\n  \
    \               PO Matrix                 PO Graph\n   When object 5 arrives,\
    \ the receiver scans column 5, finds that the\n   object is deliverable (since\
    \ there are no 1's in the column) and\n   immediately delivers the object to the\
    \ user application. Then, the\n   matrix is updated to remove the constraint of\
    \ any object whose\n   delivery depends on object 5 by clearing all entries of\
    \ row 5.  This\n   may enable other objects to be delivered (for example, if object\
    \ 2 is\n   buffered then the delivery of object 1 will make object 2\n   deliverable).\
    \  This leads us to the next issue - delivery of stored\n   objects.\n   In general,\
    \ whenever an object is delivered, the buffers must be\n   examined to see if\
    \ any other stored object(s) becomes deliverable.\n   CAC93 describes an efficient\
    \ algorithm to implement this processing\n   based on traversing the precedence\
    \ graph.\n   Consideration of object reliability is interesting.  The authors\
    \ have\n   taken a polling approach wherein a procedure is executed\n   periodically,\
    \ say once every 100 milliseconds, to evaluate the\n   temporal value of outstanding\
    \ objects on which the destination is\n   waiting.  Those whose temporal value\
    \ has expired (i.e. which are no\n   longer useful as defined by the application)\
    \ are \"declared lost\" and\n   treated in much the same manner as delivered objects\
    \ - the matrix is\n   updated, and if the object type is BART-L, an ACK is sent.\
    \  Any\n   objects from the current period which have not yet been delivered or\n\
    \   declared lost are candidates for the \"Terminator\" as the procedure is\n\
    \   called.  The Terminator's criterion is not specifically addressed in\n   this\
    \ RFC, but one example might be for the receiving user to\n   periodically pass\
    \ a list of no-longer-useful objects to TCP-B.\n   Another question which arises\
    \ is, \"How does one calculate the send\n   and receive windows?\"  With a partial\
    \ order service, these windows\n   are no longer contiguous intervals of objects\
    \ but rather sets of\n   objects.  In fact, there are three sets which are of\
    \ interest to the\n   receiving TCP one of which has already been mentioned -\
    \ the\n   Deliverable Set.  Additionally, we can think of the Bufferable Set\n\
    \   and the Receivable Set.  Some definitions are in order:\n      Deliverable\
    \ Set: objects which can be immediately passed up to\n           the user.\n \
    \     Buffered Set: objects stored in a buffer awaiting delivery.\n      Bufferable\
    \ Set: objects which can be stored but not immediately\n           delivered (due\
    \ to some ordering constraint).\n      Receivable Set: union of the Deliverable\
    \ Set and the Bufferable\n           Set (which are disjoint) - intuitively, all\
    \ objects which\n           are \"receivable\" must be either \"deliverable\"\
    \ or\n           \"bufferable\".\n   The following example will help to illustrate\
    \ these sets.  Consider\n   our simple service profile from earlier for the case\
    \ where the size\n   of each object is 1 MByte and the receiver has only 2 MBytes\
    \ of\n   buffer space (enough for 2 objects).  Define a boolean vector of\n  \
    \ length N (N = number of objects in a period) called the Processed\n   Vector\
    \ which is used to indicate which objects from the current\n   period have been\
    \ delivered or declared lost.  Initially, all buffers\n   are empty and the PO\
    \ Matrix and Processed Vector are as shown here,\n                1 2 3 4 5 6\n\
    \              +-------------+\n            1 | - 1 0 0 0 1 |\n            2 |\
    \ - - 0 0 0 1 |\n            3 | - - - 1 0 1 |\n            4 | - - - - 0 1 |\n\
    \            5 | - - - - - 1 |      [ F F F F F F ]\n            6 | - - - - -\
    \ - |        1 2 3 4 5 6\n              +-------------+\n                 PO Matrix\
    \        Processed Vector\n   From the PO Matrix, it is clear that the Deliverable\
    \ Set =\n   {(1,1),(1,3),(1,5)}, where (1,1) refers to object #1 from period #1,\n\
    \   asssuming that the current period is period #1.\n   The Bufferable Set, however,\
    \ depends upon how one defines bufferable\n   objects.  Several approaches are\
    \ possible.  The authors' initial\n   approach to determining the Bufferable Set\
    \ can best be explained in\n   terms of the following rules,\n      Rule 1: Remaining\
    \ space must be allocated for all objects from\n              period i before\
    \ any object from period i+1 is buffered\n      Rule 2: In the event that there\
    \ exists enough space to buffer\n              some but not all objects from a\
    \ given period, space will\n              be reserved for the first objects (i.e.\
    \ 1,2,3,...,k)\n   With these rules, the Bufferable Set = {(1,2),(1,4)}, the Buffered\n\
    \   Set is trivially equal to the empty set, { }, and the Receivable Set\n   =\
    \ {(1,1),(1,2),(1,3),(1,4),(1,5)}.\n   Note that the current acknowledgment scheme\
    \ uses the min and max\n   values in the Receivable Set for its window advertisement\
    \ which is\n   transmitted in all ACK segments sent along the receive-side of\
    \ the\n   connection (from receiver to sender).  Moreover, the\n   \"piggyback_delay\"\
    \ timer is still used to couple ACKs with return data\n   (as utilized in standard\
    \ TCP).\n   Returning to our example, let us now assume that object 1 and then\
    \ 3\n   arrive at the receiver and object 2 is lost.  After processing both\n\
    \   objects, the PO Matrix and Processed Vector will have the following\n   updated\
    \ structure,\n                1 2 3 4 5 6\n              +-------------+\n   \
    \         1 | - 0 0 0 0 0 |\n            2 | - - 0 0 0 1 |\n            3 | -\
    \ - - 0 0 0 |\n            4 | - - - - 0 1 |\n            5 | - - - - - 1 |  \
    \    [ T F T F F F ]\n            6 | - - - - - - |        1 2 3 4 5 6\n     \
    \         +-------------+\n                 PO Matrix        Processed Vector\n\
    \   We can see that the Deliverable Set = {(1,2),(1,4),(1,5)}, but what\n   should\
    \ the Bufferable Set consist of?  Since only one buffer is\n   required for the\
    \ current period's objects, we have 1 Mbyte of\n   additional space available\
    \ for \"future\" objects and therefore include\n   the first object from period\
    \ #2 in both the Bufferable and the\n   Receivable Set,\n      Deliverable Set\
    \ = {(1,2),(1,4),(1,5)}\n      Bufferable Set =  {(1,6),(2,1)}\n      Buffered\
    \ Set = { }\n      Receivable Set = {(1,2),(1,4),(1,5),(1,6),(2,1)}\n   In general,\
    \ the notion of window management takes on new meaning with\n   a partial order\
    \ service.  One may re-examine the classic window\n   relations with a partial\
    \ order service in mind and devise new, less\n   restrictive relations which may\
    \ shed further light on the operation\n   of such a service.\n   Two final details:\
    \ (1) as with the sender, the receiver must\n   periodically establish or modify\
    \ the PO service profile and (2) upon\n   processing the last object in a period,\
    \ the receiver must re-set the\n   PO matrix and Processed vector to their initial\
    \ states.\n   Let us look at the state machine and pseudo-code for the receiver.\n\
    \         (2)Data Segment Arrival          (5)PO Profile fragment Arrival\n  \
    \          +------+                          +-------+\n            |      | \
    \                         |       |\n            |      V    (1)First PO Profile\
    \   |       V\n          +---------+     fragment arrives   +---------+(6) Data\
    \ Segment\n    +---->|         |----------------------->|         |<-----+ Arrival\n\
    \    |     |  ESTAB  |                        |   PO    |------+\n    |     |\
    \         |                        |         |\n    |     |         |        \
    \                |  SETUP  |<-----+\n"
- title: (3) +-----|         |<-----------------------|         |------+
  contents:
  - '(3) +-----|         |<-----------------------|         |------+

    '
- title: Terminator+---------+  (9)PO Setup complete  +---------+(7) Terminator
  contents:
  - "Terminator+---------+  (9)PO Setup complete  +---------+(7) Terminator\n    \
    \        ^      |                          |      ^\n            |      |    \
    \                      |      |\n            +------+                        \
    \  +------+\n          (4)Piggyback Timeout             (8)Piggyback Timeout\n\
    \   Event 1 - First PO Service Profile fragment arrives at network\n   =======\
    \   interface\n      Transition to the PO SETUP state\n      Store the PO service\
    \ profile (fragment)\n      Send an Acknowledgement of the PO service profile\
    \ (fragment)\n   Event 2 - Data Segment Arrival\n   =======\n      If object is\
    \ in Deliverable Set then\n           Deliver the object\n           Update PO\
    \ Matrix and Processed Vector\n           Check buffers for newly deliverable\
    \ objects\n           If all objects from current period have been processed then\n\
    \                Start the next period (re-initialize data structures)\n     \
    \      Start piggyback_delay timer to send an ACK\n      Else if object is in\
    \ Bufferable Set then\n           Store the object\n      Else\n           Discard\
    \ object\n           Start piggyback_delay timer to send an ACK\n   Event 3 -\
    \ Periodic call of the Terminator\n   =======\n      For all unprocessed objects\
    \ in the current period do\n           If object is \"no longer useful\" then\n\
    \                Update PO Matrix and Processed Vector\n                If object\
    \ is in a buffer then\n                     Release the buffer\n             \
    \   Check buffers for newly deliverable objects\n                If all objects\
    \ from current period have been processed\n                then Start the next\
    \ period (re-initialize data\n                structures)\n   Event 4 - Piggyback_delay\
    \ Timer Expires\n   =======\n      Send an ACK\n      Disable piggyback_delay\
    \ timer\n   Event 5 - PO Service Profile fragment arrives at network interface\n\
    \   =======\n      Store the PO service profile (fragment)\n      Send an Acknowledgement\
    \ of the PO service profile (fragment)\n      If entire PO Service profile has\
    \ been received then enable Event\n      (9)\n   Event 6 - Data Segment arrival\n\
    \   =======\n      (See event 2)\n   Event 7 - Periodic call of the terminator\n\
    \   =======\n      (See Event 3)\n   Event 8 - Piggyback_delay Timer Expires\n\
    \   =======\n      (See Event 4)\n   Event 9 - PO Setup Complete\n   =======\n\
    \      Transition to the ESTAB state\n   Note that, for reasons of clarity, we\
    \ have used a transitively closed\n   matrix representation of the partial order.\
    \  A more efficient\n   implementation based on an adjacency list representation\
    \ of a\n   transitively reduced precedence graph results in a more efficient\n\
    \   running time [CAC93].\n"
- title: 5. Quantifying and Comparing Partial Order Services
  contents:
  - "5. Quantifying and Comparing Partial Order Services\n   While ordered, reliable\
    \ delivery is ideal, the existence of less-\n   than-ideal underlying networks\
    \ can cause delays for applications that\n   need only partial order or partial\
    \ reliability.  By introducing a\n   partial order service, one may in effect\
    \ relax the requirements on\n   order and reliability and presumably expect some\
    \ savings in terms of\n   buffer utilization and bandwidth (due to fewer retransmissions)\
    \ and\n   shorter overall delays.  A practical question to be addressed is,\n\
    \   \"what are the expected savings likely to be?\"\n   As mentioned in Section\
    \ 2, the extent of such savings will depend\n   largely on the quality of the\
    \ underlying network - bandwidth, delay,\n   amount and distribution of loss/duplication/disorder\
    \ - as well as the\n   flexibility of the partial order itself - specified by\
    \ the PO matrix\n   and reliability vector.  If the underlying network has no\
    \ loss, a\n   partial order service essentially becomes an ordered service.\n\
    \   Collecting experimental data to ascertain realistic network\n   conditions\
    \ is a straightforward task and will help to quantify in\n   general the value\
    \ of a partial order service [Bol93].  But how can\n   one quantify and compare\
    \ the cost of providing specific levels of\n   service?\n   Preliminary research\
    \ indicates that the number of linear extensions\n   (orderings) of a partial\
    \ order in the presence of loss effectively\n   measures the complexity of that\
    \ order.  The authors have derived\n   formulae for calculating the number of\
    \ extensions when a partial\n   order is series-parallel and have proposed a metric\
    \ for comparing\n   partial orders based on this number [ACCD93b].  This metric\
    \ could be\n   used as a means for charging for the service, for example. What\
    \ also\n   may be interesting is a specific head-to-head comparison between\n\
    \   different partial orders with varying degrees of flexibility.  Work\n   is\
    \ currently underway on a simulation model aimed at providing this\n   information.\
    \  And finally, work is underway on an implementation of\n   TCP which includes\
    \ partial order service.\n"
- title: 6. Future Direction
  contents:
  - "6. Future Direction\n   In addition to the simulation and implementation work\
    \ the authors are\n   pursuing several problems related to partial ordering which\
    \ will be\n   mentioned briefly.\n   An interesting question arises when discussing\
    \ the acknowledgment\n   strategy for a partial order service.  For classic protocols,\
    \ a\n   cumulative ACK of object i confirms all objects \"up to and including\"\
    \n   i.  But the meaning of \"up to and including\" with a partial order\n   service\
    \ has different implications than with an ordered service.\n   Consider our example\
    \ partial order, ((1;2)||(3;4)||5);6).  What\n   should a cumulative ACK of object\
    \ 4 confirm?  The most logical\n   definition would say it confirms receipt of\
    \ object 4 and all objects\n   that precede 4 in the partial order, in this case,\
    \ object 3.  Nothing\n   is said about the arrival of objects 1 or 2.  With this\
    \ alternative\n   interpretation where cumulative ACKs depend on the partial order,\
    \ the\n   sender must examine the partial order matrix to determine which\n  \
    \ buffers can be released.  In this example, scanning column 4 of the\n   matrix\
    \ reveals that object 3 must come before object 4 and therefore\n   both object\
    \ buffers (and any buffers from a previous period) can be\n   released.\n   Other\
    \ partial order acknowledgment policies are possible for a\n   protocol providing\
    \ a partial order service including the use of\n   selective ACKs (which has been\
    \ proposed in [JB88] and implemented in\n   the Cray TCP [Chang93]) as well as\
    \ the current TCP strategy where an\n   ACK of i also ACKs everything <= i (in\
    \ a cyclical sequence number\n   space).  The authors are investigating an ACK\
    \ policy which utilizes a\n   combination of selective and \"partial-order-cumulative\"\
    \n   acknowledgments.  This is accomplished by replacing the current TCP\n   cumulative\
    \ ACK with one which has the partial order meaning as\n   described above and\
    \ augmenting this with intermittent selective ACKs\n   when needed.\n   In another\
    \ area, the notion of fragmented delivery, mentioned in the\n   beginning of Section\
    \ 4, looks like a promising technique for certain\n   classes of applications\
    \ which may offer a substantial improvement in\n   memory utilization.  Briefly,\
    \ the term fragmented delivery refers to\n   the ability to transfer less-than-complete\
    \ objects between the\n   transport layer and the user application (or session\
    \ layer as the\n   case may be).  For example, a 1Mbyte object could potentially\
    \ be\n   delivered in multiple \"chunks\" as segments arrive thus freeing up\n\
    \   valuable memory and reducing the delay on those pieces of data.  The\n   scenario\
    \ becomes somewhat more complex when multiple \"parallel\n   streams\" are considered\
    \ where the application could now receive\n   pieces of multiple objects associated\
    \ with different streams.\n   Additional work in the area of implementing a working\
    \ partial order\n   protocol is being performed both at the University of Delaware\
    \ and at\n   the LAAS du CNRS laboratory in Toulouse, France - particularly in\n\
    \   support of distributed, high-speed, multimedia communication. It will\n  \
    \ be interesting to examine the processing requirements for an\n   implementation\
    \ of a partial order protocol at key events (such as\n   object arrival) compared\
    \ with a non-partial order implementation.\n   Finally, the authors are interested\
    \ in the realization of a network\n   application utilizing a partial order service.\
    \  The aim of such work\n   is threefold: (1) provide further insight into the\
    \ expected\n   performance gains, (2) identify new issues unique to partial order\n\
    \   transport and, (3) build a road-map for application designers\n   interested\
    \ in using a partial order service.\n"
- title: 7. Summary
  contents:
  - "7. Summary\n   This RFC introduces the concepts of a partial order service and\n\
    \   discusses the practical issues involved with including partial\n   ordering\
    \ in a transport protocol.  The need for such a service is\n   motivated by several\
    \ applications including the vast fields of\n   distributed databases, and multimedia.\
    \  The service has been\n   presented as a backward-compatible extension to TCP\
    \ to adapt to\n   applications with different needs specified in terms of QOS\n\
    \   parameters.\n   The notion of a partial ordering extends QOS flexibility to\
    \ include\n   object delivery, reliability, and temporal value thus allowing the\n\
    \   transport layer to effectively handle a wider range of applications\n   (i.e.,\
    \ any which might benefit from such mechanisms).  The service\n   profile described\
    \ in Section 4 accurately characterizes the QOS for a\n   partial order service\
    \ (which encompasses the two extremes of total\n   ordered and unordered transport\
    \ as well).\n   Several significant modifications have been proposed and are\n\
    \   summarized here:\n       (1) Replacing the requirement for ordered delivery\
    \ with one for\n           application-dependent partial ordering\n       (2)\
    \ Allowing unreliable and partially reliable data transport\n       (3) Conducting\
    \ a non-symmetrical connection (not entirely foreign\n           to TCP, the use\
    \ of different MSS values for the two sides\n           of a connection is an\
    \ example)\n       (4) Management of \"objects\" rather than octets\n       (5)\
    \ Modified acknowledgment strategy\n       (6) New definition for the send and\
    \ receive \"windows\"\n       (7) Extension of the User/TCP interface to include\
    \ certain\n           QOS parameters\n       (8) Use of new TCP options\n   As\
    \ evidenced by this list, a partial order and partial reliability\n   service\
    \ proposes to re-examine several fundamental transport\n   mechanisms and, in\
    \ so doing, offers the opportunity for substantial\n   improvement in the support\
    \ of existing and new application areas.\n"
- title: 8. References
  contents:
  - "8. References\n   [ACCD93a]  Amer, P., Chassot, C., Connolly, T., and M. Diaz,\n\
    \              \"Partial Order Transport Service for Multimedia\n            \
    \  Applications: Reliable Service\", Second International\n              Symposium\
    \ on High Performance Distributed Computing\n              (HPDC-2), Spokane,\
    \ Washington, July 1993.\n   [ACCD93b]  Amer, P., Chassot, C., Connolly, T., and\
    \ M. Diaz,\n              \"Partial Order Transport Service for Multimedia\n \
    \             Applications: Unreliable Service\", Proc. INET '93, San\n      \
    \        Francisco, August 1993.\n   [AH91]     Anderson, D., and G. Homsy, \"\
    A Continuous Media I/O\n              Server and its Synchronization Mechanism\"\
    , IEEE\n              Computer, 24(10), 51-57, October 1991.\n   [AS93]     Agrawala,\
    \ A., and D. Sanghi, \"Experimental Assessment\n              of End-to-End Behavior\
    \ on Internet,\" Proc. IEEE INFOCOM\n              '93, San Francisco, CA, March\
    \ 1993.\n   [BCP93]    Claffy, K., Polyzos, G., and H.-W. Braun, \"Traffic\n \
    \             Characteristics of the T1 NSFNET\", Proc. IEEE INFOCOM\n       \
    \       '93, San Francisco, CA, March 1993.\n   [Bol93]    Bolot, J., \"End-to-End\
    \ Packet Delay and Loss Behavior\n              in the Internet\", SIGCOMM '93,\
    \ Ithaca, NY, September\n              1993.\n   [CAC93]    Conrad, P., Amer,\
    \ P., and T. Connolly, \"Improving\n              Performance in Transport-Layer\
    \ Communications Protocols\n              by using Partial Orders and Partial\
    \ Reliability\",\n              Work in Progress, December 1993.\n   [Chang93]\
    \  Chang, Y., \"High-Speed Transport Protocol Evaluation --\n              the\
    \ Final Report\", MCNC Center for Communications\n              Technical Document,\
    \ February 1993.\n   [Dee89]    Deering, S., \"Host Extensions for IP Multicasting,\"\
    \ STD\n              5, RFC 1112 Stanford University, August 1989.\n   [DS93]\
    \     Diaz, M., and P. Senac, \"Time Stream Petri Nets: A\n              Model\
    \ for Multimedia Synchronization\", Proceedings of\n              Multimedia Modeling\
    \ '93, Singapore, 1993.\n   [HKN91]    Hardt-Kornacki, S., and L. Ness, \"Optimization\
    \ Model\n              for the Delivery of Interactive Multimedia Documents\"\
    ,\n              In Proc.  Globecom '91, 669-673, Phoenix, Arizona,\n        \
    \      December 1991.\n   [JB88]     Jacobson, V., and R. Braden, \"TCP Extensions\
    \ for\n              Long-Delay Paths\", RFC 1072, LBL, USC/Information\n    \
    \          Sciences Institute, October 1988.\n   [JBB92]    Jacobson, V., Braden,\
    \ R., and D. Borman, \"TCP\n              Extensions for High Performance\", RFC\
    \ 1323, LBL, Cray\n              Research, USC/Information Sciences Institute,\
    \ May 1992.\n   [LMKQ89]   Leffler, S., McKusick, M., Karels, M., and J.\n   \
    \           Quarterman, \"4.3 BSD UNIX Operating System\",\n              Addison-Wesley\
    \ Publishing Company, Reading, MA, 1989.\n   [OP91]     O'Malley, S., and L. Peterson,\
    \ \"TCP Extensions\n              Considered Harmful\", RFC 1263, University of\
    \ Arizona,\n              October 1991.\n   [Pos81]    Postel, J., \"Transmission\
    \ Control Protocol - DARPA\n              Internet Program Protocol Specification,\"\
    \ STD 7,\n              RFC 793, DARPA, September 1981.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Tom Connolly\n   101C Smith Hall\n   Department of Computer\
    \ & Information Sciences\n   University of Delaware\n   Newark, DE 19716 - 2586\n\
    \   EMail: connolly@udel.edu\n   Paul D. Amer\n   101C Smith Hall\n   Department\
    \ of Computer & Information Sciences\n   University of Delaware\n   Newark, DE\
    \ 19716 - 2586\n   EMail: amer@udel.edu\n   Phill Conrad\n   101C Smith Hall\n\
    \   Department of Computer & Information Sciences\n   University of Delaware\n\
    \   Newark, DE 19716 - 2586\n   EMail: pconrad@udel.edu\n"
