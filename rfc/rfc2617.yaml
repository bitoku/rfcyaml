- title: __initial_text__
  contents:
  - '      HTTP Authentication: Basic and Digest Access Authentication

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   \"HTTP/1.0\", includes the specification for a Basic Access\n  \
    \ Authentication scheme. This scheme is not considered to be a secure\n   method\
    \ of user authentication (unless used in conjunction with some\n   external secure\
    \ system such as SSL [5]), as the user name and\n   password are passed over the\
    \ network as cleartext.\n   This document also provides the specification for\
    \ HTTP's\n   authentication framework, the original Basic authentication scheme\n\
    \   and a scheme based on cryptographic hashes, referred to as \"Digest\n   Access\
    \ Authentication\".  It is therefore also intended to serve as a\n   replacement\
    \ for RFC 2069 [6].  Some optional elements specified by\n   RFC 2069 have been\
    \ removed from this specification due to problems\n   found since its publication;\
    \ other new elements have been added for\n   compatibility, those new elements\
    \ have been made optional, but are\n   strongly recommended.\n   Like Basic, Digest\
    \ access authentication verifies that both parties\n   to a communication know\
    \ a shared secret (a password); unlike Basic,\n   this verification can be done\
    \ without sending the password in the\n   clear, which is Basic's biggest weakness.\
    \ As with most other\n   authentication protocols, the greatest sources of risks\
    \ are usually\n   found not in the core protocol itself but in policies and procedures\n\
    \   surrounding its use.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1   Access Authentication................................\
    \   3\n    1.1   Reliance on the HTTP/1.1 Specification............   3\n    1.2\
    \   Access Authentication Framework...................   3\n   2   Basic Authentication\
    \ Scheme..........................   5\n   3   Digest Access Authentication Scheme..................\
    \   6\n    3.1   Introduction......................................   6\n    \
    \ 3.1.1  Purpose.........................................   6\n     3.1.2  Overall\
    \ Operation...............................   6\n     3.1.3  Representation of\
    \ digest values.................   7\n     3.1.4  Limitations.....................................\
    \   7\n    3.2   Specification of Digest Headers...................   7\n    \
    \ 3.2.1  The WWW-Authenticate Response Header............   8\n     3.2.2  The\
    \ Authorization Request Header................  11\n     3.2.3  The Authentication-Info\
    \ Header..................  15\n    3.3   Digest Operation..................................\
    \  17\n    3.4   Security Protocol Negotiation.....................  18\n    3.5\
    \   Example...........................................  18\n    3.6   Proxy-Authentication\
    \ and Proxy-Authorization......  19\n   4   Security Considerations..............................\
    \  19\n    4.1   Authentication of Clients using Basic\n          Authentication....................................\
    \  19\n    4.2   Authentication of Clients using Digest\n          Authentication....................................\
    \  20\n    4.3   Limited Use Nonce Values..........................  21\n    4.4\
    \   Comparison of Digest with Basic Authentication....  22\n    4.5   Replay Attacks....................................\
    \  22\n    4.6   Weakness Created by Multiple Authentication\n          Schemes...........................................\
    \  23\n    4.7   Online dictionary attacks.........................  23\n    4.8\
    \   Man in the Middle.................................  24\n    4.9   Chosen plaintext\
    \ attacks..........................  24\n    4.10  Precomputed dictionary attacks....................\
    \  25\n    4.11  Batch brute force attacks.........................  25\n    4.12\
    \  Spoofing by Counterfeit Servers...................  25\n    4.13  Storing passwords.................................\
    \  26\n    4.14  Summary...........................................  26\n   5\
    \   Sample implementation................................  27\n   6   Acknowledgments......................................\
    \  31\n   7   References...........................................  31\n   8\
    \   Authors' Addresses...................................  32\n   9   Full Copyright\
    \ Statement.............................  34\n"
- title: 1 Access Authentication
  contents:
  - '1 Access Authentication

    '
- title: 1.1 Reliance on the HTTP/1.1 Specification
  contents:
  - "1.1 Reliance on the HTTP/1.1 Specification\n   This specification is a companion\
    \ to the HTTP/1.1 specification [2].\n   It uses the augmented BNF section 2.1\
    \ of that document, and relies on\n   both the non-terminals defined in that document\
    \ and other aspects of\n   the HTTP/1.1 specification.\n"
- title: 1.2 Access Authentication Framework
  contents:
  - "1.2 Access Authentication Framework\n   HTTP provides a simple challenge-response\
    \ authentication mechanism\n   that MAY be used by a server to challenge a client\
    \ request and by a\n   client to provide authentication information. It uses an\
    \ extensible,\n   case-insensitive token to identify the authentication scheme,\n\
    \   followed by a comma-separated list of attribute-value pairs which\n   carry\
    \ the parameters necessary for achieving authentication via that\n   scheme.\n\
    \      auth-scheme    = token\n      auth-param     = token \"=\" ( token | quoted-string\
    \ )\n   The 401 (Unauthorized) response message is used by an origin server\n\
    \   to challenge the authorization of a user agent. This response MUST\n   include\
    \ a WWW-Authenticate header field containing at least one\n   challenge applicable\
    \ to the requested resource. The 407 (Proxy\n   Authentication Required) response\
    \ message is used by a proxy to\n   challenge the authorization of a client and\
    \ MUST include a Proxy-\n   Authenticate header field containing at least one\
    \ challenge\n   applicable to the proxy for the requested resource.\n      challenge\
    \   = auth-scheme 1*SP 1#auth-param\n   Note: User agents will need to take special\
    \ care in parsing the WWW-\n   Authenticate or Proxy-Authenticate header field\
    \ value if it contains\n   more than one challenge, or if more than one WWW-Authenticate\
    \ header\n   field is provided, since the contents of a challenge may itself\n\
    \   contain a comma-separated list of authentication parameters.\n   The authentication\
    \ parameter realm is defined for all authentication\n   schemes:\n      realm\
    \       = \"realm\" \"=\" realm-value\n      realm-value = quoted-string\n   The\
    \ realm directive (case-insensitive) is required for all\n   authentication schemes\
    \ that issue a challenge. The realm value\n   (case-sensitive), in combination\
    \ with the canonical root URL (the\n   absoluteURI for the server whose abs_path\
    \ is empty; see section 5.1.2\n   of [2]) of the server being accessed, defines\
    \ the protection space.\n   These realms allow the protected resources on a server\
    \ to be\n   partitioned into a set of protection spaces, each with its own\n \
    \  authentication scheme and/or authorization database. The realm value\n   is\
    \ a string, generally assigned by the origin server, which may have\n   additional\
    \ semantics specific to the authentication scheme. Note that\n   there may be\
    \ multiple challenges with the same auth-scheme but\n   different realms.\n  \
    \ A user agent that wishes to authenticate itself with an origin\n   server--usually,\
    \ but not necessarily, after receiving a 401\n   (Unauthorized)--MAY do so by\
    \ including an Authorization header field\n   with the request. A client that\
    \ wishes to authenticate itself with a\n   proxy--usually, but not necessarily,\
    \ after receiving a 407 (Proxy\n   Authentication Required)--MAY do so by including\
    \ a Proxy-\n   Authorization header field with the request.  Both the Authorization\n\
    \   field value and the Proxy-Authorization field value consist of\n   credentials\
    \ containing the authentication information of the client\n   for the realm of\
    \ the resource being requested. The user agent MUST\n   choose to use one of the\
    \ challenges with the strongest auth-scheme it\n   understands and request credentials\
    \ from the user based upon that\n   challenge.\n   credentials = auth-scheme #auth-param\n\
    \      Note that many browsers will only recognize Basic and will require\n  \
    \    that it be the first auth-scheme presented. Servers should only\n      include\
    \ Basic if it is minimally acceptable.\n   The protection space determines the\
    \ domain over which credentials can\n   be automatically applied. If a prior request\
    \ has been authorized, the\n   same credentials MAY be reused for all other requests\
    \ within that\n   protection space for a period of time determined by the\n  \
    \ authentication scheme, parameters, and/or user preference. Unless\n   otherwise\
    \ defined by the authentication scheme, a single protection\n   space cannot extend\
    \ outside the scope of its server.\n   If the origin server does not wish to accept\
    \ the credentials sent\n   with a request, it SHOULD return a 401 (Unauthorized)\
    \ response. The\n   response MUST include a WWW-Authenticate header field containing\
    \ at\n   least one (possibly new) challenge applicable to the requested\n   resource.\
    \ If a proxy does not accept the credentials sent with a\n   request, it SHOULD\
    \ return a 407 (Proxy Authentication Required). The\n   response MUST include\
    \ a Proxy-Authenticate header field containing a\n   (possibly new) challenge\
    \ applicable to the proxy for the requested\n   resource.\n   The HTTP protocol\
    \ does not restrict applications to this simple\n   challenge-response mechanism\
    \ for access authentication. Additional\n   mechanisms MAY be used, such as encryption\
    \ at the transport level or\n   via message encapsulation, and with additional\
    \ header fields\n   specifying authentication information. However, these additional\n\
    \   mechanisms are not defined by this specification.\n   Proxies MUST be completely\
    \ transparent regarding user agent\n   authentication by origin servers. That\
    \ is, they must forward the\n   WWW-Authenticate and Authorization headers untouched,\
    \ and follow the\n   rules found in section 14.8 of [2]. Both the Proxy-Authenticate\
    \ and\n   the Proxy-Authorization header fields are hop-by-hop headers (see\n\
    \   section 13.5.1 of [2]).\n"
- title: 2 Basic Authentication Scheme
  contents:
  - "2 Basic Authentication Scheme\n   The \"basic\" authentication scheme is based\
    \ on the model that the\n   client must authenticate itself with a user-ID and\
    \ a password for\n   each realm.  The realm value should be considered an opaque\
    \ string\n   which can only be compared for equality with other realms on that\n\
    \   server. The server will service the request only if it can validate\n   the\
    \ user-ID and password for the protection space of the Request-URI.\n   There\
    \ are no optional authentication parameters.\n   For Basic, the framework above\
    \ is utilized as follows:\n      challenge   = \"Basic\" realm\n      credentials\
    \ = \"Basic\" basic-credentials\n   Upon receipt of an unauthorized request for\
    \ a URI within the\n   protection space, the origin server MAY respond with a\
    \ challenge like\n   the following:\n      WWW-Authenticate: Basic realm=\"WallyWorld\"\
    \n   where \"WallyWorld\" is the string assigned by the server to identify\n \
    \  the protection space of the Request-URI. A proxy may respond with the\n   same\
    \ challenge using the Proxy-Authenticate header field.\n   To receive authorization,\
    \ the client sends the userid and password,\n   separated by a single colon (\"\
    :\") character, within a base64 [7]\n   encoded string in the credentials.\n \
    \     basic-credentials = base64-user-pass\n      base64-user-pass  = <base64\
    \ [4] encoding of user-pass,\n                       except not limited to 76\
    \ char/line>\n      user-pass   = userid \":\" password\n      userid      = *<TEXT\
    \ excluding \":\">\n      password    = *TEXT\n   Userids might be case sensitive.\n\
    \   If the user agent wishes to send the userid \"Aladdin\" and password\n   \"\
    open sesame\", it would use the following header field:\n      Authorization:\
    \ Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n   A client SHOULD assume that all paths\
    \ at or deeper than the depth of\n   the last symbolic element in the path field\
    \ of the Request-URI also\n   are within the protection space specified by the\
    \ Basic realm value of\n   the current challenge. A client MAY preemptively send\
    \ the\n   corresponding Authorization header with requests for resources in\n\
    \   that space without receipt of another challenge from the server.\n   Similarly,\
    \ when a client sends a request to a proxy, it may reuse a\n   userid and password\
    \ in the Proxy-Authorization header field without\n   receiving another challenge\
    \ from the proxy server. See section 4 for\n   security considerations associated\
    \ with Basic authentication.\n"
- title: 3 Digest Access Authentication Scheme
  contents:
  - '3 Digest Access Authentication Scheme

    '
- title: 3.1 Introduction
  contents:
  - '3.1 Introduction

    '
- title: 3.1.1 Purpose
  contents:
  - "3.1.1 Purpose\n   The protocol referred to as \"HTTP/1.0\" includes the specification\
    \ for\n   a Basic Access Authentication scheme[1]. That scheme is not\n   considered\
    \ to be a secure method of user authentication, as the user\n   name and password\
    \ are passed over the network in an unencrypted form.\n   This section provides\
    \ the specification for a scheme that does not\n   send the password in cleartext,\
    \  referred to as \"Digest Access\n   Authentication\".\n   The Digest Access\
    \ Authentication scheme is not intended to be a\n   complete answer to the need\
    \ for security in the World Wide Web. This\n   scheme provides no encryption of\
    \ message content. The intent is\n   simply to create an access authentication\
    \ method that avoids the most\n   serious flaws of Basic authentication.\n"
- title: 3.1.2 Overall Operation
  contents:
  - "3.1.2 Overall Operation\n   Like Basic Access Authentication, the Digest scheme\
    \ is based on a\n   simple challenge-response paradigm. The Digest scheme challenges\n\
    \   using a nonce value. A valid response contains a checksum (by\n   default,\
    \ the MD5 checksum) of the username, the password, the given\n   nonce value,\
    \ the HTTP method, and the requested URI. In this way, the\n   password is never\
    \ sent in the clear. Just as with the Basic scheme,\n   the username and password\
    \ must be prearranged in some fashion not\n   addressed by this document.\n"
- title: 3.1.3 Representation of digest values
  contents:
  - "3.1.3 Representation of digest values\n   An optional header allows the server\
    \ to specify the algorithm used to\n   create the checksum or digest. By default\
    \ the MD5 algorithm is used\n   and that is the only algorithm described in this\
    \ document.\n   For the purposes of this document, an MD5 digest of 128 bits is\n\
    \   represented as 32 ASCII printable characters. The bits in the 128 bit\n  \
    \ digest are converted from most significant to least significant bit,\n   four\
    \ bits at a time to their ASCII presentation as follows. Each four\n   bits is\
    \ represented by its familiar hexadecimal notation from the\n   characters 0123456789abcdef.\
    \ That is, binary 0000 gets represented by\n   the character '0', 0001, by '1',\
    \ and so on up to the representation\n   of 1111 as 'f'.\n"
- title: 3.1.4 Limitations
  contents:
  - "3.1.4 Limitations\n   The Digest authentication scheme described in this document\
    \ suffers\n   from many known limitations. It is intended as a replacement for\n\
    \   Basic authentication and nothing more. It is a password-based system\n   and\
    \ (on the server side) suffers from all the same problems of any\n   password\
    \ system. In particular, no provision is made in this protocol\n   for the initial\
    \ secure arrangement between user and server to\n   establish the user's password.\n\
    \   Users and implementors should be aware that this protocol is not as\n   secure\
    \ as Kerberos, and not as secure as any client-side private-key\n   scheme. Nevertheless\
    \ it is better than nothing, better than what is\n   commonly used with telnet\
    \ and ftp, and better than Basic\n   authentication.\n"
- title: 3.2 Specification of Digest Headers
  contents:
  - "3.2 Specification of Digest Headers\n   The Digest Access Authentication scheme\
    \ is conceptually similar to\n   the Basic scheme. The formats of the modified\
    \ WWW-Authenticate header\n   line and the Authorization header line are specified\
    \ below. In\n   addition, a new header, Authentication-Info, is specified.\n"
- title: 3.2.1 The WWW-Authenticate Response Header
  contents:
  - "3.2.1 The WWW-Authenticate Response Header\n   If a server receives a request\
    \ for an access-protected object, and an\n   acceptable Authorization header is\
    \ not sent, the server responds with\n   a \"401 Unauthorized\" status code, and\
    \ a WWW-Authenticate header as\n   per the framework defined above, which for\
    \ the digest scheme is\n   utilized as follows:\n      challenge        =  \"\
    Digest\" digest-challenge\n      digest-challenge  = 1#( realm | [ domain ] |\
    \ nonce |\n                          [ opaque ] |[ stale ] | [ algorithm ] |\n\
    \                          [ qop-options ] | [auth-param] )\n      domain    \
    \        = \"domain\" \"=\" <\"> URI ( 1*SP URI ) <\">\n      URI            \
    \   = absoluteURI | abs_path\n      nonce             = \"nonce\" \"=\" nonce-value\n\
    \      nonce-value       = quoted-string\n      opaque            = \"opaque\"\
    \ \"=\" quoted-string\n      stale             = \"stale\" \"=\" ( \"true\" |\
    \ \"false\" )\n      algorithm         = \"algorithm\" \"=\" ( \"MD5\" | \"MD5-sess\"\
    \ |\n                           token )\n      qop-options       = \"qop\" \"\
    =\" <\"> 1#qop-value <\">\n      qop-value         = \"auth\" | \"auth-int\" |\
    \ token\n   The meanings of the values of the directives used above are as\n \
    \  follows:\n   realm\n     A string to be displayed to users so they know which\
    \ username and\n     password to use. This string should contain at least the\
    \ name of\n     the host performing the authentication and might additionally\n\
    \     indicate the collection of users who might have access. An example\n   \
    \  might be \"registered_users@gotham.news.com\".\n   domain\n     A quoted, space-separated\
    \ list of URIs, as specified in RFC XURI\n     [7], that define the protection\
    \ space.  If a URI is an abs_path, it\n     is relative to the canonical root\
    \ URL (see section 1.2 above) of\n     the server being accessed. An absoluteURI\
    \ in this list may refer to\n     a different server than the one being accessed.\
    \ The client can use\n     this list to determine the set of URIs for which the\
    \ same\n     authentication information may be sent: any URI that has a URI in\n\
    \     this list as a prefix (after both have been made absolute) may be\n    \
    \ assumed to be in the same protection space. If this directive is\n     omitted\
    \ or its value is empty, the client should assume that the\n     protection space\
    \ consists of all URIs on the responding server.\n     This directive is not meaningful\
    \ in Proxy-Authenticate headers, for\n     which the protection space is always\
    \ the entire proxy; if present\n     it should be ignored.\n   nonce\n     A server-specified\
    \ data string which should be uniquely generated\n     each time a 401 response\
    \ is made. It is recommended that this\n     string be base64 or hexadecimal data.\
    \ Specifically, since the\n     string is passed in the header lines as a quoted\
    \ string, the\n     double-quote character is not allowed.\n     The contents\
    \ of the nonce are implementation dependent. The quality\n     of the implementation\
    \ depends on a good choice. A nonce might, for\n     example, be constructed as\
    \ the base 64 encoding of\n         time-stamp H(time-stamp \":\" ETag \":\" private-key)\n\
    \     where time-stamp is a server-generated time or other non-repeating\n   \
    \  value, ETag is the value of the HTTP ETag header associated with\n     the\
    \ requested entity, and private-key is data known only to the\n     server.  With\
    \ a nonce of this form a server would recalculate the\n     hash portion after\
    \ receiving the client authentication header and\n     reject the request if it\
    \ did not match the nonce from that header\n     or if the time-stamp value is\
    \ not recent enough. In this way the\n     server can limit the time of the nonce's\
    \ validity. The inclusion of\n     the ETag prevents a replay request for an updated\
    \ version of the\n     resource.  (Note: including the IP address of the client\
    \ in the\n     nonce would appear to offer the server the ability to limit the\n\
    \     reuse of the nonce to the same client that originally got it.\n     However,\
    \ that would break proxy farms, where requests from a single\n     user often\
    \ go through different proxies in the farm. Also, IP\n     address spoofing is\
    \ not that hard.)\n     An implementation might choose not to accept a previously\
    \ used\n     nonce or a previously used digest, in order to protect against a\n\
    \     replay attack. Or, an implementation might choose to use one-time\n    \
    \ nonces or digests for POST or PUT requests and a time-stamp for GET\n     requests.\
    \  For more details on the issues involved see section 4.\n     of this document.\n\
    \     The nonce is opaque to the client.\n   opaque\n     A string of data, specified\
    \ by the server, which should be returned\n     by the client unchanged in the\
    \ Authorization header of subsequent\n     requests with URIs in the same protection\
    \ space. It is recommended\n     that this string be base64 or hexadecimal data.\n\
    \   stale\n     A flag, indicating that the previous request from the client was\n\
    \     rejected because the nonce value was stale. If stale is TRUE\n     (case-insensitive),\
    \ the client may wish to simply retry the request\n     with a new encrypted response,\
    \ without reprompting the user for a\n     new username and password. The server\
    \ should only set stale to TRUE\n     if it receives a request for which the nonce\
    \ is invalid but with a\n     valid digest for that nonce (indicating that the\
    \ client knows the\n     correct username/password). If stale is FALSE, or anything\
    \ other\n     than TRUE, or the stale directive is not present, the username\n\
    \     and/or password are invalid, and new values must be obtained.\n   algorithm\n\
    \     A string indicating a pair of algorithms used to produce the digest\n  \
    \   and a checksum. If this is not present it is assumed to be \"MD5\".\n    \
    \ If the algorithm is not understood, the challenge should be ignored\n     (and\
    \ a different one used, if there is more than one).\n     In this document the\
    \ string obtained by applying the digest\n     algorithm to the data \"data\"\
    \ with secret \"secret\" will be denoted\n     by KD(secret, data), and the string\
    \ obtained by applying the\n     checksum algorithm to the data \"data\" will\
    \ be denoted H(data). The\n     notation unq(X) means the value of the quoted-string\
    \ X without the\n     surrounding quotes.\n     For the \"MD5\" and \"MD5-sess\"\
    \ algorithms\n         H(data) = MD5(data)\n     and\n         KD(secret, data)\
    \ = H(concat(secret, \":\", data))\n     i.e., the digest is the MD5 of the secret\
    \ concatenated with a colon\n     concatenated with the data. The \"MD5-sess\"\
    \ algorithm is intended to\n     allow efficient 3rd party authentication servers;\
    \ for the\n     difference in usage, see the description in section 3.2.2.2.\n\
    \   qop-options\n     This directive is optional, but is made so only for backward\n\
    \     compatibility with RFC 2069 [6]; it SHOULD be used by all\n     implementations\
    \ compliant with this version of the Digest scheme.\n     If present, it is a\
    \ quoted string of one or more tokens indicating\n     the \"quality of protection\"\
    \ values supported by the server.  The\n     value \"auth\" indicates authentication;\
    \ the value \"auth-int\"\n     indicates authentication with integrity protection;\
    \ see the\n     descriptions below for calculating the response directive value\
    \ for\n     the application of this choice. Unrecognized options MUST be\n   \
    \  ignored.\n   auth-param\n     This directive allows for future extensions.\
    \ Any unrecognized\n     directive MUST be ignored.\n"
- title: 3.2.2 The Authorization Request Header
  contents:
  - "3.2.2 The Authorization Request Header\n   The client is expected to retry the\
    \ request, passing an Authorization\n   header line, which is defined according\
    \ to the framework above,\n   utilized as follows.\n       credentials      =\
    \ \"Digest\" digest-response\n       digest-response  = 1#( username | realm |\
    \ nonce | digest-uri\n                       | response | [ algorithm ] | [cnonce]\
    \ |\n                       [opaque] | [message-qop] |\n                     \
    \      [nonce-count]  | [auth-param] )\n       username         = \"username\"\
    \ \"=\" username-value\n       username-value   = quoted-string\n       digest-uri\
    \       = \"uri\" \"=\" digest-uri-value\n       digest-uri-value = request-uri\
    \   ; As specified by HTTP/1.1\n       message-qop      = \"qop\" \"=\" qop-value\n\
    \       cnonce           = \"cnonce\" \"=\" cnonce-value\n       cnonce-value\
    \     = nonce-value\n       nonce-count      = \"nc\" \"=\" nc-value\n       nc-value\
    \         = 8LHEX\n       response         = \"response\" \"=\" request-digest\n\
    \       request-digest = <\"> 32LHEX <\">\n       LHEX             =  \"0\" |\
    \ \"1\" | \"2\" | \"3\" |\n                           \"4\" | \"5\" | \"6\" |\
    \ \"7\" |\n                           \"8\" | \"9\" | \"a\" | \"b\" |\n      \
    \                     \"c\" | \"d\" | \"e\" | \"f\"\n   The values of the opaque\
    \ and algorithm fields must be those supplied\n   in the WWW-Authenticate response\
    \ header for the entity being\n   requested.\n   response\n     A string of 32\
    \ hex digits computed as defined below, which proves\n     that the user knows\
    \ a password\n   username\n     The user's name in the specified realm.\n   digest-uri\n\
    \     The URI from Request-URI of the Request-Line; duplicated here\n     because\
    \ proxies are allowed to change the Request-Line in transit.\n   qop\n     Indicates\
    \ what \"quality of protection\" the client has applied to\n     the message.\
    \ If present, its value MUST be one of the alternatives\n     the server indicated\
    \ it supports in the WWW-Authenticate header.\n     These values affect the computation\
    \ of the request-digest. Note\n     that this is a single token, not a quoted\
    \ list of alternatives as\n     in WWW- Authenticate.  This directive is optional\
    \ in order to\n     preserve backward compatibility with a minimal implementation\
    \ of\n     RFC 2069 [6], but SHOULD be used if the server indicated that qop\n\
    \     is supported by providing a qop directive in the WWW-Authenticate\n    \
    \ header field.\n   cnonce\n     This MUST be specified if a qop directive is\
    \ sent (see above), and\n     MUST NOT be specified if the server did not send\
    \ a qop directive in\n     the WWW-Authenticate header field.  The cnonce-value\
    \ is an opaque\n     quoted string value provided by the client and used by both\
    \ client\n     and server to avoid chosen plaintext attacks, to provide mutual\n\
    \     authentication, and to provide some message integrity protection.\n    \
    \ See the descriptions below of the calculation of the response-\n     digest\
    \ and request-digest values.\n   nonce-count\n     This MUST be specified if a\
    \ qop directive is sent (see above), and\n     MUST NOT be specified if the server\
    \ did not send a qop directive in\n     the WWW-Authenticate header field.  The\
    \ nc-value is the hexadecimal\n     count of the number of requests (including\
    \ the current request)\n     that the client has sent with the nonce value in\
    \ this request.  For\n     example, in the first request sent in response to a\
    \ given nonce\n     value, the client sends \"nc=00000001\".  The purpose of this\n\
    \     directive is to allow the server to detect request replays by\n     maintaining\
    \ its own copy of this count - if the same nc-value is\n     seen twice, then\
    \ the request is a replay.   See the description\n     below of the construction\
    \ of the request-digest value.\n   auth-param\n     This directive allows for\
    \ future extensions. Any unrecognized\n     directive MUST be ignored.\n   If\
    \ a directive or its value is improper, or required directives are\n   missing,\
    \ the proper response is 400 Bad Request. If the request-\n   digest is invalid,\
    \ then a login failure should be logged, since\n   repeated login failures from\
    \ a single client may indicate an attacker\n   attempting to guess passwords.\n\
    \   The definition of request-digest above indicates the encoding for its\n  \
    \ value. The following definitions show how the value is computed.\n"
- title: 3.2.2.1 Request-Digest
  contents:
  - "3.2.2.1 Request-Digest\n   If the \"qop\" value is \"auth\" or \"auth-int\":\n\
    \      request-digest  = <\"> < KD ( H(A1),     unq(nonce-value)\n           \
    \                               \":\" nc-value\n                             \
    \             \":\" unq(cnonce-value)\n                                      \
    \    \":\" unq(qop-value)\n                                          \":\" H(A2)\n\
    \                                  ) <\">\n   If the \"qop\" directive is not\
    \ present (this construction is for\n   compatibility with RFC 2069):\n      request-digest\
    \  =\n                 <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2) ) >\n \
    \  <\">\n   See below for the definitions for A1 and A2.\n"
- title: 3.2.2.2 A1
  contents:
  - "3.2.2.2 A1\n   If the \"algorithm\" directive's value is \"MD5\" or is unspecified,\
    \ then\n   A1 is:\n      A1       = unq(username-value) \":\" unq(realm-value)\
    \ \":\" passwd\n   where\n      passwd   = < user's password >\n   If the \"algorithm\"\
    \ directive's value is \"MD5-sess\", then A1 is\n   calculated only once - on\
    \ the first request by the client following\n   receipt of a WWW-Authenticate\
    \ challenge from the server.  It uses the\n   server nonce from that challenge,\
    \ and the first client nonce value to\n   construct A1 as follows:\n      A1 \
    \      = H( unq(username-value) \":\" unq(realm-value)\n                     \"\
    :\" passwd )\n                     \":\" unq(nonce-value) \":\" unq(cnonce-value)\n\
    \   This creates a 'session key' for the authentication of subsequent\n   requests\
    \ and responses which is different for each \"authentication\n   session\", thus\
    \ limiting the amount of material hashed with any one\n   key.  (Note: see further\
    \ discussion of the authentication session in\n   section 3.3.) Because the server\
    \ need only use the hash of the user\n   credentials in order to create the A1\
    \ value, this construction could\n   be used in conjunction with a third party\
    \ authentication service so\n   that the web server would not need the actual\
    \ password value.  The\n   specification of such a protocol is beyond the scope\
    \ of this\n   specification.\n"
- title: 3.2.2.3 A2
  contents:
  - "3.2.2.3 A2\n   If the \"qop\" directive's value is \"auth\" or is unspecified,\
    \ then A2\n   is:\n      A2       = Method \":\" digest-uri-value\n   If the \"\
    qop\" value is \"auth-int\", then A2 is:\n      A2       = Method \":\" digest-uri-value\
    \ \":\" H(entity-body)\n"
- title: 3.2.2.4 Directive values and quoted-string
  contents:
  - "3.2.2.4 Directive values and quoted-string\n   Note that the value of many of\
    \ the directives, such as \"username-\n   value\", are defined as a \"quoted-string\"\
    . However, the \"unq\" notation\n   indicates that surrounding quotation marks\
    \ are removed in forming the\n   string A1. Thus if the Authorization header includes\
    \ the fields\n     username=\"Mufasa\", realm=myhost@testrealm.com\n   and the\
    \ user Mufasa has password \"Circle Of Life\" then H(A1) would be\n   H(Mufasa:myhost@testrealm.com:Circle\
    \ Of Life) with no quotation marks\n   in the digested string.\n   No white space\
    \ is allowed in any of the strings to which the digest\n   function H() is applied\
    \ unless that white space exists in the quoted\n   strings or entity body whose\
    \ contents make up the string to be\n   digested. For example, the string A1 illustrated\
    \ above must be\n        Mufasa:myhost@testrealm.com:Circle Of Life\n   with no\
    \ white space on either side of the colons, but with the white\n   space between\
    \ the words used in the password value.  Likewise, the\n   other strings digested\
    \ by H() must not have white space on either\n   side of the colons which delimit\
    \ their fields unless that white space\n   was in the quoted strings or entity\
    \ body being digested.\n   Also note that if integrity protection is applied (qop=auth-int),\
    \ the\n   H(entity-body) is the hash of the entity body, not the message body\
    \ -\n   it is computed before any transfer encoding is applied by the sender\n\
    \   and after it has been removed by the recipient. Note that this\n   includes\
    \ multipart boundaries and embedded headers in each part of\n   any multipart\
    \ content-type.\n"
- title: 3.2.2.5 Various considerations
  contents:
  - "3.2.2.5 Various considerations\n   The \"Method\" value is the HTTP request method\
    \ as specified in section\n   5.1.1 of [2]. The \"request-uri\" value is the Request-URI\
    \ from the\n   request line as specified in section 5.1.2 of [2]. This may be\
    \ \"*\",\n   an \"absoluteURL\" or an \"abs_path\" as specified in section 5.1.2\
    \ of\n   [2], but it MUST agree with the Request-URI. In particular, it MUST\n\
    \   be an \"absoluteURL\" if the Request-URI is an \"absoluteURL\". The\n   \"\
    cnonce-value\" is an optional  client-chosen value whose purpose is\n   to foil\
    \ chosen plaintext attacks.\n   The authenticating server must assure that the\
    \ resource designated by\n   the \"uri\" directive is the same as the resource\
    \ specified in the\n   Request-Line; if they are not, the server SHOULD return\
    \ a 400 Bad\n   Request error. (Since this may be a symptom of an attack, server\n\
    \   implementers may want to consider logging such errors.) The purpose\n   of\
    \ duplicating information from the request URL in this field is to\n   deal with\
    \ the possibility that an intermediate proxy may alter the\n   client's Request-Line.\
    \ This altered (but presumably semantically\n   equivalent) request would not\
    \ result in the same digest as that\n   calculated by the client.\n   Implementers\
    \ should be aware of how authenticated transactions\n   interact with shared caches.\
    \ The HTTP/1.1 protocol specifies that\n   when a shared cache (see section 13.7\
    \ of [2]) has received a request\n   containing an Authorization header and a\
    \ response from relaying that\n   request, it MUST NOT return that response as\
    \ a reply to any other\n   request, unless one of two Cache-Control (see section\
    \ 14.9 of [2])\n   directives was present in the response. If the original response\n\
    \   included the \"must-revalidate\" Cache-Control directive, the cache MAY\n\
    \   use the entity of that response in replying to a subsequent request,\n   but\
    \ MUST first revalidate it with the origin server, using the\n   request headers\
    \ from the new request to allow the origin server to\n   authenticate the new\
    \ request. Alternatively, if the original response\n   included the \"public\"\
    \ Cache-Control directive, the response entity\n   MAY be returned in reply to\
    \ any subsequent request.\n"
- title: 3.2.3 The Authentication-Info Header
  contents:
  - "3.2.3 The Authentication-Info Header\n   The Authentication-Info header is used\
    \ by the server to communicate\n   some information regarding the successful authentication\
    \ in the\n   response.\n        AuthenticationInfo = \"Authentication-Info\" \"\
    :\" auth-info\n        auth-info          = 1#(nextnonce | [ message-qop ]\n \
    \                              | [ response-auth ] | [ cnonce ]\n            \
    \                   | [nonce-count] )\n        nextnonce          = \"nextnonce\"\
    \ \"=\" nonce-value\n        response-auth      = \"rspauth\" \"=\" response-digest\n\
    \        response-digest    = <\"> *LHEX <\">\n   The value of the nextnonce directive\
    \ is the nonce the server wishes\n   the client to use for a future authentication\
    \ response.  The server\n   may send the Authentication-Info header with a nextnonce\
    \ field as a\n   means of implementing one-time or otherwise changing  nonces.\
    \ If the\n   nextnonce field is present the client SHOULD use it when constructing\n\
    \   the Authorization header for its next request. Failure of the client\n   to\
    \ do so may result in a request to re-authenticate from the server\n   with the\
    \ \"stale=TRUE\".\n     Server implementations should carefully consider the performance\n\
    \     implications of the use of this mechanism; pipelined requests will\n   \
    \  not be possible if every response includes a nextnonce directive\n     that\
    \ must be used on the next request received by the server.\n     Consideration\
    \ should be given to the performance vs. security\n     tradeoffs of allowing\
    \ an old nonce value to be used for a limited\n     time to permit request pipelining.\
    \  Use of the nonce-count can\n     retain most of the security advantages of\
    \ a new server nonce\n     without the deleterious affects on pipelining.\n  \
    \ message-qop\n     Indicates the \"quality of protection\" options applied to\
    \ the\n     response by the server.  The value \"auth\" indicates authentication;\n\
    \     the value \"auth-int\" indicates authentication with integrity\n     protection.\
    \ The server SHOULD use the same value for the message-\n     qop directive in\
    \ the response as was sent by the client in the\n     corresponding request.\n\
    \   The optional response digest in the \"response-auth\" directive\n   supports\
    \ mutual authentication -- the server proves that it knows the\n   user's secret,\
    \ and with qop=auth-int also provides limited integrity\n   protection of the\
    \ response. The \"response-digest\" value is calculated\n   as for the \"request-digest\"\
    \ in the Authorization header, except that\n   if \"qop=auth\" or is not specified\
    \ in the Authorization header for the\n   request, A2 is\n      A2       = \"\
    :\" digest-uri-value\n   and if \"qop=auth-int\", then A2 is\n      A2       =\
    \ \":\" digest-uri-value \":\" H(entity-body)\n   where \"digest-uri-value\" is\
    \ the value of the \"uri\" directive on the\n   Authorization header in the request.\
    \ The \"cnonce-value\" and \"nc-\n   value\" MUST be the ones for the client request\
    \ to which this message\n   is the response. The \"response-auth\", \"cnonce\"\
    , and \"nonce-count\"\n   directives MUST BE present if \"qop=auth\" or \"qop=auth-int\"\
    \ is\n   specified.\n   The Authentication-Info header is allowed in the trailer\
    \ of an HTTP\n   message transferred via chunked transfer-coding.\n"
- title: 3.3 Digest Operation
  contents:
  - "3.3 Digest Operation\n   Upon receiving the Authorization header, the server\
    \ may check its\n   validity by looking up the password that corresponds to the\
    \ submitted\n   username. Then, the server must perform the same digest operation\n\
    \   (e.g., MD5) performed by the client, and compare the result to the\n   given\
    \ request-digest value.\n   Note that the HTTP server does not actually need to\
    \ know the user's\n   cleartext password. As long as H(A1) is available to the\
    \ server, the\n   validity of an Authorization header may be verified.\n   The\
    \ client response to a WWW-Authenticate challenge for a protection\n   space starts\
    \ an authentication session with that protection space.\n   The authentication\
    \ session lasts until the client receives another\n   WWW-Authenticate challenge\
    \ from any server in the protection space. A\n   client should remember the username,\
    \ password, nonce, nonce count and\n   opaque values associated with an authentication\
    \ session to use to\n   construct the Authorization header in future requests\
    \ within that\n   protection space. The Authorization header may be included\n\
    \   preemptively; doing so improves server efficiency and avoids extra\n   round\
    \ trips for authentication challenges. The server may choose to\n   accept the\
    \ old Authorization header information, even though the\n   nonce value included\
    \ might not be fresh. Alternatively, the server\n   may return a 401 response\
    \ with a new nonce value, causing the client\n   to retry the request; by specifying\
    \ stale=TRUE with this response,\n   the server tells the client to retry with\
    \ the new nonce, but without\n   prompting for a new username and password.\n\
    \   Because the client is required to return the value of the opaque\n   directive\
    \ given to it by the server for the duration of a session,\n   the opaque data\
    \ may be used to transport authentication session state\n   information. (Note\
    \ that any such use can also be accomplished more\n   easily and safely by including\
    \ the state in the nonce.) For example,\n   a server could be responsible for\
    \ authenticating content that\n   actually sits on another server. It would achieve\
    \ this by having the\n   first 401 response include a domain directive whose value\
    \ includes a\n   URI on the second server, and an opaque directive whose value\n\
    \   contains the state information. The client will retry the request, at\n  \
    \ which time the server might respond with a 301/302 redirection,\n   pointing\
    \ to the URI on the second server. The client will follow the\n   redirection,\
    \ and pass an Authorization header , including the\n   <opaque> data.\n   As with\
    \ the basic scheme, proxies must be completely transparent in\n   the Digest access\
    \ authentication scheme. That is, they must forward\n   the WWW-Authenticate,\
    \ Authentication-Info and Authorization headers\n   untouched. If a proxy wants\
    \ to authenticate a client before a request\n   is forwarded to the server, it\
    \ can be done using the Proxy-\n   Authenticate and Proxy-Authorization headers\
    \ described in section 3.6\n   below.\n"
- title: 3.4 Security Protocol Negotiation
  contents:
  - "3.4 Security Protocol Negotiation\n   It is useful for a server to be able to\
    \ know which security schemes a\n   client is capable of handling.\n   It is possible\
    \ that a server may want to require Digest as its\n   authentication method, even\
    \ if the server does not know that the\n   client supports it. A client is encouraged\
    \ to fail gracefully if the\n   server specifies only authentication schemes it\
    \ cannot handle.\n"
- title: 3.5 Example
  contents:
  - "3.5 Example\n   The following example assumes that an access-protected document\
    \ is\n   being requested from the server via a GET request. The URI of the\n \
    \  document is \"http://www.nowhere.org/dir/index.html\". Both client and\n  \
    \ server know that the username for this document is \"Mufasa\", and the\n   password\
    \ is \"Circle Of Life\" (with one space between each of the\n   three words).\n\
    \   The first time the client requests the document, no Authorization\n   header\
    \ is sent, so the server responds with:\n         HTTP/1.1 401 Unauthorized\n\
    \         WWW-Authenticate: Digest\n                 realm=\"testrealm@host.com\"\
    ,\n                 qop=\"auth,auth-int\",\n                 nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\"\
    ,\n                 opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\n   The client\
    \ may prompt the user for the username and password, after\n   which it will respond\
    \ with a new request, including the following\n   Authorization header:\n    \
    \     Authorization: Digest username=\"Mufasa\",\n                 realm=\"testrealm@host.com\"\
    ,\n                 nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n          \
    \       uri=\"/dir/index.html\",\n                 qop=auth,\n               \
    \  nc=00000001,\n                 cnonce=\"0a4f113b\",\n                 response=\"\
    6629fae49393a05397450978507c4ef1\",\n                 opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\
    \n"
- title: 3.6 Proxy-Authentication and Proxy-Authorization
  contents:
  - "3.6 Proxy-Authentication and Proxy-Authorization\n   The digest authentication\
    \ scheme may also be used for authenticating\n   users to proxies, proxies to\
    \ proxies, or proxies to origin servers by\n   use of the Proxy-Authenticate and\
    \ Proxy-Authorization headers. These\n   headers are instances of the Proxy-Authenticate\
    \ and Proxy-\n   Authorization headers specified in sections 10.33 and 10.34 of\
    \ the\n   HTTP/1.1 specification [2] and their behavior is subject to\n   restrictions\
    \ described there. The transactions for proxy\n   authentication are very similar\
    \ to those already described. Upon\n   receiving a request which requires authentication,\
    \ the proxy/server\n   must issue the \"407 Proxy Authentication Required\" response\
    \ with a\n   \"Proxy-Authenticate\" header.  The digest-challenge used in the\n\
    \   Proxy-Authenticate header is the same as that for the WWW-\n   Authenticate\
    \ header as defined above in section 3.2.1.\n   The client/proxy must then re-issue\
    \ the request with a Proxy-\n   Authorization header, with directives as specified\
    \ for the\n   Authorization header in section 3.2.2 above.\n   On subsequent responses,\
    \ the server sends Proxy-Authentication-Info\n   with directives the same as those\
    \ for the Authentication-Info header\n   field.\n   Note that in principle a client\
    \ could be asked to authenticate itself\n   to both a proxy and an end-server,\
    \ but never in the same response.\n"
- title: 4 Security Considerations
  contents:
  - '4 Security Considerations

    '
- title: 4.1 Authentication of Clients using Basic Authentication
  contents:
  - "4.1 Authentication of Clients using Basic Authentication\n   The Basic authentication\
    \ scheme is not a secure method of user\n   authentication, nor does it in any\
    \ way protect the entity, which is\n   transmitted in cleartext across the physical\
    \ network used as the\n   carrier. HTTP does not prevent additional authentication\
    \ schemes and\n   encryption mechanisms from being employed to increase security\
    \ or the\n   addition of enhancements (such as schemes to use one-time passwords)\n\
    \   to Basic authentication.\n   The most serious flaw in Basic authentication\
    \ is that it results in\n   the essentially cleartext transmission of the user's\
    \ password over\n   the physical network. It is this problem which Digest Authentication\n\
    \   attempts to address.\n   Because Basic authentication involves the cleartext\
    \ transmission of\n   passwords it SHOULD NOT be used (without enhancements) to\
    \ protect\n   sensitive or valuable information.\n   A common use of Basic authentication\
    \ is for identification purposes\n   -- requiring the user to provide a user name\
    \ and password as a means\n   of identification, for example, for purposes of\
    \ gathering accurate\n   usage statistics on a server. When used in this way it\
    \ is tempting to\n   think that there is no danger in its use if illicit access\
    \ to the\n   protected documents is not a major concern. This is only correct\
    \ if\n   the server issues both user name and password to the users and in\n \
    \  particular does not allow the user to choose his or her own password.\n   The\
    \ danger arises because naive users frequently reuse a single\n   password to\
    \ avoid the task of maintaining multiple passwords.\n   If a server permits users\
    \ to select their own passwords, then the\n   threat is not only unauthorized\
    \ access to documents on the server but\n   also unauthorized access to any other\
    \ resources on other systems that\n   the user protects with the same password.\
    \ Furthermore, in the\n   server's password database, many of the passwords may\
    \ also be users'\n   passwords for other sites. The owner or administrator of\
    \ such a\n   system could therefore expose all users of the system to the risk\
    \ of\n   unauthorized access to all those sites if this information is not\n \
    \  maintained in a secure fashion.\n   Basic Authentication is also vulnerable\
    \ to spoofing by counterfeit\n   servers. If a user can be led to believe that\
    \ he is connecting to a\n   host containing information protected by Basic authentication\
    \ when,\n   in fact, he is connecting to a hostile server or gateway, then the\n\
    \   attacker can request a password, store it for later use, and feign an\n  \
    \ error. This type of attack is not possible with Digest\n   Authentication. Server\
    \ implementers SHOULD guard against the\n   possibility of this sort of counterfeiting\
    \ by gateways or CGI\n   scripts. In particular it is very dangerous for a server\
    \ to simply\n   turn over a connection to a gateway.  That gateway can then use\
    \ the\n   persistent connection mechanism to engage in multiple transactions\n\
    \   with the client while impersonating the original server in a way that\n  \
    \ is not detectable by the client.\n"
- title: 4.2 Authentication of Clients using Digest Authentication
  contents:
  - "4.2 Authentication of Clients using Digest Authentication\n   Digest Authentication\
    \ does not provide a strong authentication\n   mechanism, when compared to public\
    \ key based mechanisms, for example.\n   However, it is significantly stronger\
    \ than (e.g.) CRAM-MD5, which has\n   been proposed for use with LDAP [10], POP\
    \ and IMAP (see RFC 2195\n   [9]).  It is intended to replace the much weaker\
    \ and even more\n   dangerous Basic mechanism.\n   Digest Authentication offers\
    \ no confidentiality protection beyond\n   protecting the actual password. All\
    \ of the rest of the request and\n   response are available to an eavesdropper.\n\
    \   Digest Authentication offers only limited integrity protection for\n   the\
    \ messages in either direction. If  qop=auth-int mechanism is used,\n   those\
    \ parts of the message used in the calculation of the WWW-\n   Authenticate and\
    \ Authorization header field response directive values\n   (see section 3.2 above)\
    \ are  protected.  Most header fields and their\n   values could be modified as\
    \ a part of a man-in-the-middle attack.\n   Many needs for secure HTTP transactions\
    \ cannot be met by Digest\n   Authentication. For those needs TLS or SHTTP are\
    \ more appropriate\n   protocols. In particular Digest authentication cannot be\
    \ used for any\n   transaction requiring confidentiality protection.  Nevertheless\
    \ many\n   functions remain for which Digest authentication is both useful and\n\
    \   appropriate.  Any service in present use that uses Basic should be\n   switched\
    \ to Digest as soon as practical.\n"
- title: 4.3 Limited Use Nonce Values
  contents:
  - "4.3 Limited Use Nonce Values\n   The Digest scheme uses a server-specified nonce\
    \ to seed the\n   generation of the request-digest value (as specified in section\n\
    \   3.2.2.1 above).  As shown in the example nonce in section 3.2.1, the\n   server\
    \ is free to construct the nonce such that it may only be used\n   from a particular\
    \ client, for a particular resource, for a limited\n   period of time or number\
    \ of uses, or any other restrictions.  Doing\n   so strengthens the protection\
    \ provided against, for example, replay\n   attacks (see 4.5).  However, it should\
    \ be noted that the method\n   chosen for generating and checking the nonce also\
    \ has performance and\n   resource implications.  For example, a server may choose\
    \ to allow\n   each nonce value to be used only once by maintaining a record of\n\
    \   whether or not each recently issued nonce has been returned and\n   sending\
    \ a next-nonce directive in the Authentication-Info header\n   field of every\
    \ response. This protects against even an immediate\n   replay attack, but has\
    \ a high cost checking nonce values, and perhaps\n   more important will cause\
    \ authentication failures for any pipelined\n   requests (presumably returning\
    \ a stale nonce indication).  Similarly,\n   incorporating a request-specific\
    \ element such as the Etag value for a\n   resource limits the use of the nonce\
    \ to that version of the resource\n   and also defeats pipelining. Thus it may\
    \ be useful to do so for\n   methods with side effects but have unacceptable performance\
    \ for those\n   that do not.\n"
- title: 4.4 Comparison of Digest with Basic Authentication
  contents:
  - "4.4 Comparison of Digest with Basic Authentication\n   Both Digest and Basic\
    \ Authentication are very much on the weak end of\n   the security strength spectrum.\
    \ But a comparison between the two\n   points out the utility, even necessity,\
    \ of replacing Basic by Digest.\n   The greatest threat to the type of transactions\
    \ for which these\n   protocols are used is network snooping. This kind of transaction\n\
    \   might involve, for example, online access to a database whose use is\n   restricted\
    \ to paying subscribers. With Basic authentication an\n   eavesdropper can obtain\
    \ the password of the user. This not only\n   permits him to access anything in\
    \ the database, but, often worse,\n   will permit access to anything else the\
    \ user protects with the same\n   password.\n   By contrast, with Digest Authentication\
    \ the eavesdropper only gets\n   access to the transaction in question and not\
    \ to the user's password.\n   The information gained by the eavesdropper would\
    \ permit a replay\n   attack, but only with a request for the same document, and\
    \ even that\n   may be limited by the server's choice of nonce.\n"
- title: 4.5 Replay Attacks
  contents:
  - "4.5 Replay Attacks\n   A replay attack against Digest authentication would usually\
    \ be\n   pointless for a simple GET request since an eavesdropper would\n   already\
    \ have seen the only document he could obtain with a replay.\n   This is because\
    \ the URI of the requested document is digested in the\n   client request and\
    \ the server will only deliver that document. By\n   contrast under Basic Authentication\
    \ once the eavesdropper has the\n   user's password, any document protected by\
    \ that password is open to\n   him.\n   Thus, for some purposes, it is necessary\
    \ to protect against replay\n   attacks. A good Digest implementation can do this\
    \ in various ways.\n   The server created \"nonce\" value is implementation dependent,\
    \ but if\n   it contains a digest of the client IP, a time-stamp, the resource\n\
    \   ETag, and a private server key (as recommended above) then a replay\n   attack\
    \ is not simple. An attacker must convince the server that the\n   request is\
    \ coming from a false IP address and must cause the server\n   to deliver the\
    \ document to an IP address different from the address\n   to which it believes\
    \ it is sending the document. An attack can only\n   succeed in the period before\
    \ the time-stamp expires. Digesting the\n   client IP and time-stamp in the nonce\
    \ permits an implementation which\n   does not maintain state between transactions.\n\
    \   For applications where no possibility of replay attack can be\n   tolerated\
    \ the server can use one-time nonce values which will not be\n   honored for a\
    \ second use. This requires the overhead of the server\n   remembering which nonce\
    \ values have been used until the nonce time-\n   stamp (and hence the digest\
    \ built with it) has expired, but it\n   effectively protects against replay attacks.\n\
    \   An implementation must give special attention to the possibility of\n   replay\
    \ attacks with POST and PUT requests. Unless the server employs\n   one-time or\
    \ otherwise limited-use nonces and/or insists on the use of\n   the integrity\
    \ protection of qop=auth-int, an attacker could replay\n   valid credentials from\
    \ a successful request with counterfeit form\n   data or other message body. Even\
    \ with the use of integrity protection\n   most metadata in header fields is not\
    \ protected. Proper nonce\n   generation and checking provides some protection\
    \ against replay of\n   previously used valid credentials, but see 4.8.\n"
- title: 4.6 Weakness Created by Multiple Authentication Schemes
  contents:
  - "4.6 Weakness Created by Multiple Authentication Schemes\n   An HTTP/1.1 server\
    \ may return multiple challenges with a 401\n   (Authenticate) response, and each\
    \ challenge may use a different\n   auth-scheme. A user agent MUST choose to use\
    \ the strongest auth-\n   scheme it understands and request credentials from the\
    \ user based\n   upon that challenge.\n      Note that many browsers will only\
    \ recognize Basic and will require\n      that it be the first auth-scheme presented.\
    \ Servers should only\n      include Basic if it is minimally acceptable.\n  \
    \ When the server offers choices of authentication schemes using the\n   WWW-Authenticate\
    \ header, the strength of the resulting authentication\n   is only as good as\
    \ that of the of the weakest of the authentication\n   schemes. See section 4.8\
    \ below for discussion of particular attack\n   scenarios that exploit multiple\
    \ authentication schemes.\n"
- title: 4.7 Online dictionary attacks
  contents:
  - "4.7 Online dictionary attacks\n   If the attacker can eavesdrop, then it can\
    \ test any overheard\n   nonce/response pairs against a list of common words.\
    \ Such a list is\n   usually much smaller than the total number of possible passwords.\
    \ The\n   cost of computing the response for each password on the list is paid\n\
    \   once for each challenge.\n   The server can mitigate this attack by not allowing\
    \ users to select\n   passwords that are in a dictionary.\n"
- title: 4.8 Man in the Middle
  contents:
  - "4.8 Man in the Middle\n   Both Basic and Digest authentication are vulnerable\
    \ to \"man in the\n   middle\" (MITM) attacks, for example, from a hostile or\
    \ compromised\n   proxy. Clearly, this would present all the problems of eavesdropping.\n\
    \   But it also offers some additional opportunities to the attacker.\n   A possible\
    \ man-in-the-middle attack would be to add a weak\n   authentication scheme to\
    \ the set of choices, hoping that the client\n   will use one that exposes the\
    \ user's credentials (e.g. password). For\n   this reason, the client should always\
    \ use the strongest scheme that\n   it understands from the choices offered.\n\
    \   An even better MITM attack would be to remove all offered choices,\n   replacing\
    \ them with a challenge that requests only Basic\n   authentication, then uses\
    \ the cleartext credentials from the Basic\n   authentication to authenticate\
    \ to the origin server using the\n   stronger scheme it requested. A particularly\
    \ insidious way to mount\n   such a MITM attack would be to offer a \"free\" proxy\
    \ caching service\n   to gullible users.\n   User agents should consider measures\
    \ such as presenting a visual\n   indication at the time of the credentials request\
    \ of what\n   authentication scheme is to be used, or remembering the strongest\n\
    \   authentication scheme ever requested by a server and produce a\n   warning\
    \ message before using a weaker one. It might also be a good\n   idea for the\
    \ user agent to be configured to demand Digest\n   authentication in general,\
    \ or from specific sites.\n   Or, a hostile proxy might spoof the client into\
    \ making a request the\n   attacker wanted rather than one the client wanted.\
    \ Of course, this is\n   still much harder than a comparable attack against Basic\n\
    \   Authentication.\n"
- title: 4.9 Chosen plaintext attacks
  contents:
  - "4.9 Chosen plaintext attacks\n   With Digest authentication, a MITM or a malicious\
    \ server can\n   arbitrarily choose the nonce that the client will use to compute\
    \ the\n   response. This is called a \"chosen plaintext\" attack. The ability\
    \ to\n   choose the nonce is known to make cryptanalysis much easier [8].\n  \
    \ However, no way to analyze the MD5 one-way function used by Digest\n   using\
    \ chosen plaintext is currently known.\n   The countermeasure against this attack\
    \ is for clients to be\n   configured to require the use of the optional \"cnonce\"\
    \ directive;\n   this allows the client to vary the input to the hash in a way\
    \ not\n   chosen by the attacker.\n"
- title: 4.10 Precomputed dictionary attacks
  contents:
  - "4.10 Precomputed dictionary attacks\n   With Digest authentication, if the attacker\
    \ can execute a chosen\n   plaintext attack, the attacker can precompute the response\
    \ for many\n   common words to a nonce of its choice, and store a dictionary of\n\
    \   (response, password) pairs. Such precomputation can often be done in\n   parallel\
    \ on many machines. It can then use the chosen plaintext\n   attack to acquire\
    \ a response corresponding to that challenge, and\n   just look up the password\
    \ in the dictionary. Even if most passwords\n   are not in the dictionary, some\
    \ might be. Since the attacker gets to\n   pick the challenge, the cost of computing\
    \ the response for each\n   password on the list can be amortized over finding\
    \ many passwords. A\n   dictionary with 100 million password/response pairs would\
    \ take about\n   3.2 gigabytes of disk storage.\n   The countermeasure against\
    \ this attack is to for clients to be\n   configured to require the use of the\
    \ optional \"cnonce\" directive.\n"
- title: 4.11 Batch brute force attacks
  contents:
  - "4.11 Batch brute force attacks\n   With Digest authentication, a MITM can execute\
    \ a chosen plaintext\n   attack, and can gather responses from many users to the\
    \ same nonce.\n   It can then find all the passwords within any subset of password\n\
    \   space that would generate one of the nonce/response pairs in a single\n  \
    \ pass over that space. It also reduces the time to find the first\n   password\
    \ by a factor equal to the number of nonce/response pairs\n   gathered. This search\
    \ of the password space can often be done in\n   parallel on many machines, and\
    \ even a single machine can search large\n   subsets of the password space very\
    \ quickly -- reports exist of\n   searching all passwords with six or fewer letters\
    \ in a few hours.\n   The countermeasure against this attack is to for clients\
    \ to be\n   configured to require the use of the optional \"cnonce\" directive.\n"
- title: 4.12 Spoofing by Counterfeit Servers
  contents:
  - "4.12 Spoofing by Counterfeit Servers\n   Basic Authentication is vulnerable to\
    \ spoofing by counterfeit\n   servers.  If a user can be led to believe that she\
    \ is connecting to a\n   host containing information protected by a password she\
    \ knows, when\n   in fact she is connecting to a hostile server, then the hostile\n\
    \   server can request a password, store it away for later use, and feign\n  \
    \ an error.  This type of attack is more difficult with Digest\n   Authentication\
    \ -- but the client must know to demand that Digest\n   authentication be used,\
    \ perhaps using some of the techniques\n   described above to counter \"man-in-the-middle\"\
    \ attacks.  Again, the\n   user can be helped in detecting this attack by a visual\
    \ indication of\n   the authentication mechanism in use with appropriate guidance\
    \ in\n   interpreting the implications of each scheme.\n"
- title: 4.13 Storing passwords
  contents:
  - "4.13 Storing passwords\n   Digest authentication requires that the authenticating\
    \ agent (usually\n   the server) store some data derived from the user's name\
    \ and password\n   in a \"password file\" associated with a given realm. Normally\
    \ this\n   might contain pairs consisting of username and H(A1), where H(A1) is\n\
    \   the digested value of the username, realm, and password as described\n   above.\n\
    \   The security implications of this are that if this password file is\n   compromised,\
    \ then an attacker gains immediate access to documents on\n   the server using\
    \ this realm. Unlike, say a standard UNIX password\n   file, this information\
    \ need not be decrypted in order to access\n   documents in the server realm associated\
    \ with this file. On the other\n   hand, decryption, or more likely a brute force\
    \ attack, would be\n   necessary to obtain the user's password. This is the reason\
    \ that the\n   realm is part of the digested data stored in the password file.\
    \ It\n   means that if one Digest authentication password file is compromised,\n\
    \   it does not automatically compromise others with the same username\n   and\
    \ password (though it does expose them to brute force attack).\n   There are two\
    \ important security consequences of this. First the\n   password file must be\
    \ protected as if it contained unencrypted\n   passwords, because for the purpose\
    \ of accessing documents in its\n   realm, it effectively does.\n   A second consequence\
    \ of this is that the realm string should be\n   unique among all realms which\
    \ any single user is likely to use. In\n   particular a realm string should include\
    \ the name of the host doing\n   the authentication. The inability of the client\
    \ to authenticate the\n   server is a weakness of Digest Authentication.\n"
- title: 4.14 Summary
  contents:
  - "4.14 Summary\n   By modern cryptographic standards Digest Authentication is weak.\
    \ But\n   for a large range of purposes it is valuable as a replacement for\n\
    \   Basic Authentication. It remedies some, but not all, weaknesses of\n   Basic\
    \ Authentication. Its strength may vary depending on the\n   implementation. \
    \ In particular the structure of the nonce (which is\n   dependent on the server\
    \ implementation) may affect the ease of\n   mounting a replay attack.  A range\
    \ of server options is appropriate\n   since, for example, some implementations\
    \ may be willing to accept the\n   server overhead of one-time nonces or digests\
    \ to eliminate the\n   possibility of replay. Others may satisfied with a nonce\
    \ like the one\n   recommended above restricted to a single IP address and a single\
    \ ETag\n   or with a limited lifetime.\n   The bottom line is that *any* compliant\
    \ implementation will be\n   relatively weak by cryptographic standards, but *any*\
    \ compliant\n   implementation will be far superior to Basic Authentication.\n"
- title: 5 Sample implementation
  contents:
  - "5 Sample implementation\n   The following code implements the calculations of\
    \ H(A1), H(A2),\n   request-digest and response-digest, and a test program which\
    \ computes\n   the values used in the example of section 3.5. It uses the MD5\n\
    \   implementation from RFC 1321.\n   File \"digcalc.h\":\n"
- title: '#define HASHLEN 16'
  contents:
  - '#define HASHLEN 16

    '
- title: typedef char HASH[HASHLEN];
  contents:
  - 'typedef char HASH[HASHLEN];

    '
- title: '#define HASHHEXLEN 32'
  contents:
  - '#define HASHHEXLEN 32

    '
- title: typedef char HASHHEX[HASHHEXLEN+1];
  contents:
  - 'typedef char HASHHEX[HASHHEXLEN+1];

    '
- title: '#define IN'
  contents:
  - '#define IN

    '
- title: '#define OUT'
  contents:
  - '#define OUT

    '
- title: /* calculate H(A1) as per HTTP Digest spec */
  contents:
  - '/* calculate H(A1) as per HTTP Digest spec */

    '
- title: void DigestCalcHA1(
  contents:
  - "void DigestCalcHA1(\n    IN char * pszAlg,\n    IN char * pszUserName,\n    IN\
    \ char * pszRealm,\n    IN char * pszPassword,\n    IN char * pszNonce,\n    IN\
    \ char * pszCNonce,\n    OUT HASHHEX SessionKey\n    );\n"
- title: /* calculate request-digest/response-digest as per HTTP Digest spec */
  contents:
  - '/* calculate request-digest/response-digest as per HTTP Digest spec */

    '
- title: void DigestCalcResponse(
  contents:
  - "void DigestCalcResponse(\n    IN HASHHEX HA1,           /* H(A1) */\n    IN char\
    \ * pszNonce,       /* nonce from server */\n    IN char * pszNonceCount,  /*\
    \ 8 hex digits */\n    IN char * pszCNonce,      /* client nonce */\n    IN char\
    \ * pszQop,         /* qop-value: \"\", \"auth\", \"auth-int\" */\n    IN char\
    \ * pszMethod,      /* method from the request */\n    IN char * pszDigestUri,\
    \   /* requested URL */\n    IN HASHHEX HEntity,       /* H(entity body) if qop=\"\
    auth-int\" */\n    OUT HASHHEX Response      /* request-digest or response-digest\
    \ */\n    );\n"
- title: 'File "digcalc.c":'
  contents:
  - 'File "digcalc.c":

    '
- title: '#include <global.h>'
  contents:
  - '#include <global.h>

    '
- title: '#include <md5.h>'
  contents:
  - '#include <md5.h>

    '
- title: '#include <string.h>'
  contents:
  - '#include <string.h>

    '
- title: '#include "digcalc.h"'
  contents:
  - '#include "digcalc.h"

    '
- title: void CvtHex(
  contents:
  - "void CvtHex(\n    IN HASH Bin,\n    OUT HASHHEX Hex\n    )\n"
- title: '{'
  contents:
  - "{\n    unsigned short i;\n    unsigned char j;\n    for (i = 0; i < HASHLEN;\
    \ i++) {\n        j = (Bin[i] >> 4) & 0xf;\n        if (j <= 9)\n            Hex[i*2]\
    \ = (j + '0');\n         else\n            Hex[i*2] = (j + 'a' - 10);\n      \
    \  j = Bin[i] & 0xf;\n        if (j <= 9)\n            Hex[i*2+1] = (j + '0');\n\
    \         else\n            Hex[i*2+1] = (j + 'a' - 10);\n    };\n    Hex[HASHHEXLEN]\
    \ = '\\0';\n"
- title: '};'
  contents:
  - '};

    '
- title: /* calculate H(A1) as per spec */
  contents:
  - '/* calculate H(A1) as per spec */

    '
- title: void DigestCalcHA1(
  contents:
  - "void DigestCalcHA1(\n    IN char * pszAlg,\n    IN char * pszUserName,\n    IN\
    \ char * pszRealm,\n    IN char * pszPassword,\n    IN char * pszNonce,\n    IN\
    \ char * pszCNonce,\n    OUT HASHHEX SessionKey\n    )\n"
- title: '{'
  contents:
  - "{\n      MD5_CTX Md5Ctx;\n      HASH HA1;\n      MD5Init(&Md5Ctx);\n      MD5Update(&Md5Ctx,\
    \ pszUserName, strlen(pszUserName));\n      MD5Update(&Md5Ctx, \":\", 1);\n  \
    \    MD5Update(&Md5Ctx, pszRealm, strlen(pszRealm));\n      MD5Update(&Md5Ctx,\
    \ \":\", 1);\n      MD5Update(&Md5Ctx, pszPassword, strlen(pszPassword));\n  \
    \    MD5Final(HA1, &Md5Ctx);\n      if (stricmp(pszAlg, \"md5-sess\") == 0) {\n\
    \            MD5Init(&Md5Ctx);\n            MD5Update(&Md5Ctx, HA1, HASHLEN);\n\
    \            MD5Update(&Md5Ctx, \":\", 1);\n            MD5Update(&Md5Ctx, pszNonce,\
    \ strlen(pszNonce));\n            MD5Update(&Md5Ctx, \":\", 1);\n            MD5Update(&Md5Ctx,\
    \ pszCNonce, strlen(pszCNonce));\n            MD5Final(HA1, &Md5Ctx);\n      };\n\
    \      CvtHex(HA1, SessionKey);\n"
- title: '};'
  contents:
  - '};

    '
- title: /* calculate request-digest/response-digest as per HTTP Digest spec */
  contents:
  - '/* calculate request-digest/response-digest as per HTTP Digest spec */

    '
- title: void DigestCalcResponse(
  contents:
  - "void DigestCalcResponse(\n    IN HASHHEX HA1,           /* H(A1) */\n    IN char\
    \ * pszNonce,       /* nonce from server */\n    IN char * pszNonceCount,  /*\
    \ 8 hex digits */\n    IN char * pszCNonce,      /* client nonce */\n    IN char\
    \ * pszQop,         /* qop-value: \"\", \"auth\", \"auth-int\" */\n    IN char\
    \ * pszMethod,      /* method from the request */\n    IN char * pszDigestUri,\
    \   /* requested URL */\n    IN HASHHEX HEntity,       /* H(entity body) if qop=\"\
    auth-int\" */\n    OUT HASHHEX Response      /* request-digest or response-digest\
    \ */\n    )\n"
- title: '{'
  contents:
  - "{\n      MD5_CTX Md5Ctx;\n      HASH HA2;\n      HASH RespHash;\n       HASHHEX\
    \ HA2Hex;\n      // calculate H(A2)\n      MD5Init(&Md5Ctx);\n      MD5Update(&Md5Ctx,\
    \ pszMethod, strlen(pszMethod));\n      MD5Update(&Md5Ctx, \":\", 1);\n      MD5Update(&Md5Ctx,\
    \ pszDigestUri, strlen(pszDigestUri));\n      if (stricmp(pszQop, \"auth-int\"\
    ) == 0) {\n            MD5Update(&Md5Ctx, \":\", 1);\n            MD5Update(&Md5Ctx,\
    \ HEntity, HASHHEXLEN);\n      };\n      MD5Final(HA2, &Md5Ctx);\n       CvtHex(HA2,\
    \ HA2Hex);\n      // calculate response\n      MD5Init(&Md5Ctx);\n      MD5Update(&Md5Ctx,\
    \ HA1, HASHHEXLEN);\n      MD5Update(&Md5Ctx, \":\", 1);\n      MD5Update(&Md5Ctx,\
    \ pszNonce, strlen(pszNonce));\n      MD5Update(&Md5Ctx, \":\", 1);\n      if\
    \ (*pszQop) {\n          MD5Update(&Md5Ctx, pszNonceCount, strlen(pszNonceCount));\n\
    \          MD5Update(&Md5Ctx, \":\", 1);\n          MD5Update(&Md5Ctx, pszCNonce,\
    \ strlen(pszCNonce));\n          MD5Update(&Md5Ctx, \":\", 1);\n          MD5Update(&Md5Ctx,\
    \ pszQop, strlen(pszQop));\n          MD5Update(&Md5Ctx, \":\", 1);\n      };\n\
    \      MD5Update(&Md5Ctx, HA2Hex, HASHHEXLEN);\n      MD5Final(RespHash, &Md5Ctx);\n\
    \      CvtHex(RespHash, Response);\n"
- title: '};'
  contents:
  - '};

    '
- title: 'File "digtest.c":'
  contents:
  - 'File "digtest.c":

    '
- title: '#include <stdio.h>'
  contents:
  - '#include <stdio.h>

    '
- title: '#include "digcalc.h"'
  contents:
  - '#include "digcalc.h"

    '
- title: void main(int argc, char ** argv) {
  contents:
  - "void main(int argc, char ** argv) {\n      char * pszNonce = \"dcd98b7102dd2f0e8b11d0f600bfb0c093\"\
    ;\n      char * pszCNonce = \"0a4f113b\";\n      char * pszUser = \"Mufasa\";\n\
    \      char * pszRealm = \"testrealm@host.com\";\n      char * pszPass = \"Circle\
    \ Of Life\";\n      char * pszAlg = \"md5\";\n      char szNonceCount[9] = \"\
    00000001\";\n      char * pszMethod = \"GET\";\n      char * pszQop = \"auth\"\
    ;\n      char * pszURI = \"/dir/index.html\";\n      HASHHEX HA1;\n      HASHHEX\
    \ HA2 = \"\";\n      HASHHEX Response;\n      DigestCalcHA1(pszAlg, pszUser, pszRealm,\
    \ pszPass, pszNonce,\n"
- title: pszCNonce, HA1);
  contents:
  - "pszCNonce, HA1);\n      DigestCalcResponse(HA1, pszNonce, szNonceCount, pszCNonce,\
    \ pszQop,\n       pszMethod, pszURI, HA2, Response);\n      printf(\"Response\
    \ = %s\\n\", Response);\n"
- title: '};'
  contents:
  - '};

    '
- title: 6 Acknowledgments
  contents:
  - "6 Acknowledgments\n   Eric W. Sink, of AbiSource, Inc., was one of the original\
    \ authors\n   before the specification underwent substantial revision.\n   In\
    \ addition to the authors, valuable discussion instrumental in\n   creating this\
    \ document has come from Peter J. Churchyard, Ned Freed,\n   and David M.  Kristol.\n\
    \   Jim Gettys and Larry Masinter edited this document for update.\n"
- title: 7 References
  contents:
  - "7 References\n   [1]  Berners-Lee, T.,  Fielding, R. and H. Frystyk, \"Hypertext\n\
    \        Transfer Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n   [2]  Fielding,\
    \ R.,  Gettys, J., Mogul, J., Frysyk, H., Masinter, L.,\n        Leach, P. and\
    \ T. Berners-Lee, \"Hypertext Transfer Protocol --\n        HTTP/1.1\", RFC 2616,\
    \ June 1999.\n   [3]  Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\
    \ April\n        1992.\n   [4]  Freed, N. and N. Borenstein. \"Multipurpose Internet\
    \ Mail\n        Extensions (MIME) Part One: Format of Internet Message Bodies\"\
    ,\n        RFC 2045, November 1996.\n   [5]  Dierks, T. and C. Allen \"The TLS\
    \ Protocol, Version 1.0\", RFC\n        2246, January 1999.\n   [6]  Franks, J.,\
    \ Hallam-Baker, P., Hostetler, J., Leach, P.,\n        Luotonen, A., Sink, E.\
    \ and L. Stewart, \"An Extension to HTTP :\n        Digest Access Authentication\"\
    , RFC 2069, January 1997.\n   [7]  Berners Lee, T, Fielding, R. and L. Masinter,\
    \ \"Uniform Resource\n        Identifiers (URI): Generic Syntax\", RFC 2396, August\
    \ 1998.\n   [8]  Kaliski, B.,Robshaw, M., \"Message Authentication with MD5\"\
    ,\n        CryptoBytes, Sping 1995, RSA Inc,\n        (http://www.rsa.com/rsalabs/pubs/cryptobytes/spring95/md5.htm)\n\
    \   [9]  Klensin, J., Catoe, R. and P. Krumviede, \"IMAP/POP AUTHorize\n     \
    \   Extension for Simple Challenge/Response\", RFC 2195, September\n        1997.\n\
    \   [10] Morgan, B., Alvestrand, H., Hodges, J., Wahl, M.,\n        \"Authentication\
    \ Methods for LDAP\", Work in Progress.\n"
- title: 8 Authors' Addresses
  contents:
  - "8 Authors' Addresses\n   John Franks\n   Professor of Mathematics\n   Department\
    \ of Mathematics\n   Northwestern University\n   Evanston, IL 60208-2730, USA\n\
    \   EMail: john@math.nwu.edu\n   Phillip M. Hallam-Baker\n   Principal Consultant\n\
    \   Verisign Inc.\n   301 Edgewater Place\n   Suite 210\n   Wakefield MA 01880,\
    \ USA\n   EMail: pbaker@verisign.com\n   Jeffery L. Hostetler\n   Software Craftsman\n\
    \   AbiSource, Inc.\n   6 Dunlap Court\n   Savoy, IL 61874\n   EMail: jeff@AbiSource.com\n\
    \   Scott D. Lawrence\n   Agranat Systems, Inc.\n   5 Clocktower Place, Suite\
    \ 400\n   Maynard, MA 01754, USA\n   EMail: lawrence@agranat.com\n   Paul J. Leach\n\
    \   Microsoft Corporation\n   1 Microsoft Way\n   Redmond, WA 98052, USA\n   EMail:\
    \ paulle@microsoft.com\n   Ari Luotonen\n   Member of Technical Staff\n   Netscape\
    \ Communications Corporation\n   501 East Middlefield Road\n   Mountain View,\
    \ CA 94043, USA\n   Lawrence C. Stewart\n   Open Market, Inc.\n   215 First Street\n\
    \   Cambridge, MA  02142, USA\n   EMail: stewart@OpenMarket.com\n"
- title: 9.  Full Copyright Statement
  contents:
  - "9.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
