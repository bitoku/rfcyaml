- title: __initial_text__
  contents:
  - '                IPv6 Stateless Address Autoconfiguration

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies the steps a host takes in deciding how to\n\
    \   autoconfigure its interfaces in IP version 6.  The autoconfiguration\n   process\
    \ includes generating a link-local address, generating global\n   addresses via\
    \ stateless address autoconfiguration, and the Duplicate\n   Address Detection\
    \ procedure to verify the uniqueness of the addresses\n   on a link.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n     2.1.  Requirements . . . . . . . . . . . . . . . . . . .\
    \ . . . .  7\n   3.  Design Goals . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  7\n   4.  Protocol Overview  . . . . . . . . . . . . . . . . . . . .\
    \ . .  8\n     4.1.  Site Renumbering . . . . . . . . . . . . . . . . . . . .\
    \ .  9\n   5.  Protocol Specification . . . . . . . . . . . . . . . . . . . .\
    \ 10\n     5.1.  Node Configuration Variables . . . . . . . . . . . . . . . 10\n\
    \     5.2.  Autoconfiguration-Related Structures . . . . . . . . . . . 11\n  \
    \   5.3.  Creation of Link-Local Addresses . . . . . . . . . . . . . 11\n    \
    \ 5.4.  Duplicate Address Detection  . . . . . . . . . . . . . . . 12\n      \
    \ 5.4.1.  Message Validation . . . . . . . . . . . . . . . . . . 14\n       5.4.2.\
    \  Sending Neighbor Solicitation Messages . . . . . . . . 14\n       5.4.3.  Receiving\
    \ Neighbor Solicitation Messages . . . . . . . 15\n       5.4.4.  Receiving Neighbor\
    \ Advertisement Messages  . . . . . . 16\n       5.4.5.  When Duplicate Address\
    \ Detection Fails . . . . . . . . 17\n     5.5.  Creation of Global Addresses\
    \ . . . . . . . . . . . . . . . 17\n       5.5.1.  Soliciting Router Advertisements\
    \ . . . . . . . . . . . 18\n       5.5.2.  Absence of Router Advertisements .\
    \ . . . . . . . . . . 18\n       5.5.3.  Router Advertisement Processing  . .\
    \ . . . . . . . . . 18\n       5.5.4.  Address Lifetime Expiry  . . . . . . .\
    \ . . . . . . . . 20\n     5.6.  Configuration Consistency  . . . . . . . . .\
    \ . . . . . . . 21\n     5.7.  Retaining Configured Addresses for Stability .\
    \ . . . . . . 22\n   6.  Security Considerations  . . . . . . . . . . . . . .\
    \ . . . . . 22\n   7.  Acknowledgements . . . . . . . . . . . . . . . . . . .\
    \ . . . . 23\n   8.  References . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 23\n     8.1.  Normative References . . . . . . . . . . . . . . . . .\
    \ . . 23\n     8.2.  Informative References . . . . . . . . . . . . . . . . .\
    \ . 23\n   Appendix A.  Loopback Suppression and Duplicate Address\n         \
    \       Detection . . . . . . . . . . . . . . . . . . . . . . 25\n   Appendix\
    \ B.  Changes since RFC 1971  . . . . . . . . . . . . . . . 26\n   Appendix C.\
    \  Changes since RFC 2462  . . . . . . . . . . . . . . . 27\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies the steps a host takes in deciding\
    \ how to\n   autoconfigure its interfaces in IP version 6 (IPv6).  The\n   autoconfiguration\
    \ process includes generating a link-local address,\n   generating global addresses\
    \ via stateless address autoconfiguration,\n   and the Duplicate Address Detection\
    \ procedure to verify the\n   uniqueness of the addresses on a link.\n   The IPv6\
    \ stateless autoconfiguration mechanism requires no manual\n   configuration of\
    \ hosts, minimal (if any) configuration of routers,\n   and no additional servers.\
    \  The stateless mechanism allows a host to\n   generate its own addresses using\
    \ a combination of locally available\n   information and information advertised\
    \ by routers.  Routers advertise\n   prefixes that identify the subnet(s) associated\
    \ with a link, while\n   hosts generate an \"interface identifier\" that uniquely\
    \ identifies an\n   interface on a subnet.  An address is formed by combining\
    \ the two.\n   In the absence of routers, a host can only generate link-local\n\
    \   addresses.  However, link-local addresses are sufficient for allowing\n  \
    \ communication among nodes attached to the same link.\n   The stateless approach\
    \ is used when a site is not particularly\n   concerned with the exact addresses\
    \ hosts use, so long as they are\n   unique and properly routable.  On the other\
    \ hand, Dynamic Host\n   Configuration Protocol for IPv6 (DHCPv6) [RFC3315] is\
    \ used when a\n   site requires tighter control over exact address assignments.\
    \  Both\n   stateless address autoconfiguration and DHCPv6 may be used\n   simultaneously.\n\
    \   IPv6 addresses are leased to an interface for a fixed (possibly\n   infinite)\
    \ length of time.  Each address has an associated lifetime\n   that indicates\
    \ how long the address is bound to an interface.  When a\n   lifetime expires,\
    \ the binding (and address) become invalid and the\n   address may be reassigned\
    \ to another interface elsewhere in the\n   Internet.  To handle the expiration\
    \ of address bindings gracefully,\n   an address goes through two distinct phases\
    \ while assigned to an\n   interface.  Initially, an address is \"preferred\"\
    , meaning that its\n   use in arbitrary communication is unrestricted.  Later,\
    \ an address\n   becomes \"deprecated\" in anticipation that its current interface\n\
    \   binding will become invalid.  While an address is in a deprecated\n   state,\
    \ its use is discouraged, but not strictly forbidden.  New\n   communication (e.g.,\
    \ the opening of a new TCP connection) should use\n   a preferred address when\
    \ possible.  A deprecated address should be\n   used only by applications that\
    \ have been using it and would have\n   difficulty switching to another address\
    \ without a service disruption.\n   To ensure that all configured addresses are\
    \ likely to be unique on a\n   given link, nodes run a \"duplicate address detection\"\
    \ algorithm on\n   addresses before assigning them to an interface.  The Duplicate\n\
    \   Address Detection algorithm is performed on all addresses,\n   independently\
    \ of whether they are obtained via stateless\n   autoconfiguration or DHCPv6.\
    \  This document defines the Duplicate\n   Address Detection algorithm.\n   The\
    \ autoconfiguration process specified in this document applies only\n   to hosts\
    \ and not routers.  Since host autoconfiguration uses\n   information advertised\
    \ by routers, routers will need to be configured\n   by some other means.  However,\
    \ it is expected that routers will\n   generate link-local addresses using the\
    \ mechanism described in this\n   document.  In addition, routers are expected\
    \ to successfully pass the\n   Duplicate Address Detection procedure described\
    \ in this document on\n   all addresses prior to assigning them to an interface.\n\
    \   Section 2 provides definitions for terminology used throughout this\n   document.\
    \  Section 3 describes the design goals that lead to the\n   current autoconfiguration\
    \ procedure.  Section 4 provides an overview\n   of the protocol, while Section\
    \ 5 describes the protocol in detail.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   IP -  Internet Protocol Version 6.  The terms IPv4 and IPv6\
    \ are used\n      only in contexts where necessary to avoid ambiguity.\n   node\
    \ -  a device that implements IP.\n   router -  a node that forwards IP packets\
    \ not explicitly addressed to\n      itself.\n   host -  any node that is not\
    \ a router.\n   upper layer -  a protocol layer immediately above IP.  Examples\
    \ are\n      transport protocols such as TCP and UDP, control protocols such as\n\
    \      ICMP, routing protocols such as OSPF, and Internet or lower-layer\n   \
    \   protocols being \"tunneled\" over (i.e., encapsulated in) IP such as\n   \
    \   IPX, AppleTalk, or IP itself.\n   link -  a communication facility or medium\
    \ over which nodes can\n      communicate at the link layer, i.e., the layer immediately\
    \ below\n      IP.  Examples are Ethernets (simple or bridged); PPP links; X.25,\n\
    \      Frame Relay, or ATM networks; and Internet (or higher) layer\n      \"\
    tunnels\", such as tunnels over IPv4 or IPv6 itself.  The protocol\n      described\
    \ in this document will be used on all types of links\n      unless specified\
    \ otherwise in the link-type-specific document\n      describing how to operate\
    \ IP on the link in line with [RFC4861].\n   interface -  a node's attachment\
    \ to a link.\n   packet -  an IP header plus payload.\n   address -  an IP-layer\
    \ identifier for an interface or a set of\n      interfaces.\n   unicast address\
    \ -  an identifier for a single interface.  A packet\n      sent to a unicast\
    \ address is delivered to the interface identified\n      by that address.\n \
    \  multicast address -  an identifier for a set of interfaces (typically\n   \
    \   belonging to different nodes).  A packet sent to a multicast\n      address\
    \ is delivered to all interfaces identified by that address.\n   anycast address\
    \ -  an identifier for a set of interfaces (typically\n      belonging to different\
    \ nodes).  A packet sent to an anycast\n      address is delivered to one of the\
    \ interfaces identified by that\n      address (the \"nearest\" one, according\
    \ to the routing protocol's\n      measure of distance).  See [RFC4291].\n   solicited-node\
    \ multicast address -  a multicast address to which\n      Neighbor Solicitation\
    \ messages are sent.  The algorithm for\n      computing the address is given\
    \ in [RFC4291].\n   link-layer address -  a link-layer identifier for an interface.\n\
    \      Examples include IEEE 802 addresses for Ethernet links and E.164\n    \
    \  addresses for Integrated Services Digital Network (ISDN) links.\n   link-local\
    \ address -  an address having link-only scope that can be\n      used to reach\
    \ neighboring nodes attached to the same link.  All\n      interfaces have a link-local\
    \ unicast address.\n   global address -  an address with unlimited scope.\n  \
    \ communication -  any packet exchange among nodes that requires that\n      the\
    \ address of each node used in the exchange remain the same for\n      the duration\
    \ of the packet exchange.  Examples are a TCP\n      connection or a UDP request-response.\n\
    \   tentative address -  an address whose uniqueness on a link is being\n    \
    \  verified, prior to its assignment to an interface.  A tentative\n      address\
    \ is not considered assigned to an interface in the usual\n      sense.  An interface\
    \ discards received packets addressed to a\n      tentative address, but accepts\
    \ Neighbor Discovery packets related\n      to Duplicate Address Detection for\
    \ the tentative address.\n   preferred address -  an address assigned to an interface\
    \ whose use by\n      upper-layer protocols is unrestricted.  Preferred addresses\
    \ may be\n      used as the source (or destination) address of packets sent from\n\
    \      (or to) the interface.\n   deprecated address -  An address assigned to\
    \ an interface whose use\n      is discouraged, but not forbidden.  A deprecated\
    \ address should no\n      longer be used as a source address in new communications,\
    \ but\n      packets sent from or to deprecated addresses are delivered as\n \
    \     expected.  A deprecated address may continue to be used as a\n      source\
    \ address in communications where switching to a preferred\n      address causes\
    \ hardship to a specific upper-layer activity (e.g.,\n      an existing TCP connection).\n\
    \   valid address -  a preferred or deprecated address.  A valid address\n   \
    \   may appear as the source or destination address of a packet, and\n      the\
    \ Internet routing system is expected to deliver packets sent to\n      a valid\
    \ address to their intended recipients.\n   invalid address -  an address that\
    \ is not assigned to any interface.\n      A valid address becomes invalid when\
    \ its valid lifetime expires.\n      Invalid addresses should not appear as the\
    \ destination or source\n      address of a packet.  In the former case, the Internet\
    \ routing\n      system will be unable to deliver the packet; in the latter case,\n\
    \      the recipient of the packet will be unable to respond to it.\n   preferred\
    \ lifetime -  the length of time that a valid address is\n      preferred (i.e.,\
    \ the time until deprecation).  When the preferred\n      lifetime expires, the\
    \ address becomes deprecated.\n   valid lifetime -  the length of time an address\
    \ remains in the valid\n      state (i.e., the time until invalidation).  The\
    \ valid lifetime\n      must be greater than or equal to the preferred lifetime.\
    \  When the\n      valid lifetime expires, the address becomes invalid.\n   interface\
    \ identifier -  a link-dependent identifier for an interface\n      that is (at\
    \ least) unique per link [RFC4291].  Stateless address\n      autoconfiguration\
    \ combines an interface identifier with a prefix\n      to form an address.  From\
    \ address autoconfiguration's perspective,\n      an interface identifier is a\
    \ bit string of known length.  The\n      exact length of an interface identifier\
    \ and the way it is created\n      is defined in a separate link-type specific\
    \ document that covers\n      issues related to the transmission of IP over a\
    \ particular link\n      type (e.g., [RFC2464]).  Note that the address architecture\n\
    \      [RFC4291] also defines the length of the interface identifiers for\n  \
    \    some set of addresses, but the two sets of definitions must be\n      consistent.\
    \  In many cases, the identifier will be derived from\n      the interface's link-layer\
    \ address.\n"
- title: 2.1.  Requirements
  contents:
  - "2.1.  Requirements\n   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT,\
    \ SHOULD,\n   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in\
    \ this\n   document, are to be interpreted as described in [RFC2119].\n   Note\
    \ that this document intentionally limits the use of the keywords\n   to the protocol\
    \ specification (Section 5).\n"
- title: 3.  Design Goals
  contents:
  - "3.  Design Goals\n   Stateless autoconfiguration is designed with the following\
    \ goals in\n   mind:\n   o  Manual configuration of individual machines before\
    \ connecting them\n      to the network should not be required.  Consequently,\
    \ a mechanism\n      is needed that allows a host to obtain or create unique addresses\n\
    \      for each of its interfaces.  Address autoconfiguration assumes\n      that\
    \ each interface can provide a unique identifier for that\n      interface (i.e.,\
    \ an \"interface identifier\").  In the simplest\n      case, an interface identifier\
    \ consists of the interface's link-\n      layer address.  An interface identifier\
    \ can be combined with a\n      prefix to form an address.\n   o  Small sites\
    \ consisting of a set of machines attached to a single\n      link should not\
    \ require the presence of a DHCPv6 server or router\n      as a prerequisite for\
    \ communicating.  Plug-and-play communication\n      is achieved through the use\
    \ of link-local addresses.  Link-local\n      addresses have a well-known prefix\
    \ that identifies the (single)\n      shared link to which a set of nodes attach.\
    \  A host forms a link-\n      local address by appending an interface identifier\
    \ to the link-\n      local prefix.\n   o  A large site with multiple networks\
    \ and routers should not require\n      the presence of a DHCPv6 server for address\
    \ configuration.  In\n      order to generate global addresses, hosts must determine\
    \ the\n      prefixes that identify the subnets to which they attach.  Routers\n\
    \      generate periodic Router Advertisements that include options\n      listing\
    \ the set of active prefixes on a link.\n   o  Address configuration should facilitate\
    \ the graceful renumbering\n      of a site's machines.  For example, a site may\
    \ wish to renumber\n      all of its nodes when it switches to a new network service\n\
    \      provider.  Renumbering is achieved through the leasing of\n      addresses\
    \ to interfaces and the assignment of multiple addresses\n      to the same interface.\
    \  Lease lifetimes provide the mechanism\n      through which a site phases out\
    \ old prefixes.  The assignment of\n      multiple addresses to an interface provides\
    \ for a transition\n      period during which both a new address and the one being\
    \ phased\n      out work simultaneously.\n"
- title: 4.  Protocol Overview
  contents:
  - "4.  Protocol Overview\n   This section provides an overview of the typical steps\
    \ that take\n   place when an interface autoconfigures itself.  Autoconfiguration\
    \ is\n   performed only on multicast-capable links and begins when a\n   multicast-capable\
    \ interface is enabled, e.g., during system startup.\n   Nodes (both hosts and\
    \ routers) begin the autoconfiguration process by\n   generating a link-local\
    \ address for the interface.  A link-local\n   address is formed by appending\
    \ an identifier of the interface to the\n   well-known link-local prefix [RFC4291].\n\
    \   Before the link-local address can be assigned to an interface and\n   used,\
    \ however, a node must attempt to verify that this \"tentative\"\n   address is\
    \ not already in use by another node on the link.\n   Specifically, it sends a\
    \ Neighbor Solicitation message containing the\n   tentative address as the target.\
    \  If another node is already using\n   that address, it will return a Neighbor\
    \ Advertisement saying so.  If\n   another node is also attempting to use the\
    \ same address, it will send\n   a Neighbor Solicitation for the target as well.\
    \  The exact number of\n   times the Neighbor Solicitation is (re)transmitted\
    \ and the delay time\n   between consecutive solicitations is link-specific and\
    \ may be set by\n   system management.\n   If a node determines that its tentative\
    \ link-local address is not\n   unique, autoconfiguration stops and manual configuration\
    \ of the\n   interface is required.  To simplify recovery in this case, it should\n\
    \   be possible for an administrator to supply an alternate interface\n   identifier\
    \ that overrides the default identifier in such a way that\n   the autoconfiguration\
    \ mechanism can then be applied using the new\n   (presumably unique) interface\
    \ identifier.  Alternatively, link-local\n   and other addresses will need to\
    \ be configured manually.\n   Once a node ascertains that its tentative link-local\
    \ address is\n   unique, it assigns the address to the interface.  At this point,\
    \ the\n   node has IP-level connectivity with neighboring nodes.  The remaining\n\
    \   autoconfiguration steps are performed only by hosts; the\n   (auto)configuration\
    \ of routers is beyond the scope of this document.\n   The next phase of autoconfiguration\
    \ involves obtaining a Router\n   Advertisement or determining that no routers\
    \ are present.  If routers\n   are present, they will send Router Advertisements\
    \ that specify what\n   sort of autoconfiguration a host can do.  Note that the\
    \ DHCPv6\n   service for address configuration may still be available even if\
    \ no\n   routers are present.\n   Routers send Router Advertisements periodically,\
    \ but the delay\n   between successive advertisements will generally be longer\
    \ than a\n   host performing autoconfiguration will want to wait [RFC4861].  To\n\
    \   obtain an advertisement quickly, a host sends one or more Router\n   Solicitations\
    \ to the all-routers multicast group.\n   Router Advertisements also contain zero\
    \ or more Prefix Information\n   options that contain information used by stateless\
    \ address\n   autoconfiguration to generate global addresses.  It should be noted\n\
    \   that a host may use both stateless address autoconfiguration and\n   DHCPv6\
    \ simultaneously.  One Prefix Information option field, the\n   \"autonomous address-configuration\
    \ flag\", indicates whether or not the\n   option even applies to stateless autoconfiguration.\
    \  If it does,\n   additional option fields contain a subnet prefix, together\
    \ with\n   lifetime values, indicating how long addresses created from the\n \
    \  prefix remain preferred and valid.\n   Because routers generate Router Advertisements\
    \ periodically, hosts\n   will continually receive new advertisements.  Hosts\
    \ process the\n   information contained in each advertisement as described above,\n\
    \   adding to and refreshing information received in previous\n   advertisements.\n\
    \   By default, all addresses should be tested for uniqueness prior to\n   their\
    \ assignment to an interface for safety.  The test should\n   individually be\
    \ performed on all addresses obtained manually, via\n   stateless address autoconfiguration,\
    \ or via DHCPv6.  To accommodate\n   sites that believe the overhead of performing\
    \ Duplicate Address\n   Detection outweighs its benefits, the use of Duplicate\
    \ Address\n   Detection can be disabled through the administrative setting of\
    \ a\n   per-interface configuration flag.\n   To speed the autoconfiguration process,\
    \ a host may generate its link-\n   local address (and verify its uniqueness)\
    \ in parallel with waiting\n   for a Router Advertisement.  Because a router may\
    \ delay responding to\n   a Router Solicitation for a few seconds, the total time\
    \ needed to\n   complete autoconfiguration can be significantly longer if the\
    \ two\n   steps are done serially.\n"
- title: 4.1.  Site Renumbering
  contents:
  - "4.1.  Site Renumbering\n   Address leasing facilitates site renumbering by providing\
    \ a mechanism\n   to time-out addresses assigned to interfaces in hosts.  At present,\n\
    \   upper-layer protocols such as TCP provide no support for changing\n   end-point\
    \ addresses while a connection is open.  If an end-point\n   address becomes invalid,\
    \ existing connections break and all\n   communication to the invalid address\
    \ fails.  Even when applications\n   use UDP as a transport protocol, addresses\
    \ must generally remain the\n   same during a packet exchange.\n   Dividing valid\
    \ addresses into preferred and deprecated categories\n   provides a way of indicating\
    \ to upper layers that a valid address may\n   become invalid shortly and that\
    \ future communication using the\n   address will fail, should the address's valid\
    \ lifetime expire before\n   communication ends.  To avoid this scenario, higher\
    \ layers should use\n   a preferred address (assuming one of sufficient scope\
    \ exists) to\n   increase the likelihood that an address will remain valid for\
    \ the\n   duration of the communication.  It is up to system administrators to\n\
    \   set appropriate prefix lifetimes in order to minimize the impact of\n   failed\
    \ communication when renumbering takes place.  The deprecation\n   period should\
    \ be long enough that most, if not all, communications\n   are using the new address\
    \ at the time an address becomes invalid.\n   The IP layer is expected to provide\
    \ a means for upper layers\n   (including applications) to select the most appropriate\
    \ source\n   address given a particular destination and possibly other\n   constraints.\
    \  An application may choose to select the source address\n   itself before starting\
    \ a new communication or may leave the address\n   unspecified, in which case,\
    \ the upper networking layers will use the\n   mechanism provided by the IP layer\
    \ to choose a suitable address on\n   the application's behalf.\n   Detailed address\
    \ selection rules are beyond the scope of this\n   document and are described\
    \ in [RFC3484].\n"
- title: 5.  Protocol Specification
  contents:
  - "5.  Protocol Specification\n   Autoconfiguration is performed on a per-interface\
    \ basis on multicast-\n   capable interfaces.  For multihomed hosts, autoconfiguration\
    \ is\n   performed independently on each interface.  Autoconfiguration applies\n\
    \   primarily to hosts, with two exceptions.  Routers are expected to\n   generate\
    \ a link-local address using the procedure outlined below.  In\n   addition, routers\
    \ perform Duplicate Address Detection on all\n   addresses prior to assigning\
    \ them to an interface.\n"
- title: 5.1.  Node Configuration Variables
  contents:
  - "5.1.  Node Configuration Variables\n   A node MUST allow the following autoconfiguration-related\
    \ variable to\n   be configured by system management for each multicast-capable\n\
    \   interface:\n   DupAddrDetectTransmits  The number of consecutive Neighbor\n\
    \      Solicitation messages sent while performing Duplicate Address\n      Detection\
    \ on a tentative address.  A value of zero indicates that\n      Duplicate Address\
    \ Detection is not performed on tentative\n      addresses.  A value of one indicates\
    \ a single transmission with no\n      follow-up retransmissions.\n      Default:\
    \ 1, but may be overridden by a link-type specific value in\n      the document\
    \ that covers issues related to the transmission of IP\n      over a particular\
    \ link type (e.g., [RFC2464]).\n      Autoconfiguration also assumes the presence\
    \ of the variable\n      RetransTimer as defined in [RFC4861].  For autoconfiguration\n\
    \      purposes, RetransTimer specifies the delay between consecutive\n      Neighbor\
    \ Solicitation transmissions performed during Duplicate\n      Address Detection\
    \ (if DupAddrDetectTransmits is greater than 1),\n      as well as the time a\
    \ node waits after sending the last Neighbor\n      Solicitation before ending\
    \ the Duplicate Address Detection\n      process.\n"
- title: 5.2.  Autoconfiguration-Related Structures
  contents:
  - "5.2.  Autoconfiguration-Related Structures\n   Beyond the formation of a link-local\
    \ address and use of Duplicate\n   Address Detection, how routers (auto)configure\
    \ their interfaces is\n   beyond the scope of this document.\n   A host maintains\
    \ a list of addresses together with their\n   corresponding lifetimes.  The address\
    \ list contains both\n   autoconfigured addresses and those configured manually.\n"
- title: 5.3.  Creation of Link-Local Addresses
  contents:
  - "5.3.  Creation of Link-Local Addresses\n   A node forms a link-local address\
    \ whenever an interface becomes\n   enabled.  An interface may become enabled\
    \ after any of the following\n   events:\n   -  The interface is initialized at\
    \ system startup time.\n   -  The interface is reinitialized after a temporary\
    \ interface failure\n      or after being temporarily disabled by system management.\n\
    \   -  The interface attaches to a link for the first time.  This\n      includes\
    \ the case where the attached link is dynamically changed\n      due to a change\
    \ of the access point of wireless networks.\n   -  The interface becomes enabled\
    \ by system management after having\n      been administratively disabled.\n \
    \  A link-local address is formed by combining the well-known link-local\n   prefix\
    \ FE80::0 [RFC4291] (of appropriate length) with an interface\n   identifier as\
    \ follows:\n   1.  The left-most 'prefix length' bits of the address are those\
    \ of\n       the link-local prefix.\n   2.  The bits in the address to the right\
    \ of the link-local prefix are\n       set to all zeroes.\n   3.  If the length\
    \ of the interface identifier is N bits, the right-\n       most N bits of the\
    \ address are replaced by the interface\n       identifier.\n   If the sum of\
    \ the link-local prefix length and N is larger than 128,\n   autoconfiguration\
    \ fails and manual configuration is required.  The\n   length of the interface\
    \ identifier is defined in a separate link-\n   type-specific document, which\
    \ should also be consistent with the\n   address architecture [RFC4291] (see Section\
    \ 2).  These documents will\n   carefully define the length so that link-local\
    \ addresses can be\n   autoconfigured on the link.\n   A link-local address has\
    \ an infinite preferred and valid lifetime; it\n   is never timed out.\n"
- title: 5.4.  Duplicate Address Detection
  contents:
  - "5.4.  Duplicate Address Detection\n   Duplicate Address Detection MUST be performed\
    \ on all unicast\n   addresses prior to assigning them to an interface, regardless\
    \ of\n   whether they are obtained through stateless autoconfiguration,\n   DHCPv6,\
    \ or manual configuration, with the following exceptions:\n   -  An interface\
    \ whose DupAddrDetectTransmits variable is set to zero\n      does not perform\
    \ Duplicate Address Detection.\n   -  Duplicate Address Detection MUST NOT be\
    \ performed on anycast\n      addresses (note that anycast addresses cannot syntactically\
    \ be\n      distinguished from unicast addresses).\n   -  Each individual unicast\
    \ address SHOULD be tested for uniqueness.\n      Note that there are implementations\
    \ deployed that only perform\n      Duplicate Address Detection for the link-local\
    \ address and skip\n      the test for the global address that uses the same interface\n\
    \      identifier as that of the link-local address.  Whereas this\n      document\
    \ does not invalidate such implementations, this kind of\n      \"optimization\"\
    \ is NOT RECOMMENDED, and new implementations MUST\n      NOT do that optimization.\
    \  This optimization came from the\n      assumption that all of an interface's\
    \ addresses are generated from\n      the same identifier.  However, the assumption\
    \ does actually not\n      stand; new types of addresses have been introduced\
    \ where the\n      interface identifiers are not necessarily the same for all\
    \ unicast\n      addresses on a single interface [RFC4941] [RFC3972].  Requiring\n\
    \      that Duplicate Address Detection be performed for all unicast\n      addresses\
    \ will make the algorithm robust for the current and\n      future special interface\
    \ identifiers.\n   The procedure for detecting duplicate addresses uses Neighbor\n\
    \   Solicitation and Advertisement messages as described below.  If a\n   duplicate\
    \ address is discovered during the procedure, the address\n   cannot be assigned\
    \ to the interface.  If the address is derived from\n   an interface identifier,\
    \ a new identifier will need to be assigned to\n   the interface, or all IP addresses\
    \ for the interface will need to be\n   manually configured.  Note that the method\
    \ for detecting duplicates\n   is not completely reliable, and it is possible\
    \ that duplicate\n   addresses will still exist (e.g., if the link was partitioned\
    \ while\n   Duplicate Address Detection was performed).\n   An address on which\
    \ the Duplicate Address Detection procedure is\n   applied is said to be tentative\
    \ until the procedure has completed\n   successfully.  A tentative address is\
    \ not considered \"assigned to an\n   interface\" in the traditional sense.  That\
    \ is, the interface must\n   accept Neighbor Solicitation and Advertisement messages\
    \ containing\n   the tentative address in the Target Address field, but processes\
    \ such\n   packets differently from those whose Target Address matches an\n  \
    \ address assigned to the interface.  Other packets addressed to the\n   tentative\
    \ address should be silently discarded.  Note that the \"other\n   packets\" include\
    \ Neighbor Solicitation and Advertisement messages\n   that have the tentative\
    \ (i.e., unicast) address as the IP destination\n   address and contain the tentative\
    \ address in the Target Address\n   field.  Such a case should not happen in normal\
    \ operation, though,\n   since these messages are multicasted in the Duplicate\
    \ Address\n   Detection procedure.\n   It should also be noted that Duplicate\
    \ Address Detection must be\n   performed prior to assigning an address to an\
    \ interface in order to\n   prevent multiple nodes from using the same address\
    \ simultaneously.\n   If a node begins using an address in parallel with Duplicate\
    \ Address\n   Detection, and another node is already using the address, the node\n\
    \   performing Duplicate Address Detection will erroneously process\n   traffic\
    \ intended for the other node, resulting in such possible\n   negative consequences\
    \ as the resetting of open TCP connections.\n   The following subsections describe\
    \ specific tests a node performs to\n   verify an address's uniqueness.  An address\
    \ is considered unique if\n   none of the tests indicate the presence of a duplicate\
    \ address within\n   RetransTimer milliseconds after having sent DupAddrDetectTransmits\n\
    \   Neighbor Solicitations.  Once an address is determined to be unique,\n   it\
    \ may be assigned to an interface.\n"
- title: 5.4.1.  Message Validation
  contents:
  - "5.4.1.  Message Validation\n   A node MUST silently discard any Neighbor Solicitation\
    \ or\n   Advertisement message that does not pass the validity checks\n   specified\
    \ in [RFC4861].  A Neighbor Solicitation or Advertisement\n   message that passes\
    \ these validity checks is called a valid\n   solicitation or valid advertisement,\
    \ respectively.\n"
- title: 5.4.2.  Sending Neighbor Solicitation Messages
  contents:
  - "5.4.2.  Sending Neighbor Solicitation Messages\n   Before sending a Neighbor\
    \ Solicitation, an interface MUST join the\n   all-nodes multicast address and\
    \ the solicited-node multicast address\n   of the tentative address.  The former\
    \ ensures that the node receives\n   Neighbor Advertisements from other nodes\
    \ already using the address;\n   the latter ensures that two nodes attempting\
    \ to use the same address\n   simultaneously should detect each other's presence.\n\
    \   To check an address, a node sends DupAddrDetectTransmits Neighbor\n   Solicitations,\
    \ each separated by RetransTimer milliseconds.  The\n   solicitation's Target\
    \ Address is set to the address being checked,\n   the IP source is set to the\
    \ unspecified address, and the IP\n   destination is set to the solicited-node\
    \ multicast address of the\n   target address.\n   If the Neighbor Solicitation\
    \ is going to be the first message sent\n   from an interface after interface\
    \ (re)initialization, the node SHOULD\n   delay joining the solicited-node multicast\
    \ address by a random delay\n   between 0 and MAX_RTR_SOLICITATION_DELAY as specified\
    \ in [RFC4861].\n   This serves to alleviate congestion when many nodes start\
    \ up on the\n   link at the same time, such as after a power failure, and may\
    \ help to\n   avoid race conditions when more than one node is trying to solicit\n\
    \   for the same address at the same time.\n   Even if the Neighbor Solicitation\
    \ is not going to be the first\n   message sent, the node SHOULD delay joining\
    \ the solicited-node\n   multicast address by a random delay between 0 and\n \
    \  MAX_RTR_SOLICITATION_DELAY if the address being checked is configured\n   by\
    \ a router advertisement message sent to a multicast address.  The\n   delay will\
    \ avoid similar congestion when multiple nodes are going to\n   configure addresses\
    \ by receiving the same single multicast router\n   advertisement.\n   Note that\
    \ when a node joins a multicast address, it typically sends a\n   Multicast Listener\
    \ Discovery (MLD) report message [RFC2710] [RFC3810]\n   for the multicast address.\
    \  In the case of Duplicate Address\n   Detection, the MLD report message is required\
    \ in order to inform MLD-\n   snooping switches, rather than routers, to forward\
    \ multicast packets.\n   In the above description, the delay for joining the multicast\
    \ address\n   thus means delaying transmission of the corresponding MLD report\n\
    \   message.  Since the MLD specifications do not request a random delay\n   to\
    \ avoid race conditions, just delaying Neighbor Solicitation would\n   cause congestion\
    \ by the MLD report messages.  The congestion would\n   then prevent the MLD-snooping\
    \ switches from working correctly and, as\n   a result, prevent Duplicate Address\
    \ Detection from working.  The\n   requirement to include the delay for the MLD\
    \ report in this case\n   avoids this scenario.  [RFC3590] also talks about some\
    \ interaction\n   issues between Duplicate Address Detection and MLD, and specifies\n\
    \   which source address should be used for the MLD report in this case.\n   In\
    \ order to improve the robustness of the Duplicate Address Detection\n   algorithm,\
    \ an interface MUST receive and process datagrams sent to\n   the all-nodes multicast\
    \ address or solicited-node multicast address\n   of the tentative address during\
    \ the delay period.  This does not\n   necessarily conflict with the requirement\
    \ that joining the multicast\n   group be delayed.  In fact, in some cases it\
    \ is possible for a node\n   to start listening to the group during the delay\
    \ period before MLD\n   report transmission.  It should be noted, however, that\
    \ in some link-\n   layer environments, particularly with MLD-snooping switches,\
    \ no\n   multicast reception will be available until the MLD report is sent.\n"
- title: 5.4.3.  Receiving Neighbor Solicitation Messages
  contents:
  - "5.4.3.  Receiving Neighbor Solicitation Messages\n   On receipt of a valid Neighbor\
    \ Solicitation message on an interface,\n   node behavior depends on whether or\
    \ not the target address is\n   tentative.  If the target address is not tentative\
    \ (i.e., it is\n   assigned to the receiving interface), the solicitation is processed\n\
    \   as described in [RFC4861].  If the target address is tentative, and\n   the\
    \ source address is a unicast address, the solicitation's sender is\n   performing\
    \ address resolution on the target; the solicitation should\n   be silently ignored.\
    \  Otherwise, processing takes place as described\n   below.  In all cases, a\
    \ node MUST NOT respond to a Neighbor\n   Solicitation for a tentative address.\n\
    \   If the source address of the Neighbor Solicitation is the unspecified\n  \
    \ address, the solicitation is from a node performing Duplicate Address\n   Detection.\
    \  If the solicitation is from another node, the tentative\n   address is a duplicate\
    \ and should not be used (by either node).  If\n   the solicitation is from the\
    \ node itself (because the node loops back\n   multicast packets), the solicitation\
    \ does not indicate the presence\n   of a duplicate address.\n   Implementer's\
    \ Note: many interfaces provide a way for upper layers to\n   selectively enable\
    \ and disable the looping back of multicast packets.\n   The details of how such\
    \ a facility is implemented may prevent\n   Duplicate Address Detection from working\
    \ correctly.  See Appendix A\n   for further discussion.\n   The following tests\
    \ identify conditions under which a tentative\n   address is not unique:\n   -\
    \  If a Neighbor Solicitation for a tentative address is received\n      before\
    \ one is sent, the tentative address is a duplicate.  This\n      condition occurs\
    \ when two nodes run Duplicate Address Detection\n      simultaneously, but transmit\
    \ initial solicitations at different\n      times (e.g., by selecting different\
    \ random delay values before\n      joining the solicited-node multicast address\
    \ and transmitting an\n      initial solicitation).\n   -  If the actual number\
    \ of Neighbor Solicitations received exceeds\n      the number expected based\
    \ on the loopback semantics (e.g., the\n      interface does not loop back the\
    \ packet, yet one or more\n      solicitations was received), the tentative address\
    \ is a duplicate.\n      This condition occurs when two nodes run Duplicate Address\n\
    \      Detection simultaneously and transmit solicitations at roughly the\n  \
    \    same time.\n"
- title: 5.4.4.  Receiving Neighbor Advertisement Messages
  contents:
  - "5.4.4.  Receiving Neighbor Advertisement Messages\n   On receipt of a valid Neighbor\
    \ Advertisement message on an interface,\n   node behavior depends on whether\
    \ the target address is tentative or\n   matches a unicast or anycast address\
    \ assigned to the interface:\n   1.  If the target address is tentative, the tentative\
    \ address is not\n       unique.\n   2.  If the target address matches a unicast\
    \ address assigned to the\n       receiving interface, it would possibly indicate\
    \ that the address\n       is a duplicate but it has not been detected by the\
    \ Duplicate\n       Address Detection procedure (recall that Duplicate Address\n\
    \       Detection is not completely reliable).  How to handle such a case\n  \
    \     is beyond the scope of this document.\n   3.  Otherwise, the advertisement\
    \ is processed as described in\n       [RFC4861].\n"
- title: 5.4.5.  When Duplicate Address Detection Fails
  contents:
  - "5.4.5.  When Duplicate Address Detection Fails\n   A tentative address that is\
    \ determined to be a duplicate as described\n   above MUST NOT be assigned to\
    \ an interface, and the node SHOULD log a\n   system management error.\n   If\
    \ the address is a link-local address formed from an interface\n   identifier\
    \ based on the hardware address, which is supposed to be\n   uniquely assigned\
    \ (e.g., EUI-64 for an Ethernet interface), IP\n   operation on the interface\
    \ SHOULD be disabled.  By disabling IP\n   operation, the node will then:\n  \
    \ -  not send any IP packets from the interface,\n   -  silently drop any IP packets\
    \ received on the interface, and\n   -  not forward any IP packets to the interface\
    \ (when acting as a\n      router or processing a packet with a Routing header).\n\
    \   In this case, the IP address duplication probably means duplicate\n   hardware\
    \ addresses are in use, and trying to recover from it by\n   configuring another\
    \ IP address will not result in a usable network.\n   In fact, it probably makes\
    \ things worse by creating problems that are\n   harder to diagnose than just\
    \ disabling network operation on the\n   interface; the user will see a partially\
    \ working network where some\n   things work, and other things do not.\n   On\
    \ the other hand, if the duplicate link-local address is not formed\n   from an\
    \ interface identifier based on the hardware address, which is\n   supposed to\
    \ be uniquely assigned, IP operation on the interface MAY\n   be continued.\n\
    \   Note: as specified in Section 2, \"IP\" means \"IPv6\" in the above\n   description.\
    \  While the background rationale about hardware address\n   is independent of\
    \ particular network protocols, its effect on other\n   protocols is beyond the\
    \ scope of this document.\n"
- title: 5.5.  Creation of Global Addresses
  contents:
  - "5.5.  Creation of Global Addresses\n   Global addresses are formed by appending\
    \ an interface identifier to a\n   prefix of appropriate length.  Prefixes are\
    \ obtained from Prefix\n   Information options contained in Router Advertisements.\
    \  Creation of\n   global addresses as described in this section SHOULD be locally\n\
    \   configurable.  However, the processing described below MUST be\n   enabled\
    \ by default.\n"
- title: 5.5.1.  Soliciting Router Advertisements
  contents:
  - "5.5.1.  Soliciting Router Advertisements\n   Router Advertisements are sent periodically\
    \ to the all-nodes\n   multicast address.  To obtain an advertisement quickly,\
    \ a host sends\n   out Router Solicitations as described in [RFC4861].\n"
- title: 5.5.2.  Absence of Router Advertisements
  contents:
  - "5.5.2.  Absence of Router Advertisements\n   Even if a link has no routers, the\
    \ DHCPv6 service to obtain addresses\n   may still be available, and hosts may\
    \ want to use the service.  From\n   the perspective of autoconfiguration, a link\
    \ has no routers if no\n   Router Advertisements are received after having sent\
    \ a small number\n   of Router Solicitations as described in [RFC4861].\n   Note\
    \ that it is possible that there is no router on the link in this\n   sense, but\
    \ there is a node that has the ability to forward packets.\n   In this case, the\
    \ forwarding node's address must be manually\n   configured in hosts to be able\
    \ to send packets off-link, since the\n   only mechanism to configure the default\
    \ router's address\n   automatically is the one using Router Advertisements.\n"
- title: 5.5.3.  Router Advertisement Processing
  contents:
  - "5.5.3.  Router Advertisement Processing\n   For each Prefix-Information option\
    \ in the Router Advertisement:\n    a)  If the Autonomous flag is not set, silently\
    \ ignore the Prefix\n      Information option.\n    b)  If the prefix is the link-local\
    \ prefix, silently ignore the\n      Prefix Information option.\n    c)  If the\
    \ preferred lifetime is greater than the valid lifetime,\n      silently ignore\
    \ the Prefix Information option.  A node MAY wish to\n      log a system management\
    \ error in this case.\n    d)  If the prefix advertised is not equal to the prefix\
    \ of an\n      address configured by stateless autoconfiguration already in the\n\
    \      list of addresses associated with the interface (where \"equal\"\n    \
    \  means the two prefix lengths are the same and the first prefix-\n      length\
    \ bits of the prefixes are identical), and if the Valid\n      Lifetime is not\
    \ 0, form an address (and add it to the list) by\n      combining the advertised\
    \ prefix with an interface identifier of\n      the link as follows:\n      |\
    \            128 - N bits               |       N bits           |\n      +---------------------------------------+------------------------+\n\
    \      |            link prefix                |  interface identifier  |\n  \
    \    +----------------------------------------------------------------+\n    \
    \  If the sum of the prefix length and interface identifier length\n      does\
    \ not equal 128 bits, the Prefix Information option MUST be\n      ignored.  An\
    \ implementation MAY wish to log a system management\n      error in this case.\
    \  The length of the interface identifier is\n      defined in a separate link-type\
    \ specific document, which should\n      also be consistent with the address architecture\
    \ [RFC4291] (see\n      Section 2).\n      It is the responsibility of the system\
    \ administrator to ensure\n      that the lengths of prefixes contained in Router\
    \ Advertisements\n      are consistent with the length of interface identifiers\
    \ for that\n      link type.  It should be noted, however, that this does not\
    \ mean\n      the advertised prefix length is meaningless.  In fact, the\n   \
    \   advertised length has non-trivial meaning for on-link\n      determination\
    \ in [RFC4861] where the sum of the prefix length and\n      the interface identifier\
    \ length may not be equal to 128.  Thus, it\n      should be safe to validate\
    \ the advertised prefix length here, in\n      order to detect and avoid a configuration\
    \ error specifying an\n      invalid prefix length in the context of address autoconfiguration.\n\
    \      Note that a future revision of the address architecture [RFC4291]\n   \
    \   and a future link-type-specific document, which will still be\n      consistent\
    \ with each other, could potentially allow for an\n      interface identifier\
    \ of length other than the value defined in the\n      current documents.  Thus,\
    \ an implementation should not assume a\n      particular constant.  Rather, it\
    \ should expect any lengths of\n      interface identifiers.\n      If an address\
    \ is formed successfully and the address is not yet in\n      the list, the host\
    \ adds it to the list of addresses assigned to\n      the interface, initializing\
    \ its preferred and valid lifetime\n      values from the Prefix Information option.\
    \  Note that the check\n      against the prefix performed at the beginning of\
    \ this step cannot\n      always detect the address conflict in the list.  It\
    \ could be\n      possible that an address already in the list, configured either\n\
    \      manually or by DHCPv6, happens to be identical to the newly\n      created\
    \ address, whereas such a case should be atypical.\n    e)  If the advertised\
    \ prefix is equal to the prefix of an address\n      configured by stateless autoconfiguration\
    \ in the list, the\n      preferred lifetime of the address is reset to the Preferred\n\
    \      Lifetime in the received advertisement.  The specific action to\n     \
    \ perform for the valid lifetime of the address depends on the Valid\n      Lifetime\
    \ in the received advertisement and the remaining time to\n      the valid lifetime\
    \ expiration of the previously autoconfigured\n      address.  We call the remaining\
    \ time \"RemainingLifetime\" in the\n      following discussion:\n      1.  If\
    \ the received Valid Lifetime is greater than 2 hours or\n          greater than\
    \ RemainingLifetime, set the valid lifetime of the\n          corresponding address\
    \ to the advertised Valid Lifetime.\n      2.  If RemainingLifetime is less than\
    \ or equal to 2 hours, ignore\n          the Prefix Information option with regards\
    \ to the valid\n          lifetime, unless the Router Advertisement from which\
    \ this\n          option was obtained has been authenticated (e.g., via Secure\n\
    \          Neighbor Discovery [RFC3971]).  If the Router Advertisement\n     \
    \     was authenticated, the valid lifetime of the corresponding\n          address\
    \ should be set to the Valid Lifetime in the received\n          option.\n   \
    \   3.  Otherwise, reset the valid lifetime of the corresponding\n          address\
    \ to 2 hours.\n      The above rules address a specific denial-of-service attack\
    \ in\n      which a bogus advertisement could contain prefixes with very small\n\
    \      Valid Lifetimes.  Without the above rules, a single\n      unauthenticated\
    \ advertisement containing bogus Prefix Information\n      options with short\
    \ Valid Lifetimes could cause all of a node's\n      addresses to expire prematurely.\
    \  The above rules ensure that\n      legitimate advertisements (which are sent\
    \ periodically) will\n      \"cancel\" the short Valid Lifetimes before they actually\
    \ take\n      effect.\n      Note that the preferred lifetime of the corresponding\
    \ address is\n      always reset to the Preferred Lifetime in the received Prefix\n\
    \      Information option, regardless of whether the valid lifetime is\n     \
    \ also reset or ignored.  The difference comes from the fact that\n      the possible\
    \ attack for the preferred lifetime is relatively\n      minor.  Additionally,\
    \ it is even undesirable to ignore the\n      preferred lifetime when a valid\
    \ administrator wants to deprecate a\n      particular address by sending a short\
    \ preferred lifetime (and the\n      valid lifetime is ignored by accident).\n"
- title: 5.5.4.  Address Lifetime Expiry
  contents:
  - "5.5.4.  Address Lifetime Expiry\n   A preferred address becomes deprecated when\
    \ its preferred lifetime\n   expires.  A deprecated address SHOULD continue to\
    \ be used as a source\n   address in existing communications, but SHOULD NOT be\
    \ used to\n   initiate new communications if an alternate (non-deprecated) address\n\
    \   of sufficient scope can easily be used instead.\n   Note that the feasibility\
    \ of initiating new communication using a\n   non-deprecated address may be an\
    \ application-specific decision, as\n   only the application may have knowledge\
    \ about whether the (now)\n   deprecated address was (or still is) in use by the\
    \ application.  For\n   example, if an application explicitly specifies that the\
    \ protocol\n   stack use a deprecated address as a source address, the protocol\n\
    \   stack must accept that; the application might request it because that\n  \
    \ IP address is used in higher-level communication and there might be a\n   requirement\
    \ that the multiple connections in such a grouping use the\n   same pair of IP\
    \ addresses.\n   IP and higher layers (e.g., TCP, UDP) MUST continue to accept\
    \ and\n   process datagrams destined to a deprecated address as normal since a\n\
    \   deprecated address is still a valid address for the interface.  In\n   the\
    \ case of TCP, this means TCP SYN segments sent to a deprecated\n   address are\
    \ responded to using the deprecated address as a source\n   address in the corresponding\
    \ SYN-ACK (if the connection would\n   otherwise be allowed).\n   An implementation\
    \ MAY prevent any new communication from using a\n   deprecated address, but system\
    \ management MUST have the ability to\n   disable such a facility, and the facility\
    \ MUST be disabled by\n   default.\n   Other subtle cases should also be noted\
    \ about source address\n   selection.  For example, the above description does\
    \ not clarify which\n   address should be used between a deprecated, smaller-scope\
    \ address\n   and a non-deprecated, sufficient scope address.  The details of\
    \ the\n   address selection including this case are described in [RFC3484] and\n\
    \   are beyond the scope of this document.\n   An address (and its association\
    \ with an interface) becomes invalid\n   when its valid lifetime expires.  An\
    \ invalid address MUST NOT be used\n   as a source address in outgoing communications\
    \ and MUST NOT be\n   recognized as a destination on a receiving interface.\n"
- title: 5.6.  Configuration Consistency
  contents:
  - "5.6.  Configuration Consistency\n   It is possible for hosts to obtain address\
    \ information using both\n   stateless autoconfiguration and DHCPv6 since both\
    \ may be enabled at\n   the same time.  It is also possible that the values of\
    \ other\n   configuration parameters, such as MTU size and hop limit, will be\n\
    \   learned from both Router Advertisements and DHCPv6.  If the same\n   configuration\
    \ information is provided by multiple sources, the value\n   of this information\
    \ should be consistent.  However, it is not\n   considered a fatal error if information\
    \ received from multiple\n   sources is inconsistent.  Hosts accept the union\
    \ of all information\n   received via Neighbor Discovery and DHCPv6.\n   If inconsistent\
    \ information is learned from different sources, an\n   implementation may want\
    \ to give information learned securely\n   precedence over information learned\
    \ without protection.  For\n   instance, Section 8 of [RFC3971] discusses how\
    \ to deal with\n   information learned through Secure Neighbor Discovery conflicting\n\
    \   with information learned through plain Neighbor Discovery.  The same\n   discussion\
    \ can apply to the preference between information learned\n   through plain Neighbor\
    \ Discovery and information learned via secured\n   DHCPv6, and so on.\n   In\
    \ any case, if there is no security difference, the most recently\n   obtained\
    \ values SHOULD have precedence over information learned\n   earlier.\n"
- title: 5.7.  Retaining Configured Addresses for Stability
  contents:
  - "5.7.  Retaining Configured Addresses for Stability\n   An implementation that\
    \ has stable storage may want to retain\n   addresses in the storage when the\
    \ addresses were acquired using\n   stateless address autoconfiguration.  Assuming\
    \ the lifetimes used are\n   reasonable, this technique implies that a temporary\
    \ outage (less than\n   the valid lifetime) of a router will never result in losing\
    \ a global\n   address of the node even if the node were to reboot.  When this\n\
    \   technique is used, it should also be noted that the expiration times\n   of\
    \ the preferred and valid lifetimes must be retained, in order to\n   prevent\
    \ the use of an address after it has become deprecated or\n   invalid.\n   Further\
    \ details on this kind of extension are beyond the scope of\n   this document.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Stateless address autoconfiguration allows a\
    \ host to connect to a\n   network, configure an address, and start communicating\
    \ with other\n   nodes without ever registering or authenticating itself with\
    \ the\n   local site.  Although this allows unauthorized users to connect to\n\
    \   and use a network, the threat is inherently present in the Internet\n   architecture.\
    \  Any node with a physical attachment to a network can\n   generate an address\
    \ (using a variety of ad hoc techniques) that\n   provides connectivity.\n   The\
    \ use of stateless address autoconfiguration and Duplicate Address\n   Detection\
    \ opens up the possibility of several denial-of-service\n   attacks.  For example,\
    \ any node can respond to Neighbor Solicitations\n   for a tentative address,\
    \ causing the other node to reject the address\n   as a duplicate.  A separate\
    \ document [RFC3756] discusses details\n   about these attacks, which can be addressed\
    \ with the Secure Neighbor\n   Discovery protocol [RFC3971].  It should also be\
    \ noted that [RFC3756]\n   points out that the use of IP security is not always\
    \ feasible\n   depending on network environments.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   Thomas Narten and Susan Thompson were the authors of\
    \ RFCs 1971 and\n   2462.  For this revision of the RFC, Tatuya Jinmei was the\
    \ sole\n   editor.\n   The authors of RFC 2461 would like to thank the members\
    \ of both the\n   IPNG (which is now IPV6) and ADDRCONF working groups for their\
    \ input.\n   In particular, thanks to Jim Bound, Steve Deering, Richard Draves,\n\
    \   and Erik Nordmark.  Thanks also goes to John Gilmore for alerting the\n  \
    \ WG of the \"0 Lifetime Prefix Advertisement\" denial-of-service attack\n   vulnerability;\
    \ this document incorporates changes that address this\n   vulnerability.\n  \
    \ A number of people have contributed to identifying issues with RFC\n   2461\
    \ and to proposing resolutions to the issues as reflected in this\n   version\
    \ of the document.  In addition to those listed above, the\n   contributors include\
    \ Jari Arkko, James Carlson, Brian E.  Carpenter,\n   Gregory Daley, Elwyn Davies,\
    \ Ralph Droms, Jun-ichiro Itojun Hagino,\n   Christian Huitema, Suresh Krishnan,\
    \ Soohong Daniel Park, Markku\n   Savela, Pekka Savola, Hemant Singh, Bernie Volz,\
    \ Margaret Wasserman,\n   and Vlad Yasevich.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2464]     Crawford, M., \"Transmission of\
    \ IPv6 Packets over\n                 Ethernet Networks\", RFC 2464, December\
    \ 1998.\n   [RFC2119]     Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \                 Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC4291]\
    \     Hinden, R. and S. Deering, \"IP Version 6 Addressing\n                 Architecture\"\
    , RFC 4291, February 2006.\n   [RFC4861]     Narten, T., Nordmark, E., Simpson,\
    \ W., and H. Soliman,\n                 \"Neighbor Discovery for IP version 6\
    \ (IPv6)\", RFC 4861,\n                 September 2007.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [RFC3315]     Droms, R., Bound, J., Volz, B.,\
    \ Lemon, T., Perkins, C.,\n                 and M. Carney, \"Dynamic Host Configuration\
    \ Protocol for\n                 IPv6 (DHCPv6)\", RFC 3315, July 2003.\n   [RFC3484]\
    \     Draves, R., \"Default Address Selection for Internet\n                 Protocol\
    \ version 6 (IPv6)\", RFC 3484, February 2003.\n   [RFC4941]     Narten, T., Draves,\
    \ R., and S. Krishnan, \"Privacy\n                 Extensions for Stateless Address\
    \ Autoconfiguration in\n                 IPv6\", RFC 4941, September 2007.\n \
    \  [RFC3972]     Aura, T., \"Cryptographically Generated Addresses\n         \
    \        (CGA)\", RFC 3972, March 2005.\n   [RFC2710]     Deering, S., Fenner,\
    \ W., and B. Haberman, \"Multicast\n                 Listener Discovery (MLD)\
    \ for IPv6\", RFC 2710,\n                 October 1999.\n   [RFC3810]     Vida,\
    \ R. and L. Costa, \"Multicast Listener Discovery\n                 Version 2\
    \ (MLDv2) for IPv6\", RFC 3810, June 2004.\n   [RFC3590]     Haberman, B., \"\
    Source Address Selection for the\n                 Multicast Listener Discovery\
    \ (MLD) Protocol\", RFC 3590,\n                 September 2003.\n   [RFC3971]\
    \     Arkko, J., Kempf, J., Zill, B., and P. Nikander,\n                 \"SEcure\
    \ Neighbor Discovery (SEND)\", RFC 3971,\n                 March 2005.\n   [RFC3756]\
    \     Nikander, P., Kempf, J., and E. Nordmark, \"IPv6\n                 Neighbor\
    \ Discovery (ND) Trust Models and Threats\",\n                 RFC 3756, May 2004.\n\
    \   [RFC1112]     Deering, S., \"Host extensions for IP multicasting\",\n    \
    \             STD 5, RFC 1112, August 1989.\n   [IEEE802.11]  IEEE, \"Wireless\
    \ LAN Medium Access Control (MAC) and\n                 Physical Layer (PHY) Specifications\"\
    , ANSI/IEEE\n                 STd 802.11, August 1999.\n"
- title: Appendix A.  Loopback Suppression and Duplicate Address Detection
  contents:
  - "Appendix A.  Loopback Suppression and Duplicate Address Detection\n   Determining\
    \ whether a received multicast solicitation was looped back\n   to the sender\
    \ or actually came from another node is implementation-\n   dependent.  A problematic\
    \ case occurs when two interfaces attached to\n   the same link happen to have\
    \ the same identifier and link-layer\n   address, and they both send out packets\
    \ with identical contents at\n   roughly the same time (e.g., Neighbor Solicitations\
    \ for a tentative\n   address as part of Duplicate Address Detection messages).\
    \  Although a\n   receiver will receive both packets, it cannot determine which\
    \ packet\n   was looped back and which packet came from the other node simply\
    \ by\n   comparing packet contents (i.e., the contents are identical).  In\n \
    \  this particular case, it is not necessary to know precisely which\n   packet\
    \ was looped back and which was sent by another node; if one\n   receives more\
    \ solicitations than were sent, the tentative address is\n   a duplicate.  However,\
    \ the situation may not always be this\n   straightforward.\n   The IPv4 multicast\
    \ specification [RFC1112] recommends that the\n   service interface provide a\
    \ way for an upper-layer protocol to\n   inhibit local delivery of packets sent\
    \ to a multicast group that the\n   sending host is a member of.  Some applications\
    \ know that there will\n   be no other group members on the same host, and suppressing\
    \ loopback\n   prevents them from having to receive (and discard) the packets\
    \ they\n   themselves send out.  A straightforward way to implement this\n   facility\
    \ is to disable loopback at the hardware level (if supported\n   by the hardware),\
    \ with packets looped back (if requested) by\n   software.  On interfaces in which\
    \ the hardware itself suppresses\n   loopbacks, a node running Duplicate Address\
    \ Detection simply counts\n   the number of Neighbor Solicitations received for\
    \ a tentative address\n   and compares them with the number expected.  If there\
    \ is a mismatch,\n   the tentative address is a duplicate.\n   In those cases\
    \ where the hardware cannot suppress loopbacks, however,\n   one possible software\
    \ heuristic to filter out unwanted loopbacks is\n   to discard any received packet\
    \ whose link-layer source address is the\n   same as the receiving interface's.\
    \  There is even a link-layer\n   specification that requires that any such packets\
    \ be discarded\n   [IEEE802.11].  Unfortunately, use of that criteria also results\
    \ in\n   the discarding of all packets sent by another node using the same\n \
    \  link-layer address.  Duplicate Address Detection will fail on\n   interfaces\
    \ that filter received packets in this manner:\n   o  If a node performing Duplicate\
    \ Address Detection discards received\n      packets that have the same source\
    \ link-layer address as the\n      receiving interface, it will also discard packets\
    \ from other nodes\n      that also use the same link-layer address, including\
    \ Neighbor\n      Advertisement and Neighbor Solicitation messages required to\
    \ make\n      Duplicate Address Detection work correctly.  This particular\n \
    \     problem can be avoided by temporarily disabling the software\n      suppression\
    \ of loopbacks while a node performs Duplicate Address\n      Detection, if it\
    \ is possible to disable the suppression.\n   o  If a node that is already using\
    \ a particular IP address discards\n      received packets that have the same\
    \ link-layer source address as\n      the interface, it will also discard Duplicate\
    \ Address Detection-\n      related Neighbor Solicitation messages sent by another\
    \ node that\n      also use the same link-layer address.  Consequently, Duplicate\n\
    \      Address Detection will fail, and the other node will configure a\n    \
    \  non-unique address.  Since it is generally impossible to know when\n      another\
    \ node is performing Duplicate Address Detection, this\n      scenario can be\
    \ avoided only if software suppression of loopback\n      is permanently disabled.\n\
    \   Thus, to perform Duplicate Address Detection correctly in the case\n   where\
    \ two interfaces are using the same link-layer address, an\n   implementation\
    \ must have a good understanding of the interface's\n   multicast loopback semantics,\
    \ and the interface cannot discard\n   received packets simply because the source\
    \ link-layer address is the\n   same as the interface's.  It should also be noted\
    \ that a link-layer\n   specification can conflict with the condition necessary\
    \ to make\n   Duplicate Address Detection work.\n"
- title: Appendix B.  Changes since RFC 1971
  contents:
  - "Appendix B.  Changes since RFC 1971\n   o  Changed document to use term \"interface\
    \ identifier\" rather than\n      \"interface token\" for consistency with other\
    \ IPv6 documents.\n   o  Clarified definition of deprecated address to make clear\
    \ it is OK\n      to continue sending to or from deprecated addresses.\n   o \
    \ Added rules to Section 5.5.3 Router Advertisement processing to\n      address\
    \ potential denial-of-service attack when prefixes are\n      advertised with\
    \ very short Lifetimes.\n   o  Clarified wording in Section 5.5.4 to make clear\
    \ that all upper\n      layer protocols must process (i.e., send and receive)\
    \ packets sent\n      to deprecated addresses.\n"
- title: Appendix C.  Changes since RFC 2462
  contents:
  - "Appendix C.  Changes since RFC 2462\n   Major changes that can affect existing\
    \ implementations:\n   o  Specified that a node performing Duplicate Address Detection\
    \ delay\n      joining the solicited-node multicast group, not just delay sending\n\
    \      Neighbor Solicitations, explaining the detailed reason.\n   o  Added a\
    \ requirement for a random delay before sending Neighbor\n      Solicitations\
    \ for Duplicate Address Detection if the address being\n      checked is configured\
    \ by a multicasted Router Advertisements.\n   o  Clarified that on failure of\
    \ Duplicate Address Detection, IP\n      network operation should be disabled\
    \ and that the rule should\n      apply when the hardware address is supposed\
    \ to be unique.\n   Major clarifications:\n   o  Clarified how the length of interface\
    \ identifiers should be\n      determined, described the relationship with the\
    \ prefix length\n      advertised in Router Advertisements, and avoided using\
    \ a\n      particular length hard-coded in this document.\n   o  Clarified the\
    \ processing of received neighbor advertisements while\n      performing Duplicate\
    \ Address Detection.\n   o  Removed the text regarding the M and O flags, considering\
    \ the\n      maturity of implementations and operational experiences.\n      ManagedFlag\
    \ and OtherConfigFlag were removed accordingly.  (Note\n      that this change\
    \ does not mean the use of these flags is\n      deprecated.)\n   o  Avoided the\
    \ wording of \"stateful configuration\", which is known to\n      be quite confusing,\
    \ and simply used \"DHCPv6\" wherever appropriate.\n   o  Recommended to perform\
    \ Duplicate Address Detection for all unicast\n      addresses more strongly,\
    \ considering a variety of different\n      interface identifiers, while keeping\
    \ care of existing\n      implementations.\n   o  Clarified wording in Section\
    \ 5.5.4 to make clear that a deprecated\n      address specified by an application\
    \ can be used for any\n      communication.\n   o  Clarified the prefix check\
    \ described in Section 5.5.3 using more\n      appropriate terms and that the\
    \ check is done against the prefixes\n      of addresses configured by stateless\
    \ autoconfiguration.\n   o  Changed the references to the IP security Authentication\
    \ Header to\n      references to RFC 3971 (Secure Neighbor Discovery).  Also revised\n\
    \      the Security Considerations section with a reference to RFC 3756.\n   o\
    \  Added a note when an implementation uses stable storage for\n      autoconfigured\
    \ addresses.\n   o  Added consideration about preference between inconsistent\n\
    \      information sets, one from a secured source and the other learned\n   \
    \   without protection.\n   Other miscellaneous clarifications:\n   o  Removed\
    \ references to site-local and revised wording around the\n      keyword.\n  \
    \ o  Removed redundant code in denial-of-service protection in\n      Section\
    \ 5.5.3.\n   o  Clarified that a unicasted Neighbor Solicitation or Advertisement\n\
    \      should be discarded while performing Duplicate Address Detection.\n   o\
    \  Noted in Section 5.3 that an interface can be considered as\n      becoming\
    \ enabled when a wireless access point changes.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Susan Thomson\n   Cisco Systems\n   EMail: sethomso@cisco.com\n\
    \   Thomas Narten\n   IBM Corporation\n   P.O. Box 12195\n   Research Triangle\
    \ Park, NC  27709-2195\n   USA\n   Phone: +1 919-254-7798\n   EMail: narten@us.ibm.com\n\
    \   Tatuya Jinmei\n   Corporate Research & Development Center, Toshiba Corporation\n\
    \   1 Komukai Toshiba-cho, Saiwai-ku\n   Kawasaki-shi, Kanagawa  212-8582\n  \
    \ Japan\n   Phone: +81 44-549-2230\n   EMail: jinmei@isl.rdc.toshiba.co.jp\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
