- title: __initial_text__
  contents:
  - "                 Internet Reliable Transaction Protocol\n                 Functional\
    \ and Interface Specification\n"
- title: STATUS OF THIS MEMO
  contents:
  - "STATUS OF THIS MEMO\n   This RFC is being distributed to members of the DARPA\
    \ research\n   community in order to solicit their reactions to the proposals\n\
    \   contained in it.  While the issues discussed may not be directly\n   relevant\
    \ to the research problems of the DARPA community, they may be\n   interesting\
    \ to a number of researchers and implementors.  This RFC\n   suggests a proposed\
    \ protocol for the ARPA-Internet community, and\n   requests discussion and suggestions\
    \ for improvements.  Distribution\n   of this memo is unlimited.\n"
- title: ABSTRACT
  contents:
  - "ABSTRACT\n   The Internet Reliable Transaction Protocol (IRTP) is a transport\n\
    \   level host to host protocol designed for an internet environment.  It\n  \
    \ provides reliable, sequenced delivery of packets of data between\n   hosts and\
    \ multiplexes/demultiplexes streams of packets from/to user\n   processes representing\
    \ ports.  It is simple to implement, with a\n   minimum of connection management,\
    \ at the possible expense of\n   efficiency.\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - 'Internet Reliable Transaction Protocol

    '
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n   INTRODUCTION\n      1.1   Purpose .........................................\
    \  1\n      1.2   Underlying Mechanisms ...........................  1\n     \
    \ 1.3   Relationship to Other Protocols .................  2\n   IRTP HEADERS\n\
    \      2.1   Header Format ...................................  3\n      2.2 \
    \  Packet Type .....................................  3\n      2.3   Port Number\
    \ .....................................  3\n      2.4   Sequence Number .................................\
    \  4\n      2.5   Length ..........................................  4\n     \
    \ 2.6   Checksum ........................................  4\n   INTERFACES\n\
    \      3.1   User Services Provided By IRTP ..................  5\n      3.2 \
    \  IP Services Expected by IRTP ....................  5\n   MODEL OF OPERATION\n\
    \      4.1   State Variables .................................  6\n      4.2 \
    \  IRTP Initialization .............................  7\n      4.3   Host-to-Host\
    \ Synchronization ....................  7\n      4.3.1   Response to SYNCH Packets\
    \ .....................  7\n      4.3.2   Response to SYNCH ACK Packet ..................\
    \  8\n      4.4   Transmitting Data ...............................  8\n     \
    \ 4.4.1   Receiving Data From Using Processes ...........  8\n      4.4.2   Packet\
    \ Retransmission ......................... 10\n      4.5   Receiving Data ..................................\
    \ 10\n      4.5.1   Receive and Acknowledgment Windows ............ 11\n     \
    \ 4.5.2   Invalid Packets ............................... 12\n      4.5.3   Sequence\
    \ Numbers Within Acknowledge Window .... 12\n      4.5.4   Sequence Numbers Within\
    \ the Receive Window .... 12\n      4.5.5   Forwarding Data to Using Processes\
    \ ............ 13\n   IMPLEMENTATION ISSUES\n      5.1   Retransmission Strategies\
    \ ....................... 14\n      5.2   Pinging .........................................\
    \ 14\n      5.3   Deleting Connection Tables ...................... 16\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n   LIST OF FIGURES\n      Figure 1-1\
    \    Relationship of IRTP to Other Protocols .  2\n      Figure 2-1    IRTP Header\
    \ Format ......................  3\n      Figure 4-1    SYNCH Packet Format .....................\
    \  8\n      Figure 4-2    SYNCH ACK Packet Format .................  8\n     \
    \ Figure 4-3    DATA Packet Format ......................  9\n      Figure 4-4\
    \    DATA ACK Packet Format .................. 11\n      Figure 4-5    PORT NAK\
    \ Packet Format .................. 11\n   ABBREVIATIONS\n      ICMP        Internet\
    \ Control Message Protocol\n      IP          Internet Protocol\n      IRTP  \
    \      Internet Reliable Transaction Protocol\n      RDP         Reliable Data\
    \ Protocol\n      TCP         Transmission Control Protocol\n      UDP       \
    \  User Datagram Protocol\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - 'Internet Reliable Transaction Protocol

    '
- title: CHAPTER 1 - INTRODUCTION
  contents:
  - "CHAPTER 1 - INTRODUCTION\n   The Internet Reliable Transaction Protocol (IRTP)\
    \ is a full duplex,\n   transaction oriented, host to host protocol which provides\
    \ reliable\n   sequenced delivery of packets of data, called transaction packets.\n\
    \   Note: throughout this document the terms host and internet address\n   are\
    \ used interchangeably.\n   1.1 Purpose\n      The IRTP was designed for an environment\
    \ in which one host will\n      have to maintain reliable communication with many\
    \ other hosts.  It\n      is assumed that there is a (relatively) sporadic flow\
    \ of\n      information with each destination host, however information flow\n\
    \      may be initiated at any time at either end of the connection.  The\n  \
    \    nature of the information is in the form of transactions, i.e.\n      small,\
    \ self contained messages.  There may be times at which one\n      host will want\
    \ to communicate essentially the same information to\n      all of its known destinations\
    \ as rapidly as possible.\n      In effect, the IRTP defines a constant underlying\
    \ connection\n      between two hosts. This connection is not established and\
    \ broken\n      down, rather it can be resynchronized with minimal loss of data\n\
    \      whenever one of the hosts has been rebooted.\n      Due to the lack of\
    \ connection management, it is desirable that all\n      IRTP processes keep static\
    \ information about all possible remote\n      hosts. However, the IRTP has been\
    \ designed such that minimal state\n      information needs to be associated with\
    \ each host to host pair,\n      thereby allowing one host to communicate with\
    \ many remote hosts.\n      The IRTP is more complex than UDP in that it provides\
    \ reliable,\n      sequenced delivery of packets, but it is less complex than\
    \ TCP in\n      that sequencing is done on a packet by packet (rather than\n \
    \     character stream) basis, and there is only one connection defined\n    \
    \  between any two internet addresses (that is, it is not a process\n      to\
    \ process protocol.)\n   1.2 Underlying Mechanisms\n      The IRTP uses retransmission\
    \ and acknowledgments to guarantee\n      delivery. Checksums are used to guarantee\
    \ data integrity and to\n      protect against misrouting.  There is a host to\
    \ host\n      synchronization mechanism and packet sequencing to provide\n   \
    \   duplicate detection and ordered delivery to the user process.  A\n      simple\
    \ mechanism allows IRTP to multiplex and demultiplex streams\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n      of transaction packets being exchanged\
    \ between multiple IRTP users\n      on this host and statically paired IRTP users\
    \ on the same remote\n      host.\n   1.3 Relationship to Other Protocols\n  \
    \    The IRTP is designed for use in a potentially lossy internet\n      environment.\
    \  It requires that IP be under it.  The IP protocol\n      number of IRTP is\
    \ 28.\n      Conversely, IRTP provides a reliable transport protocol for one or\n\
    \      more user processes.  User processes must have well-known IRTP\n      port\
    \ numbers, and can communicate only with matching processes\n      with the same\
    \ port number.  (Note that the term port refers to a\n      higher level protocol.\
    \  IRTP connections exists between two hosts,\n      not between a host/port and\
    \ another host/port.)\n      These relationships are depicted below.\n       \
    \  +--------+    +--------+   +-----------+\n         | port a |....| port x |\
    \   | TCP users |   Application Level\n         +--------+    +--------+   +-----------+\n\
    \               |          |            | ... |\n             +--------------+\
    \       +-----------+\n             |     IRTP     |       |    TCP    |   Host\
    \ Level\n             +--------------+       +-----------+\n                 \
    \   |                     |\n         +--------------------------------------+\n\
    \         |    Internet Protocol and ICMP        |   Internet Level\n        \
    \ +--------------------------------------+\n                          |\n    \
    \     +--------------------------------------+\n         |      Local Network\
    \ Protocol          |   Network Level\n         +--------------------------------------+\n\
    \         Figure 1-1.  Relationship of IRTP to Other Protocols\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - 'Internet Reliable Transaction Protocol

    '
- title: CHAPTER 2 - IRTP HEADERS
  contents:
  - "CHAPTER 2 - IRTP HEADERS\n   2.1 Header Format\n      Each IRTP packet is preceded\
    \ by an eight byte header depicted\n      below. The individual fields are described\
    \ in the following\n      sections.\n         0      7 8     15 16           \
    \  31\n         +--------+--------+--------+--------+\n         | packet |  port\
    \  |     sequence    |\n         |  type  | number |      number     |\n     \
    \    +--------+--------+--------+--------+\n         |      length     |    checksum\
    \     |\n         |                 |                 |\n         +-----------------+-----------------+\n\
    \         |                                   |\n         |       optional data\
    \ octets        |\n         + . . . . . . . . . . . . . . . . . |\n         Figure\
    \ 2-1.  IRTP Header Format\n   2.2 Packet Type\n      Five packet types are defined\
    \ by the IRTP. These are:\n      packet type   numeric code\n      SYNCH     \
    \         0\n      SYNCH ACK          1\n      DATA               2\n      DATA\
    \ ACK           3\n      PORT NAK           4\n      The use of individual packet\
    \ types is discussed in MODEL OF\n      OPERATION.\n   2.3 Port Number\n     \
    \ This field is used for the multiplexing and demultiplexing of\n      packets\
    \ from multiple user processes across a single IRTP\n      connection.  Processes\
    \ which desire to use IRTP must claim port\n      numbers.  A port number represents\
    \ a higher level protocol, and\n      data to/from this port may be exchanged\
    \ only with a process which\n      has claimed the same port number at a remote\
    \ host.  A process can\n      claim multiple port numbers, however, only one process\
    \ may claim\n      an individual port number.  All port numbers are well-known.\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n   2.4 Sequence Number\n      For each\
    \ communicating pair of hosts, there are two sequence\n      numbers defined,\
    \ which are the send sequence numbers for the two\n      ends.  Sequence numbers\
    \ are treated as unsigned 16 bit integers.\n      Each time a new transaction\
    \ packet is sent, the sender increases\n      the sequence number by one.  Initial\
    \ sequence numbers are\n      established when the connection is resynchronized\
    \ (see Section\n      4.3.)\n   2.5 Length\n      The length is the number of\
    \ octets in this transaction packet,\n      including the header and the data.\
    \  (This means that the minimum\n      value of the length is 8.)\n   2.6 Checksum\n\
    \      The checksum is the 16-bit one's complement of the one's\n      complement\
    \ sum of the IRTP header and the transaction packet data\n      (padded with an\
    \ octet of zero if necessary to make an even number\n      of octets.)\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - 'Internet Reliable Transaction Protocol

    '
- title: CHAPTER 3 - INTERFACES
  contents:
  - "CHAPTER 3 - INTERFACES\n   3.1 User Services Provided by IRTP\n      The exact\
    \ interface to the TRTP from the using processes is\n      implementation dependent,\
    \ however, IRTP should provide the\n      following services to the using processes.\n\
    \         o  user processes must be able to claim a port number\n         o  users\
    \ must be able to request that data be sent to a\n            particular port\
    \ at an internet address (the port must be one\n            which the user has\
    \ claimed)\n         o  users must be able to request transaction data from a\n\
    \            particular port at any (unspecified) remote internet address\n  \
    \          (the port must be one which the user has claimed)\n         o  if a\
    \ port is determined to be unreachable at a particular\n            destination,\
    \ the using process which has claimed that port\n            should be notified\n\
    \      In addition to these minimal data transfer services, a particular\n   \
    \   implementation may want to have a mechanism by which a\n      \"supervisory\"\
    \ (that is, port independent) module can define\n      dynamically the remote\
    \ internet addresses which are legal targets\n      for host to host communication\
    \ by this IRTP module.  This\n      mechanism might be internal or external to\
    \ the IRTP module itself.\n   3.2 IP Services Expected by IRTP\n      IRTP expects\
    \ a standard interface to IP through which it can send\n      and receive transaction\
    \ packets as IP datagrams.  In addition, if\n      possible, it is desirable that\
    \ IP or ICMP notify IRTP in the event\n      that a remote internet address is\
    \ unreachable.\n      If the IP implementation (including ICMP) is able to notify\
    \ IRTP\n      of source quench conditions, individual IRTP implementations may\n\
    \      be able to perform some dynamic adjustment of transmission\n      characteristics.\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - 'Internet Reliable Transaction Protocol

    '
- title: CHAPTER 4 - MODEL OF OPERATION
  contents:
  - "CHAPTER 4 - MODEL OF OPERATION\n   The basic operation of IRTP is as follows.\
    \  The first time two hosts\n   communicate (or the first time after both have\
    \ simultaneously\n   failed,) synchronization is established using constant initial\n\
    \   sequence numbers (there is a sequence number for each direction of\n   transmission).\
    \  The TCP \"quiet time\" is used following reboots to\n   insure that this will\
    \ not cause inaccurate acknowledgment processing\n   by one side or the other.\n\
    \   Once synchronization has been achieved data may be passed in both\n   directions.\
    \  Each transaction packet has a 16 bit sequence number.\n   Sequence numbers\
    \ increase monotonically as new packets are generated.\n   The receipt of each\
    \ sequence number must be acknowledged, either\n   implicitly or explicitly. \
    \ At most 8 unacknowledged packets may be\n   outstanding in one direction.  This\
    \ number (called MAXPACK) is fixed\n   for all IRTP modules. Unacknowledged packets\
    \ must be periodically\n   retransmitted.  Sequence numbers are also used for\
    \ duplicate\n   detection by receiving IRTP modules.\n   If synchronization is\
    \ lost due to the failure of one of the\n   communicating hosts, after a reboot\
    \ that host requests the remote\n   host to communicate sequence number information,\
    \ and data transfer\n   continues.\n   4.1 State Variables\n      Each IRTP is\
    \ associated with a single internet address.  The\n      synchronization mechanism\
    \ of the IRTP depends on the requirement\n      that each IRTP module knows the\
    \ internet addresses of all modules\n      with which it will communicate.  For\
    \ each remote internet address,\n      an IRTP module must maintain the following\
    \ information (called the\n      connection table):\n      rem_addr     (32 bit\
    \ remote internet address)\n      conn_state   (8  bit connection state)\n   \
    \   snd_nxt      (16 bit send sequence number)\n      rcv_nxt      (16 bit expected\
    \ next receive sequence number)\n      snd_una      (16 bit first unacknowledged\
    \ sequence number)\n      In addition to maintaining the connection tables defined\
    \ above, it\n      is required that every IRTP module have some mechanism which\n\
    \      generates \"retransmission events\" such that SYNCH packets are\n     \
    \ periodically retransmitted for any connection in synch_wait state\n      (see\
    \ Section 4.3), and the appropriate DATA packet is periodically\n      retransmitted\
    \ for any connection in data_transfer state (see\n      Section 4.4.2).  It is\
    \ implementation dependent whether this\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n      mechanism is connection dependent,\
    \ or a uniform mechanism for all\n      connections, so it has not been made part\
    \ of the connection state\n      table.  See Chapter 5 for more discussion.\n\
    \   4.2 IRTP Initialization\n      Whenever a remote internet address becomes\
    \ known by an IRTP\n      process, a 2 minute \"quiet time\" as described in the\
    \ TCP\n      specification must be observed before accepting any incoming\n  \
    \    packets or user requests.  This is to insure that no old IRTP\n      packets\
    \ are still in the network.  In addition, a connection table\n      is initialized\
    \ as follows:\n      rem_addr     =    known internet address\n      conn_state\
    \   =    0 = out-of-synch\n      snd_nxt      =    0\n      rcv_nxt      =   \
    \ 0\n      snd_una      =    0\n      Strictly speaking, the IRTP specification\
    \ does not allow\n      connection tables to be dynamically deleted and recreated,\n\
    \      however, if this happens the above procedure must be repeated.\n      See\
    \ Chapter 5 for more discussion.\n   4.3 Host-to-Host Synchronization\n      An\
    \ IRTP module must initiate synchronization whenever it receives\n      a DATA\
    \ packet or a user request referencing an internet address\n      whose connection\
    \ state is out-of-synch.  Typically, this will\n      happen only the first time\
    \ that internet address is active\n      following the reinitialization of the\
    \ IRTP module. A SYNCH packet\n      as shown below is transmitted.  Having sent\
    \ this packet, the host\n      enters connection state synch_wait (conn_state\
    \ = 1).  In this\n      state, any incoming DATA, DATA ACK or PORT NAK packets\
    \ are\n      ignored.  The SYNCH packet itself must be retransmitted\n      periodically\
    \ until synchronization has been achieved.\n      4.3.1 Response to SYNCH Packets\
    \ -\n         Whenever a SYNCH packet is received, the recipient, regardless\n\
    \         of current connection state, is required to to return a SYNCH\n    \
    \     ACK packet as shown below.  At this point the recipient enters\n       \
    \  data_transfer state (conn_state = 2).\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n      4.3.2 Response to SYNCH ACK Packet\
    \ -\n         On receipt of a SYNCH ACK packet, the behavior of the recipient\n\
    \         depends on its state.  If the recipient is in synch_wait state\n   \
    \      the recipient sets rcv_nxt to the sequence number value, sets\n       \
    \  snd_nxt and snd_una to the value in the two-octet data field,\n         and\
    \ enters data_transfer state (conn_state = 2).  Otherwise,\n         the packet\
    \ is ignored.\n            0      7 8     15 16             31\n            +--------+--------+--------+--------+\n\
    \            |00000000|00000000|00000000 00000000|\n            +--------+--------+--------+--------+\n\
    \            |        8        |    checksum     |\n            +-----------------+-----------------+\n\
    \            Figure 4-1.  SYNCH Packet Format\n            0      7 8     15 16\
    \             31\n            +--------+--------+--------+--------+\n        \
    \    |00000001| unused |     snd_una     |\n            +--------+--------+--------+--------+\n\
    \            |        10       |    checksum     |\n            +-----------------+-----------------+\n\
    \            |      rcv_nxt    |\n            +-----------------+\n          \
    \  Figure 4-2.  SYNCH ACK Packet Format\n   4.4 Transmitting Data\n      Once\
    \ in data_transfer state DATA, DATA ACK and PORT NAK packets\n      are used to\
    \ achieve communication between IRTP processes, subject\n      to the constraint\
    \ that no more than MAXPACK unacknowledged packets\n      may be transmitted on\
    \ a connection at any time.  Note that all\n      arithmetic operations and comparisons\
    \ on sequence numbers\n      described in this chapter are to be done modulo 2\
    \ to the 16.\n      4.4.1 Receiving Data From Using Processes -\n         User\
    \ processes may request IRTP to send packets of at most 512\n         user data\
    \ octets to a remote internet address and IRTP port.\n         When such a request\
    \ is received, the behavior of the IRTP\n         depends on the state of the\
    \ connection with the remote host and\n         on implementation dependent considerations.\
    \  If the connection\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n         between this IRTP module and\
    \ the remote host is not in\n         data_transfer state, that state must be\
    \ achieved (see Section\n         4.3) before acting on the user request.\n  \
    \       Once the connection is in data_transfer state, the behavior of\n     \
    \    the IRTP module in reaction to a write request from a user is\n         implementation\
    \ dependent.  The simplest IRTP implementations\n         will not accept write\
    \ requests when MAXPACK unacknowledged\n         packets have been sent to the\
    \ remote connection and will\n         provide interested users a mechanism by\
    \ which they can be\n         notified when the connection is no longer in this\
    \ state, which\n         is called flow controlled.  Such implementations are\
    \ called\n         blocking IRTP implementations.  These implementations check,\
    \ on\n         receipt of a write request, to see if the value of snd_nxt is\n\
    \         less than snd_una+MAXPACK.  If it is, IRTP prepends a DATA\n       \
    \  packet header as shown below, and transmits the packet.  The\n         value\
    \ of snd_nxt is then incremented by one.  In addition, the\n         packet must\
    \ be retained in a retransmission queue until it is\n         acknowledged.\n\
    \            0       7 8     15 16             31\n            +--------+--------+--------+--------+\n\
    \            |00000010|port num|     snd_nxt     |\n            +--------+--------+--------+--------+\n\
    \            |     length      |    checksum     |\n            +-----------------+-----------------+\n\
    \            |           data octet(s)           |\n            + . . . . . .\
    \ . . . . . . . . . . . +\n            Figure 4-3.  DATA Packet Format\n     \
    \    Other implementations may allow (some number of) write requests\n       \
    \  to be accepted even when the connection is flow controlled.\n         These\
    \ implementations, called non-blocking IRTP\n         implementations, must maintain,\
    \ in addition to the\n         retransmission queue for each connection, a queue\
    \ of accepted\n         but not yet transmitted packets, in order of request.\
    \  This is\n         called the pretransmission queue for the connection.\n  \
    \       When a non-blocking implementation receives a write request, if\n    \
    \     the connection is not flow controlled, it behaves exactly as a\n       \
    \  blocking IRTP.  Otherwise, it prepends a DATA packet header\n         without\
    \ a sequence number to the data, and appends the packet\n         to the pretransmission\
    \ queue.  Note that in this case, snd_nxt\n         is not incremented.  The value\
    \ of snd_nxt is incremented only\n         when a packet is transmitted for the\
    \ first time.\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n      4.4.2 Packet Retransmission -\n\
    \         The IRTP protocol requires that the transaction packet with\n      \
    \   sequence number snd_una be periodically retransmitted as long\n         as\
    \ there are any unacknowledged, but previously transmitted,\n         packets\
    \ (that is, as long as the value of snd_una is not equal\n         to that of\
    \ snd_nxt.)\n         The value of snd_una increases over time due to the receipt\
    \ of\n         DATA ACK or PORT NAK packets from a remote host (see Sections\n\
    \         4.5.3 and 4.5.4 below).  When either of these packet types is\n    \
    \     received, if the incoming sequence number in that packet is\n         greater\
    \ than the current value of snd_una, the value of snd_una\n         is set to\
    \ the incoming sequence number in that packet.  Any\n         DATA packets with\
    \ sequence number less than the new snd_una\n         which were queued for retransmission\
    \ are released.\n         (If this is a non-blocking IRTP implementation, for\
    \ each DATA\n         packet which is thus released from the retransmission queue,\n\
    \         the earliest buffered packet may be transmitted from the\n         pretransmission\
    \ queue, as long as the pretransmission queue is\n         non-empty.  Prior to\
    \ transmitting the packet, the current value\n         of snd_nxt is put in the\
    \ sequence number field of the header.\n         The value of snd_nxt is then\
    \ incremented by one.)\n         Finally, if the acknowledgment is a PORT NAK,\
    \ the user process\n         with the nacked port number should be notified that\
    \ the remote\n         port is not there.\n         It is also to be desired,\
    \ though it is not required, that IRTP\n         modules have some mechanism to\
    \ decide that a remote host is not\n         responding in order to notify user\
    \ processes that this host is\n         apparently unreachable.\n   4.5 Receiving\
    \ Data\n      When an IRTP module in data_transfer state receives a DATA packet,\n\
    \      its behavior depends on the port number, sequence number and\n      implementation\
    \ dependent space considerations.\n      DATA ACK and PORT NAK packets are used\
    \ to acknowledge the receipt\n      of DATA packets.  Both of these acknowledgment\
    \ packets acknowledge\n      the receipt of all sequence numbers up to, but not\
    \ including, the\n      sequence number in their headers.  Note that this value\
    \ is denoted\n      \"rcv_nxt\" in the figures below.  This number is the value\
    \ of\n      rcv_nxt at the source of the acknowledgment packet when the\n    \
    \  acknowledgment was generated.\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n         0      7 8     15 16       \
    \      31\n         +--------+--------+--------+--------+\n         |00000011|port\
    \ num|     rcv_nxt     |\n         +--------+--------+--------+--------+\n   \
    \      |        8        |    checksum     |\n         +-----------------+-----------------+\n\
    \         Figure 4-4.  DATA ACK Packet Format\n         0      7 8     15 16 \
    \            31\n         +--------+--------+--------+--------+\n         |00000100|port\
    \ num|     rcv_nxt     |\n         +--------+--------+--------+--------+\n   \
    \      |        8        |    checksum     |\n         +-----------------+-----------------+\n\
    \         Figure 4-5.  PORT NAK Packet Format\n      It is not required that a\
    \ receiving IRTP implementation return an\n      acknowledgment packet for every\
    \ incoming DATA packet, nor is it\n      required that the acknowledged sequence\
    \ number be that in the most\n      recently received packet.  The exact circumstances\
    \ under which\n      DATA ACK and PORT NAK packets are sent are detailed below.\
    \  The\n      net effect is that every sequence number is acknowledged, a sender\n\
    \      can force reacknowledgment if an ACK is lost, all acknowledgments\n   \
    \   are cumulative, and no out of order acknowledgments are permitted.\n     \
    \ 4.5.1 Receive and Acknowledgment Windows -\n         Each IRTP module has two\
    \ windows associated with the receive\n         side of a connection.  For convenience\
    \ in the following\n         discussion these are given names.  The sequence number\
    \ window\n         rcv_nxt-MAXPACK =< sequence number < rcv_nxt\n         is called\
    \ the acknowledge window.  All sequence numbers within\n         this window represent\
    \ packets which have previously been acked\n         or nacked, however, the ack\
    \ or nack may have been lost in the\n         network.\n         The sequence\
    \ number window\n         rcv_nxt =< sequence number < rcv_nxt+MYRCV =< rcv_nxt+MAXPACK\n\
    \         is called the receive window.  All sequence numbers within this\n  \
    \       window represent legal packets which may be in transit,\n         assuming\
    \ that the remote host has received acks for all packets\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n         in the acknowledge window. \
    \ The value of MYRCV depends on the\n         implementation of the IRTP.  In\
    \ the simplest case this number\n         will be one, effectively meaning that\
    \ the IRTP will ignore any\n         incoming packets not in the acknowledge window\
    \ or not equal to\n         rcv_nxt.  If the IRTP has enough memory to buffer\
    \ some incoming\n         out-of-order packets, MYRCV can be set to some number\
    \ =<\n         MAXPACK and a more complex algorithm can be used to compute\n \
    \        rcv_nxt, thereby achieving potentially greater efficiency.\n        \
    \ Note that in the latter case, these packets are not\n         acknowledged until\
    \ their sequence number is less than rcv_nxt,\n         thereby insuring that\
    \ acknowledgments are always cumulative.\n         (See 4.5.4 below.)\n      4.5.2\
    \ Invalid Packets -\n         When an IRTP receives a DATA packet, it first checks\
    \ the\n         sequence number in the received packet.  If the sequence number\n\
    \         is not within the acknowledge or receive window, the packet is\n   \
    \      discarded.  Similarly, if the computed checksum does not match\n      \
    \   that in the header, the packet is discarded.  No further action\n        \
    \ is taken.\n      4.5.3 Sequence Numbers Within Acknowledge Window -\n      \
    \   When an IRTP receives an incoming DATA packet whose sequence\n         number\
    \ is within the acknowledge window, if the port specified\n         in the incoming\
    \ DATA packet is known to this IRTP, a DATA ACK\n         packet is returned.\
    \  Otherwise, a PORT NAK is returned.\n         In both cases, the value put in\
    \ the sequence number field of\n         the acknowlegement packet is the current\
    \ value of rcv_nxt at\n         the IRTP module which is acknowledging the DATA\
    \ packet.  The\n         DATA packet itself is discarded.\n         (Note that\
    \ the PORT NAK acknowledges reception of all packet\n         numbers up to rcv_nxt.\
    \  It NAKs the port number, not the\n         sequence number.)\n      4.5.4 Sequence\
    \ Numbers Within the Receive Window -\n         If the received sequence number\
    \ is within the receive window,\n         rcv_nxt is recomputed.  How this is\
    \ done is implementation\n         dependent.  If MYRCV is one, then rcv_nxt is\
    \ simply\n         incremented.  Otherwise, rcv_nxt is set to the lowest sequence\n\
    \         number such that all data packets with sequence numbers less\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n         than this number have been received\
    \ and are buffered at the\n         receiving IRTP, or have been delivered to\
    \ their destination\n         port.\n         Once rcv_nxt has been recomputed,\
    \ a DATA ACK or PORT NAK is\n         returned, depending on whether the port\
    \ number is known or not\n         known.  The value placed in the sequence number\
    \ field is the\n         newly computed value for rcv_nxt.\n      4.5.5 Forwarding\
    \ Data to Using Processes -\n         Whenever an incoming DATA packet has been\
    \ acknowledged (either\n         implicitly or explicitly) its header can be stripped\
    \ off and it\n         can be queued for delivery to the user process which has\n\
    \         claimed its port number.  If the IRTP implementation allows\n      \
    \   MYRCV to be greater than one, care must be taken that data\n         which\
    \ was originally received out of order is forwarded to its\n         intended\
    \ recipient in order of original sequence number.\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - 'Internet Reliable Transaction Protocol

    '
- title: CHAPTER 5 - IMPLEMENTATION ISSUES
  contents:
  - "CHAPTER 5 - IMPLEMENTATION ISSUES\n   The preceding chapter was left intentionally\
    \ vague in certain ways.\n   In particular, no explicit description of the use\
    \ of a timer or\n   timers within an IRTP module was given, nor was there a description\n\
    \   of how timer events should relate to \"retransmission events\".  This\n  \
    \ was done to separate the syntactic and operational requirements of\n   the protocol\
    \ from the performance characteristics of its\n   implementation.\n   It is believed\
    \ that the protocol is robust.  That is, any\n   implementation which strictly\
    \ conforms to Chapter 4 should provide\n   reliable synchronization of two hosts\
    \ and reliable sequenced transfer\n   of transaction data between them.  However,\
    \ different ways of\n   defining the notion of a retransmission event can have\
    \ potentially\n   significant impact on the performance of the protocol in terms\
    \ of\n   throughput and in terms of the load it places on the network.  It is\n\
    \   up to the implementor to take into account overall requirements of\n   the\
    \ network environment and the intended use of the protocol, if\n   possible, to\
    \ optimize overall characteristics of the implementation.\n   Several such issues\
    \ will be discussed in this chapter.\n   5.1 Retransmission Strategies\n     \
    \ The IRTP requires that a timer mechanism exists to somehow trigger\n      retransmissions\
    \ and requires that the packet with sequence number\n      snd_una be the one\
    \ retransmitted.  It is not required that\n      retransmission be performed on\
    \ every timer event, though this is\n      one \"retransmission strategy\".  A\
    \ possible alternative strategy is\n      to perform a retransmission on a timer\
    \ event only if no ACKs have\n      been received since the last event.\n    \
    \  Additionally, the interval of the timer can affect the performance\n      of\
    \ the strategies, as can the value of MYRCV and the lossiness of\n      the network\
    \ environment.\n      It is not within the scope of this document to recommend\
    \ a\n      retransmission strategy, only to point out that different\n      strategies\
    \ have different consequences.  It might be desirable to\n      allow using processes\
    \ to \"specify\" a strategy when a port is\n      claimed in order to tailor the\
    \ service of the protocol to the\n      needs of a particular application.\n \
    \  5.2 Pinging\n      It is important to make explicit that IRTP modules ping\
    \ by\n      definition.  That is, as long as a remote internet address is\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n      known, and is in use (that is,\
    \ either synchronization or data\n      transfer is being attempted), the protocol\
    \ requires \"periodic\n      retransmission\" of packets.  Note that this is true\
    \ even if the\n      IRTP module has determined that the remote address is currently\n\
    \      unreachable.\n      It is suggested that this situation can be made more\
    \ sensible by\n      adding two fields to the connection table.  These are:\n\
    \      num_retries  (number of times current packet has been sent)\n      time_out\
    \     (current retransmission timeout)\n      These fields are to be used as follows.\
    \  It is assumed that there\n      is some default initial value for time_out\
    \ called DEFTIME, some\n      (relatively long) value for time_out called PINGTIME\
    \ and some\n      value MAX_TRIES.  The exact values of these constants are\n\
    \      implementation dependent.  The value of DEFTIME may also be\n      retransmission\
    \ strategy dependent.\n      At the time that a connection table is initialized,\
    \ num_retries is\n      set to zero, and time_out is set to DEFTIME.  Whenever\
    \ a\n      retransmission event occurs (this will either be a retransmission\n\
    \      of a SYNCH packet or of the packet with sequence number snd_una),\n   \
    \   num_retries is incremented by one unless it is equal to MAX_TRIES.\n     \
    \ If a destination is determined to be unreachable, either via an\n      ICMP\
    \ message or a Destination Host Dead message, num_retries is\n      set to MAX_TRIES.\
    \  Whenever num_retries transitions to MAX_TRIES,\n      either by being incremented\
    \ or as above, the destination is is\n      presumed unreachable and user processes\
    \ are notified. At this\n      point, time_out is set to PINGTIME, the state of\
    \ the connection\n      does not change and retransmissions occur at PINGTIME\
    \ intervals\n      until the destination becomes reachable.\n      Conversely,\
    \ whenever a SYNCH_ACK is received (in synch_wait\n      state), or an (implicit\
    \ or explicit) acknowledgment of sequence\n      number snd_una is received (in\
    \ data transfer state), time_out is\n      set to DEFTIME and num_retries is reset\
    \ to zero.  If time_out was\n      already set to PINGTIME, user processes are\
    \ notified that the\n      destination is now reachable.\n      The effect of\
    \ this system is obvious.  The implementation still\n      pings as required,\
    \ but at presumably very infrequent intervals.\n      Alternative solutions, which\
    \ might place the decision to ping on\n      using processes, are considered undesirable\
    \ because\n         o  IRTP itself becomes more complicated in terms of states\
    \ of\n            the connection table\n"
- title: RFC 938                                                    February 1985
  contents:
  - 'RFC 938                                                    February 1985

    '
- title: Internet Reliable Transaction Protocol
  contents:
  - "Internet Reliable Transaction Protocol\n         o  the user interface becomes\
    \ both more complicated and more\n            rigid\n         o  such solutions\
    \ might be deadlock prone in some instances\n         o  it seems appropriate\
    \ that the host to host protocol should\n            be the place to determine\
    \ destination reachability, if the\n            overall application requires that\
    \ such information be known\n            (as it does in the environments intended\
    \ for IRTP.)\n   5.3 Deleting Connection Tables\n      The protocol as defined\
    \ does not allow connection tables to be\n      deleted (or for a connection state\
    \ to transition to out_of_synch\n      from any other state).  It might be appropriate\
    \ to delete a\n      connection table if it is known that the destination internet\n\
    \      address is no longer one which this host wants to communicate\n      with.\
    \  (The only danger there is that if the destination does not\n      know this,\
    \ it could ping this host forever.)  It is dangerous to\n      delete a connection\
    \ table or to go into out_of_synch state to\n      avoid pinging when a destination\
    \ does not appear to be there.  Two\n      hosts with the same such strategy could\
    \ potentially deadlock and\n      fail to resynchronize.\n"
- title: AUTHOR'S ADDRESS
  contents:
  - "AUTHOR'S ADDRESS\n   Trudy Miller\n   Advanced Computer Communications\n   720\
    \ Santa Barbara Street\n   Santa Barbara, CA  93101\n   (805) 963-9431\n"
