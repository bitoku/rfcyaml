- title: __initial_text__
  contents:
  - '  Service Discovery Usage for REsource LOcation And Discovery (RELOAD)

    '
- title: Abstract
  contents:
  - "Abstract\n   REsource LOcation And Discovery (RELOAD) does not define a generic\n\
    \   service discovery mechanism as a part of the base protocol (RFC\n   6940).\
    \  This document defines how the Recursive Distributed\n   Rendezvous (ReDiR)\
    \ service discovery mechanism can be applied to\n   RELOAD overlays to provide\
    \ a generic service discovery mechanism.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7374.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................4\n  \
    \ 3. Introduction to ReDiR ...........................................5\n   4.\
    \ Using ReDiR in a RELOAD Overlay Instance ........................8\n      4.1.\
    \ Data Structure .............................................8\n      4.2. Selecting\
    \ the Starting Level ...............................9\n      4.3. Service Provider\
    \ Registration ..............................9\n      4.4. Refreshing Registrations\
    \ ..................................10\n      4.5. Service Lookups ...........................................11\n\
    \      4.6. Removing Registrations ....................................13\n  \
    \ 5. Access Control Rules ...........................................13\n   6.\
    \ REDIR Kind Definition ..........................................13\n   7. Examples\
    \ .......................................................14\n      7.1. Service\
    \ Registration ......................................14\n      7.2. Service Lookup\
    \ ............................................16\n   8. Overlay Configuration\
    \ Document Extension .......................16\n   9. Security Considerations\
    \ ........................................17\n   10. IANA Considerations ...........................................17\n\
    \      10.1. Access Control Policies ..................................17\n  \
    \    10.2. A New IETF XML Registry ..................................17\n    \
    \  10.3. Data Kind-ID .............................................18\n      10.4.\
    \ RELOAD Services Registry .................................18\n   11. References\
    \ ....................................................19\n      11.1. Normative\
    \ References .....................................19\n      11.2. Informative\
    \ Reference ....................................19\n   Acknowledgments ...................................................19\n\
    \   Authors' Addresses ................................................20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   REsource LOcation And Discovery (RELOAD) [RFC6940] is a\
    \ peer-to-peer\n   signaling protocol that can be used to maintain an overlay\
    \ network\n   and to store data in and retrieve data from the overlay.  Although\n\
    \   RELOAD defines a service discovery mechanism specific to Traversal\n   Using\
    \ Relays around Network Address Translation (TURN), it does not\n   define a generic\
    \ service discovery mechanism as a part of the base\n   protocol.  This document\
    \ defines how the Recursive Distributed\n   Rendezvous (ReDiR) service discovery\
    \ mechanism specified in [Redir]\n   can be applied to RELOAD overlays.\n   In\
    \ a peer-to-peer (P2P) overlay network such as a RELOAD Overlay\n   Instance,\
    \ the peers forming the overlay share their resources in\n   order to provide\
    \ the service the system has been designed to provide.\n   The peers in the overlay\
    \ both provide services to other peers and\n   request services from other peers.\
    \  Examples of possible services\n   peers in a RELOAD Overlay Instance can offer\
    \ to each other include a\n   TURN relay service, a voice mail service, a gateway\
    \ location service,\n   and a transcoding service.  Typically, only a small subset\
    \ of the\n   peers participating in the system are providers of a given service.\n\
    \   A peer that wishes to use a particular service faces the problem of\n   finding\
    \ peers that are providing that service from the Overlay\n   Instance.\n   A naive\
    \ way to perform service discovery is to store the Node-IDs of\n   all nodes providing\
    \ a particular service under a well-known key k.\n   The limitation of this approach\
    \ is that it scales linearly with the\n   number of nodes that provide the service.\
    \  The problem is two-fold:\n   the node n that is responsible for service s identified\
    \ by key k may\n   end up storing a large number of Node-IDs and, most importantly,\
    \ may\n   also become overloaded since all service lookup requests for service\n\
    \   s will need to be answered by node n.  An efficient service discovery\n  \
    \ mechanism does not overload the nodes storing pointers to service\n   providers.\
    \  In addition, the mechanism must ensure that the load\n   associated with providing\
    \ a given service is distributed evenly among\n   the nodes providing the service.\n\
    \   It should be noted that a simple service discovery mechanism such as\n   the\
    \ one mentioned in the previous paragraph might be an appropriate\n   solution\
    \ in a very small overlay network consisting of perhaps tens\n   of nodes.  The\
    \ ReDiR-based service discovery mechanism described in\n   this document is suitable\
    \ for use even in overlay networks where the\n   number of end users that may\
    \ make service discovery requests can be\n   very high (e.g., tens of thousands\
    \ of nodes or even higher) and where\n   a large fraction of the peers (e.g.,\
    \ on the order of one out of ten\n   or more) can offer the service.\n   ReDiR\
    \ implements service discovery by building a tree structure of\n   the service\
    \ providers that provide a particular service.  The tree\n   structure is stored\
    \ into the RELOAD Overlay Instance using RELOAD\n   Store and Fetch requests.\
    \  Each service provided in the Overlay\n   Instance has its own tree.  The nodes\
    \ in a ReDiR tree contain\n   pointers to service providers.  During service discovery,\
    \ a peer\n   wishing to use a given service fetches ReDiR tree nodes one-by-one\n\
    \   from the RELOAD Overlay Instance until it finds a service provider\n   responsible\
    \ for its Node-ID.  It has been proved that ReDiR can find\n   a service provider\
    \ using only a constant number of Fetch operations\n   [Redir].\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [RFC2119].\n   DHT:  Distributed Hash Tables (DHTs) are a class of decentralized\n\
    \      distributed systems that provide a lookup service similar to a\n      regular\
    \ hash table.  Given a key, any peer participating in the\n      system can retrieve\
    \ the value associated with that key.  The\n      responsibility for maintaining\
    \ the mapping from keys to values is\n      distributed among the peers.\n   H(x):\
    \  Refers to a hash function (e.g., SHA-1 [RFC3174]) calculated\n      over the\
    \ value x.\n   H(x,y,z):  Refers to a hash function calculated over a concatenated\n\
    \      string consisting of x, y, and z, where x, y, and z can be both\n     \
    \ strings and integers.  The network byte order is used.\n   I(lvl,k):  An interval\
    \ at level lvl in the ReDiR tree that encloses\n      key k.  As an example, I(5,10)\
    \ refers to an interval at level 5 in\n      the ReDiR tree within whose range\
    \ key 10 falls.\n   n.id:  Refers to the RELOAD Node-ID of node n.\n   Namespace:\
    \  An arbitrary identifier that identifies a service\n      provided in the RELOAD\
    \ Overlay Instance.  Examples of potential\n      namespaces include 'voice-mail'\
    \ and 'turn-server'.  The namespace\n      is a UTF-8-encoded [RFC3629] text string.\n\
    \   numBitsInNodeId:  Refers to the number of bits in a RELOAD Node-ID.\n    \
    \  This value is used in the equations for calculating the ranges of\n      intervals\
    \ that ReDiR tree nodes are responsible for.\n   ReDiR tree:  A tree structure\
    \ of the nodes that provide a particular\n      service.  The nodes embed the\
    \ ReDiR tree into the RELOAD Overlay\n      Instance using RELOAD Store and Fetch\
    \ requests.  Each tree node in\n      the ReDiR tree belongs to some level in\
    \ the tree.  The root node\n      of the ReDiR tree is located at level 0 of the\
    \ ReDiR tree.  The\n      child nodes of the root node are located at level 1.\
    \  The children\n      of the tree nodes at level 1 are located at level 2, and\
    \ so forth.\n      The ReDiR tree has a branching factor b.  At every level lvl\
    \ in\n      the ReDiR tree, there is room for a maximum of b^lvl tree nodes.\n\
    \      Each tree node in the ReDiR tree is uniquely identified by a pair\n   \
    \   (lvl,j), where lvl is a level in the ReDiR tree and j is the\n      position\
    \ of the tree node (from the left) at that level.\n   Successor:  The successor\
    \ of identifier k in namespace ns is the node\n      belonging to the namespace\
    \ ns whose identifier most immediately\n      follows the identifier k.\n"
- title: 3.  Introduction to ReDiR
  contents:
  - "3.  Introduction to ReDiR\n   Recursive Distributed Rendezvous (ReDiR) [Redir]\
    \ does not require new\n   functionality from the RELOAD base protocol [RFC6940].\
    \  This is\n   possible since ReDiR interacts with the RELOAD Overlay Instance\
    \ by\n   simply storing and fetching data, that is, using RELOAD Store and\n \
    \  Fetch requests.  ReDiR creates a tree structure of the service\n   providers\
    \ of a particular service and stores it into the RELOAD\n   Overlay Instance using\
    \ the Store and Fetch requests.  ReDiR service\n   lookups require a logarithmic\
    \ number of Fetch operations.  Further,\n   if information from past service lookups\
    \ is used to determine the\n   optimal level in the ReDiR tree from which to start\
    \ new service\n   lookups, an average service lookup can typically finish after\
    \ a\n   constant number of Fetch operations, assuming that Node-IDs are\n   distributed\
    \ uniformly at random.\n   In ReDiR, each service provided in the overlay is identified\
    \ by an\n   identifier, called the namespace.  All service providers of a given\n\
    \   service store their information under the namespace of that service.\n   Peers\
    \ wishing to use a service perform lookups within the namespace\n   of the service.\
    \  The result of a ReDiR lookup for an identifier k in\n   namespace ns is a RedirServiceProvider\
    \ structure (see Section 4.1) of\n   a service provider that belongs to ns and\
    \ whose Node-ID is the\n   closest successor of identifier k in the namespace.\n\
    \   Each tree node in the ReDiR tree contains a dictionary of\n   RedirServiceProvider\
    \ entries of peers providing a particular service.\n   Each tree node in the ReDiR\
    \ tree also belongs to some level in the\n   tree.  The root node of the ReDiR\
    \ tree is located at level 0.  The\n   child nodes of the root node are located\
    \ at level 1 of the ReDiR\n   tree.  The children of the tree nodes at level 1\
    \ are located at\n   level 2, and so forth.  The ReDiR tree has a branching factor,\
    \ whose\n   value is determined by a new element in the RELOAD overlay\n   configuration\
    \ document, called branching-factor.  The RELOAD overlay\n   configuration document\
    \ is defined in the RELOAD base protocol\n   [RFC6940].  At every level lvl in\
    \ the ReDiR tree, there is room for a\n   maximum of branching-factor^lvl tree\
    \ nodes.  As an example, in a tree\n   whose branching-factor is 2, the second\
    \ level can contain up to four\n   tree nodes (note that a given level may contain\
    \ less than the maximum\n   number of tree nodes since empty tree nodes are not\
    \ stored).  Each\n   tree node in the ReDiR tree is uniquely identified by a pair\
    \ (lvl,j),\n   where lvl is a level in the ReDiR tree and j is the position of\
    \ the\n   tree node (from the left) at that level.  As an example, the pair\n\
    \   (2,3) identifies the third tree node from the left at level 2.\n   The ReDiR\
    \ tree is stored into the RELOAD Overlay Instance tree node\n   by tree node,\
    \ by storing the values of tree node (level,j) under a\n   key created by taking\
    \ a hash over the concatenation of the namespace,\n   level, and j, that is, as\
    \ H(namespace,level,j).  As an example, the\n   root of the tree for a voice mail\
    \ service is stored at H(\"voice-\n   mail\",0,0).  Each node (level,j) in the\
    \ ReDiR tree contains b\n   intervals of the DHT's identifier space as follows:\n\
    \           [2^numBitsInNodeId*b^(-level)*(j+(b'/b)),\n            2^numBitsInNodeId*b^(-level)*(j+((b'+1)/b))),\
    \ for 0<=b'<b,\n   where b is the branching-factor and b' refers to the number\
    \ of an\n   interval within the ReDiR tree node j.\n   Figure 1 shows an example\
    \ of a ReDiR tree whose branching factor\n   is 2.  In the figure, the size of\
    \ the identifier space of the overlay\n   is 16.  Each tree node in the ReDiR\
    \ tree is shown as two horizontal\n   lines separated by a vertical bar ('|')\
    \ in the middle.  The\n   horizontal lines represent the two intervals each node\
    \ is responsible\n   for.  At level 0, there is only one node, (0,0), responsible\
    \ for two\n   intervals that together cover the entire identifier space of the\n\
    \   RELOAD Overlay Instance.  At level 1, there are two nodes, (1,0) and\n   (1,1),\
    \ each of which is responsible for half of the identifier space\n   of the RELOAD\
    \ Overlay Instance.  At level 2, there are four nodes.\n   Each of them owns one\
    \ fourth of the identifier space.  At level 3,\n   there are eight nodes, each\
    \ of which is responsible for one eighth of\n   the identifier space.\n     Level\
    \ 0  __________________|__________________\n                      |          \
    \         |\n     Level 1  ________|________   ________|________\n           \
    \      |         |         |         |\n     Level 2  ___|___   ___|___   ___|___\
    \   ___|___\n               |   |     |   |     |   |     |   |\n     Level 3\
    \  _|_ _|_   _|_ _|_   _|_ _|_   _|_ _|_\n                           Figure 1:\
    \ ReDiR Tree\n   Figure 2 illustrates how tree nodes are numbered in the ReDiR\
    \ tree at\n   levels 0-2.\n     Level 0  ________________(0,0)________________\n\
    \                      |                   |\n     Level 1  ______(1,0)______\
    \   ______(1,1)______\n                 |         |         |         |\n    \
    \ Level 2  _(2,0)_   _(2,1)_   _(2,2)_   _(2,3)_\n               |   |     | \
    \  |     |   |     |   |\n     Level 3  _|_ _|_   _|_ _|_   _|_ _|_   _|_ _|_\n\
    \                        Figure 2: ReDiR Tree Nodes\n   Figure 3 illustrates how\
    \ intervals are assigned to tree nodes in the\n   ReDiR tree at levels 0 and 1.\
    \  As an example, the single tree node\n   (0,0) at level 0 is divided into two\
    \ intervals, each of which covers\n   half of the identifier space of the overlay.\
    \  These two intervals are\n   [0,7] and [8,15].\n     Level 0  ______[0,7]_______|_______[8,15]_____\n\
    \                      |                   |\n     Level 1  _[0,3]__|__[4,7]_\
    \   _[8,11]_|_[12,15]\n                 |         |         |         |\n    \
    \ Level 2  ___|___   ___|___   ___|___   ___|___\n               |   |     | \
    \  |     |   |     |   |\n     Level 3  _|_ _|_   _|_ _|_   _|_ _|_   _|_ _|_\n\
    \                     Figure 3: Intervals in ReDiR Tree\n   Note that all of the\
    \ examples above are simplified.  In a real ReDiR\n   tree, the default ReDiR\
    \ branching factor is 10, meaning that each\n   tree node is split into 10 intervals\
    \ and that each tree node has 10\n   children.  In such a tree, level 1 contains\
    \ 10 nodes and 100\n   intervals.  Level 2 contains 100 nodes and 1000 intervals,\
    \ level 3\n   1000 nodes and 10000 intervals, etc.  Further, the size of the\n\
    \   identifier space of a real RELOAD Overlay Instance is at the minimum\n   2^128.\n"
- title: 4.  Using ReDiR in a RELOAD Overlay Instance
  contents:
  - '4.  Using ReDiR in a RELOAD Overlay Instance

    '
- title: 4.1.  Data Structure
  contents:
  - "4.1.  Data Structure\n   ReDiR tree nodes are stored using the dictionary data\
    \ model defined\n   in the RELOAD base protocol [RFC6940].  The data stored is\
    \ a\n   RedirServiceProvider Resource Record:\n         enum { none(0), (255)\
    \ }\n           RedirServiceProviderExtType;\n         struct {\n           RedirServiceProviderExtType\
    \   type;\n           Destination                   destination_list<0..2^16-1>;\n\
    \           opaque                        namespace<0..2^16-1>;\n           uint16\
    \                        level;\n           uint16                        node;\n\
    \           uint16                        length;\n           select (type) {\n\
    \               /* This type may be extended */\n           } extension;\n   \
    \      } RedirServiceProvider;\n   The contents of the RedirServiceProvider Resource\
    \ Record are as\n   follows:\n   type\n      The type of an extension to the RedirServiceProvider\
    \ Resource\n      Record.  Unknown types are allowed.\n   destination_list\n \
    \     A list of IDs through which a message is to be routed to reach the\n   \
    \   service provider.  The destination list consists of a sequence of\n      Destination\
    \ values.  The contents of the Destination structure are\n      as defined in\
    \ the RELOAD base protocol [RFC6940].\n   namespace\n      An opaque UTF-8-encoded\
    \ string containing the namespace.\n   level\n      The level in the ReDiR tree.\n\
    \   node\n      The position of the node storing this RedirServiceProvider record\n\
    \      at the current level in the ReDiR tree.\n   length\n      The length of\
    \ the rest of the Resource Record.\n   extension\n      An extension value.  The\
    \ RedirServiceProvider Resource Record can\n      be extended to include, for\
    \ instance, information specific to the\n      service or service provider.\n"
- title: 4.2.  Selecting the Starting Level
  contents:
  - "4.2.  Selecting the Starting Level\n   Before registering as a service provider\
    \ or performing a service\n   lookup, a peer needs to determine the starting level\
    \ Lstart for the\n   registration or lookup operation in the ReDiR tree.  It is\n\
    \   RECOMMENDED that Lstart is set to 2.  This recommendation is based on\n  \
    \ the findings in [Redir], which indicate that this starting level\n   results\
    \ in good performance.  In subsequent registrations, Lstart\n   MAY, as an optimization,\
    \ be set to the lowest level at which a\n   registration operation has last completed.\n\
    \   In the case of subsequent service lookups, nodes MAY, as an\n   optimization,\
    \ record the levels at which the last 16 service lookups\n   completed and take\
    \ Lstart to be the mode of those depths (mode, in\n   statistics, is the value\
    \ that appears most often in a set of data).\n"
- title: 4.3.  Service Provider Registration
  contents:
  - "4.3.  Service Provider Registration\n   A node MUST use the following procedure\
    \ to register as a service\n   provider in the RELOAD Overlay Instance:\n   1.\
    \  A node n with Node-ID n.id wishing to register as a service\n       provider\
    \ starts from a starting level Lstart (see Section 4.2 for\n       the details\
    \ on selecting the starting level).  Therefore, node n\n       sets the current\
    \ level to level=Lstart.\n   2.  Node n MUST send a RELOAD Fetch request to fetch\
    \ the contents of\n       the tree node responsible for I(level,n.id).  An interval\
    \ I(l,k)\n       is the interval at level l in the ReDiR tree that includes key\
    \ k.\n       The fetch MUST be a wildcard fetch.\n   3.  Node n MUST send a RELOAD\
    \ Store request to add its\n       RedirServiceProvider entry to the dictionary\
    \ stored in the tree\n       node responsible for I(level,n.id).  Note that node\
    \ n always\n       stores its RedirServiceProvider entry, regardless of the contents\n\
    \       of the dictionary.\n   4.  If node n's Node-ID (n.id) is the lowest or\
    \ highest Node-ID\n       stored in the tree node responsible for I(Lstart,n.id),\
    \ node n\n       MUST reduce the current level by one (i.e., set level=level-1)\n\
    \       and continue up the ReDiR tree towards the root level (level 0),\n   \
    \    repeating steps 2 and 3 above.  Node n MUST continue in this way\n      \
    \ until it reaches either the root of the tree or a level at which\n       n.id\
    \ is not the lowest or highest Node-ID in the interval\n       I(level,n.id).\n\
    \   5.  Node n MUST also perform a downward walk in the ReDiR tree,\n       during\
    \ which it goes through the tree nodes responsible for\n       intervals I(Lstart,n.id),\
    \ I(Lstart+1,n.id), I(Lstart+2,n.id),\n       etc.  At each step, node n MUST\
    \ fetch the responsible tree node\n       and store its RedirServiceProvider record\
    \ in that tree node if\n       n.id is the lowest or highest Node-ID in its interval.\
    \  Node n\n       MUST end this downward walk as soon as it reaches a level l\
    \ at\n       which it is the only service provider in its interval I(l,n.id).\n\
    \   Note that above, when we refer to 'the tree node responsible for\n   I(l,k)',\
    \ we mean the entire tree node (that is, all the intervals\n   within the tree\
    \ node) responsible for interval I(l,k).  In contrast,\n   I(l,k) refers to a\
    \ specific interval within a tree node.\n"
- title: 4.4.  Refreshing Registrations
  contents:
  - "4.4.  Refreshing Registrations\n   All state in the ReDiR tree is soft.  Therefore,\
    \ a service provider\n   needs to periodically repeat the registration process\
    \ to refresh its\n   RedirServiceProvider Resource Record.  If a record expires,\
    \ it MUST\n   be dropped from the dictionary by the peer storing the tree node.\n\
    \   Deciding an appropriate lifetime for the RedirServiceProvider\n   Resource\
    \ Records is up to each service provider.  However, a default\n   value of 10\
    \ minutes is RECOMMENDED as this is a good trade-off\n   between keeping the amount\
    \ of ReDiR traffic in the overlay at a\n   reasonable level and ensuring that\
    \ stale information is removed\n   quickly enough.  Every service provider MUST\
    \ repeat the entire\n   registration process periodically until it leaves the\
    \ RELOAD Overlay\n   Instance.  The service provider SHOULD initiate each refresh\
    \ process\n   slightly earlier (e.g., when 90% of the refresh interval has passed)\n\
    \   than the expiry time of the Resource Record.\n   Note that no new mechanisms\
    \ are needed to keep track of the remaining\n   lifetime of RedirServiceProvider\
    \ records.  The 'storage_time' and\n   'lifetime' fields of RELOAD's StoredData\
    \ structure can be used for\n   this purpose in the usual way.\n"
- title: 4.5.  Service Lookups
  contents:
  - "4.5.  Service Lookups\n   The purpose of a service lookup for identifier k in\
    \ namespace ns is\n   to find the node that is a part of ns and whose identifier\
    \ most\n   immediately follows (i.e., is the closest successor of) the\n   identifier\
    \ k.\n   A service lookup operation resembles the service registration\n   operation\
    \ described in Section 4.3.  Service lookups start from a\n   given starting level\
    \ level=Lstart in the ReDiR tree (see Section 4.2\n   for the details on selecting\
    \ the starting level).  At each step, a\n   node n wishing to discover a service\
    \ provider MUST fetch the tree\n   node responsible for the interval I(level,n.id)\
    \ that encloses the\n   search key n.id at the current level using a RELOAD Fetch\
    \ request.\n   Having fetched the tree node, node n MUST determine the next action\n\
    \   to carry out as follows:\n   Condition 1\n      If there is no successor of\
    \ node n present in the just-fetched\n      ReDiR tree node (note: within the\
    \ entire tree node and not only\n      within the current interval) responsible\
    \ for I(level,n.id), then\n      the successor of node n must be present in a\
    \ larger segment of the\n      identifier space (i.e., further up in the ReDiR\
    \ tree where each\n      interval and tree node covers a larger range of the identifier\n\
    \      space).  Therefore, node n MUST reduce the current level by one to\n  \
    \    level=level-1 and carry out a new Fetch operation for the tree\n      node\
    \ responsible for n.id at that level.  The fetched tree node is\n      then analyzed\
    \ and the next action determined by checking\n      Conditions 1-3.\n   Condition\
    \ 2\n      If n.id is neither the lowest nor the highest Node-ID within the\n\
    \      interval (note: within the interval, not within the entire tree\n     \
    \ node) I(level,n.id), n MUST next check the tree node responsible\n      for\
    \ n.id at the next level down the tree.  Thus, node n MUST\n      increase the\
    \ level by one to level=level+1 and carry out a new\n      Fetch operation at\
    \ that level.  The fetched tree node is then\n      analyzed and the next action\
    \ determined by checking the conditions\n      listed here, starting at Condition\
    \ 1.\n   Condition 3\n      If neither of the conditions above holds, meaning\
    \ that there is a\n      successor s of n.id present in the just-fetched ReDiR\
    \ tree node\n      and n.id is the highest or lowest Node-ID in its interval,\
    \ the\n      service lookup has finished successfully, and s must be the\n   \
    \   closest successor of n.id in the ReDiR tree.\n   Note that above, when we\
    \ refer to 'the tree node responsible for\n   interval I(l,k)', we mean the entire\
    \ tree node (that is, all the\n   intervals within the tree node) responsible\
    \ for interval I(l,k).  In\n   contrast, I(l,k) refers to a specific interval\
    \ within a tree node.\n   Note also that there may be some cases in which no successor\
    \ can be\n   found from the ReDiR tree.  An example is a situation in which all\
    \ of\n   the service providers stored in the ReDiR tree have a Node-ID smaller\n\
    \   than identifier k.  In this case, the upward walk of the service\n   lookup\
    \ will reach the root of the tree without encountering a\n   successor.  An appropriate\
    \ strategy in this case is to pick one of\n   the RedirServiceProvider entries\
    \ stored in the dictionary of the root\n   node at random.\n   Since RedirServiceProvider\
    \ records are expiring and registrations are\n   being refreshed periodically,\
    \ there can be certain rare situations in\n   which a service lookup may fail\
    \ even if there is a valid successor\n   present in the ReDiR tree.  An example\
    \ is a case in which a ReDiR\n   tree node is fetched just after a RedirServiceProvider\
    \ entry of the\n   only successor of k present in the tree node has expired and\
    \ just\n   before a Store request that has been sent to refresh the entry\n  \
    \ reaches the peer storing the tree node.  In this rather unlikely\n   scenario,\
    \ the successor that should have been present in the tree\n   node is temporarily\
    \ missing.  Thus, the service lookup will fail and\n   needs to be carried out\
    \ again.\n   To recover from the kinds of situations described above, a ReDiR\n\
    \   implementation MAY choose to use the optimization described next.\n   The\
    \ ReDiR implementation MAY implement a local temporary cache that\n   is maintained\
    \ for the duration of a service lookup operation in a\n   RELOAD node.  The temporary\
    \ cache is used to store all\n   RedirServiceProvider entries that have been fetched\
    \ during the upward\n   and downward walks of a service lookup operation.  Should\
    \ it happen\n   that a service lookup operation fails due to the downward walk\n\
    \   reaching a level that does not contain a successor, the cache is\n   searched\
    \ for successors of the search key.  If there are successors\n   present in the\
    \ cache, the closest one of them is selected as the\n   service provider.\n"
- title: 4.6.  Removing Registrations
  contents:
  - "4.6.  Removing Registrations\n   Before leaving the RELOAD Overlay Instance,\
    \ a service provider SHOULD\n   remove the RedirServiceProvider records it has\
    \ stored by storing\n   exists=False values in their place, as described in [RFC6940].\n"
- title: 5.  Access Control Rules
  contents:
  - "5.  Access Control Rules\n   As specified in the RELOAD base protocol [RFC6940],\
    \ every Kind that\n   is storable in an overlay must be associated with an access\
    \ control\n   policy.  This policy defines whether a request from a given node\
    \ to\n   operate on a given value should succeed or fail.  Usages can define\n\
    \   any access control rules they choose, including publicly writable\n   values.\n\
    \   ReDiR requires an access control policy that allows multiple nodes in\n  \
    \ the overlay read and write access to the ReDiR tree nodes stored in\n   the\
    \ overlay.  Therefore, none of the access control policies\n   specified in the\
    \ RELOAD base protocol [RFC6940] is sufficient.\n   This document defines a new\
    \ access control policy, called NODE-ID-\n   MATCH.  In this policy, a given value\
    \ MUST be written and overwritten\n   only if the request is signed with a key\
    \ associated with a\n   certificate whose Node-ID is equal to the dictionary key.\
    \  In\n   addition, provided that exists=True, the Node-ID MUST belong to one\n\
    \   of the intervals associated with the tree node (the number of\n   intervals\
    \ each tree node has is determined by the branching-factor\n   parameter).  Finally,\
    \ provided that exists=True,\n   H(namespace,level,node), where namespace, level,\
    \ and node are taken\n   from the RedirServiceProvider structure being stored,\
    \ MUST be equal\n   to the Resource-ID for the resource.  The NODE-ID-MATCH policy\
    \ may\n   only be used with dictionary types.\n"
- title: 6.  REDIR Kind Definition
  contents:
  - "6.  REDIR Kind Definition\n   This section defines the REDIR Kind.\n   Name\n\
    \      REDIR\n   Kind-ID\n      The Resource Name for the REDIR Kind-ID is created\
    \ by\n      concatenating three pieces of information: namespace, level, and\n\
    \      node number.  Namespace is an opaque UTF-8-encoded string\n      identifying\
    \ a service, such as 'turn-server'.  Level is an integer\n      specifying a level\
    \ in the ReDiR tree.  Node number is an integer\n      identifying a ReDiR tree\
    \ node at a specific level.  The data\n      stored is a RedirServiceProvider\
    \ structure, as defined in\n      Section 4.1.\n   Data Model\n      The data\
    \ model for the REDIR Kind-ID is dictionary.  The\n      dictionary key is the\
    \ Node-ID of the service provider.\n   Access Control\n      The access control\
    \ policy for the REDIR Kind is the NODE-ID-MATCH\n      policy that was defined\
    \ in Section 5.\n"
- title: 7.  Examples
  contents:
  - '7.  Examples

    '
- title: 7.1.  Service Registration
  contents:
  - "7.1.  Service Registration\n   Figure 4 shows an example of a ReDiR tree containing\
    \ information\n   about four different service providers whose Node-IDs are 2,\
    \ 3, 4,\n   and 7.  In the example, numBitsInNodeId=4.  Initially, the ReDiR tree\n\
    \   is empty; Figure 4 shows the state of the tree at the point when all\n   the\
    \ service providers have registered.\n     Level 0  ____2_3___4_____7_|__________________\n\
    \                      |                   |\n     Level 1  ____2_3_|_4_____7\
    \   ________|________\n                 |         |         |         |\n    \
    \ Level 2  ___|2_3   4__|__7   ___|___   ___|___\n               |   |     | \
    \  |     |   |     |   |\n     Level 3  _|_ _|3   _|_ _|_   _|_ _|_   _|_ _|_\n\
    \                     Figure 4: Example of a ReDiR Tree\n   First, peer 2 whose\
    \ Node-ID is 2 joins the namespace.  Since this is\n   the first registration\
    \ peer 2 performs, peer 2 sets the starting\n   level Lstart to 2, as was described\
    \ in Section 4.2.  Also, all other\n   peers in this example will start from level\
    \ 2.  First, peer 2 fetches\n   the contents of the tree node associated with\
    \ interval I(2,2) from\n   the RELOAD Overlay Instance.  This tree node is the\
    \ first tree node\n   from the left at level 2 since key 2 is associated with\
    \ the second\n   interval of the first tree node.  Peer 2 also stores its\n  \
    \ RedirServiceProvider record in that tree node.  Since peer 2's Node-\n   ID\
    \ is the only Node-ID stored in the tree node (i.e., peer 2's Node-\n   ID fulfills\
    \ the condition in Section 4.3 that it be the numerically\n   lowest or highest\
    \ among the keys stored in the node), peer 2\n   continues up the tree.  In fact,\
    \ peer 2 continues up in the tree all\n   the way to the root inserting its own\
    \ Node-ID in all levels since the\n   tree is empty (which means that peer 2's\
    \ Node-ID always fulfills the\n   condition that it be the numerically lowest\
    \ or highest Node-ID in the\n   interval I(level, 2) during the upward walk).\
    \  As described in\n   Section 4.3, peer 2 also walks down the tree.  The downward\
    \ walk peer\n   2 does ends at level 2 since peer 2 is the only node in its interval\n\
    \   at that level.\n   The next peer to join the namespace is peer 3, whose Node-ID\
    \ is 3.\n   Peer 3 starts from level 2.  At that level, peer 3 stores its\n  \
    \ RedirServiceProvider entry in the same interval I(2,3) that already\n   contains\
    \ the RedirServiceProvider entry of peer 2.  Interval I(2,3),\n   that is, the\
    \ interval at level 2 enclosing key 3, is associated with\n   the right-hand-side\
    \ interval of the first tree node.  Since peer 3\n   has the numerically highest\
    \ Node-ID in the tree node associated with\n   I(2,3), peer 3 continues up the\
    \ tree.  Peer 3 also stores its\n   RedirServiceProvider record at levels 1 and\
    \ 0 since its Node-ID is\n   numerically highest among the Node-IDs stored in\
    \ the intervals to\n   which its own Node-ID belongs.  Peer 3 also does a downward\
    \ walk that\n   starts from level 2 (i.e., the starting level).  Since peer 3\
    \ is not\n   the only node in interval I(2,3), it continues down the tree to level\n\
    \   3.  The downward walk ends at this level since peer 3 is the only\n   service\
    \ provider in the interval I(3,3).\n   The third peer to join the namespace is\
    \ peer 7, whose Node-ID is 7.\n   Like the two earlier peers, peer 7 also starts\
    \ from level 2 because\n   this is the first registration it performs.  Peer 7\
    \ stores its\n   RedirServiceProvider record at level 2.  At level 1, peer 7 has\
    \ the\n   numerically highest (and lowest) Node-ID in its interval I(1,7)\n  \
    \ (because it is the only node in interval I(1,7); peers 2 and 3 are\n   stored\
    \ in the same tree node but in a different interval), and\n   therefore, it stores\
    \ its Node-ID in the tree node associated with\n   that interval.  Peer 7 also\
    \ has the numerically highest Node-ID in\n   the interval I(0,7) associated with\
    \ its Node-ID at level 0.  Finally,\n   peer 7 performs a downward walk, which\
    \ ends at level 2 because peer 7\n   is the only node in its interval at that\
    \ level.\n   The final peer to join the ReDiR tree is peer 4, whose Node-ID is\
    \ 4.\n   Peer 4 starts by storing its RedirServiceProvider record at level 2.\n\
    \   Since it has the numerically lowest Node-ID in the tree node\n   associated\
    \ with interval I(2,4), it continues up in the tree to level\n   1.  At level\
    \ 1, peer 4 stores its record in the tree node associated\n   with interval I(1,4)\
    \ because it has the numerically lowest Node-ID in\n   that interval.  Next, peer\
    \ 4 continues to the root level, at which it\n   stores its RedirServiceProvider\
    \ record and finishes the upward walk\n   since the root level was reached.  Peer\
    \ 4 also does a downward walk\n   starting from level 2.  The downward walk stops\
    \ at level 2 because\n   peer 4 is the only peer in the interval I(2,4).\n"
- title: 7.2.  Service Lookup
  contents:
  - "7.2.  Service Lookup\n   This subsection gives an example of peer 5 whose Node-ID\
    \ is 5\n   performing a service lookup operation in the ReDiR tree shown in\n\
    \   Figure 4.  This is the first service lookup peer 5 carries out, and\n   thus,\
    \ the service lookup starts from the default starting level 2.\n   As the first\
    \ action, peer 5 fetches the tree node corresponding to\n   the interval I(2,5)\
    \ from the starting level.  This interval maps to\n   the second tree node from\
    \ the left at level 2 since that tree node is\n   responsible for the interval\
    \ (third interval from left) to which\n   Node-ID 5 falls at level 2.  Having\
    \ fetched the tree node, peer 5\n   checks its contents.  First, there is a successor,\
    \ peer 7, present in\n   the tree node.  Therefore, Condition 1 of Section 4.5\
    \ is false, and\n   there is no need to perform an upward walk.  Second, Node-ID\
    \ 5 is the\n   highest Node-ID in its interval, so Condition 2 of Section 4.5\
    \ is\n   also false, and there is no need to perform a downward walk.  Thus,\n\
    \   the service lookup finishes at level 2 since Node-ID 7 is the closest\n  \
    \ successor of peer 5.\n   Note that the service lookup procedure would be slightly\
    \ different if\n   peer 5 used level 3 as the starting level.  Peer 5 might use\
    \ this\n   starting level, for instance, if it has already carried out service\n\
    \   lookups in the past and follows the heuristic in Section 4.2 to\n   select\
    \ the starting level.  In this case, peer 5's first action is to\n   fetch the\
    \ tree node at level 3 that is responsible for I(3,5).  Thus,\n   peer 5 fetches\
    \ the third tree node from the left.  Since this tree\n   node is empty, peer\
    \ 5 decreases the current level by one to 2 and\n   thus continues up in the tree.\
    \  The next action peer 5 performs is\n   identical to the single action in the\
    \ previous example of fetching\n   the node associated with I(2,5) from level\
    \ 2.  Thus, the service\n   lookup finishes at level 2.\n"
- title: 8.  Overlay Configuration Document Extension
  contents:
  - "8.  Overlay Configuration Document Extension\n   This document extends the RELOAD\
    \ overlay configuration document\n   defined in the RELOAD base protocol specification\
    \ [RFC6940] by adding\n   a new element, \"branching-factor\", inside the new\
    \ \"REDIR\" kind\n   element:\n   redir:branching-factor:  The branching factor\
    \ of the ReDiR tree.  The\n      default value is 10.\n   The RELAX NG grammar\
    \ for this element is:\n   namespace redir = \"urn:ietf:params:xml:ns:p2p:redir\"\
    \n   parameter &= element redir:branching-factor { xsd:unsignedInt }?\n   The\
    \ 'redir' namespace is added into the <mandatory-extension> element\n   in the\
    \ overlay configuration file.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This document defines a new access control policy\
    \ called NODE-ID-\n   MATCH (see Section 5) whose purpose is to control which\
    \ nodes in the\n   overlay are allowed read and write access to the ReDiR tree\
    \ nodes.\n   The NODE-ID-MATCH access control policy ensures that the only node\
    \ in\n   the overlay that can store a pointer to a specific service provider\n\
    \   in the ReDiR tree is the service provider itself.  This prevents\n   attacks\
    \ where a malicious node inserts pointers to other nodes in the\n   ReDiR tree.\
    \  Further, the NODE-ID-MATCH access control policy ensures\n   that a node can\
    \ only store information in locations in the ReDiR tree\n   where it is entitled\
    \ to do so.  In other words, a node can only store\n   one RedirServiceProvider\
    \ record at any given level in the ReDiR tree.\n   This prevents an attack where\
    \ a malicious node is trying to insert a\n   high number of pointers to the ReDiR\
    \ tree.\n   When it comes to attacks such as a malicious node refusing to store\
    \ a\n   value or denying knowledge of a value it has previously accepted,\n  \
    \ such security concerns are already discussed in the RELOAD base\n   specification\
    \ [RFC6940].\n"
- title: 10.  IANA Considerations
  contents:
  - '10.  IANA Considerations

    '
- title: 10.1.  Access Control Policies
  contents:
  - "10.1.  Access Control Policies\n   This document adds a new access control policy\
    \ to the \"RELOAD Access\n   Control Policies\" registry:\n      NODE-ID-MATCH\n\
    \   This access control policy was described in Section 5.\n"
- title: 10.2.  A New IETF XML Registry
  contents:
  - "10.2.  A New IETF XML Registry\n   This document registers one new URI for the\
    \ 'redir' namespace in the\n   \"IETF XML Registry\" defined in [RFC3688].\n \
    \  URI: urn:ietf:params:xml:ns:p2p:redir\n   Registrant Contact: The IESG\n  \
    \ XML: N/A, the requested URI is an XML namespace\n"
- title: 10.3.  Data Kind-ID
  contents:
  - "10.3.  Data Kind-ID\n   This document adds one new data Kind-ID to the \"RELOAD\
    \ Data Kind-ID\"\n   registry:\n             +--------------+------------+-----------+\n\
    \             | Kind         |    Kind-ID |    RFC    |\n             +--------------+------------+-----------+\n\
    \             | REDIR        |      0x104 | [RFC7374] |\n             +--------------+------------+-----------+\n\
    \   This Kind-ID was defined in Section 6.\n"
- title: 10.4.  RELOAD Services Registry
  contents:
  - "10.4.  RELOAD Services Registry\n   IANA has created a new registry for ReDiR\
    \ namespaces:\n   Registry Name: RELOAD Services Registry\n   Reference: [RFC7374]\n\
    \   Registration Procedure: Specification Required\n   Entries in this registry\
    \ are strings denoting ReDiR namespace values.\n   The initial contents of this\
    \ registry are:\n             +----------------+-----------+\n             | Namespace\
    \      |     RFC   |\n             +----------------+-----------+\n          \
    \   | turn-server    | [RFC7374] |\n             +----------------+-----------+\n\
    \             | voice-mail     | [RFC7374] |\n             +----------------+-----------+\n\
    \   The namespace 'turn-server' is used by nodes that wish to register as\n  \
    \ providers of a TURN relay service in the RELOAD overlay and by nodes\n   that\
    \ wish to discover providers of a TURN relay service from the\n   RELOAD overlay.\
    \  In the TURN server discovery use case, the ReDiR-\n   based service discovery\
    \ and registration mechanism specified in this\n   document can be used as an\
    \ alternative to the TURN server discovery\n   mechanism specified in the RELOAD\
    \ base specification [RFC6940].  The\n   namespace 'voice-mail' is intended for\
    \ a voice mail service\n   implemented on top of a RELOAD overlay.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3174]\
    \  Eastlake, D. and P. Jones, \"US Secure Hash Algorithm 1\n              (SHA1)\"\
    , RFC 3174, September 2001,\n              <http://www.rfc-editor.org/info/rfc3174>.\n\
    \   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n        \
    \      10646\", STD 63, RFC 3629, November 2003,\n              <http://www.rfc-editor.org/info/rfc3629>.\n\
    \   [RFC3688]  Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n  \
    \            January 2004, <http://www.rfc-editor.org/info/rfc3688>.\n   [RFC6940]\
    \  Jennings, C., Lowekamp, B., Rescorla, E., Baset, S., and\n              H.\
    \ Schulzrinne, \"REsource LOcation And Discovery (RELOAD)\n              Base\
    \ Protocol\", RFC 6940, January 2014,\n              <http://www.rfc-editor.org/info/rfc6940>.\n"
- title: 11.2.  Informative Reference
  contents:
  - "11.2.  Informative Reference\n   [Redir]    Rhea, S., Godfrey, B., Karp, B.,\
    \ Kubiatowicz, J.,\n              Ratnasamy, S., Shenker, S., Stoica, I., and\
    \ H. Yu,\n              \"OpenDHT: A Public DHT Service and Its Uses\", October\n\
    \              2005.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors would like to thank Marc Petit-Huguenin, Joscha\n\
    \   Schneider, Carlos Bernardos, Spencer Dawkins, Barry Leiba, Adrian\n   Farrel,\
    \ Alexey Melnikov, Ted Lemon, and Stephen Farrell for their\n   comments on the\
    \ document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jouni Maenpaa\n   Ericsson\n   Hirsalantie 11\n   Jorvas\
    \  02420\n   Finland\n   EMail: Jouni.Maenpaa@ericsson.com\n   Gonzalo Camarillo\n\
    \   Ericsson\n   Hirsalantie 11\n   Jorvas  02420\n   Finland\n   EMail: Gonzalo.Camarillo@ericsson.com\n"
